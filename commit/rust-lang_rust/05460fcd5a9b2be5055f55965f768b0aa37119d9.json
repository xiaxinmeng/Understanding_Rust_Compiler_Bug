{"sha": "05460fcd5a9b2be5055f55965f768b0aa37119d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NDYwZmNkNWE5YjJiZTUwNTVmNTU5NjVmNzY4YjBhYTM3MTE5ZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-07T00:52:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-07T00:52:52Z"}, "message": "auto merge of #6286 : nikomatsakis/rust/issue-5910-dyna-freeze, r=nikomatsakis\n\nThis rather sprawling branch refactors the borrow checker and much of the region code, addressing a number of outstanding issues. I will close them manually after validating that there are test cases for each one, but here is a (probably partial) list:\r\n\r\n  - #4903: Flow sensitivity\r\n  - #3387: Moves in overloaded operators\r\n  - #3850: Region granularity\r\n  - #4666: Odd loaning errors\r\n  - #6021: borrow check errors with hashmaps\r\n  - #5910: @mut broken\r\n\r\ncc #5047\r\n\r\n(take 5)", "tree": {"sha": "88e3b561606409ab312f933eee2df96a5397e643", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88e3b561606409ab312f933eee2df96a5397e643"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05460fcd5a9b2be5055f55965f768b0aa37119d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05460fcd5a9b2be5055f55965f768b0aa37119d9", "html_url": "https://github.com/rust-lang/rust/commit/05460fcd5a9b2be5055f55965f768b0aa37119d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05460fcd5a9b2be5055f55965f768b0aa37119d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd5fd6e42a904723c99383e684ddeaf02f01d972", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd5fd6e42a904723c99383e684ddeaf02f01d972", "html_url": "https://github.com/rust-lang/rust/commit/bd5fd6e42a904723c99383e684ddeaf02f01d972"}, {"sha": "39a119074aa27234a68bcf57899c8c4e015cd478", "url": "https://api.github.com/repos/rust-lang/rust/commits/39a119074aa27234a68bcf57899c8c4e015cd478", "html_url": "https://github.com/rust-lang/rust/commit/39a119074aa27234a68bcf57899c8c4e015cd478"}], "stats": {"total": 19486, "additions": 14334, "deletions": 5152}, "files": [{"sha": "d531b9879a9a8b4f0b11eedad688e85b70a87efb", "filename": "Makefile.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -110,6 +110,9 @@ endif\n ifdef SAVE_TEMPS\n   CFG_RUSTC_FLAGS += --save-temps\n endif\n+ifdef ASM_COMMENTS\n+  CFG_RUSTC_FLAGS += -z asm-comments\n+endif\n ifdef TIME_PASSES\n   CFG_RUSTC_FLAGS += -Z time-passes\n endif"}, {"sha": "959defeec041392e2e18fd4ca66372eb70f5973d", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -42,7 +42,7 @@ pub fn empty_cell<T>() -> Cell<T> {\n pub impl<T> Cell<T> {\n     /// Yields the value, failing if the cell is empty.\n     fn take(&self) -> T {\n-        let mut self = unsafe { transmute_mut(self) };\n+        let self = unsafe { transmute_mut(self) };\n         if self.is_empty() {\n             fail!(~\"attempt to take an empty cell\");\n         }\n@@ -54,7 +54,7 @@ pub impl<T> Cell<T> {\n \n     /// Returns the value, failing if the cell is full.\n     fn put_back(&self, value: T) {\n-        let mut self = unsafe { transmute_mut(self) };\n+        let self = unsafe { transmute_mut(self) };\n         if !self.is_empty() {\n             fail!(~\"attempt to put a value back into a full cell\");\n         }"}, {"sha": "424cc3483092d0508033a24a33c638581be7d301", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -15,6 +15,7 @@ use ptr::mut_null;\n use repr::BoxRepr;\n use sys::TypeDesc;\n use cast::transmute;\n+#[cfg(notest)] use unstable::lang::clear_task_borrow_list;\n \n #[cfg(notest)] use ptr::to_unsafe_ptr;\n \n@@ -179,6 +180,10 @@ pub unsafe fn annihilate() {\n         n_bytes_freed: 0\n     };\n \n+    // Quick hack: we need to free this list upon task exit, and this\n+    // is a convenient place to do it.\n+    clear_task_borrow_list();\n+\n     // Pass 1: Make all boxes immortal.\n     //\n     // In this pass, nothing gets freed, so it does not matter whether"}, {"sha": "d075ff08bb7eb44d49681b16dd14cf81405dda0d", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -205,8 +205,8 @@ impl<T: Owned> Selectable for Port<T> {\n     fn header(&self) -> *PacketHeader {\n         unsafe {\n             match self.endp {\n-              Some(ref endp) => endp.header(),\n-              None => fail!(~\"peeking empty stream\")\n+                Some(ref endp) => endp.header(),\n+                None => fail!(~\"peeking empty stream\")\n             }\n         }\n     }"}, {"sha": "ba10f97e626c47f124904537fa17a9b537ae9474", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -28,13 +28,13 @@ pub mod rustrt {\n     pub extern {\n         unsafe fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n                                              src_buf_len: size_t,\n-                                             pout_len: *size_t,\n+                                             pout_len: *mut size_t,\n                                              flags: c_int)\n                                           -> *c_void;\n \n         unsafe fn tinfl_decompress_mem_to_heap(psrc_buf: *const c_void,\n                                                src_buf_len: size_t,\n-                                               pout_len: *size_t,\n+                                               pout_len: *mut size_t,\n                                                flags: c_int)\n                                             -> *c_void;\n     }\n@@ -52,11 +52,11 @@ pub fn deflate_bytes(bytes: &const [u8]) -> ~[u8] {\n             let res =\n                 rustrt::tdefl_compress_mem_to_heap(b as *c_void,\n                                                    len as size_t,\n-                                                   &outsz,\n+                                                   &mut outsz,\n                                                    lz_norm);\n             assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n-                                            outsz as uint);\n+                                             outsz as uint);\n             libc::free(res);\n             out\n         }\n@@ -66,11 +66,11 @@ pub fn deflate_bytes(bytes: &const [u8]) -> ~[u8] {\n pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n     do vec::as_const_buf(bytes) |b, len| {\n         unsafe {\n-            let outsz : size_t = 0;\n+            let mut outsz : size_t = 0;\n             let res =\n                 rustrt::tinfl_decompress_mem_to_heap(b as *c_void,\n                                                      len as size_t,\n-                                                     &outsz,\n+                                                     &mut outsz,\n                                                      0);\n             assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,"}, {"sha": "9b01c1dad06e934e51a8b1bdff20d9cfb62dcaca", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -25,6 +25,7 @@ use rand;\n use uint;\n use vec;\n use util::unreachable;\n+use kinds::Copy;\n \n static INITIAL_CAPACITY: uint = 32u; // 2^5\n \n@@ -529,6 +530,18 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n     }\n }\n \n+pub impl<K: Hash + Eq, V: Copy> HashMap<K, V> {\n+    /// Like `find`, but returns a copy of the value.\n+    fn find_copy(&self, k: &K) -> Option<V> {\n+        self.find(k).map_consume(|v| copy *v)\n+    }\n+\n+    /// Like `get`, but returns a copy of the value.\n+    fn get_copy(&self, k: &K) -> V {\n+        copy *self.get(k)\n+    }\n+}\n+\n impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n     fn eq(&self, other: &HashMap<K, V>) -> bool {\n         if self.len() != other.len() { return false; }"}, {"sha": "460fd60d4c56b4faacfac6b3ac2a27e6e60fc150", "filename": "src/libcore/io.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -1022,7 +1022,7 @@ pub enum WriterType { Screen, File }\n pub trait Writer {\n \n     /// Write all of the given bytes.\n-    fn write(&self, v: &const [u8]);\n+    fn write(&self, v: &[u8]);\n \n     /// Move the current position within the stream. The second parameter\n     /// determines the position that the first parameter is relative to.\n@@ -1039,23 +1039,23 @@ pub trait Writer {\n }\n \n impl Writer for @Writer {\n-    fn write(&self, v: &const [u8]) { self.write(v) }\n+    fn write(&self, v: &[u8]) { self.write(v) }\n     fn seek(&self, a: int, b: SeekStyle) { self.seek(a, b) }\n     fn tell(&self) -> uint { self.tell() }\n     fn flush(&self) -> int { self.flush() }\n     fn get_type(&self) -> WriterType { self.get_type() }\n }\n \n impl<W:Writer,C> Writer for Wrapper<W, C> {\n-    fn write(&self, bs: &const [u8]) { self.base.write(bs); }\n+    fn write(&self, bs: &[u8]) { self.base.write(bs); }\n     fn seek(&self, off: int, style: SeekStyle) { self.base.seek(off, style); }\n     fn tell(&self) -> uint { self.base.tell() }\n     fn flush(&self) -> int { self.base.flush() }\n     fn get_type(&self) -> WriterType { File }\n }\n \n impl Writer for *libc::FILE {\n-    fn write(&self, v: &const [u8]) {\n+    fn write(&self, v: &[u8]) {\n         unsafe {\n             do vec::as_const_buf(v) |vbuf, len| {\n                 let nout = libc::fwrite(vbuf as *c_void,\n@@ -1105,7 +1105,7 @@ pub fn FILE_writer(f: *libc::FILE, cleanup: bool) -> @Writer {\n }\n \n impl Writer for fd_t {\n-    fn write(&self, v: &const [u8]) {\n+    fn write(&self, v: &[u8]) {\n         unsafe {\n             let mut count = 0u;\n             do vec::as_const_buf(v) |vbuf, len| {\n@@ -1262,7 +1262,7 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n     }\n }\n \n-pub fn u64_from_be_bytes(data: &const [u8],\n+pub fn u64_from_be_bytes(data: &[u8],\n                          start: uint,\n                          size: uint)\n                       -> u64 {\n@@ -1497,7 +1497,7 @@ pub struct BytesWriter {\n }\n \n impl Writer for BytesWriter {\n-    fn write(&self, v: &const [u8]) {\n+    fn write(&self, v: &[u8]) {\n         let v_len = v.len();\n         let bytes_len = vec::uniq_len(&const self.bytes);\n "}, {"sha": "6fb4572913d2e7cc6c5f752a32deb0ae295c8490", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -268,8 +268,7 @@ pub mod types {\n                 pub type ssize_t = i32;\n             }\n             pub mod posix01 {\n-                use libc::types::os::arch::c95::{c_int, c_short, c_long,\n-                                                 time_t};\n+                use libc::types::os::arch::c95::{c_short, c_long, time_t};\n                 use libc::types::os::arch::posix88::{dev_t, gid_t, ino_t};\n                 use libc::types::os::arch::posix88::{mode_t, off_t};\n                 use libc::types::os::arch::posix88::{uid_t};"}, {"sha": "42c77a687e5fd131255ef081054c616b684c3cc8", "filename": "src/libcore/os.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -352,13 +352,13 @@ pub fn fsync_fd(fd: c_int, _l: io::fsync::Level) -> c_int {\n     }\n }\n \n-pub struct Pipe { mut in: c_int, mut out: c_int }\n+pub struct Pipe { in: c_int, out: c_int }\n \n #[cfg(unix)]\n pub fn pipe() -> Pipe {\n     unsafe {\n         let mut fds = Pipe {in: 0 as c_int,\n-                        out: 0 as c_int };\n+                            out: 0 as c_int };\n         assert!((libc::pipe(&mut fds.in) == (0 as c_int)));\n         return Pipe {in: fds.in, out: fds.out};\n     }\n@@ -1025,10 +1025,10 @@ pub fn last_os_error() -> ~str {\n         #[cfg(target_os = \"macos\")]\n         #[cfg(target_os = \"android\")]\n         #[cfg(target_os = \"freebsd\")]\n-        fn strerror_r(errnum: c_int, buf: *c_char, buflen: size_t) -> c_int {\n+        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t) -> c_int {\n             #[nolink]\n             extern {\n-                unsafe fn strerror_r(errnum: c_int, buf: *c_char,\n+                unsafe fn strerror_r(errnum: c_int, buf: *mut c_char,\n                                      buflen: size_t) -> c_int;\n             }\n             unsafe {\n@@ -1040,10 +1040,10 @@ pub fn last_os_error() -> ~str {\n         // and requires macros to instead use the POSIX compliant variant.\n         // So we just use __xpg_strerror_r which is always POSIX compliant\n         #[cfg(target_os = \"linux\")]\n-        fn strerror_r(errnum: c_int, buf: *c_char, buflen: size_t) -> c_int {\n+        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t) -> c_int {\n             #[nolink]\n             extern {\n-                unsafe fn __xpg_strerror_r(errnum: c_int, buf: *c_char,\n+                unsafe fn __xpg_strerror_r(errnum: c_int, buf: *mut c_char,\n                                            buflen: size_t) -> c_int;\n             }\n             unsafe {\n@@ -1053,7 +1053,7 @@ pub fn last_os_error() -> ~str {\n \n         let mut buf = [0 as c_char, ..TMPBUF_SZ];\n         unsafe {\n-            let err = strerror_r(errno() as c_int, &buf[0],\n+            let err = strerror_r(errno() as c_int, &mut buf[0],\n                                  TMPBUF_SZ as size_t);\n             if err < 0 {\n                 fail!(~\"strerror_r failure\");"}, {"sha": "85e46a0feff6b4006be4decab64bb076cf9973d5", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -296,34 +296,34 @@ impl<T> Ord for *const T {\n \n // Equality for region pointers\n #[cfg(notest)]\n-impl<'self,T:Eq> Eq for &'self const T {\n+impl<'self,T:Eq> Eq for &'self T {\n     #[inline(always)]\n-    fn eq(&self, other: & &'self const T) -> bool {\n+    fn eq(&self, other: & &'self T) -> bool {\n         return *(*self) == *(*other);\n     }\n     #[inline(always)]\n-    fn ne(&self, other: & &'self const T) -> bool {\n+    fn ne(&self, other: & &'self T) -> bool {\n         return *(*self) != *(*other);\n     }\n }\n \n // Comparison for region pointers\n #[cfg(notest)]\n-impl<'self,T:Ord> Ord for &'self const T {\n+impl<'self,T:Ord> Ord for &'self T {\n     #[inline(always)]\n-    fn lt(&self, other: & &'self const T) -> bool {\n+    fn lt(&self, other: & &'self T) -> bool {\n         *(*self) < *(*other)\n     }\n     #[inline(always)]\n-    fn le(&self, other: & &'self const T) -> bool {\n+    fn le(&self, other: & &'self T) -> bool {\n         *(*self) <= *(*other)\n     }\n     #[inline(always)]\n-    fn ge(&self, other: & &'self const T) -> bool {\n+    fn ge(&self, other: & &'self T) -> bool {\n         *(*self) >= *(*other)\n     }\n     #[inline(always)]\n-    fn gt(&self, other: & &'self const T) -> bool {\n+    fn gt(&self, other: & &'self T) -> bool {\n         *(*self) > *(*other)\n     }\n }"}, {"sha": "1d7ff17314901bf50093e8cdeecef254c22a3017", "filename": "src/libcore/rt/env.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fenv.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -31,8 +31,10 @@ pub struct Environment {\n     argc: c_int,\n     /// The argv value passed to main\n     argv: **c_char,\n-    /// Print GC debugging info\n-    debug_mem: bool\n+    /// Print GC debugging info (true if env var RUST_DEBUG_MEM is set)\n+    debug_mem: bool,\n+    /// Print GC debugging info (true if env var RUST_DEBUG_BORROW is set)\n+    debug_borrow: bool,\n }\n \n /// Get the global environment settings"}, {"sha": "663fe3e62d0106f7a93a003981300d2536bfdf47", "filename": "src/libcore/rt/sched/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -137,7 +137,6 @@ pub impl Scheduler {\n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n     fn terminate_current_task(~self) {\n-        let mut self = self;\n         assert!(self.in_task_context());\n \n         rtdebug!(\"ending running task\");\n@@ -153,7 +152,6 @@ pub impl Scheduler {\n     }\n \n     fn schedule_new_task(~self, task: ~Task) {\n-        let mut self = self;\n         assert!(self.in_task_context());\n \n         do self.switch_running_tasks_and_then(task) |last_task| {\n@@ -305,7 +303,7 @@ pub impl Scheduler {\n         unsafe {\n             let last_task = transmute::<Option<&Task>, Option<&mut Task>>(last_task);\n             let last_task_context = match last_task {\n-                Some(ref t) => Some(&mut t.saved_context), None => None\n+                Some(t) => Some(&mut t.saved_context), None => None\n             };\n             let next_task_context = match self.current_task {\n                 Some(ref mut t) => Some(&mut t.saved_context), None => None"}, {"sha": "a41c99b266b11b8381f3fa9f454d568df8ad8ec4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -2472,9 +2472,6 @@ pub trait StrSlice<'self> {\n     fn any(&self, it: &fn(char) -> bool) -> bool;\n     fn contains<'a>(&self, needle: &'a str) -> bool;\n     fn contains_char(&self, needle: char) -> bool;\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn char_iter(&self) -> StrCharIterator<'self>;\n     fn each(&self, it: &fn(u8) -> bool);\n     fn eachi(&self, it: &fn(uint, u8) -> bool);\n@@ -2536,9 +2533,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         contains_char(*self, needle)\n     }\n \n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline]\n     fn char_iter(&self) -> StrCharIterator<'self> {\n         StrCharIterator {\n@@ -2732,17 +2726,11 @@ impl Clone for ~str {\n     }\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub struct StrCharIterator<'self> {\n     priv index: uint,\n     priv string: &'self str,\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<'self> Iterator<char> for StrCharIterator<'self> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {"}, {"sha": "9e4da7ab48868a96ea998477597f479fccb3d42b", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -19,7 +19,7 @@ use io::Writer;\n use option::{None, Option, Some};\n use str;\n \n-pub type Cb<'self> = &'self fn(buf: &const [u8]) -> bool;\n+pub type Cb<'self> = &'self fn(buf: &[u8]) -> bool;\n \n /**\n  * A trait to implement in order to make a type hashable;"}, {"sha": "258da9ff38310082b8ce410b121903445d6bc8b3", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -501,7 +501,7 @@ pub mod rt {\n     pub fn conv_int(cv: Conv, i: int, buf: &mut ~str) {\n         let radix = 10;\n         let prec = get_int_precision(cv);\n-        let mut s : ~str = uint_to_str_prec(int::abs(i) as uint, radix, prec);\n+        let s : ~str = uint_to_str_prec(int::abs(i) as uint, radix, prec);\n \n         let head = if i >= 0 {\n             if have_flag(cv.flags, flag_sign_always) {\n@@ -516,7 +516,7 @@ pub mod rt {\n     }\n     pub fn conv_uint(cv: Conv, u: uint, buf: &mut ~str) {\n         let prec = get_int_precision(cv);\n-        let mut rs =\n+        let rs =\n             match cv.ty {\n               TyDefault => uint_to_str_prec(u, 10, prec),\n               TyHexLower => uint_to_str_prec(u, 16, prec),\n@@ -559,7 +559,7 @@ pub mod rt {\n               CountIs(c) => (float::to_str_exact, c as uint),\n               CountImplied => (float::to_str_digits, 6u)\n         };\n-        let mut s = to_str(f, digits);\n+        let s = to_str(f, digits);\n         let head = if 0.0 <= f {\n             if have_flag(cv.flags, flag_sign_always) {\n                 Some('+')"}, {"sha": "8153c2d43d99819b9411e99409e988d43ad8c506", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 279, "deletions": 13, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -10,26 +10,29 @@\n \n //! Runtime calls emitted by the compiler.\n \n+use uint;\n use cast::transmute;\n-use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int};\n+use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int, STDERR_FILENO};\n use managed::raw::BoxRepr;\n use str;\n use sys;\n use unstable::exchange_alloc;\n use cast::transmute;\n use rt::{context, OldTaskContext};\n use rt::local_services::borrow_local_services;\n+use option::{Option, Some, None};\n+use io;\n \n #[allow(non_camel_case_types)]\n pub type rust_task = c_void;\n \n-#[cfg(target_word_size = \"32\")]\n-pub static FROZEN_BIT: uint = 0x80000000;\n-#[cfg(target_word_size = \"64\")]\n-pub static FROZEN_BIT: uint = 0x8000000000000000;\n+pub static FROZEN_BIT: uint = 1 << (uint::bits - 1);\n+pub static MUT_BIT: uint = 1 << (uint::bits - 2);\n+static ALL_BITS: uint = FROZEN_BIT | MUT_BIT;\n \n pub mod rustrt {\n-    use libc::{c_char, uintptr_t};\n+    use unstable::lang::rust_task;\n+    use libc::{c_void, c_char, uintptr_t};\n \n     pub extern {\n         #[rust_stack]\n@@ -45,6 +48,17 @@ pub mod rustrt {\n \n         #[fast_ffi]\n         unsafe fn rust_upcall_free_noswitch(ptr: *c_char);\n+\n+        #[rust_stack]\n+        fn rust_take_task_borrow_list(task: *rust_task) -> *c_void;\n+\n+        #[rust_stack]\n+        fn rust_set_task_borrow_list(task: *rust_task, map: *c_void);\n+\n+        #[rust_stack]\n+        fn rust_try_get_task() -> *rust_task;\n+\n+        fn rust_dbg_breakpoint();\n     }\n }\n \n@@ -55,19 +69,82 @@ pub fn fail_(expr: *c_char, file: *c_char, line: size_t) -> ! {\n \n #[lang=\"fail_bounds_check\"]\n pub fn fail_bounds_check(file: *c_char, line: size_t,\n-                                index: size_t, len: size_t) {\n+                         index: size_t, len: size_t) {\n     let msg = fmt!(\"index out of bounds: the len is %d but the index is %d\",\n                     len as int, index as int);\n     do str::as_buf(msg) |p, _len| {\n         fail_(p as *c_char, file, line);\n     }\n }\n \n-pub fn fail_borrowed() {\n-    let msg = \"borrowed\";\n-    do str::as_buf(msg) |msg_p, _| {\n-        do str::as_buf(\"???\") |file_p, _| {\n-            fail_(msg_p as *c_char, file_p as *c_char, 0);\n+#[deriving(Eq)]\n+struct BorrowRecord {\n+    box: *mut BoxRepr,\n+    file: *c_char,\n+    line: size_t\n+}\n+\n+fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n+    unsafe {\n+        let cur_task: *rust_task = rustrt::rust_try_get_task();\n+        if cur_task.is_not_null() {\n+            let ptr = rustrt::rust_take_task_borrow_list(cur_task);\n+            if ptr.is_null() {\n+                None\n+            } else {\n+                let v: ~[BorrowRecord] = transmute(ptr);\n+                Some(v)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+fn swap_task_borrow_list(f: &fn(~[BorrowRecord]) -> ~[BorrowRecord]) {\n+    unsafe {\n+        let cur_task: *rust_task = rustrt::rust_try_get_task();\n+        if cur_task.is_not_null() {\n+            let mut borrow_list: ~[BorrowRecord] = {\n+                let ptr = rustrt::rust_take_task_borrow_list(cur_task);\n+                if ptr.is_null() { ~[] } else { transmute(ptr) }\n+            };\n+            borrow_list = f(borrow_list);\n+            rustrt::rust_set_task_borrow_list(cur_task, transmute(borrow_list));\n+        }\n+    }\n+}\n+\n+pub unsafe fn clear_task_borrow_list() {\n+    // pub because it is used by the box annihilator.\n+    let _ = try_take_task_borrow_list();\n+}\n+\n+unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n+    debug_borrow(\"fail_borrowed: \", box, 0, 0, file, line);\n+\n+    match try_take_task_borrow_list() {\n+        None => { // not recording borrows\n+            let msg = \"borrowed\";\n+            do str::as_buf(msg) |msg_p, _| {\n+                fail_(msg_p as *c_char, file, line);\n+            }\n+        }\n+        Some(borrow_list) => { // recording borrows\n+            let mut msg = ~\"borrowed\";\n+            let mut sep = \" at \";\n+            for borrow_list.each_reverse |entry| {\n+                if entry.box == box {\n+                    str::push_str(&mut msg, sep);\n+                    let filename = str::raw::from_c_str(entry.file);\n+                    str::push_str(&mut msg, filename);\n+                    str::push_str(&mut msg, fmt!(\":%u\", entry.line as uint));\n+                    sep = \" and at \";\n+                }\n+            }\n+            do str::as_buf(msg) |msg_p, _| {\n+                fail_(msg_p as *c_char, file, line)\n+            }\n         }\n     }\n }\n@@ -79,6 +156,77 @@ pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     transmute(exchange_alloc::malloc(transmute(td), transmute(size)))\n }\n \n+/// Because this code is so perf. sensitive, use a static constant so that\n+/// debug printouts are compiled out most of the time.\n+static ENABLE_DEBUG: bool = false;\n+\n+#[inline]\n+unsafe fn debug_borrow<T>(tag: &'static str,\n+                          p: *const T,\n+                          old_bits: uint,\n+                          new_bits: uint,\n+                          filename: *c_char,\n+                          line: size_t) {\n+    //! A useful debugging function that prints a pointer + tag + newline\n+    //! without allocating memory.\n+\n+    if ENABLE_DEBUG && ::rt::env::get().debug_borrow {\n+        debug_borrow_slow(tag, p, old_bits, new_bits, filename, line);\n+    }\n+\n+    unsafe fn debug_borrow_slow<T>(tag: &'static str,\n+                                   p: *const T,\n+                                   old_bits: uint,\n+                                   new_bits: uint,\n+                                   filename: *c_char,\n+                                   line: size_t) {\n+        let dbg = STDERR_FILENO as io::fd_t;\n+        dbg.write_str(tag);\n+        dbg.write_hex(p as uint);\n+        dbg.write_str(\" \");\n+        dbg.write_hex(old_bits);\n+        dbg.write_str(\" \");\n+        dbg.write_hex(new_bits);\n+        dbg.write_str(\" \");\n+        dbg.write_cstr(filename);\n+        dbg.write_str(\":\");\n+        dbg.write_hex(line as uint);\n+        dbg.write_str(\"\\n\");\n+    }\n+}\n+\n+trait DebugPrints {\n+    fn write_hex(&self, val: uint);\n+    unsafe fn write_cstr(&self, str: *c_char);\n+}\n+\n+impl DebugPrints for io::fd_t {\n+    fn write_hex(&self, mut i: uint) {\n+        let letters = ['0', '1', '2', '3', '4', '5', '6', '7', '8',\n+                       '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n+        static uint_nibbles: uint = ::uint::bytes << 1;\n+        let mut buffer = [0_u8, ..uint_nibbles+1];\n+        let mut c = uint_nibbles;\n+        while c > 0 {\n+            c -= 1;\n+            buffer[c] = letters[i & 0xF] as u8;\n+            i >>= 4;\n+        }\n+        self.write(buffer.slice(0, uint_nibbles));\n+    }\n+\n+    unsafe fn write_cstr(&self, p: *c_char) {\n+        use libc::strlen;\n+        use vec;\n+\n+        let len = strlen(p);\n+        let p: *u8 = transmute(p);\n+        do vec::raw::buf_as_slice(p, len as uint) |s| {\n+            self.write(s);\n+        }\n+    }\n+}\n+\n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler. If a\n // problem occurs, call exit instead.\n@@ -121,13 +269,94 @@ pub unsafe fn local_free(ptr: *c_char) {\n     }\n }\n \n+#[cfg(stage0)]\n #[lang=\"borrow_as_imm\"]\n #[inline(always)]\n pub unsafe fn borrow_as_imm(a: *u8) {\n     let a: *mut BoxRepr = transmute(a);\n     (*a).header.ref_count |= FROZEN_BIT;\n }\n \n+#[cfg(not(stage0))]\n+#[lang=\"borrow_as_imm\"]\n+#[inline(always)]\n+pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n+    let a: *mut BoxRepr = transmute(a);\n+    let old_ref_count = (*a).header.ref_count;\n+    let new_ref_count = old_ref_count | FROZEN_BIT;\n+\n+    debug_borrow(\"borrow_as_imm:\", a, old_ref_count, new_ref_count, file, line);\n+\n+    if (old_ref_count & MUT_BIT) != 0 {\n+        fail_borrowed(a, file, line);\n+    }\n+\n+    (*a).header.ref_count = new_ref_count;\n+\n+    old_ref_count\n+}\n+\n+#[cfg(not(stage0))]\n+#[lang=\"borrow_as_mut\"]\n+#[inline(always)]\n+pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n+    let a: *mut BoxRepr = transmute(a);\n+    let old_ref_count = (*a).header.ref_count;\n+    let new_ref_count = old_ref_count | MUT_BIT | FROZEN_BIT;\n+\n+    debug_borrow(\"borrow_as_mut:\", a, old_ref_count, new_ref_count, file, line);\n+\n+    if (old_ref_count & (MUT_BIT|FROZEN_BIT)) != 0 {\n+        fail_borrowed(a, file, line);\n+    }\n+\n+    (*a).header.ref_count = new_ref_count;\n+\n+    old_ref_count\n+}\n+\n+\n+#[cfg(not(stage0))]\n+#[lang=\"record_borrow\"]\n+pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n+                            file: *c_char, line: size_t) {\n+    if (old_ref_count & ALL_BITS) == 0 {\n+        // was not borrowed before\n+        let a: *mut BoxRepr = transmute(a);\n+        debug_borrow(\"record_borrow:\", a, old_ref_count, 0, file, line);\n+        do swap_task_borrow_list |borrow_list| {\n+            let mut borrow_list = borrow_list;\n+            borrow_list.push(BorrowRecord {box: a, file: file, line: line});\n+            borrow_list\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+#[lang=\"unrecord_borrow\"]\n+pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n+                              file: *c_char, line: size_t) {\n+    if (old_ref_count & ALL_BITS) == 0 {\n+        // was not borrowed before, so we should find the record at\n+        // the end of the list\n+        let a: *mut BoxRepr = transmute(a);\n+        debug_borrow(\"unrecord_borrow:\", a, old_ref_count, 0, file, line);\n+        do swap_task_borrow_list |borrow_list| {\n+            let mut borrow_list = borrow_list;\n+            assert!(!borrow_list.is_empty());\n+            let br = borrow_list.pop();\n+            if br.box != a || br.file != file || br.line != line {\n+                let err = fmt!(\"wrong borrow found, br=%?\", br);\n+                do str::as_buf(err) |msg_p, _| {\n+                    fail_(msg_p as *c_char, file, line)\n+                }\n+            }\n+            borrow_list\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n #[lang=\"return_to_mut\"]\n #[inline(always)]\n pub unsafe fn return_to_mut(a: *u8) {\n@@ -139,12 +368,49 @@ pub unsafe fn return_to_mut(a: *u8) {\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[lang=\"return_to_mut\"]\n+#[inline(always)]\n+pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n+                            file: *c_char, line: size_t) {\n+    // Sometimes the box is null, if it is conditionally frozen.\n+    // See e.g. #4904.\n+    if !a.is_null() {\n+        let a: *mut BoxRepr = transmute(a);\n+        let old_ref_count = (*a).header.ref_count;\n+        let new_ref_count =\n+            (old_ref_count & !ALL_BITS) | (orig_ref_count & ALL_BITS);\n+\n+        debug_borrow(\"return_to_mut:\",\n+                     a, old_ref_count, new_ref_count, file, line);\n+\n+        (*a).header.ref_count = new_ref_count;\n+    }\n+}\n+\n+#[cfg(stage0)]\n #[lang=\"check_not_borrowed\"]\n #[inline(always)]\n pub unsafe fn check_not_borrowed(a: *u8) {\n     let a: *mut BoxRepr = transmute(a);\n     if ((*a).header.ref_count & FROZEN_BIT) != 0 {\n-        fail_borrowed();\n+        do str::as_buf(\"XXX\") |file_p, _| {\n+            fail_borrowed(a, file_p as *c_char, 0);\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+#[lang=\"check_not_borrowed\"]\n+#[inline(always)]\n+pub unsafe fn check_not_borrowed(a: *u8,\n+                                 file: *c_char,\n+                                 line: size_t) {\n+    let a: *mut BoxRepr = transmute(a);\n+    let ref_count = (*a).header.ref_count;\n+    debug_borrow(\"check_not_borrowed:\", a, ref_count, 0, file, line);\n+    if (ref_count & FROZEN_BIT) != 0 {\n+        fail_borrowed(a, file, line);\n     }\n }\n "}, {"sha": "43616ebfd3032fda9ef5a6668eaaf963063709ab", "filename": "src/libcore/util.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -26,19 +26,20 @@ pub fn ignore<T>(_x: T) { }\n \n /// Sets `*ptr` to `new_value`, invokes `op()`, and then restores the\n /// original value of `*ptr`.\n+///\n+/// NB: This function accepts `@mut T` and not `&mut T` to avoid\n+/// an obvious borrowck hazard. Typically passing in `&mut T` will\n+/// cause borrow check errors because it freezes whatever location\n+/// that `&mut T` is stored in (either statically or dynamically).\n #[inline(always)]\n-pub fn with<T:Copy,R>(\n-    ptr: &mut T,\n-    new_value: T,\n+pub fn with<T,R>(\n+    ptr: @mut T,\n+    mut value: T,\n     op: &fn() -> R) -> R\n {\n-    // NDM: if swap operator were defined somewhat differently,\n-    // we wouldn't need to copy...\n-\n-    let old_value = *ptr;\n-    *ptr = new_value;\n+    value <-> *ptr;\n     let result = op();\n-    *ptr = old_value;\n+    *ptr = value;\n     return result;\n }\n "}, {"sha": "ced3c300a359abf2f50e71c1421dcdea4114f6fd", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -1821,17 +1821,14 @@ pub trait CopyableVector<T> {\n }\n \n /// Extension methods for vectors\n-impl<'self,T:Copy> CopyableVector<T> for &'self const [T] {\n+impl<'self,T:Copy> CopyableVector<T> for &'self [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n         let mut result = ~[];\n-        // FIXME: #4568\n-        unsafe {\n-            reserve(&mut result, self.len());\n-            for self.each |e| {\n-                result.push(copy *e);\n-            }\n+        reserve(&mut result, self.len());\n+        for self.each |e| {\n+            result.push(copy *e);\n         }\n         result\n "}, {"sha": "c34c7fe303ee22fd9b2c16d1f90a940a2719356a", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -788,7 +788,7 @@ pub fn link_binary(sess: Session,\n     };\n \n     debug!(\"output: %s\", output.to_str());\n-    let mut cc_args = link_args(sess, obj_filename, out_filename, lm);\n+    let cc_args = link_args(sess, obj_filename, out_filename, lm);\n     debug!(\"%s link args: %s\", cc_prog, str::connect(cc_args, ~\" \"));\n     // We run 'cc' here\n     let prog = run::program_output(cc_prog, cc_args);"}, {"sha": "5e8dab0f772870431dd86cf2f232da64697d7b83", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -262,38 +262,35 @@ pub fn compile_rest(sess: Session,\n              middle::check_loop::check_crate(ty_cx, crate));\n \n         let middle::moves::MoveMaps {moves_map, variable_moves_map,\n-                                     capture_map} =\n+                                     moved_variables_set, capture_map} =\n             time(time_passes, ~\"compute moves\", ||\n                  middle::moves::compute_moves(ty_cx, method_map, crate));\n \n         time(time_passes, ~\"match checking\", ||\n              middle::check_match::check_crate(ty_cx, method_map,\n                                               moves_map, crate));\n \n-        let last_use_map =\n-            time(time_passes, ~\"liveness checking\", ||\n-                 middle::liveness::check_crate(ty_cx, method_map,\n-                                               variable_moves_map,\n-                                               capture_map, crate));\n+        time(time_passes, ~\"liveness checking\", ||\n+             middle::liveness::check_crate(ty_cx, method_map,\n+                                           variable_moves_map,\n+                                           capture_map, crate));\n \n-        let (root_map, mutbl_map, write_guard_map) =\n+        let (root_map, write_guard_map) =\n             time(time_passes, ~\"borrow checking\", ||\n                  middle::borrowck::check_crate(ty_cx, method_map,\n-                                               moves_map, capture_map,\n-                                               crate));\n+                                               moves_map, moved_variables_set,\n+                                               capture_map, crate));\n \n         time(time_passes, ~\"kind checking\", ||\n-             kind::check_crate(ty_cx, method_map, last_use_map, crate));\n+             kind::check_crate(ty_cx, method_map, crate));\n \n         time(time_passes, ~\"lint checking\", ||\n              lint::check_crate(ty_cx, crate));\n \n         if upto == cu_no_trans { return (crate, Some(ty_cx)); }\n \n         let maps = astencode::Maps {\n-            mutbl_map: mutbl_map,\n             root_map: root_map,\n-            last_use_map: last_use_map,\n             method_map: method_map,\n             vtable_map: vtable_map,\n             write_guard_map: write_guard_map,\n@@ -607,11 +604,6 @@ pub fn build_session_options(binary: @~str,\n     let target_opt = getopts::opt_maybe_str(matches, ~\"target\");\n     let target_feature_opt = getopts::opt_maybe_str(matches, ~\"target-feature\");\n     let save_temps = getopts::opt_present(matches, ~\"save-temps\");\n-    match output_type {\n-      // unless we're emitting huamn-readable assembly, omit comments.\n-      link::output_type_llvm_assembly | link::output_type_assembly => (),\n-      _ => debugging_opts |= session::no_asm_comments\n-    }\n     let opt_level = {\n         if (debugging_opts & session::no_opt) != 0 {\n             No"}, {"sha": "582e1d606bca67960a6d16f65292980b214d4b4e", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -45,7 +45,7 @@ pub static time_passes: uint = 1 << 1;\n pub static count_llvm_insns: uint = 1 << 2;\n pub static time_llvm_passes: uint = 1 << 3;\n pub static trans_stats: uint = 1 << 4;\n-pub static no_asm_comments: uint = 1 << 5;\n+pub static asm_comments: uint = 1 << 5;\n pub static no_verify: uint = 1 << 6;\n pub static trace: uint = 1 << 7;\n pub static coherence: uint = 1 << 8;\n@@ -73,7 +73,7 @@ pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n      (~\"time-llvm-passes\", ~\"measure time of each LLVM pass\",\n       time_llvm_passes),\n      (~\"trans-stats\", ~\"gather trans statistics\", trans_stats),\n-     (~\"no-asm-comments\", ~\"omit comments when using -S\", no_asm_comments),\n+     (~\"asm-comments\", ~\"generate comments into the assembly (may change behavior)\", asm_comments),\n      (~\"no-verify\", ~\"skip LLVM verification\", no_verify),\n      (~\"trace\", ~\"emit trace logs\", trace),\n      (~\"coherence\", ~\"perform coherence checking\", coherence),\n@@ -188,6 +188,9 @@ pub impl Session_ {\n     fn err(@self, msg: &str) {\n         self.span_diagnostic.handler().err(msg)\n     }\n+    fn err_count(@self) -> uint {\n+        self.span_diagnostic.handler().err_count()\n+    }\n     fn has_errors(@self) -> bool {\n         self.span_diagnostic.handler().has_errors()\n     }\n@@ -263,7 +266,7 @@ pub impl Session_ {\n     }\n     fn trans_stats(@self) -> bool { self.debugging_opt(trans_stats) }\n     fn meta_stats(@self) -> bool { self.debugging_opt(meta_stats) }\n-    fn no_asm_comments(@self) -> bool { self.debugging_opt(no_asm_comments) }\n+    fn asm_comments(@self) -> bool { self.debugging_opt(asm_comments) }\n     fn no_verify(@self) -> bool { self.debugging_opt(no_verify) }\n     fn trace(@self) -> bool { self.debugging_opt(trace) }\n     fn coherence(@self) -> bool { self.debugging_opt(coherence) }"}, {"sha": "0646afa1262833ac839f7acbfd4f3a11685b8af0", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -69,7 +69,8 @@ fn generate_test_harness(sess: session::Session,\n         testfns: ~[]\n     };\n \n-    cx.ext_cx.bt_push(ExpandedFrom(CallInfo {\n+    let ext_cx = cx.ext_cx;\n+    ext_cx.bt_push(ExpandedFrom(CallInfo {\n         call_site: dummy_sp(),\n         callee: NameAndSpan {\n             name: ~\"test\",\n@@ -84,7 +85,7 @@ fn generate_test_harness(sess: session::Session,\n \n     let fold = fold::make_fold(precursor);\n     let res = @fold.fold_crate(&*crate);\n-    cx.ext_cx.bt_pop();\n+    ext_cx.bt_pop();\n     return res;\n }\n "}, {"sha": "1e6bb397068446f4d12f5bc9a8899ca0ca41efe9", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -244,8 +244,8 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n     }\n }\n \n-pub fn item_type(_: ast::def_id, item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n-                 -> ty::t {\n+pub fn item_type(_item_id: ast::def_id, item: ebml::Doc,\n+                 tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     doc_type(item, tcx, cdata)\n }\n "}, {"sha": "ccf3ffcdfffcd4b5d2d4a4182884c20ccc1a0c9a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -198,7 +198,7 @@ fn encode_type_param_bounds(ebml_w: &mut writer::Encoder,\n                             ecx: @EncodeContext,\n                             params: &OptVec<TyParam>) {\n     let ty_param_defs =\n-        @params.map_to_vec(|param| *ecx.tcx.ty_param_defs.get(&param.id));\n+        @params.map_to_vec(|param| ecx.tcx.ty_param_defs.get_copy(&param.id));\n     encode_ty_type_param_defs(ebml_w, ecx, ty_param_defs,\n                               tag_items_data_item_ty_param_bounds);\n }\n@@ -288,7 +288,7 @@ fn encode_discriminant(ecx: @EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::to_bytes(**ecx.discrim_symbols.get(&id)));\n+    ebml_w.writer.write(str::to_bytes(*ecx.discrim_symbols.get_copy(&id)));\n     ebml_w.end_tag();\n }\n \n@@ -1036,7 +1036,7 @@ fn encode_info_for_items(ecx: @EncodeContext,\n             let ebml_w = copy *ebml_w;\n             |i, cx, v| {\n                 visit::visit_item(i, cx, v);\n-                match *ecx.tcx.items.get(&i.id) {\n+                match ecx.tcx.items.get_copy(&i.id) {\n                     ast_map::node_item(_, pt) => {\n                         let mut ebml_w = copy ebml_w;\n                         encode_info_for_item(ecx, &mut ebml_w, i, index, *pt);\n@@ -1049,7 +1049,7 @@ fn encode_info_for_items(ecx: @EncodeContext,\n             let ebml_w = copy *ebml_w;\n             |ni, cx, v| {\n                 visit::visit_foreign_item(ni, cx, v);\n-                match *ecx.tcx.items.get(&ni.id) {\n+                match ecx.tcx.items.get_copy(&ni.id) {\n                     ast_map::node_foreign_item(_, abi, _, pt) => {\n                         let mut ebml_w = copy ebml_w;\n                         encode_info_for_foreign_item(ecx,"}, {"sha": "02acafbd980993b6511e6ebb56f6a10ffd06217b", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -245,6 +245,9 @@ fn parse_region(st: @mut PState) -> ty::Region {\n       't' => {\n         ty::re_static\n       }\n+      'e' => {\n+        ty::re_static\n+      }\n       _ => fail!(~\"parse_region: bad input\")\n     }\n }"}, {"sha": "c44a8e74130fdecc966d7b305b7b7419c5e4ac75", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -71,30 +71,29 @@ pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n         w.write_str(result_str);\n       }\n       ac_use_abbrevs(abbrevs) => {\n-        match abbrevs.find(&t) {\n-          Some(a) => { w.write_str(*a.s); return; }\n-          None => {\n-            let pos = w.tell();\n-            enc_sty(w, cx, /*bad*/copy ty::get(t).sty);\n-            let end = w.tell();\n-            let len = end - pos;\n-            fn estimate_sz(u: uint) -> uint {\n-                let mut n = u;\n-                let mut len = 0u;\n-                while n != 0u { len += 1u; n = n >> 4u; }\n-                return len;\n-            }\n-            let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n-            if abbrev_len < len {\n-                // I.e. it's actually an abbreviation.\n-                let s = ~\"#\" + uint::to_str_radix(pos, 16u) + ~\":\" +\n-                    uint::to_str_radix(len, 16u) + ~\"#\";\n-                let a = ty_abbrev { pos: pos, len: len, s: @s };\n-                abbrevs.insert(t, a);\n-            }\n-            return;\n+          match abbrevs.find(&t) {\n+              Some(a) => { w.write_str(*a.s); return; }\n+              None => {}\n           }\n-        }\n+          let pos = w.tell();\n+          enc_sty(w, cx, /*bad*/copy ty::get(t).sty);\n+          let end = w.tell();\n+          let len = end - pos;\n+          fn estimate_sz(u: uint) -> uint {\n+              let mut n = u;\n+              let mut len = 0u;\n+              while n != 0u { len += 1u; n = n >> 4u; }\n+              return len;\n+          }\n+          let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n+          if abbrev_len < len {\n+              // I.e. it's actually an abbreviation.\n+              let s = ~\"#\" + uint::to_str_radix(pos, 16u) + ~\":\" +\n+                  uint::to_str_radix(len, 16u) + ~\"#\";\n+              let a = ty_abbrev { pos: pos, len: len, s: @s };\n+              abbrevs.insert(t, a);\n+          }\n+          return;\n       }\n     }\n }\n@@ -152,6 +151,9 @@ fn enc_region(w: @io::Writer, cx: @ctxt, r: ty::Region) {\n       ty::re_static => {\n         w.write_char('t');\n       }\n+      ty::re_empty => {\n+        w.write_char('e');\n+      }\n       ty::re_infer(_) => {\n         // these should not crop up after typeck\n         cx.diag.handler().bug(~\"Cannot encode region variables\");"}, {"sha": "f3eac7995e8a1444dca0258a2c5f999c04d588c0", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 8, "deletions": 43, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -44,9 +44,7 @@ use writer = std::ebml::writer;\n \n // Auxiliary maps of things to be encoded\n pub struct Maps {\n-    mutbl_map: middle::borrowck::mutbl_map,\n     root_map: middle::borrowck::root_map,\n-    last_use_map: middle::liveness::last_use_map,\n     method_map: middle::typeck::method_map,\n     vtable_map: middle::typeck::vtable_map,\n     write_guard_map: middle::borrowck::write_guard_map,\n@@ -152,7 +150,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n fn reserve_id_range(sess: Session,\n                     from_id_range: ast_util::id_range) -> ast_util::id_range {\n     // Handle the case of an empty range:\n-    if ast_util::empty(from_id_range) { return from_id_range; }\n+    if from_id_range.empty() { return from_id_range; }\n     let cnt = from_id_range.max - from_id_range.min;\n     let to_id_min = sess.parse_sess.next_id;\n     let to_id_max = sess.parse_sess.next_id + cnt;\n@@ -163,7 +161,6 @@ fn reserve_id_range(sess: Session,\n pub impl ExtendedDecodeContext {\n     fn tr_id(&self, id: ast::node_id) -> ast::node_id {\n         /*!\n-         *\n          * Translates an internal id, meaning a node id that is known\n          * to refer to some part of the item currently being inlined,\n          * such as a local variable or argument.  All naked node-ids\n@@ -174,12 +171,11 @@ pub impl ExtendedDecodeContext {\n          */\n \n         // from_id_range should be non-empty\n-        assert!(!ast_util::empty(self.from_id_range));\n+        assert!(!self.from_id_range.empty());\n         (id - self.from_id_range.min + self.to_id_range.min)\n     }\n     fn tr_def_id(&self, did: ast::def_id) -> ast::def_id {\n         /*!\n-         *\n          * Translates an EXTERNAL def-id, converting the crate number\n          * from the one used in the encoded data to the current crate\n          * numbers..  By external, I mean that it be translated to a\n@@ -204,7 +200,6 @@ pub impl ExtendedDecodeContext {\n     }\n     fn tr_intern_def_id(&self, did: ast::def_id) -> ast::def_id {\n         /*!\n-         *\n          * Translates an INTERNAL def-id, meaning a def-id that is\n          * known to refer to some part of the item currently being\n          * inlined.  In that case, we want to convert the def-id to\n@@ -435,11 +430,7 @@ impl tr for ty::AutoAdjustment {\n \n impl tr for ty::AutoRef {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::AutoRef {\n-        ty::AutoRef {\n-            kind: self.kind,\n-            region: self.region.tr(xcx),\n-            mutbl: self.mutbl,\n-        }\n+        self.map_region(|r| r.tr(xcx))\n     }\n }\n \n@@ -448,7 +439,7 @@ impl tr for ty::Region {\n         match *self {\n             ty::re_bound(br) => ty::re_bound(br.tr(xcx)),\n             ty::re_scope(id) => ty::re_scope(xcx.tr_id(id)),\n-            ty::re_static | ty::re_infer(*) => *self,\n+            ty::re_empty | ty::re_static | ty::re_infer(*) => *self,\n             ty::re_free(ref fr) => {\n                 ty::re_free(ty::FreeRegion {scope_id: xcx.tr_id(fr.scope_id),\n                                             bound_region: fr.bound_region.tr(xcx)})\n@@ -724,7 +715,7 @@ trait ebml_writer_helpers {\n     fn emit_arg(&mut self, ecx: @e::EncodeContext, arg: ty::arg);\n     fn emit_ty(&mut self, ecx: @e::EncodeContext, ty: ty::t);\n     fn emit_vstore(&mut self, ecx: @e::EncodeContext, vstore: ty::vstore);\n-    fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: ~[ty::t]);\n+    fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: &[ty::t]);\n     fn emit_type_param_def(&mut self,\n                            ecx: @e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef);\n@@ -752,7 +743,7 @@ impl ebml_writer_helpers for writer::Encoder {\n         }\n     }\n \n-    fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: ~[ty::t]) {\n+    fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: &[ty::t]) {\n         do self.emit_from_vec(tys) |this, ty| {\n             this.emit_ty(ecx, *ty)\n         }\n@@ -859,9 +850,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         do ebml_w.tag(c::tag_table_node_type_subst) |ebml_w| {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                // FIXME(#5562): removing this copy causes a segfault\n-                //               before stage2\n-                ebml_w.emit_tys(ecx, /*bad*/copy **tys)\n+                ebml_w.emit_tys(ecx, **tys)\n             }\n         }\n     }\n@@ -896,23 +885,6 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         }\n     }\n \n-    if maps.mutbl_map.contains(&id) {\n-        do ebml_w.tag(c::tag_table_mutbl) |ebml_w| {\n-            ebml_w.id(id);\n-        }\n-    }\n-\n-    for maps.last_use_map.find(&id).each |&m| {\n-        do ebml_w.tag(c::tag_table_last_use) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                do ebml_w.emit_from_vec(/*bad*/ copy **m) |ebml_w, id| {\n-                    id.encode(ebml_w);\n-                }\n-            }\n-        }\n-    }\n-\n     for maps.method_map.find(&id).each |&mme| {\n         do ebml_w.tag(c::tag_table_method_map) |ebml_w| {\n             ebml_w.id(id);\n@@ -1113,9 +1085,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                 found for id %d (orig %d)\",\n                tag, id, id0);\n \n-        if tag == (c::tag_table_mutbl as uint) {\n-            dcx.maps.mutbl_map.insert(id);\n-        } else if tag == (c::tag_table_moves_map as uint) {\n+        if tag == (c::tag_table_moves_map as uint) {\n             dcx.maps.moves_map.insert(id);\n         } else {\n             let val_doc = entry_doc.get(c::tag_table_val as uint);\n@@ -1144,11 +1114,6 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n             } else if tag == (c::tag_table_param_defs as uint) {\n                 let bounds = val_dsr.read_type_param_def(xcx);\n                 dcx.tcx.ty_param_defs.insert(id, bounds);\n-            } else if tag == (c::tag_table_last_use as uint) {\n-                let ids = val_dsr.read_to_vec(|val_dsr| {\n-                    xcx.tr_id(val_dsr.read_int())\n-                });\n-                dcx.maps.last_use_map.insert(id, @mut ids);\n             } else if tag == (c::tag_table_method_map as uint) {\n                 dcx.maps.method_map.insert(\n                     id,"}, {"sha": "ba719fe34d719a1c2bd24e4acbdf0d6abdf975e9", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 512, "deletions": 554, "changes": 1066, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -18,504 +18,510 @@\n // 4. moves do not affect things loaned out in any way\n \n use middle::moves;\n-use middle::typeck::check::PurityState;\n-use middle::borrowck::{Loan, bckerr, BorrowckCtxt, inherent_mutability};\n-use middle::borrowck::{ReqMaps, root_map_key, save_and_restore_managed};\n-use middle::borrowck::{MoveError, MoveOk, MoveFromIllegalCmt};\n-use middle::borrowck::{MoveWhileBorrowed};\n-use middle::mem_categorization::{cat_arg, cat_comp, cat_deref};\n-use middle::mem_categorization::{cat_local, cat_rvalue, cat_self};\n-use middle::mem_categorization::{cat_special, cmt, gc_ptr, loan_path, lp_arg};\n-use middle::mem_categorization::{lp_comp, lp_deref, lp_local};\n+use middle::borrowck::*;\n+use mc = middle::mem_categorization;\n use middle::ty;\n-use util::ppaux::ty_to_str;\n-\n+use util::ppaux::Repr;\n use core::hashmap::HashSet;\n-use core::util::with;\n-use syntax::ast::m_mutbl;\n+use syntax::ast::{m_mutbl, m_imm, m_const};\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::codemap::span;\n-use syntax::print::pprust;\n use syntax::visit;\n+use syntax::codemap::span;\n \n-struct CheckLoanCtxt {\n+struct CheckLoanCtxt<'self> {\n     bccx: @BorrowckCtxt,\n-    req_maps: ReqMaps,\n-\n-    reported: HashSet<ast::node_id>,\n-\n-    declared_purity: @mut PurityState,\n-    fn_args: @mut @~[ast::node_id]\n-}\n-\n-// if we are enforcing purity, why are we doing so?\n-#[deriving(Eq)]\n-enum purity_cause {\n-    // enforcing purity because fn was declared pure:\n-    pc_pure_fn,\n-\n-    // enforce purity because we need to guarantee the\n-    // validity of some alias; `bckerr` describes the\n-    // reason we needed to enforce purity.\n-    pc_cmt(bckerr)\n-}\n-\n-// if we're not pure, why?\n-#[deriving(Eq)]\n-enum impurity_cause {\n-    // some surrounding block was marked as 'unsafe'\n-    pc_unsafe,\n-\n-    // nothing was unsafe, and nothing was pure\n-    pc_default,\n+    dfcx: &'self LoanDataFlow,\n+    all_loans: &'self [Loan],\n+    reported: @mut HashSet<ast::node_id>,\n }\n \n pub fn check_loans(bccx: @BorrowckCtxt,\n-                   req_maps: ReqMaps,\n-                   crate: @ast::crate) {\n+                   dfcx: &LoanDataFlow,\n+                   all_loans: &[Loan],\n+                   body: &ast::blk) {\n+    debug!(\"check_loans(body id=%?)\", body.node.id);\n+\n     let clcx = @mut CheckLoanCtxt {\n         bccx: bccx,\n-        req_maps: req_maps,\n-        reported: HashSet::new(),\n-        declared_purity: @mut PurityState::function(ast::impure_fn, 0),\n-        fn_args: @mut @~[]\n+        dfcx: dfcx,\n+        all_loans: all_loans,\n+        reported: @mut HashSet::new(),\n     };\n+\n     let vt = visit::mk_vt(@visit::Visitor {visit_expr: check_loans_in_expr,\n                                            visit_local: check_loans_in_local,\n                                            visit_block: check_loans_in_block,\n+                                           visit_pat: check_loans_in_pat,\n                                            visit_fn: check_loans_in_fn,\n                                            .. *visit::default_visitor()});\n-    visit::visit_crate(crate, clcx, vt);\n+    (vt.visit_block)(body, clcx, vt);\n }\n \n-#[deriving(Eq)]\n-enum assignment_type {\n-    at_straight_up,\n-    at_swap\n-}\n-\n-pub impl assignment_type {\n-    fn checked_by_liveness(&self) -> bool {\n-        // the liveness pass guarantees that immutable local variables\n-        // are only assigned once; but it doesn't consider &mut\n-        match *self {\n-          at_straight_up => true,\n-          at_swap => true\n-        }\n-    }\n-    fn ing_form(&self, desc: ~str) -> ~str {\n-        match *self {\n-          at_straight_up => ~\"assigning to \" + desc,\n-          at_swap => ~\"swapping to and from \" + desc\n-        }\n-    }\n+enum MoveError {\n+    MoveOk,\n+    MoveFromIllegalCmt(mc::cmt),\n+    MoveWhileBorrowed(/*loan*/@LoanPath, /*loan*/span)\n }\n \n-pub impl CheckLoanCtxt {\n+pub impl<'self> CheckLoanCtxt<'self> {\n     fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn purity(&mut self, scope_id: ast::node_id)\n-                -> Either<purity_cause, impurity_cause>\n+    fn each_issued_loan(&self,\n+                        scope_id: ast::node_id,\n+                        op: &fn(&Loan) -> bool)\n     {\n-        let default_purity = match self.declared_purity.purity {\n-          // an unsafe declaration overrides all\n-          ast::unsafe_fn => return Right(pc_unsafe),\n-\n-          // otherwise, remember what was declared as the\n-          // default, but we must scan for requirements\n-          // imposed by the borrow check\n-          ast::pure_fn => Left(pc_pure_fn),\n-          ast::extern_fn | ast::impure_fn => Right(pc_default)\n-        };\n-\n-        // scan to see if this scope or any enclosing scope requires\n-        // purity.  if so, that overrides the declaration.\n-\n-        let mut scope_id = scope_id;\n-        loop {\n-            match self.req_maps.pure_map.find(&scope_id) {\n-              None => (),\n-              Some(e) => return Left(pc_cmt(*e))\n-            }\n-\n-            match self.tcx().region_maps.opt_encl_scope(scope_id) {\n-              None => return default_purity,\n-              Some(next_scope_id) => scope_id = next_scope_id\n+        //! Iterates over each loan that that has been issued\n+        //! on entrance to `scope_id`, regardless of whether it is\n+        //! actually *in scope* at that point.  Sometimes loans\n+        //! are issued for future scopes and thus they may have been\n+        //! *issued* but not yet be in effect.\n+\n+        for self.dfcx.each_bit_on_entry(scope_id) |loan_index| {\n+            let loan = &self.all_loans[loan_index];\n+            if !op(loan) {\n+                return;\n             }\n         }\n     }\n \n-    fn walk_loans(&self,\n-                  mut scope_id: ast::node_id,\n-                  f: &fn(v: &Loan) -> bool) {\n-\n-        loop {\n-            for self.req_maps.req_loan_map.find(&scope_id).each |loans| {\n-                for loans.each |loan| {\n-                    if !f(loan) { return; }\n-                }\n-            }\n-\n-            match self.tcx().region_maps.opt_encl_scope(scope_id) {\n-              None => return,\n-              Some(next_scope_id) => scope_id = next_scope_id,\n-            }\n-        }\n-    }\n-\n-    fn walk_loans_of(&mut self,\n-                     scope_id: ast::node_id,\n-                     lp: @loan_path,\n-                     f: &fn(v: &Loan) -> bool) {\n-        for self.walk_loans(scope_id) |loan| {\n-            if loan.lp == lp {\n-                if !f(loan) { return; }\n-            }\n-        }\n-    }\n+    fn each_in_scope_loan(&self,\n+                          scope_id: ast::node_id,\n+                          op: &fn(&Loan) -> bool)\n+    {\n+        //! Like `each_issued_loan()`, but only considers loans that are\n+        //! currently in scope.\n \n-    // when we are in a pure context, we check each call to ensure\n-    // that the function which is invoked is itself pure.\n-    //\n-    // note: we take opt_expr and expr_id separately because for\n-    // overloaded operators the callee has an id but no expr.\n-    // annoying.\n-    fn check_pure_callee_or_arg(&mut self,\n-                                pc: Either<purity_cause, impurity_cause>,\n-                                opt_expr: Option<@ast::expr>,\n-                                callee_id: ast::node_id,\n-                                callee_span: span) {\n-        let tcx = self.tcx();\n-\n-        debug!(\"check_pure_callee_or_arg(pc=%?, expr=%?, \\\n-                callee_id=%d, ty=%s)\",\n-               pc,\n-               opt_expr.map(|e| pprust::expr_to_str(*e, tcx.sess.intr()) ),\n-               callee_id,\n-               ty_to_str(self.tcx(), ty::node_id_to_type(tcx, callee_id)));\n-\n-        // Purity rules: an expr B is a legal callee or argument to a\n-        // call within a pure function A if at least one of the\n-        // following holds:\n-        //\n-        // (a) A was declared pure and B is one of its arguments;\n-        // (b) B is a stack closure;\n-        // (c) B is a pure fn;\n-        // (d) B is not a fn.\n-\n-        match opt_expr {\n-          Some(expr) => {\n-            match expr.node {\n-              ast::expr_path(_) if pc == Left(pc_pure_fn) => {\n-                let def = *self.tcx().def_map.get(&expr.id);\n-                let did = ast_util::def_id_of_def(def);\n-                let is_fn_arg =\n-                    did.crate == ast::local_crate &&\n-                    (*self.fn_args).contains(&(did.node));\n-                if is_fn_arg { return; } // case (a) above\n-              }\n-              ast::expr_fn_block(*) | ast::expr_loop_body(*) |\n-              ast::expr_do_body(*) => {\n-                if self.is_stack_closure(expr.id) {\n-                    // case (b) above\n+        let region_maps = self.tcx().region_maps;\n+        for self.each_issued_loan(scope_id) |loan| {\n+            if region_maps.is_subscope_of(scope_id, loan.kill_scope) {\n+                if !op(loan) {\n                     return;\n                 }\n-              }\n-              _ => ()\n             }\n-          }\n-          None => ()\n         }\n+    }\n \n-        let callee_ty = ty::node_id_to_type(tcx, callee_id);\n-        match ty::get(callee_ty).sty {\n-            ty::ty_bare_fn(ty::BareFnTy {purity: purity, _}) |\n-            ty::ty_closure(ty::ClosureTy {purity: purity, _}) => {\n-                match purity {\n-                    ast::pure_fn => return, // case (c) above\n-                    ast::impure_fn | ast::unsafe_fn | ast::extern_fn => {\n-                        self.report_purity_error(\n-                            pc, callee_span,\n-                            fmt!(\"access to %s function\",\n-                                 purity.to_str()));\n+    fn each_in_scope_restriction(&self,\n+                                 scope_id: ast::node_id,\n+                                 loan_path: @LoanPath,\n+                                 op: &fn(&Loan, &Restriction) -> bool)\n+    {\n+        //! Iterates through all the in-scope restrictions for the\n+        //! given `loan_path`\n+\n+        for self.each_in_scope_loan(scope_id) |loan| {\n+            for loan.restrictions.each |restr| {\n+                if restr.loan_path == loan_path {\n+                    if !op(loan, restr) {\n+                        return;\n                     }\n                 }\n             }\n-            _ => return, // case (d) above\n         }\n     }\n \n-    // True if the expression with the given `id` is a stack closure.\n-    // The expression must be an expr_fn_block(*)\n-    fn is_stack_closure(&mut self, id: ast::node_id) -> bool {\n-        let fn_ty = ty::node_id_to_type(self.tcx(), id);\n-        match ty::get(fn_ty).sty {\n-            ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n-                                          _}) => true,\n-            _ => false\n-        }\n-    }\n+    fn loans_generated_by(&self, scope_id: ast::node_id) -> ~[uint] {\n+        //! Returns a vector of the loans that are generated as\n+        //! we encounter `scope_id`.\n \n-    fn is_allowed_pure_arg(&mut self, expr: @ast::expr) -> bool {\n-        return match expr.node {\n-          ast::expr_path(_) => {\n-            let def = *self.tcx().def_map.get(&expr.id);\n-            let did = ast_util::def_id_of_def(def);\n-            did.crate == ast::local_crate &&\n-                (*self.fn_args).contains(&(did.node))\n-          }\n-          ast::expr_fn_block(*) => self.is_stack_closure(expr.id),\n-          _ => false,\n-        };\n+        let mut result = ~[];\n+        for self.dfcx.each_gen_bit(scope_id) |loan_index| {\n+            result.push(loan_index);\n+        }\n+        return result;\n     }\n \n     fn check_for_conflicting_loans(&mut self, scope_id: ast::node_id) {\n-        debug!(\"check_for_conflicting_loans(scope_id=%?)\", scope_id);\n-\n-        let new_loans = match self.req_maps.req_loan_map.find(&scope_id) {\n-            None => return,\n-            Some(&loans) => loans\n-        };\n-        let new_loans: &mut ~[Loan] = new_loans;\n+        //! Checks to see whether any of the loans that are issued\n+        //! by `scope_id` conflict with loans that have already been\n+        //! issued when we enter `scope_id` (for example, we do not\n+        //! permit two `&mut` borrows of the same variable).\n \n-        debug!(\"new_loans has length %?\", new_loans.len());\n+        debug!(\"check_for_conflicting_loans(scope_id=%?)\", scope_id);\n \n-        let par_scope_id = self.tcx().region_maps.encl_scope(scope_id);\n-        for self.walk_loans(par_scope_id) |old_loan| {\n-            debug!(\"old_loan=%?\", self.bccx.loan_to_repr(old_loan));\n+        let new_loan_indices = self.loans_generated_by(scope_id);\n+        debug!(\"new_loan_indices = %?\", new_loan_indices);\n \n-            for new_loans.each |new_loan| {\n-                self.report_error_if_loans_conflict(old_loan, new_loan);\n+        for self.each_issued_loan(scope_id) |issued_loan| {\n+            for new_loan_indices.each |&new_loan_index| {\n+                let new_loan = &self.all_loans[new_loan_index];\n+                self.report_error_if_loans_conflict(issued_loan, new_loan);\n             }\n         }\n \n-        let len = new_loans.len();\n-        for uint::range(0, len) |i| {\n-            let loan_i = new_loans[i];\n-            for uint::range(i+1, len) |j| {\n-                let loan_j = new_loans[j];\n-                self.report_error_if_loans_conflict(&loan_i, &loan_j);\n+        for uint::range(0, new_loan_indices.len()) |i| {\n+            let old_loan = &self.all_loans[new_loan_indices[i]];\n+            for uint::range(i+1, new_loan_indices.len()) |j| {\n+                let new_loan = &self.all_loans[new_loan_indices[j]];\n+                self.report_error_if_loans_conflict(old_loan, new_loan);\n             }\n         }\n     }\n \n     fn report_error_if_loans_conflict(&self,\n                                       old_loan: &Loan,\n                                       new_loan: &Loan) {\n-        if old_loan.lp != new_loan.lp {\n-            return;\n-        }\n+        //! Checks whether `old_loan` and `new_loan` can safely be issued\n+        //! simultaneously.\n+\n+        debug!(\"report_error_if_loans_conflict(old_loan=%s, new_loan=%s)\",\n+               old_loan.repr(self.tcx()),\n+               new_loan.repr(self.tcx()));\n+\n+        // Should only be called for loans that are in scope at the same time.\n+        let region_maps = self.tcx().region_maps;\n+        assert!(region_maps.scopes_intersect(old_loan.kill_scope,\n+                                             new_loan.kill_scope));\n+\n+        self.report_error_if_loan_conflicts_with_restriction(\n+            old_loan, new_loan, old_loan, new_loan) &&\n+        self.report_error_if_loan_conflicts_with_restriction(\n+            new_loan, old_loan, old_loan, new_loan);\n+    }\n \n-        match (old_loan.kind, new_loan.kind) {\n-            (PartialFreeze, PartialTake) | (PartialTake, PartialFreeze) |\n-            (TotalFreeze, PartialFreeze) | (PartialFreeze, TotalFreeze) |\n-            (Immobile, _) | (_, Immobile) |\n-            (PartialFreeze, PartialFreeze) |\n-            (PartialTake, PartialTake) |\n-            (TotalFreeze, TotalFreeze) => {\n-                /* ok */\n-            }\n+    fn report_error_if_loan_conflicts_with_restriction(&self,\n+                                                       loan1: &Loan,\n+                                                       loan2: &Loan,\n+                                                       old_loan: &Loan,\n+                                                       new_loan: &Loan) -> bool {\n+        //! Checks whether the restrictions introduced by `loan1` would\n+        //! prohibit `loan2`. Returns false if an error is reported.\n+\n+        debug!(\"report_error_if_loan_conflicts_with_restriction(\\\n+                loan1=%s, loan2=%s)\",\n+               loan1.repr(self.tcx()),\n+               loan2.repr(self.tcx()));\n+\n+        // Restrictions that would cause the new loan to be immutable:\n+        let illegal_if = match loan2.mutbl {\n+            m_mutbl => RESTR_ALIAS | RESTR_FREEZE | RESTR_MUTATE,\n+            m_imm =>   RESTR_ALIAS | RESTR_FREEZE,\n+            m_const => RESTR_ALIAS,\n+        };\n+        debug!(\"illegal_if=%?\", illegal_if);\n \n-            (PartialTake, TotalFreeze) | (TotalFreeze, PartialTake) |\n-            (TotalTake, TotalFreeze) | (TotalFreeze, TotalTake) |\n-            (TotalTake, PartialFreeze) | (PartialFreeze, TotalTake) |\n-            (TotalTake, PartialTake) | (PartialTake, TotalTake) |\n-            (TotalTake, TotalTake) => {\n-                self.bccx.span_err(\n-                    new_loan.cmt.span,\n-                    fmt!(\"loan of %s as %s \\\n-                          conflicts with prior loan\",\n-                         self.bccx.cmt_to_str(new_loan.cmt),\n-                         self.bccx.loan_kind_to_str(new_loan.kind)));\n-                self.bccx.span_note(\n-                    old_loan.cmt.span,\n-                    fmt!(\"prior loan as %s granted here\",\n-                         self.bccx.loan_kind_to_str(old_loan.kind)));\n+        for loan1.restrictions.each |restr| {\n+            if !restr.set.intersects(illegal_if) { loop; }\n+            if restr.loan_path != loan2.loan_path { loop; }\n+\n+            match (new_loan.mutbl, old_loan.mutbl) {\n+                (m_mutbl, m_mutbl) => {\n+                    self.bccx.span_err(\n+                        new_loan.span,\n+                        fmt!(\"cannot borrow `%s` as mutable \\\n+                              more than once at at a time\",\n+                             self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                    self.bccx.span_note(\n+                        old_loan.span,\n+                        fmt!(\"second borrow of `%s` as mutable occurs here\",\n+                             self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                    return false;\n+                }\n+\n+                _ => {\n+                    self.bccx.span_err(\n+                        new_loan.span,\n+                        fmt!(\"cannot borrow `%s` as %s because \\\n+                              it is also borrowed as %s\"\n+                             self.bccx.loan_path_to_str(new_loan.loan_path),\n+                             self.bccx.mut_to_str(new_loan.mutbl),\n+                             self.bccx.mut_to_str(old_loan.mutbl)));\n+                    self.bccx.span_note(\n+                        old_loan.span,\n+                        fmt!(\"second borrow of `%s` occurs here\",\n+                             self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                    return false;\n+                }\n             }\n         }\n+\n+        true\n     }\n \n-    fn is_local_variable(&self, cmt: cmt) -> bool {\n+    fn is_local_variable(&self, cmt: mc::cmt) -> bool {\n         match cmt.cat {\n-          cat_local(_) => true,\n+          mc::cat_local(_) => true,\n           _ => false\n         }\n     }\n \n-    fn check_assignment(&mut self, at: assignment_type, ex: @ast::expr) {\n+    fn check_assignment(&self, expr: @ast::expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n-        let cmt = match self.bccx.tcx.adjustments.find(&ex.id) {\n-            None => self.bccx.cat_expr_unadjusted(ex),\n-            Some(&adj) => self.bccx.cat_expr_autoderefd(ex, adj)\n+        let cmt = match self.bccx.tcx.adjustments.find(&expr.id) {\n+            None => self.bccx.cat_expr_unadjusted(expr),\n+            Some(&adj) => self.bccx.cat_expr_autoderefd(expr, adj)\n         };\n \n-        debug!(\"check_assignment(cmt=%s)\",\n-               self.bccx.cmt_to_repr(cmt));\n-\n-        if self.is_local_variable(cmt) && at.checked_by_liveness() {\n-            // liveness guarantees that immutable local variables\n-            // are only assigned once\n-        } else {\n-            match cmt.mutbl {\n-                McDeclared | McInherited => {\n-                    // Ok, but if this loan is a mutable loan, then mark the\n-                    // loan path (if it exists) as being used. This is similar\n-                    // to the check performed in loan.rs in issue_loan(). This\n-                    // type of use of mutable is different from issuing a loan,\n-                    // however.\n-                    for cmt.lp.each |lp| {\n-                        for lp.node_id().each |&id| {\n-                            self.tcx().used_mut_nodes.insert(id);\n-                        }\n+        debug!(\"check_assignment(cmt=%s)\", cmt.repr(self.tcx()));\n+\n+        // check that the value being assigned is declared as mutable\n+        // and report an error otherwise.\n+        match cmt.mutbl {\n+            mc::McDeclared => {\n+                // OK, but we have to mark arguments as requiring mut\n+                // if they are assigned (other cases are handled by liveness,\n+                // since we need to distinguish local variables assigned\n+                // once vs those assigned multiple times)\n+                match cmt.cat {\n+                    mc::cat_self(*) |\n+                    mc::cat_arg(*) => {\n+                        mark_variable_as_used_mut(self, cmt);\n                     }\n+                    _ => {}\n                 }\n-                McReadOnly | McImmutable => {\n+            }\n+            mc::McInherited => {\n+                // OK, but we may have to add an entry to `used_mut_nodes`\n+                mark_variable_as_used_mut(self, cmt);\n+            }\n+            mc::McReadOnly | mc::McImmutable => {\n+                // Subtle: liveness guarantees that immutable local\n+                // variables are only assigned once, so no need to\n+                // report an error for an assignment to a local\n+                // variable (note also that it is not legal to borrow\n+                // for a local variable before it has been assigned\n+                // for the first time).\n+                if !self.is_local_variable(cmt) {\n                     self.bccx.span_err(\n-                        ex.span,\n-                        at.ing_form(self.bccx.cmt_to_str(cmt)));\n-                    return;\n+                        expr.span,\n+                        fmt!(\"cannot assign to %s %s\"\n+                             cmt.mutbl.to_user_str(),\n+                             self.bccx.cmt_to_str(cmt)));\n                 }\n+                return;\n             }\n         }\n \n-        // if this is a pure function, only loan-able state can be\n-        // assigned, because it is uniquely tied to this function and\n-        // is not visible from the outside\n-        let purity = self.purity(ex.id);\n-        match purity {\n-          Right(_) => (),\n-          Left(pc_cmt(_)) => {\n-            // Subtle: Issue #3162.  If we are enforcing purity\n-            // because there is a reference to aliasable, mutable data\n-            // that we require to be immutable, we can't allow writes\n-            // even to data owned by the current stack frame.  This is\n-            // because that aliasable data might have been located on\n-            // the current stack frame, we don't know.\n-            self.report_purity_error(\n-                purity,\n-                ex.span,\n-                at.ing_form(self.bccx.cmt_to_str(cmt)));\n-          }\n-          Left(pc_pure_fn) => {\n-            if cmt.lp.is_none() {\n-                self.report_purity_error(\n-                    purity, ex.span,\n-                    at.ing_form(self.bccx.cmt_to_str(cmt)));\n-            }\n-          }\n+        if check_for_aliasable_mutable_writes(self, expr, cmt) {\n+            check_for_assignment_to_restricted_or_frozen_location(\n+                self, expr, cmt);\n         }\n \n-        // check for a conflicting loan as well, except in the case of\n-        // taking a mutable ref.  that will create a loan of its own\n-        // which will be checked for compat separately in\n-        // check_for_conflicting_loans()\n-        for cmt.lp.each |lp| {\n-            self.check_for_loan_conflicting_with_assignment(\n-                at, ex, cmt, *lp);\n-        }\n+        fn mark_variable_as_used_mut(self: &CheckLoanCtxt,\n+                                     cmt: mc::cmt) {\n+            //! If the mutability of the `cmt` being written is inherited\n+            //! from a local variable, liveness will\n+            //! not have been able to detect that this variable's mutability\n+            //! is important, so we must add the variable to the\n+            //! `used_mut_nodes` table here.\n+\n+            let mut cmt = cmt;\n+            loop {\n+                debug!(\"mark_writes_through_upvars_as_used_mut(cmt=%s)\",\n+                       cmt.repr(self.tcx()));\n+                match cmt.cat {\n+                    mc::cat_local(id) |\n+                    mc::cat_arg(id) |\n+                    mc::cat_self(id) => {\n+                        self.tcx().used_mut_nodes.insert(id);\n+                        return;\n+                    }\n \n-        self.bccx.add_to_mutbl_map(cmt);\n+                    mc::cat_stack_upvar(b) => {\n+                        cmt = b;\n+                    }\n \n-        // Check for and insert write guards as necessary.\n-        self.add_write_guards_if_necessary(cmt);\n-    }\n+                    mc::cat_rvalue |\n+                    mc::cat_static_item |\n+                    mc::cat_implicit_self |\n+                    mc::cat_copied_upvar(*) |\n+                    mc::cat_deref(_, _, mc::unsafe_ptr(*)) |\n+                    mc::cat_deref(_, _, mc::gc_ptr(*)) |\n+                    mc::cat_deref(_, _, mc::region_ptr(*)) => {\n+                        assert_eq!(cmt.mutbl, mc::McDeclared);\n+                        return;\n+                    }\n \n-    fn add_write_guards_if_necessary(&mut self, cmt: cmt) {\n-        match cmt.cat {\n-            cat_deref(base, deref_count, ptr_kind) => {\n-                self.add_write_guards_if_necessary(base);\n-\n-                match ptr_kind {\n-                    gc_ptr(ast::m_mutbl) => {\n-                        let key = root_map_key {\n-                            id: base.id,\n-                            derefs: deref_count\n-                        };\n-                        self.bccx.write_guard_map.insert(key);\n+                    mc::cat_discr(b, _) |\n+                    mc::cat_deref(b, _, mc::uniq_ptr(*)) => {\n+                        assert_eq!(cmt.mutbl, mc::McInherited);\n+                        cmt = b;\n+                    }\n+\n+                    mc::cat_interior(b, _) => {\n+                        if cmt.mutbl == mc::McInherited {\n+                            cmt = b;\n+                        } else {\n+                            return; // field declared as mutable or some such\n+                        }\n                     }\n-                    _ => {}\n                 }\n             }\n-            cat_comp(base, _) => {\n-                self.add_write_guards_if_necessary(base);\n-            }\n-            _ => {}\n         }\n-    }\n \n-    fn check_for_loan_conflicting_with_assignment(&mut self,\n-                                                  at: assignment_type,\n-                                                  ex: @ast::expr,\n-                                                  cmt: cmt,\n-                                                  lp: @loan_path) {\n-        for self.walk_loans_of(ex.id, lp) |loan| {\n-            match loan.kind {\n-                Immobile => { /* ok */ }\n-                TotalFreeze | PartialFreeze |\n-                TotalTake | PartialTake => {\n-                    self.bccx.span_err(\n-                        ex.span,\n-                        fmt!(\"%s prohibited due to outstanding loan\",\n-                             at.ing_form(self.bccx.cmt_to_str(cmt))));\n-                    self.bccx.span_note(\n-                        loan.cmt.span,\n-                        fmt!(\"loan of %s granted here\",\n-                             self.bccx.cmt_to_str(loan.cmt)));\n-                    return;\n+        fn check_for_aliasable_mutable_writes(self: &CheckLoanCtxt,\n+                                              expr: @ast::expr,\n+                                              cmt: mc::cmt) -> bool {\n+            //! Safety checks related to writes to aliasable, mutable locations\n+\n+            let guarantor = cmt.guarantor();\n+            debug!(\"check_for_aliasable_mutable_writes(cmt=%s, guarantor=%s)\",\n+                   cmt.repr(self.tcx()), guarantor.repr(self.tcx()));\n+            match guarantor.cat {\n+                mc::cat_deref(b, _, mc::region_ptr(m_mutbl, _)) => {\n+                    // Statically prohibit writes to `&mut` when aliasable\n+\n+                    match b.freely_aliasable() {\n+                        None => {}\n+                        Some(cause) => {\n+                            self.bccx.report_aliasability_violation(\n+                                expr.span,\n+                                MutabilityViolation,\n+                                cause);\n+                        }\n+                    }\n+                }\n+\n+                mc::cat_deref(_, deref_count, mc::gc_ptr(ast::m_mutbl)) => {\n+                    // Dynamically check writes to `@mut`\n+\n+                    let key = root_map_key {\n+                        id: guarantor.id,\n+                        derefs: deref_count\n+                    };\n+                    debug!(\"Inserting write guard at %?\", key);\n+                    self.bccx.write_guard_map.insert(key);\n                 }\n+\n+                _ => {}\n             }\n-        }\n \n-        // Subtle: if the mutability of the component being assigned\n-        // is inherited from the thing that the component is embedded\n-        // within, then we have to check whether that thing has been\n-        // loaned out as immutable!  An example:\n-        //    let mut x = {f: Some(3)};\n-        //    let y = &x; // x loaned out as immutable\n-        //    x.f = none; // changes type of y.f, which appears to be imm\n-        match *lp {\n-          lp_comp(lp_base, ck) if inherent_mutability(ck) != m_mutbl => {\n-            self.check_for_loan_conflicting_with_assignment(\n-                at, ex, cmt, lp_base);\n-          }\n-          lp_comp(*) | lp_self | lp_local(*) | lp_arg(*) | lp_deref(*) => ()\n+            return true; // no errors reported\n         }\n-    }\n \n-    fn report_purity_error(&mut self, pc: Either<purity_cause, impurity_cause>,\n-                           sp: span, msg: ~str) {\n-        match pc {\n-          Right(pc_default) => { fail!(~\"pc_default should be filtered sooner\") }\n-          Right(pc_unsafe) => {\n-            // this error was prevented by being marked as unsafe, so flag the\n-            // definition as having contributed to the validity of the program\n-            let def = self.declared_purity.def;\n-            debug!(\"flagging %? as a used unsafe source\", def);\n-            self.tcx().used_unsafe.insert(def);\n-          }\n-          Left(pc_pure_fn) => {\n-            self.tcx().sess.span_err(\n-                sp,\n-                fmt!(\"%s prohibited in pure context\", msg));\n-          }\n-          Left(pc_cmt(ref e)) => {\n-            if self.reported.insert((*e).cmt.id) {\n-                self.tcx().sess.span_err(\n-                    (*e).cmt.span,\n-                    fmt!(\"illegal borrow unless pure: %s\",\n-                         self.bccx.bckerr_to_str((*e))));\n-                self.bccx.note_and_explain_bckerr((*e));\n-                self.tcx().sess.span_note(\n-                    sp,\n-                    fmt!(\"impure due to %s\", msg));\n+        fn check_for_assignment_to_restricted_or_frozen_location(\n+            self: &CheckLoanCtxt,\n+            expr: @ast::expr,\n+            cmt: mc::cmt) -> bool\n+        {\n+            //! Check for assignments that violate the terms of an\n+            //! outstanding loan.\n+\n+            let loan_path = match opt_loan_path(cmt) {\n+                Some(lp) => lp,\n+                None => { return true; /* no loan path, can't be any loans */ }\n+            };\n+\n+            // Start by searching for an assignment to a *restricted*\n+            // location. Here is one example of the kind of error caught\n+            // by this check:\n+            //\n+            //    let mut v = ~[1, 2, 3];\n+            //    let p = &v;\n+            //    v = ~[4];\n+            //\n+            // In this case, creating `p` triggers a RESTR_MUTATE\n+            // restriction on the path `v`.\n+            //\n+            // Here is a second, more subtle example:\n+            //\n+            //    let mut v = ~[1, 2, 3];\n+            //    let p = &const v[0];\n+            //    v[0] = 4;                   // OK\n+            //    v[1] = 5;                   // OK\n+            //    v = ~[4, 5, 3];             // Error\n+            //\n+            // In this case, `p` is pointing to `v[0]`, and it is a\n+            // `const` pointer in any case. So the first two\n+            // assignments are legal (and would be permitted by this\n+            // check). However, the final assignment (which is\n+            // logically equivalent) is forbidden, because it would\n+            // cause the existing `v` array to be freed, thus\n+            // invalidating `p`. In the code, this error results\n+            // because `gather_loans::restrictions` adds a\n+            // `RESTR_MUTATE` restriction whenever the contents of an\n+            // owned pointer are borrowed, and hence while `v[*]` is not\n+            // restricted from being written, `v` is.\n+            for self.each_in_scope_restriction(expr.id, loan_path)\n+                |loan, restr|\n+            {\n+                if restr.set.intersects(RESTR_MUTATE) {\n+                    self.report_illegal_mutation(expr, loan_path, loan);\n+                    return false;\n+                }\n+            }\n+\n+            // The previous code handled assignments to paths that\n+            // have been restricted. This covers paths that have been\n+            // directly lent out and their base paths, but does not\n+            // cover random extensions of those paths. For example,\n+            // the following program is not declared illegal by the\n+            // previous check:\n+            //\n+            //    let mut v = ~[1, 2, 3];\n+            //    let p = &v;\n+            //    v[0] = 4; // declared error by loop below, not code above\n+            //\n+            // The reason that this passes the previous check whereas\n+            // an assignment like `v = ~[4]` fails is because the assignment\n+            // here is to `v[*]`, and the existing restrictions were issued\n+            // for `v`, not `v[*]`.\n+            //\n+            // So in this loop, we walk back up the loan path so long\n+            // as the mutability of the path is dependent on a super\n+            // path, and check that the super path was not lent out as\n+            // mutable or immutable (a const loan is ok).\n+            //\n+            // Note that we are *not* checking for any and all\n+            // restrictions.  We are only interested in the pointers\n+            // that the user created, whereas we add restrictions for\n+            // all kinds of paths that are not directly aliased. If we checked\n+            // for all restrictions, and not just loans, then the following\n+            // valid program would be considered illegal:\n+            //\n+            //    let mut v = ~[1, 2, 3];\n+            //    let p = &const v[0];\n+            //    v[1] = 5; // ok\n+            //\n+            // Here the restriction that `v` not be mutated would be misapplied\n+            // to block the subpath `v[1]`.\n+            let full_loan_path = loan_path;\n+            let mut loan_path = loan_path;\n+            loop {\n+                match *loan_path {\n+                    // Peel back one layer if `loan_path` has\n+                    // inherited mutability\n+                    LpExtend(lp_base, mc::McInherited, _) => {\n+                        loan_path = lp_base;\n+                    }\n+\n+                    // Otherwise stop iterating\n+                    LpExtend(_, mc::McDeclared, _) |\n+                    LpExtend(_, mc::McImmutable, _) |\n+                    LpExtend(_, mc::McReadOnly, _) |\n+                    LpVar(_) => {\n+                        return true;\n+                    }\n+                }\n+\n+                // Check for a non-const loan of `loan_path`\n+                for self.each_in_scope_loan(expr.id) |loan| {\n+                    if loan.loan_path == loan_path && loan.mutbl != m_const {\n+                        self.report_illegal_mutation(expr, full_loan_path, loan);\n+                        return false;\n+                    }\n+                }\n             }\n-          }\n         }\n     }\n \n-    fn check_move_out_from_expr(@mut self, ex: @ast::expr) {\n+    fn report_illegal_mutation(&self,\n+                               expr: @ast::expr,\n+                               loan_path: &LoanPath,\n+                               loan: &Loan) {\n+        self.bccx.span_err(\n+            expr.span,\n+            fmt!(\"cannot assign to `%s` because it is borrowed\",\n+                 self.bccx.loan_path_to_str(loan_path)));\n+        self.bccx.span_note(\n+            loan.span,\n+            fmt!(\"borrow of `%s` occurs here\",\n+                 self.bccx.loan_path_to_str(loan_path)));\n+    }\n+\n+    fn check_move_out_from_expr(&self, ex: @ast::expr) {\n         match ex.node {\n             ast::expr_paren(*) => {\n                 /* In the case of an expr_paren(), the expression inside\n@@ -529,156 +535,103 @@ pub impl CheckLoanCtxt {\n                     MoveFromIllegalCmt(_) => {\n                         self.bccx.span_err(\n                             cmt.span,\n-                            fmt!(\"moving out of %s\",\n+                            fmt!(\"cannot move out of %s\",\n                                  self.bccx.cmt_to_str(cmt)));\n                     }\n-                    MoveWhileBorrowed(_, loan_cmt) => {\n+                    MoveWhileBorrowed(loan_path, loan_span) => {\n                         self.bccx.span_err(\n                             cmt.span,\n-                            fmt!(\"moving out of %s prohibited \\\n-                                  due to outstanding loan\",\n-                                 self.bccx.cmt_to_str(cmt)));\n+                            fmt!(\"cannot move out of `%s` \\\n+                                  because it is borrowed\",\n+                                 self.bccx.loan_path_to_str(loan_path)));\n                         self.bccx.span_note(\n-                            loan_cmt.span,\n-                            fmt!(\"loan of %s granted here\",\n-                                 self.bccx.cmt_to_str(loan_cmt)));\n+                            loan_span,\n+                            fmt!(\"borrow of `%s` occurs here\",\n+                                 self.bccx.loan_path_to_str(loan_path)));\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn analyze_move_out_from_cmt(&mut self, cmt: cmt) -> MoveError {\n-        debug!(\"check_move_out_from_cmt(cmt=%s)\",\n-               self.bccx.cmt_to_repr(cmt));\n+    fn analyze_move_out_from_cmt(&self, cmt: mc::cmt) -> MoveError {\n+        debug!(\"check_move_out_from_cmt(cmt=%s)\", cmt.repr(self.tcx()));\n \n         match cmt.cat {\n-          // Rvalues, locals, and arguments can be moved:\n-          cat_rvalue | cat_local(_) | cat_arg(_) | cat_self(_) => {}\n-\n-          // We allow moving out of static items because the old code\n-          // did.  This seems consistent with permitting moves out of\n-          // rvalues, I guess.\n-          cat_special(sk_static_item) => {}\n-\n-          cat_deref(_, _, unsafe_ptr) => {}\n-\n-          // Nothing else.\n-          _ => {\n-              return MoveFromIllegalCmt(cmt);\n-          }\n+            // Rvalues, locals, and arguments can be moved:\n+            mc::cat_rvalue | mc::cat_local(_) |\n+            mc::cat_arg(_) | mc::cat_self(_) => {}\n+\n+            // It seems strange to allow a move out of a static item,\n+            // but what happens in practice is that you have a\n+            // reference to a constant with a type that should be\n+            // moved, like `None::<~int>`.  The type of this constant\n+            // is technically `Option<~int>`, which moves, but we know\n+            // that the content of static items will never actually\n+            // contain allocated pointers, so we can just memcpy it.\n+            mc::cat_static_item => {}\n+\n+            mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {}\n+\n+            // Nothing else.\n+            _ => {\n+                return MoveFromIllegalCmt(cmt);\n+            }\n         }\n \n-        self.bccx.add_to_mutbl_map(cmt);\n+        // FIXME(#4384) inadequare if/when we permit `move a.b`\n \n         // check for a conflicting loan:\n-        for cmt.lp.each |lp| {\n-            for self.walk_loans_of(cmt.id, *lp) |loan| {\n-                return MoveWhileBorrowed(cmt, loan.cmt);\n+        for opt_loan_path(cmt).each |&lp| {\n+            for self.each_in_scope_restriction(cmt.id, lp) |loan, _| {\n+                // Any restriction prevents moves.\n+                return MoveWhileBorrowed(loan.loan_path, loan.span);\n             }\n         }\n \n         return MoveOk;\n     }\n \n     fn check_call(&mut self,\n-                  expr: @ast::expr,\n-                  callee: Option<@ast::expr>,\n-                  callee_id: ast::node_id,\n-                  callee_span: span,\n-                  args: &[@ast::expr]) {\n-        let pc = self.purity(expr.id);\n-        match pc {\n-            // no purity, no need to check for anything\n-            Right(pc_default) => return,\n-\n-            // some form of purity, definitely need to check\n-            Left(_) => (),\n-\n-            // Unsafe trumped. To see if the unsafe is necessary, see what the\n-            // purity would have been without a trump, and if it's some form\n-            // of purity then we need to go ahead with the check\n-            Right(pc_unsafe) => {\n-                match do with(&mut self.declared_purity.purity,\n-                              ast::impure_fn) { self.purity(expr.id) } {\n-                    Right(pc_unsafe) => fail!(~\"unsafe can't trump twice\"),\n-                    Right(pc_default) => return,\n-                    Left(_) => ()\n-                }\n-            }\n-\n-        }\n-        self.check_pure_callee_or_arg(\n-            pc, callee, callee_id, callee_span);\n-        for args.each |arg| {\n-            self.check_pure_callee_or_arg(\n-                pc, Some(*arg), arg.id, arg.span);\n-        }\n+                  _expr: @ast::expr,\n+                  _callee: Option<@ast::expr>,\n+                  _callee_id: ast::node_id,\n+                  _callee_span: span,\n+                  _args: &[@ast::expr])\n+    {\n+        // NB: This call to check for conflicting loans is not truly\n+        // necessary, because the callee_id never issues new loans.\n+        // However, I added it for consistency and lest the system\n+        // should change in the future.\n+        //\n+        // FIXME(#6268) nested method calls\n+        // self.check_for_conflicting_loans(callee_id);\n     }\n }\n \n-fn check_loans_in_fn(fk: &visit::fn_kind,\n-                     decl: &ast::fn_decl,\n-                     body: &ast::blk,\n-                     sp: span,\n-                     id: ast::node_id,\n-                     self: @mut CheckLoanCtxt,\n-                     visitor: visit::vt<@mut CheckLoanCtxt>) {\n-    let is_stack_closure = self.is_stack_closure(id);\n-    let fty = ty::node_id_to_type(self.tcx(), id);\n-\n-    let declared_purity, src;\n+fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n+                         decl: &ast::fn_decl,\n+                         body: &ast::blk,\n+                         sp: span,\n+                         id: ast::node_id,\n+                         self: @mut CheckLoanCtxt<'a>,\n+                         visitor: visit::vt<@mut CheckLoanCtxt<'a>>) {\n     match *fk {\n-        visit::fk_item_fn(*) | visit::fk_method(*) => {\n-            declared_purity = ty::ty_fn_purity(fty);\n-            src = id;\n+        visit::fk_item_fn(*) |\n+        visit::fk_method(*) => {\n+            // Don't process nested items.\n+            return;\n         }\n \n-        visit::fk_anon(*) | visit::fk_fn_block(*) => {\n+        visit::fk_anon(*) |\n+        visit::fk_fn_block(*) => {\n+            let fty = ty::node_id_to_type(self.tcx(), id);\n             let fty_sigil = ty::ty_closure_sigil(fty);\n             check_moves_from_captured_variables(self, id, fty_sigil);\n-            let pair = ty::determine_inherited_purity(\n-                (self.declared_purity.purity, self.declared_purity.def),\n-                (ty::ty_fn_purity(fty), id),\n-                fty_sigil);\n-            declared_purity = pair.first();\n-            src = pair.second();\n         }\n     }\n \n-    debug!(\"purity on entry=%?\", copy self.declared_purity);\n-    do save_and_restore_managed(self.declared_purity) {\n-        do save_and_restore_managed(self.fn_args) {\n-            self.declared_purity = @mut PurityState::function(declared_purity, src);\n-\n-            match *fk {\n-                visit::fk_anon(*) |\n-                visit::fk_fn_block(*) if is_stack_closure => {\n-                    // inherits the fn_args from enclosing ctxt\n-                }\n-                visit::fk_anon(*) | visit::fk_fn_block(*) |\n-                visit::fk_method(*) | visit::fk_item_fn(*) => {\n-                    let mut fn_args = ~[];\n-                    for decl.inputs.each |input| {\n-                        // For the purposes of purity, only consider function-\n-                        // typed bindings in trivial patterns to be function\n-                        // arguments. For example, do not allow `f` and `g` in\n-                        // (f, g): (&fn(), &fn()) to be called.\n-                        match input.pat.node {\n-                            ast::pat_ident(_, _, None) => {\n-                                fn_args.push(input.pat.id);\n-                            }\n-                            _ => {} // Ignore this argument.\n-                        }\n-                    }\n-                    *self.fn_args = @fn_args;\n-                }\n-            }\n-\n-            visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n-        }\n-    }\n-    debug!(\"purity on exit=%?\", copy self.declared_purity);\n+    visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n \n     fn check_moves_from_captured_variables(self: @mut CheckLoanCtxt,\n                                            id: ast::node_id,\n@@ -704,16 +657,16 @@ fn check_loans_in_fn(fk: &visit::fn_kind,\n                                 fmt!(\"illegal by-move capture of %s\",\n                                      self.bccx.cmt_to_str(move_cmt)));\n                         }\n-                        MoveWhileBorrowed(move_cmt, loan_cmt) => {\n+                        MoveWhileBorrowed(loan_path, loan_span) => {\n                             self.bccx.span_err(\n                                 cap_var.span,\n-                                fmt!(\"by-move capture of %s prohibited \\\n-                                      due to outstanding loan\",\n-                                     self.bccx.cmt_to_str(move_cmt)));\n+                                fmt!(\"cannot move `%s` into closure \\\n+                                      because it is borrowed\",\n+                                     self.bccx.loan_path_to_str(loan_path)));\n                             self.bccx.span_note(\n-                                loan_cmt.span,\n-                                fmt!(\"loan of %s granted here\",\n-                                     self.bccx.cmt_to_str(loan_cmt)));\n+                                loan_span,\n+                                fmt!(\"borrow of `%s` occurs here\",\n+                                     self.bccx.loan_path_to_str(loan_path)));\n                         }\n                     }\n                 }\n@@ -724,17 +677,19 @@ fn check_loans_in_fn(fk: &visit::fn_kind,\n     }\n }\n \n-fn check_loans_in_local(local: @ast::local,\n-                        self: @mut CheckLoanCtxt,\n-                        vt: visit::vt<@mut CheckLoanCtxt>) {\n+fn check_loans_in_local<'a>(local: @ast::local,\n+                            self: @mut CheckLoanCtxt<'a>,\n+                            vt: visit::vt<@mut CheckLoanCtxt<'a>>) {\n     visit::visit_local(local, self, vt);\n }\n \n-fn check_loans_in_expr(expr: @ast::expr,\n-                       self: @mut CheckLoanCtxt,\n-                       vt: visit::vt<@mut CheckLoanCtxt>) {\n-    debug!(\"check_loans_in_expr(expr=%?/%s)\",\n-           expr.id, pprust::expr_to_str(expr, self.tcx().sess.intr()));\n+fn check_loans_in_expr<'a>(expr: @ast::expr,\n+                           self: @mut CheckLoanCtxt<'a>,\n+                           vt: visit::vt<@mut CheckLoanCtxt<'a>>) {\n+    debug!(\"check_loans_in_expr(expr=%s)\",\n+           expr.repr(self.tcx()));\n+\n+    visit::visit_expr(expr, self, vt);\n \n     self.check_for_conflicting_loans(expr.id);\n \n@@ -744,12 +699,12 @@ fn check_loans_in_expr(expr: @ast::expr,\n \n     match expr.node {\n       ast::expr_swap(l, r) => {\n-        self.check_assignment(at_swap, l);\n-        self.check_assignment(at_swap, r);\n+        self.check_assignment(l);\n+        self.check_assignment(r);\n       }\n       ast::expr_assign(dest, _) |\n       ast::expr_assign_op(_, dest, _) => {\n-        self.check_assignment(at_straight_up, dest);\n+        self.check_assignment(dest);\n       }\n       ast::expr_call(f, ref args, _) => {\n         self.check_call(expr, Some(f), f.id, f.span, *args);\n@@ -774,31 +729,34 @@ fn check_loans_in_expr(expr: @ast::expr,\n                         expr.span,\n                         ~[]);\n       }\n-      ast::expr_match(*) => {\n-          // Note: moves out of pattern bindings are not checked by\n-          // the borrow checker, at least not directly.  What happens\n-          // is that if there are any moved bindings, the discriminant\n-          // will be considered a move, and this will be checked as\n-          // normal.  Then, in `middle::check_match`, we will check\n-          // that no move occurs in a binding that is underneath an\n-          // `@` or `&`.  Together these give the same guarantees as\n-          // `check_move_out_from_expr()` without requiring us to\n-          // rewalk the patterns and rebuild the pattern\n-          // categorizations.\n-      }\n       _ => { }\n     }\n-\n-    visit::visit_expr(expr, self, vt);\n }\n \n-fn check_loans_in_block(blk: &ast::blk,\n-                        self: @mut CheckLoanCtxt,\n-                        vt: visit::vt<@mut CheckLoanCtxt>) {\n-    do save_and_restore_managed(self.declared_purity) {\n-        self.check_for_conflicting_loans(blk.node.id);\n+fn check_loans_in_pat<'a>(pat: @ast::pat,\n+                          self: @mut CheckLoanCtxt<'a>,\n+                          vt: visit::vt<@mut CheckLoanCtxt<'a>>)\n+{\n+    self.check_for_conflicting_loans(pat.id);\n+\n+    // Note: moves out of pattern bindings are not checked by\n+    // the borrow checker, at least not directly.  What happens\n+    // is that if there are any moved bindings, the discriminant\n+    // will be considered a move, and this will be checked as\n+    // normal.  Then, in `middle::check_match`, we will check\n+    // that no move occurs in a binding that is underneath an\n+    // `@` or `&`.  Together these give the same guarantees as\n+    // `check_move_out_from_expr()` without requiring us to\n+    // rewalk the patterns and rebuild the pattern\n+    // categorizations.\n+\n+    visit::visit_pat(pat, self, vt);\n+}\n \n-        *self.declared_purity = self.declared_purity.recurse(blk);\n-        visit::visit_block(blk, self, vt);\n-    }\n+fn check_loans_in_block<'a>(blk: &ast::blk,\n+                            self: @mut CheckLoanCtxt<'a>,\n+                            vt: visit::vt<@mut CheckLoanCtxt<'a>>)\n+{\n+    visit::visit_block(blk, self, vt);\n+    self.check_for_conflicting_loans(blk.node.id);\n }"}, {"sha": "1e09fbe71843c1be8ea45ac2ac257daa09ff1cd8", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "added", "additions": 750, "deletions": 0, "changes": 750, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -0,0 +1,750 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+# The Borrow Checker\n+\n+This pass has the job of enforcing memory safety. This is a subtle\n+topic. The only way I know how to explain it is terms of a formal\n+model, so that's what I'll do.\n+\n+# Formal model\n+\n+Let's consider a simple subset of Rust in which you can only borrow\n+from lvalues like so:\n+\n+    LV = x | LV.f | *LV\n+\n+Here `x` represents some variable, `LV.f` is a field reference,\n+and `*LV` is a pointer dereference. There is no auto-deref or other\n+niceties. This means that if you have a type like:\n+\n+    struct S { f: uint }\n+\n+and a variable `a: ~S`, then the rust expression `a.f` would correspond\n+to an `LV` of `(*a).f`.\n+\n+Here is the formal grammar for the types we'll consider:\n+\n+    TY = () | S<'LT...> | ~TY | & 'LT MQ TY | @ MQ TY\n+    MQ = mut | imm | const\n+\n+Most of these types should be pretty self explanatory. Here `S` is a\n+struct name and we assume structs are declared like so:\n+\n+    SD = struct S<'LT...> { (f: TY)... }\n+\n+# An intuitive explanation\n+\n+## Issuing loans\n+\n+Now, imagine we had a program like this:\n+\n+    struct Foo { f: uint, g: uint }\n+    ...\n+    'a: {\n+      let mut x: ~Foo = ...;\n+      let y = &mut (*x).f;\n+      x = ...;\n+    }\n+\n+This is of course dangerous because mutating `x` will free the old\n+value and hence invalidate `y`. The borrow checker aims to prevent\n+this sort of thing.\n+\n+### Loans\n+\n+The way the borrow checker works is that it analyzes each borrow\n+expression (in our simple model, that's stuff like `&LV`, though in\n+real life there are a few other cases to consider). For each borrow\n+expression, it computes a vector of loans:\n+\n+    LOAN = (LV, LT, PT, LK)\n+    PT = Partial | Total\n+    LK = MQ | RESERVE\n+\n+Each `LOAN` tuple indicates some sort of restriction on what can be\n+done to the lvalue `LV`; `LV` will always be a path owned by the\n+current stack frame. These restrictions are called \"loans\" because\n+they are always the result of a borrow expression.\n+\n+Every loan has a lifetime `LT` during which those restrictions are in\n+effect.  The indicator `PT` distinguishes between *total* loans, in\n+which the LV itself was borrowed, and *partial* loans, which means\n+that some content ownwed by LV was borrowed.\n+\n+The final element in the loan tuple is the *loan kind* `LK`.  There\n+are four kinds: mutable, immutable, const, and reserve:\n+\n+- A \"mutable\" loan means that LV may be written to through an alias, and\n+  thus LV cannot be written to directly or immutably aliased (remember\n+  that we preserve the invariant that any given value can only be\n+  written to through one path at a time; hence if there is a mutable\n+  alias to LV, then LV cannot be written directly until this alias is\n+  out of scope).\n+\n+- An \"immutable\" loan means that LV must remain immutable.  Hence it\n+  cannot be written, but other immutable aliases are permitted.\n+\n+- A \"const\" loan means that an alias to LV exists.  LV may still be\n+  written or frozen.\n+\n+- A \"reserve\" loan is the strongest case.  It prevents both mutation\n+  and aliasing of any kind, including `&const` loans.  Reserve loans\n+  are a side-effect of borrowing an `&mut` loan.\n+\n+In addition to affecting mutability, a loan of any kind implies that\n+LV cannot be moved.\n+\n+### Example\n+\n+To give you a better feeling for what a loan is, let's look at three\n+loans that would be issued as a result of the borrow `&(*x).f` in the\n+example above:\n+\n+    ((*x).f, Total, mut, 'a)\n+    (*x, Partial, mut, 'a)\n+    (x, Partial, mut, 'a)\n+\n+The first loan states that the expression `(*x).f` has been loaned\n+totally as mutable for the lifetime `'a`. This first loan would\n+prevent an assignment `(*x).f = ...` from occurring during the\n+lifetime `'a`.\n+\n+Now let's look at the second loan. You may have expected that each\n+borrow would result in only one loan. But this is not the case.\n+Instead, there will be loans for every path where mutation might\n+affect the validity of the borrowed pointer that is created (in some\n+cases, there can even be multiple loans per path, see the section on\n+\"Borrowing in Calls\" below for the gory details). The reason for this\n+is to prevent actions that would indirectly affect the borrowed path.\n+In this case, we wish to ensure that `(*x).f` is not mutated except\n+through the mutable alias `y`.  Therefore, we must not only prevent an\n+assignment to `(*x).f` but also an assignment like `*x = Foo {...}`,\n+as this would also mutate the field `f`.  To do so, we issue a\n+*partial* mutable loan for `*x` (the loan is partial because `*x`\n+itself was not borrowed).  This partial loan will cause any attempt to\n+assign to `*x` to be flagged as an error.\n+\n+Because both partial and total loans prevent assignments, you may\n+wonder why we bother to distinguish between them.  The reason for this\n+distinction has to do with preventing double borrows. In particular,\n+it is legal to borrow both `&mut x.f` and `&mut x.g` simultaneously,\n+but it is not legal to borrow `&mut x.f` twice. In the borrow checker,\n+the first case would result in two *partial* mutable loans of `x`\n+(along with one total mutable loan of `x.f` and one of `x.g) whereas\n+the second would result in two *total* mutable loans of `x.f` (along\n+with two partial mutable loans of `x`).  Multiple *total mutable* loan\n+for the same path are not permitted, but multiple *partial* loans (of\n+any mutability) are permitted.\n+\n+Finally, we come to the third loan. This loan is a partial mutable\n+loan of `x`.  This loan prevents us from reassigning `x`, which would\n+be bad for two reasons.  First, it would change the value of `(*x).f`\n+but, even worse, it would cause the pointer `y` to become a dangling\n+pointer.  Bad all around.\n+\n+## Checking for illegal assignments, moves, and reborrows\n+\n+Once we have computed the loans introduced by each borrow, the borrow\n+checker will determine the full set of loans in scope at each\n+expression and use that to decide whether that expression is legal.\n+Remember that the scope of loan is defined by its lifetime LT.  We\n+sometimes say that a loan which is in-scope at a particular point is\n+an \"outstanding loan\".\n+\n+The kinds of expressions which in-scope loans can render illegal are\n+*assignments*, *moves*, and *borrows*.\n+\n+An assignments to an lvalue LV is illegal if there is in-scope mutable\n+or immutable loan for LV.  Assignment with an outstanding mutable loan\n+is illegal because then the `&mut` pointer is supposed to be the only\n+way to mutate the value.  Assignment with an outstanding immutable\n+loan is illegal because the value is supposed to be immutable at that\n+point.\n+\n+A move from an lvalue LV is illegal if there is any sort of\n+outstanding loan.\n+\n+A borrow expression may be illegal if any of the loans which it\n+produces conflict with other outstanding loans.  Two loans are\n+considered compatible if one of the following conditions holds:\n+\n+- At least one loan is a const loan.\n+- Both loans are partial loans.\n+- Both loans are immutable.\n+\n+Any other combination of loans is illegal.\n+\n+# The set of loans that results from a borrow expression\n+\n+Here we'll define four functions---MUTATE, FREEZE, ALIAS, and\n+TAKE---which are all used to compute the set of LOANs that result\n+from a borrow expression.  The first three functions each have\n+a similar type signature:\n+\n+    MUTATE(LV, LT, PT) -> LOANS\n+    FREEZE(LV, LT, PT) -> LOANS\n+    ALIAS(LV, LT, PT) -> LOANS\n+\n+MUTATE, FREEZE, and ALIAS are used when computing the loans result\n+from mutable, immutable, and const loans respectively.  For example,\n+the loans resulting from an expression like `&mut (*x).f` would be\n+computed by `MUTATE((*x).f, LT, Total)`, where `LT` is the lifetime of\n+the resulting pointer.  Similarly the loans for `&(*x).f` and `&const\n+(*x).f` would be computed by `FREEZE((*x).f, LT, Total)` and\n+`ALIAS((*x).f, LT, Total)` respectively. (Actually this is a slight\n+simplification; see the section below on Borrows in Calls for the full\n+gory details)\n+\n+The names MUTATE, FREEZE, and ALIAS are intended to suggest the\n+semantics of `&mut`, `&`, and `&const` borrows respectively.  `&mut`,\n+for example, creates a mutable alias of LV.  `&` causes the borrowed\n+value to be frozen (immutable).  `&const` does neither but does\n+introduce an alias to be the borrowed value.\n+\n+Each of these three functions is only defined for some inputs.  That\n+is, it may occur that some particular borrow is not legal.  For\n+example, it is illegal to make an `&mut` loan of immutable data.  In\n+that case, the MUTATE() function is simply not defined (in the code,\n+it returns a Result<> condition to indicate when a loan would be\n+illegal).\n+\n+The final function, RESERVE, is used as part of borrowing an `&mut`\n+pointer.  Due to the fact that it is used for one very particular\n+purpose, it has a rather simpler signature than the others:\n+\n+    RESERVE(LV, LT) -> LOANS\n+\n+It is explained when we come to that case.\n+\n+## The function MUTATE()\n+\n+Here we use [inference rules][ir] to define the MUTATE() function.\n+We will go case by case for the various kinds of lvalues that\n+can be borrowed.\n+\n+[ir]: http://en.wikipedia.org/wiki/Rule_of_inference\n+\n+### Mutating local variables\n+\n+The rule for mutating local variables is as follows:\n+\n+    Mutate-Variable:\n+      LT <= Scope(x)\n+      Mut(x) = Mut\n+      --------------------------------------------------\n+      MUTATE(x, LT, PT) = (x, LT, PT, mut)\n+\n+Here `Scope(x)` is the lifetime of the block in which `x` was declared\n+and `Mut(x)` indicates the mutability with which `x` was declared.\n+This rule simply states that you can only create a mutable alias\n+to a variable if it is mutable, and that alias cannot outlive the\n+stack frame in which the variable is declared.\n+\n+### Mutating fields and owned pointers\n+\n+As it turns out, the rules for mutating fields and mutating owned\n+pointers turn out to be quite similar.  The reason is that the\n+expressions `LV.f` and `*LV` are both owned by their base expression\n+`LV`.  So basically the result of mutating `LV.f` or `*LV` is computed\n+by adding a loan for `LV.f` or `*LV` and then the loans for a partial\n+take of `LV`:\n+\n+    Mutate-Field:\n+      MUTATE(LV, LT, Partial) = LOANS\n+      ------------------------------------------------------------\n+      MUTATE(LV.f, LT, PT) = LOANS, (LV.F, LT, PT, mut)\n+\n+    Mutate-Owned-Ptr:\n+      Type(LV) = ~Ty\n+      MUTATE(LV, LT, Partial) = LOANS\n+      ------------------------------------------------------------\n+      MUTATE(*LV, LT, PT) = LOANS, (*LV, LT, PT, mut)\n+\n+Note that while our micro-language only has fields, the slight\n+variations on the `Mutate-Field` rule are used for any interior content\n+that appears in the full Rust language, such as the contents of a\n+tuple, fields in a struct, or elements of a fixed-length vector.\n+\n+### Mutating dereferenced borrowed pointers\n+\n+The rule for borrowed pointers is by far the most complicated:\n+\n+    Mutate-Mut-Borrowed-Ptr:\n+      Type(LV) = &LT_P mut Ty             // (1)\n+      LT <= LT_P                          // (2)\n+      RESERVE(LV, LT) = LOANS             // (3)\n+      ------------------------------------------------------------\n+      MUTATE(*LV, LT, PT) = LOANS, (*LV, LT, PT, Mut)\n+\n+Condition (1) states that only a mutable borrowed pointer can be\n+taken.  Condition (2) states that the lifetime of the alias must be\n+less than the lifetime of the borrowed pointer being taken.\n+\n+Conditions (3) and (4) are where things get interesting.  The intended\n+semantics of the borrow is that the new `&mut` pointer is the only one\n+which has the right to modify the data; the original `&mut` pointer\n+must not be used for mutation.  Because borrowed pointers do not own\n+their content nor inherit mutability, we must be particularly cautious\n+of aliases, which could permit the original borrowed pointer to be\n+reached from another path and thus circumvent our loans.\n+\n+Here is one example of what could go wrong if we ignore clause (4):\n+\n+    let x: &mut T;\n+    ...\n+    let y = &mut *x;   // Only *y should be able to mutate...\n+    let z = &const x;\n+    **z = ...;         // ...but here **z is still able to mutate!\n+\n+Another possible error could occur with moves:\n+\n+    let x: &mut T;\n+    ...\n+    let y = &mut *x;   // Issues loan: (*x, LT, Total, Mut)\n+    let z = x;         // moves from x\n+    *z = ...;          // Mutates *y indirectly! Bad.\n+\n+In both of these cases, the problem is that when creating the alias\n+`y` we would only issue a loan preventing assignment through `*x`.\n+But this loan can be easily circumvented by moving from `x` or\n+aliasing it.  Note that, in the first example, the alias of `x` was\n+created using `&const`, which is a particularly weak form of alias.\n+\n+The danger of aliases can also occur when the `&mut` pointer itself\n+is already located in an alias location, as here:\n+\n+    let x: @mut &mut T; // or &mut &mut T, &&mut T,\n+    ...                 // &const &mut T, @&mut T, etc\n+    let y = &mut **x;   // Only *y should be able to mutate...\n+    let z = x;\n+    **z = ...;          // ...but here **z is still able to mutate!\n+\n+When we cover the rules for RESERVE, we will see that it would\n+disallow this case, because MUTATE can only be applied to canonical\n+lvalues which are owned by the current stack frame.\n+\n+It might be the case that if `&const` and `@const` pointers were\n+removed, we could do away with RESERVE and simply use MUTATE instead.\n+But we have to be careful about the final example in particular, since\n+dynamic freezing would not be sufficient to prevent this example.\n+Perhaps a combination of MUTATE with a predicate OWNED(LV).\n+\n+One final detail: unlike every other case, when we calculate the loans\n+using RESERVE we do not use the original lifetime `LT` but rather\n+`GLB(Scope(LV), LT)`.  What this says is:\n+\n+### Mutating dereferenced managed pointers\n+\n+Because the correctness of managed pointer loans is checked dynamically,\n+the rule is quite simple:\n+\n+    Mutate-Mut-Managed-Ptr:\n+      Type(LV) = @mut Ty\n+      Add ROOT-FREEZE annotation for *LV with lifetime LT\n+      ------------------------------------------------------------\n+      MUTATE(*LV, LT, Total) = []\n+\n+No loans are issued.  Instead, we add a side annotation that causes\n+`*LV` to be rooted and frozen on entry to LV.  You could rephrase\n+these rules as having multiple returns values, or rephrase this as a\n+kind of loan, but whatever.\n+\n+One interesting point is that *partial takes* of `@mut` are forbidden.\n+This is not for any soundness reason but just because it is clearer\n+for users when `@mut` values are either lent completely or not at all.\n+\n+## The function FREEZE\n+\n+The rules for FREEZE are pretty similar to MUTATE.  The first four\n+cases I'll just present without discussion, as the reasoning is\n+quite analogous to the MUTATE case:\n+\n+    Freeze-Variable:\n+      LT <= Scope(x)\n+      --------------------------------------------------\n+      FREEZE(x, LT, PT) = (x, LT, PT, imm)\n+\n+    Freeze-Field:\n+      FREEZE(LV, LT, Partial) = LOANS\n+      ------------------------------------------------------------\n+      FREEZE(LV.f, LT, PT) = LOANS, (LV.F, LT, PT, imm)\n+\n+    Freeze-Owned-Ptr:\n+      Type(LV) = ~Ty\n+      FREEZE(LV, LT, Partial) = LOANS\n+      ------------------------------------------------------------\n+      FREEZE(*LV, LT, PT) = LOANS, (*LV, LT, PT, imm)\n+\n+    Freeze-Mut-Borrowed-Ptr:\n+      Type(LV) = &LT_P mut Ty\n+      LT <= LT_P\n+      RESERVE(LV, LT) = LOANS\n+      ------------------------------------------------------------\n+      FREEZE(*LV, LT, PT) = LOANS, (*LV, LT, PT, Imm)\n+\n+    Freeze-Mut-Managed-Ptr:\n+      Type(LV) = @mut Ty\n+      Add ROOT-FREEZE annotation for *LV with lifetime LT\n+      ------------------------------------------------------------\n+      Freeze(*LV, LT, Total) = []\n+\n+The rule to \"freeze\" an immutable borrowed pointer is quite\n+simple, since the content is already immutable:\n+\n+    Freeze-Imm-Borrowed-Ptr:\n+      Type(LV) = &LT_P Ty                 // (1)\n+      LT <= LT_P                          // (2)\n+      ------------------------------------------------------------\n+      FREEZE(*LV, LT, PT) = LOANS, (*LV, LT, PT, Mut)\n+\n+The final two rules pertain to borrows of `@Ty`.  There is a bit of\n+subtlety here.  The main problem is that we must guarantee that the\n+managed box remains live for the entire borrow.  We can either do this\n+dynamically, by rooting it, or (better) statically, and hence there\n+are two rules:\n+\n+    Freeze-Imm-Managed-Ptr-1:\n+      Type(LV) = @Ty\n+      Add ROOT annotation for *LV\n+      ------------------------------------------------------------\n+      FREEZE(*LV, LT, PT) = []\n+\n+    Freeze-Imm-Managed-Ptr-2:\n+      Type(LV) = @Ty\n+      LT <= Scope(LV)\n+      Mut(LV) = imm\n+      LV is not moved\n+      ------------------------------------------------------------\n+      FREEZE(*LV, LT, PT) = []\n+\n+The intention of the second rule is to avoid an extra root if LV\n+serves as a root.  In that case, LV must (1) outlive the borrow; (2)\n+be immutable; and (3) not be moved.\n+\n+## The ALIAS function\n+\n+The function ALIAS is used for `&const` loans but also to handle one\n+corner case concerning function arguments (covered in the section\n+\"Borrows in Calls\" below).  It computes the loans that result from\n+observing that there is a pointer to `LV` and thus that pointer must\n+remain valid.\n+\n+The first two rules are simple:\n+\n+    Alias-Variable:\n+      LT <= Scope(x)\n+      --------------------------------------------------\n+      ALIAS(x, LT, PT) = (x, LT, PT, Const)\n+\n+    Alias-Field:\n+      ALIAS(LV, LT, Partial) = LOANS\n+      ------------------------------------------------------------\n+      ALIAS(LV.f, LT, PT) = LOANS, (LV.F, LT, PT, Const)\n+\n+### Aliasing owned pointers\n+\n+The rule for owned pointers is somewhat interesting:\n+\n+    Alias-Owned-Ptr:\n+      Type(LV) = ~Ty\n+      FREEZE(LV, LT, Partial) = LOANS\n+      ------------------------------------------------------------\n+      ALIAS(*LV, LT, PT) = LOANS, (*LV, LT, PT, Const)\n+\n+Here we *freeze* the base `LV`.  The reason is that if an owned\n+pointer is mutated it frees its content, which means that the alias to\n+`*LV` would become a dangling pointer.\n+\n+### Aliasing borrowed pointers\n+\n+The rule for borrowed pointers is quite simple, because borrowed\n+pointers do not own their content and thus do not play a role in\n+keeping it live:\n+\n+    Alias-Borrowed-Ptr:\n+      Type(LV) = &LT_P MQ Ty\n+      LT <= LT_P\n+      ------------------------------------------------------------\n+      ALIAS(*LV, LT, PT) = []\n+\n+Basically, the existence of a borrowed pointer to some memory with\n+lifetime LT_P is proof that the memory can safely be aliased for any\n+lifetime LT <= LT_P.\n+\n+### Aliasing managed pointers\n+\n+The rules for aliasing managed pointers are similar to those\n+used with FREEZE, except that they apply to all manager pointers\n+regardles of mutability:\n+\n+    Alias-Managed-Ptr-1:\n+      Type(LV) = @MQ Ty\n+      Add ROOT annotation for *LV\n+      ------------------------------------------------------------\n+      ALIAS(*LV, LT, PT) = []\n+\n+    Alias-Managed-Ptr-2:\n+      Type(LV) = @MQ Ty\n+      LT <= Scope(LV)\n+      Mut(LV) = imm\n+      LV is not moved\n+      ------------------------------------------------------------\n+      ALIAS(*LV, LT, PT) = []\n+\n+## The RESERVE function\n+\n+The final function, RESERVE, is used for loans of `&mut` pointers.  As\n+discussed in the section on the function MUTATE, we must be quite\n+careful when \"re-borrowing\" an `&mut` pointer to ensure that the original\n+`&mut` pointer can no longer be used to mutate.\n+\n+There are a couple of dangers to be aware of:\n+\n+- `&mut` pointers do not inherit mutability.  Therefore, if you have\n+  an lvalue LV with type `&mut T` and you freeze `LV`, you do *not*\n+  freeze `*LV`.  This is quite different from an `LV` with type `~T`.\n+\n+- Also, because they do not inherit mutability, if the `&mut` pointer\n+  lives in an aliased location, then *any alias* can be used to write!\n+\n+As a consequence of these two rules, RESERVE can only be successfully\n+invoked on an lvalue LV that is *owned by the current stack frame*.\n+This ensures that there are no aliases that are not visible from the\n+outside.  Moreover, Reserve loans are incompatible with all other\n+loans, even Const loans.  This prevents any aliases from being created\n+within the current function.\n+\n+### Reserving local variables\n+\n+The rule for reserving a variable is generally straightforward but\n+with one interesting twist:\n+\n+    Reserve-Variable:\n+      --------------------------------------------------\n+      RESERVE(x, LT) = (x, LT, Total, Reserve)\n+\n+The twist here is that the incoming lifetime is not required to\n+be a subset of the incoming variable, unlike every other case.  To\n+see the reason for this, imagine the following function:\n+\n+    struct Foo { count: uint }\n+    fn count_field(x: &'a mut Foo) -> &'a mut count {\n+        &mut (*x).count\n+    }\n+\n+This function consumes one `&mut` pointer and returns another with the\n+same lifetime pointing at a particular field.  The borrow for the\n+`&mut` expression will result in a call to `RESERVE(x, 'a)`, which is\n+intended to guarantee that `*x` is not later aliased or used to\n+mutate.  But the lifetime of `x` is limited to the current function,\n+which is a sublifetime of the parameter `'a`, so the rules used for\n+MUTATE, FREEZE, and ALIAS (which require that the lifetime of the loan\n+not exceed the lifetime of the variable) would result in an error.\n+\n+Nonetheless this function is perfectly legitimate.  After all, the\n+caller has moved in an `&mut` pointer with lifetime `'a`, and thus has\n+given up their right to mutate the value for the remainder of `'a`.\n+So it is fine for us to return a pointer with the same lifetime.\n+\n+The reason that RESERVE differs from the other functions is that\n+RESERVE is not responsible for guaranteeing that the pointed-to data\n+will outlive the borrowed pointer being created.  After all, `&mut`\n+values do not own the data they point at.\n+\n+### Reserving owned content\n+\n+The rules for fields and owned pointers are very straightforward:\n+\n+    Reserve-Field:\n+      RESERVE(LV, LT) = LOANS\n+      ------------------------------------------------------------\n+      RESERVE(LV.f, LT) = LOANS, (LV.F, LT, Total, Reserve)\n+\n+    Reserve-Owned-Ptr:\n+      Type(LV) = ~Ty\n+      RESERVE(LV, LT) = LOANS\n+      ------------------------------------------------------------\n+      RESERVE(*LV, LT) = LOANS, (*LV, LT, Total, Reserve)\n+\n+### Reserving `&mut` borrowed pointers\n+\n+Unlike other borrowed pointers, `&mut` pointers are unaliasable,\n+so we can reserve them like everything else:\n+\n+    Reserve-Mut-Borrowed-Ptr:\n+      Type(LV) = &LT_P mut Ty\n+      RESERVE(LV, LT) = LOANS\n+      ------------------------------------------------------------\n+      RESERVE(*LV, LT) = LOANS, (*LV, LT, Total, Reserve)\n+\n+## Borrows in calls\n+\n+Earlier we said that the MUTATE, FREEZE, and ALIAS functions were used\n+to compute the loans resulting from a borrow expression.  But this is\n+not strictly correct, there is a slight complication that occurs with\n+calls by which additional loans may be necessary.  We will explain\n+that here and give the full details.\n+\n+Imagine a call expression `'a: E1(E2, E3)`, where `Ei` are some\n+expressions. If we break this down to something a bit lower-level, it\n+is kind of short for:\n+\n+    'a: {\n+        'a_arg1: let temp1: ... = E1;\n+        'a_arg2: let temp2: ... = E2;\n+        'a_arg3: let temp3: ... = E3;\n+        'a_call: temp1(temp2, temp3)\n+    }\n+\n+Here the lifetime labels indicate the various lifetimes. As you can\n+see there are in fact four relevant lifetimes (only one of which was\n+named by the user): `'a` corresponds to the expression `E1(E2, E3)` as\n+a whole. `'a_arg1`, `'a_arg2`, and `'a_arg3` correspond to the\n+evaluations of `E1`, `E2`, and `E3` respectively. Finally, `'a_call`\n+corresponds to the *actual call*, which is the point where the values\n+of the parameters will be used.\n+\n+Now, let's look at a (contrived, but representative) example to see\n+why all this matters:\n+\n+    struct Foo { f: uint, g: uint }\n+    ...\n+    fn add(p: &mut uint, v: uint) {\n+        *p += v;\n+    }\n+    ...\n+    fn inc(p: &mut uint) -> uint {\n+        *p += 1; *p\n+    }\n+    fn weird() {\n+        let mut x: ~Foo = ~Foo { ... };\n+        'a: add(&mut (*x).f,\n+                'b: inc(&mut (*x).f)) // (*)\n+    }\n+\n+The important part is the line marked `(*)` which contains a call to\n+`add()`. The first argument is a mutable borrow of the field `f`.\n+The second argument *always borrows* the field `f`. Now, if these two\n+borrows overlapped in time, this would be illegal, because there would\n+be two `&mut` pointers pointing at `f`. And, in a way, they *do*\n+overlap in time, since the first argument will be evaluated first,\n+meaning that the pointer will exist when the second argument executes.\n+But in another important way they do not overlap in time. Let's\n+expand out that final call to `add()` as we did before:\n+\n+    'a: {\n+        'a_arg1: let a_temp1: ... = add;\n+        'a_arg2: let a_temp2: &'a_call mut uint = &'a_call mut (*x).f;\n+        'a_arg3_: let a_temp3: uint = {\n+            let b_temp1: ... = inc;\n+            let b_temp2: &'b_call = &'b_call mut (*x).f;\n+            'b_call: b_temp1(b_temp2)\n+        };\n+        'a_call: a_temp1(a_temp2, a_temp3)\n+    }\n+\n+When it's written this way, we can see that although there are two\n+borrows, the first has lifetime `'a_call` and the second has lifetime\n+`'b_call` and in fact these lifetimes do not overlap. So everything\n+is fine.\n+\n+But this does not mean that there isn't reason for caution!  Imagine a\n+devious program like *this* one:\n+\n+    struct Foo { f: uint, g: uint }\n+    ...\n+    fn add(p: &mut uint, v: uint) {\n+        *p += v;\n+    }\n+    ...\n+    fn consume(x: ~Foo) -> uint {\n+        x.f + x.g\n+    }\n+    fn weird() {\n+        let mut x: ~Foo = ~Foo { ... };\n+        'a: add(&mut (*x).f, consume(x)) // (*)\n+    }\n+\n+In this case, there is only one borrow, but the second argument is\n+`consume(x)` instead of a second borrow. Because `consume()` is\n+declared to take a `~Foo`, it will in fact free the pointer `x` when\n+it has finished executing. If it is not obvious why this is\n+troublesome, consider this expanded version of that call:\n+\n+    'a: {\n+        'a_arg1: let a_temp1: ... = add;\n+        'a_arg2: let a_temp2: &'a_call mut uint = &'a_call mut (*x).f;\n+        'a_arg3_: let a_temp3: uint = {\n+            let b_temp1: ... = consume;\n+            let b_temp2: ~Foo = x;\n+            'b_call: b_temp1(x)\n+        };\n+        'a_call: a_temp1(a_temp2, a_temp3)\n+    }\n+\n+In this example, we will have borrowed the first argument before `x`\n+is freed and then free `x` during evaluation of the second\n+argument. This causes `a_temp2` to be invalidated.\n+\n+Of course the loans computed from the borrow expression are supposed\n+to prevent this situation.  But if we just considered the loans from\n+`MUTATE((*x).f, 'a_call, Total)`, the resulting loans would be:\n+\n+    ((*x).f, 'a_call, Total,   Mut)\n+    (*x,     'a_call, Partial, Mut)\n+    (x,      'a_call, Partial, Mut)\n+\n+Because these loans are only in scope for `'a_call`, they do nothing\n+to prevent the move that occurs evaluating the second argument.\n+\n+The way that we solve this is to say that if you have a borrow\n+expression `&'LT_P mut LV` which itself occurs in the lifetime\n+`'LT_B`, then the resulting loans are:\n+\n+    MUTATE(LV, LT_P, Total) + ALIAS(LV, LUB(LT_P, LT_B), Total)\n+\n+The call to MUTATE is what we've seen so far.  The second part\n+expresses the idea that the expression LV will be evaluated starting\n+at LT_B until the end of LT_P.  Now, in the normal case, LT_P >= LT_B,\n+and so the second set of loans that result from a ALIAS are basically\n+a no-op.  However, in the case of an argument where the evaluation of\n+the borrow occurs before the interval where the resulting pointer will\n+be used, this ALIAS is important.\n+\n+In the case of our example, it would produce a set of loans like:\n+\n+    ((*x).f, 'a, Total, Const)\n+    (*x, 'a, Total, Const)\n+    (x, 'a, Total, Imm)\n+\n+The scope of these loans is `'a = LUB('a_arg2, 'a_call)`, and so they\n+encompass all subsequent arguments.  The first set of loans are Const\n+loans, which basically just prevent moves.  However, when we cross\n+over the dereference of the owned pointer `x`, the rule for ALIAS\n+specifies that `x` must be frozen, and hence the final loan is an Imm\n+loan.  In any case the troublesome second argument would be flagged\n+as an error.\n+\n+# Maps that are created\n+\n+Borrowck results in two maps.\n+\n+- `root_map`: identifies those expressions or patterns whose result\n+  needs to be rooted. Conceptually the root_map maps from an\n+  expression or pattern node to a `node_id` identifying the scope for\n+  which the expression must be rooted (this `node_id` should identify\n+  a block or call). The actual key to the map is not an expression id,\n+  however, but a `root_map_key`, which combines an expression id with a\n+  deref count and is used to cope with auto-deref.\n+\n+*/"}, {"sha": "fd1f6f5c450af53c1bec004cc3575be8f93e2101", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "removed", "additions": 0, "deletions": 641, "changes": 641, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fd6e42a904723c99383e684ddeaf02f01d972/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fd6e42a904723c99383e684ddeaf02f01d972/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=bd5fd6e42a904723c99383e684ddeaf02f01d972", "patch": "@@ -1,641 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ----------------------------------------------------------------------\n-// Gathering loans\n-//\n-// The borrow check proceeds in two phases. In phase one, we gather the full\n-// set of loans that are required at any point.  These are sorted according to\n-// their associated scopes.  In phase two, checking loans, we will then make\n-// sure that all of these loans are honored.\n-\n-use middle::borrowck::preserve::{PreserveCondition, PcOk, PcIfPure};\n-use middle::borrowck::{Loan, bckerr, bckres, BorrowckCtxt, err_mutbl};\n-use middle::borrowck::{LoanKind, TotalFreeze, PartialFreeze,\n-                       TotalTake, PartialTake, Immobile};\n-use middle::borrowck::ReqMaps;\n-use middle::borrowck::loan;\n-use middle::mem_categorization::{cmt, mem_categorization_ctxt};\n-use middle::pat_util;\n-use middle::ty::{ty_region};\n-use middle::ty;\n-use util::common::indenter;\n-use util::ppaux::{Repr, region_to_str};\n-\n-use core::hashmap::{HashSet, HashMap};\n-use syntax::ast::{m_const, m_imm, m_mutbl};\n-use syntax::ast;\n-use syntax::codemap::span;\n-use syntax::print::pprust;\n-use syntax::visit;\n-\n-/// Context used while gathering loans:\n-///\n-/// - `bccx`: the the borrow check context\n-/// - `req_maps`: the maps computed by `gather_loans()`, see def'n of the\n-///   struct `ReqMaps` for more info\n-/// - `item_ub`: the id of the block for the enclosing fn/method item\n-/// - `root_ub`: the id of the outermost block for which we can root\n-///   an `@T`.  This is the id of the innermost enclosing\n-///   loop or function body.\n-///\n-/// The role of `root_ub` is to prevent us from having to accumulate\n-/// vectors of rooted items at runtime.  Consider this case:\n-///\n-///     fn foo(...) -> int {\n-///         let mut ptr: &int;\n-///         while some_cond {\n-///             let x: @int = ...;\n-///             ptr = &*x;\n-///         }\n-///         *ptr\n-///     }\n-///\n-/// If we are not careful here, we would infer the scope of the borrow `&*x`\n-/// to be the body of the function `foo()` as a whole.  We would then\n-/// have root each `@int` that is produced, which is an unbounded number.\n-/// No good.  Instead what will happen is that `root_ub` will be set to the\n-/// body of the while loop and we will refuse to root the pointer `&*x`\n-/// because it would have to be rooted for a region greater than `root_ub`.\n-struct GatherLoanCtxt {\n-    bccx: @BorrowckCtxt,\n-    req_maps: ReqMaps,\n-    item_ub: ast::node_id,\n-    root_ub: ast::node_id,\n-    ignore_adjustments: HashSet<ast::node_id>\n-}\n-\n-pub fn gather_loans(bccx: @BorrowckCtxt, crate: @ast::crate) -> ReqMaps {\n-    let glcx = @mut GatherLoanCtxt {\n-        bccx: bccx,\n-        req_maps: ReqMaps { req_loan_map: HashMap::new(),\n-                            pure_map: HashMap::new() },\n-        item_ub: 0,\n-        root_ub: 0,\n-        ignore_adjustments: HashSet::new()\n-    };\n-    let v = visit::mk_vt(@visit::Visitor {visit_expr: req_loans_in_expr,\n-                                          visit_fn: req_loans_in_fn,\n-                                          visit_stmt: add_stmt_to_map,\n-                                          .. *visit::default_visitor()});\n-    visit::visit_crate(crate, glcx, v);\n-    let @GatherLoanCtxt{req_maps, _} = glcx;\n-    return req_maps;\n-}\n-\n-fn req_loans_in_fn(fk: &visit::fn_kind,\n-                   decl: &ast::fn_decl,\n-                   body: &ast::blk,\n-                   sp: span,\n-                   id: ast::node_id,\n-                   self: @mut GatherLoanCtxt,\n-                   v: visit::vt<@mut GatherLoanCtxt>) {\n-    // see explanation attached to the `root_ub` field:\n-    let old_item_id = self.item_ub;\n-    let old_root_ub = self.root_ub;\n-    self.root_ub = body.node.id;\n-\n-    match *fk {\n-        visit::fk_anon(*) | visit::fk_fn_block(*) => {}\n-        visit::fk_item_fn(*) | visit::fk_method(*) => {\n-            self.item_ub = body.node.id;\n-        }\n-    }\n-\n-    visit::visit_fn(fk, decl, body, sp, id, self, v);\n-    self.root_ub = old_root_ub;\n-    self.item_ub = old_item_id;\n-}\n-\n-fn req_loans_in_expr(ex: @ast::expr,\n-                     self: @mut GatherLoanCtxt,\n-                     vt: visit::vt<@mut GatherLoanCtxt>) {\n-    let bccx = self.bccx;\n-    let tcx = bccx.tcx;\n-    let old_root_ub = self.root_ub;\n-\n-    debug!(\"req_loans_in_expr(expr=%?/%s)\",\n-           ex.id, pprust::expr_to_str(ex, tcx.sess.intr()));\n-\n-    // If this expression is borrowed, have to ensure it remains valid:\n-    {\n-        let mut this = &mut *self;\n-        if !this.ignore_adjustments.contains(&ex.id) {\n-            for tcx.adjustments.find(&ex.id).each |&adjustments| {\n-                this.guarantee_adjustments(ex, *adjustments);\n-            }\n-        }\n-    }\n-\n-    // Special checks for various kinds of expressions:\n-    match ex.node {\n-      ast::expr_addr_of(mutbl, base) => {\n-        let base_cmt = self.bccx.cat_expr(base);\n-\n-        // make sure that the thing we are pointing out stays valid\n-        // for the lifetime `scope_r` of the resulting ptr:\n-        let scope_r = ty_region(tcx, ex.span, tcx.ty(ex));\n-        self.guarantee_valid(base_cmt, mutbl, scope_r);\n-        visit::visit_expr(ex, self, vt);\n-      }\n-\n-      ast::expr_match(ex_v, ref arms) => {\n-        let cmt = self.bccx.cat_expr(ex_v);\n-        for (*arms).each |arm| {\n-            for arm.pats.each |pat| {\n-                self.gather_pat(cmt, *pat, arm.body.node.id, ex.id);\n-            }\n-        }\n-        visit::visit_expr(ex, self, vt);\n-      }\n-\n-      ast::expr_index(rcvr, _) |\n-      ast::expr_binary(_, rcvr, _) |\n-      ast::expr_unary(_, rcvr) |\n-      ast::expr_assign_op(_, rcvr, _)\n-      if self.bccx.method_map.contains_key(&ex.id) => {\n-        // Receivers in method calls are always passed by ref.\n-        //\n-        // Here, in an overloaded operator, the call is this expression,\n-        // and hence the scope of the borrow is this call.\n-        //\n-        // FIX? / NOT REALLY---technically we should check the other\n-        // argument and consider the argument mode.  But how annoying.\n-        // And this problem when goes away when argument modes are\n-        // phased out.  So I elect to leave this undone.\n-        let scope_r = ty::re_scope(ex.id);\n-        let rcvr_cmt = self.bccx.cat_expr(rcvr);\n-        self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n-\n-        // FIXME (#3387): Total hack: Ignore adjustments for the left-hand\n-        // side. Their regions will be inferred to be too large.\n-        self.ignore_adjustments.insert(rcvr.id);\n-\n-        visit::visit_expr(ex, self, vt);\n-      }\n-\n-      // FIXME--#3387\n-      // ast::expr_binary(_, lhs, rhs) => {\n-      //     // Universal comparison operators like ==, >=, etc\n-      //     // take their arguments by reference.\n-      //     let lhs_ty = ty::expr_ty(self.tcx(), lhs);\n-      //     if !ty::type_is_scalar(lhs_ty) {\n-      //         let scope_r = ty::re_scope(ex.id);\n-      //         let lhs_cmt = self.bccx.cat_expr(lhs);\n-      //         self.guarantee_valid(lhs_cmt, m_imm, scope_r);\n-      //         let rhs_cmt = self.bccx.cat_expr(rhs);\n-      //         self.guarantee_valid(rhs_cmt, m_imm, scope_r);\n-      //     }\n-      //     visit::visit_expr(ex, self, vt);\n-      // }\n-\n-      ast::expr_field(rcvr, _, _)\n-      if self.bccx.method_map.contains_key(&ex.id) => {\n-        // Receivers in method calls are always passed by ref.\n-        //\n-        // Here, the field a.b is in fact a closure.  Eventually, this\n-        // should be an &fn, but for now it's an @fn.  In any case,\n-        // the enclosing scope is either the call where it is a rcvr\n-        // (if used like `a.b(...)`), the call where it's an argument\n-        // (if used like `x(a.b)`), or the block (if used like `let x\n-        // = a.b`).\n-        let scope_r = self.tcx().region_maps.encl_region(ex.id);\n-        let rcvr_cmt = self.bccx.cat_expr(rcvr);\n-        self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n-        visit::visit_expr(ex, self, vt);\n-      }\n-\n-      // see explanation attached to the `root_ub` field:\n-      ast::expr_while(cond, ref body) => {\n-        // during the condition, can only root for the condition\n-        self.root_ub = cond.id;\n-        (vt.visit_expr)(cond, self, vt);\n-\n-        // during body, can only root for the body\n-        self.root_ub = body.node.id;\n-        (vt.visit_block)(body, self, vt);\n-      }\n-\n-      // see explanation attached to the `root_ub` field:\n-      ast::expr_loop(ref body, _) => {\n-        self.root_ub = body.node.id;\n-        visit::visit_expr(ex, self, vt);\n-      }\n-\n-      _ => {\n-        visit::visit_expr(ex, self, vt);\n-      }\n-    }\n-\n-    // Check any contained expressions:\n-\n-    self.root_ub = old_root_ub;\n-}\n-\n-pub impl GatherLoanCtxt {\n-    fn tcx(&mut self) -> ty::ctxt { self.bccx.tcx }\n-\n-    fn guarantee_adjustments(&mut self,\n-                             expr: @ast::expr,\n-                             adjustment: &ty::AutoAdjustment) {\n-        debug!(\"guarantee_adjustments(expr=%s, adjustment=%?)\",\n-               expr.repr(self.tcx()), adjustment);\n-        let _i = indenter();\n-\n-        match *adjustment {\n-            ty::AutoAddEnv(*) => {\n-                debug!(\"autoaddenv -- no autoref\");\n-                return;\n-            }\n-\n-            ty::AutoDerefRef(\n-                ty::AutoDerefRef {\n-                    autoref: None, _ }) => {\n-                debug!(\"no autoref\");\n-                return;\n-            }\n-\n-            ty::AutoDerefRef(\n-                ty::AutoDerefRef {\n-                    autoref: Some(ref autoref),\n-                    autoderefs: autoderefs}) => {\n-                let mcx = &mem_categorization_ctxt {\n-                    tcx: self.tcx(),\n-                    method_map: self.bccx.method_map};\n-                let cmt = mcx.cat_expr_autoderefd(expr, autoderefs);\n-                debug!(\"after autoderef, cmt=%s\", self.bccx.cmt_to_repr(cmt));\n-\n-                match autoref.kind {\n-                    ty::AutoPtr => {\n-                        self.guarantee_valid(cmt,\n-                                             autoref.mutbl,\n-                                             autoref.region)\n-                    }\n-                    ty::AutoBorrowVec | ty::AutoBorrowVecRef => {\n-                        let cmt_index = mcx.cat_index(expr, cmt);\n-                        self.guarantee_valid(cmt_index,\n-                                             autoref.mutbl,\n-                                             autoref.region)\n-                    }\n-                    ty::AutoBorrowFn => {\n-                        let cmt_deref = mcx.cat_deref_fn(expr, cmt, 0);\n-                        self.guarantee_valid(cmt_deref,\n-                                             autoref.mutbl,\n-                                             autoref.region)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // guarantees that addr_of(cmt) will be valid for the duration of\n-    // `static_scope_r`, or reports an error.  This may entail taking\n-    // out loans, which will be added to the `req_loan_map`.  This can\n-    // also entail \"rooting\" GC'd pointers, which means ensuring\n-    // dynamically that they are not freed.\n-    fn guarantee_valid(&mut self,\n-                       cmt: cmt,\n-                       req_mutbl: ast::mutability,\n-                       scope_r: ty::Region)\n-    {\n-\n-        let loan_kind = match req_mutbl {\n-            m_mutbl => TotalTake,\n-            m_imm => TotalFreeze,\n-            m_const => Immobile\n-        };\n-\n-        self.bccx.stats.guaranteed_paths += 1;\n-\n-        debug!(\"guarantee_valid(cmt=%s, req_mutbl=%?, \\\n-                loan_kind=%?, scope_r=%s)\",\n-               self.bccx.cmt_to_repr(cmt),\n-               req_mutbl,\n-               loan_kind,\n-               region_to_str(self.tcx(), scope_r));\n-        let _i = indenter();\n-\n-        match cmt.lp {\n-          // If this expression is a loanable path, we MUST take out a\n-          // loan.  This is somewhat non-obvious.  You might think,\n-          // for example, that if we have an immutable local variable\n-          // `x` whose value is being borrowed, we could rely on `x`\n-          // not to change.  This is not so, however, because even\n-          // immutable locals can be moved.  So we take out a loan on\n-          // `x`, guaranteeing that it remains immutable for the\n-          // duration of the reference: if there is an attempt to move\n-          // it within that scope, the loan will be detected and an\n-          // error will be reported.\n-          Some(_) => {\n-              match loan::loan(self.bccx, cmt, scope_r, loan_kind) {\n-                  Err(ref e) => { self.bccx.report((*e)); }\n-                  Ok(loans) => {\n-                      self.add_loans(cmt, loan_kind, scope_r, loans);\n-                  }\n-              }\n-          }\n-\n-          // The path is not loanable: in that case, we must try and\n-          // preserve it dynamically (or see that it is preserved by\n-          // virtue of being rooted in some immutable path).  We must\n-          // also check that the mutability of the desired pointer\n-          // matches with the actual mutability (but if an immutable\n-          // pointer is desired, that is ok as long as we are pure)\n-          None => {\n-            let result: bckres<PreserveCondition> = {\n-                do self.check_mutbl(loan_kind, cmt).chain |pc1| {\n-                    do self.bccx.preserve(cmt, scope_r,\n-                                          self.item_ub,\n-                                          self.root_ub).chain |pc2| {\n-                        Ok(pc1.combine(pc2))\n-                    }\n-                }\n-            };\n-\n-            match result {\n-                Ok(PcOk) => {\n-                    debug!(\"result of preserve: PcOk\");\n-\n-                    // we were able guarantee the validity of the ptr,\n-                    // perhaps by rooting or because it is immutably\n-                    // rooted.  good.\n-                    self.bccx.stats.stable_paths += 1;\n-                }\n-                Ok(PcIfPure(ref e)) => {\n-                    debug!(\"result of preserve: %?\", PcIfPure((*e)));\n-\n-                    // we are only able to guarantee the validity if\n-                    // the scope is pure\n-                    match scope_r {\n-                        ty::re_scope(pure_id) => {\n-                            // if the scope is some block/expr in the\n-                            // fn, then just require that this scope\n-                            // be pure\n-                            self.req_maps.pure_map.insert(pure_id, *e);\n-                            self.bccx.stats.req_pure_paths += 1;\n-\n-                            debug!(\"requiring purity for scope %?\",\n-                                   scope_r);\n-\n-                            if self.tcx().sess.borrowck_note_pure() {\n-                                self.bccx.span_note(\n-                                    cmt.span,\n-                                    fmt!(\"purity required\"));\n-                            }\n-                        }\n-                        _ => {\n-                            // otherwise, we can't enforce purity for\n-                            // that scope, so give up and report an\n-                            // error\n-                            self.bccx.report((*e));\n-                        }\n-                    }\n-                }\n-                Err(ref e) => {\n-                    // we cannot guarantee the validity of this pointer\n-                    debug!(\"result of preserve: error\");\n-                    self.bccx.report((*e));\n-                }\n-            }\n-          }\n-        }\n-    }\n-\n-    // Check that the pat `cmt` is compatible with the required\n-    // mutability, presuming that it can be preserved to stay alive\n-    // long enough.\n-    //\n-    // For example, if you have an expression like `&x.f` where `x`\n-    // has type `@mut{f:int}`, this check might fail because `&x.f`\n-    // reqires an immutable pointer, but `f` lives in (aliased)\n-    // mutable memory.\n-    fn check_mutbl(&mut self,\n-                   loan_kind: LoanKind,\n-                   cmt: cmt)\n-                -> bckres<PreserveCondition> {\n-        debug!(\"check_mutbl(loan_kind=%?, cmt.mutbl=%?)\",\n-               loan_kind, cmt.mutbl);\n-\n-        match loan_kind {\n-            Immobile => Ok(PcOk),\n-\n-            TotalTake | PartialTake => {\n-                if cmt.mutbl.is_mutable() {\n-                    Ok(PcOk)\n-                } else {\n-                    Err(bckerr { cmt: cmt, code: err_mutbl(loan_kind) })\n-                }\n-            }\n-\n-            TotalFreeze | PartialFreeze => {\n-                if cmt.mutbl.is_immutable() {\n-                    Ok(PcOk)\n-                } else if cmt.cat.is_mutable_box() {\n-                    Ok(PcOk)\n-                } else {\n-                    // Eventually:\n-                    let e = bckerr {cmt: cmt,\n-                                    code: err_mutbl(loan_kind)};\n-                    Ok(PcIfPure(e))\n-                }\n-            }\n-        }\n-    }\n-\n-    fn add_loans(&mut self,\n-                 cmt: cmt,\n-                 loan_kind: LoanKind,\n-                 scope_r: ty::Region,\n-                 loans: ~[Loan]) {\n-        if loans.len() == 0 {\n-            return;\n-        }\n-\n-        // Normally we wouldn't allow `re_free` here. However, in this case\n-        // it should be sound. Below is nmatsakis' reasoning:\n-        //\n-        // Perhaps [this permits] a function kind of like this one here, which\n-        // consumes one mut pointer and returns a narrower one:\n-        //\n-        //     struct Foo { f: int }\n-        //     fn foo(p: &'v mut Foo) -> &'v mut int { &mut p.f }\n-        //\n-        // I think this should work fine but there is more subtlety to it than\n-        // I at first imagined. Unfortunately it's a very important use case,\n-        // I think, so it really ought to work. The changes you [pcwalton]\n-        // made to permit re_free() do permit this case, I think, but I'm not\n-        // sure what else they permit. I have to think that over a bit.\n-        //\n-        // Ordinarily, a loan with scope re_free wouldn't make sense, because\n-        // you couldn't enforce it. But in this case, your function signature\n-        // informs the caller that you demand exclusive access to p and its\n-        // contents for the lifetime v. Since borrowed pointers are\n-        // non-copyable, they must have (a) made a borrow which will enforce\n-        // those conditions and then (b) given you the resulting pointer.\n-        // Therefore, they should be respecting the loan. So it actually seems\n-        // that it's ok in this case to have a loan with re_free, so long as\n-        // the scope of the loan is no greater than the region pointer on\n-        // which it is based. Neat but not something I had previously\n-        // considered all the way through. (Note that we already rely on\n-        // similar reasoning to permit you to return borrowed pointers into\n-        // immutable structures, this is just the converse I suppose)\n-\n-        let scope_id = match scope_r {\n-            ty::re_scope(scope_id) |\n-            ty::re_free(ty::FreeRegion {scope_id, _}) => {\n-                scope_id\n-            }\n-            _ => {\n-                self.bccx.tcx.sess.span_bug(\n-                    cmt.span,\n-                    fmt!(\"loans required but scope is scope_region is %s \\\n-                          (%?)\",\n-                         region_to_str(self.tcx(), scope_r),\n-                         scope_r));\n-            }\n-        };\n-\n-        self.add_loans_to_scope_id(scope_id, loans);\n-\n-        if loan_kind.is_freeze() && !cmt.mutbl.is_immutable() {\n-            self.bccx.stats.loaned_paths_imm += 1;\n-\n-            if self.tcx().sess.borrowck_note_loan() {\n-                self.bccx.span_note(\n-                    cmt.span,\n-                    fmt!(\"immutable loan required\"));\n-            }\n-        } else {\n-            self.bccx.stats.loaned_paths_same += 1;\n-        }\n-    }\n-\n-    fn add_loans_to_scope_id(&mut self,\n-                             scope_id: ast::node_id,\n-                             loans: ~[Loan]) {\n-        debug!(\"adding %u loans to scope_id %?: %s\",\n-               loans.len(), scope_id,\n-               str::connect(loans.map(|l| self.bccx.loan_to_repr(l)), \", \"));\n-        match self.req_maps.req_loan_map.find(&scope_id) {\n-            Some(req_loans) => {\n-                req_loans.push_all(loans);\n-                return;\n-            }\n-            None => {}\n-        }\n-        self.req_maps.req_loan_map.insert(scope_id, @mut loans);\n-    }\n-\n-    fn gather_pat(@mut self,\n-                  discr_cmt: cmt,\n-                  root_pat: @ast::pat,\n-                  arm_id: ast::node_id,\n-                  match_id: ast::node_id) {\n-        do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n-            match pat.node {\n-              ast::pat_ident(bm, _, _) if self.pat_is_binding(pat) => {\n-                match bm {\n-                  ast::bind_by_ref(mutbl) => {\n-                    // ref x or ref x @ p --- creates a ptr which must\n-                    // remain valid for the scope of the match\n-\n-                    // find the region of the resulting pointer (note that\n-                    // the type of such a pattern will *always* be a\n-                    // region pointer)\n-                    let scope_r = ty_region(self.tcx(), pat.span,\n-                                            self.tcx().ty(pat));\n-\n-                    // if the scope of the region ptr turns out to be\n-                    // specific to this arm, wrap the categorization with\n-                    // a cat_discr() node.  There is a detailed discussion\n-                    // of the function of this node in method preserve():\n-                    let arm_scope = ty::re_scope(arm_id);\n-                    if self.bccx.is_subregion_of(scope_r, arm_scope) {\n-                        let cmt_discr = self.bccx.cat_discr(cmt, match_id);\n-                        self.guarantee_valid(cmt_discr, mutbl, scope_r);\n-                    } else {\n-                        self.guarantee_valid(cmt, mutbl, scope_r);\n-                    }\n-                  }\n-                  ast::bind_by_copy | ast::bind_infer => {\n-                    // Nothing to do here; neither copies nor moves induce\n-                    // borrows.\n-                  }\n-                }\n-              }\n-\n-              ast::pat_vec(_, Some(slice_pat), _) => {\n-                  // The `slice_pat` here creates a slice into the\n-                  // original vector.  This is effectively a borrow of\n-                  // the elements of the vector being matched.\n-\n-                  let slice_ty = self.tcx().ty(slice_pat);\n-                  let (slice_mutbl, slice_r) =\n-                      self.vec_slice_info(slice_pat, slice_ty);\n-                  let mcx = self.bccx.mc_ctxt();\n-                  let cmt_index = mcx.cat_index(slice_pat, cmt);\n-                  self.guarantee_valid(cmt_index, slice_mutbl, slice_r);\n-              }\n-\n-              _ => {}\n-            }\n-        }\n-    }\n-\n-    fn vec_slice_info(@mut self,\n-                      pat: @ast::pat,\n-                      slice_ty: ty::t) -> (ast::mutability, ty::Region) {\n-        /*!\n-         *\n-         * In a pattern like [a, b, ..c], normally `c` has slice type,\n-         * but if you have [a, b, ..ref c], then the type of `ref c`\n-         * will be `&&[]`, so to extract the slice details we have\n-         * to recurse through rptrs.\n-         */\n-\n-        match ty::get(slice_ty).sty {\n-            ty::ty_evec(slice_mt, ty::vstore_slice(slice_r)) => {\n-                (slice_mt.mutbl, slice_r)\n-            }\n-\n-            ty::ty_rptr(_, ref mt) => {\n-                self.vec_slice_info(pat, mt.ty)\n-            }\n-\n-            _ => {\n-                self.tcx().sess.span_bug(\n-                    pat.span,\n-                    fmt!(\"Type of slice pattern is not a slice\"));\n-            }\n-        }\n-    }\n-\n-    fn pat_is_variant_or_struct(@mut self, pat: @ast::pat) -> bool {\n-        pat_util::pat_is_variant_or_struct(self.bccx.tcx.def_map, pat)\n-    }\n-\n-    fn pat_is_binding(@mut self, pat: @ast::pat) -> bool {\n-        pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n-    }\n-}\n-\n-// Setting up info that preserve needs.\n-// This is just the most convenient place to do it.\n-fn add_stmt_to_map(stmt: @ast::stmt,\n-                   self: @mut GatherLoanCtxt,\n-                   vt: visit::vt<@mut GatherLoanCtxt>) {\n-    match stmt.node {\n-        ast::stmt_expr(_, id) | ast::stmt_semi(_, id) => {\n-            self.bccx.stmt_map.insert(id);\n-        }\n-        _ => ()\n-    }\n-    visit::visit_stmt(stmt, self, vt);\n-}"}, {"sha": "330d60a59d3ae598bbd347c41732ecafb3b67c42", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -0,0 +1,347 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module implements the check that the lifetime of a borrow\n+//! does not exceed the lifetime of the value being borrowed.\n+\n+use core::prelude::*;\n+use middle::borrowck::*;\n+use mc = middle::mem_categorization;\n+use middle::ty;\n+use syntax::ast::{m_const, m_imm, m_mutbl};\n+use syntax::ast;\n+use syntax::codemap::span;\n+use util::ppaux::{note_and_explain_region};\n+\n+pub fn guarantee_lifetime(bccx: @BorrowckCtxt,\n+                          item_scope_id: ast::node_id,\n+                          root_scope_id: ast::node_id,\n+                          span: span,\n+                          cmt: mc::cmt,\n+                          loan_region: ty::Region,\n+                          loan_mutbl: ast::mutability) {\n+    debug!(\"guarantee_lifetime(cmt=%s, loan_region=%s)\",\n+           cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n+    let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n+                                         item_scope_id: item_scope_id,\n+                                         span: span,\n+                                         loan_region: loan_region,\n+                                         loan_mutbl: loan_mutbl,\n+                                         cmt_original: cmt,\n+                                         root_scope_id: root_scope_id};\n+    ctxt.check(cmt, None);\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Private\n+\n+struct GuaranteeLifetimeContext {\n+    bccx: @BorrowckCtxt,\n+\n+    // the node id of the function body for the enclosing item\n+    item_scope_id: ast::node_id,\n+\n+    // the node id of the innermost loop / function body; this is the\n+    // longest scope for which we can root managed boxes\n+    root_scope_id: ast::node_id,\n+\n+    span: span,\n+    loan_region: ty::Region,\n+    loan_mutbl: ast::mutability,\n+    cmt_original: mc::cmt\n+}\n+\n+impl GuaranteeLifetimeContext {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.bccx.tcx\n+    }\n+\n+    fn check(&self, cmt: mc::cmt, discr_scope: Option<ast::node_id>) {\n+        //! Main routine. Walks down `cmt` until we find the \"guarantor\".\n+\n+        match cmt.cat {\n+            mc::cat_rvalue |\n+            mc::cat_implicit_self |\n+            mc::cat_copied_upvar(*) |\n+            mc::cat_local(*) |\n+            mc::cat_arg(*) |\n+            mc::cat_self(*) |\n+            mc::cat_deref(_, _, mc::region_ptr(*)) |\n+            mc::cat_deref(_, _, mc::unsafe_ptr) => {\n+                let scope = self.scope(cmt);\n+                self.check_scope(scope)\n+            }\n+\n+            mc::cat_stack_upvar(cmt) => {\n+                self.check(cmt, discr_scope)\n+            }\n+\n+            mc::cat_static_item => {\n+            }\n+\n+            mc::cat_deref(base, derefs, mc::gc_ptr(ptr_mutbl)) => {\n+                let base_scope = self.scope(base);\n+\n+                // See rule Freeze-Imm-Managed-Ptr-2 in doc.rs\n+                let omit_root = (\n+                    ptr_mutbl == m_imm &&\n+                    self.bccx.is_subregion_of(self.loan_region, base_scope) &&\n+                    base.mutbl.is_immutable() &&\n+                    !self.is_moved(base)\n+                );\n+\n+                if !omit_root {\n+                    self.check_root(cmt, base, derefs, ptr_mutbl, discr_scope);\n+                } else {\n+                    debug!(\"omitting root, base=%s, base_scope=%?\",\n+                           base.repr(self.tcx()), base_scope);\n+                }\n+            }\n+\n+            mc::cat_deref(base, _, mc::uniq_ptr(*)) |\n+            mc::cat_interior(base, _) => {\n+                self.check(base, discr_scope)\n+            }\n+\n+            mc::cat_discr(base, new_discr_scope) => {\n+                // Subtle: in a match, we must ensure that each binding\n+                // variable remains valid for the duration of the arm in\n+                // which it appears, presuming that this arm is taken.\n+                // But it is inconvenient in trans to root something just\n+                // for one arm.  Therefore, we insert a cat_discr(),\n+                // basically a special kind of category that says \"if this\n+                // value must be dynamically rooted, root it for the scope\n+                // `match_id`.\n+                //\n+                // As an example, consider this scenario:\n+                //\n+                //    let mut x = @Some(3);\n+                //    match *x { Some(y) {...} None {...} }\n+                //\n+                // Technically, the value `x` need only be rooted\n+                // in the `some` arm.  However, we evaluate `x` in trans\n+                // before we know what arm will be taken, so we just\n+                // always root it for the duration of the match.\n+                //\n+                // As a second example, consider *this* scenario:\n+                //\n+                //    let x = @mut @Some(3);\n+                //    match x { @@Some(y) {...} @@None {...} }\n+                //\n+                // Here again, `x` need only be rooted in the `some` arm.\n+                // In this case, the value which needs to be rooted is\n+                // found only when checking which pattern matches: but\n+                // this check is done before entering the arm.  Therefore,\n+                // even in this case we just choose to keep the value\n+                // rooted for the entire match.  This means the value will be\n+                // rooted even if the none arm is taken.  Oh well.\n+                //\n+                // At first, I tried to optimize the second case to only\n+                // root in one arm, but the result was suboptimal: first,\n+                // it interfered with the construction of phi nodes in the\n+                // arm, as we were adding code to root values before the\n+                // phi nodes were added.  This could have been addressed\n+                // with a second basic block.  However, the naive approach\n+                // also yielded suboptimal results for patterns like:\n+                //\n+                //    let x = @mut @...;\n+                //    match x { @@some_variant(y) | @@some_other_variant(y) =>\n+                //\n+                // The reason is that we would root the value once for\n+                // each pattern and not once per arm.  This is also easily\n+                // fixed, but it's yet more code for what is really quite\n+                // the corner case.\n+                //\n+                // Nonetheless, if you decide to optimize this case in the\n+                // future, you need only adjust where the cat_discr()\n+                // node appears to draw the line between what will be rooted\n+                // in the *arm* vs the *match*.\n+                self.check(base, Some(new_discr_scope))\n+            }\n+        }\n+    }\n+\n+    fn check_root(&self,\n+                  cmt_deref: mc::cmt,\n+                  cmt_base: mc::cmt,\n+                  derefs: uint,\n+                  ptr_mutbl: ast::mutability,\n+                  discr_scope: Option<ast::node_id>) {\n+        debug!(\"check_root(cmt_deref=%s, cmt_base=%s, derefs=%?, ptr_mutbl=%?, \\\n+                discr_scope=%?)\",\n+               cmt_deref.repr(self.tcx()),\n+               cmt_base.repr(self.tcx()),\n+               derefs,\n+               ptr_mutbl,\n+               discr_scope);\n+\n+        // Make sure that the loan does not exceed the maximum time\n+        // that we can root the value, dynamically.\n+        let root_region = ty::re_scope(self.root_scope_id);\n+        if !self.bccx.is_subregion_of(self.loan_region, root_region) {\n+            self.report_error(\n+                err_out_of_root_scope(root_region, self.loan_region));\n+            return;\n+        }\n+\n+        // Extract the scope id that indicates how long the rooting is required\n+        let root_scope = match self.loan_region {\n+            ty::re_scope(id) => id,\n+            _ => {\n+                // the check above should fail for anything is not re_scope\n+                self.bccx.tcx.sess.span_bug(\n+                    cmt_base.span,\n+                    fmt!(\"Cannot issue root for scope region: %?\",\n+                         self.loan_region));\n+            }\n+        };\n+\n+        // If inside of a match arm, expand the rooting to the entire\n+        // match. See the detailed discussion in `check()` above.\n+        let mut root_scope = match discr_scope {\n+            None => root_scope,\n+            Some(id) => {\n+                if self.bccx.is_subscope_of(root_scope, id) {\n+                    id\n+                } else {\n+                    root_scope\n+                }\n+            }\n+        };\n+\n+        // If we are borrowing the inside of an `@mut` box,\n+        // we need to dynamically mark it to prevent incompatible\n+        // borrows from happening later.\n+        let opt_dyna = match ptr_mutbl {\n+            m_imm | m_const => None,\n+            m_mutbl => {\n+                match self.loan_mutbl {\n+                    m_mutbl => Some(DynaMut),\n+                    m_imm | m_const => Some(DynaImm)\n+                }\n+            }\n+        };\n+\n+        // FIXME(#3511) grow to the nearest cleanup scope---this can\n+        // cause observable errors if freezing!\n+        if !self.bccx.tcx.region_maps.is_cleanup_scope(root_scope) {\n+            debug!(\"%? is not a cleanup scope, adjusting\", root_scope);\n+\n+            let cleanup_scope =\n+                self.bccx.tcx.region_maps.cleanup_scope(root_scope);\n+\n+            if opt_dyna.is_some() {\n+                self.tcx().sess.span_warn(\n+                    self.span,\n+                    fmt!(\"Dynamic freeze scope artifically extended \\\n+                          (see Issue #6248)\"));\n+                note_and_explain_region(\n+                    self.bccx.tcx,\n+                    \"managed value only needs to be frozen for \",\n+                    ty::re_scope(root_scope),\n+                    \"...\");\n+                note_and_explain_region(\n+                    self.bccx.tcx,\n+                    \"...but due to Issue #6248, it will be frozen for \",\n+                    ty::re_scope(cleanup_scope),\n+                    \"\");\n+            }\n+\n+            root_scope = cleanup_scope;\n+        }\n+\n+        // Add a record of what is required\n+        let rm_key = root_map_key {id: cmt_deref.id, derefs: derefs};\n+        let root_info = RootInfo {scope: root_scope, freeze: opt_dyna};\n+        self.bccx.root_map.insert(rm_key, root_info);\n+\n+        debug!(\"root_key: %? root_info: %?\", rm_key, root_info);\n+    }\n+\n+    fn check_scope(&self, max_scope: ty::Region) {\n+        //! Reports an error if `loan_region` is larger than `valid_scope`\n+\n+        if !self.bccx.is_subregion_of(self.loan_region, max_scope) {\n+            self.report_error(err_out_of_scope(max_scope, self.loan_region));\n+        }\n+    }\n+\n+    fn is_moved(&self, cmt: mc::cmt) -> bool {\n+        //! True if `cmt` is something that is potentially moved\n+        //! out of the current stack frame.\n+\n+        match cmt.guarantor().cat {\n+            mc::cat_local(id) |\n+            mc::cat_self(id) |\n+            mc::cat_arg(id) => {\n+                self.bccx.moved_variables_set.contains(&id)\n+            }\n+            mc::cat_rvalue |\n+            mc::cat_static_item |\n+            mc::cat_implicit_self |\n+            mc::cat_copied_upvar(*) |\n+            mc::cat_deref(*) => {\n+                false\n+            }\n+            r @ mc::cat_interior(*) |\n+            r @ mc::cat_stack_upvar(*) |\n+            r @ mc::cat_discr(*) => {\n+                self.tcx().sess.span_bug(\n+                    cmt.span,\n+                    fmt!(\"illegal guarantor category: %?\", r));\n+            }\n+        }\n+    }\n+\n+    fn scope(&self, cmt: mc::cmt) -> ty::Region {\n+        //! Returns the maximal region scope for the which the\n+        //! lvalue `cmt` is guaranteed to be valid without any\n+        //! rooting etc, and presuming `cmt` is not mutated.\n+\n+        match cmt.cat {\n+            mc::cat_rvalue => {\n+                ty::re_scope(self.bccx.tcx.region_maps.cleanup_scope(cmt.id))\n+            }\n+            mc::cat_implicit_self |\n+            mc::cat_copied_upvar(_) => {\n+                ty::re_scope(self.item_scope_id)\n+            }\n+            mc::cat_static_item => {\n+                ty::re_static\n+            }\n+            mc::cat_local(local_id) |\n+            mc::cat_arg(local_id) |\n+            mc::cat_self(local_id) => {\n+                self.bccx.tcx.region_maps.encl_region(local_id)\n+            }\n+            mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n+                ty::re_static\n+            }\n+            mc::cat_deref(_, _, mc::region_ptr(_, r)) => {\n+                r\n+            }\n+            mc::cat_deref(cmt, _, mc::uniq_ptr(*)) |\n+            mc::cat_deref(cmt, _, mc::gc_ptr(*)) |\n+            mc::cat_interior(cmt, _) |\n+            mc::cat_stack_upvar(cmt) |\n+            mc::cat_discr(cmt, _) => {\n+                self.scope(cmt)\n+            }\n+        }\n+    }\n+\n+    fn report_error(&self, code: bckerr_code) {\n+        self.bccx.report(BckError {\n+            cmt: self.cmt_original,\n+            span: self.span,\n+            code: code\n+        });\n+    }\n+}"}, {"sha": "5f3c5d977fef54bed40cdabcde0f24daf48d8dde", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "added", "additions": 636, "deletions": 0, "changes": 636, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -0,0 +1,636 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ----------------------------------------------------------------------\n+// Gathering loans\n+//\n+// The borrow check proceeds in two phases. In phase one, we gather the full\n+// set of loans that are required at any point.  These are sorted according to\n+// their associated scopes.  In phase two, checking loans, we will then make\n+// sure that all of these loans are honored.\n+\n+use core::prelude::*;\n+\n+use middle::borrowck::*;\n+use mc = middle::mem_categorization;\n+use middle::pat_util;\n+use middle::ty::{ty_region};\n+use middle::ty;\n+use util::common::indenter;\n+use util::ppaux::{Repr};\n+\n+use syntax::ast::{m_const, m_imm, m_mutbl};\n+use syntax::ast;\n+use syntax::ast_util::id_range;\n+use syntax::codemap::span;\n+use syntax::print::pprust;\n+use syntax::visit;\n+\n+mod lifetime;\n+mod restrictions;\n+\n+/// Context used while gathering loans:\n+///\n+/// - `bccx`: the the borrow check context\n+/// - `item_ub`: the id of the block for the enclosing fn/method item\n+/// - `root_ub`: the id of the outermost block for which we can root\n+///   an `@T`.  This is the id of the innermost enclosing\n+///   loop or function body.\n+///\n+/// The role of `root_ub` is to prevent us from having to accumulate\n+/// vectors of rooted items at runtime.  Consider this case:\n+///\n+///     fn foo(...) -> int {\n+///         let mut ptr: &int;\n+///         while some_cond {\n+///             let x: @int = ...;\n+///             ptr = &*x;\n+///         }\n+///         *ptr\n+///     }\n+///\n+/// If we are not careful here, we would infer the scope of the borrow `&*x`\n+/// to be the body of the function `foo()` as a whole.  We would then\n+/// have root each `@int` that is produced, which is an unbounded number.\n+/// No good.  Instead what will happen is that `root_ub` will be set to the\n+/// body of the while loop and we will refuse to root the pointer `&*x`\n+/// because it would have to be rooted for a region greater than `root_ub`.\n+struct GatherLoanCtxt {\n+    bccx: @BorrowckCtxt,\n+    id_range: id_range,\n+    all_loans: @mut ~[Loan],\n+    item_ub: ast::node_id,\n+    repeating_ids: ~[ast::node_id]\n+}\n+\n+pub fn gather_loans(bccx: @BorrowckCtxt,\n+                    body: &ast::blk) -> (id_range, @mut ~[Loan]) {\n+    let glcx = @mut GatherLoanCtxt {\n+        bccx: bccx,\n+        id_range: id_range::max(),\n+        all_loans: @mut ~[],\n+        item_ub: body.node.id,\n+        repeating_ids: ~[body.node.id]\n+    };\n+    let v = visit::mk_vt(@visit::Visitor {visit_expr: gather_loans_in_expr,\n+                                          visit_block: gather_loans_in_block,\n+                                          visit_fn: gather_loans_in_fn,\n+                                          visit_stmt: add_stmt_to_map,\n+                                          visit_pat: add_pat_to_id_range,\n+                                          .. *visit::default_visitor()});\n+    (v.visit_block)(body, glcx, v);\n+    return (glcx.id_range, glcx.all_loans);\n+}\n+\n+fn add_pat_to_id_range(p: @ast::pat,\n+                       self: @mut GatherLoanCtxt,\n+                       v: visit::vt<@mut GatherLoanCtxt>) {\n+    // NB: This visitor function just adds the pat ids into the id\n+    // range. We gather loans that occur in patterns using the\n+    // `gather_pat()` method below. Eventually these two should be\n+    // brought together.\n+    self.id_range.add(p.id);\n+    visit::visit_pat(p, self, v);\n+}\n+\n+fn gather_loans_in_fn(fk: &visit::fn_kind,\n+                      decl: &ast::fn_decl,\n+                      body: &ast::blk,\n+                      sp: span,\n+                      id: ast::node_id,\n+                      self: @mut GatherLoanCtxt,\n+                      v: visit::vt<@mut GatherLoanCtxt>) {\n+    match fk {\n+        // Do not visit items here, the outer loop in borrowck/mod\n+        // will visit them for us in turn.\n+        &visit::fk_item_fn(*) | &visit::fk_method(*) => {\n+            return;\n+        }\n+\n+        // Visit closures as part of the containing item.\n+        &visit::fk_anon(*) | &visit::fk_fn_block(*) => {\n+            self.push_repeating_id(body.node.id);\n+            visit::visit_fn(fk, decl, body, sp, id, self, v);\n+            self.pop_repeating_id(body.node.id);\n+        }\n+    }\n+}\n+\n+fn gather_loans_in_block(blk: &ast::blk,\n+                         self: @mut GatherLoanCtxt,\n+                         vt: visit::vt<@mut GatherLoanCtxt>) {\n+    self.id_range.add(blk.node.id);\n+    visit::visit_block(blk, self, vt);\n+}\n+\n+fn gather_loans_in_expr(ex: @ast::expr,\n+                        self: @mut GatherLoanCtxt,\n+                        vt: visit::vt<@mut GatherLoanCtxt>) {\n+    let bccx = self.bccx;\n+    let tcx = bccx.tcx;\n+\n+    debug!(\"gather_loans_in_expr(expr=%?/%s)\",\n+           ex.id, pprust::expr_to_str(ex, tcx.sess.intr()));\n+\n+    self.id_range.add(ex.id);\n+    self.id_range.add(ex.callee_id);\n+\n+    // If this expression is borrowed, have to ensure it remains valid:\n+    for tcx.adjustments.find(&ex.id).each |&adjustments| {\n+        self.guarantee_adjustments(ex, *adjustments);\n+    }\n+\n+    // Special checks for various kinds of expressions:\n+    match ex.node {\n+      ast::expr_addr_of(mutbl, base) => {\n+        let base_cmt = self.bccx.cat_expr(base);\n+\n+        // make sure that the thing we are pointing out stays valid\n+        // for the lifetime `scope_r` of the resulting ptr:\n+        let scope_r = ty_region(tcx, ex.span, ty::expr_ty(tcx, ex));\n+        self.guarantee_valid(ex.id, ex.span, base_cmt, mutbl, scope_r);\n+        visit::visit_expr(ex, self, vt);\n+      }\n+\n+      ast::expr_match(ex_v, ref arms) => {\n+        let cmt = self.bccx.cat_expr(ex_v);\n+        for arms.each |arm| {\n+            for arm.pats.each |pat| {\n+                self.gather_pat(cmt, *pat, arm.body.node.id, ex.id);\n+            }\n+        }\n+        visit::visit_expr(ex, self, vt);\n+      }\n+\n+      ast::expr_index(_, arg) |\n+      ast::expr_binary(_, _, arg)\n+      if self.bccx.method_map.contains_key(&ex.id) => {\n+          // Arguments in method calls are always passed by ref.\n+          //\n+          // Currently these do not use adjustments, so we have to\n+          // hardcode this check here (note that the receiver DOES use\n+          // adjustments).\n+          let scope_r = ty::re_scope(ex.id);\n+          let arg_cmt = self.bccx.cat_expr(arg);\n+          self.guarantee_valid(arg.id, arg.span, arg_cmt, m_imm, scope_r);\n+          visit::visit_expr(ex, self, vt);\n+      }\n+\n+      // see explanation attached to the `root_ub` field:\n+      ast::expr_while(cond, ref body) => {\n+          // during the condition, can only root for the condition\n+          self.push_repeating_id(cond.id);\n+          (vt.visit_expr)(cond, self, vt);\n+          self.pop_repeating_id(cond.id);\n+\n+          // during body, can only root for the body\n+          self.push_repeating_id(body.node.id);\n+          (vt.visit_block)(body, self, vt);\n+          self.pop_repeating_id(body.node.id);\n+      }\n+\n+      // see explanation attached to the `root_ub` field:\n+      ast::expr_loop(ref body, _) => {\n+          self.push_repeating_id(body.node.id);\n+          visit::visit_expr(ex, self, vt);\n+          self.pop_repeating_id(body.node.id);\n+      }\n+\n+      _ => {\n+        visit::visit_expr(ex, self, vt);\n+      }\n+    }\n+}\n+\n+pub impl GatherLoanCtxt {\n+    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n+\n+    fn push_repeating_id(&mut self, id: ast::node_id) {\n+        self.repeating_ids.push(id);\n+    }\n+\n+    fn pop_repeating_id(&mut self, id: ast::node_id) {\n+        let popped = self.repeating_ids.pop();\n+        assert!(id == popped);\n+    }\n+\n+    fn guarantee_adjustments(&mut self,\n+                             expr: @ast::expr,\n+                             adjustment: &ty::AutoAdjustment) {\n+        debug!(\"guarantee_adjustments(expr=%s, adjustment=%?)\",\n+               expr.repr(self.tcx()), adjustment);\n+        let _i = indenter();\n+\n+        match *adjustment {\n+            ty::AutoAddEnv(*) => {\n+                debug!(\"autoaddenv -- no autoref\");\n+                return;\n+            }\n+\n+            ty::AutoDerefRef(\n+                ty::AutoDerefRef {\n+                    autoref: None, _ }) => {\n+                debug!(\"no autoref\");\n+                return;\n+            }\n+\n+            ty::AutoDerefRef(\n+                ty::AutoDerefRef {\n+                    autoref: Some(ref autoref),\n+                    autoderefs: autoderefs}) => {\n+                let mcx = &mc::mem_categorization_ctxt {\n+                    tcx: self.tcx(),\n+                    method_map: self.bccx.method_map};\n+                let cmt = mcx.cat_expr_autoderefd(expr, autoderefs);\n+                debug!(\"after autoderef, cmt=%s\", cmt.repr(self.tcx()));\n+\n+                match *autoref {\n+                    ty::AutoPtr(r, m) => {\n+                        self.guarantee_valid(expr.id,\n+                                             expr.span,\n+                                             cmt,\n+                                             m,\n+                                             r)\n+                    }\n+                    ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n+                        let cmt_index = mcx.cat_index(expr, cmt);\n+                        self.guarantee_valid(expr.id,\n+                                             expr.span,\n+                                             cmt_index,\n+                                             m,\n+                                             r)\n+                    }\n+                    ty::AutoBorrowFn(r) => {\n+                        let cmt_deref = mcx.cat_deref_fn(expr, cmt, 0);\n+                        self.guarantee_valid(expr.id,\n+                                             expr.span,\n+                                             cmt_deref,\n+                                             m_imm,\n+                                             r)\n+                    }\n+                    ty::AutoUnsafe(_) => {}\n+                }\n+            }\n+        }\n+    }\n+\n+    // Guarantees that addr_of(cmt) will be valid for the duration of\n+    // `static_scope_r`, or reports an error.  This may entail taking\n+    // out loans, which will be added to the `req_loan_map`.  This can\n+    // also entail \"rooting\" GC'd pointers, which means ensuring\n+    // dynamically that they are not freed.\n+    fn guarantee_valid(&mut self,\n+                       borrow_id: ast::node_id,\n+                       borrow_span: span,\n+                       cmt: mc::cmt,\n+                       req_mutbl: ast::mutability,\n+                       loan_region: ty::Region)\n+    {\n+        debug!(\"guarantee_valid(borrow_id=%?, cmt=%s, \\\n+                req_mutbl=%?, loan_region=%?)\",\n+               borrow_id,\n+               cmt.repr(self.tcx()),\n+               req_mutbl,\n+               loan_region);\n+\n+        // a loan for the empty region can never be dereferenced, so\n+        // it is always safe\n+        if loan_region == ty::re_empty {\n+            return;\n+        }\n+\n+        let root_ub = { *self.repeating_ids.last() }; // FIXME(#5074)\n+\n+        // Check that the lifetime of the borrow does not exceed\n+        // the lifetime of the data being borrowed.\n+        lifetime::guarantee_lifetime(self.bccx, self.item_ub, root_ub,\n+                                     borrow_span, cmt, loan_region, req_mutbl);\n+\n+        // Check that we don't allow mutable borrows of non-mutable data.\n+        check_mutability(self.bccx, borrow_span, cmt, req_mutbl);\n+\n+        // Compute the restrictions that are required to enforce the\n+        // loan is safe.\n+        let restr = restrictions::compute_restrictions(\n+            self.bccx, borrow_span,\n+            cmt, self.restriction_set(req_mutbl));\n+\n+        // Create the loan record (if needed).\n+        let loan = match restr {\n+            restrictions::Safe => {\n+                // No restrictions---no loan record necessary\n+                return;\n+            }\n+\n+            restrictions::SafeIf(loan_path, restrictions) => {\n+                let loan_scope = match loan_region {\n+                    ty::re_scope(id) => id,\n+                    ty::re_free(ref fr) => fr.scope_id,\n+\n+                    ty::re_static => {\n+                        // If we get here, an error must have been\n+                        // reported in\n+                        // `lifetime::guarantee_lifetime()`, because\n+                        // the only legal ways to have a borrow with a\n+                        // static lifetime should not require\n+                        // restrictions. To avoid reporting derived\n+                        // errors, we just return here without adding\n+                        // any loans.\n+                        return;\n+                    }\n+\n+                    ty::re_empty |\n+                    ty::re_bound(*) |\n+                    ty::re_infer(*) => {\n+                        self.tcx().sess.span_bug(\n+                            cmt.span,\n+                            fmt!(\"Invalid borrow lifetime: %?\", loan_region));\n+                    }\n+                };\n+                debug!(\"loan_scope = %?\", loan_scope);\n+\n+                let gen_scope = self.compute_gen_scope(borrow_id, loan_scope);\n+                debug!(\"gen_scope = %?\", gen_scope);\n+\n+                let kill_scope = self.compute_kill_scope(loan_scope, loan_path);\n+                debug!(\"kill_scope = %?\", kill_scope);\n+\n+                if req_mutbl == m_mutbl {\n+                    self.mark_loan_path_as_mutated(loan_path);\n+                }\n+\n+                let all_loans = &mut *self.all_loans; // FIXME(#5074)\n+                Loan {\n+                    index: all_loans.len(),\n+                    loan_path: loan_path,\n+                    cmt: cmt,\n+                    mutbl: req_mutbl,\n+                    gen_scope: gen_scope,\n+                    kill_scope: kill_scope,\n+                    span: borrow_span,\n+                    restrictions: restrictions\n+                }\n+            }\n+        };\n+\n+        debug!(\"guarantee_valid(borrow_id=%?), loan=%s\",\n+               borrow_id, loan.repr(self.tcx()));\n+\n+        // let loan_path = loan.loan_path;\n+        // let loan_gen_scope = loan.gen_scope;\n+        // let loan_kill_scope = loan.kill_scope;\n+        self.all_loans.push(loan);\n+\n+        // if loan_gen_scope != borrow_id {\n+            // FIXME(#6268) Nested method calls\n+            //\n+            // Typically, the scope of the loan includes the point at\n+            // which the loan is originated. This\n+            // This is a subtle case. See the test case\n+            // <compile-fail/borrowck-bad-nested-calls-free.rs>\n+            // to see what we are guarding against.\n+\n+            //let restr = restrictions::compute_restrictions(\n+            //    self.bccx, borrow_span, cmt, RESTR_EMPTY);\n+            //let loan = {\n+            //    let all_loans = &mut *self.all_loans; // FIXME(#5074)\n+            //    Loan {\n+            //        index: all_loans.len(),\n+            //        loan_path: loan_path,\n+            //        cmt: cmt,\n+            //        mutbl: m_const,\n+            //        gen_scope: borrow_id,\n+            //        kill_scope: kill_scope,\n+            //        span: borrow_span,\n+            //        restrictions: restrictions\n+            //    }\n+        // }\n+\n+        fn check_mutability(bccx: @BorrowckCtxt,\n+                            borrow_span: span,\n+                            cmt: mc::cmt,\n+                            req_mutbl: ast::mutability) {\n+            match req_mutbl {\n+                m_const => {\n+                    // Data of any mutability can be lent as const.\n+                }\n+\n+                m_imm => {\n+                    match cmt.mutbl {\n+                        mc::McImmutable | mc::McDeclared | mc::McInherited => {\n+                            // both imm and mut data can be lent as imm;\n+                            // for mutable data, this is a freeze\n+                        }\n+                        mc::McReadOnly => {\n+                            bccx.report(BckError {span: borrow_span,\n+                                                  cmt: cmt,\n+                                                  code: err_mutbl(req_mutbl)});\n+                        }\n+                    }\n+                }\n+\n+                m_mutbl => {\n+                    // Only mutable data can be lent as mutable.\n+                    if !cmt.mutbl.is_mutable() {\n+                        bccx.report(BckError {span: borrow_span,\n+                                              cmt: cmt,\n+                                              code: err_mutbl(req_mutbl)});\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn restriction_set(&self, req_mutbl: ast::mutability) -> RestrictionSet {\n+        match req_mutbl {\n+            m_const => RESTR_EMPTY,\n+            m_imm   => RESTR_EMPTY | RESTR_MUTATE,\n+            m_mutbl => RESTR_EMPTY | RESTR_MUTATE | RESTR_FREEZE\n+        }\n+    }\n+\n+    fn mark_loan_path_as_mutated(&self, loan_path: @LoanPath) {\n+        //! For mutable loans of content whose mutability derives\n+        //! from a local variable, mark the mutability decl as necessary.\n+\n+        match *loan_path {\n+            LpVar(local_id) => {\n+                self.tcx().used_mut_nodes.insert(local_id);\n+            }\n+            LpExtend(base, mc::McInherited, _) => {\n+                self.mark_loan_path_as_mutated(base);\n+            }\n+            LpExtend(_, mc::McDeclared, _) |\n+            LpExtend(_, mc::McImmutable, _) |\n+            LpExtend(_, mc::McReadOnly, _) => {\n+            }\n+        }\n+    }\n+\n+    fn compute_gen_scope(&self,\n+                         borrow_id: ast::node_id,\n+                         loan_scope: ast::node_id) -> ast::node_id {\n+        //! Determine when to introduce the loan. Typically the loan\n+        //! is introduced at the point of the borrow, but in some cases,\n+        //! notably method arguments, the loan may be introduced only\n+        //! later, once it comes into scope.\n+\n+        let rm = self.bccx.tcx.region_maps;\n+        if rm.is_subscope_of(borrow_id, loan_scope) {\n+            borrow_id\n+        } else {\n+            loan_scope\n+        }\n+    }\n+\n+    fn compute_kill_scope(&self,\n+                          loan_scope: ast::node_id,\n+                          lp: @LoanPath) -> ast::node_id {\n+        //! Determine when the loan restrictions go out of scope.\n+        //! This is either when the lifetime expires or when the\n+        //! local variable which roots the loan-path goes out of scope,\n+        //! whichever happens faster.\n+        //!\n+        //! It may seem surprising that we might have a loan region\n+        //! larger than the variable which roots the loan-path; this can\n+        //! come about when variables of `&mut` type are re-borrowed,\n+        //! as in this example:\n+        //!\n+        //!     fn counter<'a>(v: &'a mut Foo) -> &'a mut uint {\n+        //!         &mut v.counter\n+        //!     }\n+        //!\n+        //! In this case, the borrowed pointer (`'a`) outlives the\n+        //! variable `v` that hosts it. Note that this doesn't come up\n+        //! with immutable `&` pointers, because borrows of such pointers\n+        //! do not require restrictions and hence do not cause a loan.\n+\n+        let rm = self.bccx.tcx.region_maps;\n+        let lexical_scope = rm.encl_scope(lp.node_id());\n+        if rm.is_subscope_of(lexical_scope, loan_scope) {\n+            lexical_scope\n+        } else {\n+            assert!(rm.is_subscope_of(loan_scope, lexical_scope));\n+            loan_scope\n+        }\n+    }\n+\n+    fn gather_pat(&mut self,\n+                  discr_cmt: mc::cmt,\n+                  root_pat: @ast::pat,\n+                  arm_body_id: ast::node_id,\n+                  match_id: ast::node_id) {\n+        do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n+            match pat.node {\n+              ast::pat_ident(bm, _, _) if self.pat_is_binding(pat) => {\n+                match bm {\n+                  ast::bind_by_ref(mutbl) => {\n+                    // ref x or ref x @ p --- creates a ptr which must\n+                    // remain valid for the scope of the match\n+\n+                    // find the region of the resulting pointer (note that\n+                    // the type of such a pattern will *always* be a\n+                    // region pointer)\n+                    let scope_r =\n+                        ty_region(self.tcx(), pat.span,\n+                                  ty::node_id_to_type(self.tcx(), pat.id));\n+\n+                    // if the scope of the region ptr turns out to be\n+                    // specific to this arm, wrap the categorization\n+                    // with a cat_discr() node.  There is a detailed\n+                    // discussion of the function of this node in\n+                    // `lifetime.rs`:\n+                    let arm_scope = ty::re_scope(arm_body_id);\n+                    if self.bccx.is_subregion_of(scope_r, arm_scope) {\n+                        let cmt_discr = self.bccx.cat_discr(cmt, match_id);\n+                        self.guarantee_valid(pat.id, pat.span,\n+                                             cmt_discr, mutbl, scope_r);\n+                    } else {\n+                        self.guarantee_valid(pat.id, pat.span,\n+                                             cmt, mutbl, scope_r);\n+                    }\n+                  }\n+                  ast::bind_by_copy | ast::bind_infer => {\n+                    // Nothing to do here; neither copies nor moves induce\n+                    // borrows.\n+                  }\n+                }\n+              }\n+\n+              ast::pat_vec(_, Some(slice_pat), _) => {\n+                  // The `slice_pat` here creates a slice into the\n+                  // original vector.  This is effectively a borrow of\n+                  // the elements of the vector being matched.\n+\n+                  let slice_ty = ty::node_id_to_type(self.tcx(),\n+                                                     slice_pat.id);\n+                  let (slice_mutbl, slice_r) =\n+                      self.vec_slice_info(slice_pat, slice_ty);\n+                  let mcx = self.bccx.mc_ctxt();\n+                  let cmt_index = mcx.cat_index(slice_pat, cmt);\n+                  self.guarantee_valid(pat.id, pat.span,\n+                                       cmt_index, slice_mutbl, slice_r);\n+              }\n+\n+              _ => {}\n+            }\n+        }\n+    }\n+\n+    fn vec_slice_info(&self,\n+                      pat: @ast::pat,\n+                      slice_ty: ty::t) -> (ast::mutability, ty::Region) {\n+        /*!\n+         *\n+         * In a pattern like [a, b, ..c], normally `c` has slice type,\n+         * but if you have [a, b, ..ref c], then the type of `ref c`\n+         * will be `&&[]`, so to extract the slice details we have\n+         * to recurse through rptrs.\n+         */\n+\n+        match ty::get(slice_ty).sty {\n+            ty::ty_evec(slice_mt, ty::vstore_slice(slice_r)) => {\n+                (slice_mt.mutbl, slice_r)\n+            }\n+\n+            ty::ty_rptr(_, ref mt) => {\n+                self.vec_slice_info(pat, mt.ty)\n+            }\n+\n+            _ => {\n+                self.tcx().sess.span_bug(\n+                    pat.span,\n+                    fmt!(\"Type of slice pattern is not a slice\"));\n+            }\n+        }\n+    }\n+\n+    fn pat_is_variant_or_struct(&self, pat: @ast::pat) -> bool {\n+        pat_util::pat_is_variant_or_struct(self.bccx.tcx.def_map, pat)\n+    }\n+\n+    fn pat_is_binding(&self, pat: @ast::pat) -> bool {\n+        pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n+    }\n+}\n+\n+// Setting up info that preserve needs.\n+// This is just the most convenient place to do it.\n+fn add_stmt_to_map(stmt: @ast::stmt,\n+                   self: @mut GatherLoanCtxt,\n+                   vt: visit::vt<@mut GatherLoanCtxt>) {\n+    match stmt.node {\n+        ast::stmt_expr(_, id) | ast::stmt_semi(_, id) => {\n+            self.bccx.stmt_map.insert(id);\n+        }\n+        _ => ()\n+    }\n+    visit::visit_stmt(stmt, self, vt);\n+}"}, {"sha": "0be4c67a9bc910ddd980ab4d340f0f100c49da97", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -0,0 +1,249 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Computes the restrictions that result from a borrow.\n+\n+use core::prelude::*;\n+use middle::borrowck::*;\n+use mc = middle::mem_categorization;\n+use middle::ty;\n+use syntax::ast::{m_const, m_imm, m_mutbl};\n+use syntax::codemap::span;\n+\n+pub enum RestrictionResult {\n+    Safe,\n+    SafeIf(@LoanPath, ~[Restriction])\n+}\n+\n+pub fn compute_restrictions(bccx: @BorrowckCtxt,\n+                            span: span,\n+                            cmt: mc::cmt,\n+                            restr: RestrictionSet) -> RestrictionResult {\n+    let ctxt = RestrictionsContext {\n+        bccx: bccx,\n+        span: span,\n+        cmt_original: cmt\n+    };\n+\n+    ctxt.compute(cmt, restr)\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Private\n+\n+struct RestrictionsContext {\n+    bccx: @BorrowckCtxt,\n+    span: span,\n+    cmt_original: mc::cmt\n+}\n+\n+impl RestrictionsContext {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.bccx.tcx\n+    }\n+\n+    fn compute(&self,\n+               cmt: mc::cmt,\n+               restrictions: RestrictionSet) -> RestrictionResult {\n+\n+        // Check for those cases where we cannot control the aliasing\n+        // and make sure that we are not being asked to.\n+        match cmt.freely_aliasable() {\n+            None => {}\n+            Some(cause) => {\n+                self.check_aliasing_permitted(cause, restrictions);\n+            }\n+        }\n+\n+        match cmt.cat {\n+            mc::cat_rvalue => {\n+                // Effectively, rvalues are stored into a\n+                // non-aliasable temporary on the stack. Since they\n+                // are inherently non-aliasable, they can only be\n+                // accessed later through the borrow itself and hence\n+                // must inherently comply with its terms.\n+                Safe\n+            }\n+\n+            mc::cat_local(local_id) |\n+            mc::cat_arg(local_id) |\n+            mc::cat_self(local_id) => {\n+                let lp = @LpVar(local_id);\n+                SafeIf(lp, ~[Restriction {loan_path: lp,\n+                                          set: restrictions}])\n+            }\n+\n+            mc::cat_interior(cmt_base, i @ mc::interior_variant(_)) => {\n+                // When we borrow the interior of an enum, we have to\n+                // ensure the enum itself is not mutated, because that\n+                // could cause the type of the memory to change.\n+                let result = self.compute(cmt_base, restrictions | RESTR_MUTATE);\n+                self.extend(result, cmt.mutbl, LpInterior(i), restrictions)\n+            }\n+\n+            mc::cat_interior(cmt_base, i @ mc::interior_tuple) |\n+            mc::cat_interior(cmt_base, i @ mc::interior_anon_field) |\n+            mc::cat_interior(cmt_base, i @ mc::interior_field(*)) |\n+            mc::cat_interior(cmt_base, i @ mc::interior_index(*)) => {\n+                // For all of these cases, overwriting the base would\n+                // not change the type of the memory, so no additional\n+                // restrictions are needed.\n+                //\n+                // FIXME(#5397) --- Mut fields are not treated soundly\n+                //                  (hopefully they will just get phased out)\n+                let result = self.compute(cmt_base, restrictions);\n+                self.extend(result, cmt.mutbl, LpInterior(i), restrictions)\n+            }\n+\n+            mc::cat_deref(cmt_base, _, mc::uniq_ptr(*)) => {\n+                // When we borrow the interior of an owned pointer, we\n+                // cannot permit the base to be mutated, because that\n+                // would cause the unique pointer to be freed.\n+                let result = self.compute(cmt_base, restrictions | RESTR_MUTATE);\n+                self.extend(result, cmt.mutbl, LpDeref, restrictions)\n+            }\n+\n+            mc::cat_copied_upvar(*) | // FIXME(#2152) allow mutation of upvars\n+            mc::cat_static_item(*) |\n+            mc::cat_implicit_self(*) |\n+            mc::cat_deref(_, _, mc::region_ptr(m_imm, _)) |\n+            mc::cat_deref(_, _, mc::gc_ptr(m_imm)) => {\n+                Safe\n+            }\n+\n+            mc::cat_deref(_, _, mc::region_ptr(m_const, _)) |\n+            mc::cat_deref(_, _, mc::gc_ptr(m_const)) => {\n+                self.check_no_mutability_control(cmt, restrictions);\n+                Safe\n+            }\n+\n+            mc::cat_deref(cmt_base, _, mc::gc_ptr(m_mutbl)) => {\n+                // Technically, no restrictions are *necessary* here.\n+                // The validity of the borrow is guaranteed\n+                // dynamically.  However, nonetheless we add a\n+                // restriction to make a \"best effort\" to report\n+                // static errors. For example, if there is code like\n+                //\n+                //    let v = @mut ~[1, 2, 3];\n+                //    for v.each |e| {\n+                //        v.push(e + 1);\n+                //    }\n+                //\n+                // Then the code below would add restrictions on `*v`,\n+                // which means that an error would be reported\n+                // here. This of course is not perfect. For example,\n+                // a function like the following would not report an error\n+                // at compile-time but would fail dynamically:\n+                //\n+                //    let v = @mut ~[1, 2, 3];\n+                //    let w = v;\n+                //    for v.each |e| {\n+                //        w.push(e + 1);\n+                //    }\n+                //\n+                // In addition, we only add a restriction for those cases\n+                // where we can construct a sensible loan path, so an\n+                // example like the following will fail dynamically:\n+                //\n+                //    impl V {\n+                //      fn get_list(&self) -> @mut ~[int];\n+                //    }\n+                //    ...\n+                //    let v: &V = ...;\n+                //    for v.get_list().each |e| {\n+                //        v.get_list().push(e + 1);\n+                //    }\n+                match opt_loan_path(cmt_base) {\n+                    None => Safe,\n+                    Some(lp_base) => {\n+                        let lp = @LpExtend(lp_base, cmt.mutbl, LpDeref);\n+                        SafeIf(lp, ~[Restriction {loan_path: lp,\n+                                                  set: restrictions}])\n+                    }\n+                }\n+            }\n+\n+            mc::cat_deref(cmt_base, _, mc::region_ptr(m_mutbl, _)) => {\n+                // Because an `&mut` pointer does not inherit its\n+                // mutability, we can only prevent mutation or prevent\n+                // freezing if it is not aliased. Therefore, in such\n+                // cases we restrict aliasing on `cmt_base`.\n+                if restrictions.intersects(RESTR_MUTATE | RESTR_FREEZE) {\n+                    let result = self.compute(cmt_base, restrictions | RESTR_ALIAS);\n+                    self.extend(result, cmt.mutbl, LpDeref, restrictions)\n+                } else {\n+                    let result = self.compute(cmt_base, restrictions);\n+                    self.extend(result, cmt.mutbl, LpDeref, restrictions)\n+                }\n+            }\n+\n+            mc::cat_deref(_, _, mc::unsafe_ptr) => {\n+                // We are very trusting when working with unsafe pointers.\n+                Safe\n+            }\n+\n+            mc::cat_stack_upvar(cmt_base) |\n+            mc::cat_discr(cmt_base, _) => {\n+                self.compute(cmt_base, restrictions)\n+            }\n+        }\n+    }\n+\n+    fn extend(&self,\n+              result: RestrictionResult,\n+              mc: mc::MutabilityCategory,\n+              elem: LoanPathElem,\n+              restrictions: RestrictionSet) -> RestrictionResult {\n+        match result {\n+            Safe => Safe,\n+            SafeIf(base_lp, base_vec) => {\n+                let lp = @LpExtend(base_lp, mc, elem);\n+                SafeIf(lp, vec::append_one(base_vec,\n+                                           Restriction {loan_path: lp,\n+                                                        set: restrictions}))\n+            }\n+        }\n+    }\n+\n+    fn check_aliasing_permitted(&self,\n+                                cause: mc::AliasableReason,\n+                                restrictions: RestrictionSet) {\n+        //! This method is invoked when the current `cmt` is something\n+        //! where aliasing cannot be controlled. It reports an error if\n+        //! the restrictions required that it not be aliased; currently\n+        //! this only occurs when re-borrowing an `&mut` pointer.\n+        //!\n+        //! NB: To be 100% consistent, we should report an error if\n+        //! RESTR_FREEZE is found, because we cannot prevent freezing,\n+        //! nor would we want to. However, we do not report such an\n+        //! error, because this restriction only occurs when the user\n+        //! is creating an `&mut` pointer to immutable or read-only\n+        //! data, and there is already another piece of code that\n+        //! checks for this condition.\n+\n+        if restrictions.intersects(RESTR_ALIAS) {\n+            self.bccx.report_aliasability_violation(\n+                self.span,\n+                BorrowViolation,\n+                cause);\n+        }\n+    }\n+\n+    fn check_no_mutability_control(&self,\n+                                   cmt: mc::cmt,\n+                                   restrictions: RestrictionSet) {\n+        if restrictions.intersects(RESTR_MUTATE | RESTR_FREEZE) {\n+            self.bccx.report(BckError {span: self.span,\n+                                       cmt: cmt,\n+                                       code: err_freeze_aliasable_const});\n+        }\n+    }\n+}\n+"}, {"sha": "641571373bda4f5d5a5b7a3e9ca238a62b00f663", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "removed", "additions": 0, "deletions": 311, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fd6e42a904723c99383e684ddeaf02f01d972/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fd6e42a904723c99383e684ddeaf02f01d972/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=bd5fd6e42a904723c99383e684ddeaf02f01d972", "patch": "@@ -1,311 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-The `Loan` module deals with borrows of *uniquely mutable* data.  We\n-say that data is uniquely mutable if the current activation (stack\n-frame) controls the only mutable reference to the data.  The most\n-common way that this can occur is if the current activation owns the\n-data being borrowed, but it can also occur with `&mut` pointers.  The\n-primary characteristic of uniquely mutable data is that, at any given\n-time, there is at most one path that can be used to mutate it, and\n-that path is only accessible from the top stack frame.\n-\n-Given that some data found at a path P is being borrowed to a borrowed\n-pointer with mutability M and lifetime L, the job of the code in this\n-module is to compute the set of *loans* that are necessary to ensure\n-that (1) the data found at P outlives L and that (2) if M is mutable\n-then the path P will not be modified directly or indirectly except\n-through that pointer.  A *loan* is the combination of a path P_L, a\n-mutability M_L, and a lifetime L_L where:\n-\n-- The path P_L indicates what data has been lent.\n-- The mutability M_L indicates the access rights on the data:\n-  - const: the data cannot be moved\n-  - immutable/mutable: the data cannot be moved or mutated\n-- The lifetime L_L indicates the *scope* of the loan.\n-\n-FIXME #4730 --- much more needed, don't have time to write this all up now\n-\n-*/\n-\n-// ----------------------------------------------------------------------\n-// Loan(Ex, M, S) = Ls holds if ToAddr(Ex) will remain valid for the entirety\n-// of the scope S, presuming that the returned set of loans `Ls` are honored.\n-\n-use middle::borrowck::{Loan, bckerr, bckres, BorrowckCtxt, err_mutbl};\n-use middle::borrowck::{LoanKind, TotalFreeze, PartialFreeze,\n-                       TotalTake, PartialTake, Immobile};\n-use middle::borrowck::{err_out_of_scope};\n-use middle::mem_categorization::{cat_arg, cat_binding, cat_discr, cat_comp};\n-use middle::mem_categorization::{cat_deref, cat_discr, cat_local, cat_self};\n-use middle::mem_categorization::{cat_special, cat_stack_upvar, cmt};\n-use middle::mem_categorization::{comp_field, comp_index, comp_variant};\n-use middle::mem_categorization::{gc_ptr, region_ptr};\n-use middle::ty;\n-use util::common::indenter;\n-\n-use syntax::ast::m_imm;\n-use syntax::ast;\n-\n-pub fn loan(bccx: @BorrowckCtxt,\n-            cmt: cmt,\n-            scope_region: ty::Region,\n-            loan_kind: LoanKind) -> bckres<~[Loan]>\n-{\n-    let mut lc = LoanContext {\n-        bccx: bccx,\n-        scope_region: scope_region,\n-        loans: ~[]\n-    };\n-    match lc.loan(cmt, loan_kind, true) {\n-        Err(ref e) => return Err((*e)),\n-        Ok(()) => {}\n-    }\n-    // FIXME #4945: Workaround for borrow check bug.\n-    Ok(copy lc.loans)\n-}\n-\n-struct LoanContext {\n-    bccx: @BorrowckCtxt,\n-\n-    // the region scope for which we must preserve the memory\n-    scope_region: ty::Region,\n-\n-    // accumulated list of loans that will be required\n-    loans: ~[Loan]\n-}\n-\n-pub impl LoanContext {\n-    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n-\n-    fn loan(&mut self,\n-            cmt: cmt,\n-            loan_kind: LoanKind,\n-            owns_lent_data: bool) -> bckres<()>\n-    {\n-        /*!\n-         *\n-         * The main routine.\n-         *\n-         * # Parameters\n-         *\n-         * - `cmt`: the categorization of the data being borrowed\n-         * - `req_mutbl`: the mutability of the borrowed pointer\n-         *                that was created\n-         * - `owns_lent_data`: indicates whether `cmt` owns the\n-         *                     data that is being lent.  See\n-         *                     discussion in `issue_loan()`.\n-         */\n-\n-        debug!(\"loan(%s, %?)\",\n-               self.bccx.cmt_to_repr(cmt),\n-               loan_kind);\n-        let _i = indenter();\n-\n-        // see stable() above; should only be called when `cmt` is lendable\n-        if cmt.lp.is_none() {\n-            self.bccx.tcx.sess.span_bug(\n-                cmt.span,\n-                \"loan() called with non-lendable value\");\n-        }\n-\n-        match cmt.cat {\n-          cat_binding(_) | cat_rvalue | cat_special(_) => {\n-            // should never be loanable\n-            self.bccx.tcx.sess.span_bug(\n-                cmt.span,\n-                \"rvalue with a non-none lp\");\n-          }\n-          cat_local(local_id) | cat_arg(local_id) | cat_self(local_id) => {\n-              // FIXME(#4903)\n-            let local_region = self.bccx.tcx.region_maps.encl_region(local_id);\n-            self.issue_loan(cmt, local_region, loan_kind,\n-                            owns_lent_data)\n-          }\n-          cat_stack_upvar(cmt) => {\n-            self.loan(cmt, loan_kind, owns_lent_data)\n-          }\n-          cat_discr(base, _) => {\n-            self.loan(base, loan_kind, owns_lent_data)\n-          }\n-          cat_comp(cmt_base, comp_field(_, m)) |\n-          cat_comp(cmt_base, comp_index(_, m)) => {\n-            // For most components, the type of the embedded data is\n-            // stable.  Therefore, the base structure need only be\n-            // const---unless the component must be immutable.  In\n-            // that case, it must also be embedded in an immutable\n-            // location, or else the whole structure could be\n-            // overwritten and the component along with it.\n-            self.loan_stable_comp(cmt, cmt_base, loan_kind, m,\n-                                  owns_lent_data)\n-          }\n-          cat_comp(cmt_base, comp_tuple) |\n-          cat_comp(cmt_base, comp_anon_field) => {\n-            // As above.\n-            self.loan_stable_comp(cmt, cmt_base, loan_kind, m_imm,\n-                                  owns_lent_data)\n-          }\n-          cat_comp(cmt_base, comp_variant(enum_did)) => {\n-            // For enums, the memory is unstable if there are multiple\n-            // variants, because if the enum value is overwritten then\n-            // the memory changes type.\n-            if ty::enum_is_univariant(self.bccx.tcx, enum_did) {\n-                self.loan_stable_comp(cmt, cmt_base, loan_kind, m_imm,\n-                                      owns_lent_data)\n-            } else {\n-                self.loan_unstable_deref(cmt, cmt_base, loan_kind,\n-                                         owns_lent_data)\n-            }\n-          }\n-          cat_deref(cmt_base, _, uniq_ptr) => {\n-            // For unique pointers, the memory being pointed out is\n-            // unstable because if the unique pointer is overwritten\n-            // then the memory is freed.\n-            self.loan_unstable_deref(cmt, cmt_base, loan_kind,\n-                                     owns_lent_data)\n-          }\n-          cat_deref(cmt_base, _, region_ptr(ast::m_mutbl, region)) => {\n-            // Mutable data can be loaned out as immutable or const. We must\n-            // loan out the base as well as the main memory. For example,\n-            // if someone borrows `*b`, we want to borrow `b` as immutable\n-            // as well.\n-            do self.loan(cmt_base, TotalFreeze, false).chain |_| {\n-                self.issue_loan(cmt, region, loan_kind, owns_lent_data)\n-            }\n-          }\n-          cat_deref(_, _, unsafe_ptr) |\n-          cat_deref(_, _, gc_ptr(_)) |\n-          cat_deref(_, _, region_ptr(_, _)) => {\n-            // Aliased data is simply not lendable.\n-            self.bccx.tcx.sess.span_bug(\n-                cmt.span,\n-                \"aliased ptr with a non-none lp\");\n-          }\n-        }\n-    }\n-\n-    // A \"stable component\" is one where assigning the base of the\n-    // component cannot cause the component itself to change types.\n-    // Example: record fields.\n-    fn loan_stable_comp(&mut self,\n-                        cmt: cmt,\n-                        cmt_base: cmt,\n-                        loan_kind: LoanKind,\n-                        comp_mutbl: ast::mutability,\n-                        owns_lent_data: bool) -> bckres<()>\n-    {\n-        let base_kind = match (comp_mutbl, loan_kind) {\n-            // Declared as \"immutable\" means: inherited mutability and\n-            // hence mutable iff parent is mutable.  So propagate\n-            // mutability on up.\n-            (m_imm, TotalFreeze) | (m_imm, PartialFreeze) => PartialFreeze,\n-            (m_imm, TotalTake) | (m_imm, PartialTake) => PartialTake,\n-\n-            // Declared as \"mutable\" means: always mutable no matter\n-            // what the mutability of the base is.  So that means we\n-            // can weaken the condition on the base to PartialFreeze.\n-            // This implies that the user could freeze the base, but\n-            // that is ok since the even with an &T base, the mut\n-            // field will still be considered mutable.\n-            (_, TotalTake) | (_, PartialTake) |\n-            (_, TotalFreeze) | (_, PartialFreeze) => {\n-                PartialFreeze\n-            }\n-\n-            // If we just need to guarantee the value won't be moved,\n-            // it doesn't matter what mutability the component was\n-            // declared with.\n-            (_, Immobile) => Immobile,\n-        };\n-\n-        do self.loan(cmt_base, base_kind, owns_lent_data).chain |_ok| {\n-            // can use static for the scope because the base\n-            // determines the lifetime, ultimately\n-            self.issue_loan(cmt, ty::re_static, loan_kind,\n-                            owns_lent_data)\n-        }\n-    }\n-\n-    // An \"unstable deref\" means a deref of a ptr/comp where, if the\n-    // base of the deref is assigned to, pointers into the result of the\n-    // deref would be invalidated. Examples: interior of variants, uniques.\n-    fn loan_unstable_deref(&mut self,\n-                           cmt: cmt,\n-                           cmt_base: cmt,\n-                           loan_kind: LoanKind,\n-                           owns_lent_data: bool) -> bckres<()> {\n-        // Variant components: the base must be immutable, because\n-        // if it is overwritten, the types of the embedded data\n-        // could change.\n-        do self.loan(cmt_base, PartialFreeze, owns_lent_data).chain |_| {\n-            // can use static, as in loan_stable_comp()\n-            self.issue_loan(cmt, ty::re_static, loan_kind,\n-                            owns_lent_data)\n-        }\n-    }\n-\n-    fn issue_loan(&mut self,\n-                  cmt: cmt,\n-                  scope_ub: ty::Region,\n-                  loan_kind: LoanKind,\n-                  owns_lent_data: bool) -> bckres<()> {\n-        // Subtle: the `scope_ub` is the maximal lifetime of `cmt`.\n-        // Therefore, if `cmt` owns the data being lent, then the\n-        // scope of the loan must be less than `scope_ub`, or else the\n-        // data would be freed while the loan is active.\n-        //\n-        // However, if `cmt` does *not* own the data being lent, then\n-        // it is ok if `cmt` goes out of scope during the loan.  This\n-        // can occur when you have an `&mut` parameter that is being\n-        // reborrowed.\n-\n-        if !owns_lent_data ||\n-            self.bccx.is_subregion_of(self.scope_region, scope_ub)\n-        {\n-            if cmt.mutbl.is_mutable() {\n-                // If this loan is a mutable loan, then mark the loan path (if\n-                // it exists) as being used. This is similar to the check\n-                // performed in check_loans.rs in check_assignment(), but this\n-                // is for a different purpose of having the 'mut' qualifier.\n-                for cmt.lp.each |lp| {\n-                    for lp.node_id().each |&id| {\n-                        self.tcx().used_mut_nodes.insert(id);\n-                    }\n-                }\n-            } else if loan_kind.is_take() {\n-                // We do not allow non-mutable data to be \"taken\"\n-                // under any circumstances.\n-                return Err(bckerr {\n-                    cmt:cmt,\n-                    code:err_mutbl(loan_kind)\n-                });\n-            }\n-\n-            self.loans.push(Loan {\n-                // Note: cmt.lp must be Some(_) because otherwise this\n-                // loan process does not apply at all.\n-                lp: cmt.lp.get(),\n-                cmt: cmt,\n-                kind: loan_kind\n-            });\n-\n-            return Ok(());\n-        } else {\n-            // The loan being requested lives longer than the data\n-            // being loaned out!\n-            return Err(bckerr {\n-                cmt:cmt,\n-                code:err_out_of_scope(scope_ub, self.scope_region)\n-            });\n-        }\n-    }\n-}"}, {"sha": "68e70d245f779fab8d399d81a77a81055b42758d", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 468, "deletions": 407, "changes": 875, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -8,254 +8,64 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-# Borrow check\n-\n-This pass is in job of enforcing *memory safety* and *purity*.  As\n-memory safety is by far the more complex topic, I'll focus on that in\n-this description, but purity will be covered later on. In the context\n-of Rust, memory safety means three basic things:\n-\n-- no writes to immutable memory;\n-- all pointers point to non-freed memory;\n-- all pointers point to memory of the same type as the pointer.\n-\n-The last point might seem confusing: after all, for the most part,\n-this condition is guaranteed by the type check.  However, there are\n-two cases where the type check effectively delegates to borrow check.\n-\n-The first case has to do with enums.  If there is a pointer to the\n-interior of an enum, and the enum is in a mutable location (such as a\n-local variable or field declared to be mutable), it is possible that\n-the user will overwrite the enum with a new value of a different\n-variant, and thus effectively change the type of the memory that the\n-pointer is pointing at.\n+/*! See doc.rs for a thorough explanation of the borrow checker */\n \n-The second case has to do with mutability.  Basically, the type\n-checker has only a limited understanding of mutability.  It will allow\n-(for example) the user to get an immutable pointer with the address of\n-a mutable local variable.  It will also allow a `@mut T` or `~mut T`\n-pointer to be borrowed as a `&r.T` pointer.  These seeming oversights\n-are in fact intentional; they allow the user to temporarily treat a\n-mutable value as immutable.  It is up to the borrow check to guarantee\n-that the value in question is not in fact mutated during the lifetime\n-`r` of the reference.\n+use core;\n+use core::prelude::*;\n \n-# Definition of unstable memory\n-\n-The primary danger to safety arises due to *unstable memory*.\n-Unstable memory is memory whose validity or type may change as a\n-result of an assignment, move, or a variable going out of scope.\n-There are two cases in Rust where memory is unstable: the contents of\n-unique boxes and enums.\n-\n-Unique boxes are unstable because when the variable containing the\n-unique box is re-assigned, moves, or goes out of scope, the unique box\n-is freed or---in the case of a move---potentially given to another\n-task.  In either case, if there is an extant and usable pointer into\n-the box, then safety guarantees would be compromised.\n-\n-Enum values are unstable because they are reassigned the types of\n-their contents may change if they are assigned with a different\n-variant than they had previously.\n-\n-# Safety criteria that must be enforced\n-\n-Whenever a piece of memory is borrowed for lifetime L, there are two\n-things which the borrow checker must guarantee.  First, it must\n-guarantee that the memory address will remain allocated (and owned by\n-the current task) for the entirety of the lifetime L.  Second, it must\n-guarantee that the type of the data will not change for the entirety\n-of the lifetime L.  In exchange, the region-based type system will\n-guarantee that the pointer is not used outside the lifetime L.  These\n-guarantees are to some extent independent but are also inter-related.\n-\n-In some cases, the type of a pointer cannot be invalidated but the\n-lifetime can.  For example, imagine a pointer to the interior of\n-a shared box like:\n-\n-    let mut x = @mut {f: 5, g: 6};\n-    let y = &mut x.f;\n-\n-Here, a pointer was created to the interior of a shared box which\n-contains a record.  Even if `*x` were to be mutated like so:\n-\n-    *x = {f: 6, g: 7};\n-\n-This would cause `*y` to change from 5 to 6, but the pointer pointer\n-`y` remains valid.  It still points at an integer even if that integer\n-has been overwritten.\n-\n-However, if we were to reassign `x` itself, like so:\n-\n-    x = @{f: 6, g: 7};\n-\n-This could potentially invalidate `y`, because if `x` were the final\n-reference to the shared box, then that memory would be released and\n-now `y` points at freed memory.  (We will see that to prevent this\n-scenario we will *root* shared boxes that reside in mutable memory\n-whose contents are borrowed; rooting means that we create a temporary\n-to ensure that the box is not collected).\n-\n-In other cases, like an enum on the stack, the memory cannot be freed\n-but its type can change:\n-\n-    let mut x = Some(5);\n-    match x {\n-      Some(ref y) => { ... }\n-      None => { ... }\n-    }\n-\n-Here as before, the pointer `y` would be invalidated if we were to\n-reassign `x` to `none`.  (We will see that this case is prevented\n-because borrowck tracks data which resides on the stack and prevents\n-variables from reassigned if there may be pointers to their interior)\n-\n-Finally, in some cases, both dangers can arise.  For example, something\n-like the following:\n-\n-    let mut x = ~Some(5);\n-    match x {\n-      ~Some(ref y) => { ... }\n-      ~None => { ... }\n-    }\n-\n-In this case, if `x` to be reassigned or `*x` were to be mutated, then\n-the pointer `y` would be invalided.  (This case is also prevented by\n-borrowck tracking data which is owned by the current stack frame)\n-\n-# Summary of the safety check\n-\n-In order to enforce mutability, the borrow check has a few tricks up\n-its sleeve:\n-\n-- When data is owned by the current stack frame, we can identify every\n-  possible assignment to a local variable and simply prevent\n-  potentially dangerous assignments directly.\n-\n-- If data is owned by a shared box, we can root the box to increase\n-  its lifetime.\n-\n-- If data is found within a borrowed pointer, we can assume that the\n-  data will remain live for the entirety of the borrowed pointer.\n-\n-- We can rely on the fact that pure actions (such as calling pure\n-  functions) do not mutate data which is not owned by the current\n-  stack frame.\n-\n-# Possible future directions\n-\n-There are numerous ways that the `borrowck` could be strengthened, but\n-these are the two most likely:\n-\n-- flow-sensitivity: we do not currently consider flow at all but only\n-  block-scoping.  This means that innocent code like the following is\n-  rejected:\n-\n-      let mut x: int;\n-      ...\n-      x = 5;\n-      let y: &int = &x; // immutable ptr created\n-      ...\n-\n-  The reason is that the scope of the pointer `y` is the entire\n-  enclosing block, and the assignment `x = 5` occurs within that\n-  block.  The analysis is not smart enough to see that `x = 5` always\n-  happens before the immutable pointer is created.  This is relatively\n-  easy to fix and will surely be fixed at some point.\n-\n-- finer-grained purity checks: currently, our fallback for\n-  guaranteeing random references into mutable, aliasable memory is to\n-  require *total purity*.  This is rather strong.  We could use local\n-  type-based alias analysis to distinguish writes that could not\n-  possibly invalid the references which must be guaranteed.  This\n-  would only work within the function boundaries; function calls would\n-  still require total purity.  This seems less likely to be\n-  implemented in the short term as it would make the code\n-  significantly more complex; there is currently no code to analyze\n-  the types and determine the possible impacts of a write.\n-\n-# How the code works\n-\n-The borrow check code is divided into several major modules, each of\n-which is documented in its own file.\n-\n-The `gather_loans` and `check_loans` are the two major passes of the\n-analysis.  The `gather_loans` pass runs over the IR once to determine\n-what memory must remain valid and for how long.  Its name is a bit of\n-a misnomer; it does in fact gather up the set of loans which are\n-granted, but it also determines when @T pointers must be rooted and\n-for which scopes purity must be required.\n-\n-The `check_loans` pass walks the IR and examines the loans and purity\n-requirements computed in `gather_loans`.  It checks to ensure that (a)\n-the conditions of all loans are honored; (b) no contradictory loans\n-were granted (for example, loaning out the same memory as mutable and\n-immutable simultaneously); and (c) any purity requirements are\n-honored.\n-\n-The remaining modules are helper modules used by `gather_loans` and\n-`check_loans`:\n-\n-- `categorization` has the job of analyzing an expression to determine\n-  what kind of memory is used in evaluating it (for example, where\n-  dereferences occur and what kind of pointer is dereferenced; whether\n-  the memory is mutable; etc)\n-- `loan` determines when data uniquely tied to the stack frame can be\n-  loaned out.\n-- `preserve` determines what actions (if any) must be taken to preserve\n-  aliasable data.  This is the code which decides when to root\n-  an @T pointer or to require purity.\n-\n-# Maps that are created\n-\n-Borrowck results in two maps.\n-\n-- `root_map`: identifies those expressions or patterns whose result\n-  needs to be rooted.  Conceptually the root_map maps from an\n-  expression or pattern node to a `node_id` identifying the scope for\n-  which the expression must be rooted (this `node_id` should identify\n-  a block or call).  The actual key to the map is not an expression id,\n-  however, but a `root_map_key`, which combines an expression id with a\n-  deref count and is used to cope with auto-deref.\n-\n-- `mutbl_map`: identifies those local variables which are modified or\n-  moved. This is used by trans to guarantee that such variables are\n-  given a memory location and not used as immediates.\n- */\n-\n-use middle::mem_categorization::*;\n+use mc = middle::mem_categorization;\n use middle::ty;\n use middle::typeck;\n use middle::moves;\n+use middle::dataflow::DataFlowContext;\n+use middle::dataflow::DataFlowOperator;\n use util::common::stmt_set;\n-use util::ppaux::note_and_explain_region;\n+use util::ppaux::{note_and_explain_region, Repr};\n \n use core::hashmap::{HashSet, HashMap};\n-use core::to_bytes;\n-use syntax::ast::{mutability, m_imm};\n+use core::io;\n+use core::result::{Result};\n+use core::ops::{BitOr, BitAnd};\n use syntax::ast;\n+use syntax::ast_map;\n+use syntax::visit;\n use syntax::codemap::span;\n \n+macro_rules! if_ok(\n+    ($inp: expr) => (\n+        match $inp {\n+            Ok(v) => { v }\n+            Err(e) => { return Err(e); }\n+        }\n+    )\n+)\n+\n+pub mod doc;\n+\n pub mod check_loans;\n+\n+#[path=\"gather_loans/mod.rs\"]\n pub mod gather_loans;\n-pub mod loan;\n-pub mod preserve;\n+\n+pub struct LoanDataFlowOperator;\n+pub type LoanDataFlow = DataFlowContext<LoanDataFlowOperator>;\n \n pub fn check_crate(\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n     moves_map: moves::MovesMap,\n+    moved_variables_set: moves::MovedVariablesSet,\n     capture_map: moves::CaptureMap,\n-    crate: @ast::crate) -> (root_map, mutbl_map, write_guard_map)\n+    crate: @ast::crate) -> (root_map, write_guard_map)\n {\n     let bccx = @BorrowckCtxt {\n         tcx: tcx,\n         method_map: method_map,\n         moves_map: moves_map,\n+        moved_variables_set: moved_variables_set,\n         capture_map: capture_map,\n         root_map: root_map(),\n-        mutbl_map: @mut HashSet::new(),\n+        loan_map: @mut HashMap::new(),\n         write_guard_map: @mut HashSet::new(),\n         stmt_map: @mut HashSet::new(),\n         stats: @mut BorrowStats {\n@@ -267,8 +77,9 @@ pub fn check_crate(\n         }\n     };\n \n-    let req_maps = gather_loans::gather_loans(bccx, crate);\n-    check_loans::check_loans(bccx, req_maps, crate);\n+    let v = visit::mk_vt(@visit::Visitor {visit_fn: borrowck_fn,\n+                                          ..*visit::default_visitor()});\n+    visit::visit_crate(crate, bccx, v);\n \n     if tcx.sess.borrowck_stats() {\n         io::println(~\"--- borrowck stats ---\");\n@@ -284,7 +95,7 @@ pub fn check_crate(\n                          make_stat(bccx, bccx.stats.req_pure_paths)));\n     }\n \n-    return (bccx.root_map, bccx.mutbl_map, bccx.write_guard_map);\n+    return (bccx.root_map, bccx.write_guard_map);\n \n     fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> ~str {\n         let stat_f = stat as float;\n@@ -293,16 +104,56 @@ pub fn check_crate(\n     }\n }\n \n+fn borrowck_fn(fk: &visit::fn_kind,\n+               decl: &ast::fn_decl,\n+               body: &ast::blk,\n+               sp: span,\n+               id: ast::node_id,\n+               self: @BorrowckCtxt,\n+               v: visit::vt<@BorrowckCtxt>) {\n+    match fk {\n+        &visit::fk_anon(*) |\n+        &visit::fk_fn_block(*) => {\n+            // Closures are checked as part of their containing fn item.\n+        }\n+\n+        &visit::fk_item_fn(*) |\n+        &visit::fk_method(*) => {\n+            debug!(\"borrowck_fn(id=%?)\", id);\n+\n+            // Check the body of fn items.\n+            let (id_range, all_loans) =\n+                gather_loans::gather_loans(self, body);\n+            let all_loans: &~[Loan] = &*all_loans; // FIXME(#5074)\n+            let mut dfcx =\n+                DataFlowContext::new(self.tcx,\n+                                     self.method_map,\n+                                     LoanDataFlowOperator,\n+                                     id_range,\n+                                     all_loans.len());\n+            for all_loans.eachi |loan_idx, loan| {\n+                dfcx.add_gen(loan.gen_scope, loan_idx);\n+                dfcx.add_kill(loan.kill_scope, loan_idx);\n+            }\n+            dfcx.propagate(body);\n+            check_loans::check_loans(self, &dfcx, *all_loans, body);\n+        }\n+    }\n+\n+    visit::visit_fn(fk, decl, body, sp, id, self, v);\n+}\n+\n // ----------------------------------------------------------------------\n // Type definitions\n \n pub struct BorrowckCtxt {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n     moves_map: moves::MovesMap,\n+    moved_variables_set: moves::MovedVariablesSet,\n     capture_map: moves::CaptureMap,\n     root_map: root_map,\n-    mutbl_map: mutbl_map,\n+    loan_map: LoanMap,\n     write_guard_map: write_guard_map,\n     stmt_map: stmt_set,\n \n@@ -318,165 +169,267 @@ pub struct BorrowStats {\n     guaranteed_paths: uint\n }\n \n-pub struct RootInfo {\n-    scope: ast::node_id,\n-    // This will be true if we need to freeze this box at runtime. This will\n-    // result in a call to `borrow_as_imm()` and `return_to_mut()`.\n-    freezes: bool   // True if we need to freeze this box at runtime.\n-}\n-\n-// a map mapping id's of expressions of gc'd type (@T, @[], etc) where\n-// the box needs to be kept live to the id of the scope for which they\n-// must stay live.\n-pub type root_map = @mut HashMap<root_map_key, RootInfo>;\n+pub type LoanMap = @mut HashMap<ast::node_id, @Loan>;\n \n-// the keys to the root map combine the `id` of the expression with\n-// the number of types that it is autodereferenced.  So, for example,\n-// if you have an expression `x.f` and x has type ~@T, we could add an\n-// entry {id:x, derefs:0} to refer to `x` itself, `{id:x, derefs:1}`\n-// to refer to the deref of the unique pointer, and so on.\n-#[deriving(Eq)]\n+// The keys to the root map combine the `id` of the deref expression\n+// with the number of types that it is *autodereferenced*. So, for\n+// example, imagine I have a variable `x: @@@T` and an expression\n+// `(*x).f`.  This will have 3 derefs, one explicit and then two\n+// autoderefs. These are the relevant `root_map_key` values that could\n+// appear:\n+//\n+//    {id:*x, derefs:0} --> roots `x` (type: @@@T, due to explicit deref)\n+//    {id:*x, derefs:1} --> roots `*x` (type: @@T, due to autoderef #1)\n+//    {id:*x, derefs:2} --> roots `**x` (type: @T, due to autoderef #2)\n+//\n+// Note that there is no entry with derefs:3---the type of that expression\n+// is T, which is not a box.\n+#[deriving(Eq, IterBytes)]\n pub struct root_map_key {\n     id: ast::node_id,\n     derefs: uint\n }\n \n-// set of ids of local vars / formal arguments that are modified / moved.\n-// this is used in trans for optimization purposes.\n-pub type mutbl_map = @mut HashSet<ast::node_id>;\n-\n // A set containing IDs of expressions of gc'd type that need to have a write\n // guard.\n pub type write_guard_map = @mut HashSet<root_map_key>;\n \n-// Errors that can occur\n-#[deriving(Eq)]\n-pub enum bckerr_code {\n-    err_mut_uniq,\n-    err_mut_variant,\n-    err_root_not_permitted,\n-    err_mutbl(LoanKind),\n-    err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n-    err_out_of_scope(ty::Region, ty::Region) // superscope, subscope\n-}\n+pub type BckResult<T> = Result<T, BckError>;\n \n-// Combination of an error code and the categorization of the expression\n-// that caused it\n #[deriving(Eq)]\n-pub struct bckerr {\n-    cmt: cmt,\n-    code: bckerr_code\n+pub enum PartialTotal {\n+    Partial,   // Loan affects some portion\n+    Total      // Loan affects entire path\n }\n \n-pub enum MoveError {\n-    MoveOk,\n-    MoveFromIllegalCmt(cmt),\n-    MoveWhileBorrowed(/*move*/ cmt, /*loan*/ cmt)\n+///////////////////////////////////////////////////////////////////////////\n+// Loans and loan paths\n+\n+/// Record of a loan that was issued.\n+pub struct Loan {\n+    index: uint,\n+    loan_path: @LoanPath,\n+    cmt: mc::cmt,\n+    mutbl: ast::mutability,\n+    restrictions: ~[Restriction],\n+    gen_scope: ast::node_id,\n+    kill_scope: ast::node_id,\n+    span: span,\n }\n \n-// shorthand for something that fails with `bckerr` or succeeds with `T`\n-pub type bckres<T> = Result<T, bckerr>;\n+#[deriving(Eq)]\n+pub enum LoanPath {\n+    LpVar(ast::node_id),               // `x` in doc.rs\n+    LpExtend(@LoanPath, mc::MutabilityCategory, LoanPathElem)\n+}\n \n #[deriving(Eq)]\n-pub enum LoanKind {\n-    TotalFreeze,   // Entire path is frozen   (borrowed as &T)\n-    PartialFreeze, // Some subpath is frozen  (borrowed as &T)\n-    TotalTake,     // Entire path is \"taken\"  (borrowed as &mut T)\n-    PartialTake,   // Some subpath is \"taken\" (borrowed as &mut T)\n-    Immobile       // Path cannot be moved    (borrowed as &const T)\n+pub enum LoanPathElem {\n+    LpDeref,                      // `*LV` in doc.rs\n+    LpInterior(mc::interior_kind) // `LV.f` in doc.rs\n }\n \n-/// a complete record of a loan that was granted\n-pub struct Loan {\n-    lp: @loan_path,\n-    cmt: cmt,\n-    kind: LoanKind\n+pub impl LoanPath {\n+    fn node_id(&self) -> ast::node_id {\n+        match *self {\n+            LpVar(local_id) => local_id,\n+            LpExtend(base, _, _) => base.node_id()\n+        }\n+    }\n }\n \n-/// maps computed by `gather_loans` that are then used by `check_loans`\n-///\n-/// - `req_loan_map`: map from each block/expr to the required loans needed\n-///   for the duration of that block/expr\n-/// - `pure_map`: map from block/expr that must be pure to the error message\n-///   that should be reported if they are not pure\n-pub struct ReqMaps {\n-    req_loan_map: HashMap<ast::node_id, @mut ~[Loan]>,\n-    pure_map: HashMap<ast::node_id, bckerr>\n+pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n+    //! Computes the `LoanPath` (if any) for a `cmt`.\n+    //! Note that this logic is somewhat duplicated in\n+    //! the method `compute()` found in `gather_loans::restrictions`,\n+    //! which allows it to share common loan path pieces as it\n+    //! traverses the CMT.\n+\n+    match cmt.cat {\n+        mc::cat_rvalue |\n+        mc::cat_static_item |\n+        mc::cat_copied_upvar(_) |\n+        mc::cat_implicit_self => {\n+            None\n+        }\n+\n+        mc::cat_local(id) |\n+        mc::cat_arg(id) |\n+        mc::cat_self(id) => {\n+            Some(@LpVar(id))\n+        }\n+\n+        mc::cat_deref(cmt_base, _, _) => {\n+            opt_loan_path(cmt_base).map(\n+                |&lp| @LpExtend(lp, cmt.mutbl, LpDeref))\n+        }\n+\n+        mc::cat_interior(cmt_base, ik) => {\n+            opt_loan_path(cmt_base).map(\n+                |&lp| @LpExtend(lp, cmt.mutbl, LpInterior(ik)))\n+        }\n+\n+        mc::cat_stack_upvar(cmt_base) |\n+        mc::cat_discr(cmt_base, _) => {\n+            opt_loan_path(cmt_base)\n+        }\n+    }\n }\n \n-pub fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T,\n-                                  f: &fn() -> U) -> U {\n-    let old_save_and_restore_t = *save_and_restore_t;\n-    let u = f();\n-    *save_and_restore_t = old_save_and_restore_t;\n-    u\n+///////////////////////////////////////////////////////////////////////////\n+// Restrictions\n+//\n+// Borrowing an lvalue often results in *restrictions* that limit what\n+// can be done with this lvalue during the scope of the loan:\n+//\n+// - `RESTR_MUTATE`: The lvalue may not be modified and mutable pointers to\n+//                   the value cannot be created.\n+// - `RESTR_FREEZE`: Immutable pointers to the value cannot be created.\n+// - `RESTR_ALIAS`: The lvalue may not be aliased in any way.\n+//\n+// In addition, no value which is restricted may be moved. Therefore,\n+// restrictions are meaningful even if the RestrictionSet is empty,\n+// because the restriction against moves is implied.\n+\n+pub struct Restriction {\n+    loan_path: @LoanPath,\n+    set: RestrictionSet\n }\n \n-pub fn save_and_restore_managed<T:Copy,U>(save_and_restore_t: @mut T,\n-                                          f: &fn() -> U) -> U {\n-    let old_save_and_restore_t = *save_and_restore_t;\n-    let u = f();\n-    *save_and_restore_t = old_save_and_restore_t;\n-    u\n+pub struct RestrictionSet {\n+    bits: u32\n }\n \n-pub impl LoanKind {\n-    fn is_freeze(&self) -> bool {\n-        match *self {\n-            TotalFreeze | PartialFreeze => true,\n-            _ => false\n-        }\n+pub static RESTR_EMPTY: RestrictionSet  = RestrictionSet {bits: 0b000};\n+pub static RESTR_MUTATE: RestrictionSet = RestrictionSet {bits: 0b001};\n+pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b010};\n+pub static RESTR_ALIAS: RestrictionSet  = RestrictionSet {bits: 0b100};\n+\n+pub impl RestrictionSet {\n+    fn intersects(&self, restr: RestrictionSet) -> bool {\n+        (self.bits & restr.bits) != 0\n     }\n \n-    fn is_take(&self) -> bool {\n-        match *self {\n-            TotalTake | PartialTake => true,\n-            _ => false\n-        }\n+    fn contains_all(&self, restr: RestrictionSet) -> bool {\n+        (self.bits & restr.bits) == restr.bits\n     }\n }\n \n-/// Creates and returns a new root_map\n+impl BitOr<RestrictionSet,RestrictionSet> for RestrictionSet {\n+    fn bitor(&self, rhs: &RestrictionSet) -> RestrictionSet {\n+        RestrictionSet {bits: self.bits | rhs.bits}\n+    }\n+}\n \n-impl to_bytes::IterBytes for root_map_key {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n+impl BitAnd<RestrictionSet,RestrictionSet> for RestrictionSet {\n+    fn bitand(&self, rhs: &RestrictionSet) -> RestrictionSet {\n+        RestrictionSet {bits: self.bits & rhs.bits}\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Rooting of managed boxes\n+//\n+// When we borrow the interior of a managed box, it is sometimes\n+// necessary to *root* the box, meaning to stash a copy of the box\n+// somewhere that the garbage collector will find it. This ensures\n+// that the box is not collected for the lifetime of the borrow.\n+//\n+// As part of this rooting, we sometimes also freeze the box at\n+// runtime, meaning that we dynamically detect when the box is\n+// borrowed in incompatible ways.\n+//\n+// Both of these actions are driven through the `root_map`, which maps\n+// from a node to the dynamic rooting action that should be taken when\n+// that node executes. The node is identified through a\n+// `root_map_key`, which pairs a node-id and a deref count---the\n+// problem is that sometimes the box that needs to be rooted is only\n+// uncovered after a certain number of auto-derefs.\n+\n+pub struct RootInfo {\n+    scope: ast::node_id,\n+    freeze: Option<DynaFreezeKind> // Some() if we should freeze box at runtime\n+}\n+\n+pub type root_map = @mut HashMap<root_map_key, RootInfo>;\n+\n pub fn root_map() -> root_map {\n     return @mut HashMap::new();\n }\n \n-// ___________________________________________________________________________\n+pub enum DynaFreezeKind {\n+    DynaImm,\n+    DynaMut\n+}\n+\n+impl ToStr for DynaFreezeKind {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            DynaMut => ~\"mutable\",\n+            DynaImm => ~\"immutable\"\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Errors\n+\n+// Errors that can occur\n+#[deriving(Eq)]\n+pub enum bckerr_code {\n+    err_mutbl(ast::mutability),\n+    err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n+    err_out_of_scope(ty::Region, ty::Region), // superscope, subscope\n+    err_freeze_aliasable_const\n+}\n+\n+// Combination of an error code and the categorization of the expression\n+// that caused it\n+#[deriving(Eq)]\n+pub struct BckError {\n+    span: span,\n+    cmt: mc::cmt,\n+    code: bckerr_code\n+}\n+\n+pub enum AliasableViolationKind {\n+    MutabilityViolation,\n+    BorrowViolation\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n // Misc\n \n pub impl BorrowckCtxt {\n     fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region) -> bool {\n         self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n \n-    fn cat_expr(&self, expr: @ast::expr) -> cmt {\n-        cat_expr(self.tcx, self.method_map, expr)\n+    fn is_subscope_of(&self, r_sub: ast::node_id, r_sup: ast::node_id) -> bool {\n+        self.tcx.region_maps.is_subscope_of(r_sub, r_sup)\n     }\n \n-    fn cat_expr_unadjusted(&self, expr: @ast::expr) -> cmt {\n-        cat_expr_unadjusted(self.tcx, self.method_map, expr)\n+    fn cat_expr(&self, expr: @ast::expr) -> mc::cmt {\n+        mc::cat_expr(self.tcx, self.method_map, expr)\n+    }\n+\n+    fn cat_expr_unadjusted(&self, expr: @ast::expr) -> mc::cmt {\n+        mc::cat_expr_unadjusted(self.tcx, self.method_map, expr)\n     }\n \n     fn cat_expr_autoderefd(&self, expr: @ast::expr,\n-                           adj: @ty::AutoAdjustment) -> cmt {\n+                           adj: @ty::AutoAdjustment) -> mc::cmt {\n         match *adj {\n             ty::AutoAddEnv(*) => {\n                 // no autoderefs\n-                cat_expr_unadjusted(self.tcx, self.method_map, expr)\n+                mc::cat_expr_unadjusted(self.tcx, self.method_map, expr)\n             }\n \n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n                     autoderefs: autoderefs, _}) => {\n-                cat_expr_autoderefd(self.tcx, self.method_map, expr,\n-                                    autoderefs)\n+                mc::cat_expr_autoderefd(self.tcx, self.method_map, expr,\n+                                        autoderefs)\n             }\n         }\n     }\n@@ -485,43 +438,33 @@ pub impl BorrowckCtxt {\n                id: ast::node_id,\n                span: span,\n                ty: ty::t,\n-               def: ast::def) -> cmt {\n-        cat_def(self.tcx, self.method_map, id, span, ty, def)\n-    }\n-\n-    fn cat_variant<N:ast_node>(&self,\n-                                arg: N,\n-                                enum_did: ast::def_id,\n-                                cmt: cmt) -> cmt {\n-        cat_variant(self.tcx, self.method_map, arg, enum_did, cmt)\n+               def: ast::def) -> mc::cmt {\n+        mc::cat_def(self.tcx, self.method_map, id, span, ty, def)\n     }\n \n-    fn cat_discr(&self, cmt: cmt, match_id: ast::node_id) -> cmt {\n-        return @cmt_ {cat:cat_discr(cmt, match_id),.. *cmt};\n+    fn cat_discr(&self, cmt: mc::cmt, match_id: ast::node_id) -> mc::cmt {\n+        @mc::cmt_ {cat:mc::cat_discr(cmt, match_id),\n+                   mutbl:cmt.mutbl.inherit(),\n+                   ..*cmt}\n     }\n \n-    fn mc_ctxt(&self) -> mem_categorization_ctxt {\n-        mem_categorization_ctxt {tcx: self.tcx,\n+    fn mc_ctxt(&self) -> mc::mem_categorization_ctxt {\n+        mc::mem_categorization_ctxt {tcx: self.tcx,\n                                  method_map: self.method_map}\n     }\n \n-    fn cat_pattern(&self, cmt: cmt, pat: @ast::pat, op: &fn(cmt, @ast::pat)) {\n+    fn cat_pattern(&self,\n+                   cmt: mc::cmt,\n+                   pat: @ast::pat,\n+                   op: &fn(mc::cmt, @ast::pat)) {\n         let mc = self.mc_ctxt();\n         mc.cat_pattern(cmt, pat, op);\n     }\n \n-    fn report_if_err(&self, bres: bckres<()>) {\n-        match bres {\n-          Ok(()) => (),\n-          Err(ref e) => self.report((*e))\n-        }\n-    }\n-\n-    fn report(&self, err: bckerr) {\n+    fn report(&self, err: BckError) {\n         self.span_err(\n-            err.cmt.span,\n-            fmt!(\"illegal borrow: %s\",\n-                 self.bckerr_to_str(err)));\n+            err.span,\n+            self.bckerr_to_str(err));\n         self.note_and_explain_bckerr(err);\n     }\n \n@@ -533,51 +476,75 @@ pub impl BorrowckCtxt {\n         self.tcx.sess.span_note(s, m);\n     }\n \n-    fn add_to_mutbl_map(&self, cmt: cmt) {\n-        match cmt.cat {\n-          cat_local(id) | cat_arg(id) => {\n-            self.mutbl_map.insert(id);\n-          }\n-          cat_stack_upvar(cmt) => {\n-            self.add_to_mutbl_map(cmt);\n-          }\n-          _ => ()\n-        }\n-    }\n-\n-    fn bckerr_to_str(&self, err: bckerr) -> ~str {\n+    fn bckerr_to_str(&self, err: BckError) -> ~str {\n         match err.code {\n             err_mutbl(lk) => {\n-                fmt!(\"creating %s alias to %s\",\n-                     self.loan_kind_to_str(lk),\n-                     self.cmt_to_str(err.cmt))\n+                fmt!(\"cannot borrow %s %s as %s\",\n+                     err.cmt.mutbl.to_user_str(),\n+                     self.cmt_to_str(err.cmt),\n+                     self.mut_to_str(lk))\n             }\n-            err_mut_uniq => {\n-                ~\"unique value in aliasable, mutable location\"\n+            err_out_of_root_scope(*) => {\n+                fmt!(\"cannot root managed value long enough\")\n             }\n-            err_mut_variant => {\n-                ~\"enum variant in aliasable, mutable location\"\n+            err_out_of_scope(*) => {\n+                fmt!(\"borrowed value does not live long enough\")\n             }\n-            err_root_not_permitted => {\n-                // note: I don't expect users to ever see this error\n-                // message, reasons are discussed in attempt_root() in\n-                // preserve.rs.\n-                ~\"rooting is not permitted\"\n+            err_freeze_aliasable_const => {\n+                // Means that the user borrowed a ~T or enum value\n+                // residing in &const or @const pointer.  Terrible\n+                // error message, but then &const and @const are\n+                // supposed to be going away.\n+                fmt!(\"unsafe borrow of aliasable, const value\")\n             }\n-            err_out_of_root_scope(*) => {\n-                ~\"cannot root managed value long enough\"\n+        }\n+    }\n+\n+    fn report_aliasability_violation(&self,\n+                                     span: span,\n+                                     kind: AliasableViolationKind,\n+                                     cause: mc::AliasableReason) {\n+        let prefix = match kind {\n+            MutabilityViolation => \"cannot assign to an `&mut`\",\n+            BorrowViolation => \"cannot borrow an `&mut`\"\n+        };\n+\n+        match cause {\n+            mc::AliasableOther => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    fmt!(\"%s in an aliasable location\", prefix));\n             }\n-            err_out_of_scope(*) => {\n-                ~\"borrowed value does not live long enough\"\n+            mc::AliasableManaged(ast::m_mutbl) => {\n+                // FIXME(#6269) reborrow @mut to &mut\n+                self.tcx.sess.span_err(\n+                    span,\n+                    fmt!(\"%s in a `@mut` pointer; \\\n+                          try borrowing as `&mut` first\", prefix));\n+            }\n+            mc::AliasableManaged(m) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    fmt!(\"%s in a `@%s` pointer; \\\n+                          try an `@mut` instead\",\n+                         prefix,\n+                         self.mut_to_keyword(m)));\n+            }\n+            mc::AliasableBorrowed(m) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    fmt!(\"%s in a `&%s` pointer; \\\n+                          try an `&mut` instead\",\n+                         prefix,\n+                         self.mut_to_keyword(m)));\n             }\n         }\n     }\n \n-    fn note_and_explain_bckerr(&self, err: bckerr) {\n+    fn note_and_explain_bckerr(&self, err: BckError) {\n         let code = err.code;\n         match code {\n-            err_mutbl(*) | err_mut_uniq | err_mut_variant |\n-            err_root_not_permitted => {}\n+            err_mutbl(*) | err_freeze_aliasable_const(*) => {}\n \n             err_out_of_root_scope(super_scope, sub_scope) => {\n                 note_and_explain_region(\n@@ -607,46 +574,140 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n+    fn append_loan_path_to_str_from_interior(&self,\n+                                             loan_path: &LoanPath,\n+                                             out: &mut ~str) {\n+        match *loan_path {\n+            LpExtend(_, _, LpDeref) => {\n+                str::push_char(out, '(');\n+                self.append_loan_path_to_str(loan_path, out);\n+                str::push_char(out, ')');\n+            }\n+            LpExtend(_, _, LpInterior(_)) |\n+            LpVar(_) => {\n+                self.append_loan_path_to_str(loan_path, out);\n+            }\n+        }\n+    }\n \n-    fn cmt_to_str(&self, cmt: cmt) -> ~str {\n-        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n-                                           method_map: self.method_map};\n-        mc.cmt_to_str(cmt)\n+    fn append_loan_path_to_str(&self, loan_path: &LoanPath, out: &mut ~str) {\n+        match *loan_path {\n+            LpVar(id) => {\n+                match self.tcx.items.find(&id) {\n+                    Some(&ast_map::node_local(ident)) => {\n+                        str::push_str(out, *self.tcx.sess.intr().get(ident));\n+                    }\n+                    r => {\n+                        self.tcx.sess.bug(\n+                            fmt!(\"Loan path LpVar(%?) maps to %?, not local\",\n+                                 id, r));\n+                    }\n+                }\n+            }\n+\n+            LpExtend(lp_base, _, LpInterior(mc::interior_field(fld, _))) => {\n+                self.append_loan_path_to_str_from_interior(lp_base, out);\n+                str::push_char(out, '.');\n+                str::push_str(out, *self.tcx.sess.intr().get(fld));\n+            }\n+\n+            LpExtend(lp_base, _, LpInterior(mc::interior_index(*))) => {\n+                self.append_loan_path_to_str_from_interior(lp_base, out);\n+                str::push_str(out, \"[]\");\n+            }\n+\n+            LpExtend(lp_base, _, LpInterior(mc::interior_tuple)) |\n+            LpExtend(lp_base, _, LpInterior(mc::interior_anon_field)) |\n+            LpExtend(lp_base, _, LpInterior(mc::interior_variant(_))) => {\n+                self.append_loan_path_to_str_from_interior(lp_base, out);\n+                str::push_str(out, \".(tuple)\");\n+            }\n+\n+            LpExtend(lp_base, _, LpDeref) => {\n+                str::push_char(out, '*');\n+                self.append_loan_path_to_str(lp_base, out);\n+            }\n+        }\n     }\n \n-    fn cmt_to_repr(&self, cmt: cmt) -> ~str {\n-        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n-                                           method_map: self.method_map};\n-        mc.cmt_to_repr(cmt)\n+    fn loan_path_to_str(&self, loan_path: &LoanPath) -> ~str {\n+        let mut result = ~\"\";\n+        self.append_loan_path_to_str(loan_path, &mut result);\n+        result\n+    }\n+\n+    fn cmt_to_str(&self, cmt: mc::cmt) -> ~str {\n+        let mc = &mc::mem_categorization_ctxt {tcx: self.tcx,\n+                                               method_map: self.method_map};\n+        mc.cmt_to_str(cmt)\n     }\n \n     fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n-        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n-                                           method_map: self.method_map};\n+        let mc = &mc::mem_categorization_ctxt {tcx: self.tcx,\n+                                               method_map: self.method_map};\n         mc.mut_to_str(mutbl)\n     }\n \n-    fn loan_kind_to_str(&self, lk: LoanKind) -> ~str {\n-        match lk {\n-            TotalFreeze | PartialFreeze => ~\"immutable\",\n-            TotalTake | PartialTake => ~\"mutable\",\n-            Immobile => ~\"read-only\"\n+    fn mut_to_keyword(&self, mutbl: ast::mutability) -> &'static str {\n+        match mutbl {\n+            ast::m_imm => \"\",\n+            ast::m_const => \"const\",\n+            ast::m_mutbl => \"mut\"\n         }\n     }\n+}\n+\n+impl DataFlowOperator for LoanDataFlowOperator {\n+    #[inline(always)]\n+    fn initial_value(&self) -> bool {\n+        false // no loans in scope by default\n+    }\n+\n+    #[inline(always)]\n+    fn join(&self, succ: uint, pred: uint) -> uint {\n+        succ | pred // loans from both preds are in scope\n+    }\n+\n+    #[inline(always)]\n+    fn walk_closures(&self) -> bool {\n+        true\n+    }\n+}\n \n-    fn loan_to_repr(&self, loan: &Loan) -> ~str {\n-        fmt!(\"Loan(lp=%?, cmt=%s, kind=%?)\",\n-             loan.lp, self.cmt_to_repr(loan.cmt), loan.kind)\n+impl Repr for Loan {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        fmt!(\"Loan_%?(%s, %?, %?-%?, %s)\",\n+             self.index,\n+             self.loan_path.repr(tcx),\n+             self.mutbl,\n+             self.gen_scope,\n+             self.kill_scope,\n+             self.restrictions.repr(tcx))\n     }\n }\n \n-// The inherent mutability of a component is its default mutability\n-// assuming it is embedded in an immutable context.  In general, the\n-// mutability can be \"overridden\" if the component is embedded in a\n-// mutable structure.\n-pub fn inherent_mutability(ck: comp_kind) -> mutability {\n-    match ck {\n-      comp_tuple | comp_anon_field | comp_variant(_) => m_imm,\n-      comp_field(_, m) | comp_index(_, m)            => m\n+impl Repr for Restriction {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        fmt!(\"Restriction(%s, %x)\",\n+             self.loan_path.repr(tcx),\n+             self.set.bits as uint)\n+    }\n+}\n+\n+impl Repr for LoanPath {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        match self {\n+            &LpVar(id) => {\n+                fmt!(\"$(%?)\", id)\n+            }\n+\n+            &LpExtend(lp, _, LpDeref) => {\n+                fmt!(\"%s.*\", lp.repr(tcx))\n+            }\n+\n+            &LpExtend(lp, _, LpInterior(ref interior)) => {\n+                fmt!(\"%s.%s\", lp.repr(tcx), interior.repr(tcx))\n+            }\n+        }\n     }\n }"}, {"sha": "62358823f23221a5cc869162be4694b3f8453a2a", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "removed", "additions": 0, "deletions": 409, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fd6e42a904723c99383e684ddeaf02f01d972/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fd6e42a904723c99383e684ddeaf02f01d972/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=bd5fd6e42a904723c99383e684ddeaf02f01d972", "patch": "@@ -1,409 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ----------------------------------------------------------------------\n-// Preserve(Ex, S) holds if ToAddr(Ex) will remain valid for the entirety of\n-// the scope S.\n-//\n-\n-use middle::borrowck::{RootInfo, bckerr, bckerr_code, bckres, BorrowckCtxt};\n-use middle::borrowck::{err_mut_uniq, err_mut_variant};\n-use middle::borrowck::{err_out_of_root_scope, err_out_of_scope};\n-use middle::borrowck::{err_root_not_permitted, root_map_key};\n-use middle::mem_categorization::{cat_arg, cat_binding, cat_comp, cat_deref};\n-use middle::mem_categorization::{cat_discr, cat_local, cat_self, cat_special};\n-use middle::mem_categorization::{cat_stack_upvar, cmt, comp_field};\n-use middle::mem_categorization::{comp_index, comp_variant, gc_ptr};\n-use middle::mem_categorization::{region_ptr};\n-use middle::ty;\n-use util::common::indenter;\n-\n-use syntax::ast;\n-\n-pub enum PreserveCondition {\n-    PcOk,\n-    PcIfPure(bckerr)\n-}\n-\n-pub impl PreserveCondition {\n-    // combines two preservation conditions such that if either of\n-    // them requires purity, the result requires purity\n-    fn combine(&self, pc: PreserveCondition) -> PreserveCondition {\n-        match *self {\n-            PcOk => {pc}\n-            PcIfPure(_) => {*self}\n-        }\n-    }\n-}\n-\n-pub impl BorrowckCtxt {\n-    fn preserve(&self,\n-                cmt: cmt,\n-                scope_region: ty::Region,\n-                item_ub: ast::node_id,\n-                root_ub: ast::node_id) -> bckres<PreserveCondition>\n-    {\n-        let ctxt = PreserveCtxt {\n-            bccx: self,\n-            scope_region: scope_region,\n-            item_ub: item_ub,\n-            root_ub: root_ub,\n-            root_managed_data: true\n-        };\n-        ctxt.preserve(cmt)\n-    }\n-}\n-\n-struct PreserveCtxt<'self> {\n-    bccx: &'self BorrowckCtxt,\n-\n-    // the region scope for which we must preserve the memory\n-    scope_region: ty::Region,\n-\n-    // the scope for the body of the enclosing fn/method item\n-    item_ub: ast::node_id,\n-\n-    // the upper bound on how long we can root an @T pointer\n-    root_ub: ast::node_id,\n-\n-    // if false, do not attempt to root managed data\n-    root_managed_data: bool\n-}\n-\n-pub impl<'self> PreserveCtxt<'self> {\n-    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n-\n-    fn preserve(&self, cmt: cmt) -> bckres<PreserveCondition> {\n-        debug!(\"preserve(cmt=%s, root_ub=%?, root_managed_data=%b)\",\n-               self.bccx.cmt_to_repr(cmt), self.root_ub,\n-               self.root_managed_data);\n-        let _i = indenter();\n-\n-        match cmt.cat {\n-          cat_special(sk_implicit_self) |\n-          cat_special(sk_heap_upvar) => {\n-            self.compare_scope(cmt, ty::re_scope(self.item_ub))\n-          }\n-          cat_special(sk_static_item) | cat_special(sk_method) => {\n-            Ok(PcOk)\n-          }\n-          cat_rvalue => {\n-            // when we borrow an rvalue, we can keep it rooted but only\n-            // up to the root_ub point\n-\n-            // When we're in a 'const &x = ...' context, self.root_ub is\n-            // zero and the rvalue is static, not bound to a scope.\n-            let scope_region = if self.root_ub == 0 {\n-                ty::re_static\n-            } else {\n-                // Maybe if we pass in the parent instead here,\n-                // we can prevent the \"scope not found\" error\n-                debug!(\"scope_region thing: %? \", cmt.id);\n-                self.tcx().region_maps.encl_region(cmt.id)\n-            };\n-\n-            self.compare_scope(cmt, scope_region)\n-          }\n-          cat_stack_upvar(cmt) => {\n-            self.preserve(cmt)\n-          }\n-          cat_local(local_id) => {\n-            // Normally, local variables are lendable, and so this\n-            // case should never trigger.  However, if we are\n-            // preserving an expression like a.b where the field `b`\n-            // has @ type, then it will recurse to ensure that the `a`\n-            // is stable to try and avoid rooting the value `a.b`.  In\n-            // this case, root_managed_data will be false.\n-            if self.root_managed_data {\n-                self.tcx().sess.span_bug(\n-                    cmt.span,\n-                    \"preserve() called with local and !root_managed_data\");\n-            }\n-            let local_region = self.tcx().region_maps.encl_region(local_id);\n-            self.compare_scope(cmt, local_region)\n-          }\n-          cat_binding(local_id) => {\n-            // Bindings are these kind of weird implicit pointers (cc\n-            // #2329).  We require (in gather_loans) that they be\n-            // rooted in an immutable location.\n-            let local_region = self.tcx().region_maps.encl_region(local_id);\n-            self.compare_scope(cmt, local_region)\n-          }\n-          cat_arg(local_id) => {\n-            // This can happen as not all args are lendable (e.g., &&\n-            // modes).  In that case, the caller guarantees stability\n-            // for at least the scope of the fn.  This is basically a\n-            // deref of a region ptr.\n-            let local_region = self.tcx().region_maps.encl_region(local_id);\n-            self.compare_scope(cmt, local_region)\n-          }\n-          cat_self(local_id) => {\n-            let local_region = self.tcx().region_maps.encl_region(local_id);\n-            self.compare_scope(cmt, local_region)\n-          }\n-          cat_comp(cmt_base, comp_field(*)) |\n-          cat_comp(cmt_base, comp_index(*)) |\n-          cat_comp(cmt_base, comp_tuple) |\n-          cat_comp(cmt_base, comp_anon_field) => {\n-            // Most embedded components: if the base is stable, the\n-            // type never changes.\n-            self.preserve(cmt_base)\n-          }\n-          cat_comp(cmt_base, comp_variant(enum_did)) => {\n-            if ty::enum_is_univariant(self.tcx(), enum_did) {\n-                self.preserve(cmt_base)\n-            } else {\n-                // If there are multiple variants: overwriting the\n-                // base could cause the type of this memory to change,\n-                // so require imm.\n-                self.require_imm(cmt, cmt_base, err_mut_variant)\n-            }\n-          }\n-          cat_deref(cmt_base, _, uniq_ptr) => {\n-            // Overwriting the base could cause this memory to be\n-            // freed, so require imm.\n-            self.require_imm(cmt, cmt_base, err_mut_uniq)\n-          }\n-          cat_deref(_, _, region_ptr(_, region)) => {\n-            // References are always \"stable\" for lifetime `region` by\n-            // induction (when the reference of type &MT was created,\n-            // the memory must have been stable).\n-            self.compare_scope(cmt, region)\n-          }\n-          cat_deref(_, _, unsafe_ptr) => {\n-            // Unsafe pointers are the user's problem\n-            Ok(PcOk)\n-          }\n-          cat_deref(base, derefs, gc_ptr(*)) => {\n-            // GC'd pointers of type @MT: if this pointer lives in\n-            // immutable, stable memory, then everything is fine.  But\n-            // otherwise we have no guarantee the pointer will stay\n-            // live, so we must root the pointer (i.e., inc the ref\n-            // count) for the duration of the loan.\n-            debug!(\"base.mutbl = %?\", base.mutbl);\n-            if cmt.cat.derefs_through_mutable_box() {\n-                self.attempt_root(cmt, base, derefs)\n-            } else if base.mutbl.is_immutable() {\n-                let non_rooting_ctxt = PreserveCtxt {\n-                    root_managed_data: false,\n-                    ..*self\n-                };\n-                match non_rooting_ctxt.preserve(base) {\n-                  Ok(PcOk) => {\n-                    Ok(PcOk)\n-                  }\n-                  Ok(PcIfPure(_)) => {\n-                    debug!(\"must root @T, otherwise purity req'd\");\n-                    self.attempt_root(cmt, base, derefs)\n-                  }\n-                  Err(ref e) => {\n-                    debug!(\"must root @T, err: %s\",\n-                           self.bccx.bckerr_to_str((*e)));\n-                    self.attempt_root(cmt, base, derefs)\n-                  }\n-                }\n-            } else {\n-                self.attempt_root(cmt, base, derefs)\n-            }\n-          }\n-          cat_discr(base, match_id) => {\n-            // Subtle: in a match, we must ensure that each binding\n-            // variable remains valid for the duration of the arm in\n-            // which it appears, presuming that this arm is taken.\n-            // But it is inconvenient in trans to root something just\n-            // for one arm.  Therefore, we insert a cat_discr(),\n-            // basically a special kind of category that says \"if this\n-            // value must be dynamically rooted, root it for the scope\n-            // `match_id`.\n-            //\n-            // As an example, consider this scenario:\n-            //\n-            //    let mut x = @Some(3);\n-            //    match *x { Some(y) {...} None {...} }\n-            //\n-            // Technically, the value `x` need only be rooted\n-            // in the `some` arm.  However, we evaluate `x` in trans\n-            // before we know what arm will be taken, so we just\n-            // always root it for the duration of the match.\n-            //\n-            // As a second example, consider *this* scenario:\n-            //\n-            //    let x = @mut @Some(3);\n-            //    match x { @@Some(y) {...} @@None {...} }\n-            //\n-            // Here again, `x` need only be rooted in the `some` arm.\n-            // In this case, the value which needs to be rooted is\n-            // found only when checking which pattern matches: but\n-            // this check is done before entering the arm.  Therefore,\n-            // even in this case we just choose to keep the value\n-            // rooted for the entire match.  This means the value will be\n-            // rooted even if the none arm is taken.  Oh well.\n-            //\n-            // At first, I tried to optimize the second case to only\n-            // root in one arm, but the result was suboptimal: first,\n-            // it interfered with the construction of phi nodes in the\n-            // arm, as we were adding code to root values before the\n-            // phi nodes were added.  This could have been addressed\n-            // with a second basic block.  However, the naive approach\n-            // also yielded suboptimal results for patterns like:\n-            //\n-            //    let x = @mut @...;\n-            //    match x { @@some_variant(y) | @@some_other_variant(y) =>\n-            //\n-            // The reason is that we would root the value once for\n-            // each pattern and not once per arm.  This is also easily\n-            // fixed, but it's yet more code for what is really quite\n-            // the corner case.\n-            //\n-            // Nonetheless, if you decide to optimize this case in the\n-            // future, you need only adjust where the cat_discr()\n-            // node appears to draw the line between what will be rooted\n-            // in the *arm* vs the *match*.\n-\n-              let match_rooting_ctxt = PreserveCtxt {\n-                  scope_region: ty::re_scope(match_id),\n-                  ..*self\n-              };\n-              match_rooting_ctxt.preserve(base)\n-          }\n-        }\n-    }\n-\n-    /// Reqiures that `cmt` (which is a deref or subcomponent of\n-    /// `base`) be found in an immutable location (that is, `base`\n-    /// must be immutable).  Also requires that `base` itself is\n-    /// preserved.\n-    fn require_imm(&self,\n-                   cmt: cmt,\n-                   cmt_base: cmt,\n-                   code: bckerr_code) -> bckres<PreserveCondition> {\n-        // Variant contents and unique pointers: must be immutably\n-        // rooted to a preserved address.\n-        match self.preserve(cmt_base) {\n-          // the base is preserved, but if we are not mutable then\n-          // purity is required\n-          Ok(PcOk) => {\n-              if !cmt_base.mutbl.is_immutable() {\n-                  Ok(PcIfPure(bckerr {cmt:cmt, code:code}))\n-              } else {\n-                  Ok(PcOk)\n-              }\n-          }\n-\n-          // the base requires purity too, that's fine\n-          Ok(PcIfPure(ref e)) => {\n-            Ok(PcIfPure((*e)))\n-          }\n-\n-          // base is not stable, doesn't matter\n-          Err(ref e) => {\n-            Err((*e))\n-          }\n-        }\n-    }\n-\n-    /// Checks that the scope for which the value must be preserved\n-    /// is a subscope of `scope_ub`; if so, success.\n-    fn compare_scope(&self,\n-                     cmt: cmt,\n-                     scope_ub: ty::Region) -> bckres<PreserveCondition> {\n-        if self.bccx.is_subregion_of(self.scope_region, scope_ub) {\n-            Ok(PcOk)\n-        } else {\n-            Err(bckerr {\n-                cmt:cmt,\n-                code:err_out_of_scope(scope_ub, self.scope_region)\n-            })\n-        }\n-    }\n-\n-    /// Here, `cmt=*base` is always a deref of managed data (if\n-    /// `derefs` != 0, then an auto-deref).  This routine determines\n-    /// whether it is safe to MAKE cmt stable by rooting the pointer\n-    /// `base`.  We can only do the dynamic root if the desired\n-    /// lifetime `self.scope_region` is a subset of `self.root_ub`\n-    /// scope; otherwise, it would either require that we hold the\n-    /// value live for longer than the current fn or else potentially\n-    /// require that an statically unbounded number of values be\n-    /// rooted (if a loop exists).\n-    fn attempt_root(&self, cmt: cmt, base: cmt,\n-                    derefs: uint) -> bckres<PreserveCondition> {\n-        if !self.root_managed_data {\n-            // normally, there is a root_ub; the only time that this\n-            // is none is when a boxed value is stored in an immutable\n-            // location.  In that case, we will test to see if that\n-            // immutable location itself can be preserved long enough\n-            // in which case no rooting is necessary.  But there it\n-            // would be sort of pointless to avoid rooting the inner\n-            // box by rooting an outer box, as it would just keep more\n-            // memory live than necessary, so we set root_ub to none.\n-            return Err(bckerr { cmt: cmt, code: err_root_not_permitted });\n-        }\n-\n-        let root_region = ty::re_scope(self.root_ub);\n-        match self.scope_region {\n-          // we can only root values if the desired region is some concrete\n-          // scope within the fn body\n-          ty::re_scope(scope_id) => {\n-            debug!(\"Considering root map entry for %s: \\\n-                    node %d:%u -> scope_id %?, root_ub %?\",\n-                   self.bccx.cmt_to_repr(cmt), base.id,\n-                   derefs, scope_id, self.root_ub);\n-            if self.bccx.is_subregion_of(self.scope_region, root_region) {\n-                debug!(\"Elected to root\");\n-                let rk = root_map_key { id: base.id, derefs: derefs };\n-                // This code could potentially lead cause boxes to be frozen\n-                // for longer than necessarily at runtime. It prevents an\n-                // ICE in trans; the fundamental problem is that it's hard\n-                // to make sure trans and borrowck have the same notion of\n-                // scope. The real fix is to clean up how trans handles\n-                // cleanups, but that's hard. If this becomes an issue, it's\n-                // an option to just change this to `let scope_to_use =\n-                // scope_id;`. Though that would potentially re-introduce\n-                // the ICE. See #3511 for more details.\n-                let scope_to_use = if\n-                    self.bccx.stmt_map.contains(&scope_id) {\n-                    // Root it in its parent scope, b/c\n-                    // trans won't introduce a new scope for the\n-                    // stmt\n-                    self.root_ub\n-                }\n-                else {\n-                    // Use the more precise scope\n-                    scope_id\n-                };\n-                // We freeze if and only if this is a *mutable* @ box that\n-                // we're borrowing into a pointer.\n-                self.bccx.root_map.insert(rk, RootInfo {\n-                    scope: scope_to_use,\n-                    freezes: cmt.cat.derefs_through_mutable_box()\n-                });\n-                return Ok(PcOk);\n-            } else {\n-                debug!(\"Unable to root\");\n-                return Err(bckerr {\n-                    cmt: cmt,\n-                    code: err_out_of_root_scope(root_region,\n-                                                self.scope_region)\n-                });\n-            }\n-          }\n-\n-          // we won't be able to root long enough\n-          _ => {\n-              return Err(bckerr {\n-                cmt:cmt,\n-                code:err_out_of_root_scope(root_region, self.scope_region)\n-              });\n-          }\n-\n-        }\n-    }\n-}"}, {"sha": "9e6d90532373a5aeb5deb36f841720696d4a9ac6", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -237,7 +237,7 @@ pub fn check_item_recursion(sess: Session,\n             match env.def_map.find(&e.id) {\n               Some(&def_const(def_id)) => {\n                 if ast_util::is_local(def_id) {\n-                  match *env.ast_map.get(&def_id.node) {\n+                  match env.ast_map.get_copy(&def_id.node) {\n                     ast_map::node_item(it, _) => {\n                       (v.visit_item)(it, env, v);\n                     }"}, {"sha": "a50895aa013b5a22ff676bbe34358ab4a3c0e927", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -523,7 +523,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                 }\n             }\n             pat_enum(_, args) => {\n-                match *cx.tcx.def_map.get(&pat_id) {\n+                match cx.tcx.def_map.get_copy(&pat_id) {\n                     def_const(did) => {\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).get();\n@@ -567,7 +567,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             }\n             pat_struct(_, ref flds, _) => {\n                 // Is this a struct or an enum variant?\n-                match *cx.tcx.def_map.get(&pat_id) {\n+                match cx.tcx.def_map.get_copy(&pat_id) {\n                     def_variant(_, variant_id) => {\n                         if variant(variant_id) == *ctor_id {\n                             // FIXME #4731: Is this right? --pcw"}, {"sha": "7c1933d67853a95515bf9c30850240c5cf942185", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -185,9 +185,7 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n         }\n     } else {\n         let maps = astencode::Maps {\n-            mutbl_map: @mut HashSet::new(),\n             root_map: @mut HashMap::new(),\n-            last_use_map: @mut HashMap::new(),\n             method_map: @mut HashMap::new(),\n             vtable_map: @mut HashMap::new(),\n             write_guard_map: @mut HashSet::new(),"}, {"sha": "ccb34851046bd9fa120cb1d52a985d4033c6900c", "filename": "src/librustc/middle/dataflow.rs", "status": "added", "additions": 1008, "deletions": 0, "changes": 1008, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -0,0 +1,1008 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+/*!\n+ * A module for propagating forward dataflow information. The analysis\n+ * assumes that the items to be propagated can be represented as bits\n+ * and thus uses bitvectors. Your job is simply to specify the so-called\n+ * GEN and KILL bits for each expression.\n+ */\n+\n+use core::prelude::*;\n+use core::cast;\n+use core::uint;\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::ast_util::id_range;\n+use syntax::print::{pp, pprust};\n+use middle::ty;\n+use middle::typeck;\n+use util::ppaux::Repr;\n+\n+pub struct DataFlowContext<O> {\n+    priv tcx: ty::ctxt,\n+    priv method_map: typeck::method_map,\n+\n+    /// the data flow operator\n+    priv oper: O,\n+\n+    /// range of ids that appear within the item in question\n+    priv id_range: id_range,\n+\n+    /// number of bits to propagate per id\n+    priv bits_per_id: uint,\n+\n+    /// number of words we will use to store bits_per_id.\n+    /// equal to bits_per_id/uint::bits rounded up.\n+    priv words_per_id: uint,\n+\n+    // Bit sets per id.  The following three fields (`gens`, `kills`,\n+    // and `on_entry`) all have the same structure. For each id in\n+    // `id_range`, there is a range of words equal to `words_per_id`.\n+    // So, to access the bits for any given id, you take a slice of\n+    // the full vector (see the method `compute_id_range()`).\n+\n+    /// bits generated as we exit the scope `id`. Updated by `add_gen()`.\n+    priv gens: ~[uint],\n+\n+    /// bits killed as we exit the scope `id`. Updated by `add_kill()`.\n+    priv kills: ~[uint],\n+\n+    /// bits that are valid on entry to the scope `id`. Updated by\n+    /// `propagate()`.\n+    priv on_entry: ~[uint]\n+}\n+\n+/// Parameterization for the precise form of data flow that is used.\n+pub trait DataFlowOperator {\n+    /// Specifies the initial value for each bit in the `on_entry` set\n+    fn initial_value(&self) -> bool;\n+\n+    /// Joins two predecessor bits together, typically either `|` or `&`\n+    fn join(&self, succ: uint, pred: uint) -> uint;\n+\n+    /// True if we should propagate through closures\n+    fn walk_closures(&self) -> bool;\n+}\n+\n+struct PropagationContext<'self, O> {\n+    dfcx: &'self mut DataFlowContext<O>,\n+    changed: bool\n+}\n+\n+#[deriving(Eq)]\n+enum LoopKind {\n+    /// A `while` or `loop` loop\n+    TrueLoop,\n+\n+    /// A `for` \"loop\" (i.e., really a func call where `break`, `return`,\n+    /// and `loop` all essentially perform an early return from the closure)\n+    ForLoop\n+}\n+\n+struct LoopScope<'self> {\n+    loop_id: ast::node_id,\n+    loop_kind: LoopKind,\n+    break_bits: ~[uint]\n+}\n+\n+impl<O:DataFlowOperator> DataFlowContext<O> {\n+    pub fn new(tcx: ty::ctxt,\n+               method_map: typeck::method_map,\n+               oper: O,\n+               id_range: id_range,\n+               bits_per_id: uint) -> DataFlowContext<O> {\n+        let words_per_id = (bits_per_id + uint::bits - 1) / uint::bits;\n+\n+        debug!(\"DataFlowContext::new(id_range=%?, bits_per_id=%?, words_per_id=%?)\",\n+               id_range, bits_per_id, words_per_id);\n+\n+        let len = (id_range.max - id_range.min) as uint * words_per_id;\n+        let gens = vec::from_elem(len, 0);\n+        let kills = vec::from_elem(len, 0);\n+        let elem = if oper.initial_value() {uint::max_value} else {0};\n+        let on_entry = vec::from_elem(len, elem);\n+\n+        DataFlowContext {\n+            tcx: tcx,\n+            method_map: method_map,\n+            words_per_id: words_per_id,\n+            bits_per_id: bits_per_id,\n+            oper: oper,\n+            id_range: id_range,\n+            gens: gens,\n+            kills: kills,\n+            on_entry: on_entry\n+        }\n+    }\n+\n+    pub fn add_gen(&mut self, id: ast::node_id, bit: uint) {\n+        //! Indicates that `id` generates `bit`\n+\n+        debug!(\"add_gen(id=%?, bit=%?)\", id, bit);\n+        let (start, end) = self.compute_id_range(id);\n+        {\n+            let gens = vec::mut_slice(self.gens, start, end);\n+            set_bit(gens, bit);\n+        }\n+    }\n+\n+    pub fn add_kill(&mut self, id: ast::node_id, bit: uint) {\n+        //! Indicates that `id` kills `bit`\n+\n+        debug!(\"add_kill(id=%?, bit=%?)\", id, bit);\n+        let (start, end) = self.compute_id_range(id);\n+        {\n+            let kills = vec::mut_slice(self.kills, start, end);\n+            set_bit(kills, bit);\n+        }\n+    }\n+\n+    fn apply_gen_kill(&self, id: ast::node_id, bits: &mut [uint]) {\n+        //! Applies the gen and kill sets for `id` to `bits`\n+\n+        debug!(\"apply_gen_kill(id=%?, bits=%s) [before]\",\n+               id, mut_bits_to_str(bits));\n+        let (start, end) = self.compute_id_range(id);\n+        let gens = self.gens.slice(start, end);\n+        bitwise(bits, gens, |a, b| a | b);\n+        let kills = self.kills.slice(start, end);\n+        bitwise(bits, kills, |a, b| a & !b);\n+\n+        debug!(\"apply_gen_kill(id=%?, bits=%s) [after]\",\n+               id, mut_bits_to_str(bits));\n+    }\n+\n+    fn apply_kill(&self, id: ast::node_id, bits: &mut [uint]) {\n+        debug!(\"apply_kill(id=%?, bits=%s) [before]\",\n+               id, mut_bits_to_str(bits));\n+        let (start, end) = self.compute_id_range(id);\n+        let kills = self.kills.slice(start, end);\n+        bitwise(bits, kills, |a, b| a & !b);\n+        debug!(\"apply_kill(id=%?, bits=%s) [after]\",\n+               id, mut_bits_to_str(bits));\n+    }\n+\n+    fn compute_id_range(&self, absolute_id: ast::node_id) -> (uint, uint) {\n+        assert!(absolute_id >= self.id_range.min);\n+        assert!(absolute_id < self.id_range.max);\n+\n+        let relative_id = absolute_id - self.id_range.min;\n+        let start = (relative_id as uint) * self.words_per_id;\n+        let end = start + self.words_per_id;\n+        (start, end)\n+    }\n+\n+\n+    pub fn each_bit_on_entry(&self,\n+                             id: ast::node_id,\n+                             f: &fn(uint) -> bool) {\n+        //! Iterates through each bit that is set on entry to `id`.\n+        //! Only useful after `propagate()` has been called.\n+\n+        let (start, end) = self.compute_id_range(id);\n+        let on_entry = vec::slice(self.on_entry, start, end);\n+        debug!(\"each_bit_on_entry(id=%?, on_entry=%s)\",\n+               id, bits_to_str(on_entry));\n+        self.each_bit(on_entry, f);\n+    }\n+\n+    pub fn each_gen_bit(&self,\n+                        id: ast::node_id,\n+                        f: &fn(uint) -> bool) {\n+        //! Iterates through each bit in the gen set for `id`.\n+\n+        let (start, end) = self.compute_id_range(id);\n+        let gens = vec::slice(self.gens, start, end);\n+        debug!(\"each_gen_bit(id=%?, gens=%s)\",\n+               id, bits_to_str(gens));\n+        self.each_bit(gens, f)\n+    }\n+\n+    fn each_bit(&self,\n+                words: &[uint],\n+                f: &fn(uint) -> bool) {\n+        //! Helper for iterating over the bits in a bit set.\n+\n+        for words.eachi |word_index, &word| {\n+            if word != 0 {\n+                let base_index = word_index * uint::bits;\n+                for uint::range(0, uint::bits) |offset| {\n+                    let bit = 1 << offset;\n+                    if (word & bit) != 0 {\n+                        // NB: we round up the total number of bits\n+                        // that we store in any given bit set so that\n+                        // it is an even multiple of uint::bits.  This\n+                        // means that there may be some stray bits at\n+                        // the end that do not correspond to any\n+                        // actual value.  So before we callback, check\n+                        // whether the bit_index is greater than the\n+                        // actual value the user specified and stop\n+                        // iterating if so.\n+                        let bit_index = base_index + offset;\n+                        if bit_index >= self.bits_per_id || !f(bit_index) {\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<O:DataFlowOperator+Copy+'static> DataFlowContext<O> {\n+//                      ^^^^^^^^^^^^ only needed for pretty printing\n+    pub fn propagate(&mut self, blk: &ast::blk) {\n+        //! Performs the data flow analysis.\n+\n+        if self.bits_per_id == 0 {\n+            // Optimize the surprisingly common degenerate case.\n+            return;\n+        }\n+\n+        let mut propcx = PropagationContext {\n+            dfcx: self,\n+            changed: true\n+        };\n+\n+        let mut temp = vec::from_elem(self.words_per_id, 0);\n+        let mut loop_scopes = ~[];\n+\n+        while propcx.changed {\n+            propcx.changed = false;\n+            propcx.reset(temp);\n+            propcx.walk_block(blk, temp, &mut loop_scopes);\n+        }\n+\n+        debug!(\"Dataflow result:\");\n+        debug!(\"%s\", {\n+            let this = @copy *self;\n+            this.pretty_print_to(io::stderr(), blk);\n+            \"\"\n+        });\n+    }\n+\n+    fn pretty_print_to(@self, wr: @io::Writer, blk: &ast::blk) {\n+        let pre: @fn(pprust::ann_node) = |node| {\n+            let (ps, id) = match node {\n+                pprust::node_expr(ps, expr) => (ps, expr.id),\n+                pprust::node_block(ps, blk) => (ps, blk.node.id),\n+                pprust::node_item(ps, _) => (ps, 0),\n+                pprust::node_pat(ps, pat) => (ps, pat.id)\n+            };\n+\n+            if id >= self.id_range.min || id < self.id_range.max {\n+                let (start, end) = self.compute_id_range(id);\n+                let on_entry = vec::slice(self.on_entry, start, end);\n+                let entry_str = bits_to_str(on_entry);\n+\n+                let gens = vec::slice(self.gens, start, end);\n+                let gens_str = if gens.any(|&u| u != 0) {\n+                    fmt!(\" gen: %s\", bits_to_str(gens))\n+                } else {\n+                    ~\"\"\n+                };\n+\n+                let kills = vec::slice(self.kills, start, end);\n+                let kills_str = if kills.any(|&u| u != 0) {\n+                    fmt!(\" kill: %s\", bits_to_str(kills))\n+                } else {\n+                    ~\"\"\n+                };\n+\n+                let comment_str = fmt!(\"id %d: %s%s%s\",\n+                                       id, entry_str, gens_str, kills_str);\n+                pprust::synth_comment(ps, comment_str);\n+                pp::space(ps.s);\n+            }\n+        };\n+\n+        let post: @fn(pprust::ann_node) = |_| {\n+        };\n+\n+        let ps = pprust::rust_printer_annotated(\n+            wr, self.tcx.sess.intr(),\n+            pprust::pp_ann {pre:pre, post:post});\n+        pprust::cbox(ps, pprust::indent_unit);\n+        pprust::ibox(ps, 0u);\n+        pprust::print_block(ps, blk);\n+        pp::eof(ps.s);\n+    }\n+}\n+\n+impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.dfcx.tcx\n+    }\n+\n+    fn walk_block(&mut self,\n+                  blk: &ast::blk,\n+                  in_out: &mut [uint],\n+                  loop_scopes: &mut ~[LoopScope]) {\n+        debug!(\"DataFlowContext::walk_block(blk.node.id=%?, in_out=%s)\",\n+               blk.node.id, bits_to_str(reslice(in_out)));\n+\n+        self.merge_with_entry_set(blk.node.id, in_out);\n+\n+        for blk.node.stmts.each |&stmt| {\n+            self.walk_stmt(stmt, in_out, loop_scopes);\n+        }\n+\n+        self.walk_opt_expr(blk.node.expr, in_out, loop_scopes);\n+\n+        self.dfcx.apply_gen_kill(blk.node.id, in_out);\n+    }\n+\n+    fn walk_stmt(&mut self,\n+                 stmt: @ast::stmt,\n+                 in_out: &mut [uint],\n+                 loop_scopes: &mut ~[LoopScope]) {\n+        match stmt.node {\n+            ast::stmt_decl(decl, _) => {\n+                self.walk_decl(decl, in_out, loop_scopes);\n+            }\n+\n+            ast::stmt_expr(expr, _) | ast::stmt_semi(expr, _) => {\n+                self.walk_expr(expr, in_out, loop_scopes);\n+            }\n+\n+            ast::stmt_mac(*) => {\n+                self.tcx().sess.span_bug(stmt.span, ~\"unexpanded macro\");\n+            }\n+        }\n+    }\n+\n+    fn walk_decl(&mut self,\n+                 decl: @ast::decl,\n+                 in_out: &mut [uint],\n+                 loop_scopes: &mut ~[LoopScope]) {\n+        match decl.node {\n+            ast::decl_local(ref locals) => {\n+                for locals.each |local| {\n+                    self.walk_pat(local.node.pat, in_out, loop_scopes);\n+                    self.walk_opt_expr(local.node.init, in_out, loop_scopes);\n+                }\n+            }\n+\n+            ast::decl_item(_) => {}\n+        }\n+    }\n+\n+    fn walk_expr(&mut self,\n+                 expr: @ast::expr,\n+                 in_out: &mut [uint],\n+                 loop_scopes: &mut ~[LoopScope]) {\n+        debug!(\"DataFlowContext::walk_expr(expr=%s, in_out=%s)\",\n+               expr.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n+\n+        self.merge_with_entry_set(expr.id, in_out);\n+\n+        match expr.node {\n+            ast::expr_fn_block(ref decl, ref body) => {\n+                if self.dfcx.oper.walk_closures() {\n+                    // In the absence of once fns, we must assume that\n+                    // every function body will execute more than\n+                    // once. Thus we treat every function body like a\n+                    // loop.\n+                    //\n+                    // What is subtle and a bit tricky, also, is how\n+                    // to deal with the \"output\" bits---that is, what\n+                    // do we consider to be the successor of a\n+                    // function body, given that it could be called\n+                    // from any point within its lifetime? What we do\n+                    // is to add their effects immediately as of the\n+                    // point of creation. Of course we have to ensure\n+                    // that this is sound for the analyses which make\n+                    // use of dataflow.\n+                    //\n+                    // In the case of the initedness checker (which\n+                    // does not currently use dataflow, but I hope to\n+                    // convert at some point), we will simply not walk\n+                    // closures at all, so it's a moot point.\n+                    //\n+                    // In the case of the borrow checker, this means\n+                    // the loans which would be created by calling a\n+                    // function come into effect immediately when the\n+                    // function is created. This is guaranteed to be\n+                    // earlier than the point at which the loan\n+                    // actually comes into scope (which is the point\n+                    // at which the closure is *called*). Because\n+                    // loans persist until the scope of the loans is\n+                    // exited, it is always a safe approximation to\n+                    // have a loan begin earlier than it actually will\n+                    // at runtime, so this should be sound.\n+                    //\n+                    // We stil have to be careful in the region\n+                    // checker and borrow checker to treat function\n+                    // bodies like loops, which implies some\n+                    // limitations. For example, a closure cannot root\n+                    // a managed box for longer than its body.\n+                    //\n+                    // General control flow looks like this:\n+                    //\n+                    //  +- (expr) <----------+\n+                    //  |    |               |\n+                    //  |    v               |\n+                    //  |  (body) -----------+--> (exit)\n+                    //  |    |               |\n+                    //  |    + (break/loop) -+\n+                    //  |                    |\n+                    //  +--------------------+\n+                    //\n+                    // This is a bit more conservative than a loop.\n+                    // Note that we must assume that even after a\n+                    // `break` occurs (e.g., in a `for` loop) that the\n+                    // closure may be reinvoked.\n+                    //\n+                    // One difference from other loops is that `loop`\n+                    // and `break` statements which target a closure\n+                    // both simply add to the `break_bits`.\n+\n+                    // func_bits represents the state when the function\n+                    // returns\n+                    let mut func_bits = reslice(in_out).to_vec();\n+\n+                    loop_scopes.push(LoopScope {\n+                        loop_id: expr.id,\n+                        loop_kind: ForLoop,\n+                        break_bits: reslice(in_out).to_vec()\n+                    });\n+                    for decl.inputs.each |input| {\n+                        self.walk_pat(input.pat, func_bits, loop_scopes);\n+                    }\n+                    self.walk_block(body, func_bits, loop_scopes);\n+\n+                    // add the bits from any early return via `break`,\n+                    // `continue`, or `return` into `func_bits`\n+                    let loop_scope = loop_scopes.pop();\n+                    join_bits(&self.dfcx.oper, loop_scope.break_bits, func_bits);\n+\n+                    // add `func_bits` to the entry bits for `expr`,\n+                    // since we must assume the function may be called\n+                    // more than once\n+                    self.add_to_entry_set(expr.id, reslice(func_bits));\n+\n+                    // the final exit bits include whatever was present\n+                    // in the original, joined with the bits from the function\n+                    join_bits(&self.dfcx.oper, func_bits, in_out);\n+                }\n+            }\n+\n+            ast::expr_if(cond, ref then, els) => {\n+                //\n+                //     (cond)\n+                //       |\n+                //       v\n+                //      ( )\n+                //     /   \\\n+                //    |     |\n+                //    v     v\n+                //  (then)(els)\n+                //    |     |\n+                //    v     v\n+                //   (  succ  )\n+                //\n+                self.walk_expr(cond, in_out, loop_scopes);\n+\n+                let mut then_bits = reslice(in_out).to_vec();\n+                self.walk_block(then, then_bits, loop_scopes);\n+\n+                self.walk_opt_expr(els, in_out, loop_scopes);\n+                join_bits(&self.dfcx.oper, then_bits, in_out);\n+            }\n+\n+            ast::expr_while(cond, ref blk) => {\n+                //\n+                //     (expr) <--+\n+                //       |       |\n+                //       v       |\n+                //  +--(cond)    |\n+                //  |    |       |\n+                //  |    v       |\n+                //  v  (blk) ----+\n+                //       |\n+                //    <--+ (break)\n+                //\n+\n+                self.walk_expr(cond, in_out, loop_scopes);\n+\n+                let mut body_bits = reslice(in_out).to_vec();\n+                loop_scopes.push(LoopScope {\n+                    loop_id: expr.id,\n+                    loop_kind: TrueLoop,\n+                    break_bits: reslice(in_out).to_vec()\n+                });\n+                self.walk_block(blk, body_bits, loop_scopes);\n+                self.add_to_entry_set(expr.id, body_bits);\n+                let new_loop_scope = loop_scopes.pop();\n+                copy_bits(new_loop_scope.break_bits, in_out);\n+            }\n+\n+            ast::expr_loop(ref blk, _) => {\n+                //\n+                //     (expr) <--+\n+                //       |       |\n+                //       v       |\n+                //     (blk) ----+\n+                //       |\n+                //    <--+ (break)\n+                //\n+\n+                let mut body_bits = reslice(in_out).to_vec();\n+                self.reset(in_out);\n+                loop_scopes.push(LoopScope {\n+                    loop_id: expr.id,\n+                    loop_kind: TrueLoop,\n+                    break_bits: reslice(in_out).to_vec()\n+                });\n+                self.walk_block(blk, body_bits, loop_scopes);\n+                self.add_to_entry_set(expr.id, body_bits);\n+\n+                let new_loop_scope = loop_scopes.pop();\n+                assert_eq!(new_loop_scope.loop_id, expr.id);\n+                copy_bits(new_loop_scope.break_bits, in_out);\n+            }\n+\n+            ast::expr_match(discr, ref arms) => {\n+                //\n+                //    (discr)\n+                //     / | \\\n+                //    |  |  |\n+                //    v  v  v\n+                //   (..arms..)\n+                //    |  |  |\n+                //    v  v  v\n+                //   (  succ  )\n+                //\n+                //\n+                self.walk_expr(discr, in_out, loop_scopes);\n+\n+                let mut guards = reslice(in_out).to_vec();\n+\n+                // We know that exactly one arm will be taken, so we\n+                // can start out with a blank slate and just union\n+                // together the bits from each arm:\n+                self.reset(in_out);\n+\n+                for arms.each |arm| {\n+                    // in_out reflects the discr and all guards to date\n+                    self.walk_opt_expr(arm.guard, guards, loop_scopes);\n+\n+                    // determine the bits for the body and then union\n+                    // them into `in_out`, which reflects all bodies to date\n+                    let mut body = reslice(guards).to_vec();\n+                    self.walk_pat_alternatives(arm.pats, body, loop_scopes);\n+                    self.walk_block(&arm.body, body, loop_scopes);\n+                    join_bits(&self.dfcx.oper, body, in_out);\n+                }\n+            }\n+\n+            ast::expr_ret(o_e) => {\n+                self.walk_opt_expr(o_e, in_out, loop_scopes);\n+\n+                // is this a return from a `for`-loop closure?\n+                match loop_scopes.position(|s| s.loop_kind == ForLoop) {\n+                    Some(i) => {\n+                        // if so, add the in_out bits to the state\n+                        // upon exit. Remember that we cannot count\n+                        // upon the `for` loop function not to invoke\n+                        // the closure again etc.\n+                        self.break_from_to(expr, &mut loop_scopes[i], in_out);\n+                    }\n+\n+                    None => {}\n+                }\n+\n+                self.reset(in_out);\n+            }\n+\n+            ast::expr_break(label) => {\n+                let scope = self.find_scope(expr, label, loop_scopes);\n+                self.break_from_to(expr, scope, in_out);\n+                self.reset(in_out);\n+            }\n+\n+            ast::expr_again(label) => {\n+                let scope = self.find_scope(expr, label, loop_scopes);\n+\n+                match scope.loop_kind {\n+                    TrueLoop => {\n+                        self.pop_scopes(expr, scope, in_out);\n+                        self.add_to_entry_set(scope.loop_id, reslice(in_out));\n+                    }\n+\n+                    ForLoop => {\n+                        // If this `loop` construct is looping back to a `for`\n+                        // loop, then `loop` is really just a return from the\n+                        // closure. Therefore, we treat it the same as `break`.\n+                        // See case for `expr_fn_block` for more details.\n+                        self.break_from_to(expr, scope, in_out);\n+                    }\n+                }\n+\n+                self.reset(in_out);\n+            }\n+\n+            ast::expr_assign(l, r) |\n+            ast::expr_assign_op(_, l, r) => {\n+                self.walk_expr(r, in_out, loop_scopes);\n+                self.walk_expr(l, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_swap(l, r) => {\n+                self.walk_expr(l, in_out, loop_scopes);\n+                self.walk_expr(r, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_vec(ref exprs, _) => {\n+                self.walk_exprs(*exprs, in_out, loop_scopes)\n+            }\n+\n+            ast::expr_repeat(l, r, _) => {\n+                self.walk_expr(l, in_out, loop_scopes);\n+                self.walk_expr(r, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_struct(_, ref fields, with_expr) => {\n+                self.walk_opt_expr(with_expr, in_out, loop_scopes);\n+                for fields.each |field| {\n+                    self.walk_expr(field.node.expr, in_out, loop_scopes);\n+                }\n+            }\n+\n+            ast::expr_call(f, ref args, _) => {\n+                self.walk_call(expr.callee_id, expr.id,\n+                               f, *args, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_method_call(rcvr, _, _, ref args, _) => {\n+                self.walk_call(expr.callee_id, expr.id,\n+                               rcvr, *args, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_index(l, r) |\n+            ast::expr_binary(_, l, r) if self.is_method_call(expr) => {\n+                self.walk_call(expr.callee_id, expr.id,\n+                               l, [r], in_out, loop_scopes);\n+            }\n+\n+            ast::expr_unary(_, e) if self.is_method_call(expr) => {\n+                self.walk_call(expr.callee_id, expr.id,\n+                               e, [], in_out, loop_scopes);\n+            }\n+\n+            ast::expr_tup(ref exprs) => {\n+                self.walk_exprs(*exprs, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_binary(op, l, r) if ast_util::lazy_binop(op) => {\n+                self.walk_expr(l, in_out, loop_scopes);\n+                let temp = reslice(in_out).to_vec();\n+                self.walk_expr(r, in_out, loop_scopes);\n+                join_bits(&self.dfcx.oper, temp, in_out);\n+            }\n+\n+            ast::expr_log(l, r) |\n+            ast::expr_index(l, r) |\n+            ast::expr_binary(_, l, r) => {\n+                self.walk_exprs([l, r], in_out, loop_scopes);\n+            }\n+\n+            ast::expr_lit(*) |\n+            ast::expr_path(*) => {\n+            }\n+\n+            ast::expr_addr_of(_, e) |\n+            ast::expr_copy(e) |\n+            ast::expr_loop_body(e) |\n+            ast::expr_do_body(e) |\n+            ast::expr_cast(e, _) |\n+            ast::expr_unary(_, e) |\n+            ast::expr_paren(e) |\n+            ast::expr_vstore(e, _) |\n+            ast::expr_field(e, _, _) => {\n+                self.walk_expr(e, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_inline_asm(ref inline_asm) => {\n+                for inline_asm.inputs.each |&(_, expr)| {\n+                    self.walk_expr(expr, in_out, loop_scopes);\n+                }\n+                for inline_asm.outputs.each |&(_, expr)| {\n+                    self.walk_expr(expr, in_out, loop_scopes);\n+                }\n+            }\n+\n+            ast::expr_block(ref blk) => {\n+                self.walk_block(blk, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_mac(*) => {\n+                self.tcx().sess.span_bug(expr.span, ~\"unexpanded macro\");\n+            }\n+        }\n+\n+        self.dfcx.apply_gen_kill(expr.id, in_out);\n+    }\n+\n+    fn pop_scopes(&mut self,\n+                  from_expr: @ast::expr,\n+                  to_scope: &mut LoopScope,\n+                  in_out: &mut [uint]) {\n+        //! Whenever you have a `break` or a `loop` statement, flow\n+        //! exits through any number of enclosing scopes on its\n+        //! way to the new destination. This function applies the kill\n+        //! sets of those enclosing scopes to `in_out` (those kill sets\n+        //! concern items that are going out of scope).\n+\n+        let tcx = self.tcx();\n+        let region_maps = tcx.region_maps;\n+\n+        debug!(\"pop_scopes(from_expr=%s, to_scope=%?, in_out=%s)\",\n+               from_expr.repr(tcx), to_scope.loop_id,\n+               bits_to_str(reslice(in_out)));\n+\n+        let mut id = from_expr.id;\n+        while id != to_scope.loop_id {\n+            self.dfcx.apply_kill(id, in_out);\n+\n+            match region_maps.opt_encl_scope(id) {\n+                Some(i) => { id = i; }\n+                None => {\n+                    tcx.sess.span_bug(\n+                        from_expr.span,\n+                        fmt!(\"pop_scopes(from_expr=%s, to_scope=%?) \\\n+                              to_scope does not enclose from_expr\",\n+                             from_expr.repr(tcx), to_scope.loop_id));\n+                }\n+            }\n+        }\n+    }\n+\n+    fn break_from_to(&mut self,\n+                     from_expr: @ast::expr,\n+                     to_scope: &mut LoopScope,\n+                     in_out: &mut [uint]) {\n+        self.pop_scopes(from_expr, to_scope, in_out);\n+        self.dfcx.apply_kill(from_expr.id, in_out);\n+        join_bits(&self.dfcx.oper, reslice(in_out), to_scope.break_bits);\n+        debug!(\"break_from_to(from_expr=%s, to_scope=%?) final break_bits=%s\",\n+               from_expr.repr(self.tcx()),\n+               to_scope.loop_id,\n+               bits_to_str(reslice(in_out)));\n+    }\n+\n+    fn walk_exprs(&mut self,\n+                  exprs: &[@ast::expr],\n+                  in_out: &mut [uint],\n+                  loop_scopes: &mut ~[LoopScope]) {\n+        for exprs.each |&expr| {\n+            self.walk_expr(expr, in_out, loop_scopes);\n+        }\n+    }\n+\n+    fn walk_opt_expr(&mut self,\n+                     opt_expr: Option<@ast::expr>,\n+                     in_out: &mut [uint],\n+                     loop_scopes: &mut ~[LoopScope]) {\n+        for opt_expr.each |&expr| {\n+            self.walk_expr(expr, in_out, loop_scopes);\n+        }\n+    }\n+\n+    fn walk_call(&mut self,\n+                 _callee_id: ast::node_id,\n+                 call_id: ast::node_id,\n+                 arg0: @ast::expr,\n+                 args: &[@ast::expr],\n+                 in_out: &mut [uint],\n+                 loop_scopes: &mut ~[LoopScope]) {\n+        self.walk_expr(arg0, in_out, loop_scopes);\n+        self.walk_exprs(args, in_out, loop_scopes);\n+\n+        // FIXME(#6268) nested method calls\n+        // self.merge_with_entry_set(callee_id, in_out);\n+        // self.dfcx.apply_gen_kill(callee_id, in_out);\n+\n+        let return_ty = ty::node_id_to_type(self.tcx(), call_id);\n+        let fails = ty::type_is_bot(return_ty);\n+        if fails {\n+            self.reset(in_out);\n+        }\n+    }\n+\n+    fn walk_pat(&mut self,\n+                pat: @ast::pat,\n+                in_out: &mut [uint],\n+                _loop_scopes: &mut ~[LoopScope]) {\n+        debug!(\"DataFlowContext::walk_pat(pat=%s, in_out=%s)\",\n+               pat.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n+\n+        do ast_util::walk_pat(pat) |p| {\n+            debug!(\"  p.id=%? in_out=%s\", p.id, bits_to_str(reslice(in_out)));\n+            self.merge_with_entry_set(p.id, in_out);\n+            self.dfcx.apply_gen_kill(p.id, in_out);\n+        }\n+    }\n+\n+    fn walk_pat_alternatives(&mut self,\n+                             pats: &[@ast::pat],\n+                             in_out: &mut [uint],\n+                             loop_scopes: &mut ~[LoopScope]) {\n+        if pats.len() == 1 {\n+            // Common special case:\n+            return self.walk_pat(pats[0], in_out, loop_scopes);\n+        }\n+\n+        // In the general case, the patterns in `pats` are\n+        // alternatives, so we must treat this like an N-way select\n+        // statement.\n+        let initial_state = reslice(in_out).to_vec();\n+        for pats.each |&pat| {\n+            let mut temp = copy initial_state;\n+            self.walk_pat(pat, temp, loop_scopes);\n+            join_bits(&self.dfcx.oper, temp, in_out);\n+        }\n+    }\n+\n+    fn find_scope<'a>(&self,\n+                      expr: @ast::expr,\n+                      label: Option<ast::ident>,\n+                      loop_scopes: &'a mut ~[LoopScope]) -> &'a mut LoopScope {\n+        let index = match label {\n+            None => {\n+                let len = loop_scopes.len();\n+                len - 1\n+            }\n+\n+            Some(_) => {\n+                match self.tcx().def_map.find(&expr.id) {\n+                    Some(&ast::def_label(loop_id)) => {\n+                        match loop_scopes.position(|l| l.loop_id == loop_id) {\n+                            Some(i) => i,\n+                            None => {\n+                                self.tcx().sess.span_bug(\n+                                    expr.span,\n+                                    fmt!(\"No loop scope for id %?\", loop_id));\n+                            }\n+                        }\n+                    }\n+\n+                    r => {\n+                        self.tcx().sess.span_bug(\n+                            expr.span,\n+                            fmt!(\"Bad entry `%?` in def_map for label\", r));\n+                    }\n+                }\n+            }\n+        };\n+\n+        &mut loop_scopes[index]\n+    }\n+\n+    fn is_method_call(&self, expr: @ast::expr) -> bool {\n+        self.dfcx.method_map.contains_key(&expr.id)\n+    }\n+\n+    fn reset(&mut self, bits: &mut [uint]) {\n+        let e = if self.dfcx.oper.initial_value() {uint::max_value} else {0};\n+        for vec::each_mut(bits) |b| { *b = e; }\n+    }\n+\n+    fn add_to_entry_set(&mut self, id: ast::node_id, pred_bits: &[uint]) {\n+        debug!(\"add_to_entry_set(id=%?, pred_bits=%s)\",\n+               id, bits_to_str(pred_bits));\n+        let (start, end) = self.dfcx.compute_id_range(id);\n+        let changed = { // FIXME(#5074) awkward construction\n+            let on_entry = vec::mut_slice(self.dfcx.on_entry, start, end);\n+            join_bits(&self.dfcx.oper, pred_bits, on_entry)\n+        };\n+        if changed {\n+            debug!(\"changed entry set for %? to %s\",\n+                   id, bits_to_str(self.dfcx.on_entry.slice(start, end)));\n+            self.changed = true;\n+        }\n+    }\n+\n+    fn merge_with_entry_set(&mut self,\n+                            id: ast::node_id,\n+                            pred_bits: &mut [uint]) {\n+        debug!(\"merge_with_entry_set(id=%?, pred_bits=%s)\",\n+               id, mut_bits_to_str(pred_bits));\n+        let (start, end) = self.dfcx.compute_id_range(id);\n+        let changed = { // FIXME(#5074) awkward construction\n+            let on_entry = vec::mut_slice(self.dfcx.on_entry, start, end);\n+            let changed = join_bits(&self.dfcx.oper, reslice(pred_bits), on_entry);\n+            copy_bits(reslice(on_entry), pred_bits);\n+            changed\n+        };\n+        if changed {\n+            debug!(\"changed entry set for %? to %s\",\n+                   id, bits_to_str(self.dfcx.on_entry.slice(start, end)));\n+            self.changed = true;\n+        }\n+    }\n+}\n+\n+fn mut_bits_to_str(words: &mut [uint]) -> ~str {\n+    bits_to_str(reslice(words))\n+}\n+\n+fn bits_to_str(words: &[uint]) -> ~str {\n+    let mut result = ~\"\";\n+    let mut sep = '[';\n+\n+    // Note: this is a little endian printout of bytes.\n+\n+    for words.each |&word| {\n+        let mut v = word;\n+        for uint::range(0, uint::bytes) |_| {\n+            str::push_char(&mut result, sep);\n+            str::push_str(&mut result, fmt!(\"%02x\", v & 0xFF));\n+            v >>= 8;\n+            sep = '-';\n+        }\n+    }\n+    str::push_char(&mut result, ']');\n+    return result;\n+}\n+\n+fn copy_bits(in_vec: &[uint], out_vec: &mut [uint]) -> bool {\n+    bitwise(out_vec, in_vec, |_, b| b)\n+}\n+\n+fn join_bits<O:DataFlowOperator>(oper: &O,\n+                                 in_vec: &[uint],\n+                                 out_vec: &mut [uint]) -> bool {\n+    bitwise(out_vec, in_vec, |a, b| oper.join(a, b))\n+}\n+\n+#[inline(always)]\n+fn bitwise(out_vec: &mut [uint],\n+           in_vec: &[uint],\n+           op: &fn(uint, uint) -> uint) -> bool {\n+    assert_eq!(out_vec.len(), in_vec.len());\n+    let mut changed = false;\n+    for uint::range(0, out_vec.len()) |i| {\n+        let old_val = out_vec[i];\n+        let new_val = op(old_val, in_vec[i]);\n+        out_vec[i] = new_val;\n+        changed |= (old_val != new_val);\n+    }\n+    return changed;\n+}\n+\n+fn set_bit(words: &mut [uint], bit: uint) -> bool {\n+    debug!(\"set_bit: words=%s bit=%s\",\n+           mut_bits_to_str(words), bit_str(bit));\n+    let word = bit / uint::bits;\n+    let bit_in_word = bit % uint::bits;\n+    let bit_mask = 1 << bit_in_word;\n+    debug!(\"word=%u bit_in_word=%u bit_mask=%u\", word, bit_in_word, word);\n+    let oldv = words[word];\n+    let newv = oldv | bit_mask;\n+    words[word] = newv;\n+    oldv != newv\n+}\n+\n+fn bit_str(bit: uint) -> ~str {\n+    let byte = bit >> 8;\n+    let lobits = 1 << (bit & 0xFF);\n+    fmt!(\"[%u:%u-%02x]\", bit, byte, lobits)\n+}\n+\n+fn reslice<'a>(v: &'a mut [uint]) -> &'a [uint] {\n+    // bFIXME(#5074) this function should not be necessary at all\n+    unsafe {\n+        cast::transmute(v)\n+    }\n+}\n+"}, {"sha": "57c3e7c3b9a05d36da36794c732fde0b92e0d5b6", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -10,7 +10,6 @@\n \n use middle::freevars::freevar_entry;\n use middle::freevars;\n-use middle::liveness;\n use middle::pat_util;\n use middle::ty;\n use middle::typeck;\n@@ -56,19 +55,16 @@ pub static try_adding: &'static str = \"Try adding a move\";\n pub struct Context {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n-    last_use_map: liveness::last_use_map,\n-    current_item: node_id,\n+    current_item: node_id\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n-                   last_use_map: liveness::last_use_map,\n                    crate: @crate) {\n     let ctx = Context {\n         tcx: tcx,\n         method_map: method_map,\n-        last_use_map: last_use_map,\n-        current_item: -1,\n+        current_item: -1\n     };\n     let visit = visit::mk_vt(@visit::Visitor {\n         visit_arm: check_arm,\n@@ -132,7 +128,7 @@ fn check_item(item: @item, cx: Context, visitor: visit::vt<Context>) {\n                             // Yes, it's a destructor.\n                             match self_type.node {\n                                 ty_path(_, path_node_id) => {\n-                                    let struct_def = *cx.tcx.def_map.get(\n+                                    let struct_def = cx.tcx.def_map.get_copy(\n                                         &path_node_id);\n                                     let struct_did =\n                                         ast_util::def_id_of_def(struct_def);\n@@ -261,11 +257,9 @@ pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n         _ => e.id\n     };\n     for cx.tcx.node_type_substs.find(&type_parameter_id).each |ts| {\n-        // FIXME(#5562): removing this copy causes a segfault before stage2\n-        let ts = /*bad*/ copy **ts;\n         let type_param_defs = match e.node {\n           expr_path(_) => {\n-            let did = ast_util::def_id_of_def(*cx.tcx.def_map.get(&e.id));\n+            let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&e.id));\n             ty::lookup_item_type(cx.tcx, did).generics.type_param_defs\n           }\n           _ => {\n@@ -286,7 +280,7 @@ pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n                        ts.repr(cx.tcx),\n                        type_param_defs.repr(cx.tcx)));\n         }\n-        for vec::each2(ts, *type_param_defs) |&ty, type_param_def| {\n+        for vec::each2(**ts, *type_param_defs) |&ty, type_param_def| {\n             check_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n         }\n     }\n@@ -324,12 +318,10 @@ fn check_ty(aty: @Ty, cx: Context, v: visit::vt<Context>) {\n     match aty.node {\n       ty_path(_, id) => {\n         for cx.tcx.node_type_substs.find(&id).each |ts| {\n-            // FIXME(#5562): removing this copy causes a segfault before stage2\n-            let ts = /*bad*/ copy **ts;\n-            let did = ast_util::def_id_of_def(*cx.tcx.def_map.get(&id));\n+            let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&id));\n             let type_param_defs =\n                 ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n-            for vec::each2(ts, *type_param_defs) |&ty, type_param_def| {\n+            for vec::each2(**ts, *type_param_defs) |&ty, type_param_def| {\n                 check_bounds(cx, aty.id, aty.span, ty, type_param_def)\n             }\n         }\n@@ -392,7 +384,7 @@ pub fn check_bounds(cx: Context,\n fn is_nullary_variant(cx: Context, ex: @expr) -> bool {\n     match ex.node {\n       expr_path(_) => {\n-        match *cx.tcx.def_map.get(&ex.id) {\n+        match cx.tcx.def_map.get_copy(&ex.id) {\n           def_variant(edid, vdid) => {\n             vec::len(ty::enum_variant_with_id(cx.tcx, edid, vdid).args) == 0u\n           }"}, {"sha": "001218ea0cf62c4c21c72d9ef88766a86b71c4ce", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 67, "deletions": 48, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -28,7 +28,6 @@ use syntax::ast_util::local_def;\n use syntax::visit::{default_simple_visitor, mk_simple_visitor, SimpleVisitor};\n use syntax::visit::visit_crate;\n \n-use core::cast::transmute;\n use core::hashmap::HashMap;\n \n pub enum LangItem {\n@@ -67,21 +66,24 @@ pub enum LangItem {\n     MallocFnLangItem,           // 28\n     FreeFnLangItem,             // 29\n     BorrowAsImmFnLangItem,      // 30\n-    ReturnToMutFnLangItem,      // 31\n-    CheckNotBorrowedFnLangItem, // 32\n-    StrDupUniqFnLangItem,       // 33\n-\n-    StartFnLangItem,            // 34\n+    BorrowAsMutFnLangItem,      // 31\n+    ReturnToMutFnLangItem,      // 32\n+    CheckNotBorrowedFnLangItem, // 33\n+    StrDupUniqFnLangItem,       // 34\n+    RecordBorrowFnLangItem,     // 35\n+    UnrecordBorrowFnLangItem,   // 36\n+\n+    StartFnLangItem,            // 37\n }\n \n pub struct LanguageItems {\n-    items: [Option<def_id>, ..35]\n+    items: [Option<def_id>, ..38]\n }\n \n pub impl LanguageItems {\n     pub fn new() -> LanguageItems {\n         LanguageItems {\n-            items: [ None, ..35 ]\n+            items: [ None, ..38 ]\n         }\n     }\n \n@@ -129,11 +131,14 @@ pub impl LanguageItems {\n             28 => \"malloc\",\n             29 => \"free\",\n             30 => \"borrow_as_imm\",\n-            31 => \"return_to_mut\",\n-            32 => \"check_not_borrowed\",\n-            33 => \"strdup_uniq\",\n+            31 => \"borrow_as_mut\",\n+            32 => \"return_to_mut\",\n+            33 => \"check_not_borrowed\",\n+            34 => \"strdup_uniq\",\n+            35 => \"record_borrow\",\n+            36 => \"unrecord_borrow\",\n \n-            34 => \"start\",\n+            37 => \"start\",\n \n             _ => \"???\"\n         }\n@@ -238,6 +243,9 @@ pub impl LanguageItems {\n     pub fn borrow_as_imm_fn(&const self) -> def_id {\n         self.items[BorrowAsImmFnLangItem as uint].get()\n     }\n+    pub fn borrow_as_mut_fn(&const self) -> def_id {\n+        self.items[BorrowAsMutFnLangItem as uint].get()\n+    }\n     pub fn return_to_mut_fn(&const self) -> def_id {\n         self.items[ReturnToMutFnLangItem as uint].get()\n     }\n@@ -247,15 +255,20 @@ pub impl LanguageItems {\n     pub fn strdup_uniq_fn(&const self) -> def_id {\n         self.items[StrDupUniqFnLangItem as uint].get()\n     }\n+    pub fn record_borrow_fn(&const self) -> def_id {\n+        self.items[RecordBorrowFnLangItem as uint].get()\n+    }\n+    pub fn unrecord_borrow_fn(&const self) -> def_id {\n+        self.items[UnrecordBorrowFnLangItem as uint].get()\n+    }\n     pub fn start_fn(&const self) -> def_id {\n         self.items[StartFnLangItem as uint].get()\n     }\n }\n \n-fn LanguageItemCollector<'r>(crate: @crate,\n-                             session: Session,\n-                             items: &'r mut LanguageItems)\n-                          -> LanguageItemCollector<'r> {\n+fn LanguageItemCollector(crate: @crate,\n+                         session: Session)\n+                      -> LanguageItemCollector {\n     let mut item_refs = HashMap::new();\n \n     item_refs.insert(@~\"const\", ConstTraitLangItem as uint);\n@@ -294,31 +307,34 @@ fn LanguageItemCollector<'r>(crate: @crate,\n     item_refs.insert(@~\"malloc\", MallocFnLangItem as uint);\n     item_refs.insert(@~\"free\", FreeFnLangItem as uint);\n     item_refs.insert(@~\"borrow_as_imm\", BorrowAsImmFnLangItem as uint);\n+    item_refs.insert(@~\"borrow_as_mut\", BorrowAsMutFnLangItem as uint);\n     item_refs.insert(@~\"return_to_mut\", ReturnToMutFnLangItem as uint);\n     item_refs.insert(@~\"check_not_borrowed\",\n                      CheckNotBorrowedFnLangItem as uint);\n     item_refs.insert(@~\"strdup_uniq\", StrDupUniqFnLangItem as uint);\n+    item_refs.insert(@~\"record_borrow\", RecordBorrowFnLangItem as uint);\n+    item_refs.insert(@~\"unrecord_borrow\", UnrecordBorrowFnLangItem as uint);\n     item_refs.insert(@~\"start\", StartFnLangItem as uint);\n \n     LanguageItemCollector {\n         crate: crate,\n         session: session,\n-        items: items,\n+        items: LanguageItems::new(),\n         item_refs: item_refs\n     }\n }\n \n-struct LanguageItemCollector<'self> {\n-    items: &'self mut LanguageItems,\n+struct LanguageItemCollector {\n+    items: LanguageItems,\n \n     crate: @crate,\n     session: Session,\n \n     item_refs: HashMap<@~str, uint>,\n }\n \n-pub impl<'self> LanguageItemCollector<'self> {\n-    fn match_and_collect_meta_item(&self, item_def_id: def_id,\n+pub impl LanguageItemCollector {\n+    fn match_and_collect_meta_item(&mut self, item_def_id: def_id,\n                                    meta_item: @meta_item) {\n         match meta_item.node {\n             meta_name_value(key, literal) => {\n@@ -333,7 +349,7 @@ pub impl<'self> LanguageItemCollector<'self> {\n         }\n     }\n \n-    fn collect_item(&self, item_index: uint, item_def_id: def_id) {\n+    fn collect_item(&mut self, item_index: uint, item_def_id: def_id) {\n         // Check for duplicates.\n         match self.items.items[item_index] {\n             Some(original_def_id) if original_def_id != item_def_id => {\n@@ -349,42 +365,45 @@ pub impl<'self> LanguageItemCollector<'self> {\n         self.items.items[item_index] = Some(item_def_id);\n     }\n \n-    fn match_and_collect_item(&self,\n+    fn match_and_collect_item(&mut self,\n                               item_def_id: def_id, key: @~str, value: @~str) {\n         if *key != ~\"lang\" {\n             return;    // Didn't match.\n         }\n \n-        match self.item_refs.find(&value) {\n+        let item_index = self.item_refs.find(&value).map(|x| **x);\n+        // prevent borrow checker from considering   ^~~~~~~~~~~\n+        // self to be borrowed (annoying)\n+\n+        match item_index {\n+            Some(item_index) => {\n+                self.collect_item(item_index, item_def_id);\n+            }\n             None => {\n                 // Didn't match.\n-            }\n-            Some(&item_index) => {\n-                self.collect_item(item_index, item_def_id)\n+                return;\n             }\n         }\n     }\n \n-    fn collect_local_language_items(&self) {\n-        unsafe {\n-            let this: *LanguageItemCollector<'self> = transmute(self);\n-            visit_crate(self.crate, (), mk_simple_visitor(@SimpleVisitor {\n-                visit_item: |item| {\n-                    for item.attrs.each |attribute| {\n-                        unsafe {\n-                            (*this).match_and_collect_meta_item(\n-                                local_def(item.id),\n-                                attribute.node.value\n-                            );\n-                        }\n+    fn collect_local_language_items(&mut self) {\n+        let this: *mut LanguageItemCollector = &mut *self;\n+        visit_crate(self.crate, (), mk_simple_visitor(@SimpleVisitor {\n+            visit_item: |item| {\n+                for item.attrs.each |attribute| {\n+                    unsafe {\n+                        (*this).match_and_collect_meta_item(\n+                            local_def(item.id),\n+                            attribute.node.value\n+                        );\n                     }\n-                },\n-                .. *default_simple_visitor()\n-            }));\n-        }\n+                }\n+            },\n+            .. *default_simple_visitor()\n+        }));\n     }\n \n-    fn collect_external_language_items(&self) {\n+    fn collect_external_language_items(&mut self) {\n         let crate_store = self.session.cstore;\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n             for each_lang_item(crate_store, crate_number)\n@@ -408,7 +427,7 @@ pub impl<'self> LanguageItemCollector<'self> {\n         }\n     }\n \n-    fn collect(&self) {\n+    fn collect(&mut self) {\n         self.collect_local_language_items();\n         self.collect_external_language_items();\n         self.check_completeness();\n@@ -418,8 +437,8 @@ pub impl<'self> LanguageItemCollector<'self> {\n pub fn collect_language_items(crate: @crate,\n                               session: Session)\n                            -> LanguageItems {\n-    let mut items = LanguageItems::new();\n-    let collector = LanguageItemCollector(crate, session, &mut items);\n+    let mut collector = LanguageItemCollector(crate, session);\n     collector.collect();\n-    copy items\n+    let LanguageItemCollector { items, _ } = collector;\n+    items\n }"}, {"sha": "b0d6d477c0c87bd5943c838069a95ab8ed601164", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -667,7 +667,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n               ast::ty_path(_, id) => {\n-                match *cx.def_map.get(&id) {\n+                match cx.def_map.get_copy(&id) {\n                   ast::def_prim_ty(ast::ty_int(ast::ty_i)) => {\n                     cx.sess.span_lint(\n                         ctypes, id, fn_id,"}, {"sha": "0bd73a15d507cf710d2f683cf7a8c15f0f2b732b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 37, "deletions": 96, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -112,7 +112,6 @@ use util::ppaux::ty_to_str;\n \n use core::cast::transmute;\n use core::hashmap::HashMap;\n-use core::util::with;\n use syntax::ast::*;\n use syntax::codemap::span;\n use syntax::parse::token::special_idents;\n@@ -121,16 +120,6 @@ use syntax::visit::{fk_anon, fk_fn_block, fk_item_fn, fk_method};\n use syntax::visit::{vt};\n use syntax::{visit, ast_util};\n \n-// Maps from an expr id to a list of variable ids for which this expr\n-// is the last use.  Typically, the expr is a path and the node id is\n-// the local/argument/etc that the path refers to.  However, it also\n-// possible for the expr to be a closure, in which case the list is a\n-// list of closed over variables that can be moved into the closure.\n-//\n-// Very subtle (#2633): borrowck will remove entries from this table\n-// if it detects an outstanding loan (that is, the addr is taken).\n-pub type last_use_map = @mut HashMap<node_id, @mut ~[node_id]>;\n-\n #[deriving(Eq)]\n struct Variable(uint);\n #[deriving(Eq)]\n@@ -158,7 +147,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n                    variable_moves_map: moves::VariableMovesMap,\n                    capture_map: moves::CaptureMap,\n-                   crate: @crate) -> last_use_map {\n+                   crate: @crate) {\n     let visitor = visit::mk_vt(@visit::Visitor {\n         visit_fn: visit_fn,\n         visit_local: visit_local,\n@@ -168,16 +157,13 @@ pub fn check_crate(tcx: ty::ctxt,\n         .. *visit::default_visitor()\n     });\n \n-    let last_use_map = @mut HashMap::new();\n     let initial_maps = @mut IrMaps(tcx,\n                                    method_map,\n                                    variable_moves_map,\n                                    capture_map,\n-                                   last_use_map,\n                                    0);\n     visit::visit_crate(crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n-    return last_use_map;\n }\n \n impl to_str::ToStr for LiveNode {\n@@ -241,23 +227,11 @@ enum VarKind {\n     ImplicitRet\n }\n \n-fn relevant_def(def: def) -> Option<node_id> {\n-    match def {\n-        def_binding(nid, _) |\n-        def_arg(nid, _) |\n-        def_local(nid, _) |\n-        def_self(nid, _) => Some(nid),\n-\n-        _ => None\n-    }\n-}\n-\n struct IrMaps {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n     variable_moves_map: moves::VariableMovesMap,\n     capture_map: moves::CaptureMap,\n-    last_use_map: last_use_map,\n \n     num_live_nodes: uint,\n     num_vars: uint,\n@@ -274,15 +248,13 @@ fn IrMaps(tcx: ty::ctxt,\n           method_map: typeck::method_map,\n           variable_moves_map: moves::VariableMovesMap,\n           capture_map: moves::CaptureMap,\n-          last_use_map: last_use_map,\n           cur_item: node_id)\n        -> IrMaps {\n     IrMaps {\n         tcx: tcx,\n         method_map: method_map,\n         variable_moves_map: variable_moves_map,\n         capture_map: capture_map,\n-        last_use_map: last_use_map,\n         num_live_nodes: 0,\n         num_vars: 0,\n         live_node_map: HashMap::new(),\n@@ -367,35 +339,13 @@ pub impl IrMaps {\n     fn lnk(&mut self, ln: LiveNode) -> LiveNodeKind {\n         self.lnks[*ln]\n     }\n-\n-    fn add_last_use(&mut self, expr_id: node_id, var: Variable) {\n-        let vk = self.var_kinds[*var];\n-        debug!(\"Node %d is a last use of variable %?\", expr_id, vk);\n-        match vk {\n-            Arg(id, _) |\n-            Local(LocalInfo { id: id, kind: FromLetNoInitializer, _ }) |\n-            Local(LocalInfo { id: id, kind: FromLetWithInitializer, _ }) |\n-            Local(LocalInfo { id: id, kind: FromMatch(_), _ }) => {\n-                let v = match self.last_use_map.find(&expr_id) {\n-                    Some(&v) => v,\n-                    None => {\n-                        let v = @mut ~[];\n-                        self.last_use_map.insert(expr_id, v);\n-                        v\n-                    }\n-                };\n-\n-                v.push(id);\n-            }\n-            ImplicitRet => debug!(\"--but it is not owned\"),\n-        }\n-    }\n }\n \n fn visit_item(item: @item, self: @mut IrMaps, v: vt<@mut IrMaps>) {\n-    do with(&mut self.cur_item, item.id) {\n-        visit::visit_item(item, self, v)\n-    }\n+    let old_cur_item = self.cur_item;\n+    self.cur_item = item.id;\n+    visit::visit_item(item, self, v);\n+    self.cur_item = old_cur_item;\n }\n \n fn visit_fn(fk: &visit::fn_kind,\n@@ -413,7 +363,6 @@ fn visit_fn(fk: &visit::fn_kind,\n                               self.method_map,\n                               self.variable_moves_map,\n                               self.capture_map,\n-                              self.last_use_map,\n                               self.cur_item);\n \n     unsafe {\n@@ -517,9 +466,9 @@ fn visit_expr(expr: @expr, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) => {\n-        let def = *self.tcx.def_map.get(&expr.id);\n+        let def = self.tcx.def_map.get_copy(&expr.id);\n         debug!(\"expr %d: path that leads to %?\", expr.id, def);\n-        if relevant_def(def).is_some() {\n+        if moves::moved_variable_node_id_from_def(def).is_some() {\n             self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n         visit::visit_expr(expr, self, vt);\n@@ -536,7 +485,7 @@ fn visit_expr(expr: @expr, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n         let cvs = self.capture_map.get(&expr.id);\n         let mut call_caps = ~[];\n         for cvs.each |cv| {\n-            match relevant_def(cv.def) {\n+            match moves::moved_variable_node_id_from_def(cv.def) {\n               Some(rv) => {\n                 let cv_ln = self.add_live_node(FreeVarNode(cv.span));\n                 let is_move = match cv.mode {\n@@ -664,8 +613,8 @@ pub impl Liveness {\n     fn variable_from_path(&self, expr: @expr) -> Option<Variable> {\n         match expr.node {\n           expr_path(_) => {\n-            let def = *self.tcx.def_map.get(&expr.id);\n-            relevant_def(def).map(\n+            let def = self.tcx.def_map.get_copy(&expr.id);\n+            moves::moved_variable_node_id_from_def(def).map(\n                 |rdef| self.variable(*rdef, expr.span)\n             )\n           }\n@@ -681,7 +630,7 @@ pub impl Liveness {\n                              span: span) -> Option<Variable> {\n         match self.tcx.def_map.find(&node_id) {\n           Some(&def) => {\n-            relevant_def(def).map(\n+            moves::moved_variable_node_id_from_def(def).map(\n                 |rdef| self.variable(*rdef, span)\n             )\n           }\n@@ -810,11 +759,13 @@ pub impl Liveness {\n             None => {\n                 // Vanilla 'break' or 'loop', so use the enclosing\n                 // loop scope\n-                let loop_scope = &mut *self.loop_scope;\n-                if loop_scope.len() == 0 {\n-                    self.tcx.sess.span_bug(sp, \"break outside loop\");\n-                }\n-                else {\n+                let len = { // FIXME(#5074) stage0\n+                    let loop_scope = &mut *self.loop_scope;\n+                    loop_scope.len()\n+                };\n+                if len == 0 {\n+                    self.tcx.sess.span_bug(sp, ~\"break outside loop\");\n+                } else {\n                     // FIXME(#5275): this shouldn't have to be a method...\n                     self.last_loop_scope()\n                 }\n@@ -1384,8 +1335,8 @@ pub impl Liveness {\n \n     fn access_path(&self, expr: @expr, succ: LiveNode, acc: uint)\n                   -> LiveNode {\n-        let def = *self.tcx.def_map.get(&expr.id);\n-        match relevant_def(def) {\n+        let def = self.tcx.def_map.get_copy(&expr.id);\n+        match moves::moved_variable_node_id_from_def(def) {\n           Some(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0u {\n@@ -1518,7 +1469,6 @@ fn check_expr(expr: @expr, self: @Liveness, vt: vt<@Liveness>) {\n       expr_path(_) => {\n         for self.variable_from_def_map(expr.id, expr.span).each |var| {\n             let ln = self.live_node(expr.id, expr.span);\n-            self.consider_last_use(expr, ln, *var);\n \n             match self.ir.variable_moves_map.find(&expr.id) {\n                 None => {}\n@@ -1537,7 +1487,6 @@ fn check_expr(expr: @expr, self: @Liveness, vt: vt<@Liveness>) {\n         let caps = self.ir.captures(expr);\n         for caps.each |cap| {\n             let var = self.variable(cap.var_nid, expr.span);\n-            self.consider_last_use(expr, cap.ln, var);\n             if cap.is_move {\n                 self.check_move_from_var(cap.ln, var, expr);\n             }\n@@ -1606,7 +1555,7 @@ enum ReadKind {\n }\n \n pub impl Liveness {\n-    fn check_ret(@self, id: node_id, sp: span, _fk: &visit::fn_kind,\n+    fn check_ret(&self, id: node_id, sp: span, _fk: &visit::fn_kind,\n                  entry_ln: LiveNode) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the\n@@ -1626,11 +1575,11 @@ pub impl Liveness {\n         }\n     }\n \n-    fn check_move_from_var(@self, ln: LiveNode,\n+    fn check_move_from_var(&self,\n+                           ln: LiveNode,\n                            var: Variable,\n                            move_expr: @expr) {\n         /*!\n-         *\n          * Checks whether `var` is live on entry to any of the\n          * successors of `ln`.  If it is, report an error.\n          * `move_expr` is the expression which caused the variable\n@@ -1650,20 +1599,10 @@ pub impl Liveness {\n         }\n     }\n \n-    fn consider_last_use(@self, expr: @expr, ln: LiveNode, var: Variable) {\n-        debug!(\"consider_last_use(expr.id=%?, ln=%s, var=%s)\",\n-               expr.id, ln.to_str(), var.to_str());\n-\n-        match self.live_on_exit(ln, var) {\n-          Some(_) => {}\n-          None => self.ir.add_last_use(expr.id, var)\n-       }\n-    }\n-\n     fn check_lvalue(@self, expr: @expr, vt: vt<@Liveness>) {\n         match expr.node {\n           expr_path(_) => {\n-            match *self.tcx.def_map.get(&expr.id) {\n+            match self.tcx.def_map.get_copy(&expr.id) {\n               def_local(nid, mutbl) => {\n                 // Assignment to an immutable variable or argument: only legal\n                 // if there is no later assignment. If this local is actually\n@@ -1676,7 +1615,7 @@ pub impl Liveness {\n                 self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n               }\n               def => {\n-                match relevant_def(def) {\n+                match moves::moved_variable_node_id_from_def(def) {\n                   Some(nid) => {\n                     let ln = self.live_node(expr.id, expr.span);\n                     let var = self.variable(nid, expr.span);\n@@ -1696,14 +1635,14 @@ pub impl Liveness {\n        }\n     }\n \n-    fn check_for_reassignments_in_pat(@self, pat: @pat, mutbl: bool) {\n+    fn check_for_reassignments_in_pat(&self, pat: @pat, mutbl: bool) {\n         do self.pat_bindings(pat) |ln, var, sp, id| {\n             self.check_for_reassignment(ln, var, sp,\n                                         if mutbl {Some(id)} else {None});\n         }\n     }\n \n-    fn check_for_reassignment(@self, ln: LiveNode, var: Variable,\n+    fn check_for_reassignment(&self, ln: LiveNode, var: Variable,\n                               orig_span: span, mutbl: Option<node_id>) {\n         match self.assigned_on_exit(ln, var) {\n           Some(ExprNode(span)) => {\n@@ -1728,7 +1667,7 @@ pub impl Liveness {\n         }\n     }\n \n-    fn report_illegal_move(@self, lnk: LiveNodeKind,\n+    fn report_illegal_move(&self, lnk: LiveNodeKind,\n                            var: Variable,\n                            move_expr: @expr) {\n         // the only time that it is possible to have a moved variable\n@@ -1793,7 +1732,8 @@ pub impl Liveness {\n         };\n     }\n \n-    fn report_move_location(@self, move_expr: @expr,\n+    fn report_move_location(&self,\n+                            move_expr: @expr,\n                             var: Variable,\n                             expr_descr: &str,\n                             pronoun: &str) {\n@@ -1807,7 +1747,8 @@ pub impl Liveness {\n                  ty_to_str(self.tcx, move_expr_ty)));\n     }\n \n-    fn report_illegal_read(@self, chk_span: span,\n+    fn report_illegal_read(&self,\n+                           chk_span: span,\n                            lnk: LiveNodeKind,\n                            var: Variable,\n                            rk: ReadKind) {\n@@ -1838,12 +1779,12 @@ pub impl Liveness {\n         }\n     }\n \n-    fn should_warn(@self, var: Variable) -> Option<@~str> {\n+    fn should_warn(&self, var: Variable) -> Option<@~str> {\n         let name = self.ir.variable_name(var);\n         if name[0] == ('_' as u8) { None } else { Some(name) }\n     }\n \n-    fn warn_about_unused_args(@self, decl: &fn_decl, entry_ln: LiveNode) {\n+    fn warn_about_unused_args(&self, decl: &fn_decl, entry_ln: LiveNode) {\n         for decl.inputs.each |arg| {\n             do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n                     |_bm, p_id, sp, _n| {\n@@ -1853,15 +1794,15 @@ pub impl Liveness {\n         }\n     }\n \n-    fn warn_about_unused_or_dead_vars_in_pat(@self, pat: @pat) {\n+    fn warn_about_unused_or_dead_vars_in_pat(&self, pat: @pat) {\n         do self.pat_bindings(pat) |ln, var, sp, id| {\n             if !self.warn_about_unused(sp, id, ln, var) {\n                 self.warn_about_dead_assign(sp, id, ln, var);\n             }\n         }\n     }\n \n-    fn warn_about_unused(@self, sp: span, id: node_id,\n+    fn warn_about_unused(&self, sp: span, id: node_id,\n                          ln: LiveNode, var: Variable) -> bool {\n         if !self.used_on_entry(ln, var) {\n             for self.should_warn(var).each |name| {\n@@ -1891,7 +1832,7 @@ pub impl Liveness {\n         return false;\n     }\n \n-    fn warn_about_dead_assign(@self, sp: span, id: node_id,\n+    fn warn_about_dead_assign(&self, sp: span, id: node_id,\n                               ln: LiveNode, var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n             for self.should_warn(var).each |name| {"}, {"sha": "dde4c044792881f455a5cd22399fce08eb491b94", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 346, "deletions": 389, "changes": 735, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -48,7 +48,7 @@\n \n use middle::ty;\n use middle::typeck;\n-use util::ppaux::{ty_to_str, region_to_str};\n+use util::ppaux::{ty_to_str, region_to_str, Repr};\n use util::common::indenter;\n \n use syntax::ast::{m_imm, m_const, m_mutbl};\n@@ -58,48 +58,46 @@ use syntax::print::pprust;\n \n #[deriving(Eq)]\n pub enum categorization {\n-    cat_rvalue,                     // result of eval'ing some misc expr\n-    cat_special(special_kind),      //\n-    cat_local(ast::node_id),        // local variable\n-    cat_binding(ast::node_id),      // pattern binding\n-    cat_arg(ast::node_id),          // formal argument\n-    cat_stack_upvar(cmt),           // upvar in stack closure\n-    cat_deref(cmt, uint, ptr_kind), // deref of a ptr\n-    cat_comp(cmt, comp_kind),       // adjust to locate an internal component\n-    cat_discr(cmt, ast::node_id),   // match discriminant (see preserve())\n-    cat_self(ast::node_id),         // explicit `self`\n+    cat_rvalue,                        // result of eval'ing some misc expr\n+    cat_static_item,\n+    cat_implicit_self,\n+    cat_copied_upvar(CopiedUpvar),     // upvar copied into @fn or ~fn env\n+    cat_stack_upvar(cmt),              // by ref upvar from &fn\n+    cat_local(ast::node_id),           // local variable\n+    cat_arg(ast::node_id),             // formal argument\n+    cat_deref(cmt, uint, ptr_kind),    // deref of a ptr\n+    cat_interior(cmt, interior_kind),          // something interior\n+    cat_discr(cmt, ast::node_id),      // match discriminant (see preserve())\n+    cat_self(ast::node_id),            // explicit `self`\n+}\n+\n+#[deriving(Eq)]\n+struct CopiedUpvar {\n+    upvar_id: ast::node_id,\n+    onceness: ast::Onceness,\n }\n \n // different kinds of pointers:\n #[deriving(Eq)]\n pub enum ptr_kind {\n-    uniq_ptr,\n+    uniq_ptr(ast::mutability),\n     gc_ptr(ast::mutability),\n     region_ptr(ast::mutability, ty::Region),\n     unsafe_ptr\n }\n \n-// I am coining the term \"components\" to mean \"pieces of a data\n-// structure accessible without a dereference\":\n+// We use the term \"interior\" to mean \"something reachable from the\n+// base without a pointer dereference\", e.g. a field\n #[deriving(Eq)]\n-pub enum comp_kind {\n-    comp_tuple,                  // elt in a tuple\n-    comp_anon_field,             // anonymous field (in e.g.\n-                                 // struct Foo(int, int);\n-    comp_variant(ast::def_id),   // internals to a variant of given enum\n-    comp_field(ast::ident,       // name of field\n-               ast::mutability), // declared mutability of field\n-    comp_index(ty::t,            // type of vec/str/etc being deref'd\n-               ast::mutability)  // mutability of vec content\n-}\n-\n-// different kinds of expressions we might evaluate\n-#[deriving(Eq)]\n-pub enum special_kind {\n-    sk_method,\n-    sk_static_item,\n-    sk_implicit_self,   // old by-reference `self`\n-    sk_heap_upvar\n+pub enum interior_kind {\n+    interior_tuple,                  // elt in a tuple\n+    interior_anon_field,             // anonymous field (in e.g.\n+                                     // struct Foo(int, int);\n+    interior_variant(ast::def_id),   // internals to a variant of given enum\n+    interior_field(ast::ident,       // name of field\n+                   ast::mutability), // declared mutability of field\n+    interior_index(ty::t,            // type of vec/str/etc being deref'd\n+                   ast::mutability)  // mutability of vec content\n }\n \n #[deriving(Eq)]\n@@ -110,49 +108,48 @@ pub enum MutabilityCategory {\n     McInherited  // Inherited from the fact that owner is mutable.\n }\n \n+// `cmt`: \"Category, Mutability, and Type\".\n+//\n // a complete categorization of a value indicating where it originated\n // and how it is located, as well as the mutability of the memory in\n // which the value is stored.\n //\n-// note: cmt stands for \"categorized mutable type\".\n+// *WARNING* The field `cmt.type` is NOT necessarily the same as the\n+// result of `node_id_to_type(cmt.id)`. This is because the `id` is\n+// always the `id` of the node producing the type; in an expression\n+// like `*x`, the type of this deref node is the deref'd type (`T`),\n+// but in a pattern like `@x`, the `@x` pattern is again a\n+// dereference, but its type is the type *before* the dereference\n+// (`@T`). So use `cmt.type` to find the type of the value in a consistent\n+// fashion. For more details, see the method `cat_pattern`\n #[deriving(Eq)]\n pub struct cmt_ {\n     id: ast::node_id,          // id of expr/pat producing this value\n     span: span,                // span of same expr/pat\n     cat: categorization,       // categorization of expr\n-    lp: Option<@loan_path>,    // loan path for expr, if any\n     mutbl: MutabilityCategory, // mutability of expr as lvalue\n-    ty: ty::t                  // type of the expr\n+    ty: ty::t                  // type of the expr (*see WARNING above*)\n }\n \n pub type cmt = @cmt_;\n \n-// a loan path is like a category, but it exists only when the data is\n-// interior to the stack frame.  loan paths are used as the key to a\n-// map indicating what is borrowed at any point in time.\n-#[deriving(Eq)]\n-pub enum loan_path {\n-    lp_local(ast::node_id),\n-    lp_arg(ast::node_id),\n-    lp_self,\n-    lp_deref(@loan_path, ptr_kind),\n-    lp_comp(@loan_path, comp_kind)\n-}\n-\n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n-pub enum deref_kind {deref_ptr(ptr_kind), deref_comp(comp_kind)}\n+pub enum deref_kind {deref_ptr(ptr_kind), deref_interior(interior_kind)}\n \n // Categorizes a derefable type.  Note that we include vectors and strings as\n // derefable (we model an index as the combination of a deref and then a\n // pointer adjustment).\n pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     match ty::get(t).sty {\n-        ty::ty_uniq(*) |\n+        ty::ty_uniq(mt) => {\n+            Some(deref_ptr(uniq_ptr(mt.mutbl)))\n+        }\n+\n         ty::ty_evec(_, ty::vstore_uniq) |\n         ty::ty_estr(ty::vstore_uniq) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) => {\n-            Some(deref_ptr(uniq_ptr))\n+            Some(deref_ptr(uniq_ptr(m_imm)))\n         }\n \n         ty::ty_rptr(r, mt) |\n@@ -181,19 +178,19 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         }\n \n         ty::ty_enum(did, _) => {\n-            Some(deref_comp(comp_variant(did)))\n+            Some(deref_interior(interior_variant(did)))\n         }\n \n         ty::ty_struct(_, _) => {\n-            Some(deref_comp(comp_anon_field))\n+            Some(deref_interior(interior_anon_field))\n         }\n \n         ty::ty_evec(mt, ty::vstore_fixed(_)) => {\n-            Some(deref_comp(comp_index(t, mt.mutbl)))\n+            Some(deref_interior(interior_index(t, mt.mutbl)))\n         }\n \n         ty::ty_estr(ty::vstore_fixed(_)) => {\n-            Some(deref_comp(comp_index(t, m_imm)))\n+            Some(deref_interior(interior_index(t, m_imm)))\n         }\n \n         _ => None\n@@ -257,19 +254,6 @@ pub fn cat_def(\n     return mcx.cat_def(expr_id, expr_span, expr_ty, def);\n }\n \n-pub fn cat_variant<N:ast_node>(\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n-    arg: N,\n-    enum_did: ast::def_id,\n-    cmt: cmt) -> cmt {\n-\n-    let mcx = &mem_categorization_ctxt {\n-        tcx: tcx, method_map: method_map\n-    };\n-    return mcx.cat_variant(arg, enum_did, cmt);\n-}\n-\n pub trait ast_node {\n     fn id(&self) -> ast::node_id;\n     fn span(&self) -> span;\n@@ -285,16 +269,6 @@ impl ast_node for @ast::pat {\n     fn span(&self) -> span { self.span }\n }\n \n-pub trait get_type_for_node {\n-    fn ty<N:ast_node>(&self, node: N) -> ty::t;\n-}\n-\n-impl get_type_for_node for ty::ctxt {\n-    fn ty<N:ast_node>(&self, node: N) -> ty::t {\n-        ty::node_id_to_type(*self, node.id())\n-    }\n-}\n-\n pub struct mem_categorization_ctxt {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n@@ -338,26 +312,24 @@ pub impl MutabilityCategory {\n         }\n     }\n \n-    fn to_user_str(&self) -> ~str {\n+    fn to_user_str(&self) -> &'static str {\n         match *self {\n-            McDeclared | McInherited => ~\"mutable\",\n-            McImmutable => ~\"immutable\",\n-            McReadOnly => ~\"const\"\n+            McDeclared | McInherited => \"mutable\",\n+            McImmutable => \"immutable\",\n+            McReadOnly => \"const\"\n         }\n     }\n }\n \n-pub impl loan_path {\n-    fn node_id(&self) -> Option<ast::node_id> {\n-        match *self {\n-            lp_local(id) | lp_arg(id) => Some(id),\n-            lp_deref(lp, _) | lp_comp(lp, _) => lp.node_id(),\n-            lp_self => None\n-        }\n+pub impl mem_categorization_ctxt {\n+    fn expr_ty(&self, expr: @ast::expr) -> ty::t {\n+        ty::expr_ty(self.tcx, expr)\n+    }\n+\n+    fn pat_ty(&self, pat: @ast::pat) -> ty::t {\n+        ty::node_id_to_type(self.tcx, pat.id)\n     }\n-}\n \n-pub impl mem_categorization_ctxt {\n     fn cat_expr(&self, expr: @ast::expr) -> cmt {\n         match self.tcx.adjustments.find(&expr.id) {\n             None => {\n@@ -406,8 +378,7 @@ pub impl mem_categorization_ctxt {\n         debug!(\"cat_expr: id=%d expr=%s\",\n                expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()));\n \n-        let tcx = self.tcx;\n-        let expr_ty = tcx.ty(expr);\n+        let expr_ty = self.expr_ty(expr);\n         match expr.node {\n           ast::expr_unary(ast::deref, e_base) => {\n             if self.method_map.contains_key(&expr.id) {\n@@ -419,12 +390,13 @@ pub impl mem_categorization_ctxt {\n           }\n \n           ast::expr_field(base, f_name, _) => {\n-            if self.method_map.contains_key(&expr.id) {\n-                return self.cat_method_ref(expr, expr_ty);\n-            }\n+            // Method calls are now a special syntactic form,\n+            // so `a.b` should always be a field.\n+            assert!(!self.method_map.contains_key(&expr.id));\n \n             let base_cmt = self.cat_expr(base);\n-            self.cat_field(expr, base_cmt, f_name, expr.id)\n+            self.cat_field(expr, base_cmt, f_name,\n+                           self.expr_ty(expr), expr.id)\n           }\n \n           ast::expr_index(base, _) => {\n@@ -437,7 +409,7 @@ pub impl mem_categorization_ctxt {\n           }\n \n           ast::expr_path(_) => {\n-            let def = *self.tcx.def_map.get(&expr.id);\n+            let def = self.tcx.def_map.get_copy(&expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -475,8 +447,7 @@ pub impl mem_categorization_ctxt {\n             @cmt_ {\n                 id:id,\n                 span:span,\n-                cat:cat_special(sk_static_item),\n-                lp:None,\n+                cat:cat_static_item,\n                 mutbl: McImmutable,\n                 ty:expr_ty\n             }\n@@ -487,66 +458,70 @@ pub impl mem_categorization_ctxt {\n             // stuff as `&const` and `&mut`?\n \n             // m: mutability of the argument\n-            // lp: loan path, must be none for aliasable things\n             let m = if mutbl {McDeclared} else {McImmutable};\n-            let lp = Some(@lp_arg(vid));\n             @cmt_ {\n-                id:id,\n-                span:span,\n-                cat:cat_arg(vid),\n-                lp:lp,\n+                id: id,\n+                span: span,\n+                cat: cat_arg(vid),\n                 mutbl: m,\n                 ty:expr_ty\n             }\n           }\n \n           ast::def_self(self_id, is_implicit) => {\n-            let cat, loan_path;\n-            if is_implicit {\n-                cat = cat_special(sk_implicit_self);\n-                loan_path = None;\n+            let cat = if is_implicit {\n+                cat_implicit_self\n             } else {\n-                cat = cat_self(self_id);\n-                loan_path = Some(@lp_self);\n+                cat_self(self_id)\n             };\n \n             @cmt_ {\n                 id:id,\n                 span:span,\n                 cat:cat,\n-                lp:loan_path,\n                 mutbl: McImmutable,\n                 ty:expr_ty\n             }\n           }\n \n-          ast::def_upvar(_, inner, fn_node_id, _) => {\n-            let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n-            let sigil = ty::ty_closure_sigil(ty);\n-            match sigil {\n-                ast::BorrowedSigil => {\n-                    let upcmt = self.cat_def(id, span, expr_ty, *inner);\n-                    @cmt_ {\n-                        id:id,\n-                        span:span,\n-                        cat:cat_stack_upvar(upcmt),\n-                        lp:upcmt.lp,\n-                        mutbl:upcmt.mutbl,\n-                        ty:upcmt.ty\n-                    }\n-                }\n-                ast::OwnedSigil | ast::ManagedSigil => {\n-                    // FIXME #2152 allow mutation of moved upvars\n-                    @cmt_ {\n-                        id:id,\n-                        span:span,\n-                        cat:cat_special(sk_heap_upvar),\n-                        lp:None,\n-                        mutbl:McImmutable,\n-                        ty:expr_ty\n-                    }\n-                }\n-            }\n+          ast::def_upvar(upvar_id, inner, fn_node_id, _) => {\n+              let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n+              match ty::get(ty).sty {\n+                  ty::ty_closure(ref closure_ty) => {\n+                      let sigil = closure_ty.sigil;\n+                      match sigil {\n+                          ast::BorrowedSigil => {\n+                              let upvar_cmt =\n+                                  self.cat_def(id, span, expr_ty, *inner);\n+                              @cmt_ {\n+                                  id:id,\n+                                  span:span,\n+                                  cat:cat_stack_upvar(upvar_cmt),\n+                                  mutbl:upvar_cmt.mutbl.inherit(),\n+                                  ty:upvar_cmt.ty\n+                              }\n+                          }\n+                          ast::OwnedSigil | ast::ManagedSigil => {\n+                              // FIXME #2152 allow mutation of moved upvars\n+                              @cmt_ {\n+                                  id:id,\n+                                  span:span,\n+                                  cat:cat_copied_upvar(CopiedUpvar {\n+                                      upvar_id: upvar_id,\n+                                      onceness: closure_ty.onceness}),\n+                                  mutbl:McImmutable,\n+                                  ty:expr_ty\n+                              }\n+                          }\n+                      }\n+                  }\n+                  _ => {\n+                      self.tcx.sess.span_bug(\n+                          span,\n+                          fmt!(\"Upvar of non-closure %? - %s\",\n+                               fn_node_id, ty.repr(self.tcx)));\n+                  }\n+              }\n           }\n \n           ast::def_local(vid, mutbl) => {\n@@ -555,7 +530,6 @@ pub impl mem_categorization_ctxt {\n                 id:id,\n                 span:span,\n                 cat:cat_local(vid),\n-                lp:Some(@lp_local(vid)),\n                 mutbl:m,\n                 ty:expr_ty\n             }\n@@ -567,34 +541,18 @@ pub impl mem_categorization_ctxt {\n                 id:id,\n                 span:span,\n                 cat:cat_local(vid),\n-                lp:Some(@lp_local(vid)),\n                 mutbl:McImmutable,\n                 ty:expr_ty\n             }\n           }\n         }\n     }\n \n-    fn cat_variant<N:ast_node>(&self,\n-                                arg: N,\n-                                enum_did: ast::def_id,\n-                                cmt: cmt) -> cmt {\n-        @cmt_ {\n-            id: arg.id(),\n-            span: arg.span(),\n-            cat: cat_comp(cmt, comp_variant(enum_did)),\n-            lp: cmt.lp.map(|l| @lp_comp(*l, comp_variant(enum_did)) ),\n-            mutbl: cmt.mutbl.inherit(),\n-            ty: self.tcx.ty(arg)\n-        }\n-    }\n-\n     fn cat_rvalue<N:ast_node>(&self, elt: N, expr_ty: ty::t) -> cmt {\n         @cmt_ {\n             id:elt.id(),\n             span:elt.span(),\n             cat:cat_rvalue,\n-            lp:None,\n             mutbl:McImmutable,\n             ty:expr_ty\n         }\n@@ -606,9 +564,9 @@ pub impl mem_categorization_ctxt {\n     /// or if the container is mutable.\n     fn inherited_mutability(&self,\n                             base_m: MutabilityCategory,\n-                            comp_m: ast::mutability) -> MutabilityCategory\n+                            interior_m: ast::mutability) -> MutabilityCategory\n     {\n-        match comp_m {\n+        match interior_m {\n             m_imm => base_m.inherit(),\n             m_const => McReadOnly,\n             m_mutbl => McDeclared\n@@ -621,6 +579,7 @@ pub impl mem_categorization_ctxt {\n                              node: N,\n                              base_cmt: cmt,\n                              f_name: ast::ident,\n+                             f_ty: ty::t,\n                              field_id: ast::node_id) -> cmt {\n         let f_mutbl = match field_mutbl(self.tcx, base_cmt.ty,\n                                         f_name, field_id) {\n@@ -634,15 +593,13 @@ pub impl mem_categorization_ctxt {\n             }\n         };\n         let m = self.inherited_mutability(base_cmt.mutbl, f_mutbl);\n-        let f_comp = comp_field(f_name, f_mutbl);\n-        let lp = base_cmt.lp.map(|lp| @lp_comp(*lp, f_comp) );\n+        let f_interior = interior_field(f_name, f_mutbl);\n         @cmt_ {\n             id: node.id(),\n             span: node.span(),\n-            cat: cat_comp(base_cmt, f_comp),\n-            lp:lp,\n+            cat: cat_interior(base_cmt, f_interior),\n             mutbl: m,\n-            ty: self.tcx.ty(node)\n+            ty: f_ty\n         }\n     }\n \n@@ -688,25 +645,10 @@ pub impl mem_categorization_ctxt {\n     {\n         match deref_kind(self.tcx, base_cmt.ty) {\n             deref_ptr(ptr) => {\n-                let lp = do base_cmt.lp.chain_ref |l| {\n-                    // Given that the ptr itself is loanable, we can\n-                    // loan out deref'd uniq ptrs or mut ptrs as the data\n-                    // they are the only way to mutably reach the data they\n-                    // point at. Other ptr types admit mutable aliases and\n-                    // are therefore not loanable.\n-                    match ptr {\n-                        uniq_ptr => Some(@lp_deref(*l, ptr)),\n-                        region_ptr(ast::m_mutbl, _) => {\n-                            Some(@lp_deref(*l, ptr))\n-                        }\n-                        gc_ptr(*) | region_ptr(_, _) | unsafe_ptr => None\n-                    }\n-                };\n-\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n                 let m = match ptr {\n-                    uniq_ptr => {\n+                    uniq_ptr(*) => {\n                         self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n                     }\n                     gc_ptr(*) | region_ptr(_, _) | unsafe_ptr => {\n@@ -718,20 +660,17 @@ pub impl mem_categorization_ctxt {\n                     id:node.id(),\n                     span:node.span(),\n                     cat:cat_deref(base_cmt, deref_cnt, ptr),\n-                    lp:lp,\n                     mutbl:m,\n                     ty:mt.ty\n                 }\n             }\n \n-            deref_comp(comp) => {\n-                let lp = base_cmt.lp.map(|l| @lp_comp(*l, comp) );\n+            deref_interior(interior) => {\n                 let m = self.inherited_mutability(base_cmt.mutbl, mt.mutbl);\n                 @cmt_ {\n                     id:node.id(),\n                     span:node.span(),\n-                    cat:cat_comp(base_cmt, comp),\n-                    lp:lp,\n+                    cat:cat_interior(base_cmt, interior),\n                     mutbl:m,\n                     ty:mt.ty\n                 }\n@@ -740,8 +679,8 @@ pub impl mem_categorization_ctxt {\n     }\n \n     fn cat_index<N:ast_node>(&self,\n-                              elt: N,\n-                              base_cmt: cmt) -> cmt {\n+                             elt: N,\n+                             base_cmt: cmt) -> cmt {\n         let mt = match ty::index(base_cmt.ty) {\n           Some(mt) => mt,\n           None => {\n@@ -754,97 +693,62 @@ pub impl mem_categorization_ctxt {\n \n         return match deref_kind(self.tcx, base_cmt.ty) {\n           deref_ptr(ptr) => {\n-            // (a) the contents are loanable if the base is loanable\n-            // and this is a *unique* vector\n-            let deref_lp = match ptr {\n-              uniq_ptr => {base_cmt.lp.map(|lp| @lp_deref(*lp, uniq_ptr))}\n-              _ => {None}\n-            };\n-\n-            // (b) for unique ptrs, we inherit mutability from the\n+            // for unique ptrs, we inherit mutability from the\n             // owning reference.\n             let m = match ptr {\n-              uniq_ptr => {\n+              uniq_ptr(*) => {\n                 self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n               }\n               gc_ptr(_) | region_ptr(_, _) | unsafe_ptr => {\n                 MutabilityCategory::from_mutbl(mt.mutbl)\n               }\n             };\n \n-            // (c) the deref is explicit in the resulting cmt\n+            // the deref is explicit in the resulting cmt\n             let deref_cmt = @cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n                 cat:cat_deref(base_cmt, 0u, ptr),\n-                lp:deref_lp,\n                 mutbl:m,\n                 ty:mt.ty\n             };\n \n-            comp(elt, deref_cmt, base_cmt.ty, m, mt)\n+            interior(elt, deref_cmt, base_cmt.ty, m, mt)\n           }\n \n-          deref_comp(_) => {\n+          deref_interior(_) => {\n             // fixed-length vectors have no deref\n             let m = self.inherited_mutability(base_cmt.mutbl, mt.mutbl);\n-            comp(elt, base_cmt, base_cmt.ty, m, mt)\n+            interior(elt, base_cmt, base_cmt.ty, m, mt)\n           }\n         };\n \n-        fn comp<N:ast_node>(elt: N, of_cmt: cmt,\n-                             vect: ty::t, mutbl: MutabilityCategory,\n-                             mt: ty::mt) -> cmt\n+        fn interior<N: ast_node>(elt: N, of_cmt: cmt,\n+                                 vect: ty::t, mutbl: MutabilityCategory,\n+                                 mt: ty::mt) -> cmt\n         {\n-            let comp = comp_index(vect, mt.mutbl);\n-            let index_lp = of_cmt.lp.map(|lp| @lp_comp(*lp, comp) );\n+            let interior = interior_index(vect, mt.mutbl);\n             @cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n-                cat:cat_comp(of_cmt, comp),\n-                lp:index_lp,\n+                cat:cat_interior(of_cmt, interior),\n                 mutbl:mutbl,\n                 ty:mt.ty\n             }\n         }\n     }\n \n-    fn cat_tuple_elt<N:ast_node>(&self,\n-                                  elt: N,\n-                                  cmt: cmt) -> cmt {\n-        @cmt_ {\n-            id: elt.id(),\n-            span: elt.span(),\n-            cat: cat_comp(cmt, comp_tuple),\n-            lp: cmt.lp.map(|l| @lp_comp(*l, comp_tuple) ),\n-            mutbl: cmt.mutbl.inherit(),\n-            ty: self.tcx.ty(elt)\n-        }\n-    }\n-\n-    fn cat_anon_struct_field<N:ast_node>(&self,\n-                                          elt: N,\n-                                          cmt: cmt) -> cmt {\n-        @cmt_ {\n-            id: elt.id(),\n-            span: elt.span(),\n-            cat: cat_comp(cmt, comp_anon_field),\n-            lp: cmt.lp.map(|l| @lp_comp(*l, comp_anon_field)),\n-            mutbl: cmt.mutbl.inherit(),\n-            ty: self.tcx.ty(elt)\n-        }\n-    }\n-\n-    fn cat_method_ref(&self,\n-                      expr: @ast::expr,\n-                      expr_ty: ty::t) -> cmt {\n+    fn cat_imm_interior<N:ast_node>(&self,\n+                                    node: N,\n+                                    base_cmt: cmt,\n+                                    interior_ty: ty::t,\n+                                    interior: interior_kind) -> cmt {\n         @cmt_ {\n-            id:expr.id,\n-            span:expr.span,\n-            cat:cat_special(sk_method),\n-            lp:None,\n-            mutbl:McImmutable,\n-            ty:expr_ty\n+            id: node.id(),\n+            span: node.span(),\n+            cat: cat_interior(base_cmt, interior),\n+            mutbl: base_cmt.mutbl.inherit(),\n+            ty: interior_ty\n         }\n     }\n \n@@ -865,32 +769,42 @@ pub impl mem_categorization_ctxt {\n         // we can be sure that the binding will remain valid for the\n         // duration of the arm.\n         //\n-        // The correspondence between the id in the cmt and which\n-        // pattern is being referred to is somewhat...subtle.  In\n-        // general, the id of the cmt is the id of the node that\n-        // produces the value.  For patterns, that's actually the\n-        // *subpattern*, generally speaking.\n+        // (*) There is subtlety concerning the correspondence between\n+        // pattern ids and types as compared to *expression* ids and\n+        // types. This is explained briefly. on the definition of the\n+        // type `cmt`, so go off and read what it says there, then\n+        // come back and I'll dive into a bit more detail here. :) OK,\n+        // back?\n         //\n-        // To see what I mean about ids etc, consider:\n+        // In general, the id of the cmt should be the node that\n+        // \"produces\" the value---patterns aren't executable code\n+        // exactly, but I consider them to \"execute\" when they match a\n+        // value. So if you have something like:\n         //\n         //     let x = @@3;\n         //     match x {\n         //       @@y { ... }\n         //     }\n         //\n-        // Here the cmt for `y` would be something like\n+        // In this case, the cmt and the relevant ids would be:\n+        //\n+        //     CMT             Id                  Type of Id Type of cmt\n         //\n         //     local(x)->@->@\n+        //     ^~~~~~~^        `x` from discr      @@int      @@int\n+        //     ^~~~~~~~~~^     `@@y` pattern node  @@int      @int\n+        //     ^~~~~~~~~~~~~^  `@y` pattern node   @int       int\n         //\n-        // where the id of `local(x)` is the id of the `x` that appears\n-        // in the match, the id of `local(x)->@` is the `@y` pattern,\n-        // and the id of `local(x)->@->@` is the id of the `y` pattern.\n-\n+        // You can see that the types of the id and the cmt are in\n+        // sync in the first line, because that id is actually the id\n+        // of an expression. But once we get to pattern ids, the types\n+        // step out of sync again. So you'll see below that we always\n+        // get the type of the *subpattern* and use that.\n \n         let tcx = self.tcx;\n         debug!(\"cat_pattern: id=%d pat=%s cmt=%s\",\n                pat.id, pprust::pat_to_str(pat, tcx.sess.intr()),\n-               self.cmt_to_repr(cmt));\n+               cmt.repr(tcx));\n         let _i = indenter();\n \n         op(cmt, pat);\n@@ -907,22 +821,27 @@ pub impl mem_categorization_ctxt {\n             match self.tcx.def_map.find(&pat.id) {\n                 Some(&ast::def_variant(enum_did, _)) => {\n                     // variant(x, y, z)\n-                    for subpats.each |subpat| {\n-                        let subcmt = self.cat_variant(*subpat, enum_did, cmt);\n-                        self.cat_pattern(subcmt, *subpat, op);\n+                    for subpats.each |&subpat| {\n+                        let subpat_ty = self.pat_ty(subpat); // see (*)\n+                        let subcmt =\n+                            self.cat_imm_interior(pat, cmt, subpat_ty,\n+                                                  interior_variant(enum_did));\n+                        self.cat_pattern(subcmt, subpat, op);\n                     }\n                 }\n                 Some(&ast::def_fn(*)) |\n                 Some(&ast::def_struct(*)) => {\n-                    for subpats.each |subpat| {\n-                        let cmt_field = self.cat_anon_struct_field(*subpat,\n-                                                                   cmt);\n-                        self.cat_pattern(cmt_field, *subpat, op);\n+                    for subpats.each |&subpat| {\n+                        let subpat_ty = self.pat_ty(subpat); // see (*)\n+                        let cmt_field =\n+                            self.cat_imm_interior(pat, cmt, subpat_ty,\n+                                                  interior_anon_field);\n+                        self.cat_pattern(cmt_field, subpat, op);\n                     }\n                 }\n                 Some(&ast::def_const(*)) => {\n-                    for subpats.each |subpat| {\n-                        self.cat_pattern(cmt, *subpat, op);\n+                    for subpats.each |&subpat| {\n+                        self.cat_pattern(cmt, subpat, op);\n                     }\n                 }\n                 _ => {\n@@ -944,39 +863,43 @@ pub impl mem_categorization_ctxt {\n           ast::pat_struct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for field_pats.each |fp| {\n-                let cmt_field = self.cat_field(fp.pat, cmt, fp.ident, pat.id);\n+                let field_ty = self.pat_ty(fp.pat); // see (*)\n+                let cmt_field = self.cat_field(pat, cmt, fp.ident,\n+                                               field_ty, pat.id);\n                 self.cat_pattern(cmt_field, fp.pat, op);\n             }\n           }\n \n           ast::pat_tup(ref subpats) => {\n             // (p1, ..., pN)\n-            for subpats.each |subpat| {\n-                let subcmt = self.cat_tuple_elt(*subpat, cmt);\n-                self.cat_pattern(subcmt, *subpat, op);\n+            for subpats.each |&subpat| {\n+                let subpat_ty = self.pat_ty(subpat); // see (*)\n+                let subcmt = self.cat_imm_interior(pat, cmt, subpat_ty,\n+                                                   interior_tuple);\n+                self.cat_pattern(subcmt, subpat, op);\n             }\n           }\n \n           ast::pat_box(subpat) | ast::pat_uniq(subpat) |\n           ast::pat_region(subpat) => {\n             // @p1, ~p1\n-            let subcmt = self.cat_deref(subpat, cmt, 0);\n+            let subcmt = self.cat_deref(pat, cmt, 0);\n             self.cat_pattern(subcmt, subpat, op);\n           }\n \n           ast::pat_vec(ref before, slice, ref after) => {\n-              for before.each |pat| {\n-                  let elt_cmt = self.cat_index(*pat, cmt);\n-                  self.cat_pattern(elt_cmt, *pat, op);\n+              for before.each |&before_pat| {\n+                  let elt_cmt = self.cat_index(pat, cmt);\n+                  self.cat_pattern(elt_cmt, before_pat, op);\n               }\n-              for slice.each |slice_pat| {\n-                  let slice_ty = self.tcx.ty(*slice_pat);\n-                  let slice_cmt = self.cat_rvalue(*slice_pat, slice_ty);\n-                  self.cat_pattern(slice_cmt, *slice_pat, op);\n+              for slice.each |&slice_pat| {\n+                  let slice_ty = self.pat_ty(slice_pat);\n+                  let slice_cmt = self.cat_rvalue(pat, slice_ty);\n+                  self.cat_pattern(slice_cmt, slice_pat, op);\n               }\n-              for after.each |pat| {\n-                  let elt_cmt = self.cat_index(*pat, cmt);\n-                  self.cat_pattern(elt_cmt, *pat, op);\n+              for after.each |&after_pat| {\n+                  let elt_cmt = self.cat_index(pat, cmt);\n+                  self.cat_pattern(elt_cmt, after_pat, op);\n               }\n           }\n \n@@ -986,29 +909,6 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_to_repr(&self, cat: categorization) -> ~str {\n-        match cat {\n-          cat_special(sk_method) => ~\"method\",\n-          cat_special(sk_static_item) => ~\"static_item\",\n-          cat_special(sk_implicit_self) => ~\"implicit-self\",\n-          cat_special(sk_heap_upvar) => ~\"heap-upvar\",\n-          cat_stack_upvar(_) => ~\"stack-upvar\",\n-          cat_rvalue => ~\"rvalue\",\n-          cat_local(node_id) => fmt!(\"local(%d)\", node_id),\n-          cat_binding(node_id) => fmt!(\"binding(%d)\", node_id),\n-          cat_arg(node_id) => fmt!(\"arg(%d)\", node_id),\n-          cat_self(node_id) => fmt!(\"self(%d)\", node_id),\n-          cat_deref(cmt, derefs, ptr) => {\n-            fmt!(\"%s->(%s, %u)\", self.cat_to_repr(cmt.cat),\n-                 self.ptr_sigil(ptr), derefs)\n-          }\n-          cat_comp(cmt, comp) => {\n-            fmt!(\"%s.%s\", self.cat_to_repr(cmt.cat), *self.comp_to_repr(comp))\n-          }\n-          cat_discr(cmt, _) => self.cat_to_repr(cmt.cat)\n-        }\n-    }\n-\n     fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n         match mutbl {\n           m_mutbl => ~\"mutable\",\n@@ -1017,84 +917,33 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn ptr_sigil(&self, ptr: ptr_kind) -> ~str {\n-        match ptr {\n-          uniq_ptr => ~\"~\",\n-          gc_ptr(_) => ~\"@\",\n-          region_ptr(_, _) => ~\"&\",\n-          unsafe_ptr => ~\"*\"\n-        }\n-    }\n-\n-    fn comp_to_repr(&self, comp: comp_kind) -> @~str {\n-        match comp {\n-          comp_field(fld, _) => self.tcx.sess.str_of(fld),\n-          comp_index(*) => @~\"[]\",\n-          comp_tuple => @~\"()\",\n-          comp_anon_field => @~\"<anonymous field>\",\n-          comp_variant(_) => @~\"<enum>\"\n-        }\n-    }\n-\n-    fn lp_to_str(&self, lp: @loan_path) -> ~str {\n-        match *lp {\n-          lp_local(node_id) => {\n-            fmt!(\"local(%d)\", node_id)\n-          }\n-          lp_arg(node_id) => {\n-            fmt!(\"arg(%d)\", node_id)\n-          }\n-          lp_self => ~\"self\",\n-          lp_deref(lp, ptr) => {\n-            fmt!(\"%s->(%s)\", self.lp_to_str(lp),\n-                 self.ptr_sigil(ptr))\n-          }\n-          lp_comp(lp, comp) => {\n-            fmt!(\"%s.%s\", self.lp_to_str(lp),\n-                 *self.comp_to_repr(comp))\n-          }\n-        }\n-    }\n-\n-    fn cmt_to_repr(&self, cmt: cmt) -> ~str {\n-        fmt!(\"{%s id:%d m:%? lp:%s ty:%s}\",\n-             self.cat_to_repr(cmt.cat),\n-             cmt.id,\n-             cmt.mutbl,\n-             cmt.lp.map_default(~\"none\", |p| self.lp_to_str(*p) ),\n-             ty_to_str(self.tcx, cmt.ty))\n-    }\n-\n     fn cmt_to_str(&self, cmt: cmt) -> ~str {\n-        let mut_str = cmt.mutbl.to_user_str();\n         match cmt.cat {\n-          cat_special(sk_method) => ~\"method\",\n-          cat_special(sk_static_item) => ~\"static item\",\n-          cat_special(sk_implicit_self) => ~\"self reference\",\n-          cat_special(sk_heap_upvar) => {\n+          cat_static_item => ~\"static item\",\n+          cat_implicit_self => ~\"self reference\",\n+          cat_copied_upvar(_) => {\n               ~\"captured outer variable in a heap closure\"\n           }\n           cat_rvalue => ~\"non-lvalue\",\n-          cat_local(_) => mut_str + ~\" local variable\",\n-          cat_binding(_) => ~\"pattern binding\",\n+          cat_local(_) => ~\"local variable\",\n           cat_self(_) => ~\"self value\",\n-          cat_arg(_) => ~\"argument\",\n-          cat_deref(_, _, pk) => fmt!(\"dereference of %s %s pointer\",\n-                                      mut_str, self.ptr_sigil(pk)),\n-          cat_stack_upvar(_) => {\n-            ~\"captured outer \" + mut_str + ~\" variable in a stack closure\"\n-          }\n-          cat_comp(_, comp_field(*)) => mut_str + ~\" field\",\n-          cat_comp(_, comp_tuple) => ~\"tuple content\",\n-          cat_comp(_, comp_anon_field) => ~\"anonymous field\",\n-          cat_comp(_, comp_variant(_)) => ~\"enum content\",\n-          cat_comp(_, comp_index(t, _)) => {\n+          cat_arg(*) => ~\"argument\",\n+          cat_deref(_, _, pk) => fmt!(\"dereference of %s pointer\",\n+                                      ptr_sigil(pk)),\n+          cat_interior(_, interior_field(*)) => ~\"field\",\n+          cat_interior(_, interior_tuple) => ~\"tuple content\",\n+          cat_interior(_, interior_anon_field) => ~\"anonymous field\",\n+          cat_interior(_, interior_variant(_)) => ~\"enum content\",\n+          cat_interior(_, interior_index(t, _)) => {\n             match ty::get(t).sty {\n-              ty::ty_evec(*) => mut_str + ~\" vec content\",\n-              ty::ty_estr(*) => mut_str + ~\" str content\",\n-              _ => mut_str + ~\" indexed content\"\n+              ty::ty_evec(*) => ~\"vec content\",\n+              ty::ty_estr(*) => ~\"str content\",\n+              _ => ~\"indexed content\"\n             }\n           }\n+          cat_stack_upvar(_) => {\n+              ~\"captured outer variable\"\n+          }\n           cat_discr(cmt, _) => {\n             self.cmt_to_str(cmt)\n           }\n@@ -1128,7 +977,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n         }\n       }\n       ty::ty_enum(*) => {\n-        match *tcx.def_map.get(&node_id) {\n+        match tcx.def_map.get_copy(&node_id) {\n           ast::def_variant(_, variant_id) => {\n             for ty::lookup_struct_fields(tcx, variant_id).each |fld| {\n                 if fld.ident == f_name {\n@@ -1149,33 +998,141 @@ pub fn field_mutbl(tcx: ty::ctxt,\n     return None;\n }\n \n-pub impl categorization {\n-    fn derefs_through_mutable_box(&const self) -> bool {\n-        match *self {\n-            cat_deref(_, _, gc_ptr(ast::m_mutbl)) => {\n-                true\n+pub enum AliasableReason {\n+    AliasableManaged(ast::mutability),\n+    AliasableBorrowed(ast::mutability),\n+    AliasableOther\n+}\n+\n+pub impl cmt_ {\n+    fn guarantor(@self) -> cmt {\n+        //! Returns `self` after stripping away any owned pointer derefs or\n+        //! interior content. The return value is basically the `cmt` which\n+        //! determines how long the value in `self` remains live.\n+\n+        match self.cat {\n+            cat_rvalue |\n+            cat_static_item |\n+            cat_implicit_self |\n+            cat_copied_upvar(*) |\n+            cat_local(*) |\n+            cat_self(*) |\n+            cat_arg(*) |\n+            cat_deref(_, _, unsafe_ptr(*)) |\n+            cat_deref(_, _, gc_ptr(*)) |\n+            cat_deref(_, _, region_ptr(*)) => {\n+                self\n+            }\n+            cat_stack_upvar(b) |\n+            cat_discr(b, _) |\n+            cat_interior(b, _) |\n+            cat_deref(b, _, uniq_ptr(*)) => {\n+                b.guarantor()\n+            }\n+        }\n+    }\n+\n+    fn is_freely_aliasable(&self) -> bool {\n+        self.freely_aliasable().is_some()\n+    }\n+\n+    fn freely_aliasable(&self) -> Option<AliasableReason> {\n+        //! True if this lvalue resides in an area that is\n+        //! freely aliasable, meaning that rustc cannot track\n+        //! the alias//es with precision.\n+\n+        // Maybe non-obvious: copied upvars can only be considered\n+        // non-aliasable in once closures, since any other kind can be\n+        // aliased and eventually recused.\n+\n+        match self.cat {\n+            cat_copied_upvar(CopiedUpvar {onceness: ast::Once, _}) |\n+            cat_rvalue(*) |\n+            cat_local(*) |\n+            cat_arg(_) |\n+            cat_self(*) |\n+            cat_deref(_, _, unsafe_ptr(*)) | // of course it is aliasable, but...\n+            cat_deref(_, _, region_ptr(m_mutbl, _)) => {\n+                None\n+            }\n+\n+            cat_copied_upvar(CopiedUpvar {onceness: ast::Many, _}) |\n+            cat_static_item(*) |\n+            cat_implicit_self(*) => {\n+                Some(AliasableOther)\n+            }\n+\n+            cat_deref(_, _, gc_ptr(m)) => {\n+                Some(AliasableManaged(m))\n+            }\n+\n+            cat_deref(_, _, region_ptr(m @ m_const, _)) |\n+            cat_deref(_, _, region_ptr(m @ m_imm, _)) => {\n+                Some(AliasableBorrowed(m))\n             }\n-            cat_deref(subcmt, _, _) |\n-            cat_comp(subcmt, _) |\n-            cat_discr(subcmt, _) |\n-            cat_stack_upvar(subcmt) => {\n-                subcmt.cat.derefs_through_mutable_box()\n+\n+            cat_stack_upvar(b) |\n+            cat_deref(b, _, uniq_ptr(*)) |\n+            cat_interior(b, _) |\n+            cat_discr(b, _) => {\n+                b.freely_aliasable()\n             }\n+        }\n+    }\n+}\n+\n+impl Repr for cmt {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        fmt!(\"{%s id:%d m:%? ty:%s}\",\n+             self.cat.repr(tcx),\n+             self.id,\n+             self.mutbl,\n+             self.ty.repr(tcx))\n+    }\n+}\n+\n+impl Repr for categorization {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        match *self {\n+            cat_static_item |\n+            cat_implicit_self |\n             cat_rvalue |\n-            cat_special(*) |\n+            cat_copied_upvar(*) |\n             cat_local(*) |\n-            cat_binding(*) |\n-            cat_arg(*) |\n-            cat_self(*) => {\n-                false\n+            cat_self(*) |\n+            cat_arg(*) => fmt!(\"%?\", *self),\n+            cat_deref(cmt, derefs, ptr) => {\n+                fmt!(\"%s->(%s, %u)\", cmt.cat.repr(tcx),\n+                     ptr_sigil(ptr), derefs)\n+            }\n+            cat_interior(cmt, interior) => {\n+                fmt!(\"%s.%s\",\n+                     cmt.cat.repr(tcx),\n+                     interior.repr(tcx))\n             }\n+            cat_stack_upvar(cmt) |\n+            cat_discr(cmt, _) => cmt.cat.repr(tcx)\n         }\n     }\n+}\n+\n+pub fn ptr_sigil(ptr: ptr_kind) -> ~str {\n+    match ptr {\n+        uniq_ptr(_) => ~\"~\",\n+        gc_ptr(_) => ~\"@\",\n+        region_ptr(_, _) => ~\"&\",\n+        unsafe_ptr => ~\"*\"\n+    }\n+}\n \n-    fn is_mutable_box(&const self) -> bool {\n+impl Repr for interior_kind {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n-            cat_deref(_, _, gc_ptr(ast::m_mutbl)) => true,\n-            _ => false\n+            interior_field(fld, _) => copy *tcx.sess.str_of(fld),\n+            interior_index(*) => ~\"[]\",\n+            interior_tuple => ~\"()\",\n+            interior_anon_field => ~\"<anonymous field>\",\n+            interior_variant(_) => ~\"<enum>\"\n         }\n     }\n }"}, {"sha": "040ff30f9e63fce79a02b153213cc3e03ad11e45", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -246,10 +246,19 @@ pub type MovesMap = @mut HashSet<node_id>;\n  * expression */\n pub type VariableMovesMap = @mut HashMap<node_id, @expr>;\n \n+/**\n+ * Set of variable node-ids that are moved.\n+ *\n+ * Note: The `VariableMovesMap` stores expression ids that\n+ * are moves, whereas this set stores the ids of the variables\n+ * that are moved at some point */\n+pub type MovedVariablesSet = @mut HashSet<node_id>;\n+\n /** See the section Output on the module comment for explanation. */\n pub struct MoveMaps {\n     moves_map: MovesMap,\n     variable_moves_map: VariableMovesMap,\n+    moved_variables_set: MovedVariablesSet,\n     capture_map: CaptureMap\n }\n \n@@ -279,13 +288,25 @@ pub fn compute_moves(tcx: ty::ctxt,\n         move_maps: MoveMaps {\n             moves_map: @mut HashSet::new(),\n             variable_moves_map: @mut HashMap::new(),\n-            capture_map: @mut HashMap::new()\n+            capture_map: @mut HashMap::new(),\n+            moved_variables_set: @mut HashSet::new()\n         }\n     };\n     visit::visit_crate(crate, visit_cx, visitor);\n     return visit_cx.move_maps;\n }\n \n+pub fn moved_variable_node_id_from_def(def: def) -> Option<node_id> {\n+    match def {\n+      def_binding(nid, _) |\n+      def_arg(nid, _) |\n+      def_local(nid, _) |\n+      def_self(nid, _) => Some(nid),\n+\n+      _ => None\n+    }\n+}\n+\n // ______________________________________________________________________\n // Expressions\n \n@@ -419,6 +440,11 @@ pub impl VisitContext {\n                     MoveInPart(entire_expr) => {\n                         self.move_maps.variable_moves_map.insert(\n                             expr.id, entire_expr);\n+\n+                        let def = self.tcx.def_map.get_copy(&expr.id);\n+                        for moved_variable_node_id_from_def(def).each |&id| {\n+                            self.move_maps.moved_variables_set.insert(id);\n+                        }\n                     }\n                     Read => {}\n                     MoveInWhole => {"}, {"sha": "ce0f124da74c9e977af8a885ec9ce60957059d62", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -481,7 +481,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                     }\n                 }\n                 expr_path(path) => {\n-                    check_path(expr.span, *tcx.def_map.get(&expr.id), path);\n+                    check_path(expr.span, tcx.def_map.get_copy(&expr.id), path);\n                 }\n                 expr_struct(_, ref fields, _) => {\n                     match ty::get(ty::expr_ty(tcx, expr)).sty {\n@@ -499,7 +499,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                         ty_enum(id, _) => {\n                             if id.crate != local_crate ||\n                                     !privileged_items.contains(&(id.node)) {\n-                                match *tcx.def_map.get(&expr.id) {\n+                                match tcx.def_map.get_copy(&expr.id) {\n                                     def_variant(_, variant_id) => {\n                                         for (*fields).each |field| {\n                                                 debug!(\"(privacy checking) \\"}, {"sha": "cdc3aa9fedb7ef57e0f509e7f62a1bfb2edebcad", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 164, "deletions": 154, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -47,59 +47,27 @@ The region maps encode information about region relationships.\n   - the free region map is populated during type check as we check\n     each function. See the function `relate_free_regions` for\n     more information.\n+- `cleanup_scopes` includes scopes where trans cleanups occur\n+  - this is intended to reflect the current state of trans, not\n+    necessarily how I think things ought to work\n */\n pub struct RegionMaps {\n     priv scope_map: HashMap<ast::node_id, ast::node_id>,\n     priv free_region_map: HashMap<FreeRegion, ~[FreeRegion]>,\n+    priv cleanup_scopes: HashSet<ast::node_id>\n }\n \n-pub struct ctxt {\n+pub struct Context {\n     sess: Session,\n     def_map: resolve::DefMap,\n \n     // Generated maps:\n     region_maps: @mut RegionMaps,\n \n-    // Generally speaking, expressions are parented to their innermost\n-    // enclosing block. But some kinds of expressions serve as\n-    // parents: calls, methods, etc.  In addition, some expressions\n-    // serve as parents by virtue of where they appear.  For example,\n-    // the condition in a while loop is always a parent.  In those\n-    // cases, we add the node id of such an expression to this set so\n-    // that when we visit it we can view it as a parent.\n-    root_exprs: @mut HashSet<ast::node_id>,\n-\n-    // The parent scope is the innermost block, statement, call, or match\n-    // expression during the execution of which the current expression\n-    // will be evaluated.  Generally speaking, the innermost parent\n-    // scope is also the closest suitable ancestor in the AST tree.\n-    //\n-    // There is a subtle point concerning call arguments.  Imagine\n-    // you have a call:\n-    //\n-    // { // block a\n-    //     foo( // call b\n-    //        x,\n-    //        y);\n-    // }\n-    //\n-    // In what lifetime are the expressions `x` and `y` evaluated?  At\n-    // first, I imagine the answer was the block `a`, as the arguments\n-    // are evaluated before the call takes place.  But this turns out\n-    // to be wrong.  The lifetime of the call must encompass the\n-    // argument evaluation as well.\n-    //\n-    // The reason is that evaluation of an earlier argument could\n-    // create a borrow which exists during the evaluation of later\n-    // arguments.  Consider this torture test, for example,\n-    //\n-    // fn test1(x: @mut ~int) {\n-    //     foo(&**x, *x = ~5);\n-    // }\n-    //\n-    // Here, the first argument `&**x` will be a borrow of the `~int`,\n-    // but the second argument overwrites that very value! Bad.\n-    // (This test is borrowck-pure-scope-in-call.rs, btw)\n+    // Scope where variables should be parented to\n+    var_parent: parent,\n+\n+    // Innermost enclosing expression\n     parent: parent,\n }\n \n@@ -128,10 +96,22 @@ pub impl RegionMaps {\n                      sup: ast::node_id)\n     {\n         debug!(\"record_parent(sub=%?, sup=%?)\", sub, sup);\n+        assert!(sub != sup);\n \n         self.scope_map.insert(sub, sup);\n     }\n \n+    pub fn record_cleanup_scope(&mut self,\n+                                scope_id: ast::node_id)\n+    {\n+        //! Records that a scope is a CLEANUP SCOPE.  This is invoked\n+        //! from within regionck.  We wait until regionck because we do\n+        //! not know which operators are overloaded until that point,\n+        //! and only overloaded operators result in cleanup scopes.\n+\n+        self.cleanup_scopes.insert(scope_id);\n+    }\n+\n     fn opt_encl_scope(&self,\n                       id: ast::node_id) -> Option<ast::node_id>\n     {\n@@ -151,6 +131,22 @@ pub impl RegionMaps {\n         }\n     }\n \n+    fn is_cleanup_scope(&self, scope_id: ast::node_id) -> bool {\n+        self.cleanup_scopes.contains(&scope_id)\n+    }\n+\n+    fn cleanup_scope(&self,\n+                     expr_id: ast::node_id) -> ast::node_id\n+    {\n+        //! Returns the scope when temps in expr will be cleaned up\n+\n+        let mut id = self.encl_scope(expr_id);\n+        while !self.cleanup_scopes.contains(&id) {\n+            id = self.encl_scope(id);\n+        }\n+        return id;\n+    }\n+\n     fn encl_region(&self,\n                    id: ast::node_id) -> ty::Region\n     {\n@@ -159,22 +155,38 @@ pub impl RegionMaps {\n         ty::re_scope(self.encl_scope(id))\n     }\n \n-    fn is_sub_scope(&self,\n-                    sub_scope: ast::node_id,\n-                    superscope: ast::node_id) -> bool\n+    pub fn scopes_intersect(&self,\n+                            scope1: ast::node_id,\n+                            scope2: ast::node_id) -> bool\n+    {\n+        self.is_subscope_of(scope1, scope2) || self.is_subscope_of(scope2, scope1)\n+    }\n+\n+    fn is_subscope_of(&self,\n+                      subscope: ast::node_id,\n+                      superscope: ast::node_id) -> bool\n     {\n         /*!\n-         * Returns true if `sub_scope` is equal to or is lexically\n+         * Returns true if `subscope` is equal to or is lexically\n          * nested inside `superscope` and false otherwise.\n          */\n \n-        let mut sub_scope = sub_scope;\n-        while superscope != sub_scope {\n-            match self.scope_map.find(&sub_scope) {\n-                None => return false,\n-                Some(&scope) => sub_scope = scope\n+        let mut s = subscope;\n+        while superscope != s {\n+            match self.scope_map.find(&s) {\n+                None => {\n+                    debug!(\"is_subscope_of(%?, %?, s=%?)=false\",\n+                           subscope, superscope, s);\n+\n+                    return false;\n+                }\n+                Some(&scope) => s = scope\n             }\n         }\n+\n+        debug!(\"is_subscope_of(%?, %?)=true\",\n+               subscope, superscope);\n+\n         return true;\n     }\n \n@@ -239,11 +251,11 @@ pub impl RegionMaps {\n                 }\n \n                 (ty::re_scope(sub_scope), ty::re_scope(super_scope)) => {\n-                    self.is_sub_scope(sub_scope, super_scope)\n+                    self.is_subscope_of(sub_scope, super_scope)\n                 }\n \n                 (ty::re_scope(sub_scope), ty::re_free(ref fr)) => {\n-                    self.is_sub_scope(sub_scope, fr.scope_id)\n+                    self.is_subscope_of(sub_scope, fr.scope_id)\n                 }\n \n                 (ty::re_free(sub_fr), ty::re_free(super_fr)) => {\n@@ -301,6 +313,7 @@ pub impl RegionMaps {\n         fn ancestors_of(self: &RegionMaps, scope: ast::node_id)\n             -> ~[ast::node_id]\n         {\n+            // debug!(\"ancestors_of(scope=%d)\", scope);\n             let mut result = ~[scope];\n             let mut scope = scope;\n             loop {\n@@ -311,13 +324,14 @@ pub impl RegionMaps {\n                         scope = superscope;\n                     }\n                 }\n+                // debug!(\"ancestors_of_loop(scope=%d)\", scope);\n             }\n         }\n     }\n }\n \n /// Extracts that current parent from cx, failing if there is none.\n-pub fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n+pub fn parent_id(cx: Context, span: span) -> ast::node_id {\n     match cx.parent {\n       None => {\n         cx.sess.span_bug(span, \"crate should not be parent here\");\n@@ -329,143 +343,136 @@ pub fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n }\n \n /// Records the current parent (if any) as the parent of `child_id`.\n-pub fn record_parent(cx: ctxt, child_id: ast::node_id) {\n+pub fn parent_to_expr(cx: Context, child_id: ast::node_id) {\n     for cx.parent.each |parent_id| {\n         cx.region_maps.record_parent(child_id, *parent_id);\n     }\n }\n \n-pub fn resolve_block(blk: &ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_block(blk: &ast::blk, cx: Context, visitor: visit::vt<Context>) {\n     // Record the parent of this block.\n-    record_parent(cx, blk.node.id);\n+    parent_to_expr(cx, blk.node.id);\n \n     // Descend.\n-    let new_cx: ctxt = ctxt {parent: Some(blk.node.id),.. cx};\n+    let new_cx = Context {var_parent: Some(blk.node.id),\n+                          parent: Some(blk.node.id),\n+                          ..cx};\n     visit::visit_block(blk, new_cx, visitor);\n }\n \n-pub fn resolve_arm(arm: &ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_arm(arm: &ast::arm, cx: Context, visitor: visit::vt<Context>) {\n     visit::visit_arm(arm, cx, visitor);\n }\n \n-pub fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n-    match pat.node {\n-      ast::pat_ident(*) => {\n-        let defn_opt = cx.def_map.find(&pat.id);\n-        match defn_opt {\n-          Some(&ast::def_variant(_,_)) => {\n-            /* Nothing to do; this names a variant. */\n-          }\n-          _ => {\n-            /* This names a local. Bind it to the containing scope. */\n-            record_parent(cx, pat.id);\n-          }\n-        }\n-      }\n-      _ => { /* no-op */ }\n-    }\n-\n+pub fn resolve_pat(pat: @ast::pat, cx: Context, visitor: visit::vt<Context>) {\n+    assert!(cx.var_parent == cx.parent);\n+    parent_to_expr(cx, pat.id);\n     visit::visit_pat(pat, cx, visitor);\n }\n \n-pub fn resolve_stmt(stmt: @ast::stmt, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_stmt(stmt: @ast::stmt, cx: Context, visitor: visit::vt<Context>) {\n     match stmt.node {\n-      ast::stmt_decl(*) => {\n-        visit::visit_stmt(stmt, cx, visitor);\n-      }\n-      // This code has to be kept consistent with trans::base::trans_stmt\n-      ast::stmt_expr(_, stmt_id) |\n-      ast::stmt_semi(_, stmt_id) => {\n-        record_parent(cx, stmt_id);\n-        let mut expr_cx = cx;\n-        expr_cx.parent = Some(stmt_id);\n-        visit::visit_stmt(stmt, expr_cx, visitor);\n-      }\n-      ast::stmt_mac(*) => cx.sess.bug(~\"unexpanded macro\")\n+        ast::stmt_decl(*) => {\n+            visit::visit_stmt(stmt, cx, visitor);\n+        }\n+        ast::stmt_expr(_, stmt_id) |\n+        ast::stmt_semi(_, stmt_id) => {\n+            parent_to_expr(cx, stmt_id);\n+            let expr_cx = Context {parent: Some(stmt_id), ..cx};\n+            visit::visit_stmt(stmt, expr_cx, visitor);\n+        }\n+        ast::stmt_mac(*) => cx.sess.bug(~\"unexpanded macro\")\n     }\n }\n \n-pub fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n-    record_parent(cx, expr.id);\n+pub fn resolve_expr(expr: @ast::expr, cx: Context, visitor: visit::vt<Context>) {\n+    parent_to_expr(cx, expr.id);\n \n     let mut new_cx = cx;\n+    new_cx.parent = Some(expr.id);\n     match expr.node {\n-      // Calls or overloadable operators\n-      // FIXME #3387\n-      // ast::expr_index(*) | ast::expr_binary(*) |\n-      // ast::expr_unary(*) |\n-      ast::expr_call(*) | ast::expr_method_call(*) => {\n-        debug!(\"node %d: %s\", expr.id, pprust::expr_to_str(expr,\n-                                                           cx.sess.intr()));\n-        new_cx.parent = Some(expr.id);\n-      }\n-      ast::expr_match(*) => {\n-        debug!(\"node %d: %s\", expr.id, pprust::expr_to_str(expr,\n-                                                           cx.sess.intr()));\n-        new_cx.parent = Some(expr.id);\n-      }\n-      ast::expr_while(cond, _) => {\n-        new_cx.root_exprs.insert(cond.id);\n-      }\n-      _ => {}\n+        ast::expr_assign_op(*) | ast::expr_index(*) | ast::expr_binary(*) |\n+        ast::expr_unary(*) | ast::expr_call(*) | ast::expr_method_call(*) => {\n+            // FIXME(#6268) Nested method calls\n+            //\n+            // The lifetimes for a call or method call look as follows:\n+            //\n+            // call.id\n+            // - arg0.id\n+            // - ...\n+            // - argN.id\n+            // - call.callee_id\n+            //\n+            // The idea is that call.callee_id represents *the time when\n+            // the invoked function is actually running* and call.id\n+            // represents *the time to prepare the arguments and make the\n+            // call*.  See the section \"Borrows in Calls\" borrowck/doc.rs\n+            // for an extended explanantion of why this distinction is\n+            // important.\n+            //\n+            // parent_to_expr(new_cx, expr.callee_id);\n+        }\n+\n+        ast::expr_match(*) => {\n+            new_cx.var_parent = Some(expr.id);\n+        }\n+\n+        _ => {}\n     };\n \n-    if new_cx.root_exprs.contains(&expr.id) {\n-        new_cx.parent = Some(expr.id);\n-    }\n \n     visit::visit_expr(expr, new_cx, visitor);\n }\n \n pub fn resolve_local(local: @ast::local,\n-                     cx: ctxt,\n-                     visitor: visit::vt<ctxt>) {\n-    record_parent(cx, local.node.id);\n+                     cx: Context,\n+                     visitor: visit::vt<Context>) {\n+    assert!(cx.var_parent == cx.parent);\n+    parent_to_expr(cx, local.node.id);\n     visit::visit_local(local, cx, visitor);\n }\n \n-pub fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_item(item: @ast::item, cx: Context, visitor: visit::vt<Context>) {\n     // Items create a new outer block scope as far as we're concerned.\n-    let new_cx: ctxt = ctxt {parent: None,.. cx};\n+    let new_cx = Context {var_parent: None, parent: None, ..cx};\n     visit::visit_item(item, new_cx, visitor);\n }\n \n pub fn resolve_fn(fk: &visit::fn_kind,\n                   decl: &ast::fn_decl,\n                   body: &ast::blk,\n-                  sp: span,\n+                  _sp: span,\n                   id: ast::node_id,\n-                  cx: ctxt,\n-                  visitor: visit::vt<ctxt>) {\n-    let fn_cx = match *fk {\n-        visit::fk_item_fn(*) | visit::fk_method(*) => {\n-            // Top-level functions are a root scope.\n-            ctxt {parent: Some(id),.. cx}\n-        }\n-\n-        visit::fk_anon(*) | visit::fk_fn_block(*) => {\n-            // Closures continue with the inherited scope.\n-            cx\n-        }\n-    };\n-\n-    // Record the ID of `self`.\n+                  cx: Context,\n+                  visitor: visit::vt<Context>) {\n+    debug!(\"region::resolve_fn(id=%?, body.node.id=%?, cx.parent=%?)\",\n+           id, body.node.id, cx.parent);\n+\n+    // The arguments and `self` are parented to the body of the fn.\n+    let decl_cx = Context {parent: Some(body.node.id),\n+                           var_parent: Some(body.node.id),\n+                           ..cx};\n     match *fk {\n         visit::fk_method(_, _, method) => {\n             cx.region_maps.record_parent(method.self_id, body.node.id);\n         }\n         _ => {}\n     }\n+    visit::visit_fn_decl(decl, decl_cx, visitor);\n \n-    debug!(\"visiting fn with body %d. cx.parent: %? \\\n-            fn_cx.parent: %?\",\n-           body.node.id, cx.parent, fn_cx.parent);\n-\n-    for decl.inputs.each |input| {\n-        cx.region_maps.record_parent(input.id, body.node.id);\n-    }\n-\n-    visit::visit_fn(fk, decl, body, sp, id, fn_cx, visitor);\n+    // The body of the fn itself is either a root scope (top-level fn)\n+    // or it continues with the inherited scope (closures).\n+    let body_cx = match *fk {\n+        visit::fk_item_fn(*) |\n+        visit::fk_method(*) => {\n+            Context {parent: None, var_parent: None, ..cx}\n+        }\n+        visit::fk_anon(*) |\n+        visit::fk_fn_block(*) => {\n+            cx\n+        }\n+    };\n+    (visitor.visit_block)(body, body_cx, visitor);\n }\n \n pub fn resolve_crate(sess: Session,\n@@ -474,13 +481,14 @@ pub fn resolve_crate(sess: Session,\n {\n     let region_maps = @mut RegionMaps {\n         scope_map: HashMap::new(),\n-        free_region_map: HashMap::new()\n+        free_region_map: HashMap::new(),\n+        cleanup_scopes: HashSet::new(),\n     };\n-    let cx: ctxt = ctxt {sess: sess,\n-                         def_map: def_map,\n-                         region_maps: region_maps,\n-                         root_exprs: @mut HashSet::new(),\n-                         parent: None};\n+    let cx = Context {sess: sess,\n+                      def_map: def_map,\n+                      region_maps: region_maps,\n+                      parent: None,\n+                      var_parent: None};\n     let visitor = visit::mk_vt(@visit::Visitor {\n         visit_block: resolve_block,\n         visit_item: resolve_item,\n@@ -771,7 +779,8 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n                    pprust::ty_to_str(ty, sess.intr()));\n \n             if cx.region_is_relevant(r) {\n-                cx.add_rp(cx.item_id, cx.add_variance(rv_contravariant))\n+                let rv = cx.add_variance(rv_contravariant);\n+                cx.add_rp(cx.item_id, rv)\n             }\n         }\n \n@@ -781,14 +790,14 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n             match f.region {\n                 Some(_) => {\n                     if cx.region_is_relevant(f.region) {\n-                        cx.add_rp(cx.item_id,\n-                                  cx.add_variance(rv_contravariant))\n+                        let rv = cx.add_variance(rv_contravariant);\n+                        cx.add_rp(cx.item_id, rv)\n                     }\n                 }\n                 None => {\n                     if f.sigil == ast::BorrowedSigil && cx.anon_implies_rp {\n-                        cx.add_rp(cx.item_id,\n-                                  cx.add_variance(rv_contravariant));\n+                        let rv = cx.add_variance(rv_contravariant);\n+                        cx.add_rp(cx.item_id, rv)\n                     }\n                 }\n             }\n@@ -819,7 +828,8 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n                     debug!(\"reference to external, rp'd type %s\",\n                            pprust::ty_to_str(ty, sess.intr()));\n                     if cx.region_is_relevant(path.rp) {\n-                        cx.add_rp(cx.item_id, cx.add_variance(variance))\n+                        let rv = cx.add_variance(variance);\n+                        cx.add_rp(cx.item_id, rv)\n                     }\n                   }\n                 }\n@@ -938,7 +948,7 @@ pub fn determine_rp_in_crate(sess: Session,\n         let cx = &mut *cx;\n         while cx.worklist.len() != 0 {\n             let c_id = cx.worklist.pop();\n-            let c_variance = *cx.region_paramd_items.get(&c_id);\n+            let c_variance = cx.region_paramd_items.get_copy(&c_id);\n             debug!(\"popped %d from worklist\", c_id);\n             match cx.dep_map.find(&c_id) {\n               None => {}"}, {"sha": "946bf26fd2713d8c4b88423be91bba89b1706bff", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -779,9 +779,9 @@ pub fn Resolver(session: Session,\n         unresolved_imports: 0,\n \n         current_module: current_module,\n-        value_ribs: ~[],\n-        type_ribs: ~[],\n-        label_ribs: ~[],\n+        value_ribs: @mut ~[],\n+        type_ribs: @mut ~[],\n+        label_ribs: @mut ~[],\n \n         xray_context: NoXray,\n         current_trait_refs: None,\n@@ -830,13 +830,13 @@ pub struct Resolver {\n \n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n-    value_ribs: ~[@Rib],\n+    value_ribs: @mut ~[@Rib],\n \n     // The current set of local scopes, for types.\n-    type_ribs: ~[@Rib],\n+    type_ribs: @mut ~[@Rib],\n \n     // The current set of local scopes, for labels.\n-    label_ribs: ~[@Rib],\n+    label_ribs: @mut ~[@Rib],\n \n     // Whether the current context is an X-ray context. An X-ray context is\n     // allowed to access private names of any module.\n@@ -971,7 +971,7 @@ pub impl Resolver {\n                 module_.children.insert(name, child);\n                 return (child, new_parent);\n             }\n-            Some(child) => {\n+            Some(&child) => {\n                 // Enforce the duplicate checking mode:\n                 //\n                 // * If we're requesting duplicate module checking, check that\n@@ -1033,7 +1033,7 @@ pub impl Resolver {\n                                   *self.session.str_of(name)));\n                     }\n                 }\n-                return (*child, new_parent);\n+                return (child, new_parent);\n             }\n         }\n     }\n@@ -1864,7 +1864,7 @@ pub impl Resolver {\n                        *self.session.str_of(target));\n \n                 match module_.import_resolutions.find(&target) {\n-                    Some(resolution) => {\n+                    Some(&resolution) => {\n                         debug!(\"(building import directive) bumping \\\n                                 reference\");\n                         resolution.outstanding_references += 1;\n@@ -2395,7 +2395,7 @@ pub impl Resolver {\n                         (*ident, new_import_resolution);\n                 }\n                 None => { /* continue ... */ }\n-                Some(dest_import_resolution) => {\n+                Some(&dest_import_resolution) => {\n                     // Merge the two import resolutions at a finer-grained\n                     // level.\n \n@@ -2433,8 +2433,8 @@ pub impl Resolver {\n                     module_.import_resolutions.insert\n                         (*ident, dest_import_resolution);\n                 }\n-                Some(existing_import_resolution) => {\n-                    dest_import_resolution = *existing_import_resolution;\n+                Some(&existing_import_resolution) => {\n+                    dest_import_resolution = existing_import_resolution;\n                 }\n             }\n \n@@ -4294,19 +4294,18 @@ pub impl Resolver {\n                 }\n \n                 pat_struct(path, _, _) => {\n-                    let structs: &mut HashSet<def_id> = &mut self.structs;\n                     match self.resolve_path(path, TypeNS, false, visitor) {\n                         Some(def_ty(class_id))\n-                                if structs.contains(&class_id) => {\n+                                if self.structs.contains(&class_id) => {\n                             let class_def = def_struct(class_id);\n                             self.record_def(pattern.id, class_def);\n                         }\n-                        Some(definition @ def_struct(class_id))\n-                                if structs.contains(&class_id) => {\n+                        Some(definition @ def_struct(class_id)) => {\n+                            assert!(self.structs.contains(&class_id));\n                             self.record_def(pattern.id, definition);\n                         }\n                         Some(definition @ def_variant(_, variant_id))\n-                                if structs.contains(&variant_id) => {\n+                                if self.structs.contains(&variant_id) => {\n                             self.record_def(pattern.id, definition);\n                         }\n                         result => {\n@@ -4608,12 +4607,12 @@ pub impl Resolver {\n         let search_result;\n         match namespace {\n             ValueNS => {\n-                search_result = self.search_ribs(&mut self.value_ribs, ident,\n+                search_result = self.search_ribs(self.value_ribs, ident,\n                                                  span,\n                                                  DontAllowCapturingSelf);\n             }\n             TypeNS => {\n-                search_result = self.search_ribs(&mut self.type_ribs, ident,\n+                search_result = self.search_ribs(self.type_ribs, ident,\n                                                  span, AllowCapturingSelf);\n             }\n         }\n@@ -4803,15 +4802,14 @@ pub impl Resolver {\n \n             expr_struct(path, _, _) => {\n                 // Resolve the path to the structure it goes to.\n-                let structs: &mut HashSet<def_id> = &mut self.structs;\n                 match self.resolve_path(path, TypeNS, false, visitor) {\n                     Some(def_ty(class_id)) | Some(def_struct(class_id))\n-                            if structs.contains(&class_id) => {\n+                            if self.structs.contains(&class_id) => {\n                         let class_def = def_struct(class_id);\n                         self.record_def(expr.id, class_def);\n                     }\n                     Some(definition @ def_variant(_, class_id))\n-                            if structs.contains(&class_id) => {\n+                            if self.structs.contains(&class_id) => {\n                         self.record_def(expr.id, definition);\n                     }\n                     _ => {\n@@ -4827,17 +4825,19 @@ pub impl Resolver {\n \n             expr_loop(_, Some(label)) => {\n                 do self.with_label_rib {\n-                    let this = &mut *self;\n-                    let def_like = dl_def(def_label(expr.id));\n-                    let rib = this.label_ribs[this.label_ribs.len() - 1];\n-                    rib.bindings.insert(label, def_like);\n+                    {\n+                        let this = &mut *self;\n+                        let def_like = dl_def(def_label(expr.id));\n+                        let rib = this.label_ribs[this.label_ribs.len() - 1];\n+                        rib.bindings.insert(label, def_like);\n+                    }\n \n                     visit_expr(expr, (), visitor);\n                 }\n             }\n \n             expr_break(Some(label)) | expr_again(Some(label)) => {\n-                match self.search_ribs(&mut self.label_ribs, label, expr.span,\n+                match self.search_ribs(self.label_ribs, label, expr.span,\n                                        DontAllowCapturingSelf) {\n                     None =>\n                         self.session.span_err(expr.span,\n@@ -5248,7 +5248,7 @@ pub impl Resolver {\n \n         debug!(\"Import resolutions:\");\n         for module_.import_resolutions.each |name, import_resolution| {\n-            let mut value_repr;\n+            let value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n                 None => { value_repr = ~\"\"; }\n                 Some(_) => {\n@@ -5257,7 +5257,7 @@ pub impl Resolver {\n                 }\n             }\n \n-            let mut type_repr;\n+            let type_repr;\n             match import_resolution.target_for_namespace(TypeNS) {\n                 None => { type_repr = ~\"\"; }\n                 Some(_) => {"}, {"sha": "2773710ca98fc13dc6e9de31b1c716db1bf06387", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "added", "additions": 5294, "deletions": 0, "changes": 5294, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "d074a2f796f4656604ebdc711aeb54b13d449ae1", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 49, "deletions": 29, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -280,7 +280,7 @@ pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n pub fn variant_opt(bcx: block, pat_id: ast::node_id)\n     -> Opt {\n     let ccx = bcx.ccx();\n-    match *ccx.tcx.def_map.get(&pat_id) {\n+    match ccx.tcx.def_map.get_copy(&pat_id) {\n         ast::def_variant(enum_id, var_id) => {\n             let variants = ty::enum_variants(ccx.tcx, enum_id);\n             for vec::each(*variants) |v| {\n@@ -516,7 +516,7 @@ pub fn enter_opt<'r>(bcx: block,\n         match p.node {\n             ast::pat_enum(*) |\n             ast::pat_ident(_, _, None) if pat_is_const(tcx.def_map, p) => {\n-                let const_def = *tcx.def_map.get(&p.id);\n+                let const_def = tcx.def_map.get_copy(&p.id);\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n                 if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n                     Some(~[])\n@@ -552,7 +552,7 @@ pub fn enter_opt<'r>(bcx: block,\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     // Look up the struct variant ID.\n                     let struct_id;\n-                    match *tcx.def_map.get(&p.id) {\n+                    match tcx.def_map.get_copy(&p.id) {\n                         ast::def_variant(_, found_struct_id) => {\n                             struct_id = found_struct_id;\n                         }\n@@ -865,17 +865,28 @@ pub fn extract_variant_args(bcx: block,\n     ExtractedBlock { vals: args, bcx: bcx }\n }\n \n+fn match_datum(bcx: block, val: ValueRef, pat_id: ast::node_id) -> Datum {\n+    //! Helper for converting from the ValueRef that we pass around in\n+    //! the match code, which is always by ref, into a Datum. Eventually\n+    //! we should just pass around a Datum and be done with it.\n+\n+    let ty = node_id_type(bcx, pat_id);\n+    Datum {val: val, ty: ty, mode: datum::ByRef, source: RevokeClean}\n+}\n+\n+\n pub fn extract_vec_elems(bcx: block,\n+                         pat_span: span,\n                          pat_id: ast::node_id,\n                          elem_count: uint,\n                          slice: Option<uint>,\n                          val: ValueRef,\n                          count: ValueRef)\n                       -> ExtractedBlock {\n     let _icx = bcx.insn_ctxt(\"match::extract_vec_elems\");\n+    let vec_datum = match_datum(bcx, val, pat_id);\n+    let (bcx, base, len) = vec_datum.get_vec_base_and_len(bcx, pat_span, pat_id);\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n-    let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n-    let (base, len) = tvec::get_base_and_len(bcx, unboxed, vt.vec_ty);\n \n     let mut elems = do vec::from_fn(elem_count) |i| {\n         match slice {\n@@ -946,30 +957,28 @@ pub fn collect_record_or_struct_fields(bcx: block,\n     }\n }\n \n-pub fn root_pats_as_necessary(bcx: block,\n+pub fn pats_require_rooting(bcx: block,\n+                            m: &[@Match],\n+                            col: uint)\n+                         -> bool {\n+    vec::any(m, |br| {\n+        let pat_id = br.pats[col].id;\n+        let key = root_map_key {id: pat_id, derefs: 0u };\n+        bcx.ccx().maps.root_map.contains_key(&key)\n+    })\n+}\n+\n+pub fn root_pats_as_necessary(mut bcx: block,\n                               m: &[@Match],\n                               col: uint,\n                               val: ValueRef)\n                            -> block {\n-    let mut bcx = bcx;\n     for vec::each(m) |br| {\n         let pat_id = br.pats[col].id;\n-\n-        let key = root_map_key {id: pat_id, derefs: 0u };\n-        match bcx.ccx().maps.root_map.find(&key) {\n-            None => (),\n-            Some(&root_info) => {\n-                // Note: the scope_id will always be the id of the match.  See\n-                // the extended comment in rustc::middle::borrowck::preserve()\n-                // for details (look for the case covering cat_discr).\n-\n-                let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n-                                   mode: ByRef, source: ZeroMem};\n-                bcx = datum.root(bcx, root_info);\n-                // If we kept going, we'd only re-root the same value, so\n-                // return now.\n-                return bcx;\n-            }\n+        if pat_id != 0 {\n+            let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n+                               mode: ByRef, source: ZeroMem};\n+            bcx = datum.root_and_write_guard(bcx, br.pats[col].span, pat_id, 0);\n         }\n     }\n     return bcx;\n@@ -1113,7 +1122,8 @@ pub fn compare_values(cx: block,\n pub fn store_non_ref_bindings(bcx: block,\n                               data: &ArmData,\n                               opt_temp_cleanups: Option<&mut ~[ValueRef]>)\n-                           -> block {\n+    -> block\n+{\n     /*!\n      *\n      * For each copy/move binding, copy the value from the value\n@@ -1124,6 +1134,7 @@ pub fn store_non_ref_bindings(bcx: block,\n      */\n \n     let mut bcx = bcx;\n+    let mut opt_temp_cleanups = opt_temp_cleanups;\n     for data.bindings_map.each_value |&binding_info| {\n         match binding_info.trmode {\n             TrByValue(is_move, lldest) => {\n@@ -1138,9 +1149,10 @@ pub fn store_non_ref_bindings(bcx: block,\n                     }\n                 };\n \n-                for opt_temp_cleanups.each |temp_cleanups| {\n+                do opt_temp_cleanups.mutate |temp_cleanups| {\n                     add_clean_temp_mem(bcx, lldest, binding_info.ty);\n                     temp_cleanups.push(lldest);\n+                    temp_cleanups\n                 }\n             }\n             TrByRef | TrByImplicitRef => {}\n@@ -1293,13 +1305,20 @@ pub fn compile_submatch(bcx: block,\n                                 vec::slice(vals, col + 1u, vals.len()));\n     let ccx = *bcx.fcx.ccx;\n     let mut pat_id = 0;\n+    let mut pat_span = dummy_sp();\n     for vec::each(m) |br| {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n-        if pat_id == 0 { pat_id = br.pats[col].id; }\n+        if pat_id == 0 {\n+            pat_id = br.pats[col].id;\n+            pat_span = br.pats[col].span;\n+        }\n     }\n \n-    bcx = root_pats_as_necessary(bcx, m, col, val);\n+    // If we are not matching against an `@T`, we should not be\n+    // required to root any values.\n+    assert!(any_box_pat(m, col) || !pats_require_rooting(bcx, m, col));\n+\n     let rec_fields = collect_record_or_struct_fields(bcx, m, col);\n     if rec_fields.len() > 0 {\n         let pat_ty = node_id_type(bcx, pat_id);\n@@ -1360,6 +1379,7 @@ pub fn compile_submatch(bcx: block,\n \n     // Unbox in case of a box field\n     if any_box_pat(m, col) {\n+        bcx = root_pats_as_necessary(bcx, m, col, val);\n         let llbox = Load(bcx, val);\n         let box_no_addrspace = non_gc_box_cast(bcx, llbox);\n         let unboxed =\n@@ -1560,8 +1580,8 @@ pub fn compile_submatch(bcx: block,\n                     vec_len_ge(_, i) => Some(i),\n                     _ => None\n                 };\n-                let args = extract_vec_elems(opt_cx, pat_id, n, slice,\n-                    val, test_val);\n+                let args = extract_vec_elems(opt_cx, pat_span, pat_id, n, slice,\n+                                             val, test_val);\n                 size = args.vals.len();\n                 unpacked = /*bad*/copy args.vals;\n                 opt_cx = args.bcx;"}, {"sha": "34f798ec7a6311d58f431525a8f6f0b19cf50e44", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 74, "deletions": 100, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -34,7 +34,6 @@ use lib;\n use metadata::common::LinkMeta;\n use metadata::{csearch, cstore, encoder};\n use middle::astencode;\n-use middle::borrowck::RootInfo;\n use middle::resolve;\n use middle::trans::_match;\n use middle::trans::adt;\n@@ -62,7 +61,6 @@ use middle::trans::type_of::*;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, ty_to_str};\n-use util::ppaux;\n \n use core::hash;\n use core::hashmap::{HashMap, HashSet};\n@@ -391,14 +389,16 @@ pub fn get_tydesc_simple(ccx: @CrateContext, t: ty::t) -> ValueRef {\n \n pub fn get_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n     match ccx.tydescs.find(&t) {\n-      Some(&inf) => inf,\n-      _ => {\n-        ccx.stats.n_static_tydescs += 1u;\n-        let inf = glue::declare_tydesc(ccx, t);\n-        ccx.tydescs.insert(t, inf);\n-        inf\n-      }\n+        Some(&inf) => {\n+            return inf;\n+        }\n+        _ => { }\n     }\n+\n+    ccx.stats.n_static_tydescs += 1u;\n+    let inf = glue::declare_tydesc(ccx, t);\n+    ccx.tydescs.insert(t, inf);\n+    return inf;\n }\n \n pub fn set_optimize_for_size(f: ValueRef) {\n@@ -885,23 +885,22 @@ pub fn need_invoke(bcx: block) -> bool {\n     // Walk the scopes to look for cleanups\n     let mut cur = bcx;\n     loop {\n-        let current = &mut *cur;\n-        let kind = &mut *current.kind;\n-        match *kind {\n-          block_scope(ref mut inf) => {\n-            for vec::each((*inf).cleanups) |cleanup| {\n-                match *cleanup {\n-                  clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n-                    if cleanup_type == normal_exit_and_unwind {\n-                        return true;\n+        match cur.kind {\n+            block_scope(inf) => {\n+                let inf = &mut *inf; // FIXME(#5074) workaround old borrowck\n+                for vec::each(inf.cleanups) |cleanup| {\n+                    match *cleanup {\n+                        clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n+                            if cleanup_type == normal_exit_and_unwind {\n+                                return true;\n+                            }\n+                        }\n                     }\n-                  }\n                 }\n             }\n-          }\n-          _ => ()\n+            _ => ()\n         }\n-        cur = match current.parent {\n+        cur = match cur.parent {\n           Some(next) => next,\n           None => return false\n         }\n@@ -923,11 +922,13 @@ pub fn in_lpad_scope_cx(bcx: block, f: &fn(si: &mut scope_info)) {\n     let mut bcx = bcx;\n     loop {\n         {\n-            // FIXME #4280: Borrow check bug workaround.\n-            let kind: &mut block_kind = &mut *bcx.kind;\n-            match *kind {\n-                block_scope(ref mut inf) => {\n-                    if inf.cleanups.len() > 0u || bcx.parent.is_none() {\n+            match bcx.kind {\n+                block_scope(inf) => {\n+                    let len = { // FIXME(#5074) workaround old borrowck\n+                        let inf = &mut *inf;\n+                        inf.cleanups.len()\n+                    };\n+                    if len > 0u || bcx.parent.is_none() {\n                         f(inf);\n                         return;\n                     }\n@@ -989,57 +990,30 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     return pad_bcx.llbb;\n }\n \n-// Arranges for the value found in `*root_loc` to be dropped once the scope\n-// associated with `scope_id` exits.  This is used to keep boxes live when\n-// there are extant region pointers pointing at the interior.\n-//\n-// Note that `root_loc` is not the value itself but rather a pointer to the\n-// value.  Generally it in alloca'd value.  The reason for this is that the\n-// value is initialized in an inner block but may be freed in some outer\n-// block, so an SSA value that is valid in the inner block may not be valid in\n-// the outer block.  In fact, the inner block may not even execute.  Rather\n-// than generate the full SSA form, we just use an alloca'd value.\n-pub fn add_root_cleanup(bcx: block,\n-                        root_info: RootInfo,\n-                        root_loc: ValueRef,\n-                        ty: ty::t) {\n-\n-    debug!(\"add_root_cleanup(bcx=%s, \\\n-                             scope=%d, \\\n-                             freezes=%?, \\\n-                             root_loc=%s, \\\n-                             ty=%s)\",\n-           bcx.to_str(),\n-           root_info.scope,\n-           root_info.freezes,\n-           val_str(bcx.ccx().tn, root_loc),\n-           ppaux::ty_to_str(bcx.ccx().tcx, ty));\n-\n-    let bcx_scope = find_bcx_for_scope(bcx, root_info.scope);\n-    if root_info.freezes {\n-        add_clean_frozen_root(bcx_scope, root_loc, ty);\n-    } else {\n-        add_clean_temp_mem(bcx_scope, root_loc, ty);\n-    }\n-\n-    fn find_bcx_for_scope(bcx: block, scope_id: ast::node_id) -> block {\n-        let mut bcx_sid = bcx;\n-        loop {\n-            bcx_sid = match bcx_sid.node_info {\n-              Some(NodeInfo { id, _ }) if id == scope_id => {\n+pub fn find_bcx_for_scope(bcx: block, scope_id: ast::node_id) -> block {\n+    let mut bcx_sid = bcx;\n+    loop {\n+        bcx_sid = match bcx_sid.node_info {\n+            Some(NodeInfo { id, _ }) if id == scope_id => {\n                 return bcx_sid\n               }\n-              _ => {\n-                match bcx_sid.parent {\n-                  None => bcx.tcx().sess.bug(\n-                      fmt!(\"no enclosing scope with id %d\", scope_id)),\n-                  Some(bcx_par) => bcx_par\n+\n+                // FIXME(#6268, #6248) hacky cleanup for nested method calls\n+                Some(NodeInfo { callee_id: Some(id), _ }) if id == scope_id => {\n+                    return bcx_sid\n+                }\n+\n+                _ => {\n+                    match bcx_sid.parent {\n+                        None => bcx.tcx().sess.bug(\n+                            fmt!(\"no enclosing scope with id %d\", scope_id)),\n+                        Some(bcx_par) => bcx_par\n+                    }\n                 }\n-              }\n             }\n         }\n     }\n-}\n+\n \n pub fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n@@ -1160,7 +1134,7 @@ pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n     let _icx = cx.insn_ctxt(\"trans_stmt\");\n     debug!(\"trans_stmt(%s)\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n-    if !cx.sess().no_asm_comments() {\n+    if cx.sess().asm_comments() {\n         add_span_comment(cx, s.span, stmt_to_str(s, cx.ccx().sess.intr()));\n     }\n \n@@ -1220,7 +1194,7 @@ pub fn new_block(cx: fn_ctxt, parent: Option<block>, kind: block_kind,\n }\n \n pub fn simple_block_scope() -> block_kind {\n-    block_scope(scope_info {\n+    block_scope(@mut scope_info {\n         loop_break: None,\n         loop_label: None,\n         cleanups: ~[],\n@@ -1248,7 +1222,7 @@ pub fn loop_scope_block(bcx: block,\n                         loop_label: Option<ident>,\n                         n: ~str,\n                         opt_node_info: Option<NodeInfo>) -> block {\n-    return new_block(bcx.fcx, Some(bcx), block_scope(scope_info {\n+    return new_block(bcx.fcx, Some(bcx), block_scope(@mut scope_info {\n         loop_break: Some(loop_break),\n         loop_label: loop_label,\n         cleanups: ~[],\n@@ -1284,7 +1258,7 @@ pub fn trans_block_cleanups(bcx: block, cleanups: ~[cleanup]) -> block {\n }\n \n pub fn trans_block_cleanups_(bcx: block,\n-                             cleanups: ~[cleanup],\n+                             cleanups: &[cleanup],\n                              /* cleanup_cx: block, */\n                              is_lpad: bool) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_block_cleanups\");\n@@ -1326,28 +1300,28 @@ pub fn cleanup_and_leave(bcx: block,\n                 @fmt!(\"cleanup_and_leave(%s)\", cur.to_str()));\n         }\n \n-        {\n-            // FIXME #4280: Borrow check bug workaround.\n-            let kind: &mut block_kind = &mut *cur.kind;\n-            match *kind {\n-              block_scope(ref mut inf) if !inf.cleanups.is_empty() => {\n-                for vec::find((*inf).cleanup_paths,\n-                              |cp| cp.target == leave).each |cp| {\n-                    Br(bcx, cp.dest);\n-                    return;\n-                }\n-                let sub_cx = sub_block(bcx, ~\"cleanup\");\n-                Br(bcx, sub_cx.llbb);\n-                inf.cleanup_paths.push(cleanup_path {\n-                    target: leave,\n-                    dest: sub_cx.llbb\n-                });\n+        match cur.kind {\n+            block_scope(inf) if !inf.empty_cleanups() => {\n+                let (sub_cx, inf_cleanups) = {\n+                    let inf = &mut *inf; // FIXME(#5074) workaround stage0\n+                    for vec::find((*inf).cleanup_paths,\n+                                  |cp| cp.target == leave).each |cp| {\n+                        Br(bcx, cp.dest);\n+                        return;\n+                    }\n+                    let sub_cx = sub_block(bcx, ~\"cleanup\");\n+                    Br(bcx, sub_cx.llbb);\n+                    inf.cleanup_paths.push(cleanup_path {\n+                        target: leave,\n+                        dest: sub_cx.llbb\n+                    });\n+                    (sub_cx, copy inf.cleanups)\n+                };\n                 bcx = trans_block_cleanups_(sub_cx,\n-                                            block_cleanups(cur),\n+                                            inf_cleanups,\n                                             is_lpad);\n-              }\n-              _ => ()\n             }\n+            _ => ()\n         }\n \n         match upto {\n@@ -2080,7 +2054,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n                                              fcx.llretptr.get(),\n                                              0,\n                                              i);\n-        let llarg = match *fcx.llargs.get(&field.node.id) {\n+        let llarg = match fcx.llargs.get_copy(&field.node.id) {\n             local_mem(x) => x,\n             _ => {\n                 ccx.tcx.sess.bug(~\"trans_tuple_struct: llarg wasn't \\\n@@ -2120,7 +2094,7 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::enum_def,\n \n pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_item\");\n-    let path = match *ccx.tcx.items.get(&item.id) {\n+    let path = match ccx.tcx.items.get_copy(&item.id) {\n         ast_map::node_item(_, p) => p,\n         // tjc: ?\n         _ => fail!(~\"trans_item\"),\n@@ -2302,7 +2276,7 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n         // Call main.\n         let lloutputarg = C_null(T_ptr(T_i8()));\n         let llenvarg = unsafe { llvm::LLVMGetParam(llfdecl, 1 as c_uint) };\n-        let mut args = ~[lloutputarg, llenvarg];\n+        let args = ~[lloutputarg, llenvarg];\n         let llresult = Call(bcx, main_llfn, args);\n         Store(bcx, llresult, fcx.llretptr.get());\n \n@@ -2413,7 +2387,7 @@ pub fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n }\n \n pub fn item_path(ccx: @CrateContext, i: @ast::item) -> path {\n-    let base = match *ccx.tcx.items.get(&i.id) {\n+    let base = match ccx.tcx.items.get_copy(&i.id) {\n         ast_map::node_item(_, p) => p,\n             // separate map for paths?\n         _ => fail!(~\"item_path\")\n@@ -2428,7 +2402,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n       Some(&v) => v,\n       None => {\n         let mut exprt = false;\n-        let val = match *tcx.items.get(&id) {\n+        let val = match tcx.items.get_copy(&id) {\n           ast_map::node_item(i, pth) => {\n             let my_path = vec::append(/*bad*/copy *pth,\n                                       ~[path_name(i.ident)]);"}, {"sha": "c3dc4f1e8eb2bdcf3ea7301299e698710f0a92c3", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -846,7 +846,7 @@ pub fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n \n pub fn add_span_comment(bcx: block, sp: span, text: &str) {\n     let ccx = bcx.ccx();\n-    if !ccx.sess.no_asm_comments() {\n+    if ccx.sess.asm_comments() {\n         let s = fmt!(\"%s (%s)\", text, ccx.sess.codemap.span_to_str(sp));\n         debug!(\"%s\", copy s);\n         add_comment(bcx, s);\n@@ -856,7 +856,7 @@ pub fn add_span_comment(bcx: block, sp: span, text: &str) {\n pub fn add_comment(bcx: block, text: &str) {\n     unsafe {\n         let ccx = bcx.ccx();\n-        if !ccx.sess.no_asm_comments() {\n+        if ccx.sess.asm_comments() {\n             let sanitized = str::replace(text, ~\"$\", ~\"\");\n             let comment_text = ~\"# \" +\n                 str::replace(sanitized, ~\"\\n\", ~\"\\n\\t# \");"}, {"sha": "87322393ab9831a05acaf45b894a7569aab3ef76", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -39,7 +39,6 @@ use middle::trans::monomorphize;\n use middle::trans::type_of;\n use middle::ty;\n use middle::typeck;\n-use util::common::indenter;\n use util::ppaux::Repr;\n \n use syntax::ast;\n@@ -340,16 +339,12 @@ pub fn trans_method_call(in_cx: block,\n         node_id_type(in_cx, call_ex.callee_id),\n         expr_ty(in_cx, call_ex),\n         |cx| {\n-            match cx.ccx().maps.method_map.find(&call_ex.id) {\n+            match cx.ccx().maps.method_map.find_copy(&call_ex.id) {\n                 Some(origin) => {\n                     debug!(\"origin for %s: %s\",\n                            call_ex.repr(in_cx.tcx()),\n                            origin.repr(in_cx.tcx()));\n \n-                    // FIXME(#5562): removing this copy causes a segfault\n-                    //               before stage2\n-                    let origin = /*bad*/ copy *origin;\n-\n                     meth::trans_method_callee(cx,\n                                               call_ex.callee_id,\n                                               rcvr,\n@@ -687,7 +682,6 @@ pub fn trans_arg_expr(bcx: block,\n            self_mode,\n            arg_expr.repr(bcx.tcx()),\n            ret_flag.map(|v| bcx.val_str(*v)));\n-    let _indenter = indenter();\n \n     // translate the arg expr to a datum\n     let arg_datumblock = match ret_flag {\n@@ -722,7 +716,7 @@ pub fn trans_arg_expr(bcx: block,\n             }\n         }\n     };\n-    let mut arg_datum = arg_datumblock.datum;\n+    let arg_datum = arg_datumblock.datum;\n     let bcx = arg_datumblock.bcx;\n \n     debug!(\"   arg datum: %s\", arg_datum.to_str(bcx.ccx()));"}, {"sha": "e0a20f64907150e3ff3e39e4b6dbb0c0e50bed0a", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -208,7 +208,6 @@ pub fn store_environment(bcx: block,\n \n     // allocate closure in the heap\n     let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, sigil, cdata_ty);\n-    let mut temp_cleanups = ~[];\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n@@ -224,7 +223,7 @@ pub fn store_environment(bcx: block,\n     for vec::eachi(bound_values) |i, bv| {\n         debug!(\"Copy %s into closure\", bv.to_str(ccx));\n \n-        if !ccx.sess.no_asm_comments() {\n+        if ccx.sess.asm_comments() {\n             add_comment(bcx, fmt!(\"Copy %s into closure\",\n                                   bv.to_str(ccx)));\n         }\n@@ -244,9 +243,6 @@ pub fn store_environment(bcx: block,\n         }\n \n     }\n-    for vec::each(temp_cleanups) |cleanup| {\n-        revoke_clean(bcx, *cleanup);\n-    }\n \n     ClosureResult { llbox: llbox, cdata_ty: cdata_ty, bcx: bcx }\n }\n@@ -424,7 +420,7 @@ pub fn trans_expr_fn(bcx: block,\n \n     let Result {bcx: bcx, val: closure} = match sigil {\n         ast::BorrowedSigil | ast::ManagedSigil | ast::OwnedSigil => {\n-            let cap_vars = *ccx.maps.capture_map.get(&user_id);\n+            let cap_vars = ccx.maps.capture_map.get_copy(&user_id);\n             let ret_handle = match is_loop_body {Some(x) => x,\n                                                  None => None};\n             let ClosureResult {llbox, cdata_ty, bcx}"}, {"sha": "442b5d25c8ba2e5f37dbf26bdd916470d1fec5f7", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 65, "deletions": 41, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -27,18 +27,18 @@ use middle::resolve;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::build;\n-use middle::trans::callee;\n use middle::trans::datum;\n use middle::trans::debuginfo;\n-use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::reachable;\n use middle::trans::shape;\n use middle::trans::type_of;\n use middle::trans::type_use;\n+use middle::trans::write_guard;\n use middle::ty::substs;\n use middle::ty;\n use middle::typeck;\n+use middle::borrowck::root_map_key;\n use util::ppaux::{Repr};\n \n use core::cast::transmute;\n@@ -467,28 +467,35 @@ pub fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n         scope_clean_changed(scope_info);\n     }\n }\n-pub fn add_clean_frozen_root(bcx: block, val: ValueRef, t: ty::t) {\n-    debug!(\"add_clean_frozen_root(%s, %s, %s)\",\n-           bcx.to_str(), val_str(bcx.ccx().tn, val),\n-           t.repr(bcx.tcx()));\n-    let (root, rooted) = root_for_cleanup(bcx, val, t);\n-    let cleanup_type = cleanup_type(bcx.tcx(), t);\n+pub fn add_clean_return_to_mut(bcx: block,\n+                               root_key: root_map_key,\n+                               frozen_val_ref: ValueRef,\n+                               bits_val_ref: ValueRef,\n+                               filename_val: ValueRef,\n+                               line_val: ValueRef) {\n+    //! When an `@mut` has been frozen, we have to\n+    //! call the lang-item `return_to_mut` when the\n+    //! freeze goes out of scope. We need to pass\n+    //! in both the value which was frozen (`frozen_val`) and\n+    //! the value (`bits_val_ref`) which was returned when the\n+    //! box was frozen initially. Here, both `frozen_val_ref` and\n+    //! `bits_val_ref` are in fact pointers to stack slots.\n+\n+    debug!(\"add_clean_return_to_mut(%s, %s, %s)\",\n+           bcx.to_str(),\n+           val_str(bcx.ccx().tn, frozen_val_ref),\n+           val_str(bcx.ccx().tn, bits_val_ref));\n     do in_scope_cx(bcx) |scope_info| {\n         scope_info.cleanups.push(\n-            clean_temp(val, |bcx| {\n-                let bcx = callee::trans_lang_call(\n-                    bcx,\n-                    bcx.tcx().lang_items.return_to_mut_fn(),\n-                    ~[\n-                        build::Load(bcx,\n-                                    build::PointerCast(bcx,\n-                                                       root,\n-                                                       T_ptr(T_ptr(T_i8()))))\n-                    ],\n-                    expr::Ignore\n-                );\n-                glue::drop_ty_root(bcx, root, rooted, t)\n-            }, cleanup_type));\n+            clean_temp(\n+                frozen_val_ref,\n+                |bcx| write_guard::return_to_mut(bcx,\n+                                                 root_key,\n+                                                 frozen_val_ref,\n+                                                 bits_val_ref,\n+                                                 filename_val,\n+                                                 line_val),\n+                normal_exit_only));\n         scope_clean_changed(scope_info);\n     }\n }\n@@ -516,6 +523,7 @@ pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n // drop glue checks whether it is zero.\n pub fn revoke_clean(cx: block, val: ValueRef) {\n     do in_scope_cx(cx) |scope_info| {\n+        let scope_info = &mut *scope_info; // FIXME(#5074) workaround borrowck\n         let cleanup_pos = vec::position(\n             scope_info.cleanups,\n             |cu| match *cu {\n@@ -534,9 +542,9 @@ pub fn revoke_clean(cx: block, val: ValueRef) {\n }\n \n pub fn block_cleanups(bcx: block) -> ~[cleanup] {\n-    match *bcx.kind {\n+    match bcx.kind {\n        block_non_scope  => ~[],\n-       block_scope(ref mut inf) => /*bad*/copy inf.cleanups\n+       block_scope(inf) => /*bad*/copy inf.cleanups\n     }\n }\n \n@@ -545,7 +553,7 @@ pub enum block_kind {\n     // cleaned up. May correspond to an actual block in the language, but also\n     // to an implicit scope, for example, calls introduce an implicit scope in\n     // which the arguments are evaluated and cleaned up.\n-    block_scope(scope_info),\n+    block_scope(@mut scope_info),\n \n     // A non-scope block is a basic block created as a translation artifact\n     // from translating code that expresses conditional logic rather than by\n@@ -568,19 +576,29 @@ pub struct scope_info {\n     landing_pad: Option<BasicBlockRef>,\n }\n \n+pub impl scope_info {\n+    fn empty_cleanups(&mut self) -> bool {\n+        self.cleanups.is_empty()\n+    }\n+}\n+\n pub trait get_node_info {\n     fn info(&self) -> Option<NodeInfo>;\n }\n \n impl get_node_info for @ast::expr {\n     fn info(&self) -> Option<NodeInfo> {\n-        Some(NodeInfo { id: self.id, span: self.span })\n+        Some(NodeInfo {id: self.id,\n+                       callee_id: Some(self.callee_id),\n+                       span: self.span})\n     }\n }\n \n impl get_node_info for ast::blk {\n     fn info(&self) -> Option<NodeInfo> {\n-        Some(NodeInfo { id: self.node.id, span: self.span })\n+        Some(NodeInfo {id: self.node.id,\n+                       callee_id: None,\n+                       span: self.span})\n     }\n }\n \n@@ -592,6 +610,7 @@ impl get_node_info for Option<@ast::expr> {\n \n pub struct NodeInfo {\n     id: ast::node_id,\n+    callee_id: Option<ast::node_id>,\n     span: span\n }\n \n@@ -611,7 +630,7 @@ pub struct block_ {\n     unreachable: bool,\n     parent: Option<block>,\n     // The 'kind' of basic block this is.\n-    kind: @mut block_kind,\n+    kind: block_kind,\n     // Is this block part of a landing pad?\n     is_lpad: bool,\n     // info about the AST node this block originated from, if any\n@@ -630,7 +649,7 @@ pub fn block_(llbb: BasicBlockRef, parent: Option<block>, kind: block_kind,\n         terminated: false,\n         unreachable: false,\n         parent: parent,\n-        kind: @mut kind,\n+        kind: kind,\n         is_lpad: is_lpad,\n         node_info: node_info,\n         fcx: fcx\n@@ -678,21 +697,17 @@ pub fn val_str(tn: @TypeNames, v: ValueRef) -> @str {\n     return ty_str(tn, val_ty(v));\n }\n \n-pub fn in_scope_cx(cx: block, f: &fn(si: &mut scope_info)) {\n+pub fn in_scope_cx(cx: block, f: &fn(si: @mut scope_info)) {\n     let mut cur = cx;\n     loop {\n-        {\n-            // XXX: Borrow check bug workaround.\n-            let kind: &mut block_kind = &mut *cur.kind;\n-            match *kind {\n-              block_scope(ref mut inf) => {\n-                  debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n-                         cur.to_str(), cx.to_str());\n-                  f(inf);\n-                  return;\n-              }\n-              _ => ()\n+        match cur.kind {\n+            block_scope(inf) => {\n+                debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n+                       cur.to_str(), cx.to_str());\n+                f(inf);\n+                return;\n             }\n+            _ => ()\n         }\n         cur = block_parent(cur);\n     }\n@@ -1517,6 +1532,15 @@ pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n     }\n }\n \n+pub fn filename_and_line_num_from_span(bcx: block,\n+                                       span: span) -> (ValueRef, ValueRef) {\n+    let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n+    let filename_cstr = C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name);\n+    let filename = build::PointerCast(bcx, filename_cstr, T_ptr(T_i8()));\n+    let line = C_int(bcx.ccx(), loc.line as int);\n+    (filename, line)\n+}\n+\n // Casts a Rust bool value to an i1.\n pub fn bool_to_i1(bcx: block, llval: ValueRef) -> ValueRef {\n     build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(false))"}, {"sha": "48c5a96c8e7b228a3db28c2b856ef0ec1d5585ba", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -157,7 +157,7 @@ pub fn get_const_val(cx: @CrateContext, def_id: ast::def_id) -> ValueRef {\n         if !ast_util::is_local(def_id) {\n             def_id = inline::maybe_instantiate_inline(cx, def_id, true);\n         }\n-        match *cx.tcx.items.get(&def_id.node) {\n+        match cx.tcx.items.get_copy(&def_id.node) {\n             ast_map::node_item(@ast::item {\n                 node: ast::item_const(_, subexpr), _\n             }, _) => {\n@@ -166,7 +166,7 @@ pub fn get_const_val(cx: @CrateContext, def_id: ast::def_id) -> ValueRef {\n             _ => cx.tcx.sess.bug(~\"expected a const to be an item\")\n         }\n     }\n-    *cx.const_values.get(&def_id.node)\n+    cx.const_values.get_copy(&def_id.node)\n }\n \n pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n@@ -194,18 +194,19 @@ pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             match adj.autoref {\n                 None => { }\n                 Some(ref autoref) => {\n-                    assert!(autoref.region == ty::re_static);\n-                    assert!(autoref.mutbl != ast::m_mutbl);\n                     // Don't copy data to do a deref+ref.\n                     let llptr = match maybe_ptr {\n                         Some(ptr) => ptr,\n                         None => const_addr_of(cx, llconst)\n                     };\n-                    match autoref.kind {\n-                        ty::AutoPtr => {\n+                    match *autoref {\n+                        ty::AutoUnsafe(m) |\n+                        ty::AutoPtr(ty::re_static, m) => {\n+                            assert!(m != ast::m_mutbl);\n                             llconst = llptr;\n                         }\n-                        ty::AutoBorrowVec => {\n+                        ty::AutoBorrowVec(ty::re_static, m) => {\n+                            assert!(m != ast::m_mutbl);\n                             let size = machine::llsize_of(cx,\n                                                           val_ty(llconst));\n                             assert!(abi::slice_elt_base == 0);\n@@ -550,7 +551,7 @@ pub fn trans_const(ccx: @CrateContext, _e: @ast::expr, id: ast::node_id) {\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = *ccx.const_values.get(&id);\n+        let v = ccx.const_values.get_copy(&id);\n         llvm::LLVMSetInitializer(g, v);\n         llvm::LLVMSetGlobalConstant(g, True);\n     }"}, {"sha": "f1192488bddb01334311fbb637f6c33777c2ad4e", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -193,7 +193,7 @@ pub fn trans_log(log_ex: @ast::expr,\n     };\n \n     let global = if ccx.module_data.contains_key(&modname) {\n-        *ccx.module_data.get(&modname)\n+        ccx.module_data.get_copy(&modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n             ccx, modpath, ~\"loglevel\");\n@@ -243,8 +243,8 @@ pub fn trans_break_cont(bcx: block,\n     let mut unwind = bcx;\n     let mut target;\n     loop {\n-        match *unwind.kind {\n-          block_scope(scope_info {\n+        match unwind.kind {\n+          block_scope(@scope_info {\n             loop_break: Some(brk),\n             loop_label: l,\n             _\n@@ -333,7 +333,7 @@ pub fn trans_fail_expr(bcx: block,\n                 bcx, expr::trans_to_datum(bcx, arg_expr));\n \n             if ty::type_is_str(arg_datum.ty) {\n-                let (lldata, _lllen) = arg_datum.get_base_and_len(bcx);\n+                let (lldata, _) = arg_datum.get_vec_base_and_len_no_root(bcx);\n                 return trans_fail_value(bcx, sp_opt, lldata);\n             } else if bcx.unreachable || ty::type_is_bot(arg_datum.ty) {\n                 return bcx;\n@@ -385,13 +385,7 @@ fn trans_fail_value(bcx: block,\n pub fn trans_fail_bounds_check(bcx: block, sp: span,\n                                index: ValueRef, len: ValueRef) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_fail_bounds_check\");\n-    let ccx = bcx.ccx();\n-\n-    let loc = bcx.sess().parse_sess.cm.lookup_char_pos(sp.lo);\n-    let line = C_int(ccx, loc.line as int);\n-    let filename_cstr = C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name);\n-    let filename = PointerCast(bcx, filename_cstr, T_ptr(T_i8()));\n-\n+    let (filename, line) = filename_and_line_num_from_span(bcx, sp);\n     let args = ~[filename, line, index, len];\n     let bcx = callee::trans_lang_call(\n         bcx, bcx.tcx().lang_items.fail_bounds_check_fn(), args, expr::Ignore);"}, {"sha": "c19650e3b684868a74a3b95869d10952fbd1dfcd", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 40, "deletions": 78, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -87,24 +87,24 @@\n \n use lib;\n use lib::llvm::ValueRef;\n-use middle::borrowck::{RootInfo, root_map_key};\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n-use middle::trans::callee;\n use middle::trans::common::*;\n use middle::trans::common;\n use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::tvec;\n use middle::trans::type_of;\n+use middle::trans::write_guard;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::ty_to_str;\n \n use core::container::Set; // XXX: this should not be necessary\n use core::to_bytes;\n use syntax::ast;\n+use syntax::codemap::span;\n use syntax::parse::token::special_idents;\n \n #[deriving(Eq)]\n@@ -516,59 +516,6 @@ pub impl Datum {\n         }\n     }\n \n-    fn root(&self, bcx: block, root_info: RootInfo) -> block {\n-        /*!\n-         *\n-         * In some cases, borrowck will decide that an @T/@[]/@str\n-         * value must be rooted for the program to be safe.  In that\n-         * case, we will call this function, which will stash a copy\n-         * away until we exit the scope `scope_id`. */\n-\n-        debug!(\"root(scope_id=%?, freezes=%?, self=%?)\",\n-               root_info.scope, root_info.freezes, self.to_str(bcx.ccx()));\n-\n-        if bcx.sess().trace() {\n-            trans_trace(\n-                bcx, None,\n-                @fmt!(\"preserving until end of scope %d\",\n-                     root_info.scope));\n-        }\n-\n-        let scratch = scratch_datum(bcx, self.ty, true);\n-        self.copy_to_datum(bcx, INIT, scratch);\n-        add_root_cleanup(bcx, root_info, scratch.val, scratch.ty);\n-\n-        // If we need to freeze the box, do that now.\n-        if root_info.freezes {\n-            callee::trans_lang_call(\n-                bcx,\n-                bcx.tcx().lang_items.borrow_as_imm_fn(),\n-                ~[\n-                    Load(bcx,\n-                         PointerCast(bcx,\n-                                     scratch.val,\n-                                     T_ptr(T_ptr(T_i8()))))\n-                ],\n-                expr::Ignore)\n-        } else {\n-            bcx\n-        }\n-    }\n-\n-    fn perform_write_guard(&self, bcx: block) -> block {\n-        // Create scratch space, but do not root it.\n-        let llval = match self.mode {\n-            ByValue => self.val,\n-            ByRef => Load(bcx, self.val),\n-        };\n-\n-        callee::trans_lang_call(\n-            bcx,\n-            bcx.tcx().lang_items.check_not_borrowed_fn(),\n-            ~[ PointerCast(bcx, llval, T_ptr(T_i8())) ],\n-            expr::Ignore)\n-    }\n-\n     fn drop_val(&self, bcx: block) -> block {\n         if !ty::type_needs_drop(bcx.tcx(), self.ty) {\n             return bcx;\n@@ -620,32 +567,20 @@ pub impl Datum {\n \n     fn try_deref(&self,\n         bcx: block,            // block wherein to generate insn's\n-        expr_id: ast::node_id, // id of expr being deref'd\n+        span: span,            // location where deref occurs\n+        expr_id: ast::node_id, // id of deref expr\n         derefs: uint,          // number of times deref'd already\n         is_auto: bool)         // if true, only deref if auto-derefable\n         -> (Option<Datum>, block)\n     {\n         let ccx = bcx.ccx();\n \n-        debug!(\"try_deref(expr_id=%d, derefs=%?, is_auto=%b, self=%?)\",\n+        debug!(\"try_deref(expr_id=%?, derefs=%?, is_auto=%b, self=%?)\",\n                expr_id, derefs, is_auto, self.to_str(bcx.ccx()));\n-        let _indenter = indenter();\n-\n-        // root the autoderef'd value, if necessary:\n-        //\n-        // (Note: root'd values are always boxes)\n-        let key = root_map_key { id: expr_id, derefs: derefs };\n-        let bcx = match ccx.maps.root_map.find(&key) {\n-            None => bcx,\n-            Some(&root_info) => self.root(bcx, root_info)\n-        };\n \n-        // Perform the write guard, if necessary.\n-        //\n-        // (Note: write-guarded values are always boxes)\n-        let bcx = if ccx.maps.write_guard_map.contains(&key) {\n-            self.perform_write_guard(bcx)\n-        } else { bcx };\n+        let bcx =\n+            write_guard::root_and_write_guard(\n+                self, bcx, span, expr_id, derefs);\n \n         match ty::get(self.ty).sty {\n             ty::ty_box(_) | ty::ty_uniq(_) => {\n@@ -755,10 +690,10 @@ pub impl Datum {\n     }\n \n     fn deref(&self, bcx: block,\n-             expr: @ast::expr,  // the expression whose value is being deref'd\n+             expr: @ast::expr,  // the deref expression\n              derefs: uint)\n           -> DatumBlock {\n-        match self.try_deref(bcx, expr.id, derefs, false) {\n+        match self.try_deref(bcx, expr.span, expr.id, derefs, false) {\n             (Some(lvres), bcx) => DatumBlock { bcx: bcx, datum: lvres },\n             (None, _) => {\n                 bcx.ccx().sess.span_bug(expr.span,\n@@ -768,6 +703,7 @@ pub impl Datum {\n     }\n \n     fn autoderef(&self, bcx: block,\n+                 span: span,\n                  expr_id: ast::node_id,\n                  max: uint)\n               -> DatumBlock {\n@@ -782,7 +718,7 @@ pub impl Datum {\n         let mut bcx = bcx;\n         while derefs < max {\n             derefs += 1u;\n-            match datum.try_deref(bcx, expr_id, derefs, true) {\n+            match datum.try_deref(bcx, span, expr_id, derefs, true) {\n                 (None, new_bcx) => { bcx = new_bcx; break }\n                 (Some(datum_deref), new_bcx) => {\n                     datum = datum_deref;\n@@ -798,8 +734,34 @@ pub impl Datum {\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n \n-    fn get_base_and_len(&self, bcx: block) -> (ValueRef, ValueRef) {\n-        tvec::get_base_and_len(bcx, self.to_appropriate_llval(bcx), self.ty)\n+    fn get_vec_base_and_len(&self,\n+                            mut bcx: block,\n+                            span: span,\n+                            expr_id: ast::node_id)\n+                            -> (block, ValueRef, ValueRef) {\n+        //! Converts a vector into the slice pair. Performs rooting\n+        //! and write guards checks.\n+\n+        // only imp't for @[] and @str, but harmless\n+        bcx = write_guard::root_and_write_guard(self, bcx, span, expr_id, 0);\n+        let (base, len) = self.get_vec_base_and_len_no_root(bcx);\n+        (bcx, base, len)\n+    }\n+\n+    fn get_vec_base_and_len_no_root(&self, bcx: block) -> (ValueRef, ValueRef) {\n+        //! Converts a vector into the slice pair. Des not root\n+        //! nor perform write guard checks.\n+\n+        let llval = self.to_appropriate_llval(bcx);\n+        tvec::get_base_and_len(bcx, llval, self.ty)\n+    }\n+\n+    fn root_and_write_guard(&self,\n+                            bcx: block,\n+                            span: span,\n+                            expr_id: ast::node_id,\n+                            derefs: uint) -> block {\n+        write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs)\n     }\n \n     fn to_result(&self, bcx: block) -> common::Result {"}, {"sha": "1e5680aff38174af137db12f23f586c93b063996", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -863,7 +863,7 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n         bcx.tcx().sess.span_bug(local.span, \"local is bound to something weird\");\n       }\n       option::None => {\n-        match *bcx.fcx.lllocals.get(&local.node.pat.id) {\n+        match bcx.fcx.lllocals.get_copy(&local.node.pat.id) {\n           local_imm(v) => v,\n           _ => bcx.tcx().sess.span_bug(local.span, \"local is bound to something weird\")\n         }\n@@ -915,7 +915,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n             };\n             update_cache(cache, tg, argument_metadata(mdval));\n \n-            let llptr = match *fcx.llargs.get(&arg.id) {\n+            let llptr = match fcx.llargs.get_copy(&arg.id) {\n               local_mem(v) | local_imm(v) => v,\n             };\n             let declargs = ~[llmdnode(~[llptr]), mdnode];\n@@ -958,7 +958,7 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n     let sp = fcx.span.get();\n     debug!(\"%s\", cx.sess.codemap.span_to_str(sp));\n \n-    let (ident, ret_ty, id) = match *cx.tcx.items.get(&fcx.id) {\n+    let (ident, ret_ty, id) = match cx.tcx.items.get_copy(&fcx.id) {\n       ast_map::node_item(item, _) => {\n         match item.node {\n           ast::item_fn(ref decl, _, _, _, _) => {"}, {"sha": "0e8b2e0474661d09de19bb840eeb6463a547fb5e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 69, "deletions": 106, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -123,7 +123,6 @@ use back::abi;\n use lib;\n use lib::llvm::{ValueRef, TypeRef, llvm};\n use metadata::csearch;\n-use middle::borrowck::root_map_key;\n use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::asm;\n@@ -146,9 +145,9 @@ use middle::trans::type_of;\n use middle::ty;\n use middle::ty::struct_mutable_fields;\n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn,\n-                 AutoDerefRef, AutoAddEnv};\n+                 AutoDerefRef, AutoAddEnv, AutoUnsafe};\n use util::common::indenter;\n-use util::ppaux::ty_to_str;\n+use util::ppaux::Repr;\n \n use core::cast::transmute;\n use core::hashmap::HashMap;\n@@ -201,33 +200,34 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n                 trans_to_datum_unadjusted(bcx, expr)\n             });\n \n+            debug!(\"unadjusted datum: %s\", datum.to_str(bcx.ccx()));\n+\n             if adj.autoderefs > 0 {\n                 let DatumBlock { bcx: new_bcx, datum: new_datum } =\n-                    datum.autoderef(bcx, expr.id, adj.autoderefs);\n+                    datum.autoderef(bcx, expr.span, expr.id, adj.autoderefs);\n                 datum = new_datum;\n                 bcx = new_bcx;\n             }\n \n             datum = match adj.autoref {\n-                None => datum,\n-                Some(ref autoref) => {\n-                    match autoref.kind {\n-                        AutoPtr => {\n-                            unpack_datum!(bcx, auto_ref(bcx, datum))\n-                        }\n-                        AutoBorrowVec => {\n-                            unpack_datum!(bcx, auto_slice(bcx, datum))\n-                        }\n-                        AutoBorrowVecRef => {\n-                            unpack_datum!(bcx, auto_slice_and_ref(bcx, datum))\n-                        }\n-                        AutoBorrowFn => {\n-                            // currently, all closure types are\n-                            // represented precisely the same, so no\n-                            // runtime adjustment is required:\n-                            datum\n-                        }\n-                    }\n+                None => {\n+                    datum\n+                }\n+                Some(AutoUnsafe(*)) | // region + unsafe ptrs have same repr\n+                Some(AutoPtr(*)) => {\n+                    unpack_datum!(bcx, auto_ref(bcx, datum))\n+                }\n+                Some(AutoBorrowVec(*)) => {\n+                    unpack_datum!(bcx, auto_slice(bcx, expr, datum))\n+                }\n+                Some(AutoBorrowVecRef(*)) => {\n+                    unpack_datum!(bcx, auto_slice_and_ref(bcx, expr, datum))\n+                }\n+                Some(AutoBorrowFn(*)) => {\n+                    // currently, all closure types are\n+                    // represented precisely the same, so no\n+                    // runtime adjustment is required:\n+                    datum\n                 }\n             };\n \n@@ -241,7 +241,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: datum.to_rptr(bcx)}\n     }\n \n-    fn auto_slice(bcx: block, datum: Datum) -> DatumBlock {\n+    fn auto_slice(bcx: block, expr: @ast::expr, datum: Datum) -> DatumBlock {\n         // This is not the most efficient thing possible; since slices\n         // are two words it'd be better if this were compiled in\n         // 'dest' mode, but I can't find a nice way to structure the\n@@ -250,7 +250,10 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n         let tcx = bcx.tcx();\n         let unit_ty = ty::sequence_element_type(tcx, datum.ty);\n-        let (base, len) = datum.get_base_and_len(bcx);\n+\n+        // FIXME(#6272) need to distinguish \"auto-slice\" from explicit index?\n+        let (bcx, base, len) =\n+            datum.get_vec_base_and_len(bcx, expr.span, expr.id);\n \n         // this type may have a different region/mutability than the\n         // real one, but it will have the same runtime representation\n@@ -273,7 +276,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n         let tcx = bcx.tcx();\n         let closure_ty = expr_ty_adjusted(bcx, expr);\n-        debug!(\"add_env(closure_ty=%s)\", ty_to_str(tcx, closure_ty));\n+        debug!(\"add_env(closure_ty=%s)\", closure_ty.repr(tcx));\n         let scratch = scratch_datum(bcx, closure_ty, false);\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n         assert!(datum.appropriate_mode() == ByValue);\n@@ -283,8 +286,10 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n-    fn auto_slice_and_ref(bcx: block, datum: Datum) -> DatumBlock {\n-        let DatumBlock { bcx, datum } = auto_slice(bcx, datum);\n+    fn auto_slice_and_ref(bcx: block,\n+                          expr: @ast::expr,\n+                          datum: Datum) -> DatumBlock {\n+        let DatumBlock { bcx, datum } = auto_slice(bcx, expr, datum);\n         auto_ref(bcx, datum)\n     }\n }\n@@ -562,7 +567,6 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n \n fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n                                dest: Dest) -> block {\n-    let mut bcx = bcx;\n     let _icx = bcx.insn_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let tcx = bcx.tcx();\n \n@@ -612,7 +616,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             let sigil = ty::ty_closure_sigil(expr_ty);\n             debug!(\"translating fn_block %s with type %s\",\n                    expr_to_str(expr, tcx.sess.intr()),\n-                   ty_to_str(tcx, expr_ty));\n+                   expr_ty.repr(tcx));\n             return closure::trans_expr_fn(bcx, sigil, decl, body,\n                                           expr.id, expr.id,\n                                           None, dest);\n@@ -820,67 +824,35 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n     trace_span!(bcx, expr.span, @shorten(bcx.expr_to_str(expr)));\n \n-    let unrooted_datum = unpack_datum!(bcx, unrooted(bcx, expr));\n-\n-    // If the lvalue must remain rooted, create a scratch datum, copy\n-    // the lvalue in there, and then arrange for it to be cleaned up\n-    // at the end of the scope with id `scope_id`:\n-    let root_key = root_map_key { id: expr.id, derefs: 0u };\n-    for bcx.ccx().maps.root_map.find(&root_key).each |&root_info| {\n-        bcx = unrooted_datum.root(bcx, *root_info);\n-    }\n-\n-    return DatumBlock {bcx: bcx, datum: unrooted_datum};\n-\n-    fn unrooted(bcx: block, expr: @ast::expr) -> DatumBlock {\n-        /*!\n-         *\n-         * Translates `expr`.  Note that this version generally\n-         * yields an unrooted, unmoved version.  Rooting and possible\n-         * moves are dealt with above in trans_lvalue_unadjusted().\n-         *\n-         * One exception is if `expr` refers to a local variable,\n-         * in which case the source may already be FromMovedLvalue\n-         * if appropriate.\n-         */\n-\n-        let mut bcx = bcx;\n-\n-        match expr.node {\n-            ast::expr_paren(e) => {\n-                return unrooted(bcx, e);\n-            }\n-            ast::expr_path(_) => {\n-                return trans_def_lvalue(bcx, expr, bcx.def(expr.id));\n-            }\n-            ast::expr_field(base, ident, _) => {\n-                return trans_rec_field(bcx, base, ident);\n-            }\n-            ast::expr_index(base, idx) => {\n-                return trans_index(bcx, expr, base, idx);\n-            }\n-            ast::expr_unary(ast::deref, base) => {\n-                let basedatum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n-                return basedatum.deref(bcx, base, 0);\n-            }\n-            _ => {\n-                bcx.tcx().sess.span_bug(\n-                    expr.span,\n-                    fmt!(\"trans_lvalue reached fall-through case: %?\",\n-                         expr.node));\n-            }\n+    return match expr.node {\n+        ast::expr_paren(e) => {\n+            trans_lvalue_unadjusted(bcx, e)\n         }\n-    }\n+        ast::expr_path(_) => {\n+            trans_def_lvalue(bcx, expr, bcx.def(expr.id))\n+        }\n+        ast::expr_field(base, ident, _) => {\n+            trans_rec_field(bcx, base, ident)\n+        }\n+        ast::expr_index(base, idx) => {\n+            trans_index(bcx, expr, base, idx)\n+        }\n+        ast::expr_unary(ast::deref, base) => {\n+            let basedatum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n+            basedatum.deref(bcx, expr, 0)\n+        }\n+        _ => {\n+            bcx.tcx().sess.span_bug(\n+                expr.span,\n+                fmt!(\"trans_lvalue reached fall-through case: %?\",\n+                     expr.node));\n+        }\n+    };\n \n     fn trans_rec_field(bcx: block,\n                        base: @ast::expr,\n                        field: ast::ident) -> DatumBlock {\n-        /*!\n-         *\n-         * Translates `base.field`.  Note that this version always\n-         * yields an unrooted, unmoved version.  Rooting and possible\n-         * moves are dealt with above in trans_lvalue_unadjusted().\n-         */\n+        //! Translates `base.field`.\n \n         let mut bcx = bcx;\n         let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n@@ -904,12 +876,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                    index_expr: @ast::expr,\n                    base: @ast::expr,\n                    idx: @ast::expr) -> DatumBlock {\n-        /*!\n-         *\n-         * Translates `base[idx]`.  Note that this version always\n-         * yields an unrooted, unmoved version.  Rooting and possible\n-         * moves are dealt with above in trans_lvalue_unadjusted().\n-         */\n+        //! Translates `base[idx]`.\n \n         let _icx = bcx.insn_ctxt(\"trans_index\");\n         let ccx = bcx.ccx();\n@@ -940,7 +907,8 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         let scaled_ix = Mul(bcx, ix_val, vt.llunit_size);\n         base::maybe_name_value(bcx.ccx(), scaled_ix, ~\"scaled_ix\");\n \n-        let mut (base, len) = base_datum.get_base_and_len(bcx);\n+        let mut (bcx, base, len) =\n+            base_datum.get_vec_base_and_len(bcx, index_expr.span, index_expr.id);\n \n         if ty::type_is_str(base_ty) {\n             // acccount for null terminator in the case of string\n@@ -972,14 +940,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                         def: ast::def)\n         -> DatumBlock\n     {\n-        /*!\n-         *\n-         * Translates a reference to a path.  Note that this version\n-         * generally yields an unrooted, unmoved version.  Rooting and\n-         * possible moves are dealt with above in\n-         * trans_lvalue_unadjusted(), with the caveat that local variables\n-         * may already be in move mode.\n-         */\n+        //! Translates a reference to a path.\n \n         let _icx = bcx.insn_ctxt(\"trans_def_lvalue\");\n         let ccx = bcx.ccx();\n@@ -1087,6 +1048,9 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n                 }\n             };\n \n+            debug!(\"def_self() reference, self_info.t=%s\",\n+                   self_info.t.repr(bcx.tcx()));\n+\n             // This cast should not be necessary. We should cast self *once*,\n             // but right now this conflicts with default methods.\n             let real_self_ty = monomorphize_type(bcx, self_info.t);\n@@ -1150,10 +1114,10 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                     tcx.sess.bug(fmt!(\n                         \"cannot get field types from the enum type %s \\\n                          without a node ID\",\n-                        ty_to_str(tcx, ty)));\n+                        ty.repr(tcx)));\n                 }\n                 Some(node_id) => {\n-                    match *tcx.def_map.get(&node_id) {\n+                    match tcx.def_map.get_copy(&node_id) {\n                         ast::def_variant(enum_id, variant_id) => {\n                             let variant_info = ty::enum_variant_with_id(\n                                 tcx, enum_id, variant_id);\n@@ -1172,7 +1136,7 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n         _ => {\n             tcx.sess.bug(fmt!(\n                 \"cannot get field types from the type %s\",\n-                ty_to_str(tcx, ty)));\n+                ty.repr(tcx)));\n         }\n     }\n }\n@@ -1403,7 +1367,6 @@ fn trans_eager_binop(bcx: block,\n                      lhs_datum: &Datum,\n                      rhs_datum: &Datum)\n                   -> DatumBlock {\n-    let mut bcx = bcx;\n     let _icx = bcx.insn_ctxt(\"trans_eager_binop\");\n \n     let lhs = lhs_datum.to_appropriate_llval(bcx);\n@@ -1573,7 +1536,7 @@ fn trans_overloaded_op(bcx: block,\n                        ret_ty: ty::t,\n                        dest: Dest)\n                        -> block {\n-    let origin = *bcx.ccx().maps.method_map.get(&expr.id);\n+    let origin = bcx.ccx().maps.method_map.get_copy(&expr.id);\n     let fty = node_id_type(bcx, expr.callee_id);\n     callee::trans_call_inner(bcx,\n                              expr.info(),"}, {"sha": "21e29b9ad825963df29f59cc956b442080db2e6e", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -724,7 +724,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n             let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n             if in_type_size != out_type_size {\n-                let sp = match *ccx.tcx.items.get(&ref_id.get()) {\n+                let sp = match ccx.tcx.items.get_copy(&ref_id.get()) {\n                     ast_map::node_expr(e) => e.span,\n                     _ => fail!(~\"transmute has non-expr arg\"),\n                 };"}, {"sha": "e5c6244879d3226b02859137e519b20de2a9b2f6", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 82, "deletions": 77, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -29,96 +29,101 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n     -> ast::def_id {\n     let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n     match ccx.external.find(&fn_id) {\n-      Some(&Some(node_id)) => {\n-        // Already inline\n-        debug!(\"maybe_instantiate_inline(%s): already inline as node id %d\",\n-               ty::item_path_str(ccx.tcx, fn_id), node_id);\n-        local_def(node_id)\n-      }\n-      Some(&None) => fn_id, // Not inlinable\n-      None => { // Not seen yet\n-        match csearch::maybe_get_item_ast(\n+        Some(&Some(node_id)) => {\n+            // Already inline\n+            debug!(\"maybe_instantiate_inline(%s): already inline as node id %d\",\n+                   ty::item_path_str(ccx.tcx, fn_id), node_id);\n+            return local_def(node_id);\n+        }\n+        Some(&None) => {\n+            return fn_id; // Not inlinable\n+        }\n+        None => {\n+            // Not seen yet\n+        }\n+    }\n+\n+    let csearch_result =\n+        csearch::maybe_get_item_ast(\n             ccx.tcx, fn_id,\n             |a,b,c,d| {\n                 astencode::decode_inlined_item(a, b, ccx.maps,\n                                                /*bad*/ copy c, d)\n-            }) {\n-\n-          csearch::not_found => {\n+            });\n+    return match csearch_result {\n+        csearch::not_found => {\n             ccx.external.insert(fn_id, None);\n             fn_id\n-          }\n-          csearch::found(ast::ii_item(item)) => {\n+        }\n+        csearch::found(ast::ii_item(item)) => {\n             ccx.external.insert(fn_id, Some(item.id));\n             ccx.stats.n_inlines += 1;\n             if translate { trans_item(ccx, item); }\n             local_def(item.id)\n-          }\n-          csearch::found(ast::ii_foreign(item)) => {\n-            ccx.external.insert(fn_id, Some(item.id));\n-            local_def(item.id)\n-          }\n-          csearch::found_parent(parent_id, ast::ii_item(item)) => {\n-            ccx.external.insert(parent_id, Some(item.id));\n-            let mut my_id = 0;\n-            match item.node {\n-              ast::item_enum(_, _) => {\n-                let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n-                let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n-                for vec::each2(*vs_here, *vs_there) |here, there| {\n-                    if there.id == fn_id { my_id = here.id.node; }\n-                    ccx.external.insert(there.id, Some(here.id.node));\n-                }\n+        }\n+        csearch::found(ast::ii_foreign(item)) => {\n+          ccx.external.insert(fn_id, Some(item.id));\n+          local_def(item.id)\n+        }\n+        csearch::found_parent(parent_id, ast::ii_item(item)) => {\n+          ccx.external.insert(parent_id, Some(item.id));\n+          let mut my_id = 0;\n+          match item.node {\n+            ast::item_enum(_, _) => {\n+              let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n+              let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n+              for vec::each2(*vs_here, *vs_there) |here, there| {\n+                  if there.id == fn_id { my_id = here.id.node; }\n+                  ccx.external.insert(there.id, Some(here.id.node));\n               }\n-              _ => ccx.sess.bug(~\"maybe_instantiate_inline: item has a \\\n-                    non-enum parent\")\n             }\n-            if translate { trans_item(ccx, item); }\n-            local_def(my_id)\n-          }\n-          csearch::found_parent(_, _) => {\n-              ccx.sess.bug(~\"maybe_get_item_ast returned a found_parent \\\n-               with a non-item parent\");\n+            _ => ccx.sess.bug(~\"maybe_instantiate_inline: item has a \\\n+                  non-enum parent\")\n           }\n-          csearch::found(ast::ii_method(impl_did, mth)) => {\n-            ccx.stats.n_inlines += 1;\n-            ccx.external.insert(fn_id, Some(mth.id));\n-            let impl_tpt = ty::lookup_item_type(ccx.tcx, impl_did);\n-            let num_type_params =\n-                impl_tpt.generics.type_param_defs.len() +\n-                mth.generics.ty_params.len();\n-            if translate && num_type_params == 0 {\n-                let llfn = get_item_val(ccx, mth.id);\n-                let path = vec::append(\n-                    ty::item_path(ccx.tcx, impl_did),\n-                    ~[path_name(mth.ident)]);\n-                let self_kind = match mth.self_ty.node {\n-                    ast::sty_static => no_self,\n-                    _ => {\n-                        let self_ty = ty::node_id_to_type(ccx.tcx,\n-                                                          mth.self_id);\n-                        debug!(\"calling inline trans_fn with self_ty %s\",\n-                               ty_to_str(ccx.tcx, self_ty));\n-                        match mth.self_ty.node {\n-                            ast::sty_value => impl_owned_self(self_ty),\n-                            _ => impl_self(self_ty),\n-                        }\n-                    }\n-                };\n-                trans_fn(ccx,\n-                         path,\n-                         &mth.decl,\n-                         &mth.body,\n-                         llfn,\n-                         self_kind,\n-                         None,\n-                         mth.id,\n-                         Some(impl_did),\n-                         []);\n-            }\n-            local_def(mth.id)\n+          if translate { trans_item(ccx, item); }\n+          local_def(my_id)\n+        }\n+        csearch::found_parent(_, _) => {\n+            ccx.sess.bug(~\"maybe_get_item_ast returned a found_parent \\\n+             with a non-item parent\");\n+        }\n+        csearch::found(ast::ii_method(impl_did, mth)) => {\n+          ccx.stats.n_inlines += 1;\n+          ccx.external.insert(fn_id, Some(mth.id));\n+          let impl_tpt = ty::lookup_item_type(ccx.tcx, impl_did);\n+          let num_type_params =\n+              impl_tpt.generics.type_param_defs.len() +\n+              mth.generics.ty_params.len();\n+          if translate && num_type_params == 0 {\n+              let llfn = get_item_val(ccx, mth.id);\n+              let path = vec::append(\n+                  ty::item_path(ccx.tcx, impl_did),\n+                  ~[path_name(mth.ident)]);\n+              let self_kind = match mth.self_ty.node {\n+                  ast::sty_static => no_self,\n+                  _ => {\n+                      let self_ty = ty::node_id_to_type(ccx.tcx,\n+                                                        mth.self_id);\n+                      debug!(\"calling inline trans_fn with self_ty %s\",\n+                             ty_to_str(ccx.tcx, self_ty));\n+                      match mth.self_ty.node {\n+                          ast::sty_value => impl_owned_self(self_ty),\n+                          _ => impl_self(self_ty),\n+                      }\n+                  }\n+              };\n+              trans_fn(ccx,\n+                       path,\n+                       &mth.decl,\n+                       &mth.body,\n+                       llfn,\n+                       self_kind,\n+                       None,\n+                       mth.id,\n+                       Some(impl_did),\n+                       []);\n           }\n+          local_def(mth.id)\n         }\n-      }\n-    }\n+    };\n }"}, {"sha": "ff9faa24376d902700bcab599598d0451203ec59", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -118,7 +118,7 @@ pub fn llalign_of(cx: @CrateContext, t: TypeRef) -> ValueRef {\n // Computes the size of the data part of an enum.\n pub fn static_size_of_enum(cx: @CrateContext, t: ty::t) -> uint {\n     if cx.enum_sizes.contains_key(&t) {\n-        return *cx.enum_sizes.get(&t);\n+        return cx.enum_sizes.get_copy(&t);\n     }\n \n     debug!(\"static_size_of_enum %s\", ty_to_str(cx.tcx, t));"}, {"sha": "934a995b588419706e880453941e74c4f3df420c", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -44,6 +44,11 @@ pub fn trans_impl(ccx: @CrateContext, path: path, name: ast::ident,\n                   methods: &[@ast::method], generics: &ast::Generics,\n                   self_ty: Option<ty::t>, id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n+    let tcx = ccx.tcx;\n+\n+    debug!(\"trans_impl(path=%s, name=%s, self_ty=%s, id=%?)\",\n+           path.repr(tcx), name.repr(tcx), self_ty.repr(tcx), id);\n+\n     if !generics.ty_params.is_empty() { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n     for vec::each(methods) |method| {\n@@ -307,7 +312,7 @@ pub fn trans_static_method_callee(bcx: block,\n     };\n \n     let mname = if method_id.crate == ast::local_crate {\n-        match *bcx.tcx().items.get(&method_id.node) {\n+        match bcx.tcx().items.get_copy(&method_id.node) {\n             ast_map::node_trait_method(trait_method, _, _) => {\n                 ast_util::trait_method_to_ty_method(trait_method).ident\n             }\n@@ -324,7 +329,7 @@ pub fn trans_static_method_callee(bcx: block,\n             name=%s\", method_id, callee_id, *ccx.sess.str_of(mname));\n \n     let vtbls = resolve_vtables_in_fn_ctxt(\n-        bcx.fcx, *ccx.maps.vtable_map.get(&callee_id));\n+        bcx.fcx, ccx.maps.vtable_map.get_copy(&callee_id));\n \n     match vtbls[bound_index] {\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n@@ -362,7 +367,7 @@ pub fn method_from_methods(ms: &[@ast::method], name: ast::ident)\n pub fn method_with_name(ccx: @CrateContext, impl_id: ast::def_id,\n                         name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n-        match *ccx.tcx.items.get(&impl_id.node) {\n+        match ccx.tcx.items.get_copy(&impl_id.node) {\n           ast_map::node_item(@ast::item {\n                 node: ast::item_impl(_, _, _, ref ms),\n                 _\n@@ -380,7 +385,7 @@ pub fn method_with_name_or_default(ccx: @CrateContext,\n                                    impl_id: ast::def_id,\n                                    name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n-        match *ccx.tcx.items.get(&impl_id.node) {\n+        match ccx.tcx.items.get_copy(&impl_id.node) {\n           ast_map::node_item(@ast::item {\n                 node: ast::item_impl(_, _, _, ref ms), _\n           }, _) => {"}, {"sha": "6e25064186941a5b13219b0691f451330ec09964", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -100,12 +100,14 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n     let llitem_ty = tpt.ty;\n \n-    let map_node = session::expect(ccx.sess, ccx.tcx.items.find(&fn_id.node),\n-     || fmt!(\"While monomorphizing %?, couldn't find it in the item map \\\n-        (may have attempted to monomorphize an item defined in a different \\\n-        crate?)\", fn_id));\n+    let map_node = session::expect(\n+        ccx.sess,\n+        ccx.tcx.items.find_copy(&fn_id.node),\n+        || fmt!(\"While monomorphizing %?, couldn't find it in the item map \\\n+                 (may have attempted to monomorphize an item \\\n+                 defined in a different crate?)\", fn_id));\n     // Get the path so that we can create a symbol\n-    let (pt, name, span) = match *map_node {\n+    let (pt, name, span) = match map_node {\n       ast_map::node_item(i, pt) => (pt, i.ident, i.span),\n       ast_map::node_variant(ref v, enm, pt) => (pt, (*v).node.name, enm.span),\n       ast_map::node_method(m, _, pt) => (pt, m.ident, m.span),\n@@ -134,6 +136,9 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n       ast_map::node_local(*) => {\n           ccx.tcx.sess.bug(~\"Can't monomorphize a local\")\n       }\n+      ast_map::node_callee_scope(*) => {\n+          ccx.tcx.sess.bug(~\"Can't monomorphize a callee-scope\")\n+      }\n       ast_map::node_struct_ctor(_, i, pt) => (pt, i.ident, i.span)\n     };\n \n@@ -182,7 +187,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         self_ty: impl_ty_opt\n     });\n \n-    let lldecl = match *map_node {\n+    let lldecl = match map_node {\n       ast_map::node_item(i@@ast::item {\n                 node: ast::item_fn(ref decl, _, _, _, ref body),\n                 _\n@@ -266,6 +271,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n       ast_map::node_trait_method(*) |\n       ast_map::node_arg(*) |\n       ast_map::node_block(*) |\n+      ast_map::node_callee_scope(*) |\n       ast_map::node_local(*) => {\n         ccx.tcx.sess.bug(fmt!(\"Can't monomorphize a %?\", map_node))\n       }"}, {"sha": "9bbf50397c35a31b6c3dd8aa5224b926726068cd", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -42,19 +42,19 @@ pub fn find_reachable(crate_mod: &_mod, exp_map2: resolve::ExportMap2,\n                       tcx: ty::ctxt, method_map: typeck::method_map) -> map {\n     let mut rmap = HashSet::new();\n     {\n-        let cx = ctx {\n+        let cx = @mut ctx {\n             exp_map2: exp_map2,\n             tcx: tcx,\n             method_map: method_map,\n             rmap: &mut rmap\n         };\n-        traverse_public_mod(&cx, ast::crate_node_id, crate_mod);\n-        traverse_all_resources_and_impls(&cx, crate_mod);\n+        traverse_public_mod(cx, ast::crate_node_id, crate_mod);\n+        traverse_all_resources_and_impls(cx, crate_mod);\n     }\n     return @rmap;\n }\n \n-fn traverse_exports(cx: &ctx, mod_id: node_id) -> bool {\n+fn traverse_exports(cx: @mut ctx, mod_id: node_id) -> bool {\n     let mut found_export = false;\n     match cx.exp_map2.find(&mod_id) {\n       Some(ref exp2s) => {\n@@ -68,23 +68,25 @@ fn traverse_exports(cx: &ctx, mod_id: node_id) -> bool {\n     return found_export;\n }\n \n-fn traverse_def_id(cx: &ctx, did: def_id) {\n+fn traverse_def_id(cx: @mut ctx, did: def_id) {\n     if did.crate != local_crate { return; }\n     match cx.tcx.items.find(&did.node) {\n         None => (), // This can happen for self, for example\n         Some(&ast_map::node_item(item, _)) => traverse_public_item(cx, item),\n         Some(&ast_map::node_method(_, impl_id, _)) => traverse_def_id(cx, impl_id),\n         Some(&ast_map::node_foreign_item(item, _, _, _)) => {\n+            let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n             cx.rmap.insert(item.id);\n         }\n         Some(&ast_map::node_variant(ref v, _, _)) => {\n+            let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n             cx.rmap.insert(v.node.id);\n         }\n         _ => ()\n     }\n }\n \n-fn traverse_public_mod(cx: &ctx, mod_id: node_id, m: &_mod) {\n+fn traverse_public_mod(cx: @mut ctx, mod_id: node_id, m: &_mod) {\n     if !traverse_exports(cx, mod_id) {\n         // No exports, so every local item is exported\n         for m.items.each |item| {\n@@ -93,16 +95,21 @@ fn traverse_public_mod(cx: &ctx, mod_id: node_id, m: &_mod) {\n     }\n }\n \n-fn traverse_public_item(cx: &ctx, item: @item) {\n-    // FIXME #6021: naming rmap shouldn't be necessary\n-    let rmap: &mut HashSet<node_id> = cx.rmap;\n-    if rmap.contains(&item.id) { return; }\n-    rmap.insert(item.id);\n+fn traverse_public_item(cx: @mut ctx, item: @item) {\n+    {\n+        // FIXME #6021: naming rmap shouldn't be necessary\n+        let cx = &mut *cx;\n+        let rmap: &mut HashSet<node_id> = cx.rmap;\n+        if rmap.contains(&item.id) { return; }\n+        rmap.insert(item.id);\n+    }\n+\n     match item.node {\n       item_mod(ref m) => traverse_public_mod(cx, item.id, m),\n       item_foreign_mod(ref nm) => {\n           if !traverse_exports(cx, item.id) {\n               for nm.items.each |item| {\n+                  let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n                   cx.rmap.insert(item.id);\n               }\n           }\n@@ -119,13 +126,17 @@ fn traverse_public_item(cx: &ctx, item: @item) {\n                 m.generics.ty_params.len() > 0u ||\n                 attr::find_inline_attr(m.attrs) != attr::ia_none\n             {\n-                cx.rmap.insert(m.id);\n+                {\n+                    let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n+                    cx.rmap.insert(m.id);\n+                }\n                 traverse_inline_body(cx, &m.body);\n             }\n         }\n       }\n       item_struct(ref struct_def, _) => {\n         for struct_def.ctor_id.each |&ctor_id| {\n+            let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n             cx.rmap.insert(ctor_id);\n         }\n       }\n@@ -140,11 +151,12 @@ fn traverse_public_item(cx: &ctx, item: @item) {\n     }\n }\n \n-fn traverse_ty<'a, 'b>(ty: @Ty, cx: &'b ctx<'a>, v: visit::vt<&'b ctx<'a>>) {\n-    // FIXME #6021: naming rmap shouldn't be necessary\n-    let rmap: &mut HashSet<node_id> = cx.rmap;\n-    if rmap.contains(&ty.id) { return; }\n-    rmap.insert(ty.id);\n+fn traverse_ty<'a>(ty: @Ty, cx: @mut ctx<'a>, v: visit::vt<@mut ctx<'a>>) {\n+    {\n+        let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n+        if cx.rmap.contains(&ty.id) { return; }\n+        cx.rmap.insert(ty.id);\n+    }\n \n     match ty.node {\n       ty_path(p, p_id) => {\n@@ -163,9 +175,9 @@ fn traverse_ty<'a, 'b>(ty: @Ty, cx: &'b ctx<'a>, v: visit::vt<&'b ctx<'a>>) {\n     }\n }\n \n-fn traverse_inline_body(cx: &ctx, body: &blk) {\n-    fn traverse_expr<'a, 'b>(e: @expr, cx: &'b ctx<'a>,\n-                             v: visit::vt<&'b ctx<'a>>) {\n+fn traverse_inline_body(cx: @mut ctx, body: &blk) {\n+    fn traverse_expr<'a>(e: @expr, cx: @mut ctx<'a>,\n+                         v: visit::vt<@mut ctx<'a>>) {\n         match e.node {\n           expr_path(_) => {\n             match cx.tcx.def_map.find(&e.id) {\n@@ -212,7 +224,7 @@ fn traverse_inline_body(cx: &ctx, body: &blk) {\n     // Don't ignore nested items: for example if a generic fn contains a\n     // generic impl (as in deque::create), we need to monomorphize the\n     // impl as well\n-    fn traverse_item(i: @item, cx: &ctx, _v: visit::vt<&ctx>) {\n+    fn traverse_item(i: @item, cx: @mut ctx, _v: visit::vt<@mut ctx>) {\n       traverse_public_item(cx, i);\n     }\n     visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n@@ -222,7 +234,7 @@ fn traverse_inline_body(cx: &ctx, body: &blk) {\n     }));\n }\n \n-fn traverse_all_resources_and_impls(cx: &ctx, crate_mod: &_mod) {\n+fn traverse_all_resources_and_impls(cx: @mut ctx, crate_mod: &_mod) {\n     visit::visit_mod(\n         crate_mod,\n         codemap::dummy_sp(),"}, {"sha": "9e1f10467e34652d09cf26fc08a5137dd132b72d", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -274,8 +274,9 @@ pub impl Reflector {\n             let repr = adt::represent_type(bcx.ccx(), t);\n             let variants = ty::substd_enum_variants(ccx.tcx, did, substs);\n             let llptrty = T_ptr(type_of(ccx, t));\n-            let (_, opaquety) = *(ccx.tcx.intrinsic_defs.find(&ccx.sess.ident_of(~\"Opaque\"))\n-                                      .expect(\"Failed to resolve intrinsic::Opaque\"));\n+            let (_, opaquety) =\n+                ccx.tcx.intrinsic_defs.find_copy(&ccx.sess.ident_of(~\"Opaque\"))\n+                .expect(\"Failed to resolve intrinsic::Opaque\");\n             let opaqueptrty = ty::mk_ptr(ccx.tcx, ty::mt { ty: opaquety, mutbl: ast::m_imm });\n \n             let make_get_disr = || {\n@@ -374,7 +375,7 @@ pub fn emit_calls_to_trait_visit_ty(bcx: block,\n     use syntax::parse::token::special_idents::tydesc;\n     let final = sub_block(bcx, ~\"final\");\n     assert!(bcx.ccx().tcx.intrinsic_defs.contains_key(&tydesc));\n-    let (_, tydesc_ty) = *bcx.ccx().tcx.intrinsic_defs.get(&tydesc);\n+    let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get_copy(&tydesc);\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);\n     let mut r = Reflector {\n         visitor_val: visitor_val,"}, {"sha": "fc27c11c06f24698ba8b30a982829cc11c1366a1", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -110,8 +110,7 @@ pub fn type_of_non_gc_box(cx: @CrateContext, t: ty::t) -> TypeRef {\n \n pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n     match cx.llsizingtypes.find(&t) {\n-        // FIXME(#5562): removing this copy causes a segfault in stage1 core\n-        Some(t) => return /*bad*/ copy *t,\n+        Some(t) => return *t,\n         None => ()\n     }\n \n@@ -178,8 +177,7 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n \n     // Check the cache.\n     match cx.lltypes.find(&t) {\n-        // FIXME(#5562): removing this copy causes a segfault in stage1 core\n-        Some(t) => return /*bad*/ copy *t,\n+        Some(&t) => return t,\n         None => ()\n     }\n "}, {"sha": "94ef33e45bbe9d6df3efc67a69395b3b74e7e0ca", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -236,18 +236,11 @@ pub fn node_type_needs(cx: Context, use_: uint, id: node_id) {\n }\n \n pub fn mark_for_method_call(cx: Context, e_id: node_id, callee_id: node_id) {\n+    let mut opt_static_did = None;\n     for cx.ccx.maps.method_map.find(&e_id).each |mth| {\n         match mth.origin {\n           typeck::method_static(did) => {\n-            for cx.ccx.tcx.node_type_substs.find(&callee_id).each |ts| {\n-                // FIXME(#5562): removing this copy causes a segfault\n-                //               before stage2\n-                let ts = /*bad*/ copy **ts;\n-                let type_uses = type_uses_for(cx.ccx, did, ts.len());\n-                for vec::each2(*type_uses, ts) |uses, subst| {\n-                    type_needs(cx, *uses, *subst)\n-                }\n-            }\n+              opt_static_did = Some(did);\n           }\n           typeck::method_param(typeck::method_param {\n               param_num: param,\n@@ -259,6 +252,19 @@ pub fn mark_for_method_call(cx: Context, e_id: node_id, callee_id: node_id) {\n               | typeck::method_super(*) => (),\n         }\n     }\n+\n+    // Note: we do not execute this code from within the each() call\n+    // above because the recursive call to `type_needs` can trigger\n+    // inlining and hence can cause `method_map` and\n+    // `node_type_substs` to be modified.\n+    for opt_static_did.each |&did| {\n+        for cx.ccx.tcx.node_type_substs.find_copy(&callee_id).each |ts| {\n+            let type_uses = type_uses_for(cx.ccx, did, ts.len());\n+            for vec::each2(*type_uses, *ts) |uses, subst| {\n+                type_needs(cx, *uses, *subst)\n+            }\n+        }\n+    }\n }\n \n pub fn mark_for_expr(cx: Context, e: @expr) {\n@@ -288,12 +294,11 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n         }\n       }\n       expr_path(_) => {\n-        for cx.ccx.tcx.node_type_substs.find(&e.id).each |ts| {\n-            // FIXME(#5562): removing this copy causes a segfault before stage2\n-            let ts = copy **ts;\n-            let id = ast_util::def_id_of_def(*cx.ccx.tcx.def_map.get(&e.id));\n+        let opt_ts = cx.ccx.tcx.node_type_substs.find_copy(&e.id);\n+        for opt_ts.each |ts| {\n+            let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get_copy(&e.id));\n             let uses_for_ts = type_uses_for(cx.ccx, id, ts.len());\n-            for vec::each2(*uses_for_ts, ts) |uses, subst| {\n+            for vec::each2(*uses_for_ts, *ts) |uses, subst| {\n                 type_needs(cx, *uses, *subst)\n             }\n         }"}, {"sha": "18f21b489b0b80ac7e437d546071e11879d02d24", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -0,0 +1,201 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Logic relating to rooting and write guards for managed values\n+//! (`@` and `@mut`). This code is primarily for use by datum;\n+//! it exists in its own module both to keep datum.rs bite-sized\n+//! and for each in debugging (e.g., so you can use\n+//! `RUST_LOG=rustc::middle::trans::write_guard`).\n+\n+use lib::llvm::ValueRef;\n+use middle::borrowck::{RootInfo, root_map_key, DynaImm, DynaMut};\n+use middle::trans::base::*;\n+use middle::trans::build::*;\n+use middle::trans::callee;\n+use middle::trans::common::*;\n+use middle::trans::datum::*;\n+use middle::trans::expr;\n+use middle::ty;\n+use driver::session;\n+use syntax::codemap::span;\n+use syntax::ast;\n+\n+pub fn root_and_write_guard(datum: &Datum,\n+                            mut bcx: block,\n+                            span: span,\n+                            expr_id: ast::node_id,\n+                            derefs: uint) -> block {\n+    let key = root_map_key { id: expr_id, derefs: derefs };\n+    debug!(\"write_guard::root_and_write_guard(key=%?)\", key);\n+\n+    // root the autoderef'd value, if necessary:\n+    //\n+    // (Note: root'd values are always boxes)\n+    let ccx = bcx.ccx();\n+    bcx = match ccx.maps.root_map.find(&key) {\n+        None => bcx,\n+        Some(&root_info) => root(datum, bcx, span, key, root_info)\n+    };\n+\n+    // Perform the write guard, if necessary.\n+    //\n+    // (Note: write-guarded values are always boxes)\n+    if ccx.maps.write_guard_map.contains(&key) {\n+        perform_write_guard(datum, bcx, span)\n+    } else {\n+        bcx\n+    }\n+}\n+\n+pub fn return_to_mut(mut bcx: block,\n+                     root_key: root_map_key,\n+                     frozen_val_ref: ValueRef,\n+                     bits_val_ref: ValueRef,\n+                     filename_val: ValueRef,\n+                     line_val: ValueRef) -> block {\n+    debug!(\"write_guard::return_to_mut(root_key=%?, %s, %s, %s)\",\n+           root_key,\n+           bcx.to_str(),\n+           val_str(bcx.ccx().tn, frozen_val_ref),\n+           val_str(bcx.ccx().tn, bits_val_ref));\n+\n+    let box_ptr =\n+        Load(bcx, PointerCast(bcx,\n+                              frozen_val_ref,\n+                              T_ptr(T_ptr(T_i8()))));\n+\n+    let bits_val =\n+        Load(bcx, bits_val_ref);\n+\n+    if bcx.tcx().sess.opts.optimize == session::No {\n+        bcx = callee::trans_lang_call(\n+            bcx,\n+            bcx.tcx().lang_items.unrecord_borrow_fn(),\n+            ~[\n+                box_ptr,\n+                bits_val,\n+                filename_val,\n+                line_val\n+            ],\n+            expr::Ignore);\n+    }\n+\n+    callee::trans_lang_call(\n+        bcx,\n+        bcx.tcx().lang_items.return_to_mut_fn(),\n+        ~[\n+            box_ptr,\n+            bits_val,\n+            filename_val,\n+            line_val\n+        ],\n+        expr::Ignore\n+    )\n+}\n+\n+fn root(datum: &Datum,\n+        mut bcx: block,\n+        span: span,\n+        root_key: root_map_key,\n+        root_info: RootInfo) -> block {\n+    //! In some cases, borrowck will decide that an @T/@[]/@str\n+    //! value must be rooted for the program to be safe.  In that\n+    //! case, we will call this function, which will stash a copy\n+    //! away until we exit the scope `scope_id`.\n+\n+    debug!(\"write_guard::root(root_key=%?, root_info=%?, datum=%?)\",\n+           root_key, root_info, datum.to_str(bcx.ccx()));\n+\n+    if bcx.sess().trace() {\n+        trans_trace(\n+            bcx, None,\n+            @fmt!(\"preserving until end of scope %d\",\n+                  root_info.scope));\n+    }\n+\n+    // First, root the datum. Note that we must zero this value,\n+    // because sometimes we root on one path but not another.\n+    // See e.g. #4904.\n+    let scratch = scratch_datum(bcx, datum.ty, true);\n+    datum.copy_to_datum(bcx, INIT, scratch);\n+    let cleanup_bcx = find_bcx_for_scope(bcx, root_info.scope);\n+    add_clean_temp_mem(cleanup_bcx, scratch.val, scratch.ty);\n+\n+    // Now, consider also freezing it.\n+    match root_info.freeze {\n+        None => {}\n+        Some(freeze_kind) => {\n+            let (filename, line) = filename_and_line_num_from_span(bcx, span);\n+\n+            // in this case, we don't have to zero, because\n+            // scratch.val will be NULL should the cleanup get\n+            // called without the freezing actually occurring, and\n+            // return_to_mut checks for this condition.\n+            let scratch_bits = scratch_datum(bcx, ty::mk_uint(), false);\n+\n+            let freeze_did = match freeze_kind {\n+                DynaImm => bcx.tcx().lang_items.borrow_as_imm_fn(),\n+                DynaMut => bcx.tcx().lang_items.borrow_as_mut_fn(),\n+            };\n+\n+            let box_ptr = Load(bcx,\n+                               PointerCast(bcx,\n+                                           scratch.val,\n+                                           T_ptr(T_ptr(T_i8()))));\n+\n+            bcx = callee::trans_lang_call(\n+                bcx,\n+                freeze_did,\n+                ~[\n+                    box_ptr,\n+                    filename,\n+                    line\n+                ],\n+                expr::SaveIn(scratch_bits.val));\n+\n+            if bcx.tcx().sess.opts.optimize == session::No {\n+                bcx = callee::trans_lang_call(\n+                    bcx,\n+                    bcx.tcx().lang_items.record_borrow_fn(),\n+                    ~[\n+                        box_ptr,\n+                        Load(bcx, scratch_bits.val),\n+                        filename,\n+                        line\n+                    ],\n+                    expr::Ignore);\n+            }\n+\n+            add_clean_return_to_mut(\n+                cleanup_bcx, root_key, scratch.val, scratch_bits.val,\n+                filename, line);\n+        }\n+    }\n+\n+    bcx\n+}\n+\n+fn perform_write_guard(datum: &Datum,\n+                       bcx: block,\n+                       span: span) -> block {\n+    debug!(\"perform_write_guard\");\n+\n+    let llval = datum.to_value_llval(bcx);\n+    let (filename, line) = filename_and_line_num_from_span(bcx, span);\n+\n+    callee::trans_lang_call(\n+        bcx,\n+        bcx.tcx().lang_items.check_not_borrowed_fn(),\n+        ~[PointerCast(bcx, llval, T_ptr(T_i8())),\n+          filename,\n+          line],\n+        expr::Ignore)\n+}\n+"}, {"sha": "d3875bad13a7bf7c9b7a289510f3e42204ed1079", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 73, "deletions": 40, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -183,26 +183,21 @@ pub struct AutoDerefRef {\n \n #[auto_encode]\n #[auto_decode]\n-pub struct AutoRef {\n-    kind: AutoRefKind,\n-    region: Region,\n-    mutbl: ast::mutability\n-}\n-\n-#[auto_encode]\n-#[auto_decode]\n-pub enum AutoRefKind {\n+pub enum AutoRef {\n     /// Convert from T to &T\n-    AutoPtr,\n+    AutoPtr(Region, ast::mutability),\n \n     /// Convert from @[]/~[]/&[] to &[] (or str)\n-    AutoBorrowVec,\n+    AutoBorrowVec(Region, ast::mutability),\n \n     /// Convert from @[]/~[]/&[] to &&[] (or str)\n-    AutoBorrowVecRef,\n+    AutoBorrowVecRef(Region, ast::mutability),\n \n     /// Convert from @fn()/~fn()/&fn() to &fn()\n-    AutoBorrowFn\n+    AutoBorrowFn(Region),\n+\n+    /// Convert from T to *T\n+    AutoUnsafe(ast::mutability)\n }\n \n // Stores information about provided methods (a.k.a. default methods) in\n@@ -432,11 +427,20 @@ pub enum Region {\n     /// A concrete region naming some expression within the current function.\n     re_scope(node_id),\n \n-    /// Static data that has an \"infinite\" lifetime.\n+    /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n     re_static,\n \n     /// A region variable.  Should not exist after typeck.\n-    re_infer(InferRegion)\n+    re_infer(InferRegion),\n+\n+    /// Empty lifetime is for data that is never accessed.\n+    /// Bottom in the region lattice. We treat re_empty somewhat\n+    /// specially; at least right now, we do not generate instances of\n+    /// it during the GLB computations, but rather\n+    /// generate an error instead. This is to improve error messages.\n+    /// The only way to get an instance of re_empty is to have a region\n+    /// variable with no constraints.\n+    re_empty,\n }\n \n pub impl Region {\n@@ -1539,6 +1543,13 @@ pub fn type_is_ty_var(ty: t) -> bool {\n \n pub fn type_is_bool(ty: t) -> bool { get(ty).sty == ty_bool }\n \n+pub fn type_is_self(ty: t) -> bool {\n+    match get(ty).sty {\n+        ty_self(*) => true,\n+        _ => false\n+    }\n+}\n+\n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n       ty_struct(*) | ty_tup(_) | ty_enum(*) | ty_closure(_) | ty_trait(*) |\n@@ -1939,7 +1950,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n \n         let _i = indenter();\n \n-        let mut result = match get(ty).sty {\n+        let result = match get(ty).sty {\n             // Scalar and unique types are sendable, constant, and owned\n             ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n             ty_bare_fn(_) | ty_ptr(_) => {\n@@ -2789,6 +2800,17 @@ pub fn ty_region(tcx: ctxt,\n     }\n }\n \n+pub fn replace_fn_sig(cx: ctxt, fsty: &sty, new_sig: FnSig) -> t {\n+    match *fsty {\n+        ty_bare_fn(ref f) => mk_bare_fn(cx, BareFnTy {sig: new_sig, ..*f}),\n+        ty_closure(ref f) => mk_closure(cx, ClosureTy {sig: new_sig, ..*f}),\n+        ref s => {\n+            cx.sess.bug(\n+                fmt!(\"ty_fn_sig() called on non-fn type: %?\", s));\n+        }\n+    }\n+}\n+\n pub fn replace_closure_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n     /*!\n      *\n@@ -2908,26 +2930,26 @@ pub fn adjust_ty(cx: ctxt,\n             match adj.autoref {\n                 None => adjusted_ty,\n                 Some(ref autoref) => {\n-                    match autoref.kind {\n-                        AutoPtr => {\n-                            mk_rptr(cx, autoref.region,\n-                                    mt {ty: adjusted_ty,\n-                                        mutbl: autoref.mutbl})\n+                    match *autoref {\n+                        AutoPtr(r, m) => {\n+                            mk_rptr(cx, r, mt {ty: adjusted_ty, mutbl: m})\n+                        }\n+\n+                        AutoBorrowVec(r, m) => {\n+                            borrow_vec(cx, span, r, m, adjusted_ty)\n                         }\n \n-                        AutoBorrowVec => {\n-                            borrow_vec(cx, span, autoref, adjusted_ty)\n+                        AutoBorrowVecRef(r, m) => {\n+                            adjusted_ty = borrow_vec(cx, span, r, m, adjusted_ty);\n+                            mk_rptr(cx, r, mt {ty: adjusted_ty, mutbl: ast::m_imm})\n                         }\n \n-                        AutoBorrowVecRef => {\n-                            adjusted_ty = borrow_vec(cx, span, autoref,\n-                                                     adjusted_ty);\n-                            mk_rptr(cx, autoref.region,\n-                                    mt {ty: adjusted_ty, mutbl: ast::m_imm})\n+                        AutoBorrowFn(r) => {\n+                            borrow_fn(cx, span, r, adjusted_ty)\n                         }\n \n-                        AutoBorrowFn => {\n-                            borrow_fn(cx, span, autoref, adjusted_ty)\n+                        AutoUnsafe(m) => {\n+                            mk_ptr(cx, mt {ty: adjusted_ty, mutbl: m})\n                         }\n                     }\n                 }\n@@ -2936,15 +2958,15 @@ pub fn adjust_ty(cx: ctxt,\n     };\n \n     fn borrow_vec(cx: ctxt, span: span,\n-                  autoref: &AutoRef, ty: ty::t) -> ty::t {\n+                  r: Region, m: ast::mutability,\n+                  ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_evec(mt, _) => {\n-                ty::mk_evec(cx, mt {ty: mt.ty, mutbl: autoref.mutbl},\n-                            vstore_slice(autoref.region))\n+                ty::mk_evec(cx, mt {ty: mt.ty, mutbl: m}, vstore_slice(r))\n             }\n \n             ty_estr(_) => {\n-                ty::mk_estr(cx, vstore_slice(autoref.region))\n+                ty::mk_estr(cx, vstore_slice(r))\n             }\n \n             ref s => {\n@@ -2956,13 +2978,12 @@ pub fn adjust_ty(cx: ctxt,\n         }\n     }\n \n-    fn borrow_fn(cx: ctxt, span: span,\n-                 autoref: &AutoRef, ty: ty::t) -> ty::t {\n+    fn borrow_fn(cx: ctxt, span: span, r: Region, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_closure(ref fty) => {\n                 ty::mk_closure(cx, ClosureTy {\n                     sigil: BorrowedSigil,\n-                    region: autoref.region,\n+                    region: r,\n                     ..copy *fty\n                 })\n             }\n@@ -2977,6 +2998,18 @@ pub fn adjust_ty(cx: ctxt,\n     }\n }\n \n+pub impl AutoRef {\n+    fn map_region(&self, f: &fn(Region) -> Region) -> AutoRef {\n+        match *self {\n+            ty::AutoPtr(r, m) => ty::AutoPtr(f(r), m),\n+            ty::AutoBorrowVec(r, m) => ty::AutoBorrowVec(f(r), m),\n+            ty::AutoBorrowVecRef(r, m) => ty::AutoBorrowVecRef(f(r), m),\n+            ty::AutoBorrowFn(r) => ty::AutoBorrowFn(f(r)),\n+            ty::AutoUnsafe(m) => ty::AutoUnsafe(m),\n+        }\n+    }\n+}\n+\n pub struct ParamsTy {\n     params: ~[t],\n     ty: t\n@@ -3749,7 +3782,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n           call eval_const_expr, it should never get called twice for the same\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n-        match *cx.items.get(&id.node) {\n+        match cx.items.get_copy(&id.node) {\n           ast_map::node_item(@ast::item {\n                     node: ast::item_enum(ref enum_definition, _),\n                     _\n@@ -3875,7 +3908,7 @@ pub fn lookup_field_type(tcx: ctxt,\n     }\n     else {\n         match tcx.tcache.find(&id) {\n-           Some(tpt) => tpt.ty,\n+           Some(&ty_param_bounds_and_ty {ty, _}) => ty,\n            None => {\n                let tpt = csearch::get_field_type(tcx, struct_id, id);\n                tcx.tcache.insert(id, tpt);\n@@ -4280,7 +4313,7 @@ pub fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n pub fn visitor_object_ty(tcx: ctxt) -> (@TraitRef, t) {\n     let ty_visitor_name = special_idents::ty_visitor;\n     assert!(tcx.intrinsic_traits.contains_key(&ty_visitor_name));\n-    let trait_ref = *tcx.intrinsic_traits.get(&ty_visitor_name);\n+    let trait_ref = tcx.intrinsic_traits.get_copy(&ty_visitor_name);\n     (trait_ref,\n      mk_trait(tcx, trait_ref.def_id, copy trait_ref.substs, BoxTraitStore, ast::m_imm))\n }"}, {"sha": "40c5df7b7683229b00474670040a7b53e330c6e8", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -118,8 +118,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n                 Some((enm, var)) => {\n                     // Assign the pattern the type of the *enum*, not the variant.\n                     let enum_tpt = ty::lookup_item_type(tcx, enm);\n-                    instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id,\n-                                     pcx.block_region);\n+                    instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id);\n \n                     // check that the type of the value being matched is a subtype\n                     // of the type of the pattern:\n@@ -175,8 +174,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n             } else {\n                 ctor_tpt\n             };\n-            instantiate_path(pcx.fcx, path, struct_tpt, pat.span, pat.id,\n-                             pcx.block_region);\n+            instantiate_path(pcx.fcx, path, struct_tpt, pat.span, pat.id);\n \n             // Check that the type of the value being matched is a subtype of\n             // the type of the pattern.\n@@ -425,7 +423,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n       }\n       ast::pat_enum(*) |\n       ast::pat_ident(*) if pat_is_const(tcx.def_map, pat) => {\n-        let const_did = ast_util::def_id_of_def(*tcx.def_map.get(&pat.id));\n+        let const_did = ast_util::def_id_of_def(tcx.def_map.get_copy(&pat.id));\n         let const_tpt = ty::lookup_item_type(tcx, const_did);\n         demand::suptype(fcx, pat.span, expected, const_tpt.ty);\n         fcx.write_ty(pat.id, const_tpt.ty);"}, {"sha": "08398f9880a402cb902a85bf283ff6ce88ce6d1a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -119,23 +119,24 @@ pub fn lookup(\n         // In a call `a.b::<X, Y, ...>(...)`:\n         expr: @ast::expr,                   // The expression `a.b(...)`.\n         self_expr: @ast::expr,              // The expression `a`.\n-        callee_id: node_id,                 // Where to store `a.b`'s type\n+        callee_id: node_id,                 /* Where to store `a.b`'s type,\n+                                             * also the scope of the call */\n         m_name: ast::ident,                 // The ident `b`.\n         self_ty: ty::t,                     // The type of `a`.\n         supplied_tps: &[ty::t],             // The list of types X, Y, ... .\n         deref_args: check::DerefArgs,       // Whether we autopointer first.\n         check_traits: CheckTraitsFlag,      // Whether we check traits only.\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<method_map_entry> {\n-    let mut impl_dups = HashSet::new();\n+    let impl_dups = @mut HashSet::new();\n     let lcx = LookupContext {\n         fcx: fcx,\n         expr: expr,\n         self_expr: self_expr,\n         callee_id: callee_id,\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n-        impl_dups: &mut impl_dups,\n+        impl_dups: impl_dups,\n         inherent_candidates: @mut ~[],\n         extension_candidates: @mut ~[],\n         deref_args: deref_args,\n@@ -154,7 +155,7 @@ pub struct LookupContext<'self> {\n     callee_id: node_id,\n     m_name: ast::ident,\n     supplied_tps: &'self [ty::t],\n-    impl_dups: &'self mut HashSet<def_id>,\n+    impl_dups: @mut HashSet<def_id>,\n     inherent_candidates: @mut ~[Candidate],\n     extension_candidates: @mut ~[Candidate],\n     deref_args: check::DerefArgs,\n@@ -640,7 +641,7 @@ pub impl<'self> LookupContext<'self> {\n         /*!\n          *\n          * In the event that we are invoking a method with a receiver\n-         * of a linear borrowed type like `&mut T` or `&mut [T]`,\n+         * of a borrowed type like `&T`, `&mut T`, or `&mut [T]`,\n          * we will \"reborrow\" the receiver implicitly.  For example, if\n          * you have a call `r.inc()` and where `r` has type `&mut T`,\n          * then we treat that like `(&mut *r).inc()`.  This avoids\n@@ -657,26 +658,25 @@ pub impl<'self> LookupContext<'self> {\n \n         let tcx = self.tcx();\n         return match ty::get(self_ty).sty {\n-            ty::ty_rptr(_, self_mt) if self_mt.mutbl == m_mutbl => {\n-                let region = self.infcx().next_region_var(self.expr.span,\n-                                                          self.expr.id);\n+            ty::ty_rptr(_, self_mt) if default_method_hack(self_mt) => {\n+                (self_ty,\n+                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                     autoderefs: autoderefs,\n+                     autoref: None}))\n+            }\n+            ty::ty_rptr(_, self_mt) => {\n+                let region = self.infcx().next_region_var_nb(self.expr.span);\n                 (ty::mk_rptr(tcx, region, self_mt),\n                  ty::AutoDerefRef(ty::AutoDerefRef {\n                      autoderefs: autoderefs+1,\n-                     autoref: Some(ty::AutoRef {kind: AutoPtr,\n-                                                region: region,\n-                                                mutbl: self_mt.mutbl})}))\n+                     autoref: Some(ty::AutoPtr(region, self_mt.mutbl))}))\n             }\n-            ty::ty_evec(self_mt, vstore_slice(_))\n-            if self_mt.mutbl == m_mutbl => {\n-                let region = self.infcx().next_region_var(self.expr.span,\n-                                                          self.expr.id);\n+            ty::ty_evec(self_mt, vstore_slice(_)) => {\n+                let region = self.infcx().next_region_var_nb(self.expr.span);\n                 (ty::mk_evec(tcx, self_mt, vstore_slice(region)),\n                  ty::AutoDerefRef(ty::AutoDerefRef {\n-                    autoderefs: autoderefs,\n-                    autoref: Some(ty::AutoRef {kind: AutoBorrowVec,\n-                                               region: region,\n-                                               mutbl: self_mt.mutbl})}))\n+                     autoderefs: autoderefs,\n+                     autoref: Some(ty::AutoBorrowVec(region, self_mt.mutbl))}))\n             }\n             _ => {\n                 (self_ty,\n@@ -685,6 +685,16 @@ pub impl<'self> LookupContext<'self> {\n                      autoref: None}))\n             }\n         };\n+\n+        fn default_method_hack(self_mt: ty::mt) -> bool {\n+            // FIXME(#6129). Default methods can't deal with autoref.\n+            //\n+            // I am a horrible monster and I pray for death. Currently\n+            // the default method code fails when you try to reborrow\n+            // because it is not handling types correctly. In lieu of\n+            // fixing that, I am introducing this horrible hack. - ndm\n+            self_mt.mutbl == m_imm && ty::type_is_self(self_mt.ty)\n+        }\n     }\n \n     fn search_for_autosliced_method(\n@@ -793,16 +803,15 @@ pub impl<'self> LookupContext<'self> {\n \n     fn search_for_some_kind_of_autorefd_method(\n         &self,\n-        kind: AutoRefKind,\n+        kind: &fn(Region, ast::mutability) -> ty::AutoRef,\n         autoderefs: uint,\n         mutbls: &[ast::mutability],\n         mk_autoref_ty: &fn(ast::mutability, ty::Region) -> ty::t)\n         -> Option<method_map_entry>\n     {\n         // This is hokey. We should have mutability inference as a\n         // variable.  But for now, try &const, then &, then &mut:\n-        let region = self.infcx().next_region_var(self.expr.span,\n-                                                  self.expr.id);\n+        let region = self.infcx().next_region_var_nb(self.expr.span);\n         for mutbls.each |mutbl| {\n             let autoref_ty = mk_autoref_ty(*mutbl, region);\n             match self.search_for_method(autoref_ty) {\n@@ -812,12 +821,7 @@ pub impl<'self> LookupContext<'self> {\n                         self.self_expr.id,\n                         @ty::AutoDerefRef(ty::AutoDerefRef {\n                             autoderefs: autoderefs,\n-                            autoref: Some(ty::AutoRef {\n-                                kind: kind,\n-                                region: region,\n-                                mutbl: *mutbl,\n-                            }),\n-                        }));\n+                            autoref: Some(kind(region, *mutbl))}));\n                     return Some(mme);\n                 }\n             }\n@@ -1024,8 +1028,7 @@ pub impl<'self> LookupContext<'self> {\n         let (_, opt_transformed_self_ty, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n                 tcx, @Nil, Some(transformed_self_ty), &bare_fn_ty.sig,\n-                |_br| self.fcx.infcx().next_region_var(\n-                    self.expr.span, self.expr.id));\n+                |_br| self.fcx.infcx().next_region_var_nb(self.expr.span));\n         let transformed_self_ty = opt_transformed_self_ty.get();\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {sig: fn_sig, ..bare_fn_ty});\n         debug!(\"after replacing bound regions, fty=%s\", self.ty_to_str(fty));"}, {"sha": "e171765ef6c4ef82d686e9b99b461a2b3f5a8064", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 47, "deletions": 39, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -207,9 +207,11 @@ pub impl PurityState {\n }\n \n pub struct FnCtxt {\n-    // var_bindings, locals and next_var_id are shared\n-    // with any nested functions that capture the environment\n-    // (and with any functions whose environment is being captured).\n+    // Number of errors that had been reported when we started\n+    // checking this function. On exit, if we find that *more* errors\n+    // have been reported, we will skip regionck and other work that\n+    // expects the types within the function to be consistent.\n+    err_count_on_creation: uint,\n \n     ret_ty: ty::t,\n     // Used by loop bodies that return from the outer function\n@@ -263,6 +265,7 @@ pub fn blank_fn_ctxt(ccx: @mut CrateCtxt,\n // It's kind of a kludge to manufacture a fake function context\n // and statement context, but we might as well do write the code only once\n     @mut FnCtxt {\n+        err_count_on_creation: ccx.tcx.sess.err_count(),\n         ret_ty: rty,\n         indirect_ret_ty: None,\n         ps: PurityState::function(ast::pure_fn, 0),\n@@ -328,6 +331,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n      */\n \n     let tcx = ccx.tcx;\n+    let err_count_on_creation = tcx.sess.err_count();\n \n     // ______________________________________________________________________\n     // First, we have to replace any bound regions in the fn and self\n@@ -368,6 +372,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         };\n \n         @mut FnCtxt {\n+            err_count_on_creation: err_count_on_creation,\n             ret_ty: ret_ty,\n             indirect_ret_ty: indirect_ret_ty,\n             ps: PurityState::function(purity, id),\n@@ -433,7 +438,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             assign(self_info.self_id, Some(self_info.self_ty));\n             debug!(\"self is assigned to %s\",\n                    fcx.infcx().ty_to_str(\n-                       *fcx.inh.locals.get(&self_info.self_id)));\n+                       fcx.inh.locals.get_copy(&self_info.self_id)));\n         }\n \n         // Add formal parameters.\n@@ -466,7 +471,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             debug!(\"Local variable %s is assigned type %s\",\n                    fcx.pat_to_str(local.node.pat),\n                    fcx.infcx().ty_to_str(\n-                       *fcx.inh.locals.get(&local.node.id)));\n+                       fcx.inh.locals.get_copy(&local.node.id)));\n             visit::visit_local(local, e, v);\n         };\n \n@@ -479,7 +484,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 debug!(\"Pattern binding %s is assigned to %s\",\n                        *tcx.sess.str_of(path.idents[0]),\n                        fcx.infcx().ty_to_str(\n-                           *fcx.inh.locals.get(&p.id)));\n+                           fcx.inh.locals.get_copy(&p.id)));\n               }\n               _ => {}\n             }\n@@ -642,7 +647,12 @@ impl AstConv for FnCtxt {\n }\n \n pub impl FnCtxt {\n-    fn infcx(&self) -> @mut infer::InferCtxt { self.inh.infcx }\n+    fn infcx(&self) -> @mut infer::InferCtxt {\n+        self.inh.infcx\n+    }\n+    fn err_count_since_creation(&self) -> uint {\n+        self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n+    }\n     fn search_in_scope_regions(\n         &self,\n         span: span,\n@@ -898,11 +908,9 @@ pub impl FnCtxt {\n \n     fn region_var_if_parameterized(&self,\n                                    rp: Option<ty::region_variance>,\n-                                   span: span,\n-                                   lower_bound: ty::Region)\n+                                   span: span)\n                                 -> Option<ty::Region> {\n-        rp.map(\n-            |_rp| self.infcx().next_region_var_with_lb(span, lower_bound))\n+        rp.map(|_rp| self.infcx().next_region_var_nb(span))\n     }\n \n     fn type_error_message(&self,\n@@ -1083,8 +1091,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n     };\n \n     let self_r = if region_param.is_some() {\n-        Some(vcx.infcx.next_region_var(location_info.span,\n-                                         location_info.id))\n+        Some(vcx.infcx.next_region_var_nb(location_info.span))\n     } else {\n         None\n     };\n@@ -1291,9 +1298,17 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // that they appear in call position.\n         check_expr(fcx, f);\n \n+        // Store the type of `f` as the type of the callee\n+        let fn_ty = fcx.expr_ty(f);\n+\n+        // FIXME(#6273) should write callee type AFTER regions have\n+        // been subst'd.  However, it is awkward to deal with this\n+        // now. Best thing would I think be to just have a separate\n+        // \"callee table\" that contains the FnSig and not a general\n+        // purpose ty::t\n+        fcx.write_ty(call_expr.callee_id, fn_ty);\n \n         // Extract the function signature from `in_fty`.\n-        let fn_ty = fcx.expr_ty(f);\n         let fn_sty = structure_of(fcx, f.span, fn_ty);\n \n         // FIXME(#3678) For now, do not permit calls to C abi functions.\n@@ -1330,7 +1345,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let (_, _, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n                 fcx.tcx(), @Nil, None, &fn_sig,\n-                |_br| fcx.infcx().next_region_var(call_expr.span, call_expr.id));\n+                |_br| fcx.infcx().next_region_var_nb(call_expr.span));\n \n         // Call the generic checker.\n         check_argument_types(fcx, call_expr.span, fn_sig.inputs, f,\n@@ -1651,7 +1666,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         };\n \n         // construct the function type\n-        let mut fn_ty = astconv::ty_of_closure(fcx,\n+        let fn_ty = astconv::ty_of_closure(fcx,\n                                                fcx,\n                                                sigil,\n                                                purity,\n@@ -1662,7 +1677,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                                &opt_vec::Empty,\n                                                expr.span);\n \n-        let mut fty_sig;\n+        let fty_sig;\n         let fty = if error_happened {\n             fty_sig = FnSig {\n                 bound_lifetime_names: opt_vec::Empty,\n@@ -1909,9 +1924,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // Generate the struct type.\n         let self_region =\n-            fcx.region_var_if_parameterized(region_parameterized,\n-                                            span,\n-                                            ty::re_scope(id));\n+            fcx.region_var_if_parameterized(region_parameterized, span);\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n             self_r: self_region,\n@@ -1997,9 +2010,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // Generate the enum type.\n         let self_region =\n-            fcx.region_var_if_parameterized(region_parameterized,\n-                                            span,\n-                                            ty::re_scope(id));\n+            fcx.region_var_if_parameterized(region_parameterized, span);\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n             self_r: self_region,\n@@ -2336,13 +2347,12 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // (and how long it is valid), which we don't know yet until type\n         // inference is complete.\n         //\n-        // Therefore, here we simply generate a region variable with\n-        // the current expression as a lower bound.  The region\n-        // inferencer will then select the ultimate value.  Finally,\n-        // borrowck is charged with guaranteeing that the value whose\n-        // address was taken can actually be made to live as long as\n-        // it needs to live.\n-        let region = fcx.infcx().next_region_var(expr.span, expr.id);\n+        // Therefore, here we simply generate a region variable.  The\n+        // region inferencer will then select the ultimate value.\n+        // Finally, borrowck is charged with guaranteeing that the\n+        // value whose address was taken can actually be made to live\n+        // as long as it needs to live.\n+        let region = fcx.infcx().next_region_var_nb(expr.span);\n \n         let tm = ty::mt { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n         let oprnd_t = if ty::type_is_error(tm.ty) {\n@@ -2359,8 +2369,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let defn = lookup_def(fcx, pth.span, id);\n \n         let tpt = ty_param_bounds_and_ty_for_def(fcx, expr.span, defn);\n-        let region_lb = ty::re_scope(expr.id);\n-        instantiate_path(fcx, pth, tpt, expr.span, expr.id, region_lb);\n+        instantiate_path(fcx, pth, tpt, expr.span, expr.id);\n       }\n       ast::expr_inline_asm(ref ia) => {\n           fcx.require_unsafe(expr.span, ~\"use of inline assembly\");\n@@ -2936,7 +2945,8 @@ pub fn check_block(fcx0: @mut FnCtxt, blk: &ast::blk)  {\n pub fn check_block_with_expected(fcx: @mut FnCtxt,\n                                  blk: &ast::blk,\n                                  expected: Option<ty::t>) {\n-    let prev = replace(&mut fcx.ps, fcx.ps.recurse(blk));\n+    let purity_state = fcx.ps.recurse(blk);\n+    let prev = replace(&mut fcx.ps, purity_state);\n \n     do fcx.with_region_lb(blk.node.id) {\n         let mut warned = false;\n@@ -3227,8 +3237,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n                         pth: @ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n                         span: span,\n-                        node_id: ast::node_id,\n-                        region_lb: ty::Region) {\n+                        node_id: ast::node_id) {\n     debug!(\">>> instantiate_path\");\n \n     let ty_param_count = tpt.generics.type_param_defs.len();\n@@ -3254,8 +3263,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n         }\n       }\n       None => { // no lifetime parameter supplied, insert default\n-        fcx.region_var_if_parameterized(\n-            tpt.generics.region_param, span, region_lb)\n+        fcx.region_var_if_parameterized(tpt.generics.region_param, span)\n       }\n     };\n \n@@ -3339,7 +3347,7 @@ pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n         ast::expr_vstore_uniq => ty::vstore_uniq,\n         ast::expr_vstore_box | ast::expr_vstore_mut_box => ty::vstore_box,\n         ast::expr_vstore_slice | ast::expr_vstore_mut_slice => {\n-            let r = fcx.infcx().next_region_var(e.span, e.id);\n+            let r = fcx.infcx().next_region_var_nb(e.span);\n             ty::vstore_slice(r)\n         }\n     }\n@@ -3462,7 +3470,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n       ~\"visit_tydesc\" => {\n         let tydesc_name = special_idents::tydesc;\n         assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n-        let (_, tydesc_ty) = *tcx.intrinsic_defs.get(&tydesc_name);\n+        let (_, tydesc_ty) = tcx.intrinsic_defs.get_copy(&tydesc_name);\n         let (_, visitor_object_ty) = ty::visitor_object_ty(tcx);\n         let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n             ty: tydesc_ty,"}, {"sha": "6db6b7556aee4452b880f533455e1162f7213712", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 374, "deletions": 247, "changes": 621, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -28,16 +28,15 @@ this point a bit better.\n */\n \n use middle::freevars::get_freevars;\n-use middle::pat_util::pat_bindings;\n use middle::ty::{re_scope};\n use middle::ty;\n use middle::typeck::check::FnCtxt;\n-use middle::typeck::check::lookup_def;\n use middle::typeck::check::regionmanip::relate_nested_regions;\n use middle::typeck::infer::resolve_and_force_all_but_regions;\n use middle::typeck::infer::resolve_type;\n use util::ppaux::{note_and_explain_region, ty_to_str,\n                   region_to_str};\n+use middle::pat_util;\n \n use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n use syntax::ast::{def_arg, def_binding, def_local, def_self, def_upvar};\n@@ -73,7 +72,11 @@ fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::def) -> ty::Region {\n }\n \n pub impl Rcx {\n-    fn resolve_type(@mut self, unresolved_ty: ty::t) -> ty::t {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.fcx.ccx.tcx\n+    }\n+\n+    fn resolve_type(&mut self, unresolved_ty: ty::t) -> ty::t {\n         /*!\n          * Try to resolve the type for the given node, returning\n          * t_err if an error results.  Note that we never care\n@@ -135,69 +138,151 @@ pub impl Rcx {\n \n pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::expr) {\n     let rcx = @mut Rcx { fcx: fcx, errors_reported: 0 };\n-    let v = regionck_visitor();\n-    (v.visit_expr)(e, rcx, v);\n+    if fcx.err_count_since_creation() == 0 {\n+        // regionck assumes typeck succeeded\n+        let v = regionck_visitor();\n+        (v.visit_expr)(e, rcx, v);\n+    }\n     fcx.infcx().resolve_regions();\n }\n \n pub fn regionck_fn(fcx: @mut FnCtxt, blk: &ast::blk) {\n     let rcx = @mut Rcx { fcx: fcx, errors_reported: 0 };\n-    let v = regionck_visitor();\n-    (v.visit_block)(blk, rcx, v);\n+    if fcx.err_count_since_creation() == 0 {\n+        // regionck assumes typeck succeeded\n+        let v = regionck_visitor();\n+        (v.visit_block)(blk, rcx, v);\n+    }\n     fcx.infcx().resolve_regions();\n }\n \n fn regionck_visitor() -> rvt {\n+    // (*) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n+    // However, right now we run into an issue whereby some free\n+    // regions are not properly related if they appear within the\n+    // types of arguments that must be inferred. This could be\n+    // addressed by deferring the construction of the region\n+    // hierarchy, and in particular the relationships between free\n+    // regions, until regionck, as described in #3238.\n     visit::mk_vt(@visit::Visitor {visit_item: visit_item,\n-                                  visit_stmt: visit_stmt,\n                                   visit_expr: visit_expr,\n-                                  visit_block: visit_block,\n+\n+                                  //visit_pat: visit_pat, // (*) see above\n+                                  visit_arm: visit_arm,\n                                   visit_local: visit_local,\n+\n+                                  visit_block: visit_block,\n                                   .. *visit::default_visitor()})\n }\n \n fn visit_item(_item: @ast::item, _rcx: @mut Rcx, _v: rvt) {\n     // Ignore items\n }\n \n-fn visit_local(l: @ast::local, rcx: @mut Rcx, v: rvt) {\n-    // Check to make sure that the regions in all local variables are\n-    // within scope.\n-    //\n-    // Note: we do this here rather than in visit_pat because we do\n-    // not wish to constrain the regions in *patterns* in quite the\n-    // same way.  `visit_node()` guarantees that the region encloses\n-    // the node in question, which ultimately constrains the regions\n-    // in patterns to enclose the match expression as a whole.  But we\n-    // want them to enclose the *arm*.  However, regions in patterns\n-    // must either derive from the discriminant or a ref pattern: in\n-    // the case of the discriminant, the regions will be constrained\n-    // when the type of the discriminant is checked.  In the case of a\n-    // ref pattern, the variable is created with a suitable lower\n-    // bound.\n-    let e = rcx.errors_reported;\n-    (v.visit_pat)(l.node.pat, rcx, v);\n-    let def_map = rcx.fcx.ccx.tcx.def_map;\n-    do pat_bindings(def_map, l.node.pat) |_bm, id, sp, _path| {\n-        visit_node(id, sp, rcx);\n-    }\n-    if e != rcx.errors_reported {\n-        return; // if decl has errors, skip initializer expr\n-    }\n+fn visit_block(b: &ast::blk, rcx: @mut Rcx, v: rvt) {\n+    rcx.fcx.tcx().region_maps.record_cleanup_scope(b.node.id);\n+    visit::visit_block(b, rcx, v);\n+}\n \n-    (v.visit_ty)(l.node.ty, rcx, v);\n-    for l.node.init.each |i| {\n-        (v.visit_expr)(*i, rcx, v);\n+fn visit_arm(arm: &ast::arm, rcx: @mut Rcx, v: rvt) {\n+    // see above\n+    for arm.pats.each |&p| {\n+        constrain_bindings_in_pat(p, rcx);\n     }\n+\n+    visit::visit_arm(arm, rcx, v);\n }\n \n-fn visit_block(b: &ast::blk, rcx: @mut Rcx, v: rvt) {\n-    visit::visit_block(b, rcx, v);\n+fn visit_local(l: @ast::local, rcx: @mut Rcx, v: rvt) {\n+    // see above\n+    constrain_bindings_in_pat(l.node.pat, rcx);\n+    visit::visit_local(l, rcx, v);\n+}\n+\n+fn constrain_bindings_in_pat(pat: @ast::pat, rcx: @mut Rcx) {\n+    let tcx = rcx.fcx.tcx();\n+    debug!(\"regionck::visit_pat(pat=%s)\", pat.repr(tcx));\n+    do pat_util::pat_bindings(tcx.def_map, pat) |_, id, span, _| {\n+        // If we have a variable that contains region'd data, that\n+        // data will be accessible from anywhere that the variable is\n+        // accessed. We must be wary of loops like this:\n+        //\n+        //     // from src/test/compile-fail/borrowck-lend-flow.rs\n+        //     let mut v = ~3, w = ~4;\n+        //     let mut x = &mut w;\n+        //     loop {\n+        //         **x += 1;   // (2)\n+        //         borrow(v);  //~ ERROR cannot borrow\n+        //         x = &mut v; // (1)\n+        //     }\n+        //\n+        // Typically, we try to determine the region of a borrow from\n+        // those points where it is dereferenced. In this case, one\n+        // might imagine that the lifetime of `x` need only be the\n+        // body of the loop. But of course this is incorrect because\n+        // the pointer that is created at point (1) is consumed at\n+        // point (2), meaning that it must be live across the loop\n+        // iteration. The easiest way to guarantee this is to require\n+        // that the lifetime of any regions that appear in a\n+        // variable's type enclose at least the variable's scope.\n+\n+        let encl_region = tcx.region_maps.encl_region(id);\n+        constrain_regions_in_type_of_node(rcx, id, encl_region, span);\n+    }\n }\n \n fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n     debug!(\"regionck::visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n+    let has_method_map = rcx.fcx.inh.method_map.contains_key(&expr.id);\n+\n+    // Record cleanup scopes, which are used by borrowck to decide the\n+    // maximum lifetime of a temporary rvalue.  These were derived by\n+    // examining where trans creates block scopes, not because this\n+    // reflects some principled decision around temporary lifetimes.\n+    // Ordinarily this would seem like something that should be setup\n+    // in region, but we need to know which uses of operators are\n+    // overloaded.  See #3511.\n+    let tcx = rcx.fcx.tcx();\n+    match expr.node {\n+        // You'd think that x += y where `+=` is overloaded would be a\n+        // cleanup scope. You'd be... kind of right. In fact the\n+        // handling of `+=` and friends in trans for overloaded\n+        // operators is a hopeless mess and I can't figure out how to\n+        // represent it. - ndm\n+        //\n+        // ast::expr_assign_op(*) |\n+\n+        ast::expr_index(*) |\n+        ast::expr_binary(*) |\n+        ast::expr_unary(*) if has_method_map => {\n+            tcx.region_maps.record_cleanup_scope(expr.id);\n+        }\n+        ast::expr_binary(ast::and, lhs, rhs) |\n+        ast::expr_binary(ast::or, lhs, rhs) => {\n+            tcx.region_maps.record_cleanup_scope(lhs.id);\n+            tcx.region_maps.record_cleanup_scope(rhs.id);\n+        }\n+        ast::expr_call(*) |\n+        ast::expr_method_call(*) => {\n+            tcx.region_maps.record_cleanup_scope(expr.id);\n+        }\n+        ast::expr_match(_, ref arms) => {\n+            tcx.region_maps.record_cleanup_scope(expr.id);\n+            for arms.each |arm| {\n+                for arm.guard.each |guard| {\n+                    tcx.region_maps.record_cleanup_scope(guard.id);\n+                }\n+            }\n+        }\n+        ast::expr_while(cond, ref body) => {\n+            tcx.region_maps.record_cleanup_scope(cond.id);\n+            tcx.region_maps.record_cleanup_scope(body.node.id);\n+        }\n+        _ => {}\n+    }\n+\n+    // Check any autoderefs or autorefs that appear.\n     for rcx.fcx.inh.adjustments.find(&expr.id).each |&adjustment| {\n         debug!(\"adjustment=%?\", adjustment);\n         match *adjustment {\n@@ -208,65 +293,54 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n                 constrain_derefs(rcx, expr, autoderefs, expr_ty);\n                 for opt_autoref.each |autoref| {\n                     guarantor::for_autoref(rcx, expr, autoderefs, autoref);\n+\n+                    // Require that the resulting region encompasses\n+                    // the current node.\n+                    //\n+                    // FIXME(#6268) remove to support nested method calls\n+                    constrain_regions_in_type_of_node(\n+                        rcx, expr.id, ty::re_scope(expr.id), expr.span);\n                 }\n             }\n             _ => {}\n         }\n     }\n \n     match expr.node {\n-        ast::expr_path(*) => {\n-            // Avoid checking the use of local variables, as we\n-            // already check their definitions.  The def'n always\n-            // encloses the use.  So if the def'n is enclosed by the\n-            // region, then the uses will also be enclosed (and\n-            // otherwise, an error will have been reported at the\n-            // def'n site).\n-            match lookup_def(rcx.fcx, expr.span, expr.id) {\n-                ast::def_local(*) | ast::def_arg(*) |\n-                ast::def_upvar(*) => return,\n-                _ => ()\n-            }\n+        ast::expr_call(callee, ref args, _) => {\n+            constrain_callee(rcx, expr, callee);\n+            constrain_call(rcx, expr, None, *args, false);\n         }\n \n-        ast::expr_call(callee, ref args, _) => {\n-            // Check for a.b() where b is a method.  Ensure that\n-            // any types in the callee are valid for the entire\n-            // method call.\n-\n-            // FIXME(#3387)--we should really invoke\n-            // `constrain_auto_ref()` on all exprs.  But that causes a\n-            // lot of spurious errors because of how the region\n-            // hierarchy is setup.\n-            if rcx.fcx.inh.method_map.contains_key(&callee.id) {\n-                match callee.node {\n-                    ast::expr_field(base, _, _) => {\n-                        constrain_auto_ref(rcx, base);\n-                    }\n-                    _ => {\n-                        // This can happen if you have code like\n-                        // (x[0])() where `x[0]` is overloaded.  Just\n-                        // ignore it.\n-                    }\n-                }\n-            } else {\n-                constrain_auto_ref(rcx, callee);\n-            }\n+        ast::expr_method_call(arg0, _, _, ref args, _) => {\n+            constrain_call(rcx, expr, Some(arg0), *args, false);\n+        }\n \n-            for args.each |arg| {\n-                constrain_auto_ref(rcx, *arg);\n-            }\n+        ast::expr_index(lhs, rhs) |\n+        ast::expr_assign_op(_, lhs, rhs) |\n+        ast::expr_binary(_, lhs, rhs) if has_method_map => {\n+            // As `expr_method_call`, but the call is via an\n+            // overloaded op.  Note that we (sadly) currently use an\n+            // implicit \"by ref\" sort of passing style here.  This\n+            // should be converted to an adjustment!\n+            constrain_call(rcx, expr, Some(lhs), [rhs], true);\n         }\n \n-        ast::expr_method_call(rcvr, _, _, ref args, _) => {\n-            // Check for a.b() where b is a method.  Ensure that\n-            // any types in the callee are valid for the entire\n-            // method call.\n+        ast::expr_unary(_, lhs) if has_method_map => {\n+            // As above.\n+            constrain_call(rcx, expr, Some(lhs), [], true);\n+        }\n \n-            constrain_auto_ref(rcx, rcvr);\n-            for args.each |arg| {\n-                constrain_auto_ref(rcx, *arg);\n-            }\n+        ast::expr_unary(ast::deref, base) => {\n+            // For *a, the lifetime of a must enclose the deref\n+            let base_ty = rcx.resolve_node_type(base.id);\n+            constrain_derefs(rcx, expr, 1, base_ty);\n+        }\n+\n+        ast::expr_index(vec_expr, _) => {\n+            // For a[b], the lifetime of a must enclose the deref\n+            let vec_type = rcx.resolve_expr_type_adjusted(vec_expr);\n+            constrain_index(rcx, expr, vec_type);\n         }\n \n         ast::expr_cast(source, _) => {\n@@ -294,25 +368,27 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n             }\n         }\n \n-        ast::expr_index(vec_expr, _) => {\n-            let vec_type = rcx.resolve_expr_type_adjusted(vec_expr);\n-            constrain_index(rcx, expr, vec_type);\n-        }\n-\n-        ast::expr_unary(ast::deref, base) => {\n-            let base_ty = rcx.resolve_node_type(base.id);\n-            constrain_derefs(rcx, expr, 1, base_ty);\n-        }\n-\n         ast::expr_addr_of(_, base) => {\n             guarantor::for_addr_of(rcx, expr, base);\n+\n+            // Require that when you write a `&expr` expression, the\n+            // resulting pointer has a lifetime that encompasses the\n+            // `&expr` expression itself. Note that we constraining\n+            // the type of the node expr.id here *before applying\n+            // adjustments*.\n+            //\n+            // FIXME(#6268) nested method calls requires that this rule change\n+            let ty0 = rcx.resolve_node_type(expr.id);\n+            constrain_regions_in_type(rcx, ty::re_scope(expr.id), expr.span, ty0);\n         }\n \n         ast::expr_match(discr, ref arms) => {\n             guarantor::for_match(rcx, discr, *arms);\n         }\n \n         ast::expr_fn_block(*) => {\n+            // The lifetime of a block fn must not outlive the variables\n+            // it closes over\n             let function_type = rcx.resolve_node_type(expr.id);\n             match ty::get(function_type).sty {\n                 ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n@@ -326,46 +402,101 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n         _ => ()\n     }\n \n-    if !visit_node(expr.id, expr.span, rcx) { return; }\n     visit::visit_expr(expr, rcx, v);\n }\n \n-fn visit_stmt(s: @ast::stmt, rcx: @mut Rcx, v: rvt) {\n-    visit::visit_stmt(s, rcx, v);\n-}\n+fn constrain_callee(rcx: @mut Rcx,\n+                    call_expr: @ast::expr,\n+                    callee_expr: @ast::expr)\n+{\n+    let tcx = rcx.fcx.tcx();\n \n-fn visit_node(id: ast::node_id, span: span, rcx: @mut Rcx) -> bool {\n-    /*!\n-     *\n-     * checks the type of the node `id` and reports an error if it\n-     * references a region that is not in scope for that node.\n-     * Returns false if an error is reported; this is used to cause us\n-     * to cut off region checking for that subtree to avoid reporting\n-     * tons of errors. */\n-\n-    let fcx = rcx.fcx;\n-\n-    // find the region where this expr evaluation is taking place\n-    let tcx = fcx.ccx.tcx;\n-    let encl_region = match tcx.region_maps.opt_encl_scope(id) {\n-        None => ty::re_static,\n-        Some(r) => ty::re_scope(r)\n-    };\n-\n-    // Otherwise, look at the type and see if it is a region pointer.\n-    constrain_regions_in_type_of_node(rcx, id, encl_region, span)\n+    let call_region = ty::re_scope(call_expr.id);\n+\n+    let callee_ty = rcx.resolve_node_type(call_expr.callee_id);\n+    match ty::get(callee_ty).sty {\n+        ty::ty_bare_fn(*) => { }\n+        ty::ty_closure(ref closure_ty) => {\n+            match rcx.fcx.mk_subr(true, callee_expr.span,\n+                                  call_region, closure_ty.region) {\n+                result::Err(_) => {\n+                    tcx.sess.span_err(\n+                        callee_expr.span,\n+                        fmt!(\"cannot invoke closure outside of its lifetime\"));\n+                    note_and_explain_region(\n+                        tcx,\n+                        \"the closure is only valid for \",\n+                        closure_ty.region,\n+                        \"\");\n+                }\n+                result::Ok(_) => {}\n+            }\n+        }\n+        _ => {\n+            // this should not happen, but it does if the program is\n+            // erroneous\n+            //\n+            // tcx.sess.span_bug(\n+            //     callee_expr.span,\n+            //     fmt!(\"Calling non-function: %s\", callee_ty.repr(tcx)));\n+        }\n+    }\n }\n \n-fn encl_region_or_static(rcx: @mut Rcx, expr: @ast::expr) -> ty::Region {\n-    // FIXME(#3850) --- interactions with modes compel overly large granularity\n-    // that is, we would probably prefer to just return re_scope(expr.id)\n-    // here but we cannot just yet.\n+fn constrain_call(rcx: @mut Rcx,\n+                  // might be expr_call, expr_method_call, or an overloaded\n+                  // operator\n+                  call_expr: @ast::expr,\n+                  receiver: Option<@ast::expr>,\n+                  arg_exprs: &[@ast::expr],\n+                  implicitly_ref_args: bool)\n+{\n+    //! Invoked on every call site (i.e., normal calls, method calls,\n+    //! and overloaded operators). Constrains the regions which appear\n+    //! in the type of the function. Also constrains the regions that\n+    //! appear in the arguments appropriately.\n \n     let tcx = rcx.fcx.tcx();\n-    match tcx.region_maps.opt_encl_scope(expr.id) {\n-        Some(s) => ty::re_scope(s),\n-        None => ty::re_static // occurs in constants\n+    debug!(\"constrain_call(call_expr=%s, implicitly_ref_args=%?)\",\n+           call_expr.repr(tcx), implicitly_ref_args);\n+    let callee_ty = rcx.resolve_node_type(call_expr.callee_id);\n+    let fn_sig = ty::ty_fn_sig(callee_ty);\n+\n+    // `callee_region` is the scope representing the time in which the\n+    // call occurs.\n+    //\n+    // FIXME(#6268) to support nested method calls, should be callee_id\n+    let callee_scope = call_expr.id;\n+    let callee_region = ty::re_scope(callee_scope);\n+\n+    for arg_exprs.each |&arg_expr| {\n+        // ensure that any regions appearing in the argument type are\n+        // valid for at least the lifetime of the function:\n+        constrain_regions_in_type_of_node(\n+            rcx, arg_expr.id, callee_region, arg_expr.span);\n+\n+        // unfortunately, there are two means of taking implicit\n+        // references, and we need to propagate constraints as a\n+        // result. modes are going away and the \"DerefArgs\" code\n+        // should be ported to use adjustments\n+        if implicitly_ref_args {\n+            guarantor::for_by_ref(rcx, arg_expr, callee_scope);\n+        }\n+    }\n+\n+    // as loop above, but for receiver\n+    for receiver.each |&r| {\n+        constrain_regions_in_type_of_node(\n+            rcx, r.id, callee_region, r.span);\n+        if implicitly_ref_args {\n+            guarantor::for_by_ref(rcx, r, callee_scope);\n+        }\n     }\n+\n+    // constrain regions that may appear in the return type to be\n+    // valid for the function call:\n+    constrain_regions_in_type(\n+        rcx, callee_region, call_expr.span, fn_sig.output);\n }\n \n fn constrain_derefs(rcx: @mut Rcx,\n@@ -379,9 +510,8 @@ fn constrain_derefs(rcx: @mut Rcx,\n      * pointer being derefenced, the lifetime of the pointer includes\n      * the deref expr.\n      */\n-\n     let tcx = rcx.fcx.tcx();\n-    let r_deref_expr = encl_region_or_static(rcx, deref_expr);\n+    let r_deref_expr = ty::re_scope(deref_expr.id);\n     for uint::range(0, derefs) |i| {\n         debug!(\"constrain_derefs(deref_expr=%s, derefd_ty=%s, derefs=%?/%?\",\n                rcx.fcx.expr_to_str(deref_expr),\n@@ -390,19 +520,8 @@ fn constrain_derefs(rcx: @mut Rcx,\n \n         match ty::get(derefd_ty).sty {\n             ty::ty_rptr(r_ptr, _) => {\n-                match rcx.fcx.mk_subr(true, deref_expr.span, r_deref_expr, r_ptr) {\n-                    result::Ok(*) => {}\n-                    result::Err(*) => {\n-                        tcx.sess.span_err(\n-                            deref_expr.span,\n-                            fmt!(\"dereference of reference outside its lifetime\"));\n-                        note_and_explain_region(\n-                            tcx,\n-                            \"the reference is only valid for \",\n-                            r_ptr,\n-                            \"\");\n-                    }\n-                }\n+                mk_subregion_due_to_derefence(rcx, deref_expr.span,\n+                                              r_deref_expr, r_ptr);\n             }\n \n             _ => {}\n@@ -417,6 +536,27 @@ fn constrain_derefs(rcx: @mut Rcx,\n     }\n }\n \n+pub fn mk_subregion_due_to_derefence(rcx: @mut Rcx,\n+                                     deref_span: span,\n+                                     minimum_lifetime: ty::Region,\n+                                     maximum_lifetime: ty::Region) {\n+    match rcx.fcx.mk_subr(true, deref_span,\n+                          minimum_lifetime, maximum_lifetime) {\n+        result::Ok(*) => {}\n+        result::Err(*) => {\n+            rcx.tcx().sess.span_err(\n+                deref_span,\n+                fmt!(\"dereference of reference outside its lifetime\"));\n+            note_and_explain_region(\n+                rcx.tcx(),\n+                \"the reference is only valid for \",\n+                maximum_lifetime,\n+                \"\");\n+        }\n+    }\n+}\n+\n+\n fn constrain_index(rcx: @mut Rcx,\n                    index_expr: @ast::expr,\n                    indexed_ty: ty::t)\n@@ -433,7 +573,7 @@ fn constrain_index(rcx: @mut Rcx,\n            rcx.fcx.expr_to_str(index_expr),\n            rcx.fcx.infcx().ty_to_str(indexed_ty));\n \n-    let r_index_expr = encl_region_or_static(rcx, index_expr);\n+    let r_index_expr = ty::re_scope(index_expr.id);\n     match ty::get(indexed_ty).sty {\n         ty::ty_estr(ty::vstore_slice(r_ptr)) |\n         ty::ty_evec(_, ty::vstore_slice(r_ptr)) => {\n@@ -456,66 +596,22 @@ fn constrain_index(rcx: @mut Rcx,\n     }\n }\n \n-fn constrain_auto_ref(rcx: @mut Rcx, expr: @ast::expr) {\n+fn constrain_free_variables(rcx: @mut Rcx,\n+                            region: ty::Region,\n+                            expr: @ast::expr) {\n     /*!\n-     *\n-     * If `expr` is auto-ref'd (e.g., as part of a borrow), then this\n-     * function ensures that the lifetime of the resulting borrowed\n-     * ptr includes at least the expression `expr`. */\n-\n-    debug!(\"constrain_auto_ref(expr=%s)\", rcx.fcx.expr_to_str(expr));\n-\n-    let adjustment = rcx.fcx.inh.adjustments.find(&expr.id);\n-    let region = match adjustment {\n-        Some(&@ty::AutoDerefRef(\n-            ty::AutoDerefRef {\n-                autoref: Some(ref auto_ref), _})) => {\n-            auto_ref.region\n-        }\n-        _ => { return; }\n-    };\n-\n-    let tcx = rcx.fcx.tcx();\n-    let encl_region = tcx.region_maps.encl_region(expr.id);\n-    match rcx.fcx.mk_subr(true, expr.span, encl_region, region) {\n-        result::Ok(()) => {}\n-        result::Err(_) => {\n-            // In practice, this cannot happen: `region` is always a\n-            // region variable, and constraints on region variables\n-            // are collected and then resolved later.  However, I\n-            // included the span_err() here (rather than, say,\n-            // span_bug()) because it seemed more future-proof: if,\n-            // for some reason, the code were to change so that in\n-            // some cases `region` is not a region variable, then\n-            // reporting an error would be the correct path.\n-            tcx.sess.span_err(\n-                expr.span,\n-                \"lifetime of borrowed pointer does not include \\\n-                 the expression being borrowed\");\n-            note_and_explain_region(\n-                tcx,\n-                \"lifetime of the borrowed pointer is\",\n-                region,\n-                \"\");\n-            rcx.errors_reported += 1;\n-        }\n-    }\n-}\n-\n-fn constrain_free_variables(\n-    rcx: @mut Rcx,\n-    region: ty::Region,\n-    expr: @ast::expr) {\n-    /*!\n-     *\n      * Make sure that all free variables referenced inside the closure\n-     * outlive the closure itself. */\n+     * outlive the closure itself.\n+     */\n \n     let tcx = rcx.fcx.ccx.tcx;\n+    debug!(\"constrain_free_variables(%s, %s)\",\n+           region.repr(tcx), expr.repr(tcx));\n     for get_freevars(tcx, expr.id).each |freevar| {\n         debug!(\"freevar def is %?\", freevar.def);\n         let def = freevar.def;\n         let en_region = encl_region_of_def(rcx.fcx, def);\n+        debug!(\"en_region = %s\", en_region.repr(tcx));\n         match rcx.fcx.mk_subr(true, freevar.span,\n                               region, en_region) {\n           result::Ok(()) => {}\n@@ -541,9 +637,13 @@ fn constrain_free_variables(\n fn constrain_regions_in_type_of_node(\n     rcx: @mut Rcx,\n     id: ast::node_id,\n-    encl_region: ty::Region,\n+    minimum_lifetime: ty::Region,\n     span: span) -> bool\n {\n+    //! Guarantees that any lifetimes which appear in the type of\n+    //! the node `id` (after applying adjustments) are valid for at\n+    //! least `minimum_lifetime`\n+\n     let tcx = rcx.fcx.tcx();\n \n     // Try to resolve the type.  If we encounter an error, then typeck\n@@ -553,22 +653,21 @@ fn constrain_regions_in_type_of_node(\n     let adjustment = rcx.fcx.inh.adjustments.find(&id);\n     let ty = ty::adjust_ty(tcx, span, ty0, adjustment);\n     debug!(\"constrain_regions_in_type_of_node(\\\n-            ty=%s, ty0=%s, id=%d, encl_region=%?, adjustment=%?)\",\n+            ty=%s, ty0=%s, id=%d, minimum_lifetime=%?, adjustment=%?)\",\n            ty_to_str(tcx, ty), ty_to_str(tcx, ty0),\n-           id, encl_region, adjustment);\n-    constrain_regions_in_type(rcx, encl_region, span, ty)\n+           id, minimum_lifetime, adjustment);\n+    constrain_regions_in_type(rcx, minimum_lifetime, span, ty)\n }\n \n fn constrain_regions_in_type(\n     rcx: @mut Rcx,\n-    encl_region: ty::Region,\n+    minimum_lifetime: ty::Region,\n     span: span,\n     ty: ty::t) -> bool\n {\n     /*!\n-     *\n      * Requires that any regions which appear in `ty` must be\n-     * superregions of `encl_region`.  Also enforces the constraint\n+     * superregions of `minimum_lifetime`.  Also enforces the constraint\n      * that given a pointer type `&'r T`, T must not contain regions\n      * that outlive 'r, as well as analogous constraints for other\n      * lifetime'd types.\n@@ -583,24 +682,24 @@ fn constrain_regions_in_type(\n     let e = rcx.errors_reported;\n     let tcx = rcx.fcx.ccx.tcx;\n \n-    debug!(\"constrain_regions_in_type(encl_region=%s, ty=%s)\",\n-           region_to_str(tcx, encl_region),\n+    debug!(\"constrain_regions_in_type(minimum_lifetime=%s, ty=%s)\",\n+           region_to_str(tcx, minimum_lifetime),\n            ty_to_str(tcx, ty));\n \n-    do relate_nested_regions(tcx, Some(encl_region), ty) |r_sub, r_sup| {\n+    do relate_nested_regions(tcx, Some(minimum_lifetime), ty) |r_sub, r_sup| {\n         debug!(\"relate(r_sub=%s, r_sup=%s)\",\n                region_to_str(tcx, r_sub),\n                region_to_str(tcx, r_sup));\n \n         if r_sup.is_bound() || r_sub.is_bound() {\n             // a bound region is one which appears inside an fn type.\n             // (e.g., the `&` in `fn(&T)`).  Such regions need not be\n-            // constrained by `encl_region` as they are placeholders\n+            // constrained by `minimum_lifetime` as they are placeholders\n             // for regions that are as-yet-unknown.\n         } else {\n             match rcx.fcx.mk_subr(true, span, r_sub, r_sup) {\n                 result::Err(_) => {\n-                    if r_sub == encl_region {\n+                    if r_sub == minimum_lifetime {\n                         tcx.sess.span_err(\n                             span,\n                             fmt!(\"reference is not valid outside of its lifetime\"));\n@@ -639,7 +738,6 @@ fn constrain_regions_in_type(\n \n pub mod guarantor {\n     /*!\n-     *\n      * The routines in this module are aiming to deal with the case\n      * where a the contents of a borrowed pointer are re-borrowed.\n      * Imagine you have a borrowed pointer `b` with lifetime L1 and\n@@ -686,35 +784,35 @@ pub mod guarantor {\n      */\n \n     use middle::typeck::check::regionck::{Rcx, infallibly_mk_subr};\n+    use middle::typeck::check::regionck::mk_subregion_due_to_derefence;\n     use middle::ty;\n     use syntax::ast;\n     use syntax::codemap::span;\n     use util::ppaux::{ty_to_str};\n \n     pub fn for_addr_of(rcx: @mut Rcx, expr: @ast::expr, base: @ast::expr) {\n         /*!\n-         *\n          * Computes the guarantor for an expression `&base` and then\n          * ensures that the lifetime of the resulting pointer is linked\n          * to the lifetime of its guarantor (if any).\n          */\n \n         debug!(\"guarantor::for_addr_of(base=%s)\", rcx.fcx.expr_to_str(base));\n-        let _i = ::util::common::indenter();\n \n         let guarantor = guarantor(rcx, base);\n         link(rcx, expr.span, expr.id, guarantor);\n     }\n \n     pub fn for_match(rcx: @mut Rcx, discr: @ast::expr, arms: &[ast::arm]) {\n         /*!\n-         *\n          * Computes the guarantors for any ref bindings in a match and\n          * then ensures that the lifetime of the resulting pointer is\n          * linked to the lifetime of its guarantor (if any).\n          */\n \n+        debug!(\"regionck::for_match()\");\n         let discr_guarantor = guarantor(rcx, discr);\n+        debug!(\"discr_guarantor=%s\", discr_guarantor.repr(rcx.tcx()));\n         for arms.each |arm| {\n             for arm.pats.each |pat| {\n                 link_ref_bindings_in_pat(rcx, *pat, discr_guarantor);\n@@ -727,7 +825,6 @@ pub mod guarantor {\n                        autoderefs: uint,\n                        autoref: &ty::AutoRef) {\n         /*!\n-         *\n          * Computes the guarantor for an expression that has an\n          * autoref adjustment and links it to the lifetime of the\n          * autoref.  This is only important when auto re-borrowing\n@@ -736,30 +833,30 @@ pub mod guarantor {\n \n         debug!(\"guarantor::for_autoref(expr=%s, autoref=%?)\",\n                rcx.fcx.expr_to_str(expr), autoref);\n-        let _i = ::util::common::indenter();\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n         debug!(\"    unadjusted cat=%?\", expr_ct.cat);\n         expr_ct = apply_autoderefs(\n             rcx, expr, autoderefs, expr_ct);\n \n-        match autoref.kind {\n-            ty::AutoPtr => {\n+        match *autoref {\n+            ty::AutoPtr(r, _) => {\n                 // In this case, we are implicitly adding an `&`.\n-                maybe_make_subregion(rcx, expr, autoref.region,\n-                                     expr_ct.cat.guarantor);\n+                maybe_make_subregion(rcx, expr, r, expr_ct.cat.guarantor);\n             }\n \n-            ty::AutoBorrowVec |\n-            ty::AutoBorrowVecRef |\n-            ty::AutoBorrowFn => {\n+            ty::AutoBorrowVec(r, _) |\n+            ty::AutoBorrowVecRef(r, _) |\n+            ty::AutoBorrowFn(r) => {\n                 // In each of these cases, what is being borrowed is\n                 // not the (autoderef'd) expr itself but rather the\n                 // contents of the autoderef'd expression (i.e., what\n                 // the pointer points at).\n-                maybe_make_subregion(rcx, expr, autoref.region,\n+                maybe_make_subregion(rcx, expr, r,\n                                      guarantor_of_deref(&expr_ct.cat));\n             }\n+\n+            ty::AutoUnsafe(_) => {}\n         }\n \n         fn maybe_make_subregion(\n@@ -774,6 +871,28 @@ pub mod guarantor {\n         }\n     }\n \n+    pub fn for_by_ref(rcx: @mut Rcx,\n+                      expr: @ast::expr,\n+                      callee_scope: ast::node_id) {\n+        /*!\n+         * Computes the guarantor for cases where the `expr` is\n+         * being passed by implicit reference and must outlive\n+         * `callee_scope`.\n+         */\n+\n+        let tcx = rcx.tcx();\n+        debug!(\"guarantor::for_by_ref(expr=%s, callee_scope=%?)\",\n+               expr.repr(tcx), callee_scope);\n+        let expr_cat = categorize(rcx, expr);\n+        debug!(\"guarantor::for_by_ref(expr=%?, callee_scope=%?) category=%?\",\n+               expr.id, callee_scope, expr_cat);\n+        let minimum_lifetime = ty::re_scope(callee_scope);\n+        for expr_cat.guarantor.each |guarantor| {\n+            mk_subregion_due_to_derefence(rcx, expr.span,\n+                                          minimum_lifetime, *guarantor);\n+        }\n+    }\n+\n     fn link(\n         rcx: @mut Rcx,\n         span: span,\n@@ -801,7 +920,7 @@ pub mod guarantor {\n         // expressions, both of which always yield a region variable, so\n         // mk_subr should never fail.\n         let rptr_ty = rcx.resolve_node_type(id);\n-        if !ty::type_is_error(rptr_ty) && !ty::type_is_bot(rptr_ty) {\n+        if !ty::type_is_bot(rptr_ty) {\n             let tcx = rcx.fcx.ccx.tcx;\n             debug!(\"rptr_ty=%s\", ty_to_str(tcx, rptr_ty));\n             let r = ty::ty_region(tcx, span, rptr_ty);\n@@ -907,7 +1026,6 @@ pub mod guarantor {\n \n     fn categorize(rcx: @mut Rcx, expr: @ast::expr) -> ExprCategorization {\n         debug!(\"categorize(expr=%s)\", rcx.fcx.expr_to_str(expr));\n-        let _i = ::util::common::indenter();\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n         debug!(\"before adjustments, cat=%?\", expr_ct.cat);\n@@ -928,12 +1046,24 @@ pub mod guarantor {\n                 expr_ct = apply_autoderefs(\n                     rcx, expr, adjustment.autoderefs, expr_ct);\n \n-                for adjustment.autoref.each |autoref| {\n-                    // If there is an autoref, then the result of this\n-                    // expression will be some sort of borrowed pointer.\n-                    expr_ct.cat.guarantor = None;\n-                    expr_ct.cat.pointer = BorrowedPointer(autoref.region);\n-                    debug!(\"autoref, cat=%?\", expr_ct.cat);\n+                match adjustment.autoref {\n+                    None => {\n+                    }\n+                    Some(ty::AutoUnsafe(_)) => {\n+                        expr_ct.cat.guarantor = None;\n+                        expr_ct.cat.pointer = OtherPointer;\n+                        debug!(\"autoref, cat=%?\", expr_ct.cat);\n+                    }\n+                    Some(ty::AutoPtr(r, _)) |\n+                    Some(ty::AutoBorrowVec(r, _)) |\n+                    Some(ty::AutoBorrowVecRef(r, _)) |\n+                    Some(ty::AutoBorrowFn(r)) => {\n+                        // If there is an autoref, then the result of this\n+                        // expression will be some sort of borrowed pointer.\n+                        expr_ct.cat.guarantor = None;\n+                        expr_ct.cat.pointer = BorrowedPointer(r);\n+                        debug!(\"autoref, cat=%?\", expr_ct.cat);\n+                    }\n                 }\n             }\n \n@@ -948,7 +1078,6 @@ pub mod guarantor {\n                              expr: @ast::expr)\n                           -> ExprCategorizationType {\n         debug!(\"categorize_unadjusted(expr=%s)\", rcx.fcx.expr_to_str(expr));\n-        let _i = ::util::common::indenter();\n \n         let guarantor = {\n             if rcx.fcx.inh.method_map.contains_key(&expr.id) {\n@@ -1053,7 +1182,6 @@ pub mod guarantor {\n \n         debug!(\"link_ref_bindings_in_pat(pat=%s, guarantor=%?)\",\n                rcx.fcx.pat_to_str(pat), guarantor);\n-        let _i = ::util::common::indenter();\n \n         match pat.node {\n             ast::pat_wild => {}\n@@ -1069,7 +1197,10 @@ pub mod guarantor {\n                     link_ref_bindings_in_pat(rcx, *p, guarantor);\n                 }\n             }\n-            ast::pat_enum(*) => {}\n+            ast::pat_enum(_, None) => {}\n+            ast::pat_enum(_, Some(ref pats)) => {\n+                link_ref_bindings_in_pats(rcx, pats, guarantor);\n+            }\n             ast::pat_struct(_, ref fpats, _) => {\n                 for fpats.each |fpat| {\n                     link_ref_bindings_in_pat(rcx, fpat.pat, guarantor);\n@@ -1086,29 +1217,25 @@ pub mod guarantor {\n             }\n             ast::pat_region(p) => {\n                 let rptr_ty = rcx.resolve_node_type(pat.id);\n-                if !ty::type_is_error(rptr_ty) {\n-                    let r = ty::ty_region(rcx.fcx.tcx(), pat.span, rptr_ty);\n-                    link_ref_bindings_in_pat(rcx, p, Some(r));\n-                }\n+                let r = ty::ty_region(rcx.fcx.tcx(), pat.span, rptr_ty);\n+                link_ref_bindings_in_pat(rcx, p, Some(r));\n             }\n             ast::pat_lit(*) => {}\n             ast::pat_range(*) => {}\n             ast::pat_vec(ref before, ref slice, ref after) => {\n                 let vec_ty = rcx.resolve_node_type(pat.id);\n-                if !ty::type_is_error(vec_ty) {\n-                    let vstore = ty::ty_vstore(vec_ty);\n-                    let guarantor1 = match vstore {\n-                        ty::vstore_fixed(_) | ty::vstore_uniq => guarantor,\n-                        ty::vstore_slice(r) => Some(r),\n-                        ty::vstore_box => None\n-                    };\n-\n-                    link_ref_bindings_in_pats(rcx, before, guarantor1);\n-                    for slice.each |&p| {\n-                        link_ref_bindings_in_pat(rcx, p, guarantor);\n-                    }\n-                    link_ref_bindings_in_pats(rcx, after, guarantor1);\n+                let vstore = ty::ty_vstore(vec_ty);\n+                let guarantor1 = match vstore {\n+                    ty::vstore_fixed(_) | ty::vstore_uniq => guarantor,\n+                    ty::vstore_slice(r) => Some(r),\n+                    ty::vstore_box => None\n+                };\n+\n+                link_ref_bindings_in_pats(rcx, before, guarantor1);\n+                for slice.each |&p| {\n+                    link_ref_bindings_in_pat(rcx, p, guarantor);\n                 }\n+                link_ref_bindings_in_pats(rcx, after, guarantor1);\n             }\n         }\n     }"}, {"sha": "cfbd012b7b7cd7b23f71094d2ccf6c5bd2cef2af", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -87,7 +87,7 @@ pub fn replace_bound_regions_in_fn_sig(\n                       to_r: &fn(ty::bound_region) -> ty::Region,\n                       r: ty::Region) -> isr_alist {\n             match r {\n-              ty::re_free(*) | ty::re_static | ty::re_scope(_) |\n+              ty::re_empty | ty::re_free(*) | ty::re_static | ty::re_scope(_) |\n               ty::re_infer(_) => {\n                 isr\n               }\n@@ -153,6 +153,7 @@ pub fn replace_bound_regions_in_fn_sig(\n               }\n \n               // Free regions like these just stay the same:\n+              ty::re_empty |\n               ty::re_static |\n               ty::re_scope(_) |\n               ty::re_free(*) |"}, {"sha": "b5bd5a48e9d783f9154391610320f0250cc2712d", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -244,11 +244,14 @@ fn lookup_vtable(vcx: &VtableContext,\n                     // Nothing found. Continue.\n                 }\n                 Some(implementations) => {\n-                    let implementations: &mut ~[@Impl] = *implementations;\n+                    let len = { // FIXME(#5074): stage0 requires it\n+                        let implementations: &mut ~[@Impl] = *implementations;\n+                        implementations.len()\n+                    };\n \n                     // implementations is the list of all impls in scope for\n                     // trait_ref. (Usually, there's just one.)\n-                    for uint::range(0, implementations.len()) |i| {\n+                    for uint::range(0, len) |i| {\n                         let im = implementations[i];\n \n                         // im is one specific impl of trait_ref.\n@@ -487,7 +490,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n         for fcx.opt_node_ty_substs(ex.id) |substs| {\n             debug!(\"vtable resolution on parameter bounds for expr %s\",\n                    ex.repr(fcx.tcx()));\n-            let def = *cx.tcx.def_map.get(&ex.id);\n+            let def = cx.tcx.def_map.get_copy(&ex.id);\n             let did = ast_util::def_id_of_def(def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             debug!(\"early resolve expr: def %? %?, %?, %s\", ex.id, did, def,"}, {"sha": "b7713eaa2fd6e92e8437220e5df3c6c1b96168c7", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -134,23 +134,22 @@ fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::node_id)\n         }\n \n         Some(&@ty::AutoDerefRef(adj)) => {\n-            let resolved_autoref = match adj.autoref {\n-                Some(ref autoref) => {\n-                    match resolve_region(fcx.infcx(), autoref.region,\n-                                         resolve_all | force_all) {\n-                        Err(e) => {\n-                            // This should not, I think, happen.\n-                            fcx.ccx.tcx.sess.span_err(\n-                                sp, fmt!(\"cannot resolve scope of borrow: %s\",\n-                                         infer::fixup_err_to_str(e)));\n-                            Some(*autoref)\n-                        }\n-                        Ok(r) => {\n-                            Some(ty::AutoRef {region: r, ..*autoref})\n-                        }\n+            let fixup_region = |r| {\n+                match resolve_region(fcx.infcx(), r, resolve_all | force_all) {\n+                    Ok(r1) => r1,\n+                    Err(e) => {\n+                        // This should not, I think, happen.\n+                        fcx.ccx.tcx.sess.span_err(\n+                            sp, fmt!(\"cannot resolve scope of borrow: %s\",\n+                                     infer::fixup_err_to_str(e)));\n+                        r\n                     }\n                 }\n-                None => None\n+            };\n+\n+            let resolved_autoref = match adj.autoref {\n+                None => None,\n+                Some(ref r) => Some(r.map_region(fixup_region))\n             };\n \n             let resolved_adj = @ty::AutoDerefRef(ty::AutoDerefRef {"}, {"sha": "82ef09a83bee9c3e10901e72a320a547a6eb21d3", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -238,8 +238,8 @@ pub impl CoherenceChecker {\n \n     fn check_implementation(&self,\n                             item: @item, associated_traits: ~[@trait_ref]) {\n-        let self_type = self.crate_context.tcx.tcache.get(\n-            &local_def(item.id));\n+        let tcx = self.crate_context.tcx;\n+        let self_type = ty::lookup_item_type(tcx, local_def(item.id));\n \n         // If there are no traits, then this implementation must have a\n         // base type.\n@@ -390,7 +390,7 @@ pub impl CoherenceChecker {\n \n             let pmm = self.crate_context.tcx.provided_methods;\n             match pmm.find(&local_def(impl_id)) {\n-                Some(mis) => {\n+                Some(&mis) => {\n                     // If the trait already has an entry in the\n                     // provided_methods_map, we just need to add this\n                     // method to that entry.\n@@ -423,8 +423,8 @@ pub impl CoherenceChecker {\n                 self.crate_context.coherence_info.inherent_methods\n                     .insert(base_def_id, implementation_list);\n             }\n-            Some(existing_implementation_list) => {\n-                implementation_list = *existing_implementation_list;\n+            Some(&existing_implementation_list) => {\n+                implementation_list = existing_implementation_list;\n             }\n         }\n \n@@ -440,19 +440,17 @@ pub impl CoherenceChecker {\n                 self.crate_context.coherence_info.extension_methods\n                     .insert(trait_id, implementation_list);\n             }\n-            Some(existing_implementation_list) => {\n-                implementation_list = *existing_implementation_list;\n+            Some(&existing_implementation_list) => {\n+                implementation_list = existing_implementation_list;\n             }\n         }\n \n         implementation_list.push(implementation);\n     }\n \n     fn check_implementation_coherence(&self) {\n-        let coherence_info = &mut self.crate_context.coherence_info;\n-        let extension_methods = &coherence_info.extension_methods;\n-\n-        for extension_methods.each_key |&trait_id| {\n+        let coherence_info = self.crate_context.coherence_info;\n+        for coherence_info.extension_methods.each_key |&trait_id| {\n             self.check_implementation_coherence_of(trait_id);\n         }\n     }\n@@ -502,20 +500,23 @@ pub impl CoherenceChecker {\n                 m.insert(self_t, the_impl);\n                 self.crate_context.tcx.trait_impls.insert(trait_t, m);\n             }\n-            Some(m) => {\n+            Some(&m) => {\n                 m.insert(self_t, the_impl);\n             }\n         }\n     }\n \n     fn iter_impls_of_trait(&self, trait_def_id: def_id, f: &fn(@Impl)) {\n-        let coherence_info = &mut self.crate_context.coherence_info;\n-        let extension_methods = &coherence_info.extension_methods;\n+        let coherence_info = self.crate_context.coherence_info;\n+        let extension_methods = &*coherence_info.extension_methods;\n \n         match extension_methods.find(&trait_def_id) {\n             Some(impls) => {\n-                let impls: &mut ~[@Impl] = *impls;\n-                for uint::range(0, impls.len()) |i| {\n+                let len = { // FIXME(#5074) stage0 requires this\n+                    let impls: &mut ~[@Impl] = *impls;\n+                    impls.len()\n+                };\n+                for uint::range(0, len) |i| {\n                     f(impls[i]);\n                 }\n             }\n@@ -645,7 +646,7 @@ pub impl CoherenceChecker {\n \n     fn get_self_type_for_implementation(&self, implementation: @Impl)\n                                      -> ty_param_bounds_and_ty {\n-        return *self.crate_context.tcx.tcache.get(&implementation.did);\n+        return self.crate_context.tcx.tcache.get_copy(&implementation.did);\n     }\n \n     // Privileged scope checking\n@@ -701,7 +702,7 @@ pub impl CoherenceChecker {\n \n     fn trait_ref_to_trait_def_id(&self, trait_ref: @trait_ref) -> def_id {\n         let def_map = self.crate_context.tcx.def_map;\n-        let trait_def = *def_map.get(&trait_ref.ref_id);\n+        let trait_def = def_map.get_copy(&trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n         return trait_id;\n     }\n@@ -741,7 +742,7 @@ pub impl CoherenceChecker {\n                                               -> bool {\n         match original_type.node {\n             ty_path(_, path_id) => {\n-                match *self.crate_context.tcx.def_map.get(&path_id) {\n+                match self.crate_context.tcx.def_map.get_copy(&path_id) {\n                     def_ty(def_id) | def_struct(def_id) => {\n                         if def_id.crate != local_crate {\n                             return false;\n@@ -1003,7 +1004,7 @@ pub impl CoherenceChecker {\n     //\n \n     fn populate_destructor_table(&self) {\n-        let coherence_info = &mut self.crate_context.coherence_info;\n+        let coherence_info = self.crate_context.coherence_info;\n         let tcx = self.crate_context.tcx;\n         let drop_trait = tcx.lang_items.drop_trait();\n         let impls_opt = coherence_info.extension_methods.find(&drop_trait);"}, {"sha": "22850c16f943652722aefbd13f6b44568542f779", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -219,7 +219,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n {\n     let tcx = ccx.tcx;\n     let region_paramd = tcx.region_paramd_items.find(&trait_id).map(|&x| *x);\n-    match *tcx.items.get(&trait_id) {\n+    match tcx.items.get_copy(&trait_id) {\n         ast_map::node_item(@ast::item {\n             node: ast::item_trait(ref generics, _, ref ms),\n             _"}, {"sha": "3620b609edf3bb4764c27b60bc820be9584d90ab", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -65,7 +65,7 @@ we may want to adjust precisely when coercions occur.\n */\n \n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowFn};\n-use middle::ty::{AutoDerefRef, AutoRef};\n+use middle::ty::{AutoDerefRef};\n use middle::ty::{vstore_slice, vstore_box, vstore_uniq};\n use middle::ty::{mt};\n use middle::ty;\n@@ -120,9 +120,9 @@ pub impl Coerce {\n                 };\n             }\n \n-            ty::ty_ptr(_) => {\n+            ty::ty_ptr(mt_b) => {\n                 return do self.unpack_actual_value(a) |sty_a| {\n-                    self.coerce_unsafe_ptr(a, sty_a, b)\n+                    self.coerce_unsafe_ptr(a, sty_a, b, mt_b)\n                 };\n             }\n \n@@ -205,11 +205,7 @@ pub impl Coerce {\n         if_ok!(sub.tys(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 1,\n-            autoref: Some(AutoRef {\n-                kind: AutoPtr,\n-                region: r_borrow,\n-                mutbl: mt_b.mutbl\n-            })\n+            autoref: Some(AutoPtr(r_borrow, mt_b.mutbl))\n         })))\n     }\n \n@@ -235,11 +231,7 @@ pub impl Coerce {\n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n-            autoref: Some(AutoRef {\n-                kind: AutoBorrowVec,\n-                region: r_a,\n-                mutbl: m_imm\n-            })\n+            autoref: Some(AutoBorrowVec(r_a, m_imm))\n         })))\n     }\n \n@@ -268,11 +260,7 @@ pub impl Coerce {\n         if_ok!(sub.tys(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n-            autoref: Some(AutoRef {\n-                kind: AutoBorrowVec,\n-                region: r_borrow,\n-                mutbl: mt_b.mutbl\n-            })\n+            autoref: Some(AutoBorrowVec(r_borrow, mt_b.mutbl))\n         })))\n     }\n \n@@ -308,11 +296,7 @@ pub impl Coerce {\n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n-            autoref: Some(AutoRef {\n-                kind: AutoBorrowFn,\n-                region: r_borrow,\n-                mutbl: m_imm\n-            })\n+            autoref: Some(AutoBorrowFn(r_borrow))\n         })))\n     }\n \n@@ -363,7 +347,8 @@ pub impl Coerce {\n     fn coerce_unsafe_ptr(&self,\n                          a: ty::t,\n                          sty_a: &ty::sty,\n-                         b: ty::t) -> CoerceResult\n+                         b: ty::t,\n+                         mt_b: ty::mt) -> CoerceResult\n     {\n         debug!(\"coerce_unsafe_ptr(a=%s, sty_a=%?, b=%s)\",\n                a.inf_str(self.infcx), sty_a,\n@@ -376,10 +361,17 @@ pub impl Coerce {\n             }\n         };\n \n-        // borrowed pointers and unsafe pointers have the same\n-        // representation, so just check that the types which they\n-        // point at are compatible:\n+        // check that the types which they point at are compatible\n         let a_unsafe = ty::mk_ptr(self.infcx.tcx, mt_a);\n-        self.subtype(a_unsafe, b)\n+        if_ok!(self.subtype(a_unsafe, b));\n+\n+        // although borrowed ptrs and unsafe ptrs have the same\n+        // representation, we still register an AutoDerefRef so that\n+        // regionck knows that that the region for `a` must be valid\n+        // here\n+        Ok(Some(@AutoDerefRef(AutoDerefRef {\n+            autoderefs: 1,\n+            autoref: Some(ty::AutoUnsafe(mt_b.mutbl))\n+        })))\n     }\n }"}, {"sha": "c195454b5327635d9414cfaa9de76580a0e7396e", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -16,6 +16,7 @@ use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n+use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::isr_alist;\n use syntax::ast;\n use syntax::ast::{Many, Once, extern_fn, impure_fn, m_const, m_imm, m_mutbl};\n@@ -188,7 +189,8 @@ impl Combine for Glb {\n         let new_vars =\n             self.infcx.region_vars.vars_created_since_snapshot(snapshot);\n         let sig1 =\n-            self.infcx.fold_regions_in_sig(\n+            fold_regions_in_sig(\n+                self.infcx.tcx,\n                 &sig0,\n                 |r, _in_fn| generalize_region(self, snapshot,\n                                               new_vars, a_isr, a_vars, b_vars,"}, {"sha": "34e006c9615a7df04c490f38916036f48002f892", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -16,6 +16,7 @@ use middle::typeck::infer::lattice::*;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n+use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::isr_alist;\n use util::common::indent;\n use util::ppaux::mt_to_str;\n@@ -141,7 +142,8 @@ impl Combine for Lub {\n         let new_vars =\n             self.infcx.region_vars.vars_created_since_snapshot(snapshot);\n         let sig1 =\n-            self.infcx.fold_regions_in_sig(\n+            fold_regions_in_sig(\n+                self.infcx.tcx,\n                 &sig0,\n                 |r, _in_fn| generalize_region(self, snapshot, new_vars,\n                                               a_isr, r));"}, {"sha": "2e784b11c357ba7ee427612f04bd0e96449e3cb8", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 34, "deletions": 56, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -339,7 +339,7 @@ pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n \n fn new_ValsAndBindings<V:Copy,T:Copy>() -> ValsAndBindings<V, T> {\n     ValsAndBindings {\n-        vals: @mut SmallIntMap::new(),\n+        vals: SmallIntMap::new(),\n         bindings: ~[]\n     }\n }\n@@ -469,28 +469,6 @@ pub fn resolve_region(cx: @mut InferCtxt, r: ty::Region, modes: uint)\n     resolver.resolve_region_chk(r)\n }\n \n-/*\n-fn resolve_borrowings(cx: @mut InferCtxt) {\n-    for cx.borrowings.each |item| {\n-        match resolve_region(cx, item.scope, resolve_all|force_all) {\n-          Ok(region) => {\n-            debug!(\"borrowing for expr %d resolved to region %?, mutbl %?\",\n-                   item.expr_id, region, item.mutbl);\n-            cx.tcx.borrowings.insert(\n-                item.expr_id, {region: region, mutbl: item.mutbl});\n-          }\n-\n-          Err(e) => {\n-            let str = fixup_err_to_str(e);\n-            cx.tcx.sess.span_err(\n-                item.span,\n-                fmt!(\"could not resolve lifetime for borrow: %s\", str));\n-          }\n-        }\n-    }\n-}\n-*/\n-\n trait then {\n     fn then<T:Copy>(&self, f: &fn() -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err>;\n@@ -554,7 +532,8 @@ struct Snapshot {\n }\n \n pub impl InferCtxt {\n-    fn combine_fields(@mut self, a_is_expected: bool,\n+    fn combine_fields(@mut self,\n+                      a_is_expected: bool,\n                       span: span) -> CombineFields {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n@@ -565,25 +544,24 @@ pub impl InferCtxt {\n         Sub(self.combine_fields(a_is_expected, span))\n     }\n \n-    fn in_snapshot(@mut self) -> bool {\n+    fn in_snapshot(&self) -> bool {\n         self.region_vars.in_snapshot()\n     }\n \n-    fn start_snapshot(@mut self) -> Snapshot {\n-        let this = &mut *self;\n+    fn start_snapshot(&mut self) -> Snapshot {\n         Snapshot {\n             ty_var_bindings_len:\n-                this.ty_var_bindings.bindings.len(),\n+                self.ty_var_bindings.bindings.len(),\n             int_var_bindings_len:\n-                this.int_var_bindings.bindings.len(),\n+                self.int_var_bindings.bindings.len(),\n             float_var_bindings_len:\n-                this.float_var_bindings.bindings.len(),\n+                self.float_var_bindings.bindings.len(),\n             region_vars_snapshot:\n-                this.region_vars.start_snapshot(),\n+                self.region_vars.start_snapshot(),\n         }\n     }\n \n-    fn rollback_to(@mut self, snapshot: &Snapshot) {\n+    fn rollback_to(&mut self, snapshot: &Snapshot) {\n         debug!(\"rollback!\");\n         rollback_to(&mut self.ty_var_bindings, snapshot.ty_var_bindings_len);\n \n@@ -647,45 +625,47 @@ fn next_simple_var<V:Copy,T:Copy>(\n }\n \n pub impl InferCtxt {\n-    fn next_ty_var_id(@mut self) -> TyVid {\n+    fn next_ty_var_id(&mut self) -> TyVid {\n         let id = self.ty_var_counter;\n         self.ty_var_counter += 1;\n-        let vals = self.ty_var_bindings.vals;\n-        vals.insert(id, Root(Bounds { lb: None, ub: None }, 0u));\n+        {\n+            let vals = &mut self.ty_var_bindings.vals;\n+            vals.insert(id, Root(Bounds { lb: None, ub: None }, 0u));\n+        }\n         return TyVid(id);\n     }\n \n-    fn next_ty_var(@mut self) -> ty::t {\n+    fn next_ty_var(&mut self) -> ty::t {\n         ty::mk_var(self.tcx, self.next_ty_var_id())\n     }\n \n-    fn next_ty_vars(@mut self, n: uint) -> ~[ty::t] {\n+    fn next_ty_vars(&mut self, n: uint) -> ~[ty::t] {\n         vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n-    fn next_int_var_id(@mut self) -> IntVid {\n+    fn next_int_var_id(&mut self) -> IntVid {\n         IntVid(next_simple_var(&mut self.int_var_counter,\n                                &mut self.int_var_bindings))\n     }\n \n-    fn next_int_var(@mut self) -> ty::t {\n+    fn next_int_var(&mut self) -> ty::t {\n         ty::mk_int_var(self.tcx, self.next_int_var_id())\n     }\n \n-    fn next_float_var_id(@mut self) -> FloatVid {\n+    fn next_float_var_id(&mut self) -> FloatVid {\n         FloatVid(next_simple_var(&mut self.float_var_counter,\n                                  &mut self.float_var_bindings))\n     }\n \n-    fn next_float_var(@mut self) -> ty::t {\n+    fn next_float_var(&mut self) -> ty::t {\n         ty::mk_float_var(self.tcx, self.next_float_var_id())\n     }\n \n-    fn next_region_var_nb(@mut self, span: span) -> ty::Region {\n+    fn next_region_var_nb(&mut self, span: span) -> ty::Region {\n         ty::re_infer(ty::ReVar(self.region_vars.new_region_var(span)))\n     }\n \n-    fn next_region_var_with_lb(@mut self, span: span,\n+    fn next_region_var_with_lb(&mut self, span: span,\n                                lb_region: ty::Region) -> ty::Region {\n         let region_var = self.next_region_var_nb(span);\n \n@@ -697,12 +677,12 @@ pub impl InferCtxt {\n         return region_var;\n     }\n \n-    fn next_region_var(@mut self, span: span, scope_id: ast::node_id)\n+    fn next_region_var(&mut self, span: span, scope_id: ast::node_id)\n                       -> ty::Region {\n         self.next_region_var_with_lb(span, ty::re_scope(scope_id))\n     }\n \n-    fn resolve_regions(@mut self) {\n+    fn resolve_regions(&mut self) {\n         self.region_vars.resolve_regions();\n     }\n \n@@ -722,7 +702,6 @@ pub impl InferCtxt {\n           result::Err(_) => typ\n         }\n     }\n-\n     fn resolve_type_vars_in_trait_ref_if_possible(@mut self,\n                                                   trait_ref: &ty::TraitRef)\n         -> ty::TraitRef\n@@ -793,7 +772,7 @@ pub impl InferCtxt {\n         self.type_error_message(sp, mk_msg, a, Some(err));\n     }\n \n-    fn replace_bound_regions_with_fresh_regions(@mut self,\n+    fn replace_bound_regions_with_fresh_regions(&mut self,\n             span: span,\n             fsig: &ty::FnSig)\n          -> (ty::FnSig, isr_alist) {\n@@ -811,15 +790,14 @@ pub impl InferCtxt {\n             });\n         (fn_sig, isr)\n     }\n+}\n \n-    fn fold_regions_in_sig(\n-        @mut self,\n-        fn_sig: &ty::FnSig,\n-        fldr: &fn(r: ty::Region, in_fn: bool) -> ty::Region) -> ty::FnSig\n-    {\n-        do ty::fold_sig(fn_sig) |t| {\n-            ty::fold_regions(self.tcx, t, fldr)\n-        }\n+pub fn fold_regions_in_sig(\n+    tcx: ty::ctxt,\n+    fn_sig: &ty::FnSig,\n+    fldr: &fn(r: ty::Region, in_fn: bool) -> ty::Region) -> ty::FnSig\n+{\n+    do ty::fold_sig(fn_sig) |t| {\n+        ty::fold_regions(tcx, t, fldr)\n     }\n-\n }"}, {"sha": "a3b5369d22a34a15ac0b99e2cd3ae26b3e7d228e", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 150, "deletions": 103, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -24,7 +24,7 @@ it's worth spending more time on a more involved analysis.  Moreover,\n regions are a simpler case than types: they don't have aggregate\n structure, for example.\n \n-Unlike normal type inference, which is similar in spirit H-M and thus\n+Unlike normal type inference, which is similar in spirit to H-M and thus\n works progressively, the region type inference works by accumulating\n constraints over the course of a function.  Finally, at the end of\n processing a function, we process and solve the constraints all at\n@@ -130,7 +130,7 @@ of these variables can effectively be unified into a single variable.\n Once SCCs are removed, we are left with a DAG.  At this point, we can\n walk the DAG in toplogical order once to compute the expanding nodes,\n and again in reverse topological order to compute the contracting\n-nodes.The main reason I did not write it this way is that I did not\n+nodes. The main reason I did not write it this way is that I did not\n feel like implementing the SCC and toplogical sort algorithms at the\n moment.\n \n@@ -538,7 +538,7 @@ more convincing in the future.\n \n use middle::ty;\n use middle::ty::{FreeRegion, Region, RegionVid};\n-use middle::ty::{re_static, re_infer, re_free, re_bound};\n+use middle::ty::{re_empty, re_static, re_infer, re_free, re_bound};\n use middle::ty::{re_scope, ReVar, ReSkolemized, br_fresh};\n use middle::typeck::infer::cres;\n use util::common::indenter;\n@@ -547,6 +547,9 @@ use util::ppaux::note_and_explain_region;\n use core::cell::{Cell, empty_cell};\n use core::hashmap::{HashMap, HashSet};\n use core::to_bytes;\n+use core::uint;\n+use core::vec;\n+use core;\n use syntax::codemap::span;\n use syntax::ast;\n \n@@ -572,18 +575,12 @@ impl to_bytes::IterBytes for Constraint {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n struct TwoRegions {\n     a: Region,\n     b: Region,\n }\n \n-impl to_bytes::IterBytes for TwoRegions {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.a, &self.b, lsb0, f)\n-    }\n-}\n-\n enum UndoLogEntry {\n     Snapshot,\n     AddVar(RegionVid),\n@@ -637,7 +634,7 @@ pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n }\n \n pub impl RegionVarBindings {\n-    fn in_snapshot(&mut self) -> bool {\n+    fn in_snapshot(&self) -> bool {\n         self.undo_log.len() > 0\n     }\n \n@@ -832,7 +829,6 @@ pub impl RegionVarBindings {\n     }\n \n     fn resolve_var(&mut self, rid: RegionVid) -> ty::Region {\n-        debug!(\"RegionVarBindings: resolve_var(%?=%u)\", rid, rid.to_uint());\n         if self.values.is_empty() {\n             self.tcx.sess.span_bug(\n                 self.var_spans[rid.to_uint()],\n@@ -841,29 +837,14 @@ pub impl RegionVarBindings {\n         }\n \n         let v = self.values.with_ref(|values| values[rid.to_uint()]);\n+        debug!(\"RegionVarBindings: resolve_var(%?=%u)=%?\",\n+               rid, rid.to_uint(), v);\n         match v {\n             Value(r) => r,\n \n             NoValue => {\n-                // No constraints, report an error.  It is plausible\n-                // that we could select an arbitrary region here\n-                // instead.  At the moment I am not doing this because\n-                // this generally masks bugs in the inference\n-                // algorithm, and given our syntax one cannot create\n-                // generally create a lifetime variable that isn't\n-                // used in some type, and hence all lifetime variables\n-                // should ultimately have some bounds.\n-\n-                self.tcx.sess.span_err(\n-                    self.var_spans[rid.to_uint()],\n-                    fmt!(\"Unconstrained region variable #%u\", rid.to_uint()));\n-\n-                // Touch of a hack: to suppress duplicate messages,\n-                // replace the NoValue entry with ErrorValue.\n-                let mut values = self.values.take();\n-                values[rid.to_uint()] = ErrorValue;\n-                self.values.put_back(values);\n-                re_static\n+                // No constraints, return ty::re_empty\n+                re_empty\n             }\n \n             ErrorValue => {\n@@ -1031,6 +1012,10 @@ priv impl RegionVarBindings {\n             re_static // nothing lives longer than static\n           }\n \n+          (re_empty, r) | (r, re_empty) => {\n+            r // everything lives longer than empty\n+          }\n+\n           (re_infer(ReVar(v_id)), _) | (_, re_infer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n                 self.var_spans[v_id.to_uint()],\n@@ -1127,6 +1112,11 @@ priv impl RegionVarBindings {\n                 Ok(r)\n             }\n \n+            (re_empty, _) | (_, re_empty) => {\n+                // nothing lives shorter than everything else\n+                Ok(re_empty)\n+            }\n+\n             (re_infer(ReVar(v_id)), _) |\n             (_, re_infer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n@@ -1266,8 +1256,6 @@ struct SpannedRegion {\n     span: span,\n }\n \n-type TwoRegionsMap = HashSet<TwoRegions>;\n-\n pub impl RegionVarBindings {\n     fn infer_variable_values(&mut self) -> ~[GraphNodeValue] {\n         let mut graph = self.construct_graph();\n@@ -1329,11 +1317,15 @@ pub impl RegionVarBindings {\n                        node_id: RegionVid,\n                        edge_dir: Direction,\n                        edge_idx: uint) {\n+            //! Insert edge `edge_idx` on the link list of edges in direction\n+            //! `edge_dir` for the node `node_id`\n             let edge_dir = edge_dir as uint;\n-            graph.edges[edge_idx].next_edge[edge_dir] =\n-                graph.nodes[node_id.to_uint()].head_edge[edge_dir];\n-            graph.nodes[node_id.to_uint()].head_edge[edge_dir] =\n-                edge_idx;\n+            assert_eq!(graph.edges[edge_idx].next_edge[edge_dir],\n+                       uint::max_value);\n+            let n = node_id.to_uint();\n+            let prev_head = graph.nodes[n].head_edge[edge_dir];\n+            graph.edges[edge_idx].next_edge[edge_dir] = prev_head;\n+            graph.nodes[n].head_edge[edge_dir] = edge_idx;\n         }\n     }\n \n@@ -1484,6 +1476,8 @@ pub impl RegionVarBindings {\n                     }\n                 }\n                 Err(_) => {\n+                    debug!(\"Setting %? to ErrorValue: no glb of %?, %?\",\n+                           a_vid, a_region, b_region);\n                     a_node.value = ErrorValue;\n                     false\n                 }\n@@ -1495,7 +1489,21 @@ pub impl RegionVarBindings {\n         &mut self,\n         graph: &Graph) -> ~[GraphNodeValue]\n     {\n-        let mut dup_map = HashSet::new();\n+        debug!(\"extract_values_and_report_conflicts()\");\n+\n+        // This is the best way that I have found to suppress\n+        // duplicate and related errors. Basically we keep a set of\n+        // flags for every node. Whenever an error occurs, we will\n+        // walk some portion of the graph looking to find pairs of\n+        // conflicting regions to report to the user. As we walk, we\n+        // trip the flags from false to true, and if we find that\n+        // we've already reported an error involving any particular\n+        // node we just stop and don't report the current error.  The\n+        // idea is to report errors that derive from independent\n+        // regions of the graph, but not those that derive from\n+        // overlapping locations.\n+        let mut dup_vec = graph.nodes.map(|_| uint::max_value);\n+\n         graph.nodes.mapi(|idx, node| {\n             match node.value {\n                 Value(_) => {\n@@ -1530,15 +1538,16 @@ pub impl RegionVarBindings {\n                        that is not used is not a problem, so if this rule\n                        starts to create problems we'll have to revisit\n                        this portion of the code and think hard about it. =) */\n+\n                     let node_vid = RegionVid { id: idx };\n                     match node.classification {\n                         Expanding => {\n                             self.report_error_for_expanding_node(\n-                                graph, &mut dup_map, node_vid);\n+                                graph, dup_vec, node_vid);\n                         }\n                         Contracting => {\n                             self.report_error_for_contracting_node(\n-                                graph, &mut dup_map, node_vid);\n+                                graph, dup_vec, node_vid);\n                         }\n                     }\n                 }\n@@ -1548,38 +1557,26 @@ pub impl RegionVarBindings {\n         })\n     }\n \n-    // Used to suppress reporting the same basic error over and over\n-    fn is_reported(&mut self,\n-                   dup_map: &mut TwoRegionsMap,\n-                   r_a: Region,\n-                   r_b: Region)\n-                -> bool {\n-        let key = TwoRegions { a: r_a, b: r_b };\n-        !dup_map.insert(key)\n-    }\n-\n     fn report_error_for_expanding_node(&mut self,\n                                        graph: &Graph,\n-                                       dup_map: &mut TwoRegionsMap,\n+                                       dup_vec: &mut [uint],\n                                        node_idx: RegionVid) {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n-        let lower_bounds =\n-            self.collect_concrete_regions(graph, node_idx, Incoming);\n-        let upper_bounds =\n-            self.collect_concrete_regions(graph, node_idx, Outgoing);\n+        let (lower_bounds, lower_dup) =\n+            self.collect_concrete_regions(graph, node_idx, Incoming, dup_vec);\n+        let (upper_bounds, upper_dup) =\n+            self.collect_concrete_regions(graph, node_idx, Outgoing, dup_vec);\n+\n+        if lower_dup || upper_dup {\n+            return;\n+        }\n \n         for vec::each(lower_bounds) |lower_bound| {\n             for vec::each(upper_bounds) |upper_bound| {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n \n-                    if self.is_reported(dup_map,\n-                                        lower_bound.region,\n-                                        upper_bound.region) {\n-                        return;\n-                    }\n-\n                     self.tcx.sess.span_err(\n                         self.var_spans[node_idx.to_uint()],\n                         fmt!(\"cannot infer an appropriate lifetime \\\n@@ -1609,16 +1606,28 @@ pub impl RegionVarBindings {\n                 }\n             }\n         }\n+\n+        self.tcx.sess.span_bug(\n+            self.var_spans[node_idx.to_uint()],\n+            fmt!(\"report_error_for_expanding_node() could not find error \\\n+                  for var %?, lower_bounds=%s, upper_bounds=%s\",\n+                 node_idx,\n+                 lower_bounds.map(|x| x.region).repr(self.tcx),\n+                 upper_bounds.map(|x| x.region).repr(self.tcx)));\n     }\n \n     fn report_error_for_contracting_node(&mut self,\n                                          graph: &Graph,\n-                                         dup_map: &mut TwoRegionsMap,\n+                                         dup_vec: &mut [uint],\n                                          node_idx: RegionVid) {\n         // Errors in contracting nodes result from two upper-bounds\n         // that have no intersection.\n-        let upper_bounds = self.collect_concrete_regions(graph, node_idx,\n-                                                         Outgoing);\n+        let (upper_bounds, dup_found) =\n+            self.collect_concrete_regions(graph, node_idx, Outgoing, dup_vec);\n+\n+        if dup_found {\n+            return;\n+        }\n \n         for vec::each(upper_bounds) |upper_bound_1| {\n             for vec::each(upper_bounds) |upper_bound_2| {\n@@ -1627,12 +1636,6 @@ pub impl RegionVarBindings {\n                   Ok(_) => {}\n                   Err(_) => {\n \n-                    if self.is_reported(dup_map,\n-                                        upper_bound_1.region,\n-                                        upper_bound_2.region) {\n-                        return;\n-                    }\n-\n                     self.tcx.sess.span_err(\n                         self.var_spans[node_idx.to_uint()],\n                         fmt!(\"cannot infer an appropriate lifetime \\\n@@ -1663,50 +1666,94 @@ pub impl RegionVarBindings {\n                 }\n             }\n         }\n+\n+        self.tcx.sess.span_bug(\n+            self.var_spans[node_idx.to_uint()],\n+            fmt!(\"report_error_for_contracting_node() could not find error \\\n+                  for var %?, upper_bounds=%s\",\n+                 node_idx,\n+                 upper_bounds.map(|x| x.region).repr(self.tcx)));\n     }\n \n     fn collect_concrete_regions(&mut self,\n                                 graph: &Graph,\n                                 orig_node_idx: RegionVid,\n-                                dir: Direction)\n-                             -> ~[SpannedRegion] {\n-        let mut set = HashSet::new();\n-        let mut stack = ~[orig_node_idx];\n-        set.insert(orig_node_idx.to_uint());\n-        let mut result = ~[];\n-        while !vec::is_empty(stack) {\n-            let node_idx = stack.pop();\n-            for self.each_edge(graph, node_idx, dir) |edge| {\n+                                dir: Direction,\n+                                dup_vec: &mut [uint])\n+                             -> (~[SpannedRegion], bool) {\n+        struct WalkState {\n+            set: HashSet<RegionVid>,\n+            stack: ~[RegionVid],\n+            result: ~[SpannedRegion],\n+            dup_found: bool\n+        }\n+        let mut state = WalkState {\n+            set: HashSet::new(),\n+            stack: ~[orig_node_idx],\n+            result: ~[],\n+            dup_found: false\n+        };\n+        state.set.insert(orig_node_idx);\n+\n+        // to start off the process, walk the source node in the\n+        // direction specified\n+        process_edges(self, &mut state, graph, orig_node_idx, dir);\n+\n+        while !state.stack.is_empty() {\n+            let node_idx = state.stack.pop();\n+            let classification = graph.nodes[node_idx.to_uint()].classification;\n+\n+            // check whether we've visited this node on some previous walk\n+            if dup_vec[node_idx.to_uint()] == uint::max_value {\n+                dup_vec[node_idx.to_uint()] = orig_node_idx.to_uint();\n+            } else if dup_vec[node_idx.to_uint()] != orig_node_idx.to_uint() {\n+                state.dup_found = true;\n+            }\n+\n+            debug!(\"collect_concrete_regions(orig_node_idx=%?, node_idx=%?, \\\n+                    classification=%?)\",\n+                   orig_node_idx, node_idx, classification);\n+\n+            // figure out the direction from which this node takes its\n+            // values, and search for concrete regions etc in that direction\n+            let dir = match classification {\n+                Expanding => Incoming,\n+                Contracting => Outgoing\n+            };\n+\n+            process_edges(self, &mut state, graph, node_idx, dir);\n+        }\n+\n+        let WalkState {result, dup_found, _} = state;\n+        return (result, dup_found);\n+\n+        fn process_edges(self: &mut RegionVarBindings,\n+                         state: &mut WalkState,\n+                         graph: &Graph,\n+                         source_vid: RegionVid,\n+                         dir: Direction) {\n+            debug!(\"process_edges(source_vid=%?, dir=%?)\", source_vid, dir);\n+\n+            for self.each_edge(graph, source_vid, dir) |edge| {\n                 match edge.constraint {\n-                  ConstrainVarSubVar(from_vid, to_vid) => {\n-                    let vid = match dir {\n-                      Incoming => from_vid,\n-                      Outgoing => to_vid\n-                    };\n-                    if set.insert(vid.to_uint()) {\n-                        stack.push(vid);\n+                    ConstrainVarSubVar(from_vid, to_vid) => {\n+                        let opp_vid =\n+                            if from_vid == source_vid {to_vid} else {from_vid};\n+                        if state.set.insert(opp_vid) {\n+                            state.stack.push(opp_vid);\n+                        }\n                     }\n-                  }\n-\n-                  ConstrainRegSubVar(region, _) => {\n-                    assert!(dir == Incoming);\n-                    result.push(SpannedRegion {\n-                        region: region,\n-                        span: edge.span\n-                    });\n-                  }\n \n-                  ConstrainVarSubReg(_, region) => {\n-                    assert!(dir == Outgoing);\n-                    result.push(SpannedRegion {\n-                        region: region,\n-                        span: edge.span\n-                    });\n-                  }\n+                    ConstrainRegSubVar(region, _) |\n+                    ConstrainVarSubReg(_, region) => {\n+                        state.result.push(SpannedRegion {\n+                            region: region,\n+                            span: edge.span\n+                        });\n+                    }\n                 }\n             }\n         }\n-        return result;\n     }\n \n     fn each_edge(&mut self,"}, {"sha": "3bcff92346566b766c675a43f790ccd69dd23913", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -23,7 +23,7 @@ pub enum VarValue<V, T> {\n }\n \n pub struct ValsAndBindings<V, T> {\n-    vals: @mut SmallIntMap<VarValue<V, T>>,\n+    vals: SmallIntMap<VarValue<V, T>>,\n     bindings: ~[(V, VarValue<V, T>)],\n }\n \n@@ -60,26 +60,25 @@ pub impl InferCtxt {\n             vid: V) -> Node<V, T>\n         {\n             let vid_u = vid.to_uint();\n-            match vb.vals.find(&vid_u) {\n+            let var_val = match vb.vals.find(&vid_u) {\n+                Some(&var_val) => var_val,\n                 None => {\n                     tcx.sess.bug(fmt!(\n                         \"failed lookup of vid `%u`\", vid_u));\n                 }\n-                Some(var_val) => {\n-                    match *var_val {\n-                        Redirect(vid) => {\n-                            let node: Node<V,T> = helper(tcx, vb, vid);\n-                            if node.root != vid {\n-                                // Path compression\n-                                vb.vals.insert(vid.to_uint(),\n-                                               Redirect(node.root));\n-                            }\n-                            node\n-                        }\n-                        Root(ref pt, rk) => {\n-                            Node {root: vid, possible_types: *pt, rank: rk}\n-                        }\n+            };\n+            match var_val {\n+                Redirect(vid) => {\n+                    let node: Node<V,T> = helper(tcx, vb, vid);\n+                    if node.root != vid {\n+                        // Path compression\n+                        vb.vals.insert(vid.to_uint(),\n+                                       Redirect(node.root));\n                     }\n+                    node\n+                }\n+                Root(pt, rk) => {\n+                    Node {root: vid, possible_types: pt, rank: rk}\n                 }\n             }\n         }\n@@ -99,8 +98,8 @@ pub impl InferCtxt {\n \n         { // FIXME(#4903)---borrow checker is not flow sensitive\n             let vb = UnifyVid::appropriate_vals_and_bindings(self);\n-            let old_v = vb.vals.get(&vid.to_uint());\n-            vb.bindings.push((vid, *old_v));\n+            let old_v = { *vb.vals.get(&vid.to_uint()) }; // FIXME(#4903)\n+            vb.bindings.push((vid, old_v));\n             vb.vals.insert(vid.to_uint(), new_v);\n         }\n     }"}, {"sha": "1a152f3c29119ea75680f4a3abe776ba61f33fd0", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -414,7 +414,11 @@ pub fn check_crate(tcx: ty::ctxt,\n     time(time_passes, ~\"type collecting\", ||\n         collect::collect_item_types(ccx, crate));\n \n-    time(time_passes, ~\"method resolution\", ||\n+    // this ensures that later parts of type checking can assume that items\n+    // have valid types and not error\n+    tcx.sess.abort_if_errors();\n+\n+    time(time_passes, ~\"coherence checking\", ||\n         coherence::check_coherence(ccx, crate));\n \n     time(time_passes, ~\"type checking\", ||"}, {"sha": "f8a19eaf374cb081504ffa74eddb352eef9e1ece", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -46,6 +46,7 @@ pub mod middle {\n         pub mod controlflow;\n         pub mod glue;\n         pub mod datum;\n+        pub mod write_guard;\n         pub mod callee;\n         pub mod expr;\n         pub mod common;\n@@ -75,6 +76,9 @@ pub mod middle {\n     }\n     pub mod ty;\n     pub mod subst;\n+    #[cfg(stage0)] #[path = \"resolve_stage0.rs\"]\n+    pub mod resolve;\n+    #[cfg(not(stage0))]\n     pub mod resolve;\n     #[path = \"typeck/mod.rs\"]\n     pub mod typeck;\n@@ -84,6 +88,7 @@ pub mod middle {\n     pub mod lint;\n     #[path = \"borrowck/mod.rs\"]\n     pub mod borrowck;\n+    pub mod dataflow;\n     pub mod mem_categorization;\n     pub mod liveness;\n     pub mod kind;"}, {"sha": "59a0a1ba3d611ed1238f9a9a75e2bba89c0c9c1b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -13,7 +13,8 @@ use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid};\n use middle::ty::{br_fresh, ctxt, field, method};\n use middle::ty::{mt, t, param_bound, param_ty};\n-use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region};\n+use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region,\n+                 re_empty};\n use middle::ty::{ty_bool, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_bare_fn, ty_closure};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n@@ -65,6 +66,9 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n           Some(&ast_map::node_block(ref blk)) => {\n             explain_span(cx, \"block\", blk.span)\n           }\n+          Some(&ast_map::node_callee_scope(expr)) => {\n+              explain_span(cx, \"callee\", expr.span)\n+          }\n           Some(&ast_map::node_expr(expr)) => {\n             match expr.node {\n               ast::expr_call(*) => explain_span(cx, \"call\", expr.span),\n@@ -113,6 +117,8 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n \n       re_static => { (~\"the static lifetime\", None) }\n \n+      re_empty => { (~\"the empty lifetime\", None) }\n+\n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n       re_infer(_) | re_bound(_) => {\n@@ -212,7 +218,8 @@ pub fn region_to_str_space(cx: ctxt, prefix: &str, region: Region) -> ~str {\n             bound_region_to_str_space(cx, prefix, br)\n         }\n         re_infer(ReVar(_)) => prefix.to_str(),\n-        re_static => fmt!(\"%s'static \", prefix)\n+        re_static => fmt!(\"%s'static \", prefix),\n+        re_empty => fmt!(\"%s'<empty> \", prefix)\n     }\n }\n \n@@ -739,3 +746,12 @@ impl Repr for ty::vstore {\n         vstore_to_str(tcx, *self)\n     }\n }\n+\n+impl Repr for ast_map::path_elt {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        match *self {\n+            ast_map::path_mod(id) => id.repr(tcx),\n+            ast_map::path_name(id) => id.repr(tcx)\n+        }\n+    }\n+}"}, {"sha": "98d7a01b928b071b688e45f631ebfd229b2291ba", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -419,26 +419,26 @@ pub struct RWReadMode<'self, T> {\n \n pub impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n     /// Access the pre-downgrade RWARC in write mode.\n-    fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n+    fn write<U>(&mut self, blk: &fn(x: &mut T) -> U) -> U {\n         match *self {\n             RWWriteMode {\n-                data: ref data,\n+                data: &ref mut data,\n                 token: ref token,\n                 poison: _\n             } => {\n                 do token.write {\n-                    blk(&mut **data)\n+                    blk(data)\n                 }\n             }\n         }\n     }\n     /// Access the pre-downgrade RWARC in write mode with a condvar.\n-    fn write_cond<'x, 'c, U>(&self,\n+    fn write_cond<'x, 'c, U>(&mut self,\n                              blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n                           -> U {\n         match *self {\n             RWWriteMode {\n-                data: ref data,\n+                data: &ref mut data,\n                 token: ref token,\n                 poison: ref poison\n             } => {\n@@ -449,7 +449,7 @@ pub impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n                             failed: &mut *poison.failed,\n                             cond: cond\n                         };\n-                        blk(&mut **data, &cvar)\n+                        blk(data, &cvar)\n                     }\n                 }\n             }\n@@ -598,8 +598,8 @@ mod tests {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n-            do arc2.write_downgrade |write_mode| {\n-                do (&write_mode).write |one| {\n+            do arc2.write_downgrade |mut write_mode| {\n+                do write_mode.write |one| {\n                     assert!(*one == 2);\n                 }\n             }\n@@ -733,8 +733,8 @@ mod tests {\n         }\n \n         // Downgrader (us)\n-        do arc.write_downgrade |write_mode| {\n-            do (&write_mode).write_cond |state, cond| {\n+        do arc.write_downgrade |mut write_mode| {\n+            do write_mode.write_cond |state, cond| {\n                 wc1.send(()); // send to another writer who will wake us up\n                 while *state == 0 {\n                     cond.wait();"}, {"sha": "da882d53fcffacc5a5c7869f0a7503ba033e7312", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -315,9 +315,6 @@ fn test_arena_destructors_fail() {\n     }\n     // Now, fail while allocating\n     do arena.alloc::<@int> {\n-        // First, recursively allocate something else; that needs to\n-        // get freed too.\n-        do arena.alloc { @20 };\n         // Now fail.\n         fail!();\n     };"}, {"sha": "ceb67fcabfa5b619f9da484db367df21ee11f071", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -215,16 +215,16 @@ pub struct Bitv {\n     nbits: uint\n }\n \n-priv impl Bitv {\n+fn die() -> ! {\n+    fail!(~\"Tried to do operation on bit vectors with different sizes\");\n+}\n \n-    fn die(&self) -> ! {\n-        fail!(~\"Tried to do operation on bit vectors with different sizes\");\n-    }\n+priv impl Bitv {\n \n     #[inline(always)]\n     fn do_op(&mut self, op: Op, other: &Bitv) -> bool {\n         if self.nbits != other.nbits {\n-            self.die();\n+            die();\n         }\n         match self.rep {\n           Small(ref mut s) => match other.rep {\n@@ -234,10 +234,10 @@ priv impl Bitv {\n               Assign     => s.become(*s1,     self.nbits),\n               Difference => s.difference(*s1, self.nbits)\n             },\n-            Big(_) => self.die()\n+            Big(_) => die()\n           },\n           Big(ref mut s) => match other.rep {\n-            Small(_) => self.die(),\n+            Small(_) => die(),\n             Big(ref s1) => match op {\n               Union      => s.union(*s1,      self.nbits),\n               Intersect  => s.intersect(*s1,  self.nbits),"}, {"sha": "864a49a14294fb1096d1a8f7e8abcdad50f85b54", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -735,7 +735,7 @@ pub mod writer {\n     priv impl Encoder {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) {\n-            assert!(v <= 0xFFFF_FFFF_u);\n+            assert!(v <= 0xFFFF_FFFF_u); // FIXME(#6130) assert warns on 32-bit\n             self.wr_tagged_u32(t as uint, v as u32);\n         }\n "}, {"sha": "53eb6c5561b682b6c4eb6685d8c69419442247a4", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -883,8 +883,8 @@ impl io::Reader for TcpSocketBuf {\n                     let ncopy = uint::min(nbuffered, needed);\n                     let dst = ptr::mut_offset(\n                         vec::raw::to_mut_ptr(buf), count);\n-                    let src = ptr::const_offset(\n-                        vec::raw::to_const_ptr(self.data.buf),\n+                    let src = ptr::offset(\n+                        vec::raw::to_ptr(self.data.buf),\n                         self.data.buf_off);\n                     ptr::copy_memory(dst, src, ncopy);\n                     self.data.buf_off += ncopy;\n@@ -967,7 +967,7 @@ impl io::Reader for TcpSocketBuf {\n \n /// Implementation of `io::Reader` trait for a buffered `net::tcp::TcpSocket`\n impl io::Writer for TcpSocketBuf {\n-    pub fn write(&self, data: &const [u8]) {\n+    pub fn write(&self, data: &[u8]) {\n         unsafe {\n             let socket_data_ptr: *TcpSocketData =\n                 &(*((*(self.data)).sock).socket_data);"}, {"sha": "93364f8a319ee8ea979ec5be2ece8eac5e616a32", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -1256,22 +1256,24 @@ mod tests {\n         match (r) {\n           node::Empty => return ~\"\",\n           node::Content(x) => {\n-            let str = @mut ~\"\";\n-            fn aux(str: @mut ~str, node: @node::Node) {\n+            let mut str = ~\"\";\n+            fn aux(str: &mut ~str, node: @node::Node) {\n                 match (*node) {\n-                  node::Leaf(x) => {\n-                    *str += str::slice(\n-                        *x.content, x.byte_offset,\n-                        x.byte_offset + x.byte_len).to_owned();\n-                  }\n-                  node::Concat(ref x) => {\n-                    aux(str, x.left);\n-                    aux(str, x.right);\n-                  }\n+                    node::Leaf(x) => {\n+                        str::push_str(\n+                            str,\n+                            str::slice(\n+                                *x.content, x.byte_offset,\n+                                x.byte_offset + x.byte_len));\n+                    }\n+                    node::Concat(ref x) => {\n+                        aux(str, x.left);\n+                        aux(str, x.right);\n+                    }\n                 }\n             }\n-            aux(str, x);\n-            return *str\n+            aux(&mut str, x);\n+            return str\n           }\n         }\n     }"}, {"sha": "a18e2f47a7721b81b7db3ae0f362ee6e2b0b47f2", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 95, "deletions": 61, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -11,7 +11,6 @@\n //! Sorting methods\n \n use core::cmp::{Eq, Ord};\n-use core::util;\n use core::vec::len;\n use core::vec;\n \n@@ -23,12 +22,12 @@ type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n  * Has worst case O(n log n) performance, best case O(n), but\n  * is not space efficient. This is a stable sort.\n  */\n-pub fn merge_sort<T:Copy>(v: &const [T], le: Le<T>) -> ~[T] {\n+pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n     type Slice = (uint, uint);\n \n     return merge_sort_(v, (0u, len(v)), le);\n \n-    fn merge_sort_<T:Copy>(v: &const [T], slice: Slice, le: Le<T>)\n+    fn merge_sort_<T:Copy>(v: &[T], slice: Slice, le: Le<T>)\n         -> ~[T] {\n         let begin = slice.first();\n         let end = slice.second();\n@@ -61,6 +60,7 @@ pub fn merge_sort<T:Copy>(v: &const [T], le: Le<T>) -> ~[T] {\n     }\n }\n \n+#[cfg(stage0)]\n fn part<T>(arr: &mut [T], left: uint,\n            right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n     arr[pivot] <-> arr[right];\n@@ -79,6 +79,23 @@ fn part<T>(arr: &mut [T], left: uint,\n     return storage_index;\n }\n \n+#[cfg(not(stage0))]\n+fn part<T>(arr: &mut [T], left: uint,\n+           right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n+    arr[pivot] <-> arr[right];\n+    let mut storage_index: uint = left;\n+    let mut i: uint = left;\n+    while i < right {\n+        if compare_func(&arr[i], &arr[right]) {\n+            arr[i] <-> arr[storage_index];\n+            storage_index += 1;\n+        }\n+        i += 1;\n+    }\n+    arr[storage_index] <-> arr[right];\n+    return storage_index;\n+}\n+\n fn qsort<T>(arr: &mut [T], left: uint,\n             right: uint, compare_func: Le<T>) {\n     if right > left {\n@@ -162,7 +179,8 @@ fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n  */\n pub fn quick_sort3<T:Copy + Ord + Eq>(arr: &mut [T]) {\n     if arr.len() <= 1 { return; }\n-    qsort3(arr, 0, (arr.len() - 1) as int);\n+    let len = arr.len(); // FIXME(#5074) nested calls\n+    qsort3(arr, 0, (len - 1) as int);\n }\n \n pub trait Sort {\n@@ -195,15 +213,20 @@ pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n     let mut idx = 0;\n     let mut remaining = size;\n     loop {\n-        let arr = vec::mut_slice(array, idx, size);\n-        let mut run_len: uint = count_run_ascending(arr);\n-\n-        if run_len < min_run {\n-            let force = if remaining <= min_run {remaining} else {min_run};\n-            let slice = vec::mut_slice(arr, 0, force);\n-            binarysort(slice, run_len);\n-            run_len = force;\n-        }\n+        let run_len: uint = {\n+            // This scope contains the slice `arr` here:\n+            let arr = vec::mut_slice(array, idx, size);\n+            let mut run_len: uint = count_run_ascending(arr);\n+\n+            if run_len < min_run {\n+                let force = if remaining <= min_run {remaining} else {min_run};\n+                let slice = vec::mut_slice(arr, 0, force);\n+                binarysort(slice, run_len);\n+                run_len = force;\n+            }\n+\n+            run_len\n+        };\n \n         ms.push_run(idx, run_len);\n         ms.merge_collapse(array);\n@@ -240,7 +263,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n         assert!(left == right);\n         let n = start-left;\n \n-        copy_vec(array, left+1, array, left, n);\n+        shift_vec(array, left+1, left, n);\n         array[left] = pivot;\n         start += 1;\n     }\n@@ -250,7 +273,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n     let mut i = start;\n     while i < end / 2 {\n-        util::swap(&mut v[i], &mut v[end - i - 1]);\n+        v[i] <-> v[end - i - 1];\n         i += 1;\n     }\n }\n@@ -286,8 +309,8 @@ fn count_run_ascending<T:Copy + Ord>(array: &mut [T]) -> uint {\n     return run;\n }\n \n-fn gallop_left<T:Copy + Ord>(key: &const T,\n-                             array: &const [T],\n+fn gallop_left<T:Copy + Ord>(key: &T,\n+                             array: &[T],\n                              hint: uint)\n                           -> uint {\n     let size = array.len();\n@@ -337,8 +360,8 @@ fn gallop_left<T:Copy + Ord>(key: &const T,\n     return ofs;\n }\n \n-fn gallop_right<T:Copy + Ord>(key: &const T,\n-                              array: &const [T],\n+fn gallop_right<T:Copy + Ord>(key: &T,\n+                              array: &[T],\n                               hint: uint)\n                            -> uint {\n     let size = array.len();\n@@ -433,14 +456,17 @@ impl<T:Copy + Ord> MergeState<T> {\n             self.runs[n+1].len = self.runs[n+2].len;\n         }\n \n-        let slice = vec::mut_slice(array, b1, b1+l1);\n-        let k = gallop_right(&const array[b2], slice, 0);\n+        let k = { // constrain lifetime of slice below\n+            let slice = vec::slice(array, b1, b1+l1);\n+            gallop_right(&array[b2], slice, 0)\n+        };\n         b1 += k;\n         l1 -= k;\n         if l1 != 0 {\n-            let slice = vec::mut_slice(array, b2, b2+l2);\n-            let l2 = gallop_left(\n-                &const array[b1+l1-1],slice,l2-1);\n+            let l2 = { // constrain lifetime of slice below\n+                let slice = vec::slice(array, b2, b2+l2);\n+                gallop_left(&array[b1+l1-1],slice,l2-1)\n+            };\n             if l2 > 0 {\n                 if l1 <= l2 {\n                     self.merge_lo(array, b1, l1, b2, l2);\n@@ -471,11 +497,11 @@ impl<T:Copy + Ord> MergeState<T> {\n         dest += 1; c2 += 1; len2 -= 1;\n \n         if len2 == 0 {\n-            copy_vec(array, dest, tmp, 0, len1);\n+            copy_vec(array, dest, tmp.slice(0, len1));\n             return;\n         }\n         if len1 == 1 {\n-            copy_vec(array, dest, array, c2, len2);\n+            shift_vec(array, dest, c2, len2);\n             array[dest+len2] <-> tmp[c1];\n             return;\n         }\n@@ -513,21 +539,25 @@ impl<T:Copy + Ord> MergeState<T> {\n             loop {\n                 assert!(len1 > 1 && len2 != 0);\n \n-                let tmp_view = vec::const_slice(tmp, c1, c1+len1);\n-                count1 = gallop_right(&const array[c2], tmp_view, 0);\n+                count1 = {\n+                    let tmp_view = vec::slice(tmp, c1, c1+len1);\n+                    gallop_right(&array[c2], tmp_view, 0)\n+                };\n                 if count1 != 0 {\n-                    copy_vec(array, dest, tmp, c1, count1);\n+                    copy_vec(array, dest, tmp.slice(c1, c1+count1));\n                     dest += count1; c1 += count1; len1 -= count1;\n                     if len1 <= 1 { break_outer = true; break; }\n                 }\n                 array[dest] <-> array[c2];\n                 dest += 1; c2 += 1; len2 -= 1;\n                 if len2 == 0 { break_outer = true; break; }\n \n-                let tmp_view = vec::const_slice(array, c2, c2+len2);\n-                count2 = gallop_left(&const tmp[c1], tmp_view, 0);\n+                count2 = {\n+                    let tmp_view = vec::slice(array, c2, c2+len2);\n+                    gallop_left(&tmp[c1], tmp_view, 0)\n+                };\n                 if count2 != 0 {\n-                    copy_vec(array, dest, array, c2, count2);\n+                    shift_vec(array, dest, c2, count2);\n                     dest += count2; c2 += count2; len2 -= count2;\n                     if len2 == 0 { break_outer = true; break; }\n                 }\n@@ -547,14 +577,14 @@ impl<T:Copy + Ord> MergeState<T> {\n \n         if len1 == 1 {\n             assert!(len2 > 0);\n-            copy_vec(array, dest, array, c2, len2);\n+            shift_vec(array, dest, c2, len2);\n             array[dest+len2] <-> tmp[c1];\n         } else if len1 == 0 {\n             fail!(~\"Comparison violates its contract!\");\n         } else {\n             assert!(len2 == 0);\n             assert!(len1 > 1);\n-            copy_vec(array, dest, tmp, c1, len1);\n+            copy_vec(array, dest, tmp.slice(c1, c1+len1));\n         }\n     }\n \n@@ -577,13 +607,13 @@ impl<T:Copy + Ord> MergeState<T> {\n         dest -= 1; c1 -= 1; len1 -= 1;\n \n         if len1 == 0 {\n-            copy_vec(array, dest-(len2-1), tmp, 0, len2);\n+            copy_vec(array, dest-(len2-1), tmp.slice(0, len2));\n             return;\n         }\n         if len2 == 1 {\n             dest -= len1;\n             c1 -= len1;\n-            copy_vec(array, dest+1, array, c1+1, len1);\n+            shift_vec(array, dest+1, c1+1, len1);\n             array[dest] <-> tmp[c2];\n             return;\n         }\n@@ -621,13 +651,15 @@ impl<T:Copy + Ord> MergeState<T> {\n             loop {\n                 assert!(len2 > 1 && len1 != 0);\n \n-                let tmp_view = vec::mut_slice(array, base1, base1+len1);\n-                count1 = len1 - gallop_right(\n-                    &const tmp[c2], tmp_view, len1-1);\n+                { // constrain scope of tmp_view:\n+                    let tmp_view = vec::mut_slice (array, base1, base1+len1);\n+                    count1 = len1 - gallop_right(\n+                        &tmp[c2], tmp_view, len1-1);\n+                }\n \n                 if count1 != 0 {\n                     dest -= count1; c1 -= count1; len1 -= count1;\n-                    copy_vec(array, dest+1, array, c1+1, count1);\n+                    shift_vec(array, dest+1, c1+1, count1);\n                     if len1 == 0 { break_outer = true; break; }\n                 }\n \n@@ -636,17 +668,16 @@ impl<T:Copy + Ord> MergeState<T> {\n                 if len2 == 1 { break_outer = true; break; }\n \n                 let count2;\n-                {\n+                { // constrain scope of tmp_view\n                     let tmp_view = vec::mut_slice(tmp, 0, len2);\n-                    count2 = len2 - gallop_left(&const array[c1],\n+                    count2 = len2 - gallop_left(&array[c1],\n                                                 tmp_view,\n                                                 len2-1);\n-                    // Make tmp_view go out of scope to appease borrowck.\n                 }\n \n                 if count2 != 0 {\n                     dest -= count2; c2 -= count2; len2 -= count2;\n-                    copy_vec(array, dest+1, tmp, c2+1, count2);\n+                    copy_vec(array, dest+1, tmp.slice(c2+1, c2+1+count2));\n                     if len2 <= 1 { break_outer = true; break; }\n                 }\n                 array[dest] <-> array[c1];\n@@ -668,14 +699,14 @@ impl<T:Copy + Ord> MergeState<T> {\n             assert!(len1 > 0);\n             dest -= len1;\n             c1 -= len1;\n-            copy_vec(array, dest+1, array, c1+1, len1);\n+            shift_vec(array, dest+1, c1+1, len1);\n             array[dest] <-> tmp[c2];\n         } else if len2 == 0 {\n             fail!(~\"Comparison violates its contract!\");\n         } else {\n             assert!(len1 == 0);\n             assert!(len2 != 0);\n-            copy_vec(array, dest-(len2-1), tmp, 0, len2);\n+            copy_vec(array, dest-(len2-1), tmp.slice(0, len2));\n         }\n     }\n \n@@ -711,21 +742,25 @@ impl<T:Copy + Ord> MergeState<T> {\n #[inline(always)]\n fn copy_vec<T:Copy>(dest: &mut [T],\n                     s1: uint,\n-                    from: &const [T],\n-                    s2: uint,\n-                    len: uint) {\n-    assert!(s1+len <= dest.len() && s2+len <= from.len());\n-\n-    let mut slice = ~[];\n-    for uint::range(s2, s2+len) |i| {\n-        slice.push(from[i]);\n-    }\n+                    from: &[T]) {\n+    assert!(s1+from.len() <= dest.len());\n \n-    for slice.eachi |i, v| {\n+    for from.eachi |i, v| {\n         dest[s1+i] = *v;\n     }\n }\n \n+#[inline(always)]\n+fn shift_vec<T:Copy>(dest: &mut [T],\n+                     s1: uint,\n+                     s2: uint,\n+                     len: uint) {\n+    assert!(s1+len <= dest.len());\n+\n+    let tmp = dest.slice(s2, s2+len).to_vec();\n+    copy_vec(dest, s1, tmp);\n+}\n+\n #[cfg(test)]\n mod test_qsort3 {\n     use sort::*;\n@@ -737,8 +772,7 @@ mod test_qsort3 {\n         quick_sort3::<int>(v1);\n         let mut i = 0;\n         while i < len {\n-            // debug!(v2[i]);\n-            assert!((v2[i] == v1[i]));\n+            assert_eq!(v2[i], v1[i]);\n             i += 1;\n         }\n     }\n@@ -1009,7 +1043,7 @@ mod big_tests {\n         tabulate_managed(low, high);\n     }\n \n-    fn multiplyVec<T:Copy>(arr: &const [T], num: uint) -> ~[T] {\n+    fn multiplyVec<T:Copy>(arr: &[T], num: uint) -> ~[T] {\n         let size = arr.len();\n         let res = do vec::from_fn(num) |i| {\n             arr[i % size]\n@@ -1025,7 +1059,7 @@ mod big_tests {\n     }\n \n     fn tabulate_unique(lo: uint, hi: uint) {\n-        fn isSorted<T:Ord>(arr: &const [T]) {\n+        fn isSorted<T:Ord>(arr: &[T]) {\n             for uint::range(0, arr.len()-1) |i| {\n                 if arr[i] > arr[i+1] {\n                     fail!(~\"Array not sorted\");\n@@ -1096,7 +1130,7 @@ mod big_tests {\n     }\n \n     fn tabulate_managed(lo: uint, hi: uint) {\n-        fn isSorted<T:Ord>(arr: &const [@T]) {\n+        fn isSorted<T:Ord>(arr: &[@T]) {\n             for uint::range(0, arr.len()-1) |i| {\n                 if arr[i] > arr[i+1] {\n                     fail!(~\"Array not sorted\");"}, {"sha": "f3d30ecd5cdf1e8807ffb0f0b8b8e6bcb7986d42", "filename": "src/libstd/sort_stage0.rs", "status": "added", "additions": 1239, "deletions": 0, "changes": 1239, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Fsort_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Fsort_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort_stage0.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -0,0 +1,1239 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Sorting methods\n+\n+use core::cmp::{Eq, Ord};\n+use core::vec::len;\n+use core::vec;\n+\n+type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n+\n+/**\n+ * Merge sort. Returns a new vector containing the sorted list.\n+ *\n+ * Has worst case O(n log n) performance, best case O(n), but\n+ * is not space efficient. This is a stable sort.\n+ */\n+pub fn merge_sort<T:Copy>(v: &const [T], le: Le<T>) -> ~[T] {\n+    type Slice = (uint, uint);\n+\n+    return merge_sort_(v, (0u, len(v)), le);\n+\n+    fn merge_sort_<T:Copy>(v: &const [T], slice: Slice, le: Le<T>)\n+        -> ~[T] {\n+        let begin = slice.first();\n+        let end = slice.second();\n+\n+        let v_len = end - begin;\n+        if v_len == 0 { return ~[]; }\n+        if v_len == 1 { return ~[v[begin]]; }\n+\n+        let mid = v_len / 2 + begin;\n+        let a = (begin, mid);\n+        let b = (mid, end);\n+        return merge(le, merge_sort_(v, a, le), merge_sort_(v, b, le));\n+    }\n+\n+    fn merge<T:Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n+        let mut rs = vec::with_capacity(len(a) + len(b));\n+        let a_len = len(a);\n+        let mut a_ix = 0;\n+        let b_len = len(b);\n+        let mut b_ix = 0;\n+        while a_ix < a_len && b_ix < b_len {\n+            if le(&a[a_ix], &b[b_ix]) {\n+                rs.push(a[a_ix]);\n+                a_ix += 1;\n+            } else { rs.push(b[b_ix]); b_ix += 1; }\n+        }\n+        rs.push_all(vec::slice(a, a_ix, a_len));\n+        rs.push_all(vec::slice(b, b_ix, b_len));\n+        rs\n+    }\n+}\n+\n+#[cfg(stage0)]\n+fn part<T>(arr: &mut [T], left: uint,\n+           right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n+    arr[pivot] <-> arr[right];\n+    let mut storage_index: uint = left;\n+    let mut i: uint = left;\n+    while i < right {\n+        let a: &mut T = &mut arr[i];\n+        let b: &mut T = &mut arr[right];\n+        if compare_func(a, b) {\n+            arr[i] <-> arr[storage_index];\n+            storage_index += 1;\n+        }\n+        i += 1;\n+    }\n+    arr[storage_index] <-> arr[right];\n+    return storage_index;\n+}\n+\n+#[cfg(not(stage0))]\n+fn part<T>(arr: &mut [T], left: uint,\n+           right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n+    arr[pivot] <-> arr[right];\n+    let mut storage_index: uint = left;\n+    let mut i: uint = left;\n+    while i < right {\n+        if compare_func(&arr[i], &arr[right]) {\n+            arr[i] <-> arr[storage_index];\n+            storage_index += 1;\n+        }\n+        i += 1;\n+    }\n+    arr[storage_index] <-> arr[right];\n+    return storage_index;\n+}\n+\n+fn qsort<T>(arr: &mut [T], left: uint,\n+            right: uint, compare_func: Le<T>) {\n+    if right > left {\n+        let pivot = (left + right) / 2u;\n+        let new_pivot = part::<T>(arr, left, right, pivot, compare_func);\n+        if new_pivot != 0u {\n+            // Need to do this check before recursing due to overflow\n+            qsort::<T>(arr, left, new_pivot - 1u, compare_func);\n+        }\n+        qsort::<T>(arr, new_pivot + 1u, right, compare_func);\n+    }\n+}\n+\n+/**\n+ * Quicksort. Sorts a mut vector in place.\n+ *\n+ * Has worst case O(n^2) performance, average case O(n log n).\n+ * This is an unstable sort.\n+ */\n+pub fn quick_sort<T>(arr: &mut [T], compare_func: Le<T>) {\n+    if len::<T>(arr) == 0u { return; }\n+    qsort::<T>(arr, 0u, len::<T>(arr) - 1u, compare_func);\n+}\n+\n+fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n+    if right <= left { return; }\n+    let v: T = arr[right];\n+    let mut i: int = left - 1;\n+    let mut j: int = right;\n+    let mut p: int = i;\n+    let mut q: int = j;\n+    loop {\n+        i += 1;\n+        while arr[i] < v { i += 1; }\n+        j -= 1;\n+        while v < arr[j] {\n+            if j == left { break; }\n+            j -= 1;\n+        }\n+        if i >= j { break; }\n+        arr[i] <-> arr[j];\n+        if arr[i] == v {\n+            p += 1;\n+            arr[p] <-> arr[i];\n+        }\n+        if v == arr[j] {\n+            q -= 1;\n+            arr[j] <-> arr[q];\n+        }\n+    }\n+    arr[i] <-> arr[right];\n+    j = i - 1;\n+    i += 1;\n+    let mut k: int = left;\n+    while k < p {\n+        arr[k] <-> arr[j];\n+        k += 1;\n+        j -= 1;\n+        if k == len::<T>(arr) as int { break; }\n+    }\n+    k = right - 1;\n+    while k > q {\n+        arr[i] <-> arr[k];\n+        k -= 1;\n+        i += 1;\n+        if k == 0 { break; }\n+    }\n+    qsort3::<T>(arr, left, j);\n+    qsort3::<T>(arr, i, right);\n+}\n+\n+/**\n+ * Fancy quicksort. Sorts a mut vector in place.\n+ *\n+ * Based on algorithm presented by ~[Sedgewick and Bentley]\n+ * (http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf).\n+ * According to these slides this is the algorithm of choice for\n+ * 'randomly ordered keys, abstract compare' & 'small number of key values'.\n+ *\n+ * This is an unstable sort.\n+ */\n+pub fn quick_sort3<T:Copy + Ord + Eq>(arr: &mut [T]) {\n+    if arr.len() <= 1 { return; }\n+    let len = arr.len() - 1; // FIXME(#5074) nested calls\n+    qsort3(arr, 0, (len - 1) as int);\n+}\n+\n+pub trait Sort {\n+    fn qsort(self);\n+}\n+\n+impl<'self, T:Copy + Ord + Eq> Sort for &'self mut [T] {\n+    fn qsort(self) { quick_sort3(self); }\n+}\n+\n+static MIN_MERGE: uint = 64;\n+static MIN_GALLOP: uint = 7;\n+static INITIAL_TMP_STORAGE: uint = 128;\n+\n+pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n+    let size = array.len();\n+    if size < 2 {\n+        return;\n+    }\n+\n+    if size < MIN_MERGE {\n+        let init_run_len = count_run_ascending(array);\n+        binarysort(array, init_run_len);\n+        return;\n+    }\n+\n+    let mut ms = MergeState();\n+    let min_run = min_run_length(size);\n+\n+    let mut idx = 0;\n+    let mut remaining = size;\n+    loop {\n+        let run_len: uint = {\n+            // This scope contains the slice `arr` here:\n+            let arr = vec::mut_slice(array, idx, size);\n+            let mut run_len: uint = count_run_ascending(arr);\n+\n+            if run_len < min_run {\n+                let force = if remaining <= min_run {remaining} else {min_run};\n+                let slice = vec::mut_slice(arr, 0, force);\n+                binarysort(slice, run_len);\n+                run_len = force;\n+            }\n+\n+            run_len\n+        };\n+\n+        ms.push_run(idx, run_len);\n+        ms.merge_collapse(array);\n+\n+        idx += run_len;\n+        remaining -= run_len;\n+        if remaining == 0 { break; }\n+    }\n+\n+    ms.merge_force_collapse(array);\n+}\n+\n+fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n+    let size = array.len();\n+    let mut start = start;\n+    assert!(start <= size);\n+\n+    if start == 0 { start += 1; }\n+\n+    while start < size {\n+        let pivot = array[start];\n+        let mut left = 0;\n+        let mut right = start;\n+        assert!(left <= right);\n+\n+        while left < right {\n+            let mid = (left + right) >> 1;\n+            if pivot < array[mid] {\n+                right = mid;\n+            } else {\n+                left = mid+1;\n+            }\n+        }\n+        assert!(left == right);\n+        let n = start-left;\n+\n+        copy_vec(array, left+1, array, left, n);\n+        array[left] = pivot;\n+        start += 1;\n+    }\n+}\n+\n+// Reverse the order of elements in a slice, in place\n+fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n+    let mut i = start;\n+    while i < end / 2 {\n+        v[i] <-> v[end - i - 1];\n+        i += 1;\n+    }\n+}\n+\n+fn min_run_length(n: uint) -> uint {\n+    let mut n = n;\n+    let mut r = 0;   // becomes 1 if any 1 bits are shifted off\n+\n+    while n >= MIN_MERGE {\n+        r |= n & 1;\n+        n >>= 1;\n+    }\n+    return n + r;\n+}\n+\n+fn count_run_ascending<T:Copy + Ord>(array: &mut [T]) -> uint {\n+    let size = array.len();\n+    assert!(size > 0);\n+    if size == 1 { return 1; }\n+\n+    let mut run = 2;\n+    if array[1] < array[0] {\n+        while run < size && array[run] < array[run-1] {\n+            run += 1;\n+        }\n+        reverse_slice(array, 0, run);\n+    } else {\n+        while run < size && array[run] >= array[run-1] {\n+            run += 1;\n+        }\n+    }\n+\n+    return run;\n+}\n+\n+fn gallop_left<T:Copy + Ord>(key: &const T,\n+                             array: &const [T],\n+                             hint: uint)\n+                          -> uint {\n+    let size = array.len();\n+    assert!(size != 0 && hint < size);\n+\n+    let mut last_ofs = 0;\n+    let mut ofs = 1;\n+\n+    if *key > array[hint] {\n+        // Gallop right until array[hint+last_ofs] < key <= array[hint+ofs]\n+        let max_ofs = size - hint;\n+        while ofs < max_ofs && *key > array[hint+ofs] {\n+            last_ofs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < last_ofs { ofs = max_ofs; } // uint overflow guard\n+        }\n+        if ofs > max_ofs { ofs = max_ofs; }\n+\n+        last_ofs += hint;\n+        ofs += hint;\n+    } else {\n+        let max_ofs = hint + 1;\n+        while ofs < max_ofs && *key <= array[hint-ofs] {\n+            last_ofs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < last_ofs { ofs = max_ofs; } // uint overflow guard\n+        }\n+\n+        if ofs > max_ofs { ofs = max_ofs; }\n+\n+        let tmp = last_ofs;\n+        last_ofs = hint - ofs;\n+        ofs = hint - tmp;\n+    }\n+    assert!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n+\n+    last_ofs += 1;\n+    while last_ofs < ofs {\n+        let m = last_ofs + ((ofs - last_ofs) >> 1);\n+        if *key > array[m] {\n+            last_ofs = m+1;\n+        } else {\n+            ofs = m;\n+        }\n+    }\n+    assert!(last_ofs == ofs);\n+    return ofs;\n+}\n+\n+fn gallop_right<T:Copy + Ord>(key: &const T,\n+                              array: &const [T],\n+                              hint: uint)\n+                           -> uint {\n+    let size = array.len();\n+    assert!(size != 0 && hint < size);\n+\n+    let mut last_ofs = 0;\n+    let mut ofs = 1;\n+\n+    if *key >= array[hint] {\n+        // Gallop right until array[hint+last_ofs] <= key < array[hint+ofs]\n+        let max_ofs = size - hint;\n+        while ofs < max_ofs && *key >= array[hint+ofs] {\n+            last_ofs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < last_ofs { ofs = max_ofs; }\n+        }\n+        if ofs > max_ofs { ofs = max_ofs; }\n+\n+        last_ofs += hint;\n+        ofs += hint;\n+    } else {\n+        // Gallop left until array[hint-ofs] <= key < array[hint-last_ofs]\n+        let max_ofs = hint + 1;\n+        while ofs < max_ofs && *key < array[hint-ofs] {\n+            last_ofs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < last_ofs { ofs = max_ofs; }\n+        }\n+        if ofs > max_ofs { ofs = max_ofs; }\n+\n+        let tmp = last_ofs;\n+        last_ofs = hint - ofs;\n+        ofs = hint - tmp;\n+    }\n+\n+    assert!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n+\n+    last_ofs += 1;\n+    while last_ofs < ofs {\n+        let m = last_ofs + ((ofs - last_ofs) >> 1);\n+\n+        if *key >= array[m] {\n+            last_ofs = m + 1;\n+        } else {\n+            ofs = m;\n+        }\n+    }\n+    assert!(last_ofs == ofs);\n+    return ofs;\n+}\n+\n+struct RunState {\n+    base: uint,\n+    len: uint,\n+}\n+\n+struct MergeState<T> {\n+    min_gallop: uint,\n+    runs: ~[RunState],\n+}\n+\n+// Fixme (#3853) Move into MergeState\n+fn MergeState<T>() -> MergeState<T> {\n+    MergeState {\n+        min_gallop: MIN_GALLOP,\n+        runs: ~[],\n+    }\n+}\n+\n+impl<T:Copy + Ord> MergeState<T> {\n+    fn push_run(&mut self, run_base: uint, run_len: uint) {\n+        let tmp = RunState{base: run_base, len: run_len};\n+        self.runs.push(tmp);\n+    }\n+\n+    fn merge_at(&mut self, n: uint, array: &mut [T]) {\n+        let size = self.runs.len();\n+        assert!(size >= 2);\n+        assert!(n == size-2 || n == size-3);\n+\n+        let mut b1 = self.runs[n].base;\n+        let mut l1 = self.runs[n].len;\n+        let b2 = self.runs[n+1].base;\n+        let l2 = self.runs[n+1].len;\n+\n+        assert!(l1 > 0 && l2 > 0);\n+        assert!(b1 + l1 == b2);\n+\n+        self.runs[n].len = l1 + l2;\n+        if n == size-3 {\n+            self.runs[n+1].base = self.runs[n+2].base;\n+            self.runs[n+1].len = self.runs[n+2].len;\n+        }\n+\n+        let k = { // constrain lifetime of slice below\n+            let slice = vec::mut_slice(array, b1, b1+l1);\n+            gallop_right(&const array[b2], slice, 0)\n+        };\n+        b1 += k;\n+        l1 -= k;\n+        if l1 != 0 {\n+            let l2 = { // constrain lifetime of slice below\n+                let slice = vec::mut_slice(array, b2, b2+l2);\n+                gallop_left(&const array[b1+l1-1],slice,l2-1)\n+            };\n+            if l2 > 0 {\n+                if l1 <= l2 {\n+                    self.merge_lo(array, b1, l1, b2, l2);\n+                } else {\n+                    self.merge_hi(array, b1, l1, b2, l2);\n+                }\n+            }\n+        }\n+        self.runs.pop();\n+    }\n+\n+    fn merge_lo(&mut self, array: &mut [T], base1: uint, len1: uint,\n+                base2: uint, len2: uint) {\n+        assert!(len1 != 0 && len2 != 0 && base1+len1 == base2);\n+\n+        let mut tmp = ~[];\n+        for uint::range(base1, base1+len1) |i| {\n+            tmp.push(array[i]);\n+        }\n+\n+        let mut c1 = 0;\n+        let mut c2 = base2;\n+        let mut dest = base1;\n+        let mut len1 = len1;\n+        let mut len2 = len2;\n+\n+        array[dest] <-> array[c2];\n+        dest += 1; c2 += 1; len2 -= 1;\n+\n+        if len2 == 0 {\n+            copy_vec(array, dest, tmp, 0, len1);\n+            return;\n+        }\n+        if len1 == 1 {\n+            copy_vec(array, dest, array, c2, len2);\n+            array[dest+len2] <-> tmp[c1];\n+            return;\n+        }\n+\n+        let mut min_gallop = self.min_gallop;\n+        loop {\n+            let mut count1 = 0;\n+            let mut count2 = 0;\n+            let mut break_outer = false;\n+\n+            loop {\n+                assert!(len1 > 1 && len2 != 0);\n+                if array[c2] < tmp[c1] {\n+                    array[dest] <-> array[c2];\n+                    dest += 1; c2 += 1; len2 -= 1;\n+                    count2 += 1; count1 = 0;\n+                    if len2 == 0 {\n+                        break_outer = true;\n+                    }\n+                } else {\n+                    array[dest] <-> tmp[c1];\n+                    dest += 1; c1 += 1; len1 -= 1;\n+                    count1 += 1; count2 = 0;\n+                    if len1 == 1 {\n+                        break_outer = true;\n+                    }\n+                }\n+                if break_outer || ((count1 | count2) >= min_gallop) {\n+                    break;\n+                }\n+            }\n+            if break_outer { break; }\n+\n+            // Start to gallop\n+            loop {\n+                assert!(len1 > 1 && len2 != 0);\n+\n+                let tmp_view = vec::const_slice(tmp, c1, c1+len1);\n+                count1 = gallop_right(&const array[c2], tmp_view, 0);\n+                if count1 != 0 {\n+                    copy_vec(array, dest, tmp, c1, count1);\n+                    dest += count1; c1 += count1; len1 -= count1;\n+                    if len1 <= 1 { break_outer = true; break; }\n+                }\n+                array[dest] <-> array[c2];\n+                dest += 1; c2 += 1; len2 -= 1;\n+                if len2 == 0 { break_outer = true; break; }\n+\n+                let tmp_view = vec::const_slice(array, c2, c2+len2);\n+                count2 = gallop_left(&const tmp[c1], tmp_view, 0);\n+                if count2 != 0 {\n+                    copy_vec(array, dest, array, c2, count2);\n+                    dest += count2; c2 += count2; len2 -= count2;\n+                    if len2 == 0 { break_outer = true; break; }\n+                }\n+                array[dest] <-> tmp[c1];\n+                dest += 1; c1 += 1; len1 -= 1;\n+                if len1 == 1 { break_outer = true; break; }\n+                min_gallop -= 1;\n+                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n+                    break;\n+                }\n+            }\n+            if break_outer { break; }\n+            if min_gallop < 0 { min_gallop = 0; }\n+            min_gallop += 2; // Penalize for leaving gallop\n+        }\n+        self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n+\n+        if len1 == 1 {\n+            assert!(len2 > 0);\n+            copy_vec(array, dest, array, c2, len2);\n+            array[dest+len2] <-> tmp[c1];\n+        } else if len1 == 0 {\n+            fail!(~\"Comparison violates its contract!\");\n+        } else {\n+            assert!(len2 == 0);\n+            assert!(len1 > 1);\n+            copy_vec(array, dest, tmp, c1, len1);\n+        }\n+    }\n+\n+    fn merge_hi(&mut self, array: &mut [T], base1: uint, len1: uint,\n+                base2: uint, len2: uint) {\n+        assert!(len1 != 1 && len2 != 0 && base1 + len1 == base2);\n+\n+        let mut tmp = ~[];\n+        for uint::range(base2, base2+len2) |i| {\n+            tmp.push(array[i]);\n+        }\n+\n+        let mut c1 = base1 + len1 - 1;\n+        let mut c2 = len2 - 1;\n+        let mut dest = base2 + len2 - 1;\n+        let mut len1 = len1;\n+        let mut len2 = len2;\n+\n+        array[dest] <-> array[c1];\n+        dest -= 1; c1 -= 1; len1 -= 1;\n+\n+        if len1 == 0 {\n+            copy_vec(array, dest-(len2-1), tmp, 0, len2);\n+            return;\n+        }\n+        if len2 == 1 {\n+            dest -= len1;\n+            c1 -= len1;\n+            copy_vec(array, dest+1, array, c1+1, len1);\n+            array[dest] <-> tmp[c2];\n+            return;\n+        }\n+\n+        let mut min_gallop = self.min_gallop;\n+        loop {\n+            let mut count1 = 0;\n+            let mut count2 = 0;\n+            let mut break_outer = false;\n+\n+            loop {\n+                assert!(len1 != 0 && len2 > 1);\n+                if tmp[c2] < array[c1] {\n+                    array[dest] <-> array[c1];\n+                    dest -= 1; c1 -= 1; len1 -= 1;\n+                    count1 += 1; count2 = 0;\n+                    if len1 == 0 {\n+                        break_outer = true;\n+                    }\n+                } else {\n+                    array[dest] <-> tmp[c2];\n+                    dest -= 1; c2 -= 1; len2 -= 1;\n+                    count2 += 1; count1 = 0;\n+                    if len2 == 1 {\n+                        break_outer = true;\n+                    }\n+                }\n+                if break_outer || ((count1 | count2) >= min_gallop) {\n+                    break;\n+                }\n+            }\n+            if break_outer { break; }\n+\n+            // Start to gallop\n+            loop {\n+                assert!(len2 > 1 && len1 != 0);\n+\n+                { // constrain scope of tmp_view:\n+                    let tmp_view = vec::mut_slice (array, base1, base1+len1);\n+                    count1 = len1 - gallop_right(\n+                        &const tmp[c2], tmp_view, len1-1);\n+                }\n+\n+                if count1 != 0 {\n+                    dest -= count1; c1 -= count1; len1 -= count1;\n+                    copy_vec(array, dest+1, array, c1+1, count1);\n+                    if len1 == 0 { break_outer = true; break; }\n+                }\n+\n+                array[dest] <-> tmp[c2];\n+                dest -= 1; c2 -= 1; len2 -= 1;\n+                if len2 == 1 { break_outer = true; break; }\n+\n+                let count2;\n+                { // constrain scope of tmp_view\n+                    let tmp_view = vec::mut_slice(tmp, 0, len2);\n+                    count2 = len2 - gallop_left(&const array[c1],\n+                                                tmp_view,\n+                                                len2-1);\n+                }\n+\n+                if count2 != 0 {\n+                    dest -= count2; c2 -= count2; len2 -= count2;\n+                    copy_vec(array, dest+1, tmp, c2+1, count2);\n+                    if len2 <= 1 { break_outer = true; break; }\n+                }\n+                array[dest] <-> array[c1];\n+                dest -= 1; c1 -= 1; len1 -= 1;\n+                if len1 == 0 { break_outer = true; break; }\n+                min_gallop -= 1;\n+                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n+                    break;\n+                }\n+            }\n+\n+            if break_outer { break; }\n+            if min_gallop < 0 { min_gallop = 0; }\n+            min_gallop += 2; // Penalize for leaving gallop\n+        }\n+        self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n+\n+        if len2 == 1 {\n+            assert!(len1 > 0);\n+            dest -= len1;\n+            c1 -= len1;\n+            copy_vec(array, dest+1, array, c1+1, len1);\n+            array[dest] <-> tmp[c2];\n+        } else if len2 == 0 {\n+            fail!(~\"Comparison violates its contract!\");\n+        } else {\n+            assert!(len1 == 0);\n+            assert!(len2 != 0);\n+            copy_vec(array, dest-(len2-1), tmp, 0, len2);\n+        }\n+    }\n+\n+    fn merge_collapse(&mut self, array: &mut [T]) {\n+        while self.runs.len() > 1 {\n+            let mut n = self.runs.len()-2;\n+            if n > 0 &&\n+                self.runs[n-1].len <= self.runs[n].len + self.runs[n+1].len\n+            {\n+                if self.runs[n-1].len < self.runs[n+1].len { n -= 1; }\n+            } else if self.runs[n].len <= self.runs[n+1].len {\n+                /* keep going */\n+            } else {\n+                break;\n+            }\n+            self.merge_at(n, array);\n+        }\n+    }\n+\n+    fn merge_force_collapse(&mut self, array: &mut [T]) {\n+        while self.runs.len() > 1 {\n+            let mut n = self.runs.len()-2;\n+            if n > 0 {\n+                if self.runs[n-1].len < self.runs[n+1].len {\n+                    n -= 1;\n+                }\n+            }\n+            self.merge_at(n, array);\n+        }\n+    }\n+}\n+\n+#[inline(always)]\n+fn copy_vec<T:Copy>(dest: &mut [T],\n+                    s1: uint,\n+                    from: &const [T],\n+                    s2: uint,\n+                    len: uint) {\n+    assert!(s1+len <= dest.len() && s2+len <= from.len());\n+\n+    let mut slice = ~[];\n+    for uint::range(s2, s2+len) |i| {\n+        slice.push(from[i]);\n+    }\n+\n+    for slice.eachi |i, v| {\n+        dest[s1+i] = *v;\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test_qsort3 {\n+    use sort::*;\n+\n+    use core::vec;\n+\n+    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n+        let len = vec::len::<int>(v1);\n+        quick_sort3::<int>(v1);\n+        let mut i = 0;\n+        while i < len {\n+            // debug!(v2[i]);\n+            assert!((v2[i] == v1[i]));\n+            i += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test() {\n+        {\n+            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let mut v1 = ~[1, 1, 1];\n+            let mut v2 = ~[1, 1, 1];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let mut v1: ~[int] = ~[];\n+            let mut v2: ~[int] = ~[];\n+            check_sort(v1, v2);\n+        }\n+        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n+        {\n+            let mut v1 = ~[9, 3, 3, 3, 9];\n+            let mut v2 = ~[3, 3, 3, 9, 9];\n+            check_sort(v1, v2);\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test_qsort {\n+    use sort::*;\n+\n+    use core::int;\n+    use core::vec;\n+\n+    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n+        let len = vec::len::<int>(v1);\n+        fn leual(a: &int, b: &int) -> bool { *a <= *b }\n+        quick_sort::<int>(v1, leual);\n+        let mut i = 0u;\n+        while i < len {\n+            // debug!(v2[i]);\n+            assert!((v2[i] == v1[i]));\n+            i += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test() {\n+        {\n+            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let mut v1 = ~[1, 1, 1];\n+            let mut v2 = ~[1, 1, 1];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let mut v1: ~[int] = ~[];\n+            let mut v2: ~[int] = ~[];\n+            check_sort(v1, v2);\n+        }\n+        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n+        {\n+            let mut v1 = ~[9, 3, 3, 3, 9];\n+            let mut v2 = ~[3, 3, 3, 9, 9];\n+            check_sort(v1, v2);\n+        }\n+    }\n+\n+    // Regression test for #750\n+    #[test]\n+    fn test_simple() {\n+        let mut names = ~[2, 1, 3];\n+\n+        let expected = ~[1, 2, 3];\n+\n+        do quick_sort(names) |x, y| { int::le(*x, *y) };\n+\n+        let immut_names = names;\n+\n+        let pairs = vec::zip_slice(expected, immut_names);\n+        for vec::each(pairs) |p| {\n+            let (a, b) = *p;\n+            debug!(\"%d %d\", a, b);\n+            assert!((a == b));\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use sort::*;\n+\n+    use core::vec;\n+\n+    fn check_sort(v1: &[int], v2: &[int]) {\n+        let len = vec::len::<int>(v1);\n+        pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n+        let f = le;\n+        let v3 = merge_sort::<int>(v1, f);\n+        let mut i = 0u;\n+        while i < len {\n+            debug!(v3[i]);\n+            assert!((v3[i] == v2[i]));\n+            i += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test() {\n+        {\n+            let v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+            let v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n+            check_sort(v1, v2);\n+        }\n+        { let v1 = ~[1, 1, 1]; let v2 = ~[1, 1, 1]; check_sort(v1, v2); }\n+        { let v1:~[int] = ~[]; let v2:~[int] = ~[]; check_sort(v1, v2); }\n+        { let v1 = ~[9]; let v2 = ~[9]; check_sort(v1, v2); }\n+        {\n+            let v1 = ~[9, 3, 3, 3, 9];\n+            let v2 = ~[3, 3, 3, 9, 9];\n+            check_sort(v1, v2);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_merge_sort_mutable() {\n+        pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n+        let mut v1 = ~[3, 2, 1];\n+        let v2 = merge_sort(v1, le);\n+        assert!(v2 == ~[1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_merge_sort_stability() {\n+        // tjc: funny that we have to use parens\n+        fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n+        {\n+            // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n+            // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n+            // (Actually, could just remove the to_str_* call, but needs an deriving(Ord) on\n+            // Ascii)\n+            let x = x.to_ascii().to_lower().to_str_ascii();\n+            let y = y.to_ascii().to_lower().to_str_ascii();\n+            x <= y\n+        }\n+\n+        let names1 = ~[\"joe bob\", \"Joe Bob\", \"Jack Brown\", \"JOE Bob\",\n+                       \"Sally Mae\", \"JOE BOB\", \"Alex Andy\"];\n+        let names2 = ~[\"Alex Andy\", \"Jack Brown\", \"joe bob\", \"Joe Bob\",\n+                       \"JOE Bob\", \"JOE BOB\", \"Sally Mae\"];\n+        let names3 = merge_sort(names1, ile);\n+        assert!(names3 == names2);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test_tim_sort {\n+    use sort::tim_sort;\n+    use core::rand::RngUtil;\n+\n+    struct CVal {\n+        val: float,\n+    }\n+\n+    impl Ord for CVal {\n+        fn lt(&self, other: &CVal) -> bool {\n+            let rng = rand::rng();\n+            if rng.gen::<float>() > 0.995 { fail!(~\"It's happening!!!\"); }\n+            (*self).val < other.val\n+        }\n+        fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n+        fn gt(&self, other: &CVal) -> bool { (*self).val > other.val }\n+        fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n+    }\n+\n+    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n+        let len = vec::len::<int>(v1);\n+        tim_sort::<int>(v1);\n+        let mut i = 0u;\n+        while i < len {\n+            // debug!(v2[i]);\n+            assert!((v2[i] == v1[i]));\n+            i += 1u;\n+        }\n+    }\n+\n+    #[test]\n+    fn test() {\n+        {\n+            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let mut v1 = ~[1, 1, 1];\n+            let mut v2 = ~[1, 1, 1];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let mut v1: ~[int] = ~[];\n+            let mut v2: ~[int] = ~[];\n+            check_sort(v1, v2);\n+        }\n+        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n+        {\n+            let mut v1 = ~[9, 3, 3, 3, 9];\n+            let mut v2 = ~[3, 3, 3, 9, 9];\n+            check_sort(v1, v2);\n+        }\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[cfg(unix)]\n+    fn crash_test() {\n+        let rng = rand::rng();\n+        let mut arr = do vec::from_fn(1000) |_i| {\n+            CVal { val: rng.gen() }\n+        };\n+\n+        tim_sort(arr);\n+        fail!(~\"Guarantee the fail\");\n+    }\n+\n+    struct DVal { val: uint }\n+\n+    impl Ord for DVal {\n+        fn lt(&self, _x: &DVal) -> bool { true }\n+        fn le(&self, _x: &DVal) -> bool { true }\n+        fn gt(&self, _x: &DVal) -> bool { true }\n+        fn ge(&self, _x: &DVal) -> bool { true }\n+    }\n+\n+    #[test]\n+    fn test_bad_Ord_impl() {\n+        let rng = rand::rng();\n+        let mut arr = do vec::from_fn(500) |_i| {\n+            DVal { val: rng.gen() }\n+        };\n+\n+        tim_sort(arr);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod big_tests {\n+    use sort::*;\n+    use core::rand::RngUtil;\n+\n+    #[test]\n+    fn test_unique() {\n+        let low = 5;\n+        let high = 10;\n+        tabulate_unique(low, high);\n+    }\n+\n+    #[test]\n+    fn test_managed() {\n+        let low = 5;\n+        let high = 10;\n+        tabulate_managed(low, high);\n+    }\n+\n+    fn multiplyVec<T:Copy>(arr: &const [T], num: uint) -> ~[T] {\n+        let size = arr.len();\n+        let res = do vec::from_fn(num) |i| {\n+            arr[i % size]\n+        };\n+        res\n+    }\n+\n+    fn makeRange(n: uint) -> ~[uint] {\n+        let one = do vec::from_fn(n) |i| { i };\n+        let mut two = copy one;\n+        vec::reverse(two);\n+        vec::append(two, one)\n+    }\n+\n+    fn tabulate_unique(lo: uint, hi: uint) {\n+        fn isSorted<T:Ord>(arr: &const [T]) {\n+            for uint::range(0, arr.len()-1) |i| {\n+                if arr[i] > arr[i+1] {\n+                    fail!(~\"Array not sorted\");\n+                }\n+            }\n+        }\n+\n+        let rng = rand::rng();\n+\n+        for uint::range(lo, hi) |i| {\n+            let n = 1 << i;\n+            let mut arr: ~[float] = do vec::from_fn(n) |_i| {\n+                rng.gen()\n+            };\n+\n+            tim_sort(arr); // *sort\n+            isSorted(arr);\n+\n+            vec::reverse(arr);\n+            tim_sort(arr); // \\sort\n+            isSorted(arr);\n+\n+            tim_sort(arr); // /sort\n+            isSorted(arr);\n+\n+            for 3.times {\n+                let i1 = rng.gen_uint_range(0, n);\n+                let i2 = rng.gen_uint_range(0, n);\n+                arr[i1] <-> arr[i2];\n+            }\n+            tim_sort(arr); // 3sort\n+            isSorted(arr);\n+\n+            if n >= 10 {\n+                let size = arr.len();\n+                let mut idx = 1;\n+                while idx <= 10 {\n+                    arr[size-idx] = rng.gen();\n+                    idx += 1;\n+                }\n+            }\n+            tim_sort(arr); // +sort\n+            isSorted(arr);\n+\n+            for (n/100).times {\n+                let idx = rng.gen_uint_range(0, n);\n+                arr[idx] = rng.gen();\n+            }\n+            tim_sort(arr);\n+            isSorted(arr);\n+\n+            let mut arr = if n > 4 {\n+                let part = vec::slice(arr, 0, 4);\n+                multiplyVec(part, n)\n+            } else { arr };\n+            tim_sort(arr); // ~sort\n+            isSorted(arr);\n+\n+            let mut arr = vec::from_elem(n, -0.5);\n+            tim_sort(arr); // =sort\n+            isSorted(arr);\n+\n+            let half = n / 2;\n+            let mut arr = makeRange(half).map(|i| *i as float);\n+            tim_sort(arr); // !sort\n+            isSorted(arr);\n+        }\n+    }\n+\n+    fn tabulate_managed(lo: uint, hi: uint) {\n+        fn isSorted<T:Ord>(arr: &const [@T]) {\n+            for uint::range(0, arr.len()-1) |i| {\n+                if arr[i] > arr[i+1] {\n+                    fail!(~\"Array not sorted\");\n+                }\n+            }\n+        }\n+\n+        let rng = rand::rng();\n+\n+        for uint::range(lo, hi) |i| {\n+            let n = 1 << i;\n+            let arr: ~[@float] = do vec::from_fn(n) |_i| {\n+                @rng.gen()\n+            };\n+            let mut arr = arr;\n+\n+            tim_sort(arr); // *sort\n+            isSorted(arr);\n+\n+            vec::reverse(arr);\n+            tim_sort(arr); // \\sort\n+            isSorted(arr);\n+\n+            tim_sort(arr); // /sort\n+            isSorted(arr);\n+\n+            for 3.times {\n+                let i1 = rng.gen_uint_range(0, n);\n+                let i2 = rng.gen_uint_range(0, n);\n+                arr[i1] <-> arr[i2];\n+            }\n+            tim_sort(arr); // 3sort\n+            isSorted(arr);\n+\n+            if n >= 10 {\n+                let size = arr.len();\n+                let mut idx = 1;\n+                while idx <= 10 {\n+                    arr[size-idx] = @rng.gen();\n+                    idx += 1;\n+                }\n+            }\n+            tim_sort(arr); // +sort\n+            isSorted(arr);\n+\n+            for (n/100).times {\n+                let idx = rng.gen_uint_range(0, n);\n+                arr[idx] = @rng.gen();\n+            }\n+            tim_sort(arr);\n+            isSorted(arr);\n+\n+            let mut arr = if n > 4 {\n+                let part = vec::slice(arr, 0, 4);\n+                multiplyVec(part, n)\n+            } else { arr };\n+            tim_sort(arr); // ~sort\n+            isSorted(arr);\n+\n+            let mut arr = vec::from_elem(n, @(-0.5));\n+            tim_sort(arr); // =sort\n+            isSorted(arr);\n+\n+            let half = n / 2;\n+            let mut arr = makeRange(half).map(|i| @(*i as float));\n+            tim_sort(arr); // !sort\n+            isSorted(arr);\n+        }\n+    }\n+\n+    struct LVal<'self> {\n+        val: uint,\n+        key: &'self fn(@uint),\n+    }\n+\n+    #[unsafe_destructor]\n+    impl<'self> Drop for LVal<'self> {\n+        fn finalize(&self) {\n+            let x = unsafe { task::local_data::local_data_get(self.key) };\n+            match x {\n+                Some(@y) => {\n+                    unsafe {\n+                        task::local_data::local_data_set(self.key, @(y+1));\n+                    }\n+                }\n+                _ => fail!(~\"Expected key to work\"),\n+            }\n+        }\n+    }\n+\n+    impl<'self> Ord for LVal<'self> {\n+        fn lt<'a>(&self, other: &'a LVal<'self>) -> bool {\n+            (*self).val < other.val\n+        }\n+        fn le<'a>(&self, other: &'a LVal<'self>) -> bool {\n+            (*self).val <= other.val\n+        }\n+        fn gt<'a>(&self, other: &'a LVal<'self>) -> bool {\n+            (*self).val > other.val\n+        }\n+        fn ge<'a>(&self, other: &'a LVal<'self>) -> bool {\n+            (*self).val >= other.val\n+        }\n+    }\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "d96dae76c42903af75fde3f34bcf409e9b01597c", "filename": "src/libstd/std.rc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -69,7 +69,14 @@ pub mod list;\n pub mod priority_queue;\n pub mod rope;\n pub mod smallintmap;\n+\n+#[cfg(stage0)]\n+#[path=\"sort_stage0.rs\"]\n+pub mod sort;\n+\n+#[cfg(not(stage0))]\n pub mod sort;\n+\n pub mod dlist;\n pub mod treemap;\n "}, {"sha": "77a02adbafba719794ef6a7331f93c609de16528", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -18,6 +18,7 @@ use diagnostic::span_handler;\n use parse::token::ident_interner;\n use print::pprust;\n use visit;\n+use syntax::parse::token::special_idents;\n \n use core::hashmap::HashMap;\n \n@@ -88,20 +89,18 @@ pub enum ast_node {\n     node_variant(variant, @item, @path),\n     node_expr(@expr),\n     node_stmt(@stmt),\n-    // Locals are numbered, because the alias analysis needs to know in which\n-    // order they are introduced.\n-    node_arg(arg, uint),\n-    node_local(uint),\n+    node_arg,\n+    node_local(ident),\n     node_block(blk),\n     node_struct_ctor(@struct_def, @item, @path),\n+    node_callee_scope(@expr)\n }\n \n pub type map = @mut HashMap<node_id, ast_node>;\n \n pub struct Ctx {\n     map: map,\n     path: path,\n-    local_id: uint,\n     diag: @span_handler,\n }\n \n@@ -117,9 +116,8 @@ pub fn mk_ast_map_visitor() -> vt {\n         visit_expr: map_expr,\n         visit_stmt: map_stmt,\n         visit_fn: map_fn,\n-        visit_local: map_local,\n-        visit_arm: map_arm,\n         visit_block: map_block,\n+        visit_pat: map_pat,\n         .. *visit::default_visitor()\n     });\n }\n@@ -128,7 +126,6 @@ pub fn map_crate(diag: @span_handler, c: @crate) -> map {\n     let cx = @mut Ctx {\n         map: @mut HashMap::new(),\n         path: ~[],\n-        local_id: 0u,\n         diag: diag,\n     };\n     visit::visit_crate(c, cx, mk_ast_map_visitor());\n@@ -151,7 +148,6 @@ pub fn map_decoded_item(diag: @span_handler,\n     let cx = @mut Ctx {\n         map: map,\n         path: copy path,\n-        local_id: 0,\n         diag: diag,\n     };\n     let v = mk_ast_map_visitor();\n@@ -186,9 +182,7 @@ pub fn map_fn(\n     v: visit::vt<@mut Ctx>\n ) {\n     for decl.inputs.each |a| {\n-        cx.map.insert(a.id,\n-                      node_arg(/* FIXME (#2543) */ copy *a, cx.local_id));\n-        cx.local_id += 1u;\n+        cx.map.insert(a.id, node_arg);\n     }\n     visit::visit_fn(fk, decl, body, sp, id, cx, v);\n }\n@@ -198,33 +192,22 @@ pub fn map_block(b: &blk, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     visit::visit_block(b, cx, v);\n }\n \n-pub fn number_pat(cx: @mut Ctx, pat: @pat) {\n-    do ast_util::walk_pat(pat) |p| {\n-        match p.node {\n-          pat_ident(*) => {\n-            cx.map.insert(p.id, node_local(cx.local_id));\n-            cx.local_id += 1u;\n-          }\n-          _ => ()\n+pub fn map_pat(pat: @pat, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+    match pat.node {\n+        pat_ident(_, path, _) => {\n+            // Note: this is at least *potentially* a pattern...\n+            cx.map.insert(pat.id, node_local(ast_util::path_to_ident(path)));\n         }\n-    };\n-}\n-\n-pub fn map_local(loc: @local, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n-    number_pat(cx, loc.node.pat);\n-    visit::visit_local(loc, cx, v);\n-}\n+        _ => ()\n+    }\n \n-pub fn map_arm(arm: &arm, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n-    number_pat(cx, arm.pats[0]);\n-    visit::visit_arm(arm, cx, v);\n+    visit::visit_pat(pat, cx, v);\n }\n \n pub fn map_method(impl_did: def_id, impl_path: @path,\n                   m: @method, cx: @mut Ctx) {\n     cx.map.insert(m.id, node_method(m, impl_did, impl_path));\n-    cx.map.insert(m.self_id, node_local(cx.local_id));\n-    cx.local_id += 1u;\n+    cx.map.insert(m.self_id, node_local(special_idents::self_));\n }\n \n pub fn map_item(i: @item, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n@@ -293,6 +276,7 @@ pub fn map_item(i: @item, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n         }\n         _ => ()\n     }\n+\n     match i.node {\n         item_mod(_) | item_foreign_mod(_) => {\n             cx.path.push(path_mod(i.ident));\n@@ -328,6 +312,18 @@ pub fn map_struct_def(\n \n pub fn map_expr(ex: @expr, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     cx.map.insert(ex.id, node_expr(ex));\n+    match ex.node {\n+        // Expressions which are or might be calls:\n+        ast::expr_call(*) |\n+        ast::expr_method_call(*) |\n+        ast::expr_index(*) |\n+        ast::expr_binary(*) |\n+        ast::expr_assign_op(*) |\n+        ast::expr_unary(*) => {\n+            cx.map.insert(ex.callee_id, node_callee_scope(ex));\n+        }\n+        _ => {}\n+    }\n     visit::visit_expr(ex, cx, v);\n }\n \n@@ -377,15 +373,18 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n       Some(&node_expr(expr)) => {\n         fmt!(\"expr %s (id=%?)\", pprust::expr_to_str(expr, itr), id)\n       }\n+      Some(&node_callee_scope(expr)) => {\n+        fmt!(\"callee_scope %s (id=%?)\", pprust::expr_to_str(expr, itr), id)\n+      }\n       Some(&node_stmt(stmt)) => {\n         fmt!(\"stmt %s (id=%?)\",\n              pprust::stmt_to_str(stmt, itr), id)\n       }\n-      Some(&node_arg(_, _)) => { // add more info here\n+      Some(&node_arg) => {\n         fmt!(\"arg (id=%?)\", id)\n       }\n-      Some(&node_local(_)) => { // add more info here\n-        fmt!(\"local (id=%?)\", id)\n+      Some(&node_local(ident)) => {\n+        fmt!(\"local (id=%?, name=%s)\", id, *itr.get(ident))\n       }\n       Some(&node_block(_)) => {\n         fmt!(\"block\")"}, {"sha": "a6094903d7b79d1d4e307349f3feeb8174f8a118", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -368,8 +368,20 @@ pub struct id_range {\n     max: node_id,\n }\n \n-pub fn empty(range: id_range) -> bool {\n-    range.min >= range.max\n+pub impl id_range {\n+    fn max() -> id_range {\n+        id_range {min: int::max_value,\n+                  max: int::min_value}\n+    }\n+\n+    fn empty(&self) -> bool {\n+        self.min >= self.max\n+    }\n+\n+    fn add(&mut self, id: node_id) {\n+        self.min = int::min(self.min, id);\n+        self.max = int::max(self.max, id + 1);\n+    }\n }\n \n pub fn id_visitor(vfn: @fn(node_id)) -> visit::vt<()> {\n@@ -467,13 +479,11 @@ pub fn visit_ids_for_inlined_item(item: &inlined_item, vfn: @fn(node_id)) {\n }\n \n pub fn compute_id_range(visit_ids_fn: &fn(@fn(node_id))) -> id_range {\n-    let min = @mut int::max_value;\n-    let max = @mut int::min_value;\n+    let result = @mut id_range::max();\n     do visit_ids_fn |id| {\n-        *min = int::min(*min, id);\n-        *max = int::max(*max, id + 1);\n+        result.add(id);\n     }\n-    id_range { min: *min, max: *max }\n+    *result\n }\n \n pub fn compute_id_range_for_inlined_item(item: &inlined_item) -> id_range {"}, {"sha": "846097550d14f5b91badc4396c72827b8f2aff42", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -248,7 +248,7 @@ pub impl FileMap {\n         // the new charpos must be > the last one (or it's the first one).\n         let lines = &mut *self.lines;\n         assert!((lines.len() == 0) || (lines[lines.len() - 1] < pos));\n-        self.lines.push(pos);\n+        lines.push(pos);\n     }\n \n     // get a line from the list of pre-computed line-beginnings\n@@ -310,7 +310,7 @@ pub impl CodeMap {\n             multibyte_chars: @mut ~[],\n         };\n \n-        self.files.push(filemap);\n+        files.push(filemap);\n \n         return filemap;\n     }\n@@ -357,7 +357,7 @@ pub impl CodeMap {\n     }\n \n     pub fn span_to_str(&self, sp: span) -> ~str {\n-        let files = &mut *self.files;\n+        let files = &*self.files;\n         if files.len() == 0 && sp == dummy_sp() {\n             return ~\"no-location\";\n         }"}, {"sha": "b313a2fc6fcc9de3761a6f59cacd8bf1ca07bf7c", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -24,6 +24,7 @@ pub trait handler {\n     fn fatal(@mut self, msg: &str) -> !;\n     fn err(@mut self, msg: &str);\n     fn bump_err_count(@mut self);\n+    fn err_count(@mut self) -> uint;\n     fn has_errors(@mut self) -> bool;\n     fn abort_if_errors(@mut self);\n     fn warn(@mut self, msg: &str);\n@@ -98,7 +99,12 @@ impl handler for HandlerT {\n     fn bump_err_count(@mut self) {\n         self.err_count += 1u;\n     }\n-    fn has_errors(@mut self) -> bool { self.err_count > 0u }\n+    fn err_count(@mut self) -> uint {\n+        self.err_count\n+    }\n+    fn has_errors(@mut self) -> bool {\n+        self.err_count > 0u\n+    }\n     fn abort_if_errors(@mut self) {\n         let s;\n         match self.err_count {"}, {"sha": "da8f87d3891945937141ece987b69599e2eeb004", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 57, "deletions": 51, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -210,29 +210,29 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n // when a macro expansion occurs, the resulting nodes have the backtrace()\n // -> expn_info of their expansion context stored into their span.\n pub trait ext_ctxt {\n-    fn codemap(@mut self) -> @CodeMap;\n-    fn parse_sess(@mut self) -> @mut parse::ParseSess;\n-    fn cfg(@mut self) -> ast::crate_cfg;\n-    fn call_site(@mut self) -> span;\n-    fn print_backtrace(@mut self);\n-    fn backtrace(@mut self) -> Option<@ExpnInfo>;\n-    fn mod_push(@mut self, mod_name: ast::ident);\n-    fn mod_pop(@mut self);\n-    fn mod_path(@mut self) -> ~[ast::ident];\n-    fn bt_push(@mut self, ei: codemap::ExpnInfo);\n-    fn bt_pop(@mut self);\n-    fn span_fatal(@mut self, sp: span, msg: &str) -> !;\n-    fn span_err(@mut self, sp: span, msg: &str);\n-    fn span_warn(@mut self, sp: span, msg: &str);\n-    fn span_unimpl(@mut self, sp: span, msg: &str) -> !;\n-    fn span_bug(@mut self, sp: span, msg: &str) -> !;\n-    fn bug(@mut self, msg: &str) -> !;\n-    fn next_id(@mut self) -> ast::node_id;\n-    fn trace_macros(@mut self) -> bool;\n-    fn set_trace_macros(@mut self, x: bool);\n+    fn codemap(&self) -> @CodeMap;\n+    fn parse_sess(&self) -> @mut parse::ParseSess;\n+    fn cfg(&self) -> ast::crate_cfg;\n+    fn call_site(&self) -> span;\n+    fn print_backtrace(&self);\n+    fn backtrace(&self) -> Option<@ExpnInfo>;\n+    fn mod_push(&self, mod_name: ast::ident);\n+    fn mod_pop(&self);\n+    fn mod_path(&self) -> ~[ast::ident];\n+    fn bt_push(&self, ei: codemap::ExpnInfo);\n+    fn bt_pop(&self);\n+    fn span_fatal(&self, sp: span, msg: &str) -> !;\n+    fn span_err(&self, sp: span, msg: &str);\n+    fn span_warn(&self, sp: span, msg: &str);\n+    fn span_unimpl(&self, sp: span, msg: &str) -> !;\n+    fn span_bug(&self, sp: span, msg: &str) -> !;\n+    fn bug(&self, msg: &str) -> !;\n+    fn next_id(&self) -> ast::node_id;\n+    fn trace_macros(&self) -> bool;\n+    fn set_trace_macros(&self, x: bool);\n     /* for unhygienic identifier transformation */\n-    fn str_of(@mut self, id: ast::ident) -> ~str;\n-    fn ident_of(@mut self, st: ~str) -> ast::ident;\n+    fn str_of(&self, id: ast::ident) -> ~str;\n+    fn ident_of(&self, st: ~str) -> ast::ident;\n }\n \n pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n@@ -241,25 +241,31 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n         parse_sess: @mut parse::ParseSess,\n         cfg: ast::crate_cfg,\n         backtrace: @mut Option<@ExpnInfo>,\n-        mod_path: ~[ast::ident],\n-        trace_mac: bool\n+\n+        // These two @mut's should really not be here,\n+        // but the self types for CtxtRepr are all wrong\n+        // and there are bugs in the code for object\n+        // types that make this hard to get right at the\n+        // moment. - nmatsakis\n+        mod_path: @mut ~[ast::ident],\n+        trace_mac: @mut bool\n     }\n     impl ext_ctxt for CtxtRepr {\n-        fn codemap(@mut self) -> @CodeMap { self.parse_sess.cm }\n-        fn parse_sess(@mut self) -> @mut parse::ParseSess { self.parse_sess }\n-        fn cfg(@mut self) -> ast::crate_cfg { copy self.cfg }\n-        fn call_site(@mut self) -> span {\n+        fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n+        fn parse_sess(&self) -> @mut parse::ParseSess { self.parse_sess }\n+        fn cfg(&self) -> ast::crate_cfg { copy self.cfg }\n+        fn call_site(&self) -> span {\n             match *self.backtrace {\n                 Some(@ExpandedFrom(CallInfo {call_site: cs, _})) => cs,\n                 None => self.bug(~\"missing top span\")\n             }\n         }\n-        fn print_backtrace(@mut self) { }\n-        fn backtrace(@mut self) -> Option<@ExpnInfo> { *self.backtrace }\n-        fn mod_push(@mut self, i: ast::ident) { self.mod_path.push(i); }\n-        fn mod_pop(@mut self) { self.mod_path.pop(); }\n-        fn mod_path(@mut self) -> ~[ast::ident] { copy self.mod_path }\n-        fn bt_push(@mut self, ei: codemap::ExpnInfo) {\n+        fn print_backtrace(&self) { }\n+        fn backtrace(&self) -> Option<@ExpnInfo> { *self.backtrace }\n+        fn mod_push(&self, i: ast::ident) { self.mod_path.push(i); }\n+        fn mod_pop(&self) { self.mod_path.pop(); }\n+        fn mod_path(&self) -> ~[ast::ident] { copy *self.mod_path }\n+        fn bt_push(&self, ei: codemap::ExpnInfo) {\n             match ei {\n               ExpandedFrom(CallInfo {call_site: cs, callee: ref callee}) => {\n                 *self.backtrace =\n@@ -270,7 +276,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n               }\n             }\n         }\n-        fn bt_pop(@mut self) {\n+        fn bt_pop(&self) {\n             match *self.backtrace {\n               Some(@ExpandedFrom(CallInfo {\n                   call_site: span {expn_info: prev, _}, _\n@@ -280,52 +286,52 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n               _ => self.bug(~\"tried to pop without a push\")\n             }\n         }\n-        fn span_fatal(@mut self, sp: span, msg: &str) -> ! {\n+        fn span_fatal(&self, sp: span, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_fatal(sp, msg);\n         }\n-        fn span_err(@mut self, sp: span, msg: &str) {\n+        fn span_err(&self, sp: span, msg: &str) {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_err(sp, msg);\n         }\n-        fn span_warn(@mut self, sp: span, msg: &str) {\n+        fn span_warn(&self, sp: span, msg: &str) {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_warn(sp, msg);\n         }\n-        fn span_unimpl(@mut self, sp: span, msg: &str) -> ! {\n+        fn span_unimpl(&self, sp: span, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_unimpl(sp, msg);\n         }\n-        fn span_bug(@mut self, sp: span, msg: &str) -> ! {\n+        fn span_bug(&self, sp: span, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_bug(sp, msg);\n         }\n-        fn bug(@mut self, msg: &str) -> ! {\n+        fn bug(&self, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.handler().bug(msg);\n         }\n-        fn next_id(@mut self) -> ast::node_id {\n+        fn next_id(&self) -> ast::node_id {\n             return parse::next_node_id(self.parse_sess);\n         }\n-        fn trace_macros(@mut self) -> bool {\n-            self.trace_mac\n+        fn trace_macros(&self) -> bool {\n+            *self.trace_mac\n         }\n-        fn set_trace_macros(@mut self, x: bool) {\n-            self.trace_mac = x\n+        fn set_trace_macros(&self, x: bool) {\n+            *self.trace_mac = x\n         }\n-        fn str_of(@mut self, id: ast::ident) -> ~str {\n+        fn str_of(&self, id: ast::ident) -> ~str {\n             copy *self.parse_sess.interner.get(id)\n         }\n-        fn ident_of(@mut self, st: ~str) -> ast::ident {\n+        fn ident_of(&self, st: ~str) -> ast::ident {\n             self.parse_sess.interner.intern(@/*bad*/ copy st)\n         }\n     }\n-    let imp: @mut CtxtRepr = @mut CtxtRepr {\n+    let imp: @CtxtRepr = @CtxtRepr {\n         parse_sess: parse_sess,\n         cfg: cfg,\n         backtrace: @mut None,\n-        mod_path: ~[],\n-        trace_mac: false\n+        mod_path: @mut ~[],\n+        trace_mac: @mut false\n     };\n     ((imp) as @ext_ctxt)\n }"}, {"sha": "0f2ad4cd54a3da7dacda4c9e33bc6e974ec0e23c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -27,6 +27,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                    fld: @ast_fold,\n                    orig: @fn(&expr_, span, @ast_fold) -> (expr_, span))\n                 -> (expr_, span) {\n+    let mut cx = cx;\n     match *e {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n@@ -112,6 +113,8 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n                         fld: @ast_fold,\n                         orig: @fn(&ast::_mod, @ast_fold) -> ast::_mod)\n                      -> ast::_mod {\n+    let mut cx = cx;\n+\n     // Fold the contents first:\n     let module_ = orig(module_, fld);\n "}, {"sha": "8799bd064f6581f337d5e69419eb425e75c420c8", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -38,11 +38,11 @@ updating the states using rule (2) until there are no changes.\n */\n \n use ext::base::ext_ctxt;\n-use ext::pipes::proto::protocol;\n+use ext::pipes::proto::{protocol_};\n \n use std::bitv::Bitv;\n \n-pub fn analyze(proto: protocol, _cx: @ext_ctxt) {\n+pub fn analyze(proto: @mut protocol_, _cx: @ext_ctxt) {\n     debug!(\"initializing colive analysis\");\n     let num_states = proto.num_states();\n     let mut colive = do (copy proto.states).map_to_vec |state| {"}, {"sha": "647c7741bd8972f5ca4de5eadc1acf6b7a53b203", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -138,34 +138,34 @@ pub struct protocol_ {\n \n pub impl protocol_ {\n     /// Get a state.\n-    fn get_state(&mut self, name: ~str) -> state {\n+    fn get_state(&self, name: ~str) -> state {\n         self.states.find(|i| i.name == name).get()\n     }\n \n-    fn get_state_by_id(&mut self, id: uint) -> state { self.states[id] }\n+    fn get_state_by_id(&self, id: uint) -> state { self.states[id] }\n \n-    fn has_state(&mut self, name: ~str) -> bool {\n+    fn has_state(&self, name: ~str) -> bool {\n         self.states.find(|i| i.name == name).is_some()\n     }\n \n-    fn filename(&mut self) -> ~str {\n+    fn filename(&self) -> ~str {\n         ~\"proto://\" + self.name\n     }\n \n-    fn num_states(&mut self) -> uint {\n+    fn num_states(&self) -> uint {\n         let states = &mut *self.states;\n         states.len()\n     }\n \n-    fn has_ty_params(&mut self) -> bool {\n+    fn has_ty_params(&self) -> bool {\n         for self.states.each |s| {\n             if s.generics.ty_params.len() > 0 {\n                 return true;\n             }\n         }\n         false\n     }\n-    fn is_bounded(&mut self) -> bool {\n+    fn is_bounded(&self) -> bool {\n         let bounded = self.bounded.get();\n         bounded\n     }\n@@ -179,7 +179,7 @@ pub impl protocol_ {\n                       generics: ast::Generics)\n                    -> state {\n         let messages = @mut ~[];\n-        let states = &*self.states;\n+        let states = &mut *self.states;\n \n         let state = @state_ {\n             id: states.len(),\n@@ -192,7 +192,7 @@ pub impl protocol_ {\n             proto: self\n         };\n \n-        self.states.push(state);\n+        states.push(state);\n         state\n     }\n }"}, {"sha": "8956622a06b589d98ca783ce4df8de7e8e4615a6", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -163,7 +163,7 @@ fn string_advance_token(r: @mut StringReader) {\n     }\n }\n \n-fn byte_offset(rdr: @mut StringReader) -> BytePos {\n+fn byte_offset(rdr: &StringReader) -> BytePos {\n     (rdr.pos - rdr.filemap.start_pos)\n }\n \n@@ -176,7 +176,7 @@ pub fn get_str_from(rdr: @mut StringReader, start: BytePos) -> ~str {\n \n // EFFECT: advance the StringReader by one character. If a newline is\n // discovered, add it to the FileMap's list of line start offsets.\n-pub fn bump(rdr: @mut StringReader) {\n+pub fn bump(rdr: &mut StringReader) {\n     rdr.last_pos = rdr.pos;\n     let current_byte_offset = byte_offset(rdr).to_uint();;\n     if current_byte_offset < (*rdr.src).len() {"}, {"sha": "6b8411a9ead15013d379164ff53a2732ca827cbd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -1602,9 +1602,9 @@ pub impl Parser {\n             token::LBRACE | token::LPAREN | token::LBRACKET => {\n                 self.parse_matcher_subseq(\n                     name_idx,\n-                    &*self.token,\n+                    *self.token,\n                     // tjc: not sure why we need a copy\n-                    &token::flip_delimiter(&*self.token)\n+                    token::flip_delimiter(&*self.token)\n                 )\n             }\n             _ => self.fatal(~\"expected open delimiter\")\n@@ -1618,15 +1618,15 @@ pub impl Parser {\n     fn parse_matcher_subseq(\n         &self,\n         name_idx: @mut uint,\n-        bra: &token::Token,\n-        ket: &token::Token\n+        bra: token::Token,\n+        ket: token::Token\n     ) -> ~[matcher] {\n         let mut ret_val = ~[];\n         let mut lparens = 0u;\n \n-        self.expect(bra);\n+        self.expect(&bra);\n \n-        while *self.token != *ket || lparens > 0u {\n+        while *self.token != ket || lparens > 0u {\n             if *self.token == token::LPAREN { lparens += 1u; }\n             if *self.token == token::RPAREN { lparens -= 1u; }\n             ret_val.push(self.parse_matcher(name_idx));\n@@ -1646,8 +1646,8 @@ pub impl Parser {\n                 let name_idx_lo = *name_idx;\n                 let ms = self.parse_matcher_subseq(\n                     name_idx,\n-                    &token::LPAREN,\n-                    &token::RPAREN\n+                    token::LPAREN,\n+                    token::RPAREN\n                 );\n                 if ms.len() == 0u {\n                     self.fatal(~\"repetition body must be nonempty\");\n@@ -3688,12 +3688,11 @@ pub impl Parser {\n                                first_item_attrs: ~[attribute])\n                             -> foreign_mod {\n         let ParsedItemsAndViewItems {\n-            attrs_remaining: attrs_remaining,\n+            attrs_remaining: _,\n             view_items: view_items,\n             items: _,\n             foreign_items: foreign_items\n         } = self.parse_foreign_items(first_item_attrs, true);\n-        let _initial_attrs = attrs_remaining;\n         assert!(*self.token == token::RBRACE);\n         ast::foreign_mod {\n             sort: sort,"}, {"sha": "43f62d72a9fade947212a5b10446796094457d3d", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -491,9 +491,9 @@ pub impl Printer {\n           }\n           END => {\n             debug!(\"print END -> pop END\");\n-            let print_stack = &*self.print_stack;\n+            let print_stack = &mut *self.print_stack;\n             assert!((print_stack.len() != 0u));\n-            self.print_stack.pop();\n+            print_stack.pop();\n           }\n           BREAK(b) => {\n             let top = self.get_top();"}, {"sha": "6f3d6604d5b98de8cce1f7928383f8eadbc9b385", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -72,6 +72,12 @@ pub fn end(s: @ps) {\n }\n \n pub fn rust_printer(writer: @io::Writer, intr: @ident_interner) -> @ps {\n+    return rust_printer_annotated(writer, intr, no_ann());\n+}\n+\n+pub fn rust_printer_annotated(writer: @io::Writer,\n+                              intr: @ident_interner,\n+                              ann: pp_ann) -> @ps {\n     return @ps {\n         s: pp::mk_printer(writer, default_columns),\n         cm: None::<@CodeMap>,\n@@ -83,7 +89,7 @@ pub fn rust_printer(writer: @io::Writer, intr: @ident_interner) -> @ps {\n             cur_lit: 0\n         },\n         boxes: @mut ~[],\n-        ann: no_ann()\n+        ann: ann\n     };\n }\n "}, {"sha": "e3a87277622184d6ca2afee42a0b0a2faa7b676a", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -44,10 +44,10 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n             None => (),\n         }\n \n-        let vect = &*self.vect;\n+        let vect = &mut *self.vect;\n         let new_idx = vect.len();\n         self.map.insert(val, new_idx);\n-        self.vect.push(val);\n+        vect.push(val);\n         new_idx\n     }\n "}, {"sha": "90dd49d684843165bb58f2592a7f21685a03a8e7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -21,6 +21,12 @@ use opt_vec::OptVec;\n // children (potentially passing in different contexts to each), call\n // visit::visit_* to apply the default traversal algorithm (again, it can\n // override the context), or prevent deeper traversal by doing nothing.\n+//\n+// Note: it is an important invariant that the default visitor walks the body\n+// of a function in \"execution order\" (more concretely, reverse post-order\n+// with respect to the CFG implied by the AST), meaning that if AST node A may\n+// execute before AST node B, then A is visited first.  The borrow checker in\n+// particular relies on this property.\n \n // Our typesystem doesn't do circular types, so the visitor record can not\n // hold functions that take visitors. A vt enum is used to break the cycle."}, {"sha": "a491379153e1a227a67a20cc39fabc3f3543b416", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -683,6 +683,20 @@ rust_task_local_data_atexit(rust_task *task, void (*cleanup_fn)(void *data)) {\n     task->task_local_data_cleanup = cleanup_fn;\n }\n \n+// set/get/atexit task_borrow_list can run on the rust stack for speed.\n+extern \"C\" void *\n+rust_take_task_borrow_list(rust_task *task) {\n+    void *r = task->borrow_list;\n+    task->borrow_list = NULL;\n+    return r;\n+}\n+extern \"C\" void\n+rust_set_task_borrow_list(rust_task *task, void *data) {\n+    assert(task->borrow_list == NULL);\n+    assert(data != NULL);\n+    task->borrow_list = data;\n+}\n+\n extern \"C\" void\n task_clear_event_reject(rust_task *task) {\n     task->clear_event_reject();"}, {"sha": "360d611492853814a7abcb982835240015891874", "filename": "src/rt/rust_env.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Frt%2Frust_env.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Frt%2Frust_env.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_env.cpp?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -24,6 +24,7 @@\n #define RUST_SEED \"RUST_SEED\"\n #define RUST_POISON_ON_FREE \"RUST_POISON_ON_FREE\"\n #define RUST_DEBUG_MEM \"RUST_DEBUG_MEM\"\n+#define RUST_DEBUG_BORROW \"RUST_DEBUG_BORROW\"\n \n #if defined(__WIN32__)\n static int\n@@ -130,6 +131,7 @@ load_env(int argc, char **argv) {\n     env->argc = argc;\n     env->argv = argv;\n     env->debug_mem = getenv(RUST_DEBUG_MEM) != NULL;\n+    env->debug_borrow = getenv(RUST_DEBUG_BORROW) != NULL;\n     return env;\n }\n "}, {"sha": "b897f0c09a90b7f625667d2a1b753ccf5fc5a981", "filename": "src/rt/rust_env.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Frt%2Frust_env.h", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Frt%2Frust_env.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_env.h?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -28,6 +28,7 @@ struct rust_env {\n     int argc;\n     char **argv;\n     rust_bool debug_mem;\n+    rust_bool debug_borrow;\n };\n \n rust_env* load_env(int argc, char **argv);"}, {"sha": "23e705357685d6841bf3bd6cfedf7f8ebd47cb41", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -42,6 +42,7 @@ rust_task::rust_task(rust_sched_loop *sched_loop, rust_task_state state,\n     total_stack_sz(0),\n     task_local_data(NULL),\n     task_local_data_cleanup(NULL),\n+    borrow_list(NULL),\n     state(state),\n     cond(NULL),\n     cond_name(\"none\"),\n@@ -75,6 +76,16 @@ rust_task::delete_this()\n     assert(ref_count == 0); // ||\n     //   (ref_count == 1 && this == sched->root_task));\n \n+    if (borrow_list) {\n+        // NOTE should free borrow_list from within rust code!\n+        // If there is a pointer in there, it is a ~[BorrowRecord] pointer,\n+        // which are currently allocated with LIBC malloc/free. But this is\n+        // not really the right way to do this, we should be freeing this\n+        // pointer from Rust code.\n+        free(borrow_list);\n+        borrow_list = NULL;\n+    }\n+\n     sched_loop->release_task(this);\n }\n "}, {"sha": "b76a177e1c87aefb0e4fbc992c1dd6c474bf30db", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -245,6 +245,11 @@ rust_task : public kernel_owned<rust_task>\n     void *task_local_data;\n     void (*task_local_data_cleanup)(void *data);\n \n+    // Contains a ~[BorrowRecord] pointer, or NULL.\n+    //\n+    // Used by borrow management code in libcore/unstable/lang.rs.\n+    void *borrow_list;\n+\n private:\n \n     // Protects state, cond, cond_name"}, {"sha": "1c3f6370deda4fecc0bde79ed07e28c6e2e0105d", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -233,3 +233,5 @@ rust_boxed_region_malloc\n rust_boxed_region_free\n rust_try\n rust_begin_unwind\n+rust_take_task_borrow_list\n+rust_set_task_borrow_list"}, {"sha": "61fb754f7619fa9814e65d634b7a3339c01845f2", "filename": "src/test/compile-fail/access-mode-in-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -16,6 +16,6 @@ fn unpack(_unpack: &fn(v: &sty) -> ~[int]) {}\n fn main() {\n     let _foo = unpack(|s| {\n         // Test that `s` is moved here.\n-        match *s { sty(v) => v } //~ ERROR moving out of dereference of immutable & pointer\n+        match *s { sty(v) => v } //~ ERROR cannot move out\n     });\n }"}, {"sha": "85f60f34bdb805d68acb18130deec888ace3ce2a", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -17,6 +17,7 @@ fn main() {\n         y = Some(x.downgrade(write_mode));\n         //~^ ERROR cannot infer an appropriate lifetime\n     }\n+    y.get();\n     // Adding this line causes a method unification failure instead\n     // do (&option::unwrap(y)).read |state| { assert!(*state == 1); }\n }"}, {"sha": "c7ae6a0dc6c52ff9b351e4c3a73bb9355cad94bb", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -17,6 +17,7 @@ fn main() {\n     do x.write_downgrade |write_mode| {\n         y = Some(write_mode);\n     }\n+    y.get();\n     // Adding this line causes a method unification failure instead\n     // do (&option::unwrap(y)).write |state| { assert!(*state == 1); }\n }"}, {"sha": "1d9249bc17b1fff82291554020d58821b45471bb", "filename": "src/test/compile-fail/attempted-access-non-fatal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fattempted-access-non-fatal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fattempted-access-non-fatal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattempted-access-non-fatal.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -11,6 +11,6 @@\n // Check that bogus field access is non-fatal\n fn main() {\n     let x = 0;\n-    debug!(x.foo); //~ ERROR attempted access of field\n-    debug!(x.bar); //~ ERROR attempted access of field\n+    let _ = x.foo; //~ ERROR attempted access of field\n+    let _ = x.bar; //~ ERROR attempted access of field\n }"}, {"sha": "83baedc78927718371cb00840480a1c6c4532ca9", "filename": "src/test/compile-fail/borrowck-addr-of-upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n fn foo(x: @int) -> @fn() -> &'static int {\n-    let result: @fn() -> &'static int = || &*x;  //~ ERROR illegal borrow\n+    let result: @fn() -> &'static int = || &*x;  //~ ERROR cannot root\n     result\n }\n \n fn bar(x: @int) -> @fn() -> &int {\n-    let result: @fn() -> &int = || &*x; //~ ERROR illegal borrow\n+    let result: @fn() -> &int = || &*x; //~ ERROR cannot root\n     result\n }\n "}, {"sha": "9b21cbf9768f7679fe1841060754cb97d9022a40", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -17,9 +17,11 @@ fn a() {\n     let mut p = ~[1];\n \n     // Create an immutable pointer into p's contents:\n-    let _q: &int = &p[0]; //~ NOTE loan of mutable vec content granted here\n+    let q: &int = &p[0];\n \n-    p[0] = 5; //~ ERROR assigning to mutable vec content prohibited due to outstanding loan\n+    p[0] = 5; //~ ERROR cannot assign\n+\n+    debug!(\"%d\", *q);\n }\n \n fn borrow(_x: &[int], _f: &fn()) {}\n@@ -30,8 +32,8 @@ fn b() {\n \n     let mut p = ~[1];\n \n-    do borrow(p) { //~ NOTE loan of mutable vec content granted here\n-        p[0] = 5; //~ ERROR assigning to mutable vec content prohibited due to outstanding loan\n+    do borrow(p) {\n+        p[0] = 5; //~ ERROR cannot assign to\n     }\n }\n "}, {"sha": "ccd0542ca7f591c338570cff8ad98dce9e6c4c70", "filename": "src/test/compile-fail/borrowck-assign-comp.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -12,32 +12,34 @@ struct point { x: int, y: int }\n \n fn a() {\n     let mut p = point {x: 3, y: 4};\n-    let _q = &p; //~ NOTE loan of mutable local variable granted here\n+    let q = &p;\n \n     // This assignment is illegal because the field x is not\n     // inherently mutable; since `p` was made immutable, `p.x` is now\n     // immutable.  Otherwise the type of &_q.x (&int) would be wrong.\n-    p.x = 5; //~ ERROR assigning to mutable field prohibited due to outstanding loan\n+    p.x = 5; //~ ERROR cannot assign to `p.x`\n+    q.x;\n }\n \n fn c() {\n     // this is sort of the opposite.  We take a loan to the interior of `p`\n     // and then try to overwrite `p` as a whole.\n \n     let mut p = point {x: 3, y: 4};\n-    let _q = &p.y; //~ NOTE loan of mutable local variable granted here\n-    p = point {x: 5, y: 7};//~ ERROR assigning to mutable local variable prohibited due to outstanding loan\n-    copy p;\n+    let q = &p.y;\n+    p = point {x: 5, y: 7};//~ ERROR cannot assign to `p`\n+    p.x; // silence warning\n+    *q; // stretch loan\n }\n \n fn d() {\n     // just for completeness's sake, the easy case, where we take the\n     // address of a subcomponent and then modify that subcomponent:\n \n     let mut p = point {x: 3, y: 4};\n-    let _q = &p.y; //~ NOTE loan of mutable field granted here\n-    p.y = 5; //~ ERROR assigning to mutable field prohibited due to outstanding loan\n-    copy p;\n+    let q = &p.y;\n+    p.y = 5; //~ ERROR cannot assign to `p.y`\n+    *q;\n }\n \n fn main() {"}, {"sha": "f0dc28b736d1668f8e3f86634f26660d6be5225c", "filename": "src/test/compile-fail/borrowck-assign-to-constants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-constants.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -12,6 +12,6 @@ static foo: int = 5;\n \n fn main() {\n     // assigning to various global constants\n-    None = Some(3); //~ ERROR assigning to static item\n-    foo = 6; //~ ERROR assigning to static item\n+    None = Some(3); //~ ERROR cannot assign to immutable static item\n+    foo = 6; //~ ERROR cannot assign to immutable static item\n }"}, {"sha": "fcaba0adc46eb710860019d8cbaf437e51c5ca90", "filename": "src/test/compile-fail/borrowck-assign-to-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-enum.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -12,5 +12,5 @@ struct foo(int);\n \n fn main() {\n     let x = foo(3);\n-    *x = 4; //~ ERROR assigning to anonymous field\n+    *x = 4; //~ ERROR cannot assign to immutable anonymous field\n }"}, {"sha": "2ee5ecfcb9ce0402496aa90a66bf75862a8b858a", "filename": "src/test/compile-fail/borrowck-assign-to-subfield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-subfield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-subfield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-subfield.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -34,6 +34,6 @@ fn main() {\n \n     // in these cases we pass through a box, so the mut\n     // of the box is dominant\n-    p.x.a = 2;     //~ ERROR assigning to immutable field\n+    p.x.a = 2;     //~ ERROR cannot assign to immutable field\n     p.z.a = 2;\n }"}, {"sha": "2ba5d0473cc62d37d26ae8630c7d2b7de77bc403", "filename": "src/test/compile-fail/borrowck-auto-mut-ref-to-immut-var.rs", "status": "renamed", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -14,17 +14,13 @@ struct Foo {\n     x: int\n }\n \n-trait Stuff {\n-    fn printme(self);\n-}\n-\n-impl<'self> Stuff for &'self mut Foo {\n-    fn printme(self) {\n+pub impl Foo {\n+    fn printme(&mut self) {\n         io::println(fmt!(\"%d\", self.x));\n     }\n }\n \n fn main() {\n     let x = Foo { x: 3 };\n-    x.printme();    //~ ERROR illegal borrow\n+    x.printme();    //~ ERROR cannot borrow\n }", "previous_filename": "src/test/compile-fail/auto-ref-borrowck-failure.rs"}, {"sha": "192fe669f57aedd165ba8af791c12b87bba72d6b", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -17,10 +17,10 @@ pub impl X {\n }\n fn main() {\n     let mut x = X(Right(main));\n-    do (&mut x).with |opt| {  //~ ERROR illegal borrow\n+    do (&mut x).with |opt| {\n         match opt {\n             &Right(ref f) => {\n-                x = X(Left((0,0))); //~ ERROR assigning to captured outer mutable variable\n+                x = X(Left((0,0))); //~ ERROR cannot assign to `x`\n                 (*f)()\n             },\n             _ => fail!()"}, {"sha": "ff1ec38ad6406b992e61475073a98ded1eb6f548", "filename": "src/test/compile-fail/borrowck-bad-nested-calls-free.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we detect nested calls that could free pointers evaluated\n+// for earlier arguments.\n+\n+fn rewrite(v: &mut ~uint) -> uint {\n+    *v = ~22;\n+    **v\n+}\n+\n+fn add(v: &uint, w: uint) -> uint {\n+    *v + w\n+}\n+\n+fn implicit() {\n+    let mut a = ~1;\n+\n+    // Note the danger here:\n+    //\n+    //    the pointer for the first argument has already been\n+    //    evaluated, but it gets freed when evaluating the second\n+    //    argument!\n+    add(\n+        a,\n+        rewrite(&mut a)); //~ ERROR cannot borrow\n+}\n+\n+fn explicit() {\n+    let mut a = ~1;\n+    add(\n+        &*a,\n+        rewrite(&mut a)); //~ ERROR cannot borrow\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "0adf486b8b3ab30b011b45c82e3e3e089f19cf91", "filename": "src/test/compile-fail/borrowck-bad-nested-calls-move.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we detect nested calls that could free pointers evaluated\n+// for earlier arguments.\n+\n+fn rewrite(v: &mut ~uint) -> uint {\n+    *v = ~22;\n+    **v\n+}\n+\n+fn add(v: &uint, w: ~uint) -> uint {\n+    *v + *w\n+}\n+\n+fn implicit() {\n+    let mut a = ~1;\n+\n+    // Note the danger here:\n+    //\n+    //    the pointer for the first argument has already been\n+    //    evaluated, but it gets moved when evaluating the second\n+    //    argument!\n+    add(\n+        a,\n+        a); //~ ERROR cannot move\n+}\n+\n+fn explicit() {\n+    let mut a = ~1;\n+    add(\n+        &*a,\n+        a); //~ ERROR cannot move\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "1051c5829ec387cd9e5957a6b48e8f042a13bdec", "filename": "src/test/compile-fail/borrowck-borrow-from-owned-ptr.rs", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -22,32 +22,37 @@ fn make_foo() -> ~Foo { fail!() }\n \n fn borrow_same_field_twice_mut_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n-    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1;\n+    let _bar2 = &mut foo.bar1;  //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_same_field_twice_mut_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n-    let _bar2 = &foo.bar1;  //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1;\n+    let _bar2 = &foo.bar1;  //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_same_field_twice_imm_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1;\n-    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+    let bar1 = &foo.bar1;\n+    let _bar2 = &mut foo.bar1;  //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_same_field_twice_imm_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1;\n+    let bar1 = &foo.bar1;\n     let _bar2 = &foo.bar1;\n+    *bar1;\n }\n \n-fn borrow_both_mut() {\n+fn borrow_both_fields_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n+    let bar1 = &mut foo.bar1;\n     let _bar2 = &mut foo.bar2;\n+    *bar1;\n }\n \n fn borrow_both_mut_pattern() {\n@@ -59,66 +64,77 @@ fn borrow_both_mut_pattern() {\n \n fn borrow_var_and_pattern() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n+    let bar1 = &mut foo.bar1;\n     match *foo {\n         Foo { bar1: ref mut _bar1, bar2: _ } => {}\n-        //~^ ERROR conflicts with prior loan\n+        //~^ ERROR cannot borrow\n     }\n+    *bar1;\n }\n \n fn borrow_mut_and_base_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n-    let _foo1 = &foo.bar1; //~ ERROR conflicts with prior loan\n-    let _foo2 = &*foo; //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &foo.bar1; //~ ERROR cannot borrow\n+    let _foo2 = &*foo; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_mut_and_base_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n-    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &mut foo.bar1; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_mut_and_base_mut2() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n-    let _foo2 = &mut *foo; //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1.int1;\n+    let _foo2 = &mut *foo; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_imm_and_base_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1.int1;\n-    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+    let bar1 = &foo.bar1.int1;\n+    let _foo1 = &mut foo.bar1; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_imm_and_base_mut2() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1.int1;\n-    let _foo2 = &mut *foo; //~ ERROR conflicts with prior loan\n+    let bar1 = &foo.bar1.int1;\n+    let _foo2 = &mut *foo; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_imm_and_base_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1.int1;\n+    let bar1 = &foo.bar1.int1;\n     let _foo1 = &foo.bar1;\n     let _foo2 = &*foo;\n+    *bar1;\n }\n \n fn borrow_mut_and_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n+    let bar1 = &mut foo.bar1;\n     let _foo1 = &foo.bar2;\n+    *bar1;\n }\n \n fn borrow_mut_from_imm() {\n     let foo = make_foo();\n-    let _bar1 = &mut foo.bar1; //~ ERROR illegal borrow\n+    let bar1 = &mut foo.bar1; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_long_path_both_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n-    let _foo1 = &mut foo.bar2.int2;\n+    let bar1 = &mut foo.bar1.int1;\n+    let foo1 = &mut foo.bar2.int2;\n+    *bar1;\n+    *foo1;\n }\n \n fn main() {}"}, {"sha": "cdcf50c906e3655234f3a9cdd276d505a8e99355", "filename": "src/test/compile-fail/borrowck-borrow-from-stack-variable.rs", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -22,32 +22,37 @@ fn make_foo() -> Foo { fail!() }\n \n fn borrow_same_field_twice_mut_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n-    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1;\n+    let _bar2 = &mut foo.bar1;  //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_same_field_twice_mut_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n-    let _bar2 = &foo.bar1;  //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1;\n+    let _bar2 = &foo.bar1;  //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_same_field_twice_imm_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1;\n-    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+    let bar1 = &foo.bar1;\n+    let _bar2 = &mut foo.bar1;  //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_same_field_twice_imm_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1;\n+    let bar1 = &foo.bar1;\n     let _bar2 = &foo.bar1;\n+    *bar1;\n }\n \n fn borrow_both_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n+    let bar1 = &mut foo.bar1;\n     let _bar2 = &mut foo.bar2;\n+    *bar1;\n }\n \n fn borrow_both_mut_pattern() {\n@@ -59,66 +64,76 @@ fn borrow_both_mut_pattern() {\n \n fn borrow_var_and_pattern() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n+    let bar1 = &mut foo.bar1;\n     match foo {\n-        Foo { bar1: ref mut _bar1, bar2: _ } => {}\n-        //~^ ERROR conflicts with prior loan\n+        Foo { bar1: ref mut _bar1, bar2: _ } => {} //\n+        //~^ ERROR cannot borrow\n     }\n+    *bar1;\n }\n \n fn borrow_mut_and_base_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n-    let _foo1 = &foo.bar1; //~ ERROR conflicts with prior loan\n-    let _foo2 = &foo; //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &foo.bar1; //~ ERROR cannot borrow\n+    let _foo2 = &foo; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_mut_and_base_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n-    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &mut foo.bar1; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_mut_and_base_mut2() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n-    let _foo2 = &mut foo; //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1.int1;\n+    let _foo2 = &mut foo; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_imm_and_base_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1.int1;\n-    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+    let bar1 = &foo.bar1.int1;\n+    let _foo1 = &mut foo.bar1; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_imm_and_base_mut2() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1.int1;\n-    let _foo2 = &mut foo; //~ ERROR conflicts with prior loan\n+    let bar1 = &foo.bar1.int1;\n+    let _foo2 = &mut foo; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_imm_and_base_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1.int1;\n+    let bar1 = &foo.bar1.int1;\n     let _foo1 = &foo.bar1;\n     let _foo2 = &foo;\n+    *bar1;\n }\n \n fn borrow_mut_and_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n+    let bar1 = &mut foo.bar1;\n     let _foo1 = &foo.bar2;\n+    *bar1;\n }\n \n fn borrow_mut_from_imm() {\n     let foo = make_foo();\n-    let _bar1 = &mut foo.bar1; //~ ERROR illegal borrow\n+    let bar1 = &mut foo.bar1; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_long_path_both_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n+    let bar1 = &mut foo.bar1.int1;\n     let _foo1 = &mut foo.bar2.int2;\n+    *bar1;\n }\n \n fn main() {}"}, {"sha": "1e5c4c5cc410c4300769e68505e2cc5e635c740b", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -28,5 +28,6 @@ fn defer<'r>(x: &'r [&'r str]) -> defer<'r> {\n }\n \n fn main() {\n-    let _x = defer(~[\"Goodbye\", \"world!\"]); //~ ERROR illegal borrow\n+    let x = defer(~[\"Goodbye\", \"world!\"]); //~ ERROR borrowed value does not live long enough\n+    x.x[0];\n }"}, {"sha": "887cb59930ebccc8358662b99a0cc5ed83f99f56", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -15,7 +15,7 @@ use core::hashmap::HashMap;\n fn main() {\n     let mut buggy_map :HashMap<uint, &uint> =\n       HashMap::new::<uint, &uint>();\n-    buggy_map.insert(42, &*~1); //~ ERROR illegal borrow\n+    buggy_map.insert(42, &*~1); //~ ERROR borrowed value does not live long enough\n \n     // but it is ok if we use a temporary\n     let tmp = ~2;"}, {"sha": "3abd19e5a11364d942dad58988a8be938087c8ee", "filename": "src/test/compile-fail/borrowck-call-method-from-mut-aliasable.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -27,13 +27,15 @@ fn a(x: &mut Foo) {\n fn b(x: &Foo) {\n     x.f();\n     x.g();\n-    x.h(); //~ ERROR illegal borrow\n+    x.h(); //~ ERROR cannot borrow\n }\n \n fn c(x: &const Foo) {\n-    x.f(); //~ ERROR illegal borrow unless pure\n+    x.f(); //~ ERROR cannot borrow\n+    //~^ ERROR unsafe borrow\n     x.g();\n-    x.h(); //~ ERROR illegal borrow\n+    x.h(); //~ ERROR cannot borrow\n+    //~^ ERROR unsafe borrow\n }\n \n fn main() {"}, {"sha": "8af10231921aaac5a5774be33bd53ad7c65161e1", "filename": "src/test/compile-fail/borrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -10,9 +10,9 @@\n \n fn main() {\n     let mut _a = 3;\n-    let _b = &mut _a; //~ NOTE loan of mutable local variable granted here\n+    let _b = &mut _a;\n     {\n         let _c = &*_b;\n-        _a = 4; //~ ERROR assigning to mutable local variable prohibited\n+        _a = 4; //~ ERROR cannot assign to `_a`\n     }\n }"}, {"sha": "109753b38e70b09b7d8ed93c1942b5aaf5561975", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -23,8 +23,8 @@ pub impl Foo {\n }\n \n fn bar(f: &mut Foo) {\n-  do f.foo |a| { //~ NOTE prior loan as mutable granted here\n-    f.n.insert(*a); //~ ERROR conflicts with prior loan\n+  do f.foo |a| {\n+    f.n.insert(*a); //~ ERROR cannot borrow\n   }\n }\n "}, {"sha": "8bcd5f9a72e70989164dbc4074cfa7f133070d4a", "filename": "src/test/compile-fail/borrowck-issue-2657-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -10,9 +10,9 @@\n \n fn main() {\n let x = Some(~1);\n-match x { //~ NOTE loan of immutable local variable granted here\n+match x {\n   Some(ref _y) => {\n-    let _a = x; //~ ERROR moving out of immutable local variable prohibited due to outstanding loan\n+    let _a = x; //~ ERROR cannot move\n   }\n   _ => {}\n }"}, {"sha": "fac805c57ca09a3ed53457be72f05c0e0d496c01", "filename": "src/test/compile-fail/borrowck-issue-2657-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -12,7 +12,7 @@ fn main() {\n let x = Some(~1);\n match x {\n   Some(ref y) => {\n-    let _b = *y; //~ ERROR moving out of dereference of immutable & pointer\n+    let _b = *y; //~ ERROR cannot move out\n   }\n   _ => {}\n }"}, {"sha": "563f63b98be05528580535b642cbc6bc77fd11f6", "filename": "src/test/compile-fail/borrowck-lend-flow-if.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Note: the borrowck analysis is currently flow-insensitive.\n+// Therefore, some of these errors are marked as spurious and could be\n+// corrected by a simple change to the analysis.  The others are\n+// either genuine or would require more advanced changes.  The latter\n+// cases are noted.\n+\n+fn borrow(_v: &int) {}\n+fn borrow_mut(_v: &mut int) {}\n+fn cond() -> bool { fail!() }\n+fn for_func(_f: &fn() -> bool) { fail!() }\n+fn produce<T>() -> T { fail!(); }\n+\n+fn inc(v: &mut ~int) {\n+    *v = ~(**v + 1);\n+}\n+\n+fn pre_freeze_cond() {\n+    // In this instance, the freeze is conditional and starts before\n+    // the mut borrow.\n+\n+    let mut v = ~3;\n+    let _w;\n+    if cond() {\n+        _w = &v;\n+    }\n+    borrow_mut(v); //~ ERROR cannot borrow\n+}\n+\n+fn pre_freeze_else() {\n+    // In this instance, the freeze and mut borrow are on separate sides\n+    // of the if.\n+\n+    let mut v = ~3;\n+    let _w;\n+    if cond() {\n+        _w = &v;\n+    } else {\n+        borrow_mut(v);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b6384ad9590abd826d00dd206ca85f5465d5c623", "filename": "src/test/compile-fail/borrowck-lend-flow-loop.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -0,0 +1,164 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Note: the borrowck analysis is currently flow-insensitive.\n+// Therefore, some of these errors are marked as spurious and could be\n+// corrected by a simple change to the analysis.  The others are\n+// either genuine or would require more advanced changes.  The latter\n+// cases are noted.\n+\n+fn borrow(_v: &int) {}\n+fn borrow_mut(_v: &mut int) {}\n+fn cond() -> bool { fail!() }\n+fn for_func(_f: &fn() -> bool) { fail!() }\n+fn produce<T>() -> T { fail!(); }\n+\n+fn inc(v: &mut ~int) {\n+    *v = ~(**v + 1);\n+}\n+\n+fn loop_overarching_alias_mut() {\n+    // In this instance, the borrow encompasses the entire loop.\n+\n+    let mut v = ~3;\n+    let mut x = &mut v;\n+    **x += 1;\n+    loop {\n+        borrow(v); //~ ERROR cannot borrow\n+    }\n+}\n+\n+fn block_overarching_alias_mut() {\n+    // In this instance, the borrow encompasses the entire closure call.\n+\n+    let mut v = ~3;\n+    let mut x = &mut v;\n+    for 3.times {\n+        borrow(v); //~ ERROR cannot borrow\n+    }\n+    *x = ~5;\n+}\n+\n+fn loop_aliased_mut() {\n+    // In this instance, the borrow is carried through the loop.\n+\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &w;\n+    loop {\n+        borrow_mut(v); //~ ERROR cannot borrow\n+        _x = &v;\n+    }\n+}\n+\n+fn while_aliased_mut() {\n+    // In this instance, the borrow is carried through the loop.\n+\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &w;\n+    while cond() {\n+        borrow_mut(v); //~ ERROR cannot borrow\n+        _x = &v;\n+    }\n+}\n+\n+fn for_loop_aliased_mut() {\n+    // In this instance, the borrow is carried through the loop.\n+\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &w;\n+    for for_func {\n+        borrow_mut(v); //~ ERROR cannot borrow\n+        _x = &v;\n+    }\n+}\n+\n+fn loop_aliased_mut_break() {\n+    // In this instance, the borrow is carried through the loop.\n+\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &w;\n+    loop {\n+        borrow_mut(v);\n+        _x = &v;\n+        break;\n+    }\n+    borrow_mut(v); //~ ERROR cannot borrow\n+}\n+\n+fn while_aliased_mut_break() {\n+    // In this instance, the borrow is carried through the loop.\n+\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &w;\n+    while cond() {\n+        borrow_mut(v);\n+        _x = &v;\n+        break;\n+    }\n+    borrow_mut(v); //~ ERROR cannot borrow\n+}\n+\n+fn for_aliased_mut_break() {\n+    // In this instance, the borrow is carried through the loop.\n+\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &w;\n+    for for_func {\n+        // here we cannot be sure that `for_func` respects the break below\n+        borrow_mut(v); //~ ERROR cannot borrow\n+        _x = &v;\n+        break;\n+    }\n+    borrow_mut(v); //~ ERROR cannot borrow\n+}\n+\n+fn while_aliased_mut_cond(cond: bool, cond2: bool) {\n+    let mut v = ~3, w = ~4;\n+    let mut x = &mut w;\n+    while cond {\n+        **x += 1;\n+        borrow(v); //~ ERROR cannot borrow\n+        if cond2 {\n+            x = &mut v; //~ ERROR cannot borrow\n+        }\n+    }\n+}\n+\n+fn loop_break_pops_scopes<'r>(_v: &'r mut [uint], f: &fn(&'r mut uint) -> bool) {\n+    // Here we check that when you break out of an inner loop, the\n+    // borrows that go out of scope as you exit the inner loop are\n+    // removed from the bitset.\n+\n+    while cond() {\n+        while cond() {\n+            // this borrow is limited to the scope of `r`...\n+            let r: &'r mut uint = produce();\n+            if !f(&mut *r) {\n+                break; // ...so it is not live as exit the `while` loop here\n+            }\n+        }\n+    }\n+}\n+\n+fn loop_loop_pops_scopes<'r>(_v: &'r mut [uint], f: &fn(&'r mut uint) -> bool) {\n+    // Similar to `loop_break_pops_scopes` but for the `loop` keyword\n+\n+    while cond() {\n+        while cond() {\n+            // this borrow is limited to the scope of `r`...\n+            let r: &'r mut uint = produce();\n+            if !f(&mut *r) {\n+                loop; // ...so it is not live as exit (and re-enter) the `while` loop here\n+            }\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "7603fdc82a824c91c632b42b5ea5b439654bcb4c", "filename": "src/test/compile-fail/borrowck-lend-flow-match.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-pretty -- comments are infaithfully preserved\n+\n+#[allow(unused_variable)];\n+#[allow(dead_assignment)];\n+\n+fn cond() -> bool { fail!() }\n+fn link<'a>(v: &'a uint, w: &mut &'a uint) -> bool { *w = v; true }\n+\n+fn separate_arms() {\n+    // Here both arms perform assignments, but only is illegal.\n+\n+    let mut x = None;\n+    match x {\n+        None => {\n+            // It is ok to reassign x here, because there is in\n+            // fact no outstanding loan of x!\n+            x = Some(0);\n+        }\n+        Some(ref _i) => {\n+            x = Some(1); //~ ERROR cannot assign\n+        }\n+    }\n+    copy x; // just to prevent liveness warnings\n+}\n+\n+fn guard() {\n+    // Here the guard performs a borrow. This borrow \"infects\" all\n+    // subsequent arms (but not the prior ones).\n+\n+    let mut a = ~3;\n+    let mut b = ~4;\n+    let mut w = &*a;\n+    match 22 {\n+        _ if cond() => {\n+            b = ~5;\n+        }\n+\n+        _ if link(&*b, &mut w) => {\n+            b = ~6; //~ ERROR cannot assign\n+        }\n+\n+        _ => {\n+            b = ~7; //~ ERROR cannot assign\n+        }\n+    }\n+\n+    b = ~8; //~ ERROR cannot assign\n+}\n+\n+fn main() {}"}, {"sha": "59cac0c5d953a8f8f180f4d533c15ff5eac32d99", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 17, "deletions": 76, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -15,96 +15,37 @@\n // cases are noted.\n \n fn borrow(_v: &int) {}\n+fn borrow_mut(_v: &mut int) {}\n+fn cond() -> bool { fail!() }\n+fn for_func(_f: &fn() -> bool) { fail!() }\n+fn produce<T>() -> T { fail!(); }\n \n fn inc(v: &mut ~int) {\n     *v = ~(**v + 1);\n }\n \n-fn post_aliased_const() {\n-    let mut v = ~3;\n-    borrow(v);\n-    let _w = &const v;\n-}\n-\n-fn post_aliased_mut() {\n-    // SPURIOUS--flow\n-    let mut v = ~3;\n-    borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-    let _w = &mut v; //~ NOTE prior loan as mutable granted here\n-}\n+fn pre_freeze() {\n+    // In this instance, the freeze starts before the mut borrow.\n \n-fn post_aliased_scope(cond: bool) {\n     let mut v = ~3;\n-    borrow(v);\n-    if cond { inc(&mut v); }\n+    let _w = &v;\n+    borrow_mut(v); //~ ERROR cannot borrow\n }\n \n-fn loop_overarching_alias_mut() {\n-    let mut v = ~3;\n-    let mut _x = &mut v; //~ NOTE prior loan as mutable granted here\n-    loop {\n-        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-    }\n-}\n+fn pre_const() {\n+    // In this instance, the freeze starts before the mut borrow.\n \n-fn block_overarching_alias_mut() {\n     let mut v = ~3;\n-    let mut _x = &mut v; //~ NOTE prior loan as mutable granted here\n-    for 3.times {\n-        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-    }\n-}\n-\n-fn loop_aliased_mut() {\n-    let mut v = ~3, w = ~4;\n-    let mut _x = &mut w;\n-    loop {\n-        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-        _x = &mut v; //~ NOTE prior loan as mutable granted here\n-    }\n-}\n-\n-fn while_aliased_mut(cond: bool) {\n-    let mut v = ~3, w = ~4;\n-    let mut _x = &mut w;\n-    while cond {\n-        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-        _x = &mut v; //~ NOTE prior loan as mutable granted here\n-    }\n-}\n-\n-fn while_aliased_mut_cond(cond: bool, cond2: bool) {\n-    let mut v = ~3, w = ~4;\n-    let mut _x = &mut w;\n-    while cond {\n-        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-        if cond2 {\n-            _x = &mut v; //~ NOTE prior loan as mutable granted here\n-        }\n-    }\n-}\n-\n-fn loop_in_block() {\n-    let mut v = ~3, w = ~4;\n-    let mut _x = &mut w;\n-    for uint::range(0u, 10u) |_i| {\n-        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-        _x = &mut v; //~ NOTE prior loan as mutable granted here\n-    }\n+    let _w = &const v;\n+    borrow_mut(v);\n }\n \n-fn at_most_once_block() {\n-    fn at_most_once(f: &fn()) { f() }\n+fn post_freeze() {\n+    // In this instance, the const alias starts after the borrow.\n \n-    // Here, the borrow check has no way of knowing that the block is\n-    // executed at most once.\n-\n-    let mut v = ~3, w = ~4;\n-    let mut _x = &mut w;\n-    do at_most_once {\n-        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-        _x = &mut v; //~ NOTE prior loan as mutable granted here\n-    }\n+    let mut v = ~3;\n+    borrow_mut(v);\n+    let _w = &v;\n }\n \n fn main() {}"}, {"sha": "50dd815d4930234c55a9714011caef2a0f9201ee", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -14,17 +14,17 @@ fn borrow(v: &int, f: &fn(x: &int)) {\n \n fn box_imm() {\n     let v = ~3;\n-    let _w = &v; //~ NOTE loan of immutable local variable granted here\n+    let _w = &v;\n     do task::spawn {\n         debug!(\"v=%d\", *v);\n-        //~^ ERROR by-move capture of immutable local variable prohibited due to outstanding loan\n+        //~^ ERROR cannot move `v` into closure\n     }\n \n     let v = ~3;\n-    let _w = &v; //~ NOTE loan of immutable local variable granted here\n+    let _w = &v;\n     task::spawn(|| {\n         debug!(\"v=%d\", *v);\n-        //~^ ERROR by-move capture of immutable local variable prohibited due to outstanding loan\n+        //~^ ERROR cannot move\n     });\n }\n "}, {"sha": "b9a79f4f3b1b182d79ce1006a3813b178c63ee65", "filename": "src/test/compile-fail/borrowck-loan-blocks-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -13,8 +13,8 @@ fn take(_v: ~int) {\n \n fn box_imm() {\n     let v = ~3;\n-    let _w = &v; //~ NOTE loan of immutable local variable granted here\n-    take(v); //~ ERROR moving out of immutable local variable prohibited due to outstanding loan\n+    let _w = &v;\n+    take(v); //~ ERROR cannot move out of `v` because it is borrowed\n }\n \n fn main() {"}, {"sha": "f8415a38573c438e8a693ef22712b09ac97609dc", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -14,8 +14,8 @@ fn borrow(v: &int, f: &fn(x: &int)) {\n \n fn box_imm() {\n     let mut v = ~3;\n-    do borrow(v) |w| { //~ NOTE loan of mutable local variable granted here\n-        v = ~4; //~ ERROR assigning to captured outer mutable variable in a stack closure prohibited due to outstanding loan\n+    do borrow(v) |w| {\n+        v = ~4; //~ ERROR cannot assign to `v` because it is borrowed\n         assert!(*v == 3);\n         assert!(*w == 4);\n     }"}, {"sha": "0361213af222612e9f70b8e77b725d7e4c6e57e2", "filename": "src/test/compile-fail/borrowck-loan-in-overloaded-op.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -8,18 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test #3387\n-\n struct foo(~uint);\n \n impl Add<foo, foo> for foo {\n-    fn add(f: &foo) -> foo {\n-        foo(~(**self + **(*f)))\n+    fn add(&self, f: &foo) -> foo {\n+        foo(~(***self + **(*f)))\n     }\n }\n \n fn main() {\n     let x = foo(~3);\n-    let _y = x + x;\n-    //~^ ERROR moving out of immutable local variable prohibited due to outstanding loan\n+    let _y = x + {x}; // the `{x}` forces a move to occur\n+    //~^ ERROR cannot move out of `x`\n }"}, {"sha": "6e8e3da143e4f21657383350c24c513ccc656062", "filename": "src/test/compile-fail/borrowck-loan-local-as-both-mut-and-imm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -22,13 +22,13 @@ use core::either::{Either, Left, Right};\n \n     fn g() {\n         let mut x: Either<int,float> = Left(3);\n-        io::println(f(&mut x, &x).to_str()); //~ ERROR conflicts with prior loan\n+        io::println(f(&mut x, &x).to_str()); //~ ERROR cannot borrow\n     }\n \n     fn h() {\n         let mut x: Either<int,float> = Left(3);\n         let y: &Either<int, float> = &x;\n-        let z: &mut Either<int, float> = &mut x; //~ ERROR conflicts with prior loan\n+        let z: &mut Either<int, float> = &mut x; //~ ERROR cannot borrow\n         *z = *y;\n     }\n "}, {"sha": "061a6c553e4b0ffccbdd730133e4a1660b000e2a", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -38,12 +38,13 @@ fn b() {\n \n     // Here I create an outstanding loan and check that we get conflicts:\n \n-    let q = &mut p; //~ NOTE prior loan as mutable granted here\n+    let q = &mut p;\n \n-    p + 3;  // ok for pure fns\n-    p.times(3); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    p + 3;  //~ ERROR cannot borrow `p`\n+    p.times(3); //~ ERROR cannot borrow `p`\n \n-    q.x += 1;\n+    *q + 3; // OK to use the new alias `q`\n+    q.x += 1; // and OK to mutate it\n }\n \n fn c() {"}, {"sha": "27a66557434b0eb76ca151021ad9e213f6fc72a9", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -13,30 +13,25 @@ struct point { x: int, y: int }\n trait methods {\n     fn impurem(&self);\n     fn blockm(&self, f: &fn());\n-    fn purem(&self);\n }\n \n impl methods for point {\n     fn impurem(&self) {\n     }\n \n     fn blockm(&self, f: &fn()) { f() }\n-\n-    fn purem(&self) {\n-    }\n }\n \n fn a() {\n     let mut p = point {x: 3, y: 4};\n \n     // Here: it's ok to call even though receiver is mutable, because we\n     // can loan it out.\n-    p.purem();\n     p.impurem();\n \n     // But in this case we do not honor the loan:\n-    do p.blockm { //~ NOTE loan of mutable local variable granted here\n-        p.x = 10; //~ ERROR assigning to mutable field prohibited due to outstanding loan\n+    do p.blockm {\n+        p.x = 10; //~ ERROR cannot assign\n     }\n }\n \n@@ -45,20 +40,21 @@ fn b() {\n \n     // Here I create an outstanding loan and check that we get conflicts:\n \n-    let l = &mut p; //~ NOTE prior loan as mutable granted here\n-    //~^ NOTE prior loan as mutable granted here\n-\n-    p.purem(); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-    p.impurem(); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    let l = &mut p;\n+    p.impurem(); //~ ERROR cannot borrow\n \n     l.x += 1;\n }\n \n fn c() {\n-    // Loaning @mut as & is considered legal due to dynamic checks:\n+    // Loaning @mut as & is considered legal due to dynamic checks...\n     let q = @mut point {x: 3, y: 4};\n-    q.purem();\n     q.impurem();\n+\n+    // ...but we still detect errors statically when we can.\n+    do q.blockm {\n+        q.x = 10; //~ ERROR cannot assign\n+    }\n }\n \n fn main() {"}, {"sha": "6a8e64377aab22898a4afd171b5a370c8952cc51", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -24,8 +24,8 @@ fn has_mut_vec_and_does_not_try_to_change_it() {\n \n fn has_mut_vec_but_tries_to_change_it() {\n     let mut v = ~[1, 2, 3];\n-    do takes_imm_elt(&v[0]) { //~ NOTE loan of mutable vec content granted here\n-        v[1] = 4; //~ ERROR assigning to mutable vec content prohibited due to outstanding loan\n+    do takes_imm_elt(&v[0]) {\n+        v[1] = 4; //~ ERROR cannot assign\n     }\n }\n "}, {"sha": "c199c8795756dd72c9217b41c71fa0a36ea7bc1d", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     let foo = ~3;\n     let _pfoo = &foo;\n     let _f: @fn() -> int = || *foo + 5;\n-    //~^ ERROR by-move capture\n+    //~^ ERROR cannot move `foo`\n \n     let bar = ~3;\n     let _g = || {"}, {"sha": "e4e449822768b6fdb397012a5f4d651ae22063bc", "filename": "src/test/compile-fail/borrowck-mut-addr-of-imm-var.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let x: int = 3;\n-    let y: &mut int = &mut x; //~ ERROR illegal borrow\n+    let y: &mut int = &mut x; //~ ERROR cannot borrow\n     *y = 5;\n     debug!(*y);\n }"}, {"sha": "716f70b291398168a8bdb5ae3568c7c42a994cdd", "filename": "src/test/compile-fail/borrowck-mut-boxed-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let v = @mut [ 1, 2, 3 ];\n-    for v.each |_x| {   //~ ERROR illegal borrow\n-        v[1] = 4;\n+    for v.each |_x| {\n+        v[1] = 4; //~ ERROR cannot assign\n     }\n }"}, {"sha": "d1dc29619789227067f6207a2d9d8d704dd9ecab", "filename": "src/test/compile-fail/borrowck-mut-deref-comp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -11,8 +11,8 @@\n struct foo(~int);\n \n fn borrow(x: @mut foo) {\n-    let _y = &***x; //~ ERROR illegal borrow unless pure\n-    *x = foo(~4); //~ NOTE impure due to assigning to dereference of mutable @ pointer\n+    let _y = &***x;\n+    *x = foo(~4); //~ ERROR cannot assign\n }\n \n fn main() {"}, {"sha": "ec17976c5065cb891b2b5a899f1616381f24bf4a", "filename": "src/test/compile-fail/borrowck-mut-slice-of-imm-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -14,5 +14,5 @@ fn write(v: &mut [int]) {\n \n fn main() {\n     let v = ~[1, 2, 3];\n-    write(v); //~ ERROR illegal borrow\n+    write(v); //~ ERROR cannot borrow\n }"}, {"sha": "ed270de51e2ed886a3698043262db09327f210a8", "filename": "src/test/compile-fail/borrowck-no-cycle-in-exchange-heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -19,9 +19,9 @@ enum cycle {\n fn main() {\n     let mut x = ~node(node_ {a: ~empty});\n     // Create a cycle!\n-    match *x { //~ NOTE loan of mutable local variable granted here\n+    match *x {\n       node(ref mut y) => {\n-        y.a = x; //~ ERROR moving out of mutable local variable prohibited due to outstanding loan\n+        y.a = x; //~ ERROR cannot move out of\n       }\n       empty => {}\n     };"}, {"sha": "d60ed3d0e372b5f67f9ff0b8e2e2b4e6224e3c8c", "filename": "src/test/compile-fail/borrowck-pat-by-value-binding.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -12,23 +12,24 @@ fn process<T>(_t: T) {}\n \n fn match_const_opt_by_mut_ref(v: &const Option<int>) {\n     match *v {\n-      Some(ref mut i) => process(i), //~ ERROR illegal borrow\n+      Some(ref mut i) => process(i), //~ ERROR cannot borrow\n+        //~^ ERROR unsafe borrow of aliasable, const value\n       None => ()\n     }\n }\n \n fn match_const_opt_by_const_ref(v: &const Option<int>) {\n     match *v {\n-      Some(ref const i) => process(i), //~ ERROR illegal borrow unless pure\n-      //~^ NOTE impure due to\n+      Some(ref const i) => process(i),\n+        //~^ ERROR unsafe borrow of aliasable, const value\n       None => ()\n     }\n }\n \n fn match_const_opt_by_imm_ref(v: &const Option<int>) {\n     match *v {\n-      Some(ref i) => process(i), //~ ERROR illegal borrow unless pure\n-      //~^ NOTE impure due to\n+      Some(ref i) => process(i), //~ ERROR cannot borrow\n+        //~^ ERROR unsafe borrow of aliasable, const value\n       None => ()\n     }\n }"}, {"sha": "c50357e8b9c6208c8cff020ed19bd033fe7be91c", "filename": "src/test/compile-fail/borrowck-pat-enum.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -26,7 +26,8 @@ fn match_ref_unused(&&v: Option<int>) {\n \n fn match_const_reg(v: &const Option<int>) -> int {\n     match *v {\n-      Some(ref i) => {*i} // OK because this is pure\n+      Some(ref i) => {*i} //~ ERROR cannot borrow\n+        //~^ ERROR unsafe borrow\n       None => {0}\n     }\n }\n@@ -43,8 +44,8 @@ fn match_const_reg_unused(v: &const Option<int>) {\n \n fn match_const_reg_impure(v: &const Option<int>) {\n     match *v {\n-      Some(ref i) => {impure(*i)} //~ ERROR illegal borrow unless pure\n-      //~^ NOTE impure due to access to impure function\n+      Some(ref i) => {impure(*i)} //~ ERROR cannot borrow\n+        //~^ ERROR unsafe borrow\n       None => {}\n     }\n }\n@@ -56,5 +57,12 @@ fn match_imm_reg(v: &Option<int>) {\n     }\n }\n \n+fn match_mut_reg(v: &mut Option<int>) {\n+    match *v {\n+      Some(ref i) => {impure(*i)} // OK, frozen\n+      None => {}\n+    }\n+}\n+\n fn main() {\n }"}, {"sha": "d05160132c6c2bf790fbb0d154986486d37563a6", "filename": "src/test/compile-fail/borrowck-pat-reassign-binding.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -12,11 +12,14 @@\n \n fn main() {\n     let mut x: Option<int> = None;\n-    match x { //~ NOTE loan of mutable local variable granted here\n-      None => {}\n+    match x {\n+      None => {\n+          // Note: on this branch, no borrow has occurred.\n+          x = Some(0);\n+      }\n       Some(ref i) => {\n-        // Not ok: i is an outstanding ptr into x.\n-        x = Some(*i+1); //~ ERROR assigning to mutable local variable prohibited due to outstanding loan\n+          // But on this branch, `i` is an outstanding borrow\n+          x = Some(*i+1); //~ ERROR cannot assign to `x`\n       }\n     }\n     copy x; // just to prevent liveness warnings"}, {"sha": "dd6eca951b8f3ba22c0b9f496e148c9f79015625", "filename": "src/test/compile-fail/borrowck-pat-reassign-sometimes-binding.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fd6e42a904723c99383e684ddeaf02f01d972/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fd6e42a904723c99383e684ddeaf02f01d972/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs?ref=bd5fd6e42a904723c99383e684ddeaf02f01d972", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-pretty -- comments are infaithfully preserved\n-\n-fn main() {\n-    let mut x = None;\n-    match x { //~ NOTE loan of mutable local variable granted here\n-      None => {\n-        // It is ok to reassign x here, because there is in\n-        // fact no outstanding loan of x!\n-        x = Some(0);\n-      }\n-      Some(ref _i) => {\n-        x = Some(1); //~ ERROR assigning to mutable local variable prohibited due to outstanding loan\n-      }\n-    }\n-    copy x; // just to prevent liveness warnings\n-}"}, {"sha": "b4bd64f21358621be700d436afa9100a0d879430", "filename": "src/test/compile-fail/borrowck-reborrow-from-mut.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-mut.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -20,17 +20,17 @@ struct Bar {\n \n fn borrow_same_field_twice_mut_mut(foo: &mut Foo) {\n     let _bar1 = &mut foo.bar1;\n-    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+    let _bar2 = &mut foo.bar1;  //~ ERROR cannot borrow\n }\n \n fn borrow_same_field_twice_mut_imm(foo: &mut Foo) {\n     let _bar1 = &mut foo.bar1;\n-    let _bar2 = &foo.bar1;  //~ ERROR conflicts with prior loan\n+    let _bar2 = &foo.bar1;  //~ ERROR cannot borrow\n }\n \n fn borrow_same_field_twice_imm_mut(foo: &mut Foo) {\n     let _bar1 = &foo.bar1;\n-    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+    let _bar2 = &mut foo.bar1;  //~ ERROR cannot borrow\n }\n \n fn borrow_same_field_twice_imm_imm(foo: &mut Foo) {\n@@ -53,34 +53,34 @@ fn borrow_var_and_pattern(foo: &mut Foo) {\n     let _bar1 = &mut foo.bar1;\n     match *foo {\n         Foo { bar1: ref mut _bar1, bar2: _ } => {}\n-        //~^ ERROR conflicts with prior loan\n+        //~^ ERROR cannot borrow\n     }\n }\n \n fn borrow_mut_and_base_imm(foo: &mut Foo) {\n     let _bar1 = &mut foo.bar1.int1;\n-    let _foo1 = &foo.bar1; //~ ERROR conflicts with prior loan\n-    let _foo2 = &*foo; //~ ERROR conflicts with prior loan\n+    let _foo1 = &foo.bar1; //~ ERROR cannot borrow\n+    let _foo2 = &*foo; //~ ERROR cannot borrow\n }\n \n fn borrow_mut_and_base_mut(foo: &mut Foo) {\n     let _bar1 = &mut foo.bar1.int1;\n-    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+    let _foo1 = &mut foo.bar1; //~ ERROR cannot borrow\n }\n \n fn borrow_mut_and_base_mut2(foo: &mut Foo) {\n     let _bar1 = &mut foo.bar1.int1;\n-    let _foo2 = &mut *foo; //~ ERROR conflicts with prior loan\n+    let _foo2 = &mut *foo; //~ ERROR cannot borrow\n }\n \n fn borrow_imm_and_base_mut(foo: &mut Foo) {\n     let _bar1 = &foo.bar1.int1;\n-    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+    let _foo1 = &mut foo.bar1; //~ ERROR cannot borrow\n }\n \n fn borrow_imm_and_base_mut2(foo: &mut Foo) {\n     let _bar1 = &foo.bar1.int1;\n-    let _foo2 = &mut *foo; //~ ERROR conflicts with prior loan\n+    let _foo2 = &mut *foo; //~ ERROR cannot borrow\n }\n \n fn borrow_imm_and_base_imm(foo: &mut Foo) {\n@@ -95,7 +95,7 @@ fn borrow_mut_and_imm(foo: &mut Foo) {\n }\n \n fn borrow_mut_from_imm(foo: &Foo) {\n-    let _bar1 = &mut foo.bar1; //~ ERROR illegal borrow\n+    let _bar1 = &mut foo.bar1; //~ ERROR cannot borrow\n }\n \n fn borrow_long_path_both_mut(foo: &mut Foo) {"}, {"sha": "7026f06c2b7bb50a0fb892c4ebedcfe3ba0a6ab8", "filename": "src/test/compile-fail/borrowck-ref-into-rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -10,8 +10,8 @@\n \n fn main() {\n     let msg;\n-    match Some(~\"Hello\") { //~ ERROR illegal borrow\n-        Some(ref m) => {\n+    match Some(~\"Hello\") {\n+        Some(ref m) => { //~ ERROR borrowed value does not live long enough\n             msg = m;\n         },\n         None => { fail!() }"}, {"sha": "3a37116a1664d604755f01bbdc0e97eac91ed7a5", "filename": "src/test/compile-fail/borrowck-ref-mut-of-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -11,7 +11,7 @@\n fn destructure(x: Option<int>) -> int {\n     match x {\n       None => 0,\n-      Some(ref mut v) => *v //~ ERROR illegal borrow\n+      Some(ref mut v) => *v //~ ERROR cannot borrow\n     }\n }\n "}, {"sha": "898830bbe55ba483d5150aab17bb990360724e02", "filename": "src/test/compile-fail/borrowck-unary-move-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move-2.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -28,5 +28,5 @@ struct wrapper(noncopyable);\n \n fn main() {\n     let x1 = wrapper(noncopyable());\n-    let _x2 = *x1; //~ ERROR moving out of anonymous field\n+    let _x2 = *x1; //~ ERROR cannot move out\n }"}, {"sha": "107e478004abb327b3e565cf9e736a8b0ac19e15", "filename": "src/test/compile-fail/borrowck-unary-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n fn foo(+x: ~int) -> int {\n-    let y = &*x; //~ NOTE loan of argument granted here\n-    free(x); //~ ERROR moving out of argument prohibited due to outstanding loan\n+    let y = &*x;\n+    free(x); //~ ERROR cannot move out of `*x` because it is borrowed\n     *y\n }\n "}, {"sha": "97414ff5e786c391d70334424166c14e6eacf0c0", "filename": "src/test/compile-fail/borrowck-uniq-via-box.rs", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fd6e42a904723c99383e684ddeaf02f01d972/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fd6e42a904723c99383e684ddeaf02f01d972/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs?ref=bd5fd6e42a904723c99383e684ddeaf02f01d972", "patch": "@@ -1,54 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct Rec {\n-    f: ~int,\n-}\n-\n-struct Outer {\n-    f: Inner\n-}\n-\n-struct Inner {\n-    g: Innermost\n-}\n-\n-struct Innermost {\n-    h: ~int,\n-}\n-\n-fn borrow(_v: &int) {}\n-\n-fn box_mut(v: @mut ~int) {\n-    borrow(*v); //~ ERROR illegal borrow unless pure\n-}\n-\n-fn box_mut_rec(v: @mut Rec) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure\n-}\n-\n-fn box_mut_recs(v: @mut Outer) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure\n-}\n-\n-fn box_imm(v: @~int) {\n-    borrow(*v); // OK\n-}\n-\n-fn box_imm_rec(v: @Rec) {\n-    borrow(v.f); // OK\n-}\n-\n-fn box_imm_recs(v: @Outer) {\n-    borrow(v.f.g.h); // OK\n-}\n-\n-fn main() {\n-}"}, {"sha": "80ba1968bc751cd180fcea5596997e113201f5c1", "filename": "src/test/compile-fail/borrowck-uniq-via-lend.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -43,8 +43,8 @@ fn aliased_const() {\n \n fn aliased_mut() {\n     let mut v = ~3;\n-    let _w = &mut v; //~ NOTE prior loan as mutable granted here\n-    borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    let _w = &mut v;\n+    borrow(v); //~ ERROR cannot borrow `*v`\n }\n \n fn aliased_other() {\n@@ -56,8 +56,8 @@ fn aliased_other() {\n fn aliased_other_reassign() {\n     let mut v = ~3, w = ~4;\n     let mut _x = &mut w;\n-    _x = &mut v; //~ NOTE prior loan as mutable granted here\n-    borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    _x = &mut v;\n+    borrow(v); //~ ERROR cannot borrow `*v`\n }\n \n fn main() {"}, {"sha": "8bf627d991911343b24ed042b99581677cf03327", "filename": "src/test/compile-fail/borrowck-uniq-via-ref.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -25,6 +25,7 @@ struct Innermost {\n }\n \n fn borrow(_v: &int) {}\n+fn borrow_const(_v: &const int) {}\n \n fn box_mut(v: &mut ~int) {\n     borrow(*v); // OK: &mut -> &imm\n@@ -51,15 +52,15 @@ fn box_imm_recs(v: &Outer) {\n }\n \n fn box_const(v: &const ~int) {\n-    borrow(*v); //~ ERROR illegal borrow unless pure\n+    borrow_const(*v); //~ ERROR unsafe borrow\n }\n \n fn box_const_rec(v: &const Rec) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure\n+    borrow_const(v.f); //~ ERROR unsafe borrow\n }\n \n fn box_const_recs(v: &const Outer) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure\n+    borrow_const(v.f.g.h); //~ ERROR unsafe borrow\n }\n \n fn main() {"}, {"sha": "0c21b64bb0fb0a0d56fc54774b3ec4df70587b8b", "filename": "src/test/compile-fail/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -1,25 +1,25 @@\n fn a() -> &[int] {\n     let vec = [1, 2, 3, 4];\n-    let tail = match vec { //~ ERROR illegal borrow\n-        [_, ..tail] => tail,\n+    let tail = match vec {\n+        [_, ..tail] => tail, //~ ERROR does not live long enough\n         _ => fail!(~\"a\")\n     };\n     tail\n }\n \n fn b() -> &[int] {\n     let vec = [1, 2, 3, 4];\n-    let init = match vec { //~ ERROR illegal borrow\n-        [..init, _] => init,\n+    let init = match vec {\n+        [..init, _] => init, //~ ERROR does not live long enough\n         _ => fail!(~\"b\")\n     };\n     init\n }\n \n fn c() -> &[int] {\n     let vec = [1, 2, 3, 4];\n-    let slice = match vec { //~ ERROR illegal borrow\n-        [_, ..slice, _] => slice,\n+    let slice = match vec {\n+        [_, ..slice, _] => slice, //~ ERROR does not live long enough\n         _ => fail!(~\"c\")\n     };\n     slice"}, {"sha": "635ce77bb8a5b22909439529854c46c6cdd3476f", "filename": "src/test/compile-fail/borrowck-vec-pattern-loan-from-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -2,7 +2,7 @@ fn a() {\n     let mut v = ~[1, 2, 3];\n     match v {\n         [_a, ..tail] => {\n-            v.push(tail[0] + tail[1]); //~ ERROR conflicts with prior loan\n+            v.push(tail[0] + tail[1]); //~ ERROR cannot borrow\n         }\n         _ => {}\n     };"}, {"sha": "2898e312930fe5e04199343ffdd3f5db74d4a5bc", "filename": "src/test/compile-fail/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -1,8 +1,9 @@\n fn main() {\n     let mut a = [1, 2, 3, 4];\n-    let _ = match a {\n+    let t = match a {\n         [1, 2, ..tail] => tail,\n         _ => core::util::unreachable()\n     };\n-    a[0] = 0; //~ ERROR: assigning to mutable vec content prohibited due to outstanding loan\n+    a[0] = 0; //~ ERROR cannot assign to `a[]` because it is borrowed\n+    t[0];\n }"}, {"sha": "941455d086c8c542926edf28deaa6cb9a510956a", "filename": "src/test/compile-fail/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -2,7 +2,7 @@ fn a() {\n     let mut vec = [~1, ~2, ~3];\n     match vec {\n         [~ref _a] => {\n-            vec[0] = ~4; //~ ERROR prohibited due to outstanding loan\n+            vec[0] = ~4; //~ ERROR cannot assign to `vec[]` because it is borrowed\n         }\n         _ => fail!(~\"foo\")\n     }\n@@ -12,7 +12,7 @@ fn b() {\n     let mut vec = [~1, ~2, ~3];\n     match vec {\n         [.._b] => {\n-            vec[0] = ~4; //~ ERROR prohibited due to outstanding loan\n+            vec[0] = ~4; //~ ERROR cannot assign to `vec[]` because it is borrowed\n         }\n     }\n }"}, {"sha": "dbdd8f0809a6e1a17c812e4bdfc84f145dde1c8a", "filename": "src/test/compile-fail/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -1,7 +1,7 @@\n fn a() -> &int {\n     let vec = [1, 2, 3, 4];\n-    let tail = match vec { //~ ERROR illegal borrow\n-        [_a, ..tail] => &tail[0],\n+    let tail = match vec {\n+        [_a, ..tail] => &tail[0], //~ ERROR borrowed value does not live long enough\n         _ => fail!(~\"foo\")\n     };\n     tail"}, {"sha": "451f023f5fcf718f79830280d9bf6b928eb4d1bc", "filename": "src/test/compile-fail/borrowck-wg-borrow-mut-to-imm-fail-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-2.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let mut b = ~3;\n-    let _x = &mut *b;   //~ NOTE prior loan as mutable granted here\n-    let _y = &mut *b;   //~ ERROR loan of dereference of mutable ~ pointer as mutable conflicts with prior loan\n+    let _x = &mut *b;\n+    let _y = &mut *b; //~ ERROR cannot borrow\n }"}, {"sha": "c455de888a330bf9eeb9f6e6720b82e17ae3a2fc", "filename": "src/test/compile-fail/borrowck-wg-borrow-mut-to-imm-fail-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-3.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n     let mut a = ~3;\n-    let mut b = &mut a; //~ NOTE loan of mutable local variable granted here\n+    let mut b = &mut a;\n     let _c = &mut *b;\n-    let mut d = /*move*/ a; //~ ERROR moving out of mutable local variable prohibited due to outstanding loan\n+    let mut d = /*move*/ a; //~ ERROR cannot move out\n     *d += 1;\n }"}, {"sha": "e18808dfe538a2309acf8c135865fde3263183ed", "filename": "src/test/compile-fail/borrowck-wg-borrow-mut-to-imm-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let mut b = ~3;\n-    let _x = &mut *b;   //~ NOTE loan of mutable local variable granted here\n-    let mut y = /*move*/ b; //~ ERROR moving out of mutable local variable prohibited\n+    let _x = &mut *b;\n+    let mut y = /*move*/ b; //~ ERROR cannot move out\n     *y += 1;\n }"}, {"sha": "4050b4c5971a03248567583f14e6812d17f35a86", "filename": "src/test/compile-fail/borrowck-wg-move-base-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-move-base-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-move-base-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-move-base-2.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -2,7 +2,7 @@ fn foo(x: &mut int) {\n     let mut a = 3;\n     let mut _y = &mut *x;\n     let _z = &mut *_y;\n-    _y = &mut a; //~ ERROR assigning to mutable local variable prohibited\n+    _y = &mut a; //~ ERROR cannot assign\n }\n \n fn main() {"}, {"sha": "5fa796db884446639c8bb821d3daeb636aab7db5", "filename": "src/test/compile-fail/dead-code-ret.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -10,8 +10,12 @@\n // except according to those terms.\n \n \n-// error-pattern: dead\n+fn f(caller: &str) {\n+    debug!(caller);\n+    let x: uint = 0u32; // induce type error //~ ERROR mismatched types\n+}\n \n-fn f(caller: str) { debug!(caller); }\n-\n-fn main() { return f(\"main\"); debug!(\"Paul is dead\"); }\n+fn main() {\n+    return f(\"main\");\n+    debug!(\"Paul is dead\"); //~ WARNING unreachable\n+}"}, {"sha": "d33c591d8c87f650d6758ff7f469708ab661e42f", "filename": "src/test/compile-fail/die-not-static.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fdie-not-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fdie-not-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdie-not-static.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -1,7 +1,6 @@\n-// error-pattern:illegal borrow: borrowed value does not live long enough\n-\n fn main() {\n     let v = ~\"test\";\n     let sslice = str::slice(v, 0, v.len());\n+    //~^ ERROR borrowed value does not live long enough\n     fail!(sslice);\n }"}, {"sha": "4d145d3f9ea3aff34b3e0db1784816aa67c790b1", "filename": "src/test/compile-fail/fn-variance-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -31,5 +31,5 @@ fn main() {\n     // mutability check will fail, because the\n     // type of r has been inferred to be\n     // fn(@const int) -> @const int\n-    *r(@mut 3) = 4; //~ ERROR assigning to dereference of const @ pointer\n+    *r(@mut 3) = 4; //~ ERROR cannot assign to const dereference of @ pointer\n }"}, {"sha": "de28d72677728c658209e01672996e246285d102", "filename": "src/test/compile-fail/for-loop-decl.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fd6e42a904723c99383e684ddeaf02f01d972/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fd6e42a904723c99383e684ddeaf02f01d972/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs?ref=bd5fd6e42a904723c99383e684ddeaf02f01d972", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: mismatched types\n-extern mod std;\n-use std::bitv;\n-use core::hashmap::HashMap;\n-\n-struct FnInfo {\n-    vars: HashMap<uint, VarInfo>\n-}\n-\n-struct VarInfo {\n-    a: uint,\n-    b: uint,\n-}\n-\n-fn bitv_to_str(enclosing: FnInfo, v: ~bitv::Bitv) -> str {\n-    let s = \"\";\n-\n-    // error is that the value type in the hash map is var_info, not a box\n-    for enclosing.vars.each_value |val| {\n-        if *v.get(val) { s += \"foo\"; }\n-    }\n-    return s;\n-}\n-\n-fn main() { debug!(\"OK\"); }"}, {"sha": "66b5bd172cace9e5b2cee9e3960ea10b9a6aded0", "filename": "src/test/compile-fail/immut-function-arguments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n fn f(y: ~int) {\n-    *y = 5; //~ ERROR assigning to dereference of immutable ~ pointer\n+    *y = 5; //~ ERROR cannot assign\n }\n \n fn g() {\n-    let _frob: &fn(~int) = |q| { *q = 2; }; //~ ERROR assigning to dereference of immutable ~ pointer\n+    let _frob: &fn(~int) = |q| { *q = 2; }; //~ ERROR cannot assign\n \n }\n "}, {"sha": "26dd98757a8c2c5e4cbf79dd2c20dff38d593f30", "filename": "src/test/compile-fail/index_message.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Findex_message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Findex_message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Findex_message.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     let z = ();\n-    debug!(z[0]); //~ ERROR cannot index a value of type `()`\n+    let _ = z[0]; //~ ERROR cannot index a value of type `()`\n }"}, {"sha": "13adcd42da2b804bd3c056e47a0de1ffbc1cd840", "filename": "src/test/compile-fail/issue-1896-1.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that we require managed closures to be rooted when borrowed.\n+\n struct boxedFn<'self> { theFn: &'self fn() -> uint }\n \n fn createClosure (closedUint: uint) -> boxedFn {\n     let theFn: @fn() -> uint = || closedUint;\n-    boxedFn {theFn: theFn} //~ ERROR illegal borrow\n+    boxedFn {theFn: theFn} //~ ERROR cannot root\n }\n \n fn main () {"}, {"sha": "cdc8d546dd84801e074d5f496dd1d65f691cb864", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -23,5 +23,4 @@ impl<A> vec_monad<A> for ~[A] {\n fn main() {\n     [\"hi\"].bind(|x| [x] );\n     //~^ ERROR type `[&'static str, .. 1]` does not implement any method in scope named `bind`\n-    //~^^ ERROR Unconstrained region variable\n }"}, {"sha": "bb6d47a47622b10e94af9b3a44c0aceb8fd17295", "filename": "src/test/compile-fail/issue-2151.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -10,7 +10,6 @@\n \n fn main() {\n     for vec::each(fail!()) |i| {\n-        debug!(i * 2);\n-        //~^ ERROR the type of this value must be known\n+        let _ = i * 2; //~ ERROR the type of this value must be known\n    };\n }"}, {"sha": "a0b967d59593a2f4a2147c8ac83442744402fc1c", "filename": "src/test/compile-fail/issue-2590.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -18,7 +18,7 @@ trait parse {\n \n impl parse for parser {\n     fn parse(&self) -> ~[int] {\n-        self.tokens //~ ERROR moving out of immutable field\n+        self.tokens //~ ERROR cannot move out of field\n     }\n }\n "}, {"sha": "06fb18d7e4777f44fbebfcdc90fdc390d6342e44", "filename": "src/test/compile-fail/issue-3044.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -11,7 +11,6 @@\n fn main() {\n     let needlesArr: ~[char] = ~['a', 'f'];\n     do vec::foldr(needlesArr) |x, y| {\n-        //~^ ERROR Unconstrained region variable #2\n     }\n     //~^ ERROR 2 parameters were supplied (including the closure passed by the `do` keyword)\n     //"}, {"sha": "c872f89d88450ec37e5329841ab250be37d79090", "filename": "src/test/compile-fail/issue-511.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-511.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -17,5 +17,5 @@ fn f<T:Eq>(o: &mut Option<T>) {\n \n fn main() {\n     f::<int>(&mut option::None);\n-    //~^ ERROR illegal borrow: creating mutable alias to static item\n+    //~^ ERROR cannot borrow\n }"}, {"sha": "6bb90bff228d4eb51804841f3424058754dd21dd", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -29,4 +29,7 @@ fn main() {\n     };\n     assert!(3 == *(y.get())); //~ ERROR dereference of reference outside its lifetime\n     //~^ ERROR reference is not valid outside of its lifetime\n+    //~^^ ERROR reference is not valid outside of its lifetime\n+    //~^^^ ERROR reference is not valid outside of its lifetime\n+    //~^^^^ ERROR cannot infer an appropriate lifetime\n }"}, {"sha": "bfd1e12f3a6e05fce6d9ebcceae5876474ab2396", "filename": "src/test/compile-fail/lambda-mutate-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:assigning to captured outer immutable variable in a stack closure\n // Make sure that nesting a block within a @fn doesn't let us\n // mutate upvars from a @fn.\n fn f2(x: &fn()) { x(); }\n \n fn main() {\n     let i = 0;\n     let ctr: @fn() -> int = || { f2(|| i = i + 1 ); i };\n+    //~^ ERROR cannot assign\n     error!(ctr());\n     error!(ctr());\n     error!(ctr());"}, {"sha": "a848d8698a3d6d07cbe70cfc4c86f66610cac7b8", "filename": "src/test/compile-fail/lambda-mutate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:assigning to captured outer variable in a heap closure\n // Make sure we can't write to upvars from @fns\n fn main() {\n     let i = 0;\n     let ctr: @fn() -> int = || { i = i + 1; i };\n+    //~^ ERROR cannot assign\n     error!(ctr());\n     error!(ctr());\n     error!(ctr());"}, {"sha": "76d50710bb8c1d8add9707b9bb936300cdbcd271", "filename": "src/test/compile-fail/moves-based-on-type-block-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -16,7 +16,7 @@ fn main() {\n     let s = S { x: ~Bar(~42) };\n     loop {\n         do f(&s) |hellothere| {\n-            match hellothere.x {    //~ ERROR moving out of immutable field\n+            match hellothere.x {    //~ ERROR cannot move out\n                 ~Foo(_) => {}\n                 ~Bar(x) => io::println(x.to_str()),\n                 ~Baz => {}"}, {"sha": "ecd58d485a89dc11b6ceb78cb11bae9029e725a9", "filename": "src/test/compile-fail/moves-based-on-type-move-out-of-closure-env-issue-1965.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -13,6 +13,6 @@ fn test(_x: ~uint) {}\n fn main() {\n     let i = ~3;\n     for uint::range(0, 10) |_x| {\n-        test(i); //~ ERROR moving out of captured outer immutable variable in a stack closure\n+        test(i); //~ ERROR cannot move out\n     }\n }"}, {"sha": "f5d24b316414e69e0b13e545fc2b5880bc7ccf51", "filename": "src/test/compile-fail/mutable-class-fields-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields-2.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:assigning to immutable field\n struct cat {\n   priv mut meows : uint,\n \n@@ -17,7 +16,7 @@ struct cat {\n \n pub impl cat {\n   fn eat(&self) {\n-    self.how_hungry -= 5;\n+    self.how_hungry -= 5; //~ ERROR cannot assign\n   }\n \n }"}, {"sha": "8bebec7134cc36ff626c109e687e7654269d68c1", "filename": "src/test/compile-fail/mutable-class-fields.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -8,12 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:assigning to immutable field\n struct cat {\n   priv mut meows : uint,\n-\n   how_hungry : int,\n-\n }\n \n fn cat(in_x : uint, in_y : int) -> cat {\n@@ -25,5 +22,5 @@ fn cat(in_x : uint, in_y : int) -> cat {\n \n fn main() {\n   let nyan : cat = cat(52u, 99);\n-  nyan.how_hungry = 0;\n+  nyan.how_hungry = 0; //~ ERROR cannot assign\n }"}, {"sha": "6b3fd4f715384cc6d50ee9b3f3b8aee36cc26e85", "filename": "src/test/compile-fail/mutable-huh-ptr-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -12,7 +12,7 @@ extern mod std;\n \n fn main() {\n     unsafe fn f(&&v: *const int) {\n-        *v = 1 //~ ERROR assigning to dereference of const * pointer\n+        *v = 1 //~ ERROR cannot assign\n     }\n \n     unsafe {"}, {"sha": "4fff5a6f87c786ea5047bacbeabefc30f275044a", "filename": "src/test/compile-fail/regions-addr-of-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn foo(a: int) {\n-    let _p: &'static int = &a; //~ ERROR illegal borrow\n+    let _p: &'static int = &a; //~ ERROR borrowed value does not live long enough\n }\n \n fn bar(a: int) {"}, {"sha": "ab2620d46fdc54e320cdba72e4963b1576a7adb7", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -23,10 +23,8 @@ fn a_fn3<'a,'b>(e: a_class<'a>) -> a_class<'b> {\n     return e; //~ ERROR mismatched types: expected `a_class/&'b ` but found `a_class/&'a `\n }\n \n-fn a_fn4<'a,'b>(e: int<'a>) -> int<'b> {\n-    //~^ ERROR region parameters are not allowed on this type\n-    //~^^ ERROR region parameters are not allowed on this type\n-    return e;\n+fn a_fn4<'a,'b>() {\n+    let _: int<'a> = 1; //~ ERROR region parameters are not allowed on this type\n }\n \n fn main() { }"}, {"sha": "2ab0c14b49b656d743dcc60ce2aedc8a66693e70", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -30,12 +30,12 @@ fn compute(x: &ast) -> uint {\n fn map_nums(x: &ast, f: &fn(uint) -> uint) -> &ast {\n     match *x {\n       num(x) => {\n-        return &num(f(x)); //~ ERROR illegal borrow\n+        return &num(f(x)); //~ ERROR borrowed value does not live long enough\n       }\n       add(x, y) => {\n         let m_x = map_nums(x, f);\n         let m_y = map_nums(y, f);\n-        return &add(m_x, m_y);  //~ ERROR illegal borrow\n+        return &add(m_x, m_y);  //~ ERROR borrowed value does not live long enough\n       }\n     }\n }"}, {"sha": "8f764745697c7a87302cfaafe527ac3d16c5f125", "filename": "src/test/compile-fail/regions-creating-enums4.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -14,8 +14,7 @@ enum ast<'self> {\n }\n \n fn mk_add_bad2<'a>(x: &'a ast<'a>, y: &'a ast<'a>, z: &ast) -> ast {\n-    add(x, y)\n-         //~^ ERROR cannot infer an appropriate lifetime\n+    add(x, y) //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "5ac5e334be23d1e5b4d5ba531c2c5e497f943f80", "filename": "src/test/compile-fail/regions-escape-bound-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -14,6 +14,6 @@ fn with_int(f: &fn(x: &int)) {\n }\n \n fn main() {\n-    let mut x: Option<&int> = None; //~ ERROR cannot infer\n+    let mut x: Option<&int> = None;   //~ ERROR cannot infer\n     with_int(|y| x = Some(y));\n }"}, {"sha": "19bd0bf9747bbdb70f56cca7110ba487f5506b24", "filename": "src/test/compile-fail/regions-escape-loop-via-variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -18,6 +18,6 @@ fn main() {\n \n     loop {\n         let x = 1 + *p;\n-        p = &x; //~ ERROR illegal borrow\n+        p = &x; //~ ERROR borrowed value does not live long enough\n     }\n }"}, {"sha": "92e2cd73dfbd8c13ca5bb6cc655c258dcfda6ced", "filename": "src/test/compile-fail/regions-escape-loop-via-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -14,8 +14,8 @@ fn broken() {\n     let mut _y = ~[&mut x];\n     while x < 10 {\n         let mut z = x;\n-        _y.push(&mut z); //~ ERROR illegal borrow\n-        x += 1; //~ ERROR assigning to mutable local variable prohibited due to outstanding loan\n+        _y.push(&mut z); //~ ERROR borrowed value does not live long enough\n+        x += 1; //~ ERROR cannot assign\n     }\n }\n "}, {"sha": "aa431d6b81c6e7162084febd5a53ef5871ff135c", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -23,13 +23,8 @@ fn with<R:deref>(f: &fn(x: &int) -> R) -> int {\n }\n \n fn return_it() -> int {\n-    with(|o| o)\n-    //~^ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n-    //~^^ ERROR reference is not valid outside of its lifetime\n-    //~^^^ ERROR reference is not valid outside of its lifetime\n+    with(|o| o) //~ ERROR reference is not valid outside of its lifetime\n }\n \n fn main() {\n-    let x = return_it();\n-    debug!(\"foo=%d\", x);\n }"}, {"sha": "d519397f68c5873d42edb308cff13b7302766842", "filename": "src/test/compile-fail/regions-infer-borrow-scope-too-big.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -18,7 +18,7 @@ fn x_coord<'r>(p: &'r point) -> &'r int {\n }\n \n fn foo(p: @point) -> &int {\n-    let xc = x_coord(p); //~ ERROR illegal borrow\n+    let xc = x_coord(p); //~ ERROR cannot root\n     assert!(*xc == 3);\n     return xc;\n }"}, {"sha": "50ac5f65772fc80c2e564b8aeef08c335c7619d4", "filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -15,9 +15,9 @@ fn foo(cond: &fn() -> bool, box: &fn() -> @int) {\n     loop {\n         let x = box();\n \n-        // Here we complain because the resulting region\n-        // of this borrow is the fn body as a whole.\n-        y = borrow(x); //~ ERROR illegal borrow: cannot root managed value long enough\n+\t    // Here we complain because the resulting region\n+\t    // of this borrow is the fn body as a whole.\n+        y = borrow(x); //~ ERROR cannot root\n \n         assert!(*x == *y);\n         if cond() { break; }"}, {"sha": "fe995052c52e4a961a2eaf4ca9cf7375139b168d", "filename": "src/test/compile-fail/regions-nested-fns-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -13,7 +13,7 @@ fn ignore(_f: &fn<'z>(&'z int) -> &'z int) {}\n fn nested() {\n     let y = 3;\n     ignore(|z| {\n-        if false { &y } else { z } //~ ERROR illegal borrow\n+        if false { &y } else { z } //~ ERROR borrowed value does not live long enough\n     });\n }\n "}, {"sha": "74399967446eaa9675cf8c07ffeb2237c20045f0", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "patch": "@@ -16,7 +16,7 @@ fn nested<'x>(x: &'x int) {\n \n     ignore::<&fn<'z>(&'z int)>(|z| {\n         ay = x;\n-        ay = &y;  //~ ERROR cannot infer an appropriate lifetime\n+        ay = &y;\n         ay = z;\n     });\n "}, {"sha": "a572d90313b6af26278acfe7ca064a4b917a98e8", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "ec9a908ba98760d69e3cfd0a8423ba560a3df463", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "eccffb4051e23a928a8a8909c8c5879f52ee930f", "filename": "src/test/compile-fail/regions-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "addf20fd70249b6fbaa63e1ce1ca69d214607d50", "filename": "src/test/compile-fail/regions-var-type-out-of-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "eca5fb0d315d87aa2c83bde0a0462d1c21f7c829", "filename": "src/test/compile-fail/swap-no-lval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "c4a412f64c8d454f95df4a444f16cec3feadbe12", "filename": "src/test/compile-fail/type-shadow.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Ftype-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Ftype-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-shadow.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "faa3d6cfe47e70751c0bcc4269d15162058390a0", "filename": "src/test/compile-fail/writing-to-immutable-vec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "59a5fecd3400368ba4878d8620763fd48201734f", "filename": "src/test/run-fail/borrowck-wg-fail-2.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-2.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "a40faa1ac6fc3dfa5c2e0d7832e4291d5aa07feb", "filename": "src/test/run-fail/borrowck-wg-fail-3.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-3.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "201db14eb17d50be9b2f2e69a1edbf517e2967ed", "filename": "src/test/run-fail/borrowck-wg-fail.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "e2c8a0b549c362efc821d663fa77e519b7714a07", "filename": "src/test/run-fail/borrowck-wg-imm-then-mut.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-imm-then-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-imm-then-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-imm-then-mut.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "58b2a1d87beed70adad9d49e4bd845683b2372f0", "filename": "src/test/run-fail/borrowck-wg-mut-then-imm.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-mut-then-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-mut-then-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-mut-then-imm.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "91df90f8b3ac950406e23a2c30a306bcdb5a817c", "filename": "src/test/run-fail/borrowck-wg-one-mut-one-imm-slice-method.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slice-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slice-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slice-method.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "bae693ce4eae2efb99ffd0951a8ee2abfdd1b86d", "filename": "src/test/run-fail/borrowck-wg-one-mut-one-imm-slices.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slices.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "9e2a02b32dfed076bf4c1af93074ee451ffdab63", "filename": "src/test/run-fail/borrowck-wg-one-mut-one-imm.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "ad68448876028c62313e188d9e17358764e3b27a", "filename": "src/test/run-fail/borrowck-wg-two-array-indices.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-two-array-indices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-fail%2Fborrowck-wg-two-array-indices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-two-array-indices.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "58a477900c3248113495824c2ca5d685d8195516", "filename": "src/test/run-pass/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "4494f5f2fa337be078fd797ab9afeae7ff5648d2", "filename": "src/test/run-pass/borrowck-nested-calls.rs", "status": "renamed", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Fborrowck-nested-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Fborrowck-nested-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-nested-calls.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9", "previous_filename": "src/test/compile-fail/issue-4500.rs"}, {"sha": "20f824e969a48de8941ee64f6772b3df8658b305", "filename": "src/test/run-pass/borrowck-wg-two-imm-borrows.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Fborrowck-wg-two-imm-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Fborrowck-wg-two-imm-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-two-imm-borrows.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "b0d06dae10dc0b6fd6be0889519e432e24ced5e1", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-rcvr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "ca584e1a6e3b811082d7929dca6514e87ecf06ca", "filename": "src/test/run-pass/issue-2735-2.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Fissue-2735-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Fissue-2735-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735-2.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "44ca5d6929bd671b15b11ce5de8616744a1e431d", "filename": "src/test/run-pass/issue-2735-3.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Fissue-2735-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Fissue-2735-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735-3.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "4aeeda8312cac8f2d6be997057b5b7827bf0c7fa", "filename": "src/test/run-pass/lambda-infer-unresolved.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "5b01d24aa8be1142c2c5744d4f26e3c44c6b82d6", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05460fcd5a9b2be5055f55965f768b0aa37119d9/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=05460fcd5a9b2be5055f55965f768b0aa37119d9"}, {"sha": "d54aae7bb633727cc98d66ccbaada2faf53e488f", "filename": "src/test/run-pass/regions-mock-trans-impls.rs", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fd6e42a904723c99383e684ddeaf02f01d972/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fd6e42a904723c99383e684ddeaf02f01d972/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs?ref=bd5fd6e42a904723c99383e684ddeaf02f01d972"}]}