{"sha": "e2a869e166154c3ca9873b41c6ab8af1621704e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyYTg2OWUxNjYxNTRjM2NhOTg3M2I0MWM2YWI4YWYxNjIxNzA0ZTc=", "commit": {"author": {"name": "Philip Craig", "email": "philipjcraig@gmail.com", "date": "2019-02-09T07:15:15Z"}, "committer": {"name": "Philip Craig", "email": "philipjcraig@gmail.com", "date": "2019-02-11T07:05:38Z"}, "message": "Update gimli", "tree": {"sha": "bb092e5618ab6278e43bbcec705be50b90af9e9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb092e5618ab6278e43bbcec705be50b90af9e9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2a869e166154c3ca9873b41c6ab8af1621704e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2a869e166154c3ca9873b41c6ab8af1621704e7", "html_url": "https://github.com/rust-lang/rust/commit/e2a869e166154c3ca9873b41c6ab8af1621704e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2a869e166154c3ca9873b41c6ab8af1621704e7/comments", "author": {"login": "philipc", "id": 330342, "node_id": "MDQ6VXNlcjMzMDM0Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/330342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philipc", "html_url": "https://github.com/philipc", "followers_url": "https://api.github.com/users/philipc/followers", "following_url": "https://api.github.com/users/philipc/following{/other_user}", "gists_url": "https://api.github.com/users/philipc/gists{/gist_id}", "starred_url": "https://api.github.com/users/philipc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philipc/subscriptions", "organizations_url": "https://api.github.com/users/philipc/orgs", "repos_url": "https://api.github.com/users/philipc/repos", "events_url": "https://api.github.com/users/philipc/events{/privacy}", "received_events_url": "https://api.github.com/users/philipc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philipc", "id": 330342, "node_id": "MDQ6VXNlcjMzMDM0Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/330342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philipc", "html_url": "https://github.com/philipc", "followers_url": "https://api.github.com/users/philipc/followers", "following_url": "https://api.github.com/users/philipc/following{/other_user}", "gists_url": "https://api.github.com/users/philipc/gists{/gist_id}", "starred_url": "https://api.github.com/users/philipc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philipc/subscriptions", "organizations_url": "https://api.github.com/users/philipc/orgs", "repos_url": "https://api.github.com/users/philipc/repos", "events_url": "https://api.github.com/users/philipc/events{/privacy}", "received_events_url": "https://api.github.com/users/philipc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1eba7e5f5e80e085cea33fbac94c4238a297cf59", "url": "https://api.github.com/repos/rust-lang/rust/commits/1eba7e5f5e80e085cea33fbac94c4238a297cf59", "html_url": "https://github.com/rust-lang/rust/commit/1eba7e5f5e80e085cea33fbac94c4238a297cf59"}], "stats": {"total": 229, "additions": 79, "deletions": 150}, "files": [{"sha": "a12bb2f63dc35333ab733f6072def2438b348bb8", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2a869e166154c3ca9873b41c6ab8af1621704e7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e2a869e166154c3ca9873b41c6ab8af1621704e7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e2a869e166154c3ca9873b41c6ab8af1621704e7", "patch": "@@ -312,7 +312,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [[package]]\n name = \"gimli\"\n version = \"0.16.1\"\n-source = \"git+https://github.com/gimli-rs/gimli.git#955c33ed0056374ab349b1a175f743db3f571e0d\"\n+source = \"git+https://github.com/gimli-rs/gimli.git#1278ccb7b6eaa8eea3b9c082f18a282d3c48703b\"\n dependencies = [\n  \"arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "70622d4bd4957f27287ecf6d34c03b98f516eb07", "filename": "src/debuginfo.rs", "status": "modified", "additions": 78, "deletions": 149, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/e2a869e166154c3ca9873b41c6ab8af1621704e7/src%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a869e166154c3ca9873b41c6ab8af1621704e7/src%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo.rs?ref=e2a869e166154c3ca9873b41c6ab8af1621704e7", "patch": "@@ -7,10 +7,9 @@ use std::marker::PhantomData;\n use syntax::source_map::FileName;\n \n use gimli::write::{\n-    Address, AttributeValue, CompilationUnit, DebugAbbrev, DebugInfo, DebugLine, DebugRanges,\n-    DebugRngLists, DebugStr, EndianVec, LineProgram, LineProgramId, LineProgramTable, Range,\n-    RangeList, Result, SectionId, StringTable, UnitEntryId, UnitId, UnitTable,\n-    Writer, FileId, LineStringTable, DebugLineStr, LineString,\n+    Address, AttributeValue, DwarfUnit, EndianVec, LineProgram, Range,\n+    RangeList, Result, SectionId, UnitEntryId,\n+    Writer, FileId, LineStringTable, LineString, Sections,\n };\n use gimli::{Encoding, Format, RunTimeEndian};\n \n@@ -51,29 +50,34 @@ fn line_program_add_file(line_program: &mut LineProgram, line_strings: &mut Line\n     }\n }\n \n+#[derive(Clone)]\n struct DebugReloc {\n     offset: u32,\n     size: u8,\n-    name: String,\n+    name: DebugRelocName,\n     addend: i64,\n }\n \n+#[derive(Clone)]\n+enum DebugRelocName {\n+    Section(SectionId),\n+    Symbol(usize),\n+}\n+\n+impl DebugReloc {\n+    fn name<'a>(&self, ctx: &'a DebugContext) -> &'a str {\n+        match self.name {\n+            DebugRelocName::Section(id) => id.name(),\n+            DebugRelocName::Symbol(index) => ctx.symbols.get_index(index).unwrap(),\n+        }\n+    }\n+}\n+\n pub struct DebugContext<'tcx> {\n-    // Encoding info\n     endian: RunTimeEndian,\n     symbols: indexmap::IndexSet<String>,\n \n-    // Main data\n-    units: UnitTable,\n-    line_programs: LineProgramTable,\n-\n-    // Side tables\n-    strings: StringTable,\n-    line_strings: LineStringTable,\n-\n-    // Global ids\n-    unit_id: UnitId,\n-    global_line_program: LineProgramId,\n+    dwarf: DwarfUnit,\n     unit_range_list: RangeList,\n \n     _dummy: PhantomData<&'tcx ()>,\n@@ -89,6 +93,8 @@ impl<'a, 'tcx: 'a> DebugContext<'tcx> {\n             address_size,\n         };\n \n+        let mut dwarf = DwarfUnit::new(encoding);\n+\n         // FIXME: how to get version when building out of tree?\n         // Normally this would use option_env!(\"CFG_VERSION\").\n         let producer = format!(\"cranelift fn (rustc version {})\", \"unknown version\");\n@@ -98,45 +104,34 @@ impl<'a, 'tcx: 'a> DebugContext<'tcx> {\n             None => tcx.crate_name(LOCAL_CRATE).to_string(),\n         };\n \n-        let mut strings = StringTable::default();\n-        let mut line_strings = LineStringTable::default();\n-\n-        let mut units = UnitTable::default();\n-        let mut line_programs = LineProgramTable::default();\n-\n-        let global_line_program = line_programs.add(LineProgram::new(\n+        let line_program = LineProgram::new(\n             encoding,\n             1,\n             1,\n             -5,\n             14,\n-            LineString::new(comp_dir.as_bytes(), encoding, &mut line_strings),\n-            LineString::new(name.as_bytes(), encoding, &mut line_strings),\n+            LineString::new(comp_dir.as_bytes(), encoding, &mut dwarf.line_strings),\n+            LineString::new(name.as_bytes(), encoding, &mut dwarf.line_strings),\n             None,\n-        ));\n+        );\n+        dwarf.unit.line_program = line_program;\n \n-        let unit_id = units.add(CompilationUnit::new(encoding));\n         {\n-            let name = strings.add(&*name);\n-            let comp_dir = strings.add(&*comp_dir);\n+            let name = dwarf.strings.add(&*name);\n+            let comp_dir = dwarf.strings.add(&*comp_dir);\n \n-            let unit = units.get_mut(unit_id);\n-            let root = unit.root();\n-            let root = unit.get_mut(root);\n+            let root = dwarf.unit.root();\n+            let root = dwarf.unit.get_mut(root);\n             root.set(\n                 gimli::DW_AT_producer,\n-                AttributeValue::StringRef(strings.add(producer)),\n+                AttributeValue::StringRef(dwarf.strings.add(producer)),\n             );\n             root.set(\n                 gimli::DW_AT_language,\n                 AttributeValue::Language(gimli::DW_LANG_Rust),\n             );\n             root.set(gimli::DW_AT_name, AttributeValue::StringRef(name));\n             root.set(gimli::DW_AT_comp_dir, AttributeValue::StringRef(comp_dir));\n-            root.set(\n-                gimli::DW_AT_stmt_list,\n-                AttributeValue::LineProgramRef(global_line_program),\n-            );\n             root.set(\n                 gimli::DW_AT_low_pc,\n                 AttributeValue::Address(Address::Absolute(0)),\n@@ -147,14 +142,7 @@ impl<'a, 'tcx: 'a> DebugContext<'tcx> {\n             endian: target_endian(tcx),\n             symbols: indexmap::IndexSet::new(),\n \n-            strings,\n-            line_strings,\n-\n-            units,\n-            line_programs,\n-\n-            unit_id,\n-            global_line_program,\n+            dwarf,\n             unit_range_list: RangeList(Vec::new()),\n \n             _dummy: PhantomData,\n@@ -164,11 +152,13 @@ impl<'a, 'tcx: 'a> DebugContext<'tcx> {\n     fn emit_location(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, entry_id: UnitEntryId, span: Span) {\n         let loc = tcx.sess.source_map().lookup_char_pos(span.lo());\n \n-        let line_program = self.line_programs.get_mut(self.global_line_program);\n-        let file_id = line_program_add_file(line_program, &mut self.line_strings, &loc.file.name);\n+        let file_id = line_program_add_file(\n+            &mut self.dwarf.unit.line_program,\n+            &mut self.dwarf.line_strings,\n+            &loc.file.name,\n+        );\n \n-        let unit = self.units.get_mut(self.unit_id);\n-        let entry = unit.get_mut(entry_id);\n+        let entry = self.dwarf.unit.get_mut(entry_id);\n \n         entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(file_id));\n         entry.set(\n@@ -183,73 +173,37 @@ impl<'a, 'tcx: 'a> DebugContext<'tcx> {\n     }\n \n     pub fn emit(&mut self, artifact: &mut Artifact) {\n-        let unit = self.units.get_mut(self.unit_id);\n-        let unit_range_list_id = unit.ranges.add(self.unit_range_list.clone());\n-        let root = unit.root();\n-        let root = unit.get_mut(root);\n+        let unit_range_list_id = self.dwarf.unit.ranges.add(self.unit_range_list.clone());\n+        let root = self.dwarf.unit.root();\n+        let root = self.dwarf.unit.get_mut(root);\n         root.set(\n             gimli::DW_AT_ranges,\n             AttributeValue::RangeListRef(unit_range_list_id),\n         );\n \n-        let mut debug_abbrev = DebugAbbrev::from(WriterRelocate::new(self));\n-        let mut debug_info = DebugInfo::from(WriterRelocate::new(self));\n-        let mut debug_str = DebugStr::from(WriterRelocate::new(self));\n-        let mut debug_line_str = DebugLineStr::from(WriterRelocate::new(self));\n-        let mut debug_line = DebugLine::from(WriterRelocate::new(self));\n-        let mut debug_ranges = DebugRanges::from(WriterRelocate::new(self));\n-        let mut debug_rnglists = DebugRngLists::from(WriterRelocate::new(self));\n-\n-        let debug_str_offsets = self.strings.write(&mut debug_str).unwrap();\n-        let debug_line_str_offsets = self.line_strings.write(&mut debug_line_str).unwrap();\n-\n-        let debug_line_offsets = self.line_programs.write(&mut debug_line, &debug_line_str_offsets, &debug_str_offsets).unwrap();\n-\n-        self.units\n-            .write(\n-                &mut debug_abbrev,\n-                &mut debug_info,\n-                &mut debug_ranges,\n-                &mut debug_rnglists,\n-                &debug_line_offsets,\n-                &debug_line_str_offsets,\n-                &debug_str_offsets,\n-            )\n-            .unwrap();\n-\n-        macro decl_section($section:ident = $name:ident) {\n-            artifact\n-                .declare_with(\n-                    SectionId::$section.name(),\n-                    Decl::DebugSection,\n-                    $name.0.writer.into_vec(),\n-                )\n-                .unwrap();\n-        }\n-\n-        decl_section!(DebugAbbrev = debug_abbrev);\n-        decl_section!(DebugInfo = debug_info);\n-        decl_section!(DebugStr = debug_str);\n-        decl_section!(DebugLine = debug_line);\n-        decl_section!(DebugLineStr = debug_line_str);\n+        let mut sections = Sections::new(WriterRelocate::new(self));\n+        self.dwarf.write(&mut sections).unwrap();\n \n-        let debug_ranges_not_empty = !debug_ranges.0.writer.slice().is_empty();\n-        if debug_ranges_not_empty {\n-            decl_section!(DebugRanges = debug_ranges);\n-        }\n-\n-        let debug_rnglists_not_empty = !debug_rnglists.0.writer.slice().is_empty();\n-        if debug_rnglists_not_empty {\n-            decl_section!(DebugRngLists = debug_rnglists);\n-        }\n+        let _: Result<()> = sections.for_each_mut(|id, section| {\n+            if !section.writer.slice().is_empty() {\n+                artifact\n+                    .declare_with(\n+                        id.name(),\n+                        Decl::DebugSection,\n+                        section.writer.take(),\n+                    )\n+                    .unwrap();\n+            }\n+            Ok(())\n+        });\n \n-        macro sect_relocs($section:ident = $name:ident) {\n-            for reloc in $name.0.relocs {\n+        let _: Result<()> = sections.for_each(|id, section| {\n+            for reloc in &section.relocs {\n                 artifact\n                     .link_with(\n                         faerie::Link {\n-                            from: SectionId::$section.name(),\n-                            to: &reloc.name,\n+                            from: id.name(),\n+                            to: reloc.name(self),\n                             at: u64::from(reloc.offset),\n                         },\n                         faerie::Reloc::Debug {\n@@ -259,25 +213,8 @@ impl<'a, 'tcx: 'a> DebugContext<'tcx> {\n                     )\n                     .expect(\"faerie relocation error\");\n             }\n-        }\n-\n-        sect_relocs!(DebugAbbrev = debug_abbrev);\n-        sect_relocs!(DebugInfo = debug_info);\n-        sect_relocs!(DebugStr = debug_str);\n-        sect_relocs!(DebugLine = debug_line);\n-        sect_relocs!(DebugLineStr = debug_line_str);\n-\n-        if debug_ranges_not_empty {\n-            sect_relocs!(DebugRanges = debug_ranges);\n-        }\n-\n-        if debug_rnglists_not_empty {\n-            sect_relocs!(DebugRngLists = debug_rnglists);\n-        }\n-    }\n-\n-    fn section_name(&self, id: SectionId) -> String {\n-        id.name().to_string()\n+            Ok(())\n+        });\n     }\n }\n \n@@ -298,13 +235,12 @@ impl<'a, 'b, 'tcx: 'b> FunctionDebugContext<'a, 'tcx> {\n     ) -> Self {\n         let (symbol, _) = debug_context.symbols.insert_full(name.to_string());\n \n-        let unit = debug_context.units.get_mut(debug_context.unit_id);\n         // FIXME: add to appropriate scope intead of root\n-        let scope = unit.root();\n+        let scope = debug_context.dwarf.unit.root();\n \n-        let entry_id = unit.add(scope, gimli::DW_TAG_subprogram);\n-        let entry = unit.get_mut(entry_id);\n-        let name_id = debug_context.strings.add(name);\n+        let entry_id = debug_context.dwarf.unit.add(scope, gimli::DW_TAG_subprogram);\n+        let entry = debug_context.dwarf.unit.get_mut(entry_id);\n+        let name_id = debug_context.dwarf.strings.add(name);\n         entry.set(\n             gimli::DW_AT_linkage_name,\n             AttributeValue::StringRef(name_id),\n@@ -334,8 +270,7 @@ impl<'a, 'b, 'tcx: 'b> FunctionDebugContext<'a, 'tcx> {\n         isa: &cranelift::codegen::isa::TargetIsa,\n         source_info_set: &indexmap::IndexSet<SourceInfo>,\n     ) {\n-        let unit = self.debug_context.units.get_mut(self.debug_context.unit_id);\n-        let entry = unit.get_mut(self.entry_id);\n+        let entry = self.debug_context.dwarf.unit.get_mut(self.entry_id);\n         entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(code_size as u64));\n \n         self.debug_context.unit_range_list.0.push(Range::StartLength {\n@@ -346,10 +281,7 @@ impl<'a, 'b, 'tcx: 'b> FunctionDebugContext<'a, 'tcx> {\n             length: code_size as u64,\n         });\n \n-        let line_program = self\n-            .debug_context\n-            .line_programs\n-            .get_mut(self.debug_context.global_line_program);\n+        let line_program = &mut self.debug_context.dwarf.unit.line_program;\n \n         line_program.begin_sequence(Some(Address::Relative {\n             symbol: self.symbol,\n@@ -361,7 +293,7 @@ impl<'a, 'b, 'tcx: 'b> FunctionDebugContext<'a, 'tcx> {\n         let mut ebbs = func.layout.ebbs().collect::<Vec<_>>();\n         ebbs.sort_by_key(|ebb| func.offsets[*ebb]); // Ensure inst offsets always increase\n \n-        let line_strings = &mut self.debug_context.line_strings;\n+        let line_strings = &mut self.debug_context.dwarf.line_strings;\n         let mut create_row_for_span = |line_program: &mut LineProgram, span: Span| {\n             let loc = tcx.sess.source_map().lookup_char_pos(span.lo());\n             let file_id = line_program_add_file(line_program, line_strings, &loc.file.name);\n@@ -404,23 +336,22 @@ impl<'a, 'b, 'tcx: 'b> FunctionDebugContext<'a, 'tcx> {\n     }\n }\n \n-struct WriterRelocate<'a, 'tcx> {\n-    ctx: &'a DebugContext<'tcx>,\n+#[derive(Clone)]\n+struct WriterRelocate {\n     relocs: Vec<DebugReloc>,\n     writer: EndianVec<RunTimeEndian>,\n }\n \n-impl<'a, 'tcx> WriterRelocate<'a, 'tcx> {\n-    fn new(ctx: &'a DebugContext<'tcx>) -> Self {\n+impl WriterRelocate {\n+    fn new(ctx: & DebugContext) -> Self {\n         WriterRelocate {\n-            ctx,\n             relocs: Vec::new(),\n             writer: EndianVec::new(ctx.endian),\n         }\n     }\n }\n \n-impl<'a, 'tcx> Writer for WriterRelocate<'a, 'tcx> {\n+impl Writer for WriterRelocate {\n     type Endian = RunTimeEndian;\n \n     fn endian(&self) -> Self::Endian {\n@@ -447,7 +378,7 @@ impl<'a, 'tcx> Writer for WriterRelocate<'a, 'tcx> {\n                 self.relocs.push(DebugReloc {\n                     offset: offset as u32,\n                     size,\n-                    name: self.ctx.symbols.get_index(symbol).unwrap().clone(),\n+                    name: DebugRelocName::Symbol(symbol),\n                     addend: addend as i64,\n                 });\n                 self.write_word(0, size)\n@@ -457,11 +388,10 @@ impl<'a, 'tcx> Writer for WriterRelocate<'a, 'tcx> {\n \n     fn write_offset(&mut self, val: usize, section: SectionId, size: u8) -> Result<()> {\n         let offset = self.len() as u32;\n-        let name = self.ctx.section_name(section);\n         self.relocs.push(DebugReloc {\n             offset,\n             size,\n-            name,\n+            name: DebugRelocName::Section(section),\n             addend: val as i64,\n         });\n         self.write_word(0, size)\n@@ -474,11 +404,10 @@ impl<'a, 'tcx> Writer for WriterRelocate<'a, 'tcx> {\n         section: SectionId,\n         size: u8,\n     ) -> Result<()> {\n-        let name = self.ctx.section_name(section);\n         self.relocs.push(DebugReloc {\n             offset: offset as u32,\n             size,\n-            name,\n+            name: DebugRelocName::Section(section),\n             addend: val as i64,\n         });\n         self.write_word_at(offset, 0, size)"}]}