{"sha": "a41624829684b6c5221b0d68a9dc99e8bd8ab241", "node_id": "C_kwDOAAsO6NoAKGE0MTYyNDgyOTY4NGI2YzUyMjFiMGQ2OGE5ZGM5OWU4YmQ4YWIyNDE", "commit": {"author": {"name": "Luna Razzaghipour", "email": "lunarazzaghipour@gmail.com", "date": "2023-05-20T16:27:49Z"}, "committer": {"name": "Luna Razzaghipour", "email": "lunarazzaghipour@gmail.com", "date": "2023-05-20T16:48:30Z"}, "message": "Extract platform-specific QoS code into module", "tree": {"sha": "9c43097f399a18fd82c888ee300d3189dd91ef63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c43097f399a18fd82c888ee300d3189dd91ef63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a41624829684b6c5221b0d68a9dc99e8bd8ab241", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAAGgAAAATZWNkc2Etc2hhMi1uaXN0cDI1NgAAAAhuaXN0cDI1NgAAAE\nEEtPEPU+w9oQ90uLBc4R0g0O7C/w+fcT4a+R4nvkvJXioSPGOafBHNQJufyTj3tLLeNtO4\n1H9ztJfn/DlLu2mXigAAAANnaXQAAAAAAAAABnNoYTUxMgAAAGMAAAATZWNkc2Etc2hhMi\n1uaXN0cDI1NgAAAEgAAAAgC2TNYae8x2BI1HTECKBHUil3RxK0JRzhBT0yu88pjTkAAAAg\nP0el70pjL5W1FnKuFopdzkAh2GwvV8584NG0eY1CBAQ=\n-----END SSH SIGNATURE-----", "payload": "tree 9c43097f399a18fd82c888ee300d3189dd91ef63\nparent bb02ae7532b9c6a99eca129b146039dc5707c17e\nauthor Luna Razzaghipour <lunarazzaghipour@gmail.com> 1684600069 +1000\ncommitter Luna Razzaghipour <lunarazzaghipour@gmail.com> 1684601310 +1000\n\nExtract platform-specific QoS code into module\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a41624829684b6c5221b0d68a9dc99e8bd8ab241", "html_url": "https://github.com/rust-lang/rust/commit/a41624829684b6c5221b0d68a9dc99e8bd8ab241", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a41624829684b6c5221b0d68a9dc99e8bd8ab241/comments", "author": {"login": "lunacookies", "id": 31783266, "node_id": "MDQ6VXNlcjMxNzgzMjY2", "avatar_url": "https://avatars.githubusercontent.com/u/31783266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lunacookies", "html_url": "https://github.com/lunacookies", "followers_url": "https://api.github.com/users/lunacookies/followers", "following_url": "https://api.github.com/users/lunacookies/following{/other_user}", "gists_url": "https://api.github.com/users/lunacookies/gists{/gist_id}", "starred_url": "https://api.github.com/users/lunacookies/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lunacookies/subscriptions", "organizations_url": "https://api.github.com/users/lunacookies/orgs", "repos_url": "https://api.github.com/users/lunacookies/repos", "events_url": "https://api.github.com/users/lunacookies/events{/privacy}", "received_events_url": "https://api.github.com/users/lunacookies/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lunacookies", "id": 31783266, "node_id": "MDQ6VXNlcjMxNzgzMjY2", "avatar_url": "https://avatars.githubusercontent.com/u/31783266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lunacookies", "html_url": "https://github.com/lunacookies", "followers_url": "https://api.github.com/users/lunacookies/followers", "following_url": "https://api.github.com/users/lunacookies/following{/other_user}", "gists_url": "https://api.github.com/users/lunacookies/gists{/gist_id}", "starred_url": "https://api.github.com/users/lunacookies/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lunacookies/subscriptions", "organizations_url": "https://api.github.com/users/lunacookies/orgs", "repos_url": "https://api.github.com/users/lunacookies/repos", "events_url": "https://api.github.com/users/lunacookies/events{/privacy}", "received_events_url": "https://api.github.com/users/lunacookies/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb02ae7532b9c6a99eca129b146039dc5707c17e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb02ae7532b9c6a99eca129b146039dc5707c17e", "html_url": "https://github.com/rust-lang/rust/commit/bb02ae7532b9c6a99eca129b146039dc5707c17e"}], "stats": {"total": 173, "additions": 94, "deletions": 79}, "files": [{"sha": "5042f001435e8115df5109800cca08078312bac1", "filename": "crates/stdx/src/thread.rs", "status": "modified", "additions": 94, "deletions": 79, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/a41624829684b6c5221b0d68a9dc99e8bd8ab241/crates%2Fstdx%2Fsrc%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41624829684b6c5221b0d68a9dc99e8bd8ab241/crates%2Fstdx%2Fsrc%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fthread.rs?ref=a41624829684b6c5221b0d68a9dc99e8bd8ab241", "patch": "@@ -207,105 +207,120 @@ pub enum QoSClass {\n     UserInteractive,\n }\n \n-#[cfg(target_vendor = \"apple\")]\n-pub const IS_QOS_AVAILABLE: bool = true;\n+pub const IS_QOS_AVAILABLE: bool = imp::IS_QOS_AVAILABLE;\n \n-#[cfg(not(target_vendor = \"apple\"))]\n-pub const IS_QOS_AVAILABLE: bool = false;\n+pub fn set_current_thread_qos_class(class: QoSClass) {\n+    imp::set_current_thread_qos_class(class)\n+}\n+\n+pub fn get_current_thread_qos_class() -> Option<QoSClass> {\n+    imp::get_current_thread_qos_class()\n+}\n \n // All Apple platforms use XNU as their kernel\n // and thus have the concept of QoS.\n #[cfg(target_vendor = \"apple\")]\n-pub fn set_current_thread_qos_class(class: QoSClass) {\n-    let c = match class {\n-        QoSClass::UserInteractive => libc::qos_class_t::QOS_CLASS_USER_INTERACTIVE,\n-        QoSClass::UserInitiated => libc::qos_class_t::QOS_CLASS_USER_INITIATED,\n-        QoSClass::Utility => libc::qos_class_t::QOS_CLASS_UTILITY,\n-        QoSClass::Background => libc::qos_class_t::QOS_CLASS_BACKGROUND,\n-    };\n+mod imp {\n+    use super::QoSClass;\n \n-    let code = unsafe { libc::pthread_set_qos_class_self_np(c, 0) };\n+    pub(super) const IS_QOS_AVAILABLE: bool = true;\n \n-    if code == 0 {\n-        return;\n-    }\n+    pub(super) fn set_current_thread_qos_class(class: QoSClass) {\n+        let c = match class {\n+            QoSClass::UserInteractive => libc::qos_class_t::QOS_CLASS_USER_INTERACTIVE,\n+            QoSClass::UserInitiated => libc::qos_class_t::QOS_CLASS_USER_INITIATED,\n+            QoSClass::Utility => libc::qos_class_t::QOS_CLASS_UTILITY,\n+            QoSClass::Background => libc::qos_class_t::QOS_CLASS_BACKGROUND,\n+        };\n \n-    let errno = unsafe { *libc::__error() };\n+        let code = unsafe { libc::pthread_set_qos_class_self_np(c, 0) };\n \n-    match errno {\n-        libc::EPERM => {\n-            // This thread has been excluded from the QoS system\n-            // due to a previous call to a function such as `pthread_setschedparam`\n-            // which is incompatible with QoS.\n-            //\n-            // Panic instead of returning an error\n-            // to maintain the invariant that we only use QoS APIs.\n-            panic!(\"tried to set QoS of thread which has opted out of QoS (os error {errno})\")\n+        if code == 0 {\n+            return;\n+        }\n+\n+        let errno = unsafe { *libc::__error() };\n+\n+        match errno {\n+            libc::EPERM => {\n+                // This thread has been excluded from the QoS system\n+                // due to a previous call to a function such as `pthread_setschedparam`\n+                // which is incompatible with QoS.\n+                //\n+                // Panic instead of returning an error\n+                // to maintain the invariant that we only use QoS APIs.\n+                panic!(\"tried to set QoS of thread which has opted out of QoS (os error {errno})\")\n+            }\n+\n+            libc::EINVAL => {\n+                // This is returned if we pass something other than a qos_class_t\n+                // to `pthread_set_qos_class_self_np`.\n+                //\n+                // This is impossible, so again panic.\n+                unreachable!(\n+                    \"invalid qos_class_t value was passed to pthread_set_qos_class_self_np\"\n+                )\n+            }\n+\n+            _ => {\n+                // `pthread_set_qos_class_self_np`\u2019s documentation\n+                // does not mention any other errors.\n+                unreachable!(\"`pthread_set_qos_class_self_np` returned unexpected error {errno}\")\n+            }\n         }\n+    }\n \n-        libc::EINVAL => {\n-            // This is returned if we pass something other than a qos_class_t\n-            // to `pthread_set_qos_class_self_np`.\n+    pub(super) fn get_current_thread_qos_class() -> Option<QoSClass> {\n+        let current_thread = unsafe { libc::pthread_self() };\n+        let mut qos_class_raw = libc::qos_class_t::QOS_CLASS_UNSPECIFIED;\n+        let code = unsafe {\n+            libc::pthread_get_qos_class_np(current_thread, &mut qos_class_raw, std::ptr::null_mut())\n+        };\n+\n+        if code != 0 {\n+            // `pthread_get_qos_class_np`\u2019s documentation states that\n+            // an error value is placed into errno if the return code is not zero.\n+            // However, it never states what errors are possible.\n+            // Inspecting the source[0] shows that, as of this writing, it always returns zero.\n+            //\n+            // Whatever errors the function could report in future are likely to be\n+            // ones which we cannot handle anyway\n             //\n-            // This is impossible, so again panic.\n-            unreachable!(\"invalid qos_class_t value was passed to pthread_set_qos_class_self_np\")\n+            // 0: https://github.com/apple-oss-distributions/libpthread/blob/67e155c94093be9a204b69637d198eceff2c7c46/src/qos.c#L171-L177\n+            let errno = unsafe { *libc::__error() };\n+            unreachable!(\"`pthread_get_qos_class_np` failed unexpectedly (os error {errno})\");\n         }\n \n-        _ => {\n-            // `pthread_set_qos_class_self_np`\u2019s documentation\n-            // does not mention any other errors.\n-            unreachable!(\"`pthread_set_qos_class_self_np` returned unexpected error {errno}\")\n+        match qos_class_raw {\n+            libc::qos_class_t::QOS_CLASS_USER_INTERACTIVE => Some(QoSClass::UserInteractive),\n+            libc::qos_class_t::QOS_CLASS_USER_INITIATED => Some(QoSClass::UserInitiated),\n+            libc::qos_class_t::QOS_CLASS_DEFAULT => None, // QoS has never been set\n+            libc::qos_class_t::QOS_CLASS_UTILITY => Some(QoSClass::Utility),\n+            libc::qos_class_t::QOS_CLASS_BACKGROUND => Some(QoSClass::Background),\n+\n+            libc::qos_class_t::QOS_CLASS_UNSPECIFIED => {\n+                // Using manual scheduling APIs causes threads to \u201copt out\u201d of QoS.\n+                // At this point they become incompatible with QoS,\n+                // and as such have the \u201cunspecified\u201d QoS class.\n+                //\n+                // Panic instead of returning an error\n+                // to maintain the invariant that we only use QoS APIs.\n+                panic!(\"tried to get QoS of thread which has opted out of QoS\")\n+            }\n         }\n     }\n }\n \n+// FIXME: Windows has QoS APIs, we should use them!\n #[cfg(not(target_vendor = \"apple\"))]\n-pub fn set_current_thread_qos_class(class: QoSClass) {\n-    // FIXME: Windows has QoS APIs, we should use them!\n-}\n+mod imp {\n+    use super::QoSClass;\n \n-#[cfg(target_vendor = \"apple\")]\n-pub fn get_current_thread_qos_class() -> Option<QoSClass> {\n-    let current_thread = unsafe { libc::pthread_self() };\n-    let mut qos_class_raw = libc::qos_class_t::QOS_CLASS_UNSPECIFIED;\n-    let code = unsafe {\n-        libc::pthread_get_qos_class_np(current_thread, &mut qos_class_raw, std::ptr::null_mut())\n-    };\n-\n-    if code != 0 {\n-        // `pthread_get_qos_class_np`\u2019s documentation states that\n-        // an error value is placed into errno if the return code is not zero.\n-        // However, it never states what errors are possible.\n-        // Inspecting the source[0] shows that, as of this writing, it always returns zero.\n-        //\n-        // Whatever errors the function could report in future are likely to be\n-        // ones which we cannot handle anyway\n-        //\n-        // 0: https://github.com/apple-oss-distributions/libpthread/blob/67e155c94093be9a204b69637d198eceff2c7c46/src/qos.c#L171-L177\n-        let errno = unsafe { *libc::__error() };\n-        unreachable!(\"`pthread_get_qos_class_np` failed unexpectedly (os error {errno})\");\n-    }\n+    pub(super) const IS_QOS_AVAILABLE: bool = false;\n \n-    match qos_class_raw {\n-        libc::qos_class_t::QOS_CLASS_USER_INTERACTIVE => Some(QoSClass::UserInteractive),\n-        libc::qos_class_t::QOS_CLASS_USER_INITIATED => Some(QoSClass::UserInitiated),\n-        libc::qos_class_t::QOS_CLASS_DEFAULT => None, // QoS has never been set\n-        libc::qos_class_t::QOS_CLASS_UTILITY => Some(QoSClass::Utility),\n-        libc::qos_class_t::QOS_CLASS_BACKGROUND => Some(QoSClass::Background),\n-\n-        libc::qos_class_t::QOS_CLASS_UNSPECIFIED => {\n-            // Using manual scheduling APIs causes threads to \u201copt out\u201d of QoS.\n-            // At this point they become incompatible with QoS,\n-            // and as such have the \u201cunspecified\u201d QoS class.\n-            //\n-            // Panic instead of returning an error\n-            // to maintain the invariant that we only use QoS APIs.\n-            panic!(\"tried to get QoS of thread which has opted out of QoS\")\n-        }\n-    }\n-}\n+    pub(super) fn set_current_thread_qos_class(_: QoSClass) {}\n \n-#[cfg(not(target_vendor = \"apple\"))]\n-pub fn get_current_thread_qos_class() -> Option<QoSClass> {\n-    None\n+    pub(super) fn get_current_thread_qos_class() -> Option<QoSClass> {\n+        None\n+    }\n }"}]}