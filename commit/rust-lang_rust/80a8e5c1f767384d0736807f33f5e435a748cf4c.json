{"sha": "80a8e5c1f767384d0736807f33f5e435a748cf4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYThlNWMxZjc2NzM4NGQwNzM2ODA3ZjMzZjVlNDM1YTc0OGNmNGM=", "commit": {"author": {"name": "Sebastian Dr\u00f6ge", "email": "sebastian@centricular.com", "date": "2018-09-25T22:35:54Z"}, "committer": {"name": "Sebastian Dr\u00f6ge", "email": "sebastian@centricular.com", "date": "2018-10-18T07:38:05Z"}, "message": "Add slice::rchunks(), rchunks_mut(), rchunks_exact() and rchunks_exact_mut()\n\nThese work exactly like the normal chunks iterators but start creating\nchunks from the end of the slice.\n\nSee #55177 for the tracking issue", "tree": {"sha": "eaad523abf6caa0274f6df18340517bc8f4b7005", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaad523abf6caa0274f6df18340517bc8f4b7005"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80a8e5c1f767384d0736807f33f5e435a748cf4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80a8e5c1f767384d0736807f33f5e435a748cf4c", "html_url": "https://github.com/rust-lang/rust/commit/80a8e5c1f767384d0736807f33f5e435a748cf4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80a8e5c1f767384d0736807f33f5e435a748cf4c/comments", "author": {"login": "sdroege", "id": 301846, "node_id": "MDQ6VXNlcjMwMTg0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/301846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdroege", "html_url": "https://github.com/sdroege", "followers_url": "https://api.github.com/users/sdroege/followers", "following_url": "https://api.github.com/users/sdroege/following{/other_user}", "gists_url": "https://api.github.com/users/sdroege/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdroege/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdroege/subscriptions", "organizations_url": "https://api.github.com/users/sdroege/orgs", "repos_url": "https://api.github.com/users/sdroege/repos", "events_url": "https://api.github.com/users/sdroege/events{/privacy}", "received_events_url": "https://api.github.com/users/sdroege/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sdroege", "id": 301846, "node_id": "MDQ6VXNlcjMwMTg0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/301846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdroege", "html_url": "https://github.com/sdroege", "followers_url": "https://api.github.com/users/sdroege/followers", "following_url": "https://api.github.com/users/sdroege/following{/other_user}", "gists_url": "https://api.github.com/users/sdroege/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdroege/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdroege/subscriptions", "organizations_url": "https://api.github.com/users/sdroege/orgs", "repos_url": "https://api.github.com/users/sdroege/repos", "events_url": "https://api.github.com/users/sdroege/events{/privacy}", "received_events_url": "https://api.github.com/users/sdroege/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "567557f630693d47fd21151ff1fdbc430e330a13", "url": "https://api.github.com/repos/rust-lang/rust/commits/567557f630693d47fd21151ff1fdbc430e330a13", "html_url": "https://github.com/rust-lang/rust/commit/567557f630693d47fd21151ff1fdbc430e330a13"}], "stats": {"total": 1093, "additions": 1058, "deletions": 35}, "files": [{"sha": "0cad471d9a1d51fda7aa77b88c924768241e39e2", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80a8e5c1f767384d0736807f33f5e435a748cf4c/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a8e5c1f767384d0736807f33f5e435a748cf4c/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=80a8e5c1f767384d0736807f33f5e435a748cf4c", "patch": "@@ -120,6 +120,7 @@\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n #![feature(maybe_uninit)]\n+#![feature(rchunks)]\n \n // Allow testing this library\n "}, {"sha": "2628757b503c147b58b459cda3c9f552ed778d69", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80a8e5c1f767384d0736807f33f5e435a748cf4c/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a8e5c1f767384d0736807f33f5e435a748cf4c/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=80a8e5c1f767384d0736807f33f5e435a748cf4c", "patch": "@@ -125,6 +125,8 @@ pub use core::slice::{from_ref, from_mut};\n pub use core::slice::SliceIndex;\n #[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n pub use core::slice::{ChunksExact, ChunksExactMut};\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+pub use core::slice::{RChunks, RChunksMut, RChunksExact, RChunksExactMut};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods"}, {"sha": "62c84c9e0864eeb5e4839a3b8e71498826da65ec", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80a8e5c1f767384d0736807f33f5e435a748cf4c/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a8e5c1f767384d0736807f33f5e435a748cf4c/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=80a8e5c1f767384d0736807f33f5e435a748cf4c", "patch": "@@ -20,6 +20,7 @@\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(chunks_exact)]\n+#![feature(rchunks)]\n #![feature(repeat_generic_slice)]\n \n extern crate alloc_system;"}, {"sha": "a50f99b00220aaf68ed92bcbea68cf5138c239a5", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 114, "deletions": 2, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/80a8e5c1f767384d0736807f33f5e435a748cf4c/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a8e5c1f767384d0736807f33f5e435a748cf4c/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=80a8e5c1f767384d0736807f33f5e435a748cf4c", "patch": "@@ -998,6 +998,54 @@ fn test_chunks_exactator_0() {\n     let _it = v.chunks_exact(0);\n }\n \n+#[test]\n+fn test_rchunksator() {\n+    let v = &[1, 2, 3, 4, 5];\n+\n+    assert_eq!(v.rchunks(2).len(), 3);\n+\n+    let chunks: &[&[_]] = &[&[4, 5], &[2, 3], &[1]];\n+    assert_eq!(v.rchunks(2).collect::<Vec<_>>(), chunks);\n+    let chunks: &[&[_]] = &[&[3, 4, 5], &[1, 2]];\n+    assert_eq!(v.rchunks(3).collect::<Vec<_>>(), chunks);\n+    let chunks: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(v.rchunks(6).collect::<Vec<_>>(), chunks);\n+\n+    let chunks: &[&[_]] = &[&[1], &[2, 3], &[4, 5]];\n+    assert_eq!(v.rchunks(2).rev().collect::<Vec<_>>(), chunks);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_rchunksator_0() {\n+    let v = &[1, 2, 3, 4];\n+    let _it = v.rchunks(0);\n+}\n+\n+#[test]\n+fn test_rchunks_exactator() {\n+    let v = &[1, 2, 3, 4, 5];\n+\n+    assert_eq!(v.rchunks_exact(2).len(), 2);\n+\n+    let chunks: &[&[_]] = &[&[4, 5], &[2, 3]];\n+    assert_eq!(v.rchunks_exact(2).collect::<Vec<_>>(), chunks);\n+    let chunks: &[&[_]] = &[&[3, 4, 5]];\n+    assert_eq!(v.rchunks_exact(3).collect::<Vec<_>>(), chunks);\n+    let chunks: &[&[_]] = &[];\n+    assert_eq!(v.rchunks_exact(6).collect::<Vec<_>>(), chunks);\n+\n+    let chunks: &[&[_]] = &[&[2, 3], &[4, 5]];\n+    assert_eq!(v.rchunks_exact(2).rev().collect::<Vec<_>>(), chunks);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_rchunks_exactator_0() {\n+    let v = &[1, 2, 3, 4];\n+    let _it = v.rchunks_exact(0);\n+}\n+\n #[test]\n fn test_reverse_part() {\n     let mut values = [1, 2, 3, 4, 5];\n@@ -1205,7 +1253,7 @@ fn test_get_mut() {\n #[test]\n fn test_mut_chunks() {\n     let mut v = [0, 1, 2, 3, 4, 5, 6];\n-    assert_eq!(v.chunks_mut(2).len(), 4);\n+    assert_eq!(v.chunks_mut(3).len(), 3);\n     for (i, chunk) in v.chunks_mut(3).enumerate() {\n         for x in chunk {\n             *x = i as u8;\n@@ -1237,7 +1285,7 @@ fn test_mut_chunks_0() {\n #[test]\n fn test_mut_chunks_exact() {\n     let mut v = [0, 1, 2, 3, 4, 5, 6];\n-    assert_eq!(v.chunks_exact_mut(2).len(), 3);\n+    assert_eq!(v.chunks_exact_mut(3).len(), 2);\n     for (i, chunk) in v.chunks_exact_mut(3).enumerate() {\n         for x in chunk {\n             *x = i as u8;\n@@ -1266,6 +1314,70 @@ fn test_mut_chunks_exact_0() {\n     let _it = v.chunks_exact_mut(0);\n }\n \n+#[test]\n+fn test_mut_rchunks() {\n+    let mut v = [0, 1, 2, 3, 4, 5, 6];\n+    assert_eq!(v.rchunks_mut(3).len(), 3);\n+    for (i, chunk) in v.rchunks_mut(3).enumerate() {\n+        for x in chunk {\n+            *x = i as u8;\n+        }\n+    }\n+    let result = [2, 1, 1, 1, 0, 0, 0];\n+    assert_eq!(v, result);\n+}\n+\n+#[test]\n+fn test_mut_rchunks_rev() {\n+    let mut v = [0, 1, 2, 3, 4, 5, 6];\n+    for (i, chunk) in v.rchunks_mut(3).rev().enumerate() {\n+        for x in chunk {\n+            *x = i as u8;\n+        }\n+    }\n+    let result = [0, 1, 1, 1, 2, 2, 2];\n+    assert_eq!(v, result);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mut_rchunks_0() {\n+    let mut v = [1, 2, 3, 4];\n+    let _it = v.rchunks_mut(0);\n+}\n+\n+#[test]\n+fn test_mut_rchunks_exact() {\n+    let mut v = [0, 1, 2, 3, 4, 5, 6];\n+    assert_eq!(v.rchunks_exact_mut(3).len(), 2);\n+    for (i, chunk) in v.rchunks_exact_mut(3).enumerate() {\n+        for x in chunk {\n+            *x = i as u8;\n+        }\n+    }\n+    let result = [0, 1, 1, 1, 0, 0, 0];\n+    assert_eq!(v, result);\n+}\n+\n+#[test]\n+fn test_mut_rchunks_exact_rev() {\n+    let mut v = [0, 1, 2, 3, 4, 5, 6];\n+    for (i, chunk) in v.rchunks_exact_mut(3).rev().enumerate() {\n+        for x in chunk {\n+            *x = i as u8;\n+        }\n+    }\n+    let result = [0, 0, 0, 0, 1, 1, 1];\n+    assert_eq!(v, result);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mut_rchunks_exact_0() {\n+    let mut v = [1, 2, 3, 4];\n+    let _it = v.rchunks_exact_mut(0);\n+}\n+\n #[test]\n fn test_mut_last() {\n     let mut x = [1, 2, 3, 4, 5];"}, {"sha": "6801eb9ea09d5a5b71426663d4ce39d9f282241b", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 717, "deletions": 33, "changes": 750, "blob_url": "https://github.com/rust-lang/rust/blob/80a8e5c1f767384d0736807f33f5e435a748cf4c/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a8e5c1f767384d0736807f33f5e435a748cf4c/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=80a8e5c1f767384d0736807f33f5e435a748cf4c", "patch": "@@ -620,13 +620,15 @@ impl<T> [T] {\n         Windows { v: self, size }\n     }\n \n-    /// Returns an iterator over `chunk_size` elements of the slice at a\n-    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last chunk will\n-    /// not have length `chunk_size`.\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n+    /// beginning of the slice.\n     ///\n-    /// See [`chunks_exact`] for a variant of this iterator that returns chunks\n-    /// of always exactly `chunk_size` elements.\n+    /// The chunks are slices and do not overlap. If `chunk_size` does not divide the length of the\n+    /// slice, then the last chunk will not have length `chunk_size`.\n+    ///\n+    /// See [`chunks_exact`] for a variant of this iterator that returns chunks of always exactly\n+    /// `chunk_size` elements, and [`rchunks`] for the same iterator but starting at the end of the\n+    /// slice of the slice.\n     ///\n     /// # Panics\n     ///\n@@ -644,20 +646,23 @@ impl<T> [T] {\n     /// ```\n     ///\n     /// [`chunks_exact`]: #method.chunks_exact\n+    /// [`rchunks`]: #method.rchunks\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n         assert!(chunk_size != 0);\n         Chunks { v: self, chunk_size }\n     }\n \n-    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n-    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last chunk will not\n-    /// have length `chunk_size`.\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n+    /// beginning of the slice.\n+    ///\n+    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does not divide the\n+    /// length of the slice, then the last chunk will not have length `chunk_size`.\n     ///\n-    /// See [`chunks_exact_mut`] for a variant of this iterator that returns chunks\n-    /// of always exactly `chunk_size` elements.\n+    /// See [`chunks_exact_mut`] for a variant of this iterator that returns chunks of always\n+    /// exactly `chunk_size` elements, and [`rchunks_mut`] for the same iterator but starting at\n+    /// the end of the slice of the slice.\n     ///\n     /// # Panics\n     ///\n@@ -679,22 +684,27 @@ impl<T> [T] {\n     /// ```\n     ///\n     /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n+    /// [`rchunks_mut`]: #method.rchunks_mut\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n         assert!(chunk_size != 0);\n         ChunksMut { v: self, chunk_size }\n     }\n \n-    /// Returns an iterator over `chunk_size` elements of the slice at a\n-    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last up to `chunk_size-1`\n-    /// elements will be omitted and can be retrieved from the `remainder`\n-    /// function of the iterator.\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n+    /// beginning of the slice.\n+    ///\n+    /// The chunks are slices and do not overlap. If `chunk_size` does not divide the length of the\n+    /// slice, then the last up to `chunk_size-1` elements will be omitted and can be retrieved\n+    /// from the `remainder` function of the iterator.\n+    ///\n+    /// Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the\n+    /// resulting code better than in the case of [`chunks`].\n     ///\n-    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n-    /// can often optimize the resulting code better than in the case of\n-    /// [`chunks`].\n+    /// See [`chunks`] for a variant of this iterator that also returns the remainder as a smaller\n+    /// chunk, and [`rchunks_exact`] for the same iterator but starting at the end of the slice of\n+    /// the slice.\n     ///\n     /// # Panics\n     ///\n@@ -710,9 +720,11 @@ impl<T> [T] {\n     /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n     /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n     /// assert!(iter.next().is_none());\n+    /// assert_eq!(iter.remainder(), &['m']);\n     /// ```\n     ///\n     /// [`chunks`]: #method.chunks\n+    /// [`rchunks_exact`]: #method.rchunks_exact\n     #[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n     #[inline]\n     pub fn chunks_exact(&self, chunk_size: usize) -> ChunksExact<T> {\n@@ -723,15 +735,19 @@ impl<T> [T] {\n         ChunksExact { v: fst, rem: snd, chunk_size }\n     }\n \n-    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n-    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last up to `chunk_size-1`\n-    /// elements will be omitted and can be retrieved from the `into_remainder`\n-    /// function of the iterator.\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n+    /// beginning of the slice.\n     ///\n-    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n-    /// can often optimize the resulting code better than in the case of\n-    /// [`chunks_mut`].\n+    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does not divide the\n+    /// length of the slice, then the last up to `chunk_size-1` elements will be omitted and can be\n+    /// retrieved from the `into_remainder` function of the iterator.\n+    ///\n+    /// Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the\n+    /// resulting code better than in the case of [`chunks_mut`].\n+    ///\n+    /// See [`chunks_mut`] for a variant of this iterator that also returns the remainder as a\n+    /// smaller chunk, and [`rchunks_exact_mut`] for the same iterator but starting at the end of\n+    /// the slice of the slice.\n     ///\n     /// # Panics\n     ///\n@@ -755,6 +771,7 @@ impl<T> [T] {\n     /// ```\n     ///\n     /// [`chunks_mut`]: #method.chunks_mut\n+    /// [`rchunks_exact_mut`]: #method.rchunks_exact_mut\n     #[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n     #[inline]\n     pub fn chunks_exact_mut(&mut self, chunk_size: usize) -> ChunksExactMut<T> {\n@@ -765,6 +782,170 @@ impl<T> [T] {\n         ChunksExactMut { v: fst, rem: snd, chunk_size }\n     }\n \n+    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n+    /// of the slice.\n+    ///\n+    /// The chunks are slices and do not overlap. If `chunk_size` does not divide the length of the\n+    /// slice, then the last chunk will not have length `chunk_size`.\n+    ///\n+    /// See [`rchunks_exact`] for a variant of this iterator that returns chunks of always exactly\n+    /// `chunk_size` elements, and [`chunks`] for the same iterator but starting at the beginning\n+    /// of the slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rchunks)]\n+    ///\n+    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n+    /// let mut iter = slice.rchunks(2);\n+    /// assert_eq!(iter.next().unwrap(), &['e', 'm']);\n+    /// assert_eq!(iter.next().unwrap(), &['o', 'r']);\n+    /// assert_eq!(iter.next().unwrap(), &['l']);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// [`rchunks_exact`]: #method.rchunks_exact\n+    /// [`chunks`]: #method.chunks\n+    #[unstable(feature = \"rchunks\", issue = \"55177\")]\n+    #[inline]\n+    pub fn rchunks(&self, chunk_size: usize) -> RChunks<T> {\n+        assert!(chunk_size != 0);\n+        RChunks { v: self, chunk_size }\n+    }\n+\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n+    /// of the slice.\n+    ///\n+    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does not divide the\n+    /// length of the slice, then the last chunk will not have length `chunk_size`.\n+    ///\n+    /// See [`rchunks_exact_mut`] for a variant of this iterator that returns chunks of always\n+    /// exactly `chunk_size` elements, and [`chunks_mut`] for the same iterator but starting at the\n+    /// beginning of the slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rchunks)]\n+    ///\n+    /// let v = &mut [0, 0, 0, 0, 0];\n+    /// let mut count = 1;\n+    ///\n+    /// for chunk in v.rchunks_mut(2) {\n+    ///     for elem in chunk.iter_mut() {\n+    ///         *elem += count;\n+    ///     }\n+    ///     count += 1;\n+    /// }\n+    /// assert_eq!(v, &[3, 2, 2, 1, 1]);\n+    /// ```\n+    ///\n+    /// [`rchunks_exact_mut`]: #method.rchunks_exact_mut\n+    /// [`chunks_mut`]: #method.chunks_mut\n+    #[unstable(feature = \"rchunks\", issue = \"55177\")]\n+    #[inline]\n+    pub fn rchunks_mut(&mut self, chunk_size: usize) -> RChunksMut<T> {\n+        assert!(chunk_size != 0);\n+        RChunksMut { v: self, chunk_size }\n+    }\n+\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n+    /// beginning of the slice.\n+    ///\n+    /// The chunks are slices and do not overlap. If `chunk_size` does not divide the length of the\n+    /// slice, then the last up to `chunk_size-1` elements will be omitted and can be retrieved\n+    /// from the `remainder` function of the iterator.\n+    ///\n+    /// Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the\n+    /// resulting code better than in the case of [`chunks`].\n+    ///\n+    /// See [`rchunks`] for a variant of this iterator that also returns the remainder as a smaller\n+    /// chunk, and [`chunks_exact`] for the same iterator but starting at the beginning of the\n+    /// slice of the slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rchunks)]\n+    ///\n+    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n+    /// let mut iter = slice.rchunks_exact(2);\n+    /// assert_eq!(iter.next().unwrap(), &['e', 'm']);\n+    /// assert_eq!(iter.next().unwrap(), &['o', 'r']);\n+    /// assert!(iter.next().is_none());\n+    /// assert_eq!(iter.remainder(), &['l']);\n+    /// ```\n+    ///\n+    /// [`rchunks`]: #method.rchunks\n+    /// [`chunks_exact`]: #method.chunks_exact\n+    #[unstable(feature = \"rchunks\", issue = \"55177\")]\n+    #[inline]\n+    pub fn rchunks_exact(&self, chunk_size: usize) -> RChunksExact<T> {\n+        assert!(chunk_size != 0);\n+        let rem = self.len() % chunk_size;\n+        let (fst, snd) = self.split_at(rem);\n+        RChunksExact { v: snd, rem: fst, chunk_size }\n+    }\n+\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n+    /// of the slice.\n+    ///\n+    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does not divide the\n+    /// length of the slice, then the last up to `chunk_size-1` elements will be omitted and can be\n+    /// retrieved from the `into_remainder` function of the iterator.\n+    ///\n+    /// Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the\n+    /// resulting code better than in the case of [`chunks_mut`].\n+    ///\n+    /// See [`rchunks_mut`] for a variant of this iterator that also returns the remainder as a\n+    /// smaller chunk, and [`chunks_exact_mut`] for the same iterator but starting at the beginning\n+    /// of the slice of the slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rchunks)]\n+    ///\n+    /// let v = &mut [0, 0, 0, 0, 0];\n+    /// let mut count = 1;\n+    ///\n+    /// for chunk in v.rchunks_exact_mut(2) {\n+    ///     for elem in chunk.iter_mut() {\n+    ///         *elem += count;\n+    ///     }\n+    ///     count += 1;\n+    /// }\n+    /// assert_eq!(v, &[0, 2, 2, 1, 1]);\n+    /// ```\n+    ///\n+    /// [`rchunks_mut`]: #method.rchunks_mut\n+    /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n+    #[unstable(feature = \"rchunks\", issue = \"55177\")]\n+    #[inline]\n+    pub fn rchunks_exact_mut(&mut self, chunk_size: usize) -> RChunksExactMut<T> {\n+        assert!(chunk_size != 0);\n+        let rem = self.len() % chunk_size;\n+        let (fst, snd) = self.split_at_mut(rem);\n+        RChunksExactMut { v: snd, rem: fst, chunk_size }\n+    }\n+\n     /// Divides one slice into two at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding\n@@ -3581,7 +3762,7 @@ unsafe impl<'a, T> TrustedRandomAccess for Windows<'a, T> {\n }\n \n /// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n-/// time).\n+/// time), starting at the beginning of the slice.\n ///\n /// When the slice len is not evenly divided by the chunk size, the last slice\n /// of the iteration will be the remainder.\n@@ -3708,8 +3889,10 @@ unsafe impl<'a, T> TrustedRandomAccess for Chunks<'a, T> {\n }\n \n /// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n-/// elements at a time). When the slice len is not evenly divided by the chunk\n-/// size, the last slice of the iteration will be the remainder.\n+/// elements at a time), starting at the beginning of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last slice\n+/// of the iteration will be the remainder.\n ///\n /// This struct is created by the [`chunks_mut`] method on [slices].\n ///\n@@ -3827,7 +4010,7 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n }\n \n /// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n-/// time).\n+/// time), starting at the beginning of the slice.\n ///\n /// When the slice len is not evenly divided by the chunk size, the last\n /// up to `chunk_size-1` elements will be omitted but can be retrieved from\n@@ -3941,6 +4124,7 @@ unsafe impl<T> TrustedLen for ChunksExact<'_, T> {}\n impl<T> FusedIterator for ChunksExact<'_, T> {}\n \n #[doc(hidden)]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n unsafe impl<'a, T> TrustedRandomAccess for ChunksExact<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n         let start = i * self.chunk_size;\n@@ -3950,7 +4134,7 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExact<'a, T> {\n }\n \n /// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n-/// elements at a time).\n+/// elements at a time), starting at the beginning of the slice.\n ///\n /// When the slice len is not evenly divided by the chunk size, the last up to\n /// `chunk_size-1` elements will be omitted but can be retrieved from the\n@@ -4056,6 +4240,7 @@ unsafe impl<T> TrustedLen for ChunksExactMut<'_, T> {}\n impl<T> FusedIterator for ChunksExactMut<'_, T> {}\n \n #[doc(hidden)]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n         let start = i * self.chunk_size;\n@@ -4064,6 +4249,505 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n     fn may_have_side_effect() -> bool { false }\n }\n \n+/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n+/// time), starting at the end of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last slice\n+/// of the iteration will be the remainder.\n+///\n+/// This struct is created by the [`rchunks`] method on [slices].\n+///\n+/// [`rchunks`]: ../../std/primitive.slice.html#method.rchunks\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+pub struct RChunks<'a, T:'a> {\n+    v: &'a [T],\n+    chunk_size: usize\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> Clone for RChunks<'a, T> {\n+    fn clone(&self) -> RChunks<'a, T> {\n+        RChunks {\n+            v: self.v,\n+            chunk_size: self.chunk_size,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> Iterator for RChunks<'a, T> {\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let chunksz = cmp::min(self.v.len(), self.chunk_size);\n+            let (fst, snd) = self.v.split_at(self.v.len() - chunksz);\n+            self.v = fst;\n+            Some(snd)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.v.is_empty() {\n+            (0, Some(0))\n+        } else {\n+            let n = self.v.len() / self.chunk_size;\n+            let rem = self.v.len() % self.chunk_size;\n+            let n = if rem > 0 { n+1 } else { n };\n+            (n, Some(n))\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let (end, overflow) = n.overflowing_mul(self.chunk_size);\n+        if end >= self.v.len() || overflow {\n+            self.v = &[];\n+            None\n+        } else {\n+            // Can't underflow because of the check above\n+            let end = self.v.len() - end;\n+            let start = match end.checked_sub(self.chunk_size) {\n+                Some(sum) => sum,\n+                None => 0,\n+            };\n+            let nth = &self.v[start..end];\n+            self.v = &self.v[0..start];\n+            Some(nth)\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let rem = self.v.len() % self.chunk_size;\n+            let end = if rem == 0 { self.chunk_size } else { rem };\n+            Some(&self.v[0..end])\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> DoubleEndedIterator for RChunks<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.chunk_size;\n+            let chunksz = if remainder != 0 { remainder } else { self.chunk_size };\n+            let (fst, snd) = self.v.split_at(chunksz);\n+            self.v = snd;\n+            Some(fst)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> ExactSizeIterator for RChunks<'a, T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, T> TrustedLen for RChunks<'a, T> {}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> FusedIterator for RChunks<'a, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+unsafe impl<'a, T> TrustedRandomAccess for RChunks<'a, T> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n+        let end = self.v.len() - i * self.chunk_size;\n+        let start = match end.checked_sub(self.chunk_size) {\n+            None => 0,\n+            Some(start) => start,\n+        };\n+        from_raw_parts(self.v.as_ptr().add(start), end - start)\n+    }\n+    fn may_have_side_effect() -> bool { false }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n+/// elements at a time), starting at the end of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last slice\n+/// of the iteration will be the remainder.\n+///\n+/// This struct is created by the [`rchunks_mut`] method on [slices].\n+///\n+/// [`rchunks_mut`]: ../../std/primitive.slice.html#method.rchunks_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+pub struct RChunksMut<'a, T:'a> {\n+    v: &'a mut [T],\n+    chunk_size: usize\n+}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> Iterator for RChunksMut<'a, T> {\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let sz = cmp::min(self.v.len(), self.chunk_size);\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (head, tail) = tmp.split_at_mut(tmp_len - sz);\n+            self.v = head;\n+            Some(tail)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.v.is_empty() {\n+            (0, Some(0))\n+        } else {\n+            let n = self.v.len() / self.chunk_size;\n+            let rem = self.v.len() % self.chunk_size;\n+            let n = if rem > 0 { n + 1 } else { n };\n+            (n, Some(n))\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n+        let (end, overflow) = n.overflowing_mul(self.chunk_size);\n+        if end >= self.v.len() || overflow {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            // Can't underflow because of the check above\n+            let end = self.v.len() - end;\n+            let start = match end.checked_sub(self.chunk_size) {\n+                Some(sum) => sum,\n+                None => 0,\n+            };\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.split_at_mut(start);\n+            let (nth, _) = tail.split_at_mut(end - start);\n+            self.v = head;\n+            Some(nth)\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let rem = self.v.len() % self.chunk_size;\n+            let end = if rem == 0 { self.chunk_size } else { rem };\n+            Some(&mut self.v[0..end])\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.chunk_size;\n+            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.split_at_mut(sz);\n+            self.v = tail;\n+            Some(head)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> ExactSizeIterator for RChunksMut<'a, T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, T> TrustedLen for RChunksMut<'a, T> {}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> FusedIterator for RChunksMut<'a, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+unsafe impl<'a, T> TrustedRandomAccess for RChunksMut<'a, T> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n+        let end = self.v.len() - i * self.chunk_size;\n+        let start = match end.checked_sub(self.chunk_size) {\n+            None => 0,\n+            Some(start) => start,\n+        };\n+        from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start)\n+    }\n+    fn may_have_side_effect() -> bool { false }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n+/// time), starting at the end of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last\n+/// up to `chunk_size-1` elements will be omitted but can be retrieved from\n+/// the [`remainder`] function from the iterator.\n+///\n+/// This struct is created by the [`rchunks_exact`] method on [slices].\n+///\n+/// [`rchunks_exact`]: ../../std/primitive.slice.html#method.rchunks_exact\n+/// [`remainder`]: ../../std/slice/struct.ChunksExact.html#method.remainder\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+pub struct RChunksExact<'a, T:'a> {\n+    v: &'a [T],\n+    rem: &'a [T],\n+    chunk_size: usize\n+}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> RChunksExact<'a, T> {\n+    /// Return the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// elements.\n+    pub fn remainder(&self) -> &'a [T] {\n+        self.rem\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> Clone for RChunksExact<'a, T> {\n+    fn clone(&self) -> RChunksExact<'a, T> {\n+        RChunksExact {\n+            v: self.v,\n+            rem: self.rem,\n+            chunk_size: self.chunk_size,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> Iterator for RChunksExact<'a, T> {\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let (fst, snd) = self.v.split_at(self.v.len() - self.chunk_size);\n+            self.v = fst;\n+            Some(snd)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.v.len() / self.chunk_size;\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let (end, overflow) = n.overflowing_mul(self.chunk_size);\n+        if end >= self.v.len() || overflow {\n+            self.v = &[];\n+            None\n+        } else {\n+            let (fst, _) = self.v.split_at(self.v.len() - end);\n+            self.v = fst;\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> DoubleEndedIterator for RChunksExact<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let (fst, snd) = self.v.split_at(self.chunk_size);\n+            self.v = snd;\n+            Some(fst)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> ExactSizeIterator for RChunksExact<'a, T> {\n+    fn is_empty(&self) -> bool {\n+        self.v.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, T> TrustedLen for RChunksExact<'a, T> {}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> FusedIterator for RChunksExact<'a, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+unsafe impl<'a, T> TrustedRandomAccess for RChunksExact<'a, T> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n+        let end = self.v.len() - i * self.chunk_size;\n+        let start = end - self.chunk_size;\n+        from_raw_parts(self.v.as_ptr().add(start), self.chunk_size)\n+    }\n+    fn may_have_side_effect() -> bool { false }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n+/// elements at a time), starting at the end of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last up to\n+/// `chunk_size-1` elements will be omitted but can be retrieved from the\n+/// [`into_remainder`] function from the iterator.\n+///\n+/// This struct is created by the [`rchunks_exact_mut`] method on [slices].\n+///\n+/// [`rchunks_exact_mut`]: ../../std/primitive.slice.html#method.rchunks_exact_mut\n+/// [`into_remainder`]: ../../std/slice/struct.ChunksExactMut.html#method.into_remainder\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+pub struct RChunksExactMut<'a, T:'a> {\n+    v: &'a mut [T],\n+    rem: &'a mut [T],\n+    chunk_size: usize\n+}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> RChunksExactMut<'a, T> {\n+    /// Return the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// elements.\n+    pub fn into_remainder(self) -> &'a mut [T] {\n+        self.rem\n+    }\n+}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n+            self.v = head;\n+            Some(tail)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.v.len() / self.chunk_size;\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n+        let (end, overflow) = n.overflowing_mul(self.chunk_size);\n+        if end >= self.v.len() || overflow {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (fst, _) = tmp.split_at_mut(tmp_len - end);\n+            self.v = fst;\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n+            self.v = tail;\n+            Some(head)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> ExactSizeIterator for RChunksExactMut<'a, T> {\n+    fn is_empty(&self) -> bool {\n+        self.v.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, T> TrustedLen for RChunksExactMut<'a, T> {}\n+\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+impl<'a, T> FusedIterator for RChunksExactMut<'a, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n+        let end = self.v.len() - i * self.chunk_size;\n+        let start = end - self.chunk_size;\n+        from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size)\n+    }\n+    fn may_have_side_effect() -> bool { false }\n+}\n+\n //\n // Free functions\n //"}, {"sha": "e889d484353a586a78f8c6bdf2411ad52095efd8", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80a8e5c1f767384d0736807f33f5e435a748cf4c/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a8e5c1f767384d0736807f33f5e435a748cf4c/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=80a8e5c1f767384d0736807f33f5e435a748cf4c", "patch": "@@ -35,6 +35,7 @@\n #![feature(try_from)]\n #![feature(try_trait)]\n #![feature(chunks_exact)]\n+#![feature(rchunks)]\n #![feature(align_offset)]\n #![feature(reverse_bits)]\n #![feature(inner_deref)]"}, {"sha": "dba5a43eb21dacbd31957b97fab7f80b05a672e4", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/80a8e5c1f767384d0736807f33f5e435a748cf4c/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a8e5c1f767384d0736807f33f5e435a748cf4c/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=80a8e5c1f767384d0736807f33f5e435a748cf4c", "patch": "@@ -338,6 +338,228 @@ fn test_chunks_exact_mut_zip() {\n     assert_eq!(v1, [13, 14, 19, 20, 4]);\n }\n \n+#[test]\n+fn test_rchunks_count() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.rchunks(3);\n+    assert_eq!(c.count(), 2);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.rchunks(2);\n+    assert_eq!(c2.count(), 3);\n+\n+    let v3: &[i32] = &[];\n+    let c3 = v3.rchunks(2);\n+    assert_eq!(c3.count(), 0);\n+}\n+\n+#[test]\n+fn test_rchunks_nth() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks(2);\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c2 = v2.rchunks(3);\n+    assert_eq!(c2.nth(1).unwrap(), &[0, 1]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n+#[test]\n+fn test_rchunks_last() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.rchunks(2);\n+    assert_eq!(c.last().unwrap()[1], 1);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.rchunks(2);\n+    assert_eq!(c2.last().unwrap()[0], 0);\n+}\n+\n+#[test]\n+fn test_rchunks_zip() {\n+    let v1: &[i32] = &[0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let res = v1.rchunks(2)\n+        .zip(v2.rchunks(2))\n+        .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n+        .collect::<Vec<_>>();\n+    assert_eq!(res, vec![26, 18, 6]);\n+}\n+\n+#[test]\n+fn test_rchunks_mut_count() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let c = v.rchunks_mut(3);\n+    assert_eq!(c.count(), 2);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c2 = v2.rchunks_mut(2);\n+    assert_eq!(c2.count(), 3);\n+\n+    let v3: &mut [i32] = &mut [];\n+    let c3 = v3.rchunks_mut(2);\n+    assert_eq!(c3.count(), 0);\n+}\n+\n+#[test]\n+fn test_rchunks_mut_nth() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks_mut(2);\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let mut c2 = v2.rchunks_mut(3);\n+    assert_eq!(c2.nth(1).unwrap(), &[0, 1]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n+#[test]\n+fn test_rchunks_mut_last() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let c = v.rchunks_mut(2);\n+    assert_eq!(c.last().unwrap(), &[0, 1]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c2 = v2.rchunks_mut(2);\n+    assert_eq!(c2.last().unwrap(), &[0]);\n+}\n+\n+#[test]\n+fn test_rchunks_mut_zip() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    for (a, b) in v1.rchunks_mut(2).zip(v2.rchunks(2)) {\n+        let sum = b.iter().sum::<i32>();\n+        for v in a {\n+            *v += sum;\n+        }\n+    }\n+    assert_eq!(v1, [6, 16, 17, 22, 23]);\n+}\n+\n+#[test]\n+fn test_rchunks_exact_count() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.rchunks_exact(3);\n+    assert_eq!(c.count(), 2);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.rchunks_exact(2);\n+    assert_eq!(c2.count(), 2);\n+\n+    let v3: &[i32] = &[];\n+    let c3 = v3.rchunks_exact(2);\n+    assert_eq!(c3.count(), 0);\n+}\n+\n+#[test]\n+fn test_rchunks_exact_nth() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks_exact(2);\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n+    let mut c2 = v2.rchunks_exact(3);\n+    assert_eq!(c2.nth(1).unwrap(), &[1, 2, 3]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n+#[test]\n+fn test_rchunks_exact_last() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.rchunks_exact(2);\n+    assert_eq!(c.last().unwrap(), &[0, 1]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.rchunks_exact(2);\n+    assert_eq!(c2.last().unwrap(), &[1, 2]);\n+}\n+\n+#[test]\n+fn test_rchunks_exact_remainder() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4];\n+    let c = v.rchunks_exact(2);\n+    assert_eq!(c.remainder(), &[0]);\n+}\n+\n+#[test]\n+fn test_rchunks_exact_zip() {\n+    let v1: &[i32] = &[0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let res = v1.rchunks_exact(2)\n+        .zip(v2.rchunks_exact(2))\n+        .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n+        .collect::<Vec<_>>();\n+    assert_eq!(res, vec![26, 18]);\n+}\n+\n+#[test]\n+fn test_rchunks_exact_mut_count() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let c = v.rchunks_exact_mut(3);\n+    assert_eq!(c.count(), 2);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c2 = v2.rchunks_exact_mut(2);\n+    assert_eq!(c2.count(), 2);\n+\n+    let v3: &mut [i32] = &mut [];\n+    let c3 = v3.rchunks_exact_mut(2);\n+    assert_eq!(c3.count(), 0);\n+}\n+\n+#[test]\n+fn test_rchunks_exact_mut_nth() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks_exact_mut(2);\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n+    let mut c2 = v2.rchunks_exact_mut(3);\n+    assert_eq!(c2.nth(1).unwrap(), &[1, 2, 3]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n+#[test]\n+fn test_rchunks_exact_mut_last() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let c = v.rchunks_exact_mut(2);\n+    assert_eq!(c.last().unwrap(), &[0, 1]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c2 = v2.rchunks_exact_mut(2);\n+    assert_eq!(c2.last().unwrap(), &[1, 2]);\n+}\n+\n+#[test]\n+fn test_rchunks_exact_mut_remainder() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c = v.rchunks_exact_mut(2);\n+    assert_eq!(c.into_remainder(), &[0]);\n+}\n+\n+#[test]\n+fn test_rchunks_exact_mut_zip() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    for (a, b) in v1.rchunks_exact_mut(2).zip(v2.rchunks_exact(2)) {\n+        let sum = b.iter().sum::<i32>();\n+        for v in a {\n+            *v += sum;\n+        }\n+    }\n+    assert_eq!(v1, [0, 16, 17, 22, 23]);\n+}\n+\n #[test]\n fn test_windows_count() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];"}]}