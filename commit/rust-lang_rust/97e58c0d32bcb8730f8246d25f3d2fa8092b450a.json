{"sha": "97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ZTU4YzBkMzJiY2I4NzMwZjgyNDZkMjVmM2QyZmE4MDkyYjQ1MGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-20T15:35:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-20T15:35:51Z"}, "message": "Auto merge of #64584 - nikomatsakis:issue-64477-generator-capture-types, r=eddyb\n\nrecord fewer adjustment types in generator witnesses, avoid spurious drops in MIR construction\n\nDon't record all intermediate adjustment types -- That's way more than is needed, and winds up recording types that will never appear in MIR.\n\nNote: I'm like 90% sure that this logic is correct, but this stuff is subtle and can be hard to keep straight.  However, the risk of this PR is fairly low -- if we miss types here, I believe the most common outcome is an ICE.\n\nThis fixes the original issue cited by #64477, but I'm leaving the issue open for now since there may be other cases we can detect and improve in a targeted way.\n\nr? @Zoxc", "tree": {"sha": "91c7f262ca3d830dde50156e752f37b12aafae9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91c7f262ca3d830dde50156e752f37b12aafae9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "html_url": "https://github.com/rust-lang/rust/commit/97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ad1e7c46cf690b7ec6953b142430d21ca2d8799", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad1e7c46cf690b7ec6953b142430d21ca2d8799", "html_url": "https://github.com/rust-lang/rust/commit/9ad1e7c46cf690b7ec6953b142430d21ca2d8799"}, {"sha": "77fd0a76491afb4c93359f6ceb33a9f79c4f4228", "url": "https://api.github.com/repos/rust-lang/rust/commits/77fd0a76491afb4c93359f6ceb33a9f79c4f4228", "html_url": "https://github.com/rust-lang/rust/commit/77fd0a76491afb4c93359f6ceb33a9f79c4f4228"}], "stats": {"total": 315, "additions": 260, "deletions": 55}, "files": [{"sha": "92efcf44dea3636ce1fcad46d89d0f48322056fc", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "patch": "@@ -1917,6 +1917,15 @@ impl<'tcx> Place<'tcx> {\n         }\n     }\n \n+    /// If this place represents a local variable like `_X` with no\n+    /// projections, return `Some(_X)`.\n+    pub fn as_local(&self) -> Option<Local> {\n+        match self {\n+            Place { projection: box [], base: PlaceBase::Local(l) } => Some(*l),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn as_ref(&self) -> PlaceRef<'_, 'tcx> {\n         PlaceRef {\n             base: &self.base,"}, {"sha": "30d53502b11ff1667a39db8a0858887b7c13e0ff", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "patch": "@@ -244,6 +244,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     let success = this.cfg.start_new_block();\n                     let cleanup = this.diverge_cleanup();\n+\n+                    this.record_operands_moved(&args);\n+\n                     this.cfg.terminate(\n                         block,\n                         source_info,"}, {"sha": "a26ec72584bda72b86ef4d814094e81ca40ce6e4", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 110, "deletions": 25, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "patch": "@@ -104,25 +104,14 @@ struct Scope {\n     /// the span of that region_scope\n     region_scope_span: Span,\n \n-    /// Whether there's anything to do for the cleanup path, that is,\n-    /// when unwinding through this scope. This includes destructors,\n-    /// but not StorageDead statements, which don't get emitted at all\n-    /// for unwinding, for several reasons:\n-    ///  * clang doesn't emit llvm.lifetime.end for C++ unwinding\n-    ///  * LLVM's memory dependency analysis can't handle it atm\n-    ///  * polluting the cleanup MIR with StorageDead creates\n-    ///    landing pads even though there's no actual destructors\n-    ///  * freeing up stack space has no effect during unwinding\n-    /// Note that for generators we do emit StorageDeads, for the\n-    /// use of optimizations in the MIR generator transform.\n-    needs_cleanup: bool,\n-\n     /// set of places to drop when exiting this scope. This starts\n     /// out empty but grows as variables are declared during the\n     /// building process. This is a stack, so we always drop from the\n     /// end of the vector (top of the stack) first.\n     drops: Vec<DropData>,\n \n+    moved_locals: Vec<Local>,\n+\n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n     cached_exits: FxHashMap<(BasicBlock, region::Scope), BasicBlock>,\n \n@@ -172,7 +161,7 @@ struct CachedBlock {\n     generator_drop: Option<BasicBlock>,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq)]\n pub(crate) enum DropKind {\n     Value,\n     Storage,\n@@ -202,8 +191,7 @@ pub enum BreakableTarget {\n \n impl CachedBlock {\n     fn invalidate(&mut self) {\n-        self.generator_drop = None;\n-        self.unwind = None;\n+        *self = CachedBlock::default();\n     }\n \n     fn get(&self, generator_drop: bool) -> Option<BasicBlock> {\n@@ -261,6 +249,25 @@ impl Scope {\n             scope: self.source_scope\n         }\n     }\n+\n+\n+    /// Whether there's anything to do for the cleanup path, that is,\n+    /// when unwinding through this scope. This includes destructors,\n+    /// but not StorageDead statements, which don't get emitted at all\n+    /// for unwinding, for several reasons:\n+    ///  * clang doesn't emit llvm.lifetime.end for C++ unwinding\n+    ///  * LLVM's memory dependency analysis can't handle it atm\n+    ///  * polluting the cleanup MIR with StorageDead creates\n+    ///    landing pads even though there's no actual destructors\n+    ///  * freeing up stack space has no effect during unwinding\n+    /// Note that for generators we do emit StorageDeads, for the\n+    /// use of optimizations in the MIR generator transform.\n+    fn needs_cleanup(&self) -> bool {\n+        self.drops.iter().any(|drop| match drop.kind {\n+            DropKind::Value => true,\n+            DropKind::Storage => false,\n+        })\n+    }\n }\n \n impl<'tcx> Scopes<'tcx> {\n@@ -274,8 +281,8 @@ impl<'tcx> Scopes<'tcx> {\n             source_scope: vis_scope,\n             region_scope: region_scope.0,\n             region_scope_span: region_scope.1.span,\n-            needs_cleanup: false,\n             drops: vec![],\n+            moved_locals: vec![],\n             cached_generator_drop: None,\n             cached_exits: Default::default(),\n             cached_unwind: CachedBlock::default(),\n@@ -295,7 +302,7 @@ impl<'tcx> Scopes<'tcx> {\n \n     fn may_panic(&self, scope_count: usize) -> bool {\n         let len = self.len();\n-        self.scopes[(len - scope_count)..].iter().any(|s| s.needs_cleanup)\n+        self.scopes[(len - scope_count)..].iter().any(|s| s.needs_cleanup())\n     }\n \n     /// Finds the breakable scope for a given label. This is used for\n@@ -480,7 +487,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             block,\n             unwind_to,\n             self.arg_count,\n-            false,\n+            false, // not generator\n+            false, // not unwind path\n         ));\n \n         block.unit()\n@@ -572,7 +580,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block,\n                 unwind_to,\n                 self.arg_count,\n-                false,\n+                false, // not generator\n+                false, // not unwind path\n             ));\n \n             scope = next_scope;\n@@ -622,7 +631,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block,\n                 unwind_to,\n                 self.arg_count,\n-                true,\n+                true, // is generator\n+                true, // is cached path\n             ));\n         }\n \n@@ -801,10 +811,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // cache of outer scope stays intact.\n             scope.invalidate_cache(!needs_drop, self.is_generator, this_scope);\n             if this_scope {\n-                if let DropKind::Value = drop_kind {\n-                    scope.needs_cleanup = true;\n-                }\n-\n                 let region_scope_span = region_scope.span(self.hir.tcx(),\n                                                           &self.hir.region_scope_tree);\n                 // Attribute scope exit drops to scope's closing brace.\n@@ -822,6 +828,75 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span_bug!(span, \"region scope {:?} not in scope to drop {:?}\", region_scope, local);\n     }\n \n+    /// Indicates that the \"local operand\" stored in `local` is\n+    /// *moved* at some point during execution (see `local_scope` for\n+    /// more information about what a \"local operand\" is -- in short,\n+    /// it's an intermediate operand created as part of preparing some\n+    /// MIR instruction). We use this information to suppress\n+    /// redundant drops on the non-unwind paths. This results in less\n+    /// MIR, but also avoids spurious borrow check errors\n+    /// (c.f. #64391).\n+    ///\n+    /// Example: when compiling the call to `foo` here:\n+    ///\n+    /// ```rust\n+    /// foo(bar(), ...)\n+    /// ```\n+    ///\n+    /// we would evaluate `bar()` to an operand `_X`. We would also\n+    /// schedule `_X` to be dropped when the expression scope for\n+    /// `foo(bar())` is exited. This is relevant, for example, if the\n+    /// later arguments should unwind (it would ensure that `_X` gets\n+    /// dropped). However, if no unwind occurs, then `_X` will be\n+    /// unconditionally consumed by the `call`:\n+    ///\n+    /// ```\n+    /// bb {\n+    ///   ...\n+    ///   _R = CALL(foo, _X, ...)\n+    /// }\n+    /// ```\n+    ///\n+    /// However, `_X` is still registered to be dropped, and so if we\n+    /// do nothing else, we would generate a `DROP(_X)` that occurs\n+    /// after the call. This will later be optimized out by the\n+    /// drop-elaboation code, but in the meantime it can lead to\n+    /// spurious borrow-check errors -- the problem, ironically, is\n+    /// not the `DROP(_X)` itself, but the (spurious) unwind pathways\n+    /// that it creates. See #64391 for an example.\n+    pub fn record_operands_moved(\n+        &mut self,\n+        operands: &[Operand<'tcx>],\n+    ) {\n+        let scope = match self.local_scope() {\n+            None => {\n+                // if there is no local scope, operands won't be dropped anyway\n+                return;\n+            }\n+\n+            Some(local_scope) => {\n+                self.scopes.iter_mut().find(|scope| scope.region_scope == local_scope)\n+                    .unwrap_or_else(|| bug!(\"scope {:?} not found in scope list!\", local_scope))\n+            }\n+        };\n+\n+        // look for moves of a local variable, like `MOVE(_X)`\n+        let locals_moved = operands.iter().flat_map(|operand| match operand {\n+            Operand::Copy(_) | Operand::Constant(_) => None,\n+            Operand::Move(place) => place.as_local(),\n+        });\n+\n+        for local in locals_moved {\n+            // check if we have a Drop for this operand and -- if so\n+            // -- add it to the list of moved operands. Note that this\n+            // local might not have been an operand created for this\n+            // call, it could come from other places too.\n+            if scope.drops.iter().any(|drop| drop.local == local && drop.kind == DropKind::Value) {\n+                scope.moved_locals.push(local);\n+            }\n+        }\n+    }\n+\n     // Other\n     // =====\n     /// Branch based on a boolean condition.\n@@ -1020,6 +1095,7 @@ fn build_scope_drops<'tcx>(\n     last_unwind_to: BasicBlock,\n     arg_count: usize,\n     generator_drop: bool,\n+    is_cached_path: bool,\n ) -> BlockAnd<()> {\n     debug!(\"build_scope_drops({:?} -> {:?})\", block, scope);\n \n@@ -1046,8 +1122,17 @@ fn build_scope_drops<'tcx>(\n         let drop_data = &scope.drops[drop_idx];\n         let source_info = scope.source_info(drop_data.span);\n         let local = drop_data.local;\n+\n         match drop_data.kind {\n             DropKind::Value => {\n+                // If the operand has been moved, and we are not on an unwind\n+                // path, then don't generate the drop. (We only take this into\n+                // account for non-unwind paths so as not to disturb the\n+                // caching mechanism.)\n+                if !is_cached_path && scope.moved_locals.iter().any(|&o| o == local) {\n+                    continue;\n+                }\n+\n                 let unwind_to = get_unwind_to(scope, is_generator, drop_idx, generator_drop)\n                     .unwrap_or(last_unwind_to);\n "}, {"sha": "a7c307fdf894f760cf042eed69c04cf8434dc152", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "patch": "@@ -181,13 +181,34 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n \n         let scope = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n-        // Record the unadjusted type\n+        // If there are adjustments, then record the final type --\n+        // this is the actual value that is being produced.\n+        if let Some(adjusted_ty) = self.fcx.tables.borrow().expr_ty_adjusted_opt(expr) {\n+            self.record(adjusted_ty, scope, Some(expr), expr.span);\n+        }\n+\n+        // Also record the unadjusted type (which is the only type if\n+        // there are no adjustments). The reason for this is that the\n+        // unadjusted value is sometimes a \"temporary\" that would wind\n+        // up in a MIR temporary.\n+        //\n+        // As an example, consider an expression like `vec![].push()`.\n+        // Here, the `vec![]` would wind up MIR stored into a\n+        // temporary variable `t` which we can borrow to invoke\n+        // `<Vec<_>>::push(&mut t)`.\n+        //\n+        // Note that an expression can have many adjustments, and we\n+        // are just ignoring those intermediate types. This is because\n+        // those intermediate values are always linearly \"consumed\" by\n+        // the other adjustments, and hence would never be directly\n+        // captured in the MIR.\n+        //\n+        // (Note that this partly relies on the fact that the `Deref`\n+        // traits always return references, which means their content\n+        // can be reborrowed without needing to spill to a temporary.\n+        // If this were not the case, then we could conceivably have\n+        // to create intermediate temporaries.)\n         let ty = self.fcx.tables.borrow().expr_ty(expr);\n         self.record(ty, scope, Some(expr), expr.span);\n-\n-        // Also include the adjusted types, since these can result in MIR locals\n-        for adjustment in self.fcx.tables.borrow().expr_adjustments(expr) {\n-            self.record(adjustment.target, scope, Some(expr), expr.span);\n-        }\n     }\n }"}, {"sha": "8dc6b73edf6d473ecd804cdd314597fbdb86dcd9", "filename": "src/test/mir-opt/box_expr.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbox_expr.rs?ref=97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "patch": "@@ -57,25 +57,18 @@ impl Drop for S {\n //     }\n //\n //     bb5: {\n-//         drop(_4) -> [return: bb8, unwind: bb6];\n+//         StorageDead(_4);\n+//         StorageDead(_3);\n+//         _0 = ();\n+//         drop(_1) -> bb8;\n //     }\n-//\n //     bb6 (cleanup): {\n //         drop(_1) -> bb1;\n //     }\n-//\n //     bb7 (cleanup): {\n //         drop(_4) -> bb6;\n //     }\n-//\n //     bb8: {\n-//         StorageDead(_4);\n-//         StorageDead(_3);\n-//         _0 = ();\n-//         drop(_1) -> bb9;\n-//     }\n-//\n-//     bb9: {\n //         StorageDead(_1);\n //         return;\n //     }"}, {"sha": "109304d6d22ccdd4cb9368c12bbea673702e2f76", "filename": "src/test/mir-opt/generator-storage-dead-unwind.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs?ref=97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "patch": "@@ -57,7 +57,7 @@ fn main() {\n //     StorageLive(_6);\n //     StorageLive(_7);\n //     _7 = move _2;\n-//     _6 = const take::<Foo>(move _7) -> [return: bb9, unwind: bb8];\n+//     _6 = const take::<Foo>(move _7) -> [return: bb7, unwind: bb9];\n // }\n // bb3 (cleanup): {\n //     StorageDead(_2);\n@@ -75,24 +75,24 @@ fn main() {\n // bb6: {\n //     generator_drop;\n // }\n-// bb7 (cleanup): {\n-//     StorageDead(_3);\n-//     StorageDead(_2);\n-//     drop(_1) -> bb1;\n-// }\n-// bb8 (cleanup): {\n-//     StorageDead(_7);\n-//     StorageDead(_6);\n-//     goto -> bb7;\n-// }\n-// bb9: {\n+// bb7: {\n //     StorageDead(_7);\n //     StorageDead(_6);\n //     StorageLive(_8);\n //     StorageLive(_9);\n //     _9 = move _3;\n //     _8 = const take::<Bar>(move _9) -> [return: bb10, unwind: bb11];\n // }\n+// bb8 (cleanup): {\n+//     StorageDead(_3);\n+//     StorageDead(_2);\n+//     drop(_1) -> bb1;\n+// }\n+// bb9 (cleanup): {\n+//     StorageDead(_7);\n+//     StorageDead(_6);\n+//     goto -> bb8;\n+// }\n // bb10: {\n //     StorageDead(_9);\n //     StorageDead(_8);\n@@ -104,7 +104,7 @@ fn main() {\n // bb11 (cleanup): {\n //     StorageDead(_9);\n //     StorageDead(_8);\n-//     goto -> bb7;\n+//     goto -> bb8;\n // }\n // bb12: {\n //     return;"}, {"sha": "782bc31186ca5fb8eb8a4931bc077d8579e4d351", "filename": "src/test/mir-opt/no-spurious-drop-after-call.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Ftest%2Fmir-opt%2Fno-spurious-drop-after-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Ftest%2Fmir-opt%2Fno-spurious-drop-after-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fno-spurious-drop-after-call.rs?ref=97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "patch": "@@ -0,0 +1,24 @@\n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n+// Test that after the call to `std::mem::drop` we do not generate a\n+// MIR drop of the argument. (We used to have a `DROP(_2)` in the code\n+// below, as part of bb3.)\n+\n+fn main() {\n+    std::mem::drop(\"\".to_string());\n+}\n+\n+// END RUST SOURCE\n+// START rustc.main.ElaborateDrops.before.mir\n+//    bb2: {\n+//        StorageDead(_3);\n+//        _1 = const std::mem::drop::<std::string::String>(move _2) -> [return: bb3, unwind: bb4];\n+//    }\n+//    bb3: {\n+//        StorageDead(_2);\n+//        StorageDead(_4);\n+//        StorageDead(_1);\n+//        _0 = ();\n+//        return;\n+//    }\n+// END rustc.main.ElaborateDrops.before.mir"}, {"sha": "eef2c1fb20ab4ea97c8442829e5c2b59c11aa580", "filename": "src/test/ui/async-await/issues/issue-64391-2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64391-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64391-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64391-2.rs?ref=97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "patch": "@@ -0,0 +1,20 @@\n+// Regression test for #64391\n+//\n+// As described on the issue, the (spurious) `DROP` inserted for the\n+// `\"\".to_string()` value was causing a (spurious) unwind path that\n+// led us to believe that the future might be dropped after `config`\n+// had been dropped. This cannot, in fact, happen.\n+//\n+// check-pass\n+// edition:2018\n+\n+async fn connect() {\n+    let config = 666;\n+    connect2(&config, \"\".to_string()).await\n+}\n+\n+async fn connect2(_config: &u32, _tls: String) {\n+    unimplemented!()\n+}\n+\n+fn main() { }"}, {"sha": "802e09c8a1f00dc8db97cd7fdddcdcc0fbe8a8f0", "filename": "src/test/ui/async-await/issues/issue-64433.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64433.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64433.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64433.rs?ref=97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "patch": "@@ -0,0 +1,30 @@\n+// Regression test for issue #64433.\n+//\n+// See issue-64391-2.rs for more details, as that was fixed by the\n+// same PR.\n+//\n+// check-pass\n+// edition:2018\n+\n+#[derive(Debug)]\n+struct A<'a> {\n+    inner: Vec<&'a str>,\n+}\n+\n+struct B {}\n+\n+impl B {\n+    async fn something_with_a(&mut self, a: A<'_>) -> Result<(), String> {\n+        println!(\"{:?}\", a);\n+        Ok(())\n+    }\n+}\n+\n+async fn can_error(some_string: &str) -> Result<(), String> {\n+    let a = A { inner: vec![some_string, \"foo\"] };\n+    let mut b = B {};\n+    Ok(b.something_with_a(a).await.map(|_| ())?)\n+}\n+\n+fn main() {\n+}"}, {"sha": "5bd52d44a58279948b225db287ab4e1c772b31ad", "filename": "src/test/ui/async-await/issues/issue-64477.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64477.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e58c0d32bcb8730f8246d25f3d2fa8092b450a/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64477.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64477.rs?ref=97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "patch": "@@ -0,0 +1,20 @@\n+// Regression test for #64477.\n+//\n+// We were incorrectly claiming that the `f(x).await` future captured\n+// a value of type `T`, and hence that `T: Send` would have to hold.\n+//\n+// check-pass\n+// edition:2018\n+\n+use std::future::Future;\n+use std::pin::Pin;\n+\n+fn f<T>(_: &T) -> Pin<Box<dyn Future<Output = ()> + Send>> {\n+    unimplemented!()\n+}\n+\n+pub fn g<T: Sync>(x: &'static T) -> impl Future<Output = ()> + Send {\n+    async move { f(x).await }\n+}\n+\n+fn main() { }"}]}