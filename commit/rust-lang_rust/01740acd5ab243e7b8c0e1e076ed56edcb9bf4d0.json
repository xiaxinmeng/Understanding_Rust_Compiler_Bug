{"sha": "01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNzQwYWNkNWFiMjQzZTdiOGMwZTFlMDc2ZWQ1NmVkY2I5YmY0ZDA=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-07-01T05:42:30Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-10-29T16:09:19Z"}, "message": "Initial implementation of enum discrimnant sizing.\n\nAllows an enum with a discriminant to use any of the primitive integer\ntypes to store it.  By default the smallest usable type is chosen, but\nthis can be overridden with an attribute: `#[repr(int)]` etc., or\n`#[repr(C)]` to match the target's C ABI for the equivalent C enum.\n\nThis commit breaks a few things, due to transmutes that now no longer\nmatch in size, or u8 enums being passed to C that expects int, or\nreflection; later commits on this branch fix them.", "tree": {"sha": "2f6b6508ccef28be51058e8b8ea1736d3e04912c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f6b6508ccef28be51058e8b8ea1736d3e04912c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0", "html_url": "https://github.com/rust-lang/rust/commit/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1124a2f55406be8e758488352c59ae9deef17b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1124a2f55406be8e758488352c59ae9deef17b3", "html_url": "https://github.com/rust-lang/rust/commit/f1124a2f55406be8e758488352c59ae9deef17b3"}], "stats": {"total": 329, "additions": 252, "deletions": 77}, "files": [{"sha": "f1b280338aa5c8fdc53209d8810a1e8a4cfe5a9f", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 191, "deletions": 50, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0", "patch": "@@ -14,7 +14,8 @@\n  * This module determines how to represent enums, structs, and tuples\n  * based on their monomorphized types; it is responsible both for\n  * choosing a representation and translating basic operations on\n- * values of those types.\n+ * values of those types.  (Note: exporting the representations for\n+ * debuggers is handled in debuginfo.rs, not here.)\n  *\n  * Note that the interface treats everything as a general case of an\n  * enum, so structs/tuples/etc. have one pseudo-variant with\n@@ -29,8 +30,6 @@\n  *   that might contain one and adjust GEP indices accordingly.  See\n  *   issue #4578.\n  *\n- * - Using smaller integer types for discriminants.\n- *\n  * - Store nested enums' discriminants in the same word.  Rather, if\n  *   some variants start with enums, and those enums representations\n  *   have unused alignment padding between discriminant and body, the\n@@ -56,16 +55,21 @@ use middle::trans::machine;\n use middle::trans::type_of;\n use middle::ty;\n use middle::ty::Disr;\n+use syntax::abi::{X86, X86_64, Arm, Mips};\n use syntax::ast;\n+use syntax::attr;\n+use syntax::attr::IntType;\n use util::ppaux::ty_to_str;\n \n use middle::trans::type_::Type;\n \n+type Hint = attr::ReprAttr;\n+\n \n /// Representations.\n pub enum Repr {\n     /// C-like enums; basically an int.\n-    CEnum(Disr, Disr), // discriminant range\n+    CEnum(IntType, Disr, Disr), // discriminant range (signedness based on the IntType)\n     /**\n      * Single-case variants, and structs/tuples/records.\n      *\n@@ -78,7 +82,7 @@ pub enum Repr {\n      * General-case enums: for each case there is a struct, and they\n      * all start with a field for the discriminant.\n      */\n-    General(~[Struct]),\n+    General(IntType, ~[Struct]),\n     /**\n      * Two cases distinguished by a nullable pointer: the case with discriminant\n      * `nndiscr` is represented by the struct `nonnull`, where the `ptrfield`th\n@@ -166,11 +170,19 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             if cases.iter().all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n                 let discrs = cases.map(|c| c.discr);\n-                return CEnum(*discrs.iter().min().unwrap(), *discrs.iter().max().unwrap());\n+                let hint = ty::lookup_repr_hint(cx.tcx, def_id);\n+                let bounds = IntBounds {\n+                    ulo: *discrs.iter().min().unwrap(),\n+                    uhi: *discrs.iter().max().unwrap(),\n+                    slo: discrs.iter().map(|n| *n as i64).min().unwrap(),\n+                    shi: discrs.iter().map(|n| *n as i64).max().unwrap()\n+                };\n+                return mk_cenum(cx, hint, &bounds);\n             }\n \n             if cases.len() == 1 {\n                 // Equivalent to a struct/tuple/newtype.\n+                // FIXME: should this conflict with a discriminant size hint?\n                 assert_eq!(cases[0].discr, 0);\n                 return Univariant(mk_struct(cx, cases[0].tys, false), false)\n             }\n@@ -185,6 +197,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             }\n \n             if cases.len() == 2 {\n+                // FIXME: disable if size hint present?\n                 let mut discr = 0;\n                 while discr < 2 {\n                     if cases[1 - discr].is_zerolen(cx) {\n@@ -207,8 +220,13 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             }\n \n             // The general case.\n-            let discr = ~[ty::mk_uint()];\n-            return General(cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n+            let hint = ty::lookup_repr_hint(cx.tcx, def_id);\n+            assert!((cases.len() - 1) as i64 >= 0);\n+            let bounds = IntBounds { ulo: 0, uhi: (cases.len() - 1) as u64,\n+                                     slo: 0, shi: (cases.len() - 1) as i64 };\n+            let ity = range_to_inttype(cx, hint, &bounds);\n+            let discr = ~[ty_of_inttype(ity)];\n+            return General(ity, cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n         }\n         _ => cx.sess.bug(\"adt::represent_type called on non-ADT type\")\n     }\n@@ -225,6 +243,93 @@ fn mk_struct(cx: &mut CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     }\n }\n \n+struct IntBounds {\n+    slo: i64,\n+    shi: i64,\n+    ulo: u64,\n+    uhi: u64\n+}\n+\n+fn mk_cenum(cx: &mut CrateContext, hint: Hint, bounds: &IntBounds) -> Repr {\n+    let it = range_to_inttype(cx, hint, bounds);\n+    match it {\n+        attr::SignedInt(_) => CEnum(it, bounds.slo as Disr, bounds.shi as Disr),\n+        attr::UnsignedInt(_) => CEnum(it, bounds.ulo, bounds.uhi)\n+    }\n+}\n+\n+fn range_to_inttype(cx: &mut CrateContext, hint: Hint, bounds: &IntBounds) -> IntType {\n+    debug!(\"range_to_inttype: {:?} {:?}\", hint, bounds);\n+    // Lists of sizes to try.  u64 is always allowed as a fallback.\n+    static choose_shortest: &'static[IntType] = &[\n+        attr::UnsignedInt(ast::ty_u8), attr::SignedInt(ast::ty_i8),\n+        attr::UnsignedInt(ast::ty_u16), attr::SignedInt(ast::ty_i16),\n+        attr::UnsignedInt(ast::ty_u32), attr::SignedInt(ast::ty_i32)];\n+    static at_least_32: &'static[IntType] = &[\n+        attr::UnsignedInt(ast::ty_u32), attr::SignedInt(ast::ty_i32)];\n+\n+    let attempts;\n+    match hint {\n+        attr::ReprInt(span, ity) => {\n+            if !bounds_usable(cx, ity, bounds) {\n+                cx.sess.span_err(span, \"representation hint insufficient for discriminant range\")\n+            }\n+            return ity;\n+        }\n+        attr::ReprExtern => {\n+            attempts = match cx.sess.targ_cfg.arch {\n+                X86 | X86_64 => at_least_32,\n+                // WARNING: the ARM EABI has two variants; the one corresponding to `at_least_32`\n+                // appears to be used on Linux and NetBSD, but some systems may use the variant\n+                // corresponding to `choose_shortest`.  However, we don't run on those yet...?\n+                Arm => at_least_32,\n+                Mips => at_least_32,\n+            }\n+        }\n+        attr::ReprAny => {\n+            attempts = choose_shortest;\n+        }\n+    }\n+    let mut best = attr::UnsignedInt(ast::ty_u64);\n+    for &ity in attempts.iter() {\n+        if bounds_usable(cx, ity, bounds) {\n+            best = ity;\n+            break;\n+        }\n+    }\n+    return best;\n+}\n+\n+pub fn ll_inttype(cx: &mut CrateContext, ity: IntType) -> Type {\n+    match ity {\n+        attr::SignedInt(t) => Type::int_from_ty(cx, t),\n+        attr::UnsignedInt(t) => Type::uint_from_ty(cx, t)\n+    }\n+}\n+\n+fn bounds_usable(cx: &mut CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n+    debug!(\"bounds_usable: {:?} {:?}\", ity, bounds);\n+    match ity {\n+        attr::SignedInt(_) => {\n+            let lllo = C_integral(ll_inttype(cx, ity), bounds.slo as u64, true);\n+            let llhi = C_integral(ll_inttype(cx, ity), bounds.shi as u64, true);\n+            bounds.slo == const_to_int(lllo) as i64 && bounds.shi == const_to_int(llhi) as i64\n+        }\n+        attr::UnsignedInt(_) => {\n+            let lllo = C_integral(ll_inttype(cx, ity), bounds.ulo, false);\n+            let llhi = C_integral(ll_inttype(cx, ity), bounds.uhi, false);\n+            bounds.ulo == const_to_uint(lllo) as u64 && bounds.uhi == const_to_uint(llhi) as u64\n+        }\n+    }\n+}\n+\n+fn ty_of_inttype(ity: IntType) -> ty::t {\n+    match ity {\n+        attr::SignedInt(t) => ty::mk_mach_int(t),\n+        attr::UnsignedInt(t) => ty::mk_mach_uint(t)\n+    }\n+}\n+\n /**\n  * Returns the fields of a struct for the given representation.\n  * All nominal types are LLVM structs, in order to be able to use\n@@ -239,10 +344,10 @@ pub fn sizing_fields_of(cx: &mut CrateContext, r: &Repr) -> ~[Type] {\n }\n fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n     match *r {\n-        CEnum(*) => ~[Type::enum_discrim(cx)],\n+        CEnum(ity, _, _) => ~[ll_inttype(cx, ity)],\n         Univariant(ref st, _dtor) => struct_llfields(cx, st, sizing),\n         NullablePointer{ nonnull: ref st, _ } => struct_llfields(cx, st, sizing),\n-        General(ref sts) => {\n+        General(_ity, ref sts) => {\n             // To get \"the\" type of a general enum, we pick the case\n             // with the largest alignment (so it will always align\n             // correctly in containing structures) and pad it out.\n@@ -288,7 +393,7 @@ pub fn trans_switch(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n     -> (_match::branch_kind, Option<ValueRef>) {\n     match *r {\n         CEnum(*) | General(*) => {\n-            (_match::switch, Some(trans_get_discr(bcx, r, scrutinee)))\n+            (_match::switch, Some(trans_get_discr(bcx, r, scrutinee, None)))\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             (_match::switch, Some(nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee)))\n@@ -302,17 +407,32 @@ pub fn trans_switch(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n \n \n /// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n+pub fn trans_get_discr(bcx: @mut Block, r: &Repr, scrutinee: ValueRef, cast_to: Option<Type>)\n     -> ValueRef {\n+    let signed;\n+    let val;\n     match *r {\n-        CEnum(min, max) => load_discr(bcx, scrutinee, min, max),\n-        Univariant(*) => C_disr(bcx.ccx(), 0),\n-        General(ref cases) => load_discr(bcx, scrutinee, 0, (cases.len() - 1) as Disr),\n+        CEnum(ity, min, max) => {\n+            val = load_discr(bcx, ity, scrutinee, min, max);\n+            signed = ity.is_signed();\n+        }\n+        General(ity, ref cases) => {\n+            val = load_discr(bcx, ity, scrutinee, 0, (cases.len() - 1) as Disr);\n+            signed = ity.is_signed();\n+        }\n+        Univariant(*) => {\n+            val = C_u8(0);\n+            signed = false;\n+        }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n-            ZExt(bcx, nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee),\n-                 Type::enum_discrim(bcx.ccx()))\n+            val = nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee);\n+            signed = false;\n         }\n     }\n+    match cast_to {\n+        None => val,\n+        Some(llty) => if signed { SExt(bcx, val, llty) } else { ZExt(bcx, val, llty) }\n+    }\n }\n \n fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n@@ -324,10 +444,15 @@ fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: Disr, ptrfield:\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: @mut Block, scrutinee: ValueRef, min: Disr, max: Disr)\n+fn load_discr(bcx: @mut Block, ity: IntType, scrutinee: ValueRef, min: Disr, max: Disr)\n     -> ValueRef {\n     let ptr = GEPi(bcx, scrutinee, [0, 0]);\n-    if max + 1 == min {\n+    let llty = ll_inttype(bcx.ccx(), ity);\n+    assert_eq!(val_ty(ptr), llty.ptr_to());\n+    let bits = machine::llbitsize_of_real(bcx.ccx(), llty);\n+    assert!(bits <= 64);\n+    let mask = (-1u64 >> (64 - bits)) as Disr;\n+    if (max + 1) & mask == min & mask {\n         // i.e., if the range is everything.  The lo==hi case would be\n         // rejected by the LLVM verifier (it would mean either an\n         // empty set, which is impossible, or the entire range of the\n@@ -350,15 +475,17 @@ fn load_discr(bcx: @mut Block, scrutinee: ValueRef, min: Disr, max: Disr)\n  */\n pub fn trans_case(bcx: @mut Block, r: &Repr, discr: Disr) -> _match::opt_result {\n     match *r {\n-        CEnum(*) => {\n-            _match::single_result(rslt(bcx, C_disr(bcx.ccx(), discr)))\n+        CEnum(ity, _, _) => {\n+            _match::single_result(rslt(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n+                                                       discr as u64, true)))\n+        }\n+        General(ity, _) => {\n+            _match::single_result(rslt(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n+                                                       discr as u64, true)))\n         }\n         Univariant(*) => {\n             bcx.ccx().sess.bug(\"no cases for univariants or structs\")\n         }\n-        General(*) => {\n-            _match::single_result(rslt(bcx, C_disr(bcx.ccx(), discr)))\n-        }\n         NullablePointer{ _ } => {\n             assert!(discr == 0 || discr == 1);\n             _match::single_result(rslt(bcx, C_i1(discr != 0)))\n@@ -373,9 +500,14 @@ pub fn trans_case(bcx: @mut Block, r: &Repr, discr: Disr) -> _match::opt_result\n  */\n pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr) {\n     match *r {\n-        CEnum(min, max) => {\n-            assert!(min <= discr && discr <= max);\n-            Store(bcx, C_disr(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n+        CEnum(ity, min, max) => {\n+            assert_discr_in_range(ity, min, max, discr);\n+            Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n+                  GEPi(bcx, val, [0, 0]))\n+        }\n+        General(ity, _) => {\n+            Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n+                  GEPi(bcx, val, [0, 0]))\n         }\n         Univariant(ref st, true) => {\n             assert_eq!(discr, 0);\n@@ -385,9 +517,6 @@ pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr) {\n         Univariant(*) => {\n             assert_eq!(discr, 0);\n         }\n-        General(*) => {\n-            Store(bcx, C_disr(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n-        }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             if discr != nndiscr {\n                 let llptrptr = GEPi(bcx, val, [0, ptrfield]);\n@@ -398,6 +527,13 @@ pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr) {\n     }\n }\n \n+fn assert_discr_in_range(ity: IntType, min: Disr, max: Disr, discr: Disr) {\n+    match ity {\n+        attr::UnsignedInt(_) => assert!(min <= discr && discr <= max),\n+        attr::SignedInt(_) => assert!(min as i64 <= discr as i64 && discr as i64 <= max as i64)\n+    }\n+}\n+\n /**\n  * The number of fields in a given case; for use when obtaining this\n  * information from the type or definition is less convenient.\n@@ -409,7 +545,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n             assert_eq!(discr, 0);\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n-        General(ref cases) => cases[discr].fields.len() - 1,\n+        General(_, ref cases) => cases[discr].fields.len() - 1,\n         NullablePointer{ nonnull: ref nonnull, nndiscr, nullfields: ref nullfields, _ } => {\n             if discr == nndiscr { nonnull.fields.len() } else { nullfields.len() }\n         }\n@@ -430,7 +566,7 @@ pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr,\n             assert_eq!(discr, 0);\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n-        General(ref cases) => {\n+        General(_, ref cases) => {\n             struct_field_ptr(bcx, &cases[discr], val, ix + 1, true)\n         }\n         NullablePointer{ nonnull: ref nonnull, nullfields: ref nullfields, nndiscr, _ } => {\n@@ -498,24 +634,23 @@ pub fn trans_drop_flag_ptr(bcx: @mut Block, r: &Repr, val: ValueRef) -> ValueRef\n pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: Disr,\n                    vals: &[ValueRef]) -> ValueRef {\n     match *r {\n-        CEnum(min, max) => {\n+        CEnum(ity, min, max) => {\n             assert_eq!(vals.len(), 0);\n-            assert!(min <= discr && discr <= max);\n-            C_disr(ccx, discr)\n-        }\n-        Univariant(ref st, _dro) => {\n-            assert_eq!(discr, 0);\n-            let contents = build_const_struct(ccx, st, vals);\n-            C_struct(contents, st.packed)\n+            assert_discr_in_range(ity, min, max, discr);\n+            C_integral(ll_inttype(ccx, ity), discr as u64, true)\n         }\n-        General(ref cases) => {\n+        General(ity, ref cases) => {\n             let case = &cases[discr];\n             let max_sz = cases.iter().map(|x| x.size).max().unwrap();\n-            let discr_ty = C_disr(ccx, discr);\n-            let contents = build_const_struct(ccx, case,\n-                                              ~[discr_ty] + vals);\n+            let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n+            let contents = build_const_struct(ccx, case, ~[lldiscr] + vals);\n             C_struct(contents + &[padding(max_sz - case.size)], false)\n         }\n+        Univariant(ref st, _dro) => {\n+            assert!(discr == 0);\n+            let contents = build_const_struct(ccx, st, vals);\n+            C_struct(contents, st.packed)\n+        }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             if discr == nndiscr {\n                 C_struct(build_const_struct(ccx, nonnull, vals), false)\n@@ -585,9 +720,19 @@ fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n     -> Disr {\n     match *r {\n-        CEnum(*) => const_to_uint(val) as Disr,\n+        CEnum(ity, _, _) => {\n+            match ity {\n+                attr::SignedInt(*) => const_to_int(val) as Disr,\n+                attr::UnsignedInt(*) => const_to_uint(val) as Disr\n+            }\n+        }\n+        General(ity, _) => {\n+            match ity {\n+                attr::SignedInt(*) => const_to_int(const_get_elt(ccx, val, [0])) as Disr,\n+                attr::UnsignedInt(*) => const_to_uint(const_get_elt(ccx, val, [0])) as Disr\n+            }\n+        }\n         Univariant(*) => 0,\n-        General(*) => const_to_uint(const_get_elt(ccx, val, [0])) as Disr,\n         NullablePointer{ nndiscr, ptrfield, _ } => {\n             if is_null(const_struct_field(ccx, val, ptrfield)) {\n                 /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n@@ -646,7 +791,3 @@ pub fn is_newtypeish(r: &Repr) -> bool {\n         _ => false\n     }\n }\n-\n-fn C_disr(cx: &CrateContext, i: Disr) -> ValueRef {\n-    return C_integral(cx.int_type, i, false);\n-}"}, {"sha": "616af475609a28816f6331ff32843cdff71c3b66", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0", "patch": "@@ -109,6 +109,7 @@ use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n use std::unstable::atomics;\n use std::vec;\n+use syntax::attr;\n use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap, ast_util, ast_map, opt_vec};\n use syntax::parse::token;\n@@ -1250,7 +1251,7 @@ impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n                                   -> ~[MemberDescription] {\n         // Capture type_rep, so we don't have to copy the struct_defs array\n         let struct_defs = match *self.type_rep {\n-            adt::General(ref struct_defs) => struct_defs,\n+            adt::General(_, ref struct_defs) => struct_defs,\n             _ => cx.sess.bug(\"unreachable\")\n         };\n \n@@ -1399,14 +1400,6 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n         return FinalMetadata(empty_type_metadata);\n     }\n \n-    // Prepare some data (llvm type, size, align, etc) about the discriminant. This data will be\n-    // needed in all of the following cases.\n-    let discriminant_llvm_type = Type::enum_discrim(cx);\n-    let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n-\n-    assert!(Type::enum_discrim(cx) == cx.int_type);\n-    let discriminant_base_type_metadata = type_metadata(cx, ty::mk_int(), codemap::dummy_sp());\n-\n     let variants = ty::enum_variants(cx.tcx, enum_def_id);\n \n     let enumerators_metadata: ~[DIDescriptor] = variants\n@@ -1426,26 +1419,34 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n         })\n         .collect();\n \n-    let discriminant_type_metadata = do enum_name.with_c_str |enum_name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateEnumerationType(\n-                DIB(cx),\n-                containing_scope,\n-                enum_name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                bytes_to_bits(discriminant_size),\n-                bytes_to_bits(discriminant_align),\n-                create_DIArray(DIB(cx), enumerators_metadata),\n-                discriminant_base_type_metadata)\n+    let discriminant_type_metadata = |inttype| {\n+        let discriminant_llvm_type = adt::ll_inttype(cx, inttype);\n+        let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n+        let discriminant_base_type_metadata = type_metadata(cx, match inttype {\n+            attr::SignedInt(t) => ty::mk_mach_int(t),\n+            attr::UnsignedInt(t) => ty::mk_mach_uint(t)\n+        }, codemap::dummy_sp());\n+        do enum_name.with_c_str |enum_name| {\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateEnumerationType(\n+                    DIB(cx),\n+                    containing_scope,\n+                    enum_name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    bytes_to_bits(discriminant_size),\n+                    bytes_to_bits(discriminant_align),\n+                    create_DIArray(DIB(cx), enumerators_metadata),\n+                    discriminant_base_type_metadata)\n+            }\n         }\n     };\n \n     let type_rep = adt::represent_type(cx, enum_type);\n \n     return match *type_rep {\n-        adt::CEnum(*) => {\n-            FinalMetadata(discriminant_type_metadata)\n+        adt::CEnum(inttype, _, _) => {\n+            FinalMetadata(discriminant_type_metadata(inttype))\n         }\n         adt::Univariant(ref struct_def, _) => {\n             assert!(variants.len() == 1);\n@@ -1466,7 +1467,8 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n                 member_description_factory: member_description_factory\n             }\n         }\n-        adt::General(_) => {\n+        adt::General(inttype, _) => {\n+            let discriminant_type_metadata = discriminant_type_metadata(inttype);\n             let enum_llvm_type = type_of::type_of(cx, enum_type);\n             let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n "}, {"sha": "e1de66152069d28b7dc2be6963b94cacf35590f8", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0", "patch": "@@ -1728,7 +1728,7 @@ fn trans_imm_cast(bcx: @mut Block, expr: &ast::Expr,\n                 let repr = adt::represent_type(ccx, t_in);\n                 let slot = Alloca(bcx, ll_t_in, \"\");\n                 Store(bcx, llexpr, slot);\n-                let lldiscrim_a = adt::trans_get_discr(bcx, repr, slot);\n+                let lldiscrim_a = adt::trans_get_discr(bcx, repr, slot, Some(Type::i64()));\n                 match k_out {\n                     cast_integral => int_cast(bcx, ll_t_out,\n                                               val_ty(lldiscrim_a),"}, {"sha": "1b27e06dca83708fd4057ceb1a8940ee57d7fda8", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0", "patch": "@@ -25,7 +25,7 @@ use middle::ty;\n use util::ppaux::ty_to_str;\n \n use std::libc::c_uint;\n-use std::option::None;\n+use std::option::{Some,None};\n use std::vec;\n use syntax::ast::DefId;\n use syntax::ast;\n@@ -308,7 +308,7 @@ impl Reflector {\n                 };\n                 let mut bcx = fcx.entry_bcx.unwrap();\n                 let arg = BitCast(bcx, arg, llptrty);\n-                let ret = adt::trans_get_discr(bcx, repr, arg);\n+                let ret = adt::trans_get_discr(bcx, repr, arg, Some(ccx.int_type));\n                 Store(bcx, ret, fcx.llretptr.unwrap());\n                 match fcx.llreturn {\n                     Some(llreturn) => cleanup_and_Br(bcx, bcx, llreturn),"}, {"sha": "a9fc13437abb49365c0569ba5b037f72842936b6", "filename": "src/test/run-pass/small-enum-range-edge.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs?ref=01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Tests the range assertion wraparound case in trans::middle::adt::load_discr.\n+ */\n+\n+#[repr(u8)]\n+enum Eu { Lu = 0, Hu = 255 }\n+static CLu: Eu = Lu;\n+static CHu: Eu = Hu;\n+\n+#[repr(i8)]\n+enum Es { Ls = -128, Hs = 127 }\n+static CLs: Es = Ls;\n+static CHs: Es = Hs;\n+\n+pub fn main() {\n+    assert_eq!((Hu as u8) + 1, Lu as u8);\n+    assert_eq!((Hs as i8) + 1, Ls as i8);\n+    assert_eq!(CLu as u8, Lu as u8);\n+    assert_eq!(CHu as u8, Hu as u8);\n+    assert_eq!(CLs as i8, Ls as i8);\n+    assert_eq!(CHs as i8, Hs as i8);\n+}"}]}