{"sha": "3e5800b8d30fba923c5070ae660c1e45a630a191", "node_id": "C_kwDOAAsO6NoAKDNlNTgwMGI4ZDMwZmJhOTIzYzUwNzBhZTY2MGMxZTQ1YTYzMGExOTE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-06-20T18:13:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-20T18:13:10Z"}, "message": "Rollup merge of #98267 - compiler-errors:suggest-wildcard-arm, r=oli-obk\n\nDon't omit comma when suggesting wildcard arm after macro expr\n\n* Also adds `Span::eq_ctxt` to consolidate the various usages of `span.ctxt() == other.ctxt()`\n* Also fixes an unhygenic usage of spans which caused the suggestion to render weirdly when we had one arm match in a macro\n* Also always suggests a comma (i.e. even after a block) if we're rendering a wildcard arm in a single-line match (looks prettier :rose:)\n\nFixes #94866", "tree": {"sha": "c04a5a66a82364242edac321dd0d88ccfd92eca1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c04a5a66a82364242edac321dd0d88ccfd92eca1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e5800b8d30fba923c5070ae660c1e45a630a191", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJisLi2CRBK7hj4Ov3rIwAA1WwIAGGPK0Nmynyz+YdlsewMCxa/\nBUQbq5crtf1+fTbv2Ypd4P53Yksn+GJglbl0K4Hr5PPWPsldlGu23dmC9mLzTCb+\neAjNp0tHeIFiqOgRkyHIR1QE6o6LseE6vV4NmXBvwfZLTNoAYgI6P+WyLXJ1tgqw\nFcef3FI1CuLjYeakKteguS1pXvErmdA6SELZCq5tPvytx1iMe8PK56ktd7oyhMyF\naHXRbDz+L1NAHAGCIiL6jg8AzUKpeOYS96GNtAllZFe8Qi4L2/uGwGI/nLjTUwfM\nJsR4W3j2+XImvUYxrbrzoeNqGw9NZsl9nicP0+u/hlaXZAdARvs9ZAPgyTBhEfY=\n=N1ut\n-----END PGP SIGNATURE-----\n", "payload": "tree c04a5a66a82364242edac321dd0d88ccfd92eca1\nparent eac149368b9a681ad80fe642e4205760eb1aa93f\nparent 3d16c22864087c1ff765ffa60153368226f33968\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1655748790 +0200\ncommitter GitHub <noreply@github.com> 1655748790 +0200\n\nRollup merge of #98267 - compiler-errors:suggest-wildcard-arm, r=oli-obk\n\nDon't omit comma when suggesting wildcard arm after macro expr\n\n* Also adds `Span::eq_ctxt` to consolidate the various usages of `span.ctxt() == other.ctxt()`\n* Also fixes an unhygenic usage of spans which caused the suggestion to render weirdly when we had one arm match in a macro\n* Also always suggests a comma (i.e. even after a block) if we're rendering a wildcard arm in a single-line match (looks prettier :rose:)\n\nFixes #94866\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e5800b8d30fba923c5070ae660c1e45a630a191", "html_url": "https://github.com/rust-lang/rust/commit/3e5800b8d30fba923c5070ae660c1e45a630a191", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e5800b8d30fba923c5070ae660c1e45a630a191/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eac149368b9a681ad80fe642e4205760eb1aa93f", "url": "https://api.github.com/repos/rust-lang/rust/commits/eac149368b9a681ad80fe642e4205760eb1aa93f", "html_url": "https://github.com/rust-lang/rust/commit/eac149368b9a681ad80fe642e4205760eb1aa93f"}, {"sha": "3d16c22864087c1ff765ffa60153368226f33968", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d16c22864087c1ff765ffa60153368226f33968", "html_url": "https://github.com/rust-lang/rust/commit/3d16c22864087c1ff765ffa60153368226f33968"}], "stats": {"total": 518, "additions": 241, "deletions": 277}, "files": [{"sha": "4418b848e512a638d1b913e6e21a01c973a4c3a5", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e5800b8d30fba923c5070ae660c1e45a630a191/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5800b8d30fba923c5070ae660c1e45a630a191/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=3e5800b8d30fba923c5070ae660c1e45a630a191", "patch": "@@ -667,7 +667,7 @@ fn trim_span_hi(span: Span, to_pos: BytePos) -> Span {\n fn fn_span<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Span {\n     let fn_decl_span = tcx.def_span(def_id);\n     if let Some(body_span) = hir_body(tcx, def_id).map(|hir_body| hir_body.value.span) {\n-        if fn_decl_span.ctxt() == body_span.ctxt() { fn_decl_span.to(body_span) } else { body_span }\n+        if fn_decl_span.eq_ctxt(body_span) { fn_decl_span.to(body_span) } else { body_span }\n     } else {\n         fn_decl_span\n     }"}, {"sha": "76333b755b747d540a1ad3d526070ac92b368613", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3e5800b8d30fba923c5070ae660c1e45a630a191/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5800b8d30fba923c5070ae660c1e45a630a191/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=3e5800b8d30fba923c5070ae660c1e45a630a191", "patch": "@@ -803,7 +803,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     let mut suggestion = None;\n     let sm = cx.tcx.sess.source_map();\n     match arms {\n-        [] if sp.ctxt() == expr_span.ctxt() => {\n+        [] if sp.eq_ctxt(expr_span) => {\n             // Get the span for the empty match body `{}`.\n             let (indentation, more) = if let Some(snippet) = sm.indentation_before(sp) {\n                 (format!(\"\\n{}\", snippet), \"    \")\n@@ -821,24 +821,36 @@ fn non_exhaustive_match<'p, 'tcx>(\n             ));\n         }\n         [only] => {\n-            let pre_indentation = if let (Some(snippet), true) = (\n-                sm.indentation_before(only.span),\n-                sm.is_multiline(sp.shrink_to_hi().with_hi(only.span.lo())),\n-            ) {\n-                format!(\"\\n{}\", snippet)\n+            let (pre_indentation, is_multiline) = if let Some(snippet) = sm.indentation_before(only.span)\n+                && let Ok(with_trailing) = sm.span_extend_while(only.span, |c| c.is_whitespace() || c == ',')\n+                && sm.is_multiline(with_trailing)\n+            {\n+                (format!(\"\\n{}\", snippet), true)\n+            } else {\n+                (\" \".to_string(), false)\n+            };\n+            let comma = if matches!(only.body.kind, hir::ExprKind::Block(..))\n+                && only.span.eq_ctxt(only.body.span)\n+                && is_multiline\n+            {\n+                \"\"\n             } else {\n-                \" \".to_string()\n+                \",\"\n             };\n-            let comma = if matches!(only.body.kind, hir::ExprKind::Block(..)) { \"\" } else { \",\" };\n             suggestion = Some((\n                 only.span.shrink_to_hi(),\n                 format!(\"{}{}{} => todo!()\", comma, pre_indentation, pattern),\n             ));\n         }\n-        [.., prev, last] if prev.span.ctxt() == last.span.ctxt() => {\n+        [.., prev, last] if prev.span.eq_ctxt(last.span) => {\n             if let Ok(snippet) = sm.span_to_snippet(prev.span.between(last.span)) {\n-                let comma =\n-                    if matches!(last.body.kind, hir::ExprKind::Block(..)) { \"\" } else { \",\" };\n+                let comma = if matches!(last.body.kind, hir::ExprKind::Block(..))\n+                    && last.span.eq_ctxt(last.body.span)\n+                {\n+                    \"\"\n+                } else {\n+                    \",\"\n+                };\n                 suggestion = Some((\n                     last.span.shrink_to_hi(),\n                     format!("}, {"sha": "782b620e28fe048c775c3cd82581414d59285424", "filename": "compiler/rustc_mir_transform/src/coverage/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e5800b8d30fba923c5070ae660c1e45a630a191/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5800b8d30fba923c5070ae660c1e45a630a191/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs?ref=3e5800b8d30fba923c5070ae660c1e45a630a191", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n \n         let source_file = source_map.lookup_source_file(body_span.lo());\n         let fn_sig_span = match some_fn_sig.filter(|fn_sig| {\n-            fn_sig.span.ctxt() == body_span.ctxt()\n+            fn_sig.span.eq_ctxt(body_span)\n                 && Lrc::ptr_eq(&source_file, &source_map.lookup_source_file(fn_sig.span.lo()))\n         }) {\n             Some(fn_sig) => fn_sig.span.with_hi(body_span.lo()),"}, {"sha": "82070b903256c05ad182fcfb559062049e379035", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e5800b8d30fba923c5070ae660c1e45a630a191/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5800b8d30fba923c5070ae660c1e45a630a191/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=3e5800b8d30fba923c5070ae660c1e45a630a191", "patch": "@@ -195,7 +195,7 @@ impl CoverageSpan {\n             .expn_span\n             .parent_callsite()\n             .unwrap_or_else(|| bug!(\"macro must have a parent\"))\n-            .ctxt() == body_span.ctxt()\n+            .eq_ctxt(body_span)\n         {\n             return Some(current_macro);\n         }"}, {"sha": "7d2b7de17bf9c9c9047cc3055a44f1afa546b93d", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e5800b8d30fba923c5070ae660c1e45a630a191/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5800b8d30fba923c5070ae660c1e45a630a191/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=3e5800b8d30fba923c5070ae660c1e45a630a191", "patch": "@@ -1894,7 +1894,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         let names = rib\n             .bindings\n             .iter()\n-            .filter(|(id, _)| id.span.ctxt() == label.span.ctxt())\n+            .filter(|(id, _)| id.span.eq_ctxt(label.span))\n             .map(|(id, _)| id.name)\n             .collect::<Vec<Symbol>>();\n "}, {"sha": "a329fa153207bbf7e208b5313c86133b70629254", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e5800b8d30fba923c5070ae660c1e45a630a191/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5800b8d30fba923c5070ae660c1e45a630a191/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=3e5800b8d30fba923c5070ae660c1e45a630a191", "patch": "@@ -537,6 +537,9 @@ impl Span {\n     pub fn ctxt(self) -> SyntaxContext {\n         self.data_untracked().ctxt\n     }\n+    pub fn eq_ctxt(self, other: Span) -> bool {\n+        self.data_untracked().ctxt == other.data_untracked().ctxt\n+    }\n     #[inline]\n     pub fn with_ctxt(self, ctxt: SyntaxContext) -> Span {\n         self.data_untracked().with_ctxt(ctxt)"}, {"sha": "2566cd791997aacfaf72beff5ad139b480acbf4b", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e5800b8d30fba923c5070ae660c1e45a630a191/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5800b8d30fba923c5070ae660c1e45a630a191/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=3e5800b8d30fba923c5070ae660c1e45a630a191", "patch": "@@ -1641,7 +1641,7 @@ impl Ident {\n \n impl PartialEq for Ident {\n     fn eq(&self, rhs: &Self) -> bool {\n-        self.name == rhs.name && self.span.ctxt() == rhs.span.ctxt()\n+        self.name == rhs.name && self.span.eq_ctxt(rhs.span)\n     }\n }\n "}, {"sha": "d429b4e8effbff3a5cb80f5b6c553487b3184c42", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-exhaustive-fail.stderr", "status": "modified", "additions": 136, "deletions": 204, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/3e5800b8d30fba923c5070ae660c1e45a630a191/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e5800b8d30fba923c5070ae660c1e45a630a191/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr?ref=3e5800b8d30fba923c5070ae660c1e45a630a191", "patch": "@@ -7,9 +7,8 @@ LL |     m!(0f32, f32::NEG_INFINITY..);\n    = note: the matched value is of type `f32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:17:8\n@@ -20,9 +19,8 @@ LL |     m!(0f32, ..f32::INFINITY);\n    = note: the matched value is of type `f32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `'\\u{10ffff}'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:26:8\n@@ -33,9 +31,8 @@ LL |     m!('a', ..core::char::MAX);\n    = note: the matched value is of type `char`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         '\\u{10ffff}' => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, '\\u{10ffff}' => todo!() }\n+   |                                +++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `'\\u{10fffe}'..='\\u{10ffff}'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:27:8\n@@ -46,9 +43,8 @@ LL |     m!('a', ..ALMOST_MAX);\n    = note: the matched value is of type `char`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         '\\u{10fffe}'..='\\u{10ffff}' => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, '\\u{10fffe}'..='\\u{10ffff}' => todo!() }\n+   |                                ++++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `'\\0'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:28:8\n@@ -59,9 +55,8 @@ LL |     m!('a', ALMOST_MIN..);\n    = note: the matched value is of type `char`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         '\\0' => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, '\\0' => todo!() }\n+   |                                +++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `'\\u{10ffff}'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:29:8\n@@ -72,9 +67,8 @@ LL |     m!('a', ..=ALMOST_MAX);\n    = note: the matched value is of type `char`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         '\\u{10ffff}' => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, '\\u{10ffff}' => todo!() }\n+   |                                +++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `'b'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:30:8\n@@ -85,9 +79,8 @@ LL |     m!('a', ..=VAL | VAL_2..);\n    = note: the matched value is of type `char`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         'b' => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 'b' => todo!() }\n+   |                                ++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `'b'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:31:8\n@@ -98,9 +91,8 @@ LL |     m!('a', ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `char`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         'b' => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 'b' => todo!() }\n+   |                                ++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:41:12\n@@ -111,9 +103,8 @@ LL |         m!(0, ..u8::MAX);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `254_u8..=u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:42:12\n@@ -124,9 +115,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         254_u8..=u8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 254_u8..=u8::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_u8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:43:12\n@@ -137,9 +127,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         0_u8 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 0_u8 => todo!() }\n+   |                                +++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:44:12\n@@ -150,9 +139,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:45:12\n@@ -163,9 +151,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u8 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u8 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:46:12\n@@ -176,9 +163,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u8 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u8 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:54:12\n@@ -189,9 +175,8 @@ LL |         m!(0, ..u16::MAX);\n    = note: the matched value is of type `u16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u16::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u16::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `65534_u16..=u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:55:12\n@@ -202,9 +187,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `u16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         65534_u16..=u16::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 65534_u16..=u16::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_u16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:56:12\n@@ -215,9 +199,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `u16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         0_u16 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 0_u16 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:57:12\n@@ -228,9 +211,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `u16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u16::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u16::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:58:12\n@@ -241,9 +223,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `u16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u16 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u16 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:59:12\n@@ -254,9 +235,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `u16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u16 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u16 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:67:12\n@@ -267,9 +247,8 @@ LL |         m!(0, ..u32::MAX);\n    = note: the matched value is of type `u32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u32::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u32::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `4294967294_u32..=u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:68:12\n@@ -280,9 +259,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `u32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         4294967294_u32..=u32::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 4294967294_u32..=u32::MAX => todo!() }\n+   |                                ++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_u32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:69:12\n@@ -293,9 +271,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `u32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         0_u32 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 0_u32 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:70:12\n@@ -306,9 +283,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `u32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u32::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u32::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:71:12\n@@ -319,9 +295,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `u32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u32 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u32 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:72:12\n@@ -332,9 +307,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `u32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u32 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u32 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:80:12\n@@ -345,9 +319,8 @@ LL |         m!(0, ..u64::MAX);\n    = note: the matched value is of type `u64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u64::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u64::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `18446744073709551614_u64..=u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:81:12\n@@ -358,9 +331,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `u64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         18446744073709551614_u64..=u64::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 18446744073709551614_u64..=u64::MAX => todo!() }\n+   |                                ++++++++++++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_u64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:82:12\n@@ -371,9 +343,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `u64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         0_u64 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 0_u64 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:83:12\n@@ -384,9 +355,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `u64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u64::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u64::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:84:12\n@@ -397,9 +367,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `u64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u64 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u64 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:85:12\n@@ -410,9 +379,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `u64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u64 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u64 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:93:12\n@@ -423,9 +391,8 @@ LL |         m!(0, ..u128::MAX);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u128::MAX => todo!() }\n+   |                                ++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `340282366920938463463374607431768211454_u128..=u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:94:12\n@@ -436,9 +403,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         340282366920938463463374607431768211454_u128..=u128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 340282366920938463463374607431768211454_u128..=u128::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_u128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:95:12\n@@ -449,9 +415,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         0_u128 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 0_u128 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:96:12\n@@ -462,9 +427,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u128::MAX => todo!() }\n+   |                                ++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:97:12\n@@ -475,9 +439,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u128 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u128 => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:98:12\n@@ -488,9 +451,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u128 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u128 => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:109:12\n@@ -501,9 +463,8 @@ LL |         m!(0, ..i8::MAX);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `126_i8..=i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:110:12\n@@ -514,9 +475,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         126_i8..=i8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 126_i8..=i8::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i8::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:111:12\n@@ -527,9 +487,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i8::MIN => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i8::MIN => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:112:12\n@@ -540,9 +499,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:113:12\n@@ -553,9 +511,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i8 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i8 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:114:12\n@@ -566,9 +523,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i8 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i8 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:122:12\n@@ -579,9 +535,8 @@ LL |         m!(0, ..i16::MAX);\n    = note: the matched value is of type `i16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i16::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i16::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `32766_i16..=i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:123:12\n@@ -592,9 +547,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `i16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         32766_i16..=i16::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 32766_i16..=i16::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i16::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:124:12\n@@ -605,9 +559,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `i16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i16::MIN => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i16::MIN => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:125:12\n@@ -618,9 +571,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `i16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i16::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i16::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:126:12\n@@ -631,9 +583,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `i16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i16 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i16 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:127:12\n@@ -644,9 +595,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `i16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i16 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i16 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:135:12\n@@ -657,9 +607,8 @@ LL |         m!(0, ..i32::MAX);\n    = note: the matched value is of type `i32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i32::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i32::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `2147483646_i32..=i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:136:12\n@@ -670,9 +619,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `i32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         2147483646_i32..=i32::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 2147483646_i32..=i32::MAX => todo!() }\n+   |                                ++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i32::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:137:12\n@@ -683,9 +631,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `i32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i32::MIN => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i32::MIN => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:138:12\n@@ -696,9 +643,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `i32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i32::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i32::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:139:12\n@@ -709,9 +655,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `i32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i32 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i32 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:140:12\n@@ -722,9 +667,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `i32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i32 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i32 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:148:12\n@@ -735,9 +679,8 @@ LL |         m!(0, ..i64::MAX);\n    = note: the matched value is of type `i64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i64::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i64::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `9223372036854775806_i64..=i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:149:12\n@@ -748,9 +691,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `i64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         9223372036854775806_i64..=i64::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 9223372036854775806_i64..=i64::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i64::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:150:12\n@@ -761,9 +703,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `i64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i64::MIN => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i64::MIN => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:151:12\n@@ -774,9 +715,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `i64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i64::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i64::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:152:12\n@@ -787,9 +727,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `i64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i64 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i64 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:153:12\n@@ -800,9 +739,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `i64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i64 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i64 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:161:12\n@@ -813,9 +751,8 @@ LL |         m!(0, ..i128::MAX);\n    = note: the matched value is of type `i128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i128::MAX => todo!() }\n+   |                                ++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `170141183460469231731687303715884105726_i128..=i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:162:12\n@@ -826,9 +763,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `i128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         170141183460469231731687303715884105726_i128..=i128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 170141183460469231731687303715884105726_i128..=i128::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i128::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:163:12\n@@ -839,9 +775,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `i128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i128::MIN => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i128::MIN => todo!() }\n+   |                                ++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:164:12\n@@ -852,9 +787,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `i128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i128::MAX => todo!() }\n+   |                                ++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:165:12\n@@ -865,9 +799,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `i128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i128 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i128 => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:166:12\n@@ -878,9 +811,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `i128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i128 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i128 => todo!() }\n+   |                                ++++++++++++++++++++\n \n error: aborting due to 68 previous errors\n "}, {"sha": "c42034879369232c258265e28c7ceee85c7a8d57", "filename": "src/test/ui/issue-94866.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e5800b8d30fba923c5070ae660c1e45a630a191/src%2Ftest%2Fui%2Fissue-94866.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5800b8d30fba923c5070ae660c1e45a630a191/src%2Ftest%2Fui%2Fissue-94866.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-94866.rs?ref=3e5800b8d30fba923c5070ae660c1e45a630a191", "patch": "@@ -0,0 +1,14 @@\n+macro_rules! m {\n+    () => {\n+        {}\n+    };\n+}\n+\n+enum Enum { A, B }\n+\n+fn main() {\n+    match Enum::A {\n+    //~^ ERROR non-exhaustive patterns\n+    Enum::A => m!()\n+    }\n+}"}, {"sha": "5477d83f449209ee59375ff18db17253552a9e98", "filename": "src/test/ui/issue-94866.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3e5800b8d30fba923c5070ae660c1e45a630a191/src%2Ftest%2Fui%2Fissue-94866.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e5800b8d30fba923c5070ae660c1e45a630a191/src%2Ftest%2Fui%2Fissue-94866.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-94866.stderr?ref=3e5800b8d30fba923c5070ae660c1e45a630a191", "patch": "@@ -0,0 +1,21 @@\n+error[E0004]: non-exhaustive patterns: `B` not covered\n+  --> $DIR/issue-94866.rs:10:11\n+   |\n+LL |     match Enum::A {\n+   |           ^^^^^^^ pattern `B` not covered\n+   |\n+note: `Enum` defined here\n+  --> $DIR/issue-94866.rs:7:16\n+   |\n+LL | enum Enum { A, B }\n+   |      ----      ^ not covered\n+   = note: the matched value is of type `Enum`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~     Enum::A => m!(),\n+LL +     B => todo!()\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "f30ba05dff9e4343f4199e843086d8d5d9fe1e59", "filename": "src/test/ui/pattern/usefulness/integer-ranges/exhaustiveness.stderr", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3e5800b8d30fba923c5070ae660c1e45a630a191/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fexhaustiveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e5800b8d30fba923c5070ae660c1e45a630a191/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fexhaustiveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fexhaustiveness.stderr?ref=3e5800b8d30fba923c5070ae660c1e45a630a191", "patch": "@@ -7,9 +7,8 @@ LL |     m!(0u8, 0..255);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u8::MAX` not covered\n   --> $DIR/exhaustiveness.rs:48:8\n@@ -20,9 +19,8 @@ LL |     m!(0u8, 0..=254);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_u8` not covered\n   --> $DIR/exhaustiveness.rs:49:8\n@@ -33,9 +31,8 @@ LL |     m!(0u8, 1..=255);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         0_u8 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 0_u8 => todo!() }\n+   |                                +++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `42_u8` not covered\n   --> $DIR/exhaustiveness.rs:50:8\n@@ -46,9 +43,8 @@ LL |     m!(0u8, 0..42 | 43..=255);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         42_u8 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 42_u8 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/exhaustiveness.rs:51:8\n@@ -59,9 +55,8 @@ LL |     m!(0i8, -128..127);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/exhaustiveness.rs:52:8\n@@ -72,9 +67,8 @@ LL |     m!(0i8, -128..=126);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i8::MIN` not covered\n   --> $DIR/exhaustiveness.rs:53:8\n@@ -85,9 +79,8 @@ LL |     m!(0i8, -127..=127);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i8::MIN => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i8::MIN => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_i8` not covered\n   --> $DIR/exhaustiveness.rs:54:11\n@@ -111,9 +104,8 @@ LL |     m!(0u128, 0..=ALMOST_MAX);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u128::MAX => todo!() }\n+   |                                ++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `5_u128..=u128::MAX` not covered\n   --> $DIR/exhaustiveness.rs:60:8\n@@ -124,9 +116,8 @@ LL |     m!(0u128, 0..=4);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         5_u128..=u128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 5_u128..=u128::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_u128` not covered\n   --> $DIR/exhaustiveness.rs:61:8\n@@ -137,9 +128,8 @@ LL |     m!(0u128, 1..=u128::MAX);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         0_u128 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 0_u128 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `(126_u8..=127_u8, false)` not covered\n   --> $DIR/exhaustiveness.rs:69:11"}, {"sha": "e3eb98ccdcda5db09855f90e47b628dcec81edf8", "filename": "src/test/ui/pattern/usefulness/integer-ranges/pointer-sized-int.deny.stderr", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3e5800b8d30fba923c5070ae660c1e45a630a191/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e5800b8d30fba923c5070ae660c1e45a630a191/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr?ref=3e5800b8d30fba923c5070ae660c1e45a630a191", "patch": "@@ -39,9 +39,8 @@ LL |     m!(0usize, 0..=usize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:24:8\n@@ -54,9 +53,8 @@ LL |     m!(0usize, 0..5 | 5..=usize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:26:8\n@@ -69,9 +67,8 @@ LL |     m!(0usize, 0..usize::MAX | usize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `(_, _)` not covered\n   --> $DIR/pointer-sized-int.rs:28:8\n@@ -82,9 +79,8 @@ LL |     m!((0usize, true), (0..5, true) | (5..=usize::MAX, true) | (0..=usize::\n    = note: the matched value is of type `(usize, bool)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         (_, _) => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, (_, _) => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:31:8\n@@ -97,9 +93,8 @@ LL |     m!(0isize, isize::MIN..=isize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:33:8\n@@ -112,9 +107,8 @@ LL |     m!(0isize, isize::MIN..5 | 5..=isize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:35:8\n@@ -127,9 +121,8 @@ LL |     m!(0isize, isize::MIN..isize::MAX | isize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `(_, _)` not covered\n   --> $DIR/pointer-sized-int.rs:37:8\n@@ -140,9 +133,8 @@ LL |     m!((0isize, true), (isize::MIN..5, true)\n    = note: the matched value is of type `(isize, bool)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         (_, _) => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, (_, _) => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:41:11"}, {"sha": "89b4e06efdacd7c7afb34a730a817aae628ec1f3", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e5800b8d30fba923c5070ae660c1e45a630a191/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e5800b8d30fba923c5070ae660c1e45a630a191/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=3e5800b8d30fba923c5070ae660c1e45a630a191", "patch": "@@ -12,8 +12,8 @@ LL | enum T { A, B }\n    = note: the matched value is of type `T`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL |     match x { T::B => { } A => todo!() }\n-   |                           ++++++++++++\n+LL |     match x { T::B => { }, A => todo!() }\n+   |                          ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `false` not covered\n   --> $DIR/non-exhaustive-match.rs:8:11"}, {"sha": "e2a65ff8524040062aefcaad59b284c07e11921a", "filename": "src/test/ui/pattern/usefulness/tuple-struct-nonexhaustive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e5800b8d30fba923c5070ae660c1e45a630a191/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e5800b8d30fba923c5070ae660c1e45a630a191/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr?ref=3e5800b8d30fba923c5070ae660c1e45a630a191", "patch": "@@ -12,7 +12,7 @@ LL | struct Foo(isize, isize);\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         Foo(2, b) => println!(\"{}\", b)\n+LL ~         Foo(2, b) => println!(\"{}\", b),\n LL +         Foo(_, _) => todo!()\n    |\n "}]}