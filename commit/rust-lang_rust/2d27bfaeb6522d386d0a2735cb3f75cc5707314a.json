{"sha": "2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMjdiZmFlYjY1MjJkMzg2ZDBhMjczNWNiM2Y3NWNjNTcwNzMxNGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-30T06:32:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-30T06:32:11Z"}, "message": "auto merge of #17704 : nick29581/rust/object-safety, r=nikomatsakis\n\nr? @nikomatsakis", "tree": {"sha": "0b27f013ab6f65b62150aed544c1a98f561792c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b27f013ab6f65b62150aed544c1a98f561792c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "html_url": "https://github.com/rust-lang/rust/commit/2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6", "html_url": "https://github.com/rust-lang/rust/commit/d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6"}, {"sha": "88a250d194d7a7995c0740d706d9eb19007a85ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/88a250d194d7a7995c0740d706d9eb19007a85ee", "html_url": "https://github.com/rust-lang/rust/commit/88a250d194d7a7995c0740d706d9eb19007a85ee"}], "stats": {"total": 703, "additions": 309, "deletions": 394}, "files": [{"sha": "c4e213790880f894c7269dd3190f03204e339326", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -53,7 +53,6 @@ register_diagnostics!(\n     E0035,\n     E0036,\n     E0038,\n-    E0039,\n     E0040,\n     E0044,\n     E0045,"}, {"sha": "cd3cc43b8539d4e17ab2bdbb0bb8fe043fae7ecb", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 6, "deletions": 82, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -619,14 +619,12 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n         let tcx = self.tcx();\n \n-        // It is illegal to invoke a method on a trait instance that\n-        // refers to the `Self` type. An error will be reported by\n-        // `enforce_object_limitations()` if the method refers to the\n-        // `Self` type anywhere other than the receiver. Here, we use\n-        // a substitution that replaces `Self` with the object type\n-        // itself. Hence, a `&self` method will wind up with an\n-        // argument type like `&Trait`.\n+        // It is illegal to invoke a method on a trait instance that refers to\n+        // the `Self` type.  Here, we use a substitution that replaces `Self`\n+        // with the object type itself. Hence, a `&self` method will wind up\n+        // with an argument type like `&Trait`.\n         let rcvr_substs = substs.with_self_ty(self_ty);\n+\n         let trait_ref = Rc::new(TraitRef {\n             def_id: did,\n             substs: rcvr_substs.clone()\n@@ -1336,16 +1334,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                self.ty_to_string(rcvr_ty),\n                candidate.repr(self.tcx()));\n \n-        let mut rcvr_substs = candidate.rcvr_substs.clone();\n-\n-        if !self.enforce_object_limitations(candidate) {\n-            // Here we change `Self` from `Trait` to `err` in the case that\n-            // this is an illegal object method. This is necessary to prevent\n-            // the user from getting strange, derivative errors when the method\n-            // takes an argument/return-type of type `Self` etc.\n-            rcvr_substs.types.get_mut_slice(SelfSpace)[0] = ty::mk_err();\n-        }\n-\n+        let rcvr_substs = candidate.rcvr_substs.clone();\n         self.enforce_drop_trait_limitations(candidate);\n \n         // Determine the values for the generic parameters of the method.\n@@ -1554,71 +1543,6 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n     }\n \n-    fn enforce_object_limitations(&self, candidate: &Candidate) -> bool {\n-        /*!\n-         * There are some limitations to calling functions through an\n-         * object, because (a) the self type is not known\n-         * (that's the whole point of a trait instance, after all, to\n-         * obscure the self type) and (b) the call must go through a\n-         * vtable and hence cannot be monomorphized.\n-         */\n-\n-        match candidate.origin {\n-            MethodStatic(..) |\n-            MethodTypeParam(..) |\n-            MethodStaticUnboxedClosure(..) => {\n-                return true; // not a call to a trait instance\n-            }\n-            MethodTraitObject(..) => {}\n-        }\n-\n-        match candidate.method_ty.explicit_self {\n-            ty::StaticExplicitSelfCategory => { // reason (a) above\n-                self.tcx().sess.span_err(\n-                    self.span,\n-                    \"cannot call a method without a receiver \\\n-                     through an object\");\n-                return false;\n-            }\n-\n-            ty::ByValueExplicitSelfCategory |\n-            ty::ByReferenceExplicitSelfCategory(..) |\n-            ty::ByBoxExplicitSelfCategory => {}\n-        }\n-\n-        // reason (a) above\n-        let check_for_self_ty = |ty| -> bool {\n-            if ty::type_has_self(ty) {\n-                span_err!(self.tcx().sess, self.span, E0038,\n-                    \"cannot call a method whose type contains a \\\n-                     self-type through an object\");\n-                false\n-            } else {\n-                true\n-            }\n-        };\n-        let ref sig = candidate.method_ty.fty.sig;\n-        for &input_ty in sig.inputs[1..].iter() {\n-            if !check_for_self_ty(input_ty) {\n-                return false;\n-            }\n-        }\n-        if let ty::FnConverging(result_type) = sig.output {\n-            if !check_for_self_ty(result_type) {\n-                return false;\n-            }\n-        }\n-\n-        if candidate.method_ty.generics.has_type_params(subst::FnSpace) {\n-            // reason (b) above\n-            span_err!(self.tcx().sess, self.span, E0039,\n-                \"cannot call a generic method through an object\");\n-            return false;\n-        }\n-\n-        true\n-    }\n-\n     fn enforce_drop_trait_limitations(&self, candidate: &Candidate) {\n         // No code can call the finalize method explicitly.\n         let bad = match candidate.origin {"}, {"sha": "94c4d7c25e0a615fca13381c962a4a72401bef8a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -1687,6 +1687,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.register_unsize_obligations(span, &**u)\n             }\n             ty::UnsizeVtable(ref ty_trait, self_ty) => {\n+                vtable::check_object_safety(self.tcx(), ty_trait, span);\n                 // If the type is `Foo+'a`, ensures that the type\n                 // being cast to `Foo+'a` implements `Foo`:\n                 vtable::register_object_cast_obligations(self,"}, {"sha": "b7195734e8b39ca9da1d22c340c4461873464c54", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 102, "deletions": 3, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::subst::{SelfSpace};\n+use middle::subst::{SelfSpace, FnSpace};\n use middle::traits;\n use middle::traits::{SelectionError, OutputTypeParameterMismatch, Overflow, Unimplemented};\n use middle::traits::{Obligation, obligation_for_builtin_bound};\n@@ -21,8 +21,7 @@ use middle::typeck::infer;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::ppaux::UserString;\n-use util::ppaux::Repr;\n+use util::ppaux::{UserString, Repr, ty_to_string};\n \n pub fn check_object_cast(fcx: &FnCtxt,\n                          cast_expr: &ast::Expr,\n@@ -46,6 +45,7 @@ pub fn check_object_cast(fcx: &FnCtxt,\n \n             // Ensure that if ~T is cast to ~Trait, then T : Trait\n             push_cast_obligation(fcx, cast_expr, object_trait, referent_ty);\n+            check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n         }\n \n         (&ty::ty_rptr(referent_region, ty::mt { ty: referent_ty,\n@@ -68,6 +68,8 @@ pub fn check_object_cast(fcx: &FnCtxt,\n                                infer::RelateObjectBound(source_expr.span),\n                                target_region,\n                                referent_region);\n+\n+                check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n             }\n         }\n \n@@ -128,6 +130,103 @@ pub fn check_object_cast(fcx: &FnCtxt,\n     }\n }\n \n+// Check that a trait is 'object-safe'. This should be checked whenever a trait object\n+// is created (by casting or coercion, etc.). A trait is object-safe if all its\n+// methods are object-safe. A trait method is object-safe if it does not take\n+// self by value, has no type parameters and does not use the `Self` type, except\n+// in self position.\n+pub fn check_object_safety(tcx: &ty::ctxt, object_trait: &ty::TyTrait, span: Span) {\n+    // Skip the fn_once lang item trait since only the compiler should call\n+    // `call_once` which is the method which takes self by value. What could go\n+    // wrong?\n+    match tcx.lang_items.fn_once_trait() {\n+        Some(def_id) if def_id == object_trait.def_id => return,\n+        _ => {}\n+    }\n+\n+    let trait_items = ty::trait_items(tcx, object_trait.def_id);\n+\n+    let mut errors = Vec::new();\n+    for item in trait_items.iter() {\n+        match *item {\n+            ty::MethodTraitItem(ref m) => {\n+                errors.push(check_object_safety_of_method(tcx, &**m))\n+            }\n+            ty::TypeTraitItem(_) => {}\n+        }\n+    }\n+\n+    let mut errors = errors.iter().flat_map(|x| x.iter()).peekable();\n+    if errors.peek().is_some() {\n+        let trait_name = ty::item_path_str(tcx, object_trait.def_id);\n+        span_err!(tcx.sess, span, E0038,\n+            \"cannot convert to a trait object because trait `{}` is not object-safe\",\n+            trait_name);\n+\n+        for msg in errors {\n+            tcx.sess.note(msg.as_slice());\n+        }\n+    }\n+\n+    // Returns a vec of error messages. If hte vec is empty - no errors!\n+    fn check_object_safety_of_method(tcx: &ty::ctxt, method: &ty::Method) -> Vec<String> {\n+        /*!\n+         * There are some limitations to calling functions through an\n+         * object, because (a) the self type is not known\n+         * (that's the whole point of a trait instance, after all, to\n+         * obscure the self type) and (b) the call must go through a\n+         * vtable and hence cannot be monomorphized.\n+         */\n+        let mut msgs = Vec::new();\n+\n+        let method_name = method.name.repr(tcx);\n+\n+        match method.explicit_self {\n+            ty::ByValueExplicitSelfCategory => { // reason (a) above\n+                msgs.push(format!(\"cannot call a method (`{}`) with a by-value \\\n+                                   receiver through a trait object\", method_name))\n+            }\n+\n+            ty::StaticExplicitSelfCategory |\n+            ty::ByReferenceExplicitSelfCategory(..) |\n+            ty::ByBoxExplicitSelfCategory => {}\n+        }\n+\n+        // reason (a) above\n+        let check_for_self_ty = |ty| {\n+            if ty::type_has_self(ty) {\n+                Some(format!(\n+                    \"cannot call a method (`{}`) whose type contains \\\n+                     a self-type (`{}`) through a trait object\",\n+                    method_name, ty_to_string(tcx, ty)))\n+            } else {\n+                None\n+            }\n+        };\n+        let ref sig = method.fty.sig;\n+        for &input_ty in sig.inputs[1..].iter() {\n+            match check_for_self_ty(input_ty) {\n+                Some(msg) => msgs.push(msg),\n+                _ => {}\n+            }\n+        }\n+        if let ty::FnConverging(result_type) = sig.output {\n+            match check_for_self_ty(result_type) {\n+                Some(msg) => msgs.push(msg),\n+                _ => {}\n+            }\n+        }\n+\n+        if method.generics.has_type_params(FnSpace) {\n+            // reason (b) above\n+            msgs.push(format!(\"cannot call a generic method (`{}`) through a trait object\",\n+                              method_name));\n+        }\n+\n+        msgs\n+    }\n+}\n+\n pub fn register_object_cast_obligations(fcx: &FnCtxt,\n                                         span: Span,\n                                         object_trait: &ty::TyTrait,"}, {"sha": "078a9a014c9c8d97c38d29c2e9e527edcc63b918", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -172,7 +172,7 @@ pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n mod test {\n     use prelude::*;\n     use io;\n-    use io::{MemReader, MemWriter};\n+    use io::{MemReader, MemWriter, BytesReader};\n \n     struct InitialZeroByteReader {\n         count: int,"}, {"sha": "d22650107a334e697f3a8ec149cf9f835a930405", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -712,17 +712,6 @@ pub trait Reader {\n         })\n     }\n \n-    /// Create an iterator that reads a single byte on\n-    /// each iteration, until EOF.\n-    ///\n-    /// # Error\n-    ///\n-    /// Any error other than `EndOfFile` that is produced by the underlying Reader\n-    /// is returned by the iterator and should be handled by the caller.\n-    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self> {\n-        extensions::Bytes::new(self)\n-    }\n-\n     // Byte conversion helpers\n \n     /// Reads `n` little-endian unsigned integer bytes.\n@@ -932,16 +921,41 @@ pub trait Reader {\n     fn read_i8(&mut self) -> IoResult<i8> {\n         self.read_byte().map(|i| i as i8)\n     }\n+}\n \n+/// A reader which can be converted to a RefReader.\n+pub trait AsRefReader {\n     /// Creates a wrapper around a mutable reference to the reader.\n     ///\n     /// This is useful to allow applying adaptors while still\n     /// retaining ownership of the original value.\n-    fn by_ref<'a>(&'a mut self) -> RefReader<'a, Self> {\n+    fn by_ref<'a>(&'a mut self) -> RefReader<'a, Self>;\n+}\n+\n+impl<T: Reader> AsRefReader for T {\n+    fn by_ref<'a>(&'a mut self) -> RefReader<'a, T> {\n         RefReader { inner: self }\n     }\n }\n \n+/// A reader which can be converted to bytes.\n+pub trait BytesReader {\n+    /// Create an iterator that reads a single byte on\n+    /// each iteration, until EOF.\n+    ///\n+    /// # Error\n+    ///\n+    /// Any error other than `EndOfFile` that is produced by the underlying Reader\n+    /// is returned by the iterator and should be handled by the caller.\n+    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self>;\n+}\n+\n+impl<T: Reader> BytesReader for T {\n+    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, T> {\n+        extensions::Bytes::new(self)\n+    }\n+}\n+\n impl<'a> Reader for Box<Reader+'a> {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let reader: &mut Reader = &mut **self;\n@@ -986,6 +1000,7 @@ unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -\n /// # fn process_input<R: Reader>(r: R) {}\n /// # fn foo() {\n /// use std::io;\n+/// use std::io::AsRefReader;\n /// use std::io::util::LimitReader;\n ///\n /// let mut stream = io::stdin();\n@@ -1268,13 +1283,20 @@ pub trait Writer {\n     fn write_i8(&mut self, n: i8) -> IoResult<()> {\n         self.write([n as u8])\n     }\n+}\n \n+/// A writer which can be converted to a RefWriter.\n+pub trait AsRefWriter {\n     /// Creates a wrapper around a mutable reference to the writer.\n     ///\n     /// This is useful to allow applying wrappers while still\n     /// retaining ownership of the original value.\n     #[inline]\n-    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, Self> {\n+    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, Self>;\n+}\n+\n+impl<T: Writer> AsRefWriter for T {\n+    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, T> {\n         RefWriter { inner: self }\n     }\n }\n@@ -1309,7 +1331,7 @@ impl<'a> Writer for &'a mut Writer+'a {\n /// # fn process_input<R: Reader>(r: R) {}\n /// # fn foo () {\n /// use std::io::util::TeeReader;\n-/// use std::io::{stdin, MemWriter};\n+/// use std::io::{stdin, MemWriter, AsRefWriter};\n ///\n /// let mut output = MemWriter::new();\n ///"}, {"sha": "5694565b4ea6a98e7a6ab5be9bb0226bbf6b09d6", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -265,7 +265,7 @@ impl<T: Iterator<u8>> Reader for IterReader<T> {\n \n #[cfg(test)]\n mod test {\n-    use io::{MemReader, MemWriter, BufReader};\n+    use io::{MemReader, MemWriter, BufReader, AsRefReader};\n     use io;\n     use boxed::Box;\n     use super::*;"}, {"sha": "2e93f6badf2c96ec9995e0db3bebe17e2dc3fd71", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 26, "deletions": 37, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -89,30 +89,25 @@ impl Writer for WriterWrapper {\n /// Return a Terminal wrapping stdout, or None if a terminal couldn't be\n /// opened.\n pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n-    let ti: Option<TerminfoTerminal<WriterWrapper>>\n-        = Terminal::new(WriterWrapper {\n-            wrapped: box std::io::stdout() as Box<Writer + Send>,\n-        });\n-    ti.map(|t| box t as Box<Terminal<WriterWrapper> + Send>)\n+    TerminfoTerminal::new(WriterWrapper {\n+        wrapped: box std::io::stdout() as Box<Writer + Send>,\n+    })\n }\n \n #[cfg(windows)]\n /// Return a Terminal wrapping stdout, or None if a terminal couldn't be\n /// opened.\n pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n-    let ti: Option<TerminfoTerminal<WriterWrapper>>\n-        = Terminal::new(WriterWrapper {\n-            wrapped: box std::io::stdout() as Box<Writer + Send>,\n-        });\n+    let ti = TerminfoTerminal::new(WriterWrapper {\n+        wrapped: box std::io::stdout() as Box<Writer + Send>,\n+    });\n \n     match ti {\n-        Some(t) => Some(box t as Box<Terminal<WriterWrapper> + Send>),\n+        Some(t) => Some(t),\n         None => {\n-            let wc: Option<WinConsole<WriterWrapper>>\n-                = Terminal::new(WriterWrapper {\n-                    wrapped: box std::io::stdout() as Box<Writer + Send>,\n-                });\n-            wc.map(|w| box w as Box<Terminal<WriterWrapper> + Send>)\n+            WinConsole::new(WriterWrapper {\n+                wrapped: box std::io::stdout() as Box<Writer + Send>,\n+            })\n         }\n     }\n }\n@@ -121,30 +116,25 @@ pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n /// Return a Terminal wrapping stderr, or None if a terminal couldn't be\n /// opened.\n pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send> + Send> {\n-    let ti: Option<TerminfoTerminal<WriterWrapper>>\n-        = Terminal::new(WriterWrapper {\n-            wrapped: box std::io::stderr() as Box<Writer + Send>,\n-        });\n-    ti.map(|t| box t as Box<Terminal<WriterWrapper> + Send>)\n+    TerminfoTerminal::new(WriterWrapper {\n+        wrapped: box std::io::stderr() as Box<Writer + Send>,\n+    })\n }\n \n #[cfg(windows)]\n /// Return a Terminal wrapping stderr, or None if a terminal couldn't be\n /// opened.\n pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send> + Send> {\n-    let ti: Option<TerminfoTerminal<WriterWrapper>>\n-        = Terminal::new(WriterWrapper {\n-            wrapped: box std::io::stderr() as Box<Writer + Send>,\n-        });\n+    let ti = TerminfoTerminal::new(WriterWrapper {\n+        wrapped: box std::io::stderr() as Box<Writer + Send>,\n+    });\n \n     match ti {\n-        Some(t) => Some(box t as Box<Terminal<WriterWrapper> + Send>),\n+        Some(t) => Some(t),\n         None => {\n-            let wc: Option<WinConsole<WriterWrapper>>\n-                = Terminal::new(WriterWrapper {\n-                    wrapped: box std::io::stderr() as Box<Writer + Send>,\n-                });\n-            wc.map(|w| box w as Box<Terminal<WriterWrapper> + Send>)\n+            WinConsole::new(WriterWrapper {\n+                wrapped: box std::io::stderr() as Box<Writer + Send>,\n+            })\n         }\n     }\n }\n@@ -208,10 +198,6 @@ pub mod attr {\n /// A terminal with similar capabilities to an ANSI Terminal\n /// (foreground/background colors etc).\n pub trait Terminal<T: Writer>: Writer {\n-    /// Returns `None` whenever the terminal cannot be created for some\n-    /// reason.\n-    fn new(out: T) -> Option<Self>;\n-\n     /// Sets the foreground color to the given color.\n     ///\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n@@ -242,12 +228,15 @@ pub trait Terminal<T: Writer>: Writer {\n     /// Returns `Ok()`.\n     fn reset(&mut self) -> IoResult<()>;\n \n-    /// Returns the contained stream, destroying the `Terminal`\n-    fn unwrap(self) -> T;\n-\n     /// Gets an immutable reference to the stream inside\n     fn get_ref<'a>(&'a self) -> &'a T;\n \n     /// Gets a mutable reference to the stream inside\n     fn get_mut<'a>(&'a mut self) -> &'a mut T;\n }\n+\n+/// A terminal which can be unwrapped.\n+pub trait UnwrappableTerminal<T: Writer>: Terminal<T> {\n+    /// Returns the contained stream, destroying the `Terminal`\n+    fn unwrap(self) -> T;\n+}"}, {"sha": "73edcf948921687719cbf081923266081bb1553b", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -17,6 +17,7 @@ use std::os;\n use attr;\n use color;\n use Terminal;\n+use UnwrappableTerminal;\n use self::searcher::open;\n use self::parser::compiled::{parse, msys_terminfo};\n use self::parm::{expand, Number, Variables};\n@@ -71,44 +72,7 @@ pub struct TerminfoTerminal<T> {\n     ti: Box<TermInfo>\n }\n \n-impl<T: Writer> Terminal<T> for TerminfoTerminal<T> {\n-    fn new(out: T) -> Option<TerminfoTerminal<T>> {\n-        let term = match os::getenv(\"TERM\") {\n-            Some(t) => t,\n-            None => {\n-                debug!(\"TERM environment variable not defined\");\n-                return None;\n-            }\n-        };\n-\n-        let entry = open(term.as_slice());\n-        if entry.is_err() {\n-            if os::getenv(\"MSYSCON\").map_or(false, |s| {\n-                    \"mintty.exe\" == s.as_slice()\n-                }) {\n-                // msys terminal\n-                return Some(TerminfoTerminal {out: out, ti: msys_terminfo(), num_colors: 8});\n-            }\n-            debug!(\"error finding terminfo entry: {}\", entry.err().unwrap());\n-            return None;\n-        }\n-\n-        let mut file = entry.unwrap();\n-        let ti = parse(&mut file, false);\n-        if ti.is_err() {\n-            debug!(\"error parsing terminfo entry: {}\", ti.unwrap_err());\n-            return None;\n-        }\n-\n-        let inf = ti.unwrap();\n-        let nc = if inf.strings.find_equiv(&(\"setaf\")).is_some()\n-                 && inf.strings.find_equiv(&(\"setab\")).is_some() {\n-                     inf.numbers.find_equiv(&(\"colors\")).map_or(0, |&n| n)\n-                 } else { 0 };\n-\n-        return Some(TerminfoTerminal {out: out, ti: inf, num_colors: nc});\n-    }\n-\n+impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n     fn fg(&mut self, color: color::Color) -> IoResult<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n@@ -195,14 +159,59 @@ impl<T: Writer> Terminal<T> for TerminfoTerminal<T> {\n         Ok(())\n     }\n \n-    fn unwrap(self) -> T { self.out }\n-\n     fn get_ref<'a>(&'a self) -> &'a T { &self.out }\n \n     fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.out }\n }\n \n-impl<T: Writer> TerminfoTerminal<T> {\n+impl<T: Writer+Send> UnwrappableTerminal<T> for TerminfoTerminal<T> {\n+    fn unwrap(self) -> T { self.out }\n+}\n+\n+impl<T: Writer+Send> TerminfoTerminal<T> {\n+    /// Returns `None` whenever the terminal cannot be created for some\n+    /// reason.\n+    pub fn new(out: T) -> Option<Box<Terminal<T>+Send+'static>> {\n+        let term = match os::getenv(\"TERM\") {\n+            Some(t) => t,\n+            None => {\n+                debug!(\"TERM environment variable not defined\");\n+                return None;\n+            }\n+        };\n+\n+        let entry = open(term.as_slice());\n+        if entry.is_err() {\n+            if os::getenv(\"MSYSCON\").map_or(false, |s| {\n+                    \"mintty.exe\" == s.as_slice()\n+                }) {\n+                // msys terminal\n+                return Some(box TerminfoTerminal {out: out,\n+                                                  ti: msys_terminfo(),\n+                                                  num_colors: 8} as Box<Terminal<T>+Send>);\n+            }\n+            debug!(\"error finding terminfo entry: {}\", entry.err().unwrap());\n+            return None;\n+        }\n+\n+        let mut file = entry.unwrap();\n+        let ti = parse(&mut file, false);\n+        if ti.is_err() {\n+            debug!(\"error parsing terminfo entry: {}\", ti.unwrap_err());\n+            return None;\n+        }\n+\n+        let inf = ti.unwrap();\n+        let nc = if inf.strings.find_equiv(&(\"setaf\")).is_some()\n+                 && inf.strings.find_equiv(&(\"setab\")).is_some() {\n+                     inf.numbers.find_equiv(&(\"colors\")).map_or(0, |&n| n)\n+                 } else { 0 };\n+\n+        return Some(box TerminfoTerminal {out: out,\n+                                          ti: inf,\n+                                          num_colors: nc} as Box<Terminal<T>+Send>);\n+    }\n+\n     fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n         if color >= self.num_colors && color >= 8 && color < 16 {\n             color-8"}, {"sha": "7ce6fb658b56d36a5998da51f3507a844b3c8d60", "filename": "src/libterm/win.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -18,7 +18,7 @@ use std::io::IoResult;\n \n use attr;\n use color;\n-use Terminal;\n+use {Terminal,UnwrappableTerminal};\n \n /// A Terminal implementation which uses the Win32 Console API.\n pub struct WinConsole<T> {\n@@ -91,7 +91,7 @@ fn bits_to_color(bits: u16) -> color::Color {\n     }\n }\n \n-impl<T: Writer> WinConsole<T> {\n+impl<T: Writer+Send> WinConsole<T> {\n     fn apply(&mut self) {\n         let _unused = self.buf.flush();\n         let mut accum: libc::WORD = 0;\n@@ -112,20 +112,10 @@ impl<T: Writer> WinConsole<T> {\n             SetConsoleTextAttribute(out, accum);\n         }\n     }\n-}\n-\n-impl<T: Writer> Writer for WinConsole<T> {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.buf.write(buf)\n-    }\n-\n-    fn flush(&mut self) -> IoResult<()> {\n-        self.buf.flush()\n-    }\n-}\n \n-impl<T: Writer> Terminal<T> for WinConsole<T> {\n-    fn new(out: T) -> Option<WinConsole<T>> {\n+    /// Returns `None` whenever the terminal cannot be created for some\n+    /// reason.\n+    pub fn new(out: T) -> Option<Box<Terminal<T>+Send+'static>> {\n         let fg;\n         let bg;\n         unsafe {\n@@ -138,11 +128,23 @@ impl<T: Writer> Terminal<T> for WinConsole<T> {\n                 bg = color::BLACK;\n             }\n         }\n-        Some(WinConsole { buf: out,\n-                          def_foreground: fg, def_background: bg,\n-                          foreground: fg, background: bg } )\n+        Some(box WinConsole { buf: out,\n+                              def_foreground: fg, def_background: bg,\n+                              foreground: fg, background: bg } as Box<Terminal<T>+Send>)\n     }\n+}\n \n+impl<T: Writer> Writer for WinConsole<T> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.buf.write(buf)\n+    }\n+\n+    fn flush(&mut self) -> IoResult<()> {\n+        self.buf.flush()\n+    }\n+}\n+\n+impl<T: Writer+Send> Terminal<T> for WinConsole<T> {\n     fn fg(&mut self, color: color::Color) -> IoResult<bool> {\n         self.foreground = color;\n         self.apply();\n@@ -190,9 +192,11 @@ impl<T: Writer> Terminal<T> for WinConsole<T> {\n         Ok(())\n     }\n \n-    fn unwrap(self) -> T { self.buf }\n-\n     fn get_ref<'a>(&'a self) -> &'a T { &self.buf }\n \n     fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.buf }\n }\n+\n+impl<T: Writer+Send> UnwrappableTerminal<T> for WinConsole<T> {\n+    fn unwrap(self) -> T { self.buf }\n+}"}, {"sha": "dfeba04109281fdf594a2db5d22560a55eea08e8", "filename": "src/test/compile-fail/region-object-lifetime-in-coercion.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -11,24 +11,27 @@\n // Test that attempts to implicitly coerce a value into an\n // object respect the lifetime bound on the object type.\n \n-fn a(v: &[u8]) -> Box<Clone + 'static> {\n-    let x: Box<Clone + 'static> = box v; //~ ERROR does not outlive\n+trait Foo {}\n+impl<'a> Foo for &'a [u8] {}\n+\n+fn a(v: &[u8]) -> Box<Foo + 'static> {\n+    let x: Box<Foo + 'static> = box v; //~ ERROR does not outlive\n     x\n }\n \n-fn b(v: &[u8]) -> Box<Clone + 'static> {\n+fn b(v: &[u8]) -> Box<Foo + 'static> {\n     box v //~ ERROR does not outlive\n }\n \n-fn c(v: &[u8]) -> Box<Clone> {\n+fn c(v: &[u8]) -> Box<Foo> {\n     box v // OK thanks to lifetime elision\n }\n \n-fn d<'a,'b>(v: &'a [u8]) -> Box<Clone+'b> {\n+fn d<'a,'b>(v: &'a [u8]) -> Box<Foo+'b> {\n     box v //~ ERROR does not outlive\n }\n \n-fn e<'a:'b,'b>(v: &'a [u8]) -> Box<Clone+'b> {\n+fn e<'a:'b,'b>(v: &'a [u8]) -> Box<Foo+'b> {\n     box v // OK, thanks to 'a:'b\n }\n "}, {"sha": "44ee5002dce3d409a2d391ecd0e732dede7a7e20", "filename": "src/test/compile-fail/selftype-traittype.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs?ref=d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-trait add {\n-    fn plus(&self, x: Self) -> Self;\n-}\n-\n-fn do_add(x: Box<add+'static>, y: Box<add+'static>) -> Box<add+'static> {\n-    x.plus(y) //~ ERROR E0038\n-}\n-\n-fn main() {}"}, {"sha": "88b907a5cb965538e59ece6e7977b932861b1016", "filename": "src/test/compile-fail/trait-objects.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Ftest%2Fcompile-fail%2Ftrait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Ftest%2Fcompile-fail%2Ftrait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-objects.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    fn foo(self);\n+}\n+\n+trait Bar {\n+    fn bar(&self, x: &Self);\n+}\n+\n+trait Baz {\n+    fn baz<T>(&self, x: &T);\n+}\n+\n+impl Foo for int {\n+    fn foo(self) {}\n+}\n+\n+impl Bar for int {\n+    fn bar(&self, _x: &int) {}\n+}\n+\n+impl Baz for int {\n+    fn baz<T>(&self, _x: &T) {}\n+}\n+\n+fn main() {\n+    let _: &Foo = &42i; //~ ERROR cannot convert to a trait object\n+    let _: &Bar = &42i; //~ ERROR cannot convert to a trait object\n+    let _: &Baz = &42i; //~ ERROR cannot convert to a trait object\n+\n+    let _ = &42i as &Foo; //~ ERROR cannot convert to a trait object\n+    let _ = &42i as &Bar; //~ ERROR cannot convert to a trait object\n+    let _ = &42i as &Baz; //~ ERROR cannot convert to a trait object\n+}"}, {"sha": "a24f7710d7b61c88c740c9565cbb7e530dea96b1", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -16,5 +16,5 @@ impl bar for uint { fn dup(&self) -> uint { *self } fn blah<X>(&self) {} }\n fn main() {\n     10i.dup::<int>(); //~ ERROR does not take type parameters\n     10i.blah::<int, int>(); //~ ERROR incorrect number of type parameters\n-    (box 10i as Box<bar>).dup(); //~ ERROR contains a self-type\n+    (box 10i as Box<bar>).dup(); //~ ERROR cannot convert to a trait object\n }"}, {"sha": "6b000866d3ab942cb1cf5cd172151a8328d0996b", "filename": "src/test/run-fail/by-value-self-objects-fail.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6/src%2Ftest%2Frun-fail%2Fby-value-self-objects-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6/src%2Ftest%2Frun-fail%2Fby-value-self-objects-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fby-value-self-objects-fail.rs?ref=d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6", "patch": "@@ -1,51 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:explicit panic\n-\n-trait Foo {\n-    fn foo(self, x: int);\n-}\n-\n-struct S {\n-    x: int,\n-    y: int,\n-    z: int,\n-    s: String,\n-}\n-\n-impl Foo for S {\n-    fn foo(self, x: int) {\n-        panic!()\n-    }\n-}\n-\n-impl Drop for S {\n-    fn drop(&mut self) {\n-        println!(\"bye 1!\");\n-    }\n-}\n-\n-fn f() {\n-    let s = S {\n-        x: 2,\n-        y: 3,\n-        z: 4,\n-        s: \"hello\".to_string(),\n-    };\n-    let st = box s as Box<Foo>;\n-    st.foo(5);\n-}\n-\n-fn main() {\n-    f();\n-}\n-\n-"}, {"sha": "3a588367a9709a4f074a151d6d623d05f74fbc41", "filename": "src/test/run-pass/by-value-self-objects.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6/src%2Ftest%2Frun-pass%2Fby-value-self-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6/src%2Ftest%2Frun-pass%2Fby-value-self-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fby-value-self-objects.rs?ref=d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-static mut destructor_count: uint = 0;\n-\n-trait Foo {\n-    fn foo(self, x: int);\n-}\n-\n-struct S {\n-    x: int,\n-    y: int,\n-    z: int,\n-    s: String,\n-}\n-\n-impl Foo for S {\n-    fn foo(self, x: int) {\n-        assert!(self.x == 2);\n-        assert!(self.y == 3);\n-        assert!(self.z == 4);\n-        assert!(self.s.as_slice() == \"hello\");\n-        assert!(x == 5);\n-    }\n-}\n-\n-impl Drop for S {\n-    fn drop(&mut self) {\n-        println!(\"bye 1!\");\n-        unsafe {\n-            destructor_count += 1;\n-        }\n-    }\n-}\n-\n-impl Foo for int {\n-    fn foo(self, x: int) {\n-        println!(\"{}\", x * x);\n-    }\n-}\n-\n-fn f() {\n-    let s = S {\n-        x: 2,\n-        y: 3,\n-        z: 4,\n-        s: \"hello\".to_string(),\n-    };\n-    let st = box s as Box<Foo>;\n-    st.foo(5);\n-    println!(\"bye 2!\");\n-}\n-\n-fn g() {\n-    let s = 2i;\n-    let st = box s as Box<Foo>;\n-    st.foo(3);\n-    println!(\"bye 3!\");\n-}\n-\n-fn main() {\n-    f();\n-\n-    unsafe {\n-        assert!(destructor_count == 1);\n-    }\n-\n-    g();\n-}\n-"}, {"sha": "f08805fe49c2c9c7ae74e3e3db39f7de49cccb68", "filename": "src/test/run-pass/issue-11267.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Ftest%2Frun-pass%2Fissue-11267.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Ftest%2Frun-pass%2Fissue-11267.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11267.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -12,11 +12,14 @@\n \n struct Empty;\n \n-impl Iterator<int> for Empty {\n+trait T<U> {\n+    fn next(&mut self) -> Option<U>;\n+}\n+impl T<int> for Empty {\n     fn next(&mut self) -> Option<int> { None }\n }\n \n-fn do_something_with(a : &mut Iterator<int>) {\n+fn do_something_with(a : &mut T<int>) {\n     println!(\"{}\", a.next())\n }\n "}, {"sha": "0c09e456930c2d83f3d2b6debdfd4f953a6c1dc9", "filename": "src/test/run-pass/issue-15763.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Ftest%2Frun-pass%2Fissue-15763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Ftest%2Frun-pass%2Fissue-15763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15763.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -60,16 +60,16 @@ fn dd() -> Result<int, int> {\n }\n \n trait A {\n-    fn aaa(self) -> int {\n+    fn aaa(&self) -> int {\n         3\n     }\n-    fn bbb(self) -> int {\n+    fn bbb(&self) -> int {\n         return 3;\n     }\n-    fn ccc(self) -> Result<int, int> {\n+    fn ccc(&self) -> Result<int, int> {\n         Ok(3)\n     }\n-    fn ddd(self) -> Result<int, int> {\n+    fn ddd(&self) -> Result<int, int> {\n         return Ok(3);\n     }\n }"}, {"sha": "8f0ec5ec7a19e89a30536a2352684dbb4c5e60cc", "filename": "src/test/run-pass/trait-cast-generic.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6/src%2Ftest%2Frun-pass%2Ftrait-cast-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6/src%2Ftest%2Frun-pass%2Ftrait-cast-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-cast-generic.rs?ref=d1fc2dec79689fe6bd37c95f3fe5b7acd476fff6", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Testing casting of a generic Struct to a Trait with a generic method.\n-// This is test for issue 10955.\n-#![allow(unused_variable)]\n-\n-trait Foo {\n-    fn f<A>(a: A) -> A {\n-        a\n-    }\n-}\n-\n-struct Bar<T> {\n-    x: T,\n-}\n-\n-impl<T> Foo for Bar<T> { }\n-\n-pub fn main() {\n-    let a = Bar { x: 1u };\n-    let b = &a as &Foo;\n-}"}, {"sha": "c4880e97c458bef96152d15ddd9df87fdd8b2363", "filename": "src/test/run-pass/trait-default-method-xc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d27bfaeb6522d386d0a2735cb3f75cc5707314a/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs?ref=2d27bfaeb6522d386d0a2735cb3f75cc5707314a", "patch": "@@ -72,9 +72,6 @@ pub fn main() {\n     assert_eq!(g(0i, 3.14f64, 1i), (3.14f64, 1i));\n     assert_eq!(g(false, 3.14f64, 1i), (3.14, 1));\n \n-    let obj = box 0i as Box<A>;\n-    assert_eq!(obj.h(), 11);\n-\n \n     // Trying out a real one\n     assert!(12i.test_neq(&10i));"}]}