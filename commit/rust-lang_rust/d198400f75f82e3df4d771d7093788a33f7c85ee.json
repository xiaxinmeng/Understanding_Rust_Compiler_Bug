{"sha": "d198400f75f82e3df4d771d7093788a33f7c85ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxOTg0MDBmNzVmODJlM2RmNGQ3NzFkNzA5Mzc4OGEzM2Y3Yzg1ZWU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-15T11:52:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-09-15T11:52:20Z"}, "message": "Merge pull request #451 from TimDiekmann/master\n\nRemove unchecked_shr/shl from intrinsics", "tree": {"sha": "faaf47ee530af32f09ea4f5734e18252f0e0bfa5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faaf47ee530af32f09ea4f5734e18252f0e0bfa5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d198400f75f82e3df4d771d7093788a33f7c85ee", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbnPJ0CRBK7hj4Ov3rIwAAdHIIABqt0BmLKgTmfM6/qLFJCY+h\n78l3Wg9tpk11/sj3VlJaevYB9t2uqh5+reNqge8a2+jo/dD8FwOAvb7aFgZX7haf\n/2FyHVZbeFQHMoubdVtzOcCs1Go3qj0Vk/XpubYGL+triOBvoHtNZ36G4sHYnKCI\ns5bcHFmrRewdRMQ+XzKo5PyzPnovor7TlKIn7WgZaOJSjWbf5o1FA2NcMCOEHRN9\nyZO08KAPniuDTAmtxFtwoPVfnqtlGuo2bJ/7XM99sJuk+naRY+ZZ8tlojEd+3vjX\nHSq8jzKeDRTEHzHWkmXzxd1iM2Fcw0f0oGDtXqoJdOHWNJRO3byAjLRhJ+BcUkY=\n=iFoT\n-----END PGP SIGNATURE-----\n", "payload": "tree faaf47ee530af32f09ea4f5734e18252f0e0bfa5\nparent 5a8b46d993520af54e5eb3084319837037268b80\nparent b488b51b66c8740f8e8e3e68d225e7ef14e8cf55\nauthor Ralf Jung <post@ralfj.de> 1537012340 +0200\ncommitter GitHub <noreply@github.com> 1537012340 +0200\n\nMerge pull request #451 from TimDiekmann/master\n\nRemove unchecked_shr/shl from intrinsics"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d198400f75f82e3df4d771d7093788a33f7c85ee", "html_url": "https://github.com/rust-lang/rust/commit/d198400f75f82e3df4d771d7093788a33f7c85ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d198400f75f82e3df4d771d7093788a33f7c85ee/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a8b46d993520af54e5eb3084319837037268b80", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a8b46d993520af54e5eb3084319837037268b80", "html_url": "https://github.com/rust-lang/rust/commit/5a8b46d993520af54e5eb3084319837037268b80"}, {"sha": "b488b51b66c8740f8e8e3e68d225e7ef14e8cf55", "url": "https://api.github.com/repos/rust-lang/rust/commits/b488b51b66c8740f8e8e3e68d225e7ef14e8cf55", "html_url": "https://github.com/rust-lang/rust/commit/b488b51b66c8740f8e8e3e68d225e7ef14e8cf55"}], "stats": {"total": 222, "additions": 47, "deletions": 175}, "files": [{"sha": "125ee2d988549282f05e16b1272da0e441670302", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d198400f75f82e3df4d771d7093788a33f7c85ee/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/d198400f75f82e3df4d771d7093788a33f7c85ee/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=d198400f75f82e3df4d771d7093788a33f7c85ee", "patch": "@@ -1 +1 @@\n-nightly-2018-09-01\n+nightly-2018-09-15"}, {"sha": "a8cb58fdddfe48e6496c8458dac40c0371ab47b1", "filename": "src/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d198400f75f82e3df4d771d7093788a33f7c85ee/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d198400f75f82e3df4d771d7093788a33f7c85ee/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=d198400f75f82e3df4d771d7093788a33f7c85ee", "patch": "@@ -33,39 +33,6 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n         let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n         match intrinsic_name {\n-            \"add_with_overflow\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                self.binop_with_overflow(\n-                    mir::BinOp::Add,\n-                    l,\n-                    r,\n-                    dest,\n-                )?\n-            }\n-\n-            \"sub_with_overflow\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                self.binop_with_overflow(\n-                    mir::BinOp::Sub,\n-                    l,\n-                    r,\n-                    dest,\n-                )?\n-            }\n-\n-            \"mul_with_overflow\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                self.binop_with_overflow(\n-                    mir::BinOp::Mul,\n-                    l,\n-                    r,\n-                    dest,\n-                )?\n-            }\n-\n             \"arith_offset\" => {\n                 let offset = self.read_scalar(args[1])?.to_isize(&self)?;\n                 let ptr = self.read_scalar(args[0])?.not_undef()?;\n@@ -326,39 +293,6 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 self.write_scalar(result_ptr, dest)?;\n             }\n \n-            \"overflowing_sub\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                self.binop_ignore_overflow(\n-                    mir::BinOp::Sub,\n-                    l,\n-                    r,\n-                    dest,\n-                )?;\n-            }\n-\n-            \"overflowing_mul\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                self.binop_ignore_overflow(\n-                    mir::BinOp::Mul,\n-                    r,\n-                    l,\n-                    dest,\n-                )?;\n-            }\n-\n-            \"overflowing_add\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                self.binop_ignore_overflow(\n-                    mir::BinOp::Add,\n-                    r,\n-                    l,\n-                    dest,\n-                )?;\n-            }\n-\n             \"powf32\" => {\n                 let f = self.read_scalar(args[0])?.to_f32()?;\n                 let f2 = self.read_scalar(args[1])?.to_f32()?;\n@@ -443,42 +377,6 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 self.write_value(value, dest)?;\n             }\n \n-            \"unchecked_shl\" => {\n-                let bits = dest.layout.size.bytes() as u128 * 8;\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                let rval = r.to_scalar()?.to_bytes()?;\n-                if rval >= bits {\n-                    return err!(Intrinsic(\n-                        format!(\"Overflowing shift by {} in unchecked_shl\", rval),\n-                    ));\n-                }\n-                self.binop_ignore_overflow(\n-                    mir::BinOp::Shl,\n-                    l,\n-                    r,\n-                    dest,\n-                )?;\n-            }\n-\n-            \"unchecked_shr\" => {\n-                let bits = dest.layout.size.bytes() as u128 * 8;\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                let rval = r.to_scalar()?.to_bytes()?;\n-                if rval >= bits {\n-                    return err!(Intrinsic(\n-                        format!(\"Overflowing shift by {} in unchecked_shr\", rval),\n-                    ));\n-                }\n-                self.binop_ignore_overflow(\n-                    mir::BinOp::Shr,\n-                    l,\n-                    r,\n-                    dest,\n-                )?;\n-            }\n-\n             \"unchecked_div\" => {\n                 let l = self.read_value(args[0])?;\n                 let r = self.read_value(args[1])?;"}, {"sha": "8bf66999c3decb201c125afd91886ba4a552fe79", "filename": "src/lib.rs", "status": "modified", "additions": 5, "deletions": 71, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d198400f75f82e3df4d771d7093788a33f7c85ee/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d198400f75f82e3df4d771d7093788a33f7c85ee/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d198400f75f82e3df4d771d7093788a33f7c85ee", "patch": "@@ -18,14 +18,11 @@ use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n \n-use rustc_data_structures::fx::FxHasher;\n-\n use syntax::ast::Mutability;\n use syntax::attr;\n \n use std::marker::PhantomData;\n-use std::collections::{HashMap, BTreeMap};\n-use std::hash::{Hash, Hasher};\n+use std::collections::HashMap;\n \n pub use rustc::mir::interpret::*;\n pub use rustc_mir::interpret::*;\n@@ -43,7 +40,7 @@ use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n use operator::EvalContextExt as OperatorEvalContextExt;\n use intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n use tls::EvalContextExt as TlsEvalContextExt;\n-use memory::MemoryKind as MiriMemoryKind;\n+use memory::{MemoryKind as MiriMemoryKind, TlsKey, TlsEntry, MemoryData};\n use locks::LockInfo;\n use range_map::RangeMap;\n use helpers::FalibleScalarExt;\n@@ -63,7 +60,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n     let main_mir = ecx.load_mir(main_instance.def)?;\n \n-    if !main_mir.return_ty().is_nil() || main_mir.arg_count != 0 {\n+    if !main_mir.return_ty().is_unit() || main_mir.arg_count != 0 {\n         return err!(Unimplemented(\n             \"miri does not support main functions without `fn()` type signatures\"\n                 .to_owned(),\n@@ -214,75 +211,12 @@ pub struct Evaluator<'tcx> {\n     _dummy : PhantomData<&'tcx ()>,\n }\n \n-impl<'tcx> Hash for Evaluator<'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        let Evaluator {\n-            env_vars,\n-            _dummy: _,\n-        } = self;\n-\n-        env_vars.iter()\n-            .map(|(env, ptr)| {\n-                let mut h = FxHasher::default();\n-                env.hash(&mut h);\n-                ptr.hash(&mut h);\n-                h.finish()\n-            })\n-            .fold(0u64, |acc, hash| acc.wrapping_add(hash))\n-            .hash(state);\n-    }\n-}\n-\n-pub type TlsKey = u128;\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub struct TlsEntry<'tcx> {\n-    data: Scalar, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n-    dtor: Option<ty::Instance<'tcx>>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq)]\n-pub struct MemoryData<'tcx> {\n-    /// The Key to use for the next thread-local allocation.\n-    next_thread_local: TlsKey,\n-\n-    /// pthreads-style thread-local storage.\n-    thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n-\n-    /// Memory regions that are locked by some function\n-    ///\n-    /// Only mutable (static mut, heap, stack) allocations have an entry in this map.\n-    /// The entry is created when allocating the memory and deleted after deallocation.\n-    locks: HashMap<AllocId, RangeMap<LockInfo<'tcx>>>,\n-}\n-\n-impl<'tcx> MemoryData<'tcx> {\n-    fn new() -> Self {\n-        MemoryData {\n-            next_thread_local: 1, // start with 1 as we must not use 0 on Windows\n-            thread_local: BTreeMap::new(),\n-            locks: HashMap::new(),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Hash for MemoryData<'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        let MemoryData {\n-            next_thread_local: _,\n-            thread_local,\n-            locks: _,\n-        } = self;\n-\n-        thread_local.hash(state);\n-    }\n-}\n-\n impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n-    type MemoryData = MemoryData<'tcx>;\n+    type MemoryData = memory::MemoryData<'tcx>;\n     type MemoryKinds = memory::MemoryKind;\n \n     const MUT_STATIC_KIND: Option<memory::MemoryKind> = Some(memory::MemoryKind::MutStatic);\n+    const DETECT_LOOPS: bool = false;\n \n     /// Returns Ok() when the function was handled, fail otherwise\n     fn find_fn<'a>("}, {"sha": "9f8118a223bc24b9b2a04abd163b69f3d78d146f", "filename": "src/memory.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d198400f75f82e3df4d771d7093788a33f7c85ee/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d198400f75f82e3df4d771d7093788a33f7c85ee/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=d198400f75f82e3df4d771d7093788a33f7c85ee", "patch": "@@ -1,4 +1,44 @@\n-#[derive(Debug, PartialEq, Copy, Clone, Hash, Eq)]\n+use std::collections::{HashMap, BTreeMap};\n+\n+use rustc::ty;\n+\n+use super::{AllocId, Scalar, LockInfo, RangeMap};\n+\n+pub type TlsKey = u128;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct TlsEntry<'tcx> {\n+    pub(crate) data: Scalar, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n+    pub(crate) dtor: Option<ty::Instance<'tcx>>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct MemoryData<'tcx> {\n+    /// The Key to use for the next thread-local allocation.\n+    pub(crate) next_thread_local: TlsKey,\n+\n+    /// pthreads-style thread-local storage.\n+    pub(crate) thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n+\n+    /// Memory regions that are locked by some function\n+    ///\n+    /// Only mutable (static mut, heap, stack) allocations have an entry in this map.\n+    /// The entry is created when allocating the memory and deleted after deallocation.\n+    pub(crate) locks: HashMap<AllocId, RangeMap<LockInfo<'tcx>>>,\n+}\n+\n+impl<'tcx> MemoryData<'tcx> {\n+    pub(crate) fn new() -> Self {\n+        MemoryData {\n+            next_thread_local: 1, // start with 1 as we must not use 0 on Windows\n+            thread_local: BTreeMap::new(),\n+            locks: HashMap::new(),\n+        }\n+    }\n+}\n+\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum MemoryKind {\n     /// `__rust_alloc` memory\n     Rust,"}]}