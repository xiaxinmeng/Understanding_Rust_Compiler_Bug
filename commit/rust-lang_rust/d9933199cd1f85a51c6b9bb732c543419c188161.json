{"sha": "d9933199cd1f85a51c6b9bb732c543419c188161", "node_id": "C_kwDOAAsO6NoAKGQ5OTMzMTk5Y2QxZjg1YTUxYzZiOWJiNzMyYzU0MzQxOWMxODgxNjE", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-10-01T17:01:31Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2023-03-01T00:18:40Z"}, "message": "Merge apply_attrs_callsite into call and invoke\n\nSome codegen backends are not able to apply callsite attrs after the fact.", "tree": {"sha": "e87a0ffa775a3300d89b5a93e2026c978f6ac015", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e87a0ffa775a3300d89b5a93e2026c978f6ac015"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9933199cd1f85a51c6b9bb732c543419c188161", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9933199cd1f85a51c6b9bb732c543419c188161", "html_url": "https://github.com/rust-lang/rust/commit/d9933199cd1f85a51c6b9bb732c543419c188161", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9933199cd1f85a51c6b9bb732c543419c188161/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15b0747049300aca6e90c38b4a25f10cc2f89d29", "url": "https://api.github.com/repos/rust-lang/rust/commits/15b0747049300aca6e90c38b4a25f10cc2f89d29", "html_url": "https://github.com/rust-lang/rust/commit/15b0747049300aca6e90c38b4a25f10cc2f89d29"}], "stats": {"total": 36, "additions": 23, "deletions": 13}, "files": [{"sha": "6fb1cbfad8cd3a422ef427b0797e8ac9af1b97cf", "filename": "src/abi.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9933199cd1f85a51c6b9bb732c543419c188161/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9933199cd1f85a51c6b9bb732c543419c188161/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=d9933199cd1f85a51c6b9bb732c543419c188161", "patch": "@@ -11,10 +11,6 @@ use crate::intrinsic::ArgAbiExt;\n use crate::type_of::LayoutGccExt;\n \n impl<'a, 'gcc, 'tcx> AbiBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn apply_attrs_callsite(&mut self, _fn_abi: &FnAbi<'tcx, Ty<'tcx>>, _callsite: Self::Value) {\n-        // TODO(antoyo)\n-    }\n-\n     fn get_param(&mut self, index: usize) -> Self::Value {\n         let func = self.current_func();\n         let param = func.get_param(index as i32);"}, {"sha": "41e9d61a10e50b53dd5b280cc7c1a1e236d163a8", "filename": "src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9933199cd1f85a51c6b9bb732c543419c188161/src%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9933199cd1f85a51c6b9bb732c543419c188161/src%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fasm.rs?ref=d9933199cd1f85a51c6b9bb732c543419c188161", "patch": "@@ -501,7 +501,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         if options.contains(InlineAsmOptions::NORETURN) {\n             let builtin_unreachable = self.context.get_builtin_function(\"__builtin_unreachable\");\n             let builtin_unreachable: RValue<'gcc> = unsafe { std::mem::transmute(builtin_unreachable) };\n-            self.call(self.type_void(), builtin_unreachable, &[], None);\n+            self.call(self.type_void(), None, builtin_unreachable, &[], None);\n         }\n \n         // Write results to outputs."}, {"sha": "9cf2d6519015d68924490bc38e2d4c5d23a9b795", "filename": "src/builder.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d9933199cd1f85a51c6b9bb732c543419c188161/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9933199cd1f85a51c6b9bb732c543419c188161/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=d9933199cd1f85a51c6b9bb732c543419c188161", "patch": "@@ -455,7 +455,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     #[cfg(feature=\"master\")]\n-    fn invoke(&mut self, typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    fn invoke(&mut self, typ: Type<'gcc>, fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n         let try_block = self.current_func().new_block(\"try\");\n \n         let current_block = self.block.clone();\n@@ -483,10 +483,13 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     #[cfg(not(feature=\"master\"))]\n-    fn invoke(&mut self, typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n-        let call_site = self.call(typ, func, args, None);\n+    fn invoke(&mut self, typ: Type<'gcc>, fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        let call_site = self.call(typ, None, func, args, None);\n         let condition = self.context.new_rvalue_from_int(self.bool_type, 1);\n         self.llbb().end_with_conditional(None, condition, then, catch);\n+        if let Some(_fn_abi) = fn_abi {\n+            // TODO(bjorn3): Apply function attributes\n+        }\n         call_site\n     }\n \n@@ -1359,16 +1362,27 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n-    fn call(&mut self, _typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    fn call(\n+        &mut self,\n+        _typ: Type<'gcc>,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n+        func: RValue<'gcc>,\n+        args: &[RValue<'gcc>],\n+        funclet: Option<&Funclet>,\n+    ) -> RValue<'gcc> {\n         // FIXME(antoyo): remove when having a proper API.\n         let gcc_func = unsafe { std::mem::transmute(func) };\n-        if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {\n+        let call = if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {\n             self.function_call(func, args, funclet)\n         }\n         else {\n             // If it's a not function that was defined, it's a function pointer.\n             self.function_ptr_call(func, args, funclet)\n+        };\n+        if let Some(_fn_abi) = fn_abi {\n+            // TODO(bjorn3): Apply function attributes\n         }\n+        call\n     }\n \n     fn zext(&mut self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {"}, {"sha": "b58381871a9cf933c73cd43f710758df9f8a0231", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9933199cd1f85a51c6b9bb732c543419c188161/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9933199cd1f85a51c6b9bb732c543419c188161/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=d9933199cd1f85a51c6b9bb732c543419c188161", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 _ if simple.is_some() => {\n                     // FIXME(antoyo): remove this cast when the API supports function.\n                     let func = unsafe { std::mem::transmute(simple.expect(\"simple\")) };\n-                    self.call(self.type_void(), func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n+                    self.call(self.type_void(), None, func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n                 },\n                 sym::likely => {\n                     self.expect(args[0].immediate(), true)\n@@ -352,7 +352,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn abort(&mut self) {\n         let func = self.context.get_builtin_function(\"abort\");\n         let func: RValue<'gcc> = unsafe { std::mem::transmute(func) };\n-        self.call(self.type_void(), func, &[], None);\n+        self.call(self.type_void(), None, func, &[], None);\n     }\n \n     fn assume(&mut self, value: Self::Value) {\n@@ -1133,7 +1133,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n fn try_intrinsic<'a, 'b, 'gcc, 'tcx>(bx: &'b mut Builder<'a, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n     if bx.sess().panic_strategy() == PanicStrategy::Abort {\n-        bx.call(bx.type_void(), try_func, &[data], None);\n+        bx.call(bx.type_void(), None, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n         let ret_align = bx.tcx.data_layout.i32_align.abi;"}]}