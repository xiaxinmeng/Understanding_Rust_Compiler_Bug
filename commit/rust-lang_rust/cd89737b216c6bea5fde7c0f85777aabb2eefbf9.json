{"sha": "cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkODk3MzdiMjE2YzZiZWE1ZmRlN2MwZjg1Nzc3YWFiYjJlZWZiZjk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-11T02:34:47Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-11T02:34:47Z"}, "message": "Update for rustc 1.19.0-nightly (4bf5c99af 2017-06-10).", "tree": {"sha": "d9841e43e4f0fe49bfcac17899e9a4e56924f8c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9841e43e4f0fe49bfcac17899e9a4e56924f8c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "html_url": "https://github.com/rust-lang/rust/commit/cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72ed74adfbdf0583525e7d16013a80c00e04b2e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/72ed74adfbdf0583525e7d16013a80c00e04b2e4", "html_url": "https://github.com/rust-lang/rust/commit/72ed74adfbdf0583525e7d16013a80c00e04b2e4"}], "stats": {"total": 205, "additions": 93, "deletions": 112}, "files": [{"sha": "07d838bef2ede9eb9899882cb9c5a83c3ccca73a", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -82,14 +82,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                 if let hir::ExprBinary(binop, ref l, ref r) = rhs.node {\n                     if op.node == binop.node {\n                         let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n-                            let ty = cx.tables.expr_ty(assignee);\n-                            if ty.walk_shallow().next().is_some() {\n-                                return; // implements_trait does not work with generics\n-                            }\n-                            let rty = cx.tables.expr_ty(rhs);\n-                            if rty.walk_shallow().next().is_some() {\n-                                return; // implements_trait does not work with generics\n-                            }\n                             span_lint_and_then(cx,\n                                                MISREFACTORED_ASSIGN_OP,\n                                                expr.span,\n@@ -120,13 +112,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                     #[allow(cyclomatic_complexity)]\n                     let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n                         let ty = cx.tables.expr_ty(assignee);\n-                        if ty.walk_shallow().next().is_some() {\n-                            return; // implements_trait does not work with generics\n-                        }\n                         let rty = cx.tables.expr_ty(rhs);\n-                        if rty.walk_shallow().next().is_some() {\n-                            return; // implements_trait does not work with generics\n-                        }\n                         macro_rules! ops {\n                             ($op:expr,\n                              $cx:expr,\n@@ -152,7 +138,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                             let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) = item.node,\n                                             trait_ref.path.def.def_id() == trait_id\n                                         ], { return; }}\n-                                        implements_trait($cx, $ty, trait_id, &[$rty], None)\n+                                        implements_trait($cx, $ty, trait_id, &[$rty])\n                                     },)*\n                                     _ => false,\n                                 }"}, {"sha": "d8e2f0872630bf20aae3814703826118a7eb0be6", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -136,8 +136,7 @@ fn check_hash_peq<'a, 'tcx>(\n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: ty::Ty<'tcx>) {\n     if match_path_old(&trait_ref.path, &paths::CLONE_TRAIT) {\n-        let def_id = cx.tcx.hir.local_def_id(item.id);\n-        if !is_copy(cx, ty, def_id) {\n+        if !is_copy(cx, ty) {\n             return;\n         }\n "}, {"sha": "c938f17cd4979c08244aed58949582bd5a2f698b", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                    &msg,\n                                    arg.span,\n                                    &format!(\"argument has type {}\", arg_ty.sty));\n-            } else if is_copy(cx, arg_ty, cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(arg.id))) {\n+            } else if is_copy(cx, arg_ty) {\n                 if match_def_path(cx.tcx, def_id, &paths::DROP) {\n                     lint = DROP_COPY;\n                     msg = DROP_COPY_SUMMARY.to_string();"}, {"sha": "12b588967f8a66e7a47de052ebd15ea6aaa6abc7", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EnumGlobUse {\n     fn check_mod(&mut self, cx: &LateContext<'a, 'tcx>, m: &'tcx Mod, _: Span, _: NodeId) {\n         // only check top level `use` statements\n         for item in &m.item_ids {\n-            self.lint_item(cx, cx.krate.item(item.id));\n+            self.lint_item(cx, cx.tcx.hir.expect_item(item.id));\n         }\n     }\n }"}, {"sha": "9eab6352cc2e319e91fbfaa27e83554ea2a3b1c4", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -75,8 +75,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                 BiNe | BiEq => (cx.tcx.lang_items.eq_trait(), true),\n                 BiLt | BiLe | BiGe | BiGt => (cx.tcx.lang_items.ord_trait(), true),\n             };\n-            let parent = cx.tcx.hir.get_parent(e.id);\n-            let parent = cx.tcx.hir.local_def_id(parent);\n             if let Some(trait_id) = trait_id {\n                 #[allow(match_same_arms)]\n                 match (&left.node, &right.node) {\n@@ -87,10 +85,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     (&ExprAddrOf(_, ref l), &ExprAddrOf(_, ref r)) => {\n                         let lty = cx.tables.expr_ty(l);\n                         let rty = cx.tables.expr_ty(r);\n-                        let lcpy = is_copy(cx, lty, parent);\n-                        let rcpy = is_copy(cx, rty, parent);\n+                        let lcpy = is_copy(cx, lty);\n+                        let rcpy = is_copy(cx, rty);\n                         // either operator autorefs or both args are copyable\n-                        if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty], None) {\n+                        if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty]) {\n                             span_lint_and_then(cx,\n                                                OP_REF,\n                                                e.span,\n@@ -104,13 +102,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                                                     (right.span, rsnip)]);\n                             })\n                         } else if lcpy && !rcpy &&\n-                                  implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)], None) {\n+                                  implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)]) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"needlessly taken reference of left operand\", |db| {\n                                 let lsnip = snippet(cx, l.span, \"...\").to_string();\n                                 db.span_suggestion(left.span, \"use the left value directly\", lsnip);\n                             })\n                         } else if !lcpy && rcpy &&\n-                                  implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty], None) {\n+                                  implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty]) {\n                             span_lint_and_then(cx,\n                                                OP_REF,\n                                                e.span,\n@@ -124,9 +122,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     // &foo == bar\n                     (&ExprAddrOf(_, ref l), _) => {\n                         let lty = cx.tables.expr_ty(l);\n-                        let lcpy = is_copy(cx, lty, parent);\n+                        let lcpy = is_copy(cx, lty);\n                         if (requires_ref || lcpy) &&\n-                           implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)], None) {\n+                           implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)]) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"needlessly taken reference of left operand\", |db| {\n                                 let lsnip = snippet(cx, l.span, \"...\").to_string();\n                                 db.span_suggestion(left.span, \"use the left value directly\", lsnip);\n@@ -136,9 +134,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     // foo == &bar\n                     (_, &ExprAddrOf(_, ref r)) => {\n                         let rty = cx.tables.expr_ty(r);\n-                        let rcpy = is_copy(cx, rty, parent);\n+                        let rcpy = is_copy(cx, rty);\n                         if (requires_ref || rcpy) &&\n-                           implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty], None) {\n+                           implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty]) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |db| {\n                                 let rsnip = snippet(cx, r.span, \"...\").to_string();\n                                 db.span_suggestion(right.span, \"use the right value directly\", rsnip);"}, {"sha": "24026f2624acc1f7f50af65a8d53d327799c1484", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -8,7 +8,7 @@ use rustc::ty;\n use rustc::util::nodemap::NodeSet;\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n-use utils::span_lint;\n+use utils::{span_lint, type_size};\n \n pub struct Pass {\n     pub too_large_for_stack: u64,\n@@ -42,9 +42,8 @@ fn is_non_trait_box(ty: ty::Ty) -> bool {\n }\n \n struct EscapeDelegate<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     set: NodeSet,\n-    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n     too_large_for_stack: u64,\n }\n \n@@ -65,19 +64,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         node_id: NodeId\n     ) {\n         let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n-        let param_env = cx.tcx.param_env(fn_def_id).reveal_all();\n         let mut v = EscapeDelegate {\n+            cx: cx,\n             set: NodeSet(),\n-            tcx: cx.tcx,\n-            param_env: param_env,\n             too_large_for_stack: self.too_large_for_stack,\n         };\n \n-        cx.tcx.infer_ctxt(body.id()).enter(|infcx| {\n-            let region_maps = &cx.tcx.region_maps(fn_def_id);\n-            let mut vis = ExprUseVisitor::new(&mut v, region_maps, &infcx, param_env);\n-            vis.consume_body(body);\n-        });\n+        let region_maps = &cx.tcx.region_maps(fn_def_id);\n+        ExprUseVisitor::new(&mut v, cx.tcx, cx.param_env, region_maps, cx.tables)\n+            .consume_body(body);\n \n         for node in v.set {\n             span_lint(cx,\n@@ -88,7 +83,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'gcx> {\n+impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     fn consume(&mut self, _: NodeId, _: Span, cmt: cmt<'tcx>, mode: ConsumeMode) {\n         if let Categorization::Local(lid) = cmt.cat {\n             if let Move(DirectRefMove) = mode {\n@@ -99,7 +94,7 @@ impl<'a, 'gcx: 'tcx, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'gcx> {\n     }\n     fn matched_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: MatchMode) {}\n     fn consume_pat(&mut self, consume_pat: &Pat, cmt: cmt<'tcx>, _: ConsumeMode) {\n-        let map = &self.tcx.hir;\n+        let map = &self.cx.tcx.hir;\n         if map.is_argument(consume_pat.id) {\n             // Skip closure arguments\n             if let Some(NodeExpr(..)) = map.find(map.get_parent_node(consume_pat.id)) {\n@@ -172,18 +167,14 @@ impl<'a, 'gcx: 'tcx, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'gcx> {\n     fn mutate(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: MutateMode) {}\n }\n \n-impl<'a, 'tcx: 'a> EscapeDelegate<'a, 'tcx> {\n-    fn is_large_box(&self, ty: ty::Ty) -> bool {\n+impl<'a, 'tcx> EscapeDelegate<'a, 'tcx> {\n+    fn is_large_box(&self, ty: ty::Ty<'tcx>) -> bool {\n         // Large types need to be boxed to avoid stack\n         // overflows.\n         if ty.is_box() {\n-            if let Some(inner) = self.tcx.lift(&ty.boxed_ty()) {\n-                if let Ok(layout) = inner.layout(self.tcx, self.param_env) {\n-                    return layout.size(self.tcx).bytes() > self.too_large_for_stack;\n-                }\n-            }\n+            type_size(self.cx, ty.boxed_ty()).unwrap_or(0) > self.too_large_for_stack\n+        } else {\n+            false\n         }\n-\n-        false\n     }\n }"}, {"sha": "586bef3aa3af6a6f7bd7e75ba6c0e45e4b251d5a", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -659,7 +659,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             // check conventions w.r.t. conversion method names and predicates\n             let def_id = cx.tcx.hir.local_def_id(item.id);\n             let ty = cx.tcx.type_of(def_id);\n-            let is_copy = is_copy(cx, ty, def_id);\n+            let is_copy = is_copy(cx, ty);\n             for &(ref conv, self_kinds) in &CONVENTIONS {\n                 if_let_chain! {[\n                     conv.check(&name.as_str()),\n@@ -684,9 +684,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             }\n \n             let ret_ty = return_ty(cx, implitem.id);\n-            let implitem_defid = cx.tcx.hir.local_def_id(implitem.id);\n             if name == \"new\" &&\n-               !ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem_defid)) {\n+               !ret_ty.walk().any(|t| same_tys(cx, t, ty)) {\n                 span_lint(cx,\n                           NEW_RET_NO_SELF,\n                           implitem.span,\n@@ -725,7 +724,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n                         return false;\n                     };\n \n-                    if implements_trait(cx, arg_ty, default_trait_id, &[], None) {\n+                    if implements_trait(cx, arg_ty, default_trait_id, &[]) {\n                         span_lint_and_then(cx,\n                                            OR_FUN_CALL,\n                                            span,\n@@ -822,7 +821,6 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n /// Checks for the `CLONE_ON_COPY` lint.\n fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: ty::Ty) {\n     let ty = cx.tables.expr_ty(expr);\n-    let parent = cx.tcx.hir.get_parent(expr.id);\n     if let ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) = arg_ty.sty {\n         if let ty::TyRef(..) = inner.sty {\n             span_lint_and_then(cx,\n@@ -839,7 +837,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n         }\n     }\n \n-    if is_copy(cx, ty, cx.tcx.hir.local_def_id(parent)) {\n+    if is_copy(cx, ty) {\n         span_lint_and_then(cx,\n                            CLONE_ON_COPY,\n                            expr.span,\n@@ -1268,7 +1266,7 @@ fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n /// This checks whether a given type is known to implement Debug.\n fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n     match cx.tcx.lang_items.debug_trait() {\n-        Some(debug) => implements_trait(cx, ty, debug, &[], None),\n+        Some(debug) => implements_trait(cx, ty, debug, &[]),\n         None => false,\n     }\n }"}, {"sha": "fda048110fe4641e460adfb108677fc458a20477", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -455,13 +455,13 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n     // *arg impls PartialEq<other>\n     if !arg_ty\n         .builtin_deref(true, ty::LvaluePreference::NoPreference)\n-        .map_or(false, |tam| implements_trait(cx, tam.ty, partial_eq_trait_id, &[other_ty], None))\n+        .map_or(false, |tam| implements_trait(cx, tam.ty, partial_eq_trait_id, &[other_ty]))\n         // arg impls PartialEq<*other>\n         && !other_ty\n         .builtin_deref(true, ty::LvaluePreference::NoPreference)\n-        .map_or(false, |tam| implements_trait(cx, arg_ty, partial_eq_trait_id, &[tam.ty], None))\n+        .map_or(false, |tam| implements_trait(cx, arg_ty, partial_eq_trait_id, &[tam.ty]))\n         // arg impls PartialEq<other>\n-        && !implements_trait(cx, arg_ty, partial_eq_trait_id, &[other_ty], None) {\n+        && !implements_trait(cx, arg_ty, partial_eq_trait_id, &[other_ty]) {\n         return;\n     }\n "}, {"sha": "fda67f3202d5ff144e25f5a302fa0084891959f1", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -82,21 +82,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n \n         let preds: Vec<ty::Predicate> = {\n-            let parameter_env = cx.tcx.param_env(fn_def_id);\n-            traits::elaborate_predicates(cx.tcx, parameter_env.caller_bounds.to_vec())\n+            traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.to_vec())\n                 .filter(|p| !p.is_global())\n                 .collect()\n         };\n \n         // Collect moved variables and spans which will need dereferencings from the function body.\n         let MovedVariablesCtxt { moved_vars, spans_need_deref, .. } = {\n             let mut ctx = MovedVariablesCtxt::new(cx);\n-            cx.tcx.infer_ctxt(body.id()).enter(|infcx| {\n-                let param_env = cx.tcx.param_env(fn_def_id);\n-                let region_maps = &cx.tcx.region_maps(fn_def_id);\n-                euv::ExprUseVisitor::new(&mut ctx, region_maps, &infcx, param_env)\n-                    .consume_body(body);\n-            });\n+            let region_maps = &cx.tcx.region_maps(fn_def_id);\n+            euv::ExprUseVisitor::new(&mut ctx, cx.tcx, cx.param_env, region_maps, cx.tables)\n+                .consume_body(body);\n             ctx\n         };\n \n@@ -119,9 +115,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n             if_let_chain! {[\n                 !is_self(arg),\n                 !ty.is_mutable_pointer(),\n-                !is_copy(cx, ty, fn_def_id),\n-                !implements_trait(cx, ty, fn_trait, &[], Some(node_id)),\n-                !implements_trait(cx, ty, asref_trait, &[], Some(node_id)),\n+                !is_copy(cx, ty),\n+                !implements_trait(cx, ty, fn_trait, &[]),\n+                !implements_trait(cx, ty, asref_trait, &[]),\n                 !implements_borrow_trait,\n \n                 let PatKind::Binding(mode, defid, ..) = arg.pat.node,\n@@ -190,7 +186,7 @@ struct MovedVariablesCtxt<'a, 'tcx: 'a> {\n     spans_need_deref: HashMap<DefId, HashSet<Span>>,\n }\n \n-impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n     fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n         MovedVariablesCtxt {\n             cx: cx,\n@@ -199,7 +195,7 @@ impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn move_common(&mut self, _consume_id: NodeId, _span: Span, cmt: mc::cmt) {\n+    fn move_common(&mut self, _consume_id: NodeId, _span: Span, cmt: mc::cmt<'tcx>) {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n         if_let_chain! {[\n@@ -210,7 +206,7 @@ impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n         }}\n     }\n \n-    fn non_moving_pat(&mut self, matched_pat: &Pat, cmt: mc::cmt) {\n+    fn non_moving_pat(&mut self, matched_pat: &Pat, cmt: mc::cmt<'tcx>) {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n         if_let_chain! {[\n@@ -262,7 +258,7 @@ impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'gcx> {\n+impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n     fn consume(&mut self, consume_id: NodeId, consume_span: Span, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n         if let euv::ConsumeMode::Move(_) = mode {\n             self.move_common(consume_id, consume_span, cmt);"}, {"sha": "0d102164ebc09a2e96c006fde1cb88b4949a2b37", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -108,15 +108,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                 // can't be implemented by default\n                 return;\n             }\n-            let def_id = cx.tcx.hir.local_def_id(id);\n             if decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n                 let self_ty = cx.tcx\n                     .type_of(cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id)));\n                 if_let_chain!{[\n-                    self_ty.walk_shallow().next().is_none(), // implements_trait does not work with generics\n-                    same_tys(cx, self_ty, return_ty(cx, id), def_id),\n+                    same_tys(cx, self_ty, return_ty(cx, id)),\n                     let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT),\n-                    !implements_trait(cx, self_ty, default_trait_id, &[], None)\n+                    !implements_trait(cx, self_ty, default_trait_id, &[])\n                 ], {\n                     if let Some(sp) = can_derive_default(self_ty, cx, default_trait_id) {\n                         span_lint_and_then(cx,\n@@ -157,7 +155,7 @@ fn can_derive_default<'t, 'c>(ty: ty::Ty<'t>, cx: &LateContext<'c, 't>, default_\n         ty::TyAdt(adt_def, substs) if adt_def.is_struct() => {\n             for field in adt_def.all_fields() {\n                 let f_ty = field.ty(cx.tcx, substs);\n-                if !implements_trait(cx, f_ty, default_trait_id, &[], None) {\n+                if !implements_trait(cx, f_ty, default_trait_id, &[]) {\n                     return None;\n                 }\n             }"}, {"sha": "ea79a77877a0ecb61a7ffac19a59f9a5a1c8110b", "filename": "clippy_lints/src/should_assert_eq.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fshould_assert_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fshould_assert_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshould_assert_eq.rs?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -49,10 +49,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ShouldAssertEq {\n             let ty1 = cx.tables.expr_ty(expr1);\n             let ty2 = cx.tables.expr_ty(expr2);\n \n-            let parent = cx.tcx.hir.get_parent(e.id);\n-\n-            if implements_trait(cx, ty1, debug_trait, &[], Some(parent)) &&\n-                implements_trait(cx, ty2, debug_trait, &[], Some(parent)) {\n+            if implements_trait(cx, ty1, debug_trait, &[]) &&\n+                implements_trait(cx, ty2, debug_trait, &[]) {\n                 span_lint(cx, SHOULD_ASSERT_EQ, e.span, &format!(\"use `{}{}` for better reporting\", debug, sugg));\n             }\n         }}"}, {"sha": "9833cc537939a29cd6c10f6c0fdf58aa232e0f00", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -5,9 +5,7 @@ use rustc::hir::def::Def;\n use rustc::hir::map::Node;\n use rustc::lint::{LintContext, LateContext, Level, Lint};\n use rustc::session::Session;\n-use rustc::traits::Reveal;\n use rustc::traits;\n-use rustc::ty::subst::{Subst, Substs};\n use rustc::ty;\n use rustc::mir::transform::MirSource;\n use rustc_errors;\n@@ -312,20 +310,12 @@ pub fn implements_trait<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     ty: ty::Ty<'tcx>,\n     trait_id: DefId,\n-    ty_params: &[ty::Ty<'tcx>],\n-    parent_node_id: Option<NodeId>\n+    ty_params: &[ty::Ty<'tcx>]\n ) -> bool {\n     let ty = cx.tcx.erase_regions(&ty);\n-    let param_env = if let Some(id) = parent_node_id {\n-        let def_id = cx.tcx.hir.body_owner_def_id(BodyId { node_id: id });\n-        cx.tcx.param_env(def_id).reveal_all()\n-    } else {\n-        ty::ParamEnv::empty(Reveal::All)\n-    };\n-    cx.tcx.infer_ctxt(()).enter(|infcx| {\n-        let obligation = cx.tcx.predicate_for_trait_def(\n-            param_env, traits::ObligationCause::dummy(), trait_id, 0, ty, ty_params);\n-\n+    let obligation = cx.tcx.predicate_for_trait_def(\n+        cx.param_env, traits::ObligationCause::dummy(), trait_id, 0, ty, ty_params);\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n         traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n     })\n }\n@@ -776,12 +766,10 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> ty::T\n pub fn same_tys<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     a: ty::Ty<'tcx>,\n-    b: ty::Ty<'tcx>,\n-    parameter_item: DefId\n+    b: ty::Ty<'tcx>\n ) -> bool {\n-    let param_env = cx.tcx.param_env(parameter_item).reveal_all();\n-    cx.tcx.infer_ctxt(()).enter(|infcx| {\n-        infcx.can_eq(param_env, a, b).is_ok()\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n+        infcx.can_eq(cx.param_env, a, b).is_ok()\n     })\n }\n \n@@ -794,10 +782,8 @@ pub fn type_is_unsafe_function(ty: ty::Ty) -> bool {\n     }\n }\n \n-pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, env: DefId) -> bool {\n-    let substs = Substs::identity_for_item(cx.tcx, env);\n-    let env = cx.tcx.param_env(env);\n-    !ty.subst(cx.tcx, substs).moves_by_default(cx.tcx.global_tcx(), env, DUMMY_SP)\n+pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>) -> bool {\n+    !ty.moves_by_default(cx.tcx.global_tcx(), cx.param_env, DUMMY_SP)\n }\n \n /// Return whether a pattern is refutable.\n@@ -959,6 +945,5 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n }\n \n pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>) -> Option<u64> {\n-    ty.layout(cx.tcx, ty::ParamEnv::empty(Reveal::All))\n-      .ok().map(|layout| layout.size(cx.tcx).bytes())\n+    ty.layout(cx.tcx, cx.param_env).ok().map(|layout| layout.size(cx.tcx).bytes())\n }"}, {"sha": "369c27d357fd92d3e5960fa2d85a18f11fbf65de", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if_let_chain!{[\n             let Some((_, arg, _)) = higher::for_loop(expr),\n             let Some(vec_args) = higher::vec_macro(cx, arg),\n-            is_copy(cx, vec_type(cx.tables.expr_ty_adjusted(arg)), cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(expr.id))),\n+            is_copy(cx, vec_type(cx.tables.expr_ty_adjusted(arg))),\n         ], {\n             // report the error around the `vec!` not inside `<std macros>:`\n             let span = arg.span.ctxt.outer().expn_info().map(|info| info.call_site).expect(\"unable to get call_site\");"}, {"sha": "8e399b90d9d2244a4775a70387e3d5c590a38b25", "filename": "clippy_tests/examples/assign_ops.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_tests%2Fexamples%2Fassign_ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_tests%2Fexamples%2Fassign_ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fassign_ops.stderr?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -166,6 +166,14 @@ error: manual implementation of an assign operation\n    |\n    = note: `-D assign-op-pattern` implied by `-D warnings`\n \n+error: manual implementation of an assign operation\n+  --> assign_ops.rs:40:5\n+   |\n+40 |     s = s + \"bla\";\n+   |     ^^^^^^^^^^^^^ help: replace it with `s += \"bla\"`\n+   |\n+   = note: `-D assign-op-pattern` implied by `-D warnings`\n+\n error: aborting due to previous error(s)\n \n error: Could not compile `clippy_tests`."}, {"sha": "2b0e4dcdf1b34ffd951de509b7735579d6db9504", "filename": "clippy_tests/examples/strings.stderr", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_tests%2Fexamples%2Fstrings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd89737b216c6bea5fde7c0f85777aabb2eefbf9/clippy_tests%2Fexamples%2Fstrings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fstrings.stderr?ref=cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "patch": "@@ -1,3 +1,11 @@\n+error: manual implementation of an assign operation\n+  --> strings.rs:10:9\n+   |\n+10 |         x = x + \".\";\n+   |         ^^^^^^^^^^^ help: replace it with `x += \".\"`\n+   |\n+   = note: `-D assign-op-pattern` implied by `-D warnings`\n+\n error: you added something to a string. Consider using `String::push_str()` instead\n   --> strings.rs:10:13\n    |\n@@ -22,6 +30,14 @@ error: you assigned the result of adding something to this string. Consider usin\n    |\n    = note: `-D string-add-assign` implied by `-D warnings`\n \n+error: manual implementation of an assign operation\n+  --> strings.rs:24:9\n+   |\n+24 |         x = x + \".\";\n+   |         ^^^^^^^^^^^ help: replace it with `x += \".\"`\n+   |\n+   = note: `-D assign-op-pattern` implied by `-D warnings`\n+\n error: you assigned the result of adding something to this string. Consider using `String::push_str()` instead\n   --> strings.rs:38:9\n    |\n@@ -30,6 +46,14 @@ error: you assigned the result of adding something to this string. Consider usin\n    |\n    = note: `-D string-add-assign` implied by `-D warnings`\n \n+error: manual implementation of an assign operation\n+  --> strings.rs:38:9\n+   |\n+38 |         x = x + \".\";\n+   |         ^^^^^^^^^^^ help: replace it with `x += \".\"`\n+   |\n+   = note: `-D assign-op-pattern` implied by `-D warnings`\n+\n error: you added something to a string. Consider using `String::push_str()` instead\n   --> strings.rs:42:13\n    |"}]}