{"sha": "789abf063d04684cea85c8fe4adb3233249da7e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4OWFiZjA2M2QwNDY4NGNlYTg1YzhmZTRhZGIzMjMzMjQ5ZGE3ZTg=", "commit": {"author": {"name": "Seiichi Uchida", "email": "topecongiro@localhost.localdomain", "date": "2017-06-01T03:07:10Z"}, "committer": {"name": "Seiichi Uchida", "email": "topecongiro@localhost.localdomain", "date": "2017-06-01T03:08:20Z"}, "message": "Use block indent style when visual indent failed", "tree": {"sha": "7cd4b56c473c8faa54b156871b7a3eebba10020a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cd4b56c473c8faa54b156871b7a3eebba10020a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/789abf063d04684cea85c8fe4adb3233249da7e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/789abf063d04684cea85c8fe4adb3233249da7e8", "html_url": "https://github.com/rust-lang/rust/commit/789abf063d04684cea85c8fe4adb3233249da7e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/789abf063d04684cea85c8fe4adb3233249da7e8/comments", "author": null, "committer": null, "parents": [{"sha": "f6e8e9facc5b64a426ca7b95d69459c56035d7b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e8e9facc5b64a426ca7b95d69459c56035d7b4", "html_url": "https://github.com/rust-lang/rust/commit/f6e8e9facc5b64a426ca7b95d69459c56035d7b4"}], "stats": {"total": 127, "additions": 105, "deletions": 22}, "files": [{"sha": "69f62319ade22b775750c941795524477c215aeb", "filename": "src/expr.rs", "status": "modified", "additions": 46, "deletions": 22, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/789abf063d04684cea85c8fe4adb3233249da7e8/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789abf063d04684cea85c8fe4adb3233249da7e8/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=789abf063d04684cea85c8fe4adb3233249da7e8", "patch": "@@ -599,11 +599,14 @@ fn rewrite_closure(capture: ast::CaptureBy,\n                              -> Option<String> {\n         // Start with visual indent, then fall back to block indent if the\n         // closure is large.\n-        if let Some(block_str) = block.rewrite(&context, shape) {\n-            let block_threshold = context.config.closure_block_indent_threshold();\n-            if block_threshold < 0 || block_str.matches('\\n').count() <= block_threshold as usize {\n-                if let Some(block_str) = block_str.rewrite(context, shape) {\n-                    return Some(format!(\"{} {}\", prefix, block_str));\n+        let block_threshold = context.config.closure_block_indent_threshold();\n+        if block_threshold >= 0 {\n+            if let Some(block_str) = block.rewrite(&context, shape) {\n+                if block_str.matches('\\n').count() <= block_threshold as usize &&\n+                   !need_block_indent(&block_str, shape) {\n+                    if let Some(block_str) = block_str.rewrite(context, shape) {\n+                        return Some(format!(\"{} {}\", prefix, block_str));\n+                    }\n                 }\n             }\n         }\n@@ -1676,20 +1679,40 @@ fn rewrite_call_inner(context: &RewriteContext,\n         .ok_or(Ordering::Greater)?;\n \n     let span_lo = context.codemap.span_after(span, \"(\");\n-    let span = mk_sp(span_lo, span.hi);\n+    let new_span = mk_sp(span_lo, span.hi);\n \n     let (extendable, list_str) = rewrite_call_args(context,\n                                                    args,\n-                                                   span,\n+                                                   new_span,\n                                                    nested_shape,\n                                                    one_line_width,\n                                                    force_trailing_comma)\n         .ok_or(Ordering::Less)?;\n+\n+    if !use_block_indent(context) && need_block_indent(&list_str, nested_shape) && !extendable {\n+        println!(\"here\");\n+        let mut new_context = context.clone();\n+        new_context.use_block = true;\n+        return rewrite_call_inner(&new_context,\n+                                  callee_str,\n+                                  args,\n+                                  span,\n+                                  shape,\n+                                  force_trailing_comma);\n+    }\n+\n     Ok(format!(\"{}{}\",\n                callee_str,\n                wrap_args_with_parens(context, &list_str, extendable, shape, nested_shape)))\n }\n \n+fn need_block_indent(s: &str, shape: Shape) -> bool {\n+    s.lines().skip(1).any(|s| {\n+                              s.find(|c| !char::is_whitespace(c))\n+                                  .map_or(false, |w| w + 1 < shape.indent.width())\n+                          })\n+}\n+\n fn rewrite_call_args(context: &RewriteContext,\n                      args: &[ptr::P<ast::Expr>],\n                      span: Span,\n@@ -1720,8 +1743,7 @@ fn rewrite_call_args(context: &RewriteContext,\n     // Replace the last item with its first line to see if it fits with\n     // first arguments.\n     if overflow_last {\n-        let arg_shape = if context.config.fn_call_style() == IndentStyle::Block &&\n-                           is_extendable(args) {\n+        let arg_shape = if use_block_indent(context) && is_extendable(args) {\n             Shape {\n                 width: context.config.fn_call_width(),\n                 indent: shape.block().indent.block_unindent(context.config),\n@@ -1799,8 +1821,7 @@ fn rewrite_call_args(context: &RewriteContext,\n         // If arguments do not fit in a single line and do not contain newline,\n         // try to put it on the next line. Try this only when we are in block mode\n         // and not rewriting macro.\n-        Some(ref s) if context.config.fn_call_style() == IndentStyle::Block &&\n-                       !context.inside_macro &&\n+        Some(ref s) if use_block_indent(context) && !context.inside_macro &&\n                        ((!can_be_overflowed(context, args) && last_char_is_not_comma &&\n                          s.contains('\\n')) ||\n                         first_line_width(s) > one_line_budget) => {\n@@ -1814,23 +1835,25 @@ fn rewrite_call_args(context: &RewriteContext,\n     }\n }\n \n+fn use_block_indent(context: &RewriteContext) -> bool {\n+    context.config.fn_call_style() == IndentStyle::Block || context.use_block\n+}\n+\n fn can_be_overflowed(context: &RewriteContext, args: &[ptr::P<ast::Expr>]) -> bool {\n     match args.last().map(|x| &x.node) {\n         Some(&ast::ExprKind::Match(..)) => {\n-            (context.config.fn_call_style() == IndentStyle::Block && args.len() == 1) ||\n+            (use_block_indent(context) && args.len() == 1) ||\n             (context.config.fn_call_style() == IndentStyle::Visual && args.len() > 1)\n         }\n         Some(&ast::ExprKind::Block(..)) |\n         Some(&ast::ExprKind::Closure(..)) => {\n-            context.config.fn_call_style() == IndentStyle::Block ||\n+            use_block_indent(context) ||\n             context.config.fn_call_style() == IndentStyle::Visual && args.len() > 1\n         }\n         Some(&ast::ExprKind::Call(..)) |\n         Some(&ast::ExprKind::Mac(..)) |\n-        Some(&ast::ExprKind::Struct(..)) => {\n-            context.config.fn_call_style() == IndentStyle::Block && args.len() == 1\n-        }\n-        Some(&ast::ExprKind::Tup(..)) => context.config.fn_call_style() == IndentStyle::Block,\n+        Some(&ast::ExprKind::Struct(..)) => use_block_indent(context) && args.len() == 1,\n+        Some(&ast::ExprKind::Tup(..)) => use_block_indent(context),\n         _ => false,\n     }\n }\n@@ -1865,8 +1888,8 @@ fn wrap_args_with_parens(context: &RewriteContext,\n                          shape: Shape,\n                          nested_shape: Shape)\n                          -> String {\n-    if context.config.fn_call_style() == IndentStyle::Visual ||\n-       (context.inside_macro && !args_str.contains('\\n')) || is_extendable {\n+    if !use_block_indent(context) || (context.inside_macro && !args_str.contains('\\n')) ||\n+       is_extendable {\n         if context.config.spaces_within_parens() && args_str.len() > 0 {\n             format!(\"( {} )\", args_str)\n         } else {\n@@ -2062,9 +2085,10 @@ fn shape_from_fn_call_style(context: &RewriteContext,\n                             overhead: usize,\n                             offset: usize)\n                             -> Option<Shape> {\n-    match context.config.fn_call_style() {\n-        IndentStyle::Block => Some(shape.block().block_indent(context.config.tab_spaces())),\n-        IndentStyle::Visual => shape.visual_indent(offset).sub_width(overhead),\n+    if use_block_indent(context) {\n+        Some(shape.block().block_indent(context.config.tab_spaces()))\n+    } else {\n+        shape.visual_indent(offset).sub_width(overhead)\n     }\n }\n "}, {"sha": "272e67756abb7b4e572919520147c14c20978cac", "filename": "src/rewrite.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/789abf063d04684cea85c8fe4adb3233249da7e8/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789abf063d04684cea85c8fe4adb3233249da7e8/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=789abf063d04684cea85c8fe4adb3233249da7e8", "patch": "@@ -27,6 +27,7 @@ pub struct RewriteContext<'a> {\n     pub codemap: &'a CodeMap,\n     pub config: &'a Config,\n     pub inside_macro: bool,\n+    pub use_block: bool,\n }\n \n impl<'a> RewriteContext<'a> {"}, {"sha": "affcbf6b082dbf9d977fa9315875a43307213e06", "filename": "src/visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/789abf063d04684cea85c8fe4adb3233249da7e8/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789abf063d04684cea85c8fe4adb3233249da7e8/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=789abf063d04684cea85c8fe4adb3233249da7e8", "patch": "@@ -610,6 +610,7 @@ impl<'a> FmtVisitor<'a> {\n             codemap: self.codemap,\n             config: self.config,\n             inside_macro: false,\n+            use_block: false,\n         }\n     }\n }"}, {"sha": "7dd75c52891fae82f13634ecf6e1ad0fe51b1aa7", "filename": "tests/target/nested-visual-block.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/789abf063d04684cea85c8fe4adb3233249da7e8/tests%2Ftarget%2Fnested-visual-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789abf063d04684cea85c8fe4adb3233249da7e8/tests%2Ftarget%2Fnested-visual-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fnested-visual-block.rs?ref=789abf063d04684cea85c8fe4adb3233249da7e8", "patch": "@@ -0,0 +1,57 @@\n+fn main() {\n+    // #1078\n+    let items = itemize_list(\n+        context.codemap,\n+        field_iter,\n+        \"}\",\n+        |item| match *item {\n+            StructLitField::Regular(ref field) => field.span.lo,\n+            StructLitField::Base(ref expr) => {\n+                let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n+                let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n+                let pos = snippet.find_uncommented(\"..\").unwrap();\n+                last_field_hi + BytePos(pos as u32)\n+            }\n+        },\n+        |item| match *item {\n+            StructLitField::Regular(ref field) => field.span.hi,\n+            StructLitField::Base(ref expr) => expr.span.hi,\n+        },\n+        |item| {\n+            match *item {\n+                StructLitField::Regular(ref field) => {\n+                    rewrite_field(inner_context,\n+                                  &field,\n+                                  &Constraints::new(v_budget.checked_sub(1).unwrap_or(0), indent))\n+                }\n+                StructLitField::Base(ref expr) => {\n+                    // 2 = ..\n+                    expr.rewrite(inner_context,\n+                                 &Constraints::new(try_opt!(v_budget.checked_sub(2)), indent + 2))\n+                        .map(|s| format!(\"..{}\", s))\n+                }\n+            }\n+        },\n+        context.codemap.span_after(span, \"{\"),\n+        span.hi,\n+    );\n+\n+    // #1580\n+    self.0.pool.execute(move || {\n+        let _timer = segments.0.rotate_timer.time();\n+        if let Err(e) = segments.rotate_async(wal) {\n+            error!(\"error compacting segment storage WAL\", unsafe { error: e.display() });\n+        }\n+    });\n+\n+    // #1581\n+    bootstrap.checks.register(\n+        \"PERSISTED_LOCATIONS\",\n+        move || if locations2.0.inner_mut.lock().poisoned {\n+            Check::new(State::Error,\n+                       \"Persisted location storage is poisoned due to a write failure\")\n+        } else {\n+            Check::new(State::Healthy, \"Persisted location storage is healthy\")\n+        }\n+    );\n+}"}]}