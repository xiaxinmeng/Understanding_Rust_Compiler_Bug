{"sha": "4038189688ce2705d41bec97238715aa17f44c1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMzgxODk2ODhjZTI3MDVkNDFiZWM5NzIzODcxNWFhMTdmNDRjMWQ=", "commit": {"author": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-09-24T20:06:38Z"}, "committer": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-09-24T22:21:12Z"}, "message": "Optimize struct_field_ptr", "tree": {"sha": "375389db08a4f92d94be32601f0b1e4f4ecf9e07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/375389db08a4f92d94be32601f0b1e4f4ecf9e07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4038189688ce2705d41bec97238715aa17f44c1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4038189688ce2705d41bec97238715aa17f44c1d", "html_url": "https://github.com/rust-lang/rust/commit/4038189688ce2705d41bec97238715aa17f44c1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4038189688ce2705d41bec97238715aa17f44c1d/comments", "author": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f16068e577a916122ff1f24719aad2b80e40c975", "url": "https://api.github.com/repos/rust-lang/rust/commits/f16068e577a916122ff1f24719aad2b80e40c975", "html_url": "https://github.com/rust-lang/rust/commit/f16068e577a916122ff1f24719aad2b80e40c975"}], "stats": {"total": 88, "additions": 11, "deletions": 77}, "files": [{"sha": "9bc1c1bc960d92c8811f4e9df89219f9efb50d82", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4038189688ce2705d41bec97238715aa17f44c1d/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4038189688ce2705d41bec97238715aa17f44c1d/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=4038189688ce2705d41bec97238715aa17f44c1d", "patch": "@@ -650,6 +650,15 @@ impl<'a, 'gcx, 'tcx> Struct {\n         }\n         Ok(None)\n     }\n+\n+    pub fn offset_of_field(&self, index: usize) -> Size {\n+        assert!(index < self.offset_after_field.len());\n+        if index == 0 {\n+            Size::from_bytes(0)\n+        } else {\n+            self.offset_after_field[index-1]\n+        }\n+    }\n }\n \n /// An untagged union."}, {"sha": "c7528c0cf69e575d26c29ea9c8ed364a956e8ffd", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 2, "deletions": 70, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4038189688ce2705d41bec97238715aa17f44c1d/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4038189688ce2705d41bec97238715aa17f44c1d/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=4038189688ce2705d41bec97238715aa17f44c1d", "patch": "@@ -41,7 +41,6 @@\n //!   used unboxed and any field can have pointers (including mutable)\n //!   taken to it, implementing them for Rust seems difficult.\n \n-pub use self::Repr::*;\n use super::Disr;\n \n use std;\n@@ -50,7 +49,6 @@ use llvm::{ValueRef, True, IntEQ, IntNE};\n use rustc::ty::layout;\n use rustc::ty::{self, Ty, AdtKind};\n use syntax::attr;\n-use syntax::attr::IntType;\n use build::*;\n use common::*;\n use debuginfo::DebugLoc;\n@@ -70,66 +68,6 @@ pub enum BranchKind {\n \n type Hint = attr::ReprAttr;\n \n-/// Representations.\n-#[derive(Eq, PartialEq, Debug)]\n-pub enum Repr<'tcx> {\n-    /// C-like enums; basically an int.\n-    CEnum(IntType, Disr, Disr), // discriminant range (signedness based on the IntType)\n-    /// Single-case variants, and structs/tuples/records.\n-    Univariant(Struct<'tcx>),\n-    /// Untagged unions.\n-    UntaggedUnion(Union<'tcx>),\n-    /// General-case enums: for each case there is a struct, and they\n-    /// all start with a field for the discriminant.\n-    General(IntType, Vec<Struct<'tcx>>),\n-    /// Two cases distinguished by a nullable pointer: the case with discriminant\n-    /// `nndiscr` must have single field which is known to be nonnull due to its type.\n-    /// The other case is known to be zero sized. Hence we represent the enum\n-    /// as simply a nullable pointer: if not null it indicates the `nndiscr` variant,\n-    /// otherwise it indicates the other case.\n-    RawNullablePointer {\n-        nndiscr: Disr,\n-        nnty: Ty<'tcx>,\n-        nullfields: Vec<Ty<'tcx>>\n-    },\n-    /// Two cases distinguished by a nullable pointer: the case with discriminant\n-    /// `nndiscr` is represented by the struct `nonnull`, where the `discrfield`th\n-    /// field is known to be nonnull due to its type; if that field is null, then\n-    /// it represents the other case, which is inhabited by at most one value\n-    /// (and all other fields are undefined/unused).\n-    ///\n-    /// For example, `std::option::Option` instantiated at a safe pointer type\n-    /// is represented such that `None` is a null pointer and `Some` is the\n-    /// identity function.\n-    StructWrappedNullablePointer {\n-        nonnull: Struct<'tcx>,\n-        nndiscr: Disr,\n-        discrfield: DiscrField,\n-        nullfields: Vec<Ty<'tcx>>,\n-    }\n-}\n-\n-/// For structs, and struct-like parts of anything fancier.\n-#[derive(Eq, PartialEq, Debug)]\n-pub struct Struct<'tcx> {\n-    // If the struct is DST, then the size and alignment do not take into\n-    // account the unsized fields of the struct.\n-    pub size: u64,\n-    pub align: u32,\n-    pub sized: bool,\n-    pub packed: bool,\n-    pub fields: Vec<Ty<'tcx>>,\n-}\n-\n-/// For untagged unions.\n-#[derive(Eq, PartialEq, Debug)]\n-pub struct Union<'tcx> {\n-    pub min_size: u64,\n-    pub align: u32,\n-    pub packed: bool,\n-    pub fields: Vec<Ty<'tcx>>,\n-}\n-\n #[derive(Copy, Clone)]\n pub struct MaybeSizedValue {\n     pub value: ValueRef,\n@@ -696,14 +634,8 @@ fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n \n     let meta = val.meta;\n \n-    // Calculate the unaligned offset of the unsized field.\n-    let mut offset = 0;\n-    for &ty in &fields[0..ix] {\n-        let llty = type_of::sizing_type_of(ccx, ty);\n-        let type_align = type_of::align_of(ccx, ty);\n-        offset = roundup(offset, type_align);\n-        offset += machine::llsize_of_alloc(ccx, llty);\n-    }\n+\n+    let offset = st.offset_of_field(ix).bytes();\n     let unaligned_offset = C_uint(bcx.ccx(), offset);\n \n     // Get the alignment of the field"}, {"sha": "1b67516a9e6d0f025b254f91ee7a0558624c1fef", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4038189688ce2705d41bec97238715aa17f44c1d/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4038189688ce2705d41bec97238715aa17f44c1d/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=4038189688ce2705d41bec97238715aa17f44c1d", "patch": "@@ -17,7 +17,6 @@ use rustc::hir::def_id::DefId;\n use rustc::traits;\n use rustc::mir::mir_map::MirMap;\n use rustc::mir::repr as mir;\n-use adt;\n use base;\n use builder::Builder;\n use common::BuilderRef_res;\n@@ -142,7 +141,6 @@ pub struct LocalCrateContext<'tcx> {\n \n     lltypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n     llsizingtypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n-    adt_reprs: RefCell<FnvHashMap<Ty<'tcx>, Rc<adt::Repr<'tcx>>>>,\n     type_hashcodes: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n@@ -677,7 +675,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 statics_to_rauw: RefCell::new(Vec::new()),\n                 lltypes: RefCell::new(FnvHashMap()),\n                 llsizingtypes: RefCell::new(FnvHashMap()),\n-                adt_reprs: RefCell::new(FnvHashMap()),\n                 type_hashcodes: RefCell::new(FnvHashMap()),\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n@@ -918,10 +915,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().llsizingtypes\n     }\n \n-    pub fn adt_reprs<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Rc<adt::Repr<'tcx>>>> {\n-        &self.local().adt_reprs\n-    }\n-\n     pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n         &self.shared.symbol_hasher\n     }"}]}