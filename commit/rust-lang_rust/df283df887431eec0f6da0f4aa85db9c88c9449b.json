{"sha": "df283df887431eec0f6da0f4aa85db9c88c9449b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMjgzZGY4ODc0MzFlZWMwZjZkYTBmNGFhODVkYjljODhjOTQ0OWI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2018-02-21T21:02:52Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:34:18Z"}, "message": "Don't use the undefined bytes of PrimVal::Bytes", "tree": {"sha": "777db3042d7a0586a18c47d5417a8df784620a23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/777db3042d7a0586a18c47d5417a8df784620a23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df283df887431eec0f6da0f4aa85db9c88c9449b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg53oACgkQpp+NIls6\n19kRDA//R7pFVG997kSsUKJz6+ljb+iShtnDX/rN8/uFELehR0EdPM83gWoZu7oW\no3Qtc1YSOyGlAMaaXd54A5mJfRjJ2qVpw9f7xKmAD0EF06mjV9gIQ7q0EMoCKOf2\nBqJaAQ2sbPmHyGLJwYRv7iFAufC5xJsLbbKrQV9Oar3Se3RBSeVqZkhoIUKFktbQ\nlNNUGTdHVDZ9LBW0MWygczL/H+OBD/h5CLiopnNsnziCMbYd3efFu04xHulvaYp/\npjmaQH5I4PjqeviFnqHzOhRGAobNSCBTew1RCUZ9I4aHyzEe3slT0E4UP/hn2krr\nLsAD9dfJid0hE7/1u+pLh0tTcIKVxxtEaRk8bY/fvbiUNnJgxWm7zAJKSs42mmCn\nqNUHCE4osDCw3JkJ6tLvwx7HK7qgz2sa9JltCCIcz8mQHpxzxb3nSKqk4FVm9ZNk\nFU9scy0T+3H35iU9uQ8q43BwaTZ7TjdpA2hMvR4ga7DCO7Kvur9ZfUS4sBH22yK+\n4qglQdw8I+MK6ILbT78KxPlPK7HHWm3+6uqBFrKOHij1bPpILkVXlLK9Sdgqgjpp\nKs6JtvmXP9Btt5OgvAJzDWpfMw4lEQkEOHTkHcB72vM6M2FAL7yrce0OtOE9VeHe\n8W9R7+1inmCCCHTn9zTu10azGuuRgRaRXjqVIqx8k64sfcGhsiY=\n=VV90\n-----END PGP SIGNATURE-----", "payload": "tree 777db3042d7a0586a18c47d5417a8df784620a23\nparent 7218836500a9444ae5e9f66cd09c0b4e6a64377c\nauthor Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1519246972 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520494458 +0100\n\nDon't use the undefined bytes of PrimVal::Bytes\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df283df887431eec0f6da0f4aa85db9c88c9449b", "html_url": "https://github.com/rust-lang/rust/commit/df283df887431eec0f6da0f4aa85db9c88c9449b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df283df887431eec0f6da0f4aa85db9c88c9449b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7218836500a9444ae5e9f66cd09c0b4e6a64377c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7218836500a9444ae5e9f66cd09c0b4e6a64377c", "html_url": "https://github.com/rust-lang/rust/commit/7218836500a9444ae5e9f66cd09c0b4e6a64377c"}], "stats": {"total": 532, "additions": 255, "deletions": 277}, "files": [{"sha": "67f30f53a6810fb8feff799ca86cc57b12fbdeed", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=df283df887431eec0f6da0f4aa85db9c88c9449b", "patch": "@@ -10,7 +10,7 @@ mod value;\n \n pub use self::error::{EvalError, EvalResult, EvalErrorKind};\n \n-pub use self::value::{PrimVal, PrimValKind, Value, Pointer, bytes_to_f32, bytes_to_f64};\n+pub use self::value::{PrimVal, PrimValKind, Value, Pointer};\n \n use std::collections::BTreeMap;\n use std::fmt;"}, {"sha": "7289d74bfbb1bd653fa529cd7951ff7da8a11bb6", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=df283df887431eec0f6da0f4aa85db9c88c9449b", "patch": "@@ -4,22 +4,6 @@ use ty::layout::{Align, HasDataLayout};\n use ty;\n \n use super::{EvalResult, MemoryPointer, PointerArithmetic};\n-use syntax::ast::FloatTy;\n-use rustc_const_math::ConstFloat;\n-\n-pub fn bytes_to_f32(bits: u128) -> ConstFloat {\n-    ConstFloat {\n-        bits,\n-        ty: FloatTy::F32,\n-    }\n-}\n-\n-pub fn bytes_to_f64(bits: u128) -> ConstFloat {\n-    ConstFloat {\n-        bits,\n-        ty: FloatTy::F64,\n-    }\n-}\n \n /// A `Value` represents a single self-contained Rust value.\n ///\n@@ -182,10 +166,6 @@ impl<'tcx> PrimVal {\n         PrimVal::Bytes(n as u128)\n     }\n \n-    pub fn from_float(f: ConstFloat) -> Self {\n-        PrimVal::Bytes(f.bits)\n-    }\n-\n     pub fn from_bool(b: bool) -> Self {\n         PrimVal::Bytes(b as u128)\n     }\n@@ -260,14 +240,6 @@ impl<'tcx> PrimVal {\n         })\n     }\n \n-    pub fn to_f32(self) -> EvalResult<'tcx, ConstFloat> {\n-        self.to_bytes().map(bytes_to_f32)\n-    }\n-\n-    pub fn to_f64(self) -> EvalResult<'tcx, ConstFloat> {\n-        self.to_bytes().map(bytes_to_f64)\n-    }\n-\n     pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n         match self.to_bytes()? {\n             0 => Ok(false),"}, {"sha": "d730c95f4dd886c03cbbedc988f0d6d5011ac594", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=df283df887431eec0f6da0f4aa85db9c88c9449b", "patch": "@@ -1845,10 +1845,34 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                         ..\n                     }) => {\n                         trace!(\"discriminants: {} ({:?})\", b, repr_type);\n-                        discr = Discr {\n-                            val: b,\n-                            ty: repr_type.to_ty(tcx),\n-                        };\n+                        let ty = repr_type.to_ty(tcx);\n+                        if ty.is_signed() {\n+                            let (ty, param_env) = tcx\n+                                .lift_to_global(&(ty, param_env))\n+                                .unwrap_or_else(|| {\n+                                bug!(\"MIR: discriminants({:?}, {:?}) got \\\n+                                    type with inference types/regions\",\n+                                    ty, param_env);\n+                            });\n+                            let size = tcx.global_tcx()\n+                                .layout_of(param_env.and(ty))\n+                                .expect(\"int layout\")\n+                                .size\n+                                .bits();\n+                            let val = b as i128;\n+                            // sign extend to i128\n+                            let amt = 128 - size;\n+                            let val = (val << amt) >> amt;\n+                            discr = Discr {\n+                                val: val as u128,\n+                                ty,\n+                            };\n+                        } else {\n+                            discr = Discr {\n+                                val: b,\n+                                ty,\n+                            };\n+                        }\n                     }\n                     _ => {\n                         if !expr_did.is_local() {"}, {"sha": "59f44fa9229a925c2707d3829e06c909f0863450", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=df283df887431eec0f6da0f4aa85db9c88c9449b", "patch": "@@ -22,7 +22,6 @@ use rustc::middle::region;\n use rustc::ty::{self, Ty};\n use rustc::mir::*;\n use rustc::mir::interpret::{Value, PrimVal};\n-use syntax::ast;\n use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -382,9 +381,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     // Helper to get a `-1` value of the appropriate type\n     fn neg_1_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n+        let bits = self.hir.type_bit_size(ty);\n+        let n = (!0u128) >> (128 - bits);\n         let literal = Literal::Value {\n             value: self.hir.tcx().mk_const(ty::Const {\n-                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(-1i128 as u128))),\n+                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(n))),\n                 ty\n             })\n         };\n@@ -394,31 +395,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     // Helper to get the minimum value of the appropriate type\n     fn minval_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let literal = match ty.sty {\n-            ty::TyInt(ity) => {\n-                let ity = match ity {\n-                    ast::IntTy::Isize => self.hir.tcx().sess.target.isize_ty,\n-                    other => other,\n-                };\n-                let val = match ity {\n-                    ast::IntTy::I8  => i8::min_value() as i128,\n-                    ast::IntTy::I16 => i16::min_value() as i128,\n-                    ast::IntTy::I32 => i32::min_value() as i128,\n-                    ast::IntTy::I64 => i64::min_value() as i128,\n-                    ast::IntTy::I128 => i128::min_value() as i128,\n-                    ast::IntTy::Isize => unreachable!(),\n-                };\n-\n-                Literal::Value {\n-                    value: self.hir.tcx().mk_const(ty::Const {\n-                        val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(val as u128))),\n-                        ty\n-                    })\n-                }\n-            }\n-            _ => {\n-                span_bug!(span, \"Invalid type for minval_literal: `{:?}`\", ty)\n-            }\n+        assert!(ty.is_signed());\n+        let bits = self.hir.type_bit_size(ty);\n+        let n = 1 << (bits - 1);\n+        let literal = Literal::Value {\n+            value: self.hir.tcx().mk_const(ty::Const {\n+                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(n))),\n+                ty\n+            })\n         };\n \n         self.literal_operand(span, ty, literal)"}, {"sha": "ec484785ca2f048396cfebf8a249f7334e9d4c56", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=df283df887431eec0f6da0f4aa85db9c88c9449b", "patch": "@@ -149,13 +149,34 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn type_bit_size(\n+        &self,\n+        ty: Ty<'tcx>,\n+    ) -> u64 {\n+        let tcx = self.tcx.global_tcx();\n+        let (ty, param_env) = self\n+            .tcx\n+            .lift_to_global(&(ty, self.param_env))\n+            .unwrap_or_else(|| {\n+            bug!(\"MIR: Cx::const_eval_literal({:?}, {:?}) got \\\n+                type with inference types/regions\",\n+                ty, self.param_env);\n+        });\n+        tcx\n+            .layout_of(param_env.and(ty))\n+            .expect(\"int layout\")\n+            .size\n+            .bits()\n+    }\n+\n     pub fn const_eval_literal(\n         &mut self,\n         lit: &'tcx ast::LitKind,\n         ty: Ty<'tcx>,\n         sp: Span,\n         neg: bool,\n     ) -> Literal<'tcx> {\n+        trace!(\"const_eval_literal: {:#?}, {:?}, {:?}, {:?}\", lit, ty, sp, neg);\n         let tcx = self.tcx.global_tcx();\n \n         let parse_float = |num: &str, fty| -> ConstFloat {\n@@ -165,6 +186,15 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             })\n         };\n \n+        let clamp = |n| {\n+            let size = self.type_bit_size(ty);\n+            trace!(\"clamp {} with size {} and amt {}\", n, size, 128 - size);\n+            let amt = 128 - size;\n+            let result = (n << amt) >> amt;\n+            trace!(\"clamp result: {}\", result);\n+            result\n+        };\n+\n         use rustc::mir::interpret::*;\n         let lit = match *lit {\n             LitKind::Str(ref s, _) => {\n@@ -185,9 +215,10 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             LitKind::Int(n, _) if neg => {\n                 let n = n as i128;\n                 let n = n.overflowing_neg().0;\n-                Value::ByVal(PrimVal::Bytes(n as u128))\n+                let n = clamp(n as u128);\n+                Value::ByVal(PrimVal::Bytes(n))\n             },\n-            LitKind::Int(n, _) => Value::ByVal(PrimVal::Bytes(n)),\n+            LitKind::Int(n, _) => Value::ByVal(PrimVal::Bytes(clamp(n))),\n             LitKind::Float(n, fty) => {\n                 let n = n.as_str();\n                 let mut f = parse_float(&n, fty);"}, {"sha": "9b118b7fb78b68b07bea5992e6fca64eb836ac46", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 39, "deletions": 66, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=df283df887431eec0f6da0f4aa85db9c88c9449b", "patch": "@@ -14,75 +14,37 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         src_ty: Ty<'tcx>,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, PrimVal> {\n+        use rustc::ty::TypeVariants::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", val, src_ty, dest_ty);\n-        let src_kind = self.ty_to_primval_kind(src_ty)?;\n \n         match val {\n             PrimVal::Undef => Ok(PrimVal::Undef),\n             PrimVal::Ptr(ptr) => self.cast_from_ptr(ptr, dest_ty),\n-            val @ PrimVal::Bytes(_) => {\n-                use rustc::mir::interpret::PrimValKind::*;\n-                match src_kind {\n-                    F32 => self.cast_from_float(val.to_f32()?, dest_ty),\n-                    F64 => self.cast_from_float(val.to_f64()?, dest_ty),\n-\n-                    I8 | I16 | I32 | I64 | I128 => {\n-                        self.cast_from_signed_int(val.to_i128()?, dest_ty)\n-                    }\n-\n-                    Bool | Char | U8 | U16 | U32 | U64 | U128 | FnPtr | Ptr => {\n-                        self.cast_from_int(val.to_u128()?, dest_ty, false)\n-                    }\n+            PrimVal::Bytes(b) => {\n+                match src_ty.sty {\n+                    TyFloat(fty) => self.cast_from_float(b, fty, dest_ty),\n+                    _ => self.cast_from_int(b, src_ty, dest_ty),\n                 }\n             }\n         }\n     }\n \n-    fn cast_from_signed_int(&self, val: i128, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n-        self.cast_from_int(val as u128, ty, val < 0)\n-    }\n-\n-    fn int_to_int(&self, v: i128, ty: IntTy) -> u128 {\n-        match ty {\n-            IntTy::I8 => v as i8 as u128,\n-            IntTy::I16 => v as i16 as u128,\n-            IntTy::I32 => v as i32 as u128,\n-            IntTy::I64 => v as i64 as u128,\n-            IntTy::I128 => v as u128,\n-            IntTy::Isize => {\n-                let ty = self.tcx.sess.target.isize_ty;\n-                self.int_to_int(v, ty)\n-            }\n-        }\n-    }\n-    fn int_to_uint(&self, v: u128, ty: UintTy) -> u128 {\n-        match ty {\n-            UintTy::U8 => v as u8 as u128,\n-            UintTy::U16 => v as u16 as u128,\n-            UintTy::U32 => v as u32 as u128,\n-            UintTy::U64 => v as u64 as u128,\n-            UintTy::U128 => v,\n-            UintTy::Usize => {\n-                let ty = self.tcx.sess.target.usize_ty;\n-                self.int_to_uint(v, ty)\n-            }\n-        }\n-    }\n-\n     fn cast_from_int(\n         &self,\n         v: u128,\n-        ty: Ty<'tcx>,\n-        negative: bool,\n+        src_ty: Ty<'tcx>,\n+        dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, PrimVal> {\n-        trace!(\"cast_from_int: {}, {}, {}\", v, ty, negative);\n+        trace!(\"cast_from_int: {}, {}, {}\", v, src_ty, dest_ty);\n         use rustc::ty::TypeVariants::*;\n-        match ty.sty {\n-            // Casts to bool are not permitted by rustc, no need to handle them here.\n-            TyInt(ty) => Ok(PrimVal::Bytes(self.int_to_int(v as i128, ty))),\n-            TyUint(ty) => Ok(PrimVal::Bytes(self.int_to_uint(v, ty))),\n+        match dest_ty.sty {\n+            TyInt(_) | TyUint(_) => {\n+                let v = self.sign_extend(v, src_ty)?;\n+                let v = self.truncate(v, dest_ty)?;\n+                Ok(PrimVal::Bytes(v))\n+            }\n \n-            TyFloat(fty) if negative => Ok(PrimVal::Bytes(ConstFloat::from_i128(v as i128, fty).bits)),\n+            TyFloat(fty) if src_ty.is_signed() => Ok(PrimVal::Bytes(ConstFloat::from_i128(v as i128, fty).bits)),\n             TyFloat(fty) => Ok(PrimVal::Bytes(ConstFloat::from_u128(v, fty).bits)),\n \n             TyChar if v as u8 as u128 == v => Ok(PrimVal::Bytes(v)),\n@@ -91,31 +53,42 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n             TyRawPtr(_) => Ok(PrimVal::Bytes(self.memory.truncate_to_ptr(v).0 as u128)),\n \n-            _ => err!(Unimplemented(format!(\"int to {:?} cast\", ty))),\n+            // Casts to bool are not permitted by rustc, no need to handle them here.\n+            _ => err!(Unimplemented(format!(\"int to {:?} cast\", dest_ty))),\n         }\n     }\n \n-    fn cast_from_float(&self, val: ConstFloat, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    fn cast_from_float(&self, bits: u128, fty: FloatTy, dest_ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use rustc::ty::TypeVariants::*;\n-        match ty.sty {\n+        use rustc_apfloat::FloatConvert;\n+        match dest_ty.sty {\n+            // float -> uint\n             TyUint(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size() as usize * 8);\n-                match val.ty {\n-                    FloatTy::F32 => Ok(PrimVal::Bytes(Single::from_bits(val.bits).to_u128(width).value)),\n-                    FloatTy::F64 => Ok(PrimVal::Bytes(Double::from_bits(val.bits).to_u128(width).value)),\n+                match fty {\n+                    FloatTy::F32 => Ok(PrimVal::Bytes(Single::from_bits(bits).to_u128(width).value)),\n+                    FloatTy::F64 => Ok(PrimVal::Bytes(Double::from_bits(bits).to_u128(width).value)),\n                 }\n             },\n-\n+            // float -> int\n             TyInt(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size() as usize * 8);\n-                match val.ty {\n-                    FloatTy::F32 => Ok(PrimVal::from_i128(Single::from_bits(val.bits).to_i128(width).value)),\n-                    FloatTy::F64 => Ok(PrimVal::from_i128(Double::from_bits(val.bits).to_i128(width).value)),\n+                match fty {\n+                    FloatTy::F32 => Ok(PrimVal::from_i128(Single::from_bits(bits).to_i128(width).value)),\n+                    FloatTy::F64 => Ok(PrimVal::from_i128(Double::from_bits(bits).to_i128(width).value)),\n                 }\n             },\n-\n-            TyFloat(fty) => Ok(PrimVal::from_float(val.convert(fty))),\n-            _ => err!(Unimplemented(format!(\"float to {:?} cast\", ty))),\n+            // f64 -> f32\n+            TyFloat(FloatTy::F32) if fty == FloatTy::F64 => {\n+                Ok(PrimVal::Bytes(Single::to_bits(Double::from_bits(bits).convert(&mut false).value)))\n+            },\n+            // f32 -> f64\n+            TyFloat(FloatTy::F64) if fty == FloatTy::F32 => {\n+                Ok(PrimVal::Bytes(Double::to_bits(Single::from_bits(bits).convert(&mut false).value)))\n+            },\n+            // identity cast\n+            TyFloat(_) => Ok(PrimVal::Bytes(bits)),\n+            _ => err!(Unimplemented(format!(\"float to {:?} cast\", dest_ty))),\n         }\n     }\n "}, {"sha": "e38969e45d2fca372310c5296bf82351b32bab37", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=df283df887431eec0f6da0f4aa85db9c88c9449b", "patch": "@@ -19,7 +19,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{Place, PlaceExtra, Memory,\n-            HasMemory, MemoryKind, operator,\n+            HasMemory, MemoryKind,\n             Machine};\n \n pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n@@ -536,10 +536,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n             UnaryOp(un_op, ref operand) => {\n                 let val = self.eval_operand_to_primval(operand)?;\n-                let kind = self.ty_to_primval_kind(dest_ty)?;\n+                let val = self.unary_op(un_op, val, dest_ty)?;\n                 self.write_primval(\n                     dest,\n-                    operator::unary_op(un_op, val, kind)?,\n+                    val,\n                     dest_ty,\n                 )?;\n             }\n@@ -1677,6 +1677,22 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             self.tcx.sess.err(&e.to_string());\n         }\n     }\n+\n+    pub fn sign_extend(&self, value: u128, ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n+        let size = self.layout_of(ty)?.size.bits();\n+        // sign extend\n+        let amt = 128 - size;\n+        // shift the unsigned value to the left\n+        // and back to the right as signed (essentially fills with FF on the left)\n+        Ok((((value << amt) as i128) >> amt) as u128)\n+    }\n+\n+    pub fn truncate(&self, value: u128, ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n+        let size = self.layout_of(ty)?.size.bits();\n+        let amt = 128 - size;\n+        // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n+        Ok((value << amt) >> amt)\n+    }\n }\n \n impl<'mir, 'tcx> Frame<'mir, 'tcx> {"}, {"sha": "010ec8b9bc03f046b3351457a1f8c6b082e9d8f1", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=df283df887431eec0f6da0f4aa85db9c88c9449b", "patch": "@@ -666,7 +666,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         // Now we do the actual reading\n         let bytes = if signed {\n-            read_target_int(endianness, bytes).unwrap() as u128\n+            let bytes = read_target_int(endianness, bytes).unwrap() as u128;\n+            let amt = 128 - (size * 8);\n+            // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n+            (bytes << amt) >> amt\n         } else {\n             read_target_uint(endianness, bytes).unwrap()\n         };"}, {"sha": "b1ee3d568fd129c1a02638ba33f8d5076ca9e714", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=df283df887431eec0f6da0f4aa85db9c88c9449b", "patch": "@@ -30,5 +30,4 @@ pub use self::const_eval::{\n \n pub use self::machine::Machine;\n \n-pub use self::operator::unary_op;\n pub use self::memory::{write_target_uint, write_target_int, read_target_uint, read_target_int};"}, {"sha": "13087cfd473bc3d8ae9480d3aec37424d8951964", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 116, "deletions": 141, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=df283df887431eec0f6da0f4aa85db9c88c9449b", "patch": "@@ -1,12 +1,13 @@\n use rustc::mir;\n-use rustc::ty::Ty;\n+use rustc::ty::{self, Ty};\n use rustc_const_math::ConstFloat;\n use syntax::ast::FloatTy;\n use std::cmp::Ordering;\n+use rustc::ty::layout::LayoutOf;\n \n use super::{EvalContext, Place, Machine, ValTy};\n \n-use rustc::mir::interpret::{EvalResult, PrimVal, PrimValKind, Value, bytes_to_f32, bytes_to_f64};\n+use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn binop_with_overflow(\n@@ -55,74 +56,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n }\n \n-macro_rules! overflow {\n-    (overflowing_div, $l:expr, $r:expr) => ({\n-        let (val, overflowed) = if $r == 0 {\n-            ($l, true)\n-        } else {\n-            $l.overflowing_div($r)\n-        };\n-        let primval = PrimVal::Bytes(val as u128);\n-        Ok((primval, overflowed))\n-    });\n-    (overflowing_rem, $l:expr, $r:expr) => ({\n-        let (val, overflowed) = if $r == 0 {\n-            ($l, true)\n-        } else {\n-            $l.overflowing_rem($r)\n-        };\n-        let primval = PrimVal::Bytes(val as u128);\n-        Ok((primval, overflowed))\n-    });\n-    ($op:ident, $l:expr, $r:expr) => ({\n-        let (val, overflowed) = $l.$op($r);\n-        let primval = PrimVal::Bytes(val as u128);\n-        Ok((primval, overflowed))\n-    })\n-}\n-\n-macro_rules! int_arithmetic {\n-    ($kind:expr, $int_op:ident, $l:expr, $r:expr) => ({\n-        let l = $l;\n-        let r = $r;\n-        use rustc::mir::interpret::PrimValKind::*;\n-        match $kind {\n-            I8  => overflow!($int_op, l as i8,  r as i8),\n-            I16 => overflow!($int_op, l as i16, r as i16),\n-            I32 => overflow!($int_op, l as i32, r as i32),\n-            I64 => overflow!($int_op, l as i64, r as i64),\n-            I128 => overflow!($int_op, l as i128, r as i128),\n-            U8  => overflow!($int_op, l as u8,  r as u8),\n-            U16 => overflow!($int_op, l as u16, r as u16),\n-            U32 => overflow!($int_op, l as u32, r as u32),\n-            U64 => overflow!($int_op, l as u64, r as u64),\n-            U128 => overflow!($int_op, l as u128, r as u128),\n-            _ => bug!(\"int_arithmetic should only be called on int primvals\"),\n-        }\n-    })\n-}\n-\n-macro_rules! int_shift {\n-    ($kind:expr, $int_op:ident, $l:expr, $r:expr) => ({\n-        let l = $l;\n-        let r = $r;\n-        let r_wrapped = r as u32;\n-        match $kind {\n-            I8  => overflow!($int_op, l as i8,  r_wrapped),\n-            I16 => overflow!($int_op, l as i16, r_wrapped),\n-            I32 => overflow!($int_op, l as i32, r_wrapped),\n-            I64 => overflow!($int_op, l as i64, r_wrapped),\n-            I128 => overflow!($int_op, l as i128, r_wrapped),\n-            U8  => overflow!($int_op, l as u8,  r_wrapped),\n-            U16 => overflow!($int_op, l as u16, r_wrapped),\n-            U32 => overflow!($int_op, l as u32, r_wrapped),\n-            U64 => overflow!($int_op, l as u64, r_wrapped),\n-            U128 => overflow!($int_op, l as u128, r_wrapped),\n-            _ => bug!(\"int_shift should only be called on int primvals\"),\n-        }.map(|(val, over)| (val, over || r != r_wrapped as u128))\n-    })\n-}\n-\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Returns the result of the specified operation and whether it overflowed.\n     pub fn binary_op(\n@@ -134,11 +67,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         right_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, (PrimVal, bool)> {\n         use rustc::mir::BinOp::*;\n-        use rustc::mir::interpret::PrimValKind::*;\n \n         let left_kind = self.ty_to_primval_kind(left_ty)?;\n         let right_kind = self.ty_to_primval_kind(right_ty)?;\n-        //trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n+        trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n \n         // I: Handle operations that support pointers\n         if !left_kind.is_float() && !right_kind.is_float() {\n@@ -153,11 +85,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         // These ops can have an RHS with a different numeric type.\n         if right_kind.is_int() && (bin_op == Shl || bin_op == Shr) {\n-            return match bin_op {\n-                Shl => int_shift!(left_kind, overflowing_shl, l, r),\n-                Shr => int_shift!(left_kind, overflowing_shr, l, r),\n+            let op: fn(u128, u32) -> (u128, bool) = match bin_op {\n+                Shl => u128::overflowing_shl,\n+                Shr => u128::overflowing_shr,\n                 _ => bug!(\"it has already been checked that this is a shift op\"),\n             };\n+            let l = if left_ty.is_signed() {\n+                self.sign_extend(l, left_ty)?\n+            } else {\n+                l\n+            };\n+            let (result, oflo) = op(l, r as u32);\n+            let truncated = self.truncate(result, left_ty)?;\n+            return Ok((PrimVal::Bytes(truncated), oflo || truncated != result));\n         }\n \n         if left_kind != right_kind {\n@@ -197,94 +137,129 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         };\n \n-        let val = match (bin_op, left_kind) {\n-            (_, F32) => float_op(bin_op, l, r, FloatTy::F32),\n-            (_, F64) => float_op(bin_op, l, r, FloatTy::F64),\n-\n-\n-            (Eq, _) => PrimVal::from_bool(l == r),\n-            (Ne, _) => PrimVal::from_bool(l != r),\n-\n-            (Lt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) < (r as i128)),\n-            (Lt, _) => PrimVal::from_bool(l < r),\n-            (Le, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) <= (r as i128)),\n-            (Le, _) => PrimVal::from_bool(l <= r),\n-            (Gt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) > (r as i128)),\n-            (Gt, _) => PrimVal::from_bool(l > r),\n-            (Ge, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) >= (r as i128)),\n-            (Ge, _) => PrimVal::from_bool(l >= r),\n+        if left_ty.is_signed() {\n+            let op: Option<fn(&i128, &i128) -> bool> = match bin_op {\n+                Lt => Some(i128::lt),\n+                Le => Some(i128::le),\n+                Gt => Some(i128::gt),\n+                Ge => Some(i128::ge),\n+                _ => None,\n+            };\n+            if let Some(op) = op {\n+                let l = self.sign_extend(l, left_ty)? as i128;\n+                let r = self.sign_extend(r, right_ty)? as i128;\n+                return Ok((PrimVal::from_bool(op(&l, &r)), false));\n+            }\n+            let op: Option<fn(i128, i128) -> (i128, bool)> = match bin_op {\n+                Rem | Div if r == 0 => return Ok((PrimVal::Bytes(l), true)),\n+                Div => Some(i128::overflowing_div),\n+                Rem => Some(i128::overflowing_rem),\n+                Add => Some(i128::overflowing_add),\n+                Sub => Some(i128::overflowing_sub),\n+                Mul => Some(i128::overflowing_mul),\n+                _ => None,\n+            };\n+            if let Some(op) = op {\n+                let l128 = self.sign_extend(l, left_ty)? as i128;\n+                let r = self.sign_extend(r, right_ty)? as i128;\n+                let size = self.layout_of(left_ty)?.size.bits();\n+                match bin_op {\n+                    Rem | Div => {\n+                        // int_min / -1\n+                        if r == -1 && l == (1 << (size - 1)) {\n+                            return Ok((PrimVal::Bytes(l), true));\n+                        }\n+                    },\n+                    _ => {},\n+                }\n+                trace!(\"{}, {}, {}\", l, l128, r);\n+                let (result, mut oflo) = op(l128, r);\n+                trace!(\"{}, {}\", result, oflo);\n+                if !oflo && size != 128 {\n+                    let max = 1 << (size - 1);\n+                    oflo = result >= max || result < -max;\n+                }\n+                let result = result as u128;\n+                let truncated = self.truncate(result, left_ty)?;\n+                return Ok((PrimVal::Bytes(truncated), oflo));\n+            }\n+        }\n \n-            (BitOr, _) => PrimVal::Bytes(l | r),\n-            (BitAnd, _) => PrimVal::Bytes(l & r),\n-            (BitXor, _) => PrimVal::Bytes(l ^ r),\n+        if let ty::TyFloat(fty) = left_ty.sty {\n+            return Ok((float_op(bin_op, l, r, fty), false));\n+        }\n \n-            (Add, k) if k.is_int() => return int_arithmetic!(k, overflowing_add, l, r),\n-            (Sub, k) if k.is_int() => return int_arithmetic!(k, overflowing_sub, l, r),\n-            (Mul, k) if k.is_int() => return int_arithmetic!(k, overflowing_mul, l, r),\n-            (Div, k) if k.is_int() => return int_arithmetic!(k, overflowing_div, l, r),\n-            (Rem, k) if k.is_int() => return int_arithmetic!(k, overflowing_rem, l, r),\n+        // only ints left\n+        let val = match bin_op {\n+            Eq => PrimVal::from_bool(l == r),\n+            Ne => PrimVal::from_bool(l != r),\n+\n+            Lt => PrimVal::from_bool(l < r),\n+            Le => PrimVal::from_bool(l <= r),\n+            Gt => PrimVal::from_bool(l > r),\n+            Ge => PrimVal::from_bool(l >= r),\n+\n+            BitOr => PrimVal::Bytes(l | r),\n+            BitAnd => PrimVal::Bytes(l & r),\n+            BitXor => PrimVal::Bytes(l ^ r),\n+\n+            Add | Sub | Mul | Rem | Div => {\n+                let op: fn(u128, u128) -> (u128, bool) = match bin_op {\n+                    Add => u128::overflowing_add,\n+                    Sub => u128::overflowing_sub,\n+                    Mul => u128::overflowing_mul,\n+                    Rem | Div if r == 0 => return Ok((PrimVal::Bytes(l), true)),\n+                    Div => u128::overflowing_div,\n+                    Rem => u128::overflowing_rem,\n+                    _ => bug!(),\n+                };\n+                let (result, oflo) = op(l, r);\n+                let truncated = self.truncate(result, left_ty)?;\n+                return Ok((PrimVal::Bytes(truncated), oflo || truncated != result));\n+            }\n \n             _ => {\n                 let msg = format!(\n                     \"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n                     bin_op,\n                     left,\n-                    left_kind,\n+                    left_ty,\n                     right,\n-                    right_kind\n+                    right_ty,\n                 );\n                 return err!(Unimplemented(msg));\n             }\n         };\n \n         Ok((val, false))\n     }\n-}\n \n-pub fn unary_op<'tcx>(\n-    un_op: mir::UnOp,\n-    val: PrimVal,\n-    val_kind: PrimValKind,\n-) -> EvalResult<'tcx, PrimVal> {\n-    use rustc::mir::UnOp::*;\n-    use rustc::mir::interpret::PrimValKind::*;\n-\n-    let bytes = val.to_bytes()?;\n+    pub fn unary_op(\n+        &self,\n+        un_op: mir::UnOp,\n+        val: PrimVal,\n+        ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, PrimVal> {\n+        use rustc::mir::UnOp::*;\n+        use rustc_apfloat::ieee::{Single, Double};\n+        use rustc_apfloat::Float;\n \n-    let result_bytes = match (un_op, val_kind) {\n-        (Not, Bool) => !val.to_bool()? as u128,\n+        let bytes = val.to_bytes()?;\n+        let size = self.layout_of(ty)?.size.bits();\n \n-        (Not, U8) => !(bytes as u8) as u128,\n-        (Not, U16) => !(bytes as u16) as u128,\n-        (Not, U32) => !(bytes as u32) as u128,\n-        (Not, U64) => !(bytes as u64) as u128,\n-        (Not, U128) => !bytes,\n+        let result_bytes = match (un_op, &ty.sty) {\n \n-        (Not, I8) => !(bytes as i8) as u128,\n-        (Not, I16) => !(bytes as i16) as u128,\n-        (Not, I32) => !(bytes as i32) as u128,\n-        (Not, I64) => !(bytes as i64) as u128,\n-        (Not, I128) => !(bytes as i128) as u128,\n+            (Not, ty::TyBool) => !val.to_bool()? as u128,\n \n-        (Neg, I8) if bytes == i8::min_value() as u128 => return err!(OverflowingMath),\n-        (Neg, I8) => -(bytes as i8) as u128,\n-        (Neg, I16) if bytes == i16::min_value() as u128 => return err!(OverflowingMath),\n-        (Neg, I16) => -(bytes as i16) as u128,\n-        (Neg, I32) if bytes == i32::min_value() as u128 => return err!(OverflowingMath),\n-        (Neg, I32) => -(bytes as i32) as u128,\n-        (Neg, I64) if bytes == i64::min_value() as u128 => return err!(OverflowingMath),\n-        (Neg, I64) => -(bytes as i64) as u128,\n-        (Neg, I128) if bytes == i128::min_value() as u128 => return err!(OverflowingMath),\n-        (Neg, I128) => -(bytes as i128) as u128,\n+            (Not, _) => !bytes,\n \n-        (Neg, F32) => (-bytes_to_f32(bytes)).bits,\n-        (Neg, F64) => (-bytes_to_f64(bytes)).bits,\n+            (Neg, ty::TyFloat(FloatTy::F32)) => Single::to_bits(-Single::from_bits(bytes)),\n+            (Neg, ty::TyFloat(FloatTy::F64)) => Double::to_bits(-Double::from_bits(bytes)),\n \n-        _ => {\n-            let msg = format!(\"unimplemented unary op: {:?}, {:?}\", un_op, val);\n-            return err!(Unimplemented(msg));\n-        }\n-    };\n+            (Neg, _) if bytes == (1 << (size - 1)) => return err!(OverflowingMath),\n+            (Neg, _) => (-(bytes as i128)) as u128,\n+        };\n \n-    Ok(PrimVal::Bytes(result_bytes))\n+        Ok(PrimVal::Bytes(self.truncate(result_bytes, ty)?))\n+    }\n }"}, {"sha": "1b64178477e16f701514f290322fe78e1bbfb57e", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=df283df887431eec0f6da0f4aa85db9c88c9449b", "patch": "@@ -20,7 +20,7 @@ use rustc::mir::visit::{Visitor, PlaceContext};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{TyCtxt, self, Instance};\n use rustc::mir::interpret::{Value, PrimVal, GlobalId};\n-use interpret::{eval_body_with_mir, mk_borrowck_eval_cx, unary_op, ValTy};\n+use interpret::{eval_body_with_mir, mk_borrowck_eval_cx, ValTy};\n use transform::{MirPass, MirSource};\n use syntax::codemap::Span;\n use rustc::ty::subst::Substs;\n@@ -205,8 +205,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n \n                 let val = self.eval_operand(arg)?;\n                 let prim = ecx.value_to_primval(ValTy { value: val.0, ty: val.1 }).ok()?;\n-                let kind = ecx.ty_to_primval_kind(val.1).ok()?;\n-                match unary_op(op, prim, kind) {\n+                match ecx.unary_op(op, prim, val.1) {\n                     Ok(val) => Some((Value::ByVal(val), place_ty, span)),\n                     Err(mut err) => {\n                         ecx.report(&mut err, false, Some(span));"}, {"sha": "5c633eb6112ffdb47264c9ca50c5976137c4cdc1", "filename": "src/test/run-pass/const-negation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Ftest%2Frun-pass%2Fconst-negation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df283df887431eec0f6da0f4aa85db9c88c9449b/src%2Ftest%2Frun-pass%2Fconst-negation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-negation.rs?ref=df283df887431eec0f6da0f4aa85db9c88c9449b", "patch": "@@ -17,11 +17,13 @@ fn main() {\n     const I: isize = -9223372036854775808isize;\n     assert_eq!(::std::i32::MIN as u64, 0xffffffff80000000);\n     assert_eq!(-2147483648isize as u64, 0xffffffff80000000);\n+    assert_eq!(-2147483648i32 as u64, 0xffffffff80000000);\n     assert_eq!(::std::i64::MIN as u64, 0x8000000000000000);\n     #[cfg(target_pointer_width = \"64\")]\n     assert_eq!(-9223372036854775808isize as u64, 0x8000000000000000);\n     #[cfg(target_pointer_width = \"32\")]\n     assert_eq!(-9223372036854775808isize as u64, 0);\n+    assert_eq!(-9223372036854775808i32 as u64, 0);\n     const J: usize = ::std::i32::MAX as usize;\n     const K: usize = -1i32 as u32 as usize;\n     const L: usize = ::std::i32::MIN as usize;"}]}