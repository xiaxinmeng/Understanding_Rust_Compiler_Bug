{"sha": "0292640e147f0e9debb83f396b4304a2eb3bb4c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyOTI2NDBlMTQ3ZjBlOWRlYmI4M2YzOTZiNDMwNGEyZWIzYmI0YzI=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-05T06:31:05Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-05T06:31:05Z"}, "message": "Allow chain item to extend if the parent ends with closing parens and alike", "tree": {"sha": "a6608b981637f5349c454ce701f4fe1391d1c803", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6608b981637f5349c454ce701f4fe1391d1c803"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0292640e147f0e9debb83f396b4304a2eb3bb4c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0292640e147f0e9debb83f396b4304a2eb3bb4c2", "html_url": "https://github.com/rust-lang/rust/commit/0292640e147f0e9debb83f396b4304a2eb3bb4c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0292640e147f0e9debb83f396b4304a2eb3bb4c2/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcc7f32152f9469969460e0d45efd7742647fb6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcc7f32152f9469969460e0d45efd7742647fb6e", "html_url": "https://github.com/rust-lang/rust/commit/dcc7f32152f9469969460e0d45efd7742647fb6e"}], "stats": {"total": 97, "additions": 72, "deletions": 25}, "files": [{"sha": "c48fdeb0b66dc9588511cfe7ea73ca527d491407", "filename": "src/chains.rs", "status": "modified", "additions": 72, "deletions": 25, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0292640e147f0e9debb83f396b4304a2eb3bb4c2/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0292640e147f0e9debb83f396b4304a2eb3bb4c2/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=0292640e147f0e9debb83f396b4304a2eb3bb4c2", "patch": "@@ -117,22 +117,18 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     };\n     let parent_rewrite = try_opt!(parent.rewrite(context, parent_shape));\n     let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n+    let is_small_parent = parent_rewrite.len() <= context.config.tab_spaces();\n \n     // Decide how to layout the rest of the chain. `extend` is true if we can\n     // put the first non-parent item on the same line as the parent.\n-    let first_subexpr_is_try = match subexpr_list.last().unwrap().node {\n-        ast::ExprKind::Try(..) => true,\n-        _ => false,\n-    };\n+    let first_subexpr_is_try = subexpr_list.last().map_or(false, is_try);\n     let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n         let nested_shape = if first_subexpr_is_try {\n             parent_shape.block_indent(context.config.tab_spaces())\n         } else {\n             chain_indent(context, shape.add_offset(parent_rewrite.len()))\n         };\n-        (nested_shape,\n-         context.config.chain_indent() == IndentStyle::Visual ||\n-         parent_rewrite.len() <= context.config.tab_spaces())\n+        (nested_shape, context.config.chain_indent() == IndentStyle::Visual || is_small_parent)\n     } else if is_block_expr(context, &parent, &parent_rewrite) {\n         match context.config.chain_indent() {\n             // Try to put the first child on the same line with parent's last line\n@@ -258,26 +254,47 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         format!(\"\\n{}\", nested_shape.indent.to_string(context.config))\n     };\n \n-    let first_connector = if subexpr_list.is_empty() {\n-        \"\"\n-    } else if extend || first_subexpr_is_try {\n-        // 1 = \";\", being conservative here.\n-        if last_line_width(&parent_rewrite) + first_line_width(&rewrites[0]) + 1 <=\n-           context.config.max_width() {\n-            \"\"\n-        } else {\n-            &*connector\n-        }\n+    let first_connector = choose_first_connector(context,\n+                                                 &parent_rewrite,\n+                                                 &rewrites[0],\n+                                                 &connector,\n+                                                 &subexpr_list,\n+                                                 extend);\n+\n+    if is_small_parent && rewrites.len() > 1 {\n+        let second_connector = choose_first_connector(context,\n+                                                      &rewrites[0],\n+                                                      &rewrites[1],\n+                                                      &connector,\n+                                                      &subexpr_list[0..subexpr_list.len() - 1],\n+                                                      false);\n+        wrap_str(format!(\"{}{}{}{}{}\",\n+                         parent_rewrite,\n+                         first_connector,\n+                         rewrites[0],\n+                         second_connector,\n+                         join_rewrites(&rewrites[1..],\n+                                       &subexpr_list[0..subexpr_list.len() - 1],\n+                                       &connector)),\n+                 context.config.max_width(),\n+                 shape)\n     } else {\n-        &*connector\n-    };\n+        wrap_str(format!(\"{}{}{}\",\n+                         parent_rewrite,\n+                         first_connector,\n+                         join_rewrites(&rewrites, &subexpr_list, &connector)),\n+                 context.config.max_width(),\n+                 shape)\n+    }\n+}\n \n-    wrap_str(format!(\"{}{}{}\",\n-                     parent_rewrite,\n-                     first_connector,\n-                     join_rewrites(&rewrites, &subexpr_list, &connector)),\n-             context.config.max_width(),\n-             shape)\n+fn is_extendable_parent(context: &RewriteContext, parent_str: &str) -> bool {\n+    context.config.chain_indent() == IndentStyle::Block &&\n+    parent_str.lines().last().map_or(false, |s| {\n+        s.trim()\n+            .chars()\n+            .all(|c| c == ')' || c == ']' || c == '}' || c == '?')\n+    })\n }\n \n // True if the chain is only `?`s.\n@@ -476,6 +493,36 @@ fn is_continuable(expr: &ast::Expr) -> bool {\n     }\n }\n \n+fn is_try(expr: &ast::Expr) -> bool {\n+    match expr.node {\n+        ast::ExprKind::Try(..) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn choose_first_connector<'a>(context: &RewriteContext,\n+                              parent_str: &str,\n+                              first_child_str: &str,\n+                              connector: &'a str,\n+                              subexpr_list: &[ast::Expr],\n+                              extend: bool)\n+                              -> &'a str {\n+    if subexpr_list.is_empty() {\n+        \"\"\n+    } else if extend || subexpr_list.last().map_or(false, is_try) ||\n+              is_extendable_parent(context, parent_str) {\n+        // 1 = \";\", being conservative here.\n+        if last_line_width(parent_str) + first_line_width(first_child_str) + 1 <=\n+           context.config.max_width() {\n+            \"\"\n+        } else {\n+            connector\n+        }\n+    } else {\n+        connector\n+    }\n+}\n+\n fn rewrite_method_call(method_name: ast::Ident,\n                        types: &[ptr::P<ast::Ty>],\n                        args: &[ptr::P<ast::Expr>],"}]}