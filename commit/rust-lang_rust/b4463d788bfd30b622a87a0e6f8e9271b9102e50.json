{"sha": "b4463d788bfd30b622a87a0e6f8e9271b9102e50", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NDYzZDc4OGJmZDMwYjYyMmE4N2EwZTZmOGU5MjcxYjkxMDJlNTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-24T03:40:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-24T03:40:16Z"}, "message": "Auto merge of #50943 - oli-obk:cleanups, r=estebank\n\nimpl Trait diagnostic/test cleanups", "tree": {"sha": "118b67318466e123b8b57e80144063dbdba0728f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/118b67318466e123b8b57e80144063dbdba0728f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4463d788bfd30b622a87a0e6f8e9271b9102e50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4463d788bfd30b622a87a0e6f8e9271b9102e50", "html_url": "https://github.com/rust-lang/rust/commit/b4463d788bfd30b622a87a0e6f8e9271b9102e50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4463d788bfd30b622a87a0e6f8e9271b9102e50/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "242195d290053d1cc3b8895fca4ae66eacc98f3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/242195d290053d1cc3b8895fca4ae66eacc98f3c", "html_url": "https://github.com/rust-lang/rust/commit/242195d290053d1cc3b8895fca4ae66eacc98f3c"}, {"sha": "849c565e2f98c2eb180a21ad1842c32579ed14e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/849c565e2f98c2eb180a21ad1842c32579ed14e3", "html_url": "https://github.com/rust-lang/rust/commit/849c565e2f98c2eb180a21ad1842c32579ed14e3"}], "stats": {"total": 370, "additions": 282, "deletions": 88}, "files": [{"sha": "81b32f436c8dded59ff4cd0bffa5c182b3f7cd08", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=b4463d788bfd30b622a87a0e6f8e9271b9102e50", "patch": "@@ -259,6 +259,25 @@ impl Diagnostic {\n         self\n     }\n \n+    pub fn multipart_suggestion(\n+        &mut self,\n+        msg: &str,\n+        suggestion: Vec<(Span, String)>,\n+    ) -> &mut Self {\n+        self.suggestions.push(CodeSuggestion {\n+            substitutions: vec![Substitution {\n+                parts: suggestion\n+                    .into_iter()\n+                    .map(|(span, snippet)| SubstitutionPart { snippet, span })\n+                    .collect(),\n+            }],\n+            msg: msg.to_owned(),\n+            show_code_when_inline: true,\n+            applicability: Applicability::Unspecified,\n+        });\n+        self\n+    }\n+\n     /// Prints out a message with multiple suggested edits of the code.\n     pub fn span_suggestions(&mut self, sp: Span, msg: &str, suggestions: Vec<String>) -> &mut Self {\n         self.suggestions.push(CodeSuggestion {"}, {"sha": "b813edadc577e10b31c0749e86c60b6c418186bd", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=b4463d788bfd30b622a87a0e6f8e9271b9102e50", "patch": "@@ -178,6 +178,11 @@ impl<'a> DiagnosticBuilder<'a> {\n                                           msg: &str,\n                                           suggestion: String)\n                                           -> &mut Self);\n+    forward!(pub fn multipart_suggestion(\n+        &mut self,\n+        msg: &str,\n+        suggestion: Vec<(Span, String)>\n+    ) -> &mut Self);\n     forward!(pub fn span_suggestion(&mut self,\n                                     sp: Span,\n                                     msg: &str,"}, {"sha": "e3ed7d4d9c74443e240ef5863efc783fa44f048b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 74, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b4463d788bfd30b622a87a0e6f8e9271b9102e50", "patch": "@@ -42,7 +42,7 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n-use syntax::codemap::{BytePos, CodeMap};\n+use syntax::codemap::CodeMap;\n use syntax::ext::hygiene::{Mark, MarkKind, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n@@ -211,12 +211,12 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             // Try to retrieve the span of the function signature and generate a new message with\n             // a local type parameter\n             let sugg_msg = \"try using a local type parameter instead\";\n-            if let Some((sugg_span, new_snippet)) = generate_local_type_param_snippet(cm, span) {\n+            if let Some((sugg_span, new_snippet)) = cm.generate_local_type_param_snippet(span) {\n                 // Suggest the modification to the user\n                 err.span_suggestion(sugg_span,\n                                     sugg_msg,\n                                     new_snippet);\n-            } else if let Some(sp) = generate_fn_name_span(cm, span) {\n+            } else if let Some(sp) = cm.generate_fn_name_span(span) {\n                 err.span_label(sp, \"try adding a local type parameter in this method instead\");\n             } else {\n                 err.help(\"try using a local type parameter instead\");\n@@ -413,77 +413,6 @@ fn reduce_impl_span_to_impl_keyword(cm: &CodeMap, impl_span: Span) -> Span {\n     impl_span\n }\n \n-fn generate_fn_name_span(cm: &CodeMap, span: Span) -> Option<Span> {\n-    let prev_span = cm.span_extend_to_prev_str(span, \"fn\", true);\n-    cm.span_to_snippet(prev_span).map(|snippet| {\n-        let len = snippet.find(|c: char| !c.is_alphanumeric() && c != '_')\n-            .expect(\"no label after fn\");\n-        prev_span.with_hi(BytePos(prev_span.lo().0 + len as u32))\n-    }).ok()\n-}\n-\n-/// Take the span of a type parameter in a function signature and try to generate a span for the\n-/// function name (with generics) and a new snippet for this span with the pointed type parameter as\n-/// a new local type parameter.\n-///\n-/// For instance:\n-/// ```rust,ignore (pseudo-Rust)\n-/// // Given span\n-/// fn my_function(param: T)\n-/// //                    ^ Original span\n-///\n-/// // Result\n-/// fn my_function(param: T)\n-/// // ^^^^^^^^^^^ Generated span with snippet `my_function<T>`\n-/// ```\n-///\n-/// Attention: The method used is very fragile since it essentially duplicates the work of the\n-/// parser. If you need to use this function or something similar, please consider updating the\n-/// codemap functions and this function to something more robust.\n-fn generate_local_type_param_snippet(cm: &CodeMap, span: Span) -> Option<(Span, String)> {\n-    // Try to extend the span to the previous \"fn\" keyword to retrieve the function\n-    // signature\n-    let sugg_span = cm.span_extend_to_prev_str(span, \"fn\", false);\n-    if sugg_span != span {\n-        if let Ok(snippet) = cm.span_to_snippet(sugg_span) {\n-            // Consume the function name\n-            let mut offset = snippet.find(|c: char| !c.is_alphanumeric() && c != '_')\n-                .expect(\"no label after fn\");\n-\n-            // Consume the generics part of the function signature\n-            let mut bracket_counter = 0;\n-            let mut last_char = None;\n-            for c in snippet[offset..].chars() {\n-                match c {\n-                    '<' => bracket_counter += 1,\n-                    '>' => bracket_counter -= 1,\n-                    '(' => if bracket_counter == 0 { break; }\n-                    _ => {}\n-                }\n-                offset += c.len_utf8();\n-                last_char = Some(c);\n-            }\n-\n-            // Adjust the suggestion span to encompass the function name with its generics\n-            let sugg_span = sugg_span.with_hi(BytePos(sugg_span.lo().0 + offset as u32));\n-\n-            // Prepare the new suggested snippet to append the type parameter that triggered\n-            // the error in the generics of the function signature\n-            let mut new_snippet = if last_char == Some('>') {\n-                format!(\"{}, \", &snippet[..(offset - '>'.len_utf8())])\n-            } else {\n-                format!(\"{}<\", &snippet[..offset])\n-            };\n-            new_snippet.push_str(&cm.span_to_snippet(span).unwrap_or(\"T\".to_string()));\n-            new_snippet.push('>');\n-\n-            return Some((sugg_span, new_snippet));\n-        }\n-    }\n-\n-    None\n-}\n-\n #[derive(Copy, Clone, Debug)]\n struct BindingInfo {\n     span: Span,"}, {"sha": "d185bc6f300aaec7982fa819008d17d80be383f8", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 126, "deletions": 3, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=b4463d788bfd30b622a87a0e6f8e9271b9102e50", "patch": "@@ -720,7 +720,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         _trait_item_span: Option<Span>) // FIXME necessary?\n                                         -> Result<(), ErrorReported> {\n     // FIXME(chrisvittal) Clean up this function, list of FIXME items:\n-    //     1. Better messages for the span lables\n+    //     1. Better messages for the span labels\n     //     2. Explanation as to what is going on\n     //     3. Correct the function signature for what we actually use\n     // If we get here, we already have the same number of generics, so the zip will\n@@ -751,8 +751,131 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            E0643,\n                                            \"method `{}` has incompatible signature for trait\",\n                                            trait_m.name);\n-            err.span_label(trait_span, \"annotation in trait\");\n-            err.span_label(impl_span, \"annotation in impl\");\n+            err.span_label(trait_span, \"declaration in trait here\");\n+            match (impl_synthetic, trait_synthetic) {\n+                // The case where the impl method uses `impl Trait` but the trait method uses\n+                // explicit generics\n+                (Some(hir::SyntheticTyParamKind::ImplTrait), None) => {\n+                    err.span_label(impl_span, \"expected generic parameter, found `impl Trait`\");\n+                    (|| {\n+                        // try taking the name from the trait impl\n+                        // FIXME: this is obviously suboptimal since the name can already be used\n+                        // as another generic argument\n+                        let new_name = tcx\n+                            .sess\n+                            .codemap()\n+                            .span_to_snippet(trait_span)\n+                            .ok()?;\n+                        let trait_m = tcx.hir.as_local_node_id(trait_m.def_id)?;\n+                        let trait_m = tcx.hir.trait_item(hir::TraitItemId { node_id: trait_m });\n+\n+                        let impl_m = tcx.hir.as_local_node_id(impl_m.def_id)?;\n+                        let impl_m = tcx.hir.impl_item(hir::ImplItemId { node_id: impl_m });\n+\n+                        // in case there are no generics, take the spot between the function name\n+                        // and the opening paren of the argument list\n+                        let new_generics_span = tcx\n+                            .sess\n+                            .codemap()\n+                            .generate_fn_name_span(impl_m.span)?\n+                            .shrink_to_hi();\n+                        // in case there are generics, just replace them\n+                        let generics_span = impl_m\n+                            .generics\n+                            .span\n+                            .substitute_dummy(new_generics_span);\n+                        // replace with the generics from the trait\n+                        let new_generics = tcx\n+                            .sess\n+                            .codemap()\n+                            .span_to_snippet(trait_m.generics.span)\n+                            .ok()?;\n+\n+                        err.multipart_suggestion(\n+                            \"try changing the `impl Trait` argument to a generic parameter\",\n+                            vec![\n+                                // replace `impl Trait` with `T`\n+                                (impl_span, new_name),\n+                                // replace impl method generics with trait method generics\n+                                // This isn't quite right, as users might have changed the names\n+                                // of the generics, but it works for the common case\n+                                (generics_span, new_generics),\n+                            ],\n+                        );\n+                        Some(())\n+                    })();\n+                },\n+                // The case where the trait method uses `impl Trait`, but the impl method uses\n+                // explicit generics.\n+                (None, Some(hir::SyntheticTyParamKind::ImplTrait)) => {\n+                    err.span_label(impl_span, \"expected `impl Trait`, found generic parameter\");\n+                    (|| {\n+                        let impl_m = tcx.hir.as_local_node_id(impl_m.def_id)?;\n+                        let impl_m = tcx.hir.impl_item(hir::ImplItemId { node_id: impl_m });\n+                        let input_tys = match impl_m.node {\n+                            hir::ImplItemKind::Method(ref sig, _) => &sig.decl.inputs,\n+                            _ => unreachable!(),\n+                        };\n+                        struct Visitor(Option<Span>, hir::def_id::DefId);\n+                        impl<'v> hir::intravisit::Visitor<'v> for Visitor {\n+                            fn visit_ty(&mut self, ty: &'v hir::Ty) {\n+                                hir::intravisit::walk_ty(self, ty);\n+                                match ty.node {\n+                                    hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n+                                        if let hir::def::Def::TyParam(def_id) = path.def {\n+                                            if def_id == self.1 {\n+                                                self.0 = Some(ty.span);\n+                                            }\n+                                        }\n+                                    },\n+                                    _ => {}\n+                                }\n+                            }\n+                            fn nested_visit_map<'this>(\n+                                &'this mut self\n+                            ) -> hir::intravisit::NestedVisitorMap<'this, 'v> {\n+                                hir::intravisit::NestedVisitorMap::None\n+                            }\n+                        }\n+                        let mut visitor = Visitor(None, impl_def_id);\n+                        for ty in input_tys {\n+                            hir::intravisit::Visitor::visit_ty(&mut visitor, ty);\n+                        }\n+                        let span = visitor.0?;\n+\n+                        let param = impl_m.generics.params.iter().filter_map(|param| {\n+                            match param {\n+                                hir::GenericParam::Type(param) => {\n+                                    if param.id == impl_node_id {\n+                                        Some(param)\n+                                    } else {\n+                                        None\n+                                    }\n+                                },\n+                                hir::GenericParam::Lifetime(..) => None,\n+                            }\n+                        }).next()?;\n+                        let bounds = param.bounds.first()?.span().to(param.bounds.last()?.span());\n+                        let bounds = tcx\n+                            .sess\n+                            .codemap()\n+                            .span_to_snippet(bounds)\n+                            .ok()?;\n+\n+                        err.multipart_suggestion(\n+                            \"try removing the generic parameter and using `impl Trait` instead\",\n+                            vec![\n+                                // delete generic parameters\n+                                (impl_m.generics.span, String::new()),\n+                                // replace param usage with `impl Trait`\n+                                (span, format!(\"impl {}\", bounds)),\n+                            ],\n+                        );\n+                        Some(())\n+                    })();\n+                },\n+                _ => unreachable!(),\n+            }\n             err.emit();\n             error_found = true;\n         }"}, {"sha": "fe8ce75a4b8ea5483a8cc483e783d3f98901b2af", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=b4463d788bfd30b622a87a0e6f8e9271b9102e50", "patch": "@@ -874,6 +874,78 @@ impl CodeMap {\n     pub fn count_lines(&self) -> usize {\n         self.files().iter().fold(0, |a, f| a + f.count_lines())\n     }\n+\n+\n+    pub fn generate_fn_name_span(&self, span: Span) -> Option<Span> {\n+        let prev_span = self.span_extend_to_prev_str(span, \"fn\", true);\n+        self.span_to_snippet(prev_span).map(|snippet| {\n+            let len = snippet.find(|c: char| !c.is_alphanumeric() && c != '_')\n+                .expect(\"no label after fn\");\n+            prev_span.with_hi(BytePos(prev_span.lo().0 + len as u32))\n+        }).ok()\n+    }\n+\n+    /// Take the span of a type parameter in a function signature and try to generate a span for the\n+    /// function name (with generics) and a new snippet for this span with the pointed type\n+    /// parameter as a new local type parameter.\n+    ///\n+    /// For instance:\n+    /// ```rust,ignore (pseudo-Rust)\n+    /// // Given span\n+    /// fn my_function(param: T)\n+    /// //                    ^ Original span\n+    ///\n+    /// // Result\n+    /// fn my_function(param: T)\n+    /// // ^^^^^^^^^^^ Generated span with snippet `my_function<T>`\n+    /// ```\n+    ///\n+    /// Attention: The method used is very fragile since it essentially duplicates the work of the\n+    /// parser. If you need to use this function or something similar, please consider updating the\n+    /// codemap functions and this function to something more robust.\n+    pub fn generate_local_type_param_snippet(&self, span: Span) -> Option<(Span, String)> {\n+        // Try to extend the span to the previous \"fn\" keyword to retrieve the function\n+        // signature\n+        let sugg_span = self.span_extend_to_prev_str(span, \"fn\", false);\n+        if sugg_span != span {\n+            if let Ok(snippet) = self.span_to_snippet(sugg_span) {\n+                // Consume the function name\n+                let mut offset = snippet.find(|c: char| !c.is_alphanumeric() && c != '_')\n+                    .expect(\"no label after fn\");\n+\n+                // Consume the generics part of the function signature\n+                let mut bracket_counter = 0;\n+                let mut last_char = None;\n+                for c in snippet[offset..].chars() {\n+                    match c {\n+                        '<' => bracket_counter += 1,\n+                        '>' => bracket_counter -= 1,\n+                        '(' => if bracket_counter == 0 { break; }\n+                        _ => {}\n+                    }\n+                    offset += c.len_utf8();\n+                    last_char = Some(c);\n+                }\n+\n+                // Adjust the suggestion span to encompass the function name with its generics\n+                let sugg_span = sugg_span.with_hi(BytePos(sugg_span.lo().0 + offset as u32));\n+\n+                // Prepare the new suggested snippet to append the type parameter that triggered\n+                // the error in the generics of the function signature\n+                let mut new_snippet = if last_char == Some('>') {\n+                    format!(\"{}, \", &snippet[..(offset - '>'.len_utf8())])\n+                } else {\n+                    format!(\"{}<\", &snippet[..offset])\n+                };\n+                new_snippet.push_str(&self.span_to_snippet(span).unwrap_or(\"T\".to_string()));\n+                new_snippet.push('>');\n+\n+                return Some((sugg_span, new_snippet));\n+            }\n+        }\n+\n+        None\n+    }\n }\n \n impl CodeMapper for CodeMap {"}, {"sha": "d6707f590113ce5e464edd019ca0b55225d610e1", "filename": "src/test/ui/impl-trait/impl-generic-mismatch.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.rs?ref=b4463d788bfd30b622a87a0e6f8e9271b9102e50", "previous_filename": "src/test/compile-fail/impl-trait/impl-generic-mismatch.rs"}, {"sha": "e133d825ba015256ea36bab998b77918e772df3f", "filename": "src/test/ui/impl-trait/impl-generic-mismatch.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr?ref=b4463d788bfd30b622a87a0e6f8e9271b9102e50", "patch": "@@ -0,0 +1,44 @@\n+error[E0643]: method `foo` has incompatible signature for trait\n+  --> $DIR/impl-generic-mismatch.rs:18:12\n+   |\n+LL |     fn foo(&self, _: &impl Debug);\n+   |                       ---------- declaration in trait here\n+...\n+LL |     fn foo<U: Debug>(&self, _: &U) { }\n+   |            ^ expected `impl Trait`, found generic parameter\n+help: try removing the generic parameter and using `impl Trait` instead\n+   |\n+LL |     fn foo(&self, _: &impl Debug) { }\n+   |\n+\n+error[E0643]: method `bar` has incompatible signature for trait\n+  --> $DIR/impl-generic-mismatch.rs:27:23\n+   |\n+LL |     fn bar<U: Debug>(&self, _: &U);\n+   |            - declaration in trait here\n+...\n+LL |     fn bar(&self, _: &impl Debug) { }\n+   |                       ^^^^^^^^^^ expected generic parameter, found `impl Trait`\n+help: try changing the `impl Trait` argument to a generic parameter\n+   |\n+LL |     fn bar<U: Debug><U: Debug>(&self, _: &U);\n+LL | }\n+LL | \n+LL | impl Bar for () {\n+LL |     fn bar(&self, _: &U) { }\n+   |\n+\n+error[E0643]: method `hash` has incompatible signature for trait\n+  --> $DIR/impl-generic-mismatch.rs:38:33\n+   |\n+LL |     fn hash(&self, hasher: &mut impl Hasher) {}\n+   |                                 ^^^^^^^^^^^ expected generic parameter, found `impl Trait`\n+   | \n+  ::: $SRC_DIR/libcore/hash/mod.rs:185:13\n+   |\n+LL |     fn hash<H: Hasher>(&self, state: &mut H);\n+   |             - declaration in trait here\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0643`."}, {"sha": "63d000c05683543d30f31148b7c82a0c790eb4ab", "filename": "src/test/ui/impl-trait/universal_wrong_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.rs?ref=b4463d788bfd30b622a87a0e6f8e9271b9102e50", "patch": "@@ -13,12 +13,12 @@ use std::fmt::Display;\n fn foo(f: impl Display + Clone) -> String {\n     wants_debug(f);\n     wants_display(f);\n-    wants_clone(f); //~ ERROR cannot find\n+    wants_clone(f);\n }\n \n fn wants_debug(g: impl Debug) { } //~ ERROR cannot find\n fn wants_display(g: impl Debug) { } //~ ERROR cannot find\n-fn wants_cone(g: impl Clone) { }\n+fn wants_clone(g: impl Clone) { }\n \n fn main() {\n }"}, {"sha": "68a318e2ac4b7fba5dcc3c22c191b1a7ff398d4a", "filename": "src/test/ui/impl-trait/universal_wrong_bounds.stderr", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.stderr?ref=b4463d788bfd30b622a87a0e6f8e9271b9102e50", "patch": "@@ -1,9 +1,3 @@\n-error[E0425]: cannot find function `wants_clone` in this scope\n-  --> $DIR/universal_wrong_bounds.rs:16:5\n-   |\n-LL |     wants_clone(f); //~ ERROR cannot find\n-   |     ^^^^^^^^^^^ did you mean `wants_cone`?\n-\n error[E0405]: cannot find trait `Debug` in this scope\n   --> $DIR/universal_wrong_bounds.rs:19:24\n    |\n@@ -24,7 +18,6 @@ help: possible candidate is found in another module, you can import it into scop\n LL | use std::fmt::Debug;\n    |\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors occurred: E0405, E0425.\n-For more information about an error, try `rustc --explain E0405`.\n+For more information about this error, try `rustc --explain E0405`."}, {"sha": "9ff80cc1d3c3069b3b1e0add1048515f7d91c2ca", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4463d788bfd30b622a87a0e6f8e9271b9102e50/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=b4463d788bfd30b622a87a0e6f8e9271b9102e50", "patch": "@@ -2863,6 +2863,15 @@ impl<'test> TestCx<'test> {\n \n         let mut normalized = output.replace(&parent_dir_str, \"$DIR\");\n \n+        // Paths into the libstd/libcore\n+        let src_dir = self.config.src_base.parent().unwrap().parent().unwrap();\n+        let src_dir_str = if json {\n+            src_dir.display().to_string().replace(\"\\\\\", \"\\\\\\\\\")\n+        } else {\n+            src_dir.display().to_string()\n+        };\n+        normalized = normalized.replace(&src_dir_str, \"$SRC_DIR\");\n+\n         if json {\n             // escaped newlines in json strings should be readable\n             // in the stderr files. There's no point int being correct,"}]}