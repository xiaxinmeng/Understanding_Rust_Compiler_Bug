{"sha": "c22e7f02d11ff6c6741cdf0847bb7b77dbc5e868", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMmU3ZjAyZDExZmY2YzY3NDFjZGYwODQ3YmI3Yjc3ZGJjNWU4Njg=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-11-01T11:25:36Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-11-01T14:01:56Z"}, "message": "Cleaned up the option and result module in more detail\n\nMade both types implement more standard traits in a nicer way\n\nDerived more traits", "tree": {"sha": "e79b830e0205f3187729a6afae76b4c3bf426674", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e79b830e0205f3187729a6afae76b4c3bf426674"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c22e7f02d11ff6c6741cdf0847bb7b77dbc5e868", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c22e7f02d11ff6c6741cdf0847bb7b77dbc5e868", "html_url": "https://github.com/rust-lang/rust/commit/c22e7f02d11ff6c6741cdf0847bb7b77dbc5e868", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c22e7f02d11ff6c6741cdf0847bb7b77dbc5e868/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d92c53f4a5707ee994d74d9e96995d7bac2ab13", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d92c53f4a5707ee994d74d9e96995d7bac2ab13", "html_url": "https://github.com/rust-lang/rust/commit/0d92c53f4a5707ee994d74d9e96995d7bac2ab13"}], "stats": {"total": 99, "additions": 42, "deletions": 57}, "files": [{"sha": "ad81dfd651705f4d011cd8ba018423f42b5d9007", "filename": "src/libstd/option.rs", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c22e7f02d11ff6c6741cdf0847bb7b77dbc5e868/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22e7f02d11ff6c6741cdf0847bb7b77dbc5e868/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=c22e7f02d11ff6c6741cdf0847bb7b77dbc5e868", "patch": "@@ -40,46 +40,28 @@\n use any::Any;\n use clone::Clone;\n use clone::DeepClone;\n-use cmp::{Eq,Ord};\n+use cmp::{Eq, TotalEq, TotalOrd};\n use default::Default;\n use either;\n use fmt;\n use iter::{Iterator, DoubleEndedIterator, ExactSize};\n-use iter;\n use kinds::Send;\n use num::Zero;\n-use result;\n-use str::{StrSlice, OwnedStr};\n+use result::{IntoResult, ToResult, AsResult};\n+use result::{Result, Ok, Err};\n+use str::OwnedStr;\n use to_str::ToStr;\n use util;\n \n /// The option type\n-#[deriving(Clone, DeepClone, Eq, ToStr)]\n+#[deriving(Clone, DeepClone, Eq, Ord, TotalEq, TotalOrd, ToStr)]\n pub enum Option<T> {\n     /// No value\n     None,\n     /// Some value `T`\n     Some(T)\n }\n \n-impl<T: Eq + Ord> Ord for Option<T> {\n-    fn lt(&self, other: &Option<T>) -> bool {\n-        iter::order::lt(self.iter(), other.iter())\n-    }\n-\n-    fn le(&self, other: &Option<T>) -> bool {\n-        iter::order::le(self.iter(), other.iter())\n-    }\n-\n-    fn ge(&self, other: &Option<T>) -> bool {\n-        iter::order::ge(self.iter(), other.iter())\n-    }\n-\n-    fn gt(&self, other: &Option<T>) -> bool {\n-        iter::order::gt(self.iter(), other.iter())\n-    }\n-}\n-\n /////////////////////////////////////////////////////////////////////////////\n // Type implementation\n /////////////////////////////////////////////////////////////////////////////\n@@ -436,22 +418,33 @@ impl<T> AsOption<T> for Option<T> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n-impl<T: Clone> result::ToResult<T, ()> for Option<T> {\n+impl<T: Clone> ToResult<T, ()> for Option<T> {\n     #[inline]\n-    fn to_result(&self) -> result::Result<T, ()> {\n+    fn to_result(&self) -> Result<T, ()> {\n         match *self {\n-            Some(ref x) => result::Ok(x.clone()),\n-            None => result::Err(()),\n+            Some(ref x) => Ok(x.clone()),\n+            None => Err(()),\n         }\n     }\n }\n \n-impl<T> result::IntoResult<T, ()> for Option<T> {\n+impl<T> IntoResult<T, ()> for Option<T> {\n     #[inline]\n-    fn into_result(self) -> result::Result<T, ()> {\n+    fn into_result(self) -> Result<T, ()> {\n         match self {\n-            Some(x) => result::Ok(x),\n-            None => result::Err(()),\n+            Some(x) => Ok(x),\n+            None => Err(()),\n+        }\n+    }\n+}\n+\n+impl<T> AsResult<T, ()> for Option<T> {\n+    #[inline]\n+    fn as_result<'a>(&'a self) -> Result<&'a T, &'a ()> {\n+        static UNIT: () = ();\n+        match *self {\n+            Some(ref t) => Ok(t),\n+            None => Err(&UNIT),\n         }\n     }\n }\n@@ -536,7 +529,8 @@ mod tests {\n     use either::{IntoEither, ToEither};\n     use either;\n     use result::{IntoResult, ToResult};\n-    use result;\n+    use result::{Result, Ok, Err};\n+    use str::StrSlice;\n     use util;\n \n     #[test]\n@@ -814,17 +808,17 @@ mod tests {\n         let some: Option<int> = Some(100);\n         let none: Option<int> = None;\n \n-        assert_eq!(some.to_result(), result::Ok(100));\n-        assert_eq!(none.to_result(), result::Err(()));\n+        assert_eq!(some.to_result(), Ok(100));\n+        assert_eq!(none.to_result(), Err(()));\n     }\n \n     #[test]\n     pub fn test_into_result() {\n         let some: Option<int> = Some(100);\n         let none: Option<int> = None;\n \n-        assert_eq!(some.into_result(), result::Ok(100));\n-        assert_eq!(none.into_result(), result::Err(()));\n+        assert_eq!(some.into_result(), Ok(100));\n+        assert_eq!(none.into_result(), Err(()));\n     }\n \n     #[test]"}, {"sha": "dcc910281ab2bfa28c4e115e9738010be7192128", "filename": "src/libstd/result.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c22e7f02d11ff6c6741cdf0847bb7b77dbc5e868/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22e7f02d11ff6c6741cdf0847bb7b77dbc5e868/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=c22e7f02d11ff6c6741cdf0847bb7b77dbc5e868", "patch": "@@ -18,7 +18,8 @@ use fmt;\n use iter::Iterator;\n use kinds::Send;\n use option::{None, Option, Some, OptionIterator};\n-use option;\n+use option::{ToOption, IntoOption, AsOption};\n+use str::OwnedStr;\n use to_str::ToStr;\n use vec::OwnedVector;\n use vec;\n@@ -28,7 +29,7 @@ use vec;\n /// In order to provide informative error messages, `E` is required to implement `ToStr`.\n /// It is further recommended for `E` to be a descriptive error type, eg a `enum` for\n /// all possible errors cases.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, DeepClone, Eq, Ord, TotalEq, TotalOrd, ToStr)]\n pub enum Result<T, E> {\n     /// Contains the successful result value\n     Ok(T),\n@@ -300,7 +301,7 @@ impl<T, E> AsResult<T, E> for Result<T, E> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n-impl<T: Clone, E> option::ToOption<T> for Result<T, E> {\n+impl<T: Clone, E> ToOption<T> for Result<T, E> {\n     #[inline]\n     fn to_option(&self) -> Option<T> {\n         match *self {\n@@ -310,7 +311,7 @@ impl<T: Clone, E> option::ToOption<T> for Result<T, E> {\n     }\n }\n \n-impl<T, E> option::IntoOption<T> for Result<T, E> {\n+impl<T, E> IntoOption<T> for Result<T, E> {\n     #[inline]\n     fn into_option(self) -> Option<T> {\n         match self {\n@@ -320,7 +321,7 @@ impl<T, E> option::IntoOption<T> for Result<T, E> {\n     }\n }\n \n-impl<T, E> option::AsOption<T> for Result<T, E> {\n+impl<T, E> AsOption<T> for Result<T, E> {\n     #[inline]\n     fn as_option<'a>(&'a self) -> Option<&'a T> {\n         match *self {\n@@ -360,16 +361,6 @@ impl<T, E> either::AsEither<E, T> for Result<T, E> {\n     }\n }\n \n-impl<T: ToStr, E: ToStr> ToStr for Result<T, E> {\n-    #[inline]\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            Ok(ref t) => format!(\"Ok({:s})\", t.to_str()),\n-            Err(ref e) => format!(\"Err({:s})\", e.to_str())\n-        }\n-    }\n-}\n-\n impl<T: fmt::Default, E: fmt::Default> fmt::Default for Result<T, E> {\n     #[inline]\n     fn fmt(s: &Result<T, E>, f: &mut fmt::Formatter) {\n@@ -457,7 +448,7 @@ mod tests {\n     use either;\n     use iter::range;\n     use option::{IntoOption, ToOption, AsOption};\n-    use option;\n+    use option::{Option, Some, None};\n     use vec::ImmutableVector;\n     use to_str::ToStr;\n \n@@ -588,17 +579,17 @@ mod tests {\n         let ok: Result<int, int> = Ok(100);\n         let err: Result<int, int> = Err(404);\n \n-        assert_eq!(ok.to_option(), option::Some(100));\n-        assert_eq!(err.to_option(), option::None);\n+        assert_eq!(ok.to_option(), Some(100));\n+        assert_eq!(err.to_option(), None);\n     }\n \n     #[test]\n     pub fn test_into_option() {\n         let ok: Result<int, int> = Ok(100);\n         let err: Result<int, int> = Err(404);\n \n-        assert_eq!(ok.into_option(), option::Some(100));\n-        assert_eq!(err.into_option(), option::None);\n+        assert_eq!(ok.into_option(), Some(100));\n+        assert_eq!(err.into_option(), None);\n     }\n \n     #[test]\n@@ -607,7 +598,7 @@ mod tests {\n         let err: Result<int, int> = Err(404);\n \n         assert_eq!(ok.as_option().unwrap(), &100);\n-        assert_eq!(err.as_option(), option::None);\n+        assert_eq!(err.as_option(), None);\n     }\n \n     #[test]"}]}