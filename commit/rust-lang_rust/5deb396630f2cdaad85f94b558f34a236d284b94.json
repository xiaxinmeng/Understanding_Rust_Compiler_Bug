{"sha": "5deb396630f2cdaad85f94b558f34a236d284b94", "node_id": "C_kwDOAAsO6NoAKDVkZWIzOTY2MzBmMmNkYWFkODVmOTRiNTU4ZjM0YTIzNmQyODRiOTQ", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-06-25T01:45:49Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-06-25T01:45:49Z"}, "message": "Fix rustdoc under `#[no_core]`", "tree": {"sha": "4fe9a62860d073f4565b1fc7c36843dd73dd3436", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fe9a62860d073f4565b1fc7c36843dd73dd3436"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5deb396630f2cdaad85f94b558f34a236d284b94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5deb396630f2cdaad85f94b558f34a236d284b94", "html_url": "https://github.com/rust-lang/rust/commit/5deb396630f2cdaad85f94b558f34a236d284b94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5deb396630f2cdaad85f94b558f34a236d284b94/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc1fc08dc9a6957a79cc24edde4dc016debf3fa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc1fc08dc9a6957a79cc24edde4dc016debf3fa7", "html_url": "https://github.com/rust-lang/rust/commit/dc1fc08dc9a6957a79cc24edde4dc016debf3fa7"}], "stats": {"total": 60, "additions": 32, "deletions": 28}, "files": [{"sha": "f9192a5e648482b66ebf671cc24934a9adee48f5", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5deb396630f2cdaad85f94b558f34a236d284b94/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5deb396630f2cdaad85f94b558f34a236d284b94/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=5deb396630f2cdaad85f94b558f34a236d284b94", "patch": "@@ -3,12 +3,14 @@ use std::collections::BTreeMap;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::def_id::DefId;\n+use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::symbol::Symbol;\n use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n-use crate::clean::types::{FnRetTy, Function, GenericBound, Generics, Type, WherePredicate};\n+use crate::clean::types::{\n+    FnRetTy, Function, GenericBound, Generics, ItemId, Type, WherePredicate,\n+};\n use crate::formats::cache::{Cache, OrphanImplItem};\n use crate::formats::item_type::ItemType;\n use crate::html::format::join_with_double_colon;\n@@ -21,7 +23,7 @@ pub(crate) fn build_index<'tcx>(\n     cache: &mut Cache,\n     tcx: TyCtxt<'tcx>,\n ) -> String {\n-    let mut defid_to_pathid = FxHashMap::default();\n+    let mut itemid_to_pathid = FxHashMap::default();\n     let mut crate_paths = vec![];\n \n     // Attach all orphan items to the type's definition if the type\n@@ -79,38 +81,39 @@ pub(crate) fn build_index<'tcx>(\n         fn convert_render_type(\n             ty: &mut RenderType,\n             cache: &mut Cache,\n-            defid_to_pathid: &mut FxHashMap<DefId, usize>,\n+            itemid_to_pathid: &mut FxHashMap<ItemId, usize>,\n             lastpathid: &mut usize,\n             crate_paths: &mut Vec<(ItemType, Symbol)>,\n         ) {\n             if let Some(generics) = &mut ty.generics {\n                 for item in generics {\n-                    convert_render_type(item, cache, defid_to_pathid, lastpathid, crate_paths);\n+                    convert_render_type(item, cache, itemid_to_pathid, lastpathid, crate_paths);\n                 }\n             }\n             let Cache { ref paths, ref external_paths, .. } = *cache;\n             let Some(id) = ty.id.clone() else {\n                 assert!(ty.generics.is_some());\n                 return;\n             };\n-            let (defid, path, item_type) = match id {\n+            let (itemid, path, item_type) = match id {\n                 RenderTypeId::DefId(defid) => {\n                     if let Some(&(ref fqp, item_type)) =\n                         paths.get(&defid).or_else(|| external_paths.get(&defid))\n                     {\n-                        (defid, *fqp.last().unwrap(), item_type)\n+                        (ItemId::DefId(defid), *fqp.last().unwrap(), item_type)\n                     } else {\n                         ty.id = None;\n                         return;\n                     }\n                 }\n-                RenderTypeId::Primitive(primitive) => {\n-                    let defid = *cache.primitive_locations.get(&primitive).unwrap();\n-                    (defid, primitive.as_sym(), ItemType::Primitive)\n-                }\n+                RenderTypeId::Primitive(primitive) => (\n+                    ItemId::Primitive(primitive, LOCAL_CRATE),\n+                    primitive.as_sym(),\n+                    ItemType::Primitive,\n+                ),\n                 RenderTypeId::Index(_) => return,\n             };\n-            match defid_to_pathid.entry(defid) {\n+            match itemid_to_pathid.entry(itemid) {\n                 Entry::Occupied(entry) => ty.id = Some(RenderTypeId::Index(*entry.get())),\n                 Entry::Vacant(entry) => {\n                     let pathid = *lastpathid;\n@@ -126,7 +129,7 @@ pub(crate) fn build_index<'tcx>(\n                 convert_render_type(\n                     item,\n                     cache,\n-                    &mut defid_to_pathid,\n+                    &mut itemid_to_pathid,\n                     &mut lastpathid,\n                     &mut crate_paths,\n                 );\n@@ -135,7 +138,7 @@ pub(crate) fn build_index<'tcx>(\n                 convert_render_type(\n                     item,\n                     cache,\n-                    &mut defid_to_pathid,\n+                    &mut itemid_to_pathid,\n                     &mut lastpathid,\n                     &mut crate_paths,\n                 );\n@@ -149,21 +152,22 @@ pub(crate) fn build_index<'tcx>(\n     let crate_items: Vec<&IndexItem> = search_index\n         .iter_mut()\n         .map(|item| {\n-            item.parent_idx = item.parent.and_then(|defid| match defid_to_pathid.entry(defid) {\n-                Entry::Occupied(entry) => Some(*entry.get()),\n-                Entry::Vacant(entry) => {\n-                    let pathid = lastpathid;\n-                    entry.insert(pathid);\n-                    lastpathid += 1;\n-\n-                    if let Some(&(ref fqp, short)) = paths.get(&defid) {\n-                        crate_paths.push((short, *fqp.last().unwrap()));\n-                        Some(pathid)\n-                    } else {\n-                        None\n+            item.parent_idx =\n+                item.parent.and_then(|defid| match itemid_to_pathid.entry(ItemId::DefId(defid)) {\n+                    Entry::Occupied(entry) => Some(*entry.get()),\n+                    Entry::Vacant(entry) => {\n+                        let pathid = lastpathid;\n+                        entry.insert(pathid);\n+                        lastpathid += 1;\n+\n+                        if let Some(&(ref fqp, short)) = paths.get(&defid) {\n+                            crate_paths.push((short, *fqp.last().unwrap()));\n+                            Some(pathid)\n+                        } else {\n+                            None\n+                        }\n                     }\n-                }\n-            });\n+                });\n \n             // Omit the parent path if it is same to that of the prior item.\n             if lastpath == &item.path {"}]}