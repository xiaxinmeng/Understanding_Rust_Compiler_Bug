{"sha": "1d7c9bd137b883623921a7befb57ed8781a0e614", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkN2M5YmQxMzdiODgzNjIzOTIxYTdiZWZiNTdlZDg3ODFhMGU2MTQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-25T13:35:47Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:51Z"}, "message": "trans: use sizing_type_of for interacting with potentially incomplete types.", "tree": {"sha": "d3358e3f31769c81303f7e630c1be448ddfc5227", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3358e3f31769c81303f7e630c1be448ddfc5227"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d7c9bd137b883623921a7befb57ed8781a0e614", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d7c9bd137b883623921a7befb57ed8781a0e614", "html_url": "https://github.com/rust-lang/rust/commit/1d7c9bd137b883623921a7befb57ed8781a0e614", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d7c9bd137b883623921a7befb57ed8781a0e614/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d492d09f31699ff2ef1cda9da71ab3f1910a649f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d492d09f31699ff2ef1cda9da71ab3f1910a649f", "html_url": "https://github.com/rust-lang/rust/commit/d492d09f31699ff2ef1cda9da71ab3f1910a649f"}], "stats": {"total": 130, "additions": 71, "deletions": 59}, "files": [{"sha": "8bf4f143faff8f8e968608b3ae2d89fa8694b33d", "filename": "src/librustc_trans/trans/abi.rs", "status": "modified", "additions": 50, "deletions": 35, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/1d7c9bd137b883623921a7befb57ed8781a0e614/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7c9bd137b883623921a7befb57ed8781a0e614/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fabi.rs?ref=1d7c9bd137b883623921a7befb57ed8781a0e614", "patch": "@@ -61,6 +61,21 @@ pub enum ArgKind {\n pub struct ArgType {\n     pub kind: ArgKind,\n     /// Original LLVM type\n+    pub original_ty: Type,\n+    /// Sizing LLVM type (pointers are opaque).\n+    /// Unlike original_ty, this is guaranteed to be complete.\n+    ///\n+    /// For example, while we're computing the function pointer type in\n+    /// `struct Foo(fn(Foo));`, `original_ty` is still LLVM's `%Foo = {}`.\n+    /// The field type will likely end up being `void(%Foo)*`, but we cannot\n+    /// use `%Foo` to compute properties (e.g. size and alignment) of `Foo`,\n+    /// until `%Foo` is completed by having all of its field types inserted,\n+    /// so `ty` holds the \"sizing type\" of `Foo`, which replaces all pointers\n+    /// with opaque ones, resulting in `{i8*}` for `Foo`.\n+    /// ABI-specific logic can then look at the size, alignment and fields of\n+    /// `{i8*}` in order to determine how the argument will be passed.\n+    /// Only later will `original_ty` aka `%Foo` be used in the LLVM function\n+    /// pointer type, without ever having introspected it.\n     pub ty: Type,\n     /// Coerced LLVM Type\n     pub cast: Option<Type>,\n@@ -71,9 +86,10 @@ pub struct ArgType {\n }\n \n impl ArgType {\n-    fn new(ty: Type) -> ArgType {\n+    fn new(original_ty: Type, ty: Type) -> ArgType {\n         ArgType {\n             kind: Direct,\n+            original_ty: original_ty,\n             ty: ty,\n             cast: None,\n             pad: None,\n@@ -90,14 +106,6 @@ impl ArgType {\n     }\n }\n \n-fn c_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n-    if ty.is_bool() {\n-        Type::i1(cx)\n-    } else {\n-        type_of::type_of(cx, ty)\n-    }\n-}\n-\n /// Metadata describing how the arguments to a native function\n /// should be passed in order to respect the native ABI.\n ///\n@@ -147,13 +155,6 @@ impl FnType {\n             Aapcs => llvm::CCallConv,\n         };\n \n-        let rty = match sig.output {\n-            ty::FnConverging(ret_ty) if !return_type_is_void(ccx, ret_ty) => {\n-                c_type_of(ccx, ret_ty)\n-            }\n-            _ => Type::void(ccx)\n-        };\n-\n         let mut inputs = &sig.inputs[..];\n         let extra_args = if abi == RustCall {\n             assert!(!sig.variadic && extra_args.is_empty());\n@@ -173,30 +174,45 @@ impl FnType {\n             extra_args\n         };\n \n+        let arg_of = |ty: Ty<'tcx>| {\n+            if ty.is_bool() {\n+                let llty = Type::i1(ccx);\n+                let mut arg = ArgType::new(llty, llty);\n+                arg.attr = Some(llvm::Attribute::ZExt);\n+                arg\n+            } else {\n+                ArgType::new(type_of::type_of(ccx, ty),\n+                             type_of::sizing_type_of(ccx, ty))\n+            }\n+        };\n+\n+        let ret = match sig.output {\n+            ty::FnConverging(ret_ty) if !return_type_is_void(ccx, ret_ty) => {\n+                arg_of(ret_ty)\n+            }\n+            _ => ArgType::new(Type::void(ccx), Type::void(ccx))\n+        };\n+\n         let mut args = Vec::with_capacity(inputs.len() + extra_args.len());\n         for ty in inputs.iter().chain(extra_args.iter()) {\n-            let llty = c_type_of(ccx, ty);\n+            let arg = arg_of(ty);\n             if type_is_fat_ptr(ccx.tcx(), ty) {\n-                args.extend(llty.field_types().into_iter().map(ArgType::new));\n+                let original = arg.original_ty.field_types();\n+                let sizing = arg.ty.field_types();\n+                args.extend(original.into_iter().zip(sizing)\n+                                    .map(|(o, s)| ArgType::new(o, s)));\n             } else {\n-                args.push(ArgType::new(llty));\n+                args.push(arg);\n             }\n         }\n \n         let mut fty = FnType {\n             args: args,\n-            ret: ArgType::new(rty),\n+            ret: ret,\n             variadic: sig.variadic,\n             cconv: cconv\n         };\n \n-        // Add ZExt attributes to i1 arguments and returns.\n-        for arg in Some(&mut fty.ret).into_iter().chain(&mut fty.args) {\n-            if arg.ty == Type::i1(ccx) {\n-                arg.attr = Some(llvm::Attribute::ZExt);\n-            }\n-        }\n-\n         if abi == Rust || abi == RustCall {\n             let fixup = |arg: &mut ArgType| {\n                 if !arg.ty.is_aggregate() {\n@@ -213,13 +229,12 @@ impl FnType {\n                     arg.cast = Some(Type::ix(ccx, size * 8));\n                 }\n             };\n-            if let ty::FnConverging(ret_ty) = sig.output {\n+            if fty.ret.ty != Type::void(ccx) {\n                 // Fat pointers are returned by-value.\n-                if !type_is_fat_ptr(ccx.tcx(), ret_ty) &&\n-                   fty.ret.ty != Type::void(ccx) {\n+                if !type_is_fat_ptr(ccx.tcx(), sig.output.unwrap()) {\n                     fixup(&mut fty.ret);\n                 }\n-            };\n+            }\n             for arg in &mut fty.args {\n                 fixup(arg);\n             }\n@@ -256,10 +271,10 @@ impl FnType {\n         let mut llargument_tys = Vec::new();\n \n         let llreturn_ty = if self.ret.is_indirect() {\n-            llargument_tys.push(self.ret.ty.ptr_to());\n+            llargument_tys.push(self.ret.original_ty.ptr_to());\n             Type::void(ccx)\n         } else {\n-            self.ret.cast.unwrap_or(self.ret.ty)\n+            self.ret.cast.unwrap_or(self.ret.original_ty)\n         };\n \n         for arg in &self.args {\n@@ -272,9 +287,9 @@ impl FnType {\n             }\n \n             let llarg_ty = if arg.is_indirect() {\n-                arg.ty.ptr_to()\n+                arg.original_ty.ptr_to()\n             } else {\n-                arg.cast.unwrap_or(arg.ty)\n+                arg.cast.unwrap_or(arg.original_ty)\n             };\n \n             llargument_tys.push(llarg_ty);"}, {"sha": "ed96871002a1b77c0ddcea11fb98c4728596a0bf", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1d7c9bd137b883623921a7befb57ed8781a0e614/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7c9bd137b883623921a7befb57ed8781a0e614/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=1d7c9bd137b883623921a7befb57ed8781a0e614", "patch": "@@ -203,7 +203,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                i,\n                Value(llarg_rust),\n                rust_indirect,\n-               arg_ty.ty);\n+               arg_ty);\n \n         // Ensure that we always have the Rust value indirectly,\n         // because it makes bitcasting easier.\n@@ -261,12 +261,9 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // type to match because some ABIs will use a different type than\n     // the Rust type. e.g., a {u32,u32} struct could be returned as\n     // u64.\n-    if fn_type.ret.ty != Type::void(ccx) && !fn_type.ret.is_indirect() {\n-        let llrust_ret_ty = fn_type.ret.ty;\n-        let llforeign_ret_ty = match fn_type.ret.cast {\n-            Some(ty) => ty,\n-            None => fn_type.ret.ty\n-        };\n+    let llrust_ret_ty = fn_type.ret.original_ty;\n+    if llrust_ret_ty != Type::void(ccx) && !fn_type.ret.is_indirect() {\n+        let llforeign_ret_ty = fn_type.ret.cast.unwrap_or(llrust_ret_ty);\n \n         debug!(\"llretptr={:?}\", Value(llretptr));\n         debug!(\"llforeign_retval={:?}\", Value(llforeign_retval));\n@@ -625,12 +622,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                           None, Some(attributes));\n \n         // Get the return value where the foreign fn expects it.\n-        let llforeign_ret_ty = match fn_ty.ret.cast {\n-            Some(ty) => ty,\n-            None => fn_ty.ret.ty\n-        };\n+        let llforeign_ret_ty = fn_ty.ret.cast.unwrap_or(fn_ty.ret.original_ty);\n         match foreign_outptr {\n-            None if fn_ty.ret.ty == Type::void(ccx) => {\n+            None if llforeign_ret_ty == Type::void(ccx) => {\n                 // Function returns `()` or `bot`, which in Rust is the LLVM\n                 // type \"{}\" but in foreign ABIs is \"Void\".\n                 builder.ret_void();"}, {"sha": "7871ebccbd4700aacba469641ad6316f5552f3f1", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1d7c9bd137b883623921a7befb57ed8781a0e614/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7c9bd137b883623921a7befb57ed8781a0e614/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=1d7c9bd137b883623921a7befb57ed8781a0e614", "patch": "@@ -108,7 +108,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n     let llsizingty = match t.sty {\n         _ if !type_is_sized(cx.tcx(), t) => {\n-            Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n+            Type::struct_(cx, &[Type::i8p(cx), unsized_info_ty(cx, t)], false)\n         }\n \n         ty::TyBool => Type::bool(cx),\n@@ -123,7 +123,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             if type_is_sized(cx.tcx(), ty) {\n                 Type::i8p(cx)\n             } else {\n-                Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n+                Type::struct_(cx, &[Type::i8p(cx), unsized_info_ty(cx, ty)], false)\n             }\n         }\n \n@@ -177,6 +177,18 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     llsizingty\n }\n \n+fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n+    let unsized_part = ccx.tcx().struct_tail(ty);\n+    match unsized_part.sty {\n+        ty::TyStr | ty::TyArray(..) | ty::TySlice(_) => {\n+            Type::uint_from_ty(ccx, ast::UintTy::Us)\n+        }\n+        ty::TyTrait(_) => Type::vtable_ptr(ccx),\n+        _ => unreachable!(\"Unexpected tail in unsized_info_ty: {:?} for ty={:?}\",\n+                          unsized_part, ty)\n+    }\n+}\n+\n pub fn arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     if t.is_bool() {\n         Type::i1(cx)\n@@ -283,16 +295,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n                   cx.tn().find_type(\"str_slice\").unwrap()\n               } else {\n                   let ptr_ty = in_memory_type_of(cx, ty).ptr_to();\n-                  let unsized_part = cx.tcx().struct_tail(ty);\n-                  let info_ty = match unsized_part.sty {\n-                      ty::TyStr | ty::TyArray(..) | ty::TySlice(_) => {\n-                          Type::uint_from_ty(cx, ast::UintTy::Us)\n-                      }\n-                      ty::TyTrait(_) => Type::vtable_ptr(cx),\n-                      _ => panic!(\"Unexpected type returned from \\\n-                                   struct_tail: {:?} for ty={:?}\",\n-                                  unsized_part, ty)\n-                  };\n+                  let info_ty = unsized_info_ty(cx, ty);\n                   Type::struct_(cx, &[ptr_ty, info_ty], false)\n               }\n           } else {"}]}