{"sha": "8f2a040d10d0a747312ecd19fe1a253771063e0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMmEwNDBkMTBkMGE3NDczMTJlY2QxOWZlMWEyNTM3NzEwNjNlMGQ=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-06-10T11:57:58Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-08-04T14:40:57Z"}, "message": "add implicit sized to `impl Trait` parameters", "tree": {"sha": "cb719359638d9b5f8cd3b2a8bbf6fd42005c49dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb719359638d9b5f8cd3b2a8bbf6fd42005c49dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f2a040d10d0a747312ecd19fe1a253771063e0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f2a040d10d0a747312ecd19fe1a253771063e0d", "html_url": "https://github.com/rust-lang/rust/commit/8f2a040d10d0a747312ecd19fe1a253771063e0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f2a040d10d0a747312ecd19fe1a253771063e0d/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72002b401dcc0f9fb14ebf2d8d255f051bfdc513", "url": "https://api.github.com/repos/rust-lang/rust/commits/72002b401dcc0f9fb14ebf2d8d255f051bfdc513", "html_url": "https://github.com/rust-lang/rust/commit/72002b401dcc0f9fb14ebf2d8d255f051bfdc513"}], "stats": {"total": 69, "additions": 44, "deletions": 25}, "files": [{"sha": "3a9e3012319e168f7bb4ead89cb65f4727189c8e", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8f2a040d10d0a747312ecd19fe1a253771063e0d/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f2a040d10d0a747312ecd19fe1a253771063e0d/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=8f2a040d10d0a747312ecd19fe1a253771063e0d", "patch": "@@ -996,6 +996,7 @@ pub(crate) fn generic_predicates_for_param_query(\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let generics = generics(db.upcast(), param_id.parent);\n+    // TODO(iDawer): add implicitly sized clauses?\n     resolver\n         .where_predicates_in_scope()\n         // we have to filter out all other predicates *first*, before attempting to lower them\n@@ -1036,7 +1037,7 @@ pub(crate) fn trait_environment_query(\n                 traits_in_scope\n                     .push((tr.self_type_parameter(&Interner).clone(), tr.hir_trait_id()));\n             }\n-            let program_clause: chalk_ir::ProgramClause<Interner> = pred.clone().cast(&Interner);\n+            let program_clause: chalk_ir::ProgramClause<Interner> = pred.cast(&Interner);\n             clauses.push(program_clause.into_from_env_clause(&Interner));\n         }\n     }\n@@ -1063,6 +1064,15 @@ pub(crate) fn trait_environment_query(\n         clauses.push(program_clause.into_from_env_clause(&Interner));\n     }\n \n+    let subst = generics(db.upcast(), def).type_params_subst(db);\n+    let explicitly_unsized_tys = ctx.unsized_types.into_inner();\n+    let implicitly_sized_clauses =\n+        implicitly_sized_clauses(db, def, &explicitly_unsized_tys, &subst, &resolver).map(|pred| {\n+            let program_clause: chalk_ir::ProgramClause<Interner> = pred.cast(&Interner);\n+            program_clause.into_from_env_clause(&Interner)\n+        });\n+    clauses.extend(implicitly_sized_clauses);\n+\n     let krate = def.module(db.upcast()).krate();\n \n     let env = chalk_ir::Environment::new(&Interner).add_clauses(&Interner, clauses);\n@@ -1085,34 +1095,43 @@ pub(crate) fn generic_predicates_query(\n         .flat_map(|pred| ctx.lower_where_predicate(pred, false).map(|p| make_binders(&generics, p)))\n         .collect::<Vec<_>>();\n \n-    // Generate implicit `: Sized` predicates for all generics that has no `?Sized` bound.\n-    // Exception is Self of a trait.\n-    let is_trait_def = matches!(def, GenericDefId::TraitId(..));\n+    let subst = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n     let explicitly_unsized_tys = ctx.unsized_types.into_inner();\n-    let subtsts = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n-    let generic_args = &subtsts.as_slice(&Interner)[is_trait_def as usize..];\n+    let implicitly_sized_predicates =\n+        implicitly_sized_clauses(db, def, &explicitly_unsized_tys, &subst, &resolver)\n+            .map(|p| make_binders(&generics, crate::wrap_empty_binders(p)));\n+    predicates.extend(implicitly_sized_predicates);\n+    predicates.into()\n+}\n+\n+/// Generate implicit `: Sized` predicates for all generics that has no `?Sized` bound.\n+/// Exception is Self of a trait def.\n+fn implicitly_sized_clauses<'a>(\n+    db: &dyn HirDatabase,\n+    def: GenericDefId,\n+    explicitly_unsized_tys: &'a FxHashSet<Ty>,\n+    substitution: &'a Substitution,\n+    resolver: &Resolver,\n+) -> impl Iterator<Item = WhereClause> + 'a {\n+    let is_trait_def = matches!(def, GenericDefId::TraitId(..));\n+    let generic_args = &substitution.as_slice(&Interner)[is_trait_def as usize..];\n     let sized_trait = resolver\n         .krate()\n         .and_then(|krate| db.lang_item(krate, \"sized\".into()))\n         .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n-    let sized_predicates = sized_trait\n-        .into_iter()\n-        .flat_map(|sized_trait| {\n-            let implicitly_sized_tys = generic_args\n-                .iter()\n-                .filter_map(|generic_arg| generic_arg.ty(&Interner))\n-                .filter(|&self_ty| !explicitly_unsized_tys.contains(self_ty));\n-            implicitly_sized_tys.map(move |self_ty| {\n-                WhereClause::Implemented(TraitRef {\n-                    trait_id: sized_trait,\n-                    substitution: Substitution::from1(&Interner, self_ty.clone()),\n-                })\n+\n+    sized_trait.into_iter().flat_map(move |sized_trait| {\n+        let implicitly_sized_tys = generic_args\n+            .iter()\n+            .filter_map(|generic_arg| generic_arg.ty(&Interner))\n+            .filter(move |&self_ty| !explicitly_unsized_tys.contains(self_ty));\n+        implicitly_sized_tys.map(move |self_ty| {\n+            WhereClause::Implemented(TraitRef {\n+                trait_id: sized_trait,\n+                substitution: Substitution::from1(&Interner, self_ty.clone()),\n             })\n         })\n-        .map(|p| make_binders(&generics, crate::wrap_empty_binders(p)));\n-\n-    predicates.extend(sized_predicates);\n-    predicates.into()\n+    })\n }\n \n /// Resolve the default type params from generics"}, {"sha": "abf00d91ff0652432d45ea9e45dc21a6532d707e", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f2a040d10d0a747312ecd19fe1a253771063e0d/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f2a040d10d0a747312ecd19fe1a253771063e0d/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=8f2a040d10d0a747312ecd19fe1a253771063e0d", "patch": "@@ -398,15 +398,15 @@ fn test() {\n \n #[test]\n fn coerce_unsize_apit() {\n-    // FIXME: #8984\n     check(\n         r#\"\n //- minicore: coerce_unsized\n trait Foo {}\n \n-fn test(f: impl Foo) {\n+fn test(f: impl Foo, g: &(impl Foo + ?Sized)) {\n     let _: &dyn Foo = &f;\n-                    //^^ expected &dyn Foo, got &impl Foo\n+    let _: &dyn Foo = g;\n+                    //^ expected &dyn Foo, got &impl Foo\n }\n         \"#,\n     );"}]}