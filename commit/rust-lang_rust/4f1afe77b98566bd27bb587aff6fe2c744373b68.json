{"sha": "4f1afe77b98566bd27bb587aff6fe2c744373b68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMWFmZTc3Yjk4NTY2YmQyN2JiNTg3YWZmNmZlMmM3NDQzNzNiNjg=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-23T16:53:52Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-23T16:53:52Z"}, "message": "Split off path expression inference code into submodule", "tree": {"sha": "890379c54508dcd291a0fd1b2c51ab153675e811", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/890379c54508dcd291a0fd1b2c51ab153675e811"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f1afe77b98566bd27bb587aff6fe2c744373b68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f1afe77b98566bd27bb587aff6fe2c744373b68", "html_url": "https://github.com/rust-lang/rust/commit/4f1afe77b98566bd27bb587aff6fe2c744373b68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f1afe77b98566bd27bb587aff6fe2c744373b68/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea", "html_url": "https://github.com/rust-lang/rust/commit/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea"}], "stats": {"total": 371, "additions": 199, "deletions": 172}, "files": [{"sha": "81a8623bf6997ad96f9e7cfe9684f6ff33e228b8", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 4, "deletions": 172, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/4f1afe77b98566bd27bb587aff6fe2c744373b68/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1afe77b98566bd27bb587aff6fe2c744373b68/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=4f1afe77b98566bd27bb587aff6fe2c744373b68", "patch": "@@ -45,13 +45,14 @@ use crate::{\n     name,\n     nameres::Namespace,\n     path::{known, GenericArg, GenericArgs},\n-    resolve::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n+    resolve::{Resolver, TypeNs},\n     ty::infer::diagnostics::InferenceDiagnostic,\n     type_ref::{Mutability, TypeRef},\n     Adt, AssocItem, ConstData, DefWithBody, FnData, Function, HasBody, Name, Path, StructField,\n };\n \n mod unify;\n+mod path;\n \n /// The entry point of type inference.\n pub fn infer_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n@@ -466,175 +467,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         })\n     }\n \n-    fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n-        let (value, self_subst) = if let crate::PathKind::Type(type_ref) = &path.kind {\n-            if path.segments.is_empty() {\n-                // This can't actually happen syntax-wise\n-                return None;\n-            }\n-            let ty = self.make_ty(type_ref);\n-            let remaining_segments_for_ty = &path.segments[..path.segments.len() - 1];\n-            let ty = Ty::from_type_relative_path(self.db, resolver, ty, remaining_segments_for_ty);\n-            self.resolve_ty_assoc_item(\n-                ty,\n-                path.segments.last().expect(\"path had at least one segment\"),\n-                id,\n-            )?\n-        } else {\n-            let value_or_partial = resolver.resolve_path_in_value_ns(self.db, &path)?;\n-\n-            match value_or_partial {\n-                ResolveValueResult::ValueNs(it) => (it, None),\n-                ResolveValueResult::Partial(def, remaining_index) => {\n-                    self.resolve_assoc_item(def, path, remaining_index, id)?\n-                }\n-            }\n-        };\n-\n-        let typable: TypableDef = match value {\n-            ValueNs::LocalBinding(pat) => {\n-                let ty = self.result.type_of_pat.get(pat)?.clone();\n-                let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n-                return Some(ty);\n-            }\n-            ValueNs::Function(it) => it.into(),\n-            ValueNs::Const(it) => it.into(),\n-            ValueNs::Static(it) => it.into(),\n-            ValueNs::Struct(it) => it.into(),\n-            ValueNs::EnumVariant(it) => it.into(),\n-        };\n-\n-        let mut ty = self.db.type_for_def(typable, Namespace::Values);\n-        if let Some(self_subst) = self_subst {\n-            ty = ty.subst(&self_subst);\n-        }\n-\n-        let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n-        let ty = ty.subst(&substs);\n-        let ty = self.insert_type_vars(ty);\n-        let ty = self.normalize_associated_types_in(ty);\n-        Some(ty)\n-    }\n-\n-    fn resolve_assoc_item(\n-        &mut self,\n-        def: TypeNs,\n-        path: &Path,\n-        remaining_index: usize,\n-        id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substs>)> {\n-        assert!(remaining_index < path.segments.len());\n-        // there may be more intermediate segments between the resolved one and\n-        // the end. Only the last segment needs to be resolved to a value; from\n-        // the segments before that, we need to get either a type or a trait ref.\n-\n-        let resolved_segment = &path.segments[remaining_index - 1];\n-        let remaining_segments = &path.segments[remaining_index..];\n-        let is_before_last = remaining_segments.len() == 1;\n-\n-        match (def, is_before_last) {\n-            (TypeNs::Trait(_trait), true) => {\n-                // FIXME Associated item of trait, e.g. `Default::default`\n-                None\n-            }\n-            (def, _) => {\n-                // Either we already have a type (e.g. `Vec::new`), or we have a\n-                // trait but it's not the last segment, so the next segment\n-                // should resolve to an associated type of that trait (e.g. `<T\n-                // as Iterator>::Item::default`)\n-                let remaining_segments_for_ty = &remaining_segments[..remaining_segments.len() - 1];\n-                let ty = Ty::from_partly_resolved_hir_path(\n-                    self.db,\n-                    &self.resolver,\n-                    def,\n-                    resolved_segment,\n-                    remaining_segments_for_ty,\n-                );\n-                if let Ty::Unknown = ty {\n-                    return None;\n-                }\n-\n-                let segment =\n-                    remaining_segments.last().expect(\"there should be at least one segment here\");\n-\n-                self.resolve_ty_assoc_item(ty, segment, id)\n-            }\n-        }\n-    }\n-\n-    fn resolve_ty_assoc_item(\n-        &mut self,\n-        ty: Ty,\n-        segment: &crate::path::PathSegment,\n-        id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substs>)> {\n-        if let Ty::Unknown = ty {\n-            return None;\n-        }\n-\n-        let krate = self.resolver.krate()?;\n-\n-        // Find impl\n-        // FIXME: consider trait candidates\n-        let item = ty.clone().iterate_impl_items(self.db, krate, |item| match item {\n-            AssocItem::Function(func) => {\n-                if segment.name == func.name(self.db) {\n-                    Some(AssocItem::Function(func))\n-                } else {\n-                    None\n-                }\n-            }\n-\n-            AssocItem::Const(konst) => {\n-                if konst.name(self.db).map_or(false, |n| n == segment.name) {\n-                    Some(AssocItem::Const(konst))\n-                } else {\n-                    None\n-                }\n-            }\n-            AssocItem::TypeAlias(_) => None,\n-        })?;\n-        let def = match item {\n-            AssocItem::Function(f) => ValueNs::Function(f),\n-            AssocItem::Const(c) => ValueNs::Const(c),\n-            AssocItem::TypeAlias(_) => unreachable!(),\n-        };\n-        let substs = self.find_self_types(&def, ty);\n-\n-        self.write_assoc_resolution(id, item);\n-        Some((def, substs))\n-    }\n-\n-    fn find_self_types(&self, def: &ValueNs, actual_def_ty: Ty) -> Option<Substs> {\n-        if let ValueNs::Function(func) = def {\n-            // We only do the infer if parent has generic params\n-            let gen = func.generic_params(self.db);\n-            if gen.count_parent_params() == 0 {\n-                return None;\n-            }\n-\n-            let impl_block = func.impl_block(self.db)?.target_ty(self.db);\n-            let impl_block_substs = impl_block.substs()?;\n-            let actual_substs = actual_def_ty.substs()?;\n-\n-            let mut new_substs = vec![Ty::Unknown; gen.count_parent_params()];\n-\n-            // The following code *link up* the function actual parma type\n-            // and impl_block type param index\n-            impl_block_substs.iter().zip(actual_substs.iter()).for_each(|(param, pty)| {\n-                if let Ty::Param { idx, .. } = param {\n-                    if let Some(s) = new_substs.get_mut(*idx as usize) {\n-                        *s = pty.clone();\n-                    }\n-                }\n-            });\n-\n-            Some(Substs(new_substs.into()))\n-        } else {\n-            None\n-        }\n-    }\n-\n     fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantDef>) {\n         let path = match path {\n             Some(path) => path,\n@@ -807,7 +639,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Pat::Path(path) => {\n                 // FIXME use correct resolver for the surrounding expression\n                 let resolver = self.resolver.clone();\n-                self.infer_path_expr(&resolver, &path, pat.into()).unwrap_or(Ty::Unknown)\n+                self.infer_path(&resolver, &path, pat.into()).unwrap_or(Ty::Unknown)\n             }\n             Pat::Bind { mode, name: _, subpat } => {\n                 let mode = if mode == &BindingAnnotation::Unannotated {\n@@ -1121,7 +953,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n                 let resolver = expr::resolver_for_expr(self.body.clone(), self.db, tgt_expr);\n-                self.infer_path_expr(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n+                self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n             }\n             Expr::Continue => Ty::simple(TypeCtor::Never),\n             Expr::Break { expr } => {"}, {"sha": "54aae4f0ca7b87281abefd9f63596bdbaef26e36", "filename": "crates/ra_hir/src/ty/infer/path.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/4f1afe77b98566bd27bb587aff6fe2c744373b68/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1afe77b98566bd27bb587aff6fe2c744373b68/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs?ref=4f1afe77b98566bd27bb587aff6fe2c744373b68", "patch": "@@ -0,0 +1,195 @@\n+//! Path expression resolution.\n+\n+use super::{ExprOrPatId, InferenceContext};\n+use crate::{\n+    db::HirDatabase,\n+    resolve::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n+    ty::{Substs, Ty, TypableDef, TypeWalk},\n+    AssocItem, HasGenericParams, Namespace, Path,\n+};\n+\n+impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n+    pub(super) fn infer_path(\n+        &mut self,\n+        resolver: &Resolver,\n+        path: &Path,\n+        id: ExprOrPatId,\n+    ) -> Option<Ty> {\n+        let ty = self.resolve_value_path(resolver, path, id)?;\n+        let ty = self.insert_type_vars(ty);\n+        let ty = self.normalize_associated_types_in(ty);\n+        Some(ty)\n+    }\n+\n+    fn resolve_value_path(\n+        &mut self,\n+        resolver: &Resolver,\n+        path: &Path,\n+        id: ExprOrPatId,\n+    ) -> Option<Ty> {\n+        let (value, self_subst) = if let crate::PathKind::Type(type_ref) = &path.kind {\n+            if path.segments.is_empty() {\n+                // This can't actually happen syntax-wise\n+                return None;\n+            }\n+            let ty = self.make_ty(type_ref);\n+            let remaining_segments_for_ty = &path.segments[..path.segments.len() - 1];\n+            let ty = Ty::from_type_relative_path(self.db, resolver, ty, remaining_segments_for_ty);\n+            self.resolve_ty_assoc_item(\n+                ty,\n+                path.segments.last().expect(\"path had at least one segment\"),\n+                id,\n+            )?\n+        } else {\n+            let value_or_partial = resolver.resolve_path_in_value_ns(self.db, &path)?;\n+\n+            match value_or_partial {\n+                ResolveValueResult::ValueNs(it) => (it, None),\n+                ResolveValueResult::Partial(def, remaining_index) => {\n+                    self.resolve_assoc_item(def, path, remaining_index, id)?\n+                }\n+            }\n+        };\n+\n+        let typable: TypableDef = match value {\n+            ValueNs::LocalBinding(pat) => {\n+                let ty = self.result.type_of_pat.get(pat)?.clone();\n+                let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+                return Some(ty);\n+            }\n+            ValueNs::Function(it) => it.into(),\n+            ValueNs::Const(it) => it.into(),\n+            ValueNs::Static(it) => it.into(),\n+            ValueNs::Struct(it) => it.into(),\n+            ValueNs::EnumVariant(it) => it.into(),\n+        };\n+\n+        let mut ty = self.db.type_for_def(typable, Namespace::Values);\n+        if let Some(self_subst) = self_subst {\n+            ty = ty.subst(&self_subst);\n+        }\n+\n+        let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n+        let ty = ty.subst(&substs);\n+        Some(ty)\n+    }\n+\n+    fn resolve_assoc_item(\n+        &mut self,\n+        def: TypeNs,\n+        path: &Path,\n+        remaining_index: usize,\n+        id: ExprOrPatId,\n+    ) -> Option<(ValueNs, Option<Substs>)> {\n+        assert!(remaining_index < path.segments.len());\n+        // there may be more intermediate segments between the resolved one and\n+        // the end. Only the last segment needs to be resolved to a value; from\n+        // the segments before that, we need to get either a type or a trait ref.\n+\n+        let resolved_segment = &path.segments[remaining_index - 1];\n+        let remaining_segments = &path.segments[remaining_index..];\n+        let is_before_last = remaining_segments.len() == 1;\n+\n+        match (def, is_before_last) {\n+            (TypeNs::Trait(_trait), true) => {\n+                // FIXME Associated item of trait, e.g. `Default::default`\n+                None\n+            }\n+            (def, _) => {\n+                // Either we already have a type (e.g. `Vec::new`), or we have a\n+                // trait but it's not the last segment, so the next segment\n+                // should resolve to an associated type of that trait (e.g. `<T\n+                // as Iterator>::Item::default`)\n+                let remaining_segments_for_ty = &remaining_segments[..remaining_segments.len() - 1];\n+                let ty = Ty::from_partly_resolved_hir_path(\n+                    self.db,\n+                    &self.resolver,\n+                    def,\n+                    resolved_segment,\n+                    remaining_segments_for_ty,\n+                );\n+                if let Ty::Unknown = ty {\n+                    return None;\n+                }\n+\n+                let segment =\n+                    remaining_segments.last().expect(\"there should be at least one segment here\");\n+\n+                self.resolve_ty_assoc_item(ty, segment, id)\n+            }\n+        }\n+    }\n+\n+    fn resolve_ty_assoc_item(\n+        &mut self,\n+        ty: Ty,\n+        segment: &crate::path::PathSegment,\n+        id: ExprOrPatId,\n+    ) -> Option<(ValueNs, Option<Substs>)> {\n+        if let Ty::Unknown = ty {\n+            return None;\n+        }\n+\n+        let krate = self.resolver.krate()?;\n+\n+        // Find impl\n+        // FIXME: consider trait candidates\n+        let item = ty.clone().iterate_impl_items(self.db, krate, |item| match item {\n+            AssocItem::Function(func) => {\n+                if segment.name == func.name(self.db) {\n+                    Some(AssocItem::Function(func))\n+                } else {\n+                    None\n+                }\n+            }\n+\n+            AssocItem::Const(konst) => {\n+                if konst.name(self.db).map_or(false, |n| n == segment.name) {\n+                    Some(AssocItem::Const(konst))\n+                } else {\n+                    None\n+                }\n+            }\n+            AssocItem::TypeAlias(_) => None,\n+        })?;\n+        let def = match item {\n+            AssocItem::Function(f) => ValueNs::Function(f),\n+            AssocItem::Const(c) => ValueNs::Const(c),\n+            AssocItem::TypeAlias(_) => unreachable!(),\n+        };\n+        let substs = self.find_self_types(&def, ty);\n+\n+        self.write_assoc_resolution(id, item);\n+        Some((def, substs))\n+    }\n+\n+    fn find_self_types(&self, def: &ValueNs, actual_def_ty: Ty) -> Option<Substs> {\n+        if let ValueNs::Function(func) = def {\n+            // We only do the infer if parent has generic params\n+            let gen = func.generic_params(self.db);\n+            if gen.count_parent_params() == 0 {\n+                return None;\n+            }\n+\n+            let impl_block = func.impl_block(self.db)?.target_ty(self.db);\n+            let impl_block_substs = impl_block.substs()?;\n+            let actual_substs = actual_def_ty.substs()?;\n+\n+            let mut new_substs = vec![Ty::Unknown; gen.count_parent_params()];\n+\n+            // The following code *link up* the function actual parma type\n+            // and impl_block type param index\n+            impl_block_substs.iter().zip(actual_substs.iter()).for_each(|(param, pty)| {\n+                if let Ty::Param { idx, .. } = param {\n+                    if let Some(s) = new_substs.get_mut(*idx as usize) {\n+                        *s = pty.clone();\n+                    }\n+                }\n+            });\n+\n+            Some(Substs(new_substs.into()))\n+        } else {\n+            None\n+        }\n+    }\n+}"}]}