{"sha": "44631722ff234241cb7100103320a402fe4fdfa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NjMxNzIyZmYyMzQyNDFjYjcxMDAxMDMzMjBhNDAyZmU0ZmRmYTk=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-07-26T22:46:34Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-07-26T22:48:25Z"}, "message": "Tutorial fixes\n\nCloses #3032\nCloses #3031\nCloses #3030\nCloses #3028", "tree": {"sha": "64cd379adfc468550748c2be787e8f888fdbffed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64cd379adfc468550748c2be787e8f888fdbffed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44631722ff234241cb7100103320a402fe4fdfa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44631722ff234241cb7100103320a402fe4fdfa9", "html_url": "https://github.com/rust-lang/rust/commit/44631722ff234241cb7100103320a402fe4fdfa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44631722ff234241cb7100103320a402fe4fdfa9/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afd9a75c9ebf56b0a387928cdbef7d086200f534", "url": "https://api.github.com/repos/rust-lang/rust/commits/afd9a75c9ebf56b0a387928cdbef7d086200f534", "html_url": "https://github.com/rust-lang/rust/commit/afd9a75c9ebf56b0a387928cdbef7d086200f534"}], "stats": {"total": 38, "additions": 22, "deletions": 16}, "files": [{"sha": "ed32100c6fc644f3d952b517c73f03c3cd96f4b1", "filename": "doc/tutorial.md", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/44631722ff234241cb7100103320a402fe4fdfa9/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/44631722ff234241cb7100103320a402fe4fdfa9/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=44631722ff234241cb7100103320a402fe4fdfa9", "patch": "@@ -735,9 +735,12 @@ of numeric literal patterns can be expressed with `to`. The underscore\n (`_`) is a wildcard pattern that matches everything.\n \n If the arm with the wildcard pattern was left off in the above\n-example, running it on a number greater than ten (or negative) would\n-cause a run-time failure. When no arm matches, `alt` constructs do not\n-silently fall through\u2014they blow up instead.\n+example, the typechecker would reject it at compile time. `alt`\n+constructs must be exhaustive: they must have an arm covering every\n+possible case. (You may use the `alt check` construct to write a\n+non-exhaustive match, but it's highly undesirable to do so. You may\n+reason that the missing cases will never occur, but the typechecker\n+provides you with no assurance that your reasoning is correct.)\n \n A powerful application of pattern matching is *destructuring*, where\n you use the matching to get at the contents of data types. Remember\n@@ -2500,8 +2503,8 @@ impl <T> of seq<T> for ~[T] {\n }\n ~~~~\n \n-Note that the implementation has to explicitly declare the its\n-parameter `T` before using it to specify its trait type. This is\n+Note that the implementation has to explicitly declare the type\n+parameter that it binds, `T`, before using it to specify its trait type. This is\n needed because it could also, for example, specify an implementation\n of `seq<int>`\u2014the `of` clause *refers* to a type, rather than defining\n one.\n@@ -2621,9 +2624,10 @@ OpenSSL libraries installed, it should 'just work'.\n \n ~~~~ {.xfail-test}\n use std;\n+import libc::c_uint;\n \n extern mod crypto {\n-    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+    fn SHA1(src: *u8, sz: c_uint, out: *u8) -> *u8;\n }\n \n fn as_hex(data: ~[u8]) -> ~str {\n@@ -2635,7 +2639,7 @@ fn as_hex(data: ~[u8]) -> ~str {\n fn sha1(data: ~str) -> ~str unsafe {\n     let bytes = str::bytes(data);\n     let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n-                            vec::len(bytes), ptr::null());\n+                            vec::len(bytes) as c_uint, ptr::null());\n     ret as_hex(vec::unsafe::from_buf(hash, 20u));\n }\n \n@@ -2701,7 +2705,7 @@ return a pointer.\n \n ~~~~ {.xfail-test}\n # extern mod crypto {\n-fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+fn SHA1(src: *u8, sz: libc::c_uint, out: *u8) -> *u8;\n # }\n ~~~~\n \n@@ -2792,7 +2796,7 @@ This pointer will become invalid as soon as the vector it points into\n is cleaned up, so you should be very careful how you use it. In this\n case, the local variable `bytes` outlives the pointer, so we're good.\n \n-Passing a null pointer as third argument to `SHA1` causes it to use a\n+Passing a null pointer as the third argument to `SHA1` makes it use a\n static buffer, and thus save us the effort of allocating memory\n ourselves. `ptr::null` is a generic function that will return an\n unsafe null pointer of the correct type (Rust generics are awesome\n@@ -2815,15 +2819,17 @@ microsecond-resolution timer.\n \n ~~~~\n use std;\n-type timeval = {mut tv_sec: uint,\n-                mut tv_usec: uint};\n+import libc::c_ulonglong;\n+\n+type timeval = {mut tv_sec: c_ulonglong,\n+                mut tv_usec: c_ulonglong};\n #[nolink]\n-extern mod libc {\n+extern mod lib_c {\n     fn gettimeofday(tv: *timeval, tz: *()) -> i32;\n }\n fn unix_time_in_microseconds() -> u64 unsafe {\n-    let x = {mut tv_sec: 0u, mut tv_usec: 0u};\n-    libc::gettimeofday(ptr::addr_of(x), ptr::null());\n+    let x = {mut tv_sec: 0 as c_ulonglong, mut tv_usec: 0 as c_ulonglong};\n+    lib_c::gettimeofday(ptr::addr_of(x), ptr::null());\n     ret (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n }\n \n@@ -2839,8 +2845,8 @@ define a record type with the same contents, and declare\n \n The second argument to `gettimeofday` (the time zone) is not used by\n this program, so it simply declares it to be a pointer to the nil\n-type. Since null pointer look the same, no matter which type they are\n-supposed to point at, this is safe.\n+type. Since all null pointers have the same representation regardless of\n+their referent type, this is safe.\n \n # Tasks\n "}]}