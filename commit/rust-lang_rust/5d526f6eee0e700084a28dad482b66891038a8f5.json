{"sha": "5d526f6eee0e700084a28dad482b66891038a8f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNTI2ZjZlZWUwZTcwMDA4NGEyOGRhZDQ4MmI2Njg5MTAzOGE4ZjU=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-07T17:01:56Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-16T04:19:00Z"}, "message": "Take sys/vxworks/thread from sys/unix instead.", "tree": {"sha": "946fa1f30eaa2e76f637d3f0e6bf29f53500534c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/946fa1f30eaa2e76f637d3f0e6bf29f53500534c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d526f6eee0e700084a28dad482b66891038a8f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d526f6eee0e700084a28dad482b66891038a8f5", "html_url": "https://github.com/rust-lang/rust/commit/5d526f6eee0e700084a28dad482b66891038a8f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d526f6eee0e700084a28dad482b66891038a8f5/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8628f43bfe9df8b06283fdc1d8acb4643f74194", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8628f43bfe9df8b06283fdc1d8acb4643f74194", "html_url": "https://github.com/rust-lang/rust/commit/c8628f43bfe9df8b06283fdc1d8acb4643f74194"}], "stats": {"total": 165, "additions": 7, "deletions": 158}, "files": [{"sha": "fdf114d6df6fec17fd354e14acee433c9b152c77", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d526f6eee0e700084a28dad482b66891038a8f5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d526f6eee0e700084a28dad482b66891038a8f5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=5d526f6eee0e700084a28dad482b66891038a8f5", "patch": "@@ -6,10 +6,12 @@ use crate::ptr;\n use crate::sys::{os, stack_overflow};\n use crate::time::Duration;\n \n-#[cfg(not(target_os = \"l4re\"))]\n+#[cfg(not(any(target_os = \"l4re\", target_os = \"vxworks\")))]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n #[cfg(target_os = \"l4re\")]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 1024 * 1024;\n+#[cfg(target_os = \"vxworks\")]\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 256 * 1024;\n \n pub struct Thread {\n     id: libc::pthread_t,\n@@ -152,10 +154,11 @@ impl Thread {\n         target_os = \"haiku\",\n         target_os = \"l4re\",\n         target_os = \"emscripten\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     ))]\n     pub fn set_name(_name: &CStr) {\n-        // Newlib, Haiku, and Emscripten have no way to set a thread name.\n+        // Newlib, Haiku, Emscripten, and VxWorks have no way to set a thread name.\n     }\n     #[cfg(target_os = \"fuchsia\")]\n     pub fn set_name(_name: &CStr) {"}, {"sha": "142d70ebb5c1035d58a8a9359ec44c5054702269", "filename": "library/std/src/sys/vxworks/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d526f6eee0e700084a28dad482b66891038a8f5/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d526f6eee0e700084a28dad482b66891038a8f5/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs?ref=5d526f6eee0e700084a28dad482b66891038a8f5", "patch": "@@ -31,6 +31,7 @@ pub mod rwlock;\n #[path = \"../unix/stack_overflow.rs\"]\n pub mod stack_overflow;\n pub mod stdio;\n+#[path = \"../unix/thread.rs\"]\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;"}, {"sha": "24a2e0f965d28f1caa255b2cb902b91b80255454", "filename": "library/std/src/sys/vxworks/thread.rs", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c8628f43bfe9df8b06283fdc1d8acb4643f74194/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8628f43bfe9df8b06283fdc1d8acb4643f74194/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fthread.rs?ref=c8628f43bfe9df8b06283fdc1d8acb4643f74194", "patch": "@@ -1,155 +0,0 @@\n-use crate::cmp;\n-use crate::ffi::CStr;\n-use crate::io;\n-use crate::mem;\n-use crate::ptr;\n-use crate::sys::{os, stack_overflow};\n-use crate::time::Duration;\n-\n-pub const DEFAULT_MIN_STACK_SIZE: usize = 0x40000; // 256K\n-\n-pub struct Thread {\n-    id: libc::pthread_t,\n-}\n-\n-// Some platforms may have pthread_t as a pointer in which case we still want\n-// a thread to be Send/Sync\n-unsafe impl Send for Thread {}\n-unsafe impl Sync for Thread {}\n-\n-// The pthread_attr_setstacksize symbol doesn't exist in the emscripten libc,\n-// so we have to not link to it to satisfy emcc's ERROR_ON_UNDEFINED_SYMBOLS.\n-unsafe fn pthread_attr_setstacksize(\n-    attr: *mut libc::pthread_attr_t,\n-    stack_size: libc::size_t,\n-) -> libc::c_int {\n-    libc::pthread_attr_setstacksize(attr, stack_size)\n-}\n-\n-impl Thread {\n-    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = Box::into_raw(box p);\n-        let mut native: libc::pthread_t = mem::zeroed();\n-        let mut attr: libc::pthread_attr_t = mem::zeroed();\n-        assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n-\n-        let stack_size = cmp::max(stack, min_stack_size(&attr));\n-\n-        match pthread_attr_setstacksize(&mut attr, stack_size) {\n-            0 => {}\n-            n => {\n-                assert_eq!(n, libc::EINVAL);\n-                // EINVAL means |stack_size| is either too small or not a\n-                // multiple of the system page size.  Because it's definitely\n-                // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n-                // Round up to the nearest page and try again.\n-                let page_size = os::page_size();\n-                let stack_size =\n-                    (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);\n-                assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n-            }\n-        };\n-\n-        let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n-        // Note: if the thread creation fails and this assert fails, then p will\n-        // be leaked. However, an alternative design could cause double-free\n-        // which is clearly worse.\n-        assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n-\n-        return if ret != 0 {\n-            // The thread failed to start and as a result p was not consumed. Therefore, it is\n-            // safe to reconstruct the box so that it gets deallocated.\n-            drop(Box::from_raw(p));\n-            Err(io::Error::from_raw_os_error(ret))\n-        } else {\n-            Ok(Thread { id: native })\n-        };\n-\n-        extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n-            unsafe {\n-                // Next, set up our stack overflow handler which may get triggered if we run\n-                // out of stack.\n-                let _handler = stack_overflow::Handler::new();\n-                // Finally, let's run some code.\n-                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n-            }\n-            ptr::null_mut()\n-        }\n-    }\n-\n-    pub fn yield_now() {\n-        let ret = unsafe { libc::sched_yield() };\n-        debug_assert_eq!(ret, 0);\n-    }\n-\n-    pub fn set_name(_name: &CStr) {\n-        // VxWorks does not provide a way to set the task name except at creation time\n-    }\n-\n-    pub fn sleep(dur: Duration) {\n-        let mut secs = dur.as_secs();\n-        let mut nsecs = dur.subsec_nanos() as _;\n-\n-        // If we're awoken with a signal then the return value will be -1 and\n-        // nanosleep will fill in `ts` with the remaining time.\n-        unsafe {\n-            while secs > 0 || nsecs > 0 {\n-                let mut ts = libc::timespec {\n-                    tv_sec: cmp::min(libc::time_t::MAX as u64, secs) as libc::time_t,\n-                    tv_nsec: nsecs,\n-                };\n-                secs -= ts.tv_sec as u64;\n-                if libc::nanosleep(&ts, &mut ts) == -1 {\n-                    assert_eq!(os::errno(), libc::EINTR);\n-                    secs += ts.tv_sec as u64;\n-                    nsecs = ts.tv_nsec;\n-                } else {\n-                    nsecs = 0;\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn join(self) {\n-        unsafe {\n-            let ret = libc::pthread_join(self.id, ptr::null_mut());\n-            mem::forget(self);\n-            assert!(ret == 0, \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n-        }\n-    }\n-\n-    pub fn id(&self) -> libc::pthread_t {\n-        self.id\n-    }\n-\n-    pub fn into_id(self) -> libc::pthread_t {\n-        let id = self.id;\n-        mem::forget(self);\n-        id\n-    }\n-}\n-\n-impl Drop for Thread {\n-    fn drop(&mut self) {\n-        let ret = unsafe { libc::pthread_detach(self.id) };\n-        debug_assert_eq!(ret, 0);\n-    }\n-}\n-\n-#[cfg_attr(test, allow(dead_code))]\n-pub mod guard {\n-    use crate::ops::Range;\n-    pub type Guard = Range<usize>;\n-    pub unsafe fn current() -> Option<Guard> {\n-        None\n-    }\n-    pub unsafe fn init() -> Option<Guard> {\n-        None\n-    }\n-    pub unsafe fn deinit() {}\n-}\n-\n-fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n-    libc::PTHREAD_STACK_MIN\n-}"}]}