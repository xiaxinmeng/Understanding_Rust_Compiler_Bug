{"sha": "3097453f21668bb5469f8f5ef768de4d225856c6", "node_id": "C_kwDOAAsO6NoAKDMwOTc0NTNmMjE2NjhiYjU0NjlmOGY1ZWY3NjhkZTRkMjI1ODU2YzY", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-03-09T13:36:54Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-03-09T13:36:54Z"}, "message": "improve readability of winnowing", "tree": {"sha": "272af0d767e0335ae34fc4825caa51b696aa9746", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/272af0d767e0335ae34fc4825caa51b696aa9746"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3097453f21668bb5469f8f5ef768de4d225856c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3097453f21668bb5469f8f5ef768de4d225856c6", "html_url": "https://github.com/rust-lang/rust/commit/3097453f21668bb5469f8f5ef768de4d225856c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3097453f21668bb5469f8f5ef768de4d225856c6/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39f2657d1101b50f9b71ae460b762d330cc8426b", "url": "https://api.github.com/repos/rust-lang/rust/commits/39f2657d1101b50f9b71ae460b762d330cc8426b", "html_url": "https://github.com/rust-lang/rust/commit/39f2657d1101b50f9b71ae460b762d330cc8426b"}], "stats": {"total": 105, "additions": 66, "deletions": 39}, "files": [{"sha": "d28af1c29e9ab029276950e4d3449a24705dac5e", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 66, "deletions": 39, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/3097453f21668bb5469f8f5ef768de4d225856c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3097453f21668bb5469f8f5ef768de4d225856c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=3097453f21668bb5469f8f5ef768de4d225856c6", "patch": "@@ -465,14 +465,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if candidates.len() > 1 {\n             let mut i = 0;\n             while i < candidates.len() {\n-                let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n+                let should_drop_i = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n                     self.candidate_should_be_dropped_in_favor_of(\n                         &candidates[i],\n                         &candidates[j],\n                         needs_infer,\n-                    )\n+                    ) == DropVictim::Yes\n                 });\n-                if is_dup {\n+                if should_drop_i {\n                     debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n                     candidates.swap_remove(i);\n                 } else {\n@@ -1842,15 +1842,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ProjectionMatchesProjection::No\n         }\n     }\n+}\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // WINNOW\n-    //\n-    // Winnowing is the process of attempting to resolve ambiguity by\n-    // probing further. During the winnowing process, we unify all\n-    // type variables and then we also attempt to evaluate recursive\n-    // bounds to see if they are satisfied.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+enum DropVictim {\n+    Yes,\n+    No,\n+}\n \n+/// ## Winnowing\n+///\n+/// Winnowing is the process of attempting to resolve ambiguity by\n+/// probing further. During the winnowing process, we unify all\n+/// type variables and then we also attempt to evaluate recursive\n+/// bounds to see if they are satisfied.\n+impl<'tcx> SelectionContext<'_, 'tcx> {\n     /// Returns `true` if `victim` should be dropped in favor of\n     /// `other`. Generally speaking we will drop duplicate\n     /// candidates and prefer where-clause candidates.\n@@ -1861,9 +1867,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         victim: &EvaluatedCandidate<'tcx>,\n         other: &EvaluatedCandidate<'tcx>,\n         needs_infer: bool,\n-    ) -> bool {\n+    ) -> DropVictim {\n         if victim.candidate == other.candidate {\n-            return true;\n+            return DropVictim::Yes;\n         }\n \n         // Check if a bound would previously have been removed when normalizing\n@@ -1887,11 +1893,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // FIXME(@jswrenn): this should probably be more sophisticated\n-            (TransmutabilityCandidate, _) | (_, TransmutabilityCandidate) => false,\n+            (TransmutabilityCandidate, _) | (_, TransmutabilityCandidate) => DropVictim::No,\n \n             // (*)\n-            (BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_), _) => true,\n-            (_, BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_)) => false,\n+            (BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_), _) => {\n+                DropVictim::Yes\n+            }\n+            (_, BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_)) => {\n+                DropVictim::No\n+            }\n \n             (ParamCandidate(other), ParamCandidate(victim)) => {\n                 let same_except_bound_vars = other.skip_binder().trait_ref\n@@ -1905,28 +1915,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // or the current one if tied (they should both evaluate to the same answer). This is\n                     // probably best characterized as a \"hack\", since we might prefer to just do our\n                     // best to *not* create essentially duplicate candidates in the first place.\n-                    other.bound_vars().len() <= victim.bound_vars().len()\n+                    if other.bound_vars().len() <= victim.bound_vars().len() {\n+                        DropVictim::Yes\n+                    } else {\n+                        DropVictim::No\n+                    }\n                 } else if other.skip_binder().trait_ref == victim.skip_binder().trait_ref\n                     && victim.skip_binder().constness == ty::BoundConstness::NotConst\n                     && other.skip_binder().polarity == victim.skip_binder().polarity\n                 {\n                     // Drop otherwise equivalent non-const candidates in favor of const candidates.\n-                    true\n+                    DropVictim::Yes\n                 } else {\n-                    false\n+                    DropVictim::No\n                 }\n             }\n \n             // Drop otherwise equivalent non-const fn pointer candidates\n-            (FnPointerCandidate { .. }, FnPointerCandidate { is_const: false }) => true,\n+            (FnPointerCandidate { .. }, FnPointerCandidate { is_const: false }) => DropVictim::Yes,\n \n-            // Global bounds from the where clause should be ignored\n-            // here (see issue #50825). Otherwise, we have a where\n-            // clause so don't go around looking for impls.\n-            // Arbitrarily give param candidates priority\n-            // over projection and object candidates.\n             (\n-                ParamCandidate(ref cand),\n+                ParamCandidate(ref other_cand),\n                 ImplCandidate(..)\n                 | ClosureCandidate { .. }\n                 | GeneratorCandidate\n@@ -1939,11 +1948,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitAliasCandidate\n                 | ObjectCandidate(_)\n                 | ProjectionCandidate(..),\n-            ) => !is_global(cand),\n-            (ObjectCandidate(_) | ProjectionCandidate(..), ParamCandidate(ref cand)) => {\n+            ) => {\n+                if is_global(other_cand) {\n+                    DropVictim::No\n+                } else {\n+                    // We have a where clause so don't go around looking\n+                    // for impls. Arbitrarily give param candidates priority\n+                    // over projection and object candidates.\n+                    //\n+                    // Global bounds from the where clause should be ignored\n+                    // here (see issue #50825).\n+                    DropVictim::Yes\n+                }\n+            }\n+            (ObjectCandidate(_) | ProjectionCandidate(..), ParamCandidate(ref victim_cand)) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n-                is_global(cand)\n+                if is_global(victim_cand) { DropVictim::Yes } else { DropVictim::No }\n             }\n             (\n                 ImplCandidate(_)\n@@ -1956,18 +1977,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { has_nested: true }\n                 | TraitAliasCandidate,\n-                ParamCandidate(ref cand),\n+                ParamCandidate(ref victim_cand),\n             ) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n-                is_global(cand) && other.evaluation.must_apply_modulo_regions()\n+                if is_global(victim_cand) && other.evaluation.must_apply_modulo_regions() {\n+                    DropVictim::Yes\n+                } else {\n+                    DropVictim::No\n+                }\n             }\n \n             (ProjectionCandidate(i, _), ProjectionCandidate(j, _))\n             | (ObjectCandidate(i), ObjectCandidate(j)) => {\n                 // Arbitrarily pick the lower numbered candidate for backwards\n                 // compatibility reasons. Don't let this affect inference.\n-                i < j && !needs_infer\n+                if i < j && !needs_infer { DropVictim::Yes } else { DropVictim::No }\n             }\n             (ObjectCandidate(_), ProjectionCandidate(..))\n             | (ProjectionCandidate(..), ObjectCandidate(_)) => {\n@@ -1987,7 +2012,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate,\n-            ) => true,\n+            ) => DropVictim::Yes,\n \n             (\n                 ImplCandidate(..)\n@@ -2001,7 +2026,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate,\n                 ObjectCandidate(_) | ProjectionCandidate(..),\n-            ) => false,\n+            ) => DropVictim::No,\n \n             (&ImplCandidate(other_def), &ImplCandidate(victim_def)) => {\n                 // See if we can toss out `victim` based on specialization.\n@@ -2014,7 +2039,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let tcx = self.tcx();\n                 if other.evaluation.must_apply_modulo_regions() {\n                     if tcx.specializes((other_def, victim_def)) {\n-                        return true;\n+                        return DropVictim::Yes;\n                     }\n                 }\n \n@@ -2060,13 +2085,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             // will then correctly report an inference error, since the\n                             // existence of multiple marker trait impls tells us nothing\n                             // about which one should actually apply.\n-                            !needs_infer\n+                            if needs_infer { DropVictim::No } else { DropVictim::Yes }\n                         }\n-                        Some(_) => true,\n-                        None => false,\n+                        Some(_) => DropVictim::Yes,\n+                        None => DropVictim::No,\n                     }\n                 } else {\n-                    false\n+                    DropVictim::No\n                 }\n             }\n \n@@ -2092,10 +2117,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { has_nested: true }\n                 | TraitAliasCandidate,\n-            ) => false,\n+            ) => DropVictim::No,\n         }\n     }\n+}\n \n+impl<'tcx> SelectionContext<'_, 'tcx> {\n     fn sized_conditions(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,"}]}