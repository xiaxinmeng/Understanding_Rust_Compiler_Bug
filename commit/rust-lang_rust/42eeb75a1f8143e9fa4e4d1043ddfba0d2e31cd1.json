{"sha": "42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyZWViNzVhMWY4MTQzZTlmYTRlNGQxMDQzZGRmYmEwZDJlMzFjZDE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-30T18:27:26Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-30T18:27:50Z"}, "message": "Merge branch 'wip_unsized_types'\n\ncc #14", "tree": {"sha": "f547cda0953a26abebf48790d377d578f3b1dffc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f547cda0953a26abebf48790d377d578f3b1dffc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1", "html_url": "https://github.com/rust-lang/rust/commit/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8111eee37a6e60abc49e95646bb654efd3af0fb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8111eee37a6e60abc49e95646bb654efd3af0fb6", "html_url": "https://github.com/rust-lang/rust/commit/8111eee37a6e60abc49e95646bb654efd3af0fb6"}, {"sha": "9878eea61c7a715d798640e932d9752043599ee3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9878eea61c7a715d798640e932d9752043599ee3", "html_url": "https://github.com/rust-lang/rust/commit/9878eea61c7a715d798640e932d9752043599ee3"}], "stats": {"total": 241, "additions": 201, "deletions": 40}, "files": [{"sha": "a3d31c6c7706bc232c0219afa4217d2e1b4a9acd", "filename": "build.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/build.sh", "raw_url": "https://github.com/rust-lang/rust/raw/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/build.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.sh?ref=42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1", "patch": "@@ -41,4 +41,4 @@ gcc target/out/mini_core.o target/out/mini_core_hello_world.o -o target/out/mini\n ./target/out/mini_core_hello_world\n \n $RUSTC target/libcore/src/libcore/lib.rs --color=always --crate-type lib -Cincremental=target/incremental 2>&1 | (head -n 20; echo \"====\"; tail -n 1000)\n-cat target/out/log.txt | sort | uniq -c | grep -v \"rval unsize move\" | grep -v \"rval len\"\n+cat target/out/log.txt | sort | uniq -c"}, {"sha": "5df8e69efd3e9191cb7b5c6f73a4d98ed8885d84", "filename": "examples/example.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/examples%2Fexample.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/examples%2Fexample.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/examples%2Fexample.rs?ref=42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1", "patch": "@@ -141,9 +141,9 @@ unsafe fn call_uninit() -> u8 {\n }\n \n // TODO: enable when fat pointers are supported\n-/*unsafe fn deref_str_ptr(s: *const str) -> &'static str {\n+unsafe fn deref_str_ptr(s: *const str) -> &'static str {\n     &*s\n-}*/\n+}\n \n fn use_array(arr: [u8; 3]) -> u8 {\n     arr[1]\n@@ -153,6 +153,10 @@ fn repeat_array() -> [u8; 3] {\n     [0; 3]\n }\n \n+fn array_as_slice(arr: &[u8; 3]) -> &[u8] {\n+    arr\n+}\n+\n /*unsafe fn use_ctlz_nonzero(a: u16) -> u16 {\n     intrinsics::ctlz_nonzero(a)\n }*/\n@@ -176,3 +180,7 @@ fn make_array() -> [u8; 3] {\n fn some_promoted_tuple() -> &'static (&'static str, &'static str) {\n     &(\"abc\", \"some\")\n }\n+\n+fn index_slice(s: &[u8]) -> u8 {\n+    s[2]\n+}"}, {"sha": "2eb2e95025654e65f0e0609153e07ed0df694dce", "filename": "examples/mini_core.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/examples%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/examples%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/examples%2Fmini_core.rs?ref=42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1", "patch": "@@ -207,3 +207,11 @@ impl<T> Index<usize> for [T; 3] {\n         &self[index]\n     }\n }\n+\n+impl<T> Index<usize> for [T] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}"}, {"sha": "c775beef2f09ea5a9b6e90a57f11864af5ba3c59", "filename": "examples/mini_core_hello_world.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/examples%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/examples%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/examples%2Fmini_core_hello_world.rs?ref=42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1", "patch": "@@ -43,7 +43,8 @@ static NUM_REF: &'static u8 = unsafe { &NUM };\n \n fn main() {\n     unsafe {\n-        let (ptr, _): (*const u8, usize) = intrinsics::transmute(\"Hello!\\0\");\n+        let slice: &[u8] = b\"Hello!\\0\" as &[u8; 7];\n+        let ptr: *const u8 = slice as *const [u8] as *const u8;\n         puts(ptr);\n     }\n "}, {"sha": "112d87743feabbd54aac4b26ed35010a57d8d19f", "filename": "src/abi.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1", "patch": "@@ -28,6 +28,11 @@ fn get_pass_mode<'a, 'tcx: 'a>(\n     ty: Ty<'tcx>,\n     is_return: bool,\n ) -> PassMode {\n+    assert!(\n+        !tcx.layout_of(ParamEnv::reveal_all().and(ty))\n+            .unwrap()\n+            .is_unsized()\n+    );\n     if ty.sty == tcx.mk_nil().sty {\n         if is_return {\n             //if false {\n@@ -312,7 +317,7 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n             //unimplemented!(\"pass mode nopass\");\n             fx.local_map.insert(\n                 RETURN_PLACE,\n-                CPlace::Addr(null, fx.layout_of(fx.return_type())),\n+                CPlace::Addr(null, None, fx.layout_of(fx.return_type())),\n             );\n         }\n         PassMode::ByVal(ret_ty) => {\n@@ -321,8 +326,10 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n                 .insert(RETURN_PLACE, CPlace::Var(RETURN_PLACE, ret_layout));\n         }\n         PassMode::ByRef => {\n-            fx.local_map\n-                .insert(RETURN_PLACE, CPlace::Addr(ret_param.unwrap(), ret_layout));\n+            fx.local_map.insert(\n+                RETURN_PLACE,\n+                CPlace::Addr(ret_param.unwrap(), None, ret_layout),\n+            );\n         }\n     }\n "}, {"sha": "c0ea7644f9037b3134da3536535a86b364285da7", "filename": "src/base.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1", "patch": "@@ -309,8 +309,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                 }\n                 Rvalue::Ref(_, _, place) => {\n                     let place = trans_place(fx, place);\n-                    let addr = place.expect_addr();\n-                    lval.write_cvalue(fx, CValue::ByVal(addr, dest_layout));\n+                    place.write_place_ref(fx, lval);\n                 }\n                 Rvalue::BinaryOp(bin_op, lhs, rhs) => {\n                     let ty = fx.monomorphize(&lhs.ty(&fx.mir.local_decls, fx.tcx));\n@@ -459,7 +458,8 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                     unimplemented!(\"rval closure_fn_ptr {:?} {:?}\", operand, ty)\n                 }\n                 Rvalue::Cast(CastKind::Unsize, operand, ty) => {\n-                    unimpl!(\"rval unsize {:?} {:?}\", operand, ty);\n+                    let operand = trans_operand(fx, operand);\n+                    operand.unsize_value(fx, lval);\n                 }\n                 Rvalue::Discriminant(place) => {\n                     let place = trans_place(fx, place).to_cvalue(fx);\n@@ -474,7 +474,15 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                         to.write_cvalue(fx, operand);\n                     }\n                 }\n-                Rvalue::Len(lval) => unimpl!(\"rval len {:?}\", lval),\n+                Rvalue::Len(place) => {\n+                    let place = trans_place(fx, place);\n+                    let size = match place {\n+                        CPlace::Addr(_, size, _) => size.unwrap(),\n+                        CPlace::Var(_, _) => unreachable!(),\n+                    };\n+                    let usize_layout = fx.layout_of(fx.tcx.types.usize);\n+                    lval.write_cvalue(fx, CValue::ByVal(size, usize_layout));\n+                }\n                 Rvalue::NullaryOp(NullOp::Box, ty) => unimplemented!(\"rval box {:?}\", ty),\n                 Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                     assert!(\n@@ -893,13 +901,7 @@ pub fn trans_place<'a, 'tcx: 'a>(\n         Place::Projection(projection) => {\n             let base = trans_place(fx, &projection.base);\n             match projection.elem {\n-                ProjectionElem::Deref => {\n-                    let layout = fx.layout_of(place.ty(&*fx.mir, fx.tcx).to_ty(fx.tcx));\n-                    if layout.is_unsized() {\n-                        unimpl!(\"Unsized places are not yet implemented\");\n-                    }\n-                    CPlace::Addr(base.to_cvalue(fx).load_value(fx), layout)\n-                }\n+                ProjectionElem::Deref => base.place_deref(fx),\n                 ProjectionElem::Field(field, _ty) => base.place_field(fx, field),\n                 ProjectionElem::Index(local) => {\n                     let index = fx.get_local_place(local).to_cvalue(fx).load_value(fx);"}, {"sha": "fd98d83221a93648dcc338b78c59b9a6b2cb60fa", "filename": "src/common.rs", "status": "modified", "additions": 154, "deletions": 20, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1", "patch": "@@ -19,6 +19,24 @@ pub fn pointer_ty(tcx: TyCtxt) -> types::Type {\n     }\n }\n \n+fn scalar_to_cton_type(tcx: TyCtxt, scalar: &Scalar) -> Type {\n+    match scalar.value.size(tcx).bits() {\n+        8 => types::I8,\n+        16 => types::I16,\n+        32 => types::I32,\n+        64 => types::I64,\n+        size => bug!(\"Unsupported scalar size {}\", size),\n+    }\n+}\n+\n+fn ptr_referee<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n+    match ty.sty {\n+        ty::Ref(_, ty, _) => ty,\n+        ty::RawPtr(TypeAndMut { ty, mutbl: _ }) => ty,\n+        _ => bug!(\"{:?}\", ty),\n+    }\n+}\n+\n pub fn cton_type_from_ty<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: Ty<'tcx>,\n@@ -198,6 +216,43 @@ impl<'tcx> CValue<'tcx> {\n         CValue::ByRef(field_ptr, field_layout)\n     }\n \n+    pub fn unsize_value<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n+        if self.layout().ty == dest.layout().ty {\n+            dest.write_cvalue(fx, self); // FIXME this shouldn't happen (rust-lang/rust#53602)\n+            return;\n+        }\n+        match &self.layout().ty.sty {\n+            ty::Ref(_, ty, _) | ty::RawPtr(TypeAndMut { ty, mutbl: _ }) => {\n+                let (ptr, extra) = match ptr_referee(dest.layout().ty).sty {\n+                    ty::Slice(slice_elem_ty) => match ty.sty {\n+                        ty::Array(array_elem_ty, size) => {\n+                            assert_eq!(slice_elem_ty, array_elem_ty);\n+                            let ptr = self.load_value(fx);\n+                            let extra = fx\n+                                .bcx\n+                                .ins()\n+                                .iconst(fx.module.pointer_type(), size.unwrap_usize(fx.tcx) as i64);\n+                            (ptr, extra)\n+                        }\n+                        _ => bug!(\"unsize non array {:?} to slice\", ty),\n+                    },\n+                    ty::Dynamic(_, _) => match ty.sty {\n+                        ty::Dynamic(_, _) => self.load_value_pair(fx),\n+                        _ => unimpl!(\"unsize of type ... to {:?}\", dest.layout().ty),\n+                    },\n+                    _ => bug!(\n+                        \"unsize of type {:?} to {:?}\",\n+                        self.layout().ty,\n+                        dest.layout().ty\n+                    ),\n+                };\n+                println!(\"ty {:?}\", self.layout().ty);\n+                dest.write_cvalue(fx, CValue::ByValPair(ptr, extra, dest.layout()));\n+            }\n+            ty => unimpl!(\"unsize of non ptr {:?}\", ty),\n+        }\n+    }\n+\n     pub fn const_val<'a>(\n         fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n         ty: Ty<'tcx>,\n@@ -224,18 +279,19 @@ impl<'tcx> CValue<'tcx> {\n #[derive(Debug, Copy, Clone)]\n pub enum CPlace<'tcx> {\n     Var(Local, TyLayout<'tcx>),\n-    Addr(Value, TyLayout<'tcx>),\n+    Addr(Value, Option<Value>, TyLayout<'tcx>),\n }\n \n impl<'a, 'tcx: 'a> CPlace<'tcx> {\n     pub fn layout(&self) -> TyLayout<'tcx> {\n         match *self {\n-            CPlace::Var(_, layout) | CPlace::Addr(_, layout) => layout,\n+            CPlace::Var(_, layout) | CPlace::Addr(_, _, layout) => layout,\n         }\n     }\n \n     pub fn temp(fx: &mut FunctionCx<'a, 'tcx, impl Backend>, ty: Ty<'tcx>) -> CPlace<'tcx> {\n         let layout = fx.layout_of(ty);\n+        assert!(!layout.is_unsized());\n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             size: layout.size.bytes() as u32,\n@@ -245,6 +301,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n             fx.bcx\n                 .ins()\n                 .stack_addr(fx.module.pointer_type(), stack_slot, 0),\n+            None,\n             layout,\n         )\n     }\n@@ -255,24 +312,30 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n         ty: Ty<'tcx>,\n     ) -> CPlace<'tcx> {\n         let layout = fx.layout_of(ty);\n+        assert!(!layout.is_unsized());\n         CPlace::Addr(\n             fx.bcx\n                 .ins()\n                 .stack_addr(fx.module.pointer_type(), stack_slot, 0),\n+            None,\n             layout,\n         )\n     }\n \n     pub fn to_cvalue(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> CValue<'tcx> {\n         match self {\n             CPlace::Var(var, layout) => CValue::ByVal(fx.bcx.use_var(mir_var(var)), layout),\n-            CPlace::Addr(addr, layout) => CValue::ByRef(addr, layout),\n+            CPlace::Addr(addr, extra, layout) => {\n+                assert!(extra.is_none(), \"unsized values are not yet supported\");\n+                CValue::ByRef(addr, layout)\n+            }\n         }\n     }\n \n     pub fn expect_addr(self) -> Value {\n         match self {\n-            CPlace::Addr(addr, _layout) => addr,\n+            CPlace::Addr(addr, None, _layout) => addr,\n+            CPlace::Addr(_, _, _) => bug!(\"Expected sized CPlace::Addr, found {:?}\", self),\n             CPlace::Var(_, _) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n         }\n     }\n@@ -308,7 +371,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n                 let data = from.load_value(fx);\n                 fx.bcx.def_var(mir_var(var), data)\n             }\n-            CPlace::Addr(addr, layout) => {\n+            CPlace::Addr(addr, None, layout) => {\n                 let size = layout.size.bytes() as i32;\n \n                 match from {\n@@ -346,6 +409,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n                     }\n                 }\n             }\n+            CPlace::Addr(_, _, _) => bug!(\"Can't write value to unsized place {:?}\", self),\n         }\n     }\n \n@@ -354,38 +418,108 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n         fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n         field: mir::Field,\n     ) -> CPlace<'tcx> {\n-        let base = self.expect_addr();\n         let layout = self.layout();\n+        if layout.is_unsized() {\n+            unimpl!(\"unsized place_field\");\n+        }\n \n+        let base = self.expect_addr();\n         let (field_ptr, field_layout) = codegen_field(fx, base, layout, field);\n-        CPlace::Addr(field_ptr, field_layout)\n+        CPlace::Addr(field_ptr, None, field_layout)\n     }\n \n     pub fn place_index(\n         self,\n         fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n         index: Value,\n     ) -> CPlace<'tcx> {\n-        let addr = self.expect_addr();\n-        let layout = self.layout();\n-        match layout.ty.sty {\n-            ty::Array(elem_ty, _) => {\n-                let elem_layout = fx.layout_of(elem_ty);\n-                let offset = fx\n-                    .bcx\n-                    .ins()\n-                    .imul_imm(index, elem_layout.size.bytes() as i64);\n-                CPlace::Addr(fx.bcx.ins().iadd(addr, offset), elem_layout)\n+        let (elem_layout, addr) = match self.layout().ty.sty {\n+            ty::Array(elem_ty, _) => (fx.layout_of(elem_ty), self.expect_addr()),\n+            ty::Slice(elem_ty) => (\n+                fx.layout_of(elem_ty),\n+                match self {\n+                    CPlace::Addr(addr, _, _) => addr,\n+                    CPlace::Var(_, _) => bug!(\"Expected CPlace::Addr found CPlace::Var\"),\n+                },\n+            ),\n+            _ => bug!(\"place_index({:?})\", self.layout().ty),\n+        };\n+\n+        let offset = fx\n+            .bcx\n+            .ins()\n+            .imul_imm(index, elem_layout.size.bytes() as i64);\n+\n+        CPlace::Addr(fx.bcx.ins().iadd(addr, offset), None, elem_layout)\n+    }\n+\n+    pub fn place_deref(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> CPlace<'tcx> {\n+        let inner_layout = fx.layout_of(ptr_referee(self.layout().ty));\n+        if !inner_layout.is_unsized() {\n+            CPlace::Addr(self.to_cvalue(fx).load_value(fx), None, inner_layout)\n+        } else {\n+            match self.layout().abi {\n+                Abi::ScalarPair(ref a, ref b) => {\n+                    let addr = self.expect_addr();\n+                    let ptr =\n+                        fx.bcx\n+                            .ins()\n+                            .load(scalar_to_cton_type(fx.tcx, a), MemFlags::new(), addr, 0);\n+                    let extra = fx.bcx.ins().load(\n+                        scalar_to_cton_type(fx.tcx, b),\n+                        MemFlags::new(),\n+                        addr,\n+                        a.value.size(fx.tcx).bytes() as u32 as i32,\n+                    );\n+                    println!(\n+                        \"unsized deref: ptr: {:?} extra: {:?} self: {:?}\",\n+                        ptr, extra, self\n+                    );\n+                    CPlace::Addr(ptr, Some(extra), inner_layout)\n+                }\n+                _ => bug!(\n+                    \"Fat ptr doesn't have abi ScalarPair, but it has {:?}\",\n+                    self.layout().abi\n+                ),\n+            }\n+        }\n+    }\n+\n+    pub fn write_place_ref(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n+        if !self.layout().is_unsized() {\n+            let ptr = CValue::ByVal(self.expect_addr(), dest.layout());\n+            dest.write_cvalue(fx, ptr);\n+        } else {\n+            match self {\n+                CPlace::Var(_, _) => bug!(\"expected CPlace::Addr found CPlace::Var\"),\n+                CPlace::Addr(value, extra, _) => match dest.layout().abi {\n+                    Abi::ScalarPair(ref a, _) => {\n+                        fx.bcx\n+                            .ins()\n+                            .store(MemFlags::new(), value, dest.expect_addr(), 0);\n+                        fx.bcx.ins().store(\n+                            MemFlags::new(),\n+                            extra.expect(\"unsized type without metadata\"),\n+                            dest.expect_addr(),\n+                            a.value.size(fx.tcx).bytes() as u32 as i32,\n+                        );\n+                    }\n+                    _ => bug!(\n+                        \"Non ScalarPair abi {:?} in write_place_ref dest\",\n+                        dest.layout().abi\n+                    ),\n+                },\n             }\n-            ty::Slice(_elem_ty) => unimplemented!(\"place_index(TySlice)\"),\n-            _ => bug!(\"place_index({:?})\", layout.ty),\n         }\n     }\n \n     pub fn unchecked_cast_to(self, layout: TyLayout<'tcx>) -> Self {\n         match self {\n             CPlace::Var(var, _) => CPlace::Var(var, layout),\n-            CPlace::Addr(addr, _) => CPlace::Addr(addr, layout),\n+            CPlace::Addr(addr, extra, _) => {\n+                assert!(!layout.is_unsized());\n+                CPlace::Addr(addr, extra, layout)\n+            }\n         }\n     }\n "}, {"sha": "f912f435fcbf7acdc5a050b740397d8ac85c5b1b", "filename": "src/constant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1", "patch": "@@ -179,7 +179,8 @@ fn cplace_for_dataid<'a, 'tcx: 'a>(\n         .ins()\n         .global_value(fx.module.pointer_type(), local_data_id);\n     let layout = fx.layout_of(fx.monomorphize(&ty));\n-    CPlace::Addr(global_ptr, layout)\n+    assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n+    CPlace::Addr(global_ptr, None, layout)\n }\n \n fn define_all_allocs<'a, 'tcx: 'a, B: Backend + 'a>("}, {"sha": "fa74f928ddb45aa7a94a0d2ded0f06ed569b34ba", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=42eeb75a1f8143e9fa4e4d1043ddfba0d2e31cd1", "patch": "@@ -63,7 +63,7 @@ mod prelude {\n     pub use rustc::mir::interpret::AllocId;\n     pub use rustc::mir::*;\n     pub use rustc::session::{config::CrateType, Session};\n-    pub use rustc::ty::layout::{self, LayoutOf, Size, TyLayout};\n+    pub use rustc::ty::layout::{self, Abi, LayoutOf, Scalar, Size, TyLayout};\n     pub use rustc::ty::{\n         self, subst::Substs, FnSig, Instance, InstanceDef, ParamEnv, PolyFnSig, Ty, TyCtxt,\n         TypeAndMut, TypeFoldable,"}]}