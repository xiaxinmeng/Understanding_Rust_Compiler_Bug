{"sha": "cc51186be0c68897042a72bd52147e345ad2a2cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNTExODZiZTBjNjg4OTcwNDJhNzJiZDUyMTQ3ZTM0NWFkMmEyY2Q=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-05-07T10:30:51Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-05-07T10:30:51Z"}, "message": "Add is_normal and classify methods to Float trait", "tree": {"sha": "d62915d4465739ce30122cef2e377d8ac7b22230", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d62915d4465739ce30122cef2e377d8ac7b22230"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc51186be0c68897042a72bd52147e345ad2a2cd", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc51186be0c68897042a72bd52147e345ad2a2cd", "html_url": "https://github.com/rust-lang/rust/commit/cc51186be0c68897042a72bd52147e345ad2a2cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc51186be0c68897042a72bd52147e345ad2a2cd/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9ac2b95f485c31e40273dee7f09dcfff8340777", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9ac2b95f485c31e40273dee7f09dcfff8340777", "html_url": "https://github.com/rust-lang/rust/commit/a9ac2b95f485c31e40273dee7f09dcfff8340777"}], "stats": {"total": 187, "additions": 170, "deletions": 17}, "files": [{"sha": "3c4faa95dd190ec9e6d17a5e3ff6911fbe52fd76", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cc51186be0c68897042a72bd52147e345ad2a2cd/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc51186be0c68897042a72bd52147e345ad2a2cd/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=cc51186be0c68897042a72bd52147e345ad2a2cd", "patch": "@@ -11,6 +11,7 @@\n //! Operations and constants for `f32`\n \n use num::{Zero, One, strconv};\n+use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n use prelude::*;\n \n pub use cmath::c_float_targ_consts::*;\n@@ -568,12 +569,39 @@ impl Float for f32 {\n         *self == Float::infinity() || *self == Float::neg_infinity()\n     }\n \n-    /// Returns `true` if the number is not infinite or NaN\n+    /// Returns `true` if the number is neither infinite or NaN\n     #[inline(always)]\n     fn is_finite(&self) -> bool {\n         !(self.is_NaN() || self.is_infinite())\n     }\n \n+    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n+    #[inline(always)]\n+    fn is_normal(&self) -> bool {\n+        match self.classify() {\n+            FPNormal => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns the floating point category of the number. If only one property is going to\n+    /// be tested, it is generally faster to use the specific predicate instead.\n+    fn classify(&self) -> FPCategory {\n+        static EXP_MASK: u32 = 0x7f800000;\n+        static MAN_MASK: u32 = 0x007fffff;\n+\n+        match (\n+            unsafe { ::cast::transmute::<f32,u32>(*self) } & EXP_MASK,\n+            unsafe { ::cast::transmute::<f32,u32>(*self) } & MAN_MASK\n+        ) {\n+            (EXP_MASK, 0)        => FPInfinite,\n+            (EXP_MASK, _)        => FPNaN,\n+            (exp, _) if exp != 0 => FPNormal,\n+            _ if self.is_zero()  => FPZero,\n+            _                    => FPSubnormal,\n+        }\n+    }\n+\n     #[inline(always)]\n     fn mantissa_digits() -> uint { 24 }\n \n@@ -846,6 +874,7 @@ impl num::FromStrRadix for f32 {\n #[cfg(test)]\n mod tests {\n     use f32::*;\n+    use num::*;\n     use super::*;\n     use prelude::*;\n \n@@ -1041,4 +1070,28 @@ mod tests {\n         assert_eq!(Primitive::bits::<f32>(), sys::size_of::<f32>() * 8);\n         assert_eq!(Primitive::bytes::<f32>(), sys::size_of::<f32>());\n     }\n+\n+    #[test]\n+    fn test_is_normal() {\n+        assert!(!Float::NaN::<f32>().is_normal());\n+        assert!(!Float::infinity::<f32>().is_normal());\n+        assert!(!Float::neg_infinity::<f32>().is_normal());\n+        assert!(!Zero::zero::<f32>().is_normal());\n+        assert!(!Float::neg_zero::<f32>().is_normal());\n+        assert!(1f32.is_normal());\n+        assert!(1e-37f32.is_normal());\n+        assert!(!1e-38f32.is_normal());\n+    }\n+\n+    #[test]\n+    fn test_classify() {\n+        assert_eq!(Float::NaN::<f32>().classify(), FPNaN);\n+        assert_eq!(Float::infinity::<f32>().classify(), FPInfinite);\n+        assert_eq!(Float::neg_infinity::<f32>().classify(), FPInfinite);\n+        assert_eq!(Zero::zero::<f32>().classify(), FPZero);\n+        assert_eq!(Float::neg_zero::<f32>().classify(), FPZero);\n+        assert_eq!(1f32.classify(), FPNormal);\n+        assert_eq!(1e-37f32.classify(), FPNormal);\n+        assert_eq!(1e-38f32.classify(), FPSubnormal);\n+    }\n }"}, {"sha": "30c101fe8a9c6ed9de35c92f6c0267f9137b6742", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cc51186be0c68897042a72bd52147e345ad2a2cd/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc51186be0c68897042a72bd52147e345ad2a2cd/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=cc51186be0c68897042a72bd52147e345ad2a2cd", "patch": "@@ -12,6 +12,7 @@\n \n use libc::c_int;\n use num::{Zero, One, strconv};\n+use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n use prelude::*;\n \n pub use cmath::c_double_targ_consts::*;\n@@ -611,12 +612,39 @@ impl Float for f64 {\n         *self == Float::infinity() || *self == Float::neg_infinity()\n     }\n \n-    /// Returns `true` if the number is not infinite or NaN\n+    /// Returns `true` if the number is neither infinite or NaN\n     #[inline(always)]\n     fn is_finite(&self) -> bool {\n         !(self.is_NaN() || self.is_infinite())\n     }\n \n+    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n+    #[inline(always)]\n+    fn is_normal(&self) -> bool {\n+        match self.classify() {\n+            FPNormal => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns the floating point category of the number. If only one property is going to\n+    /// be tested, it is generally faster to use the specific predicate instead.\n+    fn classify(&self) -> FPCategory {\n+        static EXP_MASK: u64 = 0x7ff0000000000000;\n+        static MAN_MASK: u64 = 0x000fffffffffffff;\n+\n+        match (\n+            unsafe { ::cast::transmute::<f64,u64>(*self) } & EXP_MASK,\n+            unsafe { ::cast::transmute::<f64,u64>(*self) } & MAN_MASK\n+        ) {\n+            (EXP_MASK, 0)        => FPInfinite,\n+            (EXP_MASK, _)        => FPNaN,\n+            (exp, _) if exp != 0 => FPNormal,\n+            _ if self.is_zero()  => FPZero,\n+            _                    => FPSubnormal,\n+        }\n+    }\n+\n     #[inline(always)]\n     fn mantissa_digits() -> uint { 53 }\n \n@@ -889,6 +917,7 @@ impl num::FromStrRadix for f64 {\n #[cfg(test)]\n mod tests {\n     use f64::*;\n+    use num::*;\n     use super::*;\n     use prelude::*;\n \n@@ -1088,4 +1117,27 @@ mod tests {\n         assert_eq!(Primitive::bits::<f64>(), sys::size_of::<f64>() * 8);\n         assert_eq!(Primitive::bytes::<f64>(), sys::size_of::<f64>());\n     }\n+\n+    #[test]\n+    fn test_is_normal() {\n+        assert!(!Float::NaN::<f64>().is_normal());\n+        assert!(!Float::infinity::<f64>().is_normal());\n+        assert!(!Float::neg_infinity::<f64>().is_normal());\n+        assert!(!Zero::zero::<f64>().is_normal());\n+        assert!(!Float::neg_zero::<f64>().is_normal());\n+        assert!(1f64.is_normal());\n+        assert!(1e-307f64.is_normal());\n+        assert!(!1e-308f64.is_normal());\n+    }\n+\n+    #[test]\n+    fn test_classify() {\n+        assert_eq!(Float::NaN::<f64>().classify(), FPNaN);\n+        assert_eq!(Float::infinity::<f64>().classify(), FPInfinite);\n+        assert_eq!(Float::neg_infinity::<f64>().classify(), FPInfinite);\n+        assert_eq!(Zero::zero::<f64>().classify(), FPZero);\n+        assert_eq!(Float::neg_zero::<f64>().classify(), FPZero);\n+        assert_eq!(1e-307f64.classify(), FPNormal);\n+        assert_eq!(1e-308f64.classify(), FPSubnormal);\n+    }\n }"}, {"sha": "9c3d30be0d499718994379ad47c4ce60f1ed8ae3", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/cc51186be0c68897042a72bd52147e345ad2a2cd/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc51186be0c68897042a72bd52147e345ad2a2cd/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=cc51186be0c68897042a72bd52147e345ad2a2cd", "patch": "@@ -22,6 +22,7 @@\n \n use libc::c_int;\n use num::{Zero, One, strconv};\n+use num::FPCategory;\n use prelude::*;\n \n pub use f64::{add, sub, mul, div, rem, lt, le, eq, ne, ge, gt};\n@@ -782,32 +783,37 @@ impl Primitive for float {\n \n impl Float for float {\n     #[inline(always)]\n-    fn NaN() -> float { 0.0 / 0.0 }\n+    fn NaN() -> float { Float::NaN::<f64>() as float }\n \n     #[inline(always)]\n-    fn infinity() -> float { 1.0 / 0.0 }\n+    fn infinity() -> float { Float::infinity::<f64>() as float }\n \n     #[inline(always)]\n-    fn neg_infinity() -> float { -1.0 / 0.0 }\n+    fn neg_infinity() -> float { Float::neg_infinity::<f64>() as float }\n \n     #[inline(always)]\n-    fn neg_zero() -> float { -0.0 }\n+    fn neg_zero() -> float { Float::neg_zero::<f64>() as float }\n \n     /// Returns `true` if the number is NaN\n     #[inline(always)]\n-    fn is_NaN(&self) -> bool { *self != *self }\n+    fn is_NaN(&self) -> bool { (*self as f64).is_NaN() }\n \n     /// Returns `true` if the number is infinite\n     #[inline(always)]\n-    fn is_infinite(&self) -> bool {\n-        *self == Float::infinity() || *self == Float::neg_infinity()\n-    }\n+    fn is_infinite(&self) -> bool { (*self as f64).is_infinite() }\n \n-    /// Returns `true` if the number is not infinite or NaN\n+    /// Returns `true` if the number is neither infinite or NaN\n     #[inline(always)]\n-    fn is_finite(&self) -> bool {\n-        !(self.is_NaN() || self.is_infinite())\n-    }\n+    fn is_finite(&self) -> bool { (*self as f64).is_finite() }\n+\n+    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n+    #[inline(always)]\n+    fn is_normal(&self) -> bool { (*self as f64).is_normal() }\n+\n+    /// Returns the floating point category of the number. If only one property is going to\n+    /// be tested, it is generally faster to use the specific predicate instead.\n+    #[inline(always)]\n+    fn classify(&self) -> FPCategory { (*self as f64).classify() }\n \n     #[inline(always)]\n     fn mantissa_digits() -> uint { Float::mantissa_digits::<f64>() }\n@@ -844,9 +850,7 @@ impl Float for float {\n     /// than if the operations were performed separately\n     ///\n     #[inline(always)]\n-    fn ln_1p(&self) -> float {\n-        (*self as f64).ln_1p() as float\n-    }\n+    fn ln_1p(&self) -> float { (*self as f64).ln_1p() as float }\n \n     ///\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n@@ -867,6 +871,7 @@ impl Float for float {\n \n #[cfg(test)]\n mod tests {\n+    use num::*;\n     use super::*;\n     use prelude::*;\n \n@@ -1063,6 +1068,30 @@ mod tests {\n         assert_eq!(Primitive::bytes::<float>(), sys::size_of::<float>());\n     }\n \n+    #[test]\n+    fn test_is_normal() {\n+        assert!(!Float::NaN::<float>().is_normal());\n+        assert!(!Float::infinity::<float>().is_normal());\n+        assert!(!Float::neg_infinity::<float>().is_normal());\n+        assert!(!Zero::zero::<float>().is_normal());\n+        assert!(!Float::neg_zero::<float>().is_normal());\n+        assert!(1f.is_normal());\n+        assert!(1e-307f.is_normal());\n+        assert!(!1e-308f.is_normal());\n+    }\n+\n+    #[test]\n+    fn test_classify() {\n+        assert_eq!(Float::NaN::<float>().classify(), FPNaN);\n+        assert_eq!(Float::infinity::<float>().classify(), FPInfinite);\n+        assert_eq!(Float::neg_infinity::<float>().classify(), FPInfinite);\n+        assert_eq!(Zero::zero::<float>().classify(), FPZero);\n+        assert_eq!(Float::neg_zero::<float>().classify(), FPZero);\n+        assert_eq!(1f.classify(), FPNormal);\n+        assert_eq!(1e-307f.classify(), FPNormal);\n+        assert_eq!(1e-308f.classify(), FPSubnormal);\n+    }\n+\n     #[test]\n     pub fn test_to_str_exact_do_decimal() {\n         let s = to_str_exact(5.0, 4u);"}, {"sha": "50ba55039d4089da4dd0623dbc3e30083327c86e", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cc51186be0c68897042a72bd52147e345ad2a2cd/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc51186be0c68897042a72bd52147e345ad2a2cd/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=cc51186be0c68897042a72bd52147e345ad2a2cd", "patch": "@@ -237,6 +237,23 @@ pub trait Int: Integer\n              + Bitwise\n              + BitCount {}\n \n+///\n+/// Used for representing the classification of floating point numbers\n+///\n+#[deriving(Eq)]\n+pub enum FPCategory {\n+    /// \"Not a Number\", often obtained by dividing by zero\n+    FPNaN,\n+    /// Positive or negative infinity\n+    FPInfinite ,\n+    /// Positive or negative zero\n+    FPZero,\n+    /// De-normalized floating point representation (less precise than `FPNormal`)\n+    FPSubnormal,\n+    /// A regular floating point number\n+    FPNormal,\n+}\n+\n ///\n /// Primitive floating point numbers\n ///\n@@ -253,6 +270,8 @@ pub trait Float: Real\n     fn is_NaN(&self) -> bool;\n     fn is_infinite(&self) -> bool;\n     fn is_finite(&self) -> bool;\n+    fn is_normal(&self) -> bool;\n+    fn classify(&self) -> FPCategory;\n \n     fn mantissa_digits() -> uint;\n     fn digits() -> uint;"}]}