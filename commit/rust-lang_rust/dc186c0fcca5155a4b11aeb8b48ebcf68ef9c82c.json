{"sha": "dc186c0fcca5155a4b11aeb8b48ebcf68ef9c82c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMTg2YzBmY2NhNTE1NWE0YjExYWViOGI0OGViY2Y2OGVmOWM4MmM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-07T18:40:31Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-08T11:53:31Z"}, "message": "Import fixpoint loop for name resolution", "tree": {"sha": "d79ff83ca775ab4d298ad8f18e9de442a96a3531", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d79ff83ca775ab4d298ad8f18e9de442a96a3531"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc186c0fcca5155a4b11aeb8b48ebcf68ef9c82c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc186c0fcca5155a4b11aeb8b48ebcf68ef9c82c", "html_url": "https://github.com/rust-lang/rust/commit/dc186c0fcca5155a4b11aeb8b48ebcf68ef9c82c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc186c0fcca5155a4b11aeb8b48ebcf68ef9c82c/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2592cf09087ae0a6cad5b588cbf1ab1161440e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2592cf09087ae0a6cad5b588cbf1ab1161440e9", "html_url": "https://github.com/rust-lang/rust/commit/e2592cf09087ae0a6cad5b588cbf1ab1161440e9"}], "stats": {"total": 78, "additions": 62, "deletions": 16}, "files": [{"sha": "bd66b5d2c409ff61548f232fc9018c16505e72f9", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dc186c0fcca5155a4b11aeb8b48ebcf68ef9c82c/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc186c0fcca5155a4b11aeb8b48ebcf68ef9c82c/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=dc186c0fcca5155a4b11aeb8b48ebcf68ef9c82c", "patch": "@@ -16,7 +16,7 @@\n //! structure itself is modified.\n use std::sync::Arc;\n \n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use ra_syntax::{\n     TextRange,\n     SyntaxKind::{self, *},\n@@ -295,6 +295,7 @@ pub(crate) struct Resolver<'a, DB> {\n     input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,\n     source_root: SourceRootId,\n     module_tree: Arc<ModuleTree>,\n+    processed_imports: FxHashSet<(ModuleId, usize)>,\n     result: ItemMap,\n }\n \n@@ -313,6 +314,7 @@ where\n             input,\n             source_root,\n             module_tree,\n+            processed_imports: FxHashSet::default(),\n             result: ItemMap::default(),\n         }\n     }\n@@ -322,9 +324,16 @@ where\n             self.populate_module(module_id, Arc::clone(items))?;\n         }\n \n-        for &module_id in self.input.keys() {\n-            self.db.check_canceled()?;\n-            self.resolve_imports(module_id)?;\n+        loop {\n+            let processed_imports_count = self.processed_imports.len();\n+            for &module_id in self.input.keys() {\n+                self.db.check_canceled()?;\n+                self.resolve_imports(module_id)?;\n+            }\n+            if processed_imports_count == self.processed_imports.len() {\n+                // no new imports resolved\n+                break;\n+            }\n         }\n         Ok(self.result)\n     }\n@@ -418,15 +427,21 @@ where\n     }\n \n     fn resolve_imports(&mut self, module_id: ModuleId) -> Cancelable<()> {\n-        for import in self.input[&module_id].imports.iter() {\n-            self.resolve_import(module_id, import)?;\n+        for (i, import) in self.input[&module_id].imports.iter().enumerate() {\n+            if self.processed_imports.contains(&(module_id, i)) {\n+                // already done\n+                continue;\n+            }\n+            if self.resolve_import(module_id, import)? {\n+                self.processed_imports.insert((module_id, i));\n+            }\n         }\n         Ok(())\n     }\n \n-    fn resolve_import(&mut self, module_id: ModuleId, import: &Import) -> Cancelable<()> {\n+    fn resolve_import(&mut self, module_id: ModuleId, import: &Import) -> Cancelable<bool> {\n         let ptr = match import.kind {\n-            ImportKind::Glob => return Ok(()),\n+            ImportKind::Glob => return Ok(false),\n             ImportKind::Named(ptr) => ptr,\n         };\n \n@@ -436,7 +451,7 @@ where\n                 match module_id.parent(&self.module_tree) {\n                     Some(it) => it,\n                     // TODO: error\n-                    None => return Ok(()),\n+                    None => return Ok(true), // this can't suddenly resolve if we just resolve some other imports\n                 }\n             }\n             PathKind::Crate => module_id.crate_root(&self.module_tree),\n@@ -447,14 +462,14 @@ where\n \n             let def_id = match self.result.per_module[&curr].items.get(name) {\n                 Some(res) if !res.def_id.is_none() => res.def_id,\n-                _ => return Ok(()),\n+                _ => return Ok(false),\n             };\n \n             if !is_last {\n                 let type_def_id = if let Some(d) = def_id.take(Namespace::Types) {\n                     d\n                 } else {\n-                    return Ok(());\n+                    return Ok(false);\n                 };\n                 curr = match type_def_id.loc(self.db) {\n                     DefLoc {\n@@ -479,12 +494,14 @@ where\n                                         import: Some(ptr),\n                                     };\n                                     items.items.insert(name.clone(), res);\n-                                })\n+                                });\n+                                return Ok(true);\n+                            } else {\n+                                return Ok(false);\n                             }\n-                            return Ok(());\n                         }\n                     }\n-                    _ => return Ok(()),\n+                    _ => return Ok(true), // this resolved to a non-module, so the path won't ever resolve\n                 }\n             } else {\n                 self.update(module_id, |items| {\n@@ -496,7 +513,7 @@ where\n                 })\n             }\n         }\n-        Ok(())\n+        Ok(true)\n     }\n \n     fn update(&mut self, module_id: ModuleId, f: impl FnOnce(&mut ModuleScope)) {"}, {"sha": "04faec4fb268d5527f77dc8410130d8c7d11df1c", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/dc186c0fcca5155a4b11aeb8b48ebcf68ef9c82c/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc186c0fcca5155a4b11aeb8b48ebcf68ef9c82c/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=dc186c0fcca5155a4b11aeb8b48ebcf68ef9c82c", "patch": "@@ -35,7 +35,7 @@ fn check_module_item_map(map: &hir::ItemMap, module_id: hir::ModuleId, expected:\n         .map(|it| it.trim())\n         .collect::<Vec<_>>()\n         .join(\"\\n\");\n-    assert_eq_text!(&actual, &expected);\n+    assert_eq_text!(&expected, &actual);\n \n     fn dump_resolution(resolution: &hir::Resolution) -> &'static str {\n         match (\n@@ -77,6 +77,35 @@ fn item_map_smoke_test() {\n     );\n }\n \n+#[test]\n+fn re_exports() {\n+    let (item_map, module_id) = item_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+\n+        use self::foo::Baz;\n+        <|>\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        pub use self::bar::Baz;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+    \",\n+    );\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+            Baz: t v\n+            foo: t\n+        \",\n+    );\n+}\n+\n #[test]\n fn item_map_contains_items_from_expansions() {\n     let (item_map, module_id) = item_map("}]}