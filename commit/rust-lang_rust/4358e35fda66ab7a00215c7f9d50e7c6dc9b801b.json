{"sha": "4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNThlMzVmZGE2NmFiN2EwMDIxNWM3ZjlkNTBlN2M2ZGM5YjgwMWI=", "commit": {"author": {"name": "Cameron Hart", "email": "cameron.hart@gmail.com", "date": "2017-01-14T22:49:29Z"}, "committer": {"name": "Cameron Hart", "email": "cameron.hart@gmail.com", "date": "2017-04-20T21:32:32Z"}, "message": "Implementation of repr struct alignment RFC 1358.\n\nThe main changes around rustc::ty::Layout::struct and rustc_trans:adt:\n* Added primitive_align field which stores alignment before repr align\n* Always emit field padding when generating the LLVM struct fields\n* Added methods for adjusting field indexes from the layout index to the\n  LLVM struct field index\n\nThe main user of this information is rustc_trans::adt::struct_llfields\nwhich determines the LLVM fields to be used by LLVM, including padding\nfields.", "tree": {"sha": "a25741bc07d2a01d06a99d2135a776c61d42e3d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a25741bc07d2a01d06a99d2135a776c61d42e3d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "html_url": "https://github.com/rust-lang/rust/commit/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/comments", "author": {"login": "bitshifter", "id": 135700, "node_id": "MDQ6VXNlcjEzNTcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/135700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitshifter", "html_url": "https://github.com/bitshifter", "followers_url": "https://api.github.com/users/bitshifter/followers", "following_url": "https://api.github.com/users/bitshifter/following{/other_user}", "gists_url": "https://api.github.com/users/bitshifter/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitshifter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitshifter/subscriptions", "organizations_url": "https://api.github.com/users/bitshifter/orgs", "repos_url": "https://api.github.com/users/bitshifter/repos", "events_url": "https://api.github.com/users/bitshifter/events{/privacy}", "received_events_url": "https://api.github.com/users/bitshifter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bitshifter", "id": 135700, "node_id": "MDQ6VXNlcjEzNTcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/135700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitshifter", "html_url": "https://github.com/bitshifter", "followers_url": "https://api.github.com/users/bitshifter/followers", "following_url": "https://api.github.com/users/bitshifter/following{/other_user}", "gists_url": "https://api.github.com/users/bitshifter/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitshifter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitshifter/subscriptions", "organizations_url": "https://api.github.com/users/bitshifter/orgs", "repos_url": "https://api.github.com/users/bitshifter/repos", "events_url": "https://api.github.com/users/bitshifter/events{/privacy}", "received_events_url": "https://api.github.com/users/bitshifter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddc5d7bd4b9ea3e8a8ccf82cb443e950be311d61", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc5d7bd4b9ea3e8a8ccf82cb443e950be311d61", "html_url": "https://github.com/rust-lang/rust/commit/ddc5d7bd4b9ea3e8a8ccf82cb443e950be311d61"}], "stats": {"total": 724, "additions": 646, "deletions": 78}, "files": [{"sha": "2851191dc141a1373b04dbe78093f45245642686", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -1847,5 +1847,6 @@ register_diagnostics! {\n     E0489, // type/lifetime parameter not in scope here\n     E0490, // a value of type `..` is borrowed for too long\n     E0495, // cannot infer an appropriate lifetime due to conflicting requirements\n-    E0566  // conflicting representation hints\n+    E0566, // conflicting representation hints\n+    E0587, // conflicting packed and align representation hints\n }"}, {"sha": "bf292ccb8d86d064212c1d33c40e56b90c0c144a", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -57,6 +57,9 @@ impl<'a> CheckAttrVisitor<'a> {\n         };\n \n         let mut conflicting_reprs = 0;\n+        let mut found_packed = false;\n+        let mut found_align = false;\n+\n         for word in words {\n \n             let name = match word.name() {\n@@ -84,6 +87,7 @@ impl<'a> CheckAttrVisitor<'a> {\n                                 (\"attribute should be applied to struct or union\",\n                                  \"a struct or union\")\n                     } else {\n+                        found_packed = true;\n                         continue\n                     }\n                 }\n@@ -96,6 +100,15 @@ impl<'a> CheckAttrVisitor<'a> {\n                         continue\n                     }\n                 }\n+                \"align\" => {\n+                    found_align = true;\n+                    if target != Target::Struct {\n+                        (\"attribute should be applied to struct\",\n+                         \"a struct\")\n+                    } else {\n+                        continue\n+                    }\n+                }\n                 \"i8\" | \"u8\" | \"i16\" | \"u16\" |\n                 \"i32\" | \"u32\" | \"i64\" | \"u64\" |\n                 \"isize\" | \"usize\" => {\n@@ -117,6 +130,10 @@ impl<'a> CheckAttrVisitor<'a> {\n             span_warn!(self.sess, attr.span, E0566,\n                        \"conflicting representation hints\");\n         }\n+        if found_align && found_packed {\n+            struct_span_err!(self.sess, attr.span, E0587,\n+                             \"conflicting packed and align representation hints\").emit();\n+        }\n     }\n \n     fn check_attribute(&self, attr: &ast::Attribute, target: Target) {"}, {"sha": "6a206640b3baa0233e71bfbc15e794f61ab5c388", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 83, "deletions": 6, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -548,8 +548,12 @@ pub type FieldPath = Vec<u32>;\n /// A structure, a product type in ADT terms.\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct Struct {\n+    /// Maximum alignment of fields and repr alignment.\n     pub align: Align,\n \n+    /// Primitive alignment of fields without repr alignment.\n+    pub primitive_align: Align,\n+\n     /// If true, no alignment padding is used.\n     pub packed: bool,\n \n@@ -583,10 +587,20 @@ impl<'a, 'gcx, 'tcx> Struct {\n     fn new(dl: &TargetDataLayout, fields: &Vec<&'a Layout>,\n                   repr: &ReprOptions, kind: StructKind,\n                   scapegoat: Ty<'gcx>) -> Result<Struct, LayoutError<'gcx>> {\n-        let packed = repr.packed();\n+        if repr.packed() && repr.align > 0 {\n+            bug!(\"Struct cannot be packed and aligned\");\n+        }\n+\n+        let align = if repr.packed() {\n+            dl.i8_align\n+        } else {\n+            dl.aggregate_align\n+        };\n+\n         let mut ret = Struct {\n-            align: if packed { dl.i8_align } else { dl.aggregate_align },\n-            packed: packed,\n+            align: align,\n+            primitive_align: align,\n+            packed: repr.packed(),\n             sized: true,\n             offsets: vec![],\n             memory_index: vec![],\n@@ -660,7 +674,9 @@ impl<'a, 'gcx, 'tcx> Struct {\n             // Invariant: offset < dl.obj_size_bound() <= 1<<61\n             if !ret.packed {\n                 let align = field.align(dl);\n+                let primitive_align = field.primitive_align(dl);\n                 ret.align = ret.align.max(align);\n+                ret.primitive_align = ret.primitive_align.max(primitive_align);\n                 offset = offset.abi_align(align);\n             }\n \n@@ -671,6 +687,11 @@ impl<'a, 'gcx, 'tcx> Struct {\n                            .map_or(Err(LayoutError::SizeOverflow(scapegoat)), Ok)?;\n         }\n \n+        if repr.align > 0 {\n+            let repr_align = repr.align as u64;\n+            ret.align = ret.align.max(Align::from_bytes(repr_align, repr_align).unwrap());\n+            debug!(\"Struct::new repr_align: {:?}\", repr_align);\n+        }\n \n         debug!(\"Struct::new min_size: {:?}\", offset);\n         ret.min_size = offset;\n@@ -836,12 +857,23 @@ impl<'a, 'gcx, 'tcx> Struct {\n         }\n         Ok(None)\n     }\n+\n+    pub fn over_align(&self) -> Option<u32> {\n+        let align = self.align.abi();\n+        let primitive_align = self.primitive_align.abi();\n+        if align > primitive_align {\n+            Some(align as u32)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /// An untagged union.\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct Union {\n     pub align: Align,\n+    pub primitive_align: Align,\n \n     pub min_size: Size,\n \n@@ -851,8 +883,10 @@ pub struct Union {\n \n impl<'a, 'gcx, 'tcx> Union {\n     fn new(dl: &TargetDataLayout, packed: bool) -> Union {\n+        let align = if packed { dl.i8_align } else { dl.aggregate_align };\n         Union {\n-            align: if packed { dl.i8_align } else { dl.aggregate_align },\n+            align: align,\n+            primitive_align: align,\n             min_size: Size::from_bytes(0),\n             packed: packed,\n         }\n@@ -875,6 +909,7 @@ impl<'a, 'gcx, 'tcx> Union {\n \n             if !self.packed {\n                 self.align = self.align.max(field.align(dl));\n+                self.primitive_align = self.primitive_align.max(field.primitive_align(dl));\n             }\n             self.min_size = cmp::max(self.min_size, field.size(dl));\n         }\n@@ -888,6 +923,16 @@ impl<'a, 'gcx, 'tcx> Union {\n     pub fn stride(&self) -> Size {\n         self.min_size.abi_align(self.align)\n     }\n+\n+    pub fn over_align(&self) -> Option<u32> {\n+        let align = self.align.abi();\n+        let primitive_align = self.primitive_align.abi();\n+        if align > primitive_align {\n+            Some(align as u32)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /// The first half of a fat pointer.\n@@ -924,6 +969,7 @@ pub enum Layout {\n         /// If true, the size is exact, otherwise it's only a lower bound.\n         sized: bool,\n         align: Align,\n+        primitive_align: Align,\n         element_size: Size,\n         count: u64\n     },\n@@ -970,7 +1016,8 @@ pub enum Layout {\n         discr: Integer,\n         variants: Vec<Struct>,\n         size: Size,\n-        align: Align\n+        align: Align,\n+        primitive_align: Align,\n     },\n \n     /// Two cases distinguished by a nullable pointer: the case with discriminant\n@@ -1118,6 +1165,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 Array {\n                     sized: true,\n                     align: element.align(dl),\n+                    primitive_align: element.primitive_align(dl),\n                     element_size: element_size,\n                     count: count\n                 }\n@@ -1127,6 +1175,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 Array {\n                     sized: false,\n                     align: element.align(dl),\n+                    primitive_align: element.primitive_align(dl),\n                     element_size: element.size(dl),\n                     count: 0\n                 }\n@@ -1135,6 +1184,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 Array {\n                     sized: false,\n                     align: dl.i8_align,\n+                    primitive_align: dl.i8_align,\n                     element_size: Size::from_bytes(1),\n                     count: 0\n                 }\n@@ -1340,6 +1390,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 assert!(discr_max >= 0);\n                 let (min_ity, _) = Integer::repr_discr(tcx, ty, &def.repr, 0, discr_max);\n                 let mut align = dl.aggregate_align;\n+                let mut primitive_align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n \n                 // We're interested in the smallest alignment, so start large.\n@@ -1369,6 +1420,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     }\n                     size = cmp::max(size, st.min_size);\n                     align = align.max(st.align);\n+                    primitive_align = primitive_align.max(st.primitive_align);\n                     Ok(st)\n                 }).collect::<Result<Vec<_>, _>>()?;\n \n@@ -1435,7 +1487,8 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     discr: ity,\n                     variants: variants,\n                     size: size,\n-                    align: align\n+                    align: align,\n+                    primitive_align: primitive_align\n                 }\n             }\n \n@@ -1557,6 +1610,30 @@ impl<'a, 'gcx, 'tcx> Layout {\n         }\n     }\n \n+    /// Returns alignment before repr alignment is applied\n+    pub fn primitive_align(&self, dl: &TargetDataLayout) -> Align {\n+        match *self {\n+            Array { primitive_align, .. } | General { primitive_align, .. } => primitive_align,\n+            Univariant { ref variant, .. } |\n+            StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n+                variant.primitive_align\n+            },\n+\n+            _ => self.align(dl)\n+        }\n+    }\n+\n+    /// Returns repr alignment if it is greater than the primitive alignment.\n+    pub fn over_align(&self, dl: &TargetDataLayout) -> Option<u32> {\n+        let align = self.align(dl);\n+        let primitive_align = self.primitive_align(dl);\n+        if align.abi() > primitive_align.abi() {\n+            Some(align.abi() as u32)\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn field_offset<C: HasDataLayout>(&self,\n                                           cx: C,\n                                           i: usize,"}, {"sha": "db8b093e369e02075a2b7f19ba81be3c4cd55d46", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -37,6 +37,7 @@ use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell, Ref};\n use std::collections::BTreeMap;\n+use std::cmp;\n use std::hash::{Hash, Hasher};\n use std::ops::Deref;\n use std::rc::Rc;\n@@ -1464,10 +1465,12 @@ impl_stable_hash_for!(struct ReprFlags {\n #[derive(Copy, Clone, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n+    pub align: u16,\n     pub flags: ReprFlags,\n }\n \n impl_stable_hash_for!(struct ReprOptions {\n+    align,\n     int,\n     flags\n });\n@@ -1476,7 +1479,7 @@ impl ReprOptions {\n     pub fn new(tcx: TyCtxt, did: DefId) -> ReprOptions {\n         let mut flags = ReprFlags::empty();\n         let mut size = None;\n-\n+        let mut max_align = 0;\n         for attr in tcx.get_attrs(did).iter() {\n             for r in attr::find_repr_attrs(tcx.sess.diagnostic(), attr) {\n                 flags.insert(match r {\n@@ -1487,6 +1490,10 @@ impl ReprOptions {\n                         size = Some(i);\n                         ReprFlags::empty()\n                     },\n+                    attr::ReprAlign(align) => {\n+                        max_align = cmp::max(align, max_align);\n+                        ReprFlags::empty()\n+                    },\n                 });\n             }\n         }\n@@ -1500,7 +1507,7 @@ impl ReprOptions {\n         if !tcx.consider_optimizing(|| format!(\"Reorder fields of {:?}\", tcx.item_path_str(did))) {\n             flags.insert(ReprFlags::IS_LINEAR);\n         }\n-        ReprOptions { int: size, flags: flags }\n+        ReprOptions { int: size, align: max_align, flags: flags }\n     }\n \n     #[inline]"}, {"sha": "efe4acfa9e072296727d65acfae0d14b3c8f58a2", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -553,7 +553,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let llscratch = bcx.alloca(ty, \"abi_cast\");\n+                let llscratch = bcx.alloca(ty, \"abi_cast\", None);\n                 base::Lifetime::Start.call(bcx, llscratch);\n \n                 // ...where we first store the value..."}, {"sha": "3c73aba7cd7eda77cff22601136bfc14a2aeb220", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 65, "deletions": 17, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -90,12 +90,12 @@ pub fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n /// and fill in the actual contents in a second pass to prevent\n /// unbounded recursion; see also the comments in `trans::type_of`.\n pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    generic_type_of(cx, t, None, false, false)\n+    generic_type_of(cx, t, None, false)\n }\n \n pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     t: Ty<'tcx>, name: &str) -> Type {\n-    generic_type_of(cx, t, Some(name), false, false)\n+    generic_type_of(cx, t, Some(name), false)\n }\n \n pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -114,7 +114,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 _ => unreachable!()\n             };\n             let fields = compute_fields(cx, t, nonnull_variant_index as usize, true);\n-            llty.set_struct_body(&struct_llfields(cx, &fields, nonnull_variant, false, false),\n+            llty.set_struct_body(&struct_llfields(cx, &fields, nonnull_variant, false),\n                                  packed)\n         },\n         _ => bug!(\"This function cannot handle {} with layout {:#?}\", t, l)\n@@ -124,11 +124,9 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              t: Ty<'tcx>,\n                              name: Option<&str>,\n-                             sizing: bool,\n-                             dst: bool) -> Type {\n+                             sizing: bool) -> Type {\n     let l = cx.layout_of(t);\n-    debug!(\"adt::generic_type_of t: {:?} name: {:?} sizing: {} dst: {}\",\n-           t, name, sizing, dst);\n+    debug!(\"adt::generic_type_of t: {:?} name: {:?} sizing: {}\", t, name, sizing);\n     match *l {\n         layout::CEnum { discr, .. } => Type::from_integer(cx, discr),\n         layout::RawNullablePointer { nndiscr, .. } => {\n@@ -148,7 +146,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields = compute_fields(cx, t, nndiscr as usize, false);\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, &fields, nonnull, sizing, dst),\n+                    Type::struct_(cx, &struct_llfields(cx, &fields, nonnull, sizing),\n                                   nonnull.packed)\n                 }\n                 Some(name) => {\n@@ -163,7 +161,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields = compute_fields(cx, t, 0, true);\n             match name {\n                 None => {\n-                    let fields = struct_llfields(cx, &fields, &variant, sizing, dst);\n+                    let fields = struct_llfields(cx, &fields, &variant, sizing);\n                     Type::struct_(cx, &fields, variant.packed)\n                 }\n                 Some(name) => {\n@@ -245,15 +243,65 @@ fn union_fill(cx: &CrateContext, size: u64, align: u64) -> Type {\n }\n \n \n-fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fields: &Vec<Ty<'tcx>>,\n+// Double index to account for padding (FieldPath already uses `Struct::memory_index`)\n+fn struct_llfields_path(discrfield: &layout::FieldPath) -> Vec<usize> {\n+    discrfield.iter().map(|&i| (i as usize) << 1).collect::<Vec<_>>()\n+}\n+\n+\n+// Lookup `Struct::memory_index` and double it to account for padding\n+pub fn struct_llfields_index(variant: &layout::Struct, index: usize) -> usize {\n+    (variant.memory_index[index] as usize) << 1\n+}\n+\n+\n+pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, field_tys: &Vec<Ty<'tcx>>,\n                              variant: &layout::Struct,\n-                             sizing: bool, _dst: bool) -> Vec<Type> {\n-    let fields = variant.field_index_by_increasing_offset().map(|i| fields[i as usize]);\n+                             sizing: bool) -> Vec<Type> {\n     if sizing {\n-        bug!()\n+        bug!();\n+    }\n+    debug!(\"struct_llfields: variant: {:?}\", variant);\n+    let mut first_field = true;\n+    let mut min_offset = 0;\n+    let mut result: Vec<Type> = Vec::with_capacity(field_tys.len() * 2);\n+    let field_iter = variant.field_index_by_increasing_offset().map(|i| {\n+        (i, field_tys[i as usize], variant.offsets[i as usize].bytes()) });\n+    for (index, ty, target_offset) in field_iter.filter(\n+        |&(_, ty, _)| !sizing || cx.shared().type_is_sized(ty)) {\n+        if first_field {\n+            debug!(\"struct_llfields: {} ty: {} min_offset: {} target_offset: {}\",\n+                index, ty, min_offset, target_offset);\n+            first_field = false;\n+        } else {\n+            assert!(target_offset >= min_offset);\n+            let padding_bytes = if variant.packed { 0 } else { target_offset - min_offset };\n+            result.push(Type::array(&Type::i8(cx), padding_bytes));\n+            debug!(\"struct_llfields: {} ty: {} pad_bytes: {} min_offset: {} target_offset: {}\",\n+                index, ty, padding_bytes, min_offset, target_offset);\n+        }\n+        let llty = type_of::in_memory_type_of(cx, ty);\n+        result.push(llty);\n+        let layout = cx.layout_of(ty);\n+        let target_size = layout.size(&cx.tcx().data_layout).bytes();\n+        min_offset = target_offset + target_size;\n+    }\n+    if variant.sized && !field_tys.is_empty() {\n+        if variant.stride().bytes() < min_offset {\n+            bug!(\"variant: {:?} stride: {} min_offset: {}\", variant, variant.stride().bytes(),\n+            min_offset);\n+        }\n+        let padding_bytes = variant.stride().bytes() - min_offset;\n+        debug!(\"struct_llfields: pad_bytes: {} min_offset: {} min_size: {} stride: {}\\n\",\n+               padding_bytes, min_offset, variant.min_size.bytes(), variant.stride().bytes());\n+        result.push(Type::array(&Type::i8(cx), padding_bytes));\n+        assert!(result.len() == (field_tys.len() * 2));\n     } else {\n-        fields.map(|ty| type_of::in_memory_type_of(cx, ty)).collect()\n+        debug!(\"struct_llfields: min_offset: {} min_size: {} stride: {}\\n\",\n+               min_offset, variant.min_size.bytes(), variant.stride().bytes());\n     }\n+\n+    result\n }\n \n pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n@@ -309,8 +357,8 @@ fn struct_wrapped_nullable_bitdiscr(\n     scrutinee: ValueRef,\n     alignment: Alignment,\n ) -> ValueRef {\n-    let llptrptr = bcx.gepi(scrutinee,\n-        &discrfield.iter().map(|f| *f as usize).collect::<Vec<_>>());\n+    let path = struct_llfields_path(discrfield);\n+    let llptrptr = bcx.gepi(scrutinee, &path);\n     let llptr = bcx.load(llptrptr, alignment.to_align());\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     bcx.icmp(cmp, llptr, C_null(val_ty(llptr)))\n@@ -380,7 +428,7 @@ pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: Valu\n                     let align = C_i32(bcx.ccx, nonnull.align.abi() as i32);\n                     base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                 } else {\n-                    let path = discrfield.iter().map(|&i| i as usize).collect::<Vec<_>>();\n+                    let path = struct_llfields_path(discrfield);\n                     let llptrptr = bcx.gepi(val, &path);\n                     let llptrty = val_ty(llptrptr).element_type();\n                     bcx.store(C_null(llptrty), llptrptr, None);"}, {"sha": "5103ca5c5e1094ef94b66bbbe65a497e07f21cd7", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -477,24 +477,28 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn alloca(&self, ty: Type, name: &str) -> ValueRef {\n+    pub fn alloca(&self, ty: Type, name: &str, align: Option<u32>) -> ValueRef {\n         let builder = Builder::with_ccx(self.ccx);\n         builder.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n-        builder.dynamic_alloca(ty, name)\n+        builder.dynamic_alloca(ty, name, align)\n     }\n \n-    pub fn dynamic_alloca(&self, ty: Type, name: &str) -> ValueRef {\n+    pub fn dynamic_alloca(&self, ty: Type, name: &str, align: Option<u32>) -> ValueRef {\n         self.count_insn(\"alloca\");\n         unsafe {\n-            if name.is_empty() {\n+            let alloca = if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n             } else {\n                 let name = CString::new(name).unwrap();\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(),\n                                       name.as_ptr())\n+            };\n+            if let Some(align) = align {\n+                llvm::LLVMSetAlignment(alloca, align as c_uint);\n             }\n+            alloca\n         }\n     }\n "}, {"sha": "54e20f590c6718350bd22c1b4326402202f4cc63", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -778,7 +778,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         //\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = Type::i64(ccx).ptr_to();\n-        let slot = bcx.alloca(i64p, \"slot\");\n+        let slot = bcx.alloca(i64p, \"slot\", None);\n         bcx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n             None);\n "}, {"sha": "d94d7f4430bf006bfb0ed196e888c24e42e06c8b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -15,6 +15,7 @@ use rustc::ty::{self, TypeFoldable};\n use rustc::ty::layout::{self, LayoutTyper};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n+use adt;\n use base::{self, Lifetime};\n use callee;\n use builder::Builder;\n@@ -177,7 +178,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n                     let llslot = match op.val {\n                         Immediate(_) | Pair(..) => {\n-                            let llscratch = bcx.alloca(ret.memory_ty(bcx.ccx), \"ret\");\n+                            let llscratch = bcx.alloca(ret.memory_ty(bcx.ccx), \"ret\", None);\n                             self.store_operand(&bcx, llscratch, None, op);\n                             llscratch\n                         }\n@@ -630,7 +631,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => {\n                 if arg.is_indirect() || arg.cast.is_some() {\n-                    let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\");\n+                    let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\", None);\n                     self.store_operand(bcx, llscratch, None, op);\n                     (llscratch, Alignment::AbiAligned, true)\n                 } else {\n@@ -642,7 +643,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                 // have scary latent bugs around.\n \n-                let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\");\n+                let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\", None);\n                 base::memcpy_ty(bcx, llscratch, llval, op.ty, Some(1));\n                 (llscratch, Alignment::AbiAligned, true)\n             }\n@@ -711,7 +712,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     bug!(\"Not a tuple.\");\n                 };\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let mut elem = bcx.extract_value(llval, v.memory_index[n] as usize);\n+                    let mut elem = bcx.extract_value(\n+                        llval, adt::struct_llfields_index(v, n));\n                     // Truncate bools to i1, if needed\n                     if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx) {\n                         elem = bcx.trunc(elem, Type::i1(bcx.ccx));\n@@ -750,7 +752,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             slot\n         } else {\n             let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-            let slot = bcx.alloca(llretty, \"personalityslot\");\n+            let slot = bcx.alloca(llretty, \"personalityslot\", None);\n             self.llpersonalityslot = Some(slot);\n             slot\n         }"}, {"sha": "9a461e4aafc23e4200c053d7ff87797bf0fdb4df", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -97,7 +97,8 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n     pub fn alloca(bcx: &Builder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> LvalueRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, ty);\n-        let tmp = bcx.alloca(type_of::type_of(bcx.ccx, ty), name);\n+        let tmp = bcx.alloca(\n+            type_of::type_of(bcx.ccx, ty), name, bcx.ccx.over_align_of(ty));\n         assert!(!ty.has_param_types());\n         Self::new_sized_ty(tmp, ty, Alignment::AbiAligned)\n     }\n@@ -131,11 +132,9 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n         let alignment = self.alignment | Alignment::from_packed(st.packed);\n \n+        let llfields = adt::struct_llfields(ccx, fields, st, false);\n         let ptr_val = if needs_cast {\n-            let fields = st.field_index_by_increasing_offset().map(|i| {\n-                type_of::in_memory_type_of(ccx, fields[i])\n-            }).collect::<Vec<_>>();\n-            let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n+            let real_ty = Type::struct_(ccx, &llfields[..], st.packed);\n             bcx.pointercast(self.llval, real_ty.ptr_to())\n         } else {\n             self.llval\n@@ -147,14 +146,16 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         //   * Field is sized - pointer is properly aligned already\n         if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n             bcx.ccx.shared().type_is_sized(fty) {\n-                return (bcx.struct_gep(ptr_val, st.memory_index[ix] as usize), alignment);\n+                return (bcx.struct_gep(\n+                        ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n             }\n \n         // If the type of the last field is [T] or str, then we don't need to do\n         // any adjusments\n         match fty.sty {\n             ty::TySlice(..) | ty::TyStr => {\n-                return (bcx.struct_gep(ptr_val, st.memory_index[ix] as usize), alignment);\n+                return (bcx.struct_gep(\n+                        ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n             }\n             _ => ()\n         }\n@@ -163,7 +164,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         if !self.has_extra() {\n             debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n                 ix, Value(ptr_val));\n-            return (bcx.struct_gep(ptr_val, ix), alignment);\n+            return (bcx.struct_gep(ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n         }\n \n         // We need to get the pointer manually now."}, {"sha": "d39a91405c1854a3cc2a8063e43ef35bcbbc6b4d", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -524,7 +524,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             let env_ptr = if !env_ref {\n-                let alloc = bcx.alloca(common::val_ty(llval), \"__debuginfo_env_ptr\");\n+                let alloc = bcx.alloca(common::val_ty(llval), \"__debuginfo_env_ptr\", None);\n                 bcx.store(llval, alloc, None);\n                 alloc\n             } else {"}, {"sha": "6889b5064b649a9bf0098566e73503b256bd3943", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -15,6 +15,7 @@ use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n \n+use adt;\n use base;\n use common::{self, CrateContext, C_null};\n use builder::Builder;\n@@ -134,6 +135,12 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                 if common::val_ty(elem) == Type::i1(bcx.ccx) {\n                     elem = bcx.zext(elem, Type::i8(bcx.ccx));\n                 }\n+                let layout = bcx.ccx.layout_of(self.ty);\n+                let i = if let Layout::Univariant { ref variant, .. } = *layout {\n+                    adt::struct_llfields_index(variant, i)\n+                } else {\n+                    i\n+                };\n                 llpair = bcx.insert_value(llpair, elem, i);\n             }\n             self.val = OperandValue::Immediate(llpair);\n@@ -183,14 +190,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             let (lldata, llextra) = base::load_fat_ptr(bcx, llval, align, ty);\n             OperandValue::Pair(lldata, llextra)\n         } else if common::type_is_imm_pair(bcx.ccx, ty) {\n-            let f_align = match *bcx.ccx.layout_of(ty) {\n-                Layout::Univariant { ref variant, .. } =>\n-                    Alignment::from_packed(variant.packed) | align,\n-                _ => align\n+            let (ix0, ix1, f_align) = match *bcx.ccx.layout_of(ty) {\n+                Layout::Univariant { ref variant, .. } => {\n+                    (adt::struct_llfields_index(variant, 0),\n+                    adt::struct_llfields_index(variant, 1),\n+                    Alignment::from_packed(variant.packed) | align)\n+                },\n+                _ => (0, 1, align)\n             };\n             let [a_ty, b_ty] = common::type_pair_fields(bcx.ccx, ty).unwrap();\n-            let a_ptr = bcx.struct_gep(llval, 0);\n-            let b_ptr = bcx.struct_gep(llval, 1);\n+            let a_ptr = bcx.struct_gep(llval, ix0);\n+            let b_ptr = bcx.struct_gep(llval, ix1);\n \n             OperandValue::Pair(\n                 base::load_ty(bcx, a_ptr, f_align, a_ty),\n@@ -302,17 +312,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 bcx.store(base::from_immediate(bcx, s), lldest, align);\n             }\n             OperandValue::Pair(a, b) => {\n-                let f_align = match *bcx.ccx.layout_of(operand.ty) {\n-                    Layout::Univariant { ref variant, .. } if variant.packed => {\n-                        Some(1)\n+                let (ix0, ix1, f_align) = match *bcx.ccx.layout_of(operand.ty) {\n+                    Layout::Univariant { ref variant, .. } => {\n+                        (adt::struct_llfields_index(variant, 0),\n+                        adt::struct_llfields_index(variant, 1),\n+                        if variant.packed { Some(1) } else { None })\n                     }\n-                    _ => align\n+                    _ => (0, 1, align)\n                 };\n \n                 let a = base::from_immediate(bcx, a);\n                 let b = base::from_immediate(bcx, b);\n-                bcx.store(a, bcx.struct_gep(lldest, 0), f_align);\n-                bcx.store(b, bcx.struct_gep(lldest, 1), f_align);\n+                bcx.store(a, bcx.struct_gep(lldest, ix0), f_align);\n+                bcx.store(b, bcx.struct_gep(lldest, ix1), f_align);\n             }\n         }\n     }"}, {"sha": "de1c1e492f39b78b647873fe7bbe19e2d588a1c0", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -130,10 +130,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     _ => {\n                         // If this is a tuple or closure, we need to translate GEP indices.\n                         let layout = bcx.ccx.layout_of(dest.ty.to_ty(bcx.tcx()));\n-                        let translation = if let Layout::Univariant { ref variant, .. } = *layout {\n-                            Some(&variant.memory_index)\n-                        } else {\n-                            None\n+                        let get_memory_index = |i| {\n+                            if let Layout::Univariant { ref variant, .. } = *layout {\n+                                adt::struct_llfields_index(variant, i)\n+                            } else {\n+                                i\n+                            }\n                         };\n                         let alignment = dest.alignment;\n                         for (i, operand) in operands.iter().enumerate() {\n@@ -143,11 +145,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 // Note: perhaps this should be StructGep, but\n                                 // note that in some cases the values here will\n                                 // not be structs but arrays.\n-                                let i = if let Some(ref t) = translation {\n-                                    t[i] as usize\n-                                } else {\n-                                    i\n-                                };\n+                                let i = get_memory_index(i);\n                                 let dest = bcx.gepi(dest.llval, &[0, i]);\n                                 self.store_operand(&bcx, dest, alignment.to_align(), op);\n                             }"}, {"sha": "9f9126ba83a8f19fd59b8f66b5196d3c3982dbb1", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -214,6 +214,16 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n     pub fn size_of(&self, ty: Ty<'tcx>) -> machine::llsize {\n         self.layout_of(ty).size(self).bytes() as machine::llsize\n     }\n+\n+    pub fn over_align_of(&self, t: Ty<'tcx>)\n+                              -> Option<machine::llalign> {\n+        let layout = self.layout_of(t);\n+        if let Some(align) = layout.over_align(&self.tcx().data_layout) {\n+            Some(align as machine::llalign)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> String {"}, {"sha": "839af0fa6706cf0250ab7955586fd56903e689e5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -953,6 +953,12 @@ fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if def.repr.simd() {\n         check_simd(tcx, span, def_id);\n     }\n+\n+    // if struct is packed and not aligned, check fields for alignment.\n+    // Checks for combining packed and align attrs on single struct are done elsewhere.\n+    if tcx.lookup_adt_def(def_id).repr.packed() && tcx.lookup_adt_def(def_id).repr.align == 0 {\n+        check_packed(tcx, span, def_id);\n+    }\n }\n \n fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1371,6 +1377,47 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId\n     }\n }\n \n+fn check_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n+    if check_packed_inner(tcx, def_id, &mut Vec::new()) {\n+        struct_span_err!(tcx.sess, sp, E0588,\n+            \"packed struct cannot transitively contain a `[repr(align)]` struct\").emit();\n+    }\n+}\n+\n+fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                def_id: DefId,\n+                                stack: &mut Vec<DefId>) -> bool {\n+    let t = tcx.item_type(def_id);\n+    if stack.contains(&def_id) {\n+        debug!(\"check_packed_inner: {:?} is recursive\", t);\n+        return false;\n+    }\n+    match t.sty {\n+        ty::TyAdt(def, substs) if def.is_struct() => {\n+            if tcx.lookup_adt_def(def.did).repr.align > 0 {\n+                return true;\n+            }\n+            // push struct def_id before checking fields\n+            stack.push(def_id);\n+            for field in &def.struct_variant().fields {\n+                let f = field.ty(tcx, substs);\n+                match f.sty {\n+                    ty::TyAdt(def, _) => {\n+                        if check_packed_inner(tcx, def.did, stack) {\n+                            return true;\n+                        }\n+                    }\n+                    _ => ()\n+                }\n+            }\n+            // only need to pop if not early out\n+            stack.pop();\n+        }\n+        _ => ()\n+    }\n+    false\n+}\n+\n #[allow(trivial_numeric_casts)]\n pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             sp: Span,"}, {"sha": "c50156fa5f2714107dc73ee9e2572c665763a847", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -4168,5 +4168,6 @@ register_diagnostics! {\n            // but `{}` was found in the type `{}`\n     E0567, // auto traits can not have type parameters\n     E0568, // auto-traits can not have predicates,\n+    E0588, // packed struct cannot transitively contain a `[repr(align)]` struct\n     E0592, // duplicate definitions with name `{}`\n }"}, {"sha": "442345ceb3c1872852cdf75cb52f0aee8a79d3e1", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -147,6 +147,24 @@ impl NestedMetaItem {\n         self.meta_item().and_then(|meta_item| meta_item.value_str())\n     }\n \n+    /// Returns a name and single literal value tuple of the MetaItem.\n+    pub fn name_value_literal(&self) -> Option<(Name, &Lit)> {\n+        self.meta_item().and_then(\n+            |meta_item| meta_item.meta_item_list().and_then(\n+                |meta_item_list| {\n+                    if meta_item_list.len() == 1 {\n+                        let nested_item = &meta_item_list[0];\n+                        if nested_item.is_literal() {\n+                            Some((meta_item.name(), nested_item.literal().unwrap()))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    else {\n+                        None\n+                    }}))\n+    }\n+\n     /// Returns a MetaItem if self is a MetaItem with Kind Word.\n     pub fn word(&self) -> Option<&MetaItem> {\n         self.meta_item().and_then(|meta_item| if meta_item.is_word() {\n@@ -931,6 +949,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                     continue\n                 }\n \n+                let mut recognised = false;\n                 if let Some(mi) = item.word() {\n                     let word = &*mi.name().as_str();\n                     let hint = match word {\n@@ -941,20 +960,38 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                         _ => match int_type_of_word(word) {\n                             Some(ity) => Some(ReprInt(ity)),\n                             None => {\n-                                // Not a word we recognize\n-                                span_err!(diagnostic, item.span, E0552,\n-                                          \"unrecognized representation hint\");\n                                 None\n                             }\n                         }\n                     };\n \n                     if let Some(h) = hint {\n+                        recognised = true;\n                         acc.push(h);\n                     }\n-                } else {\n-                    span_err!(diagnostic, item.span, E0553,\n-                              \"unrecognized enum representation hint\");\n+                } else if let Some((name, value)) = item.name_value_literal() {\n+                    if name == \"align\" {\n+                        recognised = true;\n+                        let mut valid_align = false;\n+                        if let ast::LitKind::Int(align, ast::LitIntType::Unsuffixed) = value.node {\n+                            if align.is_power_of_two() {\n+                                // rustc::ty::layout::Align restricts align to <= 32768\n+                                if align <= 32768 {\n+                                    acc.push(ReprAlign(align as u16));\n+                                    valid_align = true;\n+                                }\n+                            }\n+                        }\n+                        if !valid_align {\n+                            span_err!(diagnostic, item.span, E0589,\n+                                      \"align representation must be a u16 power of two\");\n+                        }\n+                    }\n+                }\n+                if !recognised {\n+                    // Not a word we recognize\n+                    span_err!(diagnostic, item.span, E0552,\n+                              \"unrecognized representation hint\");\n                 }\n             }\n         }\n@@ -986,6 +1023,7 @@ pub enum ReprAttr {\n     ReprExtern,\n     ReprPacked,\n     ReprSimd,\n+    ReprAlign(u16),\n }\n \n #[derive(Eq, Hash, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]"}, {"sha": "775775875a4d1097277a0cb1a2b36c505d7cb2d8", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -287,10 +287,10 @@ register_diagnostics! {\n     E0550, // multiple deprecated attributes\n     E0551, // incorrect meta item\n     E0552, // unrecognized representation hint\n-    E0553, // unrecognized enum representation hint\n     E0554, // #[feature] may not be used on the [] release channel\n     E0555, // malformed feature attribute, expected #![feature(...)]\n     E0556, // malformed feature, expected just one word\n     E0557, // feature has been removed\n     E0584, // file for module `..` found at both .. and ..\n+    E0589, // align representation must be a u16 power of two\n }"}, {"sha": "e96883c26f33a1c854996e89ecbdc39d1cb78655", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -773,7 +773,7 @@ fn find_repr_type_name(diagnostic: &Handler, type_attrs: &[ast::Attribute]) -> &\n     for a in type_attrs {\n         for r in &attr::find_repr_attrs(diagnostic, a) {\n             repr_type_name = match *r {\n-                attr::ReprPacked | attr::ReprSimd => continue,\n+                attr::ReprPacked | attr::ReprSimd | attr::ReprAlign(_) => continue,\n                 attr::ReprExtern => \"i32\",\n \n                 attr::ReprInt(attr::SignedInt(ast::IntTy::Is)) => \"isize\","}, {"sha": "c0bfd3690c8598fd3b5989aaea5102f6afcca4c8", "filename": "src/test/compile-fail/attr-usage-repr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Ftest%2Fcompile-fail%2Fattr-usage-repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Ftest%2Fcompile-fail%2Fattr-usage-repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-usage-repr.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n+#![feature(attr_literals)]\n #![feature(repr_simd)]\n \n #[repr(C)] //~ ERROR: attribute should be applied to struct, enum or union\n@@ -29,6 +30,9 @@ struct SInt(f64, f64);\n #[repr(C)]\n enum EExtern { A, B }\n \n+#[repr(align(8))] //~ ERROR: attribute should be applied to struct\n+enum EAlign { A, B }\n+\n #[repr(packed)] //~ ERROR: attribute should be applied to struct\n enum EPacked { A, B }\n "}, {"sha": "af38673d3650e72f1f95ce081509abb2f6d09a94", "filename": "src/test/compile-fail/conflicting-repr-hints.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Ftest%2Fcompile-fail%2Fconflicting-repr-hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Ftest%2Fcompile-fail%2Fconflicting-repr-hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconflicting-repr-hints.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n #![allow(dead_code)]\n+#![feature(attr_literals)]\n \n #[repr(C)]\n enum A { A }\n@@ -26,5 +26,7 @@ enum D { D }\n #[repr(C, packed)]\n struct E(i32);\n \n-#[rustc_error]\n-fn main() {} //~ ERROR compilation successful\n+#[repr(packed, align(8))] //~ ERROR conflicting packed and align representation hints\n+struct F(i32);\n+\n+fn main() {}"}, {"sha": "96dfe1c05f9a7937bcae41707784894ca807c8f7", "filename": "src/test/compile-fail/repr-align.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Ftest%2Fcompile-fail%2Frepr-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Ftest%2Fcompile-fail%2Frepr-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepr-align.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![allow(dead_code)]\n+#![feature(attr_literals)]\n+\n+#[repr(align(16.0))] //~ ERROR: align representation must be a u16 power of two\n+struct A(i32);\n+\n+#[repr(align(15))] //~ ERROR: align representation must be a u16 power of two\n+struct B(i32);\n+\n+#[repr(align(65536))] //~ ERROR: align representation must be a u16 power of tw\n+struct C(i32);\n+\n+fn main() {}"}, {"sha": "11829dfae8cbe3cfd218df252fe7764959cca0c3", "filename": "src/test/compile-fail/repr-packed-contains-align.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Ftest%2Fcompile-fail%2Frepr-packed-contains-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Ftest%2Fcompile-fail%2Frepr-packed-contains-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepr-packed-contains-align.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(attr_literals)]\n+#![allow(dead_code)]\n+\n+#[repr(align(16))]\n+struct A(i32);\n+\n+struct B(A);\n+\n+#[repr(packed)]\n+struct C(A); //~ ERROR: packed struct cannot transitively contain a `[repr(align)]` struct\n+\n+#[repr(packed)]\n+struct D(B); //~ ERROR: packed struct cannot transitively contain a `[repr(align)]` struct\n+\n+fn main() {}"}, {"sha": "4793189d366dfb59d4a6167c386cd0be5ff15574", "filename": "src/test/run-pass/align-struct.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Ftest%2Frun-pass%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Ftest%2Frun-pass%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falign-struct.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -0,0 +1,195 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(attr_literals)]\n+\n+use std::mem;\n+\n+// Raising alignment\n+#[repr(align(16))]\n+struct Align16(i32);\n+\n+// Lowering has no effect\n+#[repr(align(1))]\n+struct Align1(i32);\n+\n+// Multiple attributes take the max\n+#[repr(align(4))]\n+#[repr(align(16))]\n+#[repr(align(8))]\n+struct AlignMany(i32);\n+\n+// Raising alignment may not alter size.\n+#[repr(align(8))]\n+#[allow(dead_code)]\n+struct Align8Many {\n+    a: i32,\n+    b: i32,\n+    c: i32,\n+    d: u8,\n+}\n+\n+enum Enum {\n+    #[allow(dead_code)]\n+    A(i32),\n+    B(Align16)\n+}\n+\n+// Nested alignment - use `#[repr(C)]` to suppress field reordering for sizeof test\n+#[repr(C)]\n+struct Nested {\n+    a: i32,\n+    b: i32,\n+    c: Align16,\n+    d: i8,\n+}\n+\n+#[repr(packed)]\n+struct Packed(i32);\n+\n+#[repr(align(16))]\n+struct AlignContainsPacked {\n+    a: Packed,\n+    b: Packed,\n+}\n+\n+impl Align16 {\n+    // return aligned type\n+    pub fn new(i: i32) -> Align16 {\n+        Align16(i)\n+    }\n+    // pass aligned type\n+    pub fn consume(a: Align16) -> i32 {\n+        a.0\n+    }\n+}\n+\n+const CONST_ALIGN16: Align16 = Align16(7);\n+static STATIC_ALIGN16: Align16 = Align16(8);\n+\n+// Check the actual address is aligned\n+fn is_aligned_to<T>(p: &T, align: usize) -> bool {\n+    let addr = p as *const T as usize;\n+    (addr & (align - 1)) == 0\n+}\n+\n+pub fn main() {\n+    // check alignment and size by type and value\n+    assert_eq!(mem::align_of::<Align16>(), 16);\n+    assert_eq!(mem::size_of::<Align16>(), 16);\n+\n+    let a = Align16(7);\n+    assert_eq!(a.0, 7);\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+\n+    assert!(is_aligned_to(&a, 16));\n+\n+    // lowering should have no effect\n+    assert_eq!(mem::align_of::<Align1>(), 4);\n+    assert_eq!(mem::size_of::<Align1>(), 4);\n+    let a = Align1(7);\n+    assert_eq!(a.0, 7);\n+    assert_eq!(mem::align_of_val(&a), 4);\n+    assert_eq!(mem::size_of_val(&a), 4);\n+    assert!(is_aligned_to(&a, 4));\n+\n+    // when multiple attributes are specified the max should be used\n+    assert_eq!(mem::align_of::<AlignMany>(), 16);\n+    assert_eq!(mem::size_of::<AlignMany>(), 16);\n+    let a = AlignMany(7);\n+    assert_eq!(a.0, 7);\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+    assert!(is_aligned_to(&a, 16));\n+\n+    // raising alignment should not reduce size\n+    assert_eq!(mem::align_of::<Align8Many>(), 8);\n+    assert_eq!(mem::size_of::<Align8Many>(), 16);\n+    let a = Align8Many { a: 1, b: 2, c: 3, d: 4 };\n+    assert_eq!(a.a, 1);\n+    assert_eq!(mem::align_of_val(&a), 8);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+    assert!(is_aligned_to(&a, 8));\n+\n+    // return type\n+    let a = Align16::new(1);\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+    assert_eq!(a.0, 1);\n+    assert!(is_aligned_to(&a, 16));\n+    assert_eq!(Align16::consume(a), 1);\n+\n+    // check const alignment, size and value\n+    assert_eq!(mem::align_of_val(&CONST_ALIGN16), 16);\n+    assert_eq!(mem::size_of_val(&CONST_ALIGN16), 16);\n+    assert_eq!(CONST_ALIGN16.0, 7);\n+    assert!(is_aligned_to(&CONST_ALIGN16, 16));\n+\n+    // check global static alignment, size and value\n+    assert_eq!(mem::align_of_val(&STATIC_ALIGN16), 16);\n+    assert_eq!(mem::size_of_val(&STATIC_ALIGN16), 16);\n+    assert_eq!(STATIC_ALIGN16.0, 8);\n+    assert!(is_aligned_to(&STATIC_ALIGN16, 16));\n+\n+    // Note that the size of Nested may change if struct field re-ordering is enabled\n+    assert_eq!(mem::align_of::<Nested>(), 16);\n+    assert_eq!(mem::size_of::<Nested>(), 48);\n+    let a = Nested{ a: 1, b: 2, c: Align16(3), d: 4};\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::align_of_val(&a.b), 4);\n+    assert_eq!(mem::align_of_val(&a.c), 16);\n+    assert_eq!(mem::size_of_val(&a), 48);\n+    assert!(is_aligned_to(&a, 16));\n+    // check the correct fields are indexed\n+    assert_eq!(a.a, 1);\n+    assert_eq!(a.b, 2);\n+    assert_eq!(a.c.0, 3);\n+    assert_eq!(a.d, 4);\n+\n+    // enum should be aligned to max alignment\n+    assert_eq!(mem::align_of::<Enum>(), 16);\n+    assert_eq!(mem::align_of_val(&Enum::B(Align16(0))), 16);\n+    let e = Enum::B(Align16(15));\n+    match e {\n+        Enum::B(ref a) => {\n+            assert_eq!(a.0, 15);\n+            assert_eq!(mem::align_of_val(a), 16);\n+            assert_eq!(mem::size_of_val(a), 16);\n+        },\n+        _ => ()\n+    }\n+    assert!(is_aligned_to(&e, 16));\n+\n+    // arrays of aligned elements should also be aligned\n+    assert_eq!(mem::align_of::<[Align16;2]>(), 16);\n+    assert_eq!(mem::size_of::<[Align16;2]>(), 32);\n+\n+    let a = [Align16(0), Align16(1)];\n+    assert_eq!(mem::align_of_val(&a[0]), 16);\n+    assert_eq!(mem::align_of_val(&a[1]), 16);\n+    assert!(is_aligned_to(&a, 16));\n+\n+    // check heap value is aligned\n+    assert_eq!(mem::align_of_val(Box::new(Align16(0)).as_ref()), 16);\n+\n+    // check heap array is aligned\n+    let a = vec!(Align16(0), Align16(1));\n+    assert_eq!(mem::align_of_val(&a[0]), 16);\n+    assert_eq!(mem::align_of_val(&a[1]), 16);\n+\n+    assert_eq!(mem::align_of::<AlignContainsPacked>(), 16);\n+    assert_eq!(mem::size_of::<AlignContainsPacked>(), 16);\n+    let a = AlignContainsPacked { a: Packed(1), b: Packed(2) };\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::align_of_val(&a.a), 1);\n+    assert_eq!(mem::align_of_val(&a.b), 1);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+    assert!(is_aligned_to(&a, 16));\n+}"}, {"sha": "ea2910f86c458a75837146c630dfba01bb1fb715", "filename": "src/test/ui/print_type_sizes/repr-align.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.rs?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z print-type-sizes\n+\n+// This file illustrates how padding is handled: alignment\n+// requirements can lead to the introduction of padding, either before\n+// fields or at the end of the structure as a whole.\n+//\n+// It avoids using u64/i64 because on some targets that is only 4-byte\n+// aligned (while on most it is 8-byte aligned) and so the resulting\n+// padding and overall computed sizes can be quite different.\n+#![feature(attr_literals)]\n+#![allow(dead_code)]\n+\n+#[repr(align(16))]\n+#[derive(Default)]\n+struct A(i32);\n+\n+enum E {\n+    A(i32),\n+    B(A)\n+}\n+\n+#[derive(Default)]\n+struct S {\n+    a: i32,\n+    b: i32,\n+    c: A,\n+    d: i8,\n+}\n+\n+fn main() {\n+    let _s: S = Default::default();\n+}"}, {"sha": "7df12f040b15d4d24dbfa071ccc2853649b43e0a", "filename": "src/test/ui/print_type_sizes/repr-align.stdout", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4358e35fda66ab7a00215c7f9d50e7c6dc9b801b/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stdout?ref=4358e35fda66ab7a00215c7f9d50e7c6dc9b801b", "patch": "@@ -0,0 +1,16 @@\n+print-type-size type: `E`: 32 bytes, alignment: 16 bytes\n+print-type-size     discriminant: 4 bytes\n+print-type-size     variant `A`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n+print-type-size     variant `B`: 28 bytes\n+print-type-size         padding: 12 bytes\n+print-type-size         field `.0`: 16 bytes, alignment: 16 bytes\n+print-type-size type: `S`: 32 bytes, alignment: 16 bytes\n+print-type-size     field `.c`: 16 bytes\n+print-type-size     field `.a`: 4 bytes\n+print-type-size     field `.b`: 4 bytes\n+print-type-size     field `.d`: 1 bytes\n+print-type-size     end padding: 7 bytes\n+print-type-size type: `A`: 16 bytes, alignment: 16 bytes\n+print-type-size     field `.0`: 4 bytes\n+print-type-size     end padding: 12 bytes"}]}