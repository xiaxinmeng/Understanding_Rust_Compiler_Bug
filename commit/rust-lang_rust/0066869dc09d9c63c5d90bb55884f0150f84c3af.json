{"sha": "0066869dc09d9c63c5d90bb55884f0150f84c3af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNjY4NjlkYzA5ZDljNjNjNWQ5MGJiNTU4ODRmMDE1MGY4NGMzYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-12T16:50:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-12T16:50:00Z"}, "message": "Auto merge of #40455 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 5 pull requests\n\n- Successful merges: #40369, #40390, #40426, #40449, #40453\n- Failed merges:", "tree": {"sha": "21d385ffc06a157ebae9d19c8521eefa6901a8c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21d385ffc06a157ebae9d19c8521eefa6901a8c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0066869dc09d9c63c5d90bb55884f0150f84c3af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0066869dc09d9c63c5d90bb55884f0150f84c3af", "html_url": "https://github.com/rust-lang/rust/commit/0066869dc09d9c63c5d90bb55884f0150f84c3af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0066869dc09d9c63c5d90bb55884f0150f84c3af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f88b24b34c6d17ebe4014bec5a0f7c2a57c529c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f88b24b34c6d17ebe4014bec5a0f7c2a57c529c7", "html_url": "https://github.com/rust-lang/rust/commit/f88b24b34c6d17ebe4014bec5a0f7c2a57c529c7"}, {"sha": "3b002a8ab5322f6503ccc3d13d3ae40ae0f54c5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b002a8ab5322f6503ccc3d13d3ae40ae0f54c5c", "html_url": "https://github.com/rust-lang/rust/commit/3b002a8ab5322f6503ccc3d13d3ae40ae0f54c5c"}], "stats": {"total": 491, "additions": 356, "deletions": 135}, "files": [{"sha": "b34007db8ac7af314b10f246cd54147df60fef6b", "filename": "src/Cargo.lock", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -67,7 +67,7 @@ dependencies = [\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -99,7 +99,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term_size 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -139,7 +139,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -157,15 +157,15 @@ name = \"env_logger\"\n version = \"0.3.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"env_logger\"\n-version = \"0.4.0\"\n+version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -178,7 +178,7 @@ name = \"filetime\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -216,13 +216,13 @@ name = \"handlebars\"\n version = \"0.25.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lazy_static 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quick-error 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 0.9.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 0.9.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -241,7 +241,7 @@ dependencies = [\n \n [[package]]\n name = \"lazy_static\"\n-version = \"0.2.2\"\n+version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -253,7 +253,7 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.20\"\n+version = \"0.2.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -266,45 +266,45 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"log\"\n-version = \"0.3.6\"\n+version = \"0.3.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.0.17\"\n+version = \"0.0.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"clap 2.20.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"handlebars 0.25.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 0.9.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 0.9.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 0.9.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 0.9.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"memchr\"\n version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"num-traits\"\n-version = \"0.1.36\"\n+version = \"0.1.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"num_cpus\"\n version = \"0.2.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -402,7 +402,7 @@ name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n  \"clap 2.20.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"mdbook 0.0.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"mdbook 0.0.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -770,18 +770,18 @@ dependencies = [\n \n [[package]]\n name = \"serde\"\n-version = \"0.9.7\"\n+version = \"0.9.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde_json\"\n-version = \"0.9.7\"\n+version = \"0.9.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 0.9.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 0.9.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -865,7 +865,7 @@ version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -883,7 +883,7 @@ version = \"3.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -909,10 +909,10 @@ dependencies = [\n \n [[package]]\n name = \"toml\"\n-version = \"0.3.0\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 0.9.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 0.9.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -967,19 +967,19 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum cmake 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1acc68a3f714627af38f9f5d09706a28584ba60dfe2cca68f40bf779f941b25\"\n \"checksum dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"80c8b71fd71146990a9742fc06dcbbde19161a267e0ad4e572c35162f4578c90\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n-\"checksum env_logger 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"99971fb1b635fe7a0ee3c4d065845bb93cca80a23b5613b5613391ece5de4144\"\n+\"checksum env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e3856f1697098606fc6cb97a93de88ca3f3bc35bb878c725920e6e82ecf05e83\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n \"checksum gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c07c758b972368e703a562686adb39125707cc1ef3399da8c019fc6c2498a75d\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n \"checksum handlebars 0.25.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b2249f6f0dc5a3bb2b3b1a8f797dfccbc4b053344d773d654ad565e51427d335\"\n \"checksum itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb2f404fbc66fd9aac13e998248505e7ecb2ad8e44ab6388684c5fb11c6c251c\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n-\"checksum lazy_static 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6abe0ee2e758cd6bc8a2cd56726359007748fbf4128da998b65d0b70f881e19b\"\n-\"checksum libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"684f330624d8c3784fb9558ca46c4ce488073a8d22450415c5eb4f4cfb0d11b5\"\n-\"checksum log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab83497bf8bf4ed2a74259c1c802351fcd67a65baa86394b6ba73c36f4838054\"\n-\"checksum mdbook 0.0.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbba458ca886cb082d026afd704eeeeb0531f7e4ffd6c619f72dc309c1c18fe4\"\n+\"checksum lazy_static 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7291b1dd97d331f752620b02dfdbc231df7fc01bf282a00769e1cdb963c460dc\"\n+\"checksum libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"88ee81885f9f04bff991e306fea7c1c60a5f0f9e409e99f6b40e3311a3363135\"\n+\"checksum log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5141eca02775a762cc6cd564d8d2c50f67c0ea3a372cbf1c51592b3e029e10ad\"\n+\"checksum mdbook 0.0.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"06a68e8738e42b38a02755d3ce5fa12d559e17acb238e4326cbc3cc056e65280\"\n \"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n-\"checksum num-traits 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a16a42856a256b39c6d3484f097f6713e14feacd9bfb02290917904fae46c81c\"\n+\"checksum num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1cbfa3781f3fe73dc05321bed52a06d2d491eaa764c52335cf4399f046ece99\"\n \"checksum num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cee7e88156f3f9e19bdd598f8d6c9db7bf4078f99f8381f43a55b09648d1a6e3\"\n \"checksum open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3478ed1686bd1300c8a981a940abc92b06fac9cbef747f4c668d4e032ff7b842\"\n \"checksum pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a6dda33d67c26f0aac90d324ab2eb7239c819fc7b2552fe9faa4fe88441edc8\"\n@@ -988,14 +988,14 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4278c17d0f6d62dfef0ab00028feb45bd7d2102843f80763474eeb1be8a10c01\"\n \"checksum regex-syntax 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f9191b1f57603095f105d317e375d19b1c9c5c3185ea9633a99a6dcbed04457\"\n \"checksum rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"237546c689f20bb44980270c73c3b9edd0891c1be49cc1274406134a66d3957b\"\n-\"checksum serde 0.9.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1e0ed773960f90a78567fcfbe935284adf50c5d7cf119aa2cf43bb0b4afa69bb\"\n-\"checksum serde_json 0.9.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2eb96d30e4e6f9fc52e08f51176d078b6f79b981dc3ed4134f7b850be9f446a8\"\n+\"checksum serde 0.9.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a702319c807c016e51f672e5c77d6f0b46afddd744b5e437d6b8436b888b458f\"\n+\"checksum serde_json 0.9.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbc45439552eb8fb86907a2c41c1fd0ef97458efb87ff7f878db466eb581824e\"\n \"checksum strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b4d15c810519a91cf877e7e36e63fe068815c678181439f2f29e2562147c3694\"\n \"checksum term_size 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07b6c1ac5b3fffd75073276bca1ceed01f67a28537097a2a9539e116e50fb21a\"\n \"checksum thread-id 3.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4437c97558c70d129e40629a5b385b3fb1ffac301e63941335e4d354081ec14a\"\n \"checksum thread_local 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c85048c6260d17cf486ceae3282d9fb6b90be220bf5b28c400f5485ffc29f0c7\"\n \"checksum toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0590d72182e50e879c4da3b11c6488dae18fccb1ae0c7a3eda18e16795844796\"\n-\"checksum toml 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"08272367dd2e766db3fa38f068067d17aa6a9dfd7259af24b3927db92f1e0c2f\"\n+\"checksum toml 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3474f3c6eaf32eedb4f4a66a26214f020f828a6d96c37e38a35e3a379bbcfd11\"\n \"checksum unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"18127285758f0e2c6cf325bb3f3d138a12fee27de4f23e146cd6a179f26c2cf3\"\n \"checksum unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bf3a113775714a22dcb774d8ea3655c53a32debae63a063acc00a91cc586245f\"\n \"checksum unreachable 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f2ae5ddb18e1c92664717616dd9549dde73f539f01bd7b77c2edb2446bdff91\""}, {"sha": "0ab0550469bad07248a69d92acb6328bdbc0eae6", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -29,6 +29,13 @@\n #![crate_type = \"dylib\"]\n #![deny(warnings)]\n #![deny(missing_docs)]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+       html_playground_url = \"https://play.rust-lang.org/\",\n+       issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n+       test(no_crate_inject, attr(deny(warnings))),\n+       test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "62d75126557284b806dcdf173c991fedf7c14bbb", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -738,7 +738,7 @@ Available lint options:\n               Allow <foo>\n     -D <foo>           Deny <foo>\n     -F <foo>           Forbid <foo> \\\n-              (deny, and deny all overrides)\n+              (deny <foo> and all attempts to override)\n \n \");\n "}, {"sha": "104cc78597a4a501f89286355d633d99fc06fbfa", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -407,7 +407,7 @@ enum PathSource<'a> {\n     // Trait paths in bounds or impls.\n     Trait,\n     // Expression paths `path`, with optional parent context.\n-    Expr(Option<&'a ExprKind>),\n+    Expr(Option<&'a Expr>),\n     // Paths in path patterns `Path`.\n     Pat,\n     // Paths in struct expressions and patterns `Path { .. }`.\n@@ -464,7 +464,7 @@ impl<'a> PathSource<'a> {\n                 ValueNS => \"method or associated constant\",\n                 MacroNS => bug!(\"associated macro\"),\n             },\n-            PathSource::Expr(parent) => match parent {\n+            PathSource::Expr(parent) => match parent.map(|p| &p.node) {\n                 // \"function\" here means \"anything callable\" rather than `Def::Fn`,\n                 // this is not precise but usually more helpful than just \"value\".\n                 Some(&ExprKind::Call(..)) => \"function\",\n@@ -2200,14 +2200,16 @@ impl<'a> Resolver<'a> {\n                           source: PathSource)\n                           -> PathResolution {\n         let segments = &path.segments.iter().map(|seg| seg.identifier).collect::<Vec<_>>();\n-        self.smart_resolve_path_fragment(id, qself, segments, path.span, source)\n+        let ident_span = path.segments.last().map_or(path.span, |seg| seg.span);\n+        self.smart_resolve_path_fragment(id, qself, segments, path.span, ident_span, source)\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n                                    qself: Option<&QSelf>,\n                                    path: &[Ident],\n                                    span: Span,\n+                                   ident_span: Span,\n                                    source: PathSource)\n                                    -> PathResolution {\n         let ns = source.namespace();\n@@ -2219,9 +2221,9 @@ impl<'a> Resolver<'a> {\n             let expected = source.descr_expected();\n             let path_str = names_to_string(path);\n             let code = source.error_code(def.is_some());\n-            let (base_msg, fallback_label) = if let Some(def) = def {\n+            let (base_msg, fallback_label, base_span) = if let Some(def) = def {\n                 (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n-                 format!(\"not a {}\", expected))\n+                 format!(\"not a {}\", expected), span)\n             } else {\n                 let item_str = path[path.len() - 1];\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n@@ -2237,9 +2239,9 @@ impl<'a> Resolver<'a> {\n                     (mod_prefix, format!(\"`{}`\", names_to_string(mod_path)))\n                 };\n                 (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n-                 format!(\"not found in {}\", mod_str))\n+                 format!(\"not found in {}\", mod_str), ident_span)\n             };\n-            let mut err = this.session.struct_span_err_with_code(span, &base_msg, code);\n+            let mut err = this.session.struct_span_err_with_code(base_span, &base_msg, code);\n \n             // Emit special messages for unresolved `Self` and `self`.\n             if is_self_type(path, ns) {\n@@ -2297,15 +2299,15 @@ impl<'a> Resolver<'a> {\n                         err.span_label(span, &format!(\"type aliases cannot be used for traits\"));\n                         return err;\n                     }\n-                    (Def::Mod(..), PathSource::Expr(Some(parent))) => match *parent {\n+                    (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n                         ExprKind::Field(_, ident) => {\n-                            err.span_label(span, &format!(\"did you mean `{}::{}`?\",\n-                                                           path_str, ident.node));\n+                            err.span_label(parent.span, &format!(\"did you mean `{}::{}`?\",\n+                                                                 path_str, ident.node));\n                             return err;\n                         }\n                         ExprKind::MethodCall(ident, ..) => {\n-                            err.span_label(span, &format!(\"did you mean `{}::{}(...)`?\",\n-                                                           path_str, ident.node));\n+                            err.span_label(parent.span, &format!(\"did you mean `{}::{}(...)`?\",\n+                                                                 path_str, ident.node));\n                             return err;\n                         }\n                         _ => {}\n@@ -2330,12 +2332,12 @@ impl<'a> Resolver<'a> {\n \n             // Try Levenshtein if nothing else worked.\n             if let Some(candidate) = this.lookup_typo_candidate(path, ns, is_expected) {\n-                err.span_label(span, &format!(\"did you mean `{}`?\", candidate));\n+                err.span_label(ident_span, &format!(\"did you mean `{}`?\", candidate));\n                 return err;\n             }\n \n             // Fallback label.\n-            err.span_label(span, &fallback_label);\n+            err.span_label(base_span, &fallback_label);\n             err\n         };\n         let report_errors = |this: &mut Self, def: Option<Def>| {\n@@ -2455,7 +2457,7 @@ impl<'a> Resolver<'a> {\n             // Make sure `A::B` in `<T as A>::B::C` is a trait item.\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n             let res = self.smart_resolve_path_fragment(id, None, &path[..qself.position + 1],\n-                                                       span, PathSource::TraitItem(ns));\n+                                                       span, span, PathSource::TraitItem(ns));\n             return Some(PathResolution::with_unresolved_segments(\n                 res.base_def(), res.unresolved_segments() + path.len() - qself.position - 1\n             ));\n@@ -2813,7 +2815,7 @@ impl<'a> Resolver<'a> {\n                                        path: &[Ident],\n                                        ns: Namespace,\n                                        filter_fn: FilterFn)\n-                                       -> Option<String>\n+                                       -> Option<Symbol>\n         where FilterFn: Fn(Def) -> bool\n     {\n         let add_module_candidates = |module: Module, names: &mut Vec<Name>| {\n@@ -2827,7 +2829,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         let mut names = Vec::new();\n-        let prefix_str = if path.len() == 1 {\n+        if path.len() == 1 {\n             // Search in lexical scope.\n             // Walk backwards up the ribs in scope and collect candidates.\n             for rib in self.ribs[ns].iter().rev() {\n@@ -2861,21 +2863,19 @@ impl<'a> Resolver<'a> {\n                     names.push(*name);\n                 }\n             }\n-            String::new()\n         } else {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS), None) {\n                 add_module_candidates(module, &mut names);\n             }\n-            names_to_string(mod_path) + \"::\"\n-        };\n+        }\n \n         let name = path[path.len() - 1].name;\n         // Make sure error reporting is deterministic.\n         names.sort_by_key(|name| name.as_str());\n         match find_best_match_for_name(names.iter(), &name.as_str(), None) {\n-            Some(found) if found != name => Some(format!(\"{}{}\", prefix_str, found)),\n+            Some(found) if found != name => Some(found),\n             _ => None,\n         }\n     }\n@@ -2898,7 +2898,7 @@ impl<'a> Resolver<'a> {\n         self.with_resolved_label(label, id, |this| this.visit_block(block));\n     }\n \n-    fn resolve_expr(&mut self, expr: &Expr, parent: Option<&ExprKind>) {\n+    fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n \n@@ -2979,11 +2979,11 @@ impl<'a> Resolver<'a> {\n \n             // Equivalent to `visit::walk_expr` + passing some context to children.\n             ExprKind::Field(ref subexpression, _) => {\n-                self.resolve_expr(subexpression, Some(&expr.node));\n+                self.resolve_expr(subexpression, Some(expr));\n             }\n             ExprKind::MethodCall(_, ref types, ref arguments) => {\n                 let mut arguments = arguments.iter();\n-                self.resolve_expr(arguments.next().unwrap(), Some(&expr.node));\n+                self.resolve_expr(arguments.next().unwrap(), Some(expr));\n                 for argument in arguments {\n                     self.resolve_expr(argument, None);\n                 }\n@@ -2999,7 +2999,7 @@ impl<'a> Resolver<'a> {\n                 });\n             }\n             ExprKind::Call(ref callee, ref arguments) => {\n-                self.resolve_expr(callee, Some(&expr.node));\n+                self.resolve_expr(callee, Some(expr));\n                 for argument in arguments {\n                     self.resolve_expr(argument, None);\n                 }\n@@ -3130,11 +3130,10 @@ impl<'a> Resolver<'a> {\n                 if ident.name == lookup_name && ns == namespace {\n                     if filter_fn(name_binding.def()) {\n                         // create the path\n-                        let span = name_binding.span;\n                         let mut segms = path_segments.clone();\n-                        segms.push(ident.into());\n+                        segms.push(ast::PathSegment::from_ident(ident, name_binding.span));\n                         let path = Path {\n-                            span: span,\n+                            span: name_binding.span,\n                             segments: segms,\n                         };\n                         // the entity is accessible in the following cases:\n@@ -3154,7 +3153,7 @@ impl<'a> Resolver<'a> {\n                 if let Some(module) = name_binding.module() {\n                     // form the path\n                     let mut path_segments = path_segments.clone();\n-                    path_segments.push(ident.into());\n+                    path_segments.push(ast::PathSegment::from_ident(ident, name_binding.span));\n \n                     if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup"}, {"sha": "dbdf3a0b21e691119a593de08a0e566ba1c0cd55", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -111,8 +111,11 @@ impl<'a> base::Resolver for Resolver<'a> {\n                     path.segments[0].identifier.name = keywords::CrateRoot.name();\n                     let module = self.0.resolve_crate_var(ident.ctxt);\n                     if !module.is_local() {\n+                        let span = path.segments[0].span;\n                         path.segments.insert(1, match module.kind {\n-                            ModuleKind::Def(_, name) => ast::Ident::with_empty_ctxt(name).into(),\n+                            ModuleKind::Def(_, name) => ast::PathSegment::from_ident(\n+                                ast::Ident::with_empty_ctxt(name), span\n+                            ),\n                             _ => unreachable!(),\n                         })\n                     }\n@@ -569,7 +572,6 @@ impl<'a> Resolver<'a> {\n             };\n             let ident = Ident::from_str(name);\n             self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro)\n-                .as_ref().map(|s| Symbol::intern(s))\n         });\n \n         if let Some(suggestion) = suggestion {"}, {"sha": "3ca8b41347a268c3ac3f65529ee09bf00506dd6c", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 155, "deletions": 5, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -19,8 +19,9 @@ use fmt::{self, Debug};\n use hash::{Hash, Hasher, BuildHasher, SipHasher13};\n use iter::{FromIterator, FusedIterator};\n use mem::{self, replace};\n-use ops::{Deref, Index};\n+use ops::{Deref, Index, InPlace, Place, Placer};\n use rand::{self, Rng};\n+use ptr;\n \n use super::table::{self, Bucket, EmptyBucket, FullBucket, FullBucketMut, RawTable, SafeHash};\n use super::table::BucketState::{Empty, Full};\n@@ -483,7 +484,7 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                                 mut hash: SafeHash,\n                                 mut key: K,\n                                 mut val: V)\n-                                -> &'a mut V {\n+                                -> FullBucketMut<'a, K, V> {\n     let start_index = bucket.index();\n     let size = bucket.table().size();\n     // Save the *starting point*.\n@@ -515,7 +516,7 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                     // bucket, which is a FullBucket on top of a\n                     // FullBucketMut, into just one FullBucketMut. The \"table\"\n                     // refers to the inner FullBucketMut in this context.\n-                    return bucket.into_table().into_mut_refs().1;\n+                    return bucket.into_table();\n                 }\n                 Full(bucket) => bucket,\n             };\n@@ -1818,6 +1819,80 @@ impl<'a, K, V> fmt::Debug for Drain<'a, K, V>\n     }\n }\n \n+/// A place for insertion to a `Entry`.\n+///\n+/// See [`HashMap::entry`](struct.HashMap.html#method.entry) for details.\n+#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"struct name and placement protocol is subject to change\",\n+           issue = \"30172\")]\n+pub struct EntryPlace<'a, K: 'a, V: 'a> {\n+    bucket: FullBucketMut<'a, K, V>,\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"struct name and placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for EntryPlace<'a, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"EntryPlace\")\n+            .field(\"key\", self.bucket.read().0)\n+            .field(\"value\", self.bucket.read().1)\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"struct name and placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, K, V> Drop for EntryPlace<'a, K, V> {\n+    fn drop(&mut self) {\n+        // Inplacement insertion failed. Only key need to drop.\n+        // The value is failed to insert into map.\n+        unsafe { self.bucket.remove_key() };\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, K, V> Placer<V> for Entry<'a, K, V> {\n+    type Place = EntryPlace<'a, K, V>;\n+\n+    fn make_place(self) -> EntryPlace<'a, K, V> {\n+        let b = match self {\n+            Occupied(mut o) => {\n+                unsafe { ptr::drop_in_place(o.elem.read_mut().1); }\n+                o.elem\n+            }\n+            Vacant(v) => {\n+                unsafe { v.insert_key() }\n+            }\n+        };\n+        EntryPlace { bucket: b }\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, K, V> Place<V> for EntryPlace<'a, K, V> {\n+    fn pointer(&mut self) -> *mut V {\n+        self.bucket.read_mut().1\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, K, V> InPlace<V> for EntryPlace<'a, K, V> {\n+    type Owner = ();\n+\n+    unsafe fn finalize(self) {\n+        mem::forget(self);\n+    }\n+}\n+\n impl<'a, K, V> Entry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n@@ -2108,7 +2183,7 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n-        match self.elem {\n+        let b = match self.elem {\n             NeqElem(mut bucket, disp) => {\n                 if disp >= DISPLACEMENT_THRESHOLD {\n                     bucket.table_mut().set_tag(true);\n@@ -2119,7 +2194,28 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n                 if disp >= DISPLACEMENT_THRESHOLD {\n                     bucket.table_mut().set_tag(true);\n                 }\n-                bucket.put(self.hash, self.key, value).into_mut_refs().1\n+                bucket.put(self.hash, self.key, value)\n+            },\n+        };\n+        b.into_mut_refs().1\n+    }\n+\n+    // Only used for InPlacement insert. Avoid unnecessary value copy.\n+    // The value remains uninitialized.\n+    unsafe fn insert_key(self) -> FullBucketMut<'a, K, V> {\n+        match self.elem {\n+            NeqElem(mut bucket, disp) => {\n+                if disp >= DISPLACEMENT_THRESHOLD {\n+                    bucket.table_mut().set_tag(true);\n+                }\n+                let uninit = mem::uninitialized();\n+                robin_hood(bucket, disp, self.hash, self.key, uninit)\n+            },\n+            NoElem(mut bucket, disp) => {\n+                if disp >= DISPLACEMENT_THRESHOLD {\n+                    bucket.table_mut().set_tag(true);\n+                }\n+                bucket.put_key(self.hash, self.key)\n             },\n         }\n     }\n@@ -2392,6 +2488,7 @@ mod test_map {\n     use super::RandomState;\n     use cell::RefCell;\n     use rand::{thread_rng, Rng};\n+    use panic;\n \n     #[test]\n     fn test_zero_capacities() {\n@@ -3265,4 +3362,57 @@ mod test_map {\n         }\n         panic!(\"Adaptive early resize failed\");\n     }\n+\n+    #[test]\n+    fn test_placement_in() {\n+        let mut map = HashMap::new();\n+        map.extend((0..10).map(|i| (i, i)));\n+\n+        map.entry(100) <- 100;\n+        assert_eq!(map[&100], 100);\n+\n+        map.entry(0) <- 10;\n+        assert_eq!(map[&0], 10);\n+\n+        assert_eq!(map.len(), 11);\n+    }\n+\n+    #[test]\n+    fn test_placement_panic() {\n+        let mut map = HashMap::new();\n+        map.extend((0..10).map(|i| (i, i)));\n+\n+        fn mkpanic() -> usize { panic!() }\n+\n+        // modify existing key\n+        // when panic happens, previous key is removed.\n+        let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { map.entry(0) <- mkpanic(); }));\n+        assert_eq!(map.len(), 9);\n+        assert!(!map.contains_key(&0));\n+\n+        // add new key\n+        let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { map.entry(100) <- mkpanic(); }));\n+        assert_eq!(map.len(), 9);\n+        assert!(!map.contains_key(&100));\n+    }\n+\n+    #[test]\n+    fn test_placement_drop() {\n+        // correctly drop\n+        struct TestV<'a>(&'a mut bool);\n+        impl<'a> Drop for TestV<'a> {\n+            fn drop(&mut self) {\n+                if !*self.0 { panic!(\"value double drop!\"); } // no double drop\n+                *self.0 = false;\n+            }\n+        }\n+\n+        fn makepanic<'a>() -> TestV<'a> { panic!() }\n+\n+        let mut can_drop = true;\n+        let mut hm = HashMap::new();\n+        hm.insert(0, TestV(&mut can_drop));\n+        let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { hm.entry(0) <- makepanic(); }));\n+        assert_eq!(hm.len(), 0);\n+    }\n }"}, {"sha": "2c8bb433e8aef1ba1fd65a5d3948802be26293e8", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -506,6 +506,22 @@ impl<K, V, M> EmptyBucket<K, V, M>\n             table: self.table,\n         }\n     }\n+\n+    /// Puts given key, remain value uninitialized.\n+    /// It is only used for inplacement insertion.\n+    pub unsafe fn put_key(mut self, hash: SafeHash, key: K) -> FullBucket<K, V, M> {\n+        *self.raw.hash = hash.inspect();\n+        let pair_mut = self.raw.pair as *mut (K, V);\n+        ptr::write(&mut (*pair_mut).0, key);\n+\n+        self.table.borrow_table_mut().size += 1;\n+\n+        FullBucket {\n+            raw: self.raw,\n+            idx: self.idx,\n+            table: self.table,\n+        }\n+    }\n }\n \n impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n@@ -581,6 +597,17 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n             v)\n         }\n     }\n+\n+    /// Remove this bucket's `key` from the hashtable.\n+    /// Only used for inplacement insertion.\n+    /// NOTE: `Value` is uninitialized when this function is called, don't try to drop the `Value`.\n+    pub unsafe fn remove_key(&mut self) {\n+        self.table.size -= 1;\n+\n+        *self.raw.hash = EMPTY_BUCKET;\n+        let pair_mut = self.raw.pair as *mut (K, V);\n+        ptr::drop_in_place(&mut (*pair_mut).0); // only drop key\n+    }\n }\n \n // This use of `Put` is misleading and restrictive, but safe and sufficient for our use cases"}, {"sha": "7fa5ad255609cc236a48c8f5248aac4a49412388", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -281,6 +281,7 @@\n #![feature(panic_unwind)]\n #![feature(peek)]\n #![feature(placement_in_syntax)]\n+#![feature(placement_new_protocol)]\n #![feature(prelude_import)]\n #![feature(pub_restricted)]\n #![feature(rand)]"}, {"sha": "fa320d2ca8b6ce52c4dc553c75cfc1900510ae00", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -134,7 +134,7 @@ impl Path {\n     pub fn from_ident(s: Span, identifier: Ident) -> Path {\n         Path {\n             span: s,\n-            segments: vec![identifier.into()],\n+            segments: vec![PathSegment::from_ident(identifier, s)],\n         }\n     }\n \n@@ -159,6 +159,8 @@ impl Path {\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub identifier: Ident,\n+    /// Span of the segment identifier.\n+    pub span: Span,\n \n     /// Type/lifetime parameters attached to this path. They come in\n     /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n@@ -170,16 +172,14 @@ pub struct PathSegment {\n     pub parameters: Option<P<PathParameters>>,\n }\n \n-impl From<Ident> for PathSegment {\n-    fn from(id: Ident) -> Self {\n-        PathSegment { identifier: id, parameters: None }\n-    }\n-}\n-\n impl PathSegment {\n+    pub fn from_ident(ident: Ident, span: Span) -> Self {\n+        PathSegment { identifier: ident, span: span, parameters: None }\n+    }\n     pub fn crate_root() -> Self {\n         PathSegment {\n             identifier: keywords::CrateRoot.ident(),\n+            span: DUMMY_SP,\n             parameters: None,\n         }\n     }"}, {"sha": "e0fb46ff5eb095a01c659ab0a6e124c30f82c577", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -38,11 +38,11 @@ pub trait AstBuilder {\n \n     fn qpath(&self, self_type: P<ast::Ty>,\n              trait_path: ast::Path,\n-             ident: ast::Ident)\n+             ident: ast::SpannedIdent)\n              -> (ast::QSelf, ast::Path);\n     fn qpath_all(&self, self_type: P<ast::Ty>,\n                 trait_path: ast::Path,\n-                ident: ast::Ident,\n+                ident: ast::SpannedIdent,\n                 lifetimes: Vec<ast::Lifetime>,\n                 types: Vec<P<ast::Ty>>,\n                 bindings: Vec<ast::TypeBinding>)\n@@ -323,7 +323,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             segments.push(ast::PathSegment::crate_root());\n         }\n \n-        segments.extend(idents.into_iter().map(Into::into));\n+        segments.extend(idents.into_iter().map(|i| ast::PathSegment::from_ident(i, sp)));\n         let parameters = if lifetimes.is_empty() && types.is_empty() && bindings.is_empty() {\n             None\n         } else {\n@@ -333,7 +333,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 bindings: bindings,\n             })))\n         };\n-        segments.push(ast::PathSegment { identifier: last_identifier, parameters: parameters });\n+        segments.push(ast::PathSegment {\n+            identifier: last_identifier,\n+            span: sp,\n+            parameters: parameters\n+        });\n         ast::Path {\n             span: sp,\n             segments: segments,\n@@ -346,7 +350,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn qpath(&self,\n              self_type: P<ast::Ty>,\n              trait_path: ast::Path,\n-             ident: ast::Ident)\n+             ident: ast::SpannedIdent)\n              -> (ast::QSelf, ast::Path) {\n         self.qpath_all(self_type, trait_path, ident, vec![], vec![], vec![])\n     }\n@@ -357,7 +361,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn qpath_all(&self,\n                  self_type: P<ast::Ty>,\n                  trait_path: ast::Path,\n-                 ident: ast::Ident,\n+                 ident: ast::SpannedIdent,\n                  lifetimes: Vec<ast::Lifetime>,\n                  types: Vec<P<ast::Ty>>,\n                  bindings: Vec<ast::TypeBinding>)\n@@ -369,7 +373,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             bindings: bindings,\n         };\n         path.segments.push(ast::PathSegment {\n-            identifier: ident,\n+            identifier: ident.node,\n+            span: ident.span,\n             parameters: Some(P(ast::PathParameters::AngleBracketed(parameters))),\n         });\n "}, {"sha": "aa968f03d68874513c545eb5343608038a93b61c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -434,8 +434,9 @@ pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n \n pub fn noop_fold_path<T: Folder>(Path { segments, span }: Path, fld: &mut T) -> Path {\n     Path {\n-        segments: segments.move_map(|PathSegment {identifier, parameters}| PathSegment {\n+        segments: segments.move_map(|PathSegment {identifier, span, parameters}| PathSegment {\n             identifier: fld.fold_ident(identifier),\n+            span: fld.new_span(span),\n             parameters: parameters.map(|ps| ps.map(|ps| fld.fold_path_parameters(ps))),\n         }),\n         span: fld.new_span(span)"}, {"sha": "88535f91379f72330ed449f407519d05b9edeb8a", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -617,13 +617,17 @@ mod tests {\n         Span {lo: BytePos(a), hi: BytePos(b), expn_id: NO_EXPANSION}\n     }\n \n+    fn str2seg(s: &str, lo: u32, hi: u32) -> ast::PathSegment {\n+        ast::PathSegment::from_ident(Ident::from_str(s), sp(lo, hi))\n+    }\n+\n     #[test] fn path_exprs_1() {\n         assert!(string_to_expr(\"a\".to_string()) ==\n                    P(ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprKind::Path(None, ast::Path {\n                         span: sp(0, 1),\n-                        segments: vec![Ident::from_str(\"a\").into()],\n+                        segments: vec![str2seg(\"a\", 0, 1)],\n                     }),\n                     span: sp(0, 1),\n                     attrs: ThinVec::new(),\n@@ -637,8 +641,8 @@ mod tests {\n                     node: ast::ExprKind::Path(None, ast::Path {\n                         span: sp(0, 6),\n                         segments: vec![ast::PathSegment::crate_root(),\n-                                       Ident::from_str(\"a\").into(),\n-                                       Ident::from_str(\"b\").into()]\n+                                       str2seg(\"a\", 2, 3),\n+                                       str2seg(\"b\", 5, 6)]\n                     }),\n                     span: sp(0, 6),\n                     attrs: ThinVec::new(),\n@@ -744,7 +748,7 @@ mod tests {\n                         id: ast::DUMMY_NODE_ID,\n                         node:ast::ExprKind::Path(None, ast::Path{\n                             span: sp(7, 8),\n-                            segments: vec![Ident::from_str(\"d\").into()],\n+                            segments: vec![str2seg(\"d\", 7, 8)],\n                         }),\n                         span:sp(7,8),\n                         attrs: ThinVec::new(),\n@@ -761,7 +765,7 @@ mod tests {\n                            id: ast::DUMMY_NODE_ID,\n                            node: ast::ExprKind::Path(None, ast::Path {\n                                span:sp(0,1),\n-                               segments: vec![Ident::from_str(\"b\").into()],\n+                               segments: vec![str2seg(\"b\", 0, 1)],\n                             }),\n                            span: sp(0,1),\n                            attrs: ThinVec::new()})),\n@@ -802,7 +806,7 @@ mod tests {\n                                     ty: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                   node: ast::TyKind::Path(None, ast::Path{\n                                         span:sp(10,13),\n-                                        segments: vec![Ident::from_str(\"i32\").into()],\n+                                        segments: vec![str2seg(\"i32\", 10, 13)],\n                                         }),\n                                         span:sp(10,13)\n                                     }),\n@@ -844,7 +848,7 @@ mod tests {\n                                                 node: ast::ExprKind::Path(None,\n                                                       ast::Path{\n                                                         span:sp(17,18),\n-                                                        segments: vec![Ident::from_str(\"b\").into()],\n+                                                        segments: vec![str2seg(\"b\", 17, 18)],\n                                                       }),\n                                                 span: sp(17,18),\n                                                 attrs: ThinVec::new()})),"}, {"sha": "ff7918cc2783a55cd15ad64f0d60106045d1f9c4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -27,7 +27,7 @@ use ast::Local;\n use ast::MacStmtStyle;\n use ast::Mac_;\n use ast::{MutTy, Mutability};\n-use ast::{Pat, PatKind};\n+use ast::{Pat, PatKind, PathSegment};\n use ast::{PolyTraitRef, QSelf};\n use ast::{Stmt, StmtKind};\n use ast::{VariantData, StructField};\n@@ -1811,7 +1811,7 @@ impl<'a> Parser<'a> {\n         };\n \n         if is_global {\n-            segments.insert(0, ast::PathSegment::crate_root());\n+            segments.insert(0, PathSegment::crate_root());\n         }\n \n         // Assemble the span.\n@@ -1829,11 +1829,12 @@ impl<'a> Parser<'a> {\n     /// - `a::b<T,U>::c<V,W>`\n     /// - `a::b<T,U>::c(V) -> W`\n     /// - `a::b<T,U>::c(V)`\n-    pub fn parse_path_segments_without_colons(&mut self) -> PResult<'a, Vec<ast::PathSegment>> {\n+    pub fn parse_path_segments_without_colons(&mut self) -> PResult<'a, Vec<PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n             let identifier = self.parse_path_segment_ident()?;\n+            let ident_span = self.prev_span;\n \n             if self.check(&token::ModSep) && self.look_ahead(1, |t| *t == token::Lt) {\n                 self.bump();\n@@ -1881,7 +1882,11 @@ impl<'a> Parser<'a> {\n             };\n \n             // Assemble and push the result.\n-            segments.push(ast::PathSegment { identifier: identifier, parameters: parameters });\n+            segments.push(PathSegment {\n+                identifier: identifier,\n+                span: ident_span,\n+                parameters: parameters\n+            });\n \n             // Continue only if we see a `::`\n             if !self.eat(&token::ModSep) {\n@@ -1892,15 +1897,16 @@ impl<'a> Parser<'a> {\n \n     /// Examples:\n     /// - `a::b::<T,U>::c`\n-    pub fn parse_path_segments_with_colons(&mut self) -> PResult<'a, Vec<ast::PathSegment>> {\n+    pub fn parse_path_segments_with_colons(&mut self) -> PResult<'a, Vec<PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n             let identifier = self.parse_path_segment_ident()?;\n+            let ident_span = self.prev_span;\n \n             // If we do not see a `::`, stop.\n             if !self.eat(&token::ModSep) {\n-                segments.push(identifier.into());\n+                segments.push(PathSegment::from_ident(identifier, ident_span));\n                 return Ok(segments);\n             }\n \n@@ -1909,8 +1915,9 @@ impl<'a> Parser<'a> {\n                 // Consumed `a::b::<`, go look for types\n                 let (lifetimes, types, bindings) = self.parse_generic_args()?;\n                 self.expect_gt()?;\n-                segments.push(ast::PathSegment {\n+                segments.push(PathSegment {\n                     identifier: identifier,\n+                    span: ident_span,\n                     parameters: ast::AngleBracketedParameterData {\n                         lifetimes: lifetimes,\n                         types: types,\n@@ -1924,22 +1931,22 @@ impl<'a> Parser<'a> {\n                 }\n             } else {\n                 // Consumed `a::`, go look for `b`\n-                segments.push(identifier.into());\n+                segments.push(PathSegment::from_ident(identifier, ident_span));\n             }\n         }\n     }\n \n     /// Examples:\n     /// - `a::b::c`\n     pub fn parse_path_segments_without_types(&mut self)\n-                                             -> PResult<'a, Vec<ast::PathSegment>> {\n+                                             -> PResult<'a, Vec<PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n             let identifier = self.parse_path_segment_ident()?;\n \n             // Assemble and push the result.\n-            segments.push(identifier.into());\n+            segments.push(PathSegment::from_ident(identifier, self.prev_span));\n \n             // If we do not see a `::` or see `::{`/`::*`, stop.\n             if !self.check(&token::ModSep) || self.is_import_coupler() {\n@@ -5950,7 +5957,7 @@ impl<'a> Parser<'a> {\n             // `{foo, bar}`, `::{foo, bar}`, `*`, or `::*`.\n             self.eat(&token::ModSep);\n             let prefix = ast::Path {\n-                segments: vec![ast::PathSegment::crate_root()],\n+                segments: vec![PathSegment::crate_root()],\n                 span: mk_sp(lo, self.span.hi),\n             };\n             let view_path_kind = if self.eat(&token::BinOp(token::Star)) {"}, {"sha": "2192d203cdc23cce08e67e73d352d4e35640d5b4", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -82,7 +82,7 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         vis: ast::Visibility::Inherited,\n         node: ast::ItemKind::Use(P(codemap::dummy_spanned(ast::ViewPathGlob(ast::Path {\n             segments: [\"{{root}}\", name, \"prelude\", \"v1\"].into_iter().map(|name| {\n-                ast::Ident::from_str(name).into()\n+                ast::PathSegment::from_ident(ast::Ident::from_str(name), DUMMY_SP)\n             }).collect(),\n             span: span,\n         })))),"}, {"sha": "e052d2cda3a42469b000be576f82b416a08bb20c", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -580,7 +580,7 @@ fn nospan<T>(t: T) -> codemap::Spanned<T> {\n fn path_node(ids: Vec<Ident>) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n-        segments: ids.into_iter().map(Into::into).collect(),\n+        segments: ids.into_iter().map(|id| ast::PathSegment::from_ident(id, DUMMY_SP)).collect(),\n     }\n }\n "}, {"sha": "dc4b8eb24cd0a570ce18531a84024bd2e90ebff9", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -61,7 +61,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n         fn path(&self) -> ast::Path {\n             ast::Path {\n                 span: self.span,\n-                segments: vec![self.ident.into()],\n+                segments: vec![ast::PathSegment::from_ident(self.ident, self.span)],\n             }\n         }\n     }"}, {"sha": "dd04c5ce356c626224f5eda92cbc93e69edc4d5c", "filename": "src/test/ui/resolve/enums-are-namespaced-xc.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -1,26 +1,26 @@\n error[E0425]: cannot find value `A` in module `namespaced_enums`\n-  --> $DIR/enums-are-namespaced-xc.rs:15:13\n+  --> $DIR/enums-are-namespaced-xc.rs:15:31\n    |\n 15 |     let _ = namespaced_enums::A;\n-   |             ^^^^^^^^^^^^^^^^^^^ not found in `namespaced_enums`\n+   |                               ^ not found in `namespaced_enums`\n    |\n    = help: possible candidate is found in another module, you can import it into scope:\n              `use namespaced_enums::Foo::A;`\n \n error[E0425]: cannot find function `B` in module `namespaced_enums`\n-  --> $DIR/enums-are-namespaced-xc.rs:18:13\n+  --> $DIR/enums-are-namespaced-xc.rs:18:31\n    |\n 18 |     let _ = namespaced_enums::B(10);\n-   |             ^^^^^^^^^^^^^^^^^^^ not found in `namespaced_enums`\n+   |                               ^ not found in `namespaced_enums`\n    |\n    = help: possible candidate is found in another module, you can import it into scope:\n              `use namespaced_enums::Foo::B;`\n \n error[E0422]: cannot find struct, variant or union type `C` in module `namespaced_enums`\n-  --> $DIR/enums-are-namespaced-xc.rs:21:13\n+  --> $DIR/enums-are-namespaced-xc.rs:21:31\n    |\n 21 |     let _ = namespaced_enums::C { a: 10 };\n-   |             ^^^^^^^^^^^^^^^^^^^ not found in `namespaced_enums`\n+   |                               ^ not found in `namespaced_enums`\n    |\n    = help: possible candidate is found in another module, you can import it into scope:\n              `use namespaced_enums::Foo::C;`"}, {"sha": "4dff2620319e4607dcee7cf5fe92c79bd922a8ab", "filename": "src/test/ui/resolve/levenshtein.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -14,7 +14,7 @@ error[E0412]: cannot find type `Opiton` in this scope\n   --> $DIR/levenshtein.rs:20:10\n    |\n 20 | type B = Opiton<u8>; // Misspelled type name from the prelude.\n-   |          ^^^^^^^^^^ did you mean `Option`?\n+   |          ^^^^^^ did you mean `Option`?\n \n error[E0412]: cannot find type `Baz` in this scope\n   --> $DIR/levenshtein.rs:23:14\n@@ -35,16 +35,16 @@ error[E0425]: cannot find function `foobar` in this scope\n    |     ^^^^^^ did you mean `foo_bar`?\n \n error[E0412]: cannot find type `first` in module `m`\n-  --> $DIR/levenshtein.rs:32:12\n+  --> $DIR/levenshtein.rs:32:15\n    |\n 32 |     let b: m::first = m::second; // Misspelled item in module.\n-   |            ^^^^^^^^ did you mean `m::First`?\n+   |               ^^^^^ did you mean `First`?\n \n error[E0425]: cannot find value `second` in module `m`\n-  --> $DIR/levenshtein.rs:32:23\n+  --> $DIR/levenshtein.rs:32:26\n    |\n 32 |     let b: m::first = m::second; // Misspelled item in module.\n-   |                       ^^^^^^^^^ did you mean `m::Second`?\n+   |                          ^^^^^^ did you mean `Second`?\n \n error: aborting due to 8 previous errors\n "}, {"sha": "85fb1777dea233abf7e71dd53e577a29a7ba84b5", "filename": "src/test/ui/resolve/suggest-path-instead-of-mod-dot-item.stderr", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -2,55 +2,73 @@ error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:27:5\n    |\n 27 |     a.I\n-   |     ^ did you mean `a::I`?\n+   |     ^--\n+   |     |\n+   |     did you mean `a::I`?\n \n error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:33:5\n    |\n 33 |     a.g()\n-   |     ^ did you mean `a::g(...)`?\n+   |     ^----\n+   |     |\n+   |     did you mean `a::g(...)`?\n \n error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:39:5\n    |\n 39 |     a.b.J\n-   |     ^ did you mean `a::b`?\n+   |     ^--\n+   |     |\n+   |     did you mean `a::b`?\n \n error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:45:5\n    |\n 45 |     a::b.J\n-   |     ^^^^ did you mean `a::b::J`?\n+   |     ^^^^--\n+   |     |\n+   |     did you mean `a::b::J`?\n \n error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:51:5\n    |\n 51 |     a.b.f();\n-   |     ^ did you mean `a::b`?\n+   |     ^--\n+   |     |\n+   |     did you mean `a::b`?\n \n error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:55:12\n    |\n 55 |     v.push(a::b);\n-   |            ^^^^ did you mean `a::I`?\n+   |            ^^^-\n+   |               |\n+   |               did you mean `I`?\n \n error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:61:5\n    |\n 61 |     a::b.f()\n-   |     ^^^^ did you mean `a::b::f(...)`?\n+   |     ^^^^----\n+   |     |\n+   |     did you mean `a::b::f(...)`?\n \n error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:67:5\n    |\n 67 |     a::b\n-   |     ^^^^ did you mean `a::I`?\n+   |     ^^^-\n+   |        |\n+   |        did you mean `I`?\n \n error[E0423]: expected function, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:73:5\n    |\n 73 |     a::b()\n-   |     ^^^^ did you mean `a::I`?\n+   |     ^^^-\n+   |        |\n+   |        did you mean `I`?\n \n error: main function not found\n "}, {"sha": "015dbfc3dc775fe509d4ac8e7bef1b8748332212", "filename": "src/test/ui/resolve/unboxed-closure-sugar-nonexistent-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -2,7 +2,7 @@ error[E0405]: cannot find trait `Nonexist` in this scope\n   --> $DIR/unboxed-closure-sugar-nonexistent-trait.rs:11:8\n    |\n 11 | fn f<F:Nonexist(isize) -> isize>(x: F) {}\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+   |        ^^^^^^^^ not found in this scope\n \n error[E0404]: expected trait, found type alias `Typedef`\n   --> $DIR/unboxed-closure-sugar-nonexistent-trait.rs:17:8"}, {"sha": "d5b95c08306b27afc372d866f5bda97b814e7368", "filename": "src/tools/rustbook/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Ftools%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0066869dc09d9c63c5d90bb55884f0150f84c3af/src%2Ftools%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2FCargo.toml?ref=0066869dc09d9c63c5d90bb55884f0150f84c3af", "patch": "@@ -8,5 +8,5 @@ license = \"MIT/Apache-2.0\"\n clap = \"2.19.3\"\n \n [dependencies.mdbook]\n-version = \"0.0.17\"\n+version = \"0.0.18\"\n default-features = false"}]}