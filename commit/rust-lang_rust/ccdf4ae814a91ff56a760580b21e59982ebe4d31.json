{"sha": "ccdf4ae814a91ff56a760580b21e59982ebe4d31", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjZGY0YWU4MTRhOTFmZjU2YTc2MDU4MGIyMWU1OTk4MmViZTRkMzE=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-07-17T21:32:59Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-07-22T18:58:51Z"}, "message": "part 2", "tree": {"sha": "86950f1ab550da20ff251937136a28b69ff09317", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86950f1ab550da20ff251937136a28b69ff09317"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccdf4ae814a91ff56a760580b21e59982ebe4d31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccdf4ae814a91ff56a760580b21e59982ebe4d31", "html_url": "https://github.com/rust-lang/rust/commit/ccdf4ae814a91ff56a760580b21e59982ebe4d31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccdf4ae814a91ff56a760580b21e59982ebe4d31/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39849d5128609040087e9942978af3405e17f958", "url": "https://api.github.com/repos/rust-lang/rust/commits/39849d5128609040087e9942978af3405e17f958", "html_url": "https://github.com/rust-lang/rust/commit/39849d5128609040087e9942978af3405e17f958"}], "stats": {"total": 105, "additions": 46, "deletions": 59}, "files": [{"sha": "d884e6e29fd58487be6794dde0df0295682335f9", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 41, "deletions": 58, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/ccdf4ae814a91ff56a760580b21e59982ebe4d31/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccdf4ae814a91ff56a760580b21e59982ebe4d31/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=ccdf4ae814a91ff56a760580b21e59982ebe4d31", "patch": "@@ -91,18 +91,13 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         let ty = self.cx.tcx.type_of(def_id);\n         let mut traits = FxHashMap();\n         if let ty::TyAdt(_adt, _) = ty.sty {\n-            use std::rc::Rc;\n-\n-            let name = Rc::new(name.clone());\n             let param_env = self.cx.tcx.param_env(def_id);\n             for &trait_def_id in self.cx.tcx.all_traits(LOCAL_CRATE).iter() {\n-                let name = name.clone();\n                 self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n-                    let name = name.clone();\n                     self.cx.tcx.infer_ctxt().enter(|infcx| {\n                         let trait_ref = infcx.tcx.impl_trait_ref(impl_def_id).unwrap();\n                         let substs = infcx.fresh_substs_for_item(DUMMY_SP, def_id);\n-                        let ty = ty.subst(infcx.tcx, substs);\n+                        let ty2 = ty.subst(infcx.tcx, substs);\n                         let param_env = param_env.subst(infcx.tcx, substs);\n \n                         let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n@@ -111,7 +106,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                         // Require the type the impl is implemented on to match\n                         // our type, and ignore the impl if there was a mismatch.\n                         let cause = traits::ObligationCause::dummy();\n-                        let eq_result = infcx.at(&cause, param_env).eq(trait_ref.self_ty(), ty);\n+                        let eq_result = infcx.at(&cause, param_env).eq(trait_ref.self_ty(), ty2);\n                         if let Ok(InferOk { value: (), obligations }) = eq_result {\n                             // FIXME(eddyb) ignoring `obligations` might cause false positives.\n                             drop(obligations);\n@@ -137,57 +132,40 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                                         traits.insert(trait_name, i);\n                                     }*/\n \n-                                    let path = get_path_for_type(infcx.tcx, def_id, def_ctor);\n-                                    let mut segments = path.clone().segments.into_vec();\n-                                    let last = segments.pop().unwrap();\n-\n-                                    use std::ops::Deref;\n-                                    let t_name: Option<String> = name.deref().clone();\n-                                    let real_name = t_name.map(|name| Ident::from_str(&name)).unwrap_or(last.ident);\n-\n-                                    segments.push(hir::PathSegment::new(\n-                                        real_name,\n-                                        self.generics_to_path_params(generics.clone()),\n-                                        false,\n-                                    ));\n-                                    let new_path = hir::Path {\n-                                        span: path.span,\n-                                        def: path.def,\n-                                        segments: HirVec::from_vec(segments),\n-                                    };\n-                                    let ty = hir::Ty {\n-                                        id: ast::DUMMY_NODE_ID,\n-                                        node: hir::Ty_::TyPath(hir::QPath::Resolved(None, P(new_path))),\n-                                        span: DUMMY_SP,\n-                                        hir_id: hir::DUMMY_HIR_ID,\n-                                    };\n-                                    traits.insert(trait_def_id, Item {\n-                                        source: Span::empty(),\n-                                        name: None,\n-                                        attrs: Default::default(),\n-                                        visibility: None,\n-                                        def_id: self.next_def_id(def_id.krate),\n-                                        stability: None,\n-                                        deprecation: None,\n-                                        inner: ImplItem(Impl {\n-                                            unsafety: hir::Unsafety::Normal,\n-                                            generics: Generics {\n-                                                params: generics.params.clean(self.cx),\n-                                                where_predicates: Vec::new(),\n-                                            },\n-                                            provided_trait_methods: FxHashSet(),\n-                                            trait_: Some(hir::TraitRef {\n-                                                path,\n-                                                ref_id: ast::DUMMY_NODE_ID,\n-                                            }.clean(self.cx)),\n-\n-                                            //Some(trait_ref.clean(self.cx)),\n-                                            for_: ty.clean(self.cx),\n-                                            items: Vec::new(),\n-                                            polarity: None,\n-                                            synthetic: true,\n-                                        })\n+                                    let mut impls = Vec::new();\n+                                    ::clean::inline::build_impl(&self.cx, impl_def_id, &mut impls);\n+                                    /*if ::std::env::var(\"LOL\").is_ok() {\n+                                        println!(\"=> {} ::> {}\",\n+                                                 infcx.tcx.item_name(trait_def_id).to_string(),\n+                                                 impls.len());\n+                                        println!(\"{:?}\", impls);\n+                                    }*/\n+                                    for impl_ in &mut impls {\n+                                        if let ImplItem(ref mut i) = impl_.inner {\n+                                            i.synthetic = true;\n+                                            i.for_ = ty.clean(&self.cx);\n+                                        }\n+                                    }\n+                                    traits.insert(trait_def_id, impls);\n+\n+                                    /*use ::clean::{self, inline::*};\n+\n+                                    let mut ret = Vec::with_capacity(2);\n+                                    record_extern_fqn(self.cx, trait_def_id, clean::TypeKind::Trait);\n+                                    ret.extend(build_impls(self.cx, trait_def_id, false));\n+                                    let inner = clean::TraitItem(build_external_trait(self.cx, trait_def_id));\n+                                    let cx = self.cx;\n+                                    ret.push(clean::Item {\n+                                        source: infcx.tcx.def_span(trait_def_id).clean(cx),\n+                                        name: Some(infcx.tcx.item_name(trait_def_id).to_string()),\n+                                        attrs: load_attrs(cx, trait_def_id),\n+                                        inner,\n+                                        visibility: Some(clean::Public),\n+                                        stability: cx.tcx.lookup_stability(trait_def_id).clean(cx),\n+                                        deprecation: cx.tcx.lookup_deprecation(trait_def_id).clean(cx),\n+                                        def_id: trait_def_id,\n                                     });\n+                                    traits.insert(trait_def_id, ret);*/\n                                 }\n                                 //println!(\"=> {}\", infcx.tcx.item_name(trait_def_id).to_string());\n                             }\n@@ -236,13 +214,18 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                 def_ctor,\n                 tcx.require_lang_item(lang_items::SyncTraitLangItem),\n             ).into_iter())\n-            .chain(traits.into_iter().map(|(_, v)| v))\n+            .chain(traits.into_iter().flat_map(|(_, v)| v.into_iter()))\n             .collect();\n \n         debug!(\n             \"get_auto_traits: type {:?} auto_traits {:?}\",\n             def_id, auto_traits\n         );\n+        if ::std::env::var(\"LOL\").is_ok() {\n+            for x in &auto_traits {\n+                println!(\"\\n=> {:?}\", x);\n+            }\n+        }\n         auto_traits\n     }\n "}, {"sha": "45cffe00cf8e4b112c52ffacdd9deed36c25d8ff", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ccdf4ae814a91ff56a760580b21e59982ebe4d31/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccdf4ae814a91ff56a760580b21e59982ebe4d31/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ccdf4ae814a91ff56a760580b21e59982ebe4d31", "patch": "@@ -2082,7 +2082,6 @@ where F: Fn(&mut fmt::Formatter) -> fmt::Result {\n impl<'a> fmt::Display for Item<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         debug_assert!(!self.item.is_stripped());\n-        println!(\"=> {:?}\", self.item.name);\n         // Write the breadcrumb trail header for the top\n         write!(fmt, \"<h1 class='fqn'><span class='in-band'>\")?;\n         match self.item.inner {\n@@ -3586,6 +3585,11 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         None => return Ok(()),\n     };\n     let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| {\n+        if ::std::env::var(\"LOL\").is_ok() {\n+            if let Some(ref t) = i.inner_impl().trait_ {\n+                println!(\"==> {:?}\", t);\n+            }\n+        }\n         i.inner_impl().trait_.is_none()\n     });\n     if !non_trait.is_empty() {"}]}