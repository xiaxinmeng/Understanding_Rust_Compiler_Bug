{"sha": "6ec4584d8482f51249d78efc340aaead76251859", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlYzQ1ODRkODQ4MmY1MTI0OWQ3OGVmYzM0MGFhZWFkNzYyNTE4NTk=", "commit": {"author": {"name": "Julien Cretin", "email": "cretin@google.com", "date": "2019-05-30T10:53:27Z"}, "committer": {"name": "Julien Cretin", "email": "cretin@google.com", "date": "2019-07-19T17:59:12Z"}, "message": "Implement checks for meta-variables in macros", "tree": {"sha": "b63ec802bf27614c8a93c7ac92eb694859ffaad0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b63ec802bf27614c8a93c7ac92eb694859ffaad0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ec4584d8482f51249d78efc340aaead76251859", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ec4584d8482f51249d78efc340aaead76251859", "html_url": "https://github.com/rust-lang/rust/commit/6ec4584d8482f51249d78efc340aaead76251859", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ec4584d8482f51249d78efc340aaead76251859/comments", "author": {"login": "ia0", "id": 969295, "node_id": "MDQ6VXNlcjk2OTI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/969295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ia0", "html_url": "https://github.com/ia0", "followers_url": "https://api.github.com/users/ia0/followers", "following_url": "https://api.github.com/users/ia0/following{/other_user}", "gists_url": "https://api.github.com/users/ia0/gists{/gist_id}", "starred_url": "https://api.github.com/users/ia0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ia0/subscriptions", "organizations_url": "https://api.github.com/users/ia0/orgs", "repos_url": "https://api.github.com/users/ia0/repos", "events_url": "https://api.github.com/users/ia0/events{/privacy}", "received_events_url": "https://api.github.com/users/ia0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ia0", "id": 969295, "node_id": "MDQ6VXNlcjk2OTI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/969295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ia0", "html_url": "https://github.com/ia0", "followers_url": "https://api.github.com/users/ia0/followers", "following_url": "https://api.github.com/users/ia0/following{/other_user}", "gists_url": "https://api.github.com/users/ia0/gists{/gist_id}", "starred_url": "https://api.github.com/users/ia0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ia0/subscriptions", "organizations_url": "https://api.github.com/users/ia0/orgs", "repos_url": "https://api.github.com/users/ia0/repos", "events_url": "https://api.github.com/users/ia0/events{/privacy}", "received_events_url": "https://api.github.com/users/ia0/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82abc0db816e7441a0d89a3eaa51f439a03f4506", "url": "https://api.github.com/repos/rust-lang/rust/commits/82abc0db816e7441a0d89a3eaa51f439a03f4506", "html_url": "https://github.com/rust-lang/rust/commit/82abc0db816e7441a0d89a3eaa51f439a03f4506"}], "stats": {"total": 960, "additions": 913, "deletions": 47}, "files": [{"sha": "6d9a6bb77dd5516405b0d7449a7682872e3688af", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -362,6 +362,12 @@ pub mod parser {\n         Warn,\n         \"ill-formed attribute inputs that were previously accepted and used in practice\"\n     }\n+\n+    declare_lint! {\n+        pub META_VARIABLE_MISUSE,\n+        Allow,\n+        \"possible meta-variable misuse at macro definition\"\n+    }\n }\n \n declare_lint! {\n@@ -448,6 +454,7 @@ declare_lint_pass! {\n         MACRO_USE_EXTERN_CRATE,\n         MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n         parser::ILL_FORMED_ATTRIBUTE_INPUT,\n+        parser::META_VARIABLE_MISUSE,\n         DEPRECATED_IN_FUTURE,\n         AMBIGUOUS_ASSOCIATED_ITEMS,\n         NESTED_IMPL_TRAIT,"}, {"sha": "dddbc31ccd4ea7e05d256a92f7c033025943958f", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -27,7 +27,7 @@ use crate::hir::def_id::{CrateNum, LOCAL_CRATE};\n use crate::hir::intravisit;\n use crate::hir;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n-use crate::lint::builtin::parser::ILL_FORMED_ATTRIBUTE_INPUT;\n+use crate::lint::builtin::parser::{ILL_FORMED_ATTRIBUTE_INPUT, META_VARIABLE_MISUSE};\n use crate::session::{Session, DiagnosticMessageId};\n use crate::ty::TyCtxt;\n use crate::ty::query::Providers;\n@@ -82,6 +82,7 @@ impl Lint {\n     pub fn from_parser_lint_id(lint_id: BufferedEarlyLintId) -> &'static Self {\n         match lint_id {\n             BufferedEarlyLintId::IllFormedAttributeInput => ILL_FORMED_ATTRIBUTE_INPUT,\n+            BufferedEarlyLintId::MetaVariableMisuse => META_VARIABLE_MISUSE,\n         }\n     }\n "}, {"sha": "36c1da2929975a3ec15ac7f4efbd58a7d0a16a99", "filename": "src/libsyntax/early_buffered_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Flibsyntax%2Fearly_buffered_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Flibsyntax%2Fearly_buffered_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fearly_buffered_lints.rs?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -10,6 +10,7 @@ use syntax_pos::MultiSpan;\n /// passed to `rustc::lint::Lint::from_parser_lint_id` to get a `rustc::lint::Lint`.\n pub enum BufferedEarlyLintId {\n     IllFormedAttributeInput,\n+    MetaVariableMisuse,\n }\n \n /// Stores buffered lint info which can later be passed to `librustc`."}, {"sha": "758d34917cbcf4f1900638dac0dde1ee942b189e", "filename": "src/libsyntax/ext/tt/macro_check.rs", "status": "added", "additions": 626, "deletions": 0, "changes": 626, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_check.rs?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -0,0 +1,626 @@\n+//! Checks that meta-variables in macro definition are correctly declared and used.\n+//!\n+//! # What is checked\n+//!\n+//! ## Meta-variables must not be bound twice\n+//!\n+//! ```\n+//! macro_rules! foo { ($x:tt $x:tt) => { $x }; }\n+//! ```\n+//!\n+//! This check is sound (no false-negative) and complete (no false-positive).\n+//!\n+//! ## Meta-variables must not be free\n+//!\n+//! ```\n+//! macro_rules! foo { () => { $x }; }\n+//! ```\n+//!\n+//! This check is also done at macro instantiation but only if the branch is taken.\n+//!\n+//! ## Meta-variables must repeat at least as many times as their binder\n+//!\n+//! ```\n+//! macro_rules! foo { ($($x:tt)*) => { $x }; }\n+//! ```\n+//!\n+//! This check is also done at macro instantiation but only if the branch is taken.\n+//!\n+//! ## Meta-variables must repeat with the same Kleene operators as their binder\n+//!\n+//! ```\n+//! macro_rules! foo { ($($x:tt)+) => { $($x)* }; }\n+//! ```\n+//!\n+//! This check is not done at macro instantiation.\n+//!\n+//! # Disclaimer\n+//!\n+//! In the presence of nested macros (a macro defined in a macro), those checks may have false\n+//! positives and false negatives. We try to detect those cases by recognizing potential macro\n+//! definitions in RHSes, but nested macros may be hidden through the use of particular values of\n+//! meta-variables.\n+//!\n+//! ## Examples of false positive\n+//!\n+//! False positives can come from cases where we don't recognize a nested macro, because it depends\n+//! on particular values of meta-variables. In the following example, we think both instances of\n+//! `$x` are free, which is a correct statement if `$name` is anything but `macro_rules`. But when\n+//! `$name` is `macro_rules`, like in the instantiation below, then `$x:tt` is actually a binder of\n+//! the nested macro and `$x` is bound to it.\n+//!\n+//! ```\n+//! macro_rules! foo { ($name:ident) => { $name! bar { ($x:tt) => { $x }; } }; }\n+//! foo!(macro_rules);\n+//! ```\n+//!\n+//! False positives can also come from cases where we think there is a nested macro while there\n+//! isn't. In the following example, we think `$x` is free, which is incorrect because `bar` is not\n+//! a nested macro since it is not evaluated as code by `stringify!`.\n+//!\n+//! ```\n+//! macro_rules! foo { () => { stringify!(macro_rules! bar { () => { $x }; }) }; }\n+//! ```\n+//!\n+//! ## Examples of false negative\n+//!\n+//! False negatives can come from cases where we don't recognize a meta-variable, because it depends\n+//! on particular values of meta-variables. In the following examples, we don't see that if `$d` is\n+//! instantiated with `$` then `$d z` becomes `$z` in the nested macro definition and is thus a free\n+//! meta-variable. Note however, that if `foo` is instantiated, then we would check the definition\n+//! of `bar` and would see the issue.\n+//!\n+//! ```\n+//! macro_rules! foo { ($d:tt) => { macro_rules! bar { ($y:tt) => { $d z }; } }; }\n+//! ```\n+//!\n+//! # How it is checked\n+//!\n+//! There are 3 main functions: `check_binders`, `check_occurrences`, and `check_nested_macro`. They\n+//! all need some kind of environment.\n+//!\n+//! ## Environments\n+//!\n+//! Environments are used to pass information.\n+//!\n+//! ### From LHS to RHS\n+//!\n+//! When checking a LHS with `check_binders`, we produce (and use) an environment for binders,\n+//! namely `Binders`. This is a mapping from binder name to information about that binder: the span\n+//! of the binder for error messages and the stack of Kleene operators under which it was bound in\n+//! the LHS.\n+//!\n+//! This environment is used by both the LHS and RHS. The LHS uses it to detect duplicate binders.\n+//! The RHS uses it to detect the other errors.\n+//!\n+//! ### From outer macro to inner macro\n+//!\n+//! When checking the RHS of an outer macro and we detect a nested macro definition, we push the\n+//! current state, namely `MacroState`, to an environment of nested macro definitions. Each state\n+//! stores the LHS binders when entering the macro definition as well as the stack of Kleene\n+//! operators under which the inner macro is defined in the RHS.\n+//!\n+//! This environment is a stack representing the nesting of macro definitions. As such, the stack of\n+//! Kleene operators under which a meta-variable is repeating is the concatenation of the stacks\n+//! stored when entering a macro definition starting from the state in which the meta-variable is\n+//! bound.\n+use crate::ast::NodeId;\n+use crate::early_buffered_lints::BufferedEarlyLintId;\n+use crate::ext::tt::quoted::{KleeneToken, TokenTree};\n+use crate::parse::token::TokenKind;\n+use crate::parse::token::{DelimToken, Token};\n+use crate::parse::ParseSess;\n+use crate::symbol::{kw, sym};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use smallvec::SmallVec;\n+use syntax_pos::{symbol::Ident, MultiSpan, Span};\n+\n+/// Stack represented as linked list.\n+///\n+/// Those are used for environments because they grow incrementally and are not mutable.\n+enum Stack<'a, T> {\n+    /// Empty stack.\n+    Empty,\n+    /// A non-empty stack.\n+    Push {\n+        /// The top element.\n+        top: T,\n+        /// The previous elements.\n+        prev: &'a Stack<'a, T>,\n+    },\n+}\n+\n+impl<'a, T> Stack<'a, T> {\n+    /// Returns whether a stack is empty.\n+    fn is_empty(&self) -> bool {\n+        match *self {\n+            Stack::Empty => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns a new stack with an element of top.\n+    fn push(&'a self, top: T) -> Stack<'a, T> {\n+        Stack::Push { top, prev: self }\n+    }\n+}\n+\n+impl<'a, T> Iterator for &'a Stack<'a, T> {\n+    type Item = &'a T;\n+\n+    // Iterates from top to bottom of the stack.\n+    fn next(&mut self) -> Option<&'a T> {\n+        match *self {\n+            Stack::Empty => None,\n+            Stack::Push { ref top, ref prev } => {\n+                *self = prev;\n+                Some(top)\n+            }\n+        }\n+    }\n+}\n+\n+impl From<&Stack<'_, KleeneToken>> for SmallVec<[KleeneToken; 1]> {\n+    fn from(ops: &Stack<'_, KleeneToken>) -> SmallVec<[KleeneToken; 1]> {\n+        let mut ops: SmallVec<[KleeneToken; 1]> = ops.cloned().collect();\n+        // The stack is innermost on top. We want outermost first.\n+        ops.reverse();\n+        ops\n+    }\n+}\n+\n+/// Information attached to a meta-variable binder in LHS.\n+struct BinderInfo {\n+    /// The span of the meta-variable in LHS.\n+    span: Span,\n+    /// The stack of Kleene operators (outermost first).\n+    ops: SmallVec<[KleeneToken; 1]>,\n+}\n+\n+/// An environment of meta-variables to their binder information.\n+type Binders = FxHashMap<Ident, BinderInfo>;\n+\n+/// The state at which we entered a macro definition in the RHS of another macro definition.\n+struct MacroState<'a> {\n+    /// The binders of the branch where we entered the macro definition.\n+    binders: &'a Binders,\n+    /// The stack of Kleene operators (outermost first) where we entered the macro definition.\n+    ops: SmallVec<[KleeneToken; 1]>,\n+}\n+\n+/// Checks that meta-variables are used correctly in a macro definition.\n+///\n+/// Arguments:\n+/// - `sess` is used to emit diagnostics and lints\n+/// - `node_id` is used to emit lints\n+/// - `span` is used when no spans are available\n+/// - `lhses` and `rhses` should have the same length and represent the macro definition\n+pub fn check_meta_variables(\n+    sess: &ParseSess,\n+    node_id: NodeId,\n+    span: Span,\n+    lhses: &[TokenTree],\n+    rhses: &[TokenTree],\n+) -> bool {\n+    if lhses.len() != rhses.len() {\n+        sess.span_diagnostic.span_bug(span, \"length mismatch between LHSes and RHSes\")\n+    }\n+    let mut valid = true;\n+    for (lhs, rhs) in lhses.iter().zip(rhses.iter()) {\n+        let mut binders = Binders::default();\n+        check_binders(sess, node_id, lhs, &Stack::Empty, &mut binders, &Stack::Empty, &mut valid);\n+        check_occurrences(sess, node_id, rhs, &Stack::Empty, &binders, &Stack::Empty, &mut valid);\n+    }\n+    valid\n+}\n+\n+/// Checks `lhs` as part of the LHS of a macro definition, extends `binders` with new binders, and\n+/// sets `valid` to false in case of errors.\n+///\n+/// Arguments:\n+/// - `sess` is used to emit diagnostics and lints\n+/// - `node_id` is used to emit lints\n+/// - `lhs` is checked as part of a LHS\n+/// - `macros` is the stack of possible outer macros\n+/// - `binders` contains the binders of the LHS\n+/// - `ops` is the stack of Kleene operators from the LHS\n+/// - `valid` is set in case of errors\n+fn check_binders(\n+    sess: &ParseSess,\n+    node_id: NodeId,\n+    lhs: &TokenTree,\n+    macros: &Stack<'_, MacroState<'_>>,\n+    binders: &mut Binders,\n+    ops: &Stack<'_, KleeneToken>,\n+    valid: &mut bool,\n+) {\n+    match *lhs {\n+        TokenTree::Token(..) => {}\n+        // This can only happen when checking a nested macro because this LHS is then in the RHS of\n+        // the outer macro. See run-pass/macros/macro-of-higher-order.rs where $y:$fragment in the\n+        // LHS of the nested macro (and RHS of the outer macro) is parsed as MetaVar(y) Colon\n+        // MetaVar(fragment) and not as MetaVarDecl(y, fragment).\n+        TokenTree::MetaVar(span, name) => {\n+            if macros.is_empty() {\n+                sess.span_diagnostic.span_bug(span, \"unexpected MetaVar in lhs\");\n+            }\n+            // There are 3 possibilities:\n+            if let Some(prev_info) = binders.get(&name) {\n+                // 1. The meta-variable is already bound in the current LHS: This is an error.\n+                let mut span = MultiSpan::from_span(span);\n+                span.push_span_label(prev_info.span, \"previous declaration\".into());\n+                buffer_lint(sess, span, node_id, \"duplicate matcher binding\");\n+            } else if get_binder_info(macros, binders, name).is_none() {\n+                // 2. The meta-variable is free: This is a binder.\n+                binders.insert(name, BinderInfo { span, ops: ops.into() });\n+            } else {\n+                // 3. The meta-variable is bound: This is an occurrence.\n+                check_occurrences(sess, node_id, lhs, macros, binders, ops, valid);\n+            }\n+        }\n+        // Similarly, this can only happen when checking a toplevel macro.\n+        TokenTree::MetaVarDecl(span, name, _kind) => {\n+            if !macros.is_empty() {\n+                sess.span_diagnostic.span_bug(span, \"unexpected MetaVarDecl in nested lhs\");\n+            }\n+            if let Some(prev_info) = get_binder_info(macros, binders, name) {\n+                // Duplicate binders at the top-level macro definition are errors. The lint is only\n+                // for nested macro definitions.\n+                sess.span_diagnostic\n+                    .struct_span_err(span, \"duplicate matcher binding\")\n+                    .span_note(prev_info.span, \"previous declaration was here\")\n+                    .emit();\n+                *valid = false;\n+            } else {\n+                binders.insert(name, BinderInfo { span, ops: ops.into() });\n+            }\n+        }\n+        TokenTree::Delimited(_, ref del) => {\n+            for tt in &del.tts {\n+                check_binders(sess, node_id, tt, macros, binders, ops, valid);\n+            }\n+        }\n+        TokenTree::Sequence(_, ref seq) => {\n+            let ops = ops.push(seq.kleene);\n+            for tt in &seq.tts {\n+                check_binders(sess, node_id, tt, macros, binders, &ops, valid);\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns the binder information of a meta-variable.\n+///\n+/// Arguments:\n+/// - `macros` is the stack of possible outer macros\n+/// - `binders` contains the current binders\n+/// - `name` is the name of the meta-variable we are looking for\n+fn get_binder_info<'a>(\n+    mut macros: &'a Stack<'a, MacroState<'a>>,\n+    binders: &'a Binders,\n+    name: Ident,\n+) -> Option<&'a BinderInfo> {\n+    binders.get(&name).or_else(|| macros.find_map(|state| state.binders.get(&name)))\n+}\n+\n+/// Checks `rhs` as part of the RHS of a macro definition and sets `valid` to false in case of\n+/// errors.\n+///\n+/// Arguments:\n+/// - `sess` is used to emit diagnostics and lints\n+/// - `node_id` is used to emit lints\n+/// - `rhs` is checked as part of a RHS\n+/// - `macros` is the stack of possible outer macros\n+/// - `binders` contains the binders of the associated LHS\n+/// - `ops` is the stack of Kleene operators from the RHS\n+/// - `valid` is set in case of errors\n+fn check_occurrences(\n+    sess: &ParseSess,\n+    node_id: NodeId,\n+    rhs: &TokenTree,\n+    macros: &Stack<'_, MacroState<'_>>,\n+    binders: &Binders,\n+    ops: &Stack<'_, KleeneToken>,\n+    valid: &mut bool,\n+) {\n+    match *rhs {\n+        TokenTree::Token(..) => {}\n+        TokenTree::MetaVarDecl(span, _name, _kind) => {\n+            sess.span_diagnostic.span_bug(span, \"unexpected MetaVarDecl in rhs\")\n+        }\n+        TokenTree::MetaVar(span, name) => {\n+            check_ops_is_prefix(sess, node_id, macros, binders, ops, span, name);\n+        }\n+        TokenTree::Delimited(_, ref del) => {\n+            check_nested_occurrences(sess, node_id, &del.tts, macros, binders, ops, valid);\n+        }\n+        TokenTree::Sequence(_, ref seq) => {\n+            let ops = ops.push(seq.kleene);\n+            check_nested_occurrences(sess, node_id, &seq.tts, macros, binders, &ops, valid);\n+        }\n+    }\n+}\n+\n+/// Represents the processed prefix of a nested macro.\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+enum NestedMacroState {\n+    /// Nothing that matches a nested macro definition was processed yet.\n+    Empty,\n+    /// The token `macro_rules` was processed.\n+    MacroRules,\n+    /// The tokens `macro_rules!` were processed.\n+    MacroRulesNot,\n+    /// The tokens `macro_rules!` followed by a name were processed. The name may be either directly\n+    /// an identifier or a meta-variable (that hopefully would be instantiated by an identifier).\n+    MacroRulesNotName,\n+    /// The keyword `macro` was processed.\n+    Macro,\n+    /// The keyword `macro` followed by a name was processed.\n+    MacroName,\n+    /// The keyword `macro` followed by a name and a token delimited by parentheses was processed.\n+    MacroNameParen,\n+}\n+\n+/// Checks `tts` as part of the RHS of a macro definition, tries to recognize nested macro\n+/// definitions, and sets `valid` to false in case of errors.\n+///\n+/// Arguments:\n+/// - `sess` is used to emit diagnostics and lints\n+/// - `node_id` is used to emit lints\n+/// - `tts` is checked as part of a RHS and may contain macro definitions\n+/// - `macros` is the stack of possible outer macros\n+/// - `binders` contains the binders of the associated LHS\n+/// - `ops` is the stack of Kleene operators from the RHS\n+/// - `valid` is set in case of errors\n+fn check_nested_occurrences(\n+    sess: &ParseSess,\n+    node_id: NodeId,\n+    tts: &[TokenTree],\n+    macros: &Stack<'_, MacroState<'_>>,\n+    binders: &Binders,\n+    ops: &Stack<'_, KleeneToken>,\n+    valid: &mut bool,\n+) {\n+    let mut state = NestedMacroState::Empty;\n+    let nested_macros = macros.push(MacroState { binders, ops: ops.into() });\n+    let mut nested_binders = Binders::default();\n+    for tt in tts {\n+        match (state, tt) {\n+            (\n+                NestedMacroState::Empty,\n+                &TokenTree::Token(Token { kind: TokenKind::Ident(name, false), .. }),\n+            ) => {\n+                if name == sym::macro_rules {\n+                    state = NestedMacroState::MacroRules;\n+                } else if name == kw::Macro {\n+                    state = NestedMacroState::Macro;\n+                }\n+            }\n+            (\n+                NestedMacroState::MacroRules,\n+                &TokenTree::Token(Token { kind: TokenKind::Not, .. }),\n+            ) => {\n+                state = NestedMacroState::MacroRulesNot;\n+            }\n+            (\n+                NestedMacroState::MacroRulesNot,\n+                &TokenTree::Token(Token { kind: TokenKind::Ident(..), .. }),\n+            ) => {\n+                state = NestedMacroState::MacroRulesNotName;\n+            }\n+            (NestedMacroState::MacroRulesNot, &TokenTree::MetaVar(..)) => {\n+                state = NestedMacroState::MacroRulesNotName;\n+                // We check that the meta-variable is correctly used.\n+                check_occurrences(sess, node_id, tt, macros, binders, ops, valid);\n+            }\n+            (NestedMacroState::MacroRulesNotName, &TokenTree::Delimited(_, ref del))\n+            | (NestedMacroState::MacroName, &TokenTree::Delimited(_, ref del))\n+                if del.delim == DelimToken::Brace =>\n+            {\n+                let legacy = state == NestedMacroState::MacroRulesNotName;\n+                state = NestedMacroState::Empty;\n+                let rest =\n+                    check_nested_macro(sess, node_id, legacy, &del.tts, &nested_macros, valid);\n+                // If we did not check the whole macro definition, then check the rest as if outside\n+                // the macro definition.\n+                check_nested_occurrences(\n+                    sess,\n+                    node_id,\n+                    &del.tts[rest..],\n+                    macros,\n+                    binders,\n+                    ops,\n+                    valid,\n+                );\n+            }\n+            (\n+                NestedMacroState::Macro,\n+                &TokenTree::Token(Token { kind: TokenKind::Ident(..), .. }),\n+            ) => {\n+                state = NestedMacroState::MacroName;\n+            }\n+            (NestedMacroState::Macro, &TokenTree::MetaVar(..)) => {\n+                state = NestedMacroState::MacroName;\n+                // We check that the meta-variable is correctly used.\n+                check_occurrences(sess, node_id, tt, macros, binders, ops, valid);\n+            }\n+            (NestedMacroState::MacroName, &TokenTree::Delimited(_, ref del))\n+                if del.delim == DelimToken::Paren =>\n+            {\n+                state = NestedMacroState::MacroNameParen;\n+                nested_binders = Binders::default();\n+                check_binders(\n+                    sess,\n+                    node_id,\n+                    tt,\n+                    &nested_macros,\n+                    &mut nested_binders,\n+                    &Stack::Empty,\n+                    valid,\n+                );\n+            }\n+            (NestedMacroState::MacroNameParen, &TokenTree::Delimited(_, ref del))\n+                if del.delim == DelimToken::Brace =>\n+            {\n+                state = NestedMacroState::Empty;\n+                check_occurrences(\n+                    sess,\n+                    node_id,\n+                    tt,\n+                    &nested_macros,\n+                    &nested_binders,\n+                    &Stack::Empty,\n+                    valid,\n+                );\n+            }\n+            (_, ref tt) => {\n+                state = NestedMacroState::Empty;\n+                check_occurrences(sess, node_id, tt, macros, binders, ops, valid);\n+            }\n+        }\n+    }\n+}\n+\n+/// Checks the body of nested macro, returns where the check stopped, and sets `valid` to false in\n+/// case of errors.\n+///\n+/// The token trees are checked as long as they look like a list of (LHS) => {RHS} token trees. This\n+/// check is a best-effort to detect a macro definition. It returns the position in `tts` where we\n+/// stopped checking because we detected we were not in a macro definition anymore.\n+///\n+/// Arguments:\n+/// - `sess` is used to emit diagnostics and lints\n+/// - `node_id` is used to emit lints\n+/// - `legacy` specifies whether the macro is legacy\n+/// - `tts` is checked as a list of (LHS) => {RHS}\n+/// - `macros` is the stack of outer macros\n+/// - `valid` is set in case of errors\n+fn check_nested_macro(\n+    sess: &ParseSess,\n+    node_id: NodeId,\n+    legacy: bool,\n+    tts: &[TokenTree],\n+    macros: &Stack<'_, MacroState<'_>>,\n+    valid: &mut bool,\n+) -> usize {\n+    let n = tts.len();\n+    let mut i = 0;\n+    let separator = if legacy { TokenKind::Semi } else { TokenKind::Comma };\n+    loop {\n+        // We expect 3 token trees: `(LHS) => {RHS}`. The separator is checked after.\n+        if i + 2 >= n\n+            || !tts[i].is_delimited()\n+            || !tts[i + 1].is_token(&TokenKind::FatArrow)\n+            || !tts[i + 2].is_delimited()\n+        {\n+            break;\n+        }\n+        let lhs = &tts[i];\n+        let rhs = &tts[i + 2];\n+        let mut binders = Binders::default();\n+        check_binders(sess, node_id, lhs, macros, &mut binders, &Stack::Empty, valid);\n+        check_occurrences(sess, node_id, rhs, macros, &binders, &Stack::Empty, valid);\n+        // Since the last semicolon is optional for legacy macros and decl_macro are not terminated,\n+        // we increment our checked position by how many token trees we already checked (the 3\n+        // above) before checking for the separator.\n+        i += 3;\n+        if i == n || !tts[i].is_token(&separator) {\n+            break;\n+        }\n+        // We increment our checked position for the semicolon.\n+        i += 1;\n+    }\n+    i\n+}\n+\n+/// Checks that a meta-variable occurrence is valid.\n+///\n+/// Arguments:\n+/// - `sess` is used to emit diagnostics and lints\n+/// - `node_id` is used to emit lints\n+/// - `macros` is the stack of possible outer macros\n+/// - `binders` contains the binders of the associated LHS\n+/// - `ops` is the stack of Kleene operators from the RHS\n+/// - `span` is the span of the meta-variable to check\n+/// - `name` is the name of the meta-variable to check\n+fn check_ops_is_prefix(\n+    sess: &ParseSess,\n+    node_id: NodeId,\n+    macros: &Stack<'_, MacroState<'_>>,\n+    binders: &Binders,\n+    ops: &Stack<'_, KleeneToken>,\n+    span: Span,\n+    name: Ident,\n+) {\n+    let macros = macros.push(MacroState { binders, ops: ops.into() });\n+    // Accumulates the stacks the operators of each state until (and including when) the\n+    // meta-variable is found. The innermost stack is first.\n+    let mut acc: SmallVec<[&SmallVec<[KleeneToken; 1]>; 1]> = SmallVec::new();\n+    for state in &macros {\n+        acc.push(&state.ops);\n+        if let Some(binder) = state.binders.get(&name) {\n+            // This variable concatenates the stack of operators from the RHS of the LHS where the\n+            // meta-variable was defined to where it is used (in possibly nested macros). The\n+            // outermost operator is first.\n+            let mut occurrence_ops: SmallVec<[KleeneToken; 2]> = SmallVec::new();\n+            // We need to iterate from the end to start with outermost stack.\n+            for ops in acc.iter().rev() {\n+                occurrence_ops.extend_from_slice(ops);\n+            }\n+            ops_is_prefix(sess, node_id, span, name, &binder.ops, &occurrence_ops);\n+            return;\n+        }\n+    }\n+    buffer_lint(sess, span.into(), node_id, &format!(\"unknown macro variable `{}`\", name));\n+}\n+\n+/// Returns whether `binder_ops` is a prefix of `occurrence_ops`.\n+///\n+/// The stack of Kleene operators of a meta-variable occurrence just needs to have the stack of\n+/// Kleene operators of its binder as a prefix.\n+///\n+/// Consider $i in the following example:\n+///\n+///     ( $( $i:ident = $($j:ident),+ );* ) => { $($( $i += $j; )+)* }\n+///\n+/// It occurs under the Kleene stack [\"*\", \"+\"] and is bound under [\"*\"] only.\n+///\n+/// Arguments:\n+/// - `sess` is used to emit diagnostics and lints\n+/// - `node_id` is used to emit lints\n+/// - `span` is the span of the meta-variable being check\n+/// - `name` is the name of the meta-variable being check\n+/// - `binder_ops` is the stack of Kleene operators for the binder\n+/// - `occurrence_ops` is the stack of Kleene operators for the occurrence\n+fn ops_is_prefix(\n+    sess: &ParseSess,\n+    node_id: NodeId,\n+    span: Span,\n+    name: Ident,\n+    binder_ops: &[KleeneToken],\n+    occurrence_ops: &[KleeneToken],\n+) {\n+    for (i, binder) in binder_ops.iter().enumerate() {\n+        if i >= occurrence_ops.len() {\n+            let mut span = MultiSpan::from_span(span);\n+            span.push_span_label(binder.span, \"expected repetition\".into());\n+            let message = &format!(\"variable '{}' is still repeating at this depth\", name);\n+            buffer_lint(sess, span, node_id, message);\n+            return;\n+        }\n+        let occurrence = &occurrence_ops[i];\n+        if occurrence.op != binder.op {\n+            let mut span = MultiSpan::from_span(span);\n+            span.push_span_label(binder.span, \"expected repetition\".into());\n+            span.push_span_label(occurrence.span, \"conflicting repetition\".into());\n+            let message = \"meta-variable repeats with different Kleene operator\";\n+            buffer_lint(sess, span, node_id, message);\n+            return;\n+        }\n+    }\n+}\n+\n+fn buffer_lint(sess: &ParseSess, span: MultiSpan, node_id: NodeId, message: &str) {\n+    sess.buffer_lint(BufferedEarlyLintId::MetaVariableMisuse, span, node_id, message);\n+}"}, {"sha": "4503cea0f10c8cf7134b4b5dcfd8ef7d1d5d2487", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 46, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -2,6 +2,7 @@ use crate::edition::Edition;\n use crate::ext::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n+use crate::ext::tt::macro_check;\n use crate::ext::tt::macro_parser::{parse, parse_failure_msg};\n use crate::ext::tt::macro_parser::{Error, Failure, Success};\n use crate::ext::tt::macro_parser::{MatchedNonterminal, MatchedSeq};\n@@ -18,7 +19,7 @@ use crate::{ast, attr, attr::TransparencyError};\n \n use errors::FatalError;\n use log::debug;\n-use syntax_pos::{symbol::Ident, Span};\n+use syntax_pos::Span;\n \n use rustc_data_structures::fx::FxHashMap;\n use std::borrow::Cow;\n@@ -366,14 +367,12 @@ pub fn compile(\n     // don't abort iteration early, so that errors for multiple lhses can be reported\n     for lhs in &lhses {\n         valid &= check_lhs_no_empty_seq(sess, slice::from_ref(lhs));\n-        valid &= check_lhs_duplicate_matcher_bindings(\n-            sess,\n-            slice::from_ref(lhs),\n-            &mut FxHashMap::default(),\n-            def.id,\n-        );\n     }\n \n+    // We use CRATE_NODE_ID instead of `def.id` otherwise we may emit buffered lints for a node id\n+    // that is not lint-checked and trigger the \"failed to process buffered lint here\" bug.\n+    valid &= macro_check::check_meta_variables(sess, ast::CRATE_NODE_ID, def.span, &lhses, &rhses);\n+\n     let expander: Box<_> =\n         Box::new(MacroRulesMacroExpander { name: def.ident, span: def.span, lhses, rhses, valid });\n \n@@ -497,45 +496,6 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[quoted::TokenTree]) -> bool {\n     true\n }\n \n-/// Check that the LHS contains no duplicate matcher bindings. e.g. `$a:expr, $a:expr` would be\n-/// illegal, since it would be ambiguous which `$a` to use if we ever needed to.\n-fn check_lhs_duplicate_matcher_bindings(\n-    sess: &ParseSess,\n-    tts: &[quoted::TokenTree],\n-    metavar_names: &mut FxHashMap<Ident, Span>,\n-    node_id: ast::NodeId,\n-) -> bool {\n-    use self::quoted::TokenTree;\n-    for tt in tts {\n-        match *tt {\n-            TokenTree::MetaVarDecl(span, name, _kind) => {\n-                if let Some(&prev_span) = metavar_names.get(&name) {\n-                    sess.span_diagnostic\n-                        .struct_span_err(span, \"duplicate matcher binding\")\n-                        .span_note(prev_span, \"previous declaration was here\")\n-                        .emit();\n-                    return false;\n-                } else {\n-                    metavar_names.insert(name, span);\n-                }\n-            }\n-            TokenTree::Delimited(_, ref del) => {\n-                if !check_lhs_duplicate_matcher_bindings(sess, &del.tts, metavar_names, node_id) {\n-                    return false;\n-                }\n-            }\n-            TokenTree::Sequence(_, ref seq) => {\n-                if !check_lhs_duplicate_matcher_bindings(sess, &seq.tts, metavar_names, node_id) {\n-                    return false;\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    true\n-}\n-\n fn check_rhs(sess: &ParseSess, rhs: &quoted::TokenTree) -> bool {\n     match *rhs {\n         quoted::TokenTree::Delimited(..) => return true,"}, {"sha": "f67e4d368cc8fe86a6ddc153607c6b04e01e247e", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -123,6 +123,22 @@ impl TokenTree {\n         }\n     }\n \n+    /// Returns `true` if the given token tree is delimited.\n+    pub fn is_delimited(&self) -> bool {\n+        match *self {\n+            TokenTree::Delimited(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns `true` if the given token tree is a token of the given kind.\n+    pub fn is_token(&self, expected_kind: &TokenKind) -> bool {\n+        match self {\n+            TokenTree::Token(Token { kind: actual_kind, .. }) => actual_kind == expected_kind,\n+            _ => false,\n+        }\n+    }\n+\n     /// Gets the `index`-th sub-token-tree. This only makes sense for delimited trees and sequences.\n     pub fn get_tt(&self, index: usize) -> TokenTree {\n         match (self, index) {"}, {"sha": "3dea1977c4dac862b37608ed7cf69d167a906d00", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -174,6 +174,7 @@ pub mod ext {\n \n     pub mod tt {\n         pub mod transcribe;\n+        pub mod macro_check;\n         pub mod macro_parser;\n         pub mod macro_rules;\n         pub mod quoted;"}, {"sha": "99a2f940176bd12ded58a02e99c257c7e5edbf05", "filename": "src/test/run-pass/macros/meta-variable-misuse.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Frun-pass%2Fmacros%2Fmeta-variable-misuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Frun-pass%2Fmacros%2Fmeta-variable-misuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacros%2Fmeta-variable-misuse.rs?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -0,0 +1,34 @@\n+// run-pass\n+#![deny(meta_variable_misuse)]\n+\n+macro_rules! foo {\n+    ($($m:ident $($f:ident $v:tt)+),*) => {\n+        $($(macro_rules! $f { () => { $v } })+)*\n+        $(macro_rules! $m { () => { $(fn $f() -> i32 { $v })+ } })*\n+    }\n+}\n+\n+foo!(m a 1 b 2, n c 3);\n+m!();\n+n!();\n+\n+macro_rules! no_shadow {\n+    ($x:tt) => { macro_rules! bar { ($x:tt) => { 42 }; } };\n+}\n+no_shadow!(z);\n+\n+macro_rules! make_plus {\n+    ($n: ident $x:expr) => { macro_rules! $n { ($y:expr) => { $x + $y }; } };\n+}\n+make_plus!(add3 3);\n+\n+fn main() {\n+    assert_eq!(a!(), 1);\n+    assert_eq!(b!(), 2);\n+    assert_eq!(c!(), 3);\n+    assert_eq!(a(), 1);\n+    assert_eq!(b(), 2);\n+    assert_eq!(c(), 3);\n+    assert_eq!(bar!(z:tt), 42);\n+    assert_eq!(add3!(9), 12);\n+}"}, {"sha": "9b7babdbb70adaa6cf1a496ad1bcd5aec9180d38", "filename": "src/test/ui/macros/issue-61053-different-kleene.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-different-kleene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-different-kleene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-different-kleene.rs?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -0,0 +1,30 @@\n+#![deny(meta_variable_misuse)]\n+\n+macro_rules! foo {\n+    () => {};\n+    ( $( $i:ident = $($j:ident),+ );* ) => { $( $( $i = $j; )* )* };\n+    //~^ ERROR meta-variable repeats with\n+    ( $( $($j:ident),+ );* ) => { $( $( $j; )+ )+ }; //~ERROR meta-variable repeats with\n+}\n+\n+macro_rules! bar {\n+    () => {};\n+    (test) => {\n+        macro_rules! nested {\n+            () => {};\n+            ( $( $i:ident = $($j:ident),+ );* ) => { $( $( $i = $j; )* )* };\n+            //~^ ERROR meta-variable repeats with\n+            ( $( $($j:ident),+ );* ) => { $( $( $j; )+ )+ }; //~ERROR meta-variable repeats with\n+        }\n+    };\n+    ( $( $i:ident = $($j:ident),+ );* ) => {\n+        $(macro_rules! $i {\n+            () => { 0 $( + $j )* }; //~ ERROR meta-variable repeats with\n+        })*\n+    };\n+}\n+\n+fn main() {\n+    foo!();\n+    bar!();\n+}"}, {"sha": "86474822a0c677da3d743e7fd5d9d0cb257a404e", "filename": "src/test/ui/macros/issue-61053-different-kleene.stderr", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-different-kleene.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-different-kleene.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-different-kleene.stderr?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -0,0 +1,45 @@\n+error: meta-variable repeats with different Kleene operator\n+  --> $DIR/issue-61053-different-kleene.rs:5:57\n+   |\n+LL |     ( $( $i:ident = $($j:ident),+ );* ) => { $( $( $i = $j; )* )* };\n+   |                                 - expected repetition   ^^   - conflicting repetition\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-61053-different-kleene.rs:1:9\n+   |\n+LL | #![deny(meta_variable_misuse)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: meta-variable repeats with different Kleene operator\n+  --> $DIR/issue-61053-different-kleene.rs:7:41\n+   |\n+LL |     ( $( $($j:ident),+ );* ) => { $( $( $j; )+ )+ };\n+   |                          -              ^^      - conflicting repetition\n+   |                          |\n+   |                          expected repetition\n+\n+error: meta-variable repeats with different Kleene operator\n+  --> $DIR/issue-61053-different-kleene.rs:15:65\n+   |\n+LL |             ( $( $i:ident = $($j:ident),+ );* ) => { $( $( $i = $j; )* )* };\n+   |                                         - expected repetition   ^^   - conflicting repetition\n+\n+error: meta-variable repeats with different Kleene operator\n+  --> $DIR/issue-61053-different-kleene.rs:17:49\n+   |\n+LL |             ( $( $($j:ident),+ );* ) => { $( $( $j; )+ )+ };\n+   |                                  -              ^^      - conflicting repetition\n+   |                                  |\n+   |                                  expected repetition\n+\n+error: meta-variable repeats with different Kleene operator\n+  --> $DIR/issue-61053-different-kleene.rs:22:28\n+   |\n+LL |     ( $( $i:ident = $($j:ident),+ );* ) => {\n+   |                                 - expected repetition\n+LL |         $(macro_rules! $i {\n+LL |             () => { 0 $( + $j )* };\n+   |                            ^^  - conflicting repetition\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "34aa571c11ee664bbb3c596e9de0d4a60ee73903", "filename": "src/test/ui/macros/issue-61053-duplicate-binder.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-duplicate-binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-duplicate-binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-duplicate-binder.rs?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -0,0 +1,14 @@\n+#![deny(meta_variable_misuse)]\n+\n+macro_rules! foo {\n+    () => {};\n+    (error) => {\n+        macro_rules! bar {\n+            ($x:tt $x:tt) => { $x }; //~ ERROR duplicate matcher binding\n+        }\n+    };\n+}\n+\n+fn main() {\n+    foo!();\n+}"}, {"sha": "fbd67b6c1e9c0eac66ce5f701d167ca4c2bde489", "filename": "src/test/ui/macros/issue-61053-duplicate-binder.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-duplicate-binder.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-duplicate-binder.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-duplicate-binder.stderr?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -0,0 +1,16 @@\n+error: duplicate matcher binding\n+  --> $DIR/issue-61053-duplicate-binder.rs:7:20\n+   |\n+LL |             ($x:tt $x:tt) => { $x };\n+   |              --    ^^\n+   |              |\n+   |              previous declaration\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-61053-duplicate-binder.rs:1:9\n+   |\n+LL | #![deny(meta_variable_misuse)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "6b36c730b82543aa2359043e4e76eddae01433f9", "filename": "src/test/ui/macros/issue-61053-missing-repetition.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-missing-repetition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-missing-repetition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-missing-repetition.rs?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -0,0 +1,28 @@\n+#![deny(meta_variable_misuse)]\n+\n+macro_rules! foo {\n+    () => {};\n+    ($( $i:ident = $($j:ident),+ );*) => { $( $i = $j; )* };\n+    //~^ ERROR variable 'j' is still repeating\n+}\n+\n+macro_rules! bar {\n+    () => {};\n+    (test) => {\n+        macro_rules! nested {\n+            () => {};\n+            ($( $i:ident = $($j:ident),+ );*) => { $( $i = $j; )* };\n+            //~^ ERROR variable 'j' is still repeating\n+        }\n+    };\n+    ( $( $i:ident = $($j:ident),+ );* ) => {\n+        $(macro_rules! $i {\n+            () => { $j }; //~ ERROR variable 'j' is still repeating\n+        })*\n+    };\n+}\n+\n+fn main() {\n+    foo!();\n+    bar!();\n+}"}, {"sha": "6f89e276c169f14d239a2cf0dd096c91add4eb2c", "filename": "src/test/ui/macros/issue-61053-missing-repetition.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-missing-repetition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-missing-repetition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-missing-repetition.stderr?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -0,0 +1,33 @@\n+error: variable 'j' is still repeating at this depth\n+  --> $DIR/issue-61053-missing-repetition.rs:5:52\n+   |\n+LL |     ($( $i:ident = $($j:ident),+ );*) => { $( $i = $j; )* };\n+   |                                -                   ^^\n+   |                                |\n+   |                                expected repetition\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-61053-missing-repetition.rs:1:9\n+   |\n+LL | #![deny(meta_variable_misuse)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: variable 'j' is still repeating at this depth\n+  --> $DIR/issue-61053-missing-repetition.rs:14:60\n+   |\n+LL |             ($( $i:ident = $($j:ident),+ );*) => { $( $i = $j; )* };\n+   |                                        -                   ^^\n+   |                                        |\n+   |                                        expected repetition\n+\n+error: variable 'j' is still repeating at this depth\n+  --> $DIR/issue-61053-missing-repetition.rs:20:21\n+   |\n+LL |     ( $( $i:ident = $($j:ident),+ );* ) => {\n+   |                                 - expected repetition\n+LL |         $(macro_rules! $i {\n+LL |             () => { $j };\n+   |                     ^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "b75cdce0cf4bde6132e74e4d6240fd9df5a20ccf", "filename": "src/test/ui/macros/issue-61053-unbound.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-unbound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-unbound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-unbound.rs?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -0,0 +1,28 @@\n+#![deny(meta_variable_misuse)]\n+\n+macro_rules! foo {\n+    () => {};\n+    ($( $i:ident = $($j:ident),+ );*) => { $( $( $i = $k; )+ )* };\n+    //~^ ERROR unknown macro variable\n+}\n+\n+macro_rules! bar {\n+    () => {};\n+    (test) => {\n+        macro_rules! nested {\n+            () => {};\n+            ($( $i:ident = $($j:ident),+ );*) => { $( $( $i = $k; )+ )* };\n+            //~^ ERROR unknown macro variable\n+        }\n+    };\n+    ( $( $i:ident = $($j:ident),+ );* ) => {\n+        $(macro_rules! $i {\n+            () => { $( $i = $k)+ }; //~ ERROR unknown macro variable\n+        })*\n+    };\n+}\n+\n+fn main() {\n+    foo!();\n+    bar!();\n+}"}, {"sha": "0fc0a7e283e9265f056b852129ced1850661fd94", "filename": "src/test/ui/macros/issue-61053-unbound.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-unbound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ec4584d8482f51249d78efc340aaead76251859/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-unbound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61053-unbound.stderr?ref=6ec4584d8482f51249d78efc340aaead76251859", "patch": "@@ -0,0 +1,26 @@\n+error: unknown macro variable `k`\n+  --> $DIR/issue-61053-unbound.rs:5:55\n+   |\n+LL |     ($( $i:ident = $($j:ident),+ );*) => { $( $( $i = $k; )+ )* };\n+   |                                                       ^^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-61053-unbound.rs:1:9\n+   |\n+LL | #![deny(meta_variable_misuse)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unknown macro variable `k`\n+  --> $DIR/issue-61053-unbound.rs:14:63\n+   |\n+LL |             ($( $i:ident = $($j:ident),+ );*) => { $( $( $i = $k; )+ )* };\n+   |                                                               ^^\n+\n+error: unknown macro variable `k`\n+  --> $DIR/issue-61053-unbound.rs:20:29\n+   |\n+LL |             () => { $( $i = $k)+ };\n+   |                             ^^\n+\n+error: aborting due to 3 previous errors\n+"}]}