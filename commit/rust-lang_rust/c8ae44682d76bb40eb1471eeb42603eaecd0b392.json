{"sha": "c8ae44682d76bb40eb1471eeb42603eaecd0b392", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YWU0NDY4MmQ3NmJiNDBlYjE0NzFlZWI0MjYwM2VhZWNkMGIzOTI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-07-06T19:19:12Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-07-11T15:32:18Z"}, "message": "`O(n*k)` code-size deriving on enums (better than previous `O(n^k)`).\n\nIn the above formulas, `n` is the number of variants, and `k` is the\nnumber of self-args fed into deriving.  In the particular case of\ninterest (namely `PartialOrd` and `Ord`), `k` is always 2, so we are\nbasically comparing `O(n)` versus `O(n^2)`.\n\nAlso, the stage is set for having *all* enum deriving codes go through\n`build_enum_match_tuple` and getting rid of `build_enum_match`.\n\nAlso, seriously attempted to clean up the code itself.  Added a bunch\nof comments attempting to document what I learned as I worked through\nthe original code and adapted it to this new strategy.", "tree": {"sha": "17350372e31066616c4d1492b3006d9bca9f06ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17350372e31066616c4d1492b3006d9bca9f06ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8ae44682d76bb40eb1471eeb42603eaecd0b392", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ae44682d76bb40eb1471eeb42603eaecd0b392", "html_url": "https://github.com/rust-lang/rust/commit/c8ae44682d76bb40eb1471eeb42603eaecd0b392", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8ae44682d76bb40eb1471eeb42603eaecd0b392/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d1bdc320ba5304854f409ba68060f5739bca044", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d1bdc320ba5304854f409ba68060f5739bca044", "html_url": "https://github.com/rust-lang/rust/commit/5d1bdc320ba5304854f409ba68060f5739bca044"}], "stats": {"total": 498, "additions": 455, "deletions": 43}, "files": [{"sha": "3164aaf98f2caa55a6a0bb0d02df9db24ad322d6", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=c8ae44682d76bb40eb1471eeb42603eaecd0b392", "patch": "@@ -69,7 +69,7 @@ fn cs_clone(\n             ctor_ident = variant.node.name;\n             all_fields = af;\n         },\n-        EnumNonMatching(..) => {\n+        EnumNonMatching(..) | EnumNonMatchingCollapsed (..) => {\n             cx.span_bug(trait_span,\n                         format!(\"non-matching enum variants in \\\n                                  `deriving({})`\","}, {"sha": "3c7f82a315acb87cfdeaaf0e6283275eab38d073", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=c8ae44682d76bb40eb1471eeb42603eaecd0b392", "patch": "@@ -27,10 +27,12 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n     // any fields are not equal or if the enum variants are different\n     fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> Gc<Expr> {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n-                                 cx, span, substr)\n+               |cx, span, _, _| cx.expr_bool(span, false),\n+               cx, span, substr)\n     }\n     fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> Gc<Expr> {\n         cs_or(|cx, span, _, _| cx.expr_bool(span, true),\n+              |cx, span, _, _| cx.expr_bool(span, true),\n               cx, span, substr)\n     }\n "}, {"sha": "52a180deffb3f64f9fe870474f2d132499a99b7e", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=c8ae44682d76bb40eb1471eeb42603eaecd0b392", "patch": "@@ -35,7 +35,7 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                 args: vec!(borrowed_self()),\n                 ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 attributes: attrs,\n-                on_nonmatching: NonMatchesExplode,\n+                on_nonmatching: NonMatchesCollapseWithTags,\n                 combine_substructure: combine_substructure(|cx, span, substr| {\n                     cs_op($op, $equal, cx, span, substr)\n                 })\n@@ -59,7 +59,7 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n         args: vec![borrowed_self()],\n         ret_ty: ret_ty,\n         attributes: attrs,\n-        on_nonmatching: NonMatchesExplode,\n+        on_nonmatching: NonMatchesCollapseWithTags,\n         combine_substructure: combine_substructure(|cx, span, substr| {\n             cs_partial_cmp(cx, span, substr)\n         })\n@@ -96,6 +96,24 @@ pub fn some_ordering_const(cx: &mut ExtCtxt, span: Span, cnst: Ordering) -> Gc<a\n     cx.expr_some(span, ordering)\n }\n \n+pub enum OrderingOp {\n+    PartialCmpOp, LtOp, LeOp, GtOp, GeOp,\n+}\n+\n+pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n+                               span: Span,\n+                               op: OrderingOp,\n+                               self_arg_tags: &[ast::Ident]) -> Gc<ast::Expr> {\n+    let lft = cx.expr_ident(span, self_arg_tags[0]);\n+    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n+    let op_str = match op {\n+        PartialCmpOp => \"partial_cmp\",\n+        LtOp => \"lt\", LeOp => \"le\",\n+        GtOp => \"gt\", GeOp => \"ge\",\n+    };\n+    cx.expr_method_call(span, lft, cx.ident_of(op_str), vec![rgt])\n+}\n+\n pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> Gc<Expr> {\n     let test_id = cx.ident_of(\"__test\");\n@@ -147,7 +165,14 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n                 // later one.\n                 [(self_var, _, _), (other_var, _, _)] =>\n                      some_ordering_const(cx, span, self_var.cmp(&other_var)),\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n+                _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\"),\n+            }\n+        },\n+        |cx, span, (self_args, tag_tuple), _non_self_args| {\n+            if self_args.len() != 2 {\n+                cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n+            } else {\n+                some_ordering_collapsed(cx, span, PartialCmpOp, tag_tuple)\n             }\n         },\n         cx, span, substr)\n@@ -206,5 +231,16 @@ fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span,\n                 _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n             }\n         },\n+        |cx, span, (self_args, tag_tuple), _non_self_args| {\n+            if self_args.len() != 2 {\n+                cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n+            } else {\n+                let op = match (less, equal) {\n+                    (true,  true) => LeOp, (true,  false) => LtOp,\n+                    (false, true) => GeOp, (false, false) => GtOp,\n+                };\n+                some_ordering_collapsed(cx, span, op, tag_tuple)\n+            }\n+        },\n         cx, span, substr)\n }"}, {"sha": "3a6b1fa218aee8d4510e611b6fc046888fe1ce25", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=c8ae44682d76bb40eb1471eeb42603eaecd0b392", "patch": "@@ -32,6 +32,7 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n             let block = cx.block(span, stmts, None);\n             cx.expr_block(block)\n         },\n+                       |cx, sp, _, _| cx.span_bug(sp, \"non matching enums in deriving(Eq)?\"),\n                        |cx, sp, _, _| cx.span_bug(sp, \"non matching enums in deriving(Eq)?\"),\n                        cx,\n                        span,"}, {"sha": "0e4b786857bac78d1455201dceaa17bbcb8e6b25", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=c8ae44682d76bb40eb1471eeb42603eaecd0b392", "patch": "@@ -41,7 +41,7 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                 args: vec!(borrowed_self()),\n                 ret_ty: Literal(Path::new(vec!(\"std\", \"cmp\", \"Ordering\"))),\n                 attributes: attrs,\n-                on_nonmatching: NonMatchesExplode,\n+                on_nonmatching: NonMatchesCollapseWithTags,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     cs_cmp(a, b, c)\n                 }),\n@@ -65,6 +65,14 @@ pub fn ordering_const(cx: &mut ExtCtxt, span: Span, cnst: Ordering) -> ast::Path\n                      cx.ident_of(cnst)))\n }\n \n+pub fn ordering_collapsed(cx: &mut ExtCtxt,\n+                          span: Span,\n+                          self_arg_tags: &[ast::Ident]) -> Gc<ast::Expr> {\n+    let lft = cx.expr_ident(span, self_arg_tags[0]);\n+    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n+    cx.expr_method_call(span, lft, cx.ident_of(\"cmp\"), vec![rgt])\n+}\n+\n pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> Gc<Expr> {\n     let test_id = cx.ident_of(\"__test\");\n@@ -122,5 +130,12 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n                 _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n             }\n         },\n+        |cx, span, (self_args, tag_tuple), _non_self_args| {\n+            if self_args.len() != 2 {\n+                cx.span_bug(span, \"not exactly 2 arguments in `deriving(TotalOrd)`\")\n+            } else {\n+                ordering_collapsed(cx, span, tag_tuple)\n+            }\n+        },\n         cx, span, substr)\n }"}, {"sha": "039e4e2fb5723c02320d14a1fc0f369d2741325c", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 389, "deletions": 36, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=c8ae44682d76bb40eb1471eeb42603eaecd0b392", "patch": "@@ -135,7 +135,7 @@\n //!               }])\n //! ~~~\n //!\n-//! For `C1 {x}` and `C1 {x}` ,\n+//! For `C1 {x}` and `C1 {x}`,\n //!\n //! ~~~text\n //! EnumMatching(1, <ast::Variant for C1>,\n@@ -150,14 +150,20 @@\n //! For `C0(a)` and `C1 {x}` ,\n //!\n //! ~~~text\n-//! EnumNonMatching(~[(0, <ast::Variant for B0>,\n-//!                    ~[(<span of int>, None, <expr for &a>)]),\n-//!                   (1, <ast::Variant for B1>,\n-//!                    ~[(<span of x>, Some(<ident of x>),\n-//!                       <expr for &other.x>)])])\n+//! EnumNonMatchingCollapsed(\n+//!     ~[<ident of self>, <ident of __arg_1>],\n+//!     &[<ast::Variant for C0>, <ast::Variant for C1>],\n+//!     &[<ident for self index value>, <ident of __arg_1 index value>])\n //! ~~~\n //!\n-//! (and vice versa, but with the order of the outermost list flipped.)\n+//! It is the same for when the arguments are flipped to `C1 {x}` and\n+//! `C0(a)`; the only difference is what the values of the identifiers\n+//! <ident for self index value> and <ident of __arg_1 index value> will\n+//! be in the generated code.\n+//!\n+//! `EnumNonMatchingCollapsed` deliberately provides far less information\n+//! than is generally available for a given pair of variants; see #15375\n+//! for discussion.\n //!\n //! ## Static\n //!\n@@ -172,7 +178,6 @@\n //!                                   (<ident of C1>, <span of C1>,\n //!                                    Named(~[(<ident of x>, <span of x>)]))])\n //! ~~~\n-//!\n \n use std::cell::RefCell;\n use std::gc::{Gc, GC};\n@@ -215,9 +220,18 @@ pub struct TraitDef<'a> {\n \n #[deriving(PartialEq, Eq)]\n pub enum HandleNonMatchingEnums {\n-    NonMatchesCollapse, // handle all non-matches via one `_ => ..` clause\n-    NonMatchesExplode, // handle via n^k cases for n variants and k self-args\n-    NonMatchHandlingIrrelevant, // cannot encounter two enums of Self type\n+    /// handle all non-matches via one `_ => ..` clause\n+    NonMatchesCollapse,\n+\n+    /// handle all non-matches via one `_ => ..` clause that has\n+    /// access to a tuple of tags indicating each variant index.\n+    NonMatchesCollapseWithTags,\n+\n+    /// handle via n^k cases for n variants and k self-args\n+    NonMatchesExplode,\n+\n+    /// cannot encounter two enums of Self type\n+    NonMatchHandlingIrrelevant,\n }\n \n pub struct MethodDef<'a> {\n@@ -308,6 +322,16 @@ pub enum SubstructureFields<'a> {\n     EnumNonMatching(&'a [(uint, P<ast::Variant>,\n                           Vec<(Span, Option<Ident>, Gc<Expr>)>)]),\n \n+    /**\n+    non-matching variants of the enum, but with all state hidden from\n+    the consequent code.  The first component holds Idents for all of\n+    the Self arguments; the second component is a slice of all of the\n+    variants for the enum itself, and the third component is a list of\n+    Idents bound to the variant index values for each of the actual\n+    input Self arguments.\n+    */\n+    EnumNonMatchingCollapsed(Vec<Ident>, &'a [Gc<ast::Variant>], &'a [Ident]),\n+\n     /// A static method where Self is a struct.\n     StaticStruct(&'a ast::StructDef, StaticFields),\n     /// A static method where Self is an enum.\n@@ -324,14 +348,16 @@ pub type CombineSubstructureFunc<'a> =\n     |&mut ExtCtxt, Span, &Substructure|: 'a -> Gc<Expr>;\n \n /**\n-Deal with non-matching enum variants, the arguments are a list\n-representing each variant: (variant index, ast::Variant instance,\n-[variant fields]), and a list of the nonself args of the type\n+Deal with non-matching enum variants.  The tuple is a list of\n+identifiers (one for each Self argument, which could be any of the\n+variants since they have been collapsed together) and the identifiers\n+holding the variant index value for each of the Self arguments.  The\n+last argument is all the non-Self args of the method being derived.\n */\n-pub type EnumNonMatchFunc<'a> =\n+pub type EnumNonMatchCollapsedFunc<'a> =\n     |&mut ExtCtxt,\n            Span,\n-           &[(uint, P<ast::Variant>, Vec<(Span, Option<Ident>, Gc<Expr>)>)],\n+           (&[Ident], &[Ident]),\n            &[Gc<Expr>]|: 'a\n            -> Gc<Expr>;\n \n@@ -531,6 +557,15 @@ impl<'a> TraitDef<'a> {\n     }\n }\n \n+fn variant_to_pat(cx: &mut ExtCtxt, sp: Span, variant: &ast::Variant)\n+                  -> Gc<ast::Pat> {\n+    let ident = cx.path_ident(sp, variant.node.name);\n+    cx.pat(sp, match variant.node.kind {\n+        ast::TupleVariantKind(..) => ast::PatEnum(ident, None),\n+        ast::StructVariantKind(..) => ast::PatStruct(ident, Vec::new(), true),\n+    })\n+}\n+\n impl<'a> MethodDef<'a> {\n     fn call_substructure_method(&self,\n                                 cx: &mut ExtCtxt,\n@@ -769,27 +804,32 @@ impl<'a> MethodDef<'a> {\n    ~~~\n     #[deriving(PartialEq)]\n     enum A {\n-        A1\n+        A1,\n         A2(int)\n     }\n \n-    // is equivalent to (with on_nonmatching == NonMatchesExplode)\n+    // is equivalent to\n \n     impl PartialEq for A {\n-        fn eq(&self, __arg_1: &A) {\n-            match *self {\n-                A1 => match *__arg_1 {\n-                    A1 => true\n-                    A2(ref __arg_1_1) => false\n-                },\n-                A2(self_1) => match *__arg_1 {\n-                    A1 => false,\n-                    A2(ref __arg_1_1) => self_1.eq(__arg_1_1)\n+        fn eq(&self, __arg_1: &A) -> ::bool {\n+            match (&*self, &*__arg_1) {\n+                (&A1, &A1) => true,\n+                (&A2(ref __self_0),\n+                 &A2(ref __arg_1_0)) => (*__self_0).eq(&(*__arg_1_0)),\n+                _ => {\n+                    let __self_vi = match *self { A1(..) => 0u, A2(..) => 1u };\n+                    let __arg_1_vi = match *__arg_1 { A1(..) => 0u, A2(..) => 1u };\n+                    false\n                 }\n             }\n         }\n     }\n    ~~~\n+\n+    (Of course `__self_vi` and `__arg_1_vi` are unused for\n+     `PartialEq`, and those subcomputations will hopefully be removed\n+     as their results are unused.  The point of `__self_vi` and\n+     `__arg_1_vi` is for `PartialOrd`; see #15503.)\n     */\n     fn expand_enum_method_body(&self,\n                                cx: &mut ExtCtxt,\n@@ -800,9 +840,15 @@ impl<'a> MethodDef<'a> {\n                                nonself_args: &[Gc<Expr>])\n                                -> Gc<Expr> {\n         let mut matches = Vec::new();\n-        self.build_enum_match(cx, trait_, enum_def, type_ident,\n-                              self_args, nonself_args,\n-                              None, &mut matches, 0)\n+        match self.on_nonmatching {\n+            NonMatchesCollapseWithTags =>\n+                self.build_enum_match_tuple(\n+                    cx, trait_, enum_def, type_ident, self_args, nonself_args),\n+            NonMatchesCollapse | NonMatchesExplode | NonMatchHandlingIrrelevant =>\n+                self.build_enum_match(\n+                    cx, trait_, enum_def, type_ident, self_args, nonself_args,\n+                    None, &mut matches, 0),\n+        }\n     }\n \n \n@@ -906,6 +952,10 @@ impl<'a> MethodDef<'a> {\n \n             let mut arms = Vec::new();\n \n+            assert!(self.on_nonmatching == NonMatchesCollapse ||\n+                    self.on_nonmatching == NonMatchesExplode ||\n+                    self.on_nonmatching == NonMatchHandlingIrrelevant);\n+\n             // the code for nonmatching variants only matters when\n             // we've seen at least one other variant already\n             assert!(match_count == 0 ||\n@@ -987,6 +1037,293 @@ impl<'a> MethodDef<'a> {\n         }\n     }\n \n+    /**\n+    Creates a match for a tuple of all `self_args`, where either all\n+    variants match, or it falls into a catch-all for when one variant\n+    does not match.\n+\n+    There are N + 1 cases because is a case for each of the N\n+    variants where all of the variants match, and one catch-all for\n+    when one does not match.\n+\n+    The catch-all handler is provided access the variant index values\n+    for each of the self-args, carried in precomputed variables. (Nota\n+    bene: the variant index values are not necessarily the\n+    discriminant values.  See issue #15523.)\n+\n+    ~~~text\n+    match (this, that, ...) {\n+      (Variant1, Variant1, Variant1) => ... // delegate Matching on Variant1\n+      (Variant2, Variant2, Variant2) => ... // delegate Matching on Variant2\n+      ...\n+      _ => {\n+        let __this_vi = match this { Variant1 => 0u, Variant2 => 1u, ... };\n+        let __that_vi = match that { Variant1 => 0u, Variant2 => 1u, ... };\n+        ... // catch-all remainder can inspect above variant index values.\n+      }\n+    }\n+    ~~~\n+    */\n+    fn build_enum_match_tuple(\n+        &self,\n+        cx: &mut ExtCtxt,\n+        trait_: &TraitDef,\n+        enum_def: &EnumDef,\n+        type_ident: Ident,\n+        self_args: &[Gc<Expr>],\n+        nonself_args: &[Gc<Expr>]) -> Gc<Expr> {\n+\n+        let sp = trait_.span;\n+        let variants = &enum_def.variants;\n+\n+        let self_arg_names = self_args.iter().enumerate()\n+            .map(|(arg_count, _self_arg)| {\n+                if arg_count == 0 {\n+                    \"__self\".to_string()\n+                } else {\n+                    format!(\"__arg_{}\", arg_count)\n+                }\n+            })\n+            .collect::<Vec<String>>();\n+\n+        let self_arg_idents = self_arg_names.iter()\n+            .map(|name|cx.ident_of(name.as_slice()))\n+            .collect::<Vec<ast::Ident>>();\n+\n+        // The `vi_idents` will be bound, solely in the catch-all, to\n+        // a series of let statements mapping each self_arg to a uint\n+        // corresponding to its variant index.\n+        let vi_idents : Vec<ast::Ident> = self_arg_names.iter()\n+            .map(|name| { let vi_suffix = format!(\"{:s}_vi\", name.as_slice());\n+                          cx.ident_of(vi_suffix.as_slice()) })\n+            .collect::<Vec<ast::Ident>>();\n+\n+        // Builds, via callback to call_substructure_method, the\n+        // delegated expression that handles the catch-all case,\n+        // using `__variants_tuple` to drive logic if necessary.\n+        let catch_all_substructure = EnumNonMatchingCollapsed(\n+            self_arg_idents, variants.as_slice(), vi_idents.as_slice());\n+\n+        // These arms are of the form:\n+        // (Variant1, Variant1, ...) => Body1\n+        // (Variant2, Variant2, ...) => Body2\n+        // ...\n+        // where each tuple has length = self_args.len()\n+        let mut match_arms : Vec<ast::Arm> = variants.iter().enumerate()\n+            .map(|(index, &variant)| {\n+\n+                // These self_pats have form Variant1, Variant2, ...\n+                let self_pats : Vec<(Gc<ast::Pat>,\n+                                     Vec<(Span, Option<Ident>, Gc<Expr>)>)>;\n+                self_pats = self_arg_names.iter()\n+                    .map(|self_arg_name|\n+                         trait_.create_enum_variant_pattern(\n+                             cx, &*variant, self_arg_name.as_slice(),\n+                             ast::MutImmutable))\n+                    .collect();\n+\n+                // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n+                // (see \"Final wrinkle\" note below for why.)\n+                let subpats = self_pats.iter()\n+                    .map(|&(p, ref _idents)| cx.pat(sp, ast::PatRegion(p)))\n+                    .collect::<Vec<Gc<ast::Pat>>>();\n+\n+                // Here is the pat = `(&VariantK, &VariantK, ...)`\n+                let single_pat = cx.pat(sp, ast::PatTup(subpats));\n+\n+                // For the BodyK, we need to delegate to our caller,\n+                // passing it an EnumMatching to indicate which case\n+                // we are in.\n+\n+                // All of the Self args have the same variant in these\n+                // cases.  So we transpose the info in self_pats to\n+                // gather the getter expressions together, in the form\n+                // that EnumMatching expects.\n+\n+                // The transposition is driven by walking across the\n+                // arg fields of the variant for the first self pat.\n+                let &(_, ref self_arg_fields) = self_pats.get(0);\n+\n+                let field_tuples : Vec<FieldInfo>;\n+\n+                field_tuples = self_arg_fields.iter().enumerate()\n+                    // For each arg field of self, pull out its getter expr ...\n+                    .map(|(field_index, &(sp, opt_ident, self_getter_expr))| {\n+                        // ... but FieldInfo also wants getter expr\n+                        // for matching other arguments of Self type;\n+                        // so walk across the *other* self_pats and\n+                        // pull out getter for same field in each of\n+                        // them (using `field_index` tracked above).\n+                        // That is the heart of the transposition.\n+                        let others = self_pats.tail().iter()\n+                            .map(|&(_pat, ref fields)| {\n+\n+                                let &(_, _opt_ident, other_getter_expr) =\n+                                    fields.get(field_index);\n+\n+                                // All Self args have same variant, so\n+                                // opt_idents are the same.  (Assert\n+                                // here to make it self-evident that\n+                                // it is okay to ignore `_opt_ident`.)\n+                                assert!(opt_ident == _opt_ident);\n+\n+                                other_getter_expr\n+                            }).collect::<Vec<Gc<Expr>>>();\n+\n+                        FieldInfo { span: sp,\n+                                    name: opt_ident,\n+                                    self_: self_getter_expr,\n+                                    other: others,\n+                        }\n+                    }).collect::<Vec<FieldInfo>>();\n+\n+                // Now, for some given VariantK, we have built up\n+                // expressions for referencing every field of every\n+                // Self arg, assuming all are instances of VariantK.\n+                // Build up code associated with such a case.\n+                let substructure = EnumMatching(index, variant, field_tuples);\n+                let arm_expr = self.call_substructure_method(\n+                    cx, trait_, type_ident, self_args, nonself_args,\n+                    &substructure);\n+\n+                cx.arm(sp, vec![single_pat], arm_expr)\n+            }).collect();\n+\n+        // We will usually need the catch-all after matching the\n+        // tuples `(VariantK, VariantK, ...)` for each VariantK of the\n+        // enum.  But:\n+        //\n+        // * when there is only one Self arg, the arms above suffice\n+        // (and the deriving we call back into may not be prepared to\n+        // handle EnumNonMatchCollapsed), and,\n+        //\n+        // * when the enum has only one variant, the single arm that\n+        // is already present always suffices.\n+        //\n+        // * In either of the two cases above, if we *did* add a\n+        //   catch-all `_` match, it would trigger the\n+        //   unreachable-pattern error.\n+        //\n+        if variants.len() > 1 && self_args.len() > 1 {\n+            let arms : Vec<ast::Arm> = variants.iter().enumerate()\n+                .map(|(index, &variant)| {\n+                    let pat = variant_to_pat(cx, sp, &*variant);\n+                    let lit = ast::LitUint(index as u64, ast::TyU);\n+                    cx.arm(sp, vec![pat], cx.expr_lit(sp, lit))\n+                }).collect();\n+\n+            // Build a series of let statements mapping each self_arg\n+            // to a uint corresponding to its variant index.\n+            // i.e. for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n+            // with three Self args, builds three statements:\n+            //\n+            // ```\n+            // let __self0_vi = match   self {\n+            //     A => 0u, B(..) => 1u, C(..) => 2u\n+            // };\n+            // let __self1_vi = match __arg1 {\n+            //     A => 0u, B(..) => 1u, C(..) => 2u\n+            // };\n+            // let __self2_vi = match __arg2 {\n+            //     A => 0u, B(..) => 1u, C(..) => 2u\n+            // };\n+            // ```\n+            let mut index_let_stmts : Vec<Gc<ast::Stmt>> = Vec::new();\n+            for (&ident, &self_arg) in vi_idents.iter().zip(self_args.iter()) {\n+                let variant_idx = cx.expr_match(sp, self_arg, arms.clone());\n+                let let_stmt = cx.stmt_let(sp, false, ident, variant_idx);\n+                index_let_stmts.push(let_stmt);\n+            }\n+\n+            let arm_expr = self.call_substructure_method(\n+                cx, trait_, type_ident, self_args, nonself_args,\n+                &catch_all_substructure);\n+\n+            // Builds the expression:\n+            // {\n+            //   let __self0_vi = ...;\n+            //   let __self1_vi = ...;\n+            //   ...\n+            //   <delegated expression referring to __self0_vi, et al.>\n+            // }\n+            let arm_expr = cx.expr_block(\n+                cx.block_all(sp, Vec::new(), index_let_stmts, Some(arm_expr)));\n+\n+            // Builds arm:\n+            // _ => { let __self0_vi = ...;\n+            //        let __self1_vi = ...;\n+            //        ...\n+            //        <delegated expression as above> }\n+            let catch_all_match_arm =\n+                cx.arm(sp, vec![cx.pat_wild(sp)], arm_expr);\n+\n+            match_arms.push(catch_all_match_arm);\n+\n+        } else if variants.len() == 0 {\n+            // As an additional wrinkle, For a zero-variant enum A,\n+            // currently the compiler\n+            // will accept `fn (a: &Self) { match   *a   { } }`\n+            // but rejects `fn (a: &Self) { match (&*a,) { } }`\n+            // as well as  `fn (a: &Self) { match ( *a,) { } }`\n+            //\n+            // This means that the strategy of building up a tuple of\n+            // all Self arguments fails when Self is a zero variant\n+            // enum: rustc rejects the expanded program, even though\n+            // the actual code tends to be impossible to execute (at\n+            // least safely), according to the type system.\n+            //\n+            // The most expedient fix for this is to just let the\n+            // code fall through to the catch-all.  But even this is\n+            // error-prone, since the catch-all as defined above would\n+            // generate code like this:\n+            //\n+            //     _ => { let __self0 = match *self { };\n+            //            let __self1 = match *__arg_0 { };\n+            //            <catch-all-expr> }\n+            //\n+            // Which is yields bindings for variables which type\n+            // inference cannot resolve to unique types.\n+            //\n+            // One option to the above might be to add explicit type\n+            // annotations.  But the *only* reason to go down that path\n+            // would be to try to make the expanded output consistent\n+            // with the case when the number of enum variants >= 1.\n+            //\n+            // That just isn't worth it.  In fact, trying to generate\n+            // sensible code for *any* deriving on a zero-variant enum\n+            // does not make sense.  But at the same time, for now, we\n+            // do not want to cause a compile failure just because the\n+            // user happened to attach a deriving to their\n+            // zero-variant enum.\n+            //\n+            // Instead, just generate a failing expression for the\n+            // zero variant case, skipping matches and also skipping\n+            // delegating back to the end user code entirely.\n+            //\n+            // (See also #4499 and #12609; note that some of the\n+            // discussions there influence what choice we make here;\n+            // e.g. if we feature-gate `match x { ... }` when x refers\n+            // to an uninhabited type (e.g. a zero-variant enum or a\n+            // type holding such an enum), but do not feature-gate\n+            // zero-variant enums themselves, then attempting to\n+            // derive Show on such a type could here generate code\n+            // that needs the feature gate enabled.)\n+\n+            return cx.expr_unreachable(sp);\n+        }\n+\n+        // Final wrinkle: the self_args are expressions that deref\n+        // down to desired l-values, but we cannot actually deref\n+        // them when they are fed as r-values into a tuple\n+        // expression; here add a layer of borrowing, turning\n+        // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n+        let borrowed_self_args = self_args.iter()\n+            .map(|&self_arg| cx.expr_addr_of(sp, self_arg))\n+            .collect::<Vec<Gc<ast::Expr>>>();\n+        let match_arg = cx.expr(sp, ast::ExprTup(borrowed_self_args));\n+        cx.expr_match(sp, match_arg, match_arms)\n+    }\n+\n     fn expand_static_enum_method_body(&self,\n                                       cx: &mut ExtCtxt,\n                                       trait_: &TraitDef,\n@@ -1186,6 +1523,7 @@ pub fn cs_fold(use_foldl: bool,\n                f: |&mut ExtCtxt, Span, Gc<Expr>, Gc<Expr>, &[Gc<Expr>]| -> Gc<Expr>,\n                base: Gc<Expr>,\n                enum_nonmatch_f: EnumNonMatchFunc,\n+               enum_nonmatch_g: EnumNonMatchCollapsedFunc,\n                cx: &mut ExtCtxt,\n                trait_span: Span,\n                substructure: &Substructure)\n@@ -1210,9 +1548,12 @@ pub fn cs_fold(use_foldl: bool,\n                 })\n             }\n         },\n-        EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, trait_span,\n-                                                          *all_enums,\n-                                                          substructure.nonself_args),\n+        EnumNonMatching(ref all_enums) =>\n+            enum_nonmatch_f(cx, trait_span, *all_enums,\n+                            substructure.nonself_args),\n+        EnumNonMatchingCollapsed(ref all_args, _, tuple) =>\n+            enum_nonmatch_g(cx, trait_span, (all_args.as_slice(), tuple),\n+                            substructure.nonself_args),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `deriving`\")\n         }\n@@ -1232,6 +1573,7 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n #[inline]\n pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<Gc<Expr>>| -> Gc<Expr>,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n+                      enum_nonmatch_g: EnumNonMatchCollapsedFunc,\n                       cx: &mut ExtCtxt,\n                       trait_span: Span,\n                       substructure: &Substructure)\n@@ -1250,9 +1592,12 @@ pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<Gc<Expr>>| -> Gc<Expr>,\n \n             f(cx, trait_span, called)\n         },\n-        EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, trait_span,\n-                                                          *all_enums,\n-                                                          substructure.nonself_args),\n+        EnumNonMatching(ref all_enums) =>\n+            enum_nonmatch_f(cx, trait_span, *all_enums,\n+                            substructure.nonself_args),\n+        EnumNonMatchingCollapsed(ref all_self_args, _, tuple) =>\n+            enum_nonmatch_g(cx, trait_span, (all_self_args.as_slice(), tuple),\n+                            substructure.nonself_args),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `deriving`\")\n         }\n@@ -1269,6 +1614,7 @@ pub fn cs_same_method_fold(use_foldl: bool,\n                            f: |&mut ExtCtxt, Span, Gc<Expr>, Gc<Expr>| -> Gc<Expr>,\n                            base: Gc<Expr>,\n                            enum_nonmatch_f: EnumNonMatchFunc,\n+                           enum_nonmatch_g: EnumNonMatchCollapsedFunc,\n                            cx: &mut ExtCtxt,\n                            trait_span: Span,\n                            substructure: &Substructure)\n@@ -1286,6 +1632,7 @@ pub fn cs_same_method_fold(use_foldl: bool,\n             }\n         },\n         enum_nonmatch_f,\n+        enum_nonmatch_g,\n         cx, trait_span, substructure)\n }\n \n@@ -1296,6 +1643,7 @@ on all the fields.\n #[inline]\n pub fn cs_binop(binop: ast::BinOp, base: Gc<Expr>,\n                 enum_nonmatch_f: EnumNonMatchFunc,\n+                enum_nonmatch_g: EnumNonMatchCollapsedFunc,\n                 cx: &mut ExtCtxt, trait_span: Span,\n                 substructure: &Substructure) -> Gc<Expr> {\n     cs_same_method_fold(\n@@ -1308,25 +1656,30 @@ pub fn cs_binop(binop: ast::BinOp, base: Gc<Expr>,\n         },\n         base,\n         enum_nonmatch_f,\n+        enum_nonmatch_g,\n         cx, trait_span, substructure)\n }\n \n /// cs_binop with binop == or\n #[inline]\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n+             enum_nonmatch_g: EnumNonMatchCollapsedFunc,\n              cx: &mut ExtCtxt, span: Span,\n              substructure: &Substructure) -> Gc<Expr> {\n     cs_binop(ast::BiOr, cx.expr_bool(span, false),\n              enum_nonmatch_f,\n+             enum_nonmatch_g,\n              cx, span, substructure)\n }\n \n /// cs_binop with binop == and\n #[inline]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n+              enum_nonmatch_g: EnumNonMatchCollapsedFunc,\n               cx: &mut ExtCtxt, span: Span,\n               substructure: &Substructure) -> Gc<Expr> {\n     cs_binop(ast::BiAnd, cx.expr_bool(span, true),\n              enum_nonmatch_f,\n+             enum_nonmatch_g,\n              cx, span, substructure)\n }"}, {"sha": "f01beeb7959c258b51fc71c3aefef261e6129d65", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=c8ae44682d76bb40eb1471eeb42603eaecd0b392", "patch": "@@ -67,7 +67,8 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n         Struct(_) => substr.type_ident,\n         EnumMatching(_, v, _) => v.node.name,\n \n-        EnumNonMatching(..) | StaticStruct(..) | StaticEnum(..) => {\n+        EnumNonMatching(..) | EnumNonMatchingCollapsed(..) |\n+        StaticStruct(..) | StaticEnum(..) => {\n             cx.span_bug(span, \"nonsensical .fields in `#[deriving(Show)]`\")\n         }\n     };"}, {"sha": "59a0d1ed5ce210823d6fd472e671e3272a4ce105", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ae44682d76bb40eb1471eeb42603eaecd0b392/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=c8ae44682d76bb40eb1471eeb42603eaecd0b392", "patch": "@@ -57,6 +57,10 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                                                         \"Non-matching enum \\\n                                                          variant in \\\n                                                          deriving(Zero)\"),\n+                           |cx, span, _, _| cx.span_bug(span,\n+                                                        \"Non-matching enum \\\n+                                                         variant in \\\n+                                                         deriving(Zero)\"),\n                            cx, span, substr)\n                 })\n             }"}]}