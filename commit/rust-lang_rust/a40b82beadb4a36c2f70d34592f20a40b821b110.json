{"sha": "a40b82beadb4a36c2f70d34592f20a40b821b110", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MGI4MmJlYWRiNGEzNmMyZjcwZDM0NTkyZjIwYTQwYjgyMWIxMTA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-26T11:37:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-26T11:37:56Z"}, "message": "Rollup merge of #61102 - spastorino:move-path-for-iterate, r=oli-obk\n\nMove path for iterate\n\nr? @oli-obk", "tree": {"sha": "0df17e0fdde9cc38de3e98bd2b382f87d2efc544", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0df17e0fdde9cc38de3e98bd2b382f87d2efc544"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a40b82beadb4a36c2f70d34592f20a40b821b110", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc6nqUCRBK7hj4Ov3rIwAAdHIIAGX+0F0mC/tOwdkBxB5Hhd1H\nfEkU3J6UQZLWfa4dqx3JNFd/gm69Ngg5R0uhJZljqWYYVNC2qHCV2xHmM7atZPKG\n5Z89fhn7XNW9kNc12EsjbP35U7xO0qH27UxgQIYCNBfJGjIOr22KF2/fxPckd1Ql\n6EJz5Xvj1lnhqfCwLAFSXE6EYZQp7RLvELT8n+c6lx8/aCwyVcJXV0H4kompUSS+\nTWbjvIhjybj0ju4B86nweVSmVheQuDQoU31wzVZlxmeTaRT3ZCYP2t4+RgzBYN5b\nZXeGAsuAAgIH3dL/Gwup5lsZzBVn4hXvODAGjQzYHduC5HeUp3v/Au2IS1wQvx0=\n=sza9\n-----END PGP SIGNATURE-----\n", "payload": "tree 0df17e0fdde9cc38de3e98bd2b382f87d2efc544\nparent 58eb22fdae6847eb292754e466da7922c03fc0e4\nparent 294dc18208e8338631a30767ed0394066638eabf\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1558870676 +0200\ncommitter GitHub <noreply@github.com> 1558870676 +0200\n\nRollup merge of #61102 - spastorino:move-path-for-iterate, r=oli-obk\n\nMove path for iterate\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a40b82beadb4a36c2f70d34592f20a40b821b110", "html_url": "https://github.com/rust-lang/rust/commit/a40b82beadb4a36c2f70d34592f20a40b821b110", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a40b82beadb4a36c2f70d34592f20a40b821b110/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58eb22fdae6847eb292754e466da7922c03fc0e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/58eb22fdae6847eb292754e466da7922c03fc0e4", "html_url": "https://github.com/rust-lang/rust/commit/58eb22fdae6847eb292754e466da7922c03fc0e4"}, {"sha": "294dc18208e8338631a30767ed0394066638eabf", "url": "https://api.github.com/repos/rust-lang/rust/commits/294dc18208e8338631a30767ed0394066638eabf", "html_url": "https://github.com/rust-lang/rust/commit/294dc18208e8338631a30767ed0394066638eabf"}], "stats": {"total": 141, "additions": 73, "deletions": 68}, "files": [{"sha": "ab0a2d87302c8fab064cecb9a3fde0f2f1dda68d", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 73, "deletions": 68, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/a40b82beadb4a36c2f70d34592f20a40b821b110/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40b82beadb4a36c2f70d34592f20a40b821b110/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=a40b82beadb4a36c2f70d34592f20a40b821b110", "patch": "@@ -95,82 +95,87 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                      -> Result<MovePathIndex, MoveError<'tcx>>\n     {\n         debug!(\"lookup({:?})\", place);\n-        match *place {\n-            Place::Base(PlaceBase::Local(local)) => Ok(self.builder.data.rev_lookup.locals[local]),\n-            Place::Base(PlaceBase::Static(..)) => {\n-                Err(MoveError::cannot_move_out_of(self.loc, Static))\n-            }\n-            Place::Projection(ref proj) => {\n-                self.move_path_for_projection(place, proj)\n+        place.iterate(|place_base, place_projection| {\n+            let mut base = match place_base {\n+                PlaceBase::Local(local) => self.builder.data.rev_lookup.locals[*local],\n+                PlaceBase::Static(..) => {\n+                    return Err(MoveError::cannot_move_out_of(self.loc, Static));\n+                }\n+            };\n+\n+            for proj in place_projection {\n+                let mir = self.builder.mir;\n+                let tcx = self.builder.tcx;\n+                let place_ty = proj.base.ty(mir, tcx).ty;\n+                match place_ty.sty {\n+                    ty::Ref(..) | ty::RawPtr(..) =>\n+                        return Err(MoveError::cannot_move_out_of(\n+                            self.loc,\n+                            BorrowedContent {\n+                                target_place: Place::Projection(Box::new(proj.clone())),\n+                            })),\n+                    ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n+                        return Err(MoveError::cannot_move_out_of(self.loc,\n+                                                                 InteriorOfTypeWithDestructor {\n+                            container_ty: place_ty\n+                        })),\n+                    // move out of union - always move the entire union\n+                    ty::Adt(adt, _) if adt.is_union() =>\n+                        return Err(MoveError::UnionMove { path: base }),\n+                    ty::Slice(_) =>\n+                        return Err(MoveError::cannot_move_out_of(\n+                            self.loc,\n+                            InteriorOfSliceOrArray {\n+                                ty: place_ty, is_index: match proj.elem {\n+                                    ProjectionElem::Index(..) => true,\n+                                    _ => false\n+                                },\n+                            })),\n+                    ty::Array(..) => match proj.elem {\n+                        ProjectionElem::Index(..) =>\n+                            return Err(MoveError::cannot_move_out_of(\n+                                self.loc,\n+                                InteriorOfSliceOrArray {\n+                                    ty: place_ty, is_index: true\n+                                })),\n+                        _ => {\n+                            // FIXME: still badly broken\n+                        }\n+                    },\n+                    _ => {}\n+                };\n+\n+                base = match self\n+                    .builder\n+                    .data\n+                    .rev_lookup\n+                    .projections\n+                    .entry((base, proj.elem.lift()))\n+                {\n+                    Entry::Occupied(ent) => *ent.get(),\n+                    Entry::Vacant(ent) => {\n+                        let path = MoveDataBuilder::new_move_path(\n+                            &mut self.builder.data.move_paths,\n+                            &mut self.builder.data.path_map,\n+                            &mut self.builder.data.init_path_map,\n+                            Some(base),\n+                            Place::Projection(Box::new(proj.clone())),\n+                        );\n+                        ent.insert(path);\n+                        path\n+                    }\n+                };\n             }\n-        }\n+\n+            Ok(base)\n+        })\n     }\n \n     fn create_move_path(&mut self, place: &Place<'tcx>) {\n         // This is an non-moving access (such as an overwrite or\n         // drop), so this not being a valid move path is OK.\n         let _ = self.move_path_for(place);\n     }\n-\n-    fn move_path_for_projection(&mut self,\n-                                place: &Place<'tcx>,\n-                                proj: &Projection<'tcx>)\n-                                -> Result<MovePathIndex, MoveError<'tcx>>\n-    {\n-        let base = self.move_path_for(&proj.base)?;\n-        let mir = self.builder.mir;\n-        let tcx = self.builder.tcx;\n-        let place_ty = proj.base.ty(mir, tcx).ty;\n-        match place_ty.sty {\n-            ty::Ref(..) | ty::RawPtr(..) =>\n-                return Err(MoveError::cannot_move_out_of(\n-                    self.loc,\n-                    BorrowedContent { target_place: place.clone() })),\n-            ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n-                return Err(MoveError::cannot_move_out_of(self.loc,\n-                                                         InteriorOfTypeWithDestructor {\n-                    container_ty: place_ty\n-                })),\n-            // move out of union - always move the entire union\n-            ty::Adt(adt, _) if adt.is_union() =>\n-                return Err(MoveError::UnionMove { path: base }),\n-            ty::Slice(_) =>\n-                return Err(MoveError::cannot_move_out_of(\n-                    self.loc,\n-                    InteriorOfSliceOrArray {\n-                        ty: place_ty, is_index: match proj.elem {\n-                            ProjectionElem::Index(..) => true,\n-                            _ => false\n-                        },\n-                    })),\n-            ty::Array(..) => match proj.elem {\n-                ProjectionElem::Index(..) =>\n-                    return Err(MoveError::cannot_move_out_of(\n-                        self.loc,\n-                        InteriorOfSliceOrArray {\n-                            ty: place_ty, is_index: true\n-                        })),\n-                _ => {\n-                    // FIXME: still badly broken\n-                }\n-            },\n-            _ => {}\n-        };\n-        match self.builder.data.rev_lookup.projections.entry((base, proj.elem.lift())) {\n-            Entry::Occupied(ent) => Ok(*ent.get()),\n-            Entry::Vacant(ent) => {\n-                let path = MoveDataBuilder::new_move_path(\n-                    &mut self.builder.data.move_paths,\n-                    &mut self.builder.data.path_map,\n-                    &mut self.builder.data.init_path_map,\n-                    Some(base),\n-                    place.clone()\n-                );\n-                ent.insert(path);\n-                Ok(path)\n-            }\n-        }\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {"}]}