{"sha": "b49771e392983b8aeed5bed9f510b72656544544", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0OTc3MWUzOTI5ODNiOGFlZWQ1YmVkOWY1MTBiNzI2NTY1NDQ1NDQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-17T03:58:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-03T20:05:16Z"}, "message": "std: Remove try_send_deferred plus all fallout\n\nNow that extra::sync primitives are built on a proper mutex instead of a\npthreads one, there's no longer any use for this function.", "tree": {"sha": "c3ce5653472d6a775bbbaa6eca523af37a991cb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3ce5653472d6a775bbbaa6eca523af37a991cb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b49771e392983b8aeed5bed9f510b72656544544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b49771e392983b8aeed5bed9f510b72656544544", "html_url": "https://github.com/rust-lang/rust/commit/b49771e392983b8aeed5bed9f510b72656544544", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b49771e392983b8aeed5bed9f510b72656544544/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21e8466eca0536ab8ade7a74f7735fa6fda0142c", "url": "https://api.github.com/repos/rust-lang/rust/commits/21e8466eca0536ab8ade7a74f7735fa6fda0142c", "html_url": "https://github.com/rust-lang/rust/commit/21e8466eca0536ab8ade7a74f7735fa6fda0142c"}], "stats": {"total": 61, "additions": 31, "deletions": 30}, "files": [{"sha": "8db95f55d18db7a13f6f73256ea57d70e7dd7a5a", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=b49771e392983b8aeed5bed9f510b72656544544", "patch": "@@ -54,7 +54,7 @@ impl Runtime for SimpleTask {\n         }\n         Local::put(cur_task);\n     }\n-    fn reawaken(mut ~self, mut to_wake: ~Task, _can_resched: bool) {\n+    fn reawaken(mut ~self, mut to_wake: ~Task) {\n         let me = &mut *self as *mut SimpleTask;\n         to_wake.put_runtime(self as ~Runtime);\n         unsafe {\n@@ -76,6 +76,7 @@ impl Runtime for SimpleTask {\n     }\n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> { None }\n     fn stack_bounds(&self) -> (uint, uint) { fail!() }\n+    fn can_block(&self) -> bool { true }\n     fn wrap(~self) -> ~Any { fail!() }\n }\n "}, {"sha": "4fb61f156809fb200051e6fa0d4477d55a90005f", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=b49771e392983b8aeed5bed9f510b72656544544", "patch": "@@ -376,7 +376,7 @@ impl Runtime for GreenTask {\n         }\n     }\n \n-    fn reawaken(mut ~self, to_wake: ~Task, can_resched: bool) {\n+    fn reawaken(mut ~self, to_wake: ~Task) {\n         self.put_task(to_wake);\n         assert!(self.sched.is_none());\n \n@@ -409,15 +409,10 @@ impl Runtime for GreenTask {\n         match running_task.maybe_take_runtime::<GreenTask>() {\n             Some(mut running_green_task) => {\n                 running_green_task.put_task(running_task);\n-                let mut sched = running_green_task.sched.take_unwrap();\n+                let sched = running_green_task.sched.take_unwrap();\n \n                 if sched.pool_id == self.pool_id {\n-                    if can_resched {\n-                        sched.run_task(running_green_task, self);\n-                    } else {\n-                        sched.enqueue_task(self);\n-                        running_green_task.put_with_sched(sched);\n-                    }\n+                    sched.run_task(running_green_task, self);\n                 } else {\n                     self.reawaken_remotely();\n \n@@ -462,6 +457,8 @@ impl Runtime for GreenTask {\n          c.current_stack_segment.end() as uint)\n     }\n \n+    fn can_block(&self) -> bool { false }\n+\n     fn wrap(~self) -> ~Any { self as ~Any }\n }\n "}, {"sha": "c08e326d903312d80c3561be816e328bc128cfbc", "filename": "src/libnative/task.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=b49771e392983b8aeed5bed9f510b72656544544", "patch": "@@ -143,6 +143,8 @@ impl rt::Runtime for Ops {\n \n     fn stack_bounds(&self) -> (uint, uint) { self.stack_bounds }\n \n+    fn can_block(&self) -> bool { true }\n+\n     // This function gets a little interesting. There are a few safety and\n     // ownership violations going on here, but this is all done in the name of\n     // shared state. Additionally, all of the violations are protected with a\n@@ -231,7 +233,7 @@ impl rt::Runtime for Ops {\n \n     // See the comments on `deschedule` for why the task is forgotten here, and\n     // why it's valid to do so.\n-    fn reawaken(mut ~self, mut to_wake: ~Task, _can_resched: bool) {\n+    fn reawaken(mut ~self, mut to_wake: ~Task) {\n         unsafe {\n             let me = &mut *self as *mut Ops;\n             to_wake.put_runtime(self as ~rt::Runtime);"}, {"sha": "30e02b168ca57e8af4e7f5da7453cd6e3dc81d42", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=b49771e392983b8aeed5bed9f510b72656544544", "patch": "@@ -122,7 +122,7 @@ mod test {\n                     }\n                 }\n             };\n-            let _ = task.wake().map(|t| t.reawaken(true));\n+            let _ = task.wake().map(|t| t.reawaken());\n         }\n     }\n "}, {"sha": "39d6f851e1722546867365a4ff5e3dc6a5609396", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=b49771e392983b8aeed5bed9f510b72656544544", "patch": "@@ -208,7 +208,7 @@ fn wait_until_woken_after(slot: *mut Option<BlockedTask>, f: ||) {\n \n fn wakeup(slot: &mut Option<BlockedTask>) {\n     assert!(slot.is_some());\n-    let _ = slot.take_unwrap().wake().map(|t| t.reawaken(true));\n+    let _ = slot.take_unwrap().wake().map(|t| t.reawaken());\n }\n \n pub struct Request {"}, {"sha": "358582d436b32ec3c162ee7768adcea81ed19adc", "filename": "src/librustuv/queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=b49771e392983b8aeed5bed9f510b72656544544", "patch": "@@ -67,7 +67,7 @@ extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n     loop {\n         match state.consumer.pop() {\n             mpsc::Data(Task(task)) => {\n-                let _ = task.wake().map(|t| t.reawaken(true));\n+                let _ = task.wake().map(|t| t.reawaken());\n             }\n             mpsc::Data(Increment) => unsafe {\n                 if state.refcnt == 0 {"}, {"sha": "0363cab247d1536081a67660a9a11e364beaaeec", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=b49771e392983b8aeed5bed9f510b72656544544", "patch": "@@ -138,7 +138,7 @@ extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n \n     match timer.action.take_unwrap() {\n         WakeTask(task) => {\n-            let _ = task.wake().map(|t| t.reawaken(true));\n+            let _ = task.wake().map(|t| t.reawaken());\n         }\n         SendOnce(chan) => { let _ = chan.try_send(()); }\n         SendMany(chan, id) => {"}, {"sha": "366c268fae2b95094beab927cf02ca7a11403589", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=b49771e392983b8aeed5bed9f510b72656544544", "patch": "@@ -443,9 +443,9 @@ impl Packet {\n \n     // This function must have had at least an acquire fence before it to be\n     // properly called.\n-    fn wakeup(&mut self, can_resched: bool) {\n+    fn wakeup(&mut self) {\n         match self.to_wake.take_unwrap().wake() {\n-            Some(task) => task.reawaken(can_resched),\n+            Some(task) => task.reawaken(),\n             None => {}\n         }\n         self.selecting.store(false, Relaxed);\n@@ -519,7 +519,7 @@ impl Packet {\n         match self.channels.fetch_sub(1, SeqCst) {\n             1 => {\n                 match self.cnt.swap(DISCONNECTED, SeqCst) {\n-                    -1 => { self.wakeup(true); }\n+                    -1 => { self.wakeup(); }\n                     DISCONNECTED => {}\n                     n => { assert!(n >= 0); }\n                 }\n@@ -595,20 +595,14 @@ impl<T: Send> Chan<T> {\n     ///\n     /// Like `send`, this method will never block. If the failure of send cannot\n     /// be tolerated, then this method should be used instead.\n-    pub fn try_send(&self, t: T) -> bool { self.try(t, true) }\n-\n-    /// This function will not stick around for very long. The purpose of this\n-    /// function is to guarantee that no rescheduling is performed.\n-    pub fn try_send_deferred(&self, t: T) -> bool { self.try(t, false) }\n-\n-    fn try(&self, t: T, can_resched: bool) -> bool {\n+    pub fn try_send(&self, t: T) -> bool {\n         unsafe {\n             let this = cast::transmute_mut(self);\n             this.queue.push(t);\n             let packet = this.queue.packet();\n             match (*packet).increment() {\n                 // As described above, -1 == wakeup\n-                -1 => { (*packet).wakeup(can_resched); true }\n+                -1 => { (*packet).wakeup(); true }\n                 // Also as above, SPSC queues must be >= -2\n                 -2 => true,\n                 // We succeeded if we sent data\n@@ -623,7 +617,7 @@ impl<T: Send> Chan<T> {\n                 // the TLS overhead can be a bit much.\n                 n => {\n                     assert!(n >= 0);\n-                    if can_resched && n > 0 && n % RESCHED_FREQ == 0 {\n+                    if n > 0 && n % RESCHED_FREQ == 0 {\n                         let task: ~Task = Local::take();\n                         task.maybe_yield();\n                     }\n@@ -700,7 +694,7 @@ impl<T: Send> SharedChan<T> {\n \n             match (*packet).increment() {\n                 DISCONNECTED => {} // oh well, we tried\n-                -1 => { (*packet).wakeup(true); }\n+                -1 => { (*packet).wakeup(); }\n                 n => {\n                     if n > 0 && n % RESCHED_FREQ == 0 {\n                         let task: ~Task = Local::take();"}, {"sha": "55425eb2e7226d21f410910c9f8cb31309f5a2a1", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=b49771e392983b8aeed5bed9f510b72656544544", "patch": "@@ -146,14 +146,15 @@ pub trait Runtime {\n     fn maybe_yield(~self, cur_task: ~Task);\n     fn deschedule(~self, times: uint, cur_task: ~Task,\n                   f: |BlockedTask| -> Result<(), BlockedTask>);\n-    fn reawaken(~self, to_wake: ~Task, can_resched: bool);\n+    fn reawaken(~self, to_wake: ~Task);\n \n     // Miscellaneous calls which are very different depending on what context\n     // you're in.\n     fn spawn_sibling(~self, cur_task: ~Task, opts: TaskOpts, f: proc());\n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;\n     /// The (low, high) edges of the current stack.\n     fn stack_bounds(&self) -> (uint, uint); // (lo, hi)\n+    fn can_block(&self) -> bool;\n \n     // FIXME: This is a serious code smell and this should not exist at all.\n     fn wrap(~self) -> ~Any;"}, {"sha": "fbe82531f69778f48add0ca2860eba8e660dda5d", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49771e392983b8aeed5bed9f510b72656544544/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=b49771e392983b8aeed5bed9f510b72656544544", "patch": "@@ -250,9 +250,9 @@ impl Task {\n     /// Wakes up a previously blocked task, optionally specifiying whether the\n     /// current task can accept a change in scheduling. This function can only\n     /// be called on tasks that were previously blocked in `deschedule`.\n-    pub fn reawaken(mut ~self, can_resched: bool) {\n+    pub fn reawaken(mut ~self) {\n         let ops = self.imp.take_unwrap();\n-        ops.reawaken(self, can_resched);\n+        ops.reawaken(self);\n     }\n \n     /// Yields control of this task to another task. This function will\n@@ -283,6 +283,12 @@ impl Task {\n     pub fn stack_bounds(&self) -> (uint, uint) {\n         self.imp.get_ref().stack_bounds()\n     }\n+\n+    /// Returns whether it is legal for this task to block the OS thread that it\n+    /// is running on.\n+    pub fn can_block(&self) -> bool {\n+        self.imp.get_ref().can_block()\n+    }\n }\n \n impl Drop for Task {"}]}