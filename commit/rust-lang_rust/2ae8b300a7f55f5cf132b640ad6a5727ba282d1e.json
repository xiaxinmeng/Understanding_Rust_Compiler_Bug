{"sha": "2ae8b300a7f55f5cf132b640ad6a5727ba282d1e", "node_id": "C_kwDOAAsO6NoAKDJhZThiMzAwYTdmNTVmNWNmMTMyYjY0MGFkNmE1NzI3YmEyODJkMWU", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-04-13T04:36:13Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-08-08T01:52:25Z"}, "message": "Don't lint `unit_arg` when expanded from a proc-macro", "tree": {"sha": "892de0575566d59d2994dad95b9de2f4385fde7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/892de0575566d59d2994dad95b9de2f4385fde7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e", "html_url": "https://github.com/rust-lang/rust/commit/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5721ca9a13562f5168c6ba9f43dc19bb76c6f7bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5721ca9a13562f5168c6ba9f43dc19bb76c6f7bb", "html_url": "https://github.com/rust-lang/rust/commit/5721ca9a13562f5168c6ba9f43dc19bb76c6f7bb"}], "stats": {"total": 228, "additions": 195, "deletions": 33}, "files": [{"sha": "a74166c32d17cafb5c4753e6c0e7e406cd1440ca", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=2ae8b300a7f55f5cf132b640ad6a5727ba282d1e", "patch": "@@ -21,8 +21,8 @@ mod single_match;\n mod try_err;\n mod wild_in_or_pats;\n \n-use clippy_utils::source::{snippet_opt, span_starts_with, walk_span_to_context};\n-use clippy_utils::{higher, in_constant, meets_msrv, msrvs};\n+use clippy_utils::source::{snippet_opt, walk_span_to_context};\n+use clippy_utils::{higher, in_constant, is_span_match, meets_msrv, msrvs};\n use rustc_hir::{Arm, Expr, ExprKind, Local, MatchSource, Pat};\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -949,7 +949,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         let from_expansion = expr.span.from_expansion();\n \n         if let ExprKind::Match(ex, arms, source) = expr.kind {\n-            if source == MatchSource::Normal && !span_starts_with(cx, expr.span, \"match\") {\n+            if source == MatchSource::Normal && !is_span_match(cx, expr.span) {\n                 return;\n             }\n             if matches!(source, MatchSource::Normal | MatchSource::ForLoopDesugar) {"}, {"sha": "cd38720f72235136932f948987e8b06d786d4417", "filename": "clippy_lints/src/unit_types/unit_arg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs?ref=2ae8b300a7f55f5cf132b640ad6a5727ba282d1e", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::is_expr_from_proc_macro;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -44,7 +45,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                     }\n                 })\n                 .collect::<Vec<_>>();\n-            if !args_to_recover.is_empty() {\n+            if !args_to_recover.is_empty() && !is_expr_from_proc_macro(cx, expr) {\n                 lint_unit_args(cx, expr, &args_to_recover);\n             }\n         },"}, {"sha": "387bf72000848f455c78e91fd2bdd5e5fd60fd18", "filename": "clippy_utils/src/check_proc_macro.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs?ref=2ae8b300a7f55f5cf132b640ad6a5727ba282d1e", "patch": "@@ -0,0 +1,167 @@\n+//! This module handles checking if the span given is from a proc-macro or not.\n+//!\n+//! Proc-macros are capable of setting the span of every token they output to a few possible spans.\n+//! This includes spans we can detect easily as coming from a proc-macro (e.g. the call site\n+//! or the def site), and spans we can't easily detect as such (e.g. the span of any token\n+//! passed into the proc macro). This capability means proc-macros are capable of generating code\n+//! with a span that looks like it was written by the user, but which should not be linted by clippy\n+//! as it was generated by an external macro.\n+//!\n+//! That brings us to this module. The current approach is to determine a small bit of text which\n+//! must exist at both the start and the end of an item (e.g. an expression or a path) assuming the\n+//! code was written, and check if the span contains that text. Note this will only work correctly\n+//! if the span is not from a `macro_rules` based macro.\n+\n+use rustc_ast::ast::{IntTy, LitIntType, LitKind, StrStyle, UintTy};\n+use rustc_hir::{\n+    Block, BlockCheckMode, Closure, Destination, Expr, ExprKind, LoopSource, MatchSource, QPath, UnOp, UnsafeSource,\n+    YieldSource,\n+};\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::Session;\n+use rustc_span::{Span, Symbol};\n+\n+#[derive(Clone, Copy)]\n+enum Pat {\n+    Str(&'static str),\n+    Sym(Symbol),\n+    Num,\n+}\n+\n+/// Checks if the start and the end of the span's text matches the patterns. This will return false\n+/// if the span crosses multiple files or if source is not available.\n+fn span_matches_pat(sess: &Session, span: Span, start_pat: Pat, end_pat: Pat) -> bool {\n+    let pos = sess.source_map().lookup_byte_offset(span.lo());\n+    let Some(ref src) = pos.sf.src else {\n+        return false;\n+    };\n+    let end = span.hi() - pos.sf.start_pos;\n+    src.get(pos.pos.0 as usize..end.0 as usize).map_or(false, |s| {\n+        // Spans can be wrapped in a mixture or parenthesis, whitespace, and trailing commas.\n+        let start_str = s.trim_start_matches(|c: char| c.is_whitespace() || c == '(');\n+        let end_str = s.trim_end_matches(|c: char| c.is_whitespace() || c == ')' || c == ',');\n+        (match start_pat {\n+            Pat::Str(text) => start_str.starts_with(text),\n+            Pat::Sym(sym) => start_str.starts_with(sym.as_str()),\n+            Pat::Num => start_str.as_bytes().first().map_or(false, u8::is_ascii_digit),\n+        } && match end_pat {\n+            Pat::Str(text) => end_str.ends_with(text),\n+            Pat::Sym(sym) => end_str.ends_with(sym.as_str()),\n+            Pat::Num => end_str.as_bytes().last().map_or(false, u8::is_ascii_hexdigit),\n+        })\n+    })\n+}\n+\n+/// Get the search patterns to use for the given literal\n+fn lit_search_pat(lit: &LitKind) -> (Pat, Pat) {\n+    match lit {\n+        LitKind::Str(_, StrStyle::Cooked) => (Pat::Str(\"\\\"\"), Pat::Str(\"\\\"\")),\n+        LitKind::Str(_, StrStyle::Raw(0)) => (Pat::Str(\"r\"), Pat::Str(\"\\\"\")),\n+        LitKind::Str(_, StrStyle::Raw(_)) => (Pat::Str(\"r#\"), Pat::Str(\"#\")),\n+        LitKind::ByteStr(_) => (Pat::Str(\"b\\\"\"), Pat::Str(\"\\\"\")),\n+        LitKind::Byte(_) => (Pat::Str(\"b'\"), Pat::Str(\"'\")),\n+        LitKind::Char(_) => (Pat::Str(\"'\"), Pat::Str(\"'\")),\n+        LitKind::Int(_, LitIntType::Signed(IntTy::Isize)) => (Pat::Num, Pat::Str(\"isize\")),\n+        LitKind::Int(_, LitIntType::Unsigned(UintTy::Usize)) => (Pat::Num, Pat::Str(\"usize\")),\n+        LitKind::Int(..) => (Pat::Num, Pat::Num),\n+        LitKind::Float(..) => (Pat::Num, Pat::Str(\"\")),\n+        LitKind::Bool(true) => (Pat::Str(\"true\"), Pat::Str(\"true\")),\n+        LitKind::Bool(false) => (Pat::Str(\"false\"), Pat::Str(\"false\")),\n+        _ => (Pat::Str(\"\"), Pat::Str(\"\")),\n+    }\n+}\n+\n+/// Get the search patterns to use for the given path\n+fn qpath_search_pat(path: &QPath<'_>) -> (Pat, Pat) {\n+    match path {\n+        QPath::Resolved(ty, path) => {\n+            let start = if ty.is_some() {\n+                Pat::Str(\"<\")\n+            } else {\n+                path.segments\n+                    .first()\n+                    .map_or(Pat::Str(\"\"), |seg| Pat::Sym(seg.ident.name))\n+            };\n+            let end = path.segments.last().map_or(Pat::Str(\"\"), |seg| {\n+                if seg.args.is_some() {\n+                    Pat::Str(\">\")\n+                } else {\n+                    Pat::Sym(seg.ident.name)\n+                }\n+            });\n+            (start, end)\n+        },\n+        QPath::TypeRelative(_, name) => (Pat::Str(\"\"), Pat::Sym(name.ident.name)),\n+        QPath::LangItem(..) => (Pat::Str(\"\"), Pat::Str(\"\")),\n+    }\n+}\n+\n+/// Get the search patterns to use for the given expression\n+fn expr_search_pat(tcx: TyCtxt<'_>, e: &Expr<'_>) -> (Pat, Pat) {\n+    match e.kind {\n+        ExprKind::Box(e) => (Pat::Str(\"box\"), expr_search_pat(tcx, e).1),\n+        ExprKind::ConstBlock(_) => (Pat::Str(\"const\"), Pat::Str(\"}\")),\n+        ExprKind::Tup([]) => (Pat::Str(\")\"), Pat::Str(\"(\")),\n+        ExprKind::Unary(UnOp::Deref, _) => (Pat::Str(\"*\"), expr_search_pat(tcx, e).1),\n+        ExprKind::Unary(UnOp::Not, _) => (Pat::Str(\"!\"), expr_search_pat(tcx, e).1),\n+        ExprKind::Unary(UnOp::Neg, _) => (Pat::Str(\"-\"), expr_search_pat(tcx, e).1),\n+        ExprKind::Lit(ref lit) => lit_search_pat(&lit.node),\n+        ExprKind::Array(_) | ExprKind::Repeat(..) => (Pat::Str(\"[\"), Pat::Str(\"]\")),\n+        ExprKind::Call(e, []) | ExprKind::MethodCall(_, [e], _) => (expr_search_pat(tcx, e).0, Pat::Str(\"(\")),\n+        ExprKind::Call(first, [.., last])\n+        | ExprKind::MethodCall(_, [first, .., last], _)\n+        | ExprKind::Binary(_, first, last)\n+        | ExprKind::Tup([first, .., last])\n+        | ExprKind::Assign(first, last, _)\n+        | ExprKind::AssignOp(_, first, last) => (expr_search_pat(tcx, first).0, expr_search_pat(tcx, last).1),\n+        ExprKind::Tup([e]) | ExprKind::DropTemps(e) => expr_search_pat(tcx, e),\n+        ExprKind::Cast(e, _) | ExprKind::Type(e, _) => (expr_search_pat(tcx, e).0, Pat::Str(\"\")),\n+        ExprKind::Let(let_expr) => (Pat::Str(\"let\"), expr_search_pat(tcx, let_expr.init).1),\n+        ExprKind::If(..) => (Pat::Str(\"if\"), Pat::Str(\"}\")),\n+        ExprKind::Loop(_, Some(_), _, _) | ExprKind::Block(_, Some(_)) => (Pat::Str(\"'\"), Pat::Str(\"}\")),\n+        ExprKind::Loop(_, None, LoopSource::Loop, _) => (Pat::Str(\"loop\"), Pat::Str(\"}\")),\n+        ExprKind::Loop(_, None, LoopSource::While, _) => (Pat::Str(\"while\"), Pat::Str(\"}\")),\n+        ExprKind::Loop(_, None, LoopSource::ForLoop, _) | ExprKind::Match(_, _, MatchSource::ForLoopDesugar) => {\n+            (Pat::Str(\"for\"), Pat::Str(\"}\"))\n+        },\n+        ExprKind::Match(_, _, MatchSource::Normal) => (Pat::Str(\"match\"), Pat::Str(\"}\")),\n+        ExprKind::Match(e, _, MatchSource::TryDesugar) => (expr_search_pat(tcx, e).0, Pat::Str(\"?\")),\n+        ExprKind::Match(e, _, MatchSource::AwaitDesugar) | ExprKind::Yield(e, YieldSource::Await { .. }) => {\n+            (expr_search_pat(tcx, e).0, Pat::Str(\"await\"))\n+        },\n+        ExprKind::Closure(&Closure { body, .. }) => (Pat::Str(\"\"), expr_search_pat(tcx, &tcx.hir().body(body).value).1),\n+        ExprKind::Block(\n+            Block {\n+                rules: BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n+                ..\n+            },\n+            None,\n+        ) => (Pat::Str(\"unsafe\"), Pat::Str(\"}\")),\n+        ExprKind::Block(_, None) => (Pat::Str(\"{\"), Pat::Str(\"}\")),\n+        ExprKind::Field(e, name) => (expr_search_pat(tcx, e).0, Pat::Sym(name.name)),\n+        ExprKind::Index(e, _) => (expr_search_pat(tcx, e).0, Pat::Str(\"]\")),\n+        ExprKind::Path(ref path) => qpath_search_pat(path),\n+        ExprKind::AddrOf(_, _, e) => (Pat::Str(\"&\"), expr_search_pat(tcx, e).1),\n+        ExprKind::Break(Destination { label: None, .. }, None) => (Pat::Str(\"break\"), Pat::Str(\"break\")),\n+        ExprKind::Break(Destination { label: Some(name), .. }, None) => (Pat::Str(\"break\"), Pat::Sym(name.ident.name)),\n+        ExprKind::Break(_, Some(e)) => (Pat::Str(\"break\"), expr_search_pat(tcx, e).1),\n+        ExprKind::Continue(Destination { label: None, .. }) => (Pat::Str(\"continue\"), Pat::Str(\"continue\")),\n+        ExprKind::Continue(Destination { label: Some(name), .. }) => (Pat::Str(\"continue\"), Pat::Sym(name.ident.name)),\n+        ExprKind::Ret(None) => (Pat::Str(\"return\"), Pat::Str(\"return\")),\n+        ExprKind::Struct(path, _, _) => (qpath_search_pat(path).0, Pat::Str(\"}\")),\n+        ExprKind::Yield(e, YieldSource::Yield) => (Pat::Str(\"yield\"), expr_search_pat(tcx, e).1),\n+        _ => (Pat::Str(\"\"), Pat::Str(\"\")),\n+    }\n+}\n+\n+/// Checks if the expression likely came from a proc-macro\n+pub fn is_expr_from_proc_macro(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    let (start_pat, end_pat) = expr_search_pat(cx.tcx, e);\n+    !span_matches_pat(cx.sess(), e.span, start_pat, end_pat)\n+}\n+\n+/// Checks if the span actually refers to a match expression\n+pub fn is_span_match(cx: &LateContext<'_>, span: Span) -> bool {\n+    span_matches_pat(cx.sess(), span, Pat::Str(\"match\"), Pat::Str(\"}\"))\n+}"}, {"sha": "2d051e3a8157cf265bc6e57a6cabe337861aaac1", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=2ae8b300a7f55f5cf132b640ad6a5727ba282d1e", "patch": "@@ -38,6 +38,7 @@ pub mod sym_helper;\n \n pub mod ast_utils;\n pub mod attrs;\n+mod check_proc_macro;\n pub mod comparisons;\n pub mod consts;\n pub mod diagnostics;\n@@ -58,6 +59,7 @@ pub mod usage;\n pub mod visitors;\n \n pub use self::attrs::*;\n+pub use self::check_proc_macro::{is_expr_from_proc_macro, is_span_match};\n pub use self::hir_utils::{\n     both, count_eq, eq_expr_value, hash_expr, hash_stmt, over, HirEqInterExpr, SpanlessEq, SpanlessHash,\n };"}, {"sha": "d85f591fb9a42f0c087f61dfe95da170d65db5aa", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=2ae8b300a7f55f5cf132b640ad6a5727ba282d1e", "patch": "@@ -11,24 +11,6 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::{BytePos, Pos, Span, SpanData, SyntaxContext};\n use std::borrow::Cow;\n \n-/// Checks if the span starts with the given text. This will return false if the span crosses\n-/// multiple files or if source is not available.\n-///\n-/// This is used to check for proc macros giving unhelpful spans to things.\n-pub fn span_starts_with<T: LintContext>(cx: &T, span: Span, text: &str) -> bool {\n-    fn helper(sm: &SourceMap, span: Span, text: &str) -> bool {\n-        let pos = sm.lookup_byte_offset(span.lo());\n-        let Some(ref src) = pos.sf.src else {\n-            return false;\n-        };\n-        let end = span.hi() - pos.sf.start_pos;\n-        src.get(pos.pos.0 as usize..end.0 as usize)\n-            // Expression spans can include wrapping parenthesis. Remove them first.\n-            .map_or(false, |s| s.trim_start_matches('(').starts_with(text))\n-    }\n-    helper(cx.sess().source_map(), span, text)\n-}\n-\n /// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n /// Also takes an `Option<String>` which can be put inside the braces.\n pub fn expr_block<'a, T: LintContext>("}, {"sha": "7bf3adc07ac5645dcecf0abbc88a5743cf416103", "filename": "tests/ui/unit_arg.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/tests%2Fui%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/tests%2Fui%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.rs?ref=2ae8b300a7f55f5cf132b640ad6a5727ba282d1e", "patch": "@@ -1,3 +1,5 @@\n+// aux-build: proc_macro_with_span.rs\n+\n #![warn(clippy::unit_arg)]\n #![allow(\n     clippy::no_effect,\n@@ -8,9 +10,13 @@\n     clippy::or_fun_call,\n     clippy::needless_question_mark,\n     clippy::self_named_constructors,\n-    clippy::let_unit_value\n+    clippy::let_unit_value,\n+    clippy::never_loop\n )]\n \n+extern crate proc_macro_with_span;\n+\n+use proc_macro_with_span::with_span;\n use std::fmt::Debug;\n \n fn foo<T: Debug>(t: T) {\n@@ -127,6 +133,10 @@ fn returning_expr() -> Option<()> {\n \n fn taking_multiple_units(a: (), b: ()) {}\n \n+fn proc_macro() {\n+    with_span!(span taking_multiple_units(unsafe { (); }, 'x: loop { break 'x (); }));\n+}\n+\n fn main() {\n     bad();\n     ok();"}, {"sha": "1de9d44bb0d6ea80251502616e5843d835d8264a", "filename": "tests/ui/unit_arg.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/tests%2Fui%2Funit_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ae8b300a7f55f5cf132b640ad6a5727ba282d1e/tests%2Fui%2Funit_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.stderr?ref=2ae8b300a7f55f5cf132b640ad6a5727ba282d1e", "patch": "@@ -1,5 +1,5 @@\n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:57:5\n+  --> $DIR/unit_arg.rs:63:5\n    |\n LL | /     foo({\n LL | |         1;\n@@ -20,7 +20,7 @@ LL ~     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:60:5\n+  --> $DIR/unit_arg.rs:66:5\n    |\n LL |     foo(foo(1));\n    |     ^^^^^^^^^^^\n@@ -32,7 +32,7 @@ LL ~     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:61:5\n+  --> $DIR/unit_arg.rs:67:5\n    |\n LL | /     foo({\n LL | |         foo(1);\n@@ -54,7 +54,7 @@ LL ~     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:66:5\n+  --> $DIR/unit_arg.rs:72:5\n    |\n LL | /     b.bar({\n LL | |         1;\n@@ -74,7 +74,7 @@ LL ~     b.bar(());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:69:5\n+  --> $DIR/unit_arg.rs:75:5\n    |\n LL |     taking_multiple_units(foo(0), foo(1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -87,7 +87,7 @@ LL ~     taking_multiple_units((), ());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:70:5\n+  --> $DIR/unit_arg.rs:76:5\n    |\n LL | /     taking_multiple_units(foo(0), {\n LL | |         foo(1);\n@@ -110,7 +110,7 @@ LL ~     taking_multiple_units((), ());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:74:5\n+  --> $DIR/unit_arg.rs:80:5\n    |\n LL | /     taking_multiple_units(\n LL | |         {\n@@ -146,7 +146,7 @@ LL ~     );\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:85:13\n+  --> $DIR/unit_arg.rs:91:13\n    |\n LL |     None.or(Some(foo(2)));\n    |             ^^^^^^^^^^^^\n@@ -160,7 +160,7 @@ LL ~     });\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:88:5\n+  --> $DIR/unit_arg.rs:94:5\n    |\n LL |     foo(foo(()));\n    |     ^^^^^^^^^^^^\n@@ -172,7 +172,7 @@ LL ~     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:125:5\n+  --> $DIR/unit_arg.rs:131:5\n    |\n LL |     Some(foo(1))\n    |     ^^^^^^^^^^^^"}]}