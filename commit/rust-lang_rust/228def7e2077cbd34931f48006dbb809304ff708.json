{"sha": "228def7e2077cbd34931f48006dbb809304ff708", "node_id": "C_kwDOAAsO6NoAKDIyOGRlZjdlMjA3N2NiZDM0OTMxZjQ4MDA2ZGJiODA5MzA0ZmY3MDg", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-01T14:05:42Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-18T14:56:30Z"}, "message": "Extract AssocItem handling.", "tree": {"sha": "7875a5bcb7f1e8ce8eed9dcde5c976a203d343af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7875a5bcb7f1e8ce8eed9dcde5c976a203d343af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/228def7e2077cbd34931f48006dbb809304ff708", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/228def7e2077cbd34931f48006dbb809304ff708", "html_url": "https://github.com/rust-lang/rust/commit/228def7e2077cbd34931f48006dbb809304ff708", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/228def7e2077cbd34931f48006dbb809304ff708/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdcc53b7dc002ea4a7a28105010c5a1126ee31b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdcc53b7dc002ea4a7a28105010c5a1126ee31b7", "html_url": "https://github.com/rust-lang/rust/commit/cdcc53b7dc002ea4a7a28105010c5a1126ee31b7"}], "stats": {"total": 297, "additions": 131, "deletions": 166}, "files": [{"sha": "b520c155fa22c4696ec7fe851fcc630bb2279603", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 131, "deletions": 166, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/228def7e2077cbd34931f48006dbb809304ff708/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228def7e2077cbd34931f48006dbb809304ff708/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=228def7e2077cbd34931f48006dbb809304ff708", "patch": "@@ -1732,72 +1732,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                             |this| {\n                                 this.visit_generics(generics);\n                                 walk_list!(this, visit_param_bound, bounds, BoundKind::SuperTraits);\n-\n-                                let walk_assoc_item =\n-                                    |this: &mut Self,\n-                                     generics: &Generics,\n-                                     kind,\n-                                     item: &'ast AssocItem| {\n-                                        this.with_generic_param_rib(\n-                                            &generics.params,\n-                                            AssocItemRibKind,\n-                                            LifetimeRibKind::Generics {\n-                                                binder: item.id,\n-                                                span: generics.span,\n-                                                kind,\n-                                            },\n-                                            |this| {\n-                                                visit::walk_assoc_item(this, item, AssocCtxt::Trait)\n-                                            },\n-                                        );\n-                                    };\n-\n-                                this.with_trait_items(items, |this| {\n-                                    for item in items {\n-                                        match &item.kind {\n-                                            AssocItemKind::Const(_, ty, default) => {\n-                                                this.visit_ty(ty);\n-                                                // Only impose the restrictions of `ConstRibKind` for an\n-                                                // actual constant expression in a provided default.\n-                                                if let Some(expr) = default {\n-                                                    // We allow arbitrary const expressions inside of associated consts,\n-                                                    // even if they are potentially not const evaluatable.\n-                                                    //\n-                                                    // Type parameters can already be used and as associated consts are\n-                                                    // not used as part of the type system, this is far less surprising.\n-                                                    this.with_constant_rib(\n-                                                        IsRepeatExpr::No,\n-                                                        HasGenericParams::Yes,\n-                                                        None,\n-                                                        |this| this.visit_expr(expr),\n-                                                    );\n-                                                }\n-                                            }\n-                                            AssocItemKind::Fn(box Fn { generics, .. }) => {\n-                                                walk_assoc_item(\n-                                                    this,\n-                                                    generics,\n-                                                    LifetimeBinderKind::Function,\n-                                                    item,\n-                                                );\n-                                            }\n-                                            AssocItemKind::TyAlias(box TyAlias {\n-                                                generics,\n-                                                ..\n-                                            }) => {\n-                                                walk_assoc_item(\n-                                                    this,\n-                                                    generics,\n-                                                    LifetimeBinderKind::Item,\n-                                                    item,\n-                                                );\n-                                            }\n-                                            AssocItemKind::MacCall(_) => {\n-                                                panic!(\"unexpanded macro in resolve!\")\n-                                            }\n-                                        };\n-                                    }\n-                                });\n+                                this.resolve_trait_items(items);\n                             },\n                         );\n                     },\n@@ -2073,16 +2008,53 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     /// When evaluating a `trait` use its associated types' idents for suggestions in E0412.\n-    fn with_trait_items<T>(\n-        &mut self,\n-        trait_items: &'ast [P<AssocItem>],\n-        f: impl FnOnce(&mut Self) -> T,\n-    ) -> T {\n+    fn resolve_trait_items(&mut self, trait_items: &'ast [P<AssocItem>]) {\n         let trait_assoc_items =\n             replace(&mut self.diagnostic_metadata.current_trait_assoc_items, Some(&trait_items));\n-        let result = f(self);\n+\n+        let walk_assoc_item =\n+            |this: &mut Self, generics: &Generics, kind, item: &'ast AssocItem| {\n+                this.with_generic_param_rib(\n+                    &generics.params,\n+                    AssocItemRibKind,\n+                    LifetimeRibKind::Generics { binder: item.id, span: generics.span, kind },\n+                    |this| visit::walk_assoc_item(this, item, AssocCtxt::Trait),\n+                );\n+            };\n+\n+        for item in trait_items {\n+            match &item.kind {\n+                AssocItemKind::Const(_, ty, default) => {\n+                    self.visit_ty(ty);\n+                    // Only impose the restrictions of `ConstRibKind` for an\n+                    // actual constant expression in a provided default.\n+                    if let Some(expr) = default {\n+                        // We allow arbitrary const expressions inside of associated consts,\n+                        // even if they are potentially not const evaluatable.\n+                        //\n+                        // Type parameters can already be used and as associated consts are\n+                        // not used as part of the type system, this is far less surprising.\n+                        self.with_constant_rib(\n+                            IsRepeatExpr::No,\n+                            HasGenericParams::Yes,\n+                            None,\n+                            |this| this.visit_expr(expr),\n+                        );\n+                    }\n+                }\n+                AssocItemKind::Fn(box Fn { generics, .. }) => {\n+                    walk_assoc_item(self, generics, LifetimeBinderKind::Function, item);\n+                }\n+                AssocItemKind::TyAlias(box TyAlias { generics, .. }) => {\n+                    walk_assoc_item(self, generics, LifetimeBinderKind::Item, item);\n+                }\n+                AssocItemKind::MacCall(_) => {\n+                    panic!(\"unexpanded macro in resolve!\")\n+                }\n+            };\n+        }\n+\n         self.diagnostic_metadata.current_trait_assoc_items = trait_assoc_items;\n-        result\n     }\n \n     /// This is called to resolve a trait reference from an `impl` (i.e., `impl Trait for Foo`).\n@@ -2173,99 +2145,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                         this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n                                             debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n                                             for item in impl_items {\n-                                                use crate::ResolutionError::*;\n-                                                match &item.kind {\n-                                                    AssocItemKind::Const(_default, _ty, _expr) => {\n-                                                        debug!(\"resolve_implementation AssocItemKind::Const\");\n-                                                        // If this is a trait impl, ensure the const\n-                                                        // exists in trait\n-                                                        this.check_trait_item(\n-                                                            item.id,\n-                                                            item.ident,\n-                                                            &item.kind,\n-                                                            ValueNS,\n-                                                            item.span,\n-                                                            |i, s, c| ConstNotMemberOfTrait(i, s, c),\n-                                                        );\n-\n-                                                        // We allow arbitrary const expressions inside of associated consts,\n-                                                        // even if they are potentially not const evaluatable.\n-                                                        //\n-                                                        // Type parameters can already be used and as associated consts are\n-                                                        // not used as part of the type system, this is far less surprising.\n-                                                        this.with_constant_rib(\n-                                                            IsRepeatExpr::No,\n-                                                            HasGenericParams::Yes,\n-                                                            None,\n-                                                            |this| {\n-                                                                visit::walk_assoc_item(\n-                                                                    this,\n-                                                                    item,\n-                                                                    AssocCtxt::Impl,\n-                                                                )\n-                                                            },\n-                                                        );\n-                                                    }\n-                                                    AssocItemKind::Fn(box Fn { generics, .. }) => {\n-                                                        debug!(\"resolve_implementation AssocItemKind::Fn\");\n-                                                        // We also need a new scope for the impl item type parameters.\n-                                                        this.with_generic_param_rib(\n-                                                            &generics.params,\n-                                                            AssocItemRibKind,\n-                                                            LifetimeRibKind::Generics { binder: item.id, span: generics.span, kind: LifetimeBinderKind::Function },\n-                                                            |this| {\n-                                                                // If this is a trait impl, ensure the method\n-                                                                // exists in trait\n-                                                                this.check_trait_item(\n-                                                                    item.id,\n-                                                                    item.ident,\n-                                                                    &item.kind,\n-                                                                    ValueNS,\n-                                                                    item.span,\n-                                                                    |i, s, c| MethodNotMemberOfTrait(i, s, c),\n-                                                                );\n-\n-                                                                visit::walk_assoc_item(\n-                                                                    this,\n-                                                                    item,\n-                                                                    AssocCtxt::Impl,\n-                                                                )\n-                                                            },\n-                                                        );\n-                                                    }\n-                                                    AssocItemKind::TyAlias(box TyAlias {\n-                                                        generics, ..\n-                                                    }) => {\n-                                                        debug!(\"resolve_implementation AssocItemKind::TyAlias\");\n-                                                        // We also need a new scope for the impl item type parameters.\n-                                                        this.with_generic_param_rib(\n-                                                            &generics.params,\n-                                                            AssocItemRibKind,\n-                                                            LifetimeRibKind::Generics { binder: item.id, span: generics.span, kind: LifetimeBinderKind::Item },\n-                                                            |this| {\n-                                                                // If this is a trait impl, ensure the type\n-                                                                // exists in trait\n-                                                                this.check_trait_item(\n-                                                                    item.id,\n-                                                                    item.ident,\n-                                                                    &item.kind,\n-                                                                    TypeNS,\n-                                                                    item.span,\n-                                                                    |i, s, c| TypeNotMemberOfTrait(i, s, c),\n-                                                                );\n-\n-                                                                visit::walk_assoc_item(\n-                                                                    this,\n-                                                                    item,\n-                                                                    AssocCtxt::Impl,\n-                                                                )\n-                                                            },\n-                                                        );\n-                                                    }\n-                                                    AssocItemKind::MacCall(_) => {\n-                                                        panic!(\"unexpanded macro in resolve!\")\n-                                                    }\n-                                                }\n+                                                this.resolve_impl_item(&**item);\n                                             }\n                                         });\n                                     });\n@@ -2278,6 +2158,91 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         });\n     }\n \n+    fn resolve_impl_item(&mut self, item: &'ast AssocItem) {\n+        use crate::ResolutionError::*;\n+        match &item.kind {\n+            AssocItemKind::Const(_default, _ty, _expr) => {\n+                debug!(\"resolve_implementation AssocItemKind::Const\");\n+                // If this is a trait impl, ensure the const\n+                // exists in trait\n+                self.check_trait_item(\n+                    item.id,\n+                    item.ident,\n+                    &item.kind,\n+                    ValueNS,\n+                    item.span,\n+                    |i, s, c| ConstNotMemberOfTrait(i, s, c),\n+                );\n+\n+                // We allow arbitrary const expressions inside of associated consts,\n+                // even if they are potentially not const evaluatable.\n+                //\n+                // Type parameters can already be used and as associated consts are\n+                // not used as part of the type system, this is far less surprising.\n+                self.with_constant_rib(IsRepeatExpr::No, HasGenericParams::Yes, None, |this| {\n+                    visit::walk_assoc_item(this, item, AssocCtxt::Impl)\n+                });\n+            }\n+            AssocItemKind::Fn(box Fn { generics, .. }) => {\n+                debug!(\"resolve_implementation AssocItemKind::Fn\");\n+                // We also need a new scope for the impl item type parameters.\n+                self.with_generic_param_rib(\n+                    &generics.params,\n+                    AssocItemRibKind,\n+                    LifetimeRibKind::Generics {\n+                        binder: item.id,\n+                        span: generics.span,\n+                        kind: LifetimeBinderKind::Function,\n+                    },\n+                    |this| {\n+                        // If this is a trait impl, ensure the method\n+                        // exists in trait\n+                        this.check_trait_item(\n+                            item.id,\n+                            item.ident,\n+                            &item.kind,\n+                            ValueNS,\n+                            item.span,\n+                            |i, s, c| MethodNotMemberOfTrait(i, s, c),\n+                        );\n+\n+                        visit::walk_assoc_item(this, item, AssocCtxt::Impl)\n+                    },\n+                );\n+            }\n+            AssocItemKind::TyAlias(box TyAlias { generics, .. }) => {\n+                debug!(\"resolve_implementation AssocItemKind::TyAlias\");\n+                // We also need a new scope for the impl item type parameters.\n+                self.with_generic_param_rib(\n+                    &generics.params,\n+                    AssocItemRibKind,\n+                    LifetimeRibKind::Generics {\n+                        binder: item.id,\n+                        span: generics.span,\n+                        kind: LifetimeBinderKind::Item,\n+                    },\n+                    |this| {\n+                        // If this is a trait impl, ensure the type\n+                        // exists in trait\n+                        this.check_trait_item(\n+                            item.id,\n+                            item.ident,\n+                            &item.kind,\n+                            TypeNS,\n+                            item.span,\n+                            |i, s, c| TypeNotMemberOfTrait(i, s, c),\n+                        );\n+\n+                        visit::walk_assoc_item(this, item, AssocCtxt::Impl)\n+                    },\n+                );\n+            }\n+            AssocItemKind::MacCall(_) => {\n+                panic!(\"unexpanded macro in resolve!\")\n+            }\n+        }\n+    }\n+\n     fn check_trait_item<F>(\n         &mut self,\n         id: NodeId,"}]}