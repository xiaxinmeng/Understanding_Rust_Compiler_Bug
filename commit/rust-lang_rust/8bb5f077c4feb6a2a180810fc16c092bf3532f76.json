{"sha": "8bb5f077c4feb6a2a180810fc16c092bf3532f76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYjVmMDc3YzRmZWI2YTJhMTgwODEwZmMxNmMwOTJiZjM1MzJmNzY=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-13T17:55:01Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-13T23:20:23Z"}, "message": "Comments describing the packet structures for pipes.", "tree": {"sha": "32d14cd7a0c4c87b1002d0997c9d386ce80e90f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32d14cd7a0c4c87b1002d0997c9d386ce80e90f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bb5f077c4feb6a2a180810fc16c092bf3532f76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb5f077c4feb6a2a180810fc16c092bf3532f76", "html_url": "https://github.com/rust-lang/rust/commit/8bb5f077c4feb6a2a180810fc16c092bf3532f76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bb5f077c4feb6a2a180810fc16c092bf3532f76/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e311836140f86582501550da249c1df70427ab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e311836140f86582501550da249c1df70427ab4", "html_url": "https://github.com/rust-lang/rust/commit/6e311836140f86582501550da249c1df70427ab4"}], "stats": {"total": 46, "additions": 30, "deletions": 16}, "files": [{"sha": "6a4c09f8473cefcbc877d4ff73be5c047f228c50", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8bb5f077c4feb6a2a180810fc16c092bf3532f76/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb5f077c4feb6a2a180810fc16c092bf3532f76/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=8bb5f077c4feb6a2a180810fc16c092bf3532f76", "patch": "@@ -35,26 +35,40 @@ syntax extension. To see how that works, it is best see comments in\n libsyntax/ext/pipes.rs.\n \n This module includes two related pieces of the runtime\n-implementation. There is support for unbounded and bounded\n+implementation: support for unbounded and bounded\n protocols. The main difference between the two is the type of the\n buffer that is carried along in the endpoint data structures.\n \n-FIXME (#3072) - This is still incomplete\n \n-\n-\n-## Invariants\n-\n-This section attempts to document the invariants that must hold to\n-avoid races. These primarily deal with the state and blocked_task\n-fields on packet_headers.\n-\n-1. If the sender reads a some(task) out of blocked_task, then the task\n-that is pointed there will remain live for any events that the sender\n-might signal.\n-\n-2. The sender may only read the blocked_task field if it first ensures\n-that the packet's state field is blocked.\n+The heart of the implementation is the packet type. It contains a\n+header and a payload field. Much of the code in this module deals with\n+the header field. This is where the synchronization information is\n+stored. In the case of a bounded protocol, the header also includes a\n+pointer to the buffer the packet is contained in.\n+\n+Packets represent a single message in a protocol. The payload field\n+gets instatiated at the type of the message, which is usually an enum\n+generated by the pipe compiler. Packets are conceptually single use,\n+although in bounded protocols they are reused each time around the\n+loop.\n+\n+\n+Packets are usually handled through a send_packet_buffered or\n+recv_packet_buffered object. Each packet is referenced by one\n+send_packet and one recv_packet, and these wrappers enforce that only\n+one end can send and only one end can receive. The structs also\n+include a destructor that marks packets are terminated if the sender\n+or receiver destroys the object before sending or receiving a value.\n+\n+The *_packet_buffered structs take two type parameters. The first is\n+the message type for the current packet (or state). The second\n+represents the type of the whole buffer. For bounded protocols, the\n+protocol compiler generates a struct with a field for each protocol\n+state. This generated struct is used as the buffer type parameter. For\n+unbounded protocols, the buffer is simply one packet, so there is a\n+shorthand struct called send_packet and recv_packet, where the buffer\n+type is just `packet<T>`. Using the same underlying structure for both\n+bounded and unbounded protocols allows for less code duplication.\n \n */\n "}]}