{"sha": "d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0YTY2ZTliMDk4ZTNjMzIyMTYxZjAzOTdlOTMyY2Y2ZDNjMWIxNWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-08T10:27:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-08T10:27:58Z"}, "message": "Auto merge of #21970 - michaelwoerister:lang-item-call-debug-locs, r=brson\n\nResolves some issues caused by the recent LLVM update (which itself solved some issues).\r\n\r\nCloses #19848\r\nCloses #20798", "tree": {"sha": "c98c50c1214e23ae179ad56551e0f128dcca4c60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c98c50c1214e23ae179ad56551e0f128dcca4c60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "html_url": "https://github.com/rust-lang/rust/commit/d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4f9ec566249f88845c88c8b897097a262b4e0af", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4f9ec566249f88845c88c8b897097a262b4e0af", "html_url": "https://github.com/rust-lang/rust/commit/d4f9ec566249f88845c88c8b897097a262b4e0af"}, {"sha": "93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f", "html_url": "https://github.com/rust-lang/rust/commit/93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f"}], "stats": {"total": 700, "additions": 499, "deletions": 201}, "files": [{"sha": "7ac690f02e1b585c7c21391113a760967ffd7f38", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 53, "deletions": 12, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -28,14 +28,15 @@ use std::iter::{range_inclusive, AdditiveIterator, FromIterator, repeat};\n use std::num::Float;\n use std::slice;\n use syntax::ast::{self, DUMMY_NODE_ID, NodeId, Pat};\n-use syntax::ast_util::walk_pat;\n+use syntax::ast_util;\n use syntax::codemap::{Span, Spanned, DUMMY_SP};\n use syntax::fold::{Folder, noop_fold_pat};\n use syntax::print::pprust::pat_to_string;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor, FnKind};\n use util::ppaux::ty_to_string;\n+use util::nodemap::FnvHashMap;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n@@ -171,7 +172,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 }\n             }\n \n-            let mut static_inliner = StaticInliner::new(cx.tcx);\n+            let mut static_inliner = StaticInliner::new(cx.tcx, None);\n             let inlined_arms = arms.iter().map(|arm| {\n                 (arm.pats.iter().map(|pat| {\n                     static_inliner.fold_pat((*pat).clone())\n@@ -235,7 +236,7 @@ fn is_expr_const_nan(tcx: &ty::ctxt, expr: &ast::Expr) -> bool {\n }\n \n fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat) {\n-    walk_pat(pat, |p| {\n+    ast_util::walk_pat(pat, |p| {\n         match p.node {\n             ast::PatIdent(ast::BindByValue(ast::MutImmutable), ident, None) => {\n                 let pat_ty = ty::pat_ty(cx.tcx, p);\n@@ -266,7 +267,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n \n // Check that we do not match against a static NaN (#6804)\n fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n-    walk_pat(pat, |p| {\n+    ast_util::walk_pat(pat, |p| {\n         match p.node {\n             ast::PatLit(ref expr) if is_expr_const_nan(cx.tcx, &**expr) => {\n                 span_warn!(cx.tcx.sess, p.span, E0003,\n@@ -399,28 +400,50 @@ fn const_val_to_expr(value: &const_val) -> P<ast::Expr> {\n \n pub struct StaticInliner<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n-    pub failed: bool\n+    pub failed: bool,\n+    pub renaming_map: Option<&'a mut FnvHashMap<(NodeId, Span), NodeId>>,\n }\n \n impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n-    pub fn new<'b>(tcx: &'b ty::ctxt<'tcx>) -> StaticInliner<'b, 'tcx> {\n+    pub fn new<'b>(tcx: &'b ty::ctxt<'tcx>,\n+                   renaming_map: Option<&'b mut FnvHashMap<(NodeId, Span), NodeId>>)\n+                   -> StaticInliner<'b, 'tcx> {\n         StaticInliner {\n             tcx: tcx,\n-            failed: false\n+            failed: false,\n+            renaming_map: renaming_map\n         }\n     }\n }\n \n+struct RenamingRecorder<'map> {\n+    substituted_node_id: NodeId,\n+    origin_span: Span,\n+    renaming_map: &'map mut FnvHashMap<(NodeId, Span), NodeId>\n+}\n+\n+impl<'map> ast_util::IdVisitingOperation for RenamingRecorder<'map> {\n+    fn visit_id(&mut self, node_id: NodeId) {\n+        let key = (node_id, self.origin_span);\n+        self.renaming_map.insert(key, self.substituted_node_id);\n+    }\n+}\n+\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n-        match pat.node {\n+        return match pat.node {\n             ast::PatIdent(..) | ast::PatEnum(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).cloned();\n                 match def {\n                     Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did) {\n                         Some(const_expr) => {\n-                            const_expr_to_pat(self.tcx, const_expr).map(|mut new_pat| {\n-                                new_pat.span = pat.span;\n+                            const_expr_to_pat(self.tcx, const_expr, pat.span).map(|new_pat| {\n+\n+                                if let Some(ref mut renaming_map) = self.renaming_map {\n+                                    // Record any renamings we do here\n+                                    record_renamings(const_expr, &pat, renaming_map);\n+                                }\n+\n                                 new_pat\n                             })\n                         }\n@@ -435,6 +458,24 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n                 }\n             }\n             _ => noop_fold_pat(pat, self)\n+        };\n+\n+        fn record_renamings(const_expr: &ast::Expr,\n+                            substituted_pat: &ast::Pat,\n+                            renaming_map: &mut FnvHashMap<(NodeId, Span), NodeId>) {\n+            let mut renaming_recorder = RenamingRecorder {\n+                substituted_node_id: substituted_pat.id,\n+                origin_span: substituted_pat.span,\n+                renaming_map: renaming_map,\n+            };\n+\n+            let mut id_visitor = ast_util::IdVisitor {\n+                operation: &mut renaming_recorder,\n+                pass_through_items: true,\n+                visited_outermost: false,\n+            };\n+\n+            id_visitor.visit_expr(const_expr);\n         }\n     }\n }\n@@ -953,7 +994,7 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &ast::Local) {\n         ast::LocalFor => \"`for` loop\"\n     };\n \n-    let mut static_inliner = StaticInliner::new(cx.tcx);\n+    let mut static_inliner = StaticInliner::new(cx.tcx, None);\n     is_refutable(cx, &*static_inliner.fold_pat(loc.pat.clone()), |pat| {\n         span_err!(cx.tcx.sess, loc.pat.span, E0005,\n             \"refutable pattern in {} binding: `{}` not covered\",\n@@ -1040,7 +1081,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     };\n \n     for pat in pats {\n-        walk_pat(&**pat, |p| {\n+        ast_util::walk_pat(&**pat, |p| {\n             if pat_is_binding(def_map, &*p) {\n                 match p.node {\n                     ast::PatIdent(ast::BindByValue(_), _, ref sub) => {"}, {"sha": "a6a647173faa724f40165237a3f841f2af462b31", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -22,6 +22,7 @@ use middle::astconv_util::{ast_ty_to_prim_ty};\n use util::nodemap::DefIdMap;\n \n use syntax::ast::{self, Expr};\n+use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n@@ -304,10 +305,10 @@ pub enum const_val {\n     const_bool(bool)\n }\n \n-pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n+pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat> {\n     let pat = match expr.node {\n         ast::ExprTup(ref exprs) =>\n-            ast::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect()),\n+            ast::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect()),\n \n         ast::ExprCall(ref callee, ref args) => {\n             let def = tcx.def_map.borrow()[callee.id].clone();\n@@ -319,7 +320,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n                 def::DefVariant(_, variant_did, _) => def_to_path(tcx, variant_did),\n                 _ => unreachable!()\n             };\n-            let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect();\n+            let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect();\n             ast::PatEnum(path, Some(pats))\n         }\n \n@@ -328,15 +329,15 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n                 span: codemap::DUMMY_SP,\n                 node: ast::FieldPat {\n                     ident: field.ident.node,\n-                    pat: const_expr_to_pat(tcx, &*field.expr),\n+                    pat: const_expr_to_pat(tcx, &*field.expr, span),\n                     is_shorthand: false,\n                 },\n             }).collect();\n             ast::PatStruct(path.clone(), field_pats, false)\n         }\n \n         ast::ExprVec(ref exprs) => {\n-            let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect();\n+            let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect();\n             ast::PatVec(pats, None, vec![])\n         }\n \n@@ -349,7 +350,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n                     ast::PatEnum(path.clone(), None),\n                 _ => {\n                     match lookup_const(tcx, expr) {\n-                        Some(actual) => return const_expr_to_pat(tcx, actual),\n+                        Some(actual) => return const_expr_to_pat(tcx, actual, span),\n                         _ => unreachable!()\n                     }\n                 }\n@@ -358,14 +359,14 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n \n         ast::ExprQPath(_) => {\n             match lookup_const(tcx, expr) {\n-                Some(actual) => return const_expr_to_pat(tcx, actual),\n+                Some(actual) => return const_expr_to_pat(tcx, actual, span),\n                 _ => unreachable!()\n             }\n         }\n \n         _ => ast::PatLit(P(expr.clone()))\n     };\n-    P(ast::Pat { id: expr.id, node: pat, span: expr.span })\n+    P(ast::Pat { id: expr.id, node: pat, span: span })\n }\n \n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {"}, {"sha": "0f014800480e9db678c0feb7df8a0405542b61d8", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 122, "deletions": 61, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -213,7 +213,7 @@ use trans::expr::{self, Dest};\n use trans::tvec;\n use trans::type_of;\n use middle::ty::{self, Ty};\n-use session::config::FullDebugInfo;\n+use session::config::{NoDebugInfo, FullDebugInfo};\n use util::common::indenter;\n use util::nodemap::FnvHashMap;\n use util::ppaux::{Repr, vec_map_to_string};\n@@ -222,7 +222,7 @@ use std;\n use std::iter::AdditiveIterator;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ast::{DUMMY_NODE_ID, Ident};\n+use syntax::ast::{DUMMY_NODE_ID, Ident, NodeId};\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n use syntax::ptr::P;\n@@ -244,25 +244,29 @@ impl<'a> ConstantExpr<'a> {\n // An option identifying a branch (either a literal, an enum variant or a range)\n #[derive(Debug)]\n enum Opt<'a, 'tcx> {\n-    ConstantValue(ConstantExpr<'a>),\n-    ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>),\n-    Variant(ty::Disr, Rc<adt::Repr<'tcx>>, ast::DefId),\n-    SliceLengthEqual(uint),\n-    SliceLengthGreaterOrEqual(/* prefix length */ uint, /* suffix length */ uint),\n+    ConstantValue(ConstantExpr<'a>, DebugLoc),\n+    ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>, DebugLoc),\n+    Variant(ty::Disr, Rc<adt::Repr<'tcx>>, ast::DefId, DebugLoc),\n+    SliceLengthEqual(uint, DebugLoc),\n+    SliceLengthGreaterOrEqual(/* prefix length */ uint,\n+                              /* suffix length */ uint,\n+                              DebugLoc),\n }\n \n impl<'a, 'tcx> Opt<'a, 'tcx> {\n     fn eq(&self, other: &Opt<'a, 'tcx>, tcx: &ty::ctxt<'tcx>) -> bool {\n         match (self, other) {\n-            (&ConstantValue(a), &ConstantValue(b)) => a.eq(b, tcx),\n-            (&ConstantRange(a1, a2), &ConstantRange(b1, b2)) => {\n+            (&ConstantValue(a, _), &ConstantValue(b, _)) => a.eq(b, tcx),\n+            (&ConstantRange(a1, a2, _), &ConstantRange(b1, b2, _)) => {\n                 a1.eq(b1, tcx) && a2.eq(b2, tcx)\n             }\n-            (&Variant(a_disr, ref a_repr, a_def), &Variant(b_disr, ref b_repr, b_def)) => {\n+            (&Variant(a_disr, ref a_repr, a_def, _),\n+             &Variant(b_disr, ref b_repr, b_def, _)) => {\n                 a_disr == b_disr && *a_repr == *b_repr && a_def == b_def\n             }\n-            (&SliceLengthEqual(a), &SliceLengthEqual(b)) => a == b,\n-            (&SliceLengthGreaterOrEqual(a1, a2), &SliceLengthGreaterOrEqual(b1, b2)) => {\n+            (&SliceLengthEqual(a, _), &SliceLengthEqual(b, _)) => a == b,\n+            (&SliceLengthGreaterOrEqual(a1, a2, _),\n+             &SliceLengthGreaterOrEqual(b1, b2, _)) => {\n                 a1 == b1 && a2 == b2\n             }\n             _ => false\n@@ -273,29 +277,39 @@ impl<'a, 'tcx> Opt<'a, 'tcx> {\n         let _icx = push_ctxt(\"match::trans_opt\");\n         let ccx = bcx.ccx();\n         match *self {\n-            ConstantValue(ConstantExpr(lit_expr)) => {\n+            ConstantValue(ConstantExpr(lit_expr), _) => {\n                 let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n                 let (llval, _) = consts::const_expr(ccx, &*lit_expr);\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n                 SingleResult(Result::new(bcx, lit_datum.val))\n             }\n-            ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2)) => {\n+            ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2), _) => {\n                 let (l1, _) = consts::const_expr(ccx, &**l1);\n                 let (l2, _) = consts::const_expr(ccx, &**l2);\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }\n-            Variant(disr_val, ref repr, _) => {\n+            Variant(disr_val, ref repr, _, _) => {\n                 adt::trans_case(bcx, &**repr, disr_val)\n             }\n-            SliceLengthEqual(length) => {\n+            SliceLengthEqual(length, _) => {\n                 SingleResult(Result::new(bcx, C_uint(ccx, length)))\n             }\n-            SliceLengthGreaterOrEqual(prefix, suffix) => {\n+            SliceLengthGreaterOrEqual(prefix, suffix, _) => {\n                 LowerBound(Result::new(bcx, C_uint(ccx, prefix + suffix)))\n             }\n         }\n     }\n+\n+    fn debug_loc(&self) -> DebugLoc {\n+        match *self {\n+            ConstantValue(_,debug_loc)                 |\n+            ConstantRange(_, _, debug_loc)             |\n+            Variant(_, _, _, debug_loc)                |\n+            SliceLengthEqual(_, debug_loc)             |\n+            SliceLengthGreaterOrEqual(_, _, debug_loc) => debug_loc\n+        }\n+    }\n }\n \n #[derive(Copy, PartialEq)]\n@@ -352,6 +366,9 @@ struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n     pats: Vec<&'p ast::Pat>,\n     data: &'a ArmData<'p, 'blk, 'tcx>,\n     bound_ptrs: Vec<(Ident, ValueRef)>,\n+    // Thread along renamings done by the check_match::StaticInliner, so we can\n+    // map back to original NodeIds\n+    pat_renaming_map: Option<&'a FnvHashMap<(NodeId, Span), NodeId>>\n }\n \n impl<'a, 'p, 'blk, 'tcx> Repr<'tcx> for Match<'a, 'p, 'blk, 'tcx> {\n@@ -405,7 +422,8 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         Match {\n             pats: pats,\n             data: &*br.data,\n-            bound_ptrs: bound_ptrs\n+            bound_ptrs: bound_ptrs,\n+            pat_renaming_map: br.pat_renaming_map,\n         }\n     }).collect()\n }\n@@ -449,7 +467,8 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             Match {\n                 pats: pats,\n                 data: br.data,\n-                bound_ptrs: bound_ptrs\n+                bound_ptrs: bound_ptrs,\n+                pat_renaming_map: br.pat_renaming_map,\n             }\n         })\n     }).collect()\n@@ -527,18 +546,18 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n     let _indenter = indenter();\n \n     let ctor = match opt {\n-        &ConstantValue(ConstantExpr(expr)) => check_match::ConstantValue(\n+        &ConstantValue(ConstantExpr(expr), _) => check_match::ConstantValue(\n             const_eval::eval_const_expr(bcx.tcx(), &*expr)\n         ),\n-        &ConstantRange(ConstantExpr(lo), ConstantExpr(hi)) => check_match::ConstantRange(\n+        &ConstantRange(ConstantExpr(lo), ConstantExpr(hi), _) => check_match::ConstantRange(\n             const_eval::eval_const_expr(bcx.tcx(), &*lo),\n             const_eval::eval_const_expr(bcx.tcx(), &*hi)\n         ),\n-        &SliceLengthEqual(n) =>\n+        &SliceLengthEqual(n, _) =>\n             check_match::Slice(n),\n-        &SliceLengthGreaterOrEqual(before, after) =>\n+        &SliceLengthGreaterOrEqual(before, after, _) =>\n             check_match::SliceWithSubslice(before, after),\n-        &Variant(_, _, def_id) =>\n+        &Variant(_, _, def_id, _) =>\n             check_match::Constructor::Variant(def_id)\n     };\n \n@@ -556,34 +575,50 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    m: &[Match<'a, 'p, 'blk, 'tcx>], col: uint)\n+                                    m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                    col: uint)\n                                     -> Vec<Opt<'p, 'tcx>> {\n     let tcx = bcx.tcx();\n \n     let mut found: Vec<Opt> = vec![];\n     for br in m {\n         let cur = br.pats[col];\n+        let debug_loc = match br.pat_renaming_map {\n+            Some(pat_renaming_map) => {\n+                match pat_renaming_map.get(&(cur.id, cur.span)) {\n+                    Some(&id) => DebugLoc::At(id, cur.span),\n+                    None => DebugLoc::At(cur.id, cur.span),\n+                }\n+            }\n+            None => DebugLoc::None\n+        };\n+\n         let opt = match cur.node {\n-            ast::PatLit(ref l) => ConstantValue(ConstantExpr(&**l)),\n+            ast::PatLit(ref l) => {\n+                ConstantValue(ConstantExpr(&**l), debug_loc)\n+            }\n             ast::PatIdent(..) | ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This is either an enum variant or a variable binding.\n                 let opt_def = tcx.def_map.borrow().get(&cur.id).cloned();\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n                         let variant = ty::enum_variant_with_id(tcx, enum_id, var_id);\n-                        Variant(variant.disr_val, adt::represent_node(bcx, cur.id), var_id)\n+                        Variant(variant.disr_val,\n+                                adt::represent_node(bcx, cur.id),\n+                                var_id,\n+                                debug_loc)\n                     }\n                     _ => continue\n                 }\n             }\n             ast::PatRange(ref l1, ref l2) => {\n-                ConstantRange(ConstantExpr(&**l1), ConstantExpr(&**l2))\n+                ConstantRange(ConstantExpr(&**l1), ConstantExpr(&**l2), debug_loc)\n             }\n             ast::PatVec(ref before, None, ref after) => {\n-                SliceLengthEqual(before.len() + after.len())\n+                SliceLengthEqual(before.len() + after.len(), debug_loc)\n             }\n             ast::PatVec(ref before, Some(_), ref after) => {\n-                SliceLengthGreaterOrEqual(before.len(), after.len())\n+                SliceLengthGreaterOrEqual(before.len(), after.len(), debug_loc)\n             }\n             _ => continue\n         };\n@@ -779,30 +814,32 @@ fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               lhs: ValueRef,\n                               rhs: ValueRef,\n-                              rhs_t: Ty<'tcx>)\n+                              rhs_t: Ty<'tcx>,\n+                              debug_loc: DebugLoc)\n                               -> Result<'blk, 'tcx> {\n     fn compare_str<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                lhs: ValueRef,\n                                rhs: ValueRef,\n-                               rhs_t: Ty<'tcx>)\n+                               rhs_t: Ty<'tcx>,\n+                               debug_loc: DebugLoc)\n                                -> Result<'blk, 'tcx> {\n         let did = langcall(cx,\n                            None,\n                            &format!(\"comparison of `{}`\",\n                                    cx.ty_to_string(rhs_t))[],\n                            StrEqFnLangItem);\n-        callee::trans_lang_call(cx, did, &[lhs, rhs], None)\n+        callee::trans_lang_call(cx, did, &[lhs, rhs], None, debug_loc)\n     }\n \n     let _icx = push_ctxt(\"compare_values\");\n     if ty::type_is_scalar(rhs_t) {\n-        let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::BiEq);\n+        let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::BiEq, debug_loc);\n         return Result::new(rs.bcx, rs.val);\n     }\n \n     match rhs_t.sty {\n         ty::ty_rptr(_, mt) => match mt.ty.sty {\n-            ty::ty_str => compare_str(cx, lhs, rhs, rhs_t),\n+            ty::ty_str => compare_str(cx, lhs, rhs, rhs_t, debug_loc),\n             ty::ty_vec(ty, _) => match ty.sty {\n                 ty::ty_uint(ast::TyU8) => {\n                     // NOTE: cast &[u8] to &str and abuse the str_eq lang item,\n@@ -812,7 +849,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                              ast::MutImmutable);\n                     let lhs = BitCast(cx, lhs, type_of::type_of(cx.ccx(), t).ptr_to());\n                     let rhs = BitCast(cx, rhs, type_of::type_of(cx.ccx(), t).ptr_to());\n-                    compare_str(cx, lhs, rhs, rhs_t)\n+                    compare_str(cx, lhs, rhs, rhs_t, debug_loc)\n                 },\n                 _ => cx.sess().bug(\"only byte strings supported in compare_values\"),\n             },\n@@ -1046,20 +1083,20 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     debug!(\"test_val={}\", bcx.val_to_string(test_val));\n     if opts.len() > 0 {\n         match opts[0] {\n-            ConstantValue(_) | ConstantRange(_, _) => {\n+            ConstantValue(..) | ConstantRange(..) => {\n                 test_val = load_if_immediate(bcx, val, left_ty);\n                 kind = if ty::type_is_integral(left_ty) {\n                     Switch\n                 } else {\n                     Compare\n                 };\n             }\n-            Variant(_, ref repr, _) => {\n+            Variant(_, ref repr, _, _) => {\n                 let (the_kind, val_opt) = adt::trans_switch(bcx, &**repr, val);\n                 kind = the_kind;\n                 if let Some(tval) = val_opt { test_val = tval; }\n             }\n-            SliceLengthEqual(_) | SliceLengthGreaterOrEqual(_, _) => {\n+            SliceLengthEqual(..) | SliceLengthGreaterOrEqual(..) => {\n                 let (_, len) = tvec::get_base_and_len(bcx, val, left_ty);\n                 test_val = len;\n                 kind = Switch;\n@@ -1068,8 +1105,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     }\n     for o in &opts {\n         match *o {\n-            ConstantRange(_, _) => { kind = Compare; break },\n-            SliceLengthGreaterOrEqual(_, _) => { kind = CompareSliceLength; break },\n+            ConstantRange(..) => { kind = Compare; break },\n+            SliceLengthGreaterOrEqual(..) => { kind = CompareSliceLength; break },\n             _ => ()\n         }\n     }\n@@ -1095,10 +1132,12 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         // for the current conditional branch.\n         let mut branch_chk = None;\n         let mut opt_cx = else_cx;\n+        let debug_loc = opt.debug_loc();\n+\n         if !exhaustive || i + 1 < len {\n             opt_cx = bcx.fcx.new_temp_block(\"match_case\");\n             match kind {\n-                Single => Br(bcx, opt_cx.llbb, DebugLoc::None),\n+                Single => Br(bcx, opt_cx.llbb, debug_loc),\n                 Switch => {\n                     match opt.trans(bcx) {\n                         SingleResult(r) => {\n@@ -1121,22 +1160,33 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     let Result { bcx: after_cx, val: matches } = {\n                         match opt.trans(bcx) {\n                             SingleResult(Result { bcx, val }) => {\n-                                compare_values(bcx, test_val, val, t)\n+                                compare_values(bcx, test_val, val, t, debug_loc)\n                             }\n                             RangeResult(Result { val: vbegin, .. },\n                                         Result { bcx, val: vend }) => {\n                                 let Result { bcx, val: llge } =\n-                                    compare_scalar_types(\n-                                    bcx, test_val,\n-                                    vbegin, t, ast::BiGe);\n+                                    compare_scalar_types(bcx,\n+                                                         test_val,\n+                                                         vbegin,\n+                                                         t,\n+                                                         ast::BiGe,\n+                                                         debug_loc);\n                                 let Result { bcx, val: llle } =\n-                                    compare_scalar_types(\n-                                    bcx, test_val, vend,\n-                                    t, ast::BiLe);\n-                                Result::new(bcx, And(bcx, llge, llle, DebugLoc::None))\n+                                    compare_scalar_types(bcx,\n+                                                         test_val,\n+                                                         vend,\n+                                                         t,\n+                                                         ast::BiLe,\n+                                                         debug_loc);\n+                                Result::new(bcx, And(bcx, llge, llle, debug_loc))\n                             }\n                             LowerBound(Result { bcx, val }) => {\n-                                compare_scalar_types(bcx, test_val, val, t, ast::BiGe)\n+                                compare_scalar_types(bcx,\n+                                                     test_val,\n+                                                     val,\n+                                                     t,\n+                                                     ast::BiGe,\n+                                                     debug_loc)\n                             }\n                         }\n                     };\n@@ -1151,37 +1201,37 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     if i + 1 < len && (guarded || multi_pats || kind == CompareSliceLength) {\n                         branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n                     }\n-                    CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb, DebugLoc::None);\n+                    CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb, debug_loc);\n                 }\n                 _ => ()\n             }\n         } else if kind == Compare || kind == CompareSliceLength {\n-            Br(bcx, else_cx.llbb, DebugLoc::None);\n+            Br(bcx, else_cx.llbb, debug_loc);\n         }\n \n         let mut size = 0;\n         let mut unpacked = Vec::new();\n         match *opt {\n-            Variant(disr_val, ref repr, _) => {\n+            Variant(disr_val, ref repr, _, _) => {\n                 let ExtractedBlock {vals: argvals, bcx: new_bcx} =\n                     extract_variant_args(opt_cx, &**repr, disr_val, val);\n                 size = argvals.len();\n                 unpacked = argvals;\n                 opt_cx = new_bcx;\n             }\n-            SliceLengthEqual(len) => {\n+            SliceLengthEqual(len, _) => {\n                 let args = extract_vec_elems(opt_cx, left_ty, len, 0, val);\n                 size = args.vals.len();\n                 unpacked = args.vals.clone();\n                 opt_cx = args.bcx;\n             }\n-            SliceLengthGreaterOrEqual(before, after) => {\n+            SliceLengthGreaterOrEqual(before, after, _) => {\n                 let args = extract_vec_elems(opt_cx, left_ty, before, after, val);\n                 size = args.vals.len();\n                 unpacked = args.vals.clone();\n                 opt_cx = args.bcx;\n             }\n-            ConstantValue(_) | ConstantRange(_, _) => ()\n+            ConstantValue(..) | ConstantRange(..) => ()\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n         let mut opt_vals = unpacked;\n@@ -1385,16 +1435,27 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         bindings_map: create_bindings_map(bcx, &*arm.pats[0], discr_expr, &*arm.body)\n     }).collect();\n \n-    let mut static_inliner = StaticInliner::new(scope_cx.tcx());\n-    let arm_pats: Vec<Vec<P<ast::Pat>>> = arm_datas.iter().map(|arm_data| {\n-        arm_data.arm.pats.iter().map(|p| static_inliner.fold_pat((*p).clone())).collect()\n-    }).collect();\n+    let mut pat_renaming_map = if scope_cx.sess().opts.debuginfo != NoDebugInfo {\n+        Some(FnvHashMap())\n+    } else {\n+        None\n+    };\n+\n+    let arm_pats: Vec<Vec<P<ast::Pat>>> = {\n+        let mut static_inliner = StaticInliner::new(scope_cx.tcx(),\n+                                                    pat_renaming_map.as_mut());\n+        arm_datas.iter().map(|arm_data| {\n+            arm_data.arm.pats.iter().map(|p| static_inliner.fold_pat((*p).clone())).collect()\n+        }).collect()\n+    };\n+\n     let mut matches = Vec::new();\n     for (arm_data, pats) in arm_datas.iter().zip(arm_pats.iter()) {\n         matches.extend(pats.iter().map(|p| Match {\n             pats: vec![&**p],\n             data: arm_data,\n             bound_ptrs: Vec::new(),\n+            pat_renaming_map: pat_renaming_map.as_ref()\n         }));\n     }\n "}, {"sha": "8bb60eca8b14a12e1af6f3b8a7d6709c755d0649", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -751,7 +751,7 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         RawNullablePointer { nndiscr, nnty, .. } =>  {\n             let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n             let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n-            val = ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty));\n+            val = ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty), DebugLoc::None);\n             signed = false;\n         }\n         StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n@@ -770,7 +770,7 @@ fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, discrfield: &Disc\n     let llptrptr = GEPi(bcx, scrutinee, &discrfield[]);\n     let llptr = Load(bcx, llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n-    ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)))\n+    ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)), DebugLoc::None)\n }\n \n /// Helper for cases where the discriminant is simply loaded."}, {"sha": "52ef2b75f9571b3e89676948313ce897c829dc18", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -57,7 +57,7 @@ use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use trans::common::{CrateContext, ExternMap, FunctionContext};\n-use trans::common::{Result};\n+use trans::common::{Result, NodeIdAndSpan};\n use trans::common::{node_id_type, return_type_is_void};\n use trans::common::{tydesc_info, type_is_immediate};\n use trans::common::{type_is_zero_size, val_ty};\n@@ -66,7 +66,7 @@ use trans::consts;\n use trans::context::SharedCrateContext;\n use trans::controlflow;\n use trans::datum;\n-use trans::debuginfo::{self, DebugLoc};\n+use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::expr;\n use trans::foreign;\n use trans::glue;\n@@ -379,15 +379,17 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   llty_ptr: Type,\n                                   info_ty: Ty<'tcx>,\n                                   size: ValueRef,\n-                                  align: ValueRef)\n+                                  align: ValueRef,\n+                                  debug_loc: DebugLoc)\n                                   -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"malloc_raw_exchange\");\n \n     // Allocate space:\n     let r = callee::trans_lang_call(bcx,\n         require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem),\n         &[size, align],\n-        None);\n+        None,\n+        debug_loc);\n \n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n@@ -538,9 +540,10 @@ pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                         lhs: ValueRef,\n                                         rhs: ValueRef,\n                                         t: Ty<'tcx>,\n-                                        op: ast::BinOp_)\n+                                        op: ast::BinOp_,\n+                                        debug_loc: DebugLoc)\n                                         -> Result<'blk, 'tcx> {\n-    let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n+    let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op, debug_loc));\n \n     match t.sty {\n         ty::ty_tup(ref tys) if tys.is_empty() => f(nil_type),\n@@ -559,7 +562,8 @@ pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                          lhs: ValueRef,\n                                          rhs: ValueRef,\n                                          nt: scalar_type,\n-                                         op: ast::BinOp_)\n+                                         op: ast::BinOp_,\n+                                         debug_loc: DebugLoc)\n                                          -> ValueRef {\n     let _icx = push_ctxt(\"compare_scalar_values\");\n     fn die(cx: Block) -> ! {\n@@ -586,7 +590,7 @@ pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n           ast::BiGe => llvm::RealOGE,\n           _ => die(cx)\n         };\n-        return FCmp(cx, cmp, lhs, rhs);\n+        return FCmp(cx, cmp, lhs, rhs, debug_loc);\n       }\n       signed_int => {\n         let cmp = match op {\n@@ -598,7 +602,7 @@ pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n           ast::BiGe => llvm::IntSGE,\n           _ => die(cx)\n         };\n-        return ICmp(cx, cmp, lhs, rhs);\n+        return ICmp(cx, cmp, lhs, rhs, debug_loc);\n       }\n       unsigned_int => {\n         let cmp = match op {\n@@ -610,7 +614,7 @@ pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n           ast::BiGe => llvm::IntUGE,\n           _ => die(cx)\n         };\n-        return ICmp(cx, cmp, lhs, rhs);\n+        return ICmp(cx, cmp, lhs, rhs, debug_loc);\n       }\n     }\n }\n@@ -621,7 +625,8 @@ pub fn compare_simd_types<'blk, 'tcx>(\n                     rhs: ValueRef,\n                     t: Ty<'tcx>,\n                     size: uint,\n-                    op: ast::BinOp)\n+                    op: ast::BinOp_,\n+                    debug_loc: DebugLoc)\n                     -> ValueRef {\n     let cmp = match t.sty {\n         ty::ty_float(_) => {\n@@ -632,7 +637,7 @@ pub fn compare_simd_types<'blk, 'tcx>(\n             cx.sess().bug(\"compare_simd_types: comparison operators \\\n                            not supported for floating point SIMD types\")\n         },\n-        ty::ty_uint(_) => match op.node {\n+        ty::ty_uint(_) => match op {\n             ast::BiEq => llvm::IntEQ,\n             ast::BiNe => llvm::IntNE,\n             ast::BiLt => llvm::IntULT,\n@@ -641,7 +646,7 @@ pub fn compare_simd_types<'blk, 'tcx>(\n             ast::BiGe => llvm::IntUGE,\n             _ => cx.sess().bug(\"compare_simd_types: must be a comparison operator\"),\n         },\n-        ty::ty_int(_) => match op.node {\n+        ty::ty_int(_) => match op {\n             ast::BiEq => llvm::IntEQ,\n             ast::BiNe => llvm::IntNE,\n             ast::BiLt => llvm::IntSLT,\n@@ -657,7 +662,7 @@ pub fn compare_simd_types<'blk, 'tcx>(\n     // to get the correctly sized type. This will compile to a single instruction\n     // once the IR is converted to assembly if the SIMD instruction is supported\n     // by the target architecture.\n-    SExt(cx, ICmp(cx, cmp, lhs, rhs), return_ty)\n+    SExt(cx, ICmp(cx, cmp, lhs, rhs, debug_loc), return_ty)\n }\n \n // Iterates through the elements of a structural type.\n@@ -851,7 +856,7 @@ pub fn cast_shift_rhs<F, G>(op: ast::BinOp,\n \n pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n                                 cx: Block<'blk, 'tcx>,\n-                                span: Span,\n+                                call_info: NodeIdAndSpan,\n                                 divrem: ast::BinOp,\n                                 lhs: ValueRef,\n                                 rhs: ValueRef,\n@@ -864,22 +869,24 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n         (\"attempted remainder with a divisor of zero\",\n          \"attempted remainder with overflow\")\n     };\n+    let debug_loc = call_info.debug_loc();\n+\n     let (is_zero, is_signed) = match rhs_t.sty {\n         ty::ty_int(t) => {\n             let zero = C_integral(Type::int_from_ty(cx.ccx(), t), 0u64, false);\n-            (ICmp(cx, llvm::IntEQ, rhs, zero), true)\n+            (ICmp(cx, llvm::IntEQ, rhs, zero, debug_loc), true)\n         }\n         ty::ty_uint(t) => {\n             let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0u64, false);\n-            (ICmp(cx, llvm::IntEQ, rhs, zero), false)\n+            (ICmp(cx, llvm::IntEQ, rhs, zero, debug_loc), false)\n         }\n         _ => {\n             cx.sess().bug(&format!(\"fail-if-zero on unexpected type: {}\",\n                                   ty_to_string(cx.tcx(), rhs_t))[]);\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n-        controlflow::trans_fail(bcx, span, InternedString::new(zero_text))\n+        controlflow::trans_fail(bcx, call_info, InternedString::new(zero_text))\n     });\n \n     // To quote LLVM's documentation for the sdiv instruction:\n@@ -908,12 +915,13 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             _ => unreachable!(),\n         };\n         let minus_one = ICmp(bcx, llvm::IntEQ, rhs,\n-                             C_integral(llty, -1, false));\n+                             C_integral(llty, -1, false), debug_loc);\n         with_cond(bcx, minus_one, |bcx| {\n             let is_min = ICmp(bcx, llvm::IntEQ, lhs,\n-                              C_integral(llty, min, true));\n+                              C_integral(llty, min, true), debug_loc);\n             with_cond(bcx, is_min, |bcx| {\n-                controlflow::trans_fail(bcx, span,\n+                controlflow::trans_fail(bcx,\n+                                        call_info,\n                                         InternedString::new(overflow_text))\n             })\n         })"}, {"sha": "2fcfc5e43931d2770391bde8b4c03e92b6505954", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -856,22 +856,32 @@ pub fn FPCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n \n \n /* Comparisons */\n-pub fn ICmp(cx: Block, op: IntPredicate, lhs: ValueRef, rhs: ValueRef)\n-     -> ValueRef {\n+pub fn ICmp(cx: Block,\n+            op: IntPredicate,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n         }\n+        debug_loc.apply(cx.fcx);\n         B(cx).icmp(op, lhs, rhs)\n     }\n }\n \n-pub fn FCmp(cx: Block, op: RealPredicate, lhs: ValueRef, rhs: ValueRef)\n-     -> ValueRef {\n+pub fn FCmp(cx: Block,\n+            op: RealPredicate,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n         }\n+        debug_loc.apply(cx.fcx);\n         B(cx).fcmp(op, lhs, rhs)\n     }\n }\n@@ -941,9 +951,17 @@ pub fn Call(cx: Block,\n     B(cx).call(fn_, args, attributes)\n }\n \n-pub fn CallWithConv(cx: Block, fn_: ValueRef, args: &[ValueRef], conv: CallConv,\n-                    attributes: Option<AttrBuilder>) -> ValueRef {\n-    if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n+pub fn CallWithConv(cx: Block,\n+                    fn_: ValueRef,\n+                    args: &[ValueRef],\n+                    conv: CallConv,\n+                    attributes: Option<AttrBuilder>,\n+                    debug_loc: DebugLoc)\n+                    -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _UndefReturn(cx, fn_);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).call_with_conv(fn_, args, conv, attributes)\n }\n "}, {"sha": "e45918ce5a7455998131deae030462b578f89512", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -36,8 +36,8 @@ use trans::callee;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::closure;\n-use trans::common;\n-use trans::common::*;\n+use trans::common::{self, Block, Result, NodeIdAndSpan, ExprId, CrateContext,\n+                    ExprOrMethodCall, FunctionContext, MethodCallKey};\n use trans::consts;\n use trans::datum::*;\n use trans::debuginfo::{DebugLoc, ToDebugLoc};\n@@ -136,7 +136,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                              ref_expr: &ast::Expr)\n                              -> Callee<'blk, 'tcx> {\n         debug!(\"trans_def(def={}, ref_expr={})\", def.repr(bcx.tcx()), ref_expr.repr(bcx.tcx()));\n-        let expr_ty = node_id_type(bcx, ref_expr.id);\n+        let expr_ty = common::node_id_type(bcx, ref_expr.id);\n         match def {\n             def::DefFn(did, _) if {\n                 let maybe_def_id = inline::get_local_instance(bcx.ccx(), did);\n@@ -147,8 +147,9 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                     _ => false\n                 }\n             } => {\n-                let substs = node_id_substs(bcx.ccx(), ExprId(ref_expr.id),\n-                                            bcx.fcx.param_substs);\n+                let substs = common::node_id_substs(bcx.ccx(),\n+                                                    ExprId(ref_expr.id),\n+                                                    bcx.fcx.param_substs);\n                 Callee {\n                     bcx: bcx,\n                     data: NamedTupleConstructor(substs, 0)\n@@ -158,8 +159,9 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 ty::ty_bare_fn(_, ref f) => f.abi == synabi::RustIntrinsic,\n                 _ => false\n             } => {\n-                let substs = node_id_substs(bcx.ccx(), ExprId(ref_expr.id),\n-                                            bcx.fcx.param_substs);\n+                let substs = common::node_id_substs(bcx.ccx(),\n+                                                    ExprId(ref_expr.id),\n+                                                    bcx.fcx.param_substs);\n                 let def_id = inline::maybe_instantiate_inline(bcx.ccx(), did);\n                 Callee { bcx: bcx, data: Intrinsic(def_id.node, substs) }\n             }\n@@ -178,8 +180,9 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             }\n             def::DefVariant(tid, vid, _) => {\n                 let vinfo = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n-                let substs = node_id_substs(bcx.ccx(), ExprId(ref_expr.id),\n-                                            bcx.fcx.param_substs);\n+                let substs = common::node_id_substs(bcx.ccx(),\n+                                                    ExprId(ref_expr.id),\n+                                                    bcx.fcx.param_substs);\n \n                 // Nullary variants are not callable\n                 assert!(vinfo.args.len() > 0);\n@@ -190,8 +193,9 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 }\n             }\n             def::DefStruct(_) => {\n-                let substs = node_id_substs(bcx.ccx(), ExprId(ref_expr.id),\n-                                            bcx.fcx.param_substs);\n+                let substs = common::node_id_substs(bcx.ccx(),\n+                                                    ExprId(ref_expr.id),\n+                                                    bcx.fcx.param_substs);\n                 Callee {\n                     bcx: bcx,\n                     data: NamedTupleConstructor(substs, 0)\n@@ -226,7 +230,7 @@ pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               -> Datum<'tcx, Rvalue> {\n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n-    let substs = node_id_substs(ccx, node, param_substs);\n+    let substs = common::node_id_substs(ccx, node, param_substs);\n     debug!(\"trans_fn_ref(def_id={}, node={:?}, substs={})\",\n            def_id.repr(ccx.tcx()),\n            node,\n@@ -269,7 +273,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let _icx = push_ctxt(\"trans_fn_pointer_shim\");\n     let tcx = ccx.tcx();\n \n-    let bare_fn_ty = erase_regions(tcx, &bare_fn_ty);\n+    let bare_fn_ty = common::erase_regions(tcx, &bare_fn_ty);\n     match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty) {\n         Some(&llval) => { return llval; }\n         None => { }\n@@ -352,7 +356,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     );\n \n     bcx = trans_call_inner(bcx,\n-                           None,\n+                           DebugLoc::None,\n                            bare_fn_ty,\n                            |bcx, _| Callee { bcx: bcx, data: Fn(llfnpointer) },\n                            ArgVals(&llargs[]),\n@@ -515,7 +519,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n                                                           param_substs,\n                                                           &ref_ty);\n             let llptrty = type_of::type_of_fn_from_ty(ccx, ref_ty).ptr_to();\n-            if llptrty != val_ty(val) {\n+            if llptrty != common::val_ty(val) {\n                 let val = consts::ptrcast(val, llptrty);\n                 return Datum::new(val, ref_ty, Rvalue::new(ByValue));\n             }\n@@ -563,7 +567,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     // other weird situations. Annoying.\n     let llty = type_of::type_of_fn_from_ty(ccx, fn_type);\n     let llptrty = llty.ptr_to();\n-    if val_ty(val) != llptrty {\n+    if common::val_ty(val) != llptrty {\n         debug!(\"trans_fn_ref_with_vtables(): casting pointer!\");\n         val = consts::ptrcast(val, llptrty);\n     } else {\n@@ -577,34 +581,34 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n // Translating calls\n \n pub fn trans_call<'a, 'blk, 'tcx>(in_cx: Block<'blk, 'tcx>,\n-                                  call_ex: &ast::Expr,\n+                                  call_expr: &ast::Expr,\n                                   f: &ast::Expr,\n                                   args: CallArgs<'a, 'tcx>,\n                                   dest: expr::Dest)\n                                   -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n-                     Some(common::expr_info(call_ex)),\n-                     expr_ty_adjusted(in_cx, f),\n+                     call_expr.debug_loc(),\n+                     common::expr_ty_adjusted(in_cx, f),\n                      |cx, _| trans(cx, f),\n                      args,\n                      Some(dest)).bcx\n }\n \n pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                         call_ex: &ast::Expr,\n+                                         call_expr: &ast::Expr,\n                                          rcvr: &ast::Expr,\n                                          args: CallArgs<'a, 'tcx>,\n                                          dest: expr::Dest)\n                                          -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_method_call\");\n-    debug!(\"trans_method_call(call_ex={})\", call_ex.repr(bcx.tcx()));\n-    let method_call = MethodCall::expr(call_ex.id);\n+    debug!(\"trans_method_call(call_expr={})\", call_expr.repr(bcx.tcx()));\n+    let method_call = MethodCall::expr(call_expr.id);\n     let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n     trans_call_inner(\n         bcx,\n-        Some(common::expr_info(call_ex)),\n-        monomorphize_type(bcx, method_ty),\n+        call_expr.debug_loc(),\n+        common::monomorphize_type(bcx, method_ty),\n         |cx, arg_cleanup_scope| {\n             meth::trans_method_callee(cx, method_call, Some(rcvr), arg_cleanup_scope)\n         },\n@@ -615,15 +619,16 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    did: ast::DefId,\n                                    args: &[ValueRef],\n-                                   dest: Option<expr::Dest>)\n+                                   dest: Option<expr::Dest>,\n+                                   debug_loc: DebugLoc)\n                                    -> Result<'blk, 'tcx> {\n     let fty = if did.krate == ast::LOCAL_CRATE {\n         ty::node_id_to_type(bcx.tcx(), did.node)\n     } else {\n         csearch::get_type(bcx.tcx(), did).ty\n     };\n     callee::trans_call_inner(bcx,\n-                             None,\n+                             debug_loc,\n                              fty,\n                              |bcx, _| {\n                                 trans_fn_ref_with_substs_to_callee(bcx,\n@@ -646,7 +651,7 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// For non-lang items, `dest` is always Some, and hence the result is written into memory\n /// somewhere. Nonetheless we return the actual return value of the function.\n pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                           call_info: Option<NodeIdAndSpan>,\n+                                           debug_loc: DebugLoc,\n                                            callee_ty: Ty<'tcx>,\n                                            get_callee: F,\n                                            args: CallArgs<'a, 'tcx>,\n@@ -687,7 +692,13 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             assert!(abi == synabi::RustIntrinsic);\n             assert!(dest.is_some());\n \n-            let call_info = call_info.expect(\"no call info for intrinsic call?\");\n+            let call_info = match debug_loc {\n+                DebugLoc::At(id, span) => NodeIdAndSpan { id: id, span: span },\n+                DebugLoc::None => {\n+                    bcx.sess().bug(\"No call info for intrinsic call?\")\n+                }\n+            };\n+\n             return intrinsic::trans_intrinsic_call(bcx, node, callee_ty,\n                                                    arg_cleanup_scope, args,\n                                                    dest.unwrap(), substs,\n@@ -703,7 +714,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                                        disr,\n                                                        args,\n                                                        dest.unwrap(),\n-                                                       call_info.debug_loc());\n+                                                       debug_loc);\n         }\n     };\n \n@@ -724,12 +735,12 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             };\n             if !is_rust_fn ||\n               type_of::return_uses_outptr(ccx, ret_ty) ||\n-              type_needs_drop(bcx.tcx(), ret_ty) {\n+              common::type_needs_drop(bcx.tcx(), ret_ty) {\n                 // Push the out-pointer if we use an out-pointer for this\n                 // return type, otherwise push \"undef\".\n-                if type_is_zero_size(ccx, ret_ty) {\n+                if common::type_is_zero_size(ccx, ret_ty) {\n                     let llty = type_of::type_of(ccx, ret_ty);\n-                    Some(C_undef(llty.ptr_to()))\n+                    Some(common::C_undef(llty.ptr_to()))\n                 } else {\n                     Some(alloc_ty(bcx, ret_ty, \"__llret\"))\n                 }\n@@ -781,7 +792,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                       llfn,\n                                       &llargs[],\n                                       callee_ty,\n-                                      call_info.debug_loc());\n+                                      debug_loc);\n         bcx = b;\n         llresult = llret;\n \n@@ -790,7 +801,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         match (opt_llretslot, ret_ty) {\n             (Some(llretslot), ty::FnConverging(ret_ty)) => {\n                 if !type_of::return_uses_outptr(bcx.ccx(), ret_ty) &&\n-                    !type_is_zero_size(bcx.ccx(), ret_ty)\n+                    !common::type_is_zero_size(bcx.ccx(), ret_ty)\n                 {\n                     store_ty(bcx, llret, llretslot, ret_ty)\n                 }\n@@ -804,7 +815,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n         let mut llargs = Vec::new();\n         let arg_tys = match args {\n-            ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, &**x)).collect(),\n+            ArgExprs(a) => a.iter().map(|x| common::expr_ty(bcx, &**x)).collect(),\n             _ => panic!(\"expected arg exprs.\")\n         };\n         bcx = trans_args(bcx,\n@@ -816,9 +827,13 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                          abi);\n         fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n-        bcx = foreign::trans_native_call(bcx, callee_ty,\n-                                         llfn, opt_llretslot.unwrap(),\n-                                         &llargs[], arg_tys);\n+        bcx = foreign::trans_native_call(bcx,\n+                                         callee_ty,\n+                                         llfn,\n+                                         opt_llretslot.unwrap(),\n+                                         &llargs[],\n+                                         arg_tys,\n+                                         debug_loc);\n     }\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_cleanup_scope);\n@@ -831,7 +846,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             bcx = glue::drop_ty(bcx,\n                                 llretslot,\n                                 ret_ty,\n-                                call_info.debug_loc());\n+                                debug_loc);\n             call_lifetime_end(bcx, llretslot);\n         }\n         _ => {}\n@@ -892,7 +907,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n \n     // Now untuple the rest of the arguments.\n     let tuple_expr = &arg_exprs[1];\n-    let tuple_type = node_id_type(bcx, tuple_expr.id);\n+    let tuple_type = common::node_id_type(bcx, tuple_expr.id);\n \n     match tuple_type.sty {\n         ty::ty_tup(ref field_types) => {\n@@ -1014,7 +1029,7 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                 }\n                 let arg_ty = if i >= num_formal_args {\n                     assert!(variadic);\n-                    expr_ty_adjusted(cx, &**arg_expr)\n+                    common::expr_ty_adjusted(cx, &**arg_expr)\n                 } else {\n                     arg_tys[i]\n                 };"}, {"sha": "bebba151a0d313dee2db00c21bb38349b54f6b71", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -940,11 +940,12 @@ impl<'tcx> Cleanup<'tcx> for FreeValue<'tcx> {\n                    bcx: Block<'blk, 'tcx>,\n                    debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        debug_loc.apply(bcx.fcx);\n-\n         match self.heap {\n             HeapExchange => {\n-                glue::trans_exchange_free_ty(bcx, self.ptr, self.content_ty)\n+                glue::trans_exchange_free_ty(bcx,\n+                                             self.ptr,\n+                                             self.content_ty,\n+                                             debug_loc)\n             }\n         }\n     }\n@@ -975,11 +976,13 @@ impl<'tcx> Cleanup<'tcx> for FreeSlice {\n                    bcx: Block<'blk, 'tcx>,\n                    debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        debug_loc.apply(bcx.fcx);\n-\n         match self.heap {\n             HeapExchange => {\n-                glue::trans_exchange_free_dyn(bcx, self.ptr, self.size, self.align)\n+                glue::trans_exchange_free_dyn(bcx,\n+                                              self.ptr,\n+                                              self.size,\n+                                              self.align,\n+                                              debug_loc)\n             }\n         }\n     }"}, {"sha": "8004726d25ea2bff709c58f4995931b596538058", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -28,7 +28,6 @@ use util::ppaux::Repr;\n use syntax::ast;\n use syntax::ast::Ident;\n use syntax::ast_util;\n-use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::visit::Visitor;\n@@ -361,39 +360,40 @@ pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              sp: Span,\n+                              call_info: NodeIdAndSpan,\n                               fail_str: InternedString)\n                               -> Block<'blk, 'tcx> {\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"trans_fail_value\");\n \n     let v_str = C_str_slice(ccx, fail_str);\n-    let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n+    let loc = bcx.sess().codemap().lookup_char_pos(call_info.span.lo);\n     let filename = token::intern_and_get_ident(&loc.file.name[]);\n     let filename = C_str_slice(ccx, filename);\n     let line = C_uint(ccx, loc.line);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n     let expr_file_line = consts::const_addr_of(ccx, expr_file_line_const, ast::MutImmutable);\n     let args = vec!(expr_file_line);\n-    let did = langcall(bcx, Some(sp), \"\", PanicFnLangItem);\n+    let did = langcall(bcx, Some(call_info.span), \"\", PanicFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n                                       &args[],\n-                                      Some(expr::Ignore)).bcx;\n+                                      Some(expr::Ignore),\n+                                      call_info.debug_loc()).bcx;\n     Unreachable(bcx);\n     return bcx;\n }\n \n pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                           sp: Span,\n+                                           call_info: NodeIdAndSpan,\n                                            index: ValueRef,\n                                            len: ValueRef)\n                                            -> Block<'blk, 'tcx> {\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"trans_fail_bounds_check\");\n \n     // Extract the file/line from the span\n-    let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n+    let loc = bcx.sess().codemap().lookup_char_pos(call_info.span.lo);\n     let filename = token::intern_and_get_ident(&loc.file.name[]);\n \n     // Invoke the lang item\n@@ -402,11 +402,12 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let file_line_const = C_struct(ccx, &[filename, line], false);\n     let file_line = consts::const_addr_of(ccx, file_line_const, ast::MutImmutable);\n     let args = vec!(file_line, index, len);\n-    let did = langcall(bcx, Some(sp), \"\", PanicBoundsCheckFnLangItem);\n+    let did = langcall(bcx, Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n                                       &args[],\n-                                      Some(expr::Ignore)).bcx;\n+                                      Some(expr::Ignore),\n+                                      call_info.debug_loc()).bcx;\n     Unreachable(bcx);\n     return bcx;\n }"}, {"sha": "c10ff753936b317dbaad2ccf5b63e89aea0f00f5", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -1113,7 +1113,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum DebugLoc {\n     At(ast::NodeId, Span),\n     None"}, {"sha": "9ea7a276d97c657453dcd8b0e9a19107c26db480", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 42, "deletions": 13, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -586,7 +586,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let contents_ty = expr_ty(bcx, &**contents);\n             match box_ty.sty {\n                 ty::ty_uniq(..) => {\n-                    trans_uniq_expr(bcx, box_ty, &**contents, contents_ty)\n+                    trans_uniq_expr(bcx, expr, box_ty, &**contents, contents_ty)\n                 }\n                 _ => bcx.sess().span_bug(expr.span,\n                                          \"expected unique box\")\n@@ -696,6 +696,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n \n+    let index_expr_debug_loc = index_expr.debug_loc();\n+\n     // Check for overloaded index.\n     let method_ty = ccx.tcx()\n                        .method_map\n@@ -778,16 +780,20 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             debug!(\"trans_index: base {}\", bcx.val_to_string(base));\n             debug!(\"trans_index: len {}\", bcx.val_to_string(len));\n \n-            let bounds_check = ICmp(bcx, llvm::IntUGE, ix_val, len);\n+            let bounds_check = ICmp(bcx,\n+                                    llvm::IntUGE,\n+                                    ix_val,\n+                                    len,\n+                                    index_expr_debug_loc);\n             let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n             let expected = Call(bcx,\n                                 expect,\n                                 &[bounds_check, C_bool(ccx, false)],\n                                 None,\n-                                index_expr.debug_loc());\n+                                index_expr_debug_loc);\n             bcx = with_cond(bcx, expected, |bcx| {\n                 controlflow::trans_fail_bounds_check(bcx,\n-                                                     index_expr.span,\n+                                                     expr_info(index_expr),\n                                                      ix_val,\n                                                      len)\n             });\n@@ -1574,7 +1580,7 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             immediate_rvalue_bcx(bcx, llneg, un_ty).to_expr_datumblock()\n         }\n         ast::UnUniq => {\n-            trans_uniq_expr(bcx, un_ty, sub_expr, expr_ty(bcx, sub_expr))\n+            trans_uniq_expr(bcx, expr, un_ty, sub_expr, expr_ty(bcx, sub_expr))\n         }\n         ast::UnDeref => {\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n@@ -1584,6 +1590,7 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               box_expr: &ast::Expr,\n                                box_ty: Ty<'tcx>,\n                                contents: &ast::Expr,\n                                contents_ty: Ty<'tcx>)\n@@ -1595,7 +1602,12 @@ fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let size = llsize_of(bcx.ccx(), llty);\n     let align = C_uint(bcx.ccx(), type_of::align_of(bcx.ccx(), contents_ty));\n     let llty_ptr = llty.ptr_to();\n-    let Result { bcx, val } = malloc_raw_dyn(bcx, llty_ptr, box_ty, size, align);\n+    let Result { bcx, val } = malloc_raw_dyn(bcx,\n+                                             llty_ptr,\n+                                             box_ty,\n+                                             size,\n+                                             align,\n+                                             box_expr.debug_loc());\n     // Unique boxes do not allocate for zero-size types. The standard library\n     // may assume that `free` is never called on the pointer returned for\n     // `Box<ZeroSizeType>`.\n@@ -1697,8 +1709,12 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             FDiv(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n             // Only zero-check integers; fp /0 is NaN\n-            bcx = base::fail_if_zero_or_overflows(bcx, binop_expr.span,\n-                                                  op, lhs, rhs, rhs_t);\n+            bcx = base::fail_if_zero_or_overflows(bcx,\n+                                                  expr_info(binop_expr),\n+                                                  op,\n+                                                  lhs,\n+                                                  rhs,\n+                                                  rhs_t);\n             if is_signed {\n                 SDiv(bcx, lhs, rhs, binop_debug_loc)\n             } else {\n@@ -1711,7 +1727,8 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             FRem(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n             // Only zero-check integers; fp %0 is NaN\n-            bcx = base::fail_if_zero_or_overflows(bcx, binop_expr.span,\n+            bcx = base::fail_if_zero_or_overflows(bcx,\n+                                                  expr_info(binop_expr),\n                                                   op, lhs, rhs, rhs_t);\n             if is_signed {\n                 SRem(bcx, lhs, rhs, binop_debug_loc)\n@@ -1733,9 +1750,21 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if ty::type_is_scalar(rhs_t) {\n-            unpack_result!(bcx, base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op.node))\n+            unpack_result!(bcx,\n+                           base::compare_scalar_types(bcx,\n+                                                      lhs,\n+                                                      rhs,\n+                                                      rhs_t,\n+                                                      op.node,\n+                                                      binop_debug_loc))\n         } else if is_simd {\n-            base::compare_simd_types(bcx, lhs, rhs, intype, ty::simd_size(tcx, lhs_t), op)\n+            base::compare_simd_types(bcx,\n+                                     lhs,\n+                                     rhs,\n+                                     intype,\n+                                     ty::simd_size(tcx, lhs_t),\n+                                     op.node,\n+                                     binop_debug_loc)\n         } else {\n             bcx.tcx().sess.span_bug(binop_expr.span, \"comparison operator unsupported for type\")\n         }\n@@ -1845,7 +1874,7 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    -> Result<'blk, 'tcx> {\n     let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n     callee::trans_call_inner(bcx,\n-                             Some(expr_info(expr)),\n+                             expr.debug_loc(),\n                              monomorphize_type(bcx, method_ty),\n                              |bcx, arg_cleanup_scope| {\n                                 meth::trans_method_callee(bcx,\n@@ -1872,7 +1901,7 @@ fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     all_args.extend(args.iter().map(|e| &**e));\n     unpack_result!(bcx,\n                    callee::trans_call_inner(bcx,\n-                                            Some(expr_info(expr)),\n+                                            expr.debug_loc(),\n                                             monomorphize_type(bcx,\n                                                               method_type),\n                                             |bcx, arg_cleanup_scope| {"}, {"sha": "5f25a3c7a9210171d73d051ed5a36a86f86ce65b", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -18,6 +18,7 @@ use trans::base;\n use trans::build::*;\n use trans::cabi;\n use trans::common::*;\n+use trans::debuginfo::DebugLoc;\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -218,7 +219,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      llfn: ValueRef,\n                                      llretptr: ValueRef,\n                                      llargs_rust: &[ValueRef],\n-                                     passed_arg_tys: Vec<Ty<'tcx>>)\n+                                     passed_arg_tys: Vec<Ty<'tcx>>,\n+                                     call_debug_loc: DebugLoc)\n                                      -> Block<'blk, 'tcx>\n {\n     let ccx = bcx.ccx();\n@@ -370,7 +372,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         llfn,\n                                         &llargs_foreign[],\n                                         cc,\n-                                        Some(attrs));\n+                                        Some(attrs),\n+                                        call_debug_loc);\n \n     // If the function we just called does not use an outpointer,\n     // store the result into the rust outpointer. Cast the outpointer"}, {"sha": "8cf9a51b3bfd9ec6f74c7303fd2c3700e681ad9c", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -45,33 +45,47 @@ use std::ffi::CString;\n use syntax::ast;\n use syntax::parse::token;\n \n-pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n-                                           size: ValueRef, align: ValueRef)\n+pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                           v: ValueRef,\n+                                           size: ValueRef,\n+                                           align: ValueRef,\n+                                           debug_loc: DebugLoc)\n                                            -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     let ccx = cx.ccx();\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", ExchangeFreeFnLangItem),\n         &[PointerCast(cx, v, Type::i8p(ccx)), size, align],\n-        Some(expr::Ignore)).bcx\n+        Some(expr::Ignore),\n+        debug_loc).bcx\n }\n \n-pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n-                                       size: u64, align: u32) -> Block<'blk, 'tcx> {\n-    trans_exchange_free_dyn(cx, v, C_uint(cx.ccx(), size),\n-                                   C_uint(cx.ccx(), align))\n+pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                       v: ValueRef,\n+                                       size: u64,\n+                                       align: u32,\n+                                       debug_loc: DebugLoc)\n+                                       -> Block<'blk, 'tcx> {\n+    trans_exchange_free_dyn(cx,\n+                            v,\n+                            C_uint(cx.ccx(), size),\n+                            C_uint(cx.ccx(), align),\n+                            debug_loc)\n }\n \n-pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef,\n-                                          content_ty: Ty<'tcx>) -> Block<'blk, 'tcx> {\n+pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          ptr: ValueRef,\n+                                          content_ty: Ty<'tcx>,\n+                                          debug_loc: DebugLoc)\n+                                          -> Block<'blk, 'tcx> {\n     assert!(type_is_sized(bcx.ccx().tcx(), content_ty));\n     let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n     let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n \n     // `Box<ZeroSizeType>` does not allocate.\n     if content_size != 0 {\n         let content_align = align_of(bcx.ccx(), content_ty);\n-        trans_exchange_free(bcx, ptr, content_size, content_align)\n+        trans_exchange_free(bcx, ptr, content_size, content_align, debug_loc)\n     } else {\n         bcx\n     }\n@@ -328,7 +342,11 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             // Return the sum of sizes and max of aligns.\n             let size = Add(bcx, sized_size, unsized_size, DebugLoc::None);\n             let align = Select(bcx,\n-                               ICmp(bcx, llvm::IntULT, sized_align, unsized_align),\n+                               ICmp(bcx,\n+                                    llvm::IntULT,\n+                                    sized_align,\n+                                    unsized_align,\n+                                    DebugLoc::None),\n                                sized_align,\n                                unsized_align);\n             (size, align)\n@@ -394,7 +412,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n                         let info = Load(bcx, info);\n                         let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n-                        trans_exchange_free_dyn(bcx, llbox, llsize, llalign)\n+                        trans_exchange_free_dyn(bcx, llbox, llsize, llalign, DebugLoc::None)\n                     })\n                 }\n                 _ => {\n@@ -404,7 +422,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                     let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n                         let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n-                        trans_exchange_free_ty(bcx, llbox, content_ty)\n+                        trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n                     })\n                 }\n             }"}, {"sha": "5161382a927ac3c5d1668dab2c42f15b3c2c6202", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -667,7 +667,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n            method_offset_in_vtable);\n \n     bcx = trans_call_inner(bcx,\n-                           None,\n+                           DebugLoc::None,\n                            method_bare_fn_ty,\n                            |bcx, _| trans_trait_callee_from_llval(bcx,\n                                                                   method_bare_fn_ty,"}, {"sha": "edd4da4711f9c6610c60f9c7839c7b7f4a8efdbf", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -73,11 +73,19 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let unit_size = llsize_of_alloc(ccx, llty);\n             if unit_size != 0 {\n                 let len = get_len(bcx, vptr);\n-                let not_empty = ICmp(bcx, llvm::IntNE, len, C_uint(ccx, 0us));\n+                let not_empty = ICmp(bcx,\n+                                     llvm::IntNE,\n+                                     len,\n+                                     C_uint(ccx, 0us),\n+                                     DebugLoc::None);\n                 with_cond(bcx, not_empty, |bcx| {\n                     let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty));\n                     let size = Mul(bcx, C_uint(ccx, unit_size), len, DebugLoc::None);\n-                    glue::trans_exchange_free_dyn(bcx, dataptr, size, llalign)\n+                    glue::trans_exchange_free_dyn(bcx,\n+                                                  dataptr,\n+                                                  size,\n+                                                  llalign,\n+                                                  DebugLoc::None)\n                 })\n             } else {\n                 bcx\n@@ -439,7 +447,7 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     { // i < count\n         let lhs = Load(cond_bcx, loop_counter);\n         let rhs = count;\n-        let cond_val = ICmp(cond_bcx, llvm::IntULT, lhs, rhs);\n+        let cond_val = ICmp(cond_bcx, llvm::IntULT, lhs, rhs, DebugLoc::None);\n \n         CondBr(cond_bcx, cond_val, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n     }\n@@ -493,7 +501,7 @@ pub fn iter_vec_raw<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         let data_ptr =\n             Phi(header_bcx, val_ty(data_ptr), &[data_ptr], &[bcx.llbb]);\n         let not_yet_at_end =\n-            ICmp(header_bcx, llvm::IntULT, data_ptr, data_end_ptr);\n+            ICmp(header_bcx, llvm::IntULT, data_ptr, data_end_ptr, DebugLoc::None);\n         let body_bcx = fcx.new_temp_block(\"iter_vec_loop_body\");\n         let next_bcx = fcx.new_temp_block(\"iter_vec_next\");\n         CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);"}, {"sha": "487c69a85d6acb985756545ec589ab5c7f6793df", "filename": "src/test/debuginfo/constant-in-match-pattern.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a66e9b098e3c322161f0397e932cf6d3c1b15c/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs?ref=d4a66e9b098e3c322161f0397e932cf6d3c1b15c", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-android: FIXME(#10381)\n+// min-lldb-version: 310\n+\n+// compile-flags:-g\n+\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+#![omit_gdb_pretty_printer_section]\n+\n+// This test makes sure that the compiler doesn't crash when trying to assign\n+// debug locations to 'constant' patterns in match expressions.\n+\n+const CONSTANT: u64 = 3;\n+\n+struct Struct {\n+    a: isize,\n+    b: usize,\n+}\n+const STRUCT: Struct = Struct { a: 1, b: 2 };\n+\n+struct TupleStruct(u32);\n+const TUPLE_STRUCT: TupleStruct = TupleStruct(4);\n+\n+enum Enum {\n+    Variant1(char),\n+    Variant2 { a: u8 },\n+    Variant3\n+}\n+const VARIANT1: Enum = Enum::Variant1('v');\n+const VARIANT2: Enum = Enum::Variant2 { a: 2 };\n+const VARIANT3: Enum = Enum::Variant3;\n+\n+const STRING: &'static str = \"String\";\n+\n+fn main() {\n+\n+    match 1 {\n+        CONSTANT => {}\n+        _ => {}\n+    };\n+\n+    // if let 3 = CONSTANT {}\n+\n+    match (Struct { a: 2, b: 2 }) {\n+        STRUCT => {}\n+        _ => {}\n+    };\n+\n+    // if let STRUCT = STRUCT {}\n+\n+    match TupleStruct(3) {\n+        TUPLE_STRUCT => {}\n+        _ => {}\n+    };\n+\n+    // if let TupleStruct(4) = TUPLE_STRUCT {}\n+\n+    match VARIANT3 {\n+        VARIANT1 => {},\n+        VARIANT2 => {},\n+        VARIANT3 => {},\n+        _ => {}\n+    };\n+\n+    match (VARIANT3, VARIANT2) {\n+        (VARIANT1, VARIANT3) => {},\n+        (VARIANT2, VARIANT2) => {},\n+        (VARIANT3, VARIANT1) => {},\n+        _ => {}\n+    };\n+\n+    // if let VARIANT1 = Enum::Variant3 {}\n+    // if let VARIANT2 = Enum::Variant3 {}\n+    // if let VARIANT3 = Enum::Variant3 {}\n+\n+    match \"abc\" {\n+        STRING => {},\n+        _ => {}\n+    }\n+\n+    if let STRING = \"def\" {}\n+}"}]}