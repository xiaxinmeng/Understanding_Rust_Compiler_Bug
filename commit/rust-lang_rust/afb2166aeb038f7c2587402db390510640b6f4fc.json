{"sha": "afb2166aeb038f7c2587402db390510640b6f4fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYjIxNjZhZWIwMzhmN2MyNTg3NDAyZGIzOTA1MTA2NDBiNmY0ZmM=", "commit": {"author": {"name": "Arif Roktim", "email": "arifrroktim@gmail.com", "date": "2020-10-24T22:40:33Z"}, "committer": {"name": "Arif Roktim", "email": "arifrroktim@gmail.com", "date": "2020-10-24T23:21:53Z"}, "message": "Make IncorrectDiagnostic match rustc by copying rustc's code.", "tree": {"sha": "f6bc6128f0360009919a30e492a3b5ccc8b4c6ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6bc6128f0360009919a30e492a3b5ccc8b4c6ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afb2166aeb038f7c2587402db390510640b6f4fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afb2166aeb038f7c2587402db390510640b6f4fc", "html_url": "https://github.com/rust-lang/rust/commit/afb2166aeb038f7c2587402db390510640b6f4fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afb2166aeb038f7c2587402db390510640b6f4fc/comments", "author": {"login": "ArifRoktim", "id": 23637819, "node_id": "MDQ6VXNlcjIzNjM3ODE5", "avatar_url": "https://avatars.githubusercontent.com/u/23637819?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArifRoktim", "html_url": "https://github.com/ArifRoktim", "followers_url": "https://api.github.com/users/ArifRoktim/followers", "following_url": "https://api.github.com/users/ArifRoktim/following{/other_user}", "gists_url": "https://api.github.com/users/ArifRoktim/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArifRoktim/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArifRoktim/subscriptions", "organizations_url": "https://api.github.com/users/ArifRoktim/orgs", "repos_url": "https://api.github.com/users/ArifRoktim/repos", "events_url": "https://api.github.com/users/ArifRoktim/events{/privacy}", "received_events_url": "https://api.github.com/users/ArifRoktim/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ArifRoktim", "id": 23637819, "node_id": "MDQ6VXNlcjIzNjM3ODE5", "avatar_url": "https://avatars.githubusercontent.com/u/23637819?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArifRoktim", "html_url": "https://github.com/ArifRoktim", "followers_url": "https://api.github.com/users/ArifRoktim/followers", "following_url": "https://api.github.com/users/ArifRoktim/following{/other_user}", "gists_url": "https://api.github.com/users/ArifRoktim/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArifRoktim/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArifRoktim/subscriptions", "organizations_url": "https://api.github.com/users/ArifRoktim/orgs", "repos_url": "https://api.github.com/users/ArifRoktim/repos", "events_url": "https://api.github.com/users/ArifRoktim/events{/privacy}", "received_events_url": "https://api.github.com/users/ArifRoktim/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5c294f78ca9c621e38b23102e3b5ca1bdd175f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c294f78ca9c621e38b23102e3b5ca1bdd175f3", "html_url": "https://github.com/rust-lang/rust/commit/d5c294f78ca9c621e38b23102e3b5ca1bdd175f3"}], "stats": {"total": 249, "additions": 123, "deletions": 126}, "files": [{"sha": "b0144a2898697ff5313fe36cba2d997d95212078", "filename": "crates/hir_ty/src/diagnostics/decl_check/case_conv.rs", "status": "modified", "additions": 123, "deletions": 126, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/afb2166aeb038f7c2587402db390510640b6f4fc/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fcase_conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb2166aeb038f7c2587402db390510640b6f4fc/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fcase_conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fcase_conv.rs?ref=afb2166aeb038f7c2587402db390510640b6f4fc", "patch": "@@ -1,156 +1,145 @@\n //! Functions for string case manipulation, such as detecting the identifier case,\n //! and converting it into appropriate form.\n \n-#[derive(Debug)]\n-enum DetectedCase {\n-    LowerCamelCase,\n-    UpperCamelCase,\n-    LowerSnakeCase,\n-    UpperSnakeCase,\n-    Unknown,\n-}\n-\n-fn detect_case(ident: &str) -> DetectedCase {\n-    let trimmed_ident = ident.trim_matches('_');\n-    let first_lowercase = trimmed_ident.starts_with(|chr: char| chr.is_ascii_lowercase());\n-    let mut has_lowercase = first_lowercase;\n-    let mut has_uppercase = false;\n-    let mut has_underscore = false;\n-\n-    for chr in trimmed_ident.chars() {\n-        if chr == '_' {\n-            has_underscore = true;\n-        } else if chr.is_ascii_uppercase() {\n-            has_uppercase = true;\n-        } else if chr.is_ascii_lowercase() {\n-            has_lowercase = true;\n-        }\n-    }\n-\n-    if has_uppercase {\n-        if !has_lowercase {\n-            if has_underscore {\n-                DetectedCase::UpperSnakeCase\n-            } else {\n-                // It has uppercase only and no underscores. Ex: \"AABB\"\n-                // This is a camel cased acronym.\n-                DetectedCase::UpperCamelCase\n-            }\n-        } else if !has_underscore {\n-            if first_lowercase {\n-                DetectedCase::LowerCamelCase\n-            } else {\n-                DetectedCase::UpperCamelCase\n-            }\n-        } else {\n-            // It has uppercase, it has lowercase, it has underscore.\n-            // No assumptions here\n-            DetectedCase::Unknown\n-        }\n-    } else {\n-        DetectedCase::LowerSnakeCase\n-    }\n-}\n+// Code that was taken from rustc was taken at commit 89fdb30,\n+// from file /compiler/rustc_lint/src/nonstandard_style.rs\n \n /// Converts an identifier to an UpperCamelCase form.\n /// Returns `None` if the string is already is UpperCamelCase.\n pub fn to_camel_case(ident: &str) -> Option<String> {\n-    let detected_case = detect_case(ident);\n-\n-    match detected_case {\n-        DetectedCase::UpperCamelCase => return None,\n-        DetectedCase::LowerCamelCase => {\n-            let mut first_capitalized = false;\n-            let output = ident\n-                .chars()\n-                .map(|chr| {\n-                    if !first_capitalized && chr.is_ascii_lowercase() {\n-                        first_capitalized = true;\n-                        chr.to_ascii_uppercase()\n-                    } else {\n-                        chr\n-                    }\n-                })\n-                .collect();\n-            return Some(output);\n-        }\n-        _ => {}\n+    if is_camel_case(ident) {\n+        return None;\n     }\n \n-    let mut output = String::with_capacity(ident.len());\n-\n-    let mut capital_added = false;\n-    for chr in ident.chars() {\n-        if chr.is_alphabetic() {\n-            if !capital_added {\n-                output.push(chr.to_ascii_uppercase());\n-                capital_added = true;\n-            } else {\n-                output.push(chr.to_ascii_lowercase());\n+    // Taken from rustc.\n+    let ret = ident\n+        .trim_matches('_')\n+        .split('_')\n+        .filter(|component| !component.is_empty())\n+        .map(|component| {\n+            let mut camel_cased_component = String::new();\n+\n+            let mut new_word = true;\n+            let mut prev_is_lower_case = true;\n+\n+            for c in component.chars() {\n+                // Preserve the case if an uppercase letter follows a lowercase letter, so that\n+                // `camelCase` is converted to `CamelCase`.\n+                if prev_is_lower_case && c.is_uppercase() {\n+                    new_word = true;\n+                }\n+\n+                if new_word {\n+                    camel_cased_component.push_str(&c.to_uppercase().to_string());\n+                } else {\n+                    camel_cased_component.push_str(&c.to_lowercase().to_string());\n+                }\n+\n+                prev_is_lower_case = c.is_lowercase();\n+                new_word = false;\n             }\n-        } else if chr == '_' {\n-            // Skip this character and make the next one capital.\n-            capital_added = false;\n-        } else {\n-            // Put the characted as-is.\n-            output.push(chr);\n-        }\n-    }\n \n-    if output == ident {\n-        // While we didn't detect the correct case at the beginning, there\n-        // may be special cases: e.g. `A` is both valid CamelCase and UPPER_SNAKE_CASE.\n-        None\n-    } else {\n-        Some(output)\n-    }\n+            camel_cased_component\n+        })\n+        .fold((String::new(), None), |(acc, prev): (String, Option<String>), next| {\n+            // separate two components with an underscore if their boundary cannot\n+            // be distinguished using a uppercase/lowercase case distinction\n+            let join = if let Some(prev) = prev {\n+                let l = prev.chars().last().unwrap();\n+                let f = next.chars().next().unwrap();\n+                !char_has_case(l) && !char_has_case(f)\n+            } else {\n+                false\n+            };\n+            (acc + if join { \"_\" } else { \"\" } + &next, Some(next))\n+        })\n+        .0;\n+    Some(ret)\n }\n \n /// Converts an identifier to a lower_snake_case form.\n /// Returns `None` if the string is already in lower_snake_case.\n pub fn to_lower_snake_case(ident: &str) -> Option<String> {\n-    // First, assume that it's UPPER_SNAKE_CASE.\n-    match detect_case(ident) {\n-        DetectedCase::LowerSnakeCase => return None,\n-        DetectedCase::UpperSnakeCase => {\n-            return Some(ident.chars().map(|chr| chr.to_ascii_lowercase()).collect())\n-        }\n-        _ => {}\n+    if is_lower_snake_case(ident) {\n+        return None;\n+    } else if is_upper_snake_case(ident) {\n+        return Some(ident.to_lowercase());\n     }\n \n-    // Otherwise, assume that it's CamelCase.\n-    let lower_snake_case = stdx::to_lower_snake_case(ident);\n-\n-    if lower_snake_case == ident {\n-        // While we didn't detect the correct case at the beginning, there\n-        // may be special cases: e.g. `a` is both valid camelCase and snake_case.\n-        None\n-    } else {\n-        Some(lower_snake_case)\n-    }\n+    Some(stdx::to_lower_snake_case(ident))\n }\n \n /// Converts an identifier to an UPPER_SNAKE_CASE form.\n /// Returns `None` if the string is already is UPPER_SNAKE_CASE.\n pub fn to_upper_snake_case(ident: &str) -> Option<String> {\n-    match detect_case(ident) {\n-        DetectedCase::UpperSnakeCase => return None,\n-        DetectedCase::LowerSnakeCase => {\n-            return Some(ident.chars().map(|chr| chr.to_ascii_uppercase()).collect())\n-        }\n-        _ => {}\n+    if is_upper_snake_case(ident) {\n+        return None;\n+    } else if is_lower_snake_case(ident) {\n+        return Some(ident.to_uppercase());\n+    }\n+\n+    Some(stdx::to_upper_snake_case(ident))\n+}\n+\n+// Taken from rustc.\n+// Modified by replacing the use of unstable feature `array_windows`.\n+fn is_camel_case(name: &str) -> bool {\n+    let name = name.trim_matches('_');\n+    if name.is_empty() {\n+        return true;\n     }\n \n-    // Normalize the string from whatever form it's in currently, and then just make it uppercase.\n-    let upper_snake_case = stdx::to_upper_snake_case(ident);\n+    let mut fst = None;\n+    // start with a non-lowercase letter rather than non-uppercase\n+    // ones (some scripts don't have a concept of upper/lowercase)\n+    !name.chars().next().unwrap().is_lowercase()\n+        && !name.contains(\"__\")\n+        && !name.chars().any(|snd| {\n+            let ret = match (fst, snd) {\n+                (None, _) => false,\n+                (Some(fst), snd) => {\n+                    char_has_case(fst) && snd == '_' || char_has_case(snd) && fst == '_'\n+                }\n+            };\n+            fst = Some(snd);\n+\n+            ret\n+        })\n+}\n+\n+fn is_lower_snake_case(ident: &str) -> bool {\n+    is_snake_case(ident, char::is_uppercase)\n+}\n \n-    if upper_snake_case == ident {\n-        // While we didn't detect the correct case at the beginning, there\n-        // may be special cases: e.g. `A` is both valid CamelCase and UPPER_SNAKE_CASE.\n-        None\n-    } else {\n-        Some(upper_snake_case)\n+fn is_upper_snake_case(ident: &str) -> bool {\n+    is_snake_case(ident, char::is_lowercase)\n+}\n+\n+// Taken from rustc.\n+// Modified to allow checking for both upper and lower snake case.\n+fn is_snake_case<F: Fn(char) -> bool>(ident: &str, wrong_case: F) -> bool {\n+    if ident.is_empty() {\n+        return true;\n     }\n+    let ident = ident.trim_matches('_');\n+\n+    let mut allow_underscore = true;\n+    ident.chars().all(|c| {\n+        allow_underscore = match c {\n+            '_' if !allow_underscore => return false,\n+            '_' => false,\n+            // It would be more obvious to check for the correct case,\n+            // but some characters do not have a case.\n+            c if !wrong_case(c) => true,\n+            _ => return false,\n+        };\n+        true\n+    })\n+}\n+\n+// Taken from rustc.\n+fn char_has_case(c: char) -> bool {\n+    c.is_lowercase() || c.is_uppercase()\n }\n \n #[cfg(test)]\n@@ -173,6 +162,7 @@ mod tests {\n         check(to_lower_snake_case, \"CamelCase\", expect![[\"camel_case\"]]);\n         check(to_lower_snake_case, \"lowerCamelCase\", expect![[\"lower_camel_case\"]]);\n         check(to_lower_snake_case, \"a\", expect![[\"\"]]);\n+        check(to_lower_snake_case, \"abc\", expect![[\"\"]]);\n     }\n \n     #[test]\n@@ -187,6 +177,11 @@ mod tests {\n         check(to_camel_case, \"name\", expect![[\"Name\"]]);\n         check(to_camel_case, \"A\", expect![[\"\"]]);\n         check(to_camel_case, \"AABB\", expect![[\"\"]]);\n+        // Taken from rustc: /compiler/rustc_lint/src/nonstandard_style/tests.rs\n+        check(to_camel_case, \"X86_64\", expect![[\"\"]]);\n+        check(to_camel_case, \"x86__64\", expect![[\"X86_64\"]]);\n+        check(to_camel_case, \"Abc_123\", expect![[\"Abc123\"]]);\n+        check(to_camel_case, \"A1_b2_c3\", expect![[\"A1B2C3\"]]);\n     }\n \n     #[test]\n@@ -197,5 +192,7 @@ mod tests {\n         check(to_upper_snake_case, \"CamelCase\", expect![[\"CAMEL_CASE\"]]);\n         check(to_upper_snake_case, \"lowerCamelCase\", expect![[\"LOWER_CAMEL_CASE\"]]);\n         check(to_upper_snake_case, \"A\", expect![[\"\"]]);\n+        check(to_upper_snake_case, \"ABC\", expect![[\"\"]]);\n+        check(to_upper_snake_case, \"X86_64\", expect![[\"\"]]);\n     }\n }"}]}