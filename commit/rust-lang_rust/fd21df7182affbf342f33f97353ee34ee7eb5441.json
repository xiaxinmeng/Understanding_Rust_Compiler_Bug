{"sha": "fd21df7182affbf342f33f97353ee34ee7eb5441", "node_id": "C_kwDOAAsO6NoAKGZkMjFkZjcxODJhZmZiZjM0MmYzM2Y5NzM1M2VlMzRlZTdlYjU0NDE", "commit": {"author": {"name": "LingMan", "email": "LingMan@users.noreply.github.com", "date": "2022-09-10T05:30:29Z"}, "committer": {"name": "LingMan", "email": "LingMan@users.noreply.github.com", "date": "2022-09-11T02:13:33Z"}, "message": "Fix naming format of IEEE 754 standard\n\nCurrently the documentation of f64::min refers to \"IEEE-754 2008\" while the documentation of\nf64::minimum refers to \"IEEE 754-2019\".\nNote that one has the format IEEE,hyphen,number,space,year while the other is\nIEEE,space,number,hyphen,year. The official IEEE site [1] uses the later format and it is also the\none most commonly used throughout the codebase.\n\nUpdate all comments and - more importantly - documentation to consistently use the official format.\n\n[1] https://standards.ieee.org/ieee/754/4211/", "tree": {"sha": "cbc0f8950d6c7895700d9a04f0eb67be14c69e8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbc0f8950d6c7895700d9a04f0eb67be14c69e8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd21df7182affbf342f33f97353ee34ee7eb5441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd21df7182affbf342f33f97353ee34ee7eb5441", "html_url": "https://github.com/rust-lang/rust/commit/fd21df7182affbf342f33f97353ee34ee7eb5441", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd21df7182affbf342f33f97353ee34ee7eb5441/comments", "author": {"login": "LingMan", "id": 18645382, "node_id": "MDQ6VXNlcjE4NjQ1Mzgy", "avatar_url": "https://avatars.githubusercontent.com/u/18645382?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LingMan", "html_url": "https://github.com/LingMan", "followers_url": "https://api.github.com/users/LingMan/followers", "following_url": "https://api.github.com/users/LingMan/following{/other_user}", "gists_url": "https://api.github.com/users/LingMan/gists{/gist_id}", "starred_url": "https://api.github.com/users/LingMan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LingMan/subscriptions", "organizations_url": "https://api.github.com/users/LingMan/orgs", "repos_url": "https://api.github.com/users/LingMan/repos", "events_url": "https://api.github.com/users/LingMan/events{/privacy}", "received_events_url": "https://api.github.com/users/LingMan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LingMan", "id": 18645382, "node_id": "MDQ6VXNlcjE4NjQ1Mzgy", "avatar_url": "https://avatars.githubusercontent.com/u/18645382?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LingMan", "html_url": "https://github.com/LingMan", "followers_url": "https://api.github.com/users/LingMan/followers", "following_url": "https://api.github.com/users/LingMan/following{/other_user}", "gists_url": "https://api.github.com/users/LingMan/gists{/gist_id}", "starred_url": "https://api.github.com/users/LingMan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LingMan/subscriptions", "organizations_url": "https://api.github.com/users/LingMan/orgs", "repos_url": "https://api.github.com/users/LingMan/repos", "events_url": "https://api.github.com/users/LingMan/events{/privacy}", "received_events_url": "https://api.github.com/users/LingMan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87eb3e2dfad244025bd5ee3161be66c271f691d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/87eb3e2dfad244025bd5ee3161be66c271f691d8", "html_url": "https://github.com/rust-lang/rust/commit/87eb3e2dfad244025bd5ee3161be66c271f691d8"}], "stats": {"total": 40, "additions": 20, "deletions": 20}, "files": [{"sha": "d49e29b6e6e7fa82a9956b0d0d60847b9e819d21", "filename": "library/core/src/ffi/c_double.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd21df7182affbf342f33f97353ee34ee7eb5441/library%2Fcore%2Fsrc%2Fffi%2Fc_double.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd21df7182affbf342f33f97353ee34ee7eb5441/library%2Fcore%2Fsrc%2Fffi%2Fc_double.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_double.md?ref=fd21df7182affbf342f33f97353ee34ee7eb5441", "patch": "@@ -1,6 +1,6 @@\n Equivalent to C's `double` type.\n \n-This type will almost always be [`f64`], which is guaranteed to be an [IEEE-754 double-precision float] in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a [`float`], and it may be `f32` or something entirely different from the IEEE-754 standard.\n+This type will almost always be [`f64`], which is guaranteed to be an [IEEE 754 double-precision float] in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a [`float`], and it may be `f32` or something entirely different from the IEEE-754 standard.\n \n-[IEEE-754 double-precision float]: https://en.wikipedia.org/wiki/IEEE_754\n+[IEEE 754 double-precision float]: https://en.wikipedia.org/wiki/IEEE_754\n [`float`]: c_float"}, {"sha": "36374ef43618167b28090a6ed6be74114e84af74", "filename": "library/core/src/ffi/c_float.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd21df7182affbf342f33f97353ee34ee7eb5441/library%2Fcore%2Fsrc%2Fffi%2Fc_float.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd21df7182affbf342f33f97353ee34ee7eb5441/library%2Fcore%2Fsrc%2Fffi%2Fc_float.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_float.md?ref=fd21df7182affbf342f33f97353ee34ee7eb5441", "patch": "@@ -1,5 +1,5 @@\n Equivalent to C's `float` type.\n \n-This type will almost always be [`f32`], which is guaranteed to be an [IEEE-754 single-precision float] in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than `f32` or not follow the IEEE-754 standard at all.\n+This type will almost always be [`f32`], which is guaranteed to be an [IEEE 754 single-precision float] in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than `f32` or not follow the IEEE-754 standard at all.\n \n-[IEEE-754 single-precision float]: https://en.wikipedia.org/wiki/IEEE_754\n+[IEEE 754 single-precision float]: https://en.wikipedia.org/wiki/IEEE_754"}, {"sha": "2019f71e69b8c635e6d91b410c2403b57c81da32", "filename": "library/core/src/num/dec2flt/decimal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd21df7182affbf342f33f97353ee34ee7eb5441/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd21df7182affbf342f33f97353ee34ee7eb5441/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs?ref=fd21df7182affbf342f33f97353ee34ee7eb5441", "patch": "@@ -32,7 +32,7 @@ impl Default for Decimal {\n impl Decimal {\n     /// The maximum number of digits required to unambiguously round a float.\n     ///\n-    /// For a double-precision IEEE-754 float, this required 767 digits,\n+    /// For a double-precision IEEE 754 float, this required 767 digits,\n     /// so we store the max digits + 1.\n     ///\n     /// We can exactly represent a float in radix `b` from radix 2 if"}, {"sha": "2c6a0ba64f266ea5f4165a4040e9d80039173d06", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd21df7182affbf342f33f97353ee34ee7eb5441/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd21df7182affbf342f33f97353ee34ee7eb5441/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=fd21df7182affbf342f33f97353ee34ee7eb5441", "patch": "@@ -394,7 +394,7 @@ impl f32 {\n \n     /// Not a Number (NaN).\n     ///\n-    /// Note that IEEE-754 doesn't define just a single NaN value;\n+    /// Note that IEEE 754 doesn't define just a single NaN value;\n     /// a plethora of bit patterns are considered to be NaN.\n     /// Furthermore, the standard makes a difference\n     /// between a \"signaling\" and a \"quiet\" NaN,\n@@ -632,7 +632,7 @@ impl f32 {\n     }\n \n     /// Returns `true` if `self` has a positive sign, including `+0.0`, NaNs with\n-    /// positive sign bit and positive infinity. Note that IEEE-754 doesn't assign any\n+    /// positive sign bit and positive infinity. Note that IEEE 754 doesn't assign any\n     /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n     /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n     /// `is_sign_positive` on a NaN might produce an unexpected result in some cases.\n@@ -654,7 +654,7 @@ impl f32 {\n     }\n \n     /// Returns `true` if `self` has a negative sign, including `-0.0`, NaNs with\n-    /// negative sign bit and negative infinity. Note that IEEE-754 doesn't assign any\n+    /// negative sign bit and negative infinity. Note that IEEE 754 doesn't assign any\n     /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n     /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n     /// `is_sign_negative` on a NaN might produce an unexpected result in some cases.\n@@ -833,7 +833,7 @@ impl f32 {\n     /// Returns the maximum of the two numbers, ignoring NaN.\n     ///\n     /// If one of the arguments is NaN, then the other argument is returned.\n-    /// This follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs;\n+    /// This follows the IEEE 754-2008 semantics for maxNum, except for handling of signaling NaNs;\n     /// this function handles all NaNs the same way and avoids maxNum's problems with associativity.\n     /// This also matches the behavior of libm\u2019s fmax.\n     ///\n@@ -853,7 +853,7 @@ impl f32 {\n     /// Returns the minimum of the two numbers, ignoring NaN.\n     ///\n     /// If one of the arguments is NaN, then the other argument is returned.\n-    /// This follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs;\n+    /// This follows the IEEE 754-2008 semantics for minNum, except for handling of signaling NaNs;\n     /// this function handles all NaNs the same way and avoids minNum's problems with associativity.\n     /// This also matches the behavior of libm\u2019s fmin.\n     ///\n@@ -1051,9 +1051,9 @@ impl f32 {\n     /// It turns out this is incredibly portable, for two reasons:\n     ///\n     /// * Floats and Ints have the same endianness on all supported platforms.\n-    /// * IEEE-754 very precisely specifies the bit layout of floats.\n+    /// * IEEE 754 very precisely specifies the bit layout of floats.\n     ///\n-    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n+    /// However there is one caveat: prior to the 2008 version of IEEE 754, how\n     /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n     /// (notably x86 and ARM) picked the interpretation that was ultimately\n     /// standardized in 2008, but some didn't (notably MIPS). As a result, all"}, {"sha": "fd3c18ce29bd289c3822937e7e4c23b54dc661ad", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd21df7182affbf342f33f97353ee34ee7eb5441/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd21df7182affbf342f33f97353ee34ee7eb5441/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=fd21df7182affbf342f33f97353ee34ee7eb5441", "patch": "@@ -393,7 +393,7 @@ impl f64 {\n \n     /// Not a Number (NaN).\n     ///\n-    /// Note that IEEE-754 doesn't define just a single NaN value;\n+    /// Note that IEEE 754 doesn't define just a single NaN value;\n     /// a plethora of bit patterns are considered to be NaN.\n     /// Furthermore, the standard makes a difference\n     /// between a \"signaling\" and a \"quiet\" NaN,\n@@ -624,7 +624,7 @@ impl f64 {\n     }\n \n     /// Returns `true` if `self` has a positive sign, including `+0.0`, NaNs with\n-    /// positive sign bit and positive infinity. Note that IEEE-754 doesn't assign any\n+    /// positive sign bit and positive infinity. Note that IEEE 754 doesn't assign any\n     /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n     /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n     /// `is_sign_positive` on a NaN might produce an unexpected result in some cases.\n@@ -655,7 +655,7 @@ impl f64 {\n     }\n \n     /// Returns `true` if `self` has a negative sign, including `-0.0`, NaNs with\n-    /// negative sign bit and negative infinity. Note that IEEE-754 doesn't assign any\n+    /// negative sign bit and negative infinity. Note that IEEE 754 doesn't assign any\n     /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n     /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n     /// `is_sign_negative` on a NaN might produce an unexpected result in some cases.\n@@ -844,7 +844,7 @@ impl f64 {\n     /// Returns the maximum of the two numbers, ignoring NaN.\n     ///\n     /// If one of the arguments is NaN, then the other argument is returned.\n-    /// This follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs;\n+    /// This follows the IEEE 754-2008 semantics for maxNum, except for handling of signaling NaNs;\n     /// this function handles all NaNs the same way and avoids maxNum's problems with associativity.\n     /// This also matches the behavior of libm\u2019s fmax.\n     ///\n@@ -864,7 +864,7 @@ impl f64 {\n     /// Returns the minimum of the two numbers, ignoring NaN.\n     ///\n     /// If one of the arguments is NaN, then the other argument is returned.\n-    /// This follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs;\n+    /// This follows the IEEE 754-2008 semantics for minNum, except for handling of signaling NaNs;\n     /// this function handles all NaNs the same way and avoids minNum's problems with associativity.\n     /// This also matches the behavior of libm\u2019s fmin.\n     ///\n@@ -1044,9 +1044,9 @@ impl f64 {\n     /// It turns out this is incredibly portable, for two reasons:\n     ///\n     /// * Floats and Ints have the same endianness on all supported platforms.\n-    /// * IEEE-754 very precisely specifies the bit layout of floats.\n+    /// * IEEE 754 very precisely specifies the bit layout of floats.\n     ///\n-    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n+    /// However there is one caveat: prior to the 2008 version of IEEE 754, how\n     /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n     /// (notably x86 and ARM) picked the interpretation that was ultimately\n     /// standardized in 2008, but some didn't (notably MIPS). As a result, all"}, {"sha": "b33b080126131da2594b861682e59105e5ba8a31", "filename": "library/test/src/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd21df7182affbf342f33f97353ee34ee7eb5441/library%2Ftest%2Fsrc%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd21df7182affbf342f33f97353ee34ee7eb5441/library%2Ftest%2Fsrc%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fstats.rs?ref=fd21df7182affbf342f33f97353ee34ee7eb5441", "patch": "@@ -14,7 +14,7 @@ pub trait Stats {\n     /// Sum of the samples.\n     ///\n     /// Note: this method sacrifices performance at the altar of accuracy\n-    /// Depends on IEEE-754 arithmetic guarantees. See proof of correctness at:\n+    /// Depends on IEEE 754 arithmetic guarantees. See proof of correctness at:\n     /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric\n     /// Predicates\"][paper]\n     ///"}]}