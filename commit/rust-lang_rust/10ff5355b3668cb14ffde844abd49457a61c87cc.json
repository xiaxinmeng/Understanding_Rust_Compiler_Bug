{"sha": "10ff5355b3668cb14ffde844abd49457a61c87cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwZmY1MzU1YjM2NjhjYjE0ZmZkZTg0NGFiZDQ5NDU3YTYxYzg3Y2M=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-21T17:31:51Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T23:31:58Z"}, "message": "std: UvFileStream implements HomingIO + .home_for_io() wrapper usage", "tree": {"sha": "1e4b4e309f4eb76c5cb903464aff6e96f0278fa8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e4b4e309f4eb76c5cb903464aff6e96f0278fa8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10ff5355b3668cb14ffde844abd49457a61c87cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10ff5355b3668cb14ffde844abd49457a61c87cc", "html_url": "https://github.com/rust-lang/rust/commit/10ff5355b3668cb14ffde844abd49457a61c87cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10ff5355b3668cb14ffde844abd49457a61c87cc/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3a819b01c4993585ea38c9fbb5dadc6c59bbe05", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3a819b01c4993585ea38c9fbb5dadc6c59bbe05", "html_url": "https://github.com/rust-lang/rust/commit/c3a819b01c4993585ea38c9fbb5dadc6c59bbe05"}], "stats": {"total": 99, "additions": 60, "deletions": 39}, "files": [{"sha": "4dfeb3fccdbd43f12d84dcf62b8790a997518751", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 60, "deletions": 39, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/10ff5355b3668cb14ffde844abd49457a61c87cc/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ff5355b3668cb14ffde844abd49457a61c87cc/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=10ff5355b3668cb14ffde844abd49457a61c87cc", "patch": "@@ -460,11 +460,10 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream {\n-        ~UvFileStream {\n-            loop_: Loop{handle:self.uv_loop().native_handle()},\n-            fd: file::FileDescriptor(fd),\n-            close_on_drop: close_on_drop,\n-        } as ~RtioFileStream\n+        let loop_ = Loop {handle: self.uv_loop().native_handle()};\n+        let fd = file::FileDescriptor(fd);\n+        let home = get_handle_to_current_scheduler!();\n+        ~UvFileStream::new(loop_, fd, close_on_drop, home) as ~RtioFileStream\n     }\n \n     fn fs_open<P: PathLike>(&mut self, path: &P, flags: int, mode: int)\n@@ -480,10 +479,11 @@ impl IoFactory for UvIoFactory {\n             let path = path_cell.take();\n             do file::FileDescriptor::open(loop_, path, flags, mode) |req,err| {\n                 if err.is_none() {\n-                    let res = Ok(~UvFileStream {\n-                        loop_: loop_,\n-                        fd: file::FileDescriptor(req.get_result()),\n-                        close_on_drop: true} as ~RtioFileStream);\n+                    let home = get_handle_to_current_scheduler!();\n+                    let fd = file::FileDescriptor(req.get_result());\n+                    let fs = ~UvFileStream::new(\n+                        loop_, fd, true, home) as ~RtioFileStream;\n+                    let res = Ok(fs);\n                     unsafe { (*result_cell_ptr).put_back(res); }\n                     let scheduler = Local::take::<Scheduler>();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n@@ -1061,46 +1061,64 @@ impl RtioTimer for UvTimer {\n pub struct UvFileStream {\n     loop_: Loop,\n     fd: file::FileDescriptor,\n-    close_on_drop: bool\n+    close_on_drop: bool,\n+    home: SchedHandle\n+}\n+\n+impl HomingIO for UvFileStream {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n }\n \n impl UvFileStream {\n+    fn new(loop_: Loop, fd: file::FileDescriptor, close_on_drop: bool,\n+           home: SchedHandle) -> UvFileStream {\n+        UvFileStream {\n+            loop_: loop_,\n+            fd: fd,\n+            close_on_drop: close_on_drop,\n+            home: home\n+        }\n+    }\n     fn base_read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> {\n-        let scheduler = Local::take::<Scheduler>();\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<int, IoError>> = &result_cell;\n         let buf_ptr: *&mut [u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-            let task_cell = Cell::new(task);\n-            do self.fd.read(self.loop_, buf, offset) |req, uverr| {\n-                let res = match uverr  {\n-                    None => Ok(req.get_result() as int),\n-                    Some(err) => Err(uv_error_to_io_error(err))\n+        do self.home_for_io |self_| {\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+                let task_cell = Cell::new(task);\n+                do self_.fd.read(self.loop_, buf, offset) |req, uverr| {\n+                    let res = match uverr  {\n+                        None => Ok(req.get_result() as int),\n+                        Some(err) => Err(uv_error_to_io_error(err))\n+                    };\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n                 };\n-                unsafe { (*result_cell_ptr).put_back(res); }\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n             };\n         };\n         result_cell.take()\n     }\n     fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n-        let scheduler = Local::take::<Scheduler>();\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let buf_ptr: *&[u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-            let task_cell = Cell::new(task);\n-            do self.fd.write(self.loop_, buf, offset) |_, uverr| {\n-                let res = match uverr  {\n-                    None => Ok(()),\n-                    Some(err) => Err(uv_error_to_io_error(err))\n+        do self.home_for_io |self_| {\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+                let task_cell = Cell::new(task);\n+                do self_.fd.write(self.loop_, buf, offset) |_, uverr| {\n+                    let res = match uverr  {\n+                        None => Ok(()),\n+                        Some(err) => Err(uv_error_to_io_error(err))\n+                    };\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n                 };\n-                unsafe { (*result_cell_ptr).put_back(res); }\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n             };\n         };\n         result_cell.take()\n@@ -1109,15 +1127,18 @@ impl UvFileStream {\n \n impl Drop for UvFileStream {\n     fn drop(&self) {\n+        let self_ = unsafe { transmute::<&UvFileStream, &mut UvFileStream>(self) };\n         if self.close_on_drop {\n-            let scheduler = Local::take::<Scheduler>();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self.fd.close(self.loop_) |_,_| {\n-                    let scheduler = Local::take::<Scheduler>();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+            do self_.home_for_io |self_| {\n+                let scheduler = Local::take::<Scheduler>();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    let task_cell = Cell::new(task);\n+                    do self_.fd.close(self.loop_) |_,_| {\n+                        let scheduler = Local::take::<Scheduler>();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    };\n                 };\n-            };\n+            }\n         }\n     }\n }"}]}