{"sha": "278556f9fe8240f0c76daaaf8dcf7ee7f516e4af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ODU1NmY5ZmU4MjQwZjBjNzZkYWFhZjhkY2Y3ZWU3ZjUxNmU0YWY=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-16T12:52:43Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-24T14:53:16Z"}, "message": "Move ItemTree lowering into its own module", "tree": {"sha": "d1530234920907b99177b7e02ef3556460a74fb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1530234920907b99177b7e02ef3556460a74fb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/278556f9fe8240f0c76daaaf8dcf7ee7f516e4af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/278556f9fe8240f0c76daaaf8dcf7ee7f516e4af", "html_url": "https://github.com/rust-lang/rust/commit/278556f9fe8240f0c76daaaf8dcf7ee7f516e4af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/278556f9fe8240f0c76daaaf8dcf7ee7f516e4af/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9e5ba7d40680f8df96f33a8721ecc2eaab08ab6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9e5ba7d40680f8df96f33a8721ecc2eaab08ab6", "html_url": "https://github.com/rust-lang/rust/commit/f9e5ba7d40680f8df96f33a8721ecc2eaab08ab6"}], "stats": {"total": 1018, "additions": 513, "deletions": 505}, "files": [{"sha": "a13a989ddacbe1fffb6912263d5f9958be67ec6a", "filename": "crates/ra_hir_def/src/item_tree.rs", "status": "modified", "additions": 12, "deletions": 505, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/278556f9fe8240f0c76daaaf8dcf7ee7f516e4af/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278556f9fe8240f0c76daaaf8dcf7ee7f516e4af/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs?ref=278556f9fe8240f0c76daaaf8dcf7ee7f516e4af", "patch": "@@ -1,13 +1,23 @@\n //! A simplified AST that only contains items.\n \n+mod lower;\n+\n+use std::{\n+    ops::{Index, Range},\n+    sync::Arc,\n+};\n+\n+use ast::{AstNode, AttrsOwner, ModuleItemOwner, NameOwner, StructKind, TypeAscriptionOwner};\n+use either::Either;\n use hir_expand::{\n-    ast_id_map::{AstIdMap, FileAstId},\n+    ast_id_map::FileAstId,\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n     HirFileId, InFile,\n };\n use ra_arena::{Arena, Idx, RawId};\n use ra_syntax::{ast, match_ast};\n+use rustc_hash::FxHashMap;\n use test_utils::mark;\n \n use crate::{\n@@ -18,14 +28,6 @@ use crate::{\n     type_ref::{Mutability, TypeBound, TypeRef},\n     visibility::RawVisibility,\n };\n-use ast::{AstNode, AttrsOwner, ModuleItemOwner, NameOwner, StructKind, TypeAscriptionOwner};\n-use either::Either;\n-use rustc_hash::FxHashMap;\n-use smallvec::SmallVec;\n-use std::{\n-    ops::{Index, Range},\n-    sync::Arc,\n-};\n \n /// The item tree of a source file.\n #[derive(Debug, Default, Eq, PartialEq)]\n@@ -80,7 +82,7 @@ impl ItemTree {\n         };\n \n         let map = db.ast_id_map(file_id);\n-        let mut ctx = Ctx {\n+        let mut ctx = lower::Ctx {\n             tree: ItemTree::default(),\n             hygiene,\n             file: file_id,\n@@ -366,498 +368,3 @@ pub struct Field {\n     pub type_ref: TypeRef,\n     pub visibility: RawVisibility,\n }\n-\n-struct ModItems(SmallVec<[ModItem; 1]>);\n-\n-impl<T> From<T> for ModItems\n-where\n-    T: Into<ModItem>,\n-{\n-    fn from(t: T) -> Self {\n-        ModItems(SmallVec::from_buf([t.into(); 1]))\n-    }\n-}\n-\n-struct Ctx {\n-    tree: ItemTree,\n-    hygiene: Hygiene,\n-    file: HirFileId,\n-    source_ast_id_map: Arc<AstIdMap>,\n-    body_ctx: crate::body::LowerCtx,\n-}\n-\n-impl Ctx {\n-    fn lower(mut self, item_owner: &dyn ModuleItemOwner) -> ItemTree {\n-        self.tree.top_level = item_owner\n-            .items()\n-            .flat_map(|item| self.lower_mod_item(&item))\n-            .flat_map(|items| items.0)\n-            .collect();\n-        self.tree\n-    }\n-\n-    fn lower_mod_item(&mut self, item: &ast::ModuleItem) -> Option<ModItems> {\n-        let attrs = Attrs::new(item, &self.hygiene);\n-        let items = match item {\n-            ast::ModuleItem::StructDef(ast) => {\n-                self.lower_struct(ast).map(|data| self.tree.structs.alloc(data).into())\n-            }\n-            ast::ModuleItem::UnionDef(ast) => {\n-                self.lower_union(ast).map(|data| self.tree.unions.alloc(data).into())\n-            }\n-            ast::ModuleItem::EnumDef(ast) => {\n-                self.lower_enum(ast).map(|data| self.tree.enums.alloc(data).into())\n-            }\n-            ast::ModuleItem::FnDef(ast) => {\n-                self.lower_function(ast).map(|data| self.tree.functions.alloc(data).into())\n-            }\n-            ast::ModuleItem::TypeAliasDef(ast) => {\n-                self.lower_type_alias(ast).map(|data| self.tree.type_aliases.alloc(data).into())\n-            }\n-            ast::ModuleItem::StaticDef(ast) => {\n-                self.lower_static(ast).map(|data| self.tree.statics.alloc(data).into())\n-            }\n-            ast::ModuleItem::ConstDef(ast) => {\n-                let data = self.lower_const(ast);\n-                Some(self.tree.consts.alloc(data).into())\n-            }\n-            ast::ModuleItem::Module(ast) => {\n-                self.lower_module(ast).map(|data| self.tree.mods.alloc(data).into())\n-            }\n-            ast::ModuleItem::TraitDef(ast) => {\n-                self.lower_trait(ast).map(|data| self.tree.traits.alloc(data).into())\n-            }\n-            ast::ModuleItem::ImplDef(ast) => {\n-                self.lower_impl(ast).map(|data| self.tree.impls.alloc(data).into())\n-            }\n-            ast::ModuleItem::UseItem(ast) => Some(ModItems(\n-                self.lower_use(ast)\n-                    .into_iter()\n-                    .map(|data| self.tree.imports.alloc(data).into())\n-                    .collect::<SmallVec<_>>(),\n-            )),\n-            ast::ModuleItem::ExternCrateItem(ast) => {\n-                self.lower_extern_crate(ast).map(|data| self.tree.imports.alloc(data).into())\n-            }\n-            ast::ModuleItem::MacroCall(ast) => {\n-                self.lower_macro_call(ast).map(|data| self.tree.macro_calls.alloc(data).into())\n-            }\n-            ast::ModuleItem::ExternBlock(ast) => Some(ModItems(\n-                self.lower_extern_block(ast)\n-                    .into_iter()\n-                    .map(|item| match item {\n-                        Either::Left(func) => self.tree.functions.alloc(func).into(),\n-                        Either::Right(statik) => self.tree.statics.alloc(statik).into(),\n-                    })\n-                    .collect::<SmallVec<_>>(),\n-            )),\n-        };\n-\n-        if !attrs.is_empty() {\n-            for item in items.iter().flat_map(|items| &items.0) {\n-                self.tree.attrs.insert(*item, attrs.clone());\n-            }\n-        }\n-\n-        items\n-    }\n-\n-    fn lower_assoc_item(&mut self, item: &ast::AssocItem) -> Option<AssocItem> {\n-        match item {\n-            ast::AssocItem::FnDef(ast) => {\n-                self.lower_function(ast).map(|data| self.tree.functions.alloc(data).into())\n-            }\n-            ast::AssocItem::TypeAliasDef(ast) => {\n-                self.lower_type_alias(ast).map(|data| self.tree.type_aliases.alloc(data).into())\n-            }\n-            ast::AssocItem::ConstDef(ast) => {\n-                let data = self.lower_const(ast);\n-                Some(self.tree.consts.alloc(data).into())\n-            }\n-        }\n-    }\n-\n-    fn lower_struct(&mut self, strukt: &ast::StructDef) -> Option<Struct> {\n-        let attrs = self.lower_attrs(strukt);\n-        let visibility = self.lower_visibility(strukt);\n-        let name = strukt.name()?.as_name();\n-        let generic_params = self.lower_generic_params(strukt);\n-        let fields = self.lower_fields(&strukt.kind());\n-        let ast_id = self.source_ast_id_map.ast_id(strukt);\n-        let kind = match strukt.kind() {\n-            ast::StructKind::Record(_) => StructDefKind::Record,\n-            ast::StructKind::Tuple(_) => StructDefKind::Tuple,\n-            ast::StructKind::Unit => StructDefKind::Unit,\n-        };\n-        let res = Struct { name, attrs, visibility, generic_params, fields, ast_id, kind };\n-        Some(res)\n-    }\n-\n-    fn lower_fields(&mut self, strukt_kind: &ast::StructKind) -> Fields {\n-        match strukt_kind {\n-            ast::StructKind::Record(it) => {\n-                let range = self.lower_record_fields(it);\n-                Fields::Record(range)\n-            }\n-            ast::StructKind::Tuple(it) => {\n-                let range = self.lower_tuple_fields(it);\n-                Fields::Tuple(range)\n-            }\n-            ast::StructKind::Unit => Fields::Unit,\n-        }\n-    }\n-\n-    fn lower_record_fields(&mut self, fields: &ast::RecordFieldDefList) -> Range<Idx<Field>> {\n-        let start = self.next_field_idx();\n-        for field in fields.fields() {\n-            if let Some(data) = self.lower_record_field(&field) {\n-                self.tree.fields.alloc(data);\n-            }\n-        }\n-        let end = self.next_field_idx();\n-        start..end\n-    }\n-\n-    fn lower_record_field(&self, field: &ast::RecordFieldDef) -> Option<Field> {\n-        let name = field.name()?.as_name();\n-        let visibility = self.lower_visibility(field);\n-        let type_ref = self.lower_type_ref(&field.ascribed_type()?);\n-        let res = Field { name, type_ref, visibility };\n-        Some(res)\n-    }\n-\n-    fn lower_tuple_fields(&mut self, fields: &ast::TupleFieldDefList) -> Range<Idx<Field>> {\n-        let start = self.next_field_idx();\n-        for (i, field) in fields.fields().enumerate() {\n-            if let Some(data) = self.lower_tuple_field(i, &field) {\n-                self.tree.fields.alloc(data);\n-            }\n-        }\n-        let end = self.next_field_idx();\n-        start..end\n-    }\n-\n-    fn lower_tuple_field(&self, idx: usize, field: &ast::TupleFieldDef) -> Option<Field> {\n-        let name = Name::new_tuple_field(idx);\n-        let visibility = self.lower_visibility(field);\n-        let type_ref = self.lower_type_ref(&field.type_ref()?);\n-        let res = Field { name, type_ref, visibility };\n-        Some(res)\n-    }\n-\n-    fn lower_union(&mut self, union: &ast::UnionDef) -> Option<Union> {\n-        let attrs = self.lower_attrs(union);\n-        let visibility = self.lower_visibility(union);\n-        let name = union.name()?.as_name();\n-        let generic_params = self.lower_generic_params(union);\n-        let fields = match union.record_field_def_list() {\n-            Some(record_field_def_list) => {\n-                self.lower_fields(&StructKind::Record(record_field_def_list))\n-            }\n-            None => Fields::Record(self.next_field_idx()..self.next_field_idx()),\n-        };\n-        let ast_id = self.source_ast_id_map.ast_id(union);\n-        let res = Union { name, attrs, visibility, generic_params, fields, ast_id };\n-        Some(res)\n-    }\n-\n-    fn lower_enum(&mut self, enum_: &ast::EnumDef) -> Option<Enum> {\n-        let attrs = self.lower_attrs(enum_);\n-        let visibility = self.lower_visibility(enum_);\n-        let name = enum_.name()?.as_name();\n-        let generic_params = self.lower_generic_params(enum_);\n-        let variants = match &enum_.variant_list() {\n-            Some(variant_list) => self.lower_variants(variant_list),\n-            None => self.next_variant_idx()..self.next_variant_idx(),\n-        };\n-        let ast_id = self.source_ast_id_map.ast_id(enum_);\n-        let res = Enum { name, attrs, visibility, generic_params, variants, ast_id };\n-        Some(res)\n-    }\n-\n-    fn lower_variants(&mut self, variants: &ast::EnumVariantList) -> Range<Idx<Variant>> {\n-        let start = self.next_variant_idx();\n-        for variant in variants.variants() {\n-            if let Some(data) = self.lower_variant(&variant) {\n-                self.tree.variants.alloc(data);\n-            }\n-        }\n-        let end = self.next_variant_idx();\n-        start..end\n-    }\n-\n-    fn lower_variant(&mut self, variant: &ast::EnumVariant) -> Option<Variant> {\n-        let name = variant.name()?.as_name();\n-        let fields = self.lower_fields(&variant.kind());\n-        let res = Variant { name, fields };\n-        Some(res)\n-    }\n-\n-    fn lower_function(&mut self, func: &ast::FnDef) -> Option<Function> {\n-        let attrs = self.lower_attrs(func);\n-        let visibility = self.lower_visibility(func);\n-        let name = func.name()?.as_name();\n-        let generic_params = self.lower_generic_params(func);\n-\n-        let mut params = Vec::new();\n-        let mut has_self_param = false;\n-        if let Some(param_list) = func.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n-                    TypeRef::from_ast(&self.body_ctx, type_ref)\n-                } else {\n-                    let self_type = TypeRef::Path(name![Self].into());\n-                    match self_param.kind() {\n-                        ast::SelfParamKind::Owned => self_type,\n-                        ast::SelfParamKind::Ref => {\n-                            TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n-                        }\n-                        ast::SelfParamKind::MutRef => {\n-                            TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n-                        }\n-                    }\n-                };\n-                params.push(self_type);\n-                has_self_param = true;\n-            }\n-            for param in param_list.params() {\n-                let type_ref = TypeRef::from_ast_opt(&self.body_ctx, param.ascribed_type());\n-                params.push(type_ref);\n-            }\n-        }\n-        let ret_type = match func.ret_type().and_then(|rt| rt.type_ref()) {\n-            Some(type_ref) => TypeRef::from_ast(&self.body_ctx, type_ref),\n-            _ => TypeRef::unit(),\n-        };\n-\n-        let ret_type = if func.async_token().is_some() {\n-            let future_impl = desugar_future_path(ret_type);\n-            let ty_bound = TypeBound::Path(future_impl);\n-            TypeRef::ImplTrait(vec![ty_bound])\n-        } else {\n-            ret_type\n-        };\n-\n-        let ast_id = self.source_ast_id_map.ast_id(func);\n-        let res = Function {\n-            name,\n-            attrs,\n-            visibility,\n-            generic_params,\n-            has_self_param,\n-            params,\n-            ret_type,\n-            ast_id,\n-        };\n-        Some(res)\n-    }\n-\n-    fn lower_type_alias(&mut self, type_alias: &ast::TypeAliasDef) -> Option<TypeAlias> {\n-        let name = type_alias.name()?.as_name();\n-        let type_ref = type_alias.type_ref().map(|it| self.lower_type_ref(&it));\n-        let visibility = self.lower_visibility(type_alias);\n-        let generic_params = self.lower_generic_params(type_alias);\n-        let ast_id = self.source_ast_id_map.ast_id(type_alias);\n-        let res = TypeAlias { name, visibility, generic_params, type_ref, ast_id };\n-        Some(res)\n-    }\n-\n-    fn lower_static(&mut self, static_: &ast::StaticDef) -> Option<Static> {\n-        let name = static_.name()?.as_name();\n-        let type_ref = self.lower_type_ref_opt(static_.ascribed_type());\n-        let visibility = self.lower_visibility(static_);\n-        let ast_id = self.source_ast_id_map.ast_id(static_);\n-        let res = Static { name, visibility, type_ref, ast_id };\n-        Some(res)\n-    }\n-\n-    fn lower_const(&mut self, konst: &ast::ConstDef) -> Const {\n-        let name = konst.name().map(|it| it.as_name());\n-        let type_ref = self.lower_type_ref_opt(konst.ascribed_type());\n-        let visibility = self.lower_visibility(konst);\n-        let ast_id = self.source_ast_id_map.ast_id(konst);\n-        Const { name, visibility, type_ref, ast_id }\n-    }\n-\n-    fn lower_module(&mut self, module: &ast::Module) -> Option<Mod> {\n-        let name = module.name()?.as_name();\n-        let visibility = self.lower_visibility(module);\n-        let kind = if module.semicolon_token().is_some() {\n-            ModKind::Outline {}\n-        } else {\n-            ModKind::Inline {\n-                items: module\n-                    .item_list()\n-                    .map(|list| {\n-                        list.items()\n-                            .flat_map(|item| self.lower_mod_item(&item))\n-                            .flat_map(|items| items.0)\n-                            .collect()\n-                    })\n-                    .unwrap_or_else(|| {\n-                        mark::hit!(name_res_works_for_broken_modules);\n-                        Vec::new()\n-                    }),\n-            }\n-        };\n-        let ast_id = self.source_ast_id_map.ast_id(module);\n-        Some(Mod { name, visibility, kind, ast_id })\n-    }\n-\n-    fn lower_trait(&mut self, trait_def: &ast::TraitDef) -> Option<Trait> {\n-        let name = trait_def.name()?.as_name();\n-        let visibility = self.lower_visibility(trait_def);\n-        let generic_params = self.lower_generic_params(trait_def);\n-        let auto = trait_def.auto_token().is_some();\n-        let items = trait_def.item_list().map(|list| {\n-            // FIXME: Does not handle macros\n-            list.assoc_items().flat_map(|item| self.lower_assoc_item(&item)).collect()\n-        });\n-        let ast_id = self.source_ast_id_map.ast_id(trait_def);\n-        Some(Trait {\n-            name,\n-            visibility,\n-            generic_params,\n-            auto,\n-            items: items.unwrap_or_default(),\n-            ast_id,\n-        })\n-    }\n-\n-    fn lower_impl(&mut self, impl_def: &ast::ImplDef) -> Option<Impl> {\n-        let generic_params = self.lower_generic_params(impl_def);\n-        let target_trait = impl_def.target_trait().map(|tr| self.lower_type_ref(&tr));\n-        let target_type = self.lower_type_ref(&impl_def.target_type()?);\n-        let is_negative = impl_def.excl_token().is_some();\n-        let items = impl_def\n-            .item_list()?\n-            .assoc_items()\n-            .filter_map(|item| self.lower_assoc_item(&item))\n-            .collect();\n-        let ast_id = self.source_ast_id_map.ast_id(impl_def);\n-        Some(Impl { generic_params, target_trait, target_type, is_negative, items, ast_id })\n-    }\n-\n-    fn lower_use(&mut self, use_item: &ast::UseItem) -> Vec<Import> {\n-        // FIXME: cfg_attr\n-        let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n-        let visibility = self.lower_visibility(use_item);\n-\n-        // Every use item can expand to many `Import`s.\n-        let mut imports = Vec::new();\n-        ModPath::expand_use_item(\n-            InFile::new(self.file, use_item.clone()),\n-            &self.hygiene,\n-            |path, _tree, is_glob, alias| {\n-                imports.push(Import {\n-                    path,\n-                    alias,\n-                    visibility: visibility.clone(),\n-                    is_glob,\n-                    is_prelude,\n-                    is_extern_crate: false,\n-                    is_macro_use: false,\n-                });\n-            },\n-        );\n-\n-        imports\n-    }\n-\n-    fn lower_extern_crate(&mut self, extern_crate: &ast::ExternCrateItem) -> Option<Import> {\n-        let path = ModPath::from_name_ref(&extern_crate.name_ref()?);\n-        let alias = extern_crate.alias().map(|a| {\n-            a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n-        });\n-        let visibility = self.lower_visibility(extern_crate);\n-        // FIXME: cfg_attr\n-        let is_macro_use = extern_crate.has_atom_attr(\"macro_use\");\n-\n-        Some(Import {\n-            path,\n-            alias,\n-            visibility,\n-            is_glob: false,\n-            is_prelude: false,\n-            is_extern_crate: true,\n-            is_macro_use,\n-        })\n-    }\n-\n-    fn lower_macro_call(&mut self, m: &ast::MacroCall) -> Option<MacroCall> {\n-        let name = m.name().map(|it| it.as_name());\n-        let attrs = Attrs::new(m, &self.hygiene);\n-        let path = ModPath::from_src(m.path()?, &self.hygiene)?;\n-\n-        let ast_id = self.source_ast_id_map.ast_id(m);\n-\n-        // FIXME: cfg_attr\n-        let export_attr = attrs.by_key(\"macro_export\");\n-\n-        let is_export = export_attr.exists();\n-        let is_local_inner = if is_export {\n-            export_attr.tt_values().map(|it| &it.token_trees).flatten().any(|it| match it {\n-                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n-                    ident.text.contains(\"local_inner_macros\")\n-                }\n-                _ => false,\n-            })\n-        } else {\n-            false\n-        };\n-\n-        let is_builtin = attrs.by_key(\"rustc_builtin_macro\").exists();\n-        Some(MacroCall { name, path, is_export, is_builtin, is_local_inner, ast_id })\n-    }\n-\n-    fn lower_extern_block(&mut self, block: &ast::ExternBlock) -> Vec<Either<Function, Static>> {\n-        block.extern_item_list().map_or(Vec::new(), |list| {\n-            list.extern_items()\n-                .filter_map(|item| match item {\n-                    ast::ExternItem::FnDef(ast) => self.lower_function(&ast).map(Either::Left),\n-                    ast::ExternItem::StaticDef(ast) => self.lower_static(&ast).map(Either::Right),\n-                })\n-                .collect()\n-        })\n-    }\n-\n-    fn lower_generic_params(\n-        &mut self,\n-        _item: &impl ast::TypeParamsOwner,\n-    ) -> generics::GenericParams {\n-        // TODO\n-        generics::GenericParams { types: Arena::new(), where_predicates: Vec::new() }\n-    }\n-\n-    fn lower_attrs(&self, item: &impl ast::AttrsOwner) -> Attrs {\n-        Attrs::new(item, &self.hygiene)\n-    }\n-    fn lower_visibility(&self, item: &impl ast::VisibilityOwner) -> RawVisibility {\n-        RawVisibility::from_ast_with_hygiene(item.visibility(), &self.hygiene)\n-    }\n-    fn lower_type_ref(&self, type_ref: &ast::TypeRef) -> TypeRef {\n-        TypeRef::from_ast(&self.body_ctx, type_ref.clone())\n-    }\n-    fn lower_type_ref_opt(&self, type_ref: Option<ast::TypeRef>) -> TypeRef {\n-        TypeRef::from_ast_opt(&self.body_ctx, type_ref)\n-    }\n-\n-    fn next_field_idx(&self) -> Idx<Field> {\n-        Idx::from_raw(RawId::from(self.tree.fields.len() as u32))\n-    }\n-    fn next_variant_idx(&self) -> Idx<Variant> {\n-        Idx::from_raw(RawId::from(self.tree.variants.len() as u32))\n-    }\n-}\n-\n-fn desugar_future_path(orig: TypeRef) -> Path {\n-    let path = path![core::future::Future];\n-    let mut generic_args: Vec<_> = std::iter::repeat(None).take(path.segments.len() - 1).collect();\n-    let mut last = GenericArgs::empty();\n-    let binding =\n-        AssociatedTypeBinding { name: name![Output], type_ref: Some(orig), bounds: Vec::new() };\n-    last.bindings.push(binding);\n-    generic_args.push(Some(Arc::new(last)));\n-\n-    Path::from_known_path(path, generic_args)\n-}"}, {"sha": "d123a73106dd2c9a58926fe330e0cded88615171", "filename": "crates/ra_hir_def/src/item_tree/lower.rs", "status": "added", "additions": 501, "deletions": 0, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/278556f9fe8240f0c76daaaf8dcf7ee7f516e4af/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278556f9fe8240f0c76daaaf8dcf7ee7f516e4af/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=278556f9fe8240f0c76daaaf8dcf7ee7f516e4af", "patch": "@@ -0,0 +1,501 @@\n+use super::*;\n+use crate::attr::Attrs;\n+use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, HirFileId};\n+use ra_syntax::ast::{self, ModuleItemOwner};\n+use smallvec::SmallVec;\n+use std::sync::Arc;\n+\n+struct ModItems(SmallVec<[ModItem; 1]>);\n+\n+impl<T> From<T> for ModItems\n+where\n+    T: Into<ModItem>,\n+{\n+    fn from(t: T) -> Self {\n+        ModItems(SmallVec::from_buf([t.into(); 1]))\n+    }\n+}\n+\n+pub(super) struct Ctx {\n+    pub tree: ItemTree,\n+    pub hygiene: Hygiene,\n+    pub file: HirFileId,\n+    pub source_ast_id_map: Arc<AstIdMap>,\n+    pub body_ctx: crate::body::LowerCtx,\n+}\n+\n+impl Ctx {\n+    pub(super) fn lower(mut self, item_owner: &dyn ModuleItemOwner) -> ItemTree {\n+        self.tree.top_level = item_owner\n+            .items()\n+            .flat_map(|item| self.lower_mod_item(&item))\n+            .flat_map(|items| items.0)\n+            .collect();\n+        self.tree\n+    }\n+\n+    fn lower_mod_item(&mut self, item: &ast::ModuleItem) -> Option<ModItems> {\n+        let attrs = Attrs::new(item, &self.hygiene);\n+        let items = match item {\n+            ast::ModuleItem::StructDef(ast) => {\n+                self.lower_struct(ast).map(|data| self.tree.structs.alloc(data).into())\n+            }\n+            ast::ModuleItem::UnionDef(ast) => {\n+                self.lower_union(ast).map(|data| self.tree.unions.alloc(data).into())\n+            }\n+            ast::ModuleItem::EnumDef(ast) => {\n+                self.lower_enum(ast).map(|data| self.tree.enums.alloc(data).into())\n+            }\n+            ast::ModuleItem::FnDef(ast) => {\n+                self.lower_function(ast).map(|data| self.tree.functions.alloc(data).into())\n+            }\n+            ast::ModuleItem::TypeAliasDef(ast) => {\n+                self.lower_type_alias(ast).map(|data| self.tree.type_aliases.alloc(data).into())\n+            }\n+            ast::ModuleItem::StaticDef(ast) => {\n+                self.lower_static(ast).map(|data| self.tree.statics.alloc(data).into())\n+            }\n+            ast::ModuleItem::ConstDef(ast) => {\n+                let data = self.lower_const(ast);\n+                Some(self.tree.consts.alloc(data).into())\n+            }\n+            ast::ModuleItem::Module(ast) => {\n+                self.lower_module(ast).map(|data| self.tree.mods.alloc(data).into())\n+            }\n+            ast::ModuleItem::TraitDef(ast) => {\n+                self.lower_trait(ast).map(|data| self.tree.traits.alloc(data).into())\n+            }\n+            ast::ModuleItem::ImplDef(ast) => {\n+                self.lower_impl(ast).map(|data| self.tree.impls.alloc(data).into())\n+            }\n+            ast::ModuleItem::UseItem(ast) => Some(ModItems(\n+                self.lower_use(ast)\n+                    .into_iter()\n+                    .map(|data| self.tree.imports.alloc(data).into())\n+                    .collect::<SmallVec<_>>(),\n+            )),\n+            ast::ModuleItem::ExternCrateItem(ast) => {\n+                self.lower_extern_crate(ast).map(|data| self.tree.imports.alloc(data).into())\n+            }\n+            ast::ModuleItem::MacroCall(ast) => {\n+                self.lower_macro_call(ast).map(|data| self.tree.macro_calls.alloc(data).into())\n+            }\n+            ast::ModuleItem::ExternBlock(ast) => Some(ModItems(\n+                self.lower_extern_block(ast)\n+                    .into_iter()\n+                    .map(|item| match item {\n+                        Either::Left(func) => self.tree.functions.alloc(func).into(),\n+                        Either::Right(statik) => self.tree.statics.alloc(statik).into(),\n+                    })\n+                    .collect::<SmallVec<_>>(),\n+            )),\n+        };\n+\n+        if !attrs.is_empty() {\n+            for item in items.iter().flat_map(|items| &items.0) {\n+                self.tree.attrs.insert(*item, attrs.clone());\n+            }\n+        }\n+\n+        items\n+    }\n+\n+    fn lower_assoc_item(&mut self, item: &ast::AssocItem) -> Option<AssocItem> {\n+        match item {\n+            ast::AssocItem::FnDef(ast) => {\n+                self.lower_function(ast).map(|data| self.tree.functions.alloc(data).into())\n+            }\n+            ast::AssocItem::TypeAliasDef(ast) => {\n+                self.lower_type_alias(ast).map(|data| self.tree.type_aliases.alloc(data).into())\n+            }\n+            ast::AssocItem::ConstDef(ast) => {\n+                let data = self.lower_const(ast);\n+                Some(self.tree.consts.alloc(data).into())\n+            }\n+        }\n+    }\n+\n+    fn lower_struct(&mut self, strukt: &ast::StructDef) -> Option<Struct> {\n+        let attrs = self.lower_attrs(strukt);\n+        let visibility = self.lower_visibility(strukt);\n+        let name = strukt.name()?.as_name();\n+        let generic_params = self.lower_generic_params(strukt);\n+        let fields = self.lower_fields(&strukt.kind());\n+        let ast_id = self.source_ast_id_map.ast_id(strukt);\n+        let kind = match strukt.kind() {\n+            ast::StructKind::Record(_) => StructDefKind::Record,\n+            ast::StructKind::Tuple(_) => StructDefKind::Tuple,\n+            ast::StructKind::Unit => StructDefKind::Unit,\n+        };\n+        let res = Struct { name, attrs, visibility, generic_params, fields, ast_id, kind };\n+        Some(res)\n+    }\n+\n+    fn lower_fields(&mut self, strukt_kind: &ast::StructKind) -> Fields {\n+        match strukt_kind {\n+            ast::StructKind::Record(it) => {\n+                let range = self.lower_record_fields(it);\n+                Fields::Record(range)\n+            }\n+            ast::StructKind::Tuple(it) => {\n+                let range = self.lower_tuple_fields(it);\n+                Fields::Tuple(range)\n+            }\n+            ast::StructKind::Unit => Fields::Unit,\n+        }\n+    }\n+\n+    fn lower_record_fields(&mut self, fields: &ast::RecordFieldDefList) -> Range<Idx<Field>> {\n+        let start = self.next_field_idx();\n+        for field in fields.fields() {\n+            if let Some(data) = self.lower_record_field(&field) {\n+                self.tree.fields.alloc(data);\n+            }\n+        }\n+        let end = self.next_field_idx();\n+        start..end\n+    }\n+\n+    fn lower_record_field(&self, field: &ast::RecordFieldDef) -> Option<Field> {\n+        let name = field.name()?.as_name();\n+        let visibility = self.lower_visibility(field);\n+        let type_ref = self.lower_type_ref(&field.ascribed_type()?);\n+        let res = Field { name, type_ref, visibility };\n+        Some(res)\n+    }\n+\n+    fn lower_tuple_fields(&mut self, fields: &ast::TupleFieldDefList) -> Range<Idx<Field>> {\n+        let start = self.next_field_idx();\n+        for (i, field) in fields.fields().enumerate() {\n+            if let Some(data) = self.lower_tuple_field(i, &field) {\n+                self.tree.fields.alloc(data);\n+            }\n+        }\n+        let end = self.next_field_idx();\n+        start..end\n+    }\n+\n+    fn lower_tuple_field(&self, idx: usize, field: &ast::TupleFieldDef) -> Option<Field> {\n+        let name = Name::new_tuple_field(idx);\n+        let visibility = self.lower_visibility(field);\n+        let type_ref = self.lower_type_ref(&field.type_ref()?);\n+        let res = Field { name, type_ref, visibility };\n+        Some(res)\n+    }\n+\n+    fn lower_union(&mut self, union: &ast::UnionDef) -> Option<Union> {\n+        let attrs = self.lower_attrs(union);\n+        let visibility = self.lower_visibility(union);\n+        let name = union.name()?.as_name();\n+        let generic_params = self.lower_generic_params(union);\n+        let fields = match union.record_field_def_list() {\n+            Some(record_field_def_list) => {\n+                self.lower_fields(&StructKind::Record(record_field_def_list))\n+            }\n+            None => Fields::Record(self.next_field_idx()..self.next_field_idx()),\n+        };\n+        let ast_id = self.source_ast_id_map.ast_id(union);\n+        let res = Union { name, attrs, visibility, generic_params, fields, ast_id };\n+        Some(res)\n+    }\n+\n+    fn lower_enum(&mut self, enum_: &ast::EnumDef) -> Option<Enum> {\n+        let attrs = self.lower_attrs(enum_);\n+        let visibility = self.lower_visibility(enum_);\n+        let name = enum_.name()?.as_name();\n+        let generic_params = self.lower_generic_params(enum_);\n+        let variants = match &enum_.variant_list() {\n+            Some(variant_list) => self.lower_variants(variant_list),\n+            None => self.next_variant_idx()..self.next_variant_idx(),\n+        };\n+        let ast_id = self.source_ast_id_map.ast_id(enum_);\n+        let res = Enum { name, attrs, visibility, generic_params, variants, ast_id };\n+        Some(res)\n+    }\n+\n+    fn lower_variants(&mut self, variants: &ast::EnumVariantList) -> Range<Idx<Variant>> {\n+        let start = self.next_variant_idx();\n+        for variant in variants.variants() {\n+            if let Some(data) = self.lower_variant(&variant) {\n+                self.tree.variants.alloc(data);\n+            }\n+        }\n+        let end = self.next_variant_idx();\n+        start..end\n+    }\n+\n+    fn lower_variant(&mut self, variant: &ast::EnumVariant) -> Option<Variant> {\n+        let name = variant.name()?.as_name();\n+        let fields = self.lower_fields(&variant.kind());\n+        let res = Variant { name, fields };\n+        Some(res)\n+    }\n+\n+    fn lower_function(&mut self, func: &ast::FnDef) -> Option<Function> {\n+        let attrs = self.lower_attrs(func);\n+        let visibility = self.lower_visibility(func);\n+        let name = func.name()?.as_name();\n+        let generic_params = self.lower_generic_params(func);\n+\n+        let mut params = Vec::new();\n+        let mut has_self_param = false;\n+        if let Some(param_list) = func.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n+                    TypeRef::from_ast(&self.body_ctx, type_ref)\n+                } else {\n+                    let self_type = TypeRef::Path(name![Self].into());\n+                    match self_param.kind() {\n+                        ast::SelfParamKind::Owned => self_type,\n+                        ast::SelfParamKind::Ref => {\n+                            TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n+                        }\n+                        ast::SelfParamKind::MutRef => {\n+                            TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n+                        }\n+                    }\n+                };\n+                params.push(self_type);\n+                has_self_param = true;\n+            }\n+            for param in param_list.params() {\n+                let type_ref = TypeRef::from_ast_opt(&self.body_ctx, param.ascribed_type());\n+                params.push(type_ref);\n+            }\n+        }\n+        let ret_type = match func.ret_type().and_then(|rt| rt.type_ref()) {\n+            Some(type_ref) => TypeRef::from_ast(&self.body_ctx, type_ref),\n+            _ => TypeRef::unit(),\n+        };\n+\n+        let ret_type = if func.async_token().is_some() {\n+            let future_impl = desugar_future_path(ret_type);\n+            let ty_bound = TypeBound::Path(future_impl);\n+            TypeRef::ImplTrait(vec![ty_bound])\n+        } else {\n+            ret_type\n+        };\n+\n+        let ast_id = self.source_ast_id_map.ast_id(func);\n+        let res = Function {\n+            name,\n+            attrs,\n+            visibility,\n+            generic_params,\n+            has_self_param,\n+            params,\n+            ret_type,\n+            ast_id,\n+        };\n+        Some(res)\n+    }\n+\n+    fn lower_type_alias(&mut self, type_alias: &ast::TypeAliasDef) -> Option<TypeAlias> {\n+        let name = type_alias.name()?.as_name();\n+        let type_ref = type_alias.type_ref().map(|it| self.lower_type_ref(&it));\n+        let visibility = self.lower_visibility(type_alias);\n+        let generic_params = self.lower_generic_params(type_alias);\n+        let ast_id = self.source_ast_id_map.ast_id(type_alias);\n+        let res = TypeAlias { name, visibility, generic_params, type_ref, ast_id };\n+        Some(res)\n+    }\n+\n+    fn lower_static(&mut self, static_: &ast::StaticDef) -> Option<Static> {\n+        let name = static_.name()?.as_name();\n+        let type_ref = self.lower_type_ref_opt(static_.ascribed_type());\n+        let visibility = self.lower_visibility(static_);\n+        let ast_id = self.source_ast_id_map.ast_id(static_);\n+        let res = Static { name, visibility, type_ref, ast_id };\n+        Some(res)\n+    }\n+\n+    fn lower_const(&mut self, konst: &ast::ConstDef) -> Const {\n+        let name = konst.name().map(|it| it.as_name());\n+        let type_ref = self.lower_type_ref_opt(konst.ascribed_type());\n+        let visibility = self.lower_visibility(konst);\n+        let ast_id = self.source_ast_id_map.ast_id(konst);\n+        Const { name, visibility, type_ref, ast_id }\n+    }\n+\n+    fn lower_module(&mut self, module: &ast::Module) -> Option<Mod> {\n+        let name = module.name()?.as_name();\n+        let visibility = self.lower_visibility(module);\n+        let kind = if module.semicolon_token().is_some() {\n+            ModKind::Outline {}\n+        } else {\n+            ModKind::Inline {\n+                items: module\n+                    .item_list()\n+                    .map(|list| {\n+                        list.items()\n+                            .flat_map(|item| self.lower_mod_item(&item))\n+                            .flat_map(|items| items.0)\n+                            .collect()\n+                    })\n+                    .unwrap_or_else(|| {\n+                        mark::hit!(name_res_works_for_broken_modules);\n+                        Vec::new()\n+                    }),\n+            }\n+        };\n+        let ast_id = self.source_ast_id_map.ast_id(module);\n+        Some(Mod { name, visibility, kind, ast_id })\n+    }\n+\n+    fn lower_trait(&mut self, trait_def: &ast::TraitDef) -> Option<Trait> {\n+        let name = trait_def.name()?.as_name();\n+        let visibility = self.lower_visibility(trait_def);\n+        let generic_params = self.lower_generic_params(trait_def);\n+        let auto = trait_def.auto_token().is_some();\n+        let items = trait_def.item_list().map(|list| {\n+            // FIXME: Does not handle macros\n+            list.assoc_items().flat_map(|item| self.lower_assoc_item(&item)).collect()\n+        });\n+        let ast_id = self.source_ast_id_map.ast_id(trait_def);\n+        Some(Trait {\n+            name,\n+            visibility,\n+            generic_params,\n+            auto,\n+            items: items.unwrap_or_default(),\n+            ast_id,\n+        })\n+    }\n+\n+    fn lower_impl(&mut self, impl_def: &ast::ImplDef) -> Option<Impl> {\n+        let generic_params = self.lower_generic_params(impl_def);\n+        let target_trait = impl_def.target_trait().map(|tr| self.lower_type_ref(&tr));\n+        let target_type = self.lower_type_ref(&impl_def.target_type()?);\n+        let is_negative = impl_def.excl_token().is_some();\n+        let items = impl_def\n+            .item_list()?\n+            .assoc_items()\n+            .filter_map(|item| self.lower_assoc_item(&item))\n+            .collect();\n+        let ast_id = self.source_ast_id_map.ast_id(impl_def);\n+        Some(Impl { generic_params, target_trait, target_type, is_negative, items, ast_id })\n+    }\n+\n+    fn lower_use(&mut self, use_item: &ast::UseItem) -> Vec<Import> {\n+        // FIXME: cfg_attr\n+        let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n+        let visibility = self.lower_visibility(use_item);\n+\n+        // Every use item can expand to many `Import`s.\n+        let mut imports = Vec::new();\n+        ModPath::expand_use_item(\n+            InFile::new(self.file, use_item.clone()),\n+            &self.hygiene,\n+            |path, _tree, is_glob, alias| {\n+                imports.push(Import {\n+                    path,\n+                    alias,\n+                    visibility: visibility.clone(),\n+                    is_glob,\n+                    is_prelude,\n+                    is_extern_crate: false,\n+                    is_macro_use: false,\n+                });\n+            },\n+        );\n+\n+        imports\n+    }\n+\n+    fn lower_extern_crate(&mut self, extern_crate: &ast::ExternCrateItem) -> Option<Import> {\n+        let path = ModPath::from_name_ref(&extern_crate.name_ref()?);\n+        let alias = extern_crate.alias().map(|a| {\n+            a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n+        });\n+        let visibility = self.lower_visibility(extern_crate);\n+        // FIXME: cfg_attr\n+        let is_macro_use = extern_crate.has_atom_attr(\"macro_use\");\n+\n+        Some(Import {\n+            path,\n+            alias,\n+            visibility,\n+            is_glob: false,\n+            is_prelude: false,\n+            is_extern_crate: true,\n+            is_macro_use,\n+        })\n+    }\n+\n+    fn lower_macro_call(&mut self, m: &ast::MacroCall) -> Option<MacroCall> {\n+        let name = m.name().map(|it| it.as_name());\n+        let attrs = Attrs::new(m, &self.hygiene);\n+        let path = ModPath::from_src(m.path()?, &self.hygiene)?;\n+\n+        let ast_id = self.source_ast_id_map.ast_id(m);\n+\n+        // FIXME: cfg_attr\n+        let export_attr = attrs.by_key(\"macro_export\");\n+\n+        let is_export = export_attr.exists();\n+        let is_local_inner = if is_export {\n+            export_attr.tt_values().map(|it| &it.token_trees).flatten().any(|it| match it {\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n+                    ident.text.contains(\"local_inner_macros\")\n+                }\n+                _ => false,\n+            })\n+        } else {\n+            false\n+        };\n+\n+        let is_builtin = attrs.by_key(\"rustc_builtin_macro\").exists();\n+        Some(MacroCall { name, path, is_export, is_builtin, is_local_inner, ast_id })\n+    }\n+\n+    fn lower_extern_block(&mut self, block: &ast::ExternBlock) -> Vec<Either<Function, Static>> {\n+        block.extern_item_list().map_or(Vec::new(), |list| {\n+            list.extern_items()\n+                .filter_map(|item| match item {\n+                    ast::ExternItem::FnDef(ast) => self.lower_function(&ast).map(Either::Left),\n+                    ast::ExternItem::StaticDef(ast) => self.lower_static(&ast).map(Either::Right),\n+                })\n+                .collect()\n+        })\n+    }\n+\n+    fn lower_generic_params(\n+        &mut self,\n+        _item: &impl ast::TypeParamsOwner,\n+    ) -> generics::GenericParams {\n+        // TODO\n+        generics::GenericParams { types: Arena::new(), where_predicates: Vec::new() }\n+    }\n+\n+    fn lower_attrs(&self, item: &impl ast::AttrsOwner) -> Attrs {\n+        Attrs::new(item, &self.hygiene)\n+    }\n+    fn lower_visibility(&self, item: &impl ast::VisibilityOwner) -> RawVisibility {\n+        RawVisibility::from_ast_with_hygiene(item.visibility(), &self.hygiene)\n+    }\n+    fn lower_type_ref(&self, type_ref: &ast::TypeRef) -> TypeRef {\n+        TypeRef::from_ast(&self.body_ctx, type_ref.clone())\n+    }\n+    fn lower_type_ref_opt(&self, type_ref: Option<ast::TypeRef>) -> TypeRef {\n+        TypeRef::from_ast_opt(&self.body_ctx, type_ref)\n+    }\n+\n+    fn next_field_idx(&self) -> Idx<Field> {\n+        Idx::from_raw(RawId::from(self.tree.fields.len() as u32))\n+    }\n+    fn next_variant_idx(&self) -> Idx<Variant> {\n+        Idx::from_raw(RawId::from(self.tree.variants.len() as u32))\n+    }\n+}\n+\n+fn desugar_future_path(orig: TypeRef) -> Path {\n+    let path = path![core::future::Future];\n+    let mut generic_args: Vec<_> = std::iter::repeat(None).take(path.segments.len() - 1).collect();\n+    let mut last = GenericArgs::empty();\n+    let binding =\n+        AssociatedTypeBinding { name: name![Output], type_ref: Some(orig), bounds: Vec::new() };\n+    last.bindings.push(binding);\n+    generic_args.push(Some(Arc::new(last)));\n+\n+    Path::from_known_path(path, generic_args)\n+}"}]}