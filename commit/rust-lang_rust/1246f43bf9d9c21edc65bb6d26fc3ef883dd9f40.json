{"sha": "1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNDZmNDNiZjlkOWMyMWVkYzY1YmI2ZDI2ZmMzZWY4ODNkZDlmNDA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-13T22:52:20Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-14T05:34:43Z"}, "message": "Rollup merge of #30863 - jseyfried:no_rc, r=eddyb\n\nUse arena allocation instead of reference counting for `Module`s to fix memory leaks from `Rc` cycles.\n\nA module references its module children and its import resolutions, and an import resolution references the module defining the imported name, so there is a cycle whenever a module imports something from an ancestor module.\n\nFor example,\n```rust\nmod foo { // `foo` references `bar`.\n    fn baz() {}\n    mod bar { // `bar` references the import.\n        use foo::baz; // The import references `foo`.\n    }\n}\n```", "tree": {"sha": "d7a502871e586d7cf4dbd5bc8f0ef32ddbe7ef0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7a502871e586d7cf4dbd5bc8f0ef32ddbe7ef0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40", "html_url": "https://github.com/rust-lang/rust/commit/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e51de045ef5fd2e6878b2e770a8deb7abcf64691", "url": "https://api.github.com/repos/rust-lang/rust/commits/e51de045ef5fd2e6878b2e770a8deb7abcf64691", "html_url": "https://github.com/rust-lang/rust/commit/e51de045ef5fd2e6878b2e770a8deb7abcf64691"}, {"sha": "a8514d3ecca6bd404e2d7eff4deef31e3d00dad8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8514d3ecca6bd404e2d7eff4deef31e3d00dad8", "html_url": "https://github.com/rust-lang/rust/commit/a8514d3ecca6bd404e2d7eff4deef31e3d00dad8"}], "stats": {"total": 505, "additions": 260, "deletions": 245}, "files": [{"sha": "be53234cb02e2ca402f07197251ae7b435696f8e", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40", "patch": "@@ -103,7 +103,7 @@ DEPS_rustc_lint := rustc log syntax\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n DEPS_rustc_metadata := rustc rustc_front syntax rbml\n DEPS_rustc_mir := rustc rustc_front syntax\n-DEPS_rustc_resolve := rustc rustc_front log syntax\n+DEPS_rustc_resolve := arena rustc rustc_front log syntax\n DEPS_rustc_platform_intrinsics := rustc rustc_llvm\n DEPS_rustc_plugin := rustc rustc_metadata syntax\n DEPS_rustc_privacy := rustc rustc_front log syntax"}, {"sha": "2e713a2f50e0fcdb0d5dfe08db3c54f2107f20ab", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 54, "deletions": 58, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40", "patch": "@@ -21,7 +21,7 @@ use Module;\n use Namespace::{TypeNS, ValueNS};\n use NameBindings;\n use {names_to_string, module_to_string};\n-use ParentLink::{self, ModuleParentLink, BlockParentLink};\n+use ParentLink::{ModuleParentLink, BlockParentLink};\n use Resolver;\n use resolve_imports::Shadowable;\n use {resolve_error, resolve_struct_error, ResolutionError};\n@@ -52,7 +52,6 @@ use rustc_front::intravisit::{self, Visitor};\n \n use std::mem::replace;\n use std::ops::{Deref, DerefMut};\n-use std::rc::Rc;\n \n // Specifies how duplicates should be handled when adding a child item if\n // another item exists with the same name in some namespace.\n@@ -86,7 +85,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Constructs the reduced graph for the entire crate.\n     fn build_reduced_graph(self, krate: &hir::Crate) {\n         let mut visitor = BuildReducedGraphVisitor {\n-            parent: self.graph_root.clone(),\n+            parent: self.graph_root,\n             builder: self,\n         };\n         intravisit::walk_crate(&mut visitor, krate);\n@@ -97,12 +96,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Returns the child's corresponding name bindings.\n     fn add_child(&self,\n                  name: Name,\n-                 parent: &Rc<Module>,\n+                 parent: Module<'b>,\n                  duplicate_checking_mode: DuplicateCheckingMode,\n                  // For printing errors\n                  sp: Span)\n-                 -> NameBindings {\n-        self.check_for_conflicts_between_external_crates_and_items(&**parent, name, sp);\n+                 -> NameBindings<'b> {\n+        self.check_for_conflicts_between_external_crates_and_items(parent, name, sp);\n \n         // Add or reuse the child.\n         let child = parent.children.borrow().get(&name).cloned();\n@@ -178,12 +177,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         return false;\n     }\n \n-    fn get_parent_link(&mut self, parent: &Rc<Module>, name: Name) -> ParentLink {\n-        ModuleParentLink(Rc::downgrade(parent), name)\n-    }\n-\n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self, item: &Item, parent: &Rc<Module>) -> Rc<Module> {\n+    fn build_reduced_graph_for_item(&mut self, item: &Item, parent: Module<'b>) -> Module<'b> {\n         let name = item.name;\n         let sp = item.span;\n         let is_public = item.vis == hir::Public;\n@@ -238,7 +233,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         }\n \n                         let subclass = SingleImport(binding, source_name);\n-                        self.build_import_directive(&**parent,\n+                        self.build_import_directive(parent,\n                                                     module_path,\n                                                     subclass,\n                                                     view_path.span,\n@@ -288,7 +283,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                     (module_path.to_vec(), name, rename)\n                                 }\n                             };\n-                            self.build_import_directive(&**parent,\n+                            self.build_import_directive(parent,\n                                                         module_path,\n                                                         SingleImport(rename, name),\n                                                         source_item.span,\n@@ -298,7 +293,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         }\n                     }\n                     ViewPathGlob(_) => {\n-                        self.build_import_directive(&**parent,\n+                        self.build_import_directive(parent,\n                                                     module_path,\n                                                     GlobImport,\n                                                     view_path.span,\n@@ -307,7 +302,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                     shadowable);\n                     }\n                 }\n-                parent.clone()\n+                parent\n             }\n \n             ItemExternCrate(_) => {\n@@ -319,32 +314,32 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         index: CRATE_DEF_INDEX,\n                     };\n                     self.external_exports.insert(def_id);\n-                    let parent_link = ModuleParentLink(Rc::downgrade(parent), name);\n+                    let parent_link = ModuleParentLink(parent, name);\n                     let def = DefMod(def_id);\n-                    let external_module = Module::new(parent_link, Some(def), false, true);\n+                    let external_module = self.new_module(parent_link, Some(def), false, true);\n \n                     debug!(\"(build reduced graph for item) found extern `{}`\",\n                            module_to_string(&*external_module));\n-                    self.check_for_conflicts_for_external_crate(&parent, name, sp);\n+                    self.check_for_conflicts_for_external_crate(parent, name, sp);\n                     parent.external_module_children\n                           .borrow_mut()\n-                          .insert(name, external_module.clone());\n+                          .insert(name, external_module);\n                     self.build_reduced_graph_for_external_crate(&external_module);\n                 }\n-                parent.clone()\n+                parent\n             }\n \n             ItemMod(..) => {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateTypes, sp);\n \n-                let parent_link = self.get_parent_link(parent, name);\n+                let parent_link = ModuleParentLink(parent, name);\n                 let def = DefMod(self.ast_map.local_def_id(item.id));\n-                let module = Module::new(parent_link, Some(def), false, is_public);\n+                let module = self.new_module(parent_link, Some(def), false, is_public);\n                 name_bindings.define_module(module.clone(), sp);\n                 module\n             }\n \n-            ItemForeignMod(..) => parent.clone(),\n+            ItemForeignMod(..) => parent,\n \n             // These items live in the value namespace.\n             ItemStatic(_, m, _) => {\n@@ -354,19 +349,19 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 name_bindings.define_value(DefStatic(self.ast_map.local_def_id(item.id), mutbl),\n                                            sp,\n                                            modifiers);\n-                parent.clone()\n+                parent\n             }\n             ItemConst(_, _) => {\n                 self.add_child(name, parent, ForbidDuplicateValues, sp)\n                     .define_value(DefConst(self.ast_map.local_def_id(item.id)), sp, modifiers);\n-                parent.clone()\n+                parent\n             }\n             ItemFn(_, _, _, _, _, _) => {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n \n                 let def = DefFn(self.ast_map.local_def_id(item.id), false);\n                 name_bindings.define_value(def, sp, modifiers);\n-                parent.clone()\n+                parent\n             }\n \n             // These items live in the type namespace.\n@@ -376,11 +371,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                    ForbidDuplicateTypes,\n                                                    sp);\n \n-                let parent_link = self.get_parent_link(parent, name);\n+                let parent_link = ModuleParentLink(parent, name);\n                 let def = DefTy(self.ast_map.local_def_id(item.id), false);\n-                let module = Module::new(parent_link, Some(def), false, is_public);\n+                let module = self.new_module(parent_link, Some(def), false, is_public);\n                 name_bindings.define_module(module, sp);\n-                parent.clone()\n+                parent\n             }\n \n             ItemEnum(ref enum_definition, _) => {\n@@ -389,9 +384,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                    ForbidDuplicateTypes,\n                                                    sp);\n \n-                let parent_link = self.get_parent_link(parent, name);\n+                let parent_link = ModuleParentLink(parent, name);\n                 let def = DefTy(self.ast_map.local_def_id(item.id), true);\n-                let module = Module::new(parent_link, Some(def), false, is_public);\n+                let module = self.new_module(parent_link, Some(def), false, is_public);\n                 name_bindings.define_module(module.clone(), sp);\n \n                 let variant_modifiers = if is_public {\n@@ -404,7 +399,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.build_reduced_graph_for_variant(variant, item_def_id,\n                                                          &module, variant_modifiers);\n                 }\n-                parent.clone()\n+                parent\n             }\n \n             // These items live in both the type and value namespaces.\n@@ -444,11 +439,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let item_def_id = self.ast_map.local_def_id(item.id);\n                 self.structs.insert(item_def_id, named_fields);\n \n-                parent.clone()\n+                parent\n             }\n \n             ItemDefaultImpl(_, _) |\n-            ItemImpl(..) => parent.clone(),\n+            ItemImpl(..) => parent,\n \n             ItemTrait(_, _, _, ref items) => {\n                 let name_bindings = self.add_child(name,\n@@ -459,9 +454,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let def_id = self.ast_map.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n-                let parent_link = self.get_parent_link(parent, name);\n+                let parent_link = ModuleParentLink(parent, name);\n                 let def = DefTrait(def_id);\n-                let module_parent = Module::new(parent_link, Some(def), false, is_public);\n+                let module_parent = self.new_module(parent_link, Some(def), false, is_public);\n                 name_bindings.define_module(module_parent.clone(), sp);\n \n                 // Add the names of all the items to the trait info.\n@@ -494,7 +489,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.trait_item_map.insert((trait_item.name, def_id), trait_item_def_id);\n                 }\n \n-                parent.clone()\n+                parent\n             }\n         }\n     }\n@@ -504,7 +499,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n                                        item_id: DefId,\n-                                       parent: &Rc<Module>,\n+                                       parent: Module<'b>,\n                                        variant_modifiers: DefModifiers) {\n         let name = variant.node.name;\n         let is_exported = if variant.node.data.is_struct() {\n@@ -534,7 +529,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self,\n                                             foreign_item: &ForeignItem,\n-                                            parent: &Rc<Module>) {\n+                                            parent: Module<'b>) {\n         let name = foreign_item.name;\n         let is_public = foreign_item.vis == hir::Public;\n         let modifiers = if is_public {\n@@ -555,30 +550,30 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         name_bindings.define_value(def, foreign_item.span, modifiers);\n     }\n \n-    fn build_reduced_graph_for_block(&mut self, block: &Block, parent: &Rc<Module>) -> Rc<Module> {\n+    fn build_reduced_graph_for_block(&mut self, block: &Block, parent: Module<'b>) -> Module<'b> {\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.id;\n \n             debug!(\"(building reduced graph for block) creating a new anonymous module for block \\\n                     {}\",\n                    block_id);\n \n-            let parent_link = BlockParentLink(Rc::downgrade(parent), block_id);\n-            let new_module = Module::new(parent_link, None, false, false);\n-            parent.anonymous_children.borrow_mut().insert(block_id, new_module.clone());\n+            let parent_link = BlockParentLink(parent, block_id);\n+            let new_module = self.new_module(parent_link, None, false, false);\n+            parent.anonymous_children.borrow_mut().insert(block_id, new_module);\n             new_module\n         } else {\n-            parent.clone()\n+            parent\n         }\n     }\n \n     fn handle_external_def(&mut self,\n                            def: Def,\n                            vis: Visibility,\n-                           child_name_bindings: &NameBindings,\n+                           child_name_bindings: &NameBindings<'b>,\n                            final_ident: &str,\n                            name: Name,\n-                           new_parent: &Rc<Module>) {\n+                           new_parent: Module<'b>) {\n         debug!(\"(building reduced graph for external crate) building external def {}, priv {:?}\",\n                final_ident,\n                vis);\n@@ -609,8 +604,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     debug!(\"(building reduced graph for external crate) building module {} {}\",\n                            final_ident,\n                            is_public);\n-                    let parent_link = self.get_parent_link(new_parent, name);\n-                    let module = Module::new(parent_link, Some(def), true, is_public);\n+                    let parent_link = ModuleParentLink(new_parent, name);\n+                    let module = self.new_module(parent_link, Some(def), true, is_public);\n                     child_name_bindings.define_module(module, DUMMY_SP);\n                 }\n             }\n@@ -681,8 +676,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 }\n \n                 // Define a module if necessary.\n-                let parent_link = self.get_parent_link(new_parent, name);\n-                let module = Module::new(parent_link, Some(def), true, is_public);\n+                let parent_link = ModuleParentLink(new_parent, name);\n+                let module = self.new_module(parent_link, Some(def), true, is_public);\n                 child_name_bindings.define_module(module, DUMMY_SP);\n             }\n             DefTy(..) | DefAssociatedTy(..) => {\n@@ -728,7 +723,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_def(&mut self,\n-                                                  root: &Rc<Module>,\n+                                                  root: Module<'b>,\n                                                   xcdef: ChildItem) {\n         match xcdef.def {\n             DlDef(def) => {\n@@ -766,9 +761,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     }\n \n     /// Builds the reduced graph rooted at the given external module.\n-    fn populate_external_module(&mut self, module: &Rc<Module>) {\n+    fn populate_external_module(&mut self, module: Module<'b>) {\n         debug!(\"(populating external module) attempting to populate {}\",\n-               module_to_string(&**module));\n+               module_to_string(module));\n \n         let def_id = match module.def_id() {\n             None => {\n@@ -788,7 +783,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n-    fn populate_module_if_necessary(&mut self, module: &Rc<Module>) {\n+    fn populate_module_if_necessary(&mut self, module: Module<'b>) {\n         if !module.populated.get() {\n             self.populate_external_module(module)\n         }\n@@ -797,7 +792,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n     /// Builds the reduced graph rooted at the 'use' directive for an external\n     /// crate.\n-    fn build_reduced_graph_for_external_crate(&mut self, root: &Rc<Module>) {\n+    fn build_reduced_graph_for_external_crate(&mut self, root: Module<'b>) {\n         let root_cnum = root.def_id().unwrap().krate;\n         for child in self.session.cstore.crate_top_level_items(root_cnum) {\n             self.build_reduced_graph_for_external_crate_def(root, child);\n@@ -806,7 +801,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n     /// Creates and adds an import directive to the given module.\n     fn build_import_directive(&mut self,\n-                              module_: &Module,\n+                              module_: Module<'b>,\n                               module_path: Vec<Name>,\n                               subclass: ImportDirectiveSubclass,\n                               span: Span,\n@@ -866,7 +861,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n struct BuildReducedGraphVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     builder: GraphBuilder<'a, 'b, 'tcx>,\n-    parent: Rc<Module>,\n+    parent: Module<'b>,\n }\n \n impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n@@ -897,6 +892,7 @@ pub fn build_reduced_graph(resolver: &mut Resolver, krate: &hir::Crate) {\n     GraphBuilder { resolver: resolver }.build_reduced_graph(krate);\n }\n \n-pub fn populate_module_if_necessary(resolver: &mut Resolver, module: &Rc<Module>) {\n+pub fn populate_module_if_necessary<'a, 'tcx>(resolver: &mut Resolver<'a, 'tcx>,\n+                                              module: Module<'a>) {\n     GraphBuilder { resolver: resolver }.populate_module_if_necessary(module);\n }"}, {"sha": "9857e83bd621a7ddc47dcee3c60c5950f6fe0458", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 146, "deletions": 122, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40", "patch": "@@ -26,6 +26,7 @@\n extern crate log;\n #[macro_use]\n extern crate syntax;\n+extern crate arena;\n #[macro_use]\n #[no_link]\n extern crate rustc_bitflags;\n@@ -90,7 +91,7 @@ use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem::replace;\n-use std::rc::{Rc, Weak};\n+use std::rc::Rc;\n \n use resolve_imports::{Target, ImportDirective, ImportResolutionPerNamespace};\n use resolve_imports::Shadowable;\n@@ -576,7 +577,7 @@ pub enum Namespace {\n /// a particular namespace. The result is either definitely-resolved,\n /// definitely- unresolved, or unknown.\n #[derive(Clone)]\n-enum NamespaceResult {\n+enum NamespaceResult<'a> {\n     /// Means that resolve hasn't gathered enough information yet to determine\n     /// whether the name is bound in this namespace. (That is, it hasn't\n     /// resolved all `use` directives yet.)\n@@ -586,10 +587,10 @@ enum NamespaceResult {\n     UnboundResult,\n     /// Means that resolve has determined that the name is bound in the Module\n     /// argument, and specified by the NameBinding argument.\n-    BoundResult(Rc<Module>, NameBinding),\n+    BoundResult(Module<'a>, NameBinding<'a>),\n }\n \n-impl NamespaceResult {\n+impl<'a> NamespaceResult<'a> {\n     fn is_unknown(&self) -> bool {\n         match *self {\n             UnknownResult => true,\n@@ -766,9 +767,9 @@ enum UseLexicalScopeFlag {\n     UseLexicalScope,\n }\n \n-enum ModulePrefixResult {\n+enum ModulePrefixResult<'a> {\n     NoPrefixFound,\n-    PrefixFound(Rc<Module>, usize),\n+    PrefixFound(Module<'a>, usize),\n }\n \n #[derive(Copy, Clone)]\n@@ -830,24 +831,24 @@ impl LocalDef {\n \n /// The link from a module up to its nearest parent node.\n #[derive(Clone,Debug)]\n-enum ParentLink {\n+enum ParentLink<'a> {\n     NoParentLink,\n-    ModuleParentLink(Weak<Module>, Name),\n-    BlockParentLink(Weak<Module>, NodeId),\n+    ModuleParentLink(Module<'a>, Name),\n+    BlockParentLink(Module<'a>, NodeId),\n }\n \n /// One node in the tree of modules.\n-pub struct Module {\n-    parent_link: ParentLink,\n+pub struct ModuleS<'a> {\n+    parent_link: ParentLink<'a>,\n     def: Cell<Option<Def>>,\n     is_public: bool,\n \n-    children: RefCell<HashMap<Name, NameBindings>>,\n+    children: RefCell<HashMap<Name, NameBindings<'a>>>,\n     imports: RefCell<Vec<ImportDirective>>,\n \n     // The external module children of this node that were declared with\n     // `extern crate`.\n-    external_module_children: RefCell<HashMap<Name, Rc<Module>>>,\n+    external_module_children: RefCell<HashMap<Name, Module<'a>>>,\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n@@ -863,10 +864,10 @@ pub struct Module {\n     //\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n-    anonymous_children: RefCell<NodeMap<Rc<Module>>>,\n+    anonymous_children: RefCell<NodeMap<Module<'a>>>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: RefCell<HashMap<Name, ImportResolutionPerNamespace>>,\n+    import_resolutions: RefCell<HashMap<Name, ImportResolutionPerNamespace<'a>>>,\n \n     // The number of unresolved globs that this module exports.\n     glob_count: Cell<usize>,\n@@ -886,13 +887,11 @@ pub struct Module {\n     populated: Cell<bool>,\n }\n \n-impl Module {\n-    fn new(parent_link: ParentLink,\n-           def: Option<Def>,\n-           external: bool,\n-           is_public: bool)\n-           -> Rc<Module> {\n-        Rc::new(Module {\n+pub type Module<'a> = &'a ModuleS<'a>;\n+\n+impl<'a> ModuleS<'a> {\n+    fn new(parent_link: ParentLink<'a>, def: Option<Def>, external: bool, is_public: bool) -> Self {\n+        ModuleS {\n             parent_link: parent_link,\n             def: Cell::new(def),\n             is_public: is_public,\n@@ -906,7 +905,7 @@ impl Module {\n             pub_glob_count: Cell::new(0),\n             resolved_import_count: Cell::new(0),\n             populated: Cell::new(!external),\n-        })\n+        }\n     }\n \n     fn def_id(&self) -> Option<DefId> {\n@@ -935,9 +934,7 @@ impl Module {\n             self.imports.borrow().len() == self.resolved_import_count.get()\n         }\n     }\n-}\n \n-impl Module {\n     pub fn inc_glob_count(&self) {\n         self.glob_count.set(self.glob_count.get() + 1);\n     }\n@@ -961,7 +958,7 @@ impl Module {\n     }\n }\n \n-impl fmt::Debug for Module {\n+impl<'a> fmt::Debug for ModuleS<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f,\n                \"{:?}, {}\",\n@@ -989,20 +986,20 @@ bitflags! {\n \n // Records a possibly-private value, type, or module definition.\n #[derive(Debug)]\n-struct NsDef {\n+struct NsDef<'a> {\n     modifiers: DefModifiers, // see note in ImportResolutionPerNamespace about how to use this\n-    def_or_module: DefOrModule,\n+    def_or_module: DefOrModule<'a>,\n     span: Option<Span>,\n }\n \n #[derive(Debug)]\n-enum DefOrModule {\n+enum DefOrModule<'a> {\n     Def(Def),\n-    Module(Rc<Module>),\n+    Module(Module<'a>),\n }\n \n-impl NsDef {\n-    fn create_from_module(module: Rc<Module>, span: Option<Span>) -> Self {\n+impl<'a> NsDef<'a> {\n+    fn create_from_module(module: Module<'a>, span: Option<Span>) -> Self {\n         let modifiers = if module.is_public {\n             DefModifiers::PUBLIC\n         } else {\n@@ -1016,9 +1013,9 @@ impl NsDef {\n         NsDef { modifiers: modifiers, def_or_module: DefOrModule::Def(def), span: span }\n     }\n \n-    fn module(&self) -> Option<Rc<Module>> {\n+    fn module(&self) -> Option<Module<'a>> {\n         match self.def_or_module {\n-            DefOrModule::Module(ref module) => Some(module.clone()),\n+            DefOrModule::Module(ref module) => Some(module),\n             DefOrModule::Def(_) => None,\n         }\n     }\n@@ -1033,18 +1030,18 @@ impl NsDef {\n \n // Records at most one definition that a name in a namespace is bound to\n #[derive(Clone,Debug)]\n-pub struct NameBinding(Rc<RefCell<Option<NsDef>>>);\n+pub struct NameBinding<'a>(Rc<RefCell<Option<NsDef<'a>>>>);\n \n-impl NameBinding {\n+impl<'a> NameBinding<'a> {\n     fn new() -> Self {\n         NameBinding(Rc::new(RefCell::new(None)))\n     }\n \n-    fn create_from_module(module: Rc<Module>) -> Self {\n+    fn create_from_module(module: Module<'a>) -> Self {\n         NameBinding(Rc::new(RefCell::new(Some(NsDef::create_from_module(module, None)))))\n     }\n \n-    fn set(&self, ns_def: NsDef) {\n+    fn set(&self, ns_def: NsDef<'a>) {\n         *self.0.borrow_mut() = Some(ns_def);\n     }\n \n@@ -1054,15 +1051,15 @@ impl NameBinding {\n         }\n     }\n \n-    fn borrow(&self) -> ::std::cell::Ref<Option<NsDef>> {\n+    fn borrow(&self) -> ::std::cell::Ref<Option<NsDef<'a>>> {\n         self.0.borrow()\n     }\n \n     // Lifted versions of the NsDef methods and fields\n     fn def(&self) -> Option<Def> {\n         self.borrow().as_ref().and_then(NsDef::def)\n     }\n-    fn module(&self) -> Option<Rc<Module>> {\n+    fn module(&self) -> Option<Module<'a>> {\n         self.borrow().as_ref().and_then(NsDef::module)\n     }\n     fn span(&self) -> Option<Span> {\n@@ -1093,28 +1090,28 @@ impl NameBinding {\n // Records the definitions (at most one for each namespace) that a name is\n // bound to.\n #[derive(Clone,Debug)]\n-pub struct NameBindings {\n-    type_ns: NameBinding, // < Meaning in type namespace.\n-    value_ns: NameBinding, // < Meaning in value namespace.\n+pub struct NameBindings<'a> {\n+    type_ns: NameBinding<'a>, // < Meaning in type namespace.\n+    value_ns: NameBinding<'a>, // < Meaning in value namespace.\n }\n \n-impl ::std::ops::Index<Namespace> for NameBindings {\n-    type Output = NameBinding;\n-    fn index(&self, namespace: Namespace) -> &NameBinding {\n+impl<'a> ::std::ops::Index<Namespace> for NameBindings<'a> {\n+    type Output = NameBinding<'a>;\n+    fn index(&self, namespace: Namespace) -> &NameBinding<'a> {\n         match namespace { TypeNS => &self.type_ns, ValueNS => &self.value_ns }\n     }\n }\n \n-impl NameBindings {\n-    fn new() -> NameBindings {\n+impl<'a> NameBindings<'a> {\n+    fn new() -> Self {\n         NameBindings {\n             type_ns: NameBinding::new(),\n             value_ns: NameBinding::new(),\n         }\n     }\n \n     /// Creates a new module in this set of name bindings.\n-    fn define_module(&self, module: Rc<Module>, sp: Span) {\n+    fn define_module(&self, module: Module<'a>, sp: Span) {\n         self.type_ns.set(NsDef::create_from_module(module, Some(sp)));\n     }\n \n@@ -1170,7 +1167,7 @@ pub struct Resolver<'a, 'tcx: 'a> {\n \n     ast_map: &'a hir_map::Map<'tcx>,\n \n-    graph_root: Rc<Module>,\n+    graph_root: Module<'a>,\n \n     trait_item_map: FnvHashMap<(Name, DefId), DefId>,\n \n@@ -1180,7 +1177,7 @@ pub struct Resolver<'a, 'tcx: 'a> {\n     unresolved_imports: usize,\n \n     // The module that represents the current item scope.\n-    current_module: Rc<Module>,\n+    current_module: Module<'a>,\n \n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n@@ -1226,6 +1223,12 @@ pub struct Resolver<'a, 'tcx: 'a> {\n     // The intention is that the callback modifies this flag.\n     // Once set, the resolver falls out of the walk, preserving the ribs.\n     resolved: bool,\n+\n+    arenas: &'a ResolverArenas<'a>,\n+}\n+\n+pub struct ResolverArenas<'a> {\n+    modules: arena::TypedArena<ModuleS<'a>>,\n }\n \n #[derive(PartialEq)]\n@@ -1237,10 +1240,12 @@ enum FallbackChecks {\n impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn new(session: &'a Session,\n            ast_map: &'a hir_map::Map<'tcx>,\n-           make_glob_map: MakeGlobMap)\n+           make_glob_map: MakeGlobMap,\n+           arenas: &'a ResolverArenas<'a>)\n            -> Resolver<'a, 'tcx> {\n         let root_def_id = ast_map.local_def_id(CRATE_NODE_ID);\n-        let graph_root = Module::new(NoParentLink, Some(DefMod(root_def_id)), false, true);\n+        let graph_root = ModuleS::new(NoParentLink, Some(DefMod(root_def_id)), false, true);\n+        let graph_root = arenas.modules.alloc(graph_root);\n \n         Resolver {\n             session: session,\n@@ -1249,7 +1254,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n-            graph_root: graph_root.clone(),\n+            graph_root: graph_root,\n \n             trait_item_map: FnvHashMap(),\n             structs: FnvHashMap(),\n@@ -1281,9 +1286,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             callback: None,\n             resolved: false,\n+\n+            arenas: arenas,\n+        }\n+    }\n+\n+    fn arenas() -> ResolverArenas<'a> {\n+        ResolverArenas {\n+            modules: arena::TypedArena::new(),\n         }\n     }\n \n+    fn new_module(&self,\n+                  parent_link: ParentLink<'a>,\n+                  def: Option<Def>,\n+                  external: bool,\n+                  is_public: bool) -> Module<'a> {\n+        self.arenas.modules.alloc(ModuleS::new(parent_link, def, external, is_public))\n+    }\n+\n     #[inline]\n     fn record_import_use(&mut self, import_id: NodeId, name: Name) {\n         if !self.make_glob_map {\n@@ -1308,7 +1329,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     /// Check that an external crate doesn't collide with items or other external crates.\n-    fn check_for_conflicts_for_external_crate(&self, module: &Module, name: Name, span: Span) {\n+    fn check_for_conflicts_for_external_crate(&self, module: Module<'a>, name: Name, span: Span) {\n         if module.external_module_children.borrow().contains_key(&name) {\n             span_err!(self.session,\n                       span,\n@@ -1328,7 +1349,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Checks that the names of items don't collide with external crates.\n     fn check_for_conflicts_between_external_crates_and_items(&self,\n-                                                             module: &Module,\n+                                                             module: Module<'a>,\n                                                              name: Name,\n                                                              span: Span) {\n         if module.external_module_children.borrow().contains_key(&name) {\n@@ -1338,19 +1359,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Resolves the given module path from the given root `module_`.\n     fn resolve_module_path_from_root(&mut self,\n-                                     module_: Rc<Module>,\n+                                     module_: Module<'a>,\n                                      module_path: &[Name],\n                                      index: usize,\n                                      span: Span,\n                                      name_search_type: NameSearchType,\n                                      lp: LastPrivate)\n-                                     -> ResolveResult<(Rc<Module>, LastPrivate)> {\n-        fn search_parent_externals(needle: Name, module: &Rc<Module>) -> Option<Rc<Module>> {\n+                                     -> ResolveResult<(Module<'a>, LastPrivate)> {\n+        fn search_parent_externals<'a>(needle: Name, module: Module<'a>)\n+                                       -> Option<Module<'a>> {\n             match module.external_module_children.borrow().get(&needle) {\n-                Some(_) => Some(module.clone()),\n+                Some(_) => Some(module),\n                 None => match module.parent_link {\n                     ModuleParentLink(ref parent, _) => {\n-                        search_parent_externals(needle, &parent.upgrade().unwrap())\n+                        search_parent_externals(needle, parent)\n                     }\n                     _ => None,\n                 },\n@@ -1367,14 +1389,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // modules as we go.\n         while index < module_path_len {\n             let name = module_path[index];\n-            match self.resolve_name_in_module(search_module.clone(),\n+            match self.resolve_name_in_module(search_module,\n                                               name,\n                                               TypeNS,\n                                               name_search_type,\n                                               false) {\n                 Failed(None) => {\n                     let segment_name = name.as_str();\n-                    let module_name = module_to_string(&*search_module);\n+                    let module_name = module_to_string(search_module);\n                     let mut span = span;\n                     let msg = if \"???\" == &module_name[..] {\n                         span.hi = span.lo + Pos::from_usize(segment_name.len());\n@@ -1445,12 +1467,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// On success, returns the resolved module, and the closest *private*\n     /// module found to the destination when resolving this path.\n     fn resolve_module_path(&mut self,\n-                           module_: Rc<Module>,\n+                           module_: Module<'a>,\n                            module_path: &[Name],\n                            use_lexical_scope: UseLexicalScopeFlag,\n                            span: Span,\n                            name_search_type: NameSearchType)\n-                           -> ResolveResult<(Rc<Module>, LastPrivate)> {\n+                           -> ResolveResult<(Module<'a>, LastPrivate)> {\n         let module_path_len = module_path.len();\n         assert!(module_path_len > 0);\n \n@@ -1459,7 +1481,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                module_to_string(&*module_));\n \n         // Resolve the module prefix, if any.\n-        let module_prefix_result = self.resolve_module_prefix(module_.clone(), module_path);\n+        let module_prefix_result = self.resolve_module_prefix(module_, module_path);\n \n         let search_module;\n         let start_index;\n@@ -1495,7 +1517,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     DontUseLexicalScope => {\n                         // This is a crate-relative path. We will start the\n                         // resolution process at index zero.\n-                        search_module = self.graph_root.clone();\n+                        search_module = self.graph_root;\n                         start_index = 0;\n                         last_private = LastMod(AllPublic);\n                     }\n@@ -1519,7 +1541,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n             Success(PrefixFound(ref containing_module, index)) => {\n-                search_module = containing_module.clone();\n+                search_module = containing_module;\n                 start_index = index;\n                 last_private = LastMod(DependsOn(containing_module.def_id()\n                                                                   .unwrap()));\n@@ -1537,11 +1559,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n     fn resolve_item_in_lexical_scope(&mut self,\n-                                     module_: Rc<Module>,\n+                                     module_: Module<'a>,\n                                      name: Name,\n                                      namespace: Namespace,\n                                      record_used: bool)\n-                                     -> ResolveResult<(Target, bool)> {\n+                                     -> ResolveResult<(Target<'a>, bool)> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in namespace {:?} in `{}`\",\n                name,\n                namespace,\n@@ -1554,7 +1576,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match module_.children.borrow().get(&name) {\n             Some(name_bindings) if name_bindings[namespace].defined() => {\n                 debug!(\"top name bindings succeeded\");\n-                return Success((Target::new(module_.clone(),\n+                return Success((Target::new(module_,\n                                             name_bindings[namespace].clone(),\n                                             Shadowable::Never),\n                                 false));\n@@ -1594,9 +1616,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Search for external modules.\n         if namespace == TypeNS {\n-            // FIXME (21114): In principle unclear `child` *has* to be lifted.\n-            let child = module_.external_module_children.borrow().get(&name).cloned();\n-            if let Some(module) = child {\n+            let children = module_.external_module_children.borrow();\n+            if let Some(module) = children.get(&name) {\n                 let name_binding = NameBinding::create_from_module(module);\n                 debug!(\"lower name bindings succeeded\");\n                 return Success((Target::new(module_, name_binding, Shadowable::Never),\n@@ -1608,7 +1629,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut search_module = module_;\n         loop {\n             // Go to the next parent.\n-            match search_module.parent_link.clone() {\n+            match search_module.parent_link {\n                 NoParentLink => {\n                     // No more parents. This module was unresolved.\n                     debug!(\"(resolving item in lexical scope) unresolved module\");\n@@ -1621,16 +1642,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 searching through module parents\");\n                             return Failed(None);\n                     } else {\n-                        search_module = parent_module_node.upgrade().unwrap();\n+                        search_module = parent_module_node;\n                     }\n                 }\n-                BlockParentLink(ref parent_module_node, _) => {\n-                    search_module = parent_module_node.upgrade().unwrap();\n+                BlockParentLink(parent_module_node, _) => {\n+                    search_module = parent_module_node;\n                 }\n             }\n \n             // Resolve the name in the parent module.\n-            match self.resolve_name_in_module(search_module.clone(),\n+            match self.resolve_name_in_module(search_module,\n                                               name,\n                                               namespace,\n                                               PathSearch,\n@@ -1657,9 +1678,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Resolves a module name in the current lexical scope.\n     fn resolve_module_in_lexical_scope(&mut self,\n-                                       module_: Rc<Module>,\n+                                       module_: Module<'a>,\n                                        name: Name)\n-                                       -> ResolveResult<Rc<Module>> {\n+                                       -> ResolveResult<Module<'a>> {\n         // If this module is an anonymous module, resolve the item in the\n         // lexical scope. Otherwise, resolve the item from the crate root.\n         let resolve_result = self.resolve_item_in_lexical_scope(module_, name, TypeNS, true);\n@@ -1685,14 +1706,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     /// Returns the nearest normal module parent of the given module.\n-    fn get_nearest_normal_module_parent(&mut self, module_: Rc<Module>) -> Option<Rc<Module>> {\n+    fn get_nearest_normal_module_parent(&mut self, module_: Module<'a>) -> Option<Module<'a>> {\n         let mut module_ = module_;\n         loop {\n-            match module_.parent_link.clone() {\n+            match module_.parent_link {\n                 NoParentLink => return None,\n                 ModuleParentLink(new_module, _) |\n                 BlockParentLink(new_module, _) => {\n-                    let new_module = new_module.upgrade().unwrap();\n+                    let new_module = new_module;\n                     if new_module.is_normal() {\n                         return Some(new_module);\n                     }\n@@ -1704,11 +1725,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Returns the nearest normal module parent of the given module, or the\n     /// module itself if it is a normal module.\n-    fn get_nearest_normal_module_parent_or_self(&mut self, module_: Rc<Module>) -> Rc<Module> {\n+    fn get_nearest_normal_module_parent_or_self(&mut self, module_: Module<'a>) -> Module<'a> {\n         if module_.is_normal() {\n             return module_;\n         }\n-        match self.get_nearest_normal_module_parent(module_.clone()) {\n+        match self.get_nearest_normal_module_parent(module_) {\n             None => module_,\n             Some(new_module) => new_module,\n         }\n@@ -1718,9 +1739,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// (b) some chain of `super::`.\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n     fn resolve_module_prefix(&mut self,\n-                             module_: Rc<Module>,\n+                             module_: Module<'a>,\n                              module_path: &[Name])\n-                             -> ResolveResult<ModulePrefixResult> {\n+                             -> ResolveResult<ModulePrefixResult<'a>> {\n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n         let mut i = match &*module_path[0].as_str() {\n@@ -1756,23 +1777,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// The boolean returned on success is an indicator of whether this lookup\n     /// passed through a public re-export proxy.\n     fn resolve_name_in_module(&mut self,\n-                              module_: Rc<Module>,\n+                              module_: Module<'a>,\n                               name: Name,\n                               namespace: Namespace,\n                               name_search_type: NameSearchType,\n                               allow_private_imports: bool)\n-                              -> ResolveResult<(Target, bool)> {\n+                              -> ResolveResult<(Target<'a>, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n                name,\n                module_to_string(&*module_));\n \n         // First, check the direct children of the module.\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n-        match module_.children.borrow().get(&name) {\n+        let children = module_.children.borrow();\n+        match children.get(&name) {\n             Some(name_bindings) if name_bindings[namespace].defined() => {\n                 debug!(\"(resolving name in module) found node as child\");\n-                return Success((Target::new(module_.clone(),\n+                return Success((Target::new(module_,\n                                             name_bindings[namespace].clone(),\n                                             Shadowable::Never),\n                                 false));\n@@ -1791,7 +1813,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Check the list of resolved imports.\n-        match module_.import_resolutions.borrow().get(&name) {\n+        let children = module_.import_resolutions.borrow();\n+        match children.get(&name) {\n             Some(import_resolution) if allow_private_imports ||\n                                        import_resolution[namespace].is_public => {\n \n@@ -1823,9 +1846,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Finally, search through external children.\n         if namespace == TypeNS {\n-            // FIXME (21114): In principle unclear `child` *has* to be lifted.\n-            let child = module_.external_module_children.borrow().get(&name).cloned();\n-            if let Some(module) = child {\n+            let children = module_.external_module_children.borrow();\n+            if let Some(module) = children.get(&name) {\n                 let name_binding = NameBinding::create_from_module(module);\n                 return Success((Target::new(module_, name_binding, Shadowable::Never),\n                                 false));\n@@ -1837,7 +1859,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         return Failed(None);\n     }\n \n-    fn report_unresolved_imports(&mut self, module_: Rc<Module>) {\n+    fn report_unresolved_imports(&mut self, module_: Module<'a>) {\n         let index = module_.resolved_import_count.get();\n         let imports = module_.imports.borrow();\n         let import_count = imports.len();\n@@ -1862,7 +1884,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         for (_, module_) in module_.anonymous_children.borrow().iter() {\n-            self.report_unresolved_imports(module_.clone());\n+            self.report_unresolved_imports(module_);\n         }\n     }\n \n@@ -1887,7 +1909,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn with_scope<F>(&mut self, name: Option<Name>, f: F)\n         where F: FnOnce(&mut Resolver)\n     {\n-        let orig_module = self.current_module.clone();\n+        let orig_module = self.current_module;\n \n         // Move down in the graph.\n         match name {\n@@ -2475,14 +2497,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.value_ribs.push(Rib::new(NormalRibKind));\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n-        let orig_module = self.current_module.clone();\n+        let orig_module = self.current_module;\n         match orig_module.anonymous_children.borrow().get(&block.id) {\n             None => {\n                 // Nothing to do.\n             }\n             Some(anonymous_module) => {\n                 debug!(\"(resolving block) found anonymous module, moving down\");\n-                self.current_module = anonymous_module.clone();\n+                self.current_module = anonymous_module;\n             }\n         }\n \n@@ -2871,7 +2893,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        name: Name,\n                                        span: Span)\n                                        -> BareIdentifierPatternResolution {\n-        let module = self.current_module.clone();\n+        let module = self.current_module;\n         match self.resolve_item_in_lexical_scope(module, name, ValueNS, true) {\n             Success((target, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in finding {} at {:?}\",\n@@ -3135,7 +3157,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let containing_module;\n         let last_private;\n-        let current_module = self.current_module.clone();\n+        let current_module = self.current_module;\n         match self.resolve_module_path(current_module,\n                                        &module_path[..],\n                                        UseLexicalScope,\n@@ -3162,7 +3184,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        let def = match self.resolve_name_in_module(containing_module.clone(),\n+        let def = match self.resolve_name_in_module(containing_module,\n                                                     name,\n                                                     namespace,\n                                                     NameSearchType::PathSearch,\n@@ -3193,7 +3215,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                   .map(|ps| ps.identifier.name)\n                                   .collect::<Vec<_>>();\n \n-        let root_module = self.graph_root.clone();\n+        let root_module = self.graph_root;\n \n         let containing_module;\n         let last_private;\n@@ -3283,7 +3305,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                              record_used: bool)\n                                              -> Option<Def> {\n         // Check the items.\n-        let module = self.current_module.clone();\n+        let module = self.current_module;\n         match self.resolve_item_in_lexical_scope(module, name, namespace, record_used) {\n             Success((target, _)) => {\n                 match target.binding.def() {\n@@ -3345,11 +3367,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        fn get_module(this: &mut Resolver,\n-                      span: Span,\n-                      name_path: &[ast::Name])\n-                      -> Option<Rc<Module>> {\n-            let root = this.current_module.clone();\n+        fn get_module<'a, 'tcx>(this: &mut Resolver<'a, 'tcx>,\n+                                span: Span,\n+                                name_path: &[ast::Name])\n+                                -> Option<Module<'a>> {\n+            let root = this.current_module;\n             let last_name = name_path.last().unwrap();\n \n             if name_path.len() == 1 {\n@@ -3603,7 +3625,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let name_path = path.segments.iter()\n                                                         .map(|seg| seg.identifier.name)\n                                                         .collect::<Vec<_>>();\n-                                    let current_module = self.current_module.clone();\n+                                    let current_module = self.current_module;\n \n                                     match self.resolve_module_path(current_module,\n                                                    &name_path[..],\n@@ -3725,7 +3747,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let mut found_traits = Vec::new();\n-        let mut search_module = self.current_module.clone();\n+        let mut search_module = self.current_module;\n         loop {\n             // Look for the current trait.\n             match self.current_trait_ref {\n@@ -3778,10 +3800,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n \n-            match search_module.parent_link.clone() {\n+            match search_module.parent_link {\n                 NoParentLink | ModuleParentLink(..) => break,\n                 BlockParentLink(parent_module, _) => {\n-                    search_module = parent_module.upgrade().unwrap();\n+                    search_module = parent_module;\n                 }\n             }\n         }\n@@ -3828,7 +3850,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     //\n \n     #[allow(dead_code)]   // useful for debugging\n-    fn dump_module(&mut self, module_: Rc<Module>) {\n+    fn dump_module(&mut self, module_: Module<'a>) {\n         debug!(\"Dump of module `{}`:\", module_to_string(&*module_));\n \n         debug!(\"Children:\");\n@@ -3891,20 +3913,20 @@ fn path_names_to_string(path: &Path, depth: usize) -> String {\n }\n \n /// A somewhat inefficient routine to obtain the name of a module.\n-fn module_to_string(module: &Module) -> String {\n+fn module_to_string<'a>(module: Module<'a>) -> String {\n     let mut names = Vec::new();\n \n-    fn collect_mod(names: &mut Vec<ast::Name>, module: &Module) {\n+    fn collect_mod<'a>(names: &mut Vec<ast::Name>, module: Module<'a>) {\n         match module.parent_link {\n             NoParentLink => {}\n             ModuleParentLink(ref module, name) => {\n                 names.push(name);\n-                collect_mod(names, &*module.upgrade().unwrap());\n+                collect_mod(names, module);\n             }\n             BlockParentLink(ref module, _) => {\n                 // danger, shouldn't be ident?\n                 names.push(special_idents::opaque.name);\n-                collect_mod(names, &*module.upgrade().unwrap());\n+                collect_mod(names, module);\n             }\n         }\n     }\n@@ -3946,7 +3968,8 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n                                make_glob_map: MakeGlobMap)\n                                -> CrateMap {\n     let krate = ast_map.krate();\n-    let mut resolver = create_resolver(session, ast_map, krate, make_glob_map, None);\n+    let arenas = Resolver::arenas();\n+    let mut resolver = create_resolver(session, ast_map, krate, make_glob_map, &arenas, None);\n \n     resolver.resolve_crate(krate);\n \n@@ -3978,9 +4001,10 @@ pub fn create_resolver<'a, 'tcx>(session: &'a Session,\n                                  ast_map: &'a hir_map::Map<'tcx>,\n                                  krate: &'a Crate,\n                                  make_glob_map: MakeGlobMap,\n+                                 arenas: &'a ResolverArenas<'a>,\n                                  callback: Option<Box<Fn(hir_map::Node, &mut bool) -> bool>>)\n                                  -> Resolver<'a, 'tcx> {\n-    let mut resolver = Resolver::new(session, ast_map, make_glob_map);\n+    let mut resolver = Resolver::new(session, ast_map, make_glob_map, arenas);\n \n     resolver.callback = callback;\n "}, {"sha": "13f4348f79522052aa2b735df00d24be3f055798", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40", "patch": "@@ -28,7 +28,6 @@ use rustc::middle::def::Export;\n use syntax::ast;\n \n use std::ops::{Deref, DerefMut};\n-use std::rc::Rc;\n \n struct ExportRecorder<'a, 'b: 'a, 'tcx: 'b> {\n     resolver: &'a mut Resolver<'b, 'tcx>,\n@@ -50,7 +49,7 @@ impl<'a, 'b, 'tcx:'b> DerefMut for ExportRecorder<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n-    fn record_exports_for_module_subtree(&mut self, module_: Rc<Module>) {\n+    fn record_exports_for_module_subtree(&mut self, module_: Module<'b>) {\n         // If this isn't a local krate, then bail out. We don't need to record\n         // exports for nonlocal crates.\n \n@@ -59,23 +58,23 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n                 // OK. Continue.\n                 debug!(\"(recording exports for module subtree) recording exports for local \\\n                         module `{}`\",\n-                       module_to_string(&*module_));\n+                       module_to_string(module_));\n             }\n             None => {\n                 // Record exports for the root module.\n                 debug!(\"(recording exports for module subtree) recording exports for root module \\\n                         `{}`\",\n-                       module_to_string(&*module_));\n+                       module_to_string(module_));\n             }\n             Some(_) => {\n                 // Bail out.\n                 debug!(\"(recording exports for module subtree) not recording exports for `{}`\",\n-                       module_to_string(&*module_));\n+                       module_to_string(module_));\n                 return;\n             }\n         }\n \n-        self.record_exports_for_module(&*module_);\n+        self.record_exports_for_module(module_);\n         build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n \n         for (_, child_name_bindings) in module_.children.borrow().iter() {\n@@ -90,11 +89,11 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         }\n \n         for (_, child_module) in module_.anonymous_children.borrow().iter() {\n-            self.record_exports_for_module_subtree(child_module.clone());\n+            self.record_exports_for_module_subtree(child_module);\n         }\n     }\n \n-    fn record_exports_for_module(&mut self, module_: &Module) {\n+    fn record_exports_for_module(&mut self, module_: Module<'b>) {\n         let mut exports = Vec::new();\n \n         self.add_exports_for_module(&mut exports, module_);\n@@ -128,7 +127,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn add_exports_for_module(&mut self, exports: &mut Vec<Export>, module_: &Module) {\n+    fn add_exports_for_module(&mut self, exports: &mut Vec<Export>, module_: Module<'b>) {\n         for (name, import_resolution) in module_.import_resolutions.borrow().iter() {\n             let xs = [TypeNS, ValueNS];\n             for &ns in &xs {\n@@ -150,6 +149,6 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n \n pub fn record(resolver: &mut Resolver) {\n     let mut recorder = ExportRecorder { resolver: resolver };\n-    let root_module = recorder.graph_root.clone();\n+    let root_module = recorder.graph_root;\n     recorder.record_exports_for_module_subtree(root_module);\n }"}, {"sha": "53d1b888d8e87a5b0f8c3bfa837efafe01141178", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 50, "deletions": 54, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40", "patch": "@@ -36,7 +36,6 @@ use syntax::codemap::Span;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::mem::replace;\n-use std::rc::Rc;\n \n /// Contains data for specific types of import directives.\n #[derive(Copy, Clone,Debug)]\n@@ -84,17 +83,15 @@ impl ImportDirective {\n \n /// The item that an import resolves to.\n #[derive(Clone,Debug)]\n-pub struct Target {\n-    pub target_module: Rc<Module>,\n-    pub binding: NameBinding,\n+pub struct Target<'a> {\n+    pub target_module: Module<'a>,\n+    pub binding: NameBinding<'a>,\n     pub shadowable: Shadowable,\n }\n \n-impl Target {\n-    pub fn new(target_module: Rc<Module>,\n-               binding: NameBinding,\n-               shadowable: Shadowable)\n-               -> Target {\n+impl<'a> Target<'a> {\n+    pub fn new(target_module: Module<'a>, binding: NameBinding<'a>, shadowable: Shadowable)\n+               -> Self {\n         Target {\n             target_module: target_module,\n             binding: binding,\n@@ -109,44 +106,44 @@ impl Target {\n /// and for each namespace, it records the `use` directive importing the name in the namespace\n /// and the `Target` to which the name in the namespace resolves (if applicable).\n /// Different `use` directives may import the same name in different namespaces.\n-pub struct ImportResolutionPerNamespace {\n+pub struct ImportResolutionPerNamespace<'a> {\n     // When outstanding_references reaches zero, outside modules can count on the targets being\n     // correct. Before then, all bets are off; future `use` directives could override the name.\n     // Since shadowing is forbidden, the only way outstanding_references > 1 in a legal program\n     // is if the name is imported by exactly two `use` directives, one of which resolves to a\n     // value and the other of which resolves to a type.\n     pub outstanding_references: usize,\n-    pub type_ns: ImportResolution,\n-    pub value_ns: ImportResolution,\n+    pub type_ns: ImportResolution<'a>,\n+    pub value_ns: ImportResolution<'a>,\n }\n \n /// Records what we know about an imported name in a namespace (see `ImportResolutionPerNamespace`).\n #[derive(Clone,Debug)]\n-pub struct ImportResolution {\n+pub struct ImportResolution<'a> {\n     /// Whether the name in the namespace was imported with a `use` or a `pub use`.\n     pub is_public: bool,\n \n     /// Resolution of the name in the namespace\n-    pub target: Option<Target>,\n+    pub target: Option<Target<'a>>,\n \n     /// The source node of the `use` directive\n     pub id: NodeId,\n }\n \n-impl ::std::ops::Index<Namespace> for ImportResolutionPerNamespace {\n-    type Output = ImportResolution;\n-    fn index(&self, ns: Namespace) -> &ImportResolution {\n+impl<'a> ::std::ops::Index<Namespace> for ImportResolutionPerNamespace<'a> {\n+    type Output = ImportResolution<'a>;\n+    fn index(&self, ns: Namespace) -> &ImportResolution<'a> {\n         match ns { TypeNS => &self.type_ns, ValueNS => &self.value_ns }\n     }\n }\n \n-impl ::std::ops::IndexMut<Namespace> for ImportResolutionPerNamespace {\n-    fn index_mut(&mut self, ns: Namespace) -> &mut ImportResolution {\n+impl<'a> ::std::ops::IndexMut<Namespace> for ImportResolutionPerNamespace<'a> {\n+    fn index_mut(&mut self, ns: Namespace) -> &mut ImportResolution<'a> {\n         match ns { TypeNS => &mut self.type_ns, ValueNS => &mut self.value_ns }\n     }\n }\n \n-impl ImportResolutionPerNamespace {\n+impl<'a> ImportResolutionPerNamespace<'a> {\n     pub fn new(id: NodeId, is_public: bool) -> Self {\n         let resolution = ImportResolution { id: id, is_public: is_public, target: None };\n         ImportResolutionPerNamespace {\n@@ -191,8 +188,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                    i,\n                    self.resolver.unresolved_imports);\n \n-            let module_root = self.resolver.graph_root.clone();\n-            let errors = self.resolve_imports_for_module_subtree(module_root.clone());\n+            let module_root = self.resolver.graph_root;\n+            let errors = self.resolve_imports_for_module_subtree(module_root);\n \n             if self.resolver.unresolved_imports == 0 {\n                 debug!(\"(resolving imports) success\");\n@@ -225,13 +222,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     /// Attempts to resolve imports for the given module and all of its\n     /// submodules.\n     fn resolve_imports_for_module_subtree(&mut self,\n-                                          module_: Rc<Module>)\n+                                          module_: Module<'b>)\n                                           -> Vec<ImportResolvingError> {\n         let mut errors = Vec::new();\n         debug!(\"(resolving imports for module subtree) resolving {}\",\n                module_to_string(&*module_));\n-        let orig_module = replace(&mut self.resolver.current_module, module_.clone());\n-        errors.extend(self.resolve_imports_for_module(module_.clone()));\n+        let orig_module = replace(&mut self.resolver.current_module, module_);\n+        errors.extend(self.resolve_imports_for_module(module_));\n         self.resolver.current_module = orig_module;\n \n         build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n@@ -247,14 +244,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         }\n \n         for (_, child_module) in module_.anonymous_children.borrow().iter() {\n-            errors.extend(self.resolve_imports_for_module_subtree(child_module.clone()));\n+            errors.extend(self.resolve_imports_for_module_subtree(child_module));\n         }\n \n         errors\n     }\n \n     /// Attempts to resolve imports for the given module only.\n-    fn resolve_imports_for_module(&mut self, module: Rc<Module>) -> Vec<ImportResolvingError> {\n+    fn resolve_imports_for_module(&mut self, module: Module<'b>) -> Vec<ImportResolvingError> {\n         let mut errors = Vec::new();\n \n         if module.all_imports_resolved() {\n@@ -268,7 +265,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         let mut indeterminate_imports = Vec::new();\n         while module.resolved_import_count.get() + indeterminate_imports.len() < import_count {\n             let import_index = module.resolved_import_count.get();\n-            match self.resolve_import_for_module(module.clone(), &imports[import_index]) {\n+            match self.resolve_import_for_module(module, &imports[import_index]) {\n                 ResolveResult::Failed(err) => {\n                     let import_directive = &imports[import_index];\n                     let (span, help) = match err {\n@@ -306,7 +303,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     /// currently-unresolved imports, or success if we know the name exists.\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import_for_module(&mut self,\n-                                 module_: Rc<Module>,\n+                                 module_: Module<'b>,\n                                  import_directive: &ImportDirective)\n                                  -> ResolveResult<()> {\n         let mut resolution_result = ResolveResult::Failed(None);\n@@ -319,9 +316,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // First, resolve the module path for the directive, if necessary.\n         let container = if module_path.is_empty() {\n             // Use the crate root.\n-            Some((self.resolver.graph_root.clone(), LastMod(AllPublic)))\n+            Some((self.resolver.graph_root, LastMod(AllPublic)))\n         } else {\n-            match self.resolver.resolve_module_path(module_.clone(),\n+            match self.resolver.resolve_module_path(module_,\n                                                     &module_path[..],\n                                                     UseLexicalScopeFlag::DontUseLexicalScope,\n                                                     import_directive.span,\n@@ -399,8 +396,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     }\n \n     fn resolve_single_import(&mut self,\n-                             module_: &Module,\n-                             target_module: Rc<Module>,\n+                             module_: Module<'b>,\n+                             target_module: Module<'b>,\n                              target: Name,\n                              source: Name,\n                              directive: &ImportDirective,\n@@ -447,7 +444,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 let mut pub_err = false;\n                 if child_name_bindings.value_ns.defined() {\n                     debug!(\"(resolving single import) found value binding\");\n-                    value_result = BoundResult(target_module.clone(),\n+                    value_result = BoundResult(target_module,\n                                                child_name_bindings.value_ns.clone());\n                     if directive.is_public && !child_name_bindings.value_ns.is_public() {\n                         let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n@@ -473,7 +470,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 }\n                 if child_name_bindings.type_ns.defined() {\n                     debug!(\"(resolving single import) found type binding\");\n-                    type_result = BoundResult(target_module.clone(),\n+                    type_result = BoundResult(target_module,\n                                               child_name_bindings.type_ns.clone());\n                     if !pub_err && directive.is_public &&\n                        !child_name_bindings.type_ns.is_public() {\n@@ -543,11 +540,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     }\n                     Some(import_resolution) if import_resolution.outstanding_references == 0 => {\n \n-                        fn get_binding(this: &mut Resolver,\n-                                       import_resolution: &ImportResolutionPerNamespace,\n-                                       namespace: Namespace,\n-                                       source: Name)\n-                                       -> NamespaceResult {\n+                        fn get_binding<'a>(this: &mut Resolver,\n+                                           import_resolution: &ImportResolutionPerNamespace<'a>,\n+                                           namespace: Namespace,\n+                                           source: Name)\n+                                           -> NamespaceResult<'a> {\n \n                             // Import resolutions must be declared with \"pub\"\n                             // in order to be exported.\n@@ -640,7 +637,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         match type_result {\n             BoundResult(..) => {}\n             _ => {\n-                match target_module.external_module_children.borrow_mut().get(&source).cloned() {\n+                match target_module.external_module_children.borrow_mut().get(&source) {\n                     None => {} // Continue.\n                     Some(module) => {\n                         debug!(\"(resolving single import) found external module\");\n@@ -652,7 +649,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                             _ => {}\n                         }\n                         let name_binding = NameBinding::create_from_module(module);\n-                        type_result = BoundResult(target_module.clone(), name_binding);\n+                        type_result = BoundResult(target_module, name_binding);\n                         type_used_public = true;\n                     }\n                 }\n@@ -685,7 +682,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                              target);\n \n                         import_resolution[namespace] = ImportResolution {\n-                            target: Some(Target::new(target_module.clone(),\n+                            target: Some(Target::new(target_module,\n                                                      name_binding.clone(),\n                                                      directive.shadowable)),\n                             id: directive.id,\n@@ -777,8 +774,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     // that exports nothing is valid). target_module is the module we are\n     // actually importing, i.e., `foo` in `use foo::*`.\n     fn resolve_glob_import(&mut self,\n-                           module_: &Module,\n-                           target_module: Rc<Module>,\n+                           module_: Module<'b>,\n+                           target_module: Module<'b>,\n                            import_directive: &ImportDirective,\n                            lp: LastPrivate)\n                            -> ResolveResult<()> {\n@@ -841,7 +838,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         for (&name, name_bindings) in target_module.children.borrow().iter() {\n             self.merge_import_resolution(module_,\n-                                         target_module.clone(),\n+                                         target_module,\n                                          import_directive,\n                                          name,\n                                          name_bindings.clone());\n@@ -863,11 +860,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     }\n \n     fn merge_import_resolution(&mut self,\n-                               module_: &Module,\n-                               containing_module: Rc<Module>,\n+                               module_: Module<'b>,\n+                               containing_module: Module<'b>,\n                                import_directive: &ImportDirective,\n                                name: Name,\n-                               name_bindings: NameBindings) {\n+                               name_bindings: NameBindings<'b>) {\n         let id = import_directive.id;\n         let is_public = import_directive.is_public;\n \n@@ -916,7 +913,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                   msg);\n                     } else {\n                         dest_import_resolution[namespace] = ImportResolution {\n-                            target: Some(Target::new(containing_module.clone(),\n+                            target: Some(Target::new(containing_module,\n                                                      name_bindings[namespace].clone(),\n                                                      import_directive.shadowable)),\n                             id: id,\n@@ -993,8 +990,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Checks that imported names and items don't have the same name.\n     fn check_for_conflicts_between_imports_and_items(&mut self,\n-                                                     module: &Module,\n-                                                     import: &ImportResolutionPerNamespace,\n+                                                     module: Module<'b>,\n+                                                     import: &ImportResolutionPerNamespace<'b>,\n                                                      import_span: Span,\n                                                      name: Name) {\n         // First, check for conflicts between imports and `extern crate`s.\n@@ -1013,8 +1010,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         }\n \n         // Check for item conflicts.\n-        let children = module.children.borrow();\n-        let name_bindings = match children.get(&name) {\n+        let name_bindings = match module.children.borrow().get(&name) {\n             None => {\n                 // There can't be any conflicts.\n                 return;"}]}