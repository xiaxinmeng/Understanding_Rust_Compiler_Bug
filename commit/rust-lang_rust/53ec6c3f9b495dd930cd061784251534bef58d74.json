{"sha": "53ec6c3f9b495dd930cd061784251534bef58d74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZWM2YzNmOWI0OTVkZDkzMGNkMDYxNzg0MjUxNTM0YmVmNThkNzQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-05T21:43:32Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-05T23:22:35Z"}, "message": "rt: Remove shape code", "tree": {"sha": "afd6830ae7e332be03c20e8cf0fb0894565a308f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afd6830ae7e332be03c20e8cf0fb0894565a308f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53ec6c3f9b495dd930cd061784251534bef58d74", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53ec6c3f9b495dd930cd061784251534bef58d74", "html_url": "https://github.com/rust-lang/rust/commit/53ec6c3f9b495dd930cd061784251534bef58d74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53ec6c3f9b495dd930cd061784251534bef58d74/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc3f89e92bfba43c193fbd928f1502209157431c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc3f89e92bfba43c193fbd928f1502209157431c", "html_url": "https://github.com/rust-lang/rust/commit/bc3f89e92bfba43c193fbd928f1502209157431c"}], "stats": {"total": 1936, "additions": 8, "deletions": 1928}, "files": [{"sha": "efabfc397498b132dfdf56b4d13b3b7abe34ce5d", "filename": "mk/rt.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53ec6c3f9b495dd930cd061784251534bef58d74/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/53ec6c3f9b495dd930cd061784251534bef58d74/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=53ec6c3f9b495dd930cd061784251534bef58d74", "patch": "@@ -69,7 +69,6 @@ RUNTIME_CXXS_$(1) := \\\n               rt/isaac/randport.cpp \\\n               rt/miniz.cpp \\\n               rt/rust_kernel.cpp \\\n-              rt/rust_shape.cpp \\\n               rt/rust_abi.cpp \\\n               rt/rust_debug.cpp \\\n               rt/memory_region.cpp \\"}, {"sha": "8ad36af4ed286c2e4353731383fa30fee6add16a", "filename": "src/rt/rust_shape.cpp", "status": "removed", "additions": 0, "deletions": 542, "changes": 542, "blob_url": "https://github.com/rust-lang/rust/blob/bc3f89e92bfba43c193fbd928f1502209157431c/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bc3f89e92bfba43c193fbd928f1502209157431c/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=bc3f89e92bfba43c193fbd928f1502209157431c", "patch": "@@ -1,542 +0,0 @@\n-// Functions that interpret the shape of a type to perform various low-level\n-// actions, such as copying, freeing, comparing, and so on.\n-\n-\n-#include <algorithm>\n-#include <iomanip>\n-#include <iostream>\n-#include <sstream>\n-#include <utility>\n-\n-#include \"rust_task.h\"\n-#include \"rust_shape.h\"\n-\n-namespace shape {\n-\n-using namespace shape;\n-\n-// Constants\n-\n-const uint8_t CMP_EQ = 0u;\n-const uint8_t CMP_LT = 1u;\n-const uint8_t CMP_LE = 2u;\n-\n-// A shape printer, useful for debugging\n-\n-void\n-print::walk_tag1(tag_info &tinfo) {\n-    DPRINT(\"tag%u\", tinfo.tag_id);\n-}\n-\n-void\n-print::walk_struct1(const uint8_t *end_sp) {\n-    DPRINT(\"(\");\n-\n-    bool first = true;\n-    while (sp != end_sp) {\n-        if (!first)\n-            DPRINT(\",\");\n-        first = false;\n-\n-        walk();\n-    }\n-\n-    DPRINT(\")\");\n-}\n-\n-void\n-print::walk_res1(const rust_fn *dtor, const uint8_t *end_sp) {\n-    DPRINT(\"res@%p\", dtor);\n-\n-    // Print arguments.\n-\n-    if (sp == end_sp)\n-        return;\n-\n-    DPRINT(\"(\");\n-\n-    bool first = true;\n-    while (sp != end_sp) {\n-        if (!first)\n-            DPRINT(\",\");\n-        first = false;\n-\n-        walk();\n-    }\n-\n-    DPRINT(\")\");\n-}\n-\n-template<>\n-void print::walk_number1<uint8_t>()      { DPRINT(\"u8\"); }\n-template<>\n-void print::walk_number1<uint16_t>()     { DPRINT(\"u16\"); }\n-template<>\n-void print::walk_number1<uint32_t>()     { DPRINT(\"u32\"); }\n-template<>\n-void print::walk_number1<uint64_t>()     { DPRINT(\"u64\"); }\n-template<>\n-void print::walk_number1<int8_t>()       { DPRINT(\"i8\"); }\n-template<>\n-void print::walk_number1<int16_t>()      { DPRINT(\"i16\"); }\n-template<>\n-void print::walk_number1<int32_t>()      { DPRINT(\"i32\"); }\n-template<>\n-void print::walk_number1<int64_t>()      { DPRINT(\"i64\"); }\n-template<>\n-void print::walk_number1<float>()        { DPRINT(\"f32\"); }\n-template<>\n-void print::walk_number1<double>()       { DPRINT(\"f64\"); }\n-\n-\n-void\n-size_of::compute_tag_size(tag_info &tinfo) {\n-    // If the precalculated size and alignment are good, use them.\n-    if (tinfo.tag_sa.is_set())\n-        return;\n-\n-    uint16_t n_largest_variants = get_u16_bump(tinfo.largest_variants_ptr);\n-    tinfo.tag_sa.set(0, 0);\n-    for (uint16_t i = 0; i < n_largest_variants; i++) {\n-        uint16_t variant_id = get_u16_bump(tinfo.largest_variants_ptr);\n-        std::pair<const uint8_t *,const uint8_t *> variant_ptr_and_end =\n-            get_variant_sp(tinfo, variant_id);\n-        const uint8_t *variant_ptr = variant_ptr_and_end.first;\n-        const uint8_t *variant_end = variant_ptr_and_end.second;\n-\n-        size_of sub(*this, variant_ptr, NULL);\n-        sub.align = false;\n-\n-        // Compute the size of this variant.\n-        size_align variant_sa;\n-        bool first = true;\n-        while (sub.sp != variant_end) {\n-            if (!first)\n-                variant_sa.size = align_to(variant_sa.size, sub.sa.alignment);\n-            sub.walk();\n-            sub.align = true, first = false;\n-\n-            variant_sa.add(sub.sa.size, sub.sa.alignment);\n-        }\n-\n-        if (tinfo.tag_sa.size < variant_sa.size)\n-            tinfo.tag_sa = variant_sa;\n-    }\n-\n-    if (tinfo.variant_count == 1) {\n-        if (!tinfo.tag_sa.size)\n-            tinfo.tag_sa.set(1, 1);\n-    } else {\n-        // Add in space for the tag.\n-        tinfo.tag_sa.add(sizeof(tag_variant_t), rust_alignof<tag_align_t>());\n-    }\n-}\n-\n-void\n-size_of::walk_tag1(tag_info &tinfo) {\n-    compute_tag_size(*this, tinfo);\n-    sa = tinfo.tag_sa;\n-}\n-\n-void\n-size_of::walk_struct1(const uint8_t *end_sp) {\n-    size_align struct_sa(0, 1);\n-\n-    bool first = true;\n-    while (sp != end_sp) {\n-        if (!first)\n-            struct_sa.size = align_to(struct_sa.size, sa.alignment);\n-        walk();\n-        align = true, first = false;\n-\n-        struct_sa.add(sa);\n-    }\n-\n-    sa = struct_sa;\n-}\n-\n-// Copy constructors\n-\n-#if 0\n-\n-class copy : public data<copy,uint8_t *> {\n-    // FIXME #2892\n-};\n-\n-#endif\n-\n-\n-// Structural comparison glue.\n-\n-class cmp : public data<cmp,ptr_pair> {\n-    friend class data<cmp,ptr_pair>;\n-\n-private:\n-    void walk_slice2(bool is_pod,\n-                     const std::pair<ptr_pair,ptr_pair> &data_range);\n-\n-    void walk_vec2(bool is_pod,\n-                   const std::pair<ptr_pair,ptr_pair> &data_range);\n-\n-    inline void walk_subcontext2(cmp &sub) {\n-        sub.walk();\n-        result = sub.result;\n-    }\n-\n-    inline void walk_box_contents2(cmp &sub) {\n-        sub.align = true;\n-        sub.walk();\n-        result = sub.result;\n-    }\n-\n-    inline void walk_uniq_contents2(cmp &sub) {\n-        sub.align = true;\n-        sub.walk();\n-        result = sub.result;\n-    }\n-\n-    inline void walk_rptr_contents2(cmp &sub) {\n-        sub.align = true;\n-        sub.walk();\n-        result = sub.result;\n-    }\n-\n-    inline void cmp_two_pointers() {\n-        ALIGN_TO(rust_alignof<void *>());\n-        data_pair<uint8_t *> fst = bump_dp<uint8_t *>(dp);\n-        data_pair<uint8_t *> snd = bump_dp<uint8_t *>(dp);\n-        cmp_number(fst);\n-        if (!result)\n-            cmp_number(snd);\n-    }\n-\n-    inline void cmp_pointer() {\n-        ALIGN_TO(rust_alignof<void *>());\n-        cmp_number(bump_dp<uint8_t *>(dp));\n-    }\n-\n-    template<typename T>\n-    void cmp_number(const data_pair<T> &nums) {\n-        result = (nums.fst < nums.snd) ? -1 : (nums.fst == nums.snd) ? 0 : 1;\n-    }\n-\n-public:\n-    int result;\n-\n-    cmp(rust_task *in_task,\n-        bool in_align,\n-        const uint8_t *in_sp,\n-        const rust_shape_tables *in_tables,\n-        uint8_t *in_data_0,\n-        uint8_t *in_data_1)\n-    : data<cmp,ptr_pair>(in_task, in_align, in_sp, in_tables,\n-                         ptr_pair::make(in_data_0, in_data_1)),\n-      result(0) {}\n-\n-    cmp(const cmp &other,\n-        const uint8_t *in_sp,\n-        const rust_shape_tables *in_tables,\n-        ptr_pair &in_dp)\n-    : data<cmp,ptr_pair>(other.task, other.align, in_sp, in_tables,\n-                         in_dp),\n-      result(0) {}\n-\n-    cmp(const cmp &other,\n-        const uint8_t *in_sp = NULL,\n-        const rust_shape_tables *in_tables = NULL)\n-    : data<cmp,ptr_pair>(other.task,\n-                         other.align,\n-                         in_sp ? in_sp : other.sp,\n-                         in_tables ? in_tables : other.tables,\n-                         other.dp),\n-      result(0) {}\n-\n-    cmp(const cmp &other, const ptr_pair &in_dp)\n-    : data<cmp,ptr_pair>(other.task,\n-                         other.align,\n-                         other.sp,\n-                         other.tables,\n-                         in_dp),\n-      result(0) {}\n-\n-    void walk_vec2(bool is_pod) {\n-        walk_vec2(is_pod, get_vec_data_range(dp));\n-    }\n-\n-    void walk_unboxed_vec2(bool is_pod) {\n-        walk_vec2(is_pod, get_unboxed_vec_data_range(dp));\n-    }\n-\n-\n-    void walk_slice2(bool is_pod, bool is_str) {\n-        // Slices compare just like vecs.\n-        walk_vec2(is_pod, get_slice_data_range(is_str, dp));\n-    }\n-\n-    void walk_fixedvec2(uint16_t n_elts, size_t elt_sz, bool is_pod) {\n-        // Fixedvecs compare just like vecs.\n-        walk_vec2(is_pod, get_fixedvec_data_range(n_elts, elt_sz, dp));\n-    }\n-\n-    void walk_box2() {\n-        data<cmp,ptr_pair>::walk_box_contents1();\n-    }\n-\n-    void walk_uniq2() {\n-        data<cmp,ptr_pair>::walk_uniq_contents1();\n-    }\n-\n-    void walk_rptr2() {\n-        data<cmp,ptr_pair>::walk_rptr_contents1();\n-    }\n-\n-    void walk_trait2() {\n-        data<cmp,ptr_pair>::walk_box_contents1();\n-    }\n-\n-    void walk_tydesc2(char) {\n-        cmp_pointer();\n-    }\n-\n-    void walk_fn2(char) { return cmp_two_pointers(); }\n-    void walk_obj2()    { return cmp_two_pointers(); }\n-\n-    void walk_tag2(tag_info &tinfo,\n-                   const data_pair<tag_variant_t> &tag_variants);\n-    void walk_struct2(const uint8_t *end_sp);\n-    void walk_res2(const rust_fn *dtor, const uint8_t *end_sp);\n-    void walk_variant2(tag_info &tinfo,\n-                       tag_variant_t variant_id,\n-                       const std::pair<const uint8_t *,const uint8_t *>\n-                       variant_ptr_and_end);\n-\n-    template<typename T>\n-    void walk_number2() { cmp_number(get_dp<T>(dp)); }\n-};\n-\n-template<>\n-void cmp::cmp_number<int32_t>(const data_pair<int32_t> &nums) {\n-    result = (nums.fst < nums.snd) ? -1 : (nums.fst == nums.snd) ? 0 : 1;\n-}\n-\n-void\n-cmp::walk_vec2(bool is_pod, const std::pair<ptr_pair,ptr_pair> &data_range) {\n-    cmp sub(*this, data_range.first);\n-    ptr_pair data_end = sub.end_dp = data_range.second;\n-    while (!result && sub.dp < data_end) {\n-        sub.walk_reset();\n-        result = sub.result;\n-        sub.align = true;\n-    }\n-\n-    if (!result) {\n-        // If we hit the end, the result comes down to length comparison.\n-        int len_fst = data_range.second.fst - data_range.first.fst;\n-        int len_snd = data_range.second.snd - data_range.first.snd;\n-        cmp_number(data_pair<int>::make(len_fst, len_snd));\n-    }\n-}\n-\n-void\n-cmp::walk_tag2(tag_info &tinfo,\n-               const data_pair<tag_variant_t> &tag_variants) {\n-    cmp_number(tag_variants);\n-    if (result != 0)\n-        return;\n-    data<cmp,ptr_pair>::walk_variant1(tinfo, tag_variants.fst);\n-}\n-\n-void\n-cmp::walk_struct2(const uint8_t *end_sp) {\n-    while (!result && this->sp != end_sp) {\n-        this->walk();\n-        align = true;\n-    }\n-}\n-\n-void\n-cmp::walk_res2(const rust_fn *dtor, const uint8_t *end_sp) {\n-    this->cmp_two_pointers();\n-}\n-\n-void\n-cmp::walk_variant2(tag_info &tinfo,\n-                   tag_variant_t variant_id,\n-                   const std::pair<const uint8_t *,const uint8_t *>\n-                   variant_ptr_and_end) {\n-    cmp sub(*this, variant_ptr_and_end.first);\n-\n-    const uint8_t *variant_end = variant_ptr_and_end.second;\n-    while (!result && sub.sp < variant_end) {\n-        sub.walk();\n-        result = sub.result;\n-        sub.align = true;\n-    }\n-}\n-\n-\n-// Polymorphic logging, for convenience\n-\n-void\n-log::walk_string2(const std::pair<ptr,ptr> &data) {\n-    out << prefix << \"\\\"\" << std::hex;\n-\n-    ptr subdp = data.first;\n-    while (subdp < data.second) {\n-        char ch = *subdp;\n-        switch(ch) {\n-        case '\\n': out << \"\\\\n\"; break;\n-        case '\\r': out << \"\\\\r\"; break;\n-        case '\\t': out << \"\\\\t\"; break;\n-        case '\\\\': out << \"\\\\\\\\\"; break;\n-        case '\"': out << \"\\\\\\\"\"; break;\n-        default:\n-            if (isprint(ch)) {\n-                out << ch;\n-            } else if (ch) {\n-                out << \"\\\\x\" << std::setw(2) << std::setfill('0')\n-                    << (unsigned int)(unsigned char)ch;\n-            }\n-        }\n-        ++subdp;\n-    }\n-\n-    out << \"\\\"\" << std::dec;\n-}\n-\n-void\n-log::walk_struct2(const uint8_t *end_sp) {\n-    out << prefix << \"(\";\n-    prefix = \"\";\n-\n-    bool first = true;\n-    while (sp != end_sp) {\n-        if (!first)\n-            out << \", \";\n-        walk();\n-        align = true, first = false;\n-    }\n-\n-    out << \")\";\n-}\n-\n-void\n-log::walk_vec2(bool is_pod, const std::pair<ptr,ptr> &data) {\n-    if (peek() == SHAPE_U8) {\n-        sp++;   // It's a string. We handle this ourselves.\n-        walk_string2(data);\n-        return;\n-    }\n-\n-    out << prefix << \"[\";\n-\n-    log sub(*this, data.first);\n-    sub.end_dp = data.second;\n-\n-    while (sub.dp < data.second) {\n-        sub.walk_reset();\n-        sub.align = true;\n-        sub.prefix = \", \";\n-    }\n-\n-    out << \"]\";\n-}\n-\n-void\n-log::walk_variant2(tag_info &tinfo,\n-                   tag_variant_t variant_id,\n-                   const std::pair<const uint8_t *,const uint8_t *>\n-                   variant_ptr_and_end) {\n-    log sub(*this, variant_ptr_and_end.first);\n-    const uint8_t *variant_end = variant_ptr_and_end.second;\n-\n-    bool first = true;\n-    while (sub.sp < variant_end) {\n-        out << (first ? \"(\" : \", \");\n-        sub.walk();\n-        sub.align = true, first = false;\n-    }\n-\n-    if (!first)\n-        out << \")\";\n-}\n-\n-void\n-log::walk_res2(const rust_fn *dtor, const uint8_t *end_sp) {\n-    out << prefix << \"res\";\n-\n-    if (this->sp == end_sp)\n-        return;\n-\n-    out << \"(\";\n-\n-    bool first = true;\n-    while (sp != end_sp) {\n-        if (!first)\n-            out << \", \";\n-        walk();\n-        align = true, first = false;\n-    }\n-\n-    out << \")\";\n-}\n-\n-} // end namespace shape\n-\n-extern \"C\" void\n-shape_cmp_type(int8_t *result, const type_desc *tydesc,\n-               uint8_t *data_0, uint8_t *data_1, uint8_t cmp_type) {\n-    rust_task *task = rust_get_current_task();\n-    shape::arena arena;\n-\n-    shape::cmp cmp(task, true, tydesc->shape, tydesc->shape_tables,\n-                   data_0, data_1);\n-    cmp.walk();\n-\n-    switch (cmp_type) {\n-    case shape::CMP_EQ: *result = cmp.result == 0;  break;\n-    case shape::CMP_LT: *result = cmp.result < 0;   break;\n-    case shape::CMP_LE: *result = cmp.result <= 0;  break;\n-    }\n-}\n-\n-extern \"C\" rust_str *\n-shape_log_str(const type_desc *tydesc, uint8_t *data) {\n-    rust_task *task = rust_get_current_task();\n-\n-    shape::arena arena;\n-\n-    std::stringstream ss;\n-    shape::log log(task, true, tydesc->shape, tydesc->shape_tables,\n-                   data, ss);\n-\n-    log.walk();\n-\n-    int len = ss.str().length();\n-    return make_str(task->kernel, ss.str().c_str(), len, \"log_str\");\n-}\n-\n-extern \"C\" void\n-shape_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n-    rust_task *task = rust_get_current_task();\n-\n-    shape::arena arena;\n-\n-    std::stringstream ss;\n-    shape::log log(task, true, tydesc->shape, tydesc->shape_tables,\n-                   data, ss);\n-\n-    log.walk();\n-\n-    task->sched_loop->get_log().log(task, level, \"%s\", ss.str().c_str());\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "fffbfad1d8124fbdf10ece33226ca5785f895501", "filename": "src/rt/rust_shape.h", "status": "removed", "additions": 0, "deletions": 1314, "changes": 1314, "blob_url": "https://github.com/rust-lang/rust/blob/bc3f89e92bfba43c193fbd928f1502209157431c/src%2Frt%2Frust_shape.h", "raw_url": "https://github.com/rust-lang/rust/raw/bc3f89e92bfba43c193fbd928f1502209157431c/src%2Frt%2Frust_shape.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.h?ref=bc3f89e92bfba43c193fbd928f1502209157431c", "patch": "@@ -1,1314 +0,0 @@\n-// Functions that interpret the shape of a type to perform various low-level\n-// actions, such as copying, freeing, comparing, and so on.\n-\n-#ifndef RUST_SHAPE_H\n-#define RUST_SHAPE_H\n-\n-// Tell ISAAC to let go of max() and min() defines.\n-#undef max\n-#undef min\n-\n-#include <iostream>\n-\n-#include \"rust_globals.h\"\n-#include \"rust_util.h\"\n-\n-// ISAAC pollutes our namespace.\n-#undef align\n-\n-#define ARENA_SIZE          256\n-\n-//#define DPRINT(fmt,...)     fprintf(stderr, fmt, ##__VA_ARGS__)\n-//#define DPRINTCX(cx)        shape::print::print_cx(cx)\n-\n-#define DPRINT(fmt,...)\n-#define DPRINTCX(cx)\n-\n-\n-namespace shape {\n-\n-typedef unsigned long tag_variant_t;\n-typedef unsigned long tag_align_t;\n-\n-// Constants\n-\n-const uint8_t SHAPE_U8 = 0u;\n-const uint8_t SHAPE_U16 = 1u;\n-const uint8_t SHAPE_U32 = 2u;\n-const uint8_t SHAPE_U64 = 3u;\n-const uint8_t SHAPE_I8 = 4u;\n-const uint8_t SHAPE_I16 = 5u;\n-const uint8_t SHAPE_I32 = 6u;\n-const uint8_t SHAPE_I64 = 7u;\n-const uint8_t SHAPE_F32 = 8u;\n-const uint8_t SHAPE_F64 = 9u;\n-const uint8_t SHAPE_BOX = 10u;\n-const uint8_t SHAPE_TAG = 12u;\n-const uint8_t SHAPE_STRUCT = 17u;\n-const uint8_t SHAPE_BOX_FN = 18u;\n-const uint8_t SHAPE_RES = 20u;\n-const uint8_t SHAPE_UNIQ = 22u;\n-const uint8_t SHAPE_UNIQ_FN = 25u;\n-const uint8_t SHAPE_STACK_FN = 26u;\n-const uint8_t SHAPE_BARE_FN = 27u;\n-const uint8_t SHAPE_TYDESC = 28u;\n-const uint8_t SHAPE_SEND_TYDESC = 29u;\n-const uint8_t SHAPE_RPTR = 31u;\n-const uint8_t SHAPE_FIXEDVEC = 32u;\n-const uint8_t SHAPE_SLICE = 33u;\n-const uint8_t SHAPE_UNBOXED_VEC = 34u;\n-\n-#ifdef _LP64\n-const uint8_t SHAPE_PTR = SHAPE_U64;\n-#else\n-const uint8_t SHAPE_PTR = SHAPE_U32;\n-#endif\n-\n-\n-// Forward declarations\n-\n-struct rust_obj;\n-struct size_align;\n-class ptr;\n-\n-\n-// Arenas; these functions must execute very quickly, so we use an arena\n-// instead of malloc or new.\n-\n-class arena {\n-    uint8_t *ptr;\n-    uint8_t data[ARENA_SIZE];\n-\n-public:\n-    arena() : ptr(data) {}\n-\n-    template<typename T>\n-    inline T *alloc(size_t count = 1) {\n-        // FIXME: align (probably won't fix before #1498)\n-        size_t sz = count * sizeof(T);\n-        T *rv = (T *)ptr;\n-        ptr += sz;\n-        if (ptr > &data[ARENA_SIZE]) {\n-            fprintf(stderr, \"Arena space exhausted, sorry\\n\");\n-            abort();\n-        }\n-        return rv;\n-    }\n-};\n-\n-\n-// Alignment inquiries\n-//\n-// We can't directly use __alignof__ everywhere because that returns the\n-// preferred alignment of the type, which is different from the ABI-mandated\n-// alignment of the type in some cases (e.g. doubles on x86). The latter is\n-// what actually gets used for struct elements.\n-\n-template<typename T>\n-inline size_t\n-rust_alignof() {\n-#ifdef _MSC_VER\n-    return __alignof(T);\n-#else\n-    return __alignof__(T);\n-#endif\n-}\n-\n-template<>\n-inline size_t\n-rust_alignof<double>() {\n-    return 4;\n-}\n-\n-// Issue #2303\n-// On 32-bit x86 the alignment of 64-bit ints in structures is 4 bytes\n-// Which is different from the preferred 8-byte alignment reported\n-// by __alignof__ (at least on gcc).\n-#ifndef __WIN32__\n-#ifdef __i386__\n-template<>\n-inline size_t\n-rust_alignof<uint64_t>() {\n-    return 4;\n-}\n-#endif\n-#endif\n-\n-\n-// Utility classes\n-\n-struct size_align {\n-    size_t size;\n-    size_t alignment;\n-\n-    size_align(size_t in_size = 0, size_t in_align = 1) :\n-        size(in_size), alignment(in_align) {}\n-\n-    bool is_set() const { return alignment != 0; }\n-\n-    inline void set(size_t in_size, size_t in_align) {\n-        size = in_size;\n-        alignment = in_align;\n-    }\n-\n-    inline void add(const size_align &other) {\n-        add(other.size, other.alignment);\n-    }\n-\n-    inline void add(size_t extra_size, size_t extra_align) {\n-        size += extra_size;\n-        alignment = std::max(alignment, extra_align);\n-    }\n-\n-    static inline size_align make(size_t in_size) {\n-        size_align sa;\n-        sa.size = sa.alignment = in_size;\n-        return sa;\n-    }\n-\n-    static inline size_align make(size_t in_size, size_t in_align) {\n-        size_align sa;\n-        sa.size = in_size;\n-        sa.alignment = in_align;\n-        return sa;\n-    }\n-};\n-\n-struct tag_info {\n-    uint16_t tag_id;                        // The tag ID.\n-    const uint8_t *info_ptr;                // Pointer to the info table.\n-    uint16_t variant_count;                 // Number of variants in the tag.\n-    const uint8_t *largest_variants_ptr;    // Ptr to largest variants table.\n-    size_align tag_sa;                      // Size and align of this tag.\n-};\n-\n-\n-// Utility functions\n-\n-inline uint16_t\n-get_u16(const uint8_t *addr) {\n-    return *reinterpret_cast<const uint16_t *>(addr);\n-}\n-\n-inline uint16_t\n-get_u16_bump(const uint8_t *&addr) {\n-    uint16_t result = get_u16(addr);\n-    addr += sizeof(uint16_t);\n-    return result;\n-}\n-\n-template<typename T>\n-inline void\n-fmt_number(std::ostream &out, T n) {\n-    out << n;\n-}\n-\n-// Override the character interpretation for these two.\n-template<>\n-inline void\n-fmt_number<uint8_t>(std::ostream &out, uint8_t n) {\n-    out << (int)n;\n-}\n-template<>\n-inline void\n-fmt_number<int8_t>(std::ostream &out, int8_t n) {\n-    out << (int)n;\n-}\n-\n-\n-// Contexts\n-\n-// The base context, an abstract class. We use the curiously recurring\n-// template pattern here to avoid virtual dispatch.\n-template<typename T>\n-class ctxt {\n-public:\n-    const uint8_t *sp;                  // shape pointer\n-    const rust_shape_tables *tables;\n-    rust_task *task;\n-    bool align;\n-\n-    ctxt(rust_task *in_task,\n-         bool in_align,\n-         const uint8_t *in_sp,\n-         const rust_shape_tables *in_tables)\n-    : sp(in_sp),\n-      tables(in_tables),\n-      task(in_task),\n-      align(in_align) {}\n-\n-    template<typename U>\n-    ctxt(const ctxt<U> &other,\n-         const uint8_t *in_sp = NULL,\n-         const rust_shape_tables *in_tables = NULL)\n-    : sp(in_sp ? in_sp : other.sp),\n-      tables(in_tables ? in_tables : other.tables),\n-      task(other.task),\n-      align(other.align) {}\n-\n-    void walk();\n-    void walk_reset();\n-\n-    std::pair<const uint8_t *,const uint8_t *>\n-    get_variant_sp(tag_info &info, tag_variant_t variant_id);\n-\n-    const char *\n-    get_variant_name(tag_info &info, tag_variant_t variant_id);\n-\n-protected:\n-    inline uint8_t peek() { return *sp; }\n-\n-    inline size_align get_size_align(const uint8_t *&addr);\n-\n-private:\n-    void walk_vec0();\n-    void walk_unboxed_vec0();\n-    void walk_tag0();\n-    void walk_box0();\n-    void walk_uniq0();\n-    void walk_struct0();\n-    void walk_res0();\n-    void walk_rptr0();\n-    void walk_fixedvec0();\n-    void walk_slice0();\n-};\n-\n-\n-// Core Rust types\n-\n-struct rust_fn {\n-    void (*code)(uint8_t *rv, rust_task *task, void *env, ...);\n-    void *env;\n-};\n-\n-// Traversals\n-\n-#define WALK_NUMBER(c_type) \\\n-    static_cast<T *>(this)->template walk_number1<c_type>()\n-#define WALK_SIMPLE(method) static_cast<T *>(this)->method()\n-\n-template<typename T>\n-void\n-ctxt<T>::walk() {\n-  char s = *sp++;\n-  switch (s) {\n-    case SHAPE_U8:       WALK_NUMBER(uint8_t);       break;\n-    case SHAPE_U16:      WALK_NUMBER(uint16_t);      break;\n-    case SHAPE_U32:      WALK_NUMBER(uint32_t);      break;\n-    case SHAPE_U64:      WALK_NUMBER(uint64_t);      break;\n-    case SHAPE_I8:       WALK_NUMBER(int8_t);        break;\n-    case SHAPE_I16:      WALK_NUMBER(int16_t);       break;\n-    case SHAPE_I32:      WALK_NUMBER(int32_t);       break;\n-    case SHAPE_I64:      WALK_NUMBER(int64_t);       break;\n-    case SHAPE_F32:      WALK_NUMBER(float);         break;\n-    case SHAPE_F64:      WALK_NUMBER(double);        break;\n-    case SHAPE_TAG:      walk_tag0();             break;\n-    case SHAPE_BOX:      walk_box0();             break;\n-    case SHAPE_STRUCT:   walk_struct0();          break;\n-    case SHAPE_RES:      walk_res0();             break;\n-    case SHAPE_UNIQ:     walk_uniq0();            break;\n-    case SHAPE_BOX_FN:\n-    case SHAPE_UNIQ_FN:\n-    case SHAPE_STACK_FN:\n-    case SHAPE_BARE_FN:  static_cast<T*>(this)->walk_fn1(s); break;\n-    case SHAPE_TYDESC:\n-    case SHAPE_SEND_TYDESC: static_cast<T*>(this)->walk_tydesc1(s); break;\n-    case SHAPE_RPTR:     walk_rptr0();            break;\n-    case SHAPE_FIXEDVEC: walk_fixedvec0();        break;\n-    case SHAPE_SLICE:    walk_slice0();           break;\n-    case SHAPE_UNBOXED_VEC: walk_unboxed_vec0();  break;\n-    default:             abort();\n-    }\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_reset() {\n-    const uint8_t *old_sp = sp;\n-    walk();\n-    sp = old_sp;\n-}\n-\n-template<typename T>\n-size_align\n-ctxt<T>::get_size_align(const uint8_t *&addr) {\n-    size_align result;\n-    result.size = get_u16_bump(addr);\n-    result.alignment = *addr++;\n-    return result;\n-}\n-\n-// Returns a pointer to the beginning and a pointer to the end of the shape of\n-// the tag variant with the given ID.\n-template<typename T>\n-std::pair<const uint8_t *,const uint8_t *>\n-ctxt<T>::get_variant_sp(tag_info &tinfo, tag_variant_t variant_id) {\n-    uint16_t variant_offset = get_u16(tinfo.info_ptr +\n-                                      variant_id * sizeof(uint16_t));\n-    const uint8_t *variant_ptr = tables->tags + variant_offset;\n-    uint16_t variant_len = get_u16_bump(variant_ptr);\n-    const uint8_t *variant_end = variant_ptr + variant_len;\n-\n-    return std::make_pair(variant_ptr, variant_end);\n-}\n-\n-template<typename T>\n-const char *\n-ctxt<T>::get_variant_name(tag_info &tinfo, tag_variant_t variant_id) {\n-    std::pair<const uint8_t *,const uint8_t *> variant_ptr_and_end =\n-      this->get_variant_sp(tinfo, variant_id);\n-    // skip over the length to get the null-terminated string:\n-    return (const char*)(variant_ptr_and_end.second + 2);\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_vec0() {\n-    bool is_pod = *sp++;\n-\n-    uint16_t sp_size = get_u16_bump(sp);\n-    const uint8_t *end_sp = sp + sp_size;\n-\n-    static_cast<T *>(this)->walk_vec1(is_pod);\n-\n-    sp = end_sp;\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_unboxed_vec0() {\n-    bool is_pod = *sp++;\n-\n-    uint16_t sp_size = get_u16_bump(sp);\n-    const uint8_t *end_sp = sp + sp_size;\n-\n-    static_cast<T *>(this)->walk_unboxed_vec1(is_pod);\n-\n-    sp = end_sp;\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_tag0() {\n-    tag_info tinfo;\n-    tinfo.tag_id = get_u16_bump(sp);\n-\n-    // Determine the info pointer.\n-    uint16_t info_offset = get_u16(tables->tags +\n-                                   tinfo.tag_id * sizeof(uint16_t));\n-    tinfo.info_ptr = tables->tags + info_offset;\n-\n-    tinfo.variant_count = get_u16_bump(tinfo.info_ptr);\n-\n-    // Determine the largest-variants pointer.\n-    uint16_t largest_variants_offset = get_u16_bump(tinfo.info_ptr);\n-    tinfo.largest_variants_ptr = tables->tags + largest_variants_offset;\n-\n-    // Determine the size and alignment.\n-    tinfo.tag_sa = get_size_align(tinfo.info_ptr);\n-\n-    // Call to the implementation.\n-    static_cast<T *>(this)->walk_tag1(tinfo);\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_box0() {\n-    static_cast<T *>(this)->walk_box1();\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_uniq0() {\n-    uint16_t sp_size = get_u16_bump(sp);\n-    const uint8_t *end_sp = sp + sp_size;\n-\n-    static_cast<T *>(this)->walk_uniq1();\n-\n-    sp = end_sp;\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_rptr0() {\n-    uint16_t sp_size = get_u16_bump(sp);\n-    const uint8_t *end_sp = sp + sp_size;\n-\n-    static_cast<T *>(this)->walk_rptr1();\n-\n-    sp = end_sp;\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_fixedvec0() {\n-    uint16_t n_elts = get_u16_bump(sp);\n-    bool is_pod = *sp++;\n-    uint16_t sp_size = get_u16_bump(sp);\n-    const uint8_t *end_sp = sp + sp_size;\n-\n-    static_cast<T *>(this)->walk_fixedvec1(n_elts, is_pod);\n-\n-    sp = end_sp;\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_slice0() {\n-    bool is_pod = *sp++;\n-    bool is_str = *sp++;\n-    uint16_t sp_size = get_u16_bump(sp);\n-    const uint8_t *end_sp = sp + sp_size;\n-\n-    static_cast<T *>(this)->walk_slice1(is_pod, is_str);\n-\n-    sp = end_sp;\n-}\n-\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_struct0() {\n-    uint16_t sp_size = get_u16_bump(sp);\n-    const uint8_t *end_sp = sp + sp_size;\n-\n-    static_cast<T *>(this)->walk_struct1(end_sp);\n-\n-    sp = end_sp;\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_res0() {\n-    uint16_t dtor_offset = get_u16_bump(sp);\n-    const rust_fn **resources =\n-        reinterpret_cast<const rust_fn **>(tables->resources);\n-    const rust_fn *dtor = resources[dtor_offset];\n-\n-    uint16_t sp_size = get_u16_bump(sp);\n-    const uint8_t *end_sp = sp + sp_size;\n-\n-    static_cast<T *>(this)->walk_res1(dtor, end_sp);\n-\n-    sp = end_sp;\n-}\n-\n-// A shape printer, useful for debugging\n-\n-class print : public ctxt<print> {\n-public:\n-    template<typename T>\n-    print(const ctxt<T> &other,\n-          const uint8_t *in_sp = NULL,\n-          const rust_shape_tables *in_tables = NULL)\n-    : ctxt<print>(other, in_sp, in_tables) {}\n-\n-    print(rust_task *in_task,\n-          bool in_align,\n-          const uint8_t *in_sp,\n-          const rust_shape_tables *in_tables)\n-    : ctxt<print>(in_task, in_align, in_sp, in_tables) {}\n-\n-    void walk_tag1(tag_info &tinfo);\n-    void walk_struct1(const uint8_t *end_sp);\n-    void walk_res1(const rust_fn *dtor, const uint8_t *end_sp);\n-\n-    void walk_vec1(bool is_pod) {\n-        DPRINT(\"vec<\"); walk(); DPRINT(\">\");\n-    }\n-    void walk_unboxed_vec1(bool is_pod) {\n-        DPRINT(\"unboxed_vec<\"); walk(); DPRINT(\">\");\n-    }\n-    void walk_uniq1() {\n-        DPRINT(\"~<\"); walk(); DPRINT(\">\");\n-    }\n-    void walk_box1() {\n-        DPRINT(\"@<\"); walk(); DPRINT(\">\");\n-    }\n-    void walk_rptr1() {\n-        DPRINT(\"&<\"); walk(); DPRINT(\">\");\n-    }\n-    void walk_fixedvec1(uint16_t n_elts, bool is_pod) {\n-      DPRINT(\"fixedvec<%u, \", n_elts); walk(); DPRINT(\">\");\n-    }\n-    void walk_slice1(bool is_pod, bool is_str) {\n-      DPRINT(\"slice<\"); walk(); DPRINT(\">\");\n-    }\n-\n-    void walk_fn1(char kind) {\n-        switch(kind) {\n-          case SHAPE_BARE_FN:  DPRINT(\"fn\");  break;\n-          case SHAPE_BOX_FN:   DPRINT(\"fn@\"); break;\n-          case SHAPE_UNIQ_FN:  DPRINT(\"fn~\"); break;\n-          case SHAPE_STACK_FN: DPRINT(\"fn&\"); break;\n-          default: abort();\n-        }\n-    }\n-    void walk_trait1() { DPRINT(\"trait\"); }\n-\n-    void walk_tydesc1(char kind) {\n-        switch(kind) {\n-          case SHAPE_TYDESC: DPRINT(\"tydesc\"); break;\n-          case SHAPE_SEND_TYDESC: DPRINT(\"send-tydesc\"); break;\n-          default: abort();\n-        }\n-    }\n-\n-    template<typename T>\n-    void walk_number1() {}\n-\n-    template<typename T>\n-    static void print_cx(const T *cx) {\n-        print self(*cx);\n-        self.align = false;\n-        self.walk();\n-    }\n-};\n-\n-\n-//\n-// Size-of (which also computes alignment). Be warned: this is an expensive\n-// operation.\n-//\n-// FIXME #2894: Maybe dynamic_size_of() should call into this somehow?\n-//\n-\n-class size_of : public ctxt<size_of> {\n-private:\n-    size_align sa;\n-\n-public:\n-    size_of(const size_of &other,\n-            const uint8_t *in_sp = NULL,\n-            const rust_shape_tables *in_tables = NULL)\n-    : ctxt<size_of>(other, in_sp, in_tables) {}\n-\n-    template<typename T>\n-    size_of(const ctxt<T> &other,\n-            const uint8_t *in_sp = NULL,\n-            const rust_shape_tables *in_tables = NULL)\n-    : ctxt<size_of>(other, in_sp, in_tables) {}\n-\n-    void walk_tag1(tag_info &tinfo);\n-    void walk_struct1(const uint8_t *end_sp);\n-\n-    void walk_uniq1()       { sa.set(sizeof(void *),   sizeof(void *)); }\n-    void walk_rptr1()       { sa.set(sizeof(void *),   sizeof(void *)); }\n-    void walk_slice1(bool,bool)\n-                            { sa.set(sizeof(void *)*2, sizeof(void *)); }\n-    void walk_box1()        { sa.set(sizeof(void *),   sizeof(void *)); }\n-    void walk_fn1(char)     { sa.set(sizeof(void *)*2, sizeof(void *)); }\n-    void walk_trait1()      { sa.set(sizeof(void *),   sizeof(void *)); }\n-    void walk_tydesc1(char) { sa.set(sizeof(void *),   sizeof(void *)); }\n-    void walk_closure1();\n-\n-    void walk_vec1(bool is_pod) {\n-        sa.set(sizeof(void *), sizeof(void *));\n-    }\n-\n-    void walk_unboxed_vec1(bool is_pod) {\n-        assert(false &&\n-               \"trying to compute size of dynamically sized unboxed vector\");\n-    }\n-\n-    void walk_res1(const rust_fn *dtor, const uint8_t *end_sp) {\n-        abort();    // FIXME #2895\n-    }\n-\n-    void walk_fixedvec1(uint16_t n_elts, bool is_pod) {\n-        size_of sub(*this);\n-        sub.walk();\n-        sa.set(sub.sa.size * n_elts, sub.sa.alignment);\n-    }\n-\n-    template<typename T>\n-    void walk_number1()  { sa.set(sizeof(T), rust_alignof<T>()); }\n-\n-    void compute_tag_size(tag_info &tinfo);\n-\n-    template<typename T>\n-    static void compute_tag_size(const ctxt<T> &other_cx, tag_info &tinfo) {\n-        size_of cx(other_cx);\n-        cx.compute_tag_size(tinfo);\n-    }\n-\n-    template<typename T>\n-    static size_align get(const ctxt<T> &other_cx, unsigned back_up = 0) {\n-        size_of cx(other_cx, other_cx.sp - back_up);\n-        cx.align = false;\n-        cx.walk();\n-        assert(cx.sa.alignment > 0);\n-        return cx.sa;\n-    }\n-};\n-\n-\n-// Pointer wrappers for data traversals\n-\n-class ptr {\n-private:\n-    uint8_t *p;\n-\n-public:\n-    template<typename T>\n-    struct data { typedef T t; };\n-\n-    ptr() : p(NULL) {}\n-    explicit ptr(uint8_t *in_p) : p(in_p) {}\n-    explicit ptr(uintptr_t in_p) : p((uint8_t *)in_p) {}\n-\n-    inline ptr operator+(const size_t amount) const {\n-        return make(p + amount);\n-    }\n-    inline ptr &operator+=(const size_t amount) { p += amount; return *this; }\n-    inline bool operator<(const ptr other) { return p < other.p; }\n-    inline ptr operator++() { ptr rv(*this); p++; return rv; }\n-    inline uint8_t operator*() { return *p; }\n-\n-    template<typename T>\n-    inline operator T *() { return (T *)p; }\n-\n-    inline operator bool() const { return p != NULL; }\n-    inline operator uintptr_t() const { return (uintptr_t)p; }\n-\n-    inline const type_desc *box_body_td() const {\n-        rust_opaque_box *box = *reinterpret_cast<rust_opaque_box**>(p);\n-        assert(box->ref_count >= 1);\n-        return box->td;\n-    }\n-\n-    inline const type_desc *uniq_body_td() const {\n-        rust_opaque_box *box = *reinterpret_cast<rust_opaque_box**>(p);\n-        return box->td;\n-    }\n-\n-    inline ptr box_body() const {\n-        rust_opaque_box *box = *reinterpret_cast<rust_opaque_box**>(p);\n-        return make((uint8_t*)::box_body(box));\n-    }\n-\n-    static inline ptr make(uint8_t *in_p) {\n-        ptr self(in_p);\n-        return self;\n-    }\n-};\n-\n-template<typename T>\n-static inline T\n-bump_dp(ptr &dp) {\n-    T x = *((T *)dp);\n-    dp += sizeof(T);\n-    return x;\n-}\n-\n-template<typename T>\n-static inline T\n-get_dp(ptr dp) {\n-    return *((T *)dp);\n-}\n-\n-\n-// Pointer pairs for structural comparison\n-\n-template<typename T>\n-class data_pair {\n-public:\n-    T fst, snd;\n-\n-    data_pair() {}\n-    data_pair(T &in_fst, T &in_snd) : fst(in_fst), snd(in_snd) {}\n-\n-    inline void operator=(const T rhs) { fst = snd = rhs; }\n-\n-    static data_pair<T> make(T &fst, T &snd) {\n-          data_pair<T> data(fst, snd);\n-        return data;\n-    }\n-};\n-\n-class ptr_pair {\n-public:\n-    uint8_t *fst, *snd;\n-\n-    template<typename T>\n-    struct data { typedef data_pair<T> t; };\n-\n-    ptr_pair() : fst(NULL), snd(NULL) {}\n-    ptr_pair(uint8_t *in_fst, uint8_t *in_snd) : fst(in_fst), snd(in_snd) {}\n-    ptr_pair(data_pair<uint8_t *> &other) : fst(other.fst), snd(other.snd) {}\n-\n-    inline void operator=(uint8_t *rhs) { fst = snd = rhs; }\n-\n-    inline operator bool() const { return fst != NULL && snd != NULL; }\n-\n-    inline ptr_pair operator+(size_t n) const {\n-        return make(fst + n, snd + n);\n-    }\n-\n-    inline ptr_pair operator+=(size_t n) {\n-        fst += n; snd += n;\n-        return *this;\n-    }\n-\n-    inline ptr_pair operator-(size_t n) const {\n-        return make(fst - n, snd - n);\n-    }\n-\n-    inline bool operator<(const ptr_pair &other) const {\n-        return fst < other.fst && snd < other.snd;\n-    }\n-\n-    static inline ptr_pair make(uint8_t *fst, uint8_t *snd) {\n-        ptr_pair self(fst, snd);\n-        return self;\n-    }\n-\n-    static inline ptr_pair make(const data_pair<uint8_t *> &pair) {\n-        ptr_pair self(pair.fst, pair.snd);\n-        return self;\n-    }\n-\n-    inline const type_desc *box_body_td() const {\n-        // Here we assume that the two ptrs are both boxes with\n-        // equivalent type descriptors.  This is safe because we only\n-        // use ptr_pair in the cmp glue, and we only use the cmp glue\n-        // when rust guarantees us that the boxes are of the same\n-        // type.  As box types are not opaque to Rust, it is in a\n-        // position to make this determination.\n-        rust_opaque_box *box_fst = *reinterpret_cast<rust_opaque_box**>(fst);\n-        assert(box_fst->ref_count >= 1);\n-        return box_fst->td;\n-    }\n-\n-    inline const type_desc *uniq_body_td() const {\n-        rust_opaque_box *box_fst = *reinterpret_cast<rust_opaque_box**>(fst);\n-        return box_fst->td;\n-    }\n-\n-    inline ptr_pair box_body() const {\n-        rust_opaque_box *box_fst = *reinterpret_cast<rust_opaque_box**>(fst);\n-        rust_opaque_box *box_snd = *reinterpret_cast<rust_opaque_box**>(snd);\n-        return make((uint8_t*)::box_body(box_fst),\n-                    (uint8_t*)::box_body(box_snd));\n-    }\n-};\n-\n-// NB: This function does not align.\n-template<typename T>\n-inline data_pair<T>\n-bump_dp(ptr_pair &ptr) {\n-    data_pair<T> data(*reinterpret_cast<T *>(ptr.fst),\n-                      *reinterpret_cast<T *>(ptr.snd));\n-    ptr += sizeof(T);\n-    return data;\n-}\n-\n-template<typename T>\n-inline data_pair<T>\n-get_dp(ptr_pair &ptr) {\n-    data_pair<T> data(*reinterpret_cast<T *>(ptr.fst),\n-                      *reinterpret_cast<T *>(ptr.snd));\n-    return data;\n-}\n-\n-}   // end namespace shape\n-\n-\n-inline shape::ptr_pair\n-align_to(const shape::ptr_pair &pair, size_t n) {\n-    return shape::ptr_pair::make(align_to(pair.fst, n),\n-                                 align_to(pair.snd, n));\n-}\n-\n-\n-namespace shape {\n-\n-// An abstract class (again using the curiously recurring template pattern)\n-// for methods that actually manipulate the data involved.\n-\n-#define ALIGN_TO(alignment) \\\n-    if (this->align) { \\\n-        dp = align_to(dp, (alignment)); \\\n-        if (this->end_dp && !(dp < this->end_dp)) \\\n-            return; \\\n-    }\n-\n-#define DATA_SIMPLE(ty, call) \\\n-    ALIGN_TO(rust_alignof<ty>()); \\\n-    U end_dp = dp + sizeof(ty); \\\n-    static_cast<T *>(this)->call; \\\n-    dp = end_dp;\n-\n-template<typename T,typename U>\n-class data : public ctxt< data<T,U> > {\n-public:\n-    U dp;\n-\n-protected:\n-    U end_dp;\n-\n-    void walk_box_contents1();\n-    void walk_uniq_contents1();\n-    void walk_rptr_contents1();\n-    void walk_fn_contents1();\n-    void walk_trait_contents1();\n-    void walk_variant1(tag_info &tinfo, tag_variant_t variant);\n-\n-    static std::pair<uint8_t *,uint8_t *> get_vec_data_range(ptr dp);\n-    static std::pair<ptr_pair,ptr_pair> get_vec_data_range(ptr_pair &dp);\n-\n-    static std::pair<uint8_t *,uint8_t *> get_unboxed_vec_data_range(ptr dp);\n-    static std::pair<ptr_pair,ptr_pair>\n-        get_unboxed_vec_data_range(ptr_pair &dp);\n-    static ptr get_unboxed_vec_end(ptr dp);\n-    static ptr_pair get_unboxed_vec_end(ptr_pair &dp);\n-\n-    static std::pair<uint8_t *,uint8_t *> get_slice_data_range(bool is_str,\n-                                                               ptr dp);\n-    static std::pair<ptr_pair,ptr_pair> get_slice_data_range(bool is_str,\n-                                                             ptr_pair &dp);\n-\n-    static std::pair<uint8_t *,uint8_t *>\n-        get_fixedvec_data_range(uint16_t n_elts, size_t elt_sz, ptr dp);\n-    static std::pair<ptr_pair,ptr_pair>\n-        get_fixedvec_data_range(uint16_t n_elts, size_t elt_sz, ptr_pair &dp);\n-\n-public:\n-    data(rust_task *in_task,\n-         bool in_align,\n-         const uint8_t *in_sp,\n-         const rust_shape_tables *in_tables,\n-         U const &in_dp)\n-    : ctxt< data<T,U> >(in_task, in_align, in_sp, in_tables),\n-      dp(in_dp),\n-      end_dp() {}\n-\n-    void walk_tag1(tag_info &tinfo);\n-\n-    void walk_struct1(const uint8_t *end_sp) {\n-        // FIXME (probably won't fix before #1498): shouldn't we be aligning\n-        // to the first element here?\n-        static_cast<T *>(this)->walk_struct2(end_sp);\n-    }\n-\n-    void walk_vec1(bool is_pod) {\n-        DATA_SIMPLE(void *, walk_vec2(is_pod));\n-    }\n-\n-    void walk_unboxed_vec1(bool is_pod) {\n-        // align?\n-        U next_dp = get_unboxed_vec_end(dp);\n-        static_cast<T *>(this)->walk_unboxed_vec2(is_pod);\n-        dp = next_dp;\n-    }\n-\n-    void walk_slice1(bool is_pod, bool is_str) {\n-        DATA_SIMPLE(void *, walk_slice2(is_pod, is_str));\n-    }\n-\n-    void walk_fixedvec1(uint16_t n_elts, bool is_pod) {\n-        size_align sa = size_of::get(*this);\n-        ALIGN_TO(sa.alignment);\n-        U next_dp = dp + (n_elts * sa.size);\n-        static_cast<T *>(this)->walk_fixedvec2(n_elts, sa.size, is_pod);\n-        dp = next_dp;\n-    }\n-\n-    void walk_box1() { DATA_SIMPLE(void *, walk_box2()); }\n-\n-    void walk_uniq1() { DATA_SIMPLE(void *, walk_uniq2()); }\n-\n-    void walk_rptr1() { DATA_SIMPLE(void *, walk_rptr2()); }\n-\n-    void walk_fn1(char code) {\n-        ALIGN_TO(rust_alignof<void *>());\n-        U next_dp = dp + sizeof(void *) * 2;\n-        static_cast<T *>(this)->walk_fn2(code);\n-        dp = next_dp;\n-    }\n-\n-    void walk_trait1() {\n-        ALIGN_TO(rust_alignof<void *>());\n-        U next_dp = dp + sizeof(void *);\n-        static_cast<T *>(this)->walk_trait2();\n-        dp = next_dp;\n-    }\n-\n-    void walk_tydesc1(char kind) {\n-        ALIGN_TO(rust_alignof<void *>());\n-        U next_dp = dp + sizeof(void *);\n-        static_cast<T *>(this)->walk_tydesc2(kind);\n-        dp = next_dp;\n-    }\n-\n-    void walk_res1(const rust_fn *dtor, const uint8_t *end_sp) {\n-        // Delegate to the implementation.\n-        static_cast<T *>(this)->walk_res2(dtor, end_sp);\n-    }\n-\n-    template<typename WN>\n-    void walk_number1() {\n-        //DATA_SIMPLE(W, walk_number2<W>());\n-        ALIGN_TO(rust_alignof<WN>());\n-        U end_dp = dp + sizeof(WN);\n-        T* t = static_cast<T *>(this);\n-        t->template walk_number2<WN>();\n-        dp = end_dp;\n-    }\n-};\n-\n-template<typename T,typename U>\n-void\n-data<T,U>::walk_box_contents1() {\n-    const type_desc *body_td = dp.box_body_td();\n-    if (body_td) {\n-        U body_dp(dp.box_body());\n-        arena arena;\n-        T sub(*static_cast<T *>(this), body_td->shape,\n-              body_td->shape_tables, body_dp);\n-        sub.align = true;\n-        static_cast<T *>(this)->walk_box_contents2(sub);\n-    }\n-}\n-\n-template<typename T,typename U>\n-void\n-data<T,U>::walk_uniq_contents1() {\n-    const type_desc *body_td = dp.uniq_body_td();\n-    if (body_td) {\n-        U body_dp(dp.box_body());\n-        arena arena;\n-        T sub(*static_cast<T *>(this), /*body_td->shape,*/ this->sp,\n-              body_td->shape_tables, body_dp);\n-        sub.align = true;\n-        static_cast<T *>(this)->walk_uniq_contents2(sub);\n-    }\n-}\n-\n-template<typename T,typename U>\n-void\n-data<T,U>::walk_rptr_contents1() {\n-    typename U::template data<uint8_t *>::t box_ptr = bump_dp<uint8_t *>(dp);\n-    U data_ptr(box_ptr);\n-    T sub(*static_cast<T *>(this), data_ptr);\n-    static_cast<T *>(this)->walk_rptr_contents2(sub);\n-}\n-\n-template<typename T,typename U>\n-void\n-data<T,U>::walk_variant1(tag_info &tinfo, tag_variant_t variant_id) {\n-    std::pair<const uint8_t *,const uint8_t *> variant_ptr_and_end =\n-      this->get_variant_sp(tinfo, variant_id);\n-    static_cast<T *>(this)->walk_variant2(tinfo, variant_id,\n-                                          variant_ptr_and_end);\n-}\n-\n-template<typename T,typename U>\n-std::pair<uint8_t *,uint8_t *>\n-data<T,U>::get_vec_data_range(ptr dp) {\n-    rust_vec_box* ptr = bump_dp<rust_vec_box*>(dp);\n-    uint8_t* data = &ptr->body.data[0];\n-    return std::make_pair(data, data + ptr->body.fill);\n-}\n-\n-template<typename T,typename U>\n-std::pair<ptr_pair,ptr_pair>\n-data<T,U>::get_vec_data_range(ptr_pair &dp) {\n-    std::pair<uint8_t *,uint8_t *> fst =\n-        get_vec_data_range(shape::ptr(dp.fst));\n-    std::pair<uint8_t *,uint8_t *> snd =\n-        get_vec_data_range(shape::ptr(dp.snd));\n-    ptr_pair start(fst.first, snd.first);\n-    ptr_pair end(fst.second, snd.second);\n-    return std::make_pair(start, end);\n-}\n-\n-template<typename T,typename U>\n-std::pair<uint8_t *,uint8_t *>\n-data<T,U>::get_unboxed_vec_data_range(ptr dp) {\n-    rust_vec* ptr = (rust_vec*)dp;\n-    uint8_t* data = &ptr->data[0];\n-    return std::make_pair(data, data + ptr->fill);\n-}\n-\n-template<typename T,typename U>\n-std::pair<ptr_pair,ptr_pair>\n-data<T,U>::get_unboxed_vec_data_range(ptr_pair &dp) {\n-    std::pair<uint8_t *,uint8_t *> fst =\n-        get_unboxed_vec_data_range(shape::ptr(dp.fst));\n-    std::pair<uint8_t *,uint8_t *> snd =\n-        get_unboxed_vec_data_range(shape::ptr(dp.snd));\n-    ptr_pair start(fst.first, snd.first);\n-    ptr_pair end(fst.second, snd.second);\n-    return std::make_pair(start, end);\n-}\n-\n-template<typename T,typename U>\n-ptr data<T,U>::get_unboxed_vec_end(ptr dp) {\n-    rust_vec* ptr = (rust_vec*)dp;\n-    return dp + sizeof(rust_vec) + ptr->fill;\n-}\n-\n-template<typename T,typename U>\n-ptr_pair data<T,U>::get_unboxed_vec_end(ptr_pair &dp) {\n-    return ptr_pair(get_unboxed_vec_end(ptr(dp.fst)),\n-                    get_unboxed_vec_end(ptr(dp.snd)));\n-}\n-\n-template<typename T,typename U>\n-std::pair<uint8_t *,uint8_t *>\n-data<T,U>::get_slice_data_range(bool is_str, ptr dp) {\n-    uint8_t* ptr = bump_dp<uint8_t*>(dp);\n-    size_t len = bump_dp<size_t>(dp);\n-    if (is_str) len--;\n-    return std::make_pair(ptr, ptr + len);\n-}\n-\n-template<typename T,typename U>\n-std::pair<ptr_pair,ptr_pair>\n-data<T,U>::get_slice_data_range(bool is_str, ptr_pair &dp) {\n-    std::pair<uint8_t *,uint8_t *> fst =\n-        get_slice_data_range(is_str, shape::ptr(dp.fst));\n-    std::pair<uint8_t *,uint8_t *> snd =\n-        get_slice_data_range(is_str, shape::ptr(dp.snd));\n-    ptr_pair start(fst.first, snd.first);\n-    ptr_pair end(fst.second, snd.second);\n-    return std::make_pair(start, end);\n-}\n-\n-template<typename T,typename U>\n-std::pair<uint8_t *,uint8_t *>\n-data<T,U>::get_fixedvec_data_range(uint16_t n_elts, size_t elt_sz, ptr dp) {\n-    uint8_t* ptr = (uint8_t*)(dp);\n-    return std::make_pair(ptr, ptr + (((size_t)n_elts) * elt_sz));\n-}\n-\n-template<typename T,typename U>\n-std::pair<ptr_pair,ptr_pair>\n-data<T,U>::get_fixedvec_data_range(uint16_t n_elts, size_t elt_sz,\n-                                   ptr_pair &dp) {\n-    std::pair<uint8_t *,uint8_t *> fst =\n-        get_fixedvec_data_range(n_elts, elt_sz, shape::ptr(dp.fst));\n-    std::pair<uint8_t *,uint8_t *> snd =\n-        get_fixedvec_data_range(n_elts, elt_sz, shape::ptr(dp.snd));\n-    ptr_pair start(fst.first, snd.first);\n-    ptr_pair end(fst.second, snd.second);\n-    return std::make_pair(start, end);\n-}\n-\n-\n-template<typename T,typename U>\n-void\n-data<T,U>::walk_tag1(tag_info &tinfo) {\n-    size_of::compute_tag_size(*this, tinfo);\n-\n-    if (tinfo.variant_count > 1)\n-        ALIGN_TO(rust_alignof<tag_align_t>());\n-\n-    U end_dp = dp + tinfo.tag_sa.size;\n-\n-    typename U::template data<tag_variant_t>::t tag_variant;\n-    if (tinfo.variant_count > 1)\n-        tag_variant = bump_dp<tag_variant_t>(dp);\n-    else\n-        tag_variant = 0;\n-\n-    static_cast<T *>(this)->walk_tag2(tinfo, tag_variant);\n-\n-    dp = end_dp;\n-}\n-\n-template<typename T,typename U>\n-void\n-  data<T,U>::walk_fn_contents1() {\n-    fn_env_pair pair = bump_dp<fn_env_pair>(dp);\n-    if (!pair.env)\n-        return;\n-\n-    arena arena;\n-    const type_desc *closure_td = pair.env->td;\n-    ptr closure_dp((uintptr_t)box_body(pair.env));\n-    T sub(*static_cast<T *>(this), closure_td->shape,\n-          closure_td->shape_tables, closure_dp);\n-    sub.align = true;\n-\n-    sub.walk();\n-}\n-\n-template<typename T,typename U>\n-void\n-data<T,U>::walk_trait_contents1() {\n-    walk_box_contents1();\n-}\n-\n-// Polymorphic logging, for convenience\n-\n-class log : public data<log,ptr> {\n-    friend class data<log,ptr>;\n-\n-private:\n-    std::ostream &out;\n-    const char *prefix;\n-    bool in_string;\n-\n-    log(log &other,\n-        const uint8_t *in_sp,\n-        const rust_shape_tables *in_tables = NULL)\n-    : data<log,ptr>(other.task,\n-                    other.align,\n-                    in_sp,\n-                    in_tables ? in_tables : other.tables,\n-                    other.dp),\n-      out(other.out),\n-      prefix(\"\") {}\n-\n-    log(log &other,\n-        const uint8_t *in_sp,\n-        const rust_shape_tables *in_tables,\n-        ptr in_dp)\n-    : data<log,ptr>(other.task,\n-                    other.align,\n-                    in_sp,\n-                    in_tables,\n-                    in_dp),\n-      out(other.out),\n-      prefix(\"\") {}\n-\n-    log(log &other, ptr in_dp)\n-    : data<log,ptr>(other.task,\n-                    other.align,\n-                    other.sp,\n-                    other.tables,\n-                    in_dp),\n-      out(other.out),\n-      prefix(\"\") {}\n-\n-    void walk_vec2(bool is_pod) {\n-        if (!get_dp<void *>(dp))\n-            out << prefix << \"(null)\";\n-        else\n-            walk_vec2(is_pod, get_vec_data_range(dp));\n-    }\n-\n-    void walk_unboxed_vec2(bool is_pod) {\n-        walk_vec2(is_pod, get_unboxed_vec_data_range(dp));\n-    }\n-\n-    void walk_slice2(bool is_pod, bool is_str) {\n-        walk_vec2(is_pod, get_slice_data_range(is_str, dp));\n-        out << \"/&\";\n-    }\n-\n-    void walk_fixedvec2(uint16_t n_elts, size_t elt_sz, bool is_pod) {\n-        walk_vec2(is_pod, get_fixedvec_data_range(n_elts, elt_sz, dp));\n-        out << \"/\" << n_elts;\n-    }\n-\n-    void walk_tag2(tag_info &tinfo, tag_variant_t tag_variant) {\n-        // out << prefix << \"tag\" << tag_variant;\n-        out << prefix << get_variant_name(tinfo, tag_variant);\n-        data<log,ptr>::walk_variant1(tinfo, tag_variant);\n-    }\n-\n-    void walk_box2() {\n-        out << prefix << \"@\";\n-        prefix = \"\";\n-        data<log,ptr>::walk_box_contents1();\n-    }\n-\n-    void walk_uniq2() {\n-        out << prefix << \"~\";\n-        prefix = \"\";\n-        data<log,ptr>::walk_uniq_contents1();\n-    }\n-\n-    void walk_rptr2() {\n-        out << prefix << \"&\";\n-        prefix = \"\";\n-        data<log,ptr>::walk_rptr_contents1();\n-    }\n-\n-    void walk_fn2(char kind) {\n-        out << prefix << \"fn\";\n-        prefix = \"\";\n-        data<log,ptr>::walk_fn_contents1();\n-    }\n-\n-    void walk_trait2() {\n-        out << prefix << \"trait(\";\n-        prefix = \"\";\n-        data<log,ptr>::walk_trait_contents1();\n-        out << prefix << \")\";\n-    }\n-\n-    void walk_tydesc2(char kind) {\n-        out << prefix << \"tydesc\";\n-    }\n-\n-    void walk_subcontext2(log &sub) { sub.walk(); }\n-\n-    void walk_box_contents2(log &sub) {\n-        out << prefix;\n-        rust_opaque_box *box_ptr = *(rust_opaque_box **) dp;\n-        if (!box_ptr) {\n-            out << \"(null)\";\n-        } else {\n-            sub.align = true;\n-            sub.walk();\n-        }\n-    }\n-\n-    void walk_uniq_contents2(log &sub) {\n-        out << prefix;\n-        sub.align = true;\n-        sub.walk();\n-    }\n-\n-    void walk_rptr_contents2(log &sub) {\n-        out << prefix;\n-        sub.align = true;\n-        sub.walk();\n-    }\n-\n-    void walk_struct2(const uint8_t *end_sp);\n-    void walk_vec2(bool is_pod, const std::pair<ptr,ptr> &data);\n-    void walk_slice2(bool is_pod, const std::pair<ptr,ptr> &data);\n-    void walk_variant2(tag_info &tinfo,\n-                       tag_variant_t variant_id,\n-                       const std::pair<const uint8_t *,const uint8_t *>\n-                       variant_ptr_and_end);\n-    void walk_string2(const std::pair<ptr,ptr> &data);\n-    void walk_res2(const rust_fn *dtor, const uint8_t *end_sp);\n-\n-    template<typename T>\n-    inline void walk_number2() {\n-        out << prefix;\n-        fmt_number(out, get_dp<T>(dp));\n-    }\n-\n-public:\n-    log(rust_task *in_task,\n-        bool in_align,\n-        const uint8_t *in_sp,\n-        const rust_shape_tables *in_tables,\n-        uint8_t *in_data,\n-        std::ostream &in_out)\n-        : data<log,ptr>(in_task, in_align, in_sp, in_tables,\n-                        ptr(in_data)),\n-      out(in_out),\n-      prefix(\"\") {}\n-};\n-\n-}   // end namespace shape\n-\n-#endif\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "9612c0dc40992141931a3d49728618ddd83a0eaa", "filename": "src/rt/rust_type.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53ec6c3f9b495dd930cd061784251534bef58d74/src%2Frt%2Frust_type.h", "raw_url": "https://github.com/rust-lang/rust/raw/53ec6c3f9b495dd930cd061784251534bef58d74/src%2Frt%2Frust_type.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_type.h?ref=53ec6c3f9b495dd930cd061784251534bef58d74", "patch": "@@ -17,11 +17,6 @@ struct type_desc;\n \n typedef void CDECL (glue_fn)(void *, void *, const type_desc **, void *);\n \n-struct rust_shape_tables {\n-    uint8_t *tags;\n-    uint8_t *resources;\n-};\n-\n // Corresponds to the boxed data in the @ region.  The body follows the\n // header; you can obtain a ptr via box_body() below.\n struct rust_opaque_box {\n@@ -52,8 +47,8 @@ struct type_desc {\n     glue_fn *drop_glue;\n     glue_fn *free_glue;\n     glue_fn *visit_glue;\n-    const uint8_t *shape;\n-    const rust_shape_tables *shape_tables;\n+    const uint8_t *unused;\n+    const uint8_t *unused2;\n };\n \n extern \"C\" type_desc *rust_clone_type_desc(type_desc*);"}, {"sha": "0a9f0647789788da219b4df245bd0827c4002be8", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 4, "deletions": 50, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/53ec6c3f9b495dd930cd061784251534bef58d74/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/53ec6c3f9b495dd930cd061784251534bef58d74/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=53ec6c3f9b495dd930cd061784251534bef58d74", "patch": "@@ -301,12 +301,8 @@ rust_upcall_free(void* ptr) {\n \n extern \"C\" CDECL void\n upcall_validate_box(rust_opaque_box* ptr) {\n-    if (ptr) {\n-        assert(ptr->ref_count > 0);\n-        assert(ptr->td != NULL);\n-        assert(ptr->td->align <= 8);\n-        assert(ptr->td->size <= 4096); // might not really be true...\n-    }\n+    // XXX: Remove after snapshot\n+    abort();\n }\n \n /**********************************************************************/\n@@ -365,52 +361,10 @@ upcall_rust_personality(int version,\n     return args.retval;\n }\n \n-extern \"C\" void\n-shape_cmp_type(int8_t *result, const type_desc *tydesc,\n-               uint8_t *data_0, uint8_t *data_1, uint8_t cmp_type);\n-\n-struct s_cmp_type_args {\n-    int8_t *result;\n-    const type_desc *tydesc;\n-    uint8_t *data_0;\n-    uint8_t *data_1;\n-    uint8_t cmp_type;\n-};\n-\n-extern \"C\" void\n-upcall_s_cmp_type(s_cmp_type_args *args) {\n-    shape_cmp_type(args->result, args->tydesc,\n-                   args->data_0, args->data_1, args->cmp_type);\n-}\n-\n-extern \"C\" void\n-upcall_cmp_type(int8_t *result, const type_desc *tydesc,\n-                uint8_t *data_0, uint8_t *data_1, uint8_t cmp_type) {\n-    rust_task *task = rust_get_current_task();\n-    s_cmp_type_args args = {result, tydesc,\n-                            data_0, data_1, cmp_type};\n-    UPCALL_SWITCH_STACK(task, &args, upcall_s_cmp_type);\n-}\n-\n-extern \"C\" void\n-shape_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level);\n-\n-struct s_log_type_args {\n-    const type_desc *tydesc;\n-    uint8_t *data;\n-    uint32_t level;\n-};\n-\n-extern \"C\" void\n-upcall_s_log_type(s_log_type_args *args) {\n-    shape_log_type(args->tydesc, args->data, args->level);\n-}\n-\n extern \"C\" void\n upcall_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n-    rust_task *task = rust_get_current_task();\n-    s_log_type_args args = {tydesc, data, level};\n-    UPCALL_SWITCH_STACK(task, &args, upcall_s_log_type);\n+    // XXX: Remove after snapshot\n+    abort();\n }\n \n // NB: This needs to be blazing fast. Don't switch stacks"}, {"sha": "60e6cc3d842660de014ffde5e4ebe2e46900c6e3", "filename": "src/rt/rust_util.cpp", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/53ec6c3f9b495dd930cd061784251534bef58d74/src%2Frt%2Frust_util.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/53ec6c3f9b495dd930cd061784251534bef58d74/src%2Frt%2Frust_util.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.cpp?ref=53ec6c3f9b495dd930cd061784251534bef58d74", "patch": "@@ -1,28 +1,18 @@\n #include \"rust_type.h\"\n-#include \"rust_shape.h\"\n \n \n // A hardcoded type descriptor for strings, since the runtime needs to\n // be able to create them.\n \n-struct rust_shape_tables empty_shape_tables;\n-\n-uint8_t str_body_shape[] = {\n-    shape::SHAPE_UNBOXED_VEC,\n-    0x1, // is_pod\n-    0x1, 0x0, // size field: 1\n-    shape::SHAPE_U8\n-};\n-\n struct type_desc str_body_tydesc = {\n     1, // size\n     1, // align\n     NULL, // take_glue\n     NULL, // drop_glue\n     NULL, // free_glue\n     NULL, // visit_glue\n-    str_body_shape, // shape\n-    &empty_shape_tables, // shape_tables\n+    NULL, // shape\n+    NULL, // shape_tables\n };\n \n //"}, {"sha": "020008c38421c645fe328a2ce904bda40c509bd1", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53ec6c3f9b495dd930cd061784251534bef58d74/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/53ec6c3f9b495dd930cd061784251534bef58d74/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=53ec6c3f9b495dd930cd061784251534bef58d74", "patch": "@@ -64,14 +64,12 @@ rust_get_stack_segment\n rust_task_weaken\n rust_task_unweaken\n rust_log_str\n-shape_log_str\n start_task\n vec_reserve_shared_actual\n vec_reserve_shared\n task_clear_event_reject\n task_wait_event\n task_signal_event\n-upcall_cmp_type\n upcall_fail\n upcall_trace\n upcall_free"}]}