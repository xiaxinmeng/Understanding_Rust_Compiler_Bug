{"sha": "f88c808b7311fe6cf6f8b4133fed7e33e437b325", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4OGM4MDhiNzMxMWZlNmNmNmY4YjQxMzNmZWQ3ZTMzZTQzN2IzMjU=", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2015-12-29T04:20:20Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2015-12-29T22:03:56Z"}, "message": "Process candidates for match in the same order as written in the source.", "tree": {"sha": "08747f87817ffbe0da64f54a1040ca0dc5b31504", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08747f87817ffbe0da64f54a1040ca0dc5b31504"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f88c808b7311fe6cf6f8b4133fed7e33e437b325", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f88c808b7311fe6cf6f8b4133fed7e33e437b325", "html_url": "https://github.com/rust-lang/rust/commit/f88c808b7311fe6cf6f8b4133fed7e33e437b325", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f88c808b7311fe6cf6f8b4133fed7e33e437b325/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f72e001a0a761f711739bfe07c8ea54136ec5da", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f72e001a0a761f711739bfe07c8ea54136ec5da", "html_url": "https://github.com/rust-lang/rust/commit/9f72e001a0a761f711739bfe07c8ea54136ec5da"}], "stats": {"total": 46, "additions": 19, "deletions": 27}, "files": [{"sha": "64b9255016e6c977a7a138d384b8a93f6de26d41", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f88c808b7311fe6cf6f8b4133fed7e33e437b325/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f88c808b7311fe6cf6f8b4133fed7e33e437b325/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=f88c808b7311fe6cf6f8b4133fed7e33e437b325", "patch": "@@ -61,16 +61,13 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // assemble a list of candidates: there is one candidate per\n         // pattern, which means there may be more than one candidate\n         // *per arm*. These candidates are kept sorted such that the\n-        // highest priority candidate comes last in the list. This the\n-        // reverse of the order in which candidates are written in the\n-        // source.\n+        // highest priority candidate comes first in the list.\n+        // (i.e. same order as in source)\n         let candidates: Vec<_> =\n             arms.iter()\n                 .enumerate()\n-                .rev() // highest priority comes last\n                 .flat_map(|(arm_index, arm)| {\n                     arm.patterns.iter()\n-                                .rev()\n                                 .map(move |pat| (arm_index, pat, arm.guard.clone()))\n                 })\n                 .map(|(arm_index, pattern, guard)| {\n@@ -290,9 +287,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// The main match algorithm. It begins with a set of candidates\n     /// `candidates` and has the job of generating code to determine\n     /// which of these candidates, if any, is the correct one. The\n-    /// candidates are sorted in inverse priority -- so the last item\n-    /// in the list has highest priority. When a candidate is found to\n-    /// match the value, we will generate a branch to the appropriate\n+    /// candidates are sorted such that the first item in the list\n+    /// has the highest priority. When a candidate is found to match\n+    /// the value, we will generate a branch to the appropriate\n     /// block found in `arm_blocks`.\n     ///\n     /// The return value is a list of \"otherwise\" blocks. These are\n@@ -324,17 +321,17 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             unpack!(block = self.simplify_candidate(block, candidate));\n         }\n \n-        // The candidates are inversely sorted by priority. Check to\n-        // see whether the candidates in the front of the queue (and\n-        // hence back of the vec) have satisfied all their match\n+        // The candidates are sorted by priority. Check to see\n+        // whether the higher priority candidates (and hence at\n+        // the front of the vec) have satisfied all their match\n         // pairs.\n         let fully_matched =\n-            candidates.iter().rev().take_while(|c| c.match_pairs.is_empty()).count();\n+            candidates.iter().take_while(|c| c.match_pairs.is_empty()).count();\n         debug!(\"match_candidates: {:?} candidates fully matched\", fully_matched);\n-        for _ in 0..fully_matched {\n+        let mut unmatched_candidates = candidates.split_off(fully_matched);\n+        for candidate in candidates {\n             // If so, apply any bindings, test the guard (if any), and\n             // branch to the arm.\n-            let candidate = candidates.pop().unwrap();\n             if let Some(b) = self.bind_and_guard_matched_candidate(block, arm_blocks, candidate) {\n                 block = b;\n             } else {\n@@ -346,13 +343,13 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         // If there are no candidates that still need testing, we're done.\n         // Since all matches are exhaustive, execution should never reach this point.\n-        if candidates.is_empty() {\n+        if unmatched_candidates.is_empty() {\n             return vec![block];\n         }\n \n         // Test candidates where possible.\n         let (otherwise, tested_candidates) =\n-            self.test_candidates(span, arm_blocks, &candidates, block);\n+            self.test_candidates(span, arm_blocks, &unmatched_candidates, block);\n \n         // If the target candidates were exhaustive, then we are done.\n         if otherwise.is_empty() {\n@@ -361,15 +358,14 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         // If all candidates were sorted into `target_candidates` somewhere, then\n         // the initial set was inexhaustive.\n-        let untested_candidates = candidates.len() - tested_candidates;\n-        if untested_candidates == 0 {\n+        let untested_candidates = unmatched_candidates.split_off(tested_candidates);\n+        if untested_candidates.len() == 0 {\n             return otherwise;\n         }\n \n         // Otherwise, let's process those remaining candidates.\n         let join_block = self.join_otherwise_blocks(otherwise);\n-        candidates.truncate(untested_candidates);\n-        self.match_candidates(span, arm_blocks, candidates, join_block)\n+        self.match_candidates(span, arm_blocks, untested_candidates, join_block)\n     }\n \n     fn join_otherwise_blocks(&mut self,\n@@ -461,7 +457,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                              -> (Vec<BasicBlock>, usize)\n     {\n         // extract the match-pair from the highest priority candidate\n-        let match_pair = &candidates.last().unwrap().match_pairs[0];\n+        let match_pair = &candidates.first().unwrap().match_pairs[0];\n         let mut test = self.test(match_pair);\n \n         // most of the time, the test to perform is simply a function\n@@ -470,7 +466,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // available\n         match test.kind {\n             TestKind::SwitchInt { switch_ty, ref mut options, ref mut indices } => {\n-                for candidate in candidates.iter().rev() {\n+                for candidate in candidates.iter() {\n                     if !self.add_cases_to_switch(&match_pair.lvalue,\n                                                  candidate,\n                                                  switch_ty,\n@@ -497,7 +493,6 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // that point, we stop sorting.\n         let tested_candidates =\n             candidates.iter()\n-                      .rev()\n                       .take_while(|c| self.sort_candidate(&match_pair.lvalue,\n                                                           &test,\n                                                           c,\n@@ -512,10 +507,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let otherwise: Vec<_> =\n             target_blocks.into_iter()\n                          .zip(target_candidates)\n-                         .flat_map(|(target_block, mut target_candidates)| {\n-                             // We need to preserve the fact that the candidates\n-                             // are in the reversed order compared to the source.\n-                             target_candidates.reverse();\n+                         .flat_map(|(target_block, target_candidates)| {\n                              self.match_candidates(span,\n                                                    arm_blocks,\n                                                    target_candidates,"}]}