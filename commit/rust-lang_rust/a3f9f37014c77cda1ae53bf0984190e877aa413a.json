{"sha": "a3f9f37014c77cda1ae53bf0984190e877aa413a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZjlmMzcwMTRjNzdjZGExYWU1M2JmMDk4NDE5MGU4NzdhYTQxM2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-30T18:11:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-30T18:11:49Z"}, "message": "auto merge of #13072 : bjz/rust/bitset, r=alexcrichton\n\nThe `bitflags!` macro generates a `struct` that holds a set of C-style bitmask flags. It is useful for creating typesafe wrappers for C APIs.\r\n\r\nFor example:\r\n\r\n~~~rust\r\n#[feature(phase)];\r\n#[phase(syntax)] extern crate collections;\r\n\r\nbitflags!(Flags: u32 {\r\n    FlagA       = 0x00000001,\r\n    FlagB       = 0x00000010,\r\n    FlagC       = 0x00000100,\r\n    FlagABC     = FlagA.bits\r\n                | FlagB.bits\r\n                | FlagC.bits\r\n})\r\n\r\nfn main() {\r\n    let e1 = FlagA | FlagC;\r\n    let e2 = FlagB | FlagC;\r\n    assert!((e1 | e2) == FlagABC);   // union\r\n    assert!((e1 & e2) == FlagC);     // intersection\r\n    assert!((e1 - e2) == FlagA);     // set difference\r\n}\r\n~~~", "tree": {"sha": "a0d6f9a1989f60675df6d369b6761b45a9c15587", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0d6f9a1989f60675df6d369b6761b45a9c15587"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3f9f37014c77cda1ae53bf0984190e877aa413a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f9f37014c77cda1ae53bf0984190e877aa413a", "html_url": "https://github.com/rust-lang/rust/commit/a3f9f37014c77cda1ae53bf0984190e877aa413a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3f9f37014c77cda1ae53bf0984190e877aa413a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e9f3ea42361a5a938a4f22beff28bb2ade48af4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e9f3ea42361a5a938a4f22beff28bb2ade48af4", "html_url": "https://github.com/rust-lang/rust/commit/7e9f3ea42361a5a938a4f22beff28bb2ade48af4"}, {"sha": "63ee7bb0db642e43e19b8ec597521858805ad21e", "url": "https://api.github.com/repos/rust-lang/rust/commits/63ee7bb0db642e43e19b8ec597521858805ad21e", "html_url": "https://github.com/rust-lang/rust/commit/63ee7bb0db642e43e19b8ec597521858805ad21e"}], "stats": {"total": 260, "additions": 260, "deletions": 0}, "files": [{"sha": "8764163ddc57445efc5d271bc9524c29e3c1462d", "filename": "src/libstd/bitflags.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/a3f9f37014c77cda1ae53bf0984190e877aa413a/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f9f37014c77cda1ae53bf0984190e877aa413a/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=a3f9f37014c77cda1ae53bf0984190e877aa413a", "patch": "@@ -0,0 +1,257 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The `bitflags!` macro generates a `struct` that holds a set of C-style\n+//! bitmask flags. It is useful for creating typesafe wrappers for C APIs.\n+//!\n+//! The flags should only be defined for integer types, otherwise unexpected\n+//! type errors may occur at compile time.\n+//!\n+//! # Example\n+//!\n+//! ~~~rust\n+//! bitflags!(Flags: u32 {\n+//!     FlagA       = 0x00000001,\n+//!     FlagB       = 0x00000010,\n+//!     FlagC       = 0x00000100,\n+//!     FlagABC     = FlagA.bits\n+//!                 | FlagB.bits\n+//!                 | FlagC.bits\n+//! })\n+//!\n+//! fn main() {\n+//!     let e1 = FlagA | FlagC;\n+//!     let e2 = FlagB | FlagC;\n+//!     assert!((e1 | e2) == FlagABC);   // union\n+//!     assert!((e1 & e2) == FlagC);     // intersection\n+//!     assert!((e1 - e2) == FlagA);     // set difference\n+//! }\n+//! ~~~\n+//!\n+//! The generated `struct`s can also be extended with type and trait implementations:\n+//!\n+//! ~~~rust\n+//! use std::fmt;\n+//!\n+//! bitflags!(Flags: u32 {\n+//!     FlagA   = 0x00000001,\n+//!     FlagB   = 0x00000010\n+//! })\n+//!\n+//! impl Flags {\n+//!     pub fn clear(&mut self) {\n+//!         self.bits = 0;  // The `bits` field can be accessed from within the\n+//!                         // same module where the `bitflags!` macro was invoked.\n+//!     }\n+//! }\n+//!\n+//! impl fmt::Show for Flags {\n+//!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+//!         write!(f.buf, \"hi!\")\n+//!     }\n+//! }\n+//!\n+//! fn main() {\n+//!     let mut flags = FlagA | FlagB;\n+//!     flags.clear();\n+//!     assert!(flags.is_empty());\n+//!     assert_eq!(format!(\"{}\", flags), ~\"hi!\");\n+//! }\n+//! ~~~\n+//!\n+//! # Derived traits\n+//!\n+//! The `Eq`, `TotalEq`, and `Clone` traits are automatically derived for the\n+//! `struct` using the `deriving` attribute.\n+//!\n+//! # Operators\n+//!\n+//! The following operator traits are implemented for the generated `struct`:\n+//!\n+//! - `BitOr`: union\n+//! - `BitAnd`: intersection\n+//! - `Sub`: set difference\n+//!\n+//! # Methods\n+//!\n+//! The following methods are defined for the generated `struct`:\n+//!\n+//! - `empty`: an empty set of flags\n+//! - `bits`: the raw value of the flags currently stored\n+//! - `is_empty`: `true` if no flags are currently stored\n+//! - `intersects`: `true` if there are flags common to both `self` and `other`\n+//! - `contains`: `true` all of the flags in `other` are contained within `self`\n+//! - `insert`: inserts the specified flags in-place\n+//! - `remove`: removes the specified flags in-place\n+\n+#[macro_export]\n+macro_rules! bitflags(\n+    ($BitFlags:ident: $T:ty {\n+        $($Flag:ident = $value:expr),+\n+    }) => (\n+        #[deriving(Eq, TotalEq, Clone)]\n+        pub struct $BitFlags {\n+            bits: $T,\n+        }\n+\n+        $(pub static $Flag: $BitFlags = $BitFlags { bits: $value };)+\n+\n+        impl $BitFlags {\n+            /// Returns an empty set of flags.\n+            pub fn empty() -> $BitFlags {\n+                $BitFlags { bits: 0 }\n+            }\n+\n+            /// Returns the raw value of the flags currently stored.\n+            pub fn bits(&self) -> $T {\n+                self.bits\n+            }\n+\n+            /// Returns `true` if no flags are currently stored.\n+            pub fn is_empty(&self) -> bool {\n+                *self == $BitFlags::empty()\n+            }\n+\n+            /// Returns `true` if there are flags common to both `self` and `other`.\n+            pub fn intersects(&self, other: $BitFlags) -> bool {\n+                !(self & other).is_empty()\n+            }\n+\n+            /// Returns `true` all of the flags in `other` are contained within `self`.\n+            pub fn contains(&self, other: $BitFlags) -> bool {\n+                (self & other) == other\n+            }\n+\n+            /// Inserts the specified flags in-place.\n+            pub fn insert(&mut self, other: $BitFlags) {\n+                self.bits |= other.bits;\n+            }\n+\n+            /// Removes the specified flags in-place.\n+            pub fn remove(&mut self, other: $BitFlags) {\n+                self.bits &= !other.bits;\n+            }\n+        }\n+\n+        impl BitOr<$BitFlags, $BitFlags> for $BitFlags {\n+            /// Returns the union of the two sets of flags.\n+            #[inline]\n+            fn bitor(&self, other: &$BitFlags) -> $BitFlags {\n+                $BitFlags { bits: self.bits | other.bits }\n+            }\n+        }\n+\n+        impl BitAnd<$BitFlags, $BitFlags> for $BitFlags {\n+            /// Returns the intersection between the two sets of flags.\n+            #[inline]\n+            fn bitand(&self, other: &$BitFlags) -> $BitFlags {\n+                $BitFlags { bits: self.bits & other.bits }\n+            }\n+        }\n+\n+        impl Sub<$BitFlags, $BitFlags> for $BitFlags {\n+            /// Returns the set difference of the two sets of flags.\n+            #[inline]\n+            fn sub(&self, other: &$BitFlags) -> $BitFlags {\n+                $BitFlags { bits: self.bits & !other.bits }\n+            }\n+        }\n+    )\n+)\n+\n+#[cfg(test)]\n+mod tests {\n+    use ops::{BitOr, BitAnd, Sub};\n+\n+    bitflags!(Flags: u32 {\n+        FlagA       = 0x00000001,\n+        FlagB       = 0x00000010,\n+        FlagC       = 0x00000100,\n+        FlagABC     = FlagA.bits\n+                    | FlagB.bits\n+                    | FlagC.bits\n+    })\n+\n+    #[test]\n+    fn test_bits(){\n+        assert_eq!(Flags::empty().bits(), 0x00000000);\n+        assert_eq!(FlagA.bits(), 0x00000001);\n+        assert_eq!(FlagABC.bits(), 0x00000111);\n+    }\n+\n+    #[test]\n+    fn test_is_empty(){\n+        assert!(Flags::empty().is_empty());\n+        assert!(!FlagA.is_empty());\n+        assert!(!FlagABC.is_empty());\n+    }\n+\n+    #[test]\n+    fn test_two_empties_do_not_intersect() {\n+        let e1 = Flags::empty();\n+        let e2 = Flags::empty();\n+        assert!(!e1.intersects(e2));\n+    }\n+\n+    #[test]\n+    fn test_empty_does_not_intersect_with_full() {\n+        let e1 = Flags::empty();\n+        let e2 = FlagABC;\n+        assert!(!e1.intersects(e2));\n+    }\n+\n+    #[test]\n+    fn test_disjoint_intersects() {\n+        let e1 = FlagA;\n+        let e2 = FlagB;\n+        assert!(!e1.intersects(e2));\n+    }\n+\n+    #[test]\n+    fn test_overlapping_intersects() {\n+        let e1 = FlagA;\n+        let e2 = FlagA | FlagB;\n+        assert!(e1.intersects(e2));\n+    }\n+\n+    #[test]\n+    fn test_contains() {\n+        let e1 = FlagA;\n+        let e2 = FlagA | FlagB;\n+        assert!(!e1.contains(e2));\n+        assert!(e2.contains(e1));\n+        assert!(FlagABC.contains(e2));\n+    }\n+\n+    #[test]\n+    fn test_insert(){\n+        let mut e1 = FlagA;\n+        let e2 = FlagA | FlagB;\n+        e1.insert(e2);\n+        assert!(e1 == e2);\n+    }\n+\n+    #[test]\n+    fn test_remove(){\n+        let mut e1 = FlagA | FlagB;\n+        let e2 = FlagA | FlagC;\n+        e1.remove(e2);\n+        assert!(e1 == FlagB);\n+    }\n+\n+    #[test]\n+    fn test_operators() {\n+        let e1 = FlagA | FlagC;\n+        let e2 = FlagB | FlagC;\n+        assert!((e1 | e2) == FlagABC);   // union\n+        assert!((e1 & e2) == FlagC);     // intersection\n+        assert!((e1 - e2) == FlagA);     // set difference\n+    }\n+}"}, {"sha": "c34ebfdf7c20b4901d91e4950f703a91afe3c901", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3f9f37014c77cda1ae53bf0984190e877aa413a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f9f37014c77cda1ae53bf0984190e877aa413a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a3f9f37014c77cda1ae53bf0984190e877aa413a", "patch": "@@ -142,7 +142,10 @@ fn start(argc: int, argv: **u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, __test::main)\n }\n \n+/* Exported macros */\n+\n pub mod macros;\n+pub mod bitflags;\n \n mod rtdeps;\n "}]}