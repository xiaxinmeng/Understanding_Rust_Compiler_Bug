{"sha": "86bf3ce8591343bcc2442e95d6432f3b78e07cc5", "node_id": "C_kwDOAAsO6NoAKDg2YmYzY2U4NTkxMzQzYmNjMjQ0MmU5NWQ2NDMyZjNiNzhlMDdjYzU", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-10-09T15:08:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-09T15:08:38Z"}, "message": "Rollup merge of #75644 - c410-f3r:array, r=yaahc\n\nAdd 'core::array::from_fn' and 'core::array::try_from_fn'\n\nThese auxiliary methods fill uninitialized arrays in a safe way and are particularly useful for elements that don't implement `Default`.\n\n```rust\n// Foo doesn't implement Default\nstruct Foo(usize);\n\nlet _array = core::array::from_fn::<_, _, 2>(|idx| Foo(idx));\n```\n\nDifferent from `FromIterator`, it is guaranteed that the array will be fully filled and no error regarding uninitialized state will be throw. In certain scenarios, however, the creation of an **element** can fail and that is why the `try_from_fn` function is also provided.\n\n```rust\n#[derive(Debug, PartialEq)]\nenum SomeError {\n    Foo,\n}\n\nlet array = core::array::try_from_fn(|i| Ok::<_, SomeError>(i));\nassert_eq!(array, Ok([0, 1, 2, 3, 4]));\n\nlet another_array = core::array::try_from_fn(|_| Err(SomeError::Foo));\nassert_eq!(another_array, Err(SomeError::Foo));\n ```", "tree": {"sha": "597fe7e59099eae477085dd415540bfb5cbb4e63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/597fe7e59099eae477085dd415540bfb5cbb4e63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86bf3ce8591343bcc2442e95d6432f3b78e07cc5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhYbB2CRBK7hj4Ov3rIwAA72kIAHjbxV7ErW58oL2fuRNVY3/D\ncACmJwTgznkBd9FxUZjG2wtQn9YQ8Sr46cyQKvpdFAY7SKWij2GhOmuRJY5hyG4H\nqj5tKUcTv9hrsRsfJq125qW/A/+eiBCC+MGFb5Tt5H7itI5MNIYR3/bqhfU/yyG3\nIBrTRhLoIxhxhneNWYQ4wZpYs52Gkim5d19My6yJFEBohGQQfYUaRz8T9snBTew+\nPWePaSrOolTuaxJMVMnxwHZDTL4qYOBA+C+hsvyTvsgd4g7YjRKY+xysMcfJ4MGj\nQrMQBBNG0D4cBtEuQU/UXRRnpY/eAKVZIfN13JOThG0pSHnmKlSarYVT5c4kQRQ=\n=WfAS\n-----END PGP SIGNATURE-----\n", "payload": "tree 597fe7e59099eae477085dd415540bfb5cbb4e63\nparent bb918d0a5bf22211df0423f7474e4e4056978007\nparent 85c4a52807d6137505b0d1419cc800c210d79159\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1633792118 +0200\ncommitter GitHub <noreply@github.com> 1633792118 +0200\n\nRollup merge of #75644 - c410-f3r:array, r=yaahc\n\nAdd 'core::array::from_fn' and 'core::array::try_from_fn'\n\nThese auxiliary methods fill uninitialized arrays in a safe way and are particularly useful for elements that don't implement `Default`.\n\n```rust\n// Foo doesn't implement Default\nstruct Foo(usize);\n\nlet _array = core::array::from_fn::<_, _, 2>(|idx| Foo(idx));\n```\n\nDifferent from `FromIterator`, it is guaranteed that the array will be fully filled and no error regarding uninitialized state will be throw. In certain scenarios, however, the creation of an **element** can fail and that is why the `try_from_fn` function is also provided.\n\n```rust\n#[derive(Debug, PartialEq)]\nenum SomeError {\n    Foo,\n}\n\nlet array = core::array::try_from_fn(|i| Ok::<_, SomeError>(i));\nassert_eq!(array, Ok([0, 1, 2, 3, 4]));\n\nlet another_array = core::array::try_from_fn(|_| Err(SomeError::Foo));\nassert_eq!(another_array, Err(SomeError::Foo));\n ```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86bf3ce8591343bcc2442e95d6432f3b78e07cc5", "html_url": "https://github.com/rust-lang/rust/commit/86bf3ce8591343bcc2442e95d6432f3b78e07cc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86bf3ce8591343bcc2442e95d6432f3b78e07cc5/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb918d0a5bf22211df0423f7474e4e4056978007", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb918d0a5bf22211df0423f7474e4e4056978007", "html_url": "https://github.com/rust-lang/rust/commit/bb918d0a5bf22211df0423f7474e4e4056978007"}, {"sha": "85c4a52807d6137505b0d1419cc800c210d79159", "url": "https://api.github.com/repos/rust-lang/rust/commits/85c4a52807d6137505b0d1419cc800c210d79159", "html_url": "https://github.com/rust-lang/rust/commit/85c4a52807d6137505b0d1419cc800c210d79159"}], "stats": {"total": 205, "additions": 186, "deletions": 19}, "files": [{"sha": "8d5c0510404fb2d7743b8c547895acc5b5b1e2cd", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 103, "deletions": 17, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/86bf3ce8591343bcc2442e95d6432f3b78e07cc5/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86bf3ce8591343bcc2442e95d6432f3b78e07cc5/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=86bf3ce8591343bcc2442e95d6432f3b78e07cc5", "patch": "@@ -20,6 +20,69 @@ mod iter;\n #[stable(feature = \"array_value_iter\", since = \"1.51.0\")]\n pub use iter::IntoIter;\n \n+/// Creates an array `[T; N]` where each array element `T` is returned by the `cb` call.\n+///\n+/// # Arguments\n+///\n+/// * `cb`: Callback where the passed argument is the current array index.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// #![feature(array_from_fn)]\n+///\n+/// let array = core::array::from_fn(|i| i);\n+/// assert_eq!(array, [0, 1, 2, 3, 4]);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"array_from_fn\", issue = \"89379\")]\n+pub fn from_fn<F, T, const N: usize>(mut cb: F) -> [T; N]\n+where\n+    F: FnMut(usize) -> T,\n+{\n+    let mut idx = 0;\n+    [(); N].map(|_| {\n+        let res = cb(idx);\n+        idx += 1;\n+        res\n+    })\n+}\n+\n+/// Creates an array `[T; N]` where each fallible array element `T` is returned by the `cb` call.\n+/// Unlike `core::array::from_fn`, where the element creation can't fail, this version will return an error\n+/// if any element creation was unsuccessful.\n+///\n+/// # Arguments\n+///\n+/// * `cb`: Callback where the passed argument is the current array index.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// #![feature(array_from_fn)]\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// enum SomeError {\n+///     Foo,\n+/// }\n+///\n+/// let array = core::array::try_from_fn(|i| Ok::<_, SomeError>(i));\n+/// assert_eq!(array, Ok([0, 1, 2, 3, 4]));\n+///\n+/// let another_array = core::array::try_from_fn::<SomeError, _, (), 2>(|_| Err(SomeError::Foo));\n+/// assert_eq!(another_array, Err(SomeError::Foo));\n+/// ```\n+#[inline]\n+#[unstable(feature = \"array_from_fn\", issue = \"89379\")]\n+pub fn try_from_fn<E, F, T, const N: usize>(cb: F) -> Result<[T; N], E>\n+where\n+    F: FnMut(usize) -> Result<T, E>,\n+{\n+    // SAFETY: we know for certain that this iterator will yield exactly `N`\n+    // items.\n+    unsafe { collect_into_array_rslt_unchecked(&mut (0..N).map(cb)) }\n+}\n+\n /// Converts a reference to `T` into a reference to an array of length 1 (without copying).\n #[stable(feature = \"array_from_ref\", since = \"1.53.0\")]\n pub fn from_ref<T>(s: &T) -> &[T; 1] {\n@@ -448,13 +511,15 @@ impl<T, const N: usize> [T; N] {\n ///\n /// It is up to the caller to guarantee that `iter` yields at least `N` items.\n /// Violating this condition causes undefined behavior.\n-unsafe fn collect_into_array_unchecked<I, const N: usize>(iter: &mut I) -> [I::Item; N]\n+unsafe fn collect_into_array_rslt_unchecked<E, I, T, const N: usize>(\n+    iter: &mut I,\n+) -> Result<[T; N], E>\n where\n     // Note: `TrustedLen` here is somewhat of an experiment. This is just an\n     // internal function, so feel free to remove if this bound turns out to be a\n     // bad idea. In that case, remember to also remove the lower bound\n     // `debug_assert!` below!\n-    I: Iterator + TrustedLen,\n+    I: Iterator<Item = Result<T, E>> + TrustedLen,\n {\n     debug_assert!(N <= iter.size_hint().1.unwrap_or(usize::MAX));\n     debug_assert!(N <= iter.size_hint().0);\n@@ -463,6 +528,21 @@ where\n     unsafe { collect_into_array(iter).unwrap_unchecked() }\n }\n \n+// Infallible version of `collect_into_array_rslt_unchecked`.\n+unsafe fn collect_into_array_unchecked<I, const N: usize>(iter: &mut I) -> [I::Item; N]\n+where\n+    I: Iterator + TrustedLen,\n+{\n+    let mut map = iter.map(Ok::<_, Infallible>);\n+\n+    // SAFETY: The same safety considerations w.r.t. the iterator length\n+    // apply for `collect_into_array_rslt_unchecked` as for\n+    // `collect_into_array_unchecked`\n+    match unsafe { collect_into_array_rslt_unchecked(&mut map) } {\n+        Ok(array) => array,\n+    }\n+}\n+\n /// Pulls `N` items from `iter` and returns them as an array. If the iterator\n /// yields fewer than `N` items, `None` is returned and all already yielded\n /// items are dropped.\n@@ -473,43 +553,49 @@ where\n ///\n /// If `iter.next()` panicks, all items already yielded by the iterator are\n /// dropped.\n-fn collect_into_array<I, const N: usize>(iter: &mut I) -> Option<[I::Item; N]>\n+fn collect_into_array<E, I, T, const N: usize>(iter: &mut I) -> Option<Result<[T; N], E>>\n where\n-    I: Iterator,\n+    I: Iterator<Item = Result<T, E>>,\n {\n     if N == 0 {\n         // SAFETY: An empty array is always inhabited and has no validity invariants.\n-        return unsafe { Some(mem::zeroed()) };\n+        return unsafe { Some(Ok(mem::zeroed())) };\n     }\n \n-    struct Guard<T, const N: usize> {\n-        ptr: *mut T,\n+    struct Guard<'a, T, const N: usize> {\n+        array_mut: &'a mut [MaybeUninit<T>; N],\n         initialized: usize,\n     }\n \n-    impl<T, const N: usize> Drop for Guard<T, N> {\n+    impl<T, const N: usize> Drop for Guard<'_, T, N> {\n         fn drop(&mut self) {\n             debug_assert!(self.initialized <= N);\n \n-            let initialized_part = crate::ptr::slice_from_raw_parts_mut(self.ptr, self.initialized);\n-\n-            // SAFETY: this raw slice will contain only initialized objects.\n+            // SAFETY: this slice will contain only initialized objects.\n             unsafe {\n-                crate::ptr::drop_in_place(initialized_part);\n+                crate::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(\n+                    &mut self.array_mut.get_unchecked_mut(..self.initialized),\n+                ));\n             }\n         }\n     }\n \n     let mut array = MaybeUninit::uninit_array::<N>();\n-    let mut guard: Guard<_, N> =\n-        Guard { ptr: MaybeUninit::slice_as_mut_ptr(&mut array), initialized: 0 };\n+    let mut guard = Guard { array_mut: &mut array, initialized: 0 };\n+\n+    while let Some(item_rslt) = iter.next() {\n+        let item = match item_rslt {\n+            Err(err) => {\n+                return Some(Err(err));\n+            }\n+            Ok(elem) => elem,\n+        };\n \n-    while let Some(item) = iter.next() {\n         // SAFETY: `guard.initialized` starts at 0, is increased by one in the\n         // loop and the loop is aborted once it reaches N (which is\n         // `array.len()`).\n         unsafe {\n-            array.get_unchecked_mut(guard.initialized).write(item);\n+            guard.array_mut.get_unchecked_mut(guard.initialized).write(item);\n         }\n         guard.initialized += 1;\n \n@@ -520,7 +606,7 @@ where\n             // SAFETY: the condition above asserts that all elements are\n             // initialized.\n             let out = unsafe { MaybeUninit::array_assume_init(array) };\n-            return Some(out);\n+            return Some(Ok(out));\n         }\n     }\n "}, {"sha": "b3af1328c90d45869d0efb236f97e77e6a53df53", "filename": "library/core/tests/array.rs", "status": "modified", "additions": 82, "deletions": 2, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/86bf3ce8591343bcc2442e95d6432f3b78e07cc5/library%2Fcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86bf3ce8591343bcc2442e95d6432f3b78e07cc5/library%2Fcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Farray.rs?ref=86bf3ce8591343bcc2442e95d6432f3b78e07cc5", "patch": "@@ -1,5 +1,6 @@\n use core::array;\n use core::convert::TryFrom;\n+use core::sync::atomic::{AtomicUsize, Ordering};\n \n #[test]\n fn array_from_ref() {\n@@ -303,8 +304,6 @@ fn array_map() {\n #[test]\n #[should_panic(expected = \"test succeeded\")]\n fn array_map_drop_safety() {\n-    use core::sync::atomic::AtomicUsize;\n-    use core::sync::atomic::Ordering;\n     static DROPPED: AtomicUsize = AtomicUsize::new(0);\n     struct DropCounter;\n     impl Drop for DropCounter {\n@@ -356,3 +355,84 @@ fn cell_allows_array_cycle() {\n     b3.a[0].set(Some(&b1));\n     b3.a[1].set(Some(&b2));\n }\n+\n+#[test]\n+fn array_from_fn() {\n+    let array = core::array::from_fn(|idx| idx);\n+    assert_eq!(array, [0, 1, 2, 3, 4]);\n+}\n+\n+#[test]\n+fn array_try_from_fn() {\n+    #[derive(Debug, PartialEq)]\n+    enum SomeError {\n+        Foo,\n+    }\n+\n+    let array = core::array::try_from_fn(|i| Ok::<_, SomeError>(i));\n+    assert_eq!(array, Ok([0, 1, 2, 3, 4]));\n+\n+    let another_array = core::array::try_from_fn::<SomeError, _, (), 2>(|_| Err(SomeError::Foo));\n+    assert_eq!(another_array, Err(SomeError::Foo));\n+}\n+\n+#[cfg(not(panic = \"abort\"))]\n+#[test]\n+fn array_try_from_fn_drops_inserted_elements_on_err() {\n+    static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n+\n+    struct CountDrop;\n+    impl Drop for CountDrop {\n+        fn drop(&mut self) {\n+            DROP_COUNTER.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    let _ = catch_unwind_silent(move || {\n+        let _: Result<[CountDrop; 4], ()> = core::array::try_from_fn(|idx| {\n+            if idx == 2 {\n+                return Err(());\n+            }\n+            Ok(CountDrop)\n+        });\n+    });\n+\n+    assert_eq!(DROP_COUNTER.load(Ordering::SeqCst), 2);\n+}\n+\n+#[cfg(not(panic = \"abort\"))]\n+#[test]\n+fn array_try_from_fn_drops_inserted_elements_on_panic() {\n+    static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n+\n+    struct CountDrop;\n+    impl Drop for CountDrop {\n+        fn drop(&mut self) {\n+            DROP_COUNTER.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    let _ = catch_unwind_silent(move || {\n+        let _: Result<[CountDrop; 4], ()> = core::array::try_from_fn(|idx| {\n+            if idx == 2 {\n+                panic!(\"peek a boo\");\n+            }\n+            Ok(CountDrop)\n+        });\n+    });\n+\n+    assert_eq!(DROP_COUNTER.load(Ordering::SeqCst), 2);\n+}\n+\n+#[cfg(not(panic = \"abort\"))]\n+// https://stackoverflow.com/a/59211505\n+fn catch_unwind_silent<F, R>(f: F) -> std::thread::Result<R>\n+where\n+    F: FnOnce() -> R + core::panic::UnwindSafe,\n+{\n+    let prev_hook = std::panic::take_hook();\n+    std::panic::set_hook(Box::new(|_| {}));\n+    let result = std::panic::catch_unwind(f);\n+    std::panic::set_hook(prev_hook);\n+    result\n+}"}, {"sha": "3608853dce4e05e41679195add2e47c8772ef9c4", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86bf3ce8591343bcc2442e95d6432f3b78e07cc5/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86bf3ce8591343bcc2442e95d6432f3b78e07cc5/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=86bf3ce8591343bcc2442e95d6432f3b78e07cc5", "patch": "@@ -26,6 +26,7 @@\n #![feature(extern_types)]\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n+#![feature(array_from_fn)]\n #![feature(hashmap_internals)]\n #![feature(try_find)]\n #![feature(is_sorted)]"}]}