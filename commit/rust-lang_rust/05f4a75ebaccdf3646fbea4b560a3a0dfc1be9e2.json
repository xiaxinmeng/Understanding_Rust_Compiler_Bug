{"sha": "05f4a75ebaccdf3646fbea4b560a3a0dfc1be9e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1ZjRhNzVlYmFjY2RmMzY0NmZiZWE0YjU2MGEzYTBkZmMxYmU5ZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-04T17:11:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-04T17:11:02Z"}, "message": "Auto merge of #38414 - estebank:doc-dissambiguate, r=steveklabnik\n\nRustdoc: disambiguate Implementors when the type name is not unique\n\nPresentation [goes from](https://doc.rust-lang.org/stable/std/iter/trait.ExactSizeIterator.html#implementors):\n\n<img width=\"492\" alt=\"\" src=\"https://cloud.githubusercontent.com/assets/1606434/21276752/b2b50474-c387-11e6-96e1-9766851da269.png\">\n\nto:\n\n<img width=\"787\" alt=\"\" src=\"https://cloud.githubusercontent.com/assets/1606434/21276763/bb37f6b0-c387-11e6-8596-9163cb254674.png\">\n\non cases where there're multiple implementors with the same name.\n\nFixes #37762.", "tree": {"sha": "70ea913aaea837bf24a663b4c47e59f34287cc8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70ea913aaea837bf24a663b4c47e59f34287cc8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05f4a75ebaccdf3646fbea4b560a3a0dfc1be9e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05f4a75ebaccdf3646fbea4b560a3a0dfc1be9e2", "html_url": "https://github.com/rust-lang/rust/commit/05f4a75ebaccdf3646fbea4b560a3a0dfc1be9e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05f4a75ebaccdf3646fbea4b560a3a0dfc1be9e2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d40d01bd0e7d9d20bb3454a3d0870f00b805a01c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d40d01bd0e7d9d20bb3454a3d0870f00b805a01c", "html_url": "https://github.com/rust-lang/rust/commit/d40d01bd0e7d9d20bb3454a3d0870f00b805a01c"}, {"sha": "346a44211087a36de91877545ea28e9af501db6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/346a44211087a36de91877545ea28e9af501db6c", "html_url": "https://github.com/rust-lang/rust/commit/346a44211087a36de91877545ea28e9af501db6c"}], "stats": {"total": 371, "additions": 203, "deletions": 168}, "files": [{"sha": "faf39db572380feca0554b5d49bfb9c00a2829ed", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05f4a75ebaccdf3646fbea4b560a3a0dfc1be9e2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f4a75ebaccdf3646fbea4b560a3a0dfc1be9e2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=05f4a75ebaccdf3646fbea4b560a3a0dfc1be9e2", "patch": "@@ -2219,8 +2219,8 @@ impl Path {\n         }\n     }\n \n-    pub fn last_name(&self) -> String {\n-        self.segments.last().unwrap().name.clone()\n+    pub fn last_name(&self) -> &str {\n+        self.segments.last().unwrap().name.as_str()\n     }\n }\n "}, {"sha": "716ad05401d03036a459da76f97ccdcc89ab4f3b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 183, "deletions": 164, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/05f4a75ebaccdf3646fbea4b560a3a0dfc1be9e2/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f4a75ebaccdf3646fbea4b560a3a0dfc1be9e2/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=05f4a75ebaccdf3646fbea4b560a3a0dfc1be9e2", "patch": "@@ -433,7 +433,7 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n-                 print_all: bool) -> fmt::Result {\n+                 print_all: bool, use_absolute: bool) -> fmt::Result {\n     let last = path.segments.last().unwrap();\n     let rel_root = match &*path.segments[0].name {\n         \"self\" => Some(\"./\".to_string()),\n@@ -467,7 +467,17 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n     if w.alternate() {\n         write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.params)?;\n     } else {\n-        write!(w, \"{}{}\", HRef::new(did, &last.name), last.params)?;\n+        let path = if use_absolute {\n+            match href(did) {\n+                Some((_, _, fqp)) => format!(\"{}::{}\",\n+                                             fqp[..fqp.len()-1].join(\"::\"),\n+                                             HRef::new(did, fqp.last().unwrap())),\n+                None => format!(\"{}\", HRef::new(did, &last.name)),\n+            }\n+        } else {\n+            format!(\"{}\", HRef::new(did, &last.name))\n+        };\n+        write!(w, \"{}{}\", path, last.params)?;\n     }\n     Ok(())\n }\n@@ -551,194 +561,201 @@ impl<'a> fmt::Display for HRef<'a> {\n     }\n }\n \n-impl fmt::Display for clean::Type {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            clean::Generic(ref name) => {\n-                f.write_str(name)\n-            }\n-            clean::ResolvedPath{ did, ref typarams, ref path, is_generic } => {\n-                // Paths like T::Output and Self::Output should be rendered with all segments\n-                resolved_path(f, did, path, is_generic)?;\n-                tybounds(f, typarams)\n+fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt::Result {\n+    match *t {\n+        clean::Generic(ref name) => {\n+            f.write_str(name)\n+        }\n+        clean::ResolvedPath{ did, ref typarams, ref path, is_generic } => {\n+            // Paths like T::Output and Self::Output should be rendered with all segments\n+            resolved_path(f, did, path, is_generic, use_absolute)?;\n+            tybounds(f, typarams)\n+        }\n+        clean::Infer => write!(f, \"_\"),\n+        clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n+        clean::BareFunction(ref decl) => {\n+            if f.alternate() {\n+                write!(f, \"{}{}fn{:#}{:#}\",\n+                       UnsafetySpace(decl.unsafety),\n+                       AbiSpace(decl.abi),\n+                       decl.generics,\n+                       decl.decl)\n+            } else {\n+                write!(f, \"{}{}fn{}{}\",\n+                       UnsafetySpace(decl.unsafety),\n+                       AbiSpace(decl.abi),\n+                       decl.generics,\n+                       decl.decl)\n             }\n-            clean::Infer => write!(f, \"_\"),\n-            clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n-            clean::BareFunction(ref decl) => {\n-                if f.alternate() {\n-                    write!(f, \"{}{}fn{:#}{:#}\",\n-                           UnsafetySpace(decl.unsafety),\n-                           AbiSpace(decl.abi),\n-                           decl.generics,\n-                           decl.decl)\n-                } else {\n-                    write!(f, \"{}{}fn{}{}\",\n-                           UnsafetySpace(decl.unsafety),\n-                           AbiSpace(decl.abi),\n-                           decl.generics,\n-                           decl.decl)\n+        }\n+        clean::Tuple(ref typs) => {\n+            match &typs[..] {\n+                &[] => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n+                &[ref one] => {\n+                    primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n+                    //carry f.alternate() into this display w/o branching manually\n+                    fmt::Display::fmt(one, f)?;\n+                    primitive_link(f, PrimitiveType::Tuple, \",)\")\n                 }\n-            }\n-            clean::Tuple(ref typs) => {\n-                match &typs[..] {\n-                    &[] => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n-                    &[ref one] => {\n-                        primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                        //carry f.alternate() into this display w/o branching manually\n-                        fmt::Display::fmt(one, f)?;\n-                        primitive_link(f, PrimitiveType::Tuple, \",)\")\n-                    }\n-                    many => {\n-                        primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                        fmt::Display::fmt(&CommaSep(&many), f)?;\n-                        primitive_link(f, PrimitiveType::Tuple, \")\")\n-                    }\n+                many => {\n+                    primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n+                    fmt::Display::fmt(&CommaSep(&many), f)?;\n+                    primitive_link(f, PrimitiveType::Tuple, \")\")\n                 }\n             }\n-            clean::Vector(ref t) => {\n-                primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n-                fmt::Display::fmt(t, f)?;\n-                primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n-            }\n-            clean::FixedVector(ref t, ref s) => {\n-                primitive_link(f, PrimitiveType::Array, \"[\")?;\n-                fmt::Display::fmt(t, f)?;\n-                if f.alternate() {\n-                    primitive_link(f, PrimitiveType::Array,\n-                                   &format!(\"; {}]\", s))\n-                } else {\n-                    primitive_link(f, PrimitiveType::Array,\n-                                   &format!(\"; {}]\", Escape(s)))\n-                }\n+        }\n+        clean::Vector(ref t) => {\n+            primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n+            fmt::Display::fmt(t, f)?;\n+            primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n+        }\n+        clean::FixedVector(ref t, ref s) => {\n+            primitive_link(f, PrimitiveType::Array, \"[\")?;\n+            fmt::Display::fmt(t, f)?;\n+            if f.alternate() {\n+                primitive_link(f, PrimitiveType::Array,\n+                               &format!(\"; {}]\", s))\n+            } else {\n+                primitive_link(f, PrimitiveType::Array,\n+                               &format!(\"; {}]\", Escape(s)))\n             }\n-            clean::Never => f.write_str(\"!\"),\n-            clean::RawPointer(m, ref t) => {\n-                match **t {\n-                    clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n-                        if f.alternate() {\n-                            primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                           &format!(\"*{}{:#}\", RawMutableSpace(m), t))\n-                        } else {\n-                            primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                           &format!(\"*{}{}\", RawMutableSpace(m), t))\n-                        }\n-                    }\n-                    _ => {\n+        }\n+        clean::Never => f.write_str(\"!\"),\n+        clean::RawPointer(m, ref t) => {\n+            match **t {\n+                clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n+                    if f.alternate() {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{}\", RawMutableSpace(m)))?;\n-                        fmt::Display::fmt(t, f)\n+                                       &format!(\"*{}{:#}\", RawMutableSpace(m), t))\n+                    } else {\n+                        primitive_link(f, clean::PrimitiveType::RawPointer,\n+                                       &format!(\"*{}{}\", RawMutableSpace(m), t))\n                     }\n                 }\n+                _ => {\n+                    primitive_link(f, clean::PrimitiveType::RawPointer,\n+                                   &format!(\"*{}\", RawMutableSpace(m)))?;\n+                    fmt::Display::fmt(t, f)\n+                }\n             }\n-            clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n-                let lt = match *l {\n-                    Some(ref l) => format!(\"{} \", *l),\n-                    _ => \"\".to_string(),\n-                };\n-                let m = MutableSpace(mutability);\n-                match **ty {\n-                    clean::Vector(ref bt) => { // BorrowedRef{ ... Vector(T) } is &[T]\n-                        match **bt {\n-                            clean::Generic(_) =>\n-                                if f.alternate() {\n-                                    primitive_link(f, PrimitiveType::Slice,\n-                                        &format!(\"&{}{}[{:#}]\", lt, m, **bt))\n-                                } else {\n-                                    primitive_link(f, PrimitiveType::Slice,\n-                                        &format!(\"&amp;{}{}[{}]\", lt, m, **bt))\n-                                },\n-                            _ => {\n-                                if f.alternate() {\n-                                    primitive_link(f, PrimitiveType::Slice,\n-                                                   &format!(\"&{}{}[\", lt, m))?;\n-                                    write!(f, \"{:#}\", **bt)?;\n-                                } else {\n-                                    primitive_link(f, PrimitiveType::Slice,\n-                                                   &format!(\"&amp;{}{}[\", lt, m))?;\n-                                    write!(f, \"{}\", **bt)?;\n-                                }\n-                                primitive_link(f, PrimitiveType::Slice, \"]\")\n+        }\n+        clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n+            let lt = match *l {\n+                Some(ref l) => format!(\"{} \", *l),\n+                _ => \"\".to_string(),\n+            };\n+            let m = MutableSpace(mutability);\n+            match **ty {\n+                clean::Vector(ref bt) => { // BorrowedRef{ ... Vector(T) } is &[T]\n+                    match **bt {\n+                        clean::Generic(_) =>\n+                            if f.alternate() {\n+                                primitive_link(f, PrimitiveType::Slice,\n+                                    &format!(\"&{}{}[{:#}]\", lt, m, **bt))\n+                            } else {\n+                                primitive_link(f, PrimitiveType::Slice,\n+                                    &format!(\"&amp;{}{}[{}]\", lt, m, **bt))\n+                            },\n+                        _ => {\n+                            if f.alternate() {\n+                                primitive_link(f, PrimitiveType::Slice,\n+                                               &format!(\"&{}{}[\", lt, m))?;\n+                                write!(f, \"{:#}\", **bt)?;\n+                            } else {\n+                                primitive_link(f, PrimitiveType::Slice,\n+                                               &format!(\"&amp;{}{}[\", lt, m))?;\n+                                write!(f, \"{}\", **bt)?;\n                             }\n-                        }\n-                    }\n-                    _ => {\n-                        if f.alternate() {\n-                            write!(f, \"&{}{}{:#}\", lt, m, **ty)\n-                        } else {\n-                            write!(f, \"&amp;{}{}{}\", lt, m, **ty)\n+                            primitive_link(f, PrimitiveType::Slice, \"]\")\n                         }\n                     }\n                 }\n-            }\n-            clean::PolyTraitRef(ref bounds) => {\n-                for (i, bound) in bounds.iter().enumerate() {\n-                    if i != 0 {\n-                        write!(f, \" + \")?;\n-                    }\n+                _ => {\n                     if f.alternate() {\n-                        write!(f, \"{:#}\", *bound)?;\n+                        write!(f, \"&{}{}{:#}\", lt, m, **ty)\n                     } else {\n-                        write!(f, \"{}\", *bound)?;\n+                        write!(f, \"&amp;{}{}{}\", lt, m, **ty)\n                     }\n                 }\n-                Ok(())\n             }\n-            clean::ImplTrait(ref bounds) => {\n-                write!(f, \"impl \")?;\n-                for (i, bound) in bounds.iter().enumerate() {\n-                    if i != 0 {\n-                        write!(f, \" + \")?;\n-                    }\n-                    if f.alternate() {\n-                        write!(f, \"{:#}\", *bound)?;\n-                    } else {\n-                        write!(f, \"{}\", *bound)?;\n-                    }\n+        }\n+        clean::PolyTraitRef(ref bounds) => {\n+            for (i, bound) in bounds.iter().enumerate() {\n+                if i != 0 {\n+                    write!(f, \" + \")?;\n                 }\n-                Ok(())\n-            }\n-            // It's pretty unsightly to look at `<A as B>::C` in output, and\n-            // we've got hyperlinking on our side, so try to avoid longer\n-            // notation as much as possible by making `C` a hyperlink to trait\n-            // `B` to disambiguate.\n-            //\n-            // FIXME: this is still a lossy conversion and there should probably\n-            //        be a better way of representing this in general? Most of\n-            //        the ugliness comes from inlining across crates where\n-            //        everything comes in as a fully resolved QPath (hard to\n-            //        look at).\n-            clean::QPath {\n-                ref name,\n-                ref self_type,\n-                trait_: box clean::ResolvedPath { did, ref typarams, .. },\n-            } => {\n                 if f.alternate() {\n-                    write!(f, \"{:#}::\", self_type)?;\n+                    write!(f, \"{:#}\", *bound)?;\n                 } else {\n-                    write!(f, \"{}::\", self_type)?;\n+                    write!(f, \"{}\", *bound)?;\n                 }\n-                let path = clean::Path::singleton(name.clone());\n-                resolved_path(f, did, &path, false)?;\n-\n-                // FIXME: `typarams` are not rendered, and this seems bad?\n-                drop(typarams);\n-                Ok(())\n             }\n-            clean::QPath { ref name, ref self_type, ref trait_ } => {\n+            Ok(())\n+        }\n+        clean::ImplTrait(ref bounds) => {\n+            write!(f, \"impl \")?;\n+            for (i, bound) in bounds.iter().enumerate() {\n+                if i != 0 {\n+                    write!(f, \" + \")?;\n+                }\n                 if f.alternate() {\n-                    write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+                    write!(f, \"{:#}\", *bound)?;\n                 } else {\n-                    write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n+                    write!(f, \"{}\", *bound)?;\n                 }\n             }\n-            clean::Unique(..) => {\n-                panic!(\"should have been cleaned\")\n+            Ok(())\n+        }\n+        // It's pretty unsightly to look at `<A as B>::C` in output, and\n+        // we've got hyperlinking on our side, so try to avoid longer\n+        // notation as much as possible by making `C` a hyperlink to trait\n+        // `B` to disambiguate.\n+        //\n+        // FIXME: this is still a lossy conversion and there should probably\n+        //        be a better way of representing this in general? Most of\n+        //        the ugliness comes from inlining across crates where\n+        //        everything comes in as a fully resolved QPath (hard to\n+        //        look at).\n+        clean::QPath {\n+            ref name,\n+            ref self_type,\n+            trait_: box clean::ResolvedPath { did, ref typarams, .. },\n+        } => {\n+            if f.alternate() {\n+                write!(f, \"{:#}::\", self_type)?;\n+            } else {\n+                write!(f, \"{}::\", self_type)?;\n+            }\n+            let path = clean::Path::singleton(name.clone());\n+            resolved_path(f, did, &path, true, use_absolute)?;\n+\n+            // FIXME: `typarams` are not rendered, and this seems bad?\n+            drop(typarams);\n+            Ok(())\n+        }\n+        clean::QPath { ref name, ref self_type, ref trait_ } => {\n+            if f.alternate() {\n+                write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+            } else {\n+                write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n             }\n         }\n+        clean::Unique(..) => {\n+            panic!(\"should have been cleaned\")\n+        }\n+    }\n+}\n+\n+impl fmt::Display for clean::Type {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt_type(self, f, false)\n     }\n }\n \n-fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::Result {\n+fn fmt_impl(i: &clean::Impl,\n+            f: &mut fmt::Formatter,\n+            link_trait: bool,\n+            use_absolute: bool) -> fmt::Result {\n     let mut plain = String::new();\n \n     if f.alternate() {\n@@ -759,7 +776,7 @@ fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::R\n             plain.push_str(&format!(\"{:#}\", ty));\n         } else {\n             match *ty {\n-                clean::ResolvedPath{ typarams: None, ref path, is_generic: false, .. } => {\n+                clean::ResolvedPath { typarams: None, ref path, is_generic: false, .. } => {\n                     let last = path.segments.last().unwrap();\n                     fmt::Display::fmt(&last.name, f)?;\n                     fmt::Display::fmt(&last.params, f)?;\n@@ -772,7 +789,7 @@ fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::R\n         plain.push_str(\" for \");\n     }\n \n-    fmt::Display::fmt(&i.for_, f)?;\n+    fmt_type(&i.for_, f, use_absolute)?;\n     plain.push_str(&format!(\"{:#}\", i.for_));\n \n     fmt::Display::fmt(&WhereClause(&i.generics, plain.len() + 1), f)?;\n@@ -781,13 +798,15 @@ fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::R\n \n impl fmt::Display for clean::Impl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt_impl(self, f, true)\n+        fmt_impl(self, f, true, false)\n     }\n }\n \n // The difference from above is that trait is not hyperlinked.\n-pub fn fmt_impl_for_trait_page(i: &clean::Impl, f: &mut fmt::Formatter) -> fmt::Result {\n-    fmt_impl(i, f, false)\n+pub fn fmt_impl_for_trait_page(i: &clean::Impl,\n+                               f: &mut fmt::Formatter,\n+                               use_absolute: bool) -> fmt::Result {\n+    fmt_impl(i, f, false, use_absolute)\n }\n \n impl fmt::Display for clean::Arguments {\n@@ -978,7 +997,7 @@ impl fmt::Display for clean::Import {\n impl fmt::Display for clean::ImportSource {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.did {\n-            Some(did) => resolved_path(f, did, &self.path, true),\n+            Some(did) => resolved_path(f, did, &self.path, true, false),\n             _ => {\n                 for (i, seg) in self.path.segments.iter().enumerate() {\n                     if i > 0 {"}, {"sha": "9ea4bc436bfb83b08b4579bb209459cc8cdf531d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/05f4a75ebaccdf3646fbea4b560a3a0dfc1be9e2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f4a75ebaccdf3646fbea4b560a3a0dfc1be9e2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=05f4a75ebaccdf3646fbea4b560a3a0dfc1be9e2", "patch": "@@ -2122,9 +2122,25 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         <ul class='item-list' id='implementors-list'>\n     \")?;\n     if let Some(implementors) = cache.implementors.get(&it.def_id) {\n-        for i in implementors {\n+        let mut implementor_count: FxHashMap<&str, usize> = FxHashMap();\n+        for implementor in implementors {\n+            if let clean::Type::ResolvedPath {ref path, ..} = implementor.impl_.for_ {\n+                *implementor_count.entry(path.last_name()).or_insert(0) += 1;\n+            }\n+        }\n+\n+        for implementor in implementors {\n             write!(w, \"<li><code>\")?;\n-            fmt_impl_for_trait_page(&i.impl_, w)?;\n+            // If there's already another implementor that has the same abbridged name, use the\n+            // full path, for example in `std::iter::ExactSizeIterator`\n+            let use_absolute = if let clean::Type::ResolvedPath {\n+                ref path, ..\n+            } = implementor.impl_.for_ {\n+                implementor_count[path.last_name()] > 1\n+            } else {\n+                false\n+            };\n+            fmt_impl_for_trait_page(&implementor.impl_, w, use_absolute)?;\n             writeln!(w, \"</code></li>\")?;\n         }\n     }"}]}