{"sha": "cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNjNkNGM2MWJiODNmY2JjZWY1Y2NmZmZjZDliMjZiMWJmMmQyMGE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-06T06:01:01Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-07T03:00:07Z"}, "message": "doc: Turn off special features for rustdoc tests\n\nThese were only used for the markdown tests, and there's no reason they should\nbe distinct from the other tests.", "tree": {"sha": "8794914b76f301a24e8a9f8fc603df7ca8c1b7d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8794914b76f301a24e8a9f8fc603df7ca8c1b7d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a", "html_url": "https://github.com/rust-lang/rust/commit/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59157631061744947df9a7751ac55fe2304e67ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/59157631061744947df9a7751ac55fe2304e67ad", "html_url": "https://github.com/rust-lang/rust/commit/59157631061744947df9a7751ac55fe2304e67ad"}], "stats": {"total": 67, "additions": 39, "deletions": 28}, "files": [{"sha": "45745c7b7bc7a696f31dd13711b87db1622596e6", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a", "patch": "@@ -11,7 +11,7 @@ which both pattern-match on their input and both return early in one case,\n doing nothing otherwise:\n \n ~~~~\n-# enum T { SpecialA(uint), SpecialB(uint) };\n+# enum T { SpecialA(uint), SpecialB(uint) }\n # fn f() -> uint {\n # let input_1 = SpecialA(0);\n # let input_2 = SpecialA(0);\n@@ -37,7 +37,8 @@ lightweight custom syntax extensions, themselves defined using the\n the pattern in the above code:\n \n ~~~~\n-# enum T { SpecialA(uint), SpecialB(uint) };\n+# #![feature(macro_rules)]\n+# enum T { SpecialA(uint), SpecialB(uint) }\n # fn f() -> uint {\n # let input_1 = SpecialA(0);\n # let input_2 = SpecialA(0);\n@@ -55,6 +56,7 @@ early_return!(input_1 SpecialA);\n early_return!(input_2 SpecialB);\n # return 0;\n # }\n+# fn main() {}\n ~~~~\n \n Macros are defined in pattern-matching style: in the above example, the text\n@@ -155,7 +157,8 @@ separator token (a comma-separated list could be written `$(...),*`), and `+`\n instead of `*` to mean \"at least one\".\n \n ~~~~\n-# enum T { SpecialA(uint),SpecialB(uint),SpecialC(uint),SpecialD(uint)};\n+# #![feature(macro_rules)]\n+# enum T { SpecialA(uint),SpecialB(uint),SpecialC(uint),SpecialD(uint)}\n # fn f() -> uint {\n # let input_1 = SpecialA(0);\n # let input_2 = SpecialA(0);\n@@ -175,6 +178,7 @@ early_return!(input_1, [SpecialA|SpecialC|SpecialD]);\n early_return!(input_2, [SpecialB]);\n # return 0;\n # }\n+# fn main() {}\n ~~~~\n \n ### Transcription\n@@ -215,9 +219,10 @@ solves the problem.\n Now consider code like the following:\n \n ~~~~\n-# enum T1 { Good1(T2, uint), Bad1};\n+# #![feature(macro_rules)]\n+# enum T1 { Good1(T2, uint), Bad1}\n # struct T2 { body: T3 }\n-# enum T3 { Good2(uint), Bad2};\n+# enum T3 { Good2(uint), Bad2}\n # fn f(x: T1) -> uint {\n match x {\n     Good1(g1, val) => {\n@@ -232,6 +237,7 @@ match x {\n     _ => return 0 // default value\n }\n # }\n+# fn main() {}\n ~~~~\n \n All the complicated stuff is deeply indented, and the error-handling code is\n@@ -240,6 +246,7 @@ a match, but with a syntax that suits the problem better. The following macro\n can solve the problem:\n \n ~~~~\n+# #![feature(macro_rules)]\n macro_rules! biased_match (\n     // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n     ( ($e:expr) ~ ($p:pat) else $err:stmt ;\n@@ -261,9 +268,9 @@ macro_rules! biased_match (\n     )\n )\n \n-# enum T1 { Good1(T2, uint), Bad1};\n+# enum T1 { Good1(T2, uint), Bad1}\n # struct T2 { body: T3 }\n-# enum T3 { Good2(uint), Bad2};\n+# enum T3 { Good2(uint), Bad2}\n # fn f(x: T1) -> uint {\n biased_match!((x)       ~ (Good1(g1, val)) else { return 0 };\n               binds g1, val )\n@@ -273,13 +280,16 @@ biased_match!((g1.body) ~ (Good2(result) )\n // complicated stuff goes here\n return result + val;\n # }\n+# fn main() {}\n ~~~~\n \n This solves the indentation problem. But if we have a lot of chained matches\n like this, we might prefer to write a single macro invocation. The input\n pattern we want is clear:\n \n ~~~~\n+# #![feature(macro_rules)]\n+# fn main() {}\n # macro_rules! b(\n     ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n       binds $( $bind_res:ident ),*\n@@ -301,14 +311,18 @@ process the semicolon-terminated lines, one-by-one. So, we want the following\n input patterns:\n \n ~~~~\n+# #![feature(macro_rules)]\n # macro_rules! b(\n     ( binds $( $bind_res:ident ),* )\n # => (0))\n+# fn main() {}\n ~~~~\n \n ...and:\n \n ~~~~\n+# #![feature(macro_rules)]\n+# fn main() {}\n # macro_rules! b(\n     (    ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n       $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n@@ -322,6 +336,8 @@ The resulting macro looks like this. Note that the separation into\n piece of syntax (the `let`) which we only want to transcribe once.\n \n ~~~~\n+# #![feature(macro_rules)]\n+# fn main() {\n \n macro_rules! biased_match_rec (\n     // Handle the first layer\n@@ -365,9 +381,9 @@ macro_rules! biased_match (\n )\n \n \n-# enum T1 { Good1(T2, uint), Bad1};\n+# enum T1 { Good1(T2, uint), Bad1}\n # struct T2 { body: T3 }\n-# enum T3 { Good2(uint), Bad2};\n+# enum T3 { Good2(uint), Bad2}\n # fn f(x: T1) -> uint {\n biased_match!(\n     (x)       ~ (Good1(g1, val)) else { return 0 };\n@@ -376,6 +392,7 @@ biased_match!(\n // complicated stuff goes here\n return result + val;\n # }\n+# }\n ~~~~\n \n This technique applies to many cases where transcribing a result all at once is not possible."}, {"sha": "1431c8a5c9ae45be0491eefc5bd1436341576424", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a", "patch": "@@ -523,6 +523,7 @@ vectors provided from C, using idiomatic Rust practices.\n \n ```\n #![no_std]\n+#![feature(globs)]\n \n # extern crate libc;\n extern crate core;"}, {"sha": "619e24af36063b65a7c908dab0623d612f2d8702", "filename": "src/doc/rust.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a", "patch": "@@ -1260,13 +1260,16 @@ a = Cat;\n Enumeration constructors can have either named or unnamed fields:\n \n ~~~~\n+# #![feature(struct_variant)]\n+# fn main() {\n enum Animal {\n     Dog (String, f64),\n     Cat { name: String, weight: f64 }\n }\n \n let mut a: Animal = Dog(\"Cocoa\".to_string(), 37.2);\n a = Cat { name: \"Spotty\".to_string(), weight: 2.7 };\n+# }\n ~~~~\n \n In this example, `Cat` is a _struct-like enum variant_,"}, {"sha": "3b4164ffbc618b367f57595acafff96a5aa8cd40", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a", "patch": "@@ -774,6 +774,7 @@ fn point_from_direction(dir: Direction) -> Point {\n Enum variants may also be structs. For example:\n \n ~~~~\n+# #![feature(struct_variant)]\n use std::f64;\n # struct Point { x: f64, y: f64 }\n # fn square(x: f64) -> f64 { x * x }\n@@ -789,6 +790,7 @@ fn area(sh: Shape) -> f64 {\n         }\n     }\n }\n+# fn main() {}\n ~~~~\n \n > *Note:* This feature of the compiler is currently gated behind the\n@@ -3046,6 +3048,7 @@ use farm::{chicken, cow};\n 2. Import everything in a module with a wildcard:\n \n ~~~\n+# #![feature(globs)]\n use farm::*;\n # mod farm {\n #     pub fn cow() { println!(\"Bat-chicken? What a stupid name!\") }"}, {"sha": "500d17c9f9a57625d545a838d6384485bc4bec6c", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a", "patch": "@@ -173,7 +173,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n pub fn test(input: &str, libs: HashSet<Path>, mut test_args: Vec<String>) -> int {\n     let input_str = load_or_return!(input, 1, 2);\n \n-    let mut collector = Collector::new(input.to_string(), libs, true, true);\n+    let mut collector = Collector::new(input.to_string(), libs, true);\n     find_testable_code(input_str.as_slice(), &mut collector);\n     test_args.unshift(\"rustdoctest\".to_string());\n     testing::test_main(test_args.as_slice(), collector.tests);"}, {"sha": "1434c3eb07d53d37e173e3f935762325df3a8df3", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=cc63d4c61bb83fcbcef5ccfffcd9b26b1bf2d20a", "patch": "@@ -91,7 +91,6 @@ pub fn run(input: &str,\n \n     let mut collector = Collector::new(krate.name.to_string(),\n                                        libs,\n-                                       false,\n                                        false);\n     collector.fold_crate(krate);\n \n@@ -103,8 +102,8 @@ pub fn run(input: &str,\n }\n \n fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n-           no_run: bool, loose_feature_gating: bool) {\n-    let test = maketest(test, cratename, loose_feature_gating);\n+           no_run: bool) {\n+    let test = maketest(test, cratename);\n     let input = driver::StrInput(test.to_string());\n \n     let sessopts = config::Options {\n@@ -201,18 +200,12 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     }\n }\n \n-fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> String {\n+pub fn maketest(s: &str, cratename: &str) -> String {\n     let mut prog = String::from_str(r\"\n #![deny(warnings)]\n #![allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)]\n \");\n \n-    if loose_feature_gating {\n-        // FIXME #12773: avoid inserting these when the tutorial & manual\n-        // etc. have been updated to not use them so prolifically.\n-        prog.push_str(\"#![feature(macro_rules, globs, struct_variant, managed_boxes) ]\\n\");\n-    }\n-\n     if !s.contains(\"extern crate\") {\n         if s.contains(cratename) {\n             prog.push_str(format!(\"extern crate {};\\n\",\n@@ -238,13 +231,11 @@ pub struct Collector {\n     use_headers: bool,\n     current_header: Option<String>,\n     cratename: String,\n-\n-    loose_feature_gating: bool\n }\n \n impl Collector {\n     pub fn new(cratename: String, libs: HashSet<Path>,\n-               use_headers: bool, loose_feature_gating: bool) -> Collector {\n+               use_headers: bool) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             names: Vec::new(),\n@@ -253,8 +244,6 @@ impl Collector {\n             use_headers: use_headers,\n             current_header: None,\n             cratename: cratename,\n-\n-            loose_feature_gating: loose_feature_gating\n         }\n     }\n \n@@ -268,7 +257,6 @@ impl Collector {\n         self.cnt += 1;\n         let libs = self.libs.clone();\n         let cratename = self.cratename.to_string();\n-        let loose_feature_gating = self.loose_feature_gating;\n         debug!(\"Creating test {}: {}\", name, test);\n         self.tests.push(testing::TestDescAndFn {\n             desc: testing::TestDesc {\n@@ -281,8 +269,7 @@ impl Collector {\n                         cratename.as_slice(),\n                         libs,\n                         should_fail,\n-                        no_run,\n-                        loose_feature_gating);\n+                        no_run);\n             }),\n         });\n     }"}]}