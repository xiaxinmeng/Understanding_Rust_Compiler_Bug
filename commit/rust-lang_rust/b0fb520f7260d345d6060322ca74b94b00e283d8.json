{"sha": "b0fb520f7260d345d6060322ca74b94b00e283d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZmI1MjBmNzI2MGQzNDVkNjA2MDMyMmNhNzRiOTRiMDBlMjgzZDg=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-06-03T04:56:29Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-06-21T21:42:22Z"}, "message": "std: micro-optimize Vec constructors and add benchmarks\n\nGenerally speaking, inlining doesn't really help out with\nconstructing vectors, except for when we construct a zero-sized\nvector. This patch allows llvm to optimize this case away in\na lot of cases, which shaves off 4-8ns. It's not much, but it\nmight help in some inner loop somewhere.\n\nbefore:\n\nrunning 12 tests\ntest bench_extend_0          ... bench:       123 ns/iter (+/- 6)\ntest bench_extend_5          ... bench:       323 ns/iter (+/- 11)\ntest bench_from_fn_0         ... bench:         7 ns/iter (+/- 0)\ntest bench_from_fn_5         ... bench:        49 ns/iter (+/- 6)\ntest bench_from_iter_0       ... bench:        11 ns/iter (+/- 0)\ntest bench_from_iter_5       ... bench:       176 ns/iter (+/- 11)\ntest bench_from_slice_0      ... bench:         8 ns/iter (+/- 1)\ntest bench_from_slice_5      ... bench:        73 ns/iter (+/- 5)\ntest bench_new               ... bench:         0 ns/iter (+/- 0)\ntest bench_with_capacity_0   ... bench:         6 ns/iter (+/- 1)\ntest bench_with_capacity_100 ... bench:        41 ns/iter (+/- 3)\ntest bench_with_capacity_5   ... bench:        40 ns/iter (+/- 2)\n\nafter:\n\ntest bench_extend_0          ... bench:       123 ns/iter (+/- 7)\ntest bench_extend_5          ... bench:       339 ns/iter (+/- 27)\ntest bench_from_fn_0         ... bench:         7 ns/iter (+/- 0)\ntest bench_from_fn_5         ... bench:        54 ns/iter (+/- 4)\ntest bench_from_iter_0       ... bench:        11 ns/iter (+/- 1)\ntest bench_from_iter_5       ... bench:       182 ns/iter (+/- 16)\ntest bench_from_slice_0      ... bench:         4 ns/iter (+/- 0)\ntest bench_from_slice_5      ... bench:        62 ns/iter (+/- 3)\ntest bench_new               ... bench:         0 ns/iter (+/- 0)\ntest bench_with_capacity_0   ... bench:         0 ns/iter (+/- 0)\ntest bench_with_capacity_100 ... bench:        41 ns/iter (+/- 1)\ntest bench_with_capacity_5   ... bench:        41 ns/iter (+/- 3)", "tree": {"sha": "8720b4087c9d1497a15b67cf8b99a8e5a38f4190", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8720b4087c9d1497a15b67cf8b99a8e5a38f4190"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0fb520f7260d345d6060322ca74b94b00e283d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0fb520f7260d345d6060322ca74b94b00e283d8", "html_url": "https://github.com/rust-lang/rust/commit/b0fb520f7260d345d6060322ca74b94b00e283d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0fb520f7260d345d6060322ca74b94b00e283d8/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db9af1d505809c965e719bf4ad775ff984ee3da6", "url": "https://api.github.com/repos/rust-lang/rust/commits/db9af1d505809c965e719bf4ad775ff984ee3da6", "html_url": "https://github.com/rust-lang/rust/commit/db9af1d505809c965e719bf4ad775ff984ee3da6"}], "stats": {"total": 115, "additions": 115, "deletions": 0}, "files": [{"sha": "53fbed9e11da0108cb73f49adde666cde0093d46", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/b0fb520f7260d345d6060322ca74b94b00e283d8/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0fb520f7260d345d6060322ca74b94b00e283d8/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=b0fb520f7260d345d6060322ca74b94b00e283d8", "patch": "@@ -85,6 +85,7 @@ impl<T> Vec<T> {\n     /// # use std::vec::Vec;\n     /// let vec: Vec<int> = Vec::with_capacity(10);\n     /// ```\n+    #[inline]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n             Vec { len: 0, cap: uint::MAX, ptr: 0 as *mut T }\n@@ -110,6 +111,7 @@ impl<T> Vec<T> {\n     /// let vec = Vec::from_fn(3, |idx| idx * 2);\n     /// assert_eq!(vec, vec!(0, 2, 4));\n     /// ```\n+    #[inline]\n     pub fn from_fn(length: uint, op: |uint| -> T) -> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n@@ -193,6 +195,7 @@ impl<T: Clone> Vec<T> {\n     /// let slice = [1, 2, 3];\n     /// let vec = Vec::from_slice(slice);\n     /// ```\n+    #[inline]\n     pub fn from_slice(values: &[T]) -> Vec<T> {\n         values.iter().map(|x| x.clone()).collect()\n     }\n@@ -207,6 +210,7 @@ impl<T: Clone> Vec<T> {\n     /// let vec = Vec::from_elem(3, \"hi\");\n     /// println!(\"{}\", vec); // prints [hi, hi, hi]\n     /// ```\n+    #[inline]\n     pub fn from_elem(length: uint, value: T) -> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n@@ -353,6 +357,7 @@ impl<T:Clone> Clone for Vec<T> {\n }\n \n impl<T> FromIterator<T> for Vec<T> {\n+    #[inline]\n     fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> {\n         let (lower, _) = iterator.size_hint();\n         let mut vector = Vec::with_capacity(lower);\n@@ -364,6 +369,7 @@ impl<T> FromIterator<T> for Vec<T> {\n }\n \n impl<T> Extendable<T> for Vec<T> {\n+    #[inline]\n     fn extend<I: Iterator<T>>(&mut self, mut iterator: I) {\n         let (lower, _) = iterator.size_hint();\n         self.reserve_additional(lower);\n@@ -1029,6 +1035,7 @@ impl<T> Vec<T> {\n     /// vec.push_all_move(vec!(box 2, box 3, box 4));\n     /// assert_eq!(vec, vec!(box 1, box 2, box 3, box 4));\n     /// ```\n+    #[inline]\n     pub fn push_all_move(&mut self, other: Vec<T>) {\n         self.extend(other.move_iter());\n     }\n@@ -1306,6 +1313,7 @@ impl<T:PartialEq> Vec<T> {\n     /// let vec = vec!(1, 2, 3);\n     /// assert!(vec.contains(&1));\n     /// ```\n+    #[inline]\n     pub fn contains(&self, x: &T) -> bool {\n         self.as_slice().contains(x)\n     }\n@@ -1836,4 +1844,111 @@ mod tests {\n         let mut v = vec![BadElem(1), BadElem(2), BadElem(0xbadbeef), BadElem(4)];\n         v.truncate(0);\n     }\n+\n+    #[bench]\n+    fn bench_new(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::new();\n+            assert_eq!(v.capacity(), 0);\n+            assert!(v.as_slice() == []);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_with_capacity_0(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::with_capacity(0);\n+            assert_eq!(v.capacity(), 0);\n+            assert!(v.as_slice() == []);\n+        })\n+    }\n+\n+\n+    #[bench]\n+    fn bench_with_capacity_5(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::with_capacity(5);\n+            assert_eq!(v.capacity(), 5);\n+            assert!(v.as_slice() == []);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_with_capacity_100(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::with_capacity(100);\n+            assert_eq!(v.capacity(), 100);\n+            assert!(v.as_slice() == []);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_from_fn_0(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::from_fn(0, |_| 5);\n+            assert!(v.as_slice() == []);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_from_fn_5(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::from_fn(5, |_| 5);\n+            assert!(v.as_slice() == [5, 5, 5, 5, 5]);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_from_slice_0(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::from_slice([]);\n+            assert!(v.as_slice() == []);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_from_slice_5(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::from_slice([1, 2, 3, 4, 5]);\n+            assert!(v.as_slice() == [1, 2, 3, 4, 5]);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_from_iter_0(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v0: Vec<int> = vec!();\n+            let v1: Vec<int> = FromIterator::from_iter(v0.move_iter());\n+            assert!(v1.as_slice() == []);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_from_iter_5(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v0: Vec<int> = vec!(1, 2, 3, 4, 5);\n+            let v1: Vec<int> = FromIterator::from_iter(v0.move_iter());\n+            assert!(v1.as_slice() == [1, 2, 3, 4, 5]);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_extend_0(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v0: Vec<int> = vec!();\n+            let mut v1: Vec<int> = vec!(1, 2, 3, 4, 5);\n+            v1.extend(v0.move_iter());\n+            assert!(v1.as_slice() == [1, 2, 3, 4, 5]);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_extend_5(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v0: Vec<int> = vec!(1, 2, 3, 4, 5);\n+            let mut v1: Vec<int> = vec!(1, 2, 3, 4, 5);\n+            v1.extend(v0.move_iter());\n+            assert!(v1.as_slice() == [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]);\n+        })\n+    }\n }"}]}