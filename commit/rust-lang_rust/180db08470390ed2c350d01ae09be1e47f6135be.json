{"sha": "180db08470390ed2c350d01ae09be1e47f6135be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MGRiMDg0NzAzOTBlZDJjMzUwZDAxYWUwOWJlMWU0N2Y2MTM1YmU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-15T09:03:23Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-15T09:03:23Z"}, "message": "Refactor expr_root in alias.rs\n\nIt was too clunky and specific before. Now returns a vec of dereference specs\ninstead of a bunch of special-case information. Further accessors extract\nthe information they need from this vec.", "tree": {"sha": "8d956da5968edc10cc9563fa09bfe16ddc0a6032", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d956da5968edc10cc9563fa09bfe16ddc0a6032"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/180db08470390ed2c350d01ae09be1e47f6135be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/180db08470390ed2c350d01ae09be1e47f6135be", "html_url": "https://github.com/rust-lang/rust/commit/180db08470390ed2c350d01ae09be1e47f6135be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/180db08470390ed2c350d01ae09be1e47f6135be/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5caff8e18c30d2812ab8b30f1c66576af18caf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5caff8e18c30d2812ab8b30f1c66576af18caf3", "html_url": "https://github.com/rust-lang/rust/commit/c5caff8e18c30d2812ab8b30f1c66576af18caf3"}], "stats": {"total": 144, "additions": 71, "deletions": 73}, "files": [{"sha": "08ac6c303ccb8d21c1988333cec045c0b35289bf", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 71, "deletions": 73, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/180db08470390ed2c350d01ae09be1e47f6135be/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180db08470390ed2c350d01ae09be1e47f6135be/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=180db08470390ed2c350d01ae09be1e47f6135be", "patch": "@@ -64,7 +64,7 @@ fn visit_expr(&@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n             alt (val) {\n                 case (some(?ex)) {\n                     auto root = expr_root(*cx, ex, false);\n-                    if (!is_none(root.inner_mut)) {\n+                    if (mut_field(root.ds)) {\n                         cx.tcx.sess.span_err\n                             (ex.span,\n                              \"result of put must be immutably rooted\");\n@@ -129,7 +129,7 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc)\n                         vec::push(mut_roots, tup(i, did._1));\n                     }\n                     case (_) {\n-                        if (!root.mut_field) {\n+                        if (!mut_field(root.ds)) {\n                             cx.tcx.sess.span_err\n                                 (arg.span, \"passing a temporary value or \\\n                                  immutable field by mutable alias\");\n@@ -141,7 +141,7 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc)\n                 case (some(?did)) { vec::push(roots, did._1); }\n                 case (_) {}\n             }\n-            alt (root.inner_mut) {\n+            alt (inner_mut(root.ds)) {\n                 case (some(?t)) {\n                     vec::push(unsafe_ts, t);\n                     vec::push(unsafe_t_offsets, i);\n@@ -208,7 +208,7 @@ fn check_alt(&ctx cx, &@ast::expr input, &vec[ast::arm] arms,\n         case (some(?did)) { [did._1] }\n         case (_) { [] }\n     };\n-    let vec[ty::t] forbidden_tp = alt (root.inner_mut) {\n+    let vec[ty::t] forbidden_tp = alt (inner_mut(root.ds)) {\n         case (some(?t)) { [t] }\n         case (_) { [] }\n     };\n@@ -276,7 +276,7 @@ fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq,\n         case (some(?did)) { [did._1] }\n         case (_) { [] }\n     };\n-    auto unsafe = alt (root.inner_mut) {\n+    auto unsafe = alt (inner_mut(root.ds)) {\n         case (some(?t)) { [t] }\n         case (_) { [] }\n     };\n@@ -389,82 +389,89 @@ fn deps(&scope sc, vec[def_num] roots) -> vec[uint] {\n     ret result;\n }\n \n+tag deref_t {\n+    unbox;\n+    field(ident);\n+    index;\n+}\n+type deref = rec(bool mut, deref_t kind, ty::t outer_t);\n+\n+// Finds the root (the thing that is dereferenced) for the given expr, and a\n+// vec of dereferences that were used on this root. Note that, in this vec,\n+// the inner derefs come in front, so foo.bar.baz becomes rec(ex=foo,\n+// ds=[field(baz),field(bar)])\n fn expr_root(&ctx cx, @ast::expr ex, bool autoderef)\n-    -> rec(@ast::expr ex,\n-           option::t[ty::t] inner_mut,\n-           bool mut_in_box,\n-           bool mut_field) {\n-    let option::t[ty::t] mut = none;\n-    // This is not currently used but would make it possible to be more\n-    // liberal -- only stuff in a mutable box needs full type-inclusion\n-    // checking, things that aren't in a box need only be checked against\n-    // locally live aliases and their root.\n-    auto mut_in_box = false;\n-    auto mut_fld = false;\n-    auto depth = 0;\n+    -> rec(@ast::expr ex, vec[deref] ds) {\n+\n+    fn maybe_auto_unbox(&ctx cx, &ty::t t)\n+        -> rec(ty::t t, option::t[deref] d) {\n+        alt (ty::struct(*cx.tcx, t)) {\n+            case (ty::ty_box(?mt)) {\n+                ret rec(t=mt.ty, d=some(rec(mut=mt.mut != ast::imm,\n+                                            kind=unbox,\n+                                            outer_t=t)));\n+            }\n+            case (_) {\n+                ret rec(t=t, d=none);\n+            }\n+        }\n+    }\n+    fn maybe_push_auto_unbox(&option::t[deref] d, &mutable vec[deref] ds) {\n+        alt (d) {\n+            case (some(?d)) { vec::push(ds, d); }\n+            case (none) {}\n+        }\n+    }\n+\n+    let vec[deref] ds = [];\n     while (true) {\n         alt ({ex.node}) {\n             case (ast::expr_field(?base, ?ident, _)) {\n-                auto base_t = ty::expr_ty(*cx.tcx, base);\n-                auto auto_unbox = maybe_auto_unbox(cx, base_t);\n+                auto auto_unbox = maybe_auto_unbox\n+                    (cx, ty::expr_ty(*cx.tcx, base));\n+                auto mut = false;\n                 alt (ty::struct(*cx.tcx, auto_unbox.t)) {\n                     case (ty::ty_tup(?fields)) {\n                         auto fnm = ty::field_num(cx.tcx.sess, ex.span, ident);\n-                        if (fields.(fnm).mut != ast::imm) {\n-                            if (is_none(mut)) { mut = some(auto_unbox.t); }\n-                            if (depth == 0) { mut_fld = true; }\n-                        }\n+                        mut = fields.(fnm).mut != ast::imm;\n                     }\n                     case (ty::ty_rec(?fields)) {\n                         for (ty::field fld in fields) {\n                             if (str::eq(ident, fld.ident)) {\n-                                if (fld.mt.mut != ast::imm) {\n-                                    if (is_none(mut)) {\n-                                        mut = some(auto_unbox.t);\n-                                    }\n-                                    if (depth == 0) { mut_fld = true; }\n-                                }\n+                                mut = fld.mt.mut != ast::imm;\n                                 break;\n                             }\n                         }\n                     }\n                     case (ty::ty_obj(_)) {}\n                 }\n-                if (auto_unbox.done) {\n-                    if (!is_none(mut)) { mut_in_box = true; }\n-                    else if (auto_unbox.mut) { mut = some(base_t); }\n-                }\n+                vec::push(ds, rec(mut=mut,\n+                                  kind=field(ident),\n+                                  outer_t=auto_unbox.t));\n+                maybe_push_auto_unbox(auto_unbox.d, ds);\n                 ex = base;\n             }\n             case (ast::expr_index(?base, _, _)) {\n-                auto base_t = ty::expr_ty(*cx.tcx, base);\n-                auto auto_unbox = maybe_auto_unbox(cx, base_t);\n+                auto auto_unbox = maybe_auto_unbox\n+                    (cx, ty::expr_ty(*cx.tcx, base));\n                 alt (ty::struct(*cx.tcx, auto_unbox.t)) {\n                     case (ty::ty_vec(?mt)) {\n-                        if (mt.mut != ast::imm) {\n-                            if (is_none(mut)) { mut = some(auto_unbox.t); }\n-                            if (depth == 0) { mut_fld = true; }\n-                        }\n+                        vec::push(ds, rec(mut=mt.mut != ast::imm,\n+                                          kind=index,\n+                                          outer_t=auto_unbox.t));\n                     }\n                 }\n-                if (auto_unbox.done) {\n-                    if (!is_none(mut)) { mut_in_box = true; }\n-                    else if (auto_unbox.mut) { mut = some(base_t); }\n-                }\n+                maybe_push_auto_unbox(auto_unbox.d, ds);\n                 ex = base;\n             }\n             case (ast::expr_unary(?op, ?base, _)) {\n                 if (op == ast::deref) {\n                     auto base_t = ty::expr_ty(*cx.tcx, base);\n                     alt (ty::struct(*cx.tcx, base_t)) {\n                         case (ty::ty_box(?mt)) {\n-                            if (mt.mut != ast::imm) {\n-                                if (is_none(mut)) { mut = some(base_t); }\n-                                if (depth == 0) { mut_fld = true; }\n-                            }\n-                            if (!is_none(mut)) {\n-                                mut_in_box = true;\n-                            }\n+                            vec::push(ds, rec(mut=mt.mut != ast::imm,\n+                                              kind=unbox,\n+                                              outer_t=base_t));\n                         }\n                     }\n                     ex = base;\n@@ -474,35 +481,26 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef)\n             }\n             case (_) { break; }\n         }\n-        depth += 1;\n     }\n     if (autoderef) {\n-        auto ex_t = ty::expr_ty(*cx.tcx, ex);\n-        auto auto_unbox = maybe_auto_unbox(cx, ex_t);\n-        if (auto_unbox.done) {\n-            if (!is_none(mut)) { mut_in_box = true; }\n-            else if (auto_unbox.mut) {\n-                mut = some(ex_t);\n-                if (depth == 0) { mut_fld = true; }\n-            }\n-        }\n+        auto auto_unbox = maybe_auto_unbox(cx, ty::expr_ty(*cx.tcx, ex));\n+        maybe_push_auto_unbox(auto_unbox.d, ds);\n     }\n-    ret rec(ex = ex,\n-            inner_mut = mut,\n-            mut_in_box = mut_in_box,\n-            mut_field = mut_fld);\n+    ret rec(ex=ex, ds=ds);\n }\n \n-fn maybe_auto_unbox(&ctx cx, &ty::t t)\n-    -> rec(ty::t t, bool done, bool mut) {\n-    alt (ty::struct(*cx.tcx, t)) {\n-        case (ty::ty_box(?mt)) {\n-            ret rec(t=mt.ty, done=true, mut=mt.mut != ast::imm);\n-        }\n-        case (_) {\n-            ret rec(t=t, done=false, mut=false);\n-        }\n+fn mut_field(&vec[deref] ds) -> bool {\n+    for (deref d in ds) {\n+        if (d.mut) { ret true; }\n+    }\n+    ret false;\n+}\n+\n+fn inner_mut(&vec[deref] ds) -> option::t[ty::t] {\n+    for (deref d in ds) {\n+        if (d.mut) { ret some(d.outer_t); }\n     }\n+    ret none;\n }\n \n fn path_def_id(&ctx cx, &@ast::expr ex) -> option::t[ast::def_id] {"}]}