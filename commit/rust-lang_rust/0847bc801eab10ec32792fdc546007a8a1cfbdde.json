{"sha": "0847bc801eab10ec32792fdc546007a8a1cfbdde", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4NDdiYzgwMWVhYjEwZWMzMjc5MmZkYzU0NjAwN2E4YTFjZmJkZGU=", "commit": {"author": {"name": "unexge", "email": "unexge@gmail.com", "date": "2020-08-16T13:25:10Z"}, "committer": {"name": "unexge", "email": "unexge@gmail.com", "date": "2020-08-20T18:34:53Z"}, "message": "Use `Definition::find_usages` for finding used items in expand glob import", "tree": {"sha": "da2fcd7efce9586d94cfd941b0f498fc0fcce923", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da2fcd7efce9586d94cfd941b0f498fc0fcce923"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0847bc801eab10ec32792fdc546007a8a1cfbdde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0847bc801eab10ec32792fdc546007a8a1cfbdde", "html_url": "https://github.com/rust-lang/rust/commit/0847bc801eab10ec32792fdc546007a8a1cfbdde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0847bc801eab10ec32792fdc546007a8a1cfbdde/comments", "author": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11d048af03e0d9e07c5c67c9a644af5fbf94ed57", "url": "https://api.github.com/repos/rust-lang/rust/commits/11d048af03e0d9e07c5c67c9a644af5fbf94ed57", "html_url": "https://github.com/rust-lang/rust/commit/11d048af03e0d9e07c5c67c9a644af5fbf94ed57"}], "stats": {"total": 251, "additions": 137, "deletions": 114}, "files": [{"sha": "bf520069e88ea61214e1ced1ce67d430d3978337", "filename": "crates/assists/src/assist_context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0847bc801eab10ec32792fdc546007a8a1cfbdde/crates%2Fassists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0847bc801eab10ec32792fdc546007a8a1cfbdde/crates%2Fassists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fassist_context.rs?ref=0847bc801eab10ec32792fdc546007a8a1cfbdde", "patch": "@@ -73,10 +73,6 @@ impl<'a> AssistContext<'a> {\n         self.sema.db\n     }\n \n-    pub(crate) fn source_file(&self) -> &SourceFile {\n-        &self.source_file\n-    }\n-\n     // NB, this ignores active selection.\n     pub(crate) fn offset(&self) -> TextSize {\n         self.frange.range.start()"}, {"sha": "64267a03fc6bc63ad7067b0d2b66cf743b819f95", "filename": "crates/assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 137, "deletions": 110, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/0847bc801eab10ec32792fdc546007a8a1cfbdde/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0847bc801eab10ec32792fdc546007a8a1cfbdde/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=0847bc801eab10ec32792fdc546007a8a1cfbdde", "patch": "@@ -1,12 +1,10 @@\n use either::Either;\n-use std::iter::successors;\n-\n-use hir::{AssocItem, MacroDef, ModuleDef, Name, PathResolution, ScopeDef, SemanticsScope};\n+use hir::{MacroDef, Module, ModuleDef, Name, PathResolution, ScopeDef, SemanticsScope};\n use ide_db::{\n     defs::{classify_name_ref, Definition, NameRefClass},\n-    RootDatabase,\n+    search::SearchScope,\n };\n-use syntax::{algo, ast, AstNode, SourceFile, SyntaxNode, SyntaxToken, T};\n+use syntax::{algo, ast, AstNode, Direction, SyntaxNode, SyntaxToken, T};\n \n use crate::{\n     assist_context::{AssistBuilder, AssistContext, Assists},\n@@ -41,16 +39,17 @@ use crate::{\n pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let star = ctx.find_token_at_offset(T![*])?;\n     let (parent, mod_path) = find_parent_and_path(&star)?;\n-    let module = match ctx.sema.resolve_path(&mod_path)? {\n+    let target_module = match ctx.sema.resolve_path(&mod_path)? {\n         PathResolution::Def(ModuleDef::Module(it)) => it,\n         _ => return None,\n     };\n \n-    let source_file = ctx.source_file();\n-    let scope = ctx.sema.scope_at_offset(source_file.syntax(), ctx.offset());\n+    let current_scope = ctx.sema.scope(&star.parent());\n+    let current_module = current_scope.module()?;\n \n-    let defs_in_mod = find_defs_in_mod(ctx, scope, module)?;\n-    let names_to_import = find_names_to_import(ctx, source_file, defs_in_mod);\n+    let refs_in_target = find_refs_in_mod(ctx, target_module, Some(current_module))?;\n+    let imported_defs = find_imported_defs(ctx, star)?;\n+    let names_to_import = find_names_to_import(ctx, current_scope, refs_in_target, imported_defs);\n \n     let target = parent.clone().either(|n| n.syntax().clone(), |n| n.syntax().clone());\n     acc.add(\n@@ -85,94 +84,119 @@ fn find_parent_and_path(\n     }\n }\n \n-#[derive(PartialEq)]\n+#[derive(Debug, PartialEq, Clone)]\n enum Def {\n     ModuleDef(ModuleDef),\n     MacroDef(MacroDef),\n }\n \n-impl Def {\n-    fn name(&self, db: &RootDatabase) -> Option<Name> {\n-        match self {\n-            Def::ModuleDef(def) => def.name(db),\n-            Def::MacroDef(def) => def.name(db),\n+#[derive(Debug, Clone)]\n+struct Ref {\n+    // could be alias\n+    visible_name: Name,\n+    def: Def,\n+}\n+\n+impl Ref {\n+    fn from_scope_def(name: Name, scope_def: ScopeDef) -> Option<Self> {\n+        match scope_def {\n+            ScopeDef::ModuleDef(def) => Some(Ref { visible_name: name, def: Def::ModuleDef(def) }),\n+            ScopeDef::MacroDef(def) => Some(Ref { visible_name: name, def: Def::MacroDef(def) }),\n+            _ => None,\n         }\n     }\n-}\n \n-fn find_defs_in_mod(\n-    ctx: &AssistContext,\n-    from: SemanticsScope<'_>,\n-    module: hir::Module,\n-) -> Option<Vec<Def>> {\n-    let module_scope = module.scope(ctx.db(), from.module());\n-\n-    let mut defs = vec![];\n-    for (_, def) in module_scope {\n-        match def {\n-            ScopeDef::ModuleDef(def) => defs.push(Def::ModuleDef(def)),\n-            ScopeDef::MacroDef(def) => defs.push(Def::MacroDef(def)),\n-            _ => continue,\n+    fn is_referenced_in(&self, ctx: &AssistContext, scope: &SemanticsScope) -> bool {\n+        let def = match self.def {\n+            Def::ModuleDef(def) => Definition::ModuleDef(def),\n+            Def::MacroDef(def) => Definition::Macro(def),\n+        };\n+\n+        if let Definition::ModuleDef(ModuleDef::Trait(tr)) = def {\n+            if scope\n+                .traits_in_scope()\n+                .into_iter()\n+                .find(|other_tr_id| tr == other_tr_id.to_owned().into())\n+                .is_some()\n+            {\n+                return true;\n+            }\n         }\n+\n+        let search_scope = SearchScope::single_file(ctx.frange.file_id);\n+        !def.find_usages(&ctx.sema, Some(search_scope)).is_empty()\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+struct Refs(Vec<Ref>);\n+\n+impl Refs {\n+    fn used_refs(&self, ctx: &AssistContext, scope: &SemanticsScope) -> Refs {\n+        Refs(self.0.clone().into_iter().filter(|r| r.is_referenced_in(ctx, scope)).collect())\n     }\n \n-    Some(defs)\n+    fn filter_out_by_defs(&self, defs: Vec<Def>) -> Refs {\n+        Refs(self.0.clone().into_iter().filter(|r| !defs.contains(&r.def)).collect())\n+    }\n }\n \n-fn find_names_to_import(\n+fn find_refs_in_mod(\n     ctx: &AssistContext,\n-    source_file: &SourceFile,\n-    defs_in_mod: Vec<Def>,\n-) -> Vec<Name> {\n-    let (name_refs_in_use_item, name_refs_in_source) = source_file\n-        .syntax()\n-        .descendants()\n-        .filter_map(|n| {\n-            let name_ref = ast::NameRef::cast(n.clone())?;\n-            let name_ref_class = classify_name_ref(&ctx.sema, &name_ref)?;\n-            let is_in_use_item =\n-                successors(n.parent(), |n| n.parent()).find_map(ast::Use::cast).is_some();\n-            Some((name_ref_class, is_in_use_item))\n-        })\n-        .partition::<Vec<_>, _>(|&(_, is_in_use_item)| is_in_use_item);\n-\n-    let name_refs_to_import: Vec<NameRefClass> = name_refs_in_source\n-        .into_iter()\n-        .filter_map(|(r, _)| {\n-            if name_refs_in_use_item.contains(&(r.clone(), true)) {\n-                // already imported\n-                return None;\n-            }\n-            Some(r)\n-        })\n-        .collect();\n-\n-    let defs_in_source_file = name_refs_to_import\n-        .into_iter()\n-        .filter_map(|rc| match rc {\n-            NameRefClass::Definition(Definition::ModuleDef(def)) => Some(Def::ModuleDef(def)),\n-            NameRefClass::Definition(Definition::Macro(def)) => Some(Def::MacroDef(def)),\n-            _ => None,\n-        })\n-        .collect::<Vec<Def>>();\n+    module: Module,\n+    visible_from: Option<Module>,\n+) -> Option<Refs> {\n+    let module_scope = module.scope(ctx.db(), visible_from);\n+    let refs = module_scope.into_iter().filter_map(|(n, d)| Ref::from_scope_def(n, d)).collect();\n+    Some(Refs(refs))\n+}\n \n-    defs_in_mod\n-        .iter()\n-        .filter(|def| {\n-            if let Def::ModuleDef(ModuleDef::Trait(tr)) = def {\n-                for item in tr.items(ctx.db()) {\n-                    if let AssocItem::Function(f) = item {\n-                        if defs_in_source_file.contains(&Def::ModuleDef(ModuleDef::Function(f))) {\n-                            return true;\n-                        }\n-                    }\n-                }\n-            }\n+// looks for name refs in parent use block's siblings\n+//\n+// mod bar {\n+//     mod qux {\n+//         struct Qux;\n+//     }\n+//\n+//     pub use qux::Qux;\n+// }\n+//\n+// \u2193 ---------------\n+// use foo::*<|>;\n+// use baz::Baz;\n+// \u2191 ---------------\n+fn find_imported_defs(ctx: &AssistContext, star: SyntaxToken) -> Option<Vec<Def>> {\n+    let parent_use_item_syntax =\n+        star.ancestors().find_map(|n| if ast::Use::can_cast(n.kind()) { Some(n) } else { None })?;\n+\n+    Some(\n+        [Direction::Prev, Direction::Next]\n+            .iter()\n+            .map(|dir| {\n+                parent_use_item_syntax\n+                    .siblings(dir.to_owned())\n+                    .filter(|n| ast::Use::can_cast(n.kind()))\n+            })\n+            .flatten()\n+            .filter_map(|n| Some(n.descendants().filter_map(ast::NameRef::cast)))\n+            .flatten()\n+            .filter_map(|r| match classify_name_ref(&ctx.sema, &r)? {\n+                NameRefClass::Definition(Definition::ModuleDef(def)) => Some(Def::ModuleDef(def)),\n+                NameRefClass::Definition(Definition::Macro(def)) => Some(Def::MacroDef(def)),\n+                _ => None,\n+            })\n+            .collect(),\n+    )\n+}\n \n-            defs_in_source_file.contains(def)\n-        })\n-        .filter_map(|d| d.name(ctx.db()))\n-        .collect()\n+fn find_names_to_import(\n+    ctx: &AssistContext,\n+    current_scope: SemanticsScope,\n+    refs_in_target: Refs,\n+    imported_defs: Vec<Def>,\n+) -> Vec<Name> {\n+    let used_refs = refs_in_target.used_refs(ctx, &current_scope).filter_out_by_defs(imported_defs);\n+    used_refs.0.iter().map(|r| r.visible_name.clone()).collect()\n }\n \n fn replace_ast(\n@@ -685,34 +709,37 @@ fn qux(bar: Bar, baz: Baz) {\n \n     #[test]\n     fn expanding_glob_import_with_macro_defs() {\n-        check_assist(\n-            expand_glob_import,\n-            r\"\n-//- /lib.rs crate:foo\n-#[macro_export]\n-macro_rules! bar {\n-    () => ()\n-}\n-\n-pub fn baz() {}\n-\n-//- /main.rs crate:main deps:foo\n-use foo::*<|>;\n-\n-fn main() {\n-    bar!();\n-    baz();\n-}\n-\",\n-            r\"\n-use foo::{bar, baz};\n-\n-fn main() {\n-    bar!();\n-    baz();\n-}\n-\",\n-        )\n+        // TODO: this is currently fails because `Definition::find_usages` ignores macros\n+        //       https://github.com/rust-analyzer/rust-analyzer/issues/3484\n+        //\n+        //         check_assist(\n+        //             expand_glob_import,\n+        //             r\"\n+        // //- /lib.rs crate:foo\n+        // #[macro_export]\n+        // macro_rules! bar {\n+        //     () => ()\n+        // }\n+\n+        // pub fn baz() {}\n+\n+        // //- /main.rs crate:main deps:foo\n+        // use foo::*<|>;\n+\n+        // fn main() {\n+        //     bar!();\n+        //     baz();\n+        // }\n+        // \",\n+        //             r\"\n+        // use foo::{bar, baz};\n+\n+        // fn main() {\n+        //     bar!();\n+        //     baz();\n+        // }\n+        // \",\n+        //         )\n     }\n \n     #[test]"}]}