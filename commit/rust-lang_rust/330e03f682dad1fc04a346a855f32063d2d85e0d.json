{"sha": "330e03f682dad1fc04a346a855f32063d2d85e0d", "node_id": "C_kwDOAAsO6NoAKDMzMGUwM2Y2ODJkYWQxZmMwNGEzNDZhODU1ZjMyMDYzZDJkODVlMGQ", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-05-18T23:22:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-18T23:22:42Z"}, "message": "Rollup merge of #97062 - bjorn3:cg_ssa_driver_refactor, r=compiler-errors\n\nCouple of refactorings to cg_ssa::base::codegen_crate\n\nThis makes the code simpler and easier to read.", "tree": {"sha": "7547f65dd7e2273017a347ec755b5702de1e4625", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7547f65dd7e2273017a347ec755b5702de1e4625"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/330e03f682dad1fc04a346a855f32063d2d85e0d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJihX/CCRBK7hj4Ov3rIwAAJ7gIACGAxzFBTf8y4IQBI4dZlh5B\n0FfCrUFtRx8tKrKqTnyfqZsyV7MkaviucpS8ChGg4lVDCyC7oJ1qbQXwQK8OBpXq\nJQPpowcdfLOnXnqlNKLWt2r+khKT21GLFfSqKH4usDaqfE2LY9UyNmck5Il7IRml\nwH13lOdob1UMZ4N/rAAMqbZckO9O57CKMh5qFvAe1FXVJcYT4q8XHyJqHxh5alzm\niBjbb9eGOBsHCvC2T00hgfNu1v9yzy6yK0TJwYTMm6qkiIgudSP66+dpmDIKotOd\nE4hw1dEs5dmx1SLYa3Ln77mck7xaVYT9fKEtUOEKeg8q6e7BoXMT8nqb1ieTPFI=\n=MBvg\n-----END PGP SIGNATURE-----\n", "payload": "tree 7547f65dd7e2273017a347ec755b5702de1e4625\nparent ca3bddd14e3dd6e6f0448f0408ec04d20234b1a3\nparent a06deb519173b07932b4718cdbd90e47feca17cd\nauthor Yuki Okushi <jtitor@2k36.org> 1652916162 +0900\ncommitter GitHub <noreply@github.com> 1652916162 +0900\n\nRollup merge of #97062 - bjorn3:cg_ssa_driver_refactor, r=compiler-errors\n\nCouple of refactorings to cg_ssa::base::codegen_crate\n\nThis makes the code simpler and easier to read.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/330e03f682dad1fc04a346a855f32063d2d85e0d", "html_url": "https://github.com/rust-lang/rust/commit/330e03f682dad1fc04a346a855f32063d2d85e0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/330e03f682dad1fc04a346a855f32063d2d85e0d/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca3bddd14e3dd6e6f0448f0408ec04d20234b1a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca3bddd14e3dd6e6f0448f0408ec04d20234b1a3", "html_url": "https://github.com/rust-lang/rust/commit/ca3bddd14e3dd6e6f0448f0408ec04d20234b1a3"}, {"sha": "a06deb519173b07932b4718cdbd90e47feca17cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a06deb519173b07932b4718cdbd90e47feca17cd", "html_url": "https://github.com/rust-lang/rust/commit/a06deb519173b07932b4718cdbd90e47feca17cd"}], "stats": {"total": 57, "additions": 24, "deletions": 33}, "files": [{"sha": "d11f1534153ad49761e7e07e5f63c72254139993", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/330e03f682dad1fc04a346a855f32063d2d85e0d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330e03f682dad1fc04a346a855f32063d2d85e0d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=330e03f682dad1fc04a346a855f32063d2d85e0d", "patch": "@@ -15,8 +15,9 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n \n+use rustc_data_structures::sync::par_iter;\n #[cfg(parallel_compiler)]\n-use rustc_data_structures::sync::{par_iter, ParallelIterator};\n+use rustc_data_structures::sync::ParallelIterator;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n@@ -607,6 +608,14 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         second_half.iter().rev().interleave(first_half).copied().collect()\n     };\n \n+    // Calculate the CGU reuse\n+    let cgu_reuse = tcx.sess.time(\"find_cgu_reuse\", || {\n+        codegen_units.iter().map(|cgu| determine_cgu_reuse(tcx, &cgu)).collect::<Vec<_>>()\n+    });\n+\n+    let mut total_codegen_time = Duration::new(0, 0);\n+    let start_rss = tcx.sess.time_passes().then(|| get_resident_set_size());\n+\n     // The non-parallel compiler can only translate codegen units to LLVM IR\n     // on a single thread, leading to a staircase effect where the N LLVM\n     // threads have to wait on the single codegen threads to generate work\n@@ -617,8 +626,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // This likely is a temporary measure. Once we don't have to support the\n     // non-parallel compiler anymore, we can compile CGUs end-to-end in\n     // parallel and get rid of the complicated scheduling logic.\n-    #[cfg(parallel_compiler)]\n-    let pre_compile_cgus = |cgu_reuse: &[CguReuse]| {\n+    let mut pre_compiled_cgus = if cfg!(parallel_compiler) {\n         tcx.sess.time(\"compile_first_CGU_batch\", || {\n             // Try to find one CGU to compile per thread.\n             let cgus: Vec<_> = cgu_reuse\n@@ -638,48 +646,31 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                 })\n                 .collect();\n \n-            (pre_compiled_cgus, start_time.elapsed())\n+            total_codegen_time += start_time.elapsed();\n+\n+            pre_compiled_cgus\n         })\n+    } else {\n+        FxHashMap::default()\n     };\n \n-    #[cfg(not(parallel_compiler))]\n-    let pre_compile_cgus = |_: &[CguReuse]| (FxHashMap::default(), Duration::new(0, 0));\n-\n-    let mut cgu_reuse = Vec::new();\n-    let mut pre_compiled_cgus: Option<FxHashMap<usize, _>> = None;\n-    let mut total_codegen_time = Duration::new(0, 0);\n-    let start_rss = tcx.sess.time_passes().then(|| get_resident_set_size());\n-\n     for (i, cgu) in codegen_units.iter().enumerate() {\n         ongoing_codegen.wait_for_signal_to_codegen_item();\n         ongoing_codegen.check_for_errors(tcx.sess);\n \n-        // Do some setup work in the first iteration\n-        if pre_compiled_cgus.is_none() {\n-            // Calculate the CGU reuse\n-            cgu_reuse = tcx.sess.time(\"find_cgu_reuse\", || {\n-                codegen_units.iter().map(|cgu| determine_cgu_reuse(tcx, &cgu)).collect()\n-            });\n-            // Pre compile some CGUs\n-            let (compiled_cgus, codegen_time) = pre_compile_cgus(&cgu_reuse);\n-            pre_compiled_cgus = Some(compiled_cgus);\n-            total_codegen_time += codegen_time;\n-        }\n-\n         let cgu_reuse = cgu_reuse[i];\n         tcx.sess.cgu_reuse_tracker.set_actual_reuse(cgu.name().as_str(), cgu_reuse);\n \n         match cgu_reuse {\n             CguReuse::No => {\n-                let (module, cost) =\n-                    if let Some(cgu) = pre_compiled_cgus.as_mut().unwrap().remove(&i) {\n-                        cgu\n-                    } else {\n-                        let start_time = Instant::now();\n-                        let module = backend.compile_codegen_unit(tcx, cgu.name());\n-                        total_codegen_time += start_time.elapsed();\n-                        module\n-                    };\n+                let (module, cost) = if let Some(cgu) = pre_compiled_cgus.remove(&i) {\n+                    cgu\n+                } else {\n+                    let start_time = Instant::now();\n+                    let module = backend.compile_codegen_unit(tcx, cgu.name());\n+                    total_codegen_time += start_time.elapsed();\n+                    module\n+                };\n                 // This will unwind if there are errors, which triggers our `AbortCodegenOnDrop`\n                 // guard. Unfortunately, just skipping the `submit_codegened_module_to_llvm` makes\n                 // compilation hang on post-monomorphization errors."}]}