{"sha": "001bd7762c9fc0d032b502b6a50ad67694c30b2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwMWJkNzc2MmM5ZmMwZDAzMmI1MDJiNmE1MGFkNjc2OTRjMzBiMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-17T09:11:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-17T09:11:28Z"}, "message": "Auto merge of #79840 - dvtkrlbs:issue-79667, r=oli-obk\n\nRemove memoization leftovers from constant evaluation machine\n\nCloses #79667", "tree": {"sha": "ef6acd5725ec8f1d3b9502bb0e1c262cbbc4ecd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef6acd5725ec8f1d3b9502bb0e1c262cbbc4ecd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/001bd7762c9fc0d032b502b6a50ad67694c30b2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/001bd7762c9fc0d032b502b6a50ad67694c30b2c", "html_url": "https://github.com/rust-lang/rust/commit/001bd7762c9fc0d032b502b6a50ad67694c30b2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/001bd7762c9fc0d032b502b6a50ad67694c30b2c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdd0a78582efd17f588b35e3e227a65617d5afec", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd0a78582efd17f588b35e3e227a65617d5afec", "html_url": "https://github.com/rust-lang/rust/commit/bdd0a78582efd17f588b35e3e227a65617d5afec"}, {"sha": "a03feaae550b17d53ed5edd137ffaeaa530cae92", "url": "https://api.github.com/repos/rust-lang/rust/commits/a03feaae550b17d53ed5edd137ffaeaa530cae92", "html_url": "https://github.com/rust-lang/rust/commit/a03feaae550b17d53ed5edd137ffaeaa530cae92"}], "stats": {"total": 86, "additions": 17, "deletions": 69}, "files": [{"sha": "80b58642136eeaf1db1097a803f5571ed0afa6b3", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/001bd7762c9fc0d032b502b6a50ad67694c30b2c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001bd7762c9fc0d032b502b6a50ad67694c30b2c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=001bd7762c9fc0d032b502b6a50ad67694c30b2c", "patch": "@@ -132,7 +132,6 @@ pub use self::pointer::{Pointer, PointerArithmetic};\n /// Uniquely identifies one of the following:\n /// - A constant\n /// - A static\n-/// - A const fn where all arguments (if any) are zero-sized types\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, Lift)]\n pub struct GlobalId<'tcx> {"}, {"sha": "f13b4b7b919247893983addd97075617152494e4", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/001bd7762c9fc0d032b502b6a50ad67694c30b2c/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001bd7762c9fc0d032b502b6a50ad67694c30b2c/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=001bd7762c9fc0d032b502b6a50ad67694c30b2c", "patch": "@@ -31,6 +31,19 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n ) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n     debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n     let tcx = *ecx.tcx;\n+    assert!(\n+        cid.promoted.is_some()\n+            || matches!(\n+                ecx.tcx.def_kind(cid.instance.def_id()),\n+                DefKind::Const\n+                    | DefKind::Static\n+                    | DefKind::ConstParam\n+                    | DefKind::AnonConst\n+                    | DefKind::AssocConst\n+            ),\n+        \"Unexpected DefKind: {:?}\",\n+        ecx.tcx.def_kind(cid.instance.def_id())\n+    );\n     let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack);\n@@ -40,15 +53,6 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n     trace!(\"eval_body_using_ecx: pushing stack frame for global: {}{}\", name, prom);\n \n-    // Assert all args (if any) are zero-sized types; `eval_body_using_ecx` doesn't\n-    // make sense if the body is expecting nontrivial arguments.\n-    // (The alternative would be to use `eval_fn_call` with an args slice.)\n-    for arg in body.args_iter() {\n-        let decl = body.local_decls.get(arg).expect(\"arg missing from local_decls\");\n-        let layout = ecx.layout_of(decl.ty.subst(tcx, cid.instance.substs))?;\n-        assert!(layout.is_zst())\n-    }\n-\n     ecx.push_stack_frame(\n         cid.instance,\n         body,"}, {"sha": "72912dd76ff521e13d6cc17420e7f6a96e869ab9", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 4, "deletions": 59, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/001bd7762c9fc0d032b502b6a50ad67694c30b2c/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001bd7762c9fc0d032b502b6a50ad67694c30b2c/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=001bd7762c9fc0d032b502b6a50ad67694c30b2c", "patch": "@@ -1,6 +1,4 @@\n use rustc_middle::mir;\n-use rustc_middle::ty::layout::HasTyCtxt;\n-use rustc_middle::ty::InstanceDef;\n use rustc_middle::ty::{self, Ty};\n use std::borrow::Borrow;\n use std::collections::hash_map::Entry;\n@@ -17,60 +15,13 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::{Align, Size};\n \n use crate::interpret::{\n-    self, compile_time_machine, AllocId, Allocation, Frame, GlobalId, ImmTy, InterpCx,\n-    InterpResult, Memory, OpTy, PlaceTy, Pointer, Scalar,\n+    self, compile_time_machine, AllocId, Allocation, Frame, ImmTy, InterpCx, InterpResult, Memory,\n+    OpTy, PlaceTy, Pointer, Scalar,\n };\n \n use super::error::*;\n \n impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n-    /// Evaluate a const function where all arguments (if any) are zero-sized types.\n-    /// The evaluation is memoized thanks to the query system.\n-    ///\n-    /// Returns `true` if the call has been evaluated.\n-    fn try_eval_const_fn_call(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        args: &[OpTy<'tcx>],\n-    ) -> InterpResult<'tcx, bool> {\n-        trace!(\"try_eval_const_fn_call: {:?}\", instance);\n-        // Because `#[track_caller]` adds an implicit non-ZST argument, we also cannot\n-        // perform this optimization on items tagged with it.\n-        if instance.def.requires_caller_location(self.tcx()) {\n-            return Ok(false);\n-        }\n-        // Only memoize instrinsics. This was added in #79594 while adding the `const_allocate` intrinsic.\n-        // We only memoize intrinsics because it would be unsound to memoize functions\n-        // which might interact with the heap.\n-        // Additionally, const_allocate intrinsic is impure and thus should not be memoized;\n-        // it will not be memoized because it has non-ZST args\n-        if !matches!(instance.def, InstanceDef::Intrinsic(_)) {\n-            return Ok(false);\n-        }\n-        // For the moment we only do this for functions which take no arguments\n-        // (or all arguments are ZSTs) so that we don't memoize too much.\n-        if args.iter().any(|a| !a.layout.is_zst()) {\n-            return Ok(false);\n-        }\n-\n-        let dest = match ret {\n-            Some((dest, _)) => dest,\n-            // Don't memoize diverging function calls.\n-            None => return Ok(false),\n-        };\n-\n-        let gid = GlobalId { instance, promoted: None };\n-\n-        let place = self.eval_to_allocation(gid)?;\n-\n-        self.copy_op(place.into(), dest)?;\n-\n-        self.return_to_block(ret.map(|r| r.1))?;\n-        trace!(\"{:?}\", self.dump_place(*dest));\n-        Ok(true)\n-    }\n-\n     /// \"Intercept\" a function call to a panic-related function\n     /// because we have something special to do for it.\n     /// If this returns successfully (`Ok`), the function should just be evaluated normally.\n@@ -253,7 +204,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n-        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        _ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>, // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n@@ -263,13 +214,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             // Execution might have wandered off into other crates, so we cannot do a stability-\n             // sensitive check here.  But we can at least rule out functions that are not const\n             // at all.\n-            if ecx.tcx.is_const_fn_raw(def.did) {\n-                // If this function is a `const fn` then under certain circumstances we\n-                // can evaluate call via the query system, thus memoizing all future calls.\n-                if ecx.try_eval_const_fn_call(instance, ret, args)? {\n-                    return Ok(None);\n-                }\n-            } else {\n+            if !ecx.tcx.is_const_fn_raw(def.did) {\n                 // Some functions we support even if they are non-const -- but avoid testing\n                 // that for const fn!\n                 ecx.hook_panic_fn(instance, args)?;"}]}