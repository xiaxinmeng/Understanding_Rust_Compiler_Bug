{"sha": "7d953538d10c4a31300afd27f73563adb056beab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkOTUzNTM4ZDEwYzRhMzEzMDBhZmQyN2Y3MzU2M2FkYjA1NmJlYWI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-16T02:36:47Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-13T02:19:51Z"}, "message": "Make Rc DST-compatible", "tree": {"sha": "7c67eded203cffb8a617bfb440e7c2f4008b17b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c67eded203cffb8a617bfb440e7c2f4008b17b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d953538d10c4a31300afd27f73563adb056beab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d953538d10c4a31300afd27f73563adb056beab", "html_url": "https://github.com/rust-lang/rust/commit/7d953538d10c4a31300afd27f73563adb056beab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d953538d10c4a31300afd27f73563adb056beab/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "843db01bd925279da0a56efde532c9e3ecf73610", "url": "https://api.github.com/repos/rust-lang/rust/commits/843db01bd925279da0a56efde532c9e3ecf73610", "html_url": "https://github.com/rust-lang/rust/commit/843db01bd925279da0a56efde532c9e3ecf73610"}], "stats": {"total": 389, "additions": 382, "deletions": 7}, "files": [{"sha": "4e8a7e8bfc9c2c2ba403b7cfde0a1f0969ece57e", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 382, "deletions": 7, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/7d953538d10c4a31300afd27f73563adb056beab/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d953538d10c4a31300afd27f73563adb056beab/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=7d953538d10c4a31300afd27f73563adb056beab", "patch": "@@ -159,7 +159,7 @@ use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n-use core::marker;\n+use core::marker::{self, Sized};\n use core::mem::{self, min_align_of, size_of, forget};\n use core::nonzero::NonZero;\n use core::ops::{Deref, Drop};\n@@ -170,29 +170,67 @@ use core::result::Result;\n use core::result::Result::{Ok, Err};\n use core::intrinsics::assume;\n \n+#[cfg(not(stage0))]\n+use core::intrinsics::drop_in_place;\n+#[cfg(not(stage0))]\n+use core::marker::Unsize;\n+#[cfg(not(stage0))]\n+use core::mem::{min_align_of_val, size_of_val};\n+#[cfg(not(stage0))]\n+use core::ops::CoerceUnsized;\n+\n use heap::deallocate;\n \n+#[cfg(stage0)]\n struct RcBox<T> {\n     strong: Cell<usize>,\n     weak: Cell<usize>,\n-    value: T\n+    value: T,\n+}\n+\n+#[cfg(not(stage0))]\n+struct RcBox<T: ?Sized> {\n+    strong: Cell<usize>,\n+    weak: Cell<usize>,\n+    value: T,\n }\n \n+\n /// A reference-counted pointer type over an immutable value.\n ///\n /// See the [module level documentation](./index.html) for more details.\n+#[cfg(stage0)]\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T> {\n     // FIXME #12808: strange names to try to avoid interfering with field\n     // accesses of the contained type via Deref\n     _ptr: NonZero<*mut RcBox<T>>,\n }\n+#[cfg(not(stage0))]\n+#[unsafe_no_drop_flag]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Rc<T: ?Sized> {\n+    // FIXME #12808: strange names to try to avoid interfering with field\n+    // accesses of the contained type via Deref\n+    _ptr: NonZero<*mut RcBox<T>>,\n+}\n \n+#[cfg(stage0)]\n impl<T> !marker::Send for Rc<T> {}\n \n+#[cfg(not(stage0))]\n+impl<T: ?Sized> !marker::Send for Rc<T> {}\n+\n+#[cfg(stage0)]\n impl<T> !marker::Sync for Rc<T> {}\n \n+#[cfg(not(stage0))]\n+impl<T: ?Sized> !marker::Sync for Rc<T> {}\n+\n+#[cfg(not(stage0))] // SNAP c64d671\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}\n+\n impl<T> Rc<T> {\n     /// Constructs a new `Rc<T>`.\n     ///\n@@ -212,14 +250,39 @@ impl<T> Rc<T> {\n                 // the allocation while the strong destructor is running, even\n                 // if the weak pointer is stored inside the strong one.\n                 _ptr: NonZero::new(boxed::into_raw(box RcBox {\n-                    value: value,\n                     strong: Cell::new(1),\n-                    weak: Cell::new(1)\n+                    weak: Cell::new(1),\n+                    value: value\n                 })),\n             }\n         }\n     }\n+}\n \n+#[cfg(not(stage0))]\n+impl<T: ?Sized> Rc<T> {\n+    /// Downgrades the `Rc<T>` to a `Weak<T>` reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    /// ```\n+    #[unstable(feature = \"alloc\",\n+               reason = \"Weak pointers may not belong in this module\")]\n+    pub fn downgrade(&self) -> Weak<T> {\n+        self.inc_weak();\n+        Weak { _ptr: self._ptr }\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl<T> Rc<T> {\n     /// Downgrades the `Rc<T>` to a `Weak<T>` reference.\n     ///\n     /// # Examples\n@@ -241,14 +304,24 @@ impl<T> Rc<T> {\n }\n \n /// Get the number of weak references to this value.\n+#[cfg(stage0)]\n #[inline]\n #[unstable(feature = \"alloc\")]\n pub fn weak_count<T>(this: &Rc<T>) -> usize { this.weak() - 1 }\n+#[cfg(not(stage0))]\n+#[inline]\n+#[unstable(feature = \"alloc\")]\n+pub fn weak_count<T: ?Sized>(this: &Rc<T>) -> usize { this.weak() - 1 }\n \n /// Get the number of strong references to this value.\n+#[cfg(stage0)]\n #[inline]\n #[unstable(feature = \"alloc\")]\n pub fn strong_count<T>(this: &Rc<T>) -> usize { this.strong() }\n+#[cfg(not(stage0))]\n+#[inline]\n+#[unstable(feature = \"alloc\")]\n+pub fn strong_count<T: ?Sized>(this: &Rc<T>) -> usize { this.strong() }\n \n /// Returns true if there are no other `Rc` or `Weak<T>` values that share the\n /// same inner value.\n@@ -365,6 +438,7 @@ impl<T: Clone> Rc<T> {\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Deref for Rc<T> {\n     type Target = T;\n@@ -374,7 +448,19 @@ impl<T> Deref for Rc<T> {\n         &self.inner().value\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Deref for Rc<T> {\n+    type Target = T;\n+\n+    #[inline(always)]\n+    fn deref(&self) -> &T {\n+        &self.inner().value\n+    }\n+}\n \n+#[cfg(stage0)] // SNAP c64d671\n+#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n@@ -425,6 +511,61 @@ impl<T> Drop for Rc<T> {\n     }\n }\n \n+#[cfg(not(stage0))] // SNAP c64d671\n+#[unsafe_destructor]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Drop for Rc<T> {\n+    /// Drops the `Rc<T>`.\n+    ///\n+    /// This will decrement the strong reference count. If the strong reference\n+    /// count becomes zero and the only other references are `Weak<T>` ones,\n+    /// `drop`s the inner value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// {\n+    ///     let five = Rc::new(5);\n+    ///\n+    ///     // stuff\n+    ///\n+    ///     drop(five); // explicit drop\n+    /// }\n+    /// {\n+    ///     let five = Rc::new(5);\n+    ///\n+    ///     // stuff\n+    ///\n+    /// } // implicit drop\n+    /// ```\n+    fn drop(&mut self) {\n+        unsafe {\n+            let ptr = *self._ptr;\n+            if !(*(&ptr as *const _ as *const *const ())).is_null() {\n+                self.dec_strong();\n+                if self.strong() == 0 {\n+                    // destroy the contained object\n+                    drop_in_place(&mut (*ptr).value);\n+\n+                    // remove the implicit \"strong weak\" pointer now that we've\n+                    // destroyed the contents.\n+                    self.dec_weak();\n+\n+                    if self.weak() == 0 {\n+                        deallocate(ptr as *mut u8,\n+                                   size_of_val(&*ptr),\n+                                   min_align_of_val(&*ptr))\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Rc<T> {\n \n@@ -449,6 +590,31 @@ impl<T> Clone for Rc<T> {\n         Rc { _ptr: self._ptr }\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Clone for Rc<T> {\n+\n+    /// Makes a clone of the `Rc<T>`.\n+    ///\n+    /// When you clone an `Rc<T>`, it will create another pointer to the data and\n+    /// increase the strong reference counter.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    ///\n+    /// five.clone();\n+    /// ```\n+    #[inline]\n+    fn clone(&self) -> Rc<T> {\n+        self.inc_strong();\n+        Rc { _ptr: self._ptr }\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Rc<T> {\n@@ -610,27 +776,50 @@ impl<T: Ord> Ord for Rc<T> {\n     fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n \n-// FIXME (#18248) Make `T` `Sized?`\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Hash> Hash for Rc<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         (**self).hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized+Hash> Hash for Rc<T> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        (**self).hash(state);\n+    }\n+}\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display> fmt::Display for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized+fmt::Display> fmt::Display for Rc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&**self, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized+fmt::Debug> fmt::Debug for Rc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&**self, f)\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Pointer for Rc<T> {\n@@ -645,6 +834,7 @@ impl<T> fmt::Pointer for Rc<T> {\n /// dropped.\n ///\n /// See the [module level documentation](./index.html) for more.\n+#[cfg(stage0)]\n #[unsafe_no_drop_flag]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n@@ -653,12 +843,28 @@ pub struct Weak<T> {\n     // field accesses of the contained type via Deref\n     _ptr: NonZero<*mut RcBox<T>>,\n }\n+#[cfg(not(stage0))]\n+#[unsafe_no_drop_flag]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n+pub struct Weak<T: ?Sized> {\n+    // FIXME #12808: strange names to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _ptr: NonZero<*mut RcBox<T>>,\n+}\n \n+#[cfg(stage0)]\n impl<T> !marker::Send for Weak<T> {}\n+#[cfg(not(stage0))]\n+impl<T: ?Sized> !marker::Send for Weak<T> {}\n \n+#[cfg(stage0)]\n impl<T> !marker::Sync for Weak<T> {}\n+#[cfg(not(stage0))]\n+impl<T: ?Sized> !marker::Sync for Weak<T> {}\n \n \n+#[cfg(stage0)]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T> Weak<T> {\n@@ -691,7 +897,42 @@ impl<T> Weak<T> {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n+impl<T: ?Sized> Weak<T> {\n \n+    /// Upgrades a weak reference to a strong reference.\n+    ///\n+    /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n+    ///\n+    /// Returns `None` if there were no strong references and the data was\n+    /// destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    ///\n+    /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n+    /// ```\n+    pub fn upgrade(&self) -> Option<Rc<T>> {\n+        if self.strong() == 0 {\n+            None\n+        } else {\n+            self.inc_strong();\n+            Some(Rc { _ptr: self._ptr })\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)] // SNAP c64d671\n+#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n@@ -736,6 +977,53 @@ impl<T> Drop for Weak<T> {\n     }\n }\n \n+#[cfg(not(stage0))] // SNAP c64d671\n+#[unsafe_destructor]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Drop for Weak<T> {\n+    /// Drops the `Weak<T>`.\n+    ///\n+    /// This will decrement the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// {\n+    ///     let five = Rc::new(5);\n+    ///     let weak_five = five.downgrade();\n+    ///\n+    ///     // stuff\n+    ///\n+    ///     drop(weak_five); // explicit drop\n+    /// }\n+    /// {\n+    ///     let five = Rc::new(5);\n+    ///     let weak_five = five.downgrade();\n+    ///\n+    ///     // stuff\n+    ///\n+    /// } // implicit drop\n+    /// ```\n+    fn drop(&mut self) {\n+        unsafe {\n+            let ptr = *self._ptr;\n+            if !(*(&ptr as *const _ as *const *const ())).is_null() {\n+                self.dec_weak();\n+                // the weak count starts at 1, and will only go to zero if all\n+                // the strong pointers have disappeared.\n+                if self.weak() == 0 {\n+                    deallocate(ptr as *mut u8, size_of_val(&*ptr),\n+                               min_align_of_val(&*ptr))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T> Clone for Weak<T> {\n@@ -760,14 +1048,48 @@ impl<T> Clone for Weak<T> {\n         Weak { _ptr: self._ptr }\n     }\n }\n+#[cfg(not(stage0))]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n+impl<T: ?Sized> Clone for Weak<T> {\n+\n+    /// Makes a clone of the `Weak<T>`.\n+    ///\n+    /// This increases the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// let weak_five = Rc::new(5).downgrade();\n+    ///\n+    /// weak_five.clone();\n+    /// ```\n+    #[inline]\n+    fn clone(&self) -> Weak<T> {\n+        self.inc_weak();\n+        Weak { _ptr: self._ptr }\n+    }\n+}\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"(Weak)\")\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized+fmt::Debug> fmt::Debug for Weak<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"(Weak)\")\n+    }\n+}\n \n+#[cfg(stage0)]\n #[doc(hidden)]\n trait RcBoxPtr<T> {\n     fn inner(&self) -> &RcBox<T>;\n@@ -790,7 +1112,31 @@ trait RcBoxPtr<T> {\n     #[inline]\n     fn dec_weak(&self) { self.inner().weak.set(self.weak() - 1); }\n }\n+#[cfg(not(stage0))]\n+#[doc(hidden)]\n+trait RcBoxPtr<T: ?Sized> {\n+    fn inner(&self) -> &RcBox<T>;\n+\n+    #[inline]\n+    fn strong(&self) -> usize { self.inner().strong.get() }\n+\n+    #[inline]\n+    fn inc_strong(&self) { self.inner().strong.set(self.strong() + 1); }\n+\n+    #[inline]\n+    fn dec_strong(&self) { self.inner().strong.set(self.strong() - 1); }\n+\n+    #[inline]\n+    fn weak(&self) -> usize { self.inner().weak.get() }\n+\n+    #[inline]\n+    fn inc_weak(&self) { self.inner().weak.set(self.weak() + 1); }\n+\n+    #[inline]\n+    fn dec_weak(&self) { self.inner().weak.set(self.weak() - 1); }\n+}\n \n+#[cfg(stage0)]\n impl<T> RcBoxPtr<T> for Rc<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n@@ -799,12 +1145,27 @@ impl<T> RcBoxPtr<T> for Rc<T> {\n             // the contract anyway.\n             // This allows the null check to be elided in the destructor if we\n             // manipulated the reference count in the same function.\n-            assume(!self._ptr.is_null());\n+            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n+            &(**self._ptr)\n+        }\n+    }\n+}\n+#[cfg(not(stage0))]\n+impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n+    #[inline(always)]\n+    fn inner(&self) -> &RcBox<T> {\n+        unsafe {\n+            // Safe to assume this here, as if it weren't true, we'd be breaking\n+            // the contract anyway.\n+            // This allows the null check to be elided in the destructor if we\n+            // manipulated the reference count in the same function.\n+            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n             &(**self._ptr)\n         }\n     }\n }\n \n+#[cfg(stage0)]\n impl<T> RcBoxPtr<T> for Weak<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n@@ -813,7 +1174,21 @@ impl<T> RcBoxPtr<T> for Weak<T> {\n             // the contract anyway.\n             // This allows the null check to be elided in the destructor if we\n             // manipulated the reference count in the same function.\n-            assume(!self._ptr.is_null());\n+            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n+            &(**self._ptr)\n+        }\n+    }\n+}\n+#[cfg(not(stage0))]\n+impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n+    #[inline(always)]\n+    fn inner(&self) -> &RcBox<T> {\n+        unsafe {\n+            // Safe to assume this here, as if it weren't true, we'd be breaking\n+            // the contract anyway.\n+            // This allows the null check to be elided in the destructor if we\n+            // manipulated the reference count in the same function.\n+            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n             &(**self._ptr)\n         }\n     }"}]}