{"sha": "d3409f63687dae6096f4ed01a5ea6981a3cf0f65", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNDA5ZjYzNjg3ZGFlNjA5NmY0ZWQwMWE1ZWE2OTgxYTNjZjBmNjU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-13T01:27:03Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-13T01:27:03Z"}, "message": "Finish the majority of statement -> expression rearrangement in manual.", "tree": {"sha": "08e115e280f9abc21df22a1496549af1da3c1145", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08e115e280f9abc21df22a1496549af1da3c1145"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3409f63687dae6096f4ed01a5ea6981a3cf0f65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3409f63687dae6096f4ed01a5ea6981a3cf0f65", "html_url": "https://github.com/rust-lang/rust/commit/d3409f63687dae6096f4ed01a5ea6981a3cf0f65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3409f63687dae6096f4ed01a5ea6981a3cf0f65/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de0175abed80b13d8d8528002fe637d8c9687c93", "url": "https://api.github.com/repos/rust-lang/rust/commits/de0175abed80b13d8d8528002fe637d8c9687c93", "html_url": "https://github.com/rust-lang/rust/commit/de0175abed80b13d8d8528002fe637d8c9687c93"}], "stats": {"total": 761, "additions": 411, "deletions": 350}, "files": [{"sha": "49c626850a318c633ab4cca547039d1836b3f356", "filename": "doc/rust.texi", "status": "modified", "additions": 411, "deletions": 350, "changes": 761, "blob_url": "https://github.com/rust-lang/rust/blob/d3409f63687dae6096f4ed01a5ea6981a3cf0f65/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/d3409f63687dae6096f4ed01a5ea6981a3cf0f65/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=d3409f63687dae6096f4ed01a5ea6981a3cf0f65", "patch": "@@ -450,7 +450,7 @@ similar fashion to the way the type system permits user-defined types.\n \n A short way of thinking of this is: types statically model values,\n typestates statically model @emph{assertions that hold} before and\n-after statements.\n+after statements and expressions.\n \n @end itemize\n \n@@ -571,8 +571,9 @@ Additional specific influences can be seen from the following languages:\n * Ref.Task::                    Semantic model of tasks.\n * Ref.Item::                    The components of a module.\n * Ref.Type::                    The types of values held in memory.\n-* Ref.Expr::                    Parsed and primitive expressions.\n-* Ref.Stmt::                    Executable statements.\n+* Ref.Typestate::               Predicates that hold at points in time.\n+* Ref.Stmt::                    Components of an executable block.\n+* Ref.Expr::                    Units of execution and evaluation.\n * Ref.Run::                     Organization of runtime services.\n @end menu\n \n@@ -1028,7 +1029,7 @@ the associated value, starting from the task stack frame, at run time.\n In some contexts, the Rust grammar accepts a general @emph{path}, but a\n subsequent syntactic restriction requires the path to be an lval or a name. In\n other words: in some contexts an lval is required (for example, on the left\n-hand side of the copy operator, @pxref{Ref.Stmt.Copy}) and in other contexts a\n+hand side of the copy operator, @pxref{Ref.Expr.Copy}) and in other contexts a\n name is required (for example, as a type parameter, @pxref{Ref.Item}). In no\n case is the grammar made ambiguous by accepting a general path and restricting\n allowed paths to names or lvals after parsing. These restrictions are noted in\n@@ -1532,8 +1533,8 @@ possibility, a semi-synchronous send operation is possible, which blocks until\n there is room in the existing queue and then executes an asynchronous send.\n \n The asynchronous message-send operator is @code{<+}. The semi-synchronous\n-message-send operator is @code{<|}. @xref{Ref.Stmt.Send}. The message-receive\n-operator is @code{<-}. @xref{Ref.Stmt.Recv}.\n+message-send operator is @code{<|}. @xref{Ref.Expr.Send}. The message-receive\n+operator is @code{<-}. @xref{Ref.Expr.Recv}.\n \n @node       Ref.Task.Life\n @subsection Ref.Task.Life\n@@ -1813,7 +1814,7 @@ A function may have an @emph{effect}, which may be either @code{impure} or\n @dfn{pure}.\n \n Any pure boolean function is also called a @emph{predicate}, and may be used\n-as part of the static typestate system. @xref{Ref.Stmt.Stat.Constr}.\n+as part of the static typestate system. @xref{Ref.Typestate.Constr}.\n \n An example of a function:\n @example\n@@ -1837,7 +1838,7 @@ their execution before returning or tail-calling.\n Putting a value is similar to returning a value -- the argument to @code{put}\n is copied into the caller's frame and control transfers back to the caller --\n but the iterator frame is only @emph{suspended} during the put, and will be\n-@emph{resumed} at the statement after the @code{put}, on the next iteration of\n+@emph{resumed} at the point after the @code{put}, on the next iteration of\n the caller's loop.\n \n The output type of an iterator is the type of value that the function will\n@@ -1846,7 +1847,7 @@ of type @code{()} and completes its execution.\n \n An iterator can only be called in the loop header of a matching @code{for\n each} loop or as the argument in a @code{put each} expression.\n-@xref{Ref.Stmt.Foreach}.\n+@xref{Ref.Expr.Foreach}.\n \n An example of an iterator:\n @example\n@@ -2060,7 +2061,7 @@ some non-@code{any} type @var{T} and a reflection of the type @var{T}.\n \n Values of type @code{any} can be used in an @code{alt type} expression, in\n which the reflection is used to select a block corresponding to a particular\n-type extraction. @xref{Ref.Stmt.Alt}.\n+type extraction. @xref{Ref.Expr.Alt}.\n \n @node       Ref.Type.Mach\n @subsection Ref.Type.Mach\n@@ -2306,7 +2307,7 @@ by named reference to a @emph{tag item} declaration. @xref{Ref.Item.Tag}.\n \n The function type-constructor @code{fn} forms new function types. A function\n type consists of a sequence of input slots, an optional set of input\n-constraints (@pxref{Ref.Stmt.Stat.Constr}), an output slot, and an\n+constraints (@pxref{Ref.Typestate.Constr}), an output slot, and an\n @emph{effect}. @xref{Ref.Item.Fn}.\n \n An example of a @code{fn} type:\n@@ -2498,14 +2499,14 @@ give_ints(t2);\n @cindex Constrained types\n \n A @dfn{constrained type} is a type that carries a @emph{formal constraint}\n-(@pxref{Ref.Stmt.Stat.Constr}), which is similar to a normal constraint except\n+(@pxref{Ref.Typestate.Constr}), which is similar to a normal constraint except\n that the @emph{base name} of any slots mentioned in the constraint must be the\n special @emph{formal symbol} @emph{*}.\n \n When a constrained type is instantiated in a particular slot declaration, the\n formal symbol in the constraint is replaced with the name of the declared slot\n and the resulting constraint is checked immediately after the slot is\n-declared. @xref{Ref.Stmt.Check}.\n+declared. @xref{Ref.Expr.Check}.\n \n An example of a constrained type with two separate instantiations:\n @example\n@@ -2525,136 +2526,118 @@ let ordered_range rng2 = rec(low=15, high=17);\n \n @emph{TODO}.\n \n-@page\n-@node    Ref.Expr\n-@section Ref.Expr\n-@c * Ref.Expr::               Parsed and primitive expressions.\n-@cindex Expressions\n-\n-Rust has two kinds of expressions: @emph{parsed expressions} and\n-@emph{primitive expressions}.  The former are syntactic sugar and are\n-eliminated during parsing. The latter are very minimal, consisting only of\n-paths and primitive literals, possibly combined via a single level\n-(non-recursive) unary or binary machine-level operation (ALU or\n-FPU). @xref{Ref.Path}.\n-\n-For the most part, Rust semantics are defined in terms of @emph{statements},\n-which parsed expressions are desugared to. The desugaring is defined in the\n-grammar. @xref{Ref.Gram}. The residual primitive statements appear only in the\n-right hand side of copy statements, @xref{Ref.Stmt.Copy}.\n \n-@page\n-@node    Ref.Stmt\n-@section Ref.Stmt\n-@c * Ref.Stmt::               Executable statements.\n-@cindex Statements\n \n-A @dfn{statement} is a component of a block, which is in turn a component of\n-an outer block, a function or an iterator. When a function is spawned into a\n-task, the task @emph{executes} statements in an order determined by the body\n-of the enclosing structure. Each statement causes the task to perform certain\n-actions.\n-\n-@menu\n-* Ref.Stmt.Stat::               The static typestate system of statement analysis.\n-* Ref.Stmt.Decl::               Statement declaring an item or slot.\n-* Ref.Stmt.Copy::               Statement for copying a value.\n-* Ref.Stmt.Spawn::              Statements for creating new tasks.\n-* Ref.Stmt.Send::               Statements for sending a value into a channel.\n-* Ref.Stmt.Recv::               Statement for receiving a value from a channel.\n-* Ref.Stmt.Call::               Statement for calling a function.\n-* Ref.Stmt.Bind::               Statement for binding arguments to functions.\n-* Ref.Stmt.Ret::                Statement for stopping and producing a value.\n-* Ref.Stmt.Be::                 Statement for stopping and executing a tail call.\n-* Ref.Stmt.Put::                Statement for pausing and producing a value.\n-* Ref.Stmt.Fail::               Statement for causing task failure.\n-* Ref.Stmt.Log::                Statement for logging values to diagnostic buffers.\n-* Ref.Stmt.Note::               Statement for logging values during failure.\n-* Ref.Stmt.While::              Statement for simple conditional looping.\n-* Ref.Stmt.Break::              Statement for terminating a loop.\n-* Ref.Stmt.Cont::               Statement for terminating a single loop iteration.\n-* Ref.Stmt.For::                Statement for looping over strings and vectors.\n-* Ref.Stmt.Foreach::            Statement for looping via an iterator.\n-* Ref.Stmt.If::                 Statement for simple conditional branching.\n-* Ref.Stmt.Alt::                Statement for complex conditional branching.\n-* Ref.Stmt.Prove::              Statement for static assertion of typestate.\n-* Ref.Stmt.Check::              Statement for dynamic assertion of typestate.\n-* Ref.Stmt.IfCheck::            Statement for dynamic testing of typestate.\n-@end menu\n-\n-@node       Ref.Stmt.Stat\n-@subsection Ref.Stmt.Stat\n-@c * Ref.Stmt.Stat::         The static typestate system of statement analysis.\n+* Ref.Typestate::            The static system of predicate analysis.\n+@node       Ref.Typestate\n+@section    Ref.Typestate\n+@c * Ref.Typestate::         The static system of predicate analysis.\n @cindex Typestate system\n \n-Statements have a detailed static semantics. The static semantics determine,\n-on a statement-by-statement basis, the @emph{effects} the statement has on its\n-environment, as well the @emph{legality} of the statement in its environment.\n+Rust programs have a static semantics that determine the types of values\n+produced by each expression, as well as the @emph{predicates} that hold over\n+slots in the environment at each point in time during execution.\n \n-The legality of a statement is partly governed by syntactic rules, partly by\n-its conformance to the types of value it affects, and partly by a\n-statement-oriented static dataflow analysis. This section describes the\n-statement-oriented static dataflow analysis, also called the @emph{typestate}\n-system.\n+The latter semantics -- the dataflow analysis of predicates holding over slots\n+-- is called the @emph{typestate} system.\n \n @menu\n-* Ref.Stmt.Stat.Point::         Inter-statement positions of logical judgements.\n-* Ref.Stmt.Stat.CFG::           The control-flow graph formed by statements.\n-* Ref.Stmt.Stat.Constr::        Predicates applied to slots.\n-* Ref.Stmt.Stat.Cond::          Constraints required and implied by a statement.\n-* Ref.Stmt.Stat.Typestate::     Constraints that hold at points.\n-* Ref.Stmt.Stat.Check::         Relating dynamic state to static typestate.\n+* Ref.Typestate.Point::         Discrete positions in execution.\n+* Ref.Typestate.CFG::           The control-flow graph formed by points.\n+* Ref.Typestate.Constr::        Predicates applied to slots.\n+* Ref.Typestate.Cond::          Constraints required and implied by a point.\n+* Ref.Typestate.State::         Constraints that hold at points.\n+* Ref.Typestate.Check::         Relating dynamic state to static typestate.\n @end menu\n \n-@node          Ref.Stmt.Stat.Point\n-@subsubsection Ref.Stmt.Stat.Point\n-@c * Ref.Stmt.Stat.Point::         Inter-statement positions of logical judgements.\n+@node       Ref.Typestate.Point\n+@subsection Ref.Typestate.Point\n+@c * Ref.Typestate.Point::         Discrete positions in execution.\n @cindex Points\n \n-A @dfn{point} exists before and after any statement in a Rust program.\n+Control flows from statement to statement in a block, and through the\n+evaluation of each expression, from one sub-expression to another. This\n+sequential control flow is specified as a set of @dfn{points}, each of which\n+has a set of points before and after it in the implied control flow.\n+\n For example, this code:\n \n @example\n  s = \"hello, world\";\n  print(s);\n @end example\n \n-Consists of two statements and four points:\n+Consists of 2 statements, 3 expressions and 12 points:\n \n @itemize\n @item the point before the first statement\n+@item the point before evaluating the static initializer @code{\"hello, world\"}\n+@item the point after evaluating the static initializer @code{\"hello, world\"}\n @item the point after the first statement\n @item the point before the second statement\n+@item the point before evaluating the function value @code{print}\n+@item the point after evaluating the function value @code{print}\n+@item the point before evaluating the arguments to @code{print}\n+@item the point before evaluating the symbol @code{s}\n+@item the point after evaluating the symbol @code{s}\n+@item the point after evaluating the arguments to @code{print}\n @item the point after the second statement\n @end itemize\n \n-The typestate system reasons over points, rather than statements. This may\n-seem counter-intuitive, but points are the more primitive concept. Another way\n-of thinking about a point is as a set of @emph{instants in time} at which the\n-state of a task is fixed. By contrast, a statement represents a @emph{duration\n-in time}, during which the state of the task changes. The typestate system is\n-concerned with constraining the possible states of a task's memory at\n-@emph{instants}; it is meaningless to speak of the state of a task's memory\n-``at'' a statement, as each statement is likely to change the contents of\n-memory.\n+Whereas this code:\n+\n+@example\n+ print(x() + y());\n+@end example\n+\n+Consists of 1 statement, 7 expressions and 14 points:\n+\n+@itemize\n+@item the point before the statement\n+@item the point before evaluating the function value @code{print}\n+@item the point after evaluating the function value @code{print}\n+@item the point before evaluating the arguments to @code{print}\n+@item the point before evaluating the arguments to @code{+}\n+@item the point before evaluating the function value @code{x}\n+@item the point after evaluating the function value @code{x}\n+@item the point before evaluating the arguments to @code{x}\n+@item the point after evaluating the arguments to @code{x}\n+@item the point before evaluating the function value @code{y}\n+@item the point after evaluating the function value @code{y}\n+@item the point before evaluating the arguments to @code{y}\n+@item the point after evaluating the arguments to @code{y}\n+@item the point after evaluating the arguments to @code{+}\n+@item the point after evaluating the arguments to @code{print}\n+@end itemize\n+\n \n-@node          Ref.Stmt.Stat.CFG\n-@subsubsection Ref.Stmt.Stat.CFG\n-@c * Ref.Stmt.Stat.CFG::           The control-flow graph formed by statements.\n+The typestate system reasons over points, rather than statements or\n+expressions. This may seem counter-intuitive, but points are the more\n+primitive concept. Another way of thinking about a point is as a set of\n+@emph{instants in time} at which the state of a task is fixed. By contrast, a\n+statement or expression represents a @emph{duration in time}, during which the\n+state of the task changes. The typestate system is concerned with constraining\n+the possible states of a task's memory at @emph{instants}; it is meaningless\n+to speak of the state of a task's memory ``at'' a statement or expression, as\n+each statement or expression is likely to change the contents of memory.\n+\n+@node       Ref.Typestate.CFG\n+@subsection Ref.Typestate.CFG\n+@c * Ref.Typestate.CFG::           The control-flow graph formed by points.\n @cindex Control-flow graph\n \n Each @emph{point} can be considered a vertex in a directed @emph{graph}. Each\n-kind of statement implies a single edge in this graph between the point before\n-the statement and the point after it, as well as a set of zero or more edges\n-from the points of the statement to points before other statements. The edges\n-between points represent @emph{possible} indivisible control transfers that\n-might occur during execution.\n+kind of expression or statement implies a number of points @emph{and edges} in\n+this graph. The edges connect the points within each statement or expression,\n+as well as between those points and those of nearby statements and expressions\n+in the program. The edges between points represent @emph{possible} indivisible\n+control transfers that might occur during execution.\n \n This implicit graph is called the @dfn{control-flow graph}, or @dfn{CFG}.\n \n-@node          Ref.Stmt.Stat.Constr\n-@subsubsection Ref.Stmt.Stat.Constr\n-@c * Ref.Stmt.Stat.Constr::          Predicates applied to slots.\n+@node       Ref.Typestate.Constr\n+@subsection Ref.Typestate.Constr\n+@c * Ref.Typestate.Constr::          Predicates applied to slots.\n @cindex Predicate\n @cindex Constraint\n \n@@ -2684,9 +2667,9 @@ Predicates can only apply to slots holding immutable values. The slots a\n predicate applies to can themselves be mutable, but the types of values held\n in those slots must be immutable.\n \n-@node          Ref.Stmt.Stat.Cond\n-@subsubsection Ref.Stmt.Stat.Cond\n-@c * Ref.Stmt.Stat.Cond::          Constraints required and implied by a statement.\n+@node       Ref.Typestate.Cond\n+@subsection Ref.Typestate.Cond\n+@c * Ref.Typestate.Cond::          Constraints required and implied by a point.\n @cindex Condition\n @cindex Precondition\n @cindex Postcondition\n@@ -2696,32 +2679,33 @@ A @dfn{condition} is a set of zero or more constraints.\n Each @emph{point} has an associated @emph{condition}:\n \n @itemize\n-@item The @dfn{precondition} of a statement is the condition the statement\n-requires in the point before the condition.\n-@item The @dfn{postcondition} of a statement is the condition the statement\n-enforces in the point after the statement.\n+@item The @dfn{precondition} of a statement or expression is the condition\n+required at in the point before it.\n+@item The @dfn{postcondition} of a statement or expression is the condition\n+enforced in the point after it.\n @end itemize\n \n Any constraint present in the precondition and @emph{absent} in the\n-postcondition is considered to be @emph{dropped} by the statement.\n+postcondition is considered to be @emph{dropped} by the statement or\n+expression.\n \n-@node          Ref.Stmt.Stat.Typestate\n-@subsubsection Ref.Stmt.Stat.Typestate\n-@c * Ref.Stmt.Stat.Typestate::     Constraints that hold at points.\n+@node       Ref.Typestate.State\n+@subsection Ref.Typestate.State\n+@c * Ref.Typestate.State::     Constraints that hold at points.\n @cindex Typestate\n @cindex Prestate\n @cindex Poststate\n \n-The typestate checking system @emph{calculates} an additional\n-condition for each point called its typestate. For a given statement,\n-we call the two typestates associated with its two points the prestate\n-and a poststate.\n+The typestate checking system @emph{calculates} an additional condition for\n+each point called its typestate. For a given statement or expression, we call\n+the two typestates associated with its two points the prestate and a\n+poststate.\n \n @itemize\n-@item The @dfn{prestate} of a statement is the typestate of the point\n-before the statement.\n-@item The @dfn{poststate} of a statement is the typestate of the point\n-after the statement.\n+@item The @dfn{prestate} of a statement or expression is the typestate of the\n+point before it.\n+@item The @dfn{poststate} of a statement or expression is the typestate of the\n+point after it.\n @end itemize\n \n A @dfn{typestate} is a condition that has @emph{been determined by the\n@@ -2731,17 +2715,17 @@ typestate algorithm; prestates and poststates are @emph{outputs} from the\n typestate algorithm.\n \n The typestate algorithm analyses the preconditions and postconditions of every\n-statement in a block, and computes a condition for each\n+statement and expression in a block, and computes a condition for each\n typestate. Specifically:\n \n @itemize\n @item Initially, every typestate is empty.\n-@item Each statement's poststate is given the union of the statement's\n+@item Each statement or expression's poststate is given the union of the its\n prestate, precondition, and postcondition.\n-@item Each statement's poststate has the difference between the statement's\n+@item Each statement or expression's poststate has the difference between its\n precondition and postcondition removed.\n-@item Each statement's prestate is given the intersection of the poststates\n-of every parent statement in the CFG.\n+@item Each statement or expression's prestate is given the intersection of the\n+poststates of every predecessor point in the CFG.\n @item The previous three steps are repeated until no typestates in the\n block change.\n @end itemize\n@@ -2756,21 +2740,21 @@ prestate. If any preconditions are not satisfied, the mismatch is considered a\n static (compile-time) error.\n \n \n-@node          Ref.Stmt.Stat.Check\n-@subsubsection Ref.Stmt.Stat.Check\n-@c * Ref.Stmt.Stat.Check::         Relating dynamic state to static typestate.\n+@node       Ref.Typestate.Check\n+@subsection Ref.Typestate.Check\n+@c * Ref.Typestate.Check::         Relating dynamic state to static typestate.\n @cindex Check statement\n @cindex Assertions, see @i{Check statement}\n \n The key mechanism that connects run-time semantics and compile-time analysis\n-of typestates is the use of @code{check} statements. @xref{Ref.Stmt.Check}. A\n-@code{check} statement guarantees that @emph{if} control were to proceed past\n+of typestates is the use of @code{check} expressions. @xref{Ref.Expr.Check}. A\n+@code{check} expression guarantees that @emph{if} control were to proceed past\n it, the predicate associated with the @code{check} would have succeeded, so\n the constraint being checked @emph{statically} holds in subsequent\n-statements.@footnote{A @code{check} statement is similar to an @code{assert}\n+points.@footnote{A @code{check} expression is similar to an @code{assert}\n call in a C program, with the significant difference that the Rust compiler\n-@emph{tracks} the constraint that each @code{check} statement\n-enforces. Naturally, @code{check} statements cannot be omitted from a\n+@emph{tracks} the constraint that each @code{check} expression\n+enforces. Naturally, @code{check} expressions cannot be omitted from a\n ``production build'' of a Rust program the same way @code{asserts} are\n frequently disabled in deployed C programs.}\n \n@@ -2782,13 +2766,50 @@ system does is track which of those predicates -- whatever they calculate --\n @emph{must have been checked already} in order for program control to reach a\n particular point in the CFG. The fundamental building block, therefore, is the\n @code{check} statement, which tells the typestate system ``if control passes\n-this statement, the checked predicate holds''.\n+this point, the checked predicate holds''.\n \n From this building block, constraints can be propagated to function signatures\n and constrained types, and the responsibility to @code{check} a constraint\n pushed further and further away from the site at which the program requires it\n to hold in order to execute properly.\n \n+\n+@page\n+@node    Ref.Stmt\n+@section Ref.Stmt\n+@c * Ref.Stmt::               Components of an executable block.\n+@cindex Statements\n+\n+A @dfn{statement} is a component of a block, which is in turn a component of\n+an outer block-expression, a function or an iterator. When a function is\n+spawned into a task, the task @emph{executes} statements in an order\n+determined by the body of the enclosing structure. Each statement causes the\n+task to perform certain actions.\n+\n+Rust has two kinds of statement: declarations and expressions.\n+\n+A declaration serves to introduce a @emph{name} that can be used in the block\n+@emph{scope} enclosing the statement: all statements before and after the\n+name, from the previous opening curly-brace (@code{@{}) up to the next closing\n+curly-brace (@code{@}}).\n+\n+An expression serves the dual roles of causing side effects and producing a\n+@emph{value}. Expressions are said to @emph{evaluate to} a value, and the side\n+effects are caused during @emph{evaluation}. Many expressions contain\n+sub-expressions as operands; the definition of each kind of expression\n+dictates whether or not, and in which order, it will evaluate its\n+sub-expressions, and how the expression's value derives from the value of its\n+sub-expressions.\n+\n+In this way, the structure of execution -- both the overall sequence of\n+observable side effects and the final produced value -- is dictated by the\n+structure of expressions. Blocks themselves are expressions, so the nesting\n+sequence of block, statement, expression, and block can repeatedly nest to an\n+arbitrary depth.\n+\n+* Ref.Stmt.Decl::               Statement declaring an item or slot.\n+* Ref.Stmt.Expr::               Statement evaluating an expression.\n+\n @node       Ref.Stmt.Decl\n @subsection Ref.Stmt.Decl\n @c * Ref.Stmt.Decl::                Statement declaring an item or slot.\n@@ -2848,18 +2869,58 @@ occurs on frame-local slots, not argument slots. Function, iterator and object\n signatures must always declared types for all argument slots.\n @xref{Ref.Mem.Slot}.\n \n+@node       Ref.Stmt.Expr\n+@subsection Ref.Stmt.Expr\n+@c * Ref.Stmt.Expr::                Statement evaluating an expression\n+@cindex Expression statement\n \n+An @dfn{expression statement} is one that evaluates an expression and drops\n+its result. The purpose of an expression statement is often to cause the side\n+effects of the expression's evaluation.\n+\n+@page\n+@node    Ref.Expr\n+@section Ref.Expr\n+@c * Ref.Expr::               Parsed and primitive expressions.\n+@cindex Expressions\n+\n+\n+@menu\n+* Ref.Expr.Copy::               Expression for copying a value.\n+* Ref.Expr.Spawn::              Expressions for creating new tasks.\n+* Ref.Expr.Send::               Expressions for sending a value into a channel.\n+* Ref.Expr.Recv::               Expression for receiving a value from a channel.\n+* Ref.Expr.Call::               Expression for calling a function.\n+* Ref.Expr.Bind::               Expression for binding arguments to functions.\n+* Ref.Expr.Ret::                Expression for stopping and producing a value.\n+* Ref.Expr.Be::                 Expression for stopping and executing a tail call.\n+* Ref.Expr.Put::                Expression for pausing and producing a value.\n+* Ref.Expr.Fail::               Expression for causing task failure.\n+* Ref.Expr.Log::                Expression for logging values to diagnostic buffers.\n+* Ref.Expr.Note::               Expression for logging values during failure.\n+* Ref.Expr.While::              Expression for simple conditional looping.\n+* Ref.Expr.Break::              Expression for terminating a loop.\n+* Ref.Expr.Cont::               Expression for terminating a single loop iteration.\n+* Ref.Expr.For::                Expression for looping over strings and vectors.\n+* Ref.Expr.Foreach::            Expression for looping via an iterator.\n+* Ref.Expr.If::                 Expression for simple conditional branching.\n+* Ref.Expr.Alt::                Expression for complex conditional branching.\n+* Ref.Expr.Prove::              Expression for static assertion of typestate.\n+* Ref.Expr.Check::              Expression for dynamic assertion of typestate.\n+* Ref.Expr.IfCheck::            Expression for dynamic testing of typestate.\n+@end menu\n \n-@node       Ref.Stmt.Copy\n-@subsection Ref.Stmt.Copy\n-@c * Ref.Stmt.Copy::                Statement for copying a value.\n-@cindex Copy statement\n-@cindex Assignment operator, see @i{Copy statement}\n \n-A @dfn{copy statement} consists of an @emph{lval} followed by an equals-sign\n+@node       Ref.Expr.Copy\n+@subsection Ref.Expr.Copy\n+@c * Ref.Expr.Copy::                Expression for copying a value.\n+@cindex Copy expression\n+@cindex Assignment operator, see @i{Copy expression}\n+\n+A @dfn{copy expression} consists of an @emph{lval} followed by an equals-sign\n (@code{=}) and a primitive expression. @xref{Ref.Expr}.\n \n-Executing a copy statement causes the value denoted by the expression --\n+Executing a copy expression causes the value denoted by the expression --\n either a value or a primitive combination of values -- to be copied into the\n memory location denoted by the @emph{lval}.\n \n@@ -2869,34 +2930,34 @@ implied by the @code{lval}, as well as any existing value held in the memory\n being written-to. All such adjustment is automatic and implied by the @code{=}\n operator.\n \n-An example of three different copy statements:\n+An example of three different copy expressions:\n @example\n x = y;\n x.y = z;\n x.y = z + 2;\n @end example\n \n-@node       Ref.Stmt.Spawn\n-@subsection Ref.Stmt.Spawn\n-@c * Ref.Stmt.Spawn::               Statements creating new tasks.\n-@cindex Spawn statement\n+@node       Ref.Expr.Spawn\n+@subsection Ref.Expr.Spawn\n+@c * Ref.Expr.Spawn::               Expressions creating new tasks.\n+@cindex Spawn expression\n \n-A @code{spawn} statement consists of keyword @code{spawn}, followed by\n+A @code{spawn} expression consists of keyword @code{spawn}, followed by\n an optional literal string naming the new task and then a normal\n-@emph{call} statement (@pxref{Ref.Stmt.Call}).  A @code{spawn}\n-statement causes the runtime to construct a new task executing the\n+@emph{call} expression (@pxref{Ref.Expr.Call}).  A @code{spawn}\n+expression causes the runtime to construct a new task executing the\n called function with the given name.  The called function is referred\n to as the @dfn{entry function} for the spawned task, and its arguments\n are copied from the spawning task to the spawned task before the\n spawned task begins execution.  If no explicit name is present, the\n-task is implicitly named with the string of the call statement.\n+task is implicitly named with the string of the call expression.\n \n Functions taking alias-slot arguments, or returning non-nil values, cannot be\n spawned. Iterators cannot be spawned.\n \n-The result of a @code{spawn} statement is a @code{task} value.\n+The result of a @code{spawn} expression is a @code{task} value.\n \n-An example of a @code{spawn} statement:\n+An example of a @code{spawn} expression:\n @example\n fn helper(chan[u8] out) @{\n     // do some work.\n@@ -2911,14 +2972,14 @@ auto result <- out;\n \n @end example\n \n-@node       Ref.Stmt.Send\n-@subsection Ref.Stmt.Send\n-@c * Ref.Stmt.Send::            Statements for sending a value into a channel.\n-@cindex Send statement\n+@node       Ref.Expr.Send\n+@subsection Ref.Expr.Send\n+@c * Ref.Expr.Send::            Expressions for sending a value into a channel.\n+@cindex Send expression\n @cindex Communication\n \n-Sending a value through a channel can be done via two different statements.\n-Both statements take an @emph{lval}, denoting a channel, and a value to send\n+Sending a value through a channel can be done via two different expressions.\n+Both expressions take an @emph{lval}, denoting a channel, and a value to send\n into the channel. The action of @emph{sending} varies depending on the\n @dfn{send operator} employed.\n \n@@ -2943,16 +3004,16 @@ chan[str] c = @dots{};\n c <| \"hello, world\";\n @end example\n \n-@node       Ref.Stmt.Recv\n-@subsection Ref.Stmt.Recv\n-@c * Ref.Stmt.Recv::           Statement for receiving a value from a channel.\n-@cindex Receive statement\n+@node       Ref.Expr.Recv\n+@subsection Ref.Expr.Recv\n+@c * Ref.Expr.Recv::           Expression for receiving a value from a channel.\n+@cindex Receive expression\n @cindex Communication\n \n-The @dfn{receive statement} takes an @var{lval} to receive into and an\n+The @dfn{receive expression} takes an @var{lval} to receive into and an\n expression denoting a port, and applies the @emph{receive operator}\n (@code{<-}) to the pair, copying a value out of the port and into the\n-@var{lval}. The statement causes the receiving task to enter the @emph{blocked\n+@var{lval}. The expression causes the receiving task to enter the @emph{blocked\n reading} state until a task is sending a value to the port, at which point the\n runtime pseudo-randomly selects a sending task and copies a value from the\n head of one of the task queues to the receiving location in memory, and\n@@ -2964,48 +3025,48 @@ port[str] p = @dots{};\n let str s <- p;\n @end example\n \n-@node       Ref.Stmt.Call\n-@subsection Ref.Stmt.Call\n-@c * Ref.Stmt.Call::               Statement for calling a function.\n-@cindex Call statement\n+@node       Ref.Expr.Call\n+@subsection Ref.Expr.Call\n+@c * Ref.Expr.Call::               Expression for calling a function.\n+@cindex Call expression\n @cindex Function calls\n \n-A @dfn{call statement} invokes a function, providing a tuple of input slots\n+A @dfn{call expression} invokes a function, providing a tuple of input slots\n and an alias slot to serve as the function's output, bound to the @var{lval}\n on the right hand side of the call. If the function eventually returns, then\n-the statement completes.\n+the expression completes.\n \n-A call statement statically requires that the precondition declared in the\n-callee's signature is satisfied by the statement prestate. In this way,\n-typestates propagate through function boundaries. @xref{Ref.Stmt.Stat}.\n+A call expression statically requires that the precondition declared in the\n+callee's signature is satisfied by the expression prestate. In this way,\n+typestates propagate through function boundaries. @xref{Ref.Typestate}.\n \n-An example of a call statement:\n+An example of a call expression:\n @example\n let int x = add(1, 2);\n @end example\n \n-@node       Ref.Stmt.Bind\n-@subsection Ref.Stmt.Bind\n-@c * Ref.Stmt.Bind::          Statement for binding arguments to functions.\n-@cindex Bind statement\n+@node       Ref.Expr.Bind\n+@subsection Ref.Expr.Bind\n+@c * Ref.Expr.Bind::          Expression for binding arguments to functions.\n+@cindex Bind expression\n @cindex Closures\n @cindex Currying\n \n-A @dfn{bind statement} constructs a new function from an existing\n-function.@footnote{The @code{bind} statement is analogous to the @code{bind}\n+A @dfn{bind expression} constructs a new function from an existing\n+function.@footnote{The @code{bind} expression is analogous to the @code{bind}\n expression in the Sather language.} The new function has zero or more of its\n arguments @emph{bound} into a new, hidden boxed tuple that holds the\n-bindings. For each concrete argument passed in the @code{bind} statement, the\n+bindings. For each concrete argument passed in the @code{bind} expression, the\n corresponding parameter in the existing function is @emph{omitted} as a\n parameter of the new function. For each argument passed the placeholder symbol\n-@code{_} in the @code{bind} statement, the corresponding parameter of the\n+@code{_} in the @code{bind} expression, the corresponding parameter of the\n existing function is @emph{retained} as a parameter of the new function.\n \n Any subsequent invocation of the new function with residual arguments causes\n invocation of the existing function with the combination of bound arguments\n and residual arguments that was specified during the binding.\n \n-An example of a @code{bind} statement:\n+An example of a @code{bind} expression:\n @example\n fn add(int x, int y) -> int @{\n     ret x + y;\n@@ -3021,28 +3082,28 @@ check (add(4,5) == add5(4));\n \n @end example\n \n-A @code{bind} statement generally stores a copy of the bound arguments in the\n+A @code{bind} expression generally stores a copy of the bound arguments in the\n hidden, boxed tuple, owned by the resulting first-class function. For each\n bound slot in the bound function's signature, space is allocated in the hidden\n tuple and populated with a copy of the bound value.\n \n-The @code{bind} statement is a lightweight mechanism for simulating the more\n+The @code{bind} expression is a lightweight mechanism for simulating the more\n elaborate construct of @emph{lexical closures} that exist in other\n languages. Rust has no support for lexical closures, but many realistic uses\n-of them can be achieved with @code{bind} statements.\n+of them can be achieved with @code{bind} expressions.\n \n \n-@node       Ref.Stmt.Ret\n-@subsection Ref.Stmt.Ret\n-@c * Ref.Stmt.Ret::                Statement for stopping and producing a value.\n-@cindex Return statement\n+@node       Ref.Expr.Ret\n+@subsection Ref.Expr.Ret\n+@c * Ref.Expr.Ret::                Expression for stopping and producing a value.\n+@cindex Return expression\n \n-Executing a @code{ret} statement@footnote{A @code{ret} statement is analogous\n-to a @code{return} statement in the C family.}  copies a value into the output\n+Executing a @code{ret} expression@footnote{A @code{ret} expression is analogous\n+to a @code{return} expression in the C family.}  copies a value into the output\n slot of the current function, destroys the current function activation frame,\n and transfers control to the caller frame.\n \n-An example of a @code{ret} statement:\n+An example of a @code{ret} expression:\n @example\n fn max(int a, int b) -> int @{\n    if (a > b) @{\n@@ -3052,21 +3113,21 @@ fn max(int a, int b) -> int @{\n @}\n @end example\n \n-@node       Ref.Stmt.Be\n-@subsection Ref.Stmt.Be\n-@c * Ref.Stmt.Be::                 Statement for stopping and executing a tail call.\n-@cindex Be statement\n+@node       Ref.Expr.Be\n+@subsection Ref.Expr.Be\n+@c * Ref.Expr.Be::                 Expression for stopping and executing a tail call.\n+@cindex Be expression\n @cindex Tail calls\n \n-Executing a @code{be} statement @footnote{A @code{be} statement in is\n-analogous to a @code{become} statement in Newsqueak or Alef.}  destroys the\n+Executing a @code{be} expression @footnote{A @code{be} expression in is\n+analogous to a @code{become} expression in Newsqueak or Alef.}  destroys the\n current function activation frame and replaces it with an activation frame for\n the called function. In other words, @code{be} executes a tail-call. The\n-syntactic form of a @code{be} statement is therefore limited to @emph{tail\n+syntactic form of a @code{be} expression is therefore limited to @emph{tail\n position}: its argument must be a @emph{call expression}, and it must be the\n-last statement in a block.\n+last expression in a block.\n \n-An example of a @code{be} statement:\n+An example of a @code{be} expression:\n @example\n fn print_loop(int n) @{\n   if (n <= 0) @{\n@@ -3083,82 +3144,82 @@ copy of itself.\n \n \n \n-@node       Ref.Stmt.Put\n-@subsection Ref.Stmt.Put\n-@c * Ref.Stmt.Put::                Statement for pausing and producing a value.\n-@cindex Put statement\n+@node       Ref.Expr.Put\n+@subsection Ref.Expr.Put\n+@c * Ref.Expr.Put::                Expression for pausing and producing a value.\n+@cindex Put expression\n @cindex Iterators\n \n-Executing a @code{put} statement copies a value into the output slot of the\n+Executing a @code{put} expression copies a value into the output slot of the\n current iterator, suspends execution of the current iterator, and transfers\n control to the current put-recipient frame.\n \n-A @code{put} statement is only valid within an iterator.  @footnote{A\n-@code{put} statement is analogous to a @code{yield} statement in the CLU, and\n+A @code{put} expression is only valid within an iterator.  @footnote{A\n+@code{put} expression is analogous to a @code{yield} expression in the CLU, and\n Sather languages, or in more recent languages providing a ``generator''\n facility, such as Python, Javascript or C#. Like the generators of CLU and\n Sather but @emph{unlike} these later languages, Rust's iterators reside on the\n stack and obey a strict stack discipline.} The current put-recipient will\n-eventually resume the suspended iterator containing the @code{put} statement,\n-either continuing execution after the @code{put} statement, or terminating its\n+eventually resume the suspended iterator containing the @code{put} expression,\n+either continuing execution after the @code{put} expression, or terminating its\n execution and destroying the iterator frame.\n \n \n-@node       Ref.Stmt.Fail\n-@subsection Ref.Stmt.Fail\n-@c * Ref.Stmt.Fail::               Statement for causing task failure.\n-@cindex Fail statement\n+@node       Ref.Expr.Fail\n+@subsection Ref.Expr.Fail\n+@c * Ref.Expr.Fail::               Expression for causing task failure.\n+@cindex Fail expression\n @cindex Failure\n @cindex Unwinding\n \n-Executing a @code{fail} statement causes a task to enter the @emph{failing}\n+Executing a @code{fail} expression causes a task to enter the @emph{failing}\n state. In the @emph{failing} state, a task unwinds its stack, destroying all\n frames and freeing all resources until it reaches its entry frame, at which\n point it halts execution in the @emph{dead} state.\n \n-@node       Ref.Stmt.Log\n-@subsection Ref.Stmt.Log\n-@c * Ref.Stmt.Log::                Statement for logging values to diagnostic buffers.\n-@cindex Log statement\n+@node       Ref.Expr.Log\n+@subsection Ref.Expr.Log\n+@c * Ref.Expr.Log::                Expression for logging values to diagnostic buffers.\n+@cindex Log expression\n @cindex Logging\n \n-Executing a @code{log} statement may, depending on runtime configuration,\n+Executing a @code{log} expression may, depending on runtime configuration,\n cause a value to be appended to an internal diagnostic logging buffer provided\n-by the runtime or emitted to a system console. Log statements are enabled or\n+by the runtime or emitted to a system console. Log expressions are enabled or\n disabled dynamically at run-time on a per-task and per-item\n basis. @xref{Ref.Run.Log}.\n \n-Executing a @code{log} statement is not considered an impure effect in the\n+Executing a @code{log} expression is not considered an impure effect in the\n effect system. In other words, a pure function remains pure even if it\n-contains a log statement.\n+contains a log expression.\n \n @example\n @end example\n \n-@node       Ref.Stmt.Note\n-@subsection Ref.Stmt.Note\n-@c * Ref.Stmt.Note::                Statement for logging values during failure.\n-@cindex Note statement\n+@node       Ref.Expr.Note\n+@subsection Ref.Expr.Note\n+@c * Ref.Expr.Note::                Expression for logging values during failure.\n+@cindex Note expression\n @cindex Logging\n @cindex Unwinding\n @cindex Failure\n \n-A @code{note} statement has no effect during normal execution. The purpose of\n-a @code{note} statement is to provide additional diagnostic information to the\n-logging subsystem during task failure. @xref{Ref.Stmt.Log}. Using @code{note}\n-statements, normal diagnostic logging can be kept relatively sparse, while\n+A @code{note} expression has no effect during normal execution. The purpose of\n+a @code{note} expression is to provide additional diagnostic information to the\n+logging subsystem during task failure. @xref{Ref.Expr.Log}. Using @code{note}\n+expressions, normal diagnostic logging can be kept relatively sparse, while\n still providing verbose diagnostic ``back-traces'' when a task fails.\n \n When a task is failing, control frames @emph{unwind} from the innermost frame\n to the outermost, and from the innermost lexical block within an unwinding\n frame to the outermost. When unwinding a lexical block, the runtime processes\n-all the @code{note} statements in the block sequentially, from the first\n-statement of the block to the last.  During processing, a @code{note}\n-statement has equivalent meaning to a @code{log} statement: it causes the\n+all the @code{note} expressions in the block sequentially, from the first\n+expression of the block to the last.  During processing, a @code{note}\n+expression has equivalent meaning to a @code{log} expression: it causes the\n runtime to append the argument of the @code{note} to the internal logging\n diagnostic buffer.\n \n-An example of a @code{note} statement:\n+An example of a @code{note} expression:\n @example\n fn read_file_lines(&str path) -> vec[str] @{\n     note path;\n@@ -3175,82 +3236,82 @@ In this example, if the task fails while attempting to open or read a file,\n the runtime will log the path name that was being read. If the function\n completes normally, the runtime will not log the path.\n \n-A value that is marked by a @code{note} statement is @emph{not} copied aside\n+A value that is marked by a @code{note} expression is @emph{not} copied aside\n when control passes through the @code{note}. In other words, if a @code{note}\n-statement notes a particular @var{lval}, and code after the @code{note}\n+expression notes a particular @var{lval}, and code after the @code{note}\n mutates that slot, and then a subsequent failure occurs, the @emph{mutated}\n value will be logged during unwinding, @emph{not} the original value that was\n denoted by the @var{lval} at the moment control passed through the @code{note}\n-statement.\n+expression.\n \n-@node       Ref.Stmt.While\n-@subsection Ref.Stmt.While\n-@c * Ref.Stmt.While::              Statement for simple conditional looping.\n-@cindex While statement\n+@node       Ref.Expr.While\n+@subsection Ref.Expr.While\n+@c * Ref.Expr.While::              Expression for simple conditional looping.\n+@cindex While expression\n @cindex Loops\n @cindex Control-flow\n \n-A @code{while} statement is a loop construct. A @code{while} loop may be\n+A @code{while} expression is a loop construct. A @code{while} loop may be\n either a simple @code{while} or a @code{do}-@code{while} loop.\n \n In the case of a simple @code{while}, the loop begins by evaluating the\n boolean loop conditional expression. If the loop conditional expression\n evaluates to @code{true}, the loop body block executes and control returns to\n the loop conditional expression. If the loop conditional expression evaluates\n-to @code{false}, the @code{while} statement completes.\n+to @code{false}, the @code{while} expression completes.\n \n In the case of a @code{do}-@code{while}, the loop begins with an execution of\n the loop body. After the loop body executes, it evaluates the loop conditional\n expression. If it evaluates to @code{true}, control returns to the beginning\n of the loop body. If it evaluates to @code{false}, control exits the loop.\n \n-An example of a simple @code{while} statement:\n+An example of a simple @code{while} expression:\n @example\n while (i < 10) @{\n     print(\"hello\\n\");\n     i = i + 1;\n @}\n @end example\n \n-An example of a @code{do}-@code{while} statement:\n+An example of a @code{do}-@code{while} expression:\n @example\n do @{\n     print(\"hello\\n\");\n     i = i + 1;\n @} while (i < 10);\n @end example\n \n-@node       Ref.Stmt.Break\n-@subsection Ref.Stmt.Break\n-@c * Ref.Stmt.Break::              Statement for terminating a loop.\n-@cindex Break statement\n+@node       Ref.Expr.Break\n+@subsection Ref.Expr.Break\n+@c * Ref.Expr.Break::              Expression for terminating a loop.\n+@cindex Break expression\n @cindex Loops\n @cindex Control-flow\n \n-Executing a @code{break} statement immediately terminates the innermost loop\n+Executing a @code{break} expression immediately terminates the innermost loop\n enclosing it. It is only permitted in the body of a loop.\n \n-@node       Ref.Stmt.Cont\n-@subsection Ref.Stmt.Cont\n-@c * Ref.Stmt.Cont::               Statement for terminating a single loop iteration.\n-@cindex Continue statement\n+@node       Ref.Expr.Cont\n+@subsection Ref.Expr.Cont\n+@c * Ref.Expr.Cont::               Expression for terminating a single loop iteration.\n+@cindex Continue expression\n @cindex Loops\n @cindex Control-flow\n \n-Executing a @code{cont} statement immediately terminates the current iteration\n+Executing a @code{cont} expression immediately terminates the current iteration\n of the innermost loop enclosing it, returning control to the loop\n @emph{head}. In the case of a @code{while} loop, the head is the conditional\n expression controlling the loop. In the case of a @code{for} or @code{for\n each} loop, the head is the iterator or vector-slice increment controlling the\n loop.\n \n-A @code{cont} statement is only permitted in the body of a loop.\n+A @code{cont} expression is only permitted in the body of a loop.\n \n \n-@node       Ref.Stmt.For\n-@subsection Ref.Stmt.For\n-@c * Ref.Stmt.For::                Statement for looping over strings and vectors.\n-@cindex For statement\n+@node       Ref.Expr.For\n+@subsection Ref.Expr.For\n+@c * Ref.Expr.For::                Expression for looping over strings and vectors.\n+@cindex For expression\n @cindex Loops\n @cindex Control-flow\n \n@@ -3282,10 +3343,10 @@ for (foo e in v) @{\n @}\n @end example\n \n-@node          Ref.Stmt.Foreach\n-@subsection    Ref.Stmt.Foreach\n-@c * Ref.Stmt.Foreach::           Statement for general conditional looping.\n-@cindex Foreach statement\n+@node          Ref.Expr.Foreach\n+@subsection    Ref.Expr.Foreach\n+@c * Ref.Expr.Foreach::           Expression for general conditional looping.\n+@cindex Foreach expression\n @cindex Loops\n @cindex Control-flow\n \n@@ -3303,14 +3364,14 @@ for each (str s in _str.split(txt, \"\\n\")) @{\n @end example\n \n \n-@node       Ref.Stmt.If\n-@subsection Ref.Stmt.If\n-@c * Ref.Stmt.If::                 Statement for simple conditional branching.\n-@cindex If statement\n+@node       Ref.Expr.If\n+@subsection Ref.Expr.If\n+@c * Ref.Expr.If::                 Expression for simple conditional branching.\n+@cindex If expression\n @cindex Control-flow\n \n-An @code{if} statement is a conditional branch in program control. The form of\n-an @code{if} statement is a parenthesized condition expression, followed by a\n+An @code{if} expression is a conditional branch in program control. The form of\n+an @code{if} expression is a parenthesized condition expression, followed by a\n consequent block, any number of @code{else if} conditions and blocks, and an\n optional trailing @code{else} block. The condition expressions must have type\n @code{bool}. If a condition expression evaluates to @code{true}, the\n@@ -3320,52 +3381,52 @@ consequent block is skipped and any subsequent @code{else if} condition is\n evaluated. If all @code{if} and @code{else if} conditions evaluate to @code{false}\n then any @code{else} block is executed.\n \n-@node       Ref.Stmt.Alt\n-@subsection Ref.Stmt.Alt\n-@c * Ref.Stmt.Alt::                Statement for complex conditional branching.\n-@cindex Alt statement\n+@node       Ref.Expr.Alt\n+@subsection Ref.Expr.Alt\n+@c * Ref.Expr.Alt::                Expression for complex conditional branching.\n+@cindex Alt expression\n @cindex Control-flow\n-@cindex Switch statement, see @i{Alt statement}\n+@cindex Switch expression, see @i{Alt expression}\n \n-An @code{alt} statement is a multi-directional branch in program control.\n-There are three kinds of @code{alt} statement: communication @code{alt}\n-statements, pattern @code{alt} statements, and @code{alt type} statements.\n+An @code{alt} expression is a multi-directional branch in program control.\n+There are three kinds of @code{alt} expression: communication @code{alt}\n+expressions, pattern @code{alt} expressions, and @code{alt type} expressions.\n \n The form of each kind of @code{alt} is similar: an initial @emph{head} that\n describes the criteria for branching, followed by a sequence of zero or more\n @emph{arms}, each of which describes a @emph{case} and provides a @emph{block}\n-of statements associated with the case. When an @code{alt} is executed,\n+of expressions associated with the case. When an @code{alt} is executed,\n control enters the head, determines which of the cases to branch to, branches\n to the block associated with the chosen case, and then proceeds to the\n-statement following the @code{alt} when the case block completes.\n+expression following the @code{alt} when the case block completes.\n \n @menu\n-* Ref.Stmt.Alt.Comm::         Statement for branching on communication events.\n-* Ref.Stmt.Alt.Pat::          Statement for branching on pattern matches.\n-* Ref.Stmt.Alt.Type::         Statement for branching on types.\n+* Ref.Expr.Alt.Comm::         Expression for branching on communication events.\n+* Ref.Expr.Alt.Pat::          Expression for branching on pattern matches.\n+* Ref.Expr.Alt.Type::         Expression for branching on types.\n @end menu\n \n-@node          Ref.Stmt.Alt.Comm\n-@subsubsection Ref.Stmt.Alt.Comm\n-@c * Ref.Stmt.Alt.Comm::           Statement for branching on communication events.\n-@cindex Communication alt statement\n+@node          Ref.Expr.Alt.Comm\n+@subsubsection Ref.Expr.Alt.Comm\n+@c * Ref.Expr.Alt.Comm::           Expression for branching on communication events.\n+@cindex Communication alt expression\n @cindex Control-flow\n @cindex Communication\n @cindex Multiplexing\n \n-The simplest form of @code{alt} statement is the a @emph{communication}\n+The simplest form of @code{alt} expression is the a @emph{communication}\n @code{alt}. The cases of a communication @code{alt}'s arms are send and\n-receive statements. @xref{Ref.Task.Comm}.\n+receive expressions. @xref{Ref.Task.Comm}.\n \n To execute a communication @code{alt}, the runtime checks all of the ports and\n-channels involved in the arms of the statement to see if any @code{case} can\n+channels involved in the arms of the expression to see if any @code{case} can\n execute without blocking.  If no @code{case} can execute, the task blocks, and\n the runtime unblocks the task when a @code{case} @emph{can} execute. The\n runtime then makes a pseudo-random choice from among the set of @code{case}\n-statements that can execute, executes the statement of the @code{case} and\n+expressions that can execute, executes the expression of the @code{case} and\n branches to the block of that arm.\n \n-An example of a communication @code{alt} statement:\n+An example of a communication @code{alt} expression:\n @example\n let chan c[int] = foo();\n let port p[str] = bar();\n@@ -3382,27 +3443,27 @@ alt @{\n @}\n @end example\n \n-@node          Ref.Stmt.Alt.Pat\n-@subsubsection Ref.Stmt.Alt.Pat\n-@c * Ref.Stmt.Alt.Pat::            Statement for branching on pattern matches.\n-@cindex Pattern alt statement\n+@node          Ref.Expr.Alt.Pat\n+@subsubsection Ref.Expr.Alt.Pat\n+@c * Ref.Expr.Alt.Pat::            Expression for branching on pattern matches.\n+@cindex Pattern alt expression\n @cindex Control-flow\n \n-A pattern @code{alt} statement branches on a @emph{pattern}. The exact form of\n+A pattern @code{alt} expression branches on a @emph{pattern}. The exact form of\n matching that occurs depends on the pattern. Patterns consist of some\n combination of literals, tag constructors, variable binding specifications and\n placeholders (@code{_}). A pattern @code{alt} has a parenthesized @emph{head\n expression}, which is the value to compare to the patterns. The type of the\n patterns must equal the type of the head expression.\n \n-To execute a pattern @code{alt} statement, first the head expression is\n+To execute a pattern @code{alt} expression, first the head expression is\n evaluated, then its value is sequentially compared to the patterns in the arms\n until a match is found. The first arm with a matching @code{case} pattern is\n chosen as the branch target of the @code{alt}, any variables bound by the\n pattern are assigned to local @emph{auto} slots in the arm's block, and\n control enters the block.\n \n-An example of a pattern @code{alt} statement:\n+An example of a pattern @code{alt} expression:\n \n @example\n type list[X] = tag(nil, cons(X, @@list[X]));\n@@ -3423,20 +3484,20 @@ alt (x) @{\n @end example\n \n \n-@node          Ref.Stmt.Alt.Type\n-@subsubsection Ref.Stmt.Alt.Type\n-@c * Ref.Stmt.Alt.Type::           Statement for branching on type.\n-@cindex Type alt statement\n+@node          Ref.Expr.Alt.Type\n+@subsubsection Ref.Expr.Alt.Type\n+@c * Ref.Expr.Alt.Type::           Expression for branching on type.\n+@cindex Type alt expression\n @cindex Control-flow\n \n-An @code{alt type} statement is similar to a pattern @code{alt}, but branches\n+An @code{alt type} expression is similar to a pattern @code{alt}, but branches\n on the @emph{type} of its head expression, rather than the value. The head\n-expression of an @code{alt type} statement must be of type @code{any}, and the\n-arms of the statement are slot patterns rather than value patterns. Control\n+expression of an @code{alt type} expression must be of type @code{any}, and the\n+arms of the expression are slot patterns rather than value patterns. Control\n branches to the arm with a @code{case} that matches the @emph{actual type} of\n the value in the @code{any}.\n \n-An example of an @code{alt type} statement:\n+An example of an @code{alt type} expression:\n \n @example\n let any x = foo();\n@@ -3458,38 +3519,38 @@ alt type (x) @{\n @end example\n \n \n-@node       Ref.Stmt.Prove\n-@subsection Ref.Stmt.Prove\n-@c * Ref.Stmt.Prove::              Statement for static assertion of typestate.\n-@cindex Prove statement\n+@node       Ref.Expr.Prove\n+@subsection Ref.Expr.Prove\n+@c * Ref.Expr.Prove::              Expression for static assertion of typestate.\n+@cindex Prove expression\n @cindex Typestate system\n \n-A @code{prove} statement has no run-time effect. Its purpose is to statically\n-check (and document) that its argument constraint holds at its statement entry\n+A @code{prove} expression has no run-time effect. Its purpose is to statically\n+check (and document) that its argument constraint holds at its expression entry\n point. If its argument typestate does not hold, under the typestate algorithm,\n the program containing it will fail to compile.\n \n-@node       Ref.Stmt.Check\n-@subsection Ref.Stmt.Check\n-@c * Ref.Stmt.Check::              Statement for dynamic assertion of typestate.\n-@cindex Check statement\n+@node       Ref.Expr.Check\n+@subsection Ref.Expr.Check\n+@c * Ref.Expr.Check::              Expression for dynamic assertion of typestate.\n+@cindex Check expression\n @cindex Typestate system\n \n-A @code{check} statement connects dynamic assertions made at run-time to the\n-static typestate system. A @code{check} statement takes a constraint to check\n+A @code{check} expression connects dynamic assertions made at run-time to the\n+static typestate system. A @code{check} expression takes a constraint to check\n at run-time. If the constraint holds at run-time, control passes through the\n-@code{check} and on to the next statement in the enclosing block. If the\n-condition fails to hold at run-time, the @code{check} statement behaves as a\n-@code{fail} statement.\n+@code{check} and on to the next expression in the enclosing block. If the\n+condition fails to hold at run-time, the @code{check} expression behaves as a\n+@code{fail} expression.\n \n-The typestate algorithm is built around @code{check} statements, and in\n-particular the fact that control @emph{will not pass} a check statement with a\n+The typestate algorithm is built around @code{check} expressions, and in\n+particular the fact that control @emph{will not pass} a check expression with a\n condition that fails to hold. The typestate algorithm can therefore assume\n-that the (static) postcondition of a @code{check} statement includes the\n+that the (static) postcondition of a @code{check} expression includes the\n checked constraint itself. From there, the typestate algorithm can perform\n-dataflow calculations on subsequent statements, propagating conditions forward\n+dataflow calculations on subsequent expressions, propagating conditions forward\n and statically comparing implied states and their\n-specifications. @xref{Ref.Stmt.Stat}.\n+specifications. @xref{Ref.Typestate}.\n \n @example\n fn even(&int x) -> bool @{\n@@ -3512,18 +3573,18 @@ fn test() @{\n @}\n @end example\n \n-@node       Ref.Stmt.IfCheck\n-@subsection Ref.Stmt.IfCheck\n-@c * Ref.Stmt.IfCheck::            Statement for dynamic testing of typestate.\n-@cindex If check statement\n+@node       Ref.Expr.IfCheck\n+@subsection Ref.Expr.IfCheck\n+@c * Ref.Expr.IfCheck::            Expression for dynamic testing of typestate.\n+@cindex If check expression\n @cindex Typestate system\n @cindex Control-flow\n \n-An @code{if check} statement combines a @code{if} statement and a @code{check}\n-statement in an indivisible unit that can be used to build more complex\n-conditional control-flow than the @code{check} statement affords.\n+An @code{if check} expression combines a @code{if} expression and a @code{check}\n+expression in an indivisible unit that can be used to build more complex\n+conditional control-flow than the @code{check} expression affords.\n \n-In fact, @code{if check} is a ``more primitive'' statement @code{check};\n+In fact, @code{if check} is a ``more primitive'' expression @code{check};\n instances of the latter can be rewritten as instances of the former. The\n following two examples are equivalent:\n \n@@ -3625,9 +3686,9 @@ structure corresponding to the DWARF DIE for that slot or item.\n @c * Ref.Run.Log::                 Runtime logging system.\n @cindex Logging\n \n-The runtime contains a system for directing logging statements to a logging\n-console and/or internal logging buffers. @xref{Ref.Stmt.Log}.  Logging\n-statements can be enabled or disabled via a two-dimensional filtering process:\n+The runtime contains a system for directing logging expressions to a logging\n+console and/or internal logging buffers. @xref{Ref.Expr.Log}.  Logging\n+expressions can be enabled or disabled via a two-dimensional filtering process:\n \n @itemize\n \n@@ -3680,5 +3741,5 @@ to the task's domain; if the queue grows too big, the task will fail.\n @c fill-column: 78;\n @c indent-tabs-mode: nil\n @c buffer-file-coding-system: utf-8-unix\n-@c compile-command: \"make -k 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+@c compile-command: \"make -C $RBUILD -k 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n @c End:"}]}