{"sha": "25028986864fbb3231c54feb5e769c8778e037bf", "node_id": "C_kwDOAAsO6NoAKDI1MDI4OTg2ODY0ZmJiMzIzMWM1NGZlYjVlNzY5Yzg3NzhlMDM3YmY", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-05T15:39:36Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-08-19T14:28:59Z"}, "message": "Move `ByteCount` into `Methods` lint pass", "tree": {"sha": "3f059555cf246cce6e9db5d87e4b50db9bcea627", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f059555cf246cce6e9db5d87e4b50db9bcea627"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25028986864fbb3231c54feb5e769c8778e037bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25028986864fbb3231c54feb5e769c8778e037bf", "html_url": "https://github.com/rust-lang/rust/commit/25028986864fbb3231c54feb5e769c8778e037bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25028986864fbb3231c54feb5e769c8778e037bf/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21f595433e449ff44de5e6cd6373b8a852512d49", "url": "https://api.github.com/repos/rust-lang/rust/commits/21f595433e449ff44de5e6cd6373b8a852512d49", "html_url": "https://github.com/rust-lang/rust/commit/21f595433e449ff44de5e6cd6373b8a852512d49"}], "stats": {"total": 221, "additions": 111, "deletions": 110}, "files": [{"sha": "326ce34082af7c233b8f2d1dc44cc185a81fdb08", "filename": "clippy_lints/src/bytecount.rs", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/21f595433e449ff44de5e6cd6373b8a852512d49/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f595433e449ff44de5e6cd6373b8a852512d49/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=21f595433e449ff44de5e6cd6373b8a852512d49", "patch": "@@ -1,103 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::match_type;\n-use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{path_to_local_id, paths, peel_blocks, peel_ref_operators, strip_pat_refs};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Closure, Expr, ExprKind, PatKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, UintTy};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for naive byte counts\n-    ///\n-    /// ### Why is this bad?\n-    /// The [`bytecount`](https://crates.io/crates/bytecount)\n-    /// crate has methods to count your bytes faster, especially for large slices.\n-    ///\n-    /// ### Known problems\n-    /// If you have predominantly small slices, the\n-    /// `bytecount::count(..)` method may actually be slower. However, if you can\n-    /// ensure that less than 2\u00b3\u00b2-1 matches arise, the `naive_count_32(..)` can be\n-    /// faster in those cases.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let vec = vec![1_u8];\n-    /// let count = vec.iter().filter(|x| **x == 0u8).count();\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// # let vec = vec![1_u8];\n-    /// let count = bytecount::count(&vec, 0u8);\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub NAIVE_BYTECOUNT,\n-    pedantic,\n-    \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\"\n-}\n-\n-declare_lint_pass!(ByteCount => [NAIVE_BYTECOUNT]);\n-\n-impl<'tcx> LateLintPass<'tcx> for ByteCount {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(count, [count_recv], _) = expr.kind;\n-            if count.ident.name == sym::count;\n-            if let ExprKind::MethodCall(filter, [filter_recv, filter_arg], _) = count_recv.kind;\n-            if filter.ident.name == sym!(filter);\n-            if let ExprKind::Closure(&Closure { body, .. }) = filter_arg.kind;\n-            let body = cx.tcx.hir().body(body);\n-            if let [param] = body.params;\n-            if let PatKind::Binding(_, arg_id, _, _) = strip_pat_refs(param.pat).kind;\n-            if let ExprKind::Binary(ref op, l, r) = body.value.kind;\n-            if op.node == BinOpKind::Eq;\n-            if match_type(cx,\n-                       cx.typeck_results().expr_ty(filter_recv).peel_refs(),\n-                       &paths::SLICE_ITER);\n-            let operand_is_arg = |expr| {\n-                let expr = peel_ref_operators(cx, peel_blocks(expr));\n-                path_to_local_id(expr, arg_id)\n-            };\n-            let needle = if operand_is_arg(l) {\n-                r\n-            } else if operand_is_arg(r) {\n-                l\n-            } else {\n-                return;\n-            };\n-            if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n-            if !is_local_used(cx, needle, arg_id);\n-            then {\n-                let haystack = if let ExprKind::MethodCall(path, args, _) =\n-                        filter_recv.kind {\n-                    let p = path.ident.name;\n-                    if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n-                        &args[0]\n-                    } else {\n-                        filter_recv\n-                    }\n-                } else {\n-                    filter_recv\n-                };\n-                let mut applicability = Applicability::MaybeIncorrect;\n-                span_lint_and_sugg(\n-                    cx,\n-                    NAIVE_BYTECOUNT,\n-                    expr.span,\n-                    \"you appear to be counting bytes the naive way\",\n-                    \"consider using the bytecount crate\",\n-                    format!(\"bytecount::count({}, {})\",\n-                            snippet_with_applicability(cx, haystack.span, \"..\", &mut applicability),\n-                            snippet_with_applicability(cx, needle.span, \"..\", &mut applicability)),\n-                    applicability,\n-                );\n-            }\n-        };\n-    }\n-}"}, {"sha": "c3c24fb166803425b07ca7e4dcabc3ad68c918a3", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25028986864fbb3231c54feb5e769c8778e037bf/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25028986864fbb3231c54feb5e769c8778e037bf/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=25028986864fbb3231c54feb5e769c8778e037bf", "patch": "@@ -59,7 +59,6 @@ store.register_lints(&[\n     booleans::NONMINIMAL_BOOL,\n     booleans::OVERLY_COMPLEX_BOOL_EXPR,\n     borrow_deref_ref::BORROW_DEREF_REF,\n-    bytecount::NAIVE_BYTECOUNT,\n     bytes_count_to_len::BYTES_COUNT_TO_LEN,\n     cargo::CARGO_COMMON_METADATA,\n     cargo::MULTIPLE_CRATE_VERSIONS,\n@@ -330,6 +329,7 @@ store.register_lints(&[\n     methods::MAP_FLATTEN,\n     methods::MAP_IDENTITY,\n     methods::MAP_UNWRAP_OR,\n+    methods::NAIVE_BYTECOUNT,\n     methods::NEEDLESS_OPTION_AS_DEREF,\n     methods::NEEDLESS_OPTION_TAKE,\n     methods::NEEDLESS_SPLITN,"}, {"sha": "241d70d26287e0b4bb6a1705b3e0cca475de602f", "filename": "clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25028986864fbb3231c54feb5e769c8778e037bf/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25028986864fbb3231c54feb5e769c8778e037bf/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=25028986864fbb3231c54feb5e769c8778e037bf", "patch": "@@ -4,7 +4,6 @@\n \n store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(attrs::INLINE_ALWAYS),\n-    LintId::of(bytecount::NAIVE_BYTECOUNT),\n     LintId::of(case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS),\n     LintId::of(casts::BORROW_AS_PTR),\n     LintId::of(casts::CAST_LOSSLESS),\n@@ -64,6 +63,7 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(methods::IMPLICIT_CLONE),\n     LintId::of(methods::INEFFICIENT_TO_STRING),\n     LintId::of(methods::MAP_UNWRAP_OR),\n+    LintId::of(methods::NAIVE_BYTECOUNT),\n     LintId::of(methods::UNNECESSARY_JOIN),\n     LintId::of(misc::USED_UNDERSCORE_BINDING),\n     LintId::of(mismatching_type_param_order::MISMATCHING_TYPE_PARAM_ORDER),"}, {"sha": "617f16223258ecbf6b134659c907f8db6e8528c7", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25028986864fbb3231c54feb5e769c8778e037bf/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25028986864fbb3231c54feb5e769c8778e037bf/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=25028986864fbb3231c54feb5e769c8778e037bf", "patch": "@@ -180,7 +180,6 @@ mod blocks_in_if_conditions;\n mod bool_assert_comparison;\n mod booleans;\n mod borrow_deref_ref;\n-mod bytecount;\n mod bytes_count_to_len;\n mod cargo;\n mod case_sensitive_file_extension_comparisons;\n@@ -718,7 +717,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     );\n     store.register_late_pass(move || Box::new(pass_by_ref_or_value));\n     store.register_late_pass(|| Box::new(ref_option_ref::RefOptionRef));\n-    store.register_late_pass(|| Box::new(bytecount::ByteCount));\n     store.register_late_pass(|| Box::new(infinite_iter::InfiniteIter));\n     store.register_late_pass(|| Box::new(inline_fn_without_body::InlineFnWithoutBody));\n     store.register_late_pass(|| Box::new(useless_conversion::UselessConversion::default()));"}, {"sha": "6a7c63d76f72c8afee58a465bec5ba33a21e5436", "filename": "clippy_lints/src/methods/bytecount.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/25028986864fbb3231c54feb5e769c8778e037bf/clippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25028986864fbb3231c54feb5e769c8778e037bf/clippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs?ref=25028986864fbb3231c54feb5e769c8778e037bf", "patch": "@@ -0,0 +1,70 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::visitors::is_local_used;\n+use clippy_utils::{path_to_local_id, paths, peel_blocks, peel_ref_operators, strip_pat_refs};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Closure, Expr, ExprKind, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, UintTy};\n+use rustc_span::sym;\n+\n+use super::NAIVE_BYTECOUNT;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    filter_recv: &'tcx Expr<'_>,\n+    filter_arg: &'tcx Expr<'_>,\n+) {\n+    if_chain! {\n+        if let ExprKind::Closure(&Closure { body, .. }) = filter_arg.kind;\n+        let body = cx.tcx.hir().body(body);\n+        if let [param] = body.params;\n+        if let PatKind::Binding(_, arg_id, _, _) = strip_pat_refs(param.pat).kind;\n+        if let ExprKind::Binary(ref op, l, r) = body.value.kind;\n+        if op.node == BinOpKind::Eq;\n+        if match_type(cx,\n+                    cx.typeck_results().expr_ty(filter_recv).peel_refs(),\n+                    &paths::SLICE_ITER);\n+        let operand_is_arg = |expr| {\n+            let expr = peel_ref_operators(cx, peel_blocks(expr));\n+            path_to_local_id(expr, arg_id)\n+        };\n+        let needle = if operand_is_arg(l) {\n+            r\n+        } else if operand_is_arg(r) {\n+            l\n+        } else {\n+            return;\n+        };\n+        if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n+        if !is_local_used(cx, needle, arg_id);\n+        then {\n+            let haystack = if let ExprKind::MethodCall(path, args, _) =\n+                    filter_recv.kind {\n+                let p = path.ident.name;\n+                if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n+                    &args[0]\n+                } else {\n+                    filter_recv\n+                }\n+            } else {\n+                filter_recv\n+            };\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            span_lint_and_sugg(\n+                cx,\n+                NAIVE_BYTECOUNT,\n+                expr.span,\n+                \"you appear to be counting bytes the naive way\",\n+                \"consider using the bytecount crate\",\n+                format!(\"bytecount::count({}, {})\",\n+                        snippet_with_applicability(cx, haystack.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, needle.span, \"..\", &mut applicability)),\n+                applicability,\n+            );\n+        }\n+    };\n+}"}, {"sha": "f0d9dce5518cd52d6d969b36717e01982632e5ef", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/25028986864fbb3231c54feb5e769c8778e037bf/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25028986864fbb3231c54feb5e769c8778e037bf/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=25028986864fbb3231c54feb5e769c8778e037bf", "patch": "@@ -1,4 +1,5 @@\n mod bind_instead_of_map;\n+mod bytecount;\n mod bytes_nth;\n mod chars_cmp;\n mod chars_cmp_with_unwrap;\n@@ -82,7 +83,9 @@ use bind_instead_of_map::BindInsteadOfMap;\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_adt_constructor, contains_ty, implements_trait, is_copy, is_type_diagnostic_item};\n-use clippy_utils::{contains_return, get_trait_def_id, iter_input_pats, meets_msrv, msrvs, paths, return_ty};\n+use clippy_utils::{\n+    contains_return, get_trait_def_id, is_trait_method, iter_input_pats, meets_msrv, msrvs, paths, return_ty,\n+};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -2368,6 +2371,37 @@ declare_clippy_lint! {\n     \"Iterator for empty array\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for naive byte counts\n+    ///\n+    /// ### Why is this bad?\n+    /// The [`bytecount`](https://crates.io/crates/bytecount)\n+    /// crate has methods to count your bytes faster, especially for large slices.\n+    ///\n+    /// ### Known problems\n+    /// If you have predominantly small slices, the\n+    /// `bytecount::count(..)` method may actually be slower. However, if you can\n+    /// ensure that less than 2\u00b3\u00b2-1 matches arise, the `naive_count_32(..)` can be\n+    /// faster in those cases.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let vec = vec![1_u8];\n+    /// let count = vec.iter().filter(|x| **x == 0u8).count();\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// # let vec = vec![1_u8];\n+    /// let count = bytecount::count(&vec, 0u8);\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub NAIVE_BYTECOUNT,\n+    pedantic,\n+    \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -2471,7 +2505,8 @@ impl_lint_pass!(Methods => [\n     NO_EFFECT_REPLACE,\n     OBFUSCATED_IF_ELSE,\n     ITER_ON_SINGLE_ITEMS,\n-    ITER_ON_EMPTY_COLLECTIONS\n+    ITER_ON_EMPTY_COLLECTIONS,\n+    NAIVE_BYTECOUNT,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2726,12 +2761,13 @@ impl Methods {\n                     },\n                     _ => {},\n                 },\n-                (\"count\", []) => match method_call(recv) {\n+                (\"count\", []) if is_trait_method(cx, expr, sym::Iterator) => match method_call(recv) {\n                     Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, true, false),\n                     Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), [recv2], _)) => {\n                         iter_count::check(cx, expr, recv2, name2);\n                     },\n                     Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n+                    Some((\"filter\", [recv2, arg], _)) => bytecount::check(cx, expr, recv2, arg),\n                     _ => {},\n                 },\n                 (\"drain\", [arg]) => {"}]}