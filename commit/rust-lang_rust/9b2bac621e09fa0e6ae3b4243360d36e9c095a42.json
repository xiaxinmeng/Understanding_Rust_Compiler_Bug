{"sha": "9b2bac621e09fa0e6ae3b4243360d36e9c095a42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMmJhYzYyMWUwOWZhMGU2YWUzYjQyNDMzNjBkMzZlOWMwOTVhNDI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-09-11T17:49:10Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-09-11T17:49:10Z"}, "message": "minor: make code clearer with ControlFlow", "tree": {"sha": "414417860d9fba0d3dcea6e31330b76f7c538c28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/414417860d9fba0d3dcea6e31330b76f7c538c28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b2bac621e09fa0e6ae3b4243360d36e9c095a42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b2bac621e09fa0e6ae3b4243360d36e9c095a42", "html_url": "https://github.com/rust-lang/rust/commit/9b2bac621e09fa0e6ae3b4243360d36e9c095a42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b2bac621e09fa0e6ae3b4243360d36e9c095a42/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abdb75912c8d9297289df95e312e1b53df4960f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/abdb75912c8d9297289df95e312e1b53df4960f7", "html_url": "https://github.com/rust-lang/rust/commit/abdb75912c8d9297289df95e312e1b53df4960f7"}], "stats": {"total": 144, "additions": 71, "deletions": 73}, "files": [{"sha": "b028e76c17a5fe3648cbfd6d8738cc9cca3ee15f", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9b2bac621e09fa0e6ae3b4243360d36e9c095a42/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2bac621e09fa0e6ae3b4243360d36e9c095a42/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=9b2bac621e09fa0e6ae3b4243360d36e9c095a42", "patch": "@@ -31,7 +31,7 @@ pub mod db;\n \n mod display;\n \n-use std::{iter, sync::Arc};\n+use std::{iter, ops::ControlFlow, sync::Arc};\n \n use arrayvec::ArrayVec;\n use base_db::{CrateDisplayName, CrateId, Edition, FileId};\n@@ -2573,12 +2573,14 @@ impl Type {\n             krate,\n             traits_in_scope,\n             name,\n-            &mut |ty, assoc_item_id| match assoc_item_id {\n-                AssocItemId::FunctionId(it) => {\n-                    slot = callback(self.derived(ty.clone()), it.into());\n-                    slot.is_some()\n+            &mut |ty, assoc_item_id| {\n+                if let AssocItemId::FunctionId(func) = assoc_item_id {\n+                    if let Some(res) = callback(self.derived(ty.clone()), func.into()) {\n+                        slot = Some(res);\n+                        return ControlFlow::Break(());\n+                    }\n                 }\n-                AssocItemId::ConstId(_) | AssocItemId::TypeAliasId(_) => false,\n+                ControlFlow::Continue(())\n             },\n         );\n         slot\n@@ -2590,7 +2592,7 @@ impl Type {\n         krate: Crate,\n         traits_in_scope: &FxHashSet<TraitId>,\n         name: Option<&Name>,\n-        callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n+        callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n     ) {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n@@ -2630,8 +2632,11 @@ impl Type {\n             traits_in_scope,\n             name,\n             &mut |ty, assoc_item_id| {\n-                slot = callback(self.derived(ty.clone()), assoc_item_id.into());\n-                slot.is_some()\n+                if let Some(res) = callback(self.derived(ty.clone()), assoc_item_id.into()) {\n+                    slot = Some(res);\n+                    return ControlFlow::Break(());\n+                }\n+                ControlFlow::Continue(())\n             },\n         );\n         slot\n@@ -2643,7 +2648,7 @@ impl Type {\n         krate: Crate,\n         traits_in_scope: &FxHashSet<TraitId>,\n         name: Option<&Name>,\n-        callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n+        callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n     ) {\n         let canonical = hir_ty::replace_errors_with_variables(&self.ty);\n "}, {"sha": "3921c3655170dae37495766e55e546f1b8b9bed1", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 55, "deletions": 62, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/9b2bac621e09fa0e6ae3b4243360d36e9c095a42/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2bac621e09fa0e6ae3b4243360d36e9c095a42/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=9b2bac621e09fa0e6ae3b4243360d36e9c095a42", "patch": "@@ -2,7 +2,7 @@\n //! For details about how this works in rustc, see the method lookup page in the\n //! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)\n //! and the corresponding code mostly in librustc_typeck/check/method/probe.rs.\n-use std::{iter, sync::Arc};\n+use std::{iter, ops::ControlFlow, sync::Arc};\n \n use arrayvec::ArrayVec;\n use base_db::{CrateId, Edition};\n@@ -435,8 +435,11 @@ pub fn iterate_method_candidates<T>(\n         mode,\n         &mut |ty, item| {\n             assert!(slot.is_none());\n-            slot = callback(ty, item);\n-            slot.is_some()\n+            if let Some(it) = callback(ty, item) {\n+                slot = Some(it);\n+                return ControlFlow::Break(());\n+            }\n+            ControlFlow::Continue(())\n         },\n     );\n     slot\n@@ -451,8 +454,8 @@ pub fn iterate_method_candidates_dyn(\n     visible_from_module: Option<ModuleId>,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n-) -> bool {\n+    callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n+) -> ControlFlow<()> {\n     match mode {\n         LookupMode::MethodCall => {\n             // For method calls, rust first does any number of autoderef, and then one\n@@ -480,7 +483,7 @@ pub fn iterate_method_candidates_dyn(\n \n             let deref_chain = autoderef_method_receiver(db, krate, ty);\n             for i in 0..deref_chain.len() {\n-                if iterate_method_candidates_with_autoref(\n+                iterate_method_candidates_with_autoref(\n                     &deref_chain[i..],\n                     db,\n                     env.clone(),\n@@ -489,11 +492,9 @@ pub fn iterate_method_candidates_dyn(\n                     visible_from_module,\n                     name,\n                     callback,\n-                ) {\n-                    return true;\n-                }\n+                )?;\n             }\n-            false\n+            ControlFlow::Continue(())\n         }\n         LookupMode::Path => {\n             // No autoderef for path lookups\n@@ -519,9 +520,9 @@ fn iterate_method_candidates_with_autoref(\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: Option<ModuleId>,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n-) -> bool {\n-    if iterate_method_candidates_by_receiver(\n+    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n+) -> ControlFlow<()> {\n+    iterate_method_candidates_by_receiver(\n         &deref_chain[0],\n         &deref_chain[1..],\n         db,\n@@ -531,15 +532,15 @@ fn iterate_method_candidates_with_autoref(\n         visible_from_module,\n         name,\n         &mut callback,\n-    ) {\n-        return true;\n-    }\n+    )?;\n+\n     let refed = Canonical {\n         binders: deref_chain[0].binders.clone(),\n         value: TyKind::Ref(Mutability::Not, static_lifetime(), deref_chain[0].value.clone())\n             .intern(&Interner),\n     };\n-    if iterate_method_candidates_by_receiver(\n+\n+    iterate_method_candidates_by_receiver(\n         &refed,\n         deref_chain,\n         db,\n@@ -549,15 +550,15 @@ fn iterate_method_candidates_with_autoref(\n         visible_from_module,\n         name,\n         &mut callback,\n-    ) {\n-        return true;\n-    }\n+    )?;\n+\n     let ref_muted = Canonical {\n         binders: deref_chain[0].binders.clone(),\n         value: TyKind::Ref(Mutability::Mut, static_lifetime(), deref_chain[0].value.clone())\n             .intern(&Interner),\n     };\n-    if iterate_method_candidates_by_receiver(\n+\n+    iterate_method_candidates_by_receiver(\n         &ref_muted,\n         deref_chain,\n         db,\n@@ -567,10 +568,7 @@ fn iterate_method_candidates_with_autoref(\n         visible_from_module,\n         name,\n         &mut callback,\n-    ) {\n-        return true;\n-    }\n-    false\n+    )\n }\n \n fn iterate_method_candidates_by_receiver(\n@@ -582,13 +580,13 @@ fn iterate_method_candidates_by_receiver(\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: Option<ModuleId>,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n-) -> bool {\n+    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n+) -> ControlFlow<()> {\n     // We're looking for methods with *receiver* type receiver_ty. These could\n     // be found in any of the derefs of receiver_ty, so we have to go through\n     // that.\n     for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n-        if iterate_inherent_methods(\n+        iterate_inherent_methods(\n             self_ty,\n             db,\n             env.clone(),\n@@ -597,12 +595,11 @@ fn iterate_method_candidates_by_receiver(\n             krate,\n             visible_from_module,\n             &mut callback,\n-        ) {\n-            return true;\n-        }\n+        )?\n     }\n+\n     for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n-        if iterate_trait_method_candidates(\n+        iterate_trait_method_candidates(\n             self_ty,\n             db,\n             env.clone(),\n@@ -611,11 +608,10 @@ fn iterate_method_candidates_by_receiver(\n             name,\n             Some(receiver_ty),\n             &mut callback,\n-        ) {\n-            return true;\n-        }\n+        )?\n     }\n-    false\n+\n+    ControlFlow::Continue(())\n }\n \n fn iterate_method_candidates_for_self_ty(\n@@ -626,9 +622,9 @@ fn iterate_method_candidates_for_self_ty(\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: Option<ModuleId>,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n-) -> bool {\n-    if iterate_inherent_methods(\n+    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n+) -> ControlFlow<()> {\n+    iterate_inherent_methods(\n         self_ty,\n         db,\n         env.clone(),\n@@ -637,9 +633,7 @@ fn iterate_method_candidates_for_self_ty(\n         krate,\n         visible_from_module,\n         &mut callback,\n-    ) {\n-        return true;\n-    }\n+    )?;\n     iterate_trait_method_candidates(self_ty, db, env, krate, traits_in_scope, name, None, callback)\n }\n \n@@ -651,22 +645,24 @@ fn iterate_trait_method_candidates(\n     traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n-    callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n-) -> bool {\n+    callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n+) -> ControlFlow<()> {\n     let receiver_is_array = matches!(self_ty.value.kind(&Interner), chalk_ir::TyKind::Array(..));\n     // if ty is `dyn Trait`, the trait doesn't need to be in scope\n     let inherent_trait =\n         self_ty.value.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n-    let env_traits = if let TyKind::Placeholder(_) = self_ty.value.kind(&Interner) {\n-        // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n-        env.traits_in_scope_from_clauses(&self_ty.value)\n-            .flat_map(|t| all_super_traits(db.upcast(), t))\n-            .collect()\n-    } else {\n-        Vec::new()\n+    let env_traits = match self_ty.value.kind(&Interner) {\n+        TyKind::Placeholder(_) => {\n+            // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n+            env.traits_in_scope_from_clauses(&self_ty.value)\n+                .flat_map(|t| all_super_traits(db.upcast(), t))\n+                .collect()\n+        }\n+        _ => Vec::new(),\n     };\n     let traits =\n         inherent_trait.chain(env_traits.into_iter()).chain(traits_in_scope.iter().copied());\n+\n     'traits: for t in traits {\n         let data = db.trait_data(t);\n \n@@ -701,12 +697,10 @@ fn iterate_trait_method_candidates(\n             }\n             known_implemented = true;\n             // FIXME: we shouldn't be ignoring the binders here\n-            if callback(&self_ty.value, *item) {\n-                return true;\n-            }\n+            callback(&self_ty.value, *item)?\n         }\n     }\n-    false\n+    ControlFlow::Continue(())\n }\n \n fn filter_inherent_impls_for_self_ty<'i>(\n@@ -744,12 +738,13 @@ fn iterate_inherent_methods(\n     receiver_ty: Option<&Canonical<Ty>>,\n     krate: CrateId,\n     visible_from_module: Option<ModuleId>,\n-    callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n-) -> bool {\n+    callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n+) -> ControlFlow<()> {\n     let def_crates = match def_crates(db, &self_ty.value, krate) {\n         Some(k) => k,\n-        None => return false,\n+        None => return ControlFlow::Continue(()),\n     };\n+\n     for krate in def_crates {\n         let impls = db.inherent_impls_in_crate(krate);\n \n@@ -779,13 +774,11 @@ fn iterate_inherent_methods(\n                     continue;\n                 }\n                 let receiver_ty = receiver_ty.map(|x| &x.value).unwrap_or(&self_ty.value);\n-                if callback(receiver_ty, item) {\n-                    return true;\n-                }\n+                callback(receiver_ty, item)?;\n             }\n         }\n     }\n-    false\n+    ControlFlow::Continue(())\n }\n \n /// Returns the self type for the index trait call."}, {"sha": "922957f57d1833f209d0538ff7c093e89184f3c2", "filename": "xtask/src/install.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b2bac621e09fa0e6ae3b4243360d36e9c095a42/xtask%2Fsrc%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2bac621e09fa0e6ae3b4243360d36e9c095a42/xtask%2Fsrc%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Finstall.rs?ref=9b2bac621e09fa0e6ae3b4243360d36e9c095a42", "patch": "@@ -8,7 +8,7 @@ use xshell::{cmd, pushd};\n use crate::flags;\n \n // Latest stable, feel free to send a PR if this lags behind.\n-const REQUIRED_RUST_VERSION: u32 = 53;\n+const REQUIRED_RUST_VERSION: u32 = 55;\n \n impl flags::Install {\n     pub(crate) fn run(self) -> Result<()> {"}]}