{"sha": "641e2a110de4bb1b2c2b596ef1168ae7865aa529", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MWUyYTExMGRlNGJiMWIyYzJiNTk2ZWYxMTY4YWU3ODY1YWE1Mjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-23T05:46:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-23T05:46:52Z"}, "message": "auto merge of #19152 : alexcrichton/rust/issue-17863, r=aturon\n\nThis commit is an implementation of [RFC 240][rfc] when applied to the standard\r\nlibrary. It primarily deprecates the entirety of `string::raw`, `vec::raw`,\r\n`slice::raw`, and `str::raw` in favor of associated functions, methods, and\r\nother free functions. The detailed renaming is:\r\n\r\n* slice::raw::buf_as_slice => slice::from_raw_buf\r\n* slice::raw::mut_buf_as_slice => slice::from_raw_mut_buf\r\n* slice::shift_ptr => deprecated with no replacement\r\n* slice::pop_ptr => deprecated with no replacement\r\n* str::raw::from_utf8 => str::from_utf8_unchecked\r\n* str::raw::c_str_to_static_slice => str::from_c_str\r\n* str::raw::slice_bytes => deprecated for slice_unchecked (slight semantic diff)\r\n* str::raw::slice_unchecked => str.slice_unchecked\r\n* string::raw::from_parts => String::from_raw_parts\r\n* string::raw::from_buf_len => String::from_raw_buf_len\r\n* string::raw::from_buf => String::from_raw_buf\r\n* string::raw::from_utf8 => String::from_utf8_unchecked\r\n* vec::raw::from_buf => Vec::from_raw_buf\r\n\r\nAll previous functions exist in their `#[deprecated]` form, and the deprecation\r\nmessages indicate how to migrate to the newer variants.\r\n\r\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0240-unsafe-api-location.md\r\n[breaking-change]\r\n\r\nCloses #17863", "tree": {"sha": "e3bcf593519b1aa31df2d79373079f1ada8e0d39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3bcf593519b1aa31df2d79373079f1ada8e0d39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/641e2a110de4bb1b2c2b596ef1168ae7865aa529", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/641e2a110de4bb1b2c2b596ef1168ae7865aa529", "html_url": "https://github.com/rust-lang/rust/commit/641e2a110de4bb1b2c2b596ef1168ae7865aa529", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/641e2a110de4bb1b2c2b596ef1168ae7865aa529/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "529f8bcd8b03f1bcff46c31c682ce9274abff86d", "url": "https://api.github.com/repos/rust-lang/rust/commits/529f8bcd8b03f1bcff46c31c682ce9274abff86d", "html_url": "https://github.com/rust-lang/rust/commit/529f8bcd8b03f1bcff46c31c682ce9274abff86d"}, {"sha": "8ca27a633ed393438a12bbf074b4f2e6063baa6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ca27a633ed393438a12bbf074b4f2e6063baa6f", "html_url": "https://github.com/rust-lang/rust/commit/8ca27a633ed393438a12bbf074b4f2e6063baa6f"}], "stats": {"total": 512, "additions": 304, "deletions": 208}, "files": [{"sha": "d9a5f3d66f99147e642434023ca74a1f14494bd8", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -106,7 +106,7 @@ pub use core::slice::{OrdSlicePrelude, SlicePrelude, Items, MutItems};\n pub use core::slice::{ImmutableIntSlice, MutableIntSlice};\n pub use core::slice::{MutSplits, MutChunks, Splits};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice, CloneSlicePrelude};\n-pub use core::slice::{Found, NotFound};\n+pub use core::slice::{Found, NotFound, from_raw_buf, from_raw_mut_buf};\n \n // Functional utilities\n "}, {"sha": "ef219ec4c96f83f4f17c01b1999166501cf86b7b", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -80,6 +80,7 @@ pub use core::str::{Utf16Item, ScalarValue, LoneSurrogate, utf16_items};\n pub use core::str::{truncate_utf16_at_nul, utf8_char_width, CharRange};\n pub use core::str::{FromStr, from_str};\n pub use core::str::{Str, StrPrelude};\n+pub use core::str::{from_utf8_unchecked, from_c_str};\n pub use unicode::str::{UnicodeStrPrelude, Words, Graphemes, GraphemeIndices};\n \n // FIXME(conventions): ensure bit/char conventions are followed by str's API\n@@ -393,11 +394,11 @@ pub fn replace(s: &str, from: &str, to: &str) -> String {\n     let mut result = String::new();\n     let mut last_end = 0;\n     for (start, end) in s.match_indices(from) {\n-        result.push_str(unsafe{raw::slice_bytes(s, last_end, start)});\n+        result.push_str(unsafe { s.slice_unchecked(last_end, start) });\n         result.push_str(to);\n         last_end = end;\n     }\n-    result.push_str(unsafe{raw::slice_bytes(s, last_end, s.len())});\n+    result.push_str(unsafe { s.slice_unchecked(last_end, s.len()) });\n     result\n }\n \n@@ -674,16 +675,7 @@ pub trait StrAllocating: Str {\n     /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n     /// ```\n     fn replace(&self, from: &str, to: &str) -> String {\n-        let me = self.as_slice();\n-        let mut result = String::new();\n-        let mut last_end = 0;\n-        for (start, end) in me.match_indices(from) {\n-            result.push_str(unsafe{raw::slice_bytes(me, last_end, start)});\n-            result.push_str(to);\n-            last_end = end;\n-        }\n-        result.push_str(unsafe{raw::slice_bytes(me, last_end, me.len())});\n-        result\n+        replace(self.as_slice(), from, to)\n     }\n \n     /// Given a string, makes a new string with repeated copies of it."}, {"sha": "dd9dad9a42f7da2d5772da22c213d6dd0135ee5e", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 56, "deletions": 20, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -297,6 +297,52 @@ impl String {\n         chs.iter().map(|c| *c).collect()\n     }\n \n+    /// Creates a new `String` from a length, capacity, and pointer.\n+    ///\n+    /// This is unsafe because:\n+    /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`;\n+    /// * We assume that the `Vec` contains valid UTF-8.\n+    #[inline]\n+    #[unstable = \"function just moved from string::raw\"]\n+    pub unsafe fn from_raw_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n+        String {\n+            vec: Vec::from_raw_parts(buf, length, capacity),\n+        }\n+    }\n+\n+    /// Creates a `String` from a null-terminated `*const u8` buffer.\n+    ///\n+    /// This function is unsafe because we dereference memory until we find the\n+    /// NUL character, which is not guaranteed to be present. Additionally, the\n+    /// slice is not checked to see whether it contains valid UTF-8\n+    #[unstable = \"just renamed from `mod raw`\"]\n+    pub unsafe fn from_raw_buf(buf: *const u8) -> String {\n+        String::from_str(str::from_c_str(buf as *const i8))\n+    }\n+\n+    /// Creates a `String` from a `*const u8` buffer of the given length.\n+    ///\n+    /// This function is unsafe because it blindly assumes the validity of the\n+    /// pointer `buf` for `len` bytes of memory. This function will copy the\n+    /// memory from `buf` into a new allocation (owned by the returned\n+    /// `String`).\n+    ///\n+    /// This function is also unsafe because it does not validate that the\n+    /// buffer is valid UTF-8 encoded data.\n+    #[unstable = \"just renamed from `mod raw`\"]\n+    pub unsafe fn from_raw_buf_len(buf: *const u8, len: uint) -> String {\n+        String::from_utf8_unchecked(Vec::from_raw_buf(buf, len))\n+    }\n+\n+    /// Converts a vector of bytes to a new `String` without checking if\n+    /// it contains valid UTF-8. This is unsafe because it assumes that\n+    /// the UTF-8-ness of the vector has already been validated.\n+    #[inline]\n+    #[unstable = \"awaiting stabilization\"]\n+    pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {\n+        String { vec: bytes }\n+    }\n+\n     /// Return the underlying byte buffer, encoded as UTF-8.\n     ///\n     /// # Example\n@@ -823,12 +869,8 @@ impl<T: fmt::Show> ToString for T {\n }\n \n /// Unsafe operations\n-#[unstable = \"waiting on raw module conventions\"]\n+#[deprecated]\n pub mod raw {\n-    use core::mem;\n-    use core::ptr::RawPtr;\n-    use core::raw::Slice;\n-\n     use super::String;\n     use vec::Vec;\n \n@@ -838,45 +880,39 @@ pub mod raw {\n     /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`;\n     /// * We assume that the `Vec` contains valid UTF-8.\n     #[inline]\n+    #[deprecated = \"renamed to String::from_raw_parts\"]\n     pub unsafe fn from_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n-        String {\n-            vec: Vec::from_raw_parts(buf, length, capacity),\n-        }\n+        String::from_raw_parts(buf, length, capacity)\n     }\n \n     /// Creates a `String` from a `*const u8` buffer of the given length.\n     ///\n     /// This function is unsafe because of two reasons:\n+    ///\n     /// * A raw pointer is dereferenced and transmuted to `&[u8]`;\n     /// * The slice is not checked to see whether it contains valid UTF-8.\n+    #[deprecated = \"renamed to String::from_raw_buf_len\"]\n     pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> String {\n-        use slice::CloneSliceAllocPrelude;\n-        let slice: &[u8] = mem::transmute(Slice {\n-            data: buf,\n-            len: len,\n-        });\n-        self::from_utf8(slice.to_vec())\n+        String::from_raw_buf_len(buf, len)\n     }\n \n     /// Creates a `String` from a null-terminated `*const u8` buffer.\n     ///\n     /// This function is unsafe because we dereference memory until we find the NUL character,\n     /// which is not guaranteed to be present. Additionally, the slice is not checked to see\n     /// whether it contains valid UTF-8\n+    #[deprecated = \"renamed to String::from_raw_buf\"]\n     pub unsafe fn from_buf(buf: *const u8) -> String {\n-        let mut len = 0;\n-        while *buf.offset(len) != 0 {\n-            len += 1;\n-        }\n-        self::from_buf_len(buf, len as uint)\n+        String::from_raw_buf(buf)\n     }\n \n     /// Converts a vector of bytes to a new `String` without checking if\n     /// it contains valid UTF-8. This is unsafe because it assumes that\n     /// the UTF-8-ness of the vector has already been validated.\n     #[inline]\n+    #[deprecated = \"renamed to String::from_utf8_unchecked\"]\n     pub unsafe fn from_utf8(bytes: Vec<u8>) -> String {\n-        String { vec: bytes }\n+        String::from_utf8_unchecked(bytes)\n     }\n }\n "}, {"sha": "acb91f3edcf6310c000c72d3f44f057eed26bc1e", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -235,12 +235,27 @@ impl<T> Vec<T> {\n     ///     }\n     /// }\n     /// ```\n-    #[experimental]\n+    #[unstable = \"needs finalization\"]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n                                  capacity: uint) -> Vec<T> {\n         Vec { ptr: ptr, len: length, cap: capacity }\n     }\n \n+    /// Creates a vector by copying the elements from a raw pointer.\n+    ///\n+    /// This function will copy `elts` contiguous elements starting at `ptr`\n+    /// into a new allocation owned by the returned `Vec`. The elements of the\n+    /// buffer are copied into the vector without cloning, as if `ptr::read()`\n+    /// were called on them.\n+    #[inline]\n+    #[unstable = \"just renamed from raw::from_buf\"]\n+    pub unsafe fn from_raw_buf(ptr: *const T, elts: uint) -> Vec<T> {\n+        let mut dst = Vec::with_capacity(elts);\n+        dst.set_len(elts);\n+        ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(), ptr, elts);\n+        dst\n+    }\n+\n     /// Consumes the `Vec`, partitioning it based on a predicate.\n     ///\n     /// Partitions the `Vec` into two `Vec`s `(A,B)`, where all elements of `A`\n@@ -1367,23 +1382,18 @@ pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n }\n \n /// Unsafe vector operations.\n-#[unstable]\n+#[deprecated]\n pub mod raw {\n     use super::Vec;\n-    use core::ptr;\n-    use core::slice::SlicePrelude;\n \n     /// Constructs a vector from an unsafe pointer to a buffer.\n     ///\n     /// The elements of the buffer are copied into the vector without cloning,\n     /// as if `ptr::read()` were called on them.\n     #[inline]\n-    #[unstable]\n+    #[deprecated = \"renamed to Vec::from_raw_buf\"]\n     pub unsafe fn from_buf<T>(ptr: *const T, elts: uint) -> Vec<T> {\n-        let mut dst = Vec::with_capacity(elts);\n-        dst.set_len(elts);\n-        ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(), ptr, elts);\n-        dst\n+        Vec::from_raw_buf(ptr, elts)\n     }\n }\n "}, {"sha": "754da272c24810815f19594068c20ed0ce389bdc", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -1559,15 +1559,55 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     }\n }\n \n+/// Forms a slice from a pointer and a length.\n+///\n+/// The pointer given is actually a reference to the base of the slice. This\n+/// reference is used to give a concrete lifetime to tie the returned slice to.\n+/// Typically this should indicate that the slice is valid for as long as the\n+/// pointer itself is valid.\n+///\n+/// The `len` argument is the number of **elements**, not the number of bytes.\n+///\n+/// This function is unsafe as there is no guarantee that the given pointer is\n+/// valid for `len` elements, nor whether the lifetime provided is a suitable\n+/// lifetime for the returned slice.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::slice;\n+///\n+/// // manifest a slice out of thin air!\n+/// let ptr = 0x1234 as *const uint;\n+/// let amt = 10;\n+/// unsafe {\n+///     let slice = slice::from_raw_buf(&ptr, amt);\n+/// }\n+/// ```\n+#[inline]\n+#[unstable = \"just renamed from `mod raw`\"]\n+pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n+    transmute(RawSlice { data: *p, len: len })\n+}\n \n-\n+/// Performs the same functionality as `from_raw_buf`, except that a mutable\n+/// slice is returned.\n+///\n+/// This function is unsafe for the same reasons as `from_raw_buf`, as well as\n+/// not being able to provide a non-aliasing guarantee of the returned mutable\n+/// slice.\n+#[inline]\n+#[unstable = \"just renamed from `mod raw`\"]\n+pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n+    transmute(RawSlice { data: *p as *const T, len: len })\n+}\n \n //\n // Submodules\n //\n \n /// Unsafe operations\n-#[experimental = \"needs review\"]\n+#[deprecated]\n pub mod raw {\n     use mem::transmute;\n     use ptr::RawPtr;\n@@ -1579,6 +1619,7 @@ pub mod raw {\n      * not bytes).\n      */\n     #[inline]\n+    #[deprecated = \"renamed to slice::from_raw_buf\"]\n     pub unsafe fn buf_as_slice<T,U>(p: *const T, len: uint, f: |v: &[T]| -> U)\n                                -> U {\n         f(transmute(Slice {\n@@ -1592,6 +1633,7 @@ pub mod raw {\n      * not bytes).\n      */\n     #[inline]\n+    #[deprecated = \"renamed to slice::from_raw_mut_buf\"]\n     pub unsafe fn mut_buf_as_slice<T,\n                                    U>(\n                                    p: *mut T,\n@@ -1610,6 +1652,7 @@ pub mod raw {\n      * if the slice is empty. O(1).\n      */\n      #[inline]\n+    #[deprecated = \"inspect `Slice::{data, len}` manually (increment data by 1)\"]\n     pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> Option<*const T> {\n         if slice.len == 0 { return None; }\n         let head: *const T = slice.data;\n@@ -1623,7 +1666,8 @@ pub mod raw {\n      * slice so it no longer contains that element. Returns None\n      * if the slice is empty. O(1).\n      */\n-     #[inline]\n+    #[inline]\n+    #[deprecated = \"inspect `Slice::{data, len}` manually (decrement len by 1)\"]\n     pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> Option<*const T> {\n         if slice.len == 0 { return None; }\n         let tail: *const T = slice.data.offset((slice.len - 1) as int);"}, {"sha": "3b2a7c62312bf4922b890366769d724c850cc7d6", "filename": "src/libcore/str.rs", "status": "modified", "additions": 76, "deletions": 27, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -19,18 +19,19 @@\n pub use self::Utf16Item::*;\n pub use self::Searcher::{Naive, TwoWay, TwoWayLong};\n \n-use mem;\n-use char;\n use char::Char;\n+use char;\n use cmp::{Eq, mod};\n use default::Default;\n-use iter::{Map, Iterator};\n-use iter::{DoubleEndedIterator, ExactSize};\n use iter::range;\n+use iter::{DoubleEndedIterator, ExactSize};\n+use iter::{Map, Iterator};\n use kinds::Sized;\n+use mem;\n use num::Int;\n use option::{Option, None, Some};\n-use raw::Repr;\n+use ptr::RawPtr;\n+use raw::{Repr, Slice};\n use slice::{mod, SlicePrelude};\n use uint;\n \n@@ -82,8 +83,39 @@ Section: Creating a string\n /// Returns None if the slice is not utf-8.\n pub fn from_utf8<'a>(v: &'a [u8]) -> Option<&'a str> {\n     if is_utf8(v) {\n-        Some(unsafe { raw::from_utf8(v) })\n-    } else { None }\n+        Some(unsafe { from_utf8_unchecked(v) })\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Converts a slice of bytes to a string slice without checking\n+/// that the string contains valid UTF-8.\n+pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n+    mem::transmute(v)\n+}\n+\n+/// Constructs a static string slice from a given raw pointer.\n+///\n+/// This function will read memory starting at `s` until it finds a 0, and then\n+/// transmute the memory up to that point as a string slice, returning the\n+/// corresponding `&'static str` value.\n+///\n+/// This function is unsafe because the caller must ensure the C string itself\n+/// has the static lifetime and that the memory `s` is valid up to and including\n+/// the first null byte.\n+///\n+/// # Panics\n+///\n+/// This function will panic if the string pointed to by `s` is not valid UTF-8.\n+pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n+    let s = s as *const u8;\n+    let mut len = 0u;\n+    while *s.offset(len as int) != 0 {\n+        len += 1u;\n+    }\n+    let v: &'static [u8] = ::mem::transmute(Slice { data: s, len: len });\n+    from_utf8(v).expect(\"from_c_str passed invalid utf-8 data\")\n }\n \n /// Something that can be used to compare against a character\n@@ -352,8 +384,8 @@ impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplits<'a, Sep> {\n         }\n         match next_split {\n             Some((a, b)) => unsafe {\n-                let elt = raw::slice_unchecked(self.string, 0, a);\n-                self.string = raw::slice_unchecked(self.string, b, self.string.len());\n+                let elt = self.string.slice_unchecked(0, a);\n+                self.string = self.string.slice_unchecked(b, self.string.len());\n                 Some(elt)\n             },\n             None => self.get_end(),\n@@ -394,8 +426,8 @@ for CharSplits<'a, Sep> {\n         }\n         match next_split {\n             Some((a, b)) => unsafe {\n-                let elt = raw::slice_unchecked(self.string, b, len);\n-                self.string = raw::slice_unchecked(self.string, 0, a);\n+                let elt = self.string.slice_unchecked(b, len);\n+                self.string = self.string.slice_unchecked(0, a);\n                 Some(elt)\n             },\n             None => { self.finished = true; Some(self.string) }\n@@ -1112,22 +1144,24 @@ const CONT_MASK: u8 = 0b0011_1111u8;\n const TAG_CONT_U8: u8 = 0b1000_0000u8;\n \n /// Unsafe operations\n+#[deprecated]\n pub mod raw {\n-    use mem;\n     use ptr::RawPtr;\n     use raw::Slice;\n     use slice::SlicePrelude;\n     use str::{is_utf8, StrPrelude};\n \n     /// Converts a slice of bytes to a string slice without checking\n     /// that the string contains valid UTF-8.\n+    #[deprecated = \"renamed to str::from_utf8_unchecked\"]\n     pub unsafe fn from_utf8<'a>(v: &'a [u8]) -> &'a str {\n-        mem::transmute(v)\n+        super::from_utf8_unchecked(v)\n     }\n \n     /// Form a slice from a C string. Unsafe because the caller must ensure the\n     /// C string has the static lifetime, or else the return value may be\n     /// invalidated later.\n+    #[deprecated = \"renamed to str::from_c_str\"]\n     pub unsafe fn c_str_to_static_slice(s: *const i8) -> &'static str {\n         let s = s as *const u8;\n         let mut curr = s;\n@@ -1150,10 +1184,11 @@ pub mod raw {\n     /// If begin is greater than end.\n     /// If end is greater than the length of the string.\n     #[inline]\n+    #[deprecated = \"call the slice_unchecked method instead\"]\n     pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n         assert!(begin <= end);\n         assert!(end <= s.len());\n-        slice_unchecked(s, begin, end)\n+        s.slice_unchecked(begin, end)\n     }\n \n     /// Takes a bytewise (not UTF-8) slice from a string.\n@@ -1162,11 +1197,9 @@ pub mod raw {\n     ///\n     /// Caller must check slice boundaries!\n     #[inline]\n+    #[deprecated = \"this has moved to a method on `str` directly\"]\n     pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-        mem::transmute(Slice {\n-                data: s.as_ptr().offset(begin as int),\n-                len: end - begin,\n-            })\n+        s.slice_unchecked(begin, end)\n     }\n }\n \n@@ -1566,6 +1599,14 @@ pub trait StrPrelude for Sized? {\n     /// ```\n     fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n \n+    /// Takes a bytewise (not UTF-8) slice from a string.\n+    ///\n+    /// Returns the substring from [`begin`..`end`).\n+    ///\n+    /// Caller must check both UTF-8 character boundaries and the boundaries of\n+    /// the entire slice as well.\n+    unsafe fn slice_unchecked<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n+\n     /// Returns true if `needle` is a prefix of the string.\n     ///\n     /// # Example\n@@ -2012,7 +2053,7 @@ impl StrPrelude for str {\n         if begin <= end &&\n            self.is_char_boundary(begin) &&\n            self.is_char_boundary(end) {\n-            unsafe { raw::slice_unchecked(self, begin, end) }\n+            unsafe { self.slice_unchecked(begin, end) }\n         } else {\n             slice_error_fail(self, begin, end)\n         }\n@@ -2022,7 +2063,7 @@ impl StrPrelude for str {\n     fn slice_from(&self, begin: uint) -> &str {\n         // is_char_boundary checks that the index is in [0, .len()]\n         if self.is_char_boundary(begin) {\n-            unsafe { raw::slice_unchecked(self, begin, self.len()) }\n+            unsafe { self.slice_unchecked(begin, self.len()) }\n         } else {\n             slice_error_fail(self, begin, self.len())\n         }\n@@ -2032,7 +2073,7 @@ impl StrPrelude for str {\n     fn slice_to(&self, end: uint) -> &str {\n         // is_char_boundary checks that the index is in [0, .len()]\n         if self.is_char_boundary(end) {\n-            unsafe { raw::slice_unchecked(self, 0, end) }\n+            unsafe { self.slice_unchecked(0, end) }\n         } else {\n             slice_error_fail(self, 0, end)\n         }\n@@ -2057,10 +2098,18 @@ impl StrPrelude for str {\n         match (begin_byte, end_byte) {\n             (None, _) => panic!(\"slice_chars: `begin` is beyond end of string\"),\n             (_, None) => panic!(\"slice_chars: `end` is beyond end of string\"),\n-            (Some(a), Some(b)) => unsafe { raw::slice_bytes(self, a, b) }\n+            (Some(a), Some(b)) => unsafe { self.slice_unchecked(a, b) }\n         }\n     }\n \n+    #[inline]\n+    unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n+        mem::transmute(Slice {\n+            data: self.as_ptr().offset(begin as int),\n+            len: end - begin,\n+        })\n+    }\n+\n     #[inline]\n     fn starts_with(&self, needle: &str) -> bool {\n         let n = needle.len();\n@@ -2077,13 +2126,13 @@ impl StrPrelude for str {\n     fn trim_chars<C: CharEq>(&self, mut to_trim: C) -> &str {\n         let cur = match self.find(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n-            Some(i) => unsafe { raw::slice_bytes(self, i, self.len()) }\n+            Some(i) => unsafe { self.slice_unchecked(i, self.len()) }\n         };\n         match cur.rfind(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(i) => {\n                 let right = cur.char_range_at(i).next;\n-                unsafe { raw::slice_bytes(cur, 0, right) }\n+                unsafe { cur.slice_unchecked(0, right) }\n             }\n         }\n     }\n@@ -2092,7 +2141,7 @@ impl StrPrelude for str {\n     fn trim_left_chars<C: CharEq>(&self, mut to_trim: C) -> &str {\n         match self.find(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n-            Some(first) => unsafe { raw::slice_bytes(self, first, self.len()) }\n+            Some(first) => unsafe { self.slice_unchecked(first, self.len()) }\n         }\n     }\n \n@@ -2102,7 +2151,7 @@ impl StrPrelude for str {\n             None => \"\",\n             Some(last) => {\n                 let next = self.char_range_at(last).next;\n-                unsafe { raw::slice_bytes(self, 0u, next) }\n+                unsafe { self.slice_unchecked(0u, next) }\n             }\n         }\n     }\n@@ -2223,7 +2272,7 @@ impl StrPrelude for str {\n             None\n         } else {\n             let CharRange {ch, next} = self.char_range_at(0u);\n-            let next_s = unsafe { raw::slice_bytes(self, next, self.len()) };\n+            let next_s = unsafe { self.slice_unchecked(next, self.len()) };\n             Some((ch, next_s))\n         }\n     }"}, {"sha": "02dd53e4214ba869b145d7195e8cf962787f5f8a", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -12,7 +12,7 @@\n \n use core::prelude::*;\n use core::iter::{range_step, Repeat};\n-use core::slice::raw;\n+use core::slice;\n \n use {Rng, SeedableRng, Rand};\n \n@@ -234,12 +234,10 @@ impl Rand for IsaacRng {\n     fn rand<R: Rng>(other: &mut R) -> IsaacRng {\n         let mut ret = EMPTY;\n         unsafe {\n-            let ptr = ret.rsl.as_mut_ptr();\n+            let ptr = ret.rsl.as_mut_ptr() as *mut u8;\n \n-            raw::mut_buf_as_slice(ptr as *mut u8,\n-                                  (RAND_SIZE*4) as uint, |slice| {\n-                other.fill_bytes(slice);\n-            })\n+            let slice = slice::from_raw_mut_buf(&ptr, (RAND_SIZE * 4) as uint);\n+            other.fill_bytes(slice);\n         }\n         ret.cnt = 0;\n         ret.a = 0;\n@@ -469,12 +467,10 @@ impl Rand for Isaac64Rng {\n     fn rand<R: Rng>(other: &mut R) -> Isaac64Rng {\n         let mut ret = EMPTY_64;\n         unsafe {\n-            let ptr = ret.rsl.as_mut_ptr();\n+            let ptr = ret.rsl.as_mut_ptr() as *mut u8;\n \n-            raw::mut_buf_as_slice(ptr as *mut u8,\n-                                  (RAND_SIZE_64*8) as uint, |slice| {\n-                other.fill_bytes(slice);\n-            })\n+            let slice = slice::from_raw_mut_buf(&ptr, (RAND_SIZE_64 * 8) as uint);\n+            other.fill_bytes(slice);\n         }\n         ret.cnt = 0;\n         ret.a = 0;"}, {"sha": "bd0446dd67ff291fef3c16bfc4ebb0a335b48852", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -234,7 +234,6 @@ use std::io::fs::PathExtensions;\n use std::io;\n use std::ptr;\n use std::slice;\n-use std::string;\n use std::time::Duration;\n \n use flate;\n@@ -741,21 +740,19 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let mut name_buf = ptr::null();\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = string::raw::from_buf_len(name_buf as *const u8,\n-                                              name_len as uint);\n+            let name = String::from_raw_buf_len(name_buf as *const u8,\n+                                                name_len as uint);\n             debug!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(is_osx).as_slice() == name.as_slice() {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n-                let mut found =\n-                    Err(format!(\"metadata not found: '{}'\", filename.display()));\n                 let cvbuf: *const u8 = cbuf as *const u8;\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);\n                 let minsz = cmp::min(vlen, csz);\n-                let version_ok = slice::raw::buf_as_slice(cvbuf, minsz,\n-                    |buf0| buf0 == encoder::metadata_encoding_version);\n+                let buf0 = slice::from_raw_buf(&cvbuf, minsz);\n+                let version_ok = buf0 == encoder::metadata_encoding_version;\n                 if !version_ok {\n                     return Err((format!(\"incompatible metadata version found: '{}'\",\n                                         filename.display())));\n@@ -764,19 +761,10 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n                 let cvbuf1 = cvbuf.offset(vlen as int);\n                 debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n-                slice::raw::buf_as_slice(cvbuf1, csz-vlen, |bytes| {\n-                    match flate::inflate_bytes(bytes) {\n-                        Some(inflated) => found = Ok(MetadataVec(inflated)),\n-                        None => {\n-                            found =\n-                                Err(format!(\"failed to decompress \\\n-                                             metadata for: '{}'\",\n-                                            filename.display()))\n-                        }\n-                    }\n-                });\n-                if found.is_ok() {\n-                    return found;\n+                let bytes = slice::from_raw_buf(&cvbuf1, csz-vlen);\n+                match flate::inflate_bytes(bytes) {\n+                    Some(inflated) => return Ok(MetadataVec(inflated)),\n+                    None => {}\n                 }\n             }\n             llvm::LLVMMoveToNextSection(si.llsi);"}, {"sha": "043d7b9f1a462bd376748fc74ea18142039a6d53", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 65, "deletions": 72, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -32,7 +32,6 @@ use std::cell::{RefCell, Cell};\n use std::fmt;\n use std::slice;\n use std::str;\n-use std::string;\n use std::collections::HashMap;\n \n use html::toc::TocBuilder;\n@@ -160,54 +159,52 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n             let opaque = opaque as *mut hoedown_html_renderer_state;\n             let my_opaque: &MyOpaque = &*((*opaque).opaque as *const MyOpaque);\n-            slice::raw::buf_as_slice((*orig_text).data, (*orig_text).size as uint,\n-                                     |text| {\n-                let origtext = str::from_utf8(text).unwrap();\n-                debug!(\"docblock: ==============\\n{}\\n=======\", text);\n-                let rendered = if lang.is_null() {\n-                    false\n+            let text = slice::from_raw_buf(&(*orig_text).data,\n+                                           (*orig_text).size as uint);\n+            let origtext = str::from_utf8(text).unwrap();\n+            debug!(\"docblock: ==============\\n{}\\n=======\", text);\n+            let rendered = if lang.is_null() {\n+                false\n+            } else {\n+                let rlang = slice::from_raw_buf(&(*lang).data,\n+                                                (*lang).size as uint);\n+                let rlang = str::from_utf8(rlang).unwrap();\n+                if LangString::parse(rlang).notrust {\n+                    (my_opaque.dfltblk)(ob, orig_text, lang,\n+                                        opaque as *mut libc::c_void);\n+                    true\n                 } else {\n-                    slice::raw::buf_as_slice((*lang).data,\n-                                           (*lang).size as uint, |rlang| {\n-                        let rlang = str::from_utf8(rlang).unwrap();\n-                        if LangString::parse(rlang).notrust {\n-                            (my_opaque.dfltblk)(ob, orig_text, lang,\n-                                                opaque as *mut libc::c_void);\n-                            true\n-                        } else {\n-                            false\n-                        }\n-                    })\n-                };\n-\n-                let mut lines = origtext.lines().filter(|l| {\n-                    stripped_filtered_line(*l).is_none()\n-                });\n-                let text = lines.collect::<Vec<&str>>().connect(\"\\n\");\n-                if !rendered {\n-                    let mut s = String::new();\n-                    let id = playground_krate.get().map(|krate| {\n-                        let idx = test_idx.get().unwrap();\n-                        let i = idx.get();\n-                        idx.set(i + 1);\n-\n-                        let test = origtext.lines().map(|l| {\n-                            stripped_filtered_line(l).unwrap_or(l)\n-                        }).collect::<Vec<&str>>().connect(\"\\n\");\n-                        let krate = krate.as_ref().map(|s| s.as_slice());\n-                        let test = test::maketest(test.as_slice(), krate, false, false);\n-                        s.push_str(format!(\"<span id='rust-example-raw-{}' \\\n-                                             class='rusttest'>{}</span>\",\n-                                           i, Escape(test.as_slice())).as_slice());\n-                        format!(\"rust-example-rendered-{}\", i)\n-                    });\n-                    let id = id.as_ref().map(|a| a.as_slice());\n-                    s.push_str(highlight::highlight(text.as_slice(), None, id)\n-                                         .as_slice());\n-                    let output = s.to_c_str();\n-                    hoedown_buffer_puts(ob, output.as_ptr());\n+                    false\n                 }\n-            })\n+            };\n+\n+            let mut lines = origtext.lines().filter(|l| {\n+                stripped_filtered_line(*l).is_none()\n+            });\n+            let text = lines.collect::<Vec<&str>>().connect(\"\\n\");\n+            if !rendered {\n+                let mut s = String::new();\n+                let id = playground_krate.get().map(|krate| {\n+                    let idx = test_idx.get().unwrap();\n+                    let i = idx.get();\n+                    idx.set(i + 1);\n+\n+                    let test = origtext.lines().map(|l| {\n+                        stripped_filtered_line(l).unwrap_or(l)\n+                    }).collect::<Vec<&str>>().connect(\"\\n\");\n+                    let krate = krate.as_ref().map(|s| s.as_slice());\n+                    let test = test::maketest(test.as_slice(), krate, false, false);\n+                    s.push_str(format!(\"<span id='rust-example-raw-{}' \\\n+                                         class='rusttest'>{}</span>\",\n+                                       i, Escape(test.as_slice())).as_slice());\n+                    format!(\"rust-example-rendered-{}\", i)\n+                });\n+                let id = id.as_ref().map(|a| a.as_slice());\n+                s.push_str(highlight::highlight(text.as_slice(), None, id)\n+                                     .as_slice());\n+                let output = s.to_c_str();\n+                hoedown_buffer_puts(ob, output.as_ptr());\n+            }\n         }\n     }\n \n@@ -221,7 +218,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n             \"\".to_string()\n         } else {\n             unsafe {\n-                string::raw::from_buf_len((*text).data, (*text).size as uint)\n+                String::from_raw_buf_len((*text).data, (*text).size as uint)\n             }\n         };\n \n@@ -296,9 +293,8 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         };\n \n         if ret.is_ok() {\n-            ret = slice::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {\n-                w.write(buf)\n-            });\n+            let buf = slice::from_raw_buf(&(*ob).data, (*ob).size as uint);\n+            ret = w.write(buf);\n         }\n         hoedown_buffer_free(ob);\n         ret\n@@ -315,25 +311,23 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n             let block_info = if lang.is_null() {\n                 LangString::all_false()\n             } else {\n-                slice::raw::buf_as_slice((*lang).data,\n-                                       (*lang).size as uint, |lang| {\n-                    let s = str::from_utf8(lang).unwrap();\n-                    LangString::parse(s)\n-                })\n+                let lang = slice::from_raw_buf(&(*lang).data,\n+                                               (*lang).size as uint);\n+                let s = str::from_utf8(lang).unwrap();\n+                LangString::parse(s)\n             };\n             if block_info.notrust { return }\n-            slice::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n-                let opaque = opaque as *mut hoedown_html_renderer_state;\n-                let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n-                let text = str::from_utf8(text).unwrap();\n-                let mut lines = text.lines().map(|l| {\n-                    stripped_filtered_line(l).unwrap_or(l)\n-                });\n-                let text = lines.collect::<Vec<&str>>().connect(\"\\n\");\n-                tests.add_test(text.to_string(),\n-                               block_info.should_fail, block_info.no_run,\n-                               block_info.ignore, block_info.test_harness);\n-            })\n+            let text = slice::from_raw_buf(&(*text).data, (*text).size as uint);\n+            let opaque = opaque as *mut hoedown_html_renderer_state;\n+            let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n+            let text = str::from_utf8(text).unwrap();\n+            let mut lines = text.lines().map(|l| {\n+                stripped_filtered_line(l).unwrap_or(l)\n+            });\n+            let text = lines.collect::<Vec<&str>>().connect(\"\\n\");\n+            tests.add_test(text.to_string(),\n+                           block_info.should_fail, block_info.no_run,\n+                           block_info.ignore, block_info.test_harness);\n         }\n     }\n \n@@ -346,10 +340,9 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n             if text.is_null() {\n                 tests.register_header(\"\", level as u32);\n             } else {\n-                slice::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n-                    let text = str::from_utf8(text).unwrap();\n-                    tests.register_header(text, level as u32);\n-                })\n+                let text = slice::from_raw_buf(&(*text).data, (*text).size as uint);\n+                let text = str::from_utf8(text).unwrap();\n+                tests.register_header(text, level as u32);\n             }\n         }\n     }"}, {"sha": "d94f731e75c6450e3e24aeaf4fb9296b12440e64", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -47,10 +47,9 @@ mod imp {\n     use core::prelude::*;\n \n     use alloc::boxed::Box;\n-    use collections::slice::CloneSliceAllocPrelude;\n     use collections::vec::Vec;\n+    use collections::string::String;\n     use core::mem;\n-    use core::slice;\n \n     use mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n@@ -103,12 +102,7 @@ mod imp {\n \n     unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> {\n         Vec::from_fn(argc as uint, |i| {\n-            let base = *argv.offset(i as int);\n-            let mut len = 0;\n-            while *base.offset(len) != 0 { len += 1; }\n-            slice::raw::buf_as_slice(base, len as uint, |slice| {\n-                slice.to_vec()\n-            })\n+            String::from_raw_buf(*argv.offset(i as int)).into_bytes()\n         })\n     }\n "}, {"sha": "41feee8257f9c36eb7196f9c8ba98b0f9be13355", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -16,7 +16,6 @@ pub use self::FromBase64Error::*;\n pub use self::CharacterSet::*;\n \n use std::fmt;\n-use std::string;\n use std::error;\n \n /// Available encoding character sets\n@@ -152,9 +151,7 @@ impl ToBase64 for [u8] {\n             _ => panic!(\"Algebra is broken, please alert the math police\")\n         }\n \n-        unsafe {\n-            string::raw::from_utf8(v)\n-        }\n+        unsafe { String::from_utf8_unchecked(v) }\n     }\n }\n \n@@ -201,8 +198,8 @@ impl FromBase64 for str {\n      * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes.\n      *\n-     * You can use the `String::from_utf8` function in `std::string` to turn a\n-     * `Vec<u8>` into a string with characters corresponding to those values.\n+     * You can use the `String::from_utf8` function to turn a `Vec<u8>` into a\n+     * string with characters corresponding to those values.\n      *\n      * # Example\n      *"}, {"sha": "78859d6778d70103c0ae4436c5556c65c9c3a9f4", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -15,7 +15,6 @@\n pub use self::FromHexError::*;\n \n use std::fmt;\n-use std::string;\n use std::error;\n \n /// A trait for converting a value to hexadecimal encoding\n@@ -51,7 +50,7 @@ impl ToHex for [u8] {\n         }\n \n         unsafe {\n-            string::raw::from_utf8(v)\n+            String::from_utf8_unchecked(v)\n         }\n     }\n }\n@@ -100,7 +99,7 @@ impl FromHex for str {\n      * Convert any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes.\n      *\n-     * You can use the `String::from_utf8` function in `std::string` to turn a\n+     * You can use the `String::from_utf8` function to turn a\n      * `Vec<u8>` into a string with characters corresponding to those values.\n      *\n      * # Example"}, {"sha": "47189ba84ed71d9aa6e7a5f77e9defa2fe77f902", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -21,7 +21,7 @@ use mem;\n use option::{Option, Some, None};\n use slice::{SlicePrelude, AsSlice};\n use str::{Str, StrPrelude};\n-use string::{mod, String, IntoString};\n+use string::{String, IntoString};\n use vec::Vec;\n \n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n@@ -331,9 +331,7 @@ impl AsciiStr for [Ascii] {\n impl IntoString for Vec<Ascii> {\n     #[inline]\n     fn into_string(self) -> String {\n-        unsafe {\n-            string::raw::from_utf8(self.into_bytes())\n-        }\n+        unsafe { String::from_utf8_unchecked(self.into_bytes()) }\n     }\n }\n \n@@ -394,13 +392,13 @@ impl AsciiExt<String> for str {\n     #[inline]\n     fn to_ascii_upper(&self) -> String {\n         // Vec<u8>::to_ascii_upper() preserves the UTF-8 invariant.\n-        unsafe { string::raw::from_utf8(self.as_bytes().to_ascii_upper()) }\n+        unsafe { String::from_utf8_unchecked(self.as_bytes().to_ascii_upper()) }\n     }\n \n     #[inline]\n     fn to_ascii_lower(&self) -> String {\n         // Vec<u8>::to_ascii_lower() preserves the UTF-8 invariant.\n-        unsafe { string::raw::from_utf8(self.as_bytes().to_ascii_lower()) }\n+        unsafe { String::from_utf8_unchecked(self.as_bytes().to_ascii_lower()) }\n     }\n \n     #[inline]\n@@ -413,13 +411,13 @@ impl OwnedAsciiExt for String {\n     #[inline]\n     fn into_ascii_upper(self) -> String {\n         // Vec<u8>::into_ascii_upper() preserves the UTF-8 invariant.\n-        unsafe { string::raw::from_utf8(self.into_bytes().into_ascii_upper()) }\n+        unsafe { String::from_utf8_unchecked(self.into_bytes().into_ascii_upper()) }\n     }\n \n     #[inline]\n     fn into_ascii_lower(self) -> String {\n         // Vec<u8>::into_ascii_lower() preserves the UTF-8 invariant.\n-        unsafe { string::raw::from_utf8(self.into_bytes().into_ascii_lower()) }\n+        unsafe { String::from_utf8_unchecked(self.into_bytes().into_ascii_lower()) }\n     }\n }\n "}, {"sha": "b3591cd64081b693f20b56a82d77864829799914", "filename": "src/libstd/os.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -248,7 +248,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n     unsafe {\n         #[cfg(windows)]\n         unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n-            use slice::raw;\n+            use slice;\n \n             use libc::funcs::extra::kernel32::{\n                 GetEnvironmentStringsW,\n@@ -281,9 +281,9 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n                 while *(p as *const _).offset(len) != 0 {\n                     len += 1;\n                 }\n-                raw::buf_as_slice(p, len as uint, |s| {\n-                    result.push(String::from_utf16_lossy(s).into_bytes());\n-                });\n+                let p = p as *const u16;\n+                let s = slice::from_raw_buf(&p, len as uint);\n+                result.push(String::from_utf16_lossy(s).into_bytes());\n                 i += len as int + 1;\n             }\n             FreeEnvironmentStringsW(ch);\n@@ -1071,9 +1071,9 @@ fn real_args() -> Vec<String> {\n         while *ptr.offset(len as int) != 0 { len += 1; }\n \n         // Push it onto the list.\n-        let opt_s = slice::raw::buf_as_slice(ptr as *const _, len, |buf| {\n-            String::from_utf16(::str::truncate_utf16_at_nul(buf))\n-        });\n+        let ptr = ptr as *const u16;\n+        let buf = slice::from_raw_buf(&ptr, len);\n+        let opt_s = String::from_utf16(::str::truncate_utf16_at_nul(buf));\n         opt_s.expect(\"CommandLineToArgvW returned invalid UTF-16\")\n     });\n "}, {"sha": "d951977fa5943e0514cc239ad1a7c0f083d53458", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641e2a110de4bb1b2c2b596ef1168ae7865aa529/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=641e2a110de4bb1b2c2b596ef1168ae7865aa529", "patch": "@@ -98,7 +98,7 @@ pub fn error_string(errno: i32) -> String {\n             panic!(\"strerror_r failure\");\n         }\n \n-        ::string::raw::from_buf(p as *const u8)\n+        String::from_raw_buf(p as *const u8)\n     }\n }\n "}]}