{"sha": "5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlN2VlYzJlYWE4YjI1ZDhhNjA3YTljZWQzZWY0ZGYwMWFhYjM3ODc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-19T06:56:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-19T06:56:02Z"}, "message": "Rollup merge of #72497 - RalfJung:tag-term, r=oli-obk\n\ntag/niche terminology cleanup\n\nThe term \"discriminant\" was used in two ways throughout the compiler:\n* every enum variant has a corresponding discriminant, that can be given explicitly with `Variant = N`.\n* that discriminant is then encoded in memory to store which variant is active -- but this encoded form of the discriminant was also often called \"discriminant\", even though it is conceptually quite different (e.g., it can be smaller in size, or even use niche-filling).\n\nAfter discussion with @eddyb, this renames the second term to \"tag\". The way the tag is encoded can be either `TagEncoding::Direct` (formerly `DiscriminantKind::Tag`) or `TagEncoding::Niche` (formerly `DiscrimianntKind::Niche`).\n\nThis finally resolves some long-standing confusion I had about the handling of variant indices and discriminants, which surfaced in https://github.com/rust-lang/rust/pull/72419.\n\n(There is also a `DiscriminantKind` type in libcore, it remains unaffected. I think this corresponds to the discriminant, not the tag, so that seems all right.)\n\nr? @eddyb", "tree": {"sha": "a4ab90836968694f335adcc5582e2b98edc570cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4ab90836968694f335adcc5582e2b98edc570cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe7GGCCRBK7hj4Ov3rIwAAdHIIAK4IrPIzLYaaIN8ohLgkgn/T\nZBTlpgnb5BWe/jzlF4NsNyAConAsyQX4E0856gsrmg8ze432bIvw1elCOBB+SuHI\nupyvX75OZX4He61KdC2y7ZYqVzNLLEwXuFiml7Tn5gF0DSEOkIl5NlznssWqJnQB\n6cROU2RDVy5vsXcRYvfxX8qAZC7KEmCr/vdHjvqcyzbuyvjMrTy+cUA3B2xCfZnr\ni1WBzFxXLIo5JgX9UUAr2lYYQnwHHNIkYUydCrP3CNA2WHm+qXFWXY1RH9ZNjHDB\ntde28jIY9/deCGwtTrLjtqwGOdFvx8cvZveZqR9izJ5/AEsMiwU6ZHxsDKnZd/E=\n=whVS\n-----END PGP SIGNATURE-----\n", "payload": "tree a4ab90836968694f335adcc5582e2b98edc570cc\nparent 99be102a6d18ec05178a0f55ece6c65f65e38c48\nparent 10c8d2afb8b90e03e2d1563df021146150338c45\nauthor Ralf Jung <post@ralfj.de> 1592549762 +0200\ncommitter GitHub <noreply@github.com> 1592549762 +0200\n\nRollup merge of #72497 - RalfJung:tag-term, r=oli-obk\n\ntag/niche terminology cleanup\n\nThe term \"discriminant\" was used in two ways throughout the compiler:\n* every enum variant has a corresponding discriminant, that can be given explicitly with `Variant = N`.\n* that discriminant is then encoded in memory to store which variant is active -- but this encoded form of the discriminant was also often called \"discriminant\", even though it is conceptually quite different (e.g., it can be smaller in size, or even use niche-filling).\n\nAfter discussion with @eddyb, this renames the second term to \"tag\". The way the tag is encoded can be either `TagEncoding::Direct` (formerly `DiscriminantKind::Tag`) or `TagEncoding::Niche` (formerly `DiscrimianntKind::Niche`).\n\nThis finally resolves some long-standing confusion I had about the handling of variant indices and discriminants, which surfaced in https://github.com/rust-lang/rust/pull/72419.\n\n(There is also a `DiscriminantKind` type in libcore, it remains unaffected. I think this corresponds to the discriminant, not the tag, so that seems all right.)\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "html_url": "https://github.com/rust-lang/rust/commit/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99be102a6d18ec05178a0f55ece6c65f65e38c48", "url": "https://api.github.com/repos/rust-lang/rust/commits/99be102a6d18ec05178a0f55ece6c65f65e38c48", "html_url": "https://github.com/rust-lang/rust/commit/99be102a6d18ec05178a0f55ece6c65f65e38c48"}, {"sha": "10c8d2afb8b90e03e2d1563df021146150338c45", "url": "https://api.github.com/repos/rust-lang/rust/commits/10c8d2afb8b90e03e2d1563df021146150338c45", "html_url": "https://github.com/rust-lang/rust/commit/10c8d2afb8b90e03e2d1563df021146150338c45"}], "stats": {"total": 361, "additions": 181, "deletions": 180}, "files": [{"sha": "8a957a729fb68b496a2efab490e0a7a45fca892a", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 53, "deletions": 55, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "patch": "@@ -1,4 +1,4 @@\n-use self::EnumDiscriminantInfo::*;\n+use self::EnumTagInfo::*;\n use self::MemberDescriptionFactory::*;\n use self::RecursiveTypeDescription::*;\n \n@@ -40,7 +40,7 @@ use rustc_middle::{bug, span_bug};\n use rustc_session::config::{self, DebugInfo};\n use rustc_span::symbol::{Interner, Symbol};\n use rustc_span::{self, SourceFile, SourceFileHash, Span};\n-use rustc_target::abi::{Abi, Align, DiscriminantKind, HasDataLayout, Integer, LayoutOf};\n+use rustc_target::abi::{Abi, Align, HasDataLayout, Integer, LayoutOf, TagEncoding};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{Primitive, Size, VariantIdx, Variants};\n \n@@ -1335,7 +1335,7 @@ fn generator_layout_and_saved_local_names(\n struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n     enum_type: Ty<'tcx>,\n     layout: TyAndLayout<'tcx>,\n-    discriminant_type_metadata: Option<&'ll DIType>,\n+    tag_type_metadata: Option<&'ll DIType>,\n     containing_scope: &'ll DIScope,\n     span: Span,\n }\n@@ -1385,7 +1385,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     cx,\n                     self.layout,\n                     variant_info,\n-                    NoDiscriminant,\n+                    NoTag,\n                     self_metadata,\n                     self.span,\n                 );\n@@ -1409,19 +1409,19 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 }]\n             }\n             Variants::Multiple {\n-                discr_kind: DiscriminantKind::Tag,\n-                discr_index,\n+                tag_encoding: TagEncoding::Direct,\n+                tag_field,\n                 ref variants,\n                 ..\n             } => {\n-                let discriminant_info = if fallback {\n-                    RegularDiscriminant {\n-                        discr_field: Field::from(discr_index),\n-                        discr_type_metadata: self.discriminant_type_metadata.unwrap(),\n+                let tag_info = if fallback {\n+                    RegularTag {\n+                        tag_field: Field::from(tag_field),\n+                        tag_type_metadata: self.tag_type_metadata.unwrap(),\n                     }\n                 } else {\n                     // This doesn't matter in this case.\n-                    NoDiscriminant\n+                    NoTag\n                 };\n                 variants\n                     .iter_enumerated()\n@@ -1432,7 +1432,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                             cx,\n                             variant,\n                             variant_info,\n-                            discriminant_info,\n+                            tag_info,\n                             self_metadata,\n                             self.span,\n                         );\n@@ -1467,11 +1467,11 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     .collect()\n             }\n             Variants::Multiple {\n-                discr_kind:\n-                    DiscriminantKind::Niche { ref niche_variants, niche_start, dataful_variant },\n-                ref discr,\n+                tag_encoding:\n+                    TagEncoding::Niche { ref niche_variants, niche_start, dataful_variant },\n+                ref tag,\n                 ref variants,\n-                discr_index,\n+                tag_field,\n             } => {\n                 if fallback {\n                     let variant = self.layout.for_variant(cx, dataful_variant);\n@@ -1480,7 +1480,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         cx,\n                         variant,\n                         variant_info_for(dataful_variant),\n-                        OptimizedDiscriminant,\n+                        OptimizedTag,\n                         self.containing_scope,\n                         self.span,\n                     );\n@@ -1524,8 +1524,8 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         cx,\n                         &mut name,\n                         self.layout,\n-                        self.layout.fields.offset(discr_index),\n-                        self.layout.field(cx, discr_index).size,\n+                        self.layout.fields.offset(tag_field),\n+                        self.layout.field(cx, tag_field).size,\n                     );\n                     variant_info_for(*niche_variants.start()).map_struct_name(|variant_name| {\n                         name.push_str(variant_name);\n@@ -1552,7 +1552,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                     cx,\n                                     variant,\n                                     variant_info,\n-                                    OptimizedDiscriminant,\n+                                    OptimizedTag,\n                                     self_metadata,\n                                     self.span,\n                                 );\n@@ -1573,7 +1573,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                 let value = (i.as_u32() as u128)\n                                     .wrapping_sub(niche_variants.start().as_u32() as u128)\n                                     .wrapping_add(niche_start);\n-                                let value = truncate(value, discr.value.size(cx));\n+                                let value = truncate(value, tag.value.size(cx));\n                                 // NOTE(eddyb) do *NOT* remove this assert, until\n                                 // we pass the full 128-bit value to LLVM, otherwise\n                                 // truncation will be silent and remain undetected.\n@@ -1603,7 +1603,7 @@ struct VariantMemberDescriptionFactory<'ll, 'tcx> {\n     /// Cloned from the `layout::Struct` describing the variant.\n     offsets: Vec<Size>,\n     args: Vec<(String, Ty<'tcx>)>,\n-    discriminant_type_metadata: Option<&'ll DIType>,\n+    tag_type_metadata: Option<&'ll DIType>,\n     span: Span,\n }\n \n@@ -1617,7 +1617,7 @@ impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n                 MemberDescription {\n                     name: name.to_string(),\n                     type_metadata: if use_enum_fallback(cx) {\n-                        match self.discriminant_type_metadata {\n+                        match self.tag_type_metadata {\n                             // Discriminant is always the first field of our variant\n                             // when using the enum fallback.\n                             Some(metadata) if i == 0 => metadata,\n@@ -1637,11 +1637,14 @@ impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n     }\n }\n \n+// FIXME: terminology here should be aligned with `abi::TagEncoding`.\n+// `OptimizedTag` is `TagEncoding::Niche`, `RegularTag` is `TagEncoding::Direct`.\n+// `NoTag` should be removed; users should use `Option<EnumTagInfo>` instead.\n #[derive(Copy, Clone)]\n-enum EnumDiscriminantInfo<'ll> {\n-    RegularDiscriminant { discr_field: Field, discr_type_metadata: &'ll DIType },\n-    OptimizedDiscriminant,\n-    NoDiscriminant,\n+enum EnumTagInfo<'ll> {\n+    RegularTag { tag_field: Field, tag_type_metadata: &'ll DIType },\n+    OptimizedTag,\n+    NoTag,\n }\n \n #[derive(Copy, Clone)]\n@@ -1706,7 +1709,7 @@ fn describe_enum_variant(\n     cx: &CodegenCx<'ll, 'tcx>,\n     layout: layout::TyAndLayout<'tcx>,\n     variant: VariantInfo<'_, 'tcx>,\n-    discriminant_info: EnumDiscriminantInfo<'ll>,\n+    discriminant_info: EnumTagInfo<'ll>,\n     containing_scope: &'ll DIScope,\n     span: Span,\n ) -> (&'ll DICompositeType, MemberDescriptionFactory<'ll, 'tcx>) {\n@@ -1722,12 +1725,12 @@ fn describe_enum_variant(\n     let (offsets, args) = if use_enum_fallback(cx) {\n         // If this is not a univariant enum, there is also the discriminant field.\n         let (discr_offset, discr_arg) = match discriminant_info {\n-            RegularDiscriminant { discr_field, .. } => {\n+            RegularTag { tag_field, .. } => {\n                 // We have the layout of an enum variant, we need the layout of the outer enum\n                 let enum_layout = cx.layout_of(layout.ty);\n-                let offset = enum_layout.fields.offset(discr_field.as_usize());\n+                let offset = enum_layout.fields.offset(tag_field.as_usize());\n                 let args =\n-                    (\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, discr_field.as_usize()).ty);\n+                    (\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, tag_field.as_usize()).ty);\n                 (Some(offset), Some(args))\n             }\n             _ => (None, None),\n@@ -1757,8 +1760,8 @@ fn describe_enum_variant(\n     let member_description_factory = VariantMDF(VariantMemberDescriptionFactory {\n         offsets,\n         args,\n-        discriminant_type_metadata: match discriminant_info {\n-            RegularDiscriminant { discr_type_metadata, .. } => Some(discr_type_metadata),\n+        tag_type_metadata: match discriminant_info {\n+            RegularTag { tag_type_metadata, .. } => Some(tag_type_metadata),\n             _ => None,\n         },\n         span,\n@@ -1880,18 +1883,18 @@ fn prepare_enum_metadata(\n \n     if let (\n         &Abi::Scalar(_),\n-        &Variants::Multiple { discr_kind: DiscriminantKind::Tag, ref discr, .. },\n+        &Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, .. },\n     ) = (&layout.abi, &layout.variants)\n     {\n-        return FinalMetadata(discriminant_type_metadata(discr.value));\n+        return FinalMetadata(discriminant_type_metadata(tag.value));\n     }\n \n     if use_enum_fallback(cx) {\n         let discriminant_type_metadata = match layout.variants {\n             Variants::Single { .. }\n-            | Variants::Multiple { discr_kind: DiscriminantKind::Niche { .. }, .. } => None,\n-            Variants::Multiple { discr_kind: DiscriminantKind::Tag, ref discr, .. } => {\n-                Some(discriminant_type_metadata(discr.value))\n+            | Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, .. } => None,\n+            Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, .. } => {\n+                Some(discriminant_type_metadata(tag.value))\n             }\n         };\n \n@@ -1927,7 +1930,7 @@ fn prepare_enum_metadata(\n             EnumMDF(EnumMemberDescriptionFactory {\n                 enum_type,\n                 layout,\n-                discriminant_type_metadata,\n+                tag_type_metadata: discriminant_type_metadata,\n                 containing_scope,\n                 span,\n             }),\n@@ -1943,24 +1946,21 @@ fn prepare_enum_metadata(\n         Variants::Single { .. } => None,\n \n         Variants::Multiple {\n-            discr_kind: DiscriminantKind::Niche { .. },\n-            ref discr,\n-            discr_index,\n-            ..\n+            tag_encoding: TagEncoding::Niche { .. }, ref tag, tag_field, ..\n         } => {\n             // Find the integer type of the correct size.\n-            let size = discr.value.size(cx);\n-            let align = discr.value.align(cx);\n+            let size = tag.value.size(cx);\n+            let align = tag.value.align(cx);\n \n-            let discr_type = match discr.value {\n+            let tag_type = match tag.value {\n                 Int(t, _) => t,\n                 F32 => Integer::I32,\n                 F64 => Integer::I64,\n                 Pointer => cx.data_layout().ptr_sized_integer(),\n             }\n             .to_ty(cx.tcx, false);\n \n-            let discr_metadata = basic_type_metadata(cx, discr_type);\n+            let tag_metadata = basic_type_metadata(cx, tag_type);\n             unsafe {\n                 Some(llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n@@ -1971,17 +1971,15 @@ fn prepare_enum_metadata(\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n                     align.abi.bits() as u32,\n-                    layout.fields.offset(discr_index).bits(),\n+                    layout.fields.offset(tag_field).bits(),\n                     DIFlags::FlagArtificial,\n-                    discr_metadata,\n+                    tag_metadata,\n                 ))\n             }\n         }\n \n-        Variants::Multiple {\n-            discr_kind: DiscriminantKind::Tag, ref discr, discr_index, ..\n-        } => {\n-            let discr_type = discr.value.to_ty(cx.tcx);\n+        Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, tag_field, .. } => {\n+            let discr_type = tag.value.to_ty(cx.tcx);\n             let (size, align) = cx.size_and_align_of(discr_type);\n \n             let discr_metadata = basic_type_metadata(cx, discr_type);\n@@ -1995,7 +1993,7 @@ fn prepare_enum_metadata(\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n                     align.bits() as u32,\n-                    layout.fields.offset(discr_index).bits(),\n+                    layout.fields.offset(tag_field).bits(),\n                     DIFlags::FlagArtificial,\n                     discr_metadata,\n                 ))\n@@ -2081,7 +2079,7 @@ fn prepare_enum_metadata(\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type,\n             layout,\n-            discriminant_type_metadata: None,\n+            tag_type_metadata: None,\n             containing_scope,\n             span,\n         }),"}, {"sha": "0c8638b673d4fbdab5269a40588e22b2d458ba34", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::mir;\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::ty::layout::{HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::{self, Ty};\n-use rustc_target::abi::{Abi, Align, DiscriminantKind, FieldsShape, Int};\n+use rustc_target::abi::{Abi, Align, FieldsShape, Int, TagEncoding};\n use rustc_target::abi::{LayoutOf, VariantIdx, Variants};\n \n #[derive(Copy, Clone, Debug)]\n@@ -199,7 +199,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         if self.layout.abi.is_uninhabited() {\n             return bx.cx().const_undef(cast_to);\n         }\n-        let (discr_scalar, discr_kind, discr_index) = match self.layout.variants {\n+        let (tag_scalar, tag_encoding, tag_field) = match self.layout.variants {\n             Variants::Single { index } => {\n                 let discr_val = self\n                     .layout\n@@ -208,33 +208,33 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     .map_or(index.as_u32() as u128, |discr| discr.val);\n                 return bx.cx().const_uint_big(cast_to, discr_val);\n             }\n-            Variants::Multiple { ref discr, ref discr_kind, discr_index, .. } => {\n-                (discr, discr_kind, discr_index)\n+            Variants::Multiple { ref tag, ref tag_encoding, tag_field, .. } => {\n+                (tag, tag_encoding, tag_field)\n             }\n         };\n \n         // Read the tag/niche-encoded discriminant from memory.\n-        let encoded_discr = self.project_field(bx, discr_index);\n-        let encoded_discr = bx.load_operand(encoded_discr);\n+        let tag = self.project_field(bx, tag_field);\n+        let tag = bx.load_operand(tag);\n \n         // Decode the discriminant (specifically if it's niche-encoded).\n-        match *discr_kind {\n-            DiscriminantKind::Tag => {\n-                let signed = match discr_scalar.value {\n+        match *tag_encoding {\n+            TagEncoding::Direct => {\n+                let signed = match tag_scalar.value {\n                     // We use `i1` for bytes that are always `0` or `1`,\n                     // e.g., `#[repr(i8)] enum E { A, B }`, but we can't\n                     // let LLVM interpret the `i1` as signed, because\n                     // then `i1 1` (i.e., `E::B`) is effectively `i8 -1`.\n-                    Int(_, signed) => !discr_scalar.is_bool() && signed,\n+                    Int(_, signed) => !tag_scalar.is_bool() && signed,\n                     _ => false,\n                 };\n-                bx.intcast(encoded_discr.immediate(), cast_to, signed)\n+                bx.intcast(tag.immediate(), cast_to, signed)\n             }\n-            DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+            TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n                 // Rebase from niche values to discriminants, and check\n                 // whether the result is in range for the niche variants.\n-                let niche_llty = bx.cx().immediate_backend_type(encoded_discr.layout);\n-                let encoded_discr = encoded_discr.immediate();\n+                let niche_llty = bx.cx().immediate_backend_type(tag.layout);\n+                let tag = tag.immediate();\n \n                 // We first compute the \"relative discriminant\" (wrt `niche_variants`),\n                 // that is, if `n = niche_variants.end() - niche_variants.start()`,\n@@ -248,9 +248,9 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 let relative_discr = if niche_start == 0 {\n                     // Avoid subtracting `0`, which wouldn't work for pointers.\n                     // FIXME(eddyb) check the actual primitive type here.\n-                    encoded_discr\n+                    tag\n                 } else {\n-                    bx.sub(encoded_discr, bx.cx().const_uint_big(niche_llty, niche_start))\n+                    bx.sub(tag, bx.cx().const_uint_big(niche_llty, niche_start))\n                 };\n                 let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n                 let is_niche = {\n@@ -312,8 +312,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n             Variants::Single { index } => {\n                 assert_eq!(index, variant_index);\n             }\n-            Variants::Multiple { discr_kind: DiscriminantKind::Tag, discr_index, .. } => {\n-                let ptr = self.project_field(bx, discr_index);\n+            Variants::Multiple { tag_encoding: TagEncoding::Direct, tag_field, .. } => {\n+                let ptr = self.project_field(bx, tag_field);\n                 let to =\n                     self.layout.ty.discriminant_for_variant(bx.tcx(), variant_index).unwrap().val;\n                 bx.store(\n@@ -323,9 +323,9 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 );\n             }\n             Variants::Multiple {\n-                discr_kind:\n-                    DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start },\n-                discr_index,\n+                tag_encoding:\n+                    TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n+                tag_field,\n                 ..\n             } => {\n                 if variant_index != dataful_variant {\n@@ -339,7 +339,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                         bx.memset(self.llval, fill_byte, size, self.align, MemFlags::empty());\n                     }\n \n-                    let niche = self.project_field(bx, discr_index);\n+                    let niche = self.project_field(bx, tag_field);\n                     let niche_llty = bx.cx().immediate_backend_type(niche.layout);\n                     let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                     let niche_value = (niche_value as u128).wrapping_add(niche_start);"}, {"sha": "d1445f1b2c4a3c3b642cce36e0d18653cdf64141", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use rustc_target::abi::{DiscriminantKind, Integer, LayoutOf, VariantIdx, Variants};\n+use rustc_target::abi::{Integer, LayoutOf, TagEncoding, VariantIdx, Variants};\n use rustc_target::spec::abi::Abi;\n \n use log::debug;\n@@ -1056,15 +1056,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n             };\n             let (variants, tag) = match layout.variants {\n                 Variants::Multiple {\n-                    discr_kind: DiscriminantKind::Tag,\n-                    ref discr,\n+                    tag_encoding: TagEncoding::Direct,\n+                    ref tag,\n                     ref variants,\n                     ..\n-                } => (variants, discr),\n+                } => (variants, tag),\n                 _ => return,\n             };\n \n-            let discr_size = tag.value.size(&cx.tcx).bytes();\n+            let tag_size = tag.value.size(&cx.tcx).bytes();\n \n             debug!(\n                 \"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n@@ -1078,8 +1078,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 .iter()\n                 .zip(variants)\n                 .map(|(variant, variant_layout)| {\n-                    // Subtract the size of the enum discriminant.\n-                    let bytes = variant_layout.size.bytes().saturating_sub(discr_size);\n+                    // Subtract the size of the enum tag.\n+                    let bytes = variant_layout.size.bytes().saturating_sub(tag_size);\n \n                     debug!(\"- variant `{}` is {} bytes large\", variant.ident, bytes);\n                     bytes"}, {"sha": "abbbbf7fbd6a46bc3fde0b300403334fda4983d6", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "patch": "@@ -390,8 +390,8 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     InvalidBool(u8),\n     /// Using a non-character `u32` as character.\n     InvalidChar(u32),\n-    /// An enum discriminant was set to a value which was outside the range of valid values.\n-    InvalidDiscriminant(Scalar),\n+    /// The tag of an enum does not encode an actual discriminant.\n+    InvalidTag(Scalar),\n     /// Using a pointer-not-to-a-function as function pointer.\n     InvalidFunctionPointer(Pointer),\n     /// Using a string that is not valid UTF-8,\n@@ -463,7 +463,7 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n             InvalidChar(c) => {\n                 write!(f, \"interpreting an invalid 32-bit value as a char: 0x{:08x}\", c)\n             }\n-            InvalidDiscriminant(val) => write!(f, \"enum value has invalid discriminant: {}\", val),\n+            InvalidTag(val) => write!(f, \"enum value has invalid tag: {}\", val),\n             InvalidFunctionPointer(p) => {\n                 write!(f, \"using {} as function pointer but it does not point to a function\", p)\n             }"}, {"sha": "80f919d0c032916f608ed0323a3e70efa175b5f3", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "patch": "@@ -974,13 +974,13 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                             return Ok(tcx.intern_layout(Layout {\n                                 variants: Variants::Multiple {\n-                                    discr: niche_scalar,\n-                                    discr_kind: DiscriminantKind::Niche {\n+                                    tag: niche_scalar,\n+                                    tag_encoding: TagEncoding::Niche {\n                                         dataful_variant: i,\n                                         niche_variants,\n                                         niche_start,\n                                     },\n-                                    discr_index: 0,\n+                                    tag_field: 0,\n                                     variants: st,\n                                 },\n                                 fields: FieldsShape::Arbitrary {\n@@ -1216,9 +1216,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 tcx.intern_layout(Layout {\n                     variants: Variants::Multiple {\n-                        discr: tag,\n-                        discr_kind: DiscriminantKind::Tag,\n-                        discr_index: 0,\n+                        tag,\n+                        tag_encoding: TagEncoding::Direct,\n+                        tag_field: 0,\n                         variants: layout_variants,\n                     },\n                     fields: FieldsShape::Arbitrary {\n@@ -1399,15 +1399,15 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // Build a prefix layout, including \"promoting\" all ineligible\n         // locals as part of the prefix. We compute the layout of all of\n         // these fields at once to get optimal packing.\n-        let discr_index = substs.as_generator().prefix_tys().count();\n+        let tag_index = substs.as_generator().prefix_tys().count();\n \n         // `info.variant_fields` already accounts for the reserved variants, so no need to add them.\n         let max_discr = (info.variant_fields.len() - 1) as u128;\n         let discr_int = Integer::fit_unsigned(max_discr);\n         let discr_int_ty = discr_int.to_ty(tcx, false);\n-        let discr = Scalar { value: Primitive::Int(discr_int, false), valid_range: 0..=max_discr };\n-        let discr_layout = self.tcx.intern_layout(Layout::scalar(self, discr.clone()));\n-        let discr_layout = TyAndLayout { ty: discr_int_ty, layout: discr_layout };\n+        let tag = Scalar { value: Primitive::Int(discr_int, false), valid_range: 0..=max_discr };\n+        let tag_layout = self.tcx.intern_layout(Layout::scalar(self, tag.clone()));\n+        let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout };\n \n         let promoted_layouts = ineligible_locals\n             .iter()\n@@ -1418,7 +1418,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             .as_generator()\n             .prefix_tys()\n             .map(|ty| self.layout_of(ty))\n-            .chain(iter::once(Ok(discr_layout)))\n+            .chain(iter::once(Ok(tag_layout)))\n             .chain(promoted_layouts)\n             .collect::<Result<Vec<_>, _>>()?;\n         let prefix = self.univariant_uninterned(\n@@ -1441,7 +1441,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 // \"a\" (`0..b_start`) and \"b\" (`b_start..`) correspond to\n                 // \"outer\" and \"promoted\" fields respectively.\n-                let b_start = (discr_index + 1) as u32;\n+                let b_start = (tag_index + 1) as u32;\n                 let offsets_b = offsets.split_off(b_start as usize);\n                 let offsets_a = offsets;\n \n@@ -1558,9 +1558,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         let layout = tcx.intern_layout(Layout {\n             variants: Variants::Multiple {\n-                discr,\n-                discr_kind: DiscriminantKind::Tag,\n-                discr_index,\n+                tag: tag,\n+                tag_encoding: TagEncoding::Direct,\n+                tag_field: tag_index,\n                 variants,\n             },\n             fields: outer_fields,\n@@ -1680,7 +1680,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }\n             }\n \n-            Variants::Multiple { ref discr, ref discr_kind, .. } => {\n+            Variants::Multiple { ref tag, ref tag_encoding, .. } => {\n                 debug!(\n                     \"print-type-size `{:#?}` adt general variants def {}\",\n                     layout.ty,\n@@ -1702,8 +1702,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 record(\n                     adt_kind.into(),\n                     adt_packed,\n-                    match discr_kind {\n-                        DiscriminantKind::Tag => Some(discr.value.size(self)),\n+                    match tag_encoding {\n+                        TagEncoding::Direct => Some(tag.value.size(self)),\n                         _ => None,\n                     },\n                     variant_infos,\n@@ -2028,11 +2028,11 @@ where\n \n     fn field(this: TyAndLayout<'tcx>, cx: &C, i: usize) -> C::TyAndLayout {\n         let tcx = cx.tcx();\n-        let discr_layout = |discr: &Scalar| -> C::TyAndLayout {\n-            let layout = Layout::scalar(cx, discr.clone());\n+        let tag_layout = |tag: &Scalar| -> C::TyAndLayout {\n+            let layout = Layout::scalar(cx, tag.clone());\n             MaybeResult::from(Ok(TyAndLayout {\n                 layout: tcx.intern_layout(layout),\n-                ty: discr.value.to_ty(tcx),\n+                ty: tag.value.to_ty(tcx),\n             }))\n         };\n \n@@ -2109,9 +2109,9 @@ where\n                     .unwrap()\n                     .nth(i)\n                     .unwrap(),\n-                Variants::Multiple { ref discr, discr_index, .. } => {\n-                    if i == discr_index {\n-                        return discr_layout(discr);\n+                Variants::Multiple { ref tag, tag_field, .. } => {\n+                    if i == tag_field {\n+                        return tag_layout(tag);\n                     }\n                     substs.as_generator().prefix_tys().nth(i).unwrap()\n                 }\n@@ -2128,9 +2128,9 @@ where\n                     Variants::Single { index } => def.variants[index].fields[i].ty(tcx, substs),\n \n                     // Discriminant field for enums (where applicable).\n-                    Variants::Multiple { ref discr, .. } => {\n+                    Variants::Multiple { ref tag, .. } => {\n                         assert_eq!(i, 0);\n-                        return discr_layout(discr);\n+                        return tag_layout(tag);\n                     }\n                 }\n             }\n@@ -2207,10 +2207,10 @@ where\n                     // using more niches than just null (e.g., the first page of\n                     // the address space, or unaligned pointers).\n                     Variants::Multiple {\n-                        discr_kind: DiscriminantKind::Niche { dataful_variant, .. },\n-                        discr_index,\n+                        tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n+                        tag_field,\n                         ..\n-                    } if this.fields.offset(discr_index) == offset => {\n+                    } if this.fields.offset(tag_field) == offset => {\n                         Some(this.for_variant(cx, dataful_variant))\n                     }\n                     _ => Some(this),"}, {"sha": "35e433c4bd5cd28a3b20844619fce6db1f27297e", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::ty::layout::{PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Printer};\n use rustc_middle::ty::Ty;\n use rustc_middle::{mir, ty};\n-use rustc_target::abi::{Abi, DiscriminantKind, HasDataLayout, LayoutOf, Size};\n+use rustc_target::abi::{Abi, HasDataLayout, LayoutOf, Size, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n@@ -587,7 +587,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         op: OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, VariantIdx)> {\n         trace!(\"read_discriminant_value {:#?}\", op.layout);\n-\n         // Get type and layout of the discriminant.\n         let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(*self.tcx))?;\n         trace!(\"discriminant type: {:?}\", discr_layout.ty);\n@@ -596,10 +595,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // This is not to be confused with its \"variant index\", which is just determining its position in the\n         // declared list of variants -- they can differ with explicitly assigned discriminants.\n         // We use \"tag\" to refer to how the discriminant is encoded in memory, which can be either\n-        // straight-forward (`DiscriminantKind::Tag`) or with a niche (`DiscriminantKind::Niche`).\n-        // Unfortunately, the rest of the compiler calls the latter \"discriminant\", too, which makes things\n-        // rather confusing.\n-        let (tag_scalar_layout, tag_kind, tag_index) = match op.layout.variants {\n+        // straight-forward (`TagEncoding::Direct`) or with a niche (`TagEncoding::Niche`).\n+        let (tag_scalar_layout, tag_encoding, tag_field) = match op.layout.variants {\n             Variants::Single { index } => {\n                 let discr = match op.layout.ty.discriminant_for_variant(*self.tcx, index) {\n                     Some(discr) => {\n@@ -615,8 +612,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 return Ok((discr, index));\n             }\n-            Variants::Multiple { ref discr, ref discr_kind, discr_index, .. } => {\n-                (discr, discr_kind, discr_index)\n+            Variants::Multiple { ref tag, ref tag_encoding, tag_field, .. } => {\n+                (tag, tag_encoding, tag_field)\n             }\n         };\n \n@@ -633,21 +630,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let tag_layout = self.layout_of(tag_scalar_layout.value.to_int_ty(*self.tcx))?;\n \n         // Read tag and sanity-check `tag_layout`.\n-        let tag_val = self.read_immediate(self.operand_field(op, tag_index)?)?;\n+        let tag_val = self.read_immediate(self.operand_field(op, tag_field)?)?;\n         assert_eq!(tag_layout.size, tag_val.layout.size);\n         assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n         let tag_val = tag_val.to_scalar()?;\n         trace!(\"tag value: {:?}\", tag_val);\n \n         // Figure out which discriminant and variant this corresponds to.\n-        Ok(match *tag_kind {\n-            DiscriminantKind::Tag => {\n+        Ok(match *tag_encoding {\n+            TagEncoding::Direct => {\n                 let tag_bits = self\n                     .force_bits(tag_val, tag_layout.size)\n-                    .map_err(|_| err_ub!(InvalidDiscriminant(tag_val.erase_tag())))?;\n+                    .map_err(|_| err_ub!(InvalidTag(tag_val.erase_tag())))?;\n                 // Cast bits from tag layout to discriminant layout.\n-                let discr_val_cast = self.cast_from_scalar(tag_bits, tag_layout, discr_layout.ty);\n-                let discr_bits = discr_val_cast.assert_bits(discr_layout.size);\n+                let discr_val = self.cast_from_scalar(tag_bits, tag_layout, discr_layout.ty);\n+                let discr_bits = discr_val.assert_bits(discr_layout.size);\n                 // Convert discriminant to variant index, and catch invalid discriminants.\n                 let index = match op.layout.ty.kind {\n                     ty::Adt(adt, _) => {\n@@ -661,11 +658,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),\n                 }\n-                .ok_or_else(|| err_ub!(InvalidDiscriminant(tag_val.erase_tag())))?;\n+                .ok_or_else(|| err_ub!(InvalidTag(tag_val.erase_tag())))?;\n                 // Return the cast value, and the index.\n-                (discr_val_cast, index.0)\n+                (discr_val, index.0)\n             }\n-            DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+            TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n                 // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n                 // discriminant (encoded in niche/tag) and variant index are the same.\n                 let variants_start = niche_variants.start().as_u32();\n@@ -677,7 +674,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             && variants_start == variants_end\n                             && !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            throw_ub!(InvalidDiscriminant(tag_val.erase_tag()))\n+                            throw_ub!(InvalidTag(tag_val.erase_tag()))\n                         }\n                         dataful_variant\n                     }"}, {"sha": "396aec0a8f89f79a49d549ab07c0f5ac525c0519", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "patch": "@@ -9,7 +9,7 @@ use rustc_macros::HashStable;\n use rustc_middle::mir;\n use rustc_middle::ty::layout::{PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::{self, Ty};\n-use rustc_target::abi::{Abi, Align, DiscriminantKind, FieldsShape};\n+use rustc_target::abi::{Abi, Align, FieldsShape, TagEncoding};\n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, VariantIdx, Variants};\n \n use super::{\n@@ -1045,7 +1045,8 @@ where\n         MPlaceTy { mplace, layout }\n     }\n \n-    pub fn write_discriminant_index(\n+    /// Writes the discriminant of the given variant.\n+    pub fn write_discriminant(\n         &mut self,\n         variant_index: VariantIdx,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n@@ -1061,9 +1062,9 @@ where\n                 assert_eq!(index, variant_index);\n             }\n             Variants::Multiple {\n-                discr_kind: DiscriminantKind::Tag,\n-                discr: ref discr_layout,\n-                discr_index,\n+                tag_encoding: TagEncoding::Direct,\n+                tag: ref tag_layout,\n+                tag_field,\n                 ..\n             } => {\n                 // No need to validate that the discriminant here because the\n@@ -1075,17 +1076,17 @@ where\n                 // raw discriminants for enums are isize or bigger during\n                 // their computation, but the in-memory tag is the smallest possible\n                 // representation\n-                let size = discr_layout.value.size(self);\n-                let discr_val = truncate(discr_val, size);\n+                let size = tag_layout.value.size(self);\n+                let tag_val = truncate(discr_val, size);\n \n-                let discr_dest = self.place_field(dest, discr_index)?;\n-                self.write_scalar(Scalar::from_uint(discr_val, size), discr_dest)?;\n+                let tag_dest = self.place_field(dest, tag_field)?;\n+                self.write_scalar(Scalar::from_uint(tag_val, size), tag_dest)?;\n             }\n             Variants::Multiple {\n-                discr_kind:\n-                    DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start },\n-                discr: ref discr_layout,\n-                discr_index,\n+                tag_encoding:\n+                    TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n+                tag: ref tag_layout,\n+                tag_field,\n                 ..\n             } => {\n                 // No need to validate that the discriminant here because the\n@@ -1098,19 +1099,19 @@ where\n                         .checked_sub(variants_start)\n                         .expect(\"overflow computing relative variant idx\");\n                     // We need to use machine arithmetic when taking into account `niche_start`:\n-                    // discr_val = variant_index_relative + niche_start_val\n-                    let discr_layout = self.layout_of(discr_layout.value.to_int_ty(*self.tcx))?;\n-                    let niche_start_val = ImmTy::from_uint(niche_start, discr_layout);\n+                    // tag_val = variant_index_relative + niche_start_val\n+                    let tag_layout = self.layout_of(tag_layout.value.to_int_ty(*self.tcx))?;\n+                    let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n                     let variant_index_relative_val =\n-                        ImmTy::from_uint(variant_index_relative, discr_layout);\n-                    let discr_val = self.binary_op(\n+                        ImmTy::from_uint(variant_index_relative, tag_layout);\n+                    let tag_val = self.binary_op(\n                         mir::BinOp::Add,\n                         variant_index_relative_val,\n                         niche_start_val,\n                     )?;\n                     // Write result.\n-                    let niche_dest = self.place_field(dest, discr_index)?;\n-                    self.write_immediate(*discr_val, niche_dest)?;\n+                    let niche_dest = self.place_field(dest, tag_field)?;\n+                    self.write_immediate(*tag_val, niche_dest)?;\n                 }\n             }\n         }"}, {"sha": "18f9bbd2e315086bdb978d3eb11da7811a47e537", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "patch": "@@ -88,7 +88,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             SetDiscriminant { place, variant_index } => {\n                 let dest = self.eval_place(**place)?;\n-                self.write_discriminant_index(*variant_index, dest)?;\n+                self.write_discriminant(*variant_index, dest)?;\n             }\n \n             // Mark locals as alive\n@@ -179,7 +179,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Aggregate(ref kind, ref operands) => {\n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, _, active_field_index) => {\n-                        self.write_discriminant_index(variant_index, dest)?;\n+                        self.write_discriminant(variant_index, dest)?;\n                         if adt_def.is_enum() {\n                             (self.place_downcast(dest, variant_index)?, active_field_index)\n                         } else {"}, {"sha": "3bb9ba37120582fda0f770298e2daa4ba3c84c98", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "patch": "@@ -208,8 +208,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     fn aggregate_field_path_elem(&mut self, layout: TyAndLayout<'tcx>, field: usize) -> PathElem {\n         // First, check if we are projecting to a variant.\n         match layout.variants {\n-            Variants::Multiple { discr_index, .. } => {\n-                if discr_index == field {\n+            Variants::Multiple { tag_field, .. } => {\n+                if tag_field == field {\n                     return match layout.ty.kind {\n                         ty::Adt(def, ..) if def.is_enum() => PathElem::EnumTag,\n                         ty::Generator(..) => PathElem::GeneratorTag,\n@@ -697,8 +697,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         try_validation!(\n             self.walk_value(op),\n             self.path,\n-            err_ub!(InvalidDiscriminant(val)) =>\n-                { \"{}\", val } expected { \"a valid enum discriminant\" },\n+            err_ub!(InvalidTag(val)) =>\n+                { \"{}\", val } expected { \"a valid enum tag\" },\n             err_unsup!(ReadPointerAsBytes) =>\n                 { \"a pointer\" } expected { \"plain (non-pointer) bytes\" },\n         );"}, {"sha": "c79e9bb28900882ed0a41860f628a477d56b16a8", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "patch": "@@ -809,25 +809,30 @@ pub enum Variants {\n     /// Single enum variants, structs/tuples, unions, and all non-ADTs.\n     Single { index: VariantIdx },\n \n-    /// Enum-likes with more than one inhabited variant: for each case there is\n-    /// a struct, and they all have space reserved for the discriminant.\n-    /// For enums this is the sole field of the layout.\n+    /// Enum-likes with more than one inhabited variant: each variant comes with\n+    /// a *discriminant* (usually the same as the variant index but the user can\n+    /// assign explicit discriminant values).  That discriminant is encoded\n+    /// as a *tag* on the machine.  The layout of each variant is\n+    /// a struct, and they all have space reserved for the tag.\n+    /// For enums, the tag is the sole field of the layout.\n     Multiple {\n-        discr: Scalar,\n-        discr_kind: DiscriminantKind,\n-        discr_index: usize,\n+        tag: Scalar,\n+        tag_encoding: TagEncoding,\n+        tag_field: usize,\n         variants: IndexVec<VariantIdx, Layout>,\n     },\n }\n \n #[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n-pub enum DiscriminantKind {\n-    /// Integer tag holding the discriminant value itself.\n-    Tag,\n+pub enum TagEncoding {\n+    /// The tag directly stores the discriminant, but possibly with a smaller layout\n+    /// (so converting the tag to the discriminant can require sign extension).\n+    Direct,\n \n     /// Niche (values invalid for a type) encoding the discriminant:\n-    /// the variant `dataful_variant` contains a niche at an arbitrary\n-    /// offset (field `discr_index` of the enum), which for a variant with\n+    /// Discriminant and variant index coincide.\n+    /// The variant `dataful_variant` contains a niche at an arbitrary\n+    /// offset (field `tag_field` of the enum), which for a variant with\n     /// discriminant `d` is set to\n     /// `(d - niche_variants.start).wrapping_add(niche_start)`.\n     ///"}, {"sha": "93dd9a53ec99f95c3595d875e208dc49bf181652", "filename": "src/test/ui/consts/const-eval/double_check2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr?ref=5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "patch": "@@ -5,7 +5,7 @@ LL | / static FOO: (&Foo, &Bar) = unsafe {(\n LL | |     Union { u8: &BAR }.foo,\n LL | |     Union { u8: &BAR }.bar,\n LL | | )};\n-   | |___^ type validation failed: encountered 0x05 at .1.<deref>, but expected a valid enum discriminant\n+   | |___^ type validation failed: encountered 0x05 at .1.<deref>, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "1f7593c6db9b6b25f66bd958265cf92a7ff1ff12", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:24:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x00000001, but expected a valid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x00000001, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -26,7 +26,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:42:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x00000000, but expected a valid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x00000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "1a371c6b17000b6c93d2a491f88321ba4ee95230", "filename": "src/test/ui/layout/debug.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr?ref=5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "patch": "@@ -10,15 +10,15 @@ error: layout_of(E) = Layout {\n         ],\n     },\n     variants: Multiple {\n-        discr: Scalar {\n+        tag: Scalar {\n             value: Int(\n                 I32,\n                 false,\n             ),\n             valid_range: 0..=0,\n         },\n-        discr_kind: Tag,\n-        discr_index: 0,\n+        tag_encoding: Direct,\n+        tag_field: 0,\n         variants: [\n             Layout {\n                 fields: Arbitrary {\n@@ -202,15 +202,15 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n         ],\n     },\n     variants: Multiple {\n-        discr: Scalar {\n+        tag: Scalar {\n             value: Int(\n                 I32,\n                 false,\n             ),\n             valid_range: 0..=1,\n         },\n-        discr_kind: Tag,\n-        discr_index: 0,\n+        tag_encoding: Direct,\n+        tag_field: 0,\n         variants: [\n             Layout {\n                 fields: Arbitrary {"}]}