{"sha": "3aed498842473e58b8123cb57a6e3c8165769fb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhZWQ0OTg4NDI0NzNlNThiODEyM2NiNTdhNmUzYzgxNjU3NjlmYjI=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-04-04T18:49:14Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-04-04T18:49:14Z"}, "message": "Merge pull request #2125 from erickt/master\n\nfleshing out time.rs", "tree": {"sha": "7d838889dafe8092e6783b5d36d63fbff19c56a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d838889dafe8092e6783b5d36d63fbff19c56a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3aed498842473e58b8123cb57a6e3c8165769fb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3aed498842473e58b8123cb57a6e3c8165769fb2", "html_url": "https://github.com/rust-lang/rust/commit/3aed498842473e58b8123cb57a6e3c8165769fb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3aed498842473e58b8123cb57a6e3c8165769fb2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12d3d4f125c1209fe9f4337f0567a2dea6219ba6", "url": "https://api.github.com/repos/rust-lang/rust/commits/12d3d4f125c1209fe9f4337f0567a2dea6219ba6", "html_url": "https://github.com/rust-lang/rust/commit/12d3d4f125c1209fe9f4337f0567a2dea6219ba6"}, {"sha": "159d89604ef245d1d28b0b9e589ed741ecd354ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/159d89604ef245d1d28b0b9e589ed741ecd354ce", "html_url": "https://github.com/rust-lang/rust/commit/159d89604ef245d1d28b0b9e589ed741ecd354ce"}], "stats": {"total": 1283, "additions": 1256, "deletions": 27}, "files": [{"sha": "64385fca9bf1da9735c8853d4102f6d4fea92be2", "filename": "src/libcore/result.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3aed498842473e58b8123cb57a6e3c8165769fb2/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aed498842473e58b8123cb57a6e3c8165769fb2/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=3aed498842473e58b8123cb57a6e3c8165769fb2", "patch": "@@ -108,7 +108,15 @@ fn chain_err<T: copy, U: copy, V: copy>(\n     }\n }\n \n-impl methods<T:copy,E:copy> for result<T,E> {\n+impl extensions<T:copy, E:copy> for result<T,E> {\n+    fn get() -> T { get(self) }\n+\n+    fn get_err() -> E { get_err(self) }\n+\n+    fn success() -> bool { success(self) }\n+\n+    fn failure() -> bool { failure(self) }\n+\n     fn chain<U:copy>(op: fn(T) -> result<U,E>) -> result<U,E> {\n         chain(self, op)\n     }"}, {"sha": "b4c37a5d44df4ce9260bd3f4c7c7dfb1bbf3f57c", "filename": "src/libstd/time.rs", "status": "modified", "additions": 1102, "deletions": 15, "changes": 1117, "blob_url": "https://github.com/rust-lang/rust/blob/3aed498842473e58b8123cb57a6e3c8165769fb2/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aed498842473e58b8123cb57a6e3c8165769fb2/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=3aed498842473e58b8123cb57a6e3c8165769fb2", "patch": "@@ -1,21 +1,44 @@\n+import libc::{c_char, c_int, c_long, size_t, time_t};\n+import io::{reader, reader_util};\n+import result::{result, ok, err, extensions};\n+\n+export\n+    timespec,\n+    get_time,\n+    precise_time_ns,\n+    precise_time_s,\n+    tm,\n+    empty_tm,\n+    now,\n+    at,\n+    now_utc,\n+    at_utc,\n+    strptime;\n+\n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn get_time(&sec: u32, &usec: u32);\n+    fn get_time(&sec: i64, &nsec: i32);\n     fn precise_time_ns(&ns: u64);\n+\n+    // FIXME: The i64 values can be passed by-val when #2064 is fixed.\n+    fn rust_gmtime(&&sec: i64, &&nsec: i32, &&result: tm);\n+    fn rust_localtime(&&sec: i64, &&nsec: i32, &result: tm);\n+    fn rust_timegm(&&tm: tm, &sec: i64);\n+    fn rust_mktime(&&tm: tm, &sec: i64);\n }\n \n #[doc = \"A record specifying a time value in seconds and microseconds.\"]\n-type timeval = {sec: u32, usec: u32};\n+type timespec = {sec: i64, nsec: i32};\n \n #[doc = \"\n-Returns the current time as a `timeval` containing the seconds and\n+Returns the current time as a `timespec` containing the seconds and\n microseconds since 1970-01-01T00:00:00Z.\n \"]\n-fn get_time() -> timeval {\n-    let mut sec = 0u32;\n-    let mut usec = 0u32;\n-    rustrt::get_time(sec, usec);\n-    ret {sec: sec, usec: usec};\n+fn get_time() -> timespec {\n+    let mut sec = 0i64;\n+    let mut nsec = 0i32;\n+    rustrt::get_time(sec, nsec);\n+    ret {sec: sec, nsec: nsec};\n }\n \n #[doc = \"\n@@ -36,31 +59,791 @@ fn precise_time_s() -> float {\n     ret (precise_time_ns() as float) / 1000000000.;\n }\n \n+type tm = {\n+    tm_sec: i32, // seconds after the minute [0-60]\n+    tm_min: i32, // minutes after the hour [0-59]\n+    tm_hour: i32, // hours after midnight [0-23]\n+    tm_mday: i32, // days of the month [1-31]\n+    tm_mon: i32, // months since January [0-11]\n+    tm_year: i32, // years since 1900\n+    tm_wday: i32, // days since Sunday [0-6]\n+    tm_yday: i32, // days since January 1 [0-365]\n+    tm_isdst: i32, // Daylight Savings Time flag\n+    tm_gmtoff: i32, // offset from UTC in seconds\n+    tm_zone: str, // timezone abbreviation\n+    tm_nsec: i32, // nanoseconds\n+};\n+\n+fn empty_tm() -> tm {\n+    {\n+        tm_sec: 0_i32,\n+        tm_min: 0_i32,\n+        tm_hour: 0_i32,\n+        tm_mday: 0_i32,\n+        tm_mon: 0_i32,\n+        tm_year: 0_i32,\n+        tm_wday: 0_i32,\n+        tm_yday: 0_i32,\n+        tm_isdst: 0_i32,\n+        tm_gmtoff: 0_i32,\n+        tm_zone: \"\",\n+        tm_nsec: 0_i32,\n+    }\n+}\n+\n+#[doc = \"Returns the specified time in UTC\"]\n+fn at_utc(clock: timespec) -> tm {\n+    let mut {sec, nsec} = clock;\n+    let mut tm = empty_tm();\n+    rustrt::rust_gmtime(sec, nsec, tm);\n+    tm\n+}\n+\n+#[doc = \"Returns the current time in UTC\"]\n+fn now_utc() -> tm {\n+    at_utc(get_time())\n+}\n+\n+#[doc = \"Returns the specified time in the local timezone\"]\n+fn at(clock: timespec) -> tm {\n+    let mut {sec, nsec} = clock;\n+    let mut tm = empty_tm();\n+    rustrt::rust_localtime(sec, nsec, tm);\n+    tm\n+}\n+\n+#[doc = \"Returns the current time in the local timezone\"]\n+fn now() -> tm {\n+    at(get_time())\n+}\n+\n+#[doc = \"Parses the time from the string according to the format string.\"]\n+fn strptime(s: str, format: str) -> result<tm, str> {\n+    type tm_mut = {\n+       mut tm_sec: i32,\n+       mut tm_min: i32,\n+       mut tm_hour: i32,\n+       mut tm_mday: i32,\n+       mut tm_mon: i32,\n+       mut tm_year: i32,\n+       mut tm_wday: i32,\n+       mut tm_yday: i32,\n+       mut tm_isdst: i32,\n+       mut tm_gmtoff: i32,\n+       mut tm_zone: str,\n+       mut tm_nsec: i32,\n+    };\n+\n+    fn match_str(s: str, pos: uint, needle: str) -> bool {\n+        let mut i = pos;\n+        for str::each(needle) {|ch|\n+            if s[i] != ch {\n+                ret false;\n+            }\n+            i += 1u;\n+        }\n+        ret true;\n+    }\n+\n+    fn match_strs(s: str, pos: uint, strs: [(str, i32)])\n+      -> option<(i32, uint)> {\n+        let mut i = 0u;\n+        let len = vec::len(strs);\n+        while i < len {\n+            let (needle, value) = strs[i];\n+\n+            if match_str(s, pos, needle) {\n+                ret some((value, pos + str::len(needle)));\n+            }\n+            i += 1u;\n+        }\n+\n+        none\n+    }\n+\n+    fn match_digits(s: str, pos: uint, digits: uint, ws: bool)\n+      -> option<(i32, uint)> {\n+        let mut pos = pos;\n+        let mut value = 0_i32;\n+\n+        let mut i = 0u;\n+        while i < digits {\n+            let {ch, next} = str::char_range_at(s, pos);\n+            pos = next;\n+\n+            alt ch {\n+              '0' to '9' {\n+                value = value * 10_i32 + (ch as i32 - '0' as i32);\n+              }\n+              ' ' if ws { }\n+              _ { ret none; }\n+            }\n+            i += 1u;\n+        }\n+\n+        some((value, pos))\n+    }\n+\n+    fn parse_char(s: str, pos: uint, c: char) -> result<uint, str> {\n+        let {ch, next} = str::char_range_at(s, pos);\n+\n+        if c == ch {\n+            ok(next)\n+        } else {\n+            err(#fmt(\"Expected %?, found %?\",\n+                str::from_char(c),\n+                str::from_char(ch)))\n+        }\n+    }\n+\n+    fn parse_type(s: str, pos: uint, ch: char, tm: tm_mut)\n+      -> result<uint, str> {\n+        alt ch {\n+          'A' {\n+            alt match_strs(s, pos, [\n+                (\"Sunday\", 0_i32),\n+                (\"Monday\", 1_i32),\n+                (\"Tuesday\", 2_i32),\n+                (\"Wednesday\", 3_i32),\n+                (\"Thursday\", 4_i32),\n+                (\"Friday\", 5_i32),\n+                (\"Saturday\", 6_i32)\n+            ]) {\n+              some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n+              none { err(\"Invalid day\") }\n+            }\n+          }\n+          'a' {\n+            alt match_strs(s, pos, [\n+                (\"Sun\", 0_i32),\n+                (\"Mon\", 1_i32),\n+                (\"Tue\", 2_i32),\n+                (\"Wed\", 3_i32),\n+                (\"Thu\", 4_i32),\n+                (\"Fri\", 5_i32),\n+                (\"Sat\", 6_i32)\n+            ]) {\n+              some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n+              none { err(\"Invalid day\") }\n+            }\n+          }\n+          'B' {\n+            alt match_strs(s, pos, [\n+                (\"January\", 0_i32),\n+                (\"February\", 1_i32),\n+                (\"March\", 2_i32),\n+                (\"April\", 3_i32),\n+                (\"May\", 4_i32),\n+                (\"June\", 5_i32),\n+                (\"July\", 6_i32),\n+                (\"August\", 7_i32),\n+                (\"September\", 8_i32),\n+                (\"October\", 9_i32),\n+                (\"November\", 10_i32),\n+                (\"December\", 11_i32)\n+            ]) {\n+              some(item) { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n+              none { err(\"Invalid month\") }\n+            }\n+          }\n+          'b' | 'h' {\n+            alt match_strs(s, pos, [\n+                (\"Jan\", 0_i32),\n+                (\"Feb\", 1_i32),\n+                (\"Mar\", 2_i32),\n+                (\"Apr\", 3_i32),\n+                (\"May\", 4_i32),\n+                (\"Jun\", 5_i32),\n+                (\"Jul\", 6_i32),\n+                (\"Aug\", 7_i32),\n+                (\"Sep\", 8_i32),\n+                (\"Oct\", 9_i32),\n+                (\"Nov\", 10_i32),\n+                (\"Dec\", 11_i32)\n+            ]) {\n+              some(item) { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n+              none { err(\"Invalid month\") }\n+            }\n+          }\n+          'C' {\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) {\n+                let (v, pos) = item;\n+                tm.tm_year += (v * 100_i32) - 1900_i32;\n+                ok(pos)\n+              }\n+              none { err(\"Invalid year\") }\n+            }\n+          }\n+          'c' {\n+            parse_type(s, pos, 'a', tm)\n+                .chain { |pos| parse_char(s, pos, ' ') }\n+                .chain { |pos| parse_type(s, pos, 'b', tm) }\n+                .chain { |pos| parse_char(s, pos, ' ') }\n+                .chain { |pos| parse_type(s, pos, 'e', tm) }\n+                .chain { |pos| parse_char(s, pos, ' ') }\n+                .chain { |pos| parse_type(s, pos, 'T', tm) }\n+                .chain { |pos| parse_char(s, pos, ' ') }\n+                .chain { |pos| parse_type(s, pos, 'Y', tm) }\n+          }\n+          'D' | 'x' {\n+            parse_type(s, pos, 'm', tm)\n+                .chain { |pos| parse_char(s, pos, '/') }\n+                .chain { |pos| parse_type(s, pos, 'd', tm) }\n+                .chain { |pos| parse_char(s, pos, '/') }\n+                .chain { |pos| parse_type(s, pos, 'y', tm) }\n+          }\n+          'd' {\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n+              none { err(\"Invalid day of the month\") }\n+            }\n+          }\n+          'e' {\n+            alt match_digits(s, pos, 2u, true) {\n+              some(item) { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n+              none { err(\"Invalid day of the month\") }\n+            }\n+          }\n+          'F' {\n+            parse_type(s, pos, 'Y', tm)\n+                .chain { |pos| parse_char(s, pos, '-') }\n+                .chain { |pos| parse_type(s, pos, 'm', tm) }\n+                .chain { |pos| parse_char(s, pos, '-') }\n+                .chain { |pos| parse_type(s, pos, 'd', tm) }\n+          }\n+          'H' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n+              none { err(\"Invalid hour\") }\n+            }\n+          }\n+          'I' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) {\n+                  let (v, pos) = item;\n+                  tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n+                  ok(pos)\n+              }\n+              none { err(\"Invalid hour\") }\n+            }\n+          }\n+          'j' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 3u, false) {\n+              some(item) {\n+                let (v, pos) = item;\n+                tm.tm_yday = v - 1_i32;\n+                ok(pos)\n+              }\n+              none { err(\"Invalid year\") }\n+            }\n+          }\n+          'k' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, true) {\n+              some(item) { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n+              none { err(\"Invalid hour\") }\n+            }\n+          }\n+          'l' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, true) {\n+              some(item) {\n+                  let (v, pos) = item;\n+                  tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n+                  ok(pos)\n+              }\n+              none { err(\"Invalid hour\") }\n+            }\n+          }\n+          'M' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) { let (v, pos) = item; tm.tm_min = v; ok(pos) }\n+              none { err(\"Invalid minute\") }\n+            }\n+          }\n+          'm' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) {\n+                let (v, pos) = item;\n+                tm.tm_mon = v - 1_i32;\n+                ok(pos)\n+              }\n+              none { err(\"Invalid month\") }\n+            }\n+          }\n+          'n' { parse_char(s, pos, '\\n') }\n+          'P' {\n+            alt match_strs(s, pos, [(\"am\", 0_i32), (\"pm\", 12_i32)]) {\n+              some(item) { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n+              none { err(\"Invalid hour\") }\n+            }\n+          }\n+          'p' {\n+            alt match_strs(s, pos, [(\"AM\", 0_i32), (\"PM\", 12_i32)]) {\n+              some(item) { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n+              none { err(\"Invalid hour\") }\n+            }\n+          }\n+          'R' {\n+            parse_type(s, pos, 'H', tm)\n+                .chain { |pos| parse_char(s, pos, ':') }\n+                .chain { |pos| parse_type(s, pos, 'M', tm) }\n+          }\n+          'r' {\n+            parse_type(s, pos, 'I', tm)\n+                .chain { |pos| parse_char(s, pos, ':') }\n+                .chain { |pos| parse_type(s, pos, 'M', tm) }\n+                .chain { |pos| parse_char(s, pos, ':') }\n+                .chain { |pos| parse_type(s, pos, 'S', tm) }\n+                .chain { |pos| parse_char(s, pos, ' ') }\n+                .chain { |pos| parse_type(s, pos, 'p', tm) }\n+          }\n+          'S' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) {\n+                let (v, pos) = item;\n+                tm.tm_sec = v;\n+                ok(pos)\n+              }\n+              none { err(\"Invalid second\") }\n+            }\n+          }\n+          //'s' {}\n+          'T' | 'X' {\n+            parse_type(s, pos, 'H', tm)\n+                .chain { |pos| parse_char(s, pos, ':') }\n+                .chain { |pos| parse_type(s, pos, 'M', tm) }\n+                .chain { |pos| parse_char(s, pos, ':') }\n+                .chain { |pos| parse_type(s, pos, 'S', tm) }\n+          }\n+          't' { parse_char(s, pos, '\\t') }\n+          'u' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 1u, false) {\n+              some(item) {\n+                let (v, pos) = item;\n+                tm.tm_wday = v;\n+                ok(pos)\n+              }\n+              none { err(\"Invalid weekday\") }\n+            }\n+          }\n+          'v' {\n+            parse_type(s, pos, 'e', tm)\n+                .chain { |pos| parse_char(s, pos, '-') }\n+                .chain { |pos| parse_type(s, pos, 'b', tm) }\n+                .chain { |pos| parse_char(s, pos, '-') }\n+                .chain { |pos| parse_type(s, pos, 'Y', tm) }\n+          }\n+          //'W' {}\n+          'w' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 1u, false) {\n+              some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n+              none { err(\"Invalid weekday\") }\n+            }\n+          }\n+          //'X' {}\n+          //'x' {}\n+          'Y' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 4u, false) {\n+              some(item) {\n+                let (v, pos) = item;\n+                tm.tm_year = v - 1900_i32;\n+                ok(pos)\n+              }\n+              none { err(\"Invalid weekday\") }\n+            }\n+          }\n+          'y' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) {\n+                let (v, pos) = item;\n+                tm.tm_year = v - 1900_i32;\n+                ok(pos)\n+              }\n+              none { err(\"Invalid weekday\") }\n+            }\n+          }\n+          'Z' {\n+            if match_str(s, pos, \"UTC\") || match_str(s, pos, \"GMT\") {\n+                tm.tm_gmtoff = 0_i32;\n+                tm.tm_zone = \"UTC\";\n+                ok(pos + 3u)\n+            } else {\n+                // It's odd, but to maintain compatibility with c's\n+                // strptime we ignore the timezone.\n+                let mut pos = pos;\n+                let len = str::len(s);\n+                while pos < len {\n+                    let {ch, next} = str::char_range_at(s, pos);\n+                    pos = next;\n+                    if ch == ' ' { break; }\n+                }\n+\n+                ok(pos)\n+            }\n+          }\n+          'z' {\n+            let {ch, next} = str::char_range_at(s, pos);\n+\n+            if ch == '+' || ch == '-' {\n+                alt match_digits(s, next, 4u, false) {\n+                  some(item) {\n+                    let (v, pos) = item;\n+                    if v == 0_i32 {\n+                        tm.tm_gmtoff = 0_i32;\n+                        tm.tm_zone = \"UTC\";\n+                    }\n+\n+                    ok(pos)\n+                  }\n+                  none { err(\"Invalid zone offset\") }\n+                }\n+            } else {\n+                err(\"Invalid zone offset\")\n+            }\n+          }\n+          '%' { parse_char(s, pos, '%') }\n+          ch {\n+            err(#fmt(\"unknown formatting type: %?\", str::from_char(ch)))\n+          }\n+        }\n+    }\n+\n+    io::with_str_reader(format) { |rdr|\n+        let tm = {\n+            mut tm_sec: 0_i32,\n+            mut tm_min: 0_i32,\n+            mut tm_hour: 0_i32,\n+            mut tm_mday: 0_i32,\n+            mut tm_mon: 0_i32,\n+            mut tm_year: 0_i32,\n+            mut tm_wday: 0_i32,\n+            mut tm_yday: 0_i32,\n+            mut tm_isdst: 0_i32,\n+            mut tm_gmtoff: 0_i32,\n+            mut tm_zone: \"\",\n+            mut tm_nsec: 0_i32,\n+        };\n+        let mut pos = 0u;\n+        let len = str::len(s);\n+        let mut result = err(\"Invalid time\");\n+\n+        while !rdr.eof() && pos < len {\n+            let {ch, next} = str::char_range_at(s, pos);\n+\n+            alt rdr.read_char() {\n+              '%' {\n+                alt parse_type(s, pos, rdr.read_char(), tm) {\n+                  ok(next) { pos = next; }\n+                  err(e) { result = err(e); break; }\n+                }\n+              }\n+              c {\n+                if c != ch { break }\n+                pos = next;\n+              }\n+            }\n+        }\n+\n+        if pos == len && rdr.eof() {\n+            ok({\n+                tm_sec: tm.tm_sec,\n+                tm_min: tm.tm_min,\n+                tm_hour: tm.tm_hour,\n+                tm_mday: tm.tm_mday,\n+                tm_mon: tm.tm_mon,\n+                tm_year: tm.tm_year,\n+                tm_wday: tm.tm_wday,\n+                tm_yday: tm.tm_yday,\n+                tm_isdst: tm.tm_isdst,\n+                tm_gmtoff: tm.tm_gmtoff,\n+                tm_zone: tm.tm_zone,\n+                tm_nsec: tm.tm_nsec,\n+            })\n+        } else { result }\n+    }\n+}\n+\n+fn strftime(format: str, tm: tm) -> str {\n+    fn parse_type(ch: char, tm: tm) -> str {\n+        //FIXME: Implement missing types.\n+        alt check ch {\n+          'A' {\n+            alt check tm.tm_wday as int {\n+              0 { \"Sunday\" }\n+              1 { \"Monday\" }\n+              2 { \"Tuesday\" }\n+              3 { \"Wednesday\" }\n+              4 { \"Thursday\" }\n+              5 { \"Friday\" }\n+              6 { \"Saturday\" }\n+            }\n+          }\n+          'a' {\n+            alt check tm.tm_wday as int {\n+              0 { \"Sun\" }\n+              1 { \"Mon\" }\n+              2 { \"Tue\" }\n+              3 { \"Wed\" }\n+              4 { \"Thu\" }\n+              5 { \"Fri\" }\n+              6 { \"Sat\" }\n+            }\n+          }\n+          'B' {\n+            alt check tm.tm_mon as int {\n+              0 { \"January\" }\n+              1 { \"February\" }\n+              2 { \"March\" }\n+              3 { \"April\" }\n+              4 { \"May\" }\n+              5 { \"June\" }\n+              6 { \"July\" }\n+              7 { \"August\" }\n+              8 { \"September\" }\n+              9 { \"October\" }\n+              10 { \"November\" }\n+              11 { \"December\" }\n+            }\n+          }\n+          'b' | 'h' {\n+            alt check tm.tm_mon as int {\n+              0 { \"Jan\" }\n+              1 { \"Feb\" }\n+              2 { \"Mar\" }\n+              3 { \"Apr\" }\n+              4 { \"May\" }\n+              5 { \"Jun\" }\n+              6 { \"Jul\" }\n+              7 { \"Aug\" }\n+              8 { \"Sep\" }\n+              9 { \"Oct\" }\n+              10 { \"Nov\" }\n+              11 { \"Dec\" }\n+            }\n+          }\n+          'C' { #fmt(\"%02d\", (tm.tm_year as int + 1900) / 100) }\n+          'c' {\n+            #fmt(\"%s %s %s %s %s\",\n+                parse_type('a', tm),\n+                parse_type('b', tm),\n+                parse_type('e', tm),\n+                parse_type('T', tm),\n+                parse_type('Y', tm))\n+          }\n+          'D' | 'x' {\n+            #fmt(\"%s/%s/%s\",\n+                parse_type('m', tm),\n+                parse_type('d', tm),\n+                parse_type('y', tm))\n+          }\n+          'd' { #fmt(\"%02d\", tm.tm_mday as int) }\n+          'e' { #fmt(\"%2d\", tm.tm_mday as int) }\n+          'F' {\n+            #fmt(\"%s-%s-%s\",\n+                parse_type('Y', tm),\n+                parse_type('m', tm),\n+                parse_type('d', tm))\n+          }\n+          //'G' {}\n+          //'g' {}\n+          'H' { #fmt(\"%02d\", tm.tm_hour as int) }\n+          'I' {\n+            let mut h = tm.tm_hour as int;\n+            if h == 0 { h = 12 }\n+            if h > 12 { h -= 12 }\n+            #fmt(\"%02d\", h)\n+          }\n+          'j' { #fmt(\"%03d\", tm.tm_yday as int + 1) }\n+          'k' { #fmt(\"%2d\", tm.tm_hour as int) }\n+          'l' {\n+            let mut h = tm.tm_hour as int;\n+            if h == 0 { h = 12 }\n+            if h > 12 { h -= 12 }\n+            #fmt(\"%2d\", h)\n+          }\n+          'M' { #fmt(\"%02d\", tm.tm_min as int) }\n+          'm' { #fmt(\"%02d\", tm.tm_mon as int + 1) }\n+          'n' { \"\\n\" }\n+          'P' { if tm.tm_hour as int < 12 { \"am\" } else { \"pm\" } }\n+          'p' { if tm.tm_hour as int < 12 { \"AM\" } else { \"PM\" } }\n+          'R' {\n+            #fmt(\"%s:%s\",\n+                parse_type('H', tm),\n+                parse_type('M', tm))\n+          }\n+          'r' {\n+            #fmt(\"%s:%s:%s %s\",\n+                parse_type('I', tm),\n+                parse_type('M', tm),\n+                parse_type('S', tm),\n+                parse_type('p', tm))\n+          }\n+          'S' { #fmt(\"%02d\", tm.tm_sec as int) }\n+          's' { #fmt(\"%d\", tm.to_timespec().sec as int) }\n+          'T' | 'X' {\n+            #fmt(\"%s:%s:%s\",\n+                parse_type('H', tm),\n+                parse_type('M', tm),\n+                parse_type('S', tm))\n+          }\n+          't' { \"\\t\" }\n+          //'U' {}\n+          'u' {\n+            let i = tm.tm_wday as int;\n+            int::str(if i == 0 { 7 } else { i })\n+          }\n+          //'V' {}\n+          'v' {\n+            #fmt(\"%s-%s-%s\",\n+                parse_type('e', tm),\n+                parse_type('b', tm),\n+                parse_type('Y', tm))\n+          }\n+          //'W' {}\n+          'w' { int::str(tm.tm_wday as int) }\n+          //'X' {}\n+          //'x' {}\n+          'Y' { int::str(tm.tm_year as int + 1900) }\n+          'y' { #fmt(\"%02d\", (tm.tm_year as int + 1900) % 100) }\n+          'Z' { tm.tm_zone }\n+          'z' {\n+            let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n+            let mut m = i32::abs(tm.tm_gmtoff) / 60_i32;\n+            let h = m / 60_i32;\n+            m -= h * 60_i32;\n+            #fmt(\"%c%02d%02d\", sign, h as int, m as int)\n+          }\n+          //'+' {}\n+          '%' { \"%\" }\n+        }\n+    }\n+\n+    let mut buf = \"\";\n+\n+    io::with_str_reader(format) { |rdr|\n+        while !rdr.eof() {\n+            alt rdr.read_char() {\n+                '%' { buf += parse_type(rdr.read_char(), tm); }\n+                ch { str::push_char(buf, ch); }\n+            }\n+        }\n+    }\n+\n+    buf\n+}\n+\n+impl tm for tm {\n+    #[doc = \"Convert time to the seconds from January 1, 1970\"]\n+    fn to_timespec() -> timespec {\n+        let mut sec = 0i64;\n+        if self.tm_gmtoff == 0_i32 {\n+            rustrt::rust_timegm(self, sec);\n+        } else {\n+            rustrt::rust_mktime(self, sec);\n+        }\n+        { sec: sec, nsec: self.tm_nsec }\n+    }\n+\n+    #[doc = \"Convert time to the local timezone\"]\n+    fn to_local() -> tm {\n+        at(self.to_timespec())\n+    }\n+\n+    #[doc = \"Convert time to the UTC\"]\n+    fn to_utc() -> tm {\n+        at_utc(self.to_timespec())\n+    }\n+\n+    #[doc = \"\n+    Return a string of the current time in the form\n+    \\\"Thu Jan  1 00:00:00 1970\\\".\n+    \"]\n+    fn ctime() -> str { self.strftime(\"%c\") }\n+\n+    #[doc = \"Formats the time according to the format string.\"]\n+    fn strftime(format: str) -> str { strftime(format, self) }\n+\n+    #[doc = \"\n+    Returns a time string formatted according to RFC 822.\n+\n+    local: \\\"Thu, 22 Mar 2012 07:53:18 PST\\\"\n+    utc:   \\\"Thu, 22 Mar 2012 14:53:18 UTC\\\"\n+    \"]\n+    fn rfc822() -> str {\n+        if self.tm_gmtoff == 0_i32 {\n+            self.strftime(\"%a, %d %b %Y %T GMT\")\n+        } else {\n+            self.strftime(\"%a, %d %b %Y %T %Z\")\n+        }\n+    }\n+\n+    #[doc = \"\n+    Returns a time string formatted according to RFC 822 with Zulu time.\n+\n+    local: \\\"Thu, 22 Mar 2012 07:53:18 -0700\\\"\n+    utc:   \\\"Thu, 22 Mar 2012 14:53:18 -0000\\\"\n+    \"]\n+    fn rfc822z() -> str {\n+        self.strftime(\"%a, %d %b %Y %T %z\")\n+    }\n+\n+    #[doc = \"\n+    Returns a time string formatted according to ISO 8601.\n+\n+    local: \\\"2012-02-22T07:53:18-07:00\\\"\n+    utc:   \\\"2012-02-22T14:53:18Z\\\"\n+    \"]\n+    fn rfc3339() -> str {\n+        if self.tm_gmtoff == 0_i32 {\n+            self.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n+        } else {\n+            let s = self.strftime(\"%Y-%m-%dT%H:%M:%S\");\n+            let sign = if self.tm_gmtoff > 0_i32 { '+' } else { '-' };\n+            let mut m = i32::abs(self.tm_gmtoff) / 60_i32;\n+            let h = m / 60_i32;\n+            m -= h * 60_i32;\n+            s + #fmt(\"%c%02d:%02d\", sign, h as int, m as int)\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     import task;\n \n     #[test]\n     fn test_get_time() {\n-        const some_recent_date: u32 = 1325376000u32; // 2012-01-01T00:00:00Z\n-        const some_future_date: u32 = 1577836800u32; // 2020-01-01T00:00:00Z\n+        const some_recent_date: i64 = 1325376000i64; // 2012-01-01T00:00:00Z\n+        const some_future_date: i64 = 1577836800i64; // 2020-01-01T00:00:00Z\n \n         let tv1 = get_time();\n         log(debug, \"tv1=\" + uint::str(tv1.sec as uint) + \" sec + \"\n-                   + uint::str(tv1.usec as uint) + \" usec\");\n+                   + uint::str(tv1.nsec as uint) + \" nsec\");\n \n         assert tv1.sec > some_recent_date;\n-        assert tv1.usec < 1000000u32;\n+        assert tv1.nsec < 1000000000i32;\n \n         let tv2 = get_time();\n         log(debug, \"tv2=\" + uint::str(tv2.sec as uint) + \" sec + \"\n-                   + uint::str(tv2.usec as uint) + \" usec\");\n+                   + uint::str(tv2.nsec as uint) + \" nsec\");\n \n         assert tv2.sec >= tv1.sec;\n         assert tv2.sec < some_future_date;\n-        assert tv2.usec < 1000000u32;\n+        assert tv2.nsec < 1000000000i32;\n         if tv2.sec == tv1.sec {\n-            assert tv2.usec >= tv1.usec;\n+            assert tv2.nsec >= tv1.nsec;\n         }\n     }\n \n@@ -81,4 +864,308 @@ mod tests {\n         log(debug, \"ns2=\" + u64::str(ns2) + \" ns\");\n         assert ns2 >= ns1;\n     }\n+\n+    #[test]\n+    fn test_at_utc() {\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+\n+        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let utc = at_utc(time);\n+\n+        assert utc.tm_sec == 30_i32;\n+        assert utc.tm_min == 31_i32;\n+        assert utc.tm_hour == 23_i32;\n+        assert utc.tm_mday == 13_i32;\n+        assert utc.tm_mon == 1_i32;\n+        assert utc.tm_year == 109_i32;\n+        assert utc.tm_wday == 5_i32;\n+        assert utc.tm_yday == 43_i32;\n+        assert utc.tm_isdst == 0_i32;\n+        assert utc.tm_gmtoff == 0_i32;\n+        assert utc.tm_zone == \"UTC\";\n+        assert utc.tm_nsec == 54321_i32;\n+    }\n+\n+    #[test]\n+    fn test_at() {\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+\n+        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let local = at(time);\n+\n+        assert local.tm_sec == 30_i32;\n+        assert local.tm_min == 31_i32;\n+        assert local.tm_hour == 15_i32;\n+        assert local.tm_mday == 13_i32;\n+        assert local.tm_mon == 1_i32;\n+        assert local.tm_year == 109_i32;\n+        assert local.tm_wday == 5_i32;\n+        assert local.tm_yday == 43_i32;\n+        assert local.tm_isdst == 0_i32;\n+        assert local.tm_gmtoff == -28800_i32;\n+\n+        // FIXME: We should probably standardize on the timezone\n+        // abbreviation.\n+        let zone = local.tm_zone;\n+        assert zone == \"PST\" || zone == \"Pacific Standard Time\";\n+\n+        assert local.tm_nsec == 54321_i32;\n+    }\n+\n+    #[test]\n+    fn test_to_timespec() {\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+\n+        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let utc = at_utc(time);\n+\n+        assert utc.to_timespec() == time;\n+        assert utc.to_local().to_timespec() == time;\n+    }\n+\n+    #[test]\n+    fn test_conversions() {\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+\n+        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let utc = at_utc(time);\n+        let local = at(time);\n+\n+        assert local.to_local() == local;\n+        assert local.to_utc() == utc;\n+        assert local.to_utc().to_local() == local;\n+        assert utc.to_utc() == utc;\n+        assert utc.to_local() == local;\n+        assert utc.to_local().to_utc() == utc;\n+    }\n+\n+    #[test]\n+    fn test_strptime() {\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+\n+        alt strptime(\"\", \"\") {\n+          ok(tm) {\n+            assert tm.tm_sec == 0_i32;\n+            assert tm.tm_min == 0_i32;\n+            assert tm.tm_hour == 0_i32;\n+            assert tm.tm_mday == 0_i32;\n+            assert tm.tm_mon == 0_i32;\n+            assert tm.tm_year == 0_i32;\n+            assert tm.tm_wday == 0_i32;\n+            assert tm.tm_isdst== 0_i32;\n+            assert tm.tm_gmtoff == 0_i32;\n+            assert tm.tm_zone == \"\";\n+            assert tm.tm_nsec == 0_i32;\n+          }\n+          err(_) {}\n+        }\n+\n+        let format = \"%a %b %e %T %Y\";\n+        assert strptime(\"\", format) == err(\"Invalid time\");\n+        assert strptime(\"Fri Feb 13 15:31:30\", format) == err(\"Invalid time\");\n+\n+        alt strptime(\"Fri Feb 13 15:31:30 2009\", format) {\n+          err(e) { fail e }\n+          ok(tm) {\n+            assert tm.tm_sec == 30_i32;\n+            assert tm.tm_min == 31_i32;\n+            assert tm.tm_hour == 15_i32;\n+            assert tm.tm_mday == 13_i32;\n+            assert tm.tm_mon == 1_i32;\n+            assert tm.tm_year == 109_i32;\n+            assert tm.tm_wday == 5_i32;\n+            assert tm.tm_yday == 0_i32;\n+            assert tm.tm_isdst == 0_i32;\n+            assert tm.tm_gmtoff == 0_i32;\n+            assert tm.tm_zone == \"\";\n+            assert tm.tm_nsec == 0_i32;\n+          }\n+        }\n+\n+        fn test(s: str, format: str) -> bool {\n+            alt strptime(s, format) {\n+              ok(tm) { tm.strftime(format) == s }\n+              err(e) { fail e }\n+            }\n+        }\n+\n+        [\n+            \"Sunday\",\n+            \"Monday\",\n+            \"Tuesday\",\n+            \"Wednesday\",\n+            \"Thursday\",\n+            \"Friday\",\n+            \"Saturday\"\n+        ].iter { |day| assert test(day, \"%A\"); }\n+\n+        [\n+            \"Sun\",\n+            \"Mon\",\n+            \"Tue\",\n+            \"Wed\",\n+            \"Thu\",\n+            \"Fri\",\n+            \"Sat\"\n+        ].iter { |day| assert test(day, \"%a\"); }\n+\n+        [\n+            \"January\",\n+            \"February\",\n+            \"March\",\n+            \"April\",\n+            \"May\",\n+            \"June\",\n+            \"July\",\n+            \"August\",\n+            \"September\",\n+            \"October\",\n+            \"November\",\n+            \"December\"\n+        ].iter { |day| assert test(day, \"%B\"); }\n+\n+        [\n+            \"Jan\",\n+            \"Feb\",\n+            \"Mar\",\n+            \"Apr\",\n+            \"May\",\n+            \"Jun\",\n+            \"Jul\",\n+            \"Aug\",\n+            \"Sep\",\n+            \"Oct\",\n+            \"Nov\",\n+            \"Dec\"\n+        ].iter { |day| assert test(day, \"%b\"); }\n+\n+        assert test(\"19\", \"%C\");\n+        assert test(\"Fri Feb 13 23:31:30 2009\", \"%c\");\n+        assert test(\"02/13/09\", \"%D\");\n+        assert test(\"03\", \"%d\");\n+        assert test(\"13\", \"%d\");\n+        assert test(\" 3\", \"%e\");\n+        assert test(\"13\", \"%e\");\n+        assert test(\"2009-02-13\", \"%F\");\n+        assert test(\"03\", \"%H\");\n+        assert test(\"13\", \"%H\");\n+        assert test(\"03\", \"%I\"); // FIXME: flesh out\n+        assert test(\"11\", \"%I\"); // FIXME: flesh out\n+        assert test(\"044\", \"%j\");\n+        assert test(\" 3\", \"%k\");\n+        assert test(\"13\", \"%k\");\n+        assert test(\" 1\", \"%l\");\n+        assert test(\"11\", \"%l\");\n+        assert test(\"03\", \"%M\");\n+        assert test(\"13\", \"%M\");\n+        assert test(\"\\n\", \"%n\");\n+        assert test(\"am\", \"%P\");\n+        assert test(\"pm\", \"%P\");\n+        assert test(\"AM\", \"%p\");\n+        assert test(\"PM\", \"%p\");\n+        assert test(\"23:31\", \"%R\");\n+        assert test(\"11:31:30 AM\", \"%r\");\n+        assert test(\"11:31:30 PM\", \"%r\");\n+        assert test(\"03\", \"%S\");\n+        assert test(\"13\", \"%S\");\n+        assert test(\"15:31:30\", \"%T\");\n+        assert test(\"\\t\", \"%t\");\n+        assert test(\"1\", \"%u\");\n+        assert test(\"7\", \"%u\");\n+        assert test(\"13-Feb-2009\", \"%v\");\n+        assert test(\"0\", \"%w\");\n+        assert test(\"6\", \"%w\");\n+        assert test(\"2009\", \"%Y\");\n+        assert test(\"09\", \"%y\");\n+        assert strptime(\"UTC\", \"%Z\").get().tm_zone == \"UTC\";\n+        assert strptime(\"PST\", \"%Z\").get().tm_zone == \"\";\n+        assert strptime(\"-0000\", \"%z\").get().tm_gmtoff == 0_i32;\n+        assert strptime(\"-0800\", \"%z\").get().tm_gmtoff == 0_i32;\n+        assert test(\"%\", \"%%\");\n+    }\n+\n+    #[test]\n+    fn test_ctime() {\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+\n+        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let utc   = at_utc(time);\n+        let local = at(time);\n+\n+        assert utc.ctime()   == \"Fri Feb 13 23:31:30 2009\";\n+        assert local.ctime() == \"Fri Feb 13 15:31:30 2009\";\n+    }\n+\n+    #[test]\n+    fn test_strftime() {\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+\n+        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let utc = at_utc(time);\n+        let local = at(time);\n+\n+        assert local.strftime(\"\") == \"\";\n+        assert local.strftime(\"%A\") == \"Friday\";\n+        assert local.strftime(\"%a\") == \"Fri\";\n+        assert local.strftime(\"%B\") == \"February\";\n+        assert local.strftime(\"%b\") == \"Feb\";\n+        assert local.strftime(\"%C\") == \"20\";\n+        assert local.strftime(\"%c\") == \"Fri Feb 13 15:31:30 2009\";\n+        assert local.strftime(\"%D\") == \"02/13/09\";\n+        assert local.strftime(\"%d\") == \"13\";\n+        assert local.strftime(\"%e\") == \"13\";\n+        assert local.strftime(\"%F\") == \"2009-02-13\";\n+        // assert local.strftime(\"%G\") == \"2009\";\n+        // assert local.strftime(\"%g\") == \"09\";\n+        assert local.strftime(\"%H\") == \"15\";\n+        assert local.strftime(\"%I\") == \"03\";\n+        assert local.strftime(\"%j\") == \"044\";\n+        assert local.strftime(\"%k\") == \"15\";\n+        assert local.strftime(\"%l\") == \" 3\";\n+        assert local.strftime(\"%M\") == \"31\";\n+        assert local.strftime(\"%m\") == \"02\";\n+        assert local.strftime(\"%n\") == \"\\n\";\n+        assert local.strftime(\"%P\") == \"pm\";\n+        assert local.strftime(\"%p\") == \"PM\";\n+        assert local.strftime(\"%R\") == \"15:31\";\n+        assert local.strftime(\"%r\") == \"03:31:30 PM\";\n+        assert local.strftime(\"%S\") == \"30\";\n+        assert local.strftime(\"%s\") == \"1234567890\";\n+        assert local.strftime(\"%T\") == \"15:31:30\";\n+        assert local.strftime(\"%t\") == \"\\t\";\n+        // assert local.strftime(\"%U\") == \"06\";\n+        assert local.strftime(\"%u\") == \"5\";\n+        // assert local.strftime(\"%V\") == \"07\";\n+        assert local.strftime(\"%v\") == \"13-Feb-2009\";\n+        // assert local.strftime(\"%W\") == \"06\";\n+        assert local.strftime(\"%w\") == \"5\";\n+        // handle \"%X\"\n+        // handle \"%x\"\n+        assert local.strftime(\"%Y\") == \"2009\";\n+        assert local.strftime(\"%y\") == \"09\";\n+\n+        // FIXME: We should probably standardize on the timezone\n+        // abbreviation.\n+        let zone = local.strftime(\"%Z\");\n+        assert zone == \"PST\" || zone == \"Pacific Standard Time\";\n+\n+        assert local.strftime(\"%z\") == \"-0800\";\n+        assert local.strftime(\"%%\") == \"%\";\n+\n+        // FIXME: We should probably standardize on the timezone\n+        // abbreviation.\n+        let rfc822 = local.rfc822();\n+        let prefix = \"Fri, 13 Feb 2009 15:31:30 \";\n+        assert rfc822 == prefix + \"PST\" ||\n+               rfc822 == prefix + \"Pacific Standard Time\";\n+\n+        assert local.ctime() == \"Fri Feb 13 15:31:30 2009\";\n+        assert local.rfc822z() == \"Fri, 13 Feb 2009 15:31:30 -0800\";\n+        assert local.rfc3339() == \"2009-02-13T15:31:30-08:00\";\n+\n+        assert utc.ctime() == \"Fri Feb 13 23:31:30 2009\";\n+        assert utc.rfc822() == \"Fri, 13 Feb 2009 23:31:30 GMT\";\n+        assert utc.rfc822z() == \"Fri, 13 Feb 2009 23:31:30 -0000\";\n+        assert utc.rfc3339() == \"2009-02-13T23:31:30Z\";\n+    }\n }"}, {"sha": "9c2e2c3276c16a6dacc0b5ee3dcd732db8be2d32", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 135, "deletions": 5, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/3aed498842473e58b8123cb57a6e3c8165769fb2/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3aed498842473e58b8123cb57a6e3c8165769fb2/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=3aed498842473e58b8123cb57a6e3c8165769fb2", "patch": "@@ -8,6 +8,8 @@\n #include \"rust_abi.h\"\n #include \"rust_port.h\"\n \n+#include <time.h>\n+\n #ifdef __APPLE__\n #include <crt_externs.h>\n #endif\n@@ -79,7 +81,7 @@ rust_getcwd() {\n         return NULL;\n     }\n \n-    return make_str(task->kernel, cbuf, strlen(cbuf), \"rust_str(getcwd\");\n+    return make_str(task->kernel, cbuf, strlen(cbuf), \"rust_str(getcwd)\");\n }\n \n #if defined(__WIN32__)\n@@ -408,7 +410,7 @@ rust_ptr_eq(type_desc *t, rust_box *a, rust_box *b) {\n \n #if defined(__WIN32__)\n extern \"C\" CDECL void\n-get_time(uint32_t *sec, uint32_t *usec) {\n+get_time(int64_t *sec, int32_t *nsec) {\n     FILETIME fileTime;\n     GetSystemTimeAsFileTime(&fileTime);\n \n@@ -423,15 +425,22 @@ get_time(uint32_t *sec, uint32_t *usec) {\n     const uint64_t NANOSECONDS_FROM_1601_TO_1970 = 11644473600000000u;\n     uint64_t ns_since_1970 = ns_since_1601 - NANOSECONDS_FROM_1601_TO_1970;\n     *sec = ns_since_1970 / 1000000;\n-    *usec = ns_since_1970 % 1000000;\n+    *nsec = (ns_since_1970 % 1000000) * 1000;\n }\n #else\n extern \"C\" CDECL void\n-get_time(uint32_t *sec, uint32_t *usec) {\n+get_time(int64_t *sec, int32_t *nsec) {\n+#ifdef __APPLE__\n     struct timeval tv;\n     gettimeofday(&tv, NULL);\n     *sec = tv.tv_sec;\n-    *usec = tv.tv_usec;\n+    *nsec = tv.tv_usec * 1000;\n+#else\n+    timespec ts;\n+    clock_gettime(CLOCK_REALTIME, &ts);\n+    *sec = ts.tv_sec;\n+    *nsec = ts.tv_nsec;\n+#endif\n }\n #endif\n \n@@ -441,6 +450,127 @@ precise_time_ns(uint64_t *ns) {\n     *ns = t.time_ns();\n }\n \n+struct rust_tm {\n+    int32_t tm_sec;\n+    int32_t tm_min;\n+    int32_t tm_hour;\n+    int32_t tm_mday;\n+    int32_t tm_mon;\n+    int32_t tm_year;\n+    int32_t tm_wday;\n+    int32_t tm_yday;\n+    int32_t tm_isdst;\n+    int32_t tm_gmtoff;\n+    rust_str *tm_zone;\n+    int32_t tm_nsec;\n+};\n+\n+void rust_tm_to_tm(rust_tm* in_tm, tm* out_tm) {\n+    memset(out_tm, 0, sizeof(tm));\n+    out_tm->tm_sec = in_tm->tm_sec;\n+    out_tm->tm_min = in_tm->tm_min;\n+    out_tm->tm_hour = in_tm->tm_hour;\n+    out_tm->tm_mday = in_tm->tm_mday;\n+    out_tm->tm_mon = in_tm->tm_mon;\n+    out_tm->tm_year = in_tm->tm_year;\n+    out_tm->tm_wday = in_tm->tm_wday;\n+    out_tm->tm_yday = in_tm->tm_yday;\n+    out_tm->tm_isdst = in_tm->tm_isdst;\n+}\n+\n+void tm_to_rust_tm(tm* in_tm, rust_tm* out_tm, int32_t gmtoff,\n+                   const char *zone, int32_t nsec) {\n+    out_tm->tm_sec = in_tm->tm_sec;\n+    out_tm->tm_min = in_tm->tm_min;\n+    out_tm->tm_hour = in_tm->tm_hour;\n+    out_tm->tm_mday = in_tm->tm_mday;\n+    out_tm->tm_mon = in_tm->tm_mon;\n+    out_tm->tm_year = in_tm->tm_year;\n+    out_tm->tm_wday = in_tm->tm_wday;\n+    out_tm->tm_yday = in_tm->tm_yday;\n+    out_tm->tm_isdst = in_tm->tm_isdst;\n+    out_tm->tm_gmtoff = gmtoff;\n+    out_tm->tm_nsec = nsec;\n+\n+    if (zone != NULL) {\n+        size_t size = strlen(zone);\n+        str_reserve_shared(&out_tm->tm_zone, size);\n+        memcpy(out_tm->tm_zone->data, zone, size);\n+        out_tm->tm_zone->fill = size + 1;\n+        out_tm->tm_zone->data[size] = '\\0';\n+    }\n+}\n+\n+#if defined(__WIN32__)\n+#define TZSET() _tzset()\n+#if defined(_MSC_VER) && (_MSC_VER >= 1400)\n+#define GMTIME(clock, result) gmtime_s((result), (clock))\n+#define LOCALTIME(clock, result) localtime_s((result), (clock))\n+#define TIMEGM(result) _mkgmtime64(result)\n+#else\n+struct tm* GMTIME(const time_t *clock, tm *result) {\n+    struct tm* t = gmtime(clock);\n+    if (t == NULL || result == NULL) { return NULL; }\n+    *result = *t;\n+    return result;\n+}\n+struct tm* LOCALTIME(const time_t *clock, tm *result) {\n+    struct tm* t = localtime(clock);\n+    if (t == NULL || result == NULL) { return NULL; }\n+    *result = *t;\n+    return result;\n+}\n+#define TIMEGM(result) mktime((result)) - _timezone\n+#endif\n+#else\n+#define TZSET() tzset()\n+#define GMTIME(clock, result) gmtime_r((clock), (result))\n+#define LOCALTIME(clock, result) localtime_r((clock), (result))\n+#define TIMEGM(result) timegm(result)\n+#endif\n+\n+extern \"C\" CDECL void\n+rust_gmtime(int64_t *sec, int32_t *nsec, rust_tm *timeptr) {\n+    tm tm;\n+    time_t s = *sec;\n+    GMTIME(&s, &tm);\n+\n+    tm_to_rust_tm(&tm, timeptr, 0, \"UTC\", *nsec);\n+}\n+\n+extern \"C\" CDECL void\n+rust_localtime(int64_t *sec, int32_t *nsec, rust_tm *timeptr) {\n+    tm tm;\n+    TZSET();\n+    time_t s = *sec;\n+    LOCALTIME(&s, &tm);\n+\n+#if defined(__WIN32__)\n+    int32_t gmtoff = -timezone;\n+    char zone[64];\n+    strftime(zone, sizeof(zone), \"%Z\", &tm);\n+#else\n+    int32_t gmtoff = tm.tm_gmtoff;\n+    const char *zone = tm.tm_zone;\n+#endif\n+\n+    tm_to_rust_tm(&tm, timeptr, gmtoff, zone, *nsec);\n+}\n+\n+extern \"C\" CDECL void\n+rust_timegm(rust_tm* timeptr, int64_t *out) {\n+    tm t;\n+    rust_tm_to_tm(timeptr, &t);\n+    *out = TIMEGM(&t);\n+}\n+\n+extern \"C\" CDECL void\n+rust_mktime(rust_tm* timeptr, int64_t *out) {\n+    tm t;\n+    rust_tm_to_tm(timeptr, &t);\n+    *out = mktime(&t);\n+}\n+\n extern \"C\" CDECL rust_sched_id\n rust_get_sched_id() {\n     rust_task *task = rust_get_current_task();"}, {"sha": "c392b7142e15a19ac6a323192ff3e78adc5db94c", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aed498842473e58b8123cb57a6e3c8165769fb2/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/3aed498842473e58b8123cb57a6e3c8165769fb2/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=3aed498842473e58b8123cb57a6e3c8165769fb2", "patch": "@@ -12,6 +12,10 @@ debug_abi_2\n get_port_id\n get_task_id\n get_time\n+rust_gmtime\n+rust_localtime\n+rust_timegm\n+rust_mktime\n last_os_error\n new_port\n new_task"}, {"sha": "157141235b38f85bde02e8fb49c95230eeb26eb8", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aed498842473e58b8123cb57a6e3c8165769fb2/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aed498842473e58b8123cb57a6e3c8165769fb2/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=3aed498842473e58b8123cb57a6e3c8165769fb2", "patch": "@@ -5,7 +5,7 @@ import middle::ty;\n import syntax::ast;\n import syntax::ast::{ret_style};\n import util::ppaux::{ty_to_str, mt_to_str};\n-import result::{result, methods, chain, chain_err, ok, err, map, map2, iter2};\n+import result::{result, extensions, ok, err, map, map2, iter2};\n import ty::type_is_bot;\n \n export infer_ctxt;\n@@ -85,7 +85,7 @@ fn fixup_vars(cx: infer_ctxt, a: ty::t) -> fres<ty::t> {\n impl methods for ures {\n     fn then<T:copy>(f: fn() -> result<T,ty::type_err>)\n         -> result<T,ty::type_err> {\n-        chain(self) {|_i| f() }\n+        self.chain() {|_i| f() }\n     }\n }\n "}, {"sha": "495622b4e522ad7812c9214a5c3b16564a1ad7fc", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3aed498842473e58b8123cb57a6e3c8165769fb2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aed498842473e58b8123cb57a6e3c8165769fb2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3aed498842473e58b8123cb57a6e3c8165769fb2", "patch": "@@ -155,10 +155,10 @@ fn get_dest_addr(dest: dest) -> ValueRef {\n     }\n }\n \n-fn log_fn_time(ccx: @crate_ctxt, name: str, start: time::timeval,\n-               end: time::timeval) {\n+fn log_fn_time(ccx: @crate_ctxt, name: str, start: time::timespec,\n+               end: time::timespec) {\n     let elapsed = 1000 * ((end.sec - start.sec) as int) +\n-        ((end.usec as int) - (start.usec as int)) / 1000;\n+        ((end.nsec as int) - (start.nsec as int)) / 1000000;\n     *ccx.stats.fn_times += [{ident: name, time: elapsed}];\n }\n \n@@ -4056,7 +4056,7 @@ fn trans_fn(ccx: @crate_ctxt,\n             id: ast::node_id) {\n     let do_time = ccx.sess.opts.stats;\n     let start = if do_time { time::get_time() }\n-                else { {sec: 0u32, usec: 0u32} };\n+                else { {sec: 0i64, nsec: 0i32} };\n     let _icx = ccx.insn_ctxt(\"trans_fn\");\n     trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n                   param_substs, id, {|fcx|"}]}