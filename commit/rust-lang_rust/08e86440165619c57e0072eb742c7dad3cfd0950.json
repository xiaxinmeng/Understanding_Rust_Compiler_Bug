{"sha": "08e86440165619c57e0072eb742c7dad3cfd0950", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZTg2NDQwMTY1NjE5YzU3ZTAwNzJlYjc0MmM3ZGFkM2NmZDA5NTA=", "commit": {"author": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2021-09-06T23:05:24Z"}, "committer": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2021-09-09T00:32:03Z"}, "message": "move thir visitor to rustc_middle", "tree": {"sha": "750b8ee1f50f110521522de00e411b95cf12c825", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/750b8ee1f50f110521522de00e411b95cf12c825"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08e86440165619c57e0072eb742c7dad3cfd0950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08e86440165619c57e0072eb742c7dad3cfd0950", "html_url": "https://github.com/rust-lang/rust/commit/08e86440165619c57e0072eb742c7dad3cfd0950", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08e86440165619c57e0072eb742c7dad3cfd0950/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c170dcf04c62ffd79cbf28f340aaf6824e70f493", "url": "https://api.github.com/repos/rust-lang/rust/commits/c170dcf04c62ffd79cbf28f340aaf6824e70f493", "html_url": "https://github.com/rust-lang/rust/commit/c170dcf04c62ffd79cbf28f340aaf6824e70f493"}], "stats": {"total": 486, "additions": 244, "deletions": 242}, "files": [{"sha": "3012676c872bd042342d66c932341d6e2e5d0a85", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/08e86440165619c57e0072eb742c7dad3cfd0950/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e86440165619c57e0072eb742c7dad3cfd0950/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=08e86440165619c57e0072eb742c7dad3cfd0950", "patch": "@@ -818,3 +818,246 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n         }\n     }\n }\n+\n+pub mod visit {\n+    use super::*;\n+    pub trait Visitor<'a, 'tcx: 'a>: Sized {\n+        fn thir(&self) -> &'a Thir<'tcx>;\n+\n+        fn visit_expr(&mut self, expr: &Expr<'tcx>) {\n+            walk_expr(self, expr);\n+        }\n+\n+        fn visit_stmt(&mut self, stmt: &Stmt<'tcx>) {\n+            walk_stmt(self, stmt);\n+        }\n+\n+        fn visit_block(&mut self, block: &Block) {\n+            walk_block(self, block);\n+        }\n+\n+        fn visit_arm(&mut self, arm: &Arm<'tcx>) {\n+            walk_arm(self, arm);\n+        }\n+\n+        fn visit_pat(&mut self, pat: &Pat<'tcx>) {\n+            walk_pat(self, pat);\n+        }\n+\n+        fn visit_const(&mut self, _cnst: &'tcx Const<'tcx>) {}\n+    }\n+\n+    pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Expr<'tcx>) {\n+        use ExprKind::*;\n+        match expr.kind {\n+            Scope { value, region_scope: _, lint_level: _ } => {\n+                visitor.visit_expr(&visitor.thir()[value])\n+            }\n+            Box { value } => visitor.visit_expr(&visitor.thir()[value]),\n+            If { cond, then, else_opt, if_then_scope: _ } => {\n+                visitor.visit_expr(&visitor.thir()[cond]);\n+                visitor.visit_expr(&visitor.thir()[then]);\n+                if let Some(else_expr) = else_opt {\n+                    visitor.visit_expr(&visitor.thir()[else_expr]);\n+                }\n+            }\n+            Call { fun, ref args, ty: _, from_hir_call: _, fn_span: _ } => {\n+                visitor.visit_expr(&visitor.thir()[fun]);\n+                for &arg in &**args {\n+                    visitor.visit_expr(&visitor.thir()[arg]);\n+                }\n+            }\n+            Deref { arg } => visitor.visit_expr(&visitor.thir()[arg]),\n+            Binary { lhs, rhs, op: _ } | LogicalOp { lhs, rhs, op: _ } => {\n+                visitor.visit_expr(&visitor.thir()[lhs]);\n+                visitor.visit_expr(&visitor.thir()[rhs]);\n+            }\n+            Unary { arg, op: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n+            Cast { source } => visitor.visit_expr(&visitor.thir()[source]),\n+            Use { source } => visitor.visit_expr(&visitor.thir()[source]),\n+            NeverToAny { source } => visitor.visit_expr(&visitor.thir()[source]),\n+            Pointer { source, cast: _ } => visitor.visit_expr(&visitor.thir()[source]),\n+            Let { expr, .. } => {\n+                visitor.visit_expr(&visitor.thir()[expr]);\n+            }\n+            Loop { body } => visitor.visit_expr(&visitor.thir()[body]),\n+            Match { scrutinee, ref arms } => {\n+                visitor.visit_expr(&visitor.thir()[scrutinee]);\n+                for &arm in &**arms {\n+                    visitor.visit_arm(&visitor.thir()[arm]);\n+                }\n+            }\n+            Block { ref body } => visitor.visit_block(body),\n+            Assign { lhs, rhs } | AssignOp { lhs, rhs, op: _ } => {\n+                visitor.visit_expr(&visitor.thir()[lhs]);\n+                visitor.visit_expr(&visitor.thir()[rhs]);\n+            }\n+            Field { lhs, name: _ } => visitor.visit_expr(&visitor.thir()[lhs]),\n+            Index { lhs, index } => {\n+                visitor.visit_expr(&visitor.thir()[lhs]);\n+                visitor.visit_expr(&visitor.thir()[index]);\n+            }\n+            VarRef { id: _ } | UpvarRef { closure_def_id: _, var_hir_id: _ } => {}\n+            Borrow { arg, borrow_kind: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n+            AddressOf { arg, mutability: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n+            Break { value, label: _ } => {\n+                if let Some(value) = value {\n+                    visitor.visit_expr(&visitor.thir()[value])\n+                }\n+            }\n+            Continue { label: _ } => {}\n+            Return { value } => {\n+                if let Some(value) = value {\n+                    visitor.visit_expr(&visitor.thir()[value])\n+                }\n+            }\n+            ConstBlock { value } => visitor.visit_const(value),\n+            Repeat { value, count } => {\n+                visitor.visit_expr(&visitor.thir()[value]);\n+                visitor.visit_const(count);\n+            }\n+            Array { ref fields } | Tuple { ref fields } => {\n+                for &field in &**fields {\n+                    visitor.visit_expr(&visitor.thir()[field]);\n+                }\n+            }\n+            Adt(box crate::thir::Adt {\n+                ref fields,\n+                ref base,\n+                adt_def: _,\n+                variant_index: _,\n+                substs: _,\n+                user_ty: _,\n+            }) => {\n+                for field in &**fields {\n+                    visitor.visit_expr(&visitor.thir()[field.expr]);\n+                }\n+                if let Some(base) = base {\n+                    visitor.visit_expr(&visitor.thir()[base.base]);\n+                }\n+            }\n+            PlaceTypeAscription { source, user_ty: _ }\n+            | ValueTypeAscription { source, user_ty: _ } => {\n+                visitor.visit_expr(&visitor.thir()[source])\n+            }\n+            Closure { closure_id: _, substs: _, upvars: _, movability: _, fake_reads: _ } => {}\n+            Literal { literal, user_ty: _, const_id: _ } => visitor.visit_const(literal),\n+            StaticRef { literal, def_id: _ } => visitor.visit_const(literal),\n+            InlineAsm { ref operands, template: _, options: _, line_spans: _ } => {\n+                for op in &**operands {\n+                    use InlineAsmOperand::*;\n+                    match op {\n+                        In { expr, reg: _ }\n+                        | Out { expr: Some(expr), reg: _, late: _ }\n+                        | InOut { expr, reg: _, late: _ }\n+                        | SymFn { expr } => visitor.visit_expr(&visitor.thir()[*expr]),\n+                        SplitInOut { in_expr, out_expr, reg: _, late: _ } => {\n+                            visitor.visit_expr(&visitor.thir()[*in_expr]);\n+                            if let Some(out_expr) = out_expr {\n+                                visitor.visit_expr(&visitor.thir()[*out_expr]);\n+                            }\n+                        }\n+                        Out { expr: None, reg: _, late: _ }\n+                        | Const { value: _, span: _ }\n+                        | SymStatic { def_id: _ } => {}\n+                    }\n+                }\n+            }\n+            ThreadLocalRef(_) => {}\n+            LlvmInlineAsm { ref outputs, ref inputs, asm: _ } => {\n+                for &out_expr in &**outputs {\n+                    visitor.visit_expr(&visitor.thir()[out_expr]);\n+                }\n+                for &in_expr in &**inputs {\n+                    visitor.visit_expr(&visitor.thir()[in_expr]);\n+                }\n+            }\n+            Yield { value } => visitor.visit_expr(&visitor.thir()[value]),\n+        }\n+    }\n+\n+    pub fn walk_stmt<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, stmt: &Stmt<'tcx>) {\n+        match &stmt.kind {\n+            StmtKind::Expr { expr, scope: _ } => visitor.visit_expr(&visitor.thir()[*expr]),\n+            StmtKind::Let {\n+                initializer,\n+                remainder_scope: _,\n+                init_scope: _,\n+                ref pattern,\n+                lint_level: _,\n+            } => {\n+                if let Some(init) = initializer {\n+                    visitor.visit_expr(&visitor.thir()[*init]);\n+                }\n+                visitor.visit_pat(pattern);\n+            }\n+        }\n+    }\n+\n+    pub fn walk_block<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, block: &Block) {\n+        for &stmt in &*block.stmts {\n+            visitor.visit_stmt(&visitor.thir()[stmt]);\n+        }\n+        if let Some(expr) = block.expr {\n+            visitor.visit_expr(&visitor.thir()[expr]);\n+        }\n+    }\n+\n+    pub fn walk_arm<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, arm: &Arm<'tcx>) {\n+        match arm.guard {\n+            Some(Guard::If(expr)) => visitor.visit_expr(&visitor.thir()[expr]),\n+            Some(Guard::IfLet(ref pat, expr)) => {\n+                visitor.visit_pat(pat);\n+                visitor.visit_expr(&visitor.thir()[expr]);\n+            }\n+            None => {}\n+        }\n+        visitor.visit_pat(&arm.pattern);\n+        visitor.visit_expr(&visitor.thir()[arm.body]);\n+    }\n+\n+    pub fn walk_pat<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, pat: &Pat<'tcx>) {\n+        use PatKind::*;\n+        match pat.kind.as_ref() {\n+            AscribeUserType { subpattern, ascription: _ }\n+            | Deref { subpattern }\n+            | Binding {\n+                subpattern: Some(subpattern),\n+                mutability: _,\n+                mode: _,\n+                var: _,\n+                ty: _,\n+                is_primary: _,\n+                name: _,\n+            } => visitor.visit_pat(&subpattern),\n+            Binding { .. } | Wild => {}\n+            Variant { subpatterns, adt_def: _, substs: _, variant_index: _ }\n+            | Leaf { subpatterns } => {\n+                for subpattern in subpatterns {\n+                    visitor.visit_pat(&subpattern.pattern);\n+                }\n+            }\n+            Constant { value } => visitor.visit_const(value),\n+            Range(range) => {\n+                visitor.visit_const(range.lo);\n+                visitor.visit_const(range.hi);\n+            }\n+            Slice { prefix, slice, suffix } | Array { prefix, slice, suffix } => {\n+                for subpattern in prefix {\n+                    visitor.visit_pat(&subpattern);\n+                }\n+                if let Some(pat) = slice {\n+                    visitor.visit_pat(pat);\n+                }\n+                for subpattern in suffix {\n+                    visitor.visit_pat(&subpattern);\n+                }\n+            }\n+            Or { pats } => {\n+                for pat in pats {\n+                    visitor.visit_pat(&pat);\n+                }\n+            }\n+        };\n+    }\n+}"}, {"sha": "0e82b187201422d4983f105718266d74e946fb1d", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e86440165619c57e0072eb742c7dad3cfd0950/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e86440165619c57e0072eb742c7dad3cfd0950/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=08e86440165619c57e0072eb742c7dad3cfd0950", "patch": "@@ -1,5 +1,5 @@\n use crate::build::ExprCategory;\n-use crate::thir::visit::{self, Visitor};\n+use rustc_middle::thir::visit::{self, Visitor};\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;"}, {"sha": "ddbe1b0b69c1eb9dba9686063215b7c4086f9618", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e86440165619c57e0072eb742c7dad3cfd0950/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e86440165619c57e0072eb742c7dad3cfd0950/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=08e86440165619c57e0072eb742c7dad3cfd0950", "patch": "@@ -11,4 +11,3 @@ crate mod cx;\n crate mod pattern;\n \n mod util;\n-pub mod visit;"}, {"sha": "51c371b872057ad2a440c91df342438f8ad2c1b3", "filename": "compiler/rustc_mir_build/src/thir/visit.rs", "status": "removed", "additions": 0, "deletions": 240, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/c170dcf04c62ffd79cbf28f340aaf6824e70f493/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c170dcf04c62ffd79cbf28f340aaf6824e70f493/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fvisit.rs?ref=c170dcf04c62ffd79cbf28f340aaf6824e70f493", "patch": "@@ -1,240 +0,0 @@\n-use rustc_middle::thir::{self, *};\n-use rustc_middle::ty::Const;\n-\n-pub trait Visitor<'a, 'tcx: 'a>: Sized {\n-    fn thir(&self) -> &'a Thir<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &Expr<'tcx>) {\n-        walk_expr(self, expr);\n-    }\n-\n-    fn visit_stmt(&mut self, stmt: &Stmt<'tcx>) {\n-        walk_stmt(self, stmt);\n-    }\n-\n-    fn visit_block(&mut self, block: &Block) {\n-        walk_block(self, block);\n-    }\n-\n-    fn visit_arm(&mut self, arm: &Arm<'tcx>) {\n-        walk_arm(self, arm);\n-    }\n-\n-    fn visit_pat(&mut self, pat: &Pat<'tcx>) {\n-        walk_pat(self, pat);\n-    }\n-\n-    fn visit_const(&mut self, _cnst: &'tcx Const<'tcx>) {}\n-}\n-\n-pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Expr<'tcx>) {\n-    use ExprKind::*;\n-    match expr.kind {\n-        Scope { value, region_scope: _, lint_level: _ } => {\n-            visitor.visit_expr(&visitor.thir()[value])\n-        }\n-        Box { value } => visitor.visit_expr(&visitor.thir()[value]),\n-        If { cond, then, else_opt, if_then_scope: _ } => {\n-            visitor.visit_expr(&visitor.thir()[cond]);\n-            visitor.visit_expr(&visitor.thir()[then]);\n-            if let Some(else_expr) = else_opt {\n-                visitor.visit_expr(&visitor.thir()[else_expr]);\n-            }\n-        }\n-        Call { fun, ref args, ty: _, from_hir_call: _, fn_span: _ } => {\n-            visitor.visit_expr(&visitor.thir()[fun]);\n-            for &arg in &**args {\n-                visitor.visit_expr(&visitor.thir()[arg]);\n-            }\n-        }\n-        Deref { arg } => visitor.visit_expr(&visitor.thir()[arg]),\n-        Binary { lhs, rhs, op: _ } | LogicalOp { lhs, rhs, op: _ } => {\n-            visitor.visit_expr(&visitor.thir()[lhs]);\n-            visitor.visit_expr(&visitor.thir()[rhs]);\n-        }\n-        Unary { arg, op: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n-        Cast { source } => visitor.visit_expr(&visitor.thir()[source]),\n-        Use { source } => visitor.visit_expr(&visitor.thir()[source]),\n-        NeverToAny { source } => visitor.visit_expr(&visitor.thir()[source]),\n-        Pointer { source, cast: _ } => visitor.visit_expr(&visitor.thir()[source]),\n-        Let { expr, .. } => {\n-            visitor.visit_expr(&visitor.thir()[expr]);\n-        }\n-        Loop { body } => visitor.visit_expr(&visitor.thir()[body]),\n-        Match { scrutinee, ref arms } => {\n-            visitor.visit_expr(&visitor.thir()[scrutinee]);\n-            for &arm in &**arms {\n-                visitor.visit_arm(&visitor.thir()[arm]);\n-            }\n-        }\n-        Block { ref body } => visitor.visit_block(body),\n-        Assign { lhs, rhs } | AssignOp { lhs, rhs, op: _ } => {\n-            visitor.visit_expr(&visitor.thir()[lhs]);\n-            visitor.visit_expr(&visitor.thir()[rhs]);\n-        }\n-        Field { lhs, name: _ } => visitor.visit_expr(&visitor.thir()[lhs]),\n-        Index { lhs, index } => {\n-            visitor.visit_expr(&visitor.thir()[lhs]);\n-            visitor.visit_expr(&visitor.thir()[index]);\n-        }\n-        VarRef { id: _ } | UpvarRef { closure_def_id: _, var_hir_id: _ } => {}\n-        Borrow { arg, borrow_kind: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n-        AddressOf { arg, mutability: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n-        Break { value, label: _ } => {\n-            if let Some(value) = value {\n-                visitor.visit_expr(&visitor.thir()[value])\n-            }\n-        }\n-        Continue { label: _ } => {}\n-        Return { value } => {\n-            if let Some(value) = value {\n-                visitor.visit_expr(&visitor.thir()[value])\n-            }\n-        }\n-        ConstBlock { value } => visitor.visit_const(value),\n-        Repeat { value, count } => {\n-            visitor.visit_expr(&visitor.thir()[value]);\n-            visitor.visit_const(count);\n-        }\n-        Array { ref fields } | Tuple { ref fields } => {\n-            for &field in &**fields {\n-                visitor.visit_expr(&visitor.thir()[field]);\n-            }\n-        }\n-        Adt(box thir::Adt {\n-            ref fields,\n-            ref base,\n-            adt_def: _,\n-            variant_index: _,\n-            substs: _,\n-            user_ty: _,\n-        }) => {\n-            for field in &**fields {\n-                visitor.visit_expr(&visitor.thir()[field.expr]);\n-            }\n-            if let Some(base) = base {\n-                visitor.visit_expr(&visitor.thir()[base.base]);\n-            }\n-        }\n-        PlaceTypeAscription { source, user_ty: _ } | ValueTypeAscription { source, user_ty: _ } => {\n-            visitor.visit_expr(&visitor.thir()[source])\n-        }\n-        Closure { closure_id: _, substs: _, upvars: _, movability: _, fake_reads: _ } => {}\n-        Literal { literal, user_ty: _, const_id: _ } => visitor.visit_const(literal),\n-        StaticRef { literal, def_id: _ } => visitor.visit_const(literal),\n-        InlineAsm { ref operands, template: _, options: _, line_spans: _ } => {\n-            for op in &**operands {\n-                use InlineAsmOperand::*;\n-                match op {\n-                    In { expr, reg: _ }\n-                    | Out { expr: Some(expr), reg: _, late: _ }\n-                    | InOut { expr, reg: _, late: _ }\n-                    | SymFn { expr } => visitor.visit_expr(&visitor.thir()[*expr]),\n-                    SplitInOut { in_expr, out_expr, reg: _, late: _ } => {\n-                        visitor.visit_expr(&visitor.thir()[*in_expr]);\n-                        if let Some(out_expr) = out_expr {\n-                            visitor.visit_expr(&visitor.thir()[*out_expr]);\n-                        }\n-                    }\n-                    Out { expr: None, reg: _, late: _ }\n-                    | Const { value: _, span: _ }\n-                    | SymStatic { def_id: _ } => {}\n-                }\n-            }\n-        }\n-        ThreadLocalRef(_) => {}\n-        LlvmInlineAsm { ref outputs, ref inputs, asm: _ } => {\n-            for &out_expr in &**outputs {\n-                visitor.visit_expr(&visitor.thir()[out_expr]);\n-            }\n-            for &in_expr in &**inputs {\n-                visitor.visit_expr(&visitor.thir()[in_expr]);\n-            }\n-        }\n-        Yield { value } => visitor.visit_expr(&visitor.thir()[value]),\n-    }\n-}\n-\n-pub fn walk_stmt<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, stmt: &Stmt<'tcx>) {\n-    match &stmt.kind {\n-        StmtKind::Expr { expr, scope: _ } => visitor.visit_expr(&visitor.thir()[*expr]),\n-        StmtKind::Let {\n-            initializer,\n-            remainder_scope: _,\n-            init_scope: _,\n-            ref pattern,\n-            lint_level: _,\n-        } => {\n-            if let Some(init) = initializer {\n-                visitor.visit_expr(&visitor.thir()[*init]);\n-            }\n-            visitor.visit_pat(pattern);\n-        }\n-    }\n-}\n-\n-pub fn walk_block<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, block: &Block) {\n-    for &stmt in &*block.stmts {\n-        visitor.visit_stmt(&visitor.thir()[stmt]);\n-    }\n-    if let Some(expr) = block.expr {\n-        visitor.visit_expr(&visitor.thir()[expr]);\n-    }\n-}\n-\n-pub fn walk_arm<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, arm: &Arm<'tcx>) {\n-    match arm.guard {\n-        Some(Guard::If(expr)) => visitor.visit_expr(&visitor.thir()[expr]),\n-        Some(Guard::IfLet(ref pat, expr)) => {\n-            visitor.visit_pat(pat);\n-            visitor.visit_expr(&visitor.thir()[expr]);\n-        }\n-        None => {}\n-    }\n-    visitor.visit_pat(&arm.pattern);\n-    visitor.visit_expr(&visitor.thir()[arm.body]);\n-}\n-\n-pub fn walk_pat<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, pat: &Pat<'tcx>) {\n-    use PatKind::*;\n-    match pat.kind.as_ref() {\n-        AscribeUserType { subpattern, ascription: _ }\n-        | Deref { subpattern }\n-        | Binding {\n-            subpattern: Some(subpattern),\n-            mutability: _,\n-            mode: _,\n-            var: _,\n-            ty: _,\n-            is_primary: _,\n-            name: _,\n-        } => visitor.visit_pat(&subpattern),\n-        Binding { .. } | Wild => {}\n-        Variant { subpatterns, adt_def: _, substs: _, variant_index: _ } | Leaf { subpatterns } => {\n-            for subpattern in subpatterns {\n-                visitor.visit_pat(&subpattern.pattern);\n-            }\n-        }\n-        Constant { value } => visitor.visit_const(value),\n-        Range(range) => {\n-            visitor.visit_const(range.lo);\n-            visitor.visit_const(range.hi);\n-        }\n-        Slice { prefix, slice, suffix } | Array { prefix, slice, suffix } => {\n-            for subpattern in prefix {\n-                visitor.visit_pat(&subpattern);\n-            }\n-            if let Some(pat) = slice {\n-                visitor.visit_pat(pat);\n-            }\n-            for subpattern in suffix {\n-                visitor.visit_pat(&subpattern);\n-            }\n-        }\n-        Or { pats } => {\n-            for pat in pats {\n-                visitor.visit_pat(&pat);\n-            }\n-        }\n-    };\n-}"}]}