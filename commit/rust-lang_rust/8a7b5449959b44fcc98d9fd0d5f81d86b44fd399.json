{"sha": "8a7b5449959b44fcc98d9fd0d5f81d86b44fd399", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhN2I1NDQ5OTU5YjQ0ZmNjOThkOWZkMGQ1ZjgxZDg2YjQ0ZmQzOTk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-19T19:46:51Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-19T19:58:57Z"}, "message": "Finish name collision testing.\n\nAnd fix a the single screw-up in the source code it caught.", "tree": {"sha": "c151182106be24892999a7670ac3ca71b4952bd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c151182106be24892999a7670ac3ca71b4952bd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a7b5449959b44fcc98d9fd0d5f81d86b44fd399", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a7b5449959b44fcc98d9fd0d5f81d86b44fd399", "html_url": "https://github.com/rust-lang/rust/commit/8a7b5449959b44fcc98d9fd0d5f81d86b44fd399", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a7b5449959b44fcc98d9fd0d5f81d86b44fd399/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31d65453d47f243635ea17563db6b2c1127e9836", "url": "https://api.github.com/repos/rust-lang/rust/commits/31d65453d47f243635ea17563db6b2c1127e9836", "html_url": "https://github.com/rust-lang/rust/commit/31d65453d47f243635ea17563db6b2c1127e9836"}], "stats": {"total": 147, "additions": 139, "deletions": 8}, "files": [{"sha": "b59e70604c5471167b84f52c2949a3343773eaae", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a7b5449959b44fcc98d9fd0d5f81d86b44fd399/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a7b5449959b44fcc98d9fd0d5f81d86b44fd399/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=8a7b5449959b44fcc98d9fd0d5f81d86b44fd399", "patch": "@@ -470,7 +470,6 @@ fn parse_ty(&parser p) -> @ast::ty {\n     // FIXME: do something with this\n     let ast::layer lyr = parse_layer(p);\n \n-    let ast::ty t;\n     if      (eat_word(p, \"bool\")) { t = ast::ty_bool; }\n     else if (eat_word(p, \"int\")) { t = ast::ty_int; }\n     else if (eat_word(p, \"uint\")) { t = ast::ty_uint; }"}, {"sha": "0ad368db9d4e354b63015996f58e7809389d403e", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 131, "deletions": 7, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/8a7b5449959b44fcc98d9fd0d5f81d86b44fd399/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a7b5449959b44fcc98d9fd0d5f81d86b44fd399/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=8a7b5449959b44fcc98d9fd0d5f81d86b44fd399", "patch": "@@ -634,7 +634,7 @@ fn lookup_in_block(&ident id, &ast::block_ b, namespace ns)\n     ret none[def];\n }\n \n-fn found_def_item(@ast::item i, namespace ns) -> option::t[def] {\n+fn found_def_item(&@ast::item i, namespace ns) -> option::t[def] {\n     alt (i.node) {\n         case (ast::item_const(_, _, _, ?defid, _)) {\n             if (ns == ns_value) { ret some(ast::def_const(defid)); }\n@@ -928,20 +928,21 @@ fn lookup_external(&env e, int cnum, vec[ident] ids, namespace ns)\n // Collision detection\n \n fn check_for_collisions(&@env e, &ast::crate c) {\n-    auto msp = mie_span;\n+    // Module indices make checking those relatively simple -- just check each\n+    // name for multiple entities in the same namespace.\n     for each (@tup(ast::def_num, @indexed_mod) m in e.mod_map.items()) {\n         for each (@tup(ident, list[mod_index_entry]) name in\n                   m._1.index.items()) {\n             check_mod_name(*e, name._0, name._1);\n         }\n     }\n-    /*\n-    auto v = rec(visit_item_pre = bind visit_item(e, _),\n+\n+    // Other scopes have to be checked the hard way.\n+    auto v = rec(visit_item_pre = bind check_item(e, _),\n+                 visit_block_pre = bind check_block(e, _),\n+                 visit_arm_pre = bind check_arm(e, _)\n                  with walk::default_visitor());\n     walk::walk_crate(v, c);\n-    fn visit_item(@env e, &@ast::item i) {\n-        \n-    }*/\n }\n \n fn check_mod_name(&env e, &ident name, &list[mod_index_entry] entries) {\n@@ -983,6 +984,129 @@ fn mie_span(&mod_index_entry mie) -> span {\n }\n \n \n+fn check_item(@env e, &@ast::item i) {\n+    alt (i.node) {\n+        case (ast::item_fn(_, ?f, ?ty_params, _, _)) {\n+            check_fn(*e, i.span, f);\n+            ensure_unique(*e, i.span, ty_params, ident_id, \"type parameter\");\n+        }\n+        case (ast::item_obj(_, ?ob, ?ty_params, _, _)) {\n+            fn field_name(&ast::obj_field field) -> ident {\n+                ret field.ident;\n+            }\n+            ensure_unique(*e, i.span, ob.fields, field_name, \"object field\");\n+            for (@ast::method m in ob.methods) {\n+                check_fn(*e, m.span, m.node.meth);\n+            }\n+            ensure_unique(*e, i.span, ty_params, ident_id, \"type parameter\");\n+        }\n+        case (ast::item_tag(_, _, ?ty_params, _, _)) {\n+            ensure_unique(*e, i.span, ty_params, ident_id, \"type parameter\");\n+        }\n+        case (_) {}\n+    }\n+}\n+\n+fn check_arm(@env e, &ast::arm a) {\n+    fn walk_pat(checker ch, &@ast::pat p) {\n+        alt (p.node) {\n+            case (ast::pat_bind(?name, _, _)) {\n+                add_name(ch, p.span, name);\n+            }\n+            case (ast::pat_tag(_, ?children, _)) {\n+                for (@ast::pat child in children) {\n+                    walk_pat(ch, child);\n+                }\n+            }\n+            case (_) {}\n+        }\n+    }\n+    walk_pat(checker(*e, \"binding\"), a.pat);\n+}\n+\n+fn check_block(@env e, &ast::block b) {\n+    auto values = checker(*e, \"value\");\n+    auto types = checker(*e, \"type\");\n+    auto mods = checker(*e, \"module\");\n+    \n+    for (@ast::stmt st in b.node.stmts) {\n+        alt (st.node) {\n+            case (ast::stmt_decl(?d,_)) {\n+                alt (d.node) {\n+                    case (ast::decl_local(?loc)) {\n+                        add_name(values, d.span, loc.ident);\n+                    }\n+                    case (ast::decl_item(?it)) {\n+                        alt (it.node) {\n+                            case (ast::item_tag(?name, ?variants, _, _, _)) {\n+                                add_name(types, it.span, name);\n+                                for (ast::variant v in variants) {\n+                                    add_name(values, v.span, v.node.name);\n+                                }\n+                            }\n+                            case (ast::item_const(?name, _, _, _, _)) {\n+                                add_name(values, it.span, name);\n+                            }\n+                            case (ast::item_fn(?name, _, _, _, _)) {\n+                                add_name(values, it.span, name);\n+                            }\n+                            case (ast::item_mod(?name, _, _)) {\n+                                add_name(mods, it.span, name);\n+                            }\n+                            case (ast::item_native_mod(?name, _, _)) {\n+                                add_name(mods, it.span, name);\n+                            }\n+                            case (ast::item_ty(?name, _, _, _, _)) {\n+                                add_name(types, it.span, name);\n+                            }\n+                            case (ast::item_obj(?name, _, _, _, _)) {\n+                                add_name(types, it.span, name);\n+                                add_name(values, it.span, name);\n+                            }\n+                            case (_) { }\n+                        }\n+                    }\n+                }\n+            }\n+            case (_) {}\n+        }\n+    }\n+}\n+\n+fn check_fn(&env e, &span sp, &ast::_fn f) {\n+    fn arg_name(&ast::arg a) -> ident {\n+        ret a.ident;\n+    }\n+    ensure_unique(e, sp, f.decl.inputs, arg_name, \"argument\");\n+}\n+\n+type checker = @rec(mutable vec[ident] seen,\n+                    str kind,\n+                    session sess);\n+fn checker(&env e, str kind) -> checker {\n+    let vec[ident] seen = [];\n+    ret @rec(mutable seen=seen, kind=kind, sess=e.sess);\n+}\n+\n+fn add_name(&checker ch, &span sp, &ident id) {\n+    for (ident s in ch.seen) {\n+        if (str::eq(s, id)) {\n+            ch.sess.span_err(sp, \"duplicate \" + ch.kind + \" name: \" + id);\n+        }\n+    }\n+    vec::push(ch.seen, id);\n+}\n+\n+fn ident_id(&ident i) -> ident { ret i; }\n+\n+fn ensure_unique[T](&env e, &span sp, &vec[T] elts, fn (&T) -> ident id,\n+                    &str kind) {\n+    auto ch = checker(e, kind);\n+    for (T elt in elts) {\n+        add_name(ch, sp, id(elt));\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "7baad6b373f6f94b86ad6d80074ac00d7cc47596", "filename": "src/test/compile-fail/duplicate-name.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a7b5449959b44fcc98d9fd0d5f81d86b44fd399/src%2Ftest%2Fcompile-fail%2Fduplicate-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a7b5449959b44fcc98d9fd0d5f81d86b44fd399/src%2Ftest%2Fcompile-fail%2Fduplicate-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fduplicate-name.rs?ref=8a7b5449959b44fcc98d9fd0d5f81d86b44fd399", "patch": "@@ -0,0 +1,8 @@\n+// xfail-stage0\n+\n+// error-pattern: duplicate value name: x\n+\n+fn main() {\n+    auto x = 10;\n+    let int x = 20;\n+}"}]}