{"sha": "200ed9f8cd49e823c788b6ce1096030d9c40ec02", "node_id": "C_kwDOAAsO6NoAKDIwMGVkOWY4Y2Q0OWU4MjNjNzg4YjZjZTEwOTYwMzBkOWM0MGVjMDI", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-05-23T14:32:59Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-05-30T10:40:35Z"}, "message": "leak_check: remove unused codepath", "tree": {"sha": "ac561d5b61f4915af5a4f75a92a4c81809cf830e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac561d5b61f4915af5a4f75a92a4c81809cf830e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/200ed9f8cd49e823c788b6ce1096030d9c40ec02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/200ed9f8cd49e823c788b6ce1096030d9c40ec02", "html_url": "https://github.com/rust-lang/rust/commit/200ed9f8cd49e823c788b6ce1096030d9c40ec02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/200ed9f8cd49e823c788b6ce1096030d9c40ec02/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "578bcbc2b42191556c4438b80ba37fafa4193e82", "url": "https://api.github.com/repos/rust-lang/rust/commits/578bcbc2b42191556c4438b80ba37fafa4193e82", "html_url": "https://github.com/rust-lang/rust/commit/578bcbc2b42191556c4438b80ba37fafa4193e82"}], "stats": {"total": 51, "additions": 9, "deletions": 42}, "files": [{"sha": "ee36936a06ecfe1fc8f180602799516c600d1007", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/200ed9f8cd49e823c788b6ce1096030d9c40ec02/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200ed9f8cd49e823c788b6ce1096030d9c40ec02/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=200ed9f8cd49e823c788b6ce1096030d9c40ec02", "patch": "@@ -824,7 +824,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // want the coerced type to be the actual supertype of these two,\n             // but for now, we want to just error to ensure we don't lock\n             // ourselves into a specific behavior with NLL.\n-            self.leak_check(false, snapshot)?;\n+            self.leak_check(snapshot)?;\n \n             result\n         })"}, {"sha": "00e1082068351691947513f03621be550108896d", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/200ed9f8cd49e823c788b6ce1096030d9c40ec02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200ed9f8cd49e823c788b6ce1096030d9c40ec02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=200ed9f8cd49e823c788b6ce1096030d9c40ec02", "patch": "@@ -108,11 +108,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// See [RegionConstraintCollector::leak_check][1].\n     ///\n     /// [1]: crate::infer::region_constraints::RegionConstraintCollector::leak_check\n-    pub fn leak_check(\n-        &self,\n-        overly_polymorphic: bool,\n-        snapshot: &CombinedSnapshot<'tcx>,\n-    ) -> RelateResult<'tcx, ()> {\n+    pub fn leak_check(&self, snapshot: &CombinedSnapshot<'tcx>) -> RelateResult<'tcx, ()> {\n         // If the user gave `-Zno-leak-check`, or we have been\n         // configured to skip the leak check, then skip the leak check\n         // completely. The leak check is deprecated. Any legitimate\n@@ -125,7 +121,6 @@ impl<'tcx> InferCtxt<'tcx> {\n \n         self.inner.borrow_mut().unwrap_region_constraints().leak_check(\n             self.tcx,\n-            overly_polymorphic,\n             self.universe(),\n             snapshot,\n         )"}, {"sha": "7b9e6983212a7a6145400d772ff1a5a658215a01", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/200ed9f8cd49e823c788b6ce1096030d9c40ec02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200ed9f8cd49e823c788b6ce1096030d9c40ec02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=200ed9f8cd49e823c788b6ce1096030d9c40ec02", "patch": "@@ -65,13 +65,12 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     pub fn leak_check(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        overly_polymorphic: bool,\n         max_universe: ty::UniverseIndex,\n         snapshot: &CombinedSnapshot<'tcx>,\n     ) -> RelateResult<'tcx, ()> {\n         debug!(\n-            \"leak_check(max_universe={:?}, snapshot.universe={:?}, overly_polymorphic={:?})\",\n-            max_universe, snapshot.universe, overly_polymorphic\n+            \"leak_check(max_universe={:?}, snapshot.universe={:?})\",\n+            max_universe, snapshot.universe\n         );\n \n         assert!(UndoLogs::<super::UndoLog<'_>>::in_snapshot(&self.undo_log));\n@@ -84,14 +83,8 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         let mini_graph =\n             &MiniGraph::new(tcx, self.undo_log.region_constraints(), &self.storage.data.verifys);\n \n-        let mut leak_check = LeakCheck::new(\n-            tcx,\n-            universe_at_start_of_snapshot,\n-            max_universe,\n-            overly_polymorphic,\n-            mini_graph,\n-            self,\n-        );\n+        let mut leak_check =\n+            LeakCheck::new(tcx, universe_at_start_of_snapshot, max_universe, mini_graph, self);\n         leak_check.assign_placeholder_values()?;\n         leak_check.propagate_scc_value()?;\n         Ok(())\n@@ -101,8 +94,6 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n struct LeakCheck<'me, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     universe_at_start_of_snapshot: ty::UniverseIndex,\n-    /// Only used when reporting region errors.\n-    overly_polymorphic: bool,\n     mini_graph: &'me MiniGraph<'tcx>,\n     rcc: &'me RegionConstraintCollector<'me, 'tcx>,\n \n@@ -132,15 +123,13 @@ impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         universe_at_start_of_snapshot: ty::UniverseIndex,\n         max_universe: ty::UniverseIndex,\n-        overly_polymorphic: bool,\n         mini_graph: &'me MiniGraph<'tcx>,\n         rcc: &'me RegionConstraintCollector<'me, 'tcx>,\n     ) -> Self {\n         let dummy_scc_universe = SccUniverse { universe: max_universe, region: None };\n         Self {\n             tcx,\n             universe_at_start_of_snapshot,\n-            overly_polymorphic,\n             mini_graph,\n             rcc,\n             scc_placeholders: IndexVec::from_elem_n(None, mini_graph.sccs.num_sccs()),\n@@ -289,11 +278,7 @@ impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n         other_region: ty::Region<'tcx>,\n     ) -> TypeError<'tcx> {\n         debug!(\"error: placeholder={:?}, other_region={:?}\", placeholder, other_region);\n-        if self.overly_polymorphic {\n-            TypeError::RegionsOverlyPolymorphic(placeholder.bound.kind, other_region)\n-        } else {\n-            TypeError::RegionsInsufficientlyPolymorphic(placeholder.bound.kind, other_region)\n-        }\n+        TypeError::RegionsInsufficientlyPolymorphic(placeholder.bound.kind, other_region)\n     }\n }\n "}, {"sha": "66293f19eef63c42ccb6c9a1ce08a07ff590e2a9", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/200ed9f8cd49e823c788b6ce1096030d9c40ec02/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200ed9f8cd49e823c788b6ce1096030d9c40ec02/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=200ed9f8cd49e823c788b6ce1096030d9c40ec02", "patch": "@@ -45,7 +45,6 @@ pub enum TypeError<'tcx> {\n \n     RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n     RegionsInsufficientlyPolymorphic(BoundRegionKind, Region<'tcx>),\n-    RegionsOverlyPolymorphic(BoundRegionKind, Region<'tcx>),\n     RegionsPlaceholderMismatch,\n \n     Sorts(ExpectedFound<Ty<'tcx>>),\n@@ -74,7 +73,6 @@ impl TypeError<'_> {\n         match self {\n             TypeError::RegionsDoesNotOutlive(_, _)\n             | TypeError::RegionsInsufficientlyPolymorphic(_, _)\n-            | TypeError::RegionsOverlyPolymorphic(_, _)\n             | TypeError::RegionsPlaceholderMismatch => true,\n             _ => false,\n         }\n@@ -98,11 +96,6 @@ impl<'tcx> TypeError<'tcx> {\n             }\n         }\n \n-        let br_string = |br: ty::BoundRegionKind| match br {\n-            ty::BrNamed(_, name) => format!(\" {}\", name),\n-            _ => String::new(),\n-        };\n-\n         match self {\n             CyclicTy(_) => \"cyclic type of infinite size\".into(),\n             CyclicConst(_) => \"encountered a self-referencing constant\".into(),\n@@ -144,11 +137,6 @@ impl<'tcx> TypeError<'tcx> {\n             RegionsInsufficientlyPolymorphic(..) => {\n                 \"one type is more general than the other\".into()\n             }\n-            RegionsOverlyPolymorphic(br, _) => format!(\n-                \"expected concrete lifetime, found bound lifetime parameter{}\",\n-                br_string(br)\n-            )\n-            .into(),\n             RegionsPlaceholderMismatch => \"one type is more general than the other\".into(),\n             ArgumentSorts(values, _) | Sorts(values) => {\n                 let expected = values.expected.sort_string(tcx);\n@@ -228,7 +216,6 @@ impl<'tcx> TypeError<'tcx> {\n             | FieldMisMatch(..)\n             | RegionsDoesNotOutlive(..)\n             | RegionsInsufficientlyPolymorphic(..)\n-            | RegionsOverlyPolymorphic(..)\n             | RegionsPlaceholderMismatch\n             | Traits(_)\n             | ProjectionMismatched(_)"}, {"sha": "dda77c2a461d8df622000afc22b96e19ce0f785c", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/200ed9f8cd49e823c788b6ce1096030d9c40ec02/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200ed9f8cd49e823c788b6ce1096030d9c40ec02/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=200ed9f8cd49e823c788b6ce1096030d9c40ec02", "patch": "@@ -200,7 +200,7 @@ fn overlap_within_probe<'cx, 'tcx>(\n \n     // We disable the leak when creating the `snapshot` by using\n     // `infcx.probe_maybe_disable_leak_check`.\n-    if infcx.leak_check(true, snapshot).is_err() {\n+    if infcx.leak_check(snapshot).is_err() {\n         debug!(\"overlap: leak check failed\");\n         return None;\n     }"}, {"sha": "2c0b911c80505a5a289985a8cf0a8cd0a2125ea9", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/200ed9f8cd49e823c788b6ce1096030d9c40ec02/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200ed9f8cd49e823c788b6ce1096030d9c40ec02/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=200ed9f8cd49e823c788b6ce1096030d9c40ec02", "patch": "@@ -563,7 +563,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx.probe(|snapshot| -> Result<EvaluationResult, OverflowError> {\n             let result = op(self)?;\n \n-            match self.infcx.leak_check(true, snapshot) {\n+            match self.infcx.leak_check(snapshot) {\n                 Ok(()) => {}\n                 Err(_) => return Ok(EvaluatedToErr),\n             }"}]}