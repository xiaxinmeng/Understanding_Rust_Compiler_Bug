{"sha": "89490e416b9eff7d22cbea235475db1cba581ff6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NDkwZTQxNmI5ZWZmN2QyMmNiZWEyMzU0NzVkYjFjYmE1ODFmZjY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-13T08:51:36Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-13T09:35:25Z"}, "message": "Change resolve to use walk instead of fold\n\nPossibly, at some point, we should add a state-passing variant of\nwalk, or a wrapper that makes it easier to thread state. (See the\nrepetetive pop_state_for_* functions in this commit.)", "tree": {"sha": "271149e2c20567f18effdf0da54358297a45e5f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/271149e2c20567f18effdf0da54358297a45e5f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89490e416b9eff7d22cbea235475db1cba581ff6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89490e416b9eff7d22cbea235475db1cba581ff6", "html_url": "https://github.com/rust-lang/rust/commit/89490e416b9eff7d22cbea235475db1cba581ff6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89490e416b9eff7d22cbea235475db1cba581ff6/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7082bf4478d3c4dab5a46bf2df18b57a496023f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7082bf4478d3c4dab5a46bf2df18b57a496023f4", "html_url": "https://github.com/rust-lang/rust/commit/7082bf4478d3c4dab5a46bf2df18b57a496023f4"}], "stats": {"total": 268, "additions": 164, "deletions": 104}, "files": [{"sha": "ad89ac9cad2f84b203db75655c42057061154dc9", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89490e416b9eff7d22cbea235475db1cba581ff6/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89490e416b9eff7d22cbea235475db1cba581ff6/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=89490e416b9eff7d22cbea235475db1cba581ff6", "patch": "@@ -92,10 +92,8 @@ fn compile_input(session::session sess,\n \n     crate = time(time_passes, \"external crate reading\",\n                  bind creader::read_crates(sess, crate));\n-    auto res = time(time_passes, \"resolution\",\n-                    bind resolve::resolve_crate(sess, crate));\n-    crate = res._0;\n-    auto def_map = res._1;\n+    auto def_map = time(time_passes, \"resolution\",\n+                        bind resolve::resolve_crate(sess, crate));\n     time[()](time_passes, \"capture checking\",\n              bind capture::check_for_captures(sess, crate, def_map));\n "}, {"sha": "ce7a2376e5e1b4064652192bc9a16f09cd15325b", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 162, "deletions": 100, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/89490e416b9eff7d22cbea235475db1cba581ff6/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89490e416b9eff7d22cbea235475db1cba581ff6/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=89490e416b9eff7d22cbea235475db1cba581ff6", "patch": "@@ -93,8 +93,7 @@ tag namespace {\n     ns_type;\n }\n \n-fn resolve_crate(session sess, @ast::crate crate)\n-    -> tup(@ast::crate, def_map) {\n+fn resolve_crate(session sess, @ast::crate crate) -> def_map {\n     auto e = @rec(def_map = new_uint_hash[def](),\n                   imports = new_int_hash[import_state](),\n                   mod_map = new_int_hash[@indexed_mod](),\n@@ -104,7 +103,8 @@ fn resolve_crate(session sess, @ast::crate crate)\n                   sess = sess);\n     map_crate(e, *crate);\n     resolve_imports(*e);\n-    ret tup(resolve_names(e, *crate), e.def_map);\n+    resolve_names(e, *crate);\n+    ret e.def_map;\n }\n \n // Locate all modules and imports and index them, so that the next passes can\n@@ -115,24 +115,24 @@ fn map_crate(&@env e, &ast::crate c) {\n     auto v = rec(visit_crate_pre = bind push_env_for_crate(cell, _),\n                  visit_crate_post = bind pop_env_for_crate(cell, _),\n                  visit_view_item_pre = bind visit_view_item(e, cell, _),\n-                 visit_item_pre = bind push_env_for_item_map_mod(e, cell, _),\n+                 visit_item_pre = bind visit_item(e, cell, _),\n                  visit_item_post = bind pop_env_for_item(cell, _)\n                  with walk::default_visitor());\n     // Register the top-level mod\n     e.mod_map.insert(-1, @rec(m=c.node.module,\n                               index=index_mod(c.node.module)));\n     walk::walk_crate(v, c);\n \n-    // Helpers for this pass.\n-    fn push_env_for_crate(@mutable list[scope] sc, &ast::crate c) {\n-        *sc = cons[scope](scope_crate(@c), @*sc);\n-    }\n-    fn pop_env_for_crate(@mutable list[scope] sc, &ast::crate c) {\n-        *sc = std::list::cdr(*sc);\n+    fn visit_view_item(@env e, @mutable list[scope] sc, &@ast::view_item i) {\n+        alt (i.node) {\n+            case (ast::view_item_import(_, ?ids, ?defid)) {\n+                e.imports.insert(defid._1, todo(i, *sc));\n+            }\n+            case (_) {}\n+        }\n     }\n-    fn push_env_for_item_map_mod(@env e, @mutable list[scope] sc,\n-                                 &@ast::item i) {\n-        *sc = cons[scope](scope_item(i), @*sc);\n+    fn visit_item(@env e, @mutable list[scope] sc, &@ast::item i) {\n+        push_env_for_item(sc, i);\n         alt (i.node) {\n             case (ast::item_mod(_, ?md, ?defid)) {\n                 auto index = index_mod(md);\n@@ -145,17 +145,6 @@ fn map_crate(&@env e, &ast::crate c) {\n             case (_) {}\n         }\n     }\n-    fn pop_env_for_item(@mutable list[scope] sc, &@ast::item i) {\n-        *sc = std::list::cdr(*sc);\n-    }\n-    fn visit_view_item(@env e, @mutable list[scope] sc, &@ast::view_item i) {\n-        alt (i.node) {\n-            case (ast::view_item_import(_, ?ids, ?defid)) {\n-                e.imports.insert(defid._1, todo(i, *sc));\n-            }\n-            case (_) {}\n-        }\n-    }\n }\n \n fn resolve_imports(&env e) {\n@@ -169,68 +158,151 @@ fn resolve_imports(&env e) {\n     }\n }\n \n-// FIXME this should use walk (will need to add walk_arm)\n-fn resolve_names(&@env e, &ast::crate c) -> @ast::crate {\n-    auto fld = @rec(fold_pat_tag = bind fold_pat_tag(e,_,_,_,_,_),\n-                    fold_expr_path = bind fold_expr_path(e,_,_,_,_),\n-                    fold_ty_path = bind fold_ty_path(e,_,_,_,_),\n-                    update_env_for_crate = bind update_env_for_crate(_,_),\n-                    update_env_for_item = bind update_env_for_item(_,_),\n-                    update_env_for_native_item =\n-                       bind update_env_for_native_item(_,_),\n-                    update_env_for_block = bind update_env_for_block(_,_),\n-                    update_env_for_arm = bind update_env_for_arm(_,_),\n-                    update_env_for_expr = bind update_env_for_expr(_,_)\n-                    with *fold::new_identity_fold[list[scope]]());\n-    ret fold::fold_crate(nil[scope], fld, @c);\n-\n-    // Helpers for this pass\n+fn resolve_names(&@env e, &ast::crate c) {\n+    auto cell = @mutable nil[scope];\n+    auto v = rec(visit_crate_pre = bind push_env_for_crate(cell, _),\n+                 visit_crate_post = bind pop_env_for_crate(cell, _),\n+                 visit_item_pre = bind push_env_for_item(cell, _),\n+                 visit_item_post = bind pop_env_for_item(cell, _),\n+                 visit_method_pre = bind push_env_for_method(cell, _),\n+                 visit_method_post = bind pop_env_for_method(cell, _),\n+                 visit_native_item_pre = bind push_env_for_n_item(cell, _),\n+                 visit_native_item_post = bind pop_env_for_n_item(cell, _),\n+                 visit_block_pre = bind push_env_for_block(cell, _),\n+                 visit_block_post = bind pop_env_for_block(cell, _),\n+                 visit_arm_pre = bind walk_arm(e, cell, _),\n+                 visit_arm_post = bind pop_env_for_arm(cell, _),\n+                 visit_expr_pre = bind walk_expr(e, cell, _),\n+                 visit_expr_post = bind pop_env_for_expr(cell, _),\n+                 visit_ty_pre = bind walk_ty(e, cell, _)\n+                 with walk::default_visitor());\n+    walk::walk_crate(v, c);\n \n-    fn update_env_for_crate(&list[scope] sc, &@ast::crate c) -> list[scope] {\n-        ret cons[scope](scope_crate(c), @sc);\n-    }\n-    fn update_env_for_item(&list[scope] sc, &@ast::item i) -> list[scope] {\n-        ret cons[scope](scope_item(i), @sc);\n+    fn walk_expr(@env e, @mutable list[scope] sc, &@ast::expr exp) {\n+        push_env_for_expr(sc, exp);\n+        alt (exp.node) {\n+            case (ast::expr_path(?p, ?a)) {\n+                auto df = lookup_path_strict(*e, *sc, exp.span, p.node.idents,\n+                                             ns_value);\n+                e.def_map.insert(ast::ann_tag(a), df);\n+            }\n+            case (_) {}\n+        }\n     }\n-    fn update_env_for_native_item(&list[scope] sc, &@ast::native_item i)\n-        -> list[scope] {\n-        ret cons[scope](scope_native_item(i), @sc);\n+    fn walk_ty(@env e, @mutable list[scope] sc, &@ast::ty t) {\n+        alt (t.node) {\n+            case (ast::ty_path(?p, ?a)) {\n+                auto new_def = lookup_path_strict(*e, *sc, t.span,\n+                                                  p.node.idents, ns_type);\n+                e.def_map.insert(ast::ann_tag(a), new_def);\n+            }\n+            case (_) {}\n+        }\n     }\n-    fn update_env_for_block(&list[scope] sc, &ast::block b) -> list[scope] {\n-        ret cons[scope](scope_block(b), @sc);\n+    fn walk_arm(@env e, @mutable list[scope] sc, &ast::arm a) {\n+        walk_pat(*e, *sc, a.pat);\n+        push_env_for_arm(sc, a);\n     }\n-    fn update_env_for_expr(&list[scope] sc, &@ast::expr x) -> list[scope] {\n-        alt (x.node) {\n-            case (ast::expr_for(?d, _, _, _)) {\n-                ret cons[scope](scope_loop(d), @sc);\n-            }\n-            case (ast::expr_for_each(?d, _, _, _)) {\n-                ret cons[scope](scope_loop(d), @sc);\n+    fn walk_pat(&env e, &list[scope] sc, &@ast::pat pat) {\n+        alt (pat.node) {\n+            case (ast::pat_tag(?p, ?children, ?a)) {\n+                auto fnd = lookup_path_strict(e, sc, p.span, p.node.idents,\n+                                              ns_value);\n+                alt (fnd) {\n+                    case (ast::def_variant(?did, ?vid)) {\n+                        e.def_map.insert(ast::ann_tag(a), fnd);\n+                    }\n+                    case (_) {\n+                        e.sess.span_err(p.span, \"not a tag variant: \" +\n+                                        _str::connect(p.node.idents, \"::\"));\n+                        fail;\n+                    }\n+                }\n+                for (@ast::pat child in children) {\n+                    walk_pat(e, sc, child);\n+                }\n             }\n-            case (_) { ret sc; }\n+            case (_) {}\n         }\n     }\n-    fn update_env_for_arm(&list[scope] sc, &ast::arm p) -> list[scope] {\n-        ret cons[scope](scope_arm(p), @sc);\n-    }\n }\n \n-fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n-    alt (e.imports.get(defid._1)) {\n-        case (todo(?item, ?sc)) {\n-            resolve_import(e, item, sc);\n-            ret lookup_import(e, defid, ns);\n+// Helpers for tracking scope during a walk\n+\n+fn push_env_for_crate(@mutable list[scope] sc, &ast::crate c) {\n+    *sc = cons[scope](scope_crate(@c), @*sc);\n+}\n+fn pop_env_for_crate(@mutable list[scope] sc, &ast::crate c) {\n+    *sc = std::list::cdr(*sc);\n+}\n+\n+fn push_env_for_item(@mutable list[scope] sc, &@ast::item i) {\n+    *sc = cons[scope](scope_item(i), @*sc);\n+}\n+fn pop_env_for_item(@mutable list[scope] sc, &@ast::item i) {\n+    *sc = std::list::cdr(*sc);\n+}\n+\n+fn push_env_for_method(@mutable list[scope] sc, &@ast::method m) {\n+    let vec[ast::ty_param] tp = vec();\n+    let @ast::item i = @rec(node=ast::item_fn(m.node.ident,\n+                                              m.node.meth,\n+                                              tp,\n+                                              m.node.id,\n+                                              m.node.ann),\n+                            span=m.span);\n+    *sc = cons[scope](scope_item(i), @*sc);\n+}\n+fn pop_env_for_method(@mutable list[scope] sc, &@ast::method m) {\n+    *sc = std::list::cdr(*sc);\n+}\n+\n+fn push_env_for_n_item(@mutable list[scope] sc, &@ast::native_item i) {\n+    *sc = cons[scope](scope_native_item(i), @*sc);\n+}\n+fn pop_env_for_n_item(@mutable list[scope] sc, &@ast::native_item i) {\n+    *sc = std::list::cdr(*sc);\n+}\n+\n+fn push_env_for_block(@mutable list[scope] sc, &ast::block b) {\n+    *sc = cons[scope](scope_block(b), @*sc);\n+}\n+fn pop_env_for_block(@mutable list[scope] sc, &ast::block b) {\n+    *sc = std::list::cdr(*sc);\n+}\n+\n+fn push_env_for_expr(@mutable list[scope] sc, &@ast::expr x) {\n+    alt (x.node) {\n+        case (ast::expr_for(?d, _, _, _)) {\n+            *sc = cons[scope](scope_loop(d), @*sc);\n         }\n-        case (resolving(?sp)) {\n-            e.sess.span_err(sp, \"cyclic import\");\n+        case (ast::expr_for_each(?d, _, _, _)) {\n+            *sc = cons[scope](scope_loop(d), @*sc);\n         }\n-        case (resolved(?val, ?typ)) {\n-            ret alt (ns) { case (ns_value) { val }\n-                           case (ns_type) { typ } };\n+        case (_) {}\n+    }\n+}\n+fn pop_env_for_expr(@mutable list[scope] sc, &@ast::expr x) {\n+    alt (x.node) {\n+        case (ast::expr_for(?d, _, _, _)) {\n+            *sc = std::list::cdr(*sc);\n         }\n+        case (ast::expr_for_each(?d, _, _, _)) {\n+            *sc = std::list::cdr(*sc);\n+        }\n+        case (_) {}\n     }\n }\n \n+fn push_env_for_arm(@mutable list[scope] sc, &ast::arm p) {\n+    *sc = cons[scope](scope_arm(p), @*sc);\n+}\n+fn pop_env_for_arm(@mutable list[scope] sc, &ast::arm p) {\n+    *sc = std::list::cdr(*sc);\n+}\n+\n+// Import resolution\n+\n fn resolve_import(&env e, &@ast::view_item it, &list[scope] sc) {\n     auto defid; auto ids;\n     alt (it.node) {\n@@ -277,35 +349,7 @@ fn resolve_import(&env e, &@ast::view_item it, &list[scope] sc) {\n     }\n }\n \n-fn fold_expr_path(@env e, &list[scope] sc, &span sp, &ast::path p, &ann a)\n-    -> @ast::expr {\n-    auto df = lookup_path_strict(*e, sc, sp, p.node.idents, ns_value);\n-    e.def_map.insert(ast::ann_tag(a), df);\n-    ret @fold::respan(sp, ast::expr_path(p, a));\n-}\n-\n-\n-fn fold_pat_tag(@env e, &list[scope] sc, &span sp, &ast::path p,\n-                &vec[@ast::pat] args, &ann a) -> @ast::pat {\n-    alt (lookup_path_strict(*e, sc, sp, p.node.idents, ns_value)) {\n-        case (ast::def_variant(?did, ?vid)) {\n-            e.def_map.insert(ast::ann_tag(a), ast::def_variant(did, vid));\n-            ret @fold::respan[ast::pat_](sp, ast::pat_tag(p, args, a));\n-        }\n-        case (_) {\n-            e.sess.span_err(sp, \"not a tag variant: \" +\n-                            _str::connect(p.node.idents, \"::\"));\n-            fail;\n-        }\n-    }\n-}\n-\n-fn fold_ty_path(@env e, &list[scope] sc, &span sp, &ast::path p,\n-                &ast::ann a) -> @ast::ty {\n-    auto new_def = lookup_path_strict(*e, sc, sp, p.node.idents, ns_type);\n-    e.def_map.insert(ast::ann_tag(a), new_def);\n-    ret @fold::respan[ast::ty_](sp, ast::ty_path(p, a));\n-}\n+// Utilities\n \n fn is_module(def d) -> bool {\n     alt (d) {\n@@ -326,6 +370,8 @@ fn unresolved(&env e, &span sp, ident id, str kind) {\n     e.sess.span_err(sp, \"unresolved \" + kind + \": \" + id);\n }\n \n+// Lookup helpers\n+\n fn lookup_path_strict(&env e, &list[scope] sc, &span sp, vec[ident] idents,\n                       namespace ns) -> def {\n     auto n_idents = _vec::len(idents);\n@@ -628,6 +674,22 @@ fn found_view_item(&env e, @ast::view_item vi, namespace ns)\n     }\n }\n \n+fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n+    alt (e.imports.get(defid._1)) {\n+        case (todo(?item, ?sc)) {\n+            resolve_import(e, item, sc);\n+            ret lookup_import(e, defid, ns);\n+        }\n+        case (resolving(?sp)) {\n+            e.sess.span_err(sp, \"cyclic import\");\n+        }\n+        case (resolved(?val, ?typ)) {\n+            ret alt (ns) { case (ns_value) { val }\n+                           case (ns_type) { typ } };\n+        }\n+    }\n+}\n+\n fn lookup_in_regular_mod(&env e, def_id defid, ident id, namespace ns, dir dr)\n     -> option::t[def] {\n     auto info = e.mod_map.get(defid._1);"}]}