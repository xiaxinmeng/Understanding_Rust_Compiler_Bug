{"sha": "54fa70290d8ab65e33116eb888278f7a64ca6da4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZmE3MDI5MGQ4YWI2NWUzMzExNmViODg4Mjc4ZjdhNjRjYTZkYTQ=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-20T01:56:40Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T00:49:32Z"}, "message": "Unify the paths through `is_useful`", "tree": {"sha": "7461c11e0298f8832618e42ab59bb42ba5aff2f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7461c11e0298f8832618e42ab59bb42ba5aff2f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54fa70290d8ab65e33116eb888278f7a64ca6da4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54fa70290d8ab65e33116eb888278f7a64ca6da4", "html_url": "https://github.com/rust-lang/rust/commit/54fa70290d8ab65e33116eb888278f7a64ca6da4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54fa70290d8ab65e33116eb888278f7a64ca6da4/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c96bd28ab375e6e273bac174e86860c9d3a27510", "url": "https://api.github.com/repos/rust-lang/rust/commits/c96bd28ab375e6e273bac174e86860c9d3a27510", "html_url": "https://github.com/rust-lang/rust/commit/c96bd28ab375e6e273bac174e86860c9d3a27510"}], "stats": {"total": 156, "additions": 53, "deletions": 103}, "files": [{"sha": "c7f09ea4ad94a8c7e972365ce70437a842a1ace9", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 53, "deletions": 103, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/54fa70290d8ab65e33116eb888278f7a64ca6da4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54fa70290d8ab65e33116eb888278f7a64ca6da4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=54fa70290d8ab65e33116eb888278f7a64ca6da4", "patch": "@@ -181,7 +181,6 @@\n //! we ignore all the patterns in the first column of `P` that involve other constructors.\n //! This is where `S(c, P)` comes in:\n //! `U(P, p) := U(S(c, P), S(c, p))`\n-//! This special case is handled in `is_useful_specialized`.\n //!\n //! For example, if `P` is:\n //!\n@@ -1116,8 +1115,8 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n-    /// Some constructors (namely IntRange and Slice) actually stand for a set of actual\n-    /// constructors (integers and fixed-sized slices). When specializing for these\n+    /// Some constructors (namely Wildcard, IntRange and Slice) actually stand for a set of actual\n+    /// constructors (like variants, integers or fixed-sized slices). When specializing for these\n     /// constructors, we want to be specialising for the actual underlying constructors.\n     /// Naively, we would simply return the list of constructors they correspond to. We instead are\n     /// more clever: if there are constructors that we know will behave the same wrt the current\n@@ -1136,6 +1135,7 @@ impl<'tcx> Constructor<'tcx> {\n         debug!(\"Constructor::split({:#?}, {:#?})\", self, pcx.matrix);\n \n         match self {\n+            Wildcard => Constructor::split_wildcard(pcx),\n             // Fast-track if the range is trivial. In particular, we don't do the overlapping\n             // ranges check.\n             IntRange(ctor_range)\n@@ -1149,6 +1149,30 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n+    /// For wildcards, there are two groups of constructors: there are the constructors actually\n+    /// present in the matrix (`head_ctors`), and the constructors not present (`missing_ctors`).\n+    /// Two constructors that are not in the matrix will either both be catched (by a wildcard), or\n+    /// both not be catched. Therefore we can keep the missing constructors grouped together.\n+    fn split_wildcard<'p>(pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Self; 1]> {\n+        // Missing constructors are those that are not matched by any non-wildcard patterns in the\n+        // current column. We only fully construct them on-demand, because they're rarely used and\n+        // can be big.\n+        let missing_ctors = MissingConstructors::new(pcx);\n+\n+        if missing_ctors.is_empty() {\n+            // All the constructors are present in the matrix, so we just go through them all.\n+            // We must also split them first.\n+            // Since `all_ctors` never contains wildcards, this won't recurse more than once.\n+            let (all_ctors, _) = missing_ctors.into_inner();\n+            all_ctors.into_iter().flat_map(|ctor| ctor.split(pcx, None)).collect()\n+        } else {\n+            // Some constructors are missing, thus we can specialize with the wildcard constructor,\n+            // which will stand for those constructors that are missing, and behaves like any of\n+            // them.\n+            smallvec![Wildcard]\n+        }\n+    }\n+\n     /// Returns whether `self` is covered by `other`, ie whether `self` is a subset of `other`. For\n     /// the simple cases, this is simply checking for equality. For the \"grouped\" constructors,\n     /// this checks for inclusion.\n@@ -1617,8 +1641,8 @@ impl<'tcx> Usefulness<'tcx> {\n         match self {\n             UsefulWithWitness(witnesses) => {\n                 let new_witnesses = if ctor.is_wildcard() {\n-                    let missing_ctors = MissingConstructors::new(pcx, is_top_level);\n-                    let new_patterns = missing_ctors.report_patterns(pcx);\n+                    let missing_ctors = MissingConstructors::new(pcx);\n+                    let new_patterns = missing_ctors.report_patterns(pcx, is_top_level);\n                     witnesses\n                         .into_iter()\n                         .flat_map(|witness| {\n@@ -2217,16 +2241,15 @@ impl<'tcx> std::cmp::PartialEq for IntRange<'tcx> {\n struct MissingConstructors<'tcx> {\n     all_ctors: Vec<Constructor<'tcx>>,\n     used_ctors: Vec<Constructor<'tcx>>,\n-    is_top_level: bool,\n }\n \n impl<'tcx> MissingConstructors<'tcx> {\n-    fn new<'p>(pcx: PatCtxt<'_, 'p, 'tcx>, is_top_level: bool) -> Self {\n+    fn new<'p>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Self {\n         let used_ctors: Vec<Constructor<'_>> =\n             pcx.matrix.head_ctors(pcx.cx).cloned().filter(|c| !c.is_wildcard()).collect();\n         let all_ctors = all_constructors(pcx);\n \n-        MissingConstructors { all_ctors, used_ctors, is_top_level }\n+        MissingConstructors { all_ctors, used_ctors }\n     }\n \n     fn into_inner(self) -> (Vec<Constructor<'tcx>>, Vec<Constructor<'tcx>>) {\n@@ -2244,7 +2267,11 @@ impl<'tcx> MissingConstructors<'tcx> {\n \n     /// List the patterns corresponding to the missing constructors. In some cases, instead of\n     /// listing all constructors of a given type, we prefer to simply report a wildcard.\n-    fn report_patterns<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Pat<'tcx>; 1]> {\n+    fn report_patterns<'p>(\n+        &self,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        is_top_level: bool,\n+    ) -> SmallVec<[Pat<'tcx>; 1]> {\n         // There are 2 ways we can report a witness here.\n         // Commonly, we can report all the \"free\"\n         // constructors as witnesses, e.g., if we have:\n@@ -2272,7 +2299,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n         // `used_ctors` is empty.\n         // The exception is: if we are at the top-level, for example in an empty match, we\n         // sometimes prefer reporting the list of constructors instead of just `_`.\n-        let report_when_all_missing = self.is_top_level && !IntRange::is_integral(pcx.ty);\n+        let report_when_all_missing = is_top_level && !IntRange::is_integral(pcx.ty);\n         if self.used_ctors.is_empty() && !report_when_all_missing {\n             // All constructors are unused. Report only a wildcard\n             // rather than each individual constructor.\n@@ -2407,103 +2434,26 @@ crate fn is_useful<'p, 'tcx>(\n \n     debug!(\"is_useful_expand_first_col: ty={:#?}, expanding {:#?}\", pcx.ty, v.head());\n \n-    let constructor = v.head_ctor(cx);\n-    let ret = if !constructor.is_wildcard() {\n-        debug!(\"is_useful - expanding constructor: {:#?}\", constructor);\n-        constructor\n-            .split(pcx, Some(hir_id))\n-            .into_iter()\n-            .map(|c| {\n-                is_useful_specialized(\n-                    pcx,\n-                    v,\n-                    &c,\n-                    witness_preference,\n-                    hir_id,\n-                    is_under_guard,\n-                    is_top_level,\n-                )\n-            })\n-            .find(|result| result.is_useful())\n-            .unwrap_or(NotUseful)\n-    } else {\n-        debug!(\"is_useful - expanding wildcard\");\n-\n-        // `missing_ctors` is the set of constructors from the same type as the\n-        // first column of `matrix` that are matched only by wildcard patterns\n-        // from the first column.\n-        //\n-        // Therefore, if there is some pattern that is unmatched by `matrix`,\n-        // it will still be unmatched if the first constructor is replaced by\n-        // any of the constructors in `missing_ctors`\n-\n-        // Missing constructors are those that are not matched by any non-wildcard patterns in the\n-        // current column. We only fully construct them on-demand, because they're rarely used and\n-        // can be big.\n-        let missing_ctors = MissingConstructors::new(pcx, is_top_level);\n-\n-        debug!(\"is_useful_missing_ctors.empty()={:#?}\", missing_ctors.is_empty(),);\n-\n-        if missing_ctors.is_empty() {\n-            let (all_ctors, _) = missing_ctors.into_inner();\n-            all_ctors\n-                .into_iter()\n-                .flat_map(|ctor| ctor.split(pcx, None))\n-                .map(|c| {\n-                    is_useful_specialized(\n-                        pcx,\n-                        v,\n-                        &c,\n-                        witness_preference,\n-                        hir_id,\n-                        is_under_guard,\n-                        is_top_level,\n-                    )\n-                })\n-                .find(|result| result.is_useful())\n-                .unwrap_or(NotUseful)\n-        } else {\n-            // Some constructors are missing, thus we can specialize with the wildcard constructor,\n-            // which will stand for those constructors that are missing, and behaves like any of\n-            // them.\n-            is_useful_specialized(\n-                pcx,\n-                v,\n-                constructor,\n-                witness_preference,\n-                hir_id,\n-                is_under_guard,\n-                is_top_level,\n-            )\n-        }\n-    };\n+    let ret = v\n+        .head_ctor(cx)\n+        .split(pcx, Some(hir_id))\n+        .into_iter()\n+        .map(|ctor| {\n+            // We cache the result of `Fields::wildcards` because it is used a lot.\n+            let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n+            let matrix = pcx.matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n+            // Unwrap is ok: v can always be specialized with its own constructor.\n+            let v = v.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns, true).unwrap();\n+            let usefulness =\n+                is_useful(pcx.cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n+            usefulness.apply_constructor(pcx, &ctor, &ctor_wild_subpatterns, is_top_level)\n+        })\n+        .find(|result| result.is_useful())\n+        .unwrap_or(NotUseful);\n     debug!(\"is_useful::returns({:#?}, {:#?}) = {:?}\", matrix, v, ret);\n     ret\n }\n \n-/// A shorthand for the `U(S(c, P), S(c, q))` operation from the paper. I.e., `is_useful` applied\n-/// to the specialised version of both the pattern matrix `P` and the new pattern `q`.\n-fn is_useful_specialized<'p, 'tcx>(\n-    pcx: PatCtxt<'_, 'p, 'tcx>,\n-    v: &PatStack<'p, 'tcx>,\n-    ctor: &Constructor<'tcx>,\n-    witness_preference: WitnessPreference,\n-    hir_id: HirId,\n-    is_under_guard: bool,\n-    is_top_level: bool,\n-) -> Usefulness<'tcx> {\n-    debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, pcx.ty);\n-\n-    // We cache the result of `Fields::wildcards` because it is used a lot.\n-    let ctor_wild_subpatterns = Fields::wildcards(pcx, ctor);\n-    let matrix = pcx.matrix.specialize_constructor(pcx, ctor, &ctor_wild_subpatterns);\n-    // Unwrap is ok: v can always be specialized with its own constructor.\n-    let v = v.specialize_constructor(pcx, ctor, &ctor_wild_subpatterns, true).unwrap();\n-    let usefulness =\n-        is_useful(pcx.cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n-    usefulness.apply_constructor(pcx, ctor, &ctor_wild_subpatterns, is_top_level)\n-}\n-\n /// Determines the constructor that the given pattern can be specialized to.\n /// Returns `None` in case of a catch-all, which can't be specialized.\n fn pat_constructor<'p, 'tcx>("}]}