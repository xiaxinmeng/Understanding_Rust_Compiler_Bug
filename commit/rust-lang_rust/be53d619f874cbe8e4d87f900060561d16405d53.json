{"sha": "be53d619f874cbe8e4d87f900060561d16405d53", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNTNkNjE5Zjg3NGNiZThlNGQ4N2Y5MDAwNjA1NjFkMTY0MDVkNTM=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-07T18:22:04Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-13T22:03:47Z"}, "message": "librustrt: use unboxed closures", "tree": {"sha": "98c294e066724a124903a7779327bba076940b9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98c294e066724a124903a7779327bba076940b9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be53d619f874cbe8e4d87f900060561d16405d53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be53d619f874cbe8e4d87f900060561d16405d53", "html_url": "https://github.com/rust-lang/rust/commit/be53d619f874cbe8e4d87f900060561d16405d53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be53d619f874cbe8e4d87f900060561d16405d53/comments", "author": null, "committer": null, "parents": [{"sha": "b44b5da8c2ad8befb7deb88dc8df61508e1df22f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b44b5da8c2ad8befb7deb88dc8df61508e1df22f", "html_url": "https://github.com/rust-lang/rust/commit/b44b5da8c2ad8befb7deb88dc8df61508e1df22f"}], "stats": {"total": 59, "additions": 42, "deletions": 17}, "files": [{"sha": "c1b48e989a1c142ff85bc32bbc677fe4ff31877d", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be53d619f874cbe8e4d87f900060561d16405d53/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be53d619f874cbe8e4d87f900060561d16405d53/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=be53d619f874cbe8e4d87f900060561d16405d53", "patch": "@@ -89,7 +89,7 @@ mod imp {\n         })\n     }\n \n-    fn with_lock<T>(f: || -> T) -> T {\n+    fn with_lock<T, F>(f: F) -> T where F: FnOnce() -> T {\n         unsafe {\n             let _guard = LOCK.lock();\n             f()"}, {"sha": "865c1af1d14272e6c8f85970c43b8a45dcb710cb", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/be53d619f874cbe8e4d87f900060561d16405d53/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be53d619f874cbe8e4d87f900060561d16405d53/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=be53d619f874cbe8e4d87f900060561d16405d53", "patch": "@@ -72,6 +72,7 @@ use collections::hash;\n use core::fmt;\n use core::kinds::{Sized, marker};\n use core::mem;\n+use core::ops::{FnMut, FnOnce};\n use core::prelude::{Clone, Drop, Eq, Iterator};\n use core::prelude::{SlicePrelude, None, Option, Ordering, PartialEq};\n use core::prelude::{PartialOrd, RawPtr, Some, StrPrelude, range};\n@@ -319,14 +320,18 @@ pub trait ToCStr for Sized? {\n     ///\n     /// Panics the task if the receiver has an interior null.\n     #[inline]\n-    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    fn with_c_str<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         let c_str = self.to_c_str();\n         f(c_str.as_ptr())\n     }\n \n     /// Unsafe variant of `with_c_str()` that doesn't check for nulls.\n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         let c_str = self.to_c_str_unchecked();\n         f(c_str.as_ptr())\n     }\n@@ -344,12 +349,16 @@ impl ToCStr for str {\n     }\n \n     #[inline]\n-    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    fn with_c_str<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         self.as_bytes().with_c_str(f)\n     }\n \n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         self.as_bytes().with_c_str_unchecked(f)\n     }\n }\n@@ -366,12 +375,16 @@ impl ToCStr for String {\n     }\n \n     #[inline]\n-    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    fn with_c_str<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         self.as_bytes().with_c_str(f)\n     }\n \n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         self.as_bytes().with_c_str_unchecked(f)\n     }\n }\n@@ -397,11 +410,15 @@ impl ToCStr for [u8] {\n         CString::new(buf as *const libc::c_char, true)\n     }\n \n-    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    fn with_c_str<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         unsafe { with_c_str(self, true, f) }\n     }\n \n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         with_c_str(self, false, f)\n     }\n }\n@@ -418,19 +435,24 @@ impl<'a, Sized? T: ToCStr> ToCStr for &'a T {\n     }\n \n     #[inline]\n-    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    fn with_c_str<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         (**self).with_c_str(f)\n     }\n \n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         (**self).with_c_str_unchecked(f)\n     }\n }\n \n // Unsafe function that handles possibly copying the &[u8] into a stack array.\n-unsafe fn with_c_str<T>(v: &[u8], checked: bool,\n-                        f: |*const libc::c_char| -> T) -> T {\n+unsafe fn with_c_str<T, F>(v: &[u8], checked: bool, f: F) -> T where\n+    F: FnOnce(*const libc::c_char) -> T,\n+{\n     let c_str = if v.len() < BUF_LEN {\n         let mut buf: [u8, .. BUF_LEN] = mem::uninitialized();\n         slice::bytes::copy_memory(&mut buf, v);\n@@ -489,9 +511,12 @@ impl<'a> Iterator<libc::c_char> for CChars<'a> {\n ///\n /// The specified closure is invoked with each string that\n /// is found, and the number of strings found is returned.\n-pub unsafe fn from_c_multistring(buf: *const libc::c_char,\n-                                 count: Option<uint>,\n-                                 f: |&CString|) -> uint {\n+pub unsafe fn from_c_multistring<F>(buf: *const libc::c_char,\n+                                    count: Option<uint>,\n+                                    mut f: F)\n+                                    -> uint where\n+    F: FnMut(&CString),\n+{\n \n     let mut curr_ptr: uint = buf as uint;\n     let mut ctr = 0;\n@@ -678,7 +703,7 @@ mod tests {\n \n     #[test]\n     fn test_clone_noleak() {\n-        fn foo(f: |c: &CString|) {\n+        fn foo<F>(f: F) where F: FnOnce(&CString) {\n             let s = \"test\".to_string();\n             let c = s.to_c_str();\n             // give the closure a non-owned CString"}]}