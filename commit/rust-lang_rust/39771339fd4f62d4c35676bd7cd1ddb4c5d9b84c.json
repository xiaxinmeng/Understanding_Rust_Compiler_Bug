{"sha": "39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NzcxMzM5ZmQ0ZjYyZDRjMzU2NzZiZDdjZDFkZGI0YzVkOWI4NGM=", "commit": {"author": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2018-11-08T14:28:06Z"}, "committer": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2018-11-08T15:09:20Z"}, "message": "Allow unsized types in mem::drop and mem::forget", "tree": {"sha": "75613135a32c35e7acd9fd59ee0aee4f44595b6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75613135a32c35e7acd9fd59ee0aee4f44595b6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c", "html_url": "https://github.com/rust-lang/rust/commit/39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c/comments", "author": null, "committer": null, "parents": [{"sha": "af791bb8f4a9b93c701aa11fd05759d96898cee2", "url": "https://api.github.com/repos/rust-lang/rust/commits/af791bb8f4a9b93c701aa11fd05759d96898cee2", "html_url": "https://github.com/rust-lang/rust/commit/af791bb8f4a9b93c701aa11fd05759d96898cee2"}], "stats": {"total": 128, "additions": 126, "deletions": 2}, "files": [{"sha": "4fcce7096b4b67f00293565a69de8ec848ab32d7", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c", "patch": "@@ -714,6 +714,10 @@ extern \"rust-intrinsic\" {\n     /// initialize memory previous set to the result of `uninit`.\n     pub fn uninit<T>() -> T;\n \n+    /// Moves a value out of scope without running drop glue.\n+    #[cfg(not(stage0))]\n+    pub fn forget<T>(_: T);\n+\n     /// Reinterprets the bits of a value of one type as another type.\n     ///\n     /// Both types must have the same size. Neither the original, nor the result,"}, {"sha": "b7d0742877ee56e092068ba689f3b285f38970e9", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c", "patch": "@@ -107,6 +107,7 @@\n #![feature(staged_api)]\n #![feature(stmt_expr_attributes)]\n #![feature(unboxed_closures)]\n+#![feature(unsized_locals)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n #![feature(doc_alias)]"}, {"sha": "cff605489ed3e0e1fb9ba158633ffcebc5f1ee69", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 119, "deletions": 1, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c", "patch": "@@ -139,6 +139,124 @@ pub use intrinsics::transmute;\n /// [ub]: ../../reference/behavior-considered-undefined.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+pub fn forget<T: ?Sized>(t: T) {\n+    unsafe { intrinsics::forget(t) }\n+}\n+\n+/// Takes ownership and \"forgets\" about the value **without running its destructor**.\n+///\n+/// Any resources the value manages, such as heap memory or a file handle, will linger\n+/// forever in an unreachable state. However, it does not guarantee that pointers\n+/// to this memory will remain valid.\n+///\n+/// * If you want to leak memory, see [`Box::leak`][leak].\n+/// * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`][into_raw].\n+/// * If you want to dispose of a value properly, running its destructor, see\n+/// [`mem::drop`][drop].\n+///\n+/// # Safety\n+///\n+/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n+/// do not include a guarantee that destructors will always run. For example,\n+/// a program can create a reference cycle using [`Rc`][rc], or call\n+/// [`process::exit`][exit] to exit without running destructors. Thus, allowing\n+/// `mem::forget` from safe code does not fundamentally change Rust's safety\n+/// guarantees.\n+///\n+/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n+/// so `forget` is only recommended for specialized use cases like those shown below.\n+///\n+/// Because forgetting a value is allowed, any `unsafe` code you write must\n+/// allow for this possibility. You cannot return a value and expect that the\n+/// caller will necessarily run the value's destructor.\n+///\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [exit]: ../../std/process/fn.exit.html\n+///\n+/// # Examples\n+///\n+/// Leak an I/O object, never closing the file:\n+///\n+/// ```no_run\n+/// use std::mem;\n+/// use std::fs::File;\n+///\n+/// let file = File::open(\"foo.txt\").unwrap();\n+/// mem::forget(file);\n+/// ```\n+///\n+/// The practical use cases for `forget` are rather specialized and mainly come\n+/// up in unsafe or FFI code.\n+///\n+/// ## Use case 1\n+///\n+/// You have created an uninitialized value using [`mem::uninitialized`][uninit].\n+/// You must either initialize or `forget` it on every computation path before\n+/// Rust drops it automatically, like at the end of a scope or after a panic.\n+/// Running the destructor on an uninitialized value would be [undefined behavior][ub].\n+///\n+/// ```\n+/// use std::mem;\n+/// use std::ptr;\n+///\n+/// # let some_condition = false;\n+/// unsafe {\n+///     let mut uninit_vec: Vec<u32> = mem::uninitialized();\n+///\n+///     if some_condition {\n+///         // Initialize the variable.\n+///         ptr::write(&mut uninit_vec, Vec::new());\n+///     } else {\n+///         // Forget the uninitialized value so its destructor doesn't run.\n+///         mem::forget(uninit_vec);\n+///     }\n+/// }\n+/// ```\n+///\n+/// ## Use case 2\n+///\n+/// You have duplicated the bytes making up a value, without doing a proper\n+/// [`Clone`][clone]. You need the value's destructor to run only once,\n+/// because a double `free` is undefined behavior.\n+///\n+/// An example is a possible implementation of [`mem::swap`][swap]:\n+///\n+/// ```\n+/// use std::mem;\n+/// use std::ptr;\n+///\n+/// # #[allow(dead_code)]\n+/// fn swap<T>(x: &mut T, y: &mut T) {\n+///     unsafe {\n+///         // Give ourselves some scratch space to work with\n+///         let mut t: T = mem::uninitialized();\n+///\n+///         // Perform the swap, `&mut` pointers never alias\n+///         ptr::copy_nonoverlapping(&*x, &mut t, 1);\n+///         ptr::copy_nonoverlapping(&*y, x, 1);\n+///         ptr::copy_nonoverlapping(&t, y, 1);\n+///\n+///         // y and t now point to the same thing, but we need to completely\n+///         // forget `t` because we do not want to run the destructor for `T`\n+///         // on its value, which is still owned somewhere outside this function.\n+///         mem::forget(t);\n+///     }\n+/// }\n+/// ```\n+///\n+/// [drop]: fn.drop.html\n+/// [uninit]: fn.uninitialized.html\n+/// [clone]: ../clone/trait.Clone.html\n+/// [swap]: fn.swap.html\n+/// [FFI]: ../../book/first-edition/ffi.html\n+/// [box]: ../../std/boxed/struct.Box.html\n+/// [leak]: ../../std/boxed/struct.Box.html#method.leak\n+/// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+#[inline]\n+#[cfg(stage0)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn forget<T>(t: T) {\n     ManuallyDrop::new(t);\n }\n@@ -763,7 +881,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// [`Copy`]: ../../std/marker/trait.Copy.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn drop<T>(_x: T) { }\n+pub fn drop<T: ?Sized>(_x: T) { }\n \n /// Interprets `src` as having type `&U`, and then reads `src` without moving\n /// the contained value."}, {"sha": "1681e0137bd68f4fe78479a115881be92a6fa7ab", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c", "patch": "@@ -193,7 +193,7 @@ pub fn codegen_intrinsic_call(\n             return;\n         }\n         // Effectively no-ops\n-        \"uninit\" => {\n+        \"uninit\" | \"forget\" => {\n             return;\n         }\n         \"needs_drop\" => {"}, {"sha": "0279105473f2a3dba6264d332f567c4359bbde0f", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=39771339fd4f62d4c35676bd7cd1ddb4c5d9b84c", "patch": "@@ -134,6 +134,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"rustc_peek\" => (1, vec![param(0)], param(0)),\n             \"init\" => (1, Vec::new(), param(0)),\n             \"uninit\" => (1, Vec::new(), param(0)),\n+            \"forget\" => (1, vec![param(0)], param(0)),\n             \"transmute\" => (2, vec![ param(0) ], param(1)),\n             \"move_val_init\" => {\n                 (1,"}]}