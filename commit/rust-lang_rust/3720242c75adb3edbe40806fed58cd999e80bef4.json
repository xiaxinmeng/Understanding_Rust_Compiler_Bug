{"sha": "3720242c75adb3edbe40806fed58cd999e80bef4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3MjAyNDJjNzVhZGIzZWRiZTQwODA2ZmVkNThjZDk5OWU4MGJlZjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-12T12:57:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:38:11Z"}, "message": "extract `find_anon_type` into its own module", "tree": {"sha": "ce0f5183550636e8d448b027a49e50816d59e515", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce0f5183550636e8d448b027a49e50816d59e515"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3720242c75adb3edbe40806fed58cd999e80bef4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3720242c75adb3edbe40806fed58cd999e80bef4", "html_url": "https://github.com/rust-lang/rust/commit/3720242c75adb3edbe40806fed58cd999e80bef4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3720242c75adb3edbe40806fed58cd999e80bef4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93498e0c2285cba797123fea836670c1b826240c", "url": "https://api.github.com/repos/rust-lang/rust/commits/93498e0c2285cba797123fea836670c1b826240c", "html_url": "https://github.com/rust-lang/rust/commit/93498e0c2285cba797123fea836670c1b826240c"}], "stats": {"total": 559, "additions": 296, "deletions": 263}, "files": [{"sha": "33d38cfb0405d9d7bbc6355020434f8c3f43cc2a", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 0, "deletions": 263, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/3720242c75adb3edbe40806fed58cd999e80bef4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3720242c75adb3edbe40806fed58cd999e80bef4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=3720242c75adb3edbe40806fed58cd999e80bef4", "patch": "@@ -10,14 +10,9 @@\n \n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where both the regions are anonymous.\n-use hir;\n use infer::InferCtxt;\n-use ty::{self, Region};\n use infer::lexical_region_resolve::RegionResolutionError::*;\n use infer::lexical_region_resolve::RegionResolutionError;\n-use hir::map as hir_map;\n-use middle::resolve_lifetime as rl;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use infer::error_reporting::nice_region_error::util::AnonymousArgInfo;\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n@@ -153,263 +148,5 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .emit();\n         return true;\n     }\n-\n-    /// This function calls the `visit_ty` method for the parameters\n-    /// corresponding to the anonymous regions. The `nested_visitor.found_type`\n-    /// contains the anonymous type.\n-    ///\n-    /// # Arguments\n-    /// region - the anonymous region corresponding to the anon_anon conflict\n-    /// br - the bound region corresponding to the above region which is of type `BrAnon(_)`\n-    ///\n-    /// # Example\n-    /// ```\n-    /// fn foo(x: &mut Vec<&u8>, y: &u8)\n-    ///    { x.push(y); }\n-    /// ```\n-    /// The function returns the nested type corresponding to the anonymous region\n-    /// for e.g. `&u8` and Vec<`&u8`.\n-    pub fn find_anon_type(&self,\n-                          region: Region<'tcx>,\n-                          br: &ty::BoundRegion)\n-                          -> Option<(&hir::Ty, &hir::FnDecl)> {\n-        if let Some(anon_reg) = self.is_suitable_region(region) {\n-            let def_id = anon_reg.def_id;\n-            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let fndecl = match self.tcx.hir.get(node_id) {\n-                    hir_map::NodeItem(&hir::Item { node: hir::ItemFn(ref fndecl, ..), .. }) => {\n-                        &fndecl\n-                    }\n-                    hir_map::NodeTraitItem(&hir::TraitItem {\n-                                               node: hir::TraitItemKind::Method(ref m, ..), ..\n-                                           }) |\n-                    hir_map::NodeImplItem(&hir::ImplItem {\n-                                              node: hir::ImplItemKind::Method(ref m, ..), ..\n-                                          }) => &m.decl,\n-                    _ => return None,\n-                };\n-\n-                return fndecl\n-                           .inputs\n-                           .iter()\n-                           .filter_map(|arg| self.find_component_for_bound_region(arg, br))\n-                           .next()\n-                           .map(|ty| (ty, &**fndecl));\n-            }\n-        }\n-        None\n-    }\n-\n-    // This method creates a FindNestedTypeVisitor which returns the type corresponding\n-    // to the anonymous region.\n-    fn find_component_for_bound_region(&self,\n-                                       arg: &'gcx hir::Ty,\n-                                       br: &ty::BoundRegion)\n-                                       -> Option<(&'gcx hir::Ty)> {\n-        let mut nested_visitor = FindNestedTypeVisitor {\n-            infcx: &self,\n-            hir_map: &self.tcx.hir,\n-            bound_region: *br,\n-            found_type: None,\n-            depth: 1,\n-        };\n-        nested_visitor.visit_ty(arg);\n-        nested_visitor.found_type\n-    }\n-}\n-\n-// The FindNestedTypeVisitor captures the corresponding `hir::Ty` of the\n-// anonymous region. The example above would lead to a conflict between\n-// the two anonymous lifetimes for &u8 in x and y respectively. This visitor\n-// would be invoked twice, once for each lifetime, and would\n-// walk the types like &mut Vec<&u8> and &u8 looking for the HIR\n-// where that lifetime appears. This allows us to highlight the\n-// specific part of the type in the error message.\n-struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    hir_map: &'a hir::map::Map<'gcx>,\n-    // The bound_region corresponding to the Refree(freeregion)\n-    // associated with the anonymous region we are looking for.\n-    bound_region: ty::BoundRegion,\n-    // The type where the anonymous lifetime appears\n-    // for e.g. Vec<`&u8`> and <`&u8`>\n-    found_type: Option<&'gcx hir::Ty>,\n-    depth: u32,\n-}\n-\n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.hir_map)\n-    }\n-\n-    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n-        match arg.node {\n-            hir::TyBareFn(_) => {\n-                self.depth += 1;\n-                intravisit::walk_ty(self, arg);\n-                self.depth -= 1;\n-                return;\n-            }\n-\n-            hir::TyTraitObject(ref bounds, _) => {\n-                for bound in bounds {\n-                    self.depth += 1;\n-                    self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n-                    self.depth -= 1;\n-                }\n-            }\n-\n-            hir::TyRptr(ref lifetime, _) => {\n-                // the lifetime of the TyRptr\n-                let hir_id = self.infcx.tcx.hir.node_to_hir_id(lifetime.id);\n-                match (self.infcx.tcx.named_region(hir_id), self.bound_region) {\n-                    // Find the index of the anonymous region that was part of the\n-                    // error. We will then search the function parameters for a bound\n-                    // region at the right depth with the same index\n-                    (Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)),\n-                     ty::BrAnon(br_index)) => {\n-                        debug!(\"LateBoundAnon depth = {:?} anon_index = {:?} br_index={:?}\",\n-                               debruijn_index.depth,\n-                               anon_index,\n-                               br_index);\n-                        if debruijn_index.depth == self.depth && anon_index == br_index {\n-                            self.found_type = Some(arg);\n-                            return; // we can stop visiting now\n-                        }\n-                    }\n-\n-                    // Find the index of the named region that was part of the\n-                    // error. We will then search the function parameters for a bound\n-                    // region at the right depth with the same index\n-                    (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n-                        debug!(\"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n-                                        def_id={:?}\", id, def_id);\n-                        if id == def_id {\n-                            self.found_type = Some(arg);\n-                            return; // we can stop visiting now\n-                        }\n-                    }\n-\n-                    // Find the index of the named region that was part of the\n-                    // error. We will then search the function parameters for a bound\n-                    // region at the right depth with the same index\n-                    (\n-                     Some(rl::Region::LateBound(debruijn_index, id, _)),\n-                     ty::BrNamed(def_id, _)\n-                    ) => {\n-                        debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n-                               debruijn_index.depth);\n-                        debug!(\"self.infcx.tcx.hir.local_def_id(id)={:?}\", id);\n-                        debug!(\"def_id={:?}\", def_id);\n-                        if debruijn_index.depth == self.depth && id == def_id {\n-                            self.found_type = Some(arg);\n-                            return; // we can stop visiting now\n-                        }\n-                    }\n-\n-                    (Some(rl::Region::Static), _) |\n-                    (Some(rl::Region::Free(_, _)), _) |\n-                    (Some(rl::Region::EarlyBound(_, _, _)), _) |\n-                    (Some(rl::Region::LateBound(_, _, _)), _) |\n-                    (Some(rl::Region::LateBoundAnon(_, _)), _) |\n-                    (None, _) => {\n-                        debug!(\"no arg found\");\n-                    }\n-                }\n-            }\n-            // Checks if it is of type `hir::TyPath` which corresponds to a struct.\n-            hir::TyPath(_) => {\n-                let subvisitor = &mut TyPathVisitor {\n-                                          infcx: self.infcx,\n-                                          found_it: false,\n-                                          bound_region: self.bound_region,\n-                                          hir_map: self.hir_map,\n-                                          depth: self.depth,\n-                                      };\n-                intravisit::walk_ty(subvisitor, arg); // call walk_ty; as visit_ty is empty,\n-                // this will visit only outermost type\n-                if subvisitor.found_it {\n-                    self.found_type = Some(arg);\n-                }\n-            }\n-            _ => {}\n-        }\n-        // walk the embedded contents: e.g., if we are visiting `Vec<&Foo>`,\n-        // go on to visit `&Foo`\n-        intravisit::walk_ty(self, arg);\n-    }\n }\n \n-// The visitor captures the corresponding `hir::Ty` of the anonymous region\n-// in the case of structs ie. `hir::TyPath`.\n-// This visitor would be invoked for each lifetime corresponding to a struct,\n-// and would walk the types like Vec<Ref> in the above example and Ref looking for the HIR\n-// where that lifetime appears. This allows us to highlight the\n-// specific part of the type in the error message.\n-struct TyPathVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    hir_map: &'a hir::map::Map<'gcx>,\n-    found_it: bool,\n-    bound_region: ty::BoundRegion,\n-    depth: u32,\n-}\n-\n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.hir_map)\n-    }\n-\n-    fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n-\n-        let hir_id = self.infcx.tcx.hir.node_to_hir_id(lifetime.id);\n-        match (self.infcx.tcx.named_region(hir_id), self.bound_region) {\n-            // the lifetime of the TyPath!\n-            (Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)), ty::BrAnon(br_index)) => {\n-                if debruijn_index.depth == self.depth && anon_index == br_index {\n-                    self.found_it = true;\n-                    return;\n-                }\n-            }\n-\n-            (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n-                debug!(\"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n-                                        def_id={:?}\", id, def_id);\n-                if id == def_id {\n-                    self.found_it = true;\n-                    return; // we can stop visiting now\n-                }\n-            }\n-\n-            (Some(rl::Region::LateBound(debruijn_index, id, _)), ty::BrNamed(def_id, _)) => {\n-                debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n-                       debruijn_index.depth);\n-                debug!(\"id={:?}\", id);\n-                debug!(\"def_id={:?}\", def_id);\n-                if debruijn_index.depth == self.depth && id == def_id {\n-                    self.found_it = true;\n-                    return; // we can stop visiting now\n-                }\n-            }\n-\n-            (Some(rl::Region::Static), _) |\n-            (Some(rl::Region::EarlyBound(_, _, _)), _) |\n-            (Some(rl::Region::LateBound(_, _, _)), _) |\n-            (Some(rl::Region::LateBoundAnon(_, _)), _) |\n-            (Some(rl::Region::Free(_, _)), _) |\n-            (None, _) => {\n-                debug!(\"no arg found\");\n-            }\n-        }\n-    }\n-\n-    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n-        // ignore nested types\n-        //\n-        // If you have a type like `Foo<'a, &Ty>` we\n-        // are only interested in the immediate lifetimes ('a).\n-        //\n-        // Making `visit_ty` empty will ignore the `&Ty` embedded\n-        // inside, it will get reached by the outer visitor.\n-        debug!(\"`Ty` corresponding to a struct is {:?}\", arg);\n-    }\n-}"}, {"sha": "e93b93fcc7ca65111e9a0737df1bd1f25e6dbd8c", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/3720242c75adb3edbe40806fed58cd999e80bef4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3720242c75adb3edbe40806fed58cd999e80bef4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=3720242c75adb3edbe40806fed58cd999e80bef4", "patch": "@@ -0,0 +1,295 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir;\n+use infer::InferCtxt;\n+use ty::{self, Region};\n+use hir::map as hir_map;\n+use middle::resolve_lifetime as rl;\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    /// This function calls the `visit_ty` method for the parameters\n+    /// corresponding to the anonymous regions. The `nested_visitor.found_type`\n+    /// contains the anonymous type.\n+    ///\n+    /// # Arguments\n+    /// region - the anonymous region corresponding to the anon_anon conflict\n+    /// br - the bound region corresponding to the above region which is of type `BrAnon(_)`\n+    ///\n+    /// # Example\n+    /// ```\n+    /// fn foo(x: &mut Vec<&u8>, y: &u8)\n+    ///    { x.push(y); }\n+    /// ```\n+    /// The function returns the nested type corresponding to the anonymous region\n+    /// for e.g. `&u8` and Vec<`&u8`.\n+    pub(super) fn find_anon_type(\n+        &self,\n+        region: Region<'tcx>,\n+        br: &ty::BoundRegion,\n+    ) -> Option<(&hir::Ty, &hir::FnDecl)> {\n+        if let Some(anon_reg) = self.is_suitable_region(region) {\n+            let def_id = anon_reg.def_id;\n+            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                let fndecl = match self.tcx.hir.get(node_id) {\n+                    hir_map::NodeItem(&hir::Item {\n+                        node: hir::ItemFn(ref fndecl, ..),\n+                        ..\n+                    }) => &fndecl,\n+                    hir_map::NodeTraitItem(&hir::TraitItem {\n+                        node: hir::TraitItemKind::Method(ref m, ..),\n+                        ..\n+                    })\n+                    | hir_map::NodeImplItem(&hir::ImplItem {\n+                        node: hir::ImplItemKind::Method(ref m, ..),\n+                        ..\n+                    }) => &m.decl,\n+                    _ => return None,\n+                };\n+\n+                return fndecl\n+                    .inputs\n+                    .iter()\n+                    .filter_map(|arg| self.find_component_for_bound_region(arg, br))\n+                    .next()\n+                    .map(|ty| (ty, &**fndecl));\n+            }\n+        }\n+        None\n+    }\n+\n+    // This method creates a FindNestedTypeVisitor which returns the type corresponding\n+    // to the anonymous region.\n+    fn find_component_for_bound_region(\n+        &self,\n+        arg: &'gcx hir::Ty,\n+        br: &ty::BoundRegion,\n+    ) -> Option<(&'gcx hir::Ty)> {\n+        let mut nested_visitor = FindNestedTypeVisitor {\n+            infcx: &self,\n+            hir_map: &self.tcx.hir,\n+            bound_region: *br,\n+            found_type: None,\n+            depth: 1,\n+        };\n+        nested_visitor.visit_ty(arg);\n+        nested_visitor.found_type\n+    }\n+}\n+\n+// The FindNestedTypeVisitor captures the corresponding `hir::Ty` of the\n+// anonymous region. The example above would lead to a conflict between\n+// the two anonymous lifetimes for &u8 in x and y respectively. This visitor\n+// would be invoked twice, once for each lifetime, and would\n+// walk the types like &mut Vec<&u8> and &u8 looking for the HIR\n+// where that lifetime appears. This allows us to highlight the\n+// specific part of the type in the error message.\n+struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    hir_map: &'a hir::map::Map<'gcx>,\n+    // The bound_region corresponding to the Refree(freeregion)\n+    // associated with the anonymous region we are looking for.\n+    bound_region: ty::BoundRegion,\n+    // The type where the anonymous lifetime appears\n+    // for e.g. Vec<`&u8`> and <`&u8`>\n+    found_type: Option<&'gcx hir::Ty>,\n+    depth: u32,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.hir_map)\n+    }\n+\n+    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n+        match arg.node {\n+            hir::TyBareFn(_) => {\n+                self.depth += 1;\n+                intravisit::walk_ty(self, arg);\n+                self.depth -= 1;\n+                return;\n+            }\n+\n+            hir::TyTraitObject(ref bounds, _) => for bound in bounds {\n+                self.depth += 1;\n+                self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n+                self.depth -= 1;\n+            },\n+\n+            hir::TyRptr(ref lifetime, _) => {\n+                // the lifetime of the TyRptr\n+                let hir_id = self.infcx.tcx.hir.node_to_hir_id(lifetime.id);\n+                match (self.infcx.tcx.named_region(hir_id), self.bound_region) {\n+                    // Find the index of the anonymous region that was part of the\n+                    // error. We will then search the function parameters for a bound\n+                    // region at the right depth with the same index\n+                    (\n+                        Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)),\n+                        ty::BrAnon(br_index),\n+                    ) => {\n+                        debug!(\n+                            \"LateBoundAnon depth = {:?} anon_index = {:?} br_index={:?}\",\n+                            debruijn_index.depth,\n+                            anon_index,\n+                            br_index\n+                        );\n+                        if debruijn_index.depth == self.depth && anon_index == br_index {\n+                            self.found_type = Some(arg);\n+                            return; // we can stop visiting now\n+                        }\n+                    }\n+\n+                    // Find the index of the named region that was part of the\n+                    // error. We will then search the function parameters for a bound\n+                    // region at the right depth with the same index\n+                    (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n+                        debug!(\n+                            \"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n+                             def_id={:?}\",\n+                            id,\n+                            def_id\n+                        );\n+                        if id == def_id {\n+                            self.found_type = Some(arg);\n+                            return; // we can stop visiting now\n+                        }\n+                    }\n+\n+                    // Find the index of the named region that was part of the\n+                    // error. We will then search the function parameters for a bound\n+                    // region at the right depth with the same index\n+                    (\n+                        Some(rl::Region::LateBound(debruijn_index, id, _)),\n+                        ty::BrNamed(def_id, _),\n+                    ) => {\n+                        debug!(\n+                            \"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n+                            debruijn_index.depth\n+                        );\n+                        debug!(\"self.infcx.tcx.hir.local_def_id(id)={:?}\", id);\n+                        debug!(\"def_id={:?}\", def_id);\n+                        if debruijn_index.depth == self.depth && id == def_id {\n+                            self.found_type = Some(arg);\n+                            return; // we can stop visiting now\n+                        }\n+                    }\n+\n+                    (Some(rl::Region::Static), _)\n+                    | (Some(rl::Region::Free(_, _)), _)\n+                    | (Some(rl::Region::EarlyBound(_, _, _)), _)\n+                    | (Some(rl::Region::LateBound(_, _, _)), _)\n+                    | (Some(rl::Region::LateBoundAnon(_, _)), _)\n+                    | (None, _) => {\n+                        debug!(\"no arg found\");\n+                    }\n+                }\n+            }\n+            // Checks if it is of type `hir::TyPath` which corresponds to a struct.\n+            hir::TyPath(_) => {\n+                let subvisitor = &mut TyPathVisitor {\n+                    infcx: self.infcx,\n+                    found_it: false,\n+                    bound_region: self.bound_region,\n+                    hir_map: self.hir_map,\n+                    depth: self.depth,\n+                };\n+                intravisit::walk_ty(subvisitor, arg); // call walk_ty; as visit_ty is empty,\n+                                                      // this will visit only outermost type\n+                if subvisitor.found_it {\n+                    self.found_type = Some(arg);\n+                }\n+            }\n+            _ => {}\n+        }\n+        // walk the embedded contents: e.g., if we are visiting `Vec<&Foo>`,\n+        // go on to visit `&Foo`\n+        intravisit::walk_ty(self, arg);\n+    }\n+}\n+\n+// The visitor captures the corresponding `hir::Ty` of the anonymous region\n+// in the case of structs ie. `hir::TyPath`.\n+// This visitor would be invoked for each lifetime corresponding to a struct,\n+// and would walk the types like Vec<Ref> in the above example and Ref looking for the HIR\n+// where that lifetime appears. This allows us to highlight the\n+// specific part of the type in the error message.\n+struct TyPathVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    hir_map: &'a hir::map::Map<'gcx>,\n+    found_it: bool,\n+    bound_region: ty::BoundRegion,\n+    depth: u32,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.hir_map)\n+    }\n+\n+    fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n+        let hir_id = self.infcx.tcx.hir.node_to_hir_id(lifetime.id);\n+        match (self.infcx.tcx.named_region(hir_id), self.bound_region) {\n+            // the lifetime of the TyPath!\n+            (Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)), ty::BrAnon(br_index)) => {\n+                if debruijn_index.depth == self.depth && anon_index == br_index {\n+                    self.found_it = true;\n+                    return;\n+                }\n+            }\n+\n+            (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n+                debug!(\n+                    \"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n+                     def_id={:?}\",\n+                    id,\n+                    def_id\n+                );\n+                if id == def_id {\n+                    self.found_it = true;\n+                    return; // we can stop visiting now\n+                }\n+            }\n+\n+            (Some(rl::Region::LateBound(debruijn_index, id, _)), ty::BrNamed(def_id, _)) => {\n+                debug!(\n+                    \"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n+                    debruijn_index.depth\n+                );\n+                debug!(\"id={:?}\", id);\n+                debug!(\"def_id={:?}\", def_id);\n+                if debruijn_index.depth == self.depth && id == def_id {\n+                    self.found_it = true;\n+                    return; // we can stop visiting now\n+                }\n+            }\n+\n+            (Some(rl::Region::Static), _)\n+            | (Some(rl::Region::EarlyBound(_, _, _)), _)\n+            | (Some(rl::Region::LateBound(_, _, _)), _)\n+            | (Some(rl::Region::LateBoundAnon(_, _)), _)\n+            | (Some(rl::Region::Free(_, _)), _)\n+            | (None, _) => {\n+                debug!(\"no arg found\");\n+            }\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n+        // ignore nested types\n+        //\n+        // If you have a type like `Foo<'a, &Ty>` we\n+        // are only interested in the immediate lifetimes ('a).\n+        //\n+        // Making `visit_ty` empty will ignore the `&Ty` embedded\n+        // inside, it will get reached by the outer visitor.\n+        debug!(\"`Ty` corresponding to a struct is {:?}\", arg);\n+    }\n+}"}, {"sha": "ca6247defe0124d73638e71cf3f09b8bc0ba34b1", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3720242c75adb3edbe40806fed58cd999e80bef4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3720242c75adb3edbe40806fed58cd999e80bef4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=3720242c75adb3edbe40806fed58cd999e80bef4", "patch": "@@ -10,5 +10,6 @@\n \n #[macro_use] mod util;\n \n+mod find_anon_type;\n mod different_lifetimes;\n mod named_anon_conflict;"}]}