{"sha": "1d3e84c5d63c39de80bb1402816fd8d83966ee74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkM2U4NGM1ZDYzYzM5ZGU4MGJiMTQwMjgxNmZkOGQ4Mzk2NmVlNzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-23T01:01:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-23T01:01:36Z"}, "message": "auto merge of #6669 : yjh0502/rust/fix_6209, r=graydon\n\nFix issue #6209, and some related issues about constant expression\r\n - unmatched type between arms\r\n - unmatched type in range", "tree": {"sha": "e3844581ba8946b9eb806e17885ac9d6ee6c429f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3844581ba8946b9eb806e17885ac9d6ee6c429f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d3e84c5d63c39de80bb1402816fd8d83966ee74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d3e84c5d63c39de80bb1402816fd8d83966ee74", "html_url": "https://github.com/rust-lang/rust/commit/1d3e84c5d63c39de80bb1402816fd8d83966ee74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d3e84c5d63c39de80bb1402816fd8d83966ee74/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f517ed0b08f5a1cc9b65ac0e57dbfaaefcbf002a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f517ed0b08f5a1cc9b65ac0e57dbfaaefcbf002a", "html_url": "https://github.com/rust-lang/rust/commit/f517ed0b08f5a1cc9b65ac0e57dbfaaefcbf002a"}, {"sha": "f8af2b50eee70ea912c18e5acb510789e59dd535", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8af2b50eee70ea912c18e5acb510789e59dd535", "html_url": "https://github.com/rust-lang/rust/commit/f8af2b50eee70ea912c18e5acb510789e59dd535"}], "stats": {"total": 260, "additions": 181, "deletions": 79}, "files": [{"sha": "3717c6134726d9012d0fbac232b10ddf8f84b8e8", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 76, "deletions": 15, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/1d3e84c5d63c39de80bb1402816fd8d83966ee74/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3e84c5d63c39de80bb1402816fd8d83966ee74/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=1d3e84c5d63c39de80bb1402816fd8d83966ee74", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -498,10 +498,27 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             lookup_const_by_id(cx.tcx, did).get();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n                         let match_ = match *ctor_id {\n-                            val(ref v) => compare_const_vals(&e_v, v) == 0,\n+                            val(ref v) => {\n+                                match compare_const_vals(&e_v, v) {\n+                                    Some(val1) => (val1 == 0),\n+                                    None => {\n+                                        cx.tcx.sess.span_err(pat_span,\n+                                            \"mismatched types between arms\");\n+                                        false\n+                                    }\n+                                }\n+                            },\n                             range(ref c_lo, ref c_hi) => {\n-                                compare_const_vals(c_lo, &e_v) >= 0 &&\n-                                    compare_const_vals(c_hi, &e_v) <= 0\n+                                let m1 = compare_const_vals(c_lo, &e_v),\n+                                    m2 = compare_const_vals(c_hi, &e_v);\n+                                match (m1, m2) {\n+                                    (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n+                                    _ => {\n+                                        cx.tcx.sess.span_err(pat_span,\n+                                            \"mismatched types between ranges\");\n+                                        false\n+                                    }\n+                                }\n                             }\n                             single => true,\n                             _ => fail!(\"type error\")\n@@ -529,10 +546,26 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             lookup_const_by_id(cx.tcx, did).get();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n                         let match_ = match *ctor_id {\n-                            val(ref v) => compare_const_vals(&e_v, v) == 0,\n+                            val(ref v) =>\n+                                match compare_const_vals(&e_v, v) {\n+                                    Some(val1) => (val1 == 0),\n+                                    None => {\n+                                        cx.tcx.sess.span_err(pat_span,\n+                                            \"mismatched types between arms\");\n+                                        false\n+                                    }\n+                                },\n                             range(ref c_lo, ref c_hi) => {\n-                                compare_const_vals(c_lo, &e_v) >= 0 &&\n-                                    compare_const_vals(c_hi, &e_v) <= 0\n+                                let m1 = compare_const_vals(c_lo, &e_v),\n+                                    m2 = compare_const_vals(c_hi, &e_v);\n+                                match (m1, m2) {\n+                                    (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n+                                    _ => {\n+                                        cx.tcx.sess.span_err(pat_span,\n+                                            \"mismatched types between ranges\");\n+                                        false\n+                                    }\n+                                }\n                             }\n                             single => true,\n                             _ => fail!(\"type error\")\n@@ -619,10 +652,27 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             pat_lit(expr) => {\n                 let e_v = eval_const_expr(cx.tcx, expr);\n                 let match_ = match *ctor_id {\n-                    val(ref v) => compare_const_vals(&e_v, v) == 0,\n+                    val(ref v) => {\n+                        match compare_const_vals(&e_v, v) {\n+                            Some(val1) => val1 == 0,\n+                            None => {\n+                                cx.tcx.sess.span_err(pat_span,\n+                                    \"mismatched types between arms\");\n+                                false\n+                            }\n+                        }\n+                    },\n                     range(ref c_lo, ref c_hi) => {\n-                        compare_const_vals(c_lo, &e_v) >= 0 &&\n-                            compare_const_vals(c_hi, &e_v) <= 0\n+                        let m1 = compare_const_vals(c_lo, &e_v),\n+                            m2 = compare_const_vals(c_hi, &e_v);\n+                        match (m1, m2) {\n+                            (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n+                            _ => {\n+                                cx.tcx.sess.span_err(pat_span,\n+                                    \"mismatched types between ranges\");\n+                                false\n+                            }\n+                        }\n                     }\n                     single => true,\n                     _ => fail!(\"type error\")\n@@ -638,11 +688,22 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                     _ => fail!(\"type error\")\n                 };\n                 let v_lo = eval_const_expr(cx.tcx, lo),\n-                v_hi = eval_const_expr(cx.tcx, hi);\n-                let match_ = compare_const_vals(&c_lo, &v_lo) >= 0 &&\n-                    compare_const_vals(&c_hi, &v_hi) <= 0;\n-          if match_ { Some(vec::to_owned(r.tail())) } else { None }\n-      }\n+                    v_hi = eval_const_expr(cx.tcx, hi);\n+\n+                let m1 = compare_const_vals(&c_lo, &v_lo),\n+                    m2 = compare_const_vals(&c_hi, &v_hi);\n+                match (m1, m2) {\n+                    (Some(val1), Some(val2)) if val1 >= 0 && val2 <= 0 => {\n+                        Some(vec::to_owned(r.tail()))\n+                    },\n+                    (Some(_), Some(_)) => None,\n+                    _ => {\n+                        cx.tcx.sess.span_err(pat_span,\n+                            \"mismatched types between ranges\");\n+                        None\n+                    }\n+                }\n+            }\n             pat_vec(before, slice, after) => {\n                 match *ctor_id {\n                     vec(_) => {"}, {"sha": "751767fb58c14eadfc940d49f728d3181c0a80ad", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1d3e84c5d63c39de80bb1402816fd8d83966ee74/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3e84c5d63c39de80bb1402816fd8d83966ee74/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=1d3e84c5d63c39de80bb1402816fd8d83966ee74", "patch": "@@ -420,65 +420,73 @@ pub fn lit_to_const(lit: @lit) -> const_val {\n     }\n }\n \n-pub fn compare_const_vals(a: &const_val, b: &const_val) -> int {\n+pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n   match (a, b) {\n     (&const_int(a), &const_int(b)) => {\n         if a == b {\n-            0\n+            Some(0)\n         } else if a < b {\n-            -1\n+            Some(-1)\n         } else {\n-            1\n+            Some(1)\n         }\n     }\n     (&const_uint(a), &const_uint(b)) => {\n         if a == b {\n-            0\n+            Some(0)\n         } else if a < b {\n-            -1\n+            Some(-1)\n         } else {\n-            1\n+            Some(1)\n         }\n     }\n     (&const_float(a), &const_float(b)) => {\n         if a == b {\n-            0\n+            Some(0)\n         } else if a < b {\n-            -1\n+            Some(-1)\n         } else {\n-            1\n+            Some(1)\n         }\n     }\n     (&const_str(ref a), &const_str(ref b)) => {\n         if (*a) == (*b) {\n-            0\n+            Some(0)\n         } else if (*a) < (*b) {\n-            -1\n+            Some(-1)\n         } else {\n-            1\n+            Some(1)\n         }\n     }\n     (&const_bool(a), &const_bool(b)) => {\n         if a == b {\n-            0\n+            Some(0)\n         } else if a < b {\n-            -1\n+            Some(-1)\n         } else {\n-            1\n+            Some(1)\n         }\n     }\n-    _ => fail!(\"compare_const_vals: ill-typed comparison\")\n+    _ => {\n+        None\n+    }\n   }\n }\n \n-pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> int {\n-  compare_const_vals(&eval_const_expr(tcx, a), &eval_const_expr(tcx, b))\n+pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> Option<int> {\n+    compare_const_vals(&eval_const_expr(tcx, a), &eval_const_expr(tcx, b))\n }\n \n-pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> bool {\n-    compare_lit_exprs(tcx, a, b) == 0\n+pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> Option<bool> {\n+    match compare_lit_exprs(tcx, a, b) {\n+        Some(val) => Some(val == 0),\n+        None =>  None,\n+    }\n }\n \n-pub fn lit_eq(a: @lit, b: @lit) -> bool {\n-    compare_const_vals(&lit_to_const(a), &lit_to_const(b)) == 0\n+pub fn lit_eq(a: @lit, b: @lit) -> Option<bool> {\n+    match compare_const_vals(&lit_to_const(a), &lit_to_const(b)) {\n+        Some(val) => Some(val == 0),\n+        None =>  None,\n+    }\n }"}, {"sha": "c7f2da923296163146dbbe422238940e807aac2f", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/1d3e84c5d63c39de80bb1402816fd8d83966ee74/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3e84c5d63c39de80bb1402816fd8d83966ee74/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=1d3e84c5d63c39de80bb1402816fd8d83966ee74", "patch": "@@ -193,48 +193,55 @@ pub enum Opt {\n \n pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     match (a, b) {\n-      (&lit(a), &lit(b)) => {\n-        match (a, b) {\n-            (UnitLikeStructLit(a), UnitLikeStructLit(b)) => a == b,\n-            _ => {\n-                let a_expr;\n-                match a {\n-                    ExprLit(existing_a_expr) => a_expr = existing_a_expr,\n-                    ConstLit(a_const) => {\n-                        let e = const_eval::lookup_const_by_id(tcx, a_const);\n-                        a_expr = e.get();\n-                    }\n-                    UnitLikeStructLit(_) => {\n-                        fail!(\"UnitLikeStructLit should have been handled \\\n-                               above\")\n+        (&lit(a), &lit(b)) => {\n+            match (a, b) {\n+                (UnitLikeStructLit(a), UnitLikeStructLit(b)) => a == b,\n+                _ => {\n+                    let a_expr;\n+                    match a {\n+                        ExprLit(existing_a_expr) => a_expr = existing_a_expr,\n+                            ConstLit(a_const) => {\n+                                let e = const_eval::lookup_const_by_id(tcx, a_const);\n+                                a_expr = e.get();\n+                            }\n+                        UnitLikeStructLit(_) => {\n+                            fail!(\"UnitLikeStructLit should have been handled \\\n+                                    above\")\n+                        }\n                     }\n-                }\n \n-                let b_expr;\n-                match b {\n-                    ExprLit(existing_b_expr) => b_expr = existing_b_expr,\n-                    ConstLit(b_const) => {\n-                        let e = const_eval::lookup_const_by_id(tcx, b_const);\n-                        b_expr = e.get();\n+                    let b_expr;\n+                    match b {\n+                        ExprLit(existing_b_expr) => b_expr = existing_b_expr,\n+                            ConstLit(b_const) => {\n+                                let e = const_eval::lookup_const_by_id(tcx, b_const);\n+                                b_expr = e.get();\n+                            }\n+                        UnitLikeStructLit(_) => {\n+                            fail!(\"UnitLikeStructLit should have been handled \\\n+                                    above\")\n+                        }\n                     }\n-                    UnitLikeStructLit(_) => {\n-                        fail!(\"UnitLikeStructLit should have been handled \\\n-                               above\")\n+\n+                    match const_eval::compare_lit_exprs(tcx, a_expr, b_expr) {\n+                        Some(val1) => val1 == 0,\n+                        None => fail!(\"compare_list_exprs: type mismatch\"),\n                     }\n                 }\n-\n-                const_eval::compare_lit_exprs(tcx, a_expr, b_expr) == 0\n             }\n         }\n-      }\n-      (&range(a1, a2), &range(b1, b2)) => {\n-        const_eval::compare_lit_exprs(tcx, a1, b1) == 0 &&\n-        const_eval::compare_lit_exprs(tcx, a2, b2) == 0\n-      }\n-      (&var(a, _), &var(b, _)) => a == b,\n-      (&vec_len_eq(a), &vec_len_eq(b)) => a == b,\n-      (&vec_len_ge(a, _), &vec_len_ge(b, _)) => a == b,\n-      _ => false\n+        (&range(a1, a2), &range(b1, b2)) => {\n+            let m1 = const_eval::compare_lit_exprs(tcx, a1, b1);\n+            let m2 = const_eval::compare_lit_exprs(tcx, a2, b2);\n+            match (m1, m2) {\n+                (Some(val1), Some(val2)) => (val1 == 0 && val2 == 0),\n+                _ => fail!(\"compare_list_exprs: type mismatch\"),\n+            }\n+        }\n+        (&var(a, _), &var(b, _)) => a == b,\n+            (&vec_len_eq(a), &vec_len_eq(b)) => a == b,\n+            (&vec_len_ge(a, _), &vec_len_ge(b, _)) => a == b,\n+            _ => false\n     }\n }\n "}, {"sha": "d6ef27ab7ff0cb7c31866f8b5eb35f79475a843b", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1d3e84c5d63c39de80bb1402816fd8d83966ee74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3e84c5d63c39de80bb1402816fd8d83966ee74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=1d3e84c5d63c39de80bb1402816fd8d83966ee74", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -408,8 +408,18 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             // no-op\n         } else if !ty::type_is_numeric(b_ty) {\n             tcx.sess.span_err(pat.span, \"non-numeric type used in range\");\n-        } else if !valid_range_bounds(fcx.ccx, begin, end) {\n-            tcx.sess.span_err(begin.span, \"lower range bound must be less than upper\");\n+        } else {\n+            match valid_range_bounds(fcx.ccx, begin, end) {\n+                Some(false) => {\n+                    tcx.sess.span_err(begin.span,\n+                        \"lower range bound must be less than upper\");\n+                },\n+                None => {\n+                    tcx.sess.span_err(begin.span,\n+                        \"mismatched types in range\");\n+                },\n+                _ => { },\n+            }\n         }\n         fcx.write_ty(pat.id, b_ty);\n       }"}, {"sha": "cd58dc5fe48df2862d3eb72a15349ccb1e782a2f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1d3e84c5d63c39de80bb1402816fd8d83966ee74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3e84c5d63c39de80bb1402816fd8d83966ee74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=1d3e84c5d63c39de80bb1402816fd8d83966ee74", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -1044,8 +1044,11 @@ pub fn check_lit(fcx: @mut FnCtxt, lit: @ast::lit) -> ty::t {\n pub fn valid_range_bounds(ccx: @mut CrateCtxt,\n                           from: @ast::expr,\n                           to: @ast::expr)\n-                       -> bool {\n-    const_eval::compare_lit_exprs(ccx.tcx, from, to) <= 0\n+                       -> Option<bool> {\n+    match const_eval::compare_lit_exprs(ccx.tcx, from, to) {\n+        Some(val) => Some(val <= 0),\n+        None => None\n+    }\n }\n \n pub fn check_expr_has_type("}, {"sha": "4d2b95b61ea8d09b3438cd77feaeb9219c1892e5", "filename": "src/test/compile-fail/match-ill-type1.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d3e84c5d63c39de80bb1402816fd8d83966ee74/src%2Ftest%2Fcompile-fail%2Fmatch-ill-type1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3e84c5d63c39de80bb1402816fd8d83966ee74/src%2Ftest%2Fcompile-fail%2Fmatch-ill-type1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-ill-type1.rs?ref=1d3e84c5d63c39de80bb1402816fd8d83966ee74", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    match 1 {\n+        1..2u => 1, //~ ERROR mismatched types in range\n+        _ => 2,\n+    };\n+}"}, {"sha": "020ccde845246bc7b5b7b972cf2363e3eed46729", "filename": "src/test/compile-fail/match-ill-type2.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1d3e84c5d63c39de80bb1402816fd8d83966ee74/src%2Ftest%2Fcompile-fail%2Fmatch-ill-type2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3e84c5d63c39de80bb1402816fd8d83966ee74/src%2Ftest%2Fcompile-fail%2Fmatch-ill-type2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-ill-type2.rs?ref=1d3e84c5d63c39de80bb1402816fd8d83966ee74", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    match 1 {\n+        1 => 1, //~ ERROR mismatched types between arms\n+        2u => 1,\n+        _ => 2,\n+    };\n+}"}]}