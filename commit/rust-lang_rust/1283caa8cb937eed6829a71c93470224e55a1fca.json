{"sha": "1283caa8cb937eed6829a71c93470224e55a1fca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyODNjYWE4Y2I5MzdlZWQ2ODI5YTcxYzkzNDcwMjI0ZTU1YTFmY2E=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-04-12T12:44:31Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-04-12T12:51:11Z"}, "message": "std: migrate path::windows to using StrBuf internally.\n\nSame representation change performed with path::unix.\n\nThis also implements BytesContainer for StrBuf & adds an (unsafe) method\nfor viewing & mutating the raw byte vector of a StrBuf.", "tree": {"sha": "0cc632a2731a1ab3117feebe9d3243784b06cd78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cc632a2731a1ab3117feebe9d3243784b06cd78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1283caa8cb937eed6829a71c93470224e55a1fca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1283caa8cb937eed6829a71c93470224e55a1fca", "html_url": "https://github.com/rust-lang/rust/commit/1283caa8cb937eed6829a71c93470224e55a1fca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1283caa8cb937eed6829a71c93470224e55a1fca/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28e3340a078bfb53fd621900fb17d42d6e718526", "url": "https://api.github.com/repos/rust-lang/rust/commits/28e3340a078bfb53fd621900fb17d42d6e718526", "html_url": "https://github.com/rust-lang/rust/commit/28e3340a078bfb53fd621900fb17d42d6e718526"}], "stats": {"total": 161, "additions": 97, "deletions": 64}, "files": [{"sha": "88be22901a4489da25e4a687529c20eb8d937d98", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1283caa8cb937eed6829a71c93470224e55a1fca/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1283caa8cb937eed6829a71c93470224e55a1fca/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=1283caa8cb937eed6829a71c93470224e55a1fca", "patch": "@@ -71,6 +71,7 @@ use iter::Iterator;\n use option::{Option, None, Some};\n use str;\n use str::{MaybeOwned, Str, StrSlice, from_utf8_lossy};\n+use strbuf::StrBuf;\n use slice::{OwnedCloneableVector, OwnedVector, Vector};\n use slice::{ImmutableEqVector, ImmutableVector};\n use vec::Vec;\n@@ -528,6 +529,22 @@ impl BytesContainer for ~str {\n     #[inline]\n     fn is_str(_: Option<~str>) -> bool { true }\n }\n+impl BytesContainer for StrBuf {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.as_bytes()\n+    }\n+    #[inline]\n+    fn container_into_owned_bytes(self) -> Vec<u8> {\n+        self.into_bytes()\n+    }\n+    #[inline]\n+    fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n+        Some(self.as_slice())\n+    }\n+    #[inline]\n+    fn is_str(_: Option<StrBuf>) -> bool { true }\n+}\n \n impl<'a> BytesContainer for &'a [u8] {\n     #[inline]"}, {"sha": "739e13ea4ed10f55fec51756a3286002b180b049", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 70, "deletions": 64, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/1283caa8cb937eed6829a71c93470224e55a1fca/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1283caa8cb937eed6829a71c93470224e55a1fca/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=1283caa8cb937eed6829a71c93470224e55a1fca", "patch": "@@ -22,7 +22,6 @@ use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Rev, Iterator, Map\n use option::{Option, Some, None};\n use slice::{Vector, OwnedVector, ImmutableVector};\n use str::{CharSplits, OwnedStr, Str, StrVector, StrSlice};\n-use str;\n use strbuf::StrBuf;\n use vec::Vec;\n \n@@ -84,7 +83,7 @@ pub type RevComponents<'a> = Map<'a, Option<&'a str>, &'a [u8],\n // preserved by the data structure; let the Windows API error out on them.\n #[deriving(Clone)]\n pub struct Path {\n-    repr: ~str, // assumed to never be empty\n+    repr: StrBuf, // assumed to never be empty\n     prefix: Option<PathPrefix>,\n     sepidx: Option<uint> // index of the final separator in the non-prefix portion of repr\n }\n@@ -177,7 +176,7 @@ impl GenericPathUnsafe for Path {\n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n         let filename = filename.container_as_str().unwrap();\n         match self.sepidx_or_prefix_len() {\n-            None if \"..\" == self.repr => {\n+            None if \"..\" == self.repr.as_slice() => {\n                 let mut s = StrBuf::with_capacity(3 + filename.len());\n                 s.push_str(\"..\");\n                 s.push_char(SEP);\n@@ -187,22 +186,22 @@ impl GenericPathUnsafe for Path {\n             None => {\n                 self.update_normalized(filename);\n             }\n-            Some((_,idxa,end)) if self.repr.slice(idxa,end) == \"..\" => {\n+            Some((_,idxa,end)) if self.repr.as_slice().slice(idxa,end) == \"..\" => {\n                 let mut s = StrBuf::with_capacity(end + 1 + filename.len());\n-                s.push_str(self.repr.slice_to(end));\n+                s.push_str(self.repr.as_slice().slice_to(end));\n                 s.push_char(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n             Some((idxb,idxa,_)) if self.prefix == Some(DiskPrefix) && idxa == self.prefix_len() => {\n                 let mut s = StrBuf::with_capacity(idxb + filename.len());\n-                s.push_str(self.repr.slice_to(idxb));\n+                s.push_str(self.repr.as_slice().slice_to(idxb));\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n             Some((idxb,_,_)) => {\n                 let mut s = StrBuf::with_capacity(idxb + 1 + filename.len());\n-                s.push_str(self.repr.slice_to(idxb));\n+                s.push_str(self.repr.as_slice().slice_to(idxb));\n                 s.push_char(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n@@ -229,9 +228,10 @@ impl GenericPathUnsafe for Path {\n         }\n         fn shares_volume(me: &Path, path: &str) -> bool {\n             // path is assumed to have a prefix of Some(DiskPrefix)\n+            let repr = me.repr.as_slice();\n             match me.prefix {\n-                Some(DiskPrefix) => me.repr[0] == path[0].to_ascii().to_upper().to_byte(),\n-                Some(VerbatimDiskPrefix) => me.repr[4] == path[0].to_ascii().to_upper().to_byte(),\n+                Some(DiskPrefix) => repr[0] == path[0].to_ascii().to_upper().to_byte(),\n+                Some(VerbatimDiskPrefix) => repr[4] == path[0].to_ascii().to_upper().to_byte(),\n                 _ => false\n             }\n         }\n@@ -244,7 +244,7 @@ impl GenericPathUnsafe for Path {\n             let newpath = Path::normalize__(path, prefix);\n             me.repr = match newpath {\n                 Some(p) => p,\n-                None => path.to_owned()\n+                None => StrBuf::from_str(path)\n             };\n             me.prefix = prefix;\n             me.update_sepidx();\n@@ -256,19 +256,19 @@ impl GenericPathUnsafe for Path {\n                         else { None };\n             let pathlen = path_.as_ref().map_or(path.len(), |p| p.len());\n             let mut s = StrBuf::with_capacity(me.repr.len() + 1 + pathlen);\n-            s.push_str(me.repr);\n+            s.push_str(me.repr.as_slice());\n             let plen = me.prefix_len();\n             // if me is \"C:\" we don't want to add a path separator\n             match me.prefix {\n                 Some(DiskPrefix) if me.repr.len() == plen => (),\n-                _ if !(me.repr.len() > plen && me.repr[me.repr.len()-1] == SEP_BYTE) => {\n+                _ if !(me.repr.len() > plen && me.repr.as_slice()[me.repr.len()-1] == SEP_BYTE) => {\n                     s.push_char(SEP);\n                 }\n                 _ => ()\n             }\n             match path_ {\n                 None => s.push_str(path),\n-                Some(p) => s.push_str(p)\n+                Some(p) => s.push_str(p.as_slice())\n             };\n             me.update_normalized(s)\n         }\n@@ -346,21 +346,21 @@ impl GenericPath for Path {\n     /// Always returns a `Some` value.\n     fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n         Some(match self.sepidx_or_prefix_len() {\n-            None if \"..\" == self.repr => self.repr.as_slice(),\n+            None if \"..\" == self.repr.as_slice() => self.repr.as_slice(),\n             None => \".\",\n-            Some((_,idxa,end)) if self.repr.slice(idxa, end) == \"..\" => {\n+            Some((_,idxa,end)) if self.repr.as_slice().slice(idxa, end) == \"..\" => {\n                 self.repr.as_slice()\n             }\n-            Some((idxb,_,end)) if self.repr.slice(idxb, end) == \"\\\\\" => {\n+            Some((idxb,_,end)) if self.repr.as_slice().slice(idxb, end) == \"\\\\\" => {\n                 self.repr.as_slice()\n             }\n-            Some((0,idxa,_)) => self.repr.slice_to(idxa),\n+            Some((0,idxa,_)) => self.repr.as_slice().slice_to(idxa),\n             Some((idxb,idxa,_)) => {\n                 match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) if idxb == self.prefix_len() => {\n-                        self.repr.slice_to(idxa)\n+                        self.repr.as_slice().slice_to(idxa)\n                     }\n-                    _ => self.repr.slice_to(idxb)\n+                    _ => self.repr.as_slice().slice_to(idxb)\n                 }\n             }\n         })\n@@ -374,12 +374,13 @@ impl GenericPath for Path {\n     /// See `GenericPath::filename_str` for info.\n     /// Always returns a `Some` value if `filename` returns a `Some` value.\n     fn filename_str<'a>(&'a self) -> Option<&'a str> {\n+        let repr = self.repr.as_slice();\n         match self.sepidx_or_prefix_len() {\n-            None if \".\" == self.repr || \"..\" == self.repr => None,\n-            None => Some(self.repr.as_slice()),\n-            Some((_,idxa,end)) if self.repr.slice(idxa, end) == \"..\" => None,\n+            None if \".\" == repr || \"..\" == repr => None,\n+            None => Some(repr),\n+            Some((_,idxa,end)) if repr.slice(idxa, end) == \"..\" => None,\n             Some((_,idxa,end)) if idxa == end => None,\n-            Some((_,idxa,end)) => Some(self.repr.slice(idxa, end))\n+            Some((_,idxa,end)) => Some(repr.slice(idxa, end))\n         }\n     }\n \n@@ -404,14 +405,14 @@ impl GenericPath for Path {\n     #[inline]\n     fn pop(&mut self) -> bool {\n         match self.sepidx_or_prefix_len() {\n-            None if \".\" == self.repr => false,\n+            None if \".\" == self.repr.as_slice() => false,\n             None => {\n-                self.repr = ~\".\";\n+                self.repr = StrBuf::from_str(\".\");\n                 self.sepidx = None;\n                 true\n             }\n             Some((idxb,idxa,end)) if idxb == idxa && idxb == end => false,\n-            Some((idxb,_,end)) if self.repr.slice(idxb, end) == \"\\\\\" => false,\n+            Some((idxb,_,end)) if self.repr.as_slice().slice(idxb, end) == \"\\\\\" => false,\n             Some((idxb,idxa,_)) => {\n                 let trunc = match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) | None => {\n@@ -431,15 +432,15 @@ impl GenericPath for Path {\n         if self.prefix.is_some() {\n             Some(Path::new(match self.prefix {\n                 Some(DiskPrefix) if self.is_absolute() => {\n-                    self.repr.slice_to(self.prefix_len()+1)\n+                    self.repr.as_slice().slice_to(self.prefix_len()+1)\n                 }\n                 Some(VerbatimDiskPrefix) => {\n-                    self.repr.slice_to(self.prefix_len()+1)\n+                    self.repr.as_slice().slice_to(self.prefix_len()+1)\n                 }\n-                _ => self.repr.slice_to(self.prefix_len())\n+                _ => self.repr.as_slice().slice_to(self.prefix_len())\n             }))\n         } else if is_vol_relative(self) {\n-            Some(Path::new(self.repr.slice_to(1)))\n+            Some(Path::new(self.repr.as_slice().slice_to(1)))\n         } else {\n             None\n         }\n@@ -458,7 +459,7 @@ impl GenericPath for Path {\n     fn is_absolute(&self) -> bool {\n         match self.prefix {\n             Some(DiskPrefix) => {\n-                let rest = self.repr.slice_from(self.prefix_len());\n+                let rest = self.repr.as_slice().slice_from(self.prefix_len());\n                 rest.len() > 0 && rest[0] == SEP_BYTE\n             }\n             Some(_) => true,\n@@ -480,7 +481,7 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.str_components().map(|x|x.unwrap());\n             let mut itb = other.str_components().map(|x|x.unwrap());\n-            if \".\" == self.repr {\n+            if \".\" == self.repr.as_slice() {\n                 return itb.next() != Some(\"..\");\n             }\n             loop {\n@@ -615,15 +616,16 @@ impl Path {\n     /// Does not distinguish between absolute and cwd-relative paths, e.g.\n     /// C:\\foo and C:foo.\n     pub fn str_components<'a>(&'a self) -> StrComponents<'a> {\n+        let repr = self.repr.as_slice();\n         let s = match self.prefix {\n             Some(_) => {\n                 let plen = self.prefix_len();\n-                if self.repr.len() > plen && self.repr[plen] == SEP_BYTE {\n-                    self.repr.slice_from(plen+1)\n-                } else { self.repr.slice_from(plen) }\n+                if repr.len() > plen && repr[plen] == SEP_BYTE {\n+                    repr.slice_from(plen+1)\n+                } else { repr.slice_from(plen) }\n             }\n-            None if self.repr[0] == SEP_BYTE => self.repr.slice_from(1),\n-            None => self.repr.as_slice()\n+            None if repr[0] == SEP_BYTE => repr.slice_from(1),\n+            None => repr\n         };\n         let ret = s.split_terminator(SEP).map(Some);\n         ret\n@@ -656,54 +658,56 @@ impl Path {\n     }\n \n     fn equiv_prefix(&self, other: &Path) -> bool {\n+        let s_repr = self.repr.as_slice();\n+        let o_repr = other.repr.as_slice();\n         match (self.prefix, other.prefix) {\n             (Some(DiskPrefix), Some(VerbatimDiskPrefix)) => {\n                 self.is_absolute() &&\n-                    self.repr[0].to_ascii().eq_ignore_case(other.repr[4].to_ascii())\n+                    s_repr[0].to_ascii().eq_ignore_case(o_repr[4].to_ascii())\n             }\n             (Some(VerbatimDiskPrefix), Some(DiskPrefix)) => {\n                 other.is_absolute() &&\n-                    self.repr[4].to_ascii().eq_ignore_case(other.repr[0].to_ascii())\n+                    s_repr[4].to_ascii().eq_ignore_case(o_repr[0].to_ascii())\n             }\n             (Some(VerbatimDiskPrefix), Some(VerbatimDiskPrefix)) => {\n-                self.repr[4].to_ascii().eq_ignore_case(other.repr[4].to_ascii())\n+                s_repr[4].to_ascii().eq_ignore_case(o_repr[4].to_ascii())\n             }\n             (Some(UNCPrefix(_,_)), Some(VerbatimUNCPrefix(_,_))) => {\n-                self.repr.slice(2, self.prefix_len()) == other.repr.slice(8, other.prefix_len())\n+                s_repr.slice(2, self.prefix_len()) == o_repr.slice(8, other.prefix_len())\n             }\n             (Some(VerbatimUNCPrefix(_,_)), Some(UNCPrefix(_,_))) => {\n-                self.repr.slice(8, self.prefix_len()) == other.repr.slice(2, other.prefix_len())\n+                s_repr.slice(8, self.prefix_len()) == o_repr.slice(2, other.prefix_len())\n             }\n             (None, None) => true,\n             (a, b) if a == b => {\n-                self.repr.slice_to(self.prefix_len()) == other.repr.slice_to(other.prefix_len())\n+                s_repr.slice_to(self.prefix_len()) == o_repr.slice_to(other.prefix_len())\n             }\n             _ => false\n         }\n     }\n \n-    fn normalize_<S: Str>(s: S) -> (Option<PathPrefix>, ~str) {\n+    fn normalize_<S: Str>(s: S) -> (Option<PathPrefix>, StrBuf) {\n         // make borrowck happy\n         let (prefix, val) = {\n             let prefix = parse_prefix(s.as_slice());\n             let path = Path::normalize__(s.as_slice(), prefix);\n             (prefix, path)\n         };\n         (prefix, match val {\n-            None => s.into_owned(),\n+            None => s.into_strbuf(),\n             Some(val) => val\n         })\n     }\n \n-    fn normalize__(s: &str, prefix: Option<PathPrefix>) -> Option<~str> {\n+    fn normalize__(s: &str, prefix: Option<PathPrefix>) -> Option<StrBuf> {\n         if prefix_is_verbatim(prefix) {\n             // don't do any normalization\n             match prefix {\n                 Some(VerbatimUNCPrefix(x, 0)) if s.len() == 8 + x => {\n                     // the server component has no trailing '\\'\n-                    let mut s = StrBuf::from_owned_str(s.into_owned());\n+                    let mut s = StrBuf::from_str(s);\n                     s.push_char(SEP);\n-                    Some(s.into_owned())\n+                    Some(s)\n                 }\n                 _ => None\n             }\n@@ -730,37 +734,37 @@ impl Path {\n                         match prefix.unwrap() {\n                             DiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n-                                let mut s = s.slice_to(len).to_owned();\n+                                let mut s = StrBuf::from_str(s.slice_to(len));\n                                 unsafe {\n-                                    str::raw::as_owned_vec(&mut s)[0] =\n-                                        s[0].to_ascii().to_upper().to_byte();\n+                                    let v = s.as_mut_vec();\n+                                    *v.get_mut(0) = v.get(0).to_ascii().to_upper().to_byte();\n                                 }\n                                 if is_abs {\n                                     // normalize C:/ to C:\\\n                                     unsafe {\n-                                        str::raw::as_owned_vec(&mut s)[2] = SEP_BYTE;\n+                                        *s.as_mut_vec().get_mut(2) = SEP_BYTE;\n                                     }\n                                 }\n                                 Some(s)\n                             }\n                             VerbatimDiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n-                                let mut s = s.slice_to(len).to_owned();\n+                                let mut s = StrBuf::from_str(s.slice_to(len));\n                                 unsafe {\n-                                    str::raw::as_owned_vec(&mut s)[4] =\n-                                        s[4].to_ascii().to_upper().to_byte();\n+                                    let v = s.as_mut_vec();\n+                                    *v.get_mut(4) = v.get(4).to_ascii().to_upper().to_byte();\n                                 }\n                                 Some(s)\n                             }\n                             _ => {\n                                 let plen = prefix_len(prefix);\n                                 if s.len() > plen {\n-                                    Some(s.slice_to(plen).to_owned())\n+                                    Some(StrBuf::from_str(s.slice_to(plen)))\n                                 } else { None }\n                             }\n                         }\n                     } else if is_abs && comps.is_empty() {\n-                        Some(str::from_char(SEP))\n+                        Some(StrBuf::from_char(1, SEP))\n                     } else {\n                         let prefix_ = s.slice_to(prefix_len(prefix));\n                         let n = prefix_.len() +\n@@ -797,7 +801,7 @@ impl Path {\n                             s.push_char(SEP);\n                             s.push_str(comp);\n                         }\n-                        Some(s.into_owned())\n+                        Some(s)\n                     }\n                 }\n             }\n@@ -806,7 +810,7 @@ impl Path {\n \n     fn update_sepidx(&mut self) {\n         let s = if self.has_nonsemantic_trailing_slash() {\n-                    self.repr.slice_to(self.repr.len()-1)\n+                    self.repr.as_slice().slice_to(self.repr.len()-1)\n                 } else { self.repr.as_slice() };\n         let idx = s.rfind(if !prefix_is_verbatim(self.prefix) { is_sep }\n                           else { is_sep_verbatim });\n@@ -836,7 +840,7 @@ impl Path {\n \n     fn has_nonsemantic_trailing_slash(&self) -> bool {\n         is_verbatim(self) && self.repr.len() > self.prefix_len()+1 &&\n-            self.repr[self.repr.len()-1] == SEP_BYTE\n+            self.repr.as_slice()[self.repr.len()-1] == SEP_BYTE\n     }\n \n     fn update_normalized<S: Str>(&mut self, s: S) {\n@@ -852,7 +856,7 @@ impl Path {\n /// but absolute within that volume.\n #[inline]\n pub fn is_vol_relative(path: &Path) -> bool {\n-    path.prefix.is_none() && is_sep_byte(&path.repr[0])\n+    path.prefix.is_none() && is_sep_byte(&path.repr.as_slice()[0])\n }\n \n /// Returns whether the path is considered \"cwd-relative\", which means a path\n@@ -882,16 +886,17 @@ pub fn is_verbatim(path: &Path) -> bool {\n /// non-verbatim, the non-verbatim version is returned.\n /// Otherwise, None is returned.\n pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n+    let repr = path.repr.as_slice();\n     let new_path = match path.prefix {\n         Some(VerbatimPrefix(_)) | Some(DeviceNSPrefix(_)) => return None,\n         Some(UNCPrefix(_,_)) | Some(DiskPrefix) | None => return Some(path.clone()),\n         Some(VerbatimDiskPrefix) => {\n             // \\\\?\\D:\\\n-            Path::new(path.repr.slice_from(4))\n+            Path::new(repr.slice_from(4))\n         }\n         Some(VerbatimUNCPrefix(_,_)) => {\n             // \\\\?\\UNC\\server\\share\n-            Path::new(format!(r\"\\\\{}\", path.repr.slice_from(7)))\n+            Path::new(format!(r\"\\\\{}\", repr.slice_from(7)))\n         }\n     };\n     if new_path.prefix.is_none() {\n@@ -900,7 +905,8 @@ pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n         return None;\n     }\n     // now ensure normalization didn't change anything\n-    if path.repr.slice_from(path.prefix_len()) == new_path.repr.slice_from(new_path.prefix_len()) {\n+    if repr.slice_from(path.prefix_len()) ==\n+        new_path.repr.as_slice().slice_from(new_path.prefix_len()) {\n         Some(new_path)\n     } else {\n         None"}, {"sha": "873b7293032cf86ad3be42a2579fffe7dd6af054", "filename": "src/libstd/strbuf.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1283caa8cb937eed6829a71c93470224e55a1fca/src%2Flibstd%2Fstrbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1283caa8cb937eed6829a71c93470224e55a1fca/src%2Flibstd%2Fstrbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstrbuf.rs?ref=1283caa8cb937eed6829a71c93470224e55a1fca", "patch": "@@ -229,6 +229,13 @@ impl StrBuf {\n         *self = self.as_slice().slice(1, len).into_strbuf();\n         Some(byte)\n     }\n+\n+    /// Views the string buffer as a mutable sequence of bytes.\n+    ///\n+    /// Callers must preserve the valid UTF-8 property.\n+    pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> {\n+        &mut self.vec\n+    }\n }\n \n impl Container for StrBuf {\n@@ -271,6 +278,9 @@ impl Str for StrBuf {\n             cast::transmute::<~[u8],~str>(vec.move_iter().collect())\n         }\n     }\n+\n+    #[inline]\n+    fn into_strbuf(self) -> StrBuf { self }\n }\n \n impl fmt::Show for StrBuf {"}]}