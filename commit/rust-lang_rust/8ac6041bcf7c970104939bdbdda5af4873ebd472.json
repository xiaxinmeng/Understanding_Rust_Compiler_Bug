{"sha": "8ac6041bcf7c970104939bdbdda5af4873ebd472", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYzYwNDFiY2Y3Yzk3MDEwNDkzOWJkYmRkYTVhZjQ4NzNlYmQ0NzI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-02-13T16:57:14Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-02-13T16:57:14Z"}, "message": "Only use HIR when searching for enum constructors, otherwise fall back to AST", "tree": {"sha": "eb10eb5cac1c2c269e708144a96251336ff42e2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb10eb5cac1c2c269e708144a96251336ff42e2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ac6041bcf7c970104939bdbdda5af4873ebd472", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ac6041bcf7c970104939bdbdda5af4873ebd472", "html_url": "https://github.com/rust-lang/rust/commit/8ac6041bcf7c970104939bdbdda5af4873ebd472", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ac6041bcf7c970104939bdbdda5af4873ebd472/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c395dd1032b66e28995189a26ed688b243d3cef8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c395dd1032b66e28995189a26ed688b243d3cef8", "html_url": "https://github.com/rust-lang/rust/commit/c395dd1032b66e28995189a26ed688b243d3cef8"}], "stats": {"total": 82, "additions": 34, "deletions": 48}, "files": [{"sha": "55a44ff01c757cbde5e0a2928fedb89846dfce61", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 34, "deletions": 48, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8ac6041bcf7c970104939bdbdda5af4873ebd472/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac6041bcf7c970104939bdbdda5af4873ebd472/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=8ac6041bcf7c970104939bdbdda5af4873ebd472", "patch": "@@ -70,14 +70,11 @@ pub(crate) fn find_all_refs(\n                 });\n                 usages.references.retain(|_, it| !it.is_empty());\n             }\n-            Definition::ModuleDef(def @ hir::ModuleDef::Adt(_))\n-            | Definition::ModuleDef(def @ hir::ModuleDef::Variant(_)) => {\n+            Definition::ModuleDef(hir::ModuleDef::Adt(_))\n+            | Definition::ModuleDef(hir::ModuleDef::Variant(_)) => {\n                 refs.for_each(|it| {\n                     it.retain(|reference| {\n-                        reference\n-                            .name\n-                            .as_name_ref()\n-                            .map_or(false, |name_ref| is_lit_name_ref(sema, def, name_ref))\n+                        reference.name.as_name_ref().map_or(false, is_lit_name_ref)\n                     })\n                 });\n                 usages.references.retain(|_, it| !it.is_empty());\n@@ -189,55 +186,44 @@ fn is_enum_lit_name_ref(\n     enum_: hir::Enum,\n     name_ref: &ast::NameRef,\n ) -> bool {\n-    for ancestor in name_ref.syntax().ancestors() {\n-        match_ast! {\n-            match ancestor {\n-                ast::PathExpr(path_expr) => {\n-                    return matches!(\n-                        path_expr.path().and_then(|p| sema.resolve_path(&p)),\n-                        Some(PathResolution::Def(hir::ModuleDef::Variant(variant)))\n-                            if variant.parent_enum(sema.db) == enum_\n-                    )\n-                },\n-                ast::RecordExpr(record_expr) => {\n-                    return matches!(\n-                        record_expr.path().and_then(|p| sema.resolve_path(&p)),\n-                        Some(PathResolution::Def(hir::ModuleDef::Variant(variant)))\n-                            if variant.parent_enum(sema.db) == enum_\n-                    )\n-                },\n-                _ => (),\n+    let path_is_variant_of_enum = |path: ast::Path| {\n+        matches!(\n+            sema.resolve_path(&path),\n+            Some(PathResolution::Def(hir::ModuleDef::Variant(variant)))\n+                if variant.parent_enum(sema.db) == enum_\n+        )\n+    };\n+    name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(|ancestor| {\n+            match_ast! {\n+                match ancestor {\n+                    ast::PathExpr(path_expr) => path_expr.path().map(path_is_variant_of_enum),\n+                    ast::RecordExpr(record_expr) => record_expr.path().map(path_is_variant_of_enum),\n+                    _ => None,\n+                }\n             }\n-        }\n-    }\n-    false\n+        })\n+        .unwrap_or(false)\n }\n \n-fn is_lit_name_ref(\n-    sema: &Semantics<RootDatabase>,\n-    def: hir::ModuleDef,\n-    name_ref: &ast::NameRef,\n-) -> bool {\n-    for ancestor in name_ref.syntax().ancestors() {\n+fn path_ends_with(path: Option<ast::Path>, name_ref: &ast::NameRef) -> bool {\n+    path.and_then(|path| path.segment())\n+        .and_then(|segment| segment.name_ref())\n+        .map_or(false, |segment| segment == *name_ref)\n+}\n+\n+fn is_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref.syntax().ancestors().find_map(|ancestor| {\n         match_ast! {\n             match ancestor {\n-                ast::PathExpr(path_expr) => {\n-                    return matches!(\n-                        path_expr.path().and_then(|p| sema.resolve_path(&p)),\n-                        Some(PathResolution::Def(def2)) if def == def2\n-                    )\n-                },\n-                ast::RecordExpr(record_expr) => {\n-                    return matches!(\n-                        record_expr.path().and_then(|p| sema.resolve_path(&p)),\n-                        Some(PathResolution::Def(def2)) if def == def2\n-                    )\n-                },\n-                _ => (),\n+                ast::PathExpr(path_expr) => Some(path_ends_with(path_expr.path(), name_ref)),\n+                ast::RecordExpr(record_expr) => Some(path_ends_with(record_expr.path(), name_ref)),\n+                _ => None,\n             }\n         }\n-    }\n-    false\n+    }).unwrap_or(false)\n }\n \n #[cfg(test)]"}]}