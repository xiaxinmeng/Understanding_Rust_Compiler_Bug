{"sha": "260e99614061943d68b0d78dfa27feec9a9f996f", "node_id": "C_kwDOAAsO6NoAKDI2MGU5OTYxNDA2MTk0M2Q2OGIwZDc4ZGZhMjdmZWVjOWE5Zjk5NmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-06T23:37:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-06T23:37:02Z"}, "message": "Auto merge of #14733 - azdavis:master, r=matklad\n\nMake line-index a lib, use nohash_hasher\n\nThese seem like they are not specific to rust-analyzer and could be pulled out to their own libraries. So I did.\n\nhttps://github.com/azdavis/millet/issues/31", "tree": {"sha": "ff27a25461f14f6d5eb4f0f350c43d8fb5f1ff77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff27a25461f14f6d5eb4f0f350c43d8fb5f1ff77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/260e99614061943d68b0d78dfa27feec9a9f996f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/260e99614061943d68b0d78dfa27feec9a9f996f", "html_url": "https://github.com/rust-lang/rust/commit/260e99614061943d68b0d78dfa27feec9a9f996f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/260e99614061943d68b0d78dfa27feec9a9f996f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a10fd831209f97327f747ea095dd358057ed7891", "url": "https://api.github.com/repos/rust-lang/rust/commits/a10fd831209f97327f747ea095dd358057ed7891", "html_url": "https://github.com/rust-lang/rust/commit/a10fd831209f97327f747ea095dd358057ed7891"}, {"sha": "60056b884536c77df8b82834d253b2bc784c02e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/60056b884536c77df8b82834d253b2bc784c02e4", "html_url": "https://github.com/rust-lang/rust/commit/60056b884536c77df8b82834d253b2bc784c02e4"}], "stats": {"total": 955, "additions": 481, "deletions": 474}, "files": [{"sha": "4b22a58e568ac8a8f950edf1e4bc655c05c29144", "filename": "Cargo.lock", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -587,6 +587,7 @@ dependencies = [\n  \"itertools\",\n  \"la-arena\",\n  \"limit\",\n+ \"nohash-hasher\",\n  \"once_cell\",\n  \"profile\",\n  \"project-model\",\n@@ -650,6 +651,7 @@ dependencies = [\n  \"ide-diagnostics\",\n  \"ide-ssr\",\n  \"itertools\",\n+ \"nohash-hasher\",\n  \"oorandom\",\n  \"profile\",\n  \"pulldown-cmark\",\n@@ -717,7 +719,9 @@ dependencies = [\n  \"indexmap\",\n  \"itertools\",\n  \"limit\",\n+ \"line-index\",\n  \"memchr\",\n+ \"nohash-hasher\",\n  \"once_cell\",\n  \"oorandom\",\n  \"parser\",\n@@ -763,6 +767,7 @@ dependencies = [\n  \"hir\",\n  \"ide-db\",\n  \"itertools\",\n+ \"nohash-hasher\",\n  \"parser\",\n  \"stdx\",\n  \"syntax\",\n@@ -912,6 +917,14 @@ dependencies = [\n name = \"limit\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"line-index\"\n+version = \"0.1.0-pre.1\"\n+dependencies = [\n+ \"nohash-hasher\",\n+ \"text-size\",\n+]\n+\n [[package]]\n name = \"lock_api\"\n version = \"0.4.9\"\n@@ -1054,6 +1067,12 @@ dependencies = [\n  \"static_assertions\",\n ]\n \n+[[package]]\n+name = \"nohash-hasher\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2bf50223579dc7cdcfb3bfcacf7069ff68243f8c363f62ffa99cf000a6b9c451\"\n+\n [[package]]\n name = \"notify\"\n version = \"5.1.0\"\n@@ -1470,6 +1489,7 @@ dependencies = [\n  \"mbe\",\n  \"mimalloc\",\n  \"mio\",\n+ \"nohash-hasher\",\n  \"num_cpus\",\n  \"oorandom\",\n  \"parking_lot 0.12.1\",\n@@ -2050,6 +2070,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"fst\",\n  \"indexmap\",\n+ \"nohash-hasher\",\n  \"paths\",\n  \"rustc-hash\",\n  \"stdx\","}, {"sha": "c7b0228e331c30bcdf2387249df73eff0e5baf39", "filename": "Cargo.toml", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -74,10 +74,17 @@ toolchain = { path = \"./crates/toolchain\", version = \"0.0.0\" }\n tt = { path = \"./crates/tt\", version = \"0.0.0\" }\n vfs-notify = { path = \"./crates/vfs-notify\", version = \"0.0.0\" }\n vfs = { path = \"./crates/vfs\", version = \"0.0.0\" }\n+line-index = { version = \"0.1.0-pre.1\", path = \"./lib/line-index\" }\n \n # non-local crates\n-smallvec = { version = \"1.10.0\", features = [\"const_new\", \"union\", \"const_generics\"] }\n+smallvec = { version = \"1.10.0\", features = [\n+  \"const_new\",\n+  \"union\",\n+  \"const_generics\",\n+] }\n smol_str = \"0.2.0\"\n+nohash-hasher = \"0.2.0\"\n+text-size = \"1.1.0\"\n # the following crates are pinned to prevent us from pulling in syn 2 until all our dependencies have moved\n serde = { version = \"=1.0.156\", features = [\"derive\"] }\n serde_json = \"1.0.94\""}, {"sha": "6ca0dbb850399b8dfe1428d6819e4109a69616fb", "filename": "crates/hir-ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2FCargo.toml?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -29,6 +29,7 @@ chalk-derive = \"0.89.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n once_cell = \"1.17.0\"\n triomphe.workspace = true\n+nohash-hasher.workspace = true\n typed-arena = \"2.0.1\"\n rustc_index = { version = \"0.0.20221221\", package = \"hkalbasi-rustc-ap-rustc_index\", default-features = false }\n "}, {"sha": "7d19e0a19169a314d82f94d49c4939d6a2bb2213", "filename": "crates/hir-ty/src/test_db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftest_db.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -8,8 +8,8 @@ use base_db::{\n };\n use hir_def::{db::DefDatabase, ModuleId};\n use hir_expand::db::ExpandDatabase;\n+use nohash_hasher::IntMap;\n use rustc_hash::FxHashSet;\n-use stdx::hash::NoHashHashMap;\n use syntax::TextRange;\n use test_utils::extract_annotations;\n use triomphe::Arc;\n@@ -102,7 +102,7 @@ impl TestDB {\n         self.module_for_file_opt(file_id).unwrap()\n     }\n \n-    pub(crate) fn extract_annotations(&self) -> NoHashHashMap<FileId, Vec<(TextRange, String)>> {\n+    pub(crate) fn extract_annotations(&self) -> IntMap<FileId, Vec<(TextRange, String)>> {\n         let mut files = Vec::new();\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter() {"}, {"sha": "4e75dc4dba5410ee087b6bf2e3c7b560b03ba001", "filename": "crates/ide-db/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2FCargo.toml?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -24,6 +24,7 @@ arrayvec = \"0.7.2\"\n indexmap = \"1.9.1\"\n memchr = \"2.5.0\"\n triomphe.workspace = true\n+nohash-hasher.workspace = true\n \n # local deps\n base-db.workspace = true\n@@ -37,6 +38,8 @@ text-edit.workspace = true\n # something from some `hir-xxx` subpackage, reexport the API via `hir`.\n hir.workspace = true\n \n+line-index.workspace = true\n+\n [dev-dependencies]\n expect-test = \"1.4.0\"\n oorandom = \"11.1.3\""}, {"sha": "ff1a20f03f44cb24a094e3b8bf6b6e025541fa8c", "filename": "crates/ide-db/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Flib.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -13,7 +13,6 @@ pub mod famous_defs;\n pub mod helpers;\n pub mod items_locator;\n pub mod label;\n-pub mod line_index;\n pub mod path_transform;\n pub mod rename;\n pub mod rust_doc;\n@@ -55,6 +54,8 @@ use triomphe::Arc;\n use crate::{line_index::LineIndex, symbol_index::SymbolsDatabase};\n pub use rustc_hash::{FxHashMap, FxHashSet, FxHasher};\n \n+pub use ::line_index;\n+\n /// `base_db` is normally also needed in places where `ide_db` is used, so this re-export is for convenience.\n pub use base_db;\n \n@@ -414,4 +415,5 @@ impl SnippetCap {\n #[cfg(test)]\n mod tests {\n     mod sourcegen_lints;\n+    mod line_index;\n }"}, {"sha": "9fb58ebe8ab8e51f29f8ec68a596e2b9c4f726dd", "filename": "crates/ide-db/src/line_index.rs", "status": "removed", "additions": 0, "deletions": 317, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/a10fd831209f97327f747ea095dd358057ed7891/crates%2Fide-db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10fd831209f97327f747ea095dd358057ed7891/crates%2Fide-db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fline_index.rs?ref=a10fd831209f97327f747ea095dd358057ed7891", "patch": "@@ -1,317 +0,0 @@\n-//! `LineIndex` maps flat `TextSize` offsets into `(Line, Column)`\n-//! representation.\n-use std::{iter, mem};\n-\n-use stdx::hash::NoHashHashMap;\n-use syntax::{TextRange, TextSize};\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct LineIndex {\n-    /// Offset the beginning of each line, zero-based.\n-    pub(crate) newlines: Vec<TextSize>,\n-    /// List of non-ASCII characters on each line.\n-    pub(crate) line_wide_chars: NoHashHashMap<u32, Vec<WideChar>>,\n-}\n-\n-/// Line/Column information in native, utf8 format.\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct LineCol {\n-    /// Zero-based\n-    pub line: u32,\n-    /// Zero-based utf8 offset\n-    pub col: u32,\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum WideEncoding {\n-    Utf16,\n-    Utf32,\n-}\n-\n-/// Line/Column information in legacy encodings.\n-///\n-/// Deliberately not a generic type and different from `LineCol`.\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct WideLineCol {\n-    /// Zero-based\n-    pub line: u32,\n-    /// Zero-based\n-    pub col: u32,\n-}\n-\n-#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-pub(crate) struct WideChar {\n-    /// Start offset of a character inside a line, zero-based\n-    pub(crate) start: TextSize,\n-    /// End offset of a character inside a line, zero-based\n-    pub(crate) end: TextSize,\n-}\n-\n-impl WideChar {\n-    /// Returns the length in 8-bit UTF-8 code units.\n-    fn len(&self) -> TextSize {\n-        self.end - self.start\n-    }\n-\n-    /// Returns the length in UTF-16 or UTF-32 code units.\n-    fn wide_len(&self, enc: WideEncoding) -> usize {\n-        match enc {\n-            WideEncoding::Utf16 => {\n-                if self.len() == TextSize::from(4) {\n-                    2\n-                } else {\n-                    1\n-                }\n-            }\n-\n-            WideEncoding::Utf32 => 1,\n-        }\n-    }\n-}\n-\n-impl LineIndex {\n-    pub fn new(text: &str) -> LineIndex {\n-        let mut line_wide_chars = NoHashHashMap::default();\n-        let mut wide_chars = Vec::new();\n-\n-        let mut newlines = Vec::with_capacity(16);\n-        newlines.push(TextSize::from(0));\n-\n-        let mut curr_row = 0.into();\n-        let mut curr_col = 0.into();\n-        let mut line = 0;\n-        for c in text.chars() {\n-            let c_len = TextSize::of(c);\n-            curr_row += c_len;\n-            if c == '\\n' {\n-                newlines.push(curr_row);\n-\n-                // Save any utf-16 characters seen in the previous line\n-                if !wide_chars.is_empty() {\n-                    line_wide_chars.insert(line, mem::take(&mut wide_chars));\n-                }\n-\n-                // Prepare for processing the next line\n-                curr_col = 0.into();\n-                line += 1;\n-                continue;\n-            }\n-\n-            if !c.is_ascii() {\n-                wide_chars.push(WideChar { start: curr_col, end: curr_col + c_len });\n-            }\n-\n-            curr_col += c_len;\n-        }\n-\n-        // Save any utf-16 characters seen in the last line\n-        if !wide_chars.is_empty() {\n-            line_wide_chars.insert(line, wide_chars);\n-        }\n-\n-        newlines.shrink_to_fit();\n-        line_wide_chars.shrink_to_fit();\n-\n-        LineIndex { newlines, line_wide_chars }\n-    }\n-\n-    pub fn line_col(&self, offset: TextSize) -> LineCol {\n-        let line = self.newlines.partition_point(|&it| it <= offset) - 1;\n-        let line_start_offset = self.newlines[line];\n-        let col = offset - line_start_offset;\n-        LineCol { line: line as u32, col: col.into() }\n-    }\n-\n-    pub fn offset(&self, line_col: LineCol) -> Option<TextSize> {\n-        self.newlines\n-            .get(line_col.line as usize)\n-            .map(|offset| offset + TextSize::from(line_col.col))\n-    }\n-\n-    pub fn to_wide(&self, enc: WideEncoding, line_col: LineCol) -> WideLineCol {\n-        let col = self.utf8_to_wide_col(enc, line_col.line, line_col.col.into());\n-        WideLineCol { line: line_col.line, col: col as u32 }\n-    }\n-\n-    pub fn to_utf8(&self, enc: WideEncoding, line_col: WideLineCol) -> LineCol {\n-        let col = self.wide_to_utf8_col(enc, line_col.line, line_col.col);\n-        LineCol { line: line_col.line, col: col.into() }\n-    }\n-\n-    pub fn lines(&self, range: TextRange) -> impl Iterator<Item = TextRange> + '_ {\n-        let lo = self.newlines.partition_point(|&it| it < range.start());\n-        let hi = self.newlines.partition_point(|&it| it <= range.end());\n-        let all = iter::once(range.start())\n-            .chain(self.newlines[lo..hi].iter().copied())\n-            .chain(iter::once(range.end()));\n-\n-        all.clone()\n-            .zip(all.skip(1))\n-            .map(|(lo, hi)| TextRange::new(lo, hi))\n-            .filter(|it| !it.is_empty())\n-    }\n-\n-    fn utf8_to_wide_col(&self, enc: WideEncoding, line: u32, col: TextSize) -> usize {\n-        let mut res: usize = col.into();\n-        if let Some(wide_chars) = self.line_wide_chars.get(&line) {\n-            for c in wide_chars {\n-                if c.end <= col {\n-                    res -= usize::from(c.len()) - c.wide_len(enc);\n-                } else {\n-                    // From here on, all utf16 characters come *after* the character we are mapping,\n-                    // so we don't need to take them into account\n-                    break;\n-                }\n-            }\n-        }\n-        res\n-    }\n-\n-    fn wide_to_utf8_col(&self, enc: WideEncoding, line: u32, mut col: u32) -> TextSize {\n-        if let Some(wide_chars) = self.line_wide_chars.get(&line) {\n-            for c in wide_chars {\n-                if col > u32::from(c.start) {\n-                    col += u32::from(c.len()) - c.wide_len(enc) as u32;\n-                } else {\n-                    // From here on, all utf16 characters come *after* the character we are mapping,\n-                    // so we don't need to take them into account\n-                    break;\n-                }\n-            }\n-        }\n-\n-        col.into()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use test_utils::skip_slow_tests;\n-\n-    use super::WideEncoding::{Utf16, Utf32};\n-    use super::*;\n-\n-    #[test]\n-    fn test_line_index() {\n-        let text = \"hello\\nworld\";\n-        let table = [\n-            (00, 0, 0),\n-            (01, 0, 1),\n-            (05, 0, 5),\n-            (06, 1, 0),\n-            (07, 1, 1),\n-            (08, 1, 2),\n-            (10, 1, 4),\n-            (11, 1, 5),\n-            (12, 1, 6),\n-        ];\n-\n-        let index = LineIndex::new(text);\n-        for (offset, line, col) in table {\n-            assert_eq!(index.line_col(offset.into()), LineCol { line, col });\n-        }\n-\n-        let text = \"\\nhello\\nworld\";\n-        let table = [(0, 0, 0), (1, 1, 0), (2, 1, 1), (6, 1, 5), (7, 2, 0)];\n-        let index = LineIndex::new(text);\n-        for (offset, line, col) in table {\n-            assert_eq!(index.line_col(offset.into()), LineCol { line, col });\n-        }\n-    }\n-\n-    #[test]\n-    fn test_char_len() {\n-        assert_eq!('\u30e1'.len_utf8(), 3);\n-        assert_eq!('\u30e1'.len_utf16(), 1);\n-    }\n-\n-    #[test]\n-    fn test_empty_index() {\n-        let col_index = LineIndex::new(\n-            \"\n-const C: char = 'x';\n-\",\n-        );\n-        assert_eq!(col_index.line_wide_chars.len(), 0);\n-    }\n-\n-    #[test]\n-    fn test_every_chars() {\n-        if skip_slow_tests() {\n-            return;\n-        }\n-\n-        let text: String = {\n-            let mut chars: Vec<char> = ((0 as char)..char::MAX).collect(); // Neat!\n-            chars.extend(\"\\n\".repeat(chars.len() / 16).chars());\n-            let mut rng = oorandom::Rand32::new(stdx::rand::seed());\n-            stdx::rand::shuffle(&mut chars, |i| rng.rand_range(0..i as u32) as usize);\n-            chars.into_iter().collect()\n-        };\n-        assert!(text.contains('\ud83d\udca9')); // Sanity check.\n-\n-        let line_index = LineIndex::new(&text);\n-\n-        let mut lin_col = LineCol { line: 0, col: 0 };\n-        let mut col_utf16 = 0;\n-        let mut col_utf32 = 0;\n-        for (offset, c) in text.char_indices() {\n-            let got_offset = line_index.offset(lin_col).unwrap();\n-            assert_eq!(usize::from(got_offset), offset);\n-\n-            let got_lin_col = line_index.line_col(got_offset);\n-            assert_eq!(got_lin_col, lin_col);\n-\n-            for enc in [Utf16, Utf32] {\n-                let wide_lin_col = line_index.to_wide(enc, lin_col);\n-                let got_lin_col = line_index.to_utf8(enc, wide_lin_col);\n-                assert_eq!(got_lin_col, lin_col);\n-\n-                let want_col = match enc {\n-                    Utf16 => col_utf16,\n-                    Utf32 => col_utf32,\n-                };\n-                assert_eq!(wide_lin_col.col, want_col)\n-            }\n-\n-            if c == '\\n' {\n-                lin_col.line += 1;\n-                lin_col.col = 0;\n-                col_utf16 = 0;\n-                col_utf32 = 0;\n-            } else {\n-                lin_col.col += c.len_utf8() as u32;\n-                col_utf16 += c.len_utf16() as u32;\n-                col_utf32 += 1;\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_splitlines() {\n-        fn r(lo: u32, hi: u32) -> TextRange {\n-            TextRange::new(lo.into(), hi.into())\n-        }\n-\n-        let text = \"a\\nbb\\nccc\\n\";\n-        let line_index = LineIndex::new(text);\n-\n-        let actual = line_index.lines(r(0, 9)).collect::<Vec<_>>();\n-        let expected = vec![r(0, 2), r(2, 5), r(5, 9)];\n-        assert_eq!(actual, expected);\n-\n-        let text = \"\";\n-        let line_index = LineIndex::new(text);\n-\n-        let actual = line_index.lines(r(0, 0)).collect::<Vec<_>>();\n-        let expected = vec![];\n-        assert_eq!(actual, expected);\n-\n-        let text = \"\\n\";\n-        let line_index = LineIndex::new(text);\n-\n-        let actual = line_index.lines(r(0, 1)).collect::<Vec<_>>();\n-        let expected = vec![r(0, 1)];\n-        assert_eq!(actual, expected)\n-    }\n-}"}, {"sha": "9d00c7170975dd7ef9776534785c89c3eae3dc2d", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -11,9 +11,9 @@ use hir::{\n     AsAssocItem, DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility,\n };\n use memchr::memmem::Finder;\n+use nohash_hasher::IntMap;\n use once_cell::unsync::Lazy;\n use parser::SyntaxKind;\n-use stdx::hash::NoHashHashMap;\n use syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n use triomphe::Arc;\n \n@@ -25,7 +25,7 @@ use crate::{\n \n #[derive(Debug, Default, Clone)]\n pub struct UsageSearchResult {\n-    pub references: NoHashHashMap<FileId, Vec<FileReference>>,\n+    pub references: IntMap<FileId, Vec<FileReference>>,\n }\n \n impl UsageSearchResult {\n@@ -50,7 +50,7 @@ impl UsageSearchResult {\n \n impl IntoIterator for UsageSearchResult {\n     type Item = (FileId, Vec<FileReference>);\n-    type IntoIter = <NoHashHashMap<FileId, Vec<FileReference>> as IntoIterator>::IntoIter;\n+    type IntoIter = <IntMap<FileId, Vec<FileReference>> as IntoIterator>::IntoIter;\n \n     fn into_iter(self) -> Self::IntoIter {\n         self.references.into_iter()\n@@ -84,17 +84,17 @@ pub enum ReferenceCategory {\n /// e.g. for things like local variables.\n #[derive(Clone, Debug)]\n pub struct SearchScope {\n-    entries: NoHashHashMap<FileId, Option<TextRange>>,\n+    entries: IntMap<FileId, Option<TextRange>>,\n }\n \n impl SearchScope {\n-    fn new(entries: NoHashHashMap<FileId, Option<TextRange>>) -> SearchScope {\n+    fn new(entries: IntMap<FileId, Option<TextRange>>) -> SearchScope {\n         SearchScope { entries }\n     }\n \n     /// Build a search scope spanning the entire crate graph of files.\n     fn crate_graph(db: &RootDatabase) -> SearchScope {\n-        let mut entries = NoHashHashMap::default();\n+        let mut entries = IntMap::default();\n \n         let graph = db.crate_graph();\n         for krate in graph.iter() {\n@@ -108,7 +108,7 @@ impl SearchScope {\n \n     /// Build a search scope spanning all the reverse dependencies of the given crate.\n     fn reverse_dependencies(db: &RootDatabase, of: hir::Crate) -> SearchScope {\n-        let mut entries = NoHashHashMap::default();\n+        let mut entries = IntMap::default();\n         for rev_dep in of.transitive_reverse_dependencies(db) {\n             let root_file = rev_dep.root_file(db);\n             let source_root_id = db.file_source_root(root_file);\n@@ -128,7 +128,7 @@ impl SearchScope {\n \n     /// Build a search scope spanning the given module and all its submodules.\n     fn module_and_children(db: &RootDatabase, module: hir::Module) -> SearchScope {\n-        let mut entries = NoHashHashMap::default();\n+        let mut entries = IntMap::default();\n \n         let (file_id, range) = {\n             let InFile { file_id, value } = module.definition_source(db);\n@@ -161,7 +161,7 @@ impl SearchScope {\n \n     /// Build an empty search scope.\n     pub fn empty() -> SearchScope {\n-        SearchScope::new(NoHashHashMap::default())\n+        SearchScope::new(IntMap::default())\n     }\n \n     /// Build a empty search scope spanning the given file."}, {"sha": "061fb0f05cfb91964614b7ca57ad7fbe1cba052f", "filename": "crates/ide-db/src/source_change.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide-db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide-db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsource_change.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -5,16 +5,16 @@\n \n use std::{collections::hash_map::Entry, iter, mem};\n \n+use crate::SnippetCap;\n use base_db::{AnchoredPathBuf, FileId};\n-use stdx::{hash::NoHashHashMap, never};\n+use nohash_hasher::IntMap;\n+use stdx::never;\n use syntax::{algo, ast, ted, AstNode, SyntaxNode, SyntaxNodePtr, TextRange, TextSize};\n use text_edit::{TextEdit, TextEditBuilder};\n \n-use crate::SnippetCap;\n-\n #[derive(Default, Debug, Clone)]\n pub struct SourceChange {\n-    pub source_file_edits: NoHashHashMap<FileId, TextEdit>,\n+    pub source_file_edits: IntMap<FileId, TextEdit>,\n     pub file_system_edits: Vec<FileSystemEdit>,\n     pub is_snippet: bool,\n }\n@@ -23,7 +23,7 @@ impl SourceChange {\n     /// Creates a new SourceChange with the given label\n     /// from the edits.\n     pub fn from_edits(\n-        source_file_edits: NoHashHashMap<FileId, TextEdit>,\n+        source_file_edits: IntMap<FileId, TextEdit>,\n         file_system_edits: Vec<FileSystemEdit>,\n     ) -> Self {\n         SourceChange { source_file_edits, file_system_edits, is_snippet: false }\n@@ -77,8 +77,8 @@ impl Extend<FileSystemEdit> for SourceChange {\n     }\n }\n \n-impl From<NoHashHashMap<FileId, TextEdit>> for SourceChange {\n-    fn from(source_file_edits: NoHashHashMap<FileId, TextEdit>) -> SourceChange {\n+impl From<IntMap<FileId, TextEdit>> for SourceChange {\n+    fn from(source_file_edits: IntMap<FileId, TextEdit>) -> SourceChange {\n         SourceChange { source_file_edits, file_system_edits: Vec::new(), is_snippet: false }\n     }\n }"}, {"sha": "6b49bb2631c19bff46535620f4bdf8c3a7590562", "filename": "crates/ide-db/src/tests/line_index.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide-db%2Fsrc%2Ftests%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide-db%2Fsrc%2Ftests%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Ftests%2Fline_index.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -0,0 +1,49 @@\n+use line_index::{LineCol, LineIndex, WideEncoding};\n+use test_utils::skip_slow_tests;\n+\n+#[test]\n+fn test_every_chars() {\n+    if skip_slow_tests() {\n+        return;\n+    }\n+\n+    let text: String = {\n+        let mut chars: Vec<char> = ((0 as char)..char::MAX).collect(); // Neat!\n+        chars.extend(\"\\n\".repeat(chars.len() / 16).chars());\n+        let mut rng = oorandom::Rand32::new(stdx::rand::seed());\n+        stdx::rand::shuffle(&mut chars, |i| rng.rand_range(0..i as u32) as usize);\n+        chars.into_iter().collect()\n+    };\n+    assert!(text.contains('\ud83d\udca9')); // Sanity check.\n+\n+    let line_index = LineIndex::new(&text);\n+\n+    let mut lin_col = LineCol { line: 0, col: 0 };\n+    let mut col_utf16 = 0;\n+    let mut col_utf32 = 0;\n+    for (offset, c) in text.char_indices() {\n+        let got_offset = line_index.offset(lin_col).unwrap();\n+        assert_eq!(usize::from(got_offset), offset);\n+\n+        let got_lin_col = line_index.line_col(got_offset);\n+        assert_eq!(got_lin_col, lin_col);\n+\n+        for (enc, col) in [(WideEncoding::Utf16, col_utf16), (WideEncoding::Utf32, col_utf32)] {\n+            let wide_lin_col = line_index.to_wide(enc, lin_col).unwrap();\n+            let got_lin_col = line_index.to_utf8(enc, wide_lin_col).unwrap();\n+            assert_eq!(got_lin_col, lin_col);\n+            assert_eq!(wide_lin_col.col, col)\n+        }\n+\n+        if c == '\\n' {\n+            lin_col.line += 1;\n+            lin_col.col = 0;\n+            col_utf16 = 0;\n+            col_utf32 = 0;\n+        } else {\n+            lin_col.col += c.len_utf8() as u32;\n+            col_utf16 += c.len_utf16() as u32;\n+            col_utf32 += 1;\n+        }\n+    }\n+}"}, {"sha": "70ed6dea5bf2814b9c45438392bd5cf569d4d0cf", "filename": "crates/ide-ssr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide-ssr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide-ssr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-ssr%2FCargo.toml?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -16,6 +16,7 @@ doctest = false\n cov-mark = \"2.0.0-pre.1\"\n itertools = \"0.10.5\"\n triomphe.workspace = true\n+nohash-hasher.workspace = true\n \n # local deps\n hir.workspace = true"}, {"sha": "f51a9547a5084afe2ee7e54000c29535e7b04b36", "filename": "crates/ide-ssr/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide-ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide-ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-ssr%2Fsrc%2Flib.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -87,8 +87,8 @@ pub use crate::{errors::SsrError, from_comment::ssr_from_comment, matching::Matc\n use crate::{errors::bail, matching::MatchFailureReason};\n use hir::Semantics;\n use ide_db::base_db::{FileId, FilePosition, FileRange};\n+use nohash_hasher::IntMap;\n use resolving::ResolvedRule;\n-use stdx::hash::NoHashHashMap;\n use syntax::{ast, AstNode, SyntaxNode, TextRange};\n use text_edit::TextEdit;\n \n@@ -168,9 +168,9 @@ impl<'db> MatchFinder<'db> {\n     }\n \n     /// Finds matches for all added rules and returns edits for all found matches.\n-    pub fn edits(&self) -> NoHashHashMap<FileId, TextEdit> {\n+    pub fn edits(&self) -> IntMap<FileId, TextEdit> {\n         use ide_db::base_db::SourceDatabaseExt;\n-        let mut matches_by_file = NoHashHashMap::default();\n+        let mut matches_by_file = IntMap::default();\n         for m in self.matches().matches {\n             matches_by_file\n                 .entry(m.range.file_id)"}, {"sha": "2aee203c4ea5497f1167eb7e350b6d5023cbd769", "filename": "crates/ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2FCargo.toml?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -24,6 +24,7 @@ url = \"2.3.1\"\n dot = \"0.1.4\"\n smallvec.workspace = true\n triomphe.workspace = true\n+nohash-hasher.workspace = true\n \n # local deps\n cfg.workspace = true"}, {"sha": "291b1a349b3471b1bc3c9bd7a2c4c17542166e43", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -17,7 +17,7 @@ use ide_db::{\n     RootDatabase,\n };\n use itertools::Itertools;\n-use stdx::hash::NoHashHashMap;\n+use nohash_hasher::IntMap;\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, HasName},\n@@ -31,7 +31,7 @@ use crate::{FilePosition, NavigationTarget, TryToNav};\n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {\n     pub declaration: Option<Declaration>,\n-    pub references: NoHashHashMap<FileId, Vec<(TextRange, Option<ReferenceCategory>)>>,\n+    pub references: IntMap<FileId, Vec<(TextRange, Option<ReferenceCategory>)>>,\n }\n \n #[derive(Debug, Clone)]"}, {"sha": "ae5b8e4c422551b5e26c2e25c7acfd9ea281de28", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -46,6 +46,7 @@ tracing-subscriber = { version = \"0.3.16\", default-features = false, features =\n tracing-log = \"0.1.3\"\n tracing-tree = \"0.2.1\"\n triomphe.workspace = true\n+nohash-hasher.workspace = true\n always-assert = \"0.1.2\"\n \n # These dependencies are unused, but we pin them to a version here to restrict them for our transitive dependencies\n@@ -95,7 +96,4 @@ mbe.workspace = true\n [features]\n jemalloc = [\"jemallocator\", \"profile/jemalloc\"]\n force-always-assert = [\"always-assert/force\"]\n-in-rust-tree = [\n-    \"ide/in-rust-tree\",\n-    \"syntax/in-rust-tree\",\n-]\n+in-rust-tree = [\"ide/in-rust-tree\", \"syntax/in-rust-tree\"]"}, {"sha": "ab06b96814a2918f8898fcc8879718e9db1f552f", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -23,13 +23,14 @@ use crate::semantic_tokens;\n \n pub fn server_capabilities(config: &Config) -> ServerCapabilities {\n     ServerCapabilities {\n-        position_encoding: Some(match negotiated_encoding(config.caps()) {\n-            PositionEncoding::Utf8 => PositionEncodingKind::UTF8,\n+        position_encoding: match negotiated_encoding(config.caps()) {\n+            PositionEncoding::Utf8 => Some(PositionEncodingKind::UTF8),\n             PositionEncoding::Wide(wide) => match wide {\n-                WideEncoding::Utf16 => PositionEncodingKind::UTF16,\n-                WideEncoding::Utf32 => PositionEncodingKind::UTF32,\n+                WideEncoding::Utf16 => Some(PositionEncodingKind::UTF16),\n+                WideEncoding::Utf32 => Some(PositionEncodingKind::UTF32),\n+                _ => None,\n             },\n-        }),\n+        },\n         text_document_sync: Some(TextDocumentSyncCapability::Options(TextDocumentSyncOptions {\n             open_close: Some(true),\n             change: Some(TextDocumentSyncKind::INCREMENTAL),"}, {"sha": "33422fd058ef016f561befa4fddfe535d923ce0e", "filename": "crates/rust-analyzer/src/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -5,12 +5,12 @@ use std::mem;\n \n use ide::FileId;\n use ide_db::FxHashMap;\n-use stdx::hash::{NoHashHashMap, NoHashHashSet};\n+use nohash_hasher::{IntMap, IntSet};\n use triomphe::Arc;\n \n use crate::lsp_ext;\n \n-pub(crate) type CheckFixes = Arc<NoHashHashMap<usize, NoHashHashMap<FileId, Vec<Fix>>>>;\n+pub(crate) type CheckFixes = Arc<IntMap<usize, IntMap<FileId, Vec<Fix>>>>;\n \n #[derive(Debug, Default, Clone)]\n pub struct DiagnosticsMapConfig {\n@@ -21,12 +21,12 @@ pub struct DiagnosticsMapConfig {\n \n #[derive(Debug, Default, Clone)]\n pub(crate) struct DiagnosticCollection {\n-    // FIXME: should be NoHashHashMap<FileId, Vec<ra_id::Diagnostic>>\n-    pub(crate) native: NoHashHashMap<FileId, Vec<lsp_types::Diagnostic>>,\n+    // FIXME: should be IntMap<FileId, Vec<ra_id::Diagnostic>>\n+    pub(crate) native: IntMap<FileId, Vec<lsp_types::Diagnostic>>,\n     // FIXME: should be Vec<flycheck::Diagnostic>\n-    pub(crate) check: NoHashHashMap<usize, NoHashHashMap<FileId, Vec<lsp_types::Diagnostic>>>,\n+    pub(crate) check: IntMap<usize, IntMap<FileId, Vec<lsp_types::Diagnostic>>>,\n     pub(crate) check_fixes: CheckFixes,\n-    changes: NoHashHashSet<FileId>,\n+    changes: IntSet<FileId>,\n }\n \n #[derive(Debug, Clone)]\n@@ -106,7 +106,7 @@ impl DiagnosticCollection {\n         native.chain(check)\n     }\n \n-    pub(crate) fn take_changes(&mut self) -> Option<NoHashHashSet<FileId>> {\n+    pub(crate) fn take_changes(&mut self) -> Option<IntSet<FileId>> {\n         if self.changes.is_empty() {\n             return None;\n         }"}, {"sha": "e1d1130ff1b874f4262178d5f9de52f404e0f9da", "filename": "crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -3,7 +3,6 @@\n use std::collections::HashMap;\n \n use flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan};\n-use ide_db::line_index::WideEncoding;\n use itertools::Itertools;\n use stdx::format_to;\n use vfs::{AbsPath, AbsPathBuf};\n@@ -80,37 +79,33 @@ fn position(\n     position_encoding: &PositionEncoding,\n     span: &DiagnosticSpan,\n     line_offset: usize,\n-    column_offset: usize,\n+    column_offset_utf32: usize,\n ) -> lsp_types::Position {\n     let line_index = line_offset - span.line_start;\n \n-    let mut true_column_offset = column_offset;\n-    if let Some(line) = span.text.get(line_index) {\n-        if line.text.chars().count() == line.text.len() {\n-            // all one byte utf-8 char\n-            return lsp_types::Position {\n-                line: (line_offset as u32).saturating_sub(1),\n-                character: (column_offset as u32).saturating_sub(1),\n-            };\n-        }\n-        let mut char_offset = 0;\n-        let len_func = match position_encoding {\n-            PositionEncoding::Utf8 => char::len_utf8,\n-            PositionEncoding::Wide(WideEncoding::Utf16) => char::len_utf16,\n-            PositionEncoding::Wide(WideEncoding::Utf32) => |_| 1,\n-        };\n-        for c in line.text.chars() {\n-            char_offset += 1;\n-            if char_offset > column_offset {\n-                break;\n+    let column_offset_encoded = match span.text.get(line_index) {\n+        // Fast path.\n+        Some(line) if line.text.is_ascii() => column_offset_utf32,\n+        Some(line) => {\n+            let line_prefix_len = line\n+                .text\n+                .char_indices()\n+                .take(column_offset_utf32)\n+                .last()\n+                .map(|(pos, c)| pos + c.len_utf8())\n+                .unwrap_or(0);\n+            let line_prefix = &line.text[..line_prefix_len];\n+            match position_encoding {\n+                PositionEncoding::Utf8 => line_prefix.len(),\n+                PositionEncoding::Wide(enc) => enc.measure(line_prefix),\n             }\n-            true_column_offset += len_func(c) - 1;\n         }\n-    }\n+        None => column_offset_utf32,\n+    };\n \n     lsp_types::Position {\n         line: (line_offset as u32).saturating_sub(1),\n-        character: (true_column_offset as u32).saturating_sub(1),\n+        character: (column_offset_encoded as u32).saturating_sub(1),\n     }\n }\n "}, {"sha": "cd74a5500d0a9d47cb609cbbd0caa41086d0e9b4", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -31,7 +31,10 @@ pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> R\n         PositionEncoding::Utf8 => LineCol { line: position.line, col: position.character },\n         PositionEncoding::Wide(enc) => {\n             let line_col = WideLineCol { line: position.line, col: position.character };\n-            line_index.index.to_utf8(enc, line_col)\n+            line_index\n+                .index\n+                .to_utf8(enc, line_col)\n+                .ok_or_else(|| format_err!(\"Invalid wide col offset\"))?\n         }\n     };\n     let text_size ="}, {"sha": "9535d88454f403fe28492536b7c58f65e6b2f4b5", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -10,11 +10,11 @@ use flycheck::FlycheckHandle;\n use ide::{Analysis, AnalysisHost, Cancellable, Change, FileId};\n use ide_db::base_db::{CrateId, FileLoader, ProcMacroPaths, SourceDatabase};\n use lsp_types::{SemanticTokens, Url};\n+use nohash_hasher::IntMap;\n use parking_lot::{Mutex, RwLock};\n use proc_macro_api::ProcMacroServer;\n use project_model::{CargoWorkspace, ProjectWorkspace, Target, WorkspaceBuildScripts};\n use rustc_hash::FxHashMap;\n-use stdx::hash::NoHashHashMap;\n use triomphe::Arc;\n use vfs::AnchoredPathBuf;\n \n@@ -70,7 +70,7 @@ pub(crate) struct GlobalState {\n     pub(crate) flycheck_sender: Sender<flycheck::Message>,\n     pub(crate) flycheck_receiver: Receiver<flycheck::Message>,\n \n-    pub(crate) vfs: Arc<RwLock<(vfs::Vfs, NoHashHashMap<FileId, LineEndings>)>>,\n+    pub(crate) vfs: Arc<RwLock<(vfs::Vfs, IntMap<FileId, LineEndings>)>>,\n     pub(crate) vfs_config_version: u32,\n     pub(crate) vfs_progress_config_version: u32,\n     pub(crate) vfs_progress_n_total: usize,\n@@ -117,7 +117,7 @@ pub(crate) struct GlobalStateSnapshot {\n     pub(crate) check_fixes: CheckFixes,\n     mem_docs: MemDocs,\n     pub(crate) semantic_tokens_cache: Arc<Mutex<FxHashMap<Url, SemanticTokens>>>,\n-    vfs: Arc<RwLock<(vfs::Vfs, NoHashHashMap<FileId, LineEndings>)>>,\n+    vfs: Arc<RwLock<(vfs::Vfs, IntMap<FileId, LineEndings>)>>,\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n     // used to signal semantic highlighting to fall back to syntax based highlighting until proc-macros have been loaded\n     pub(crate) proc_macros_loaded: bool,\n@@ -170,7 +170,7 @@ impl GlobalState {\n             flycheck_sender,\n             flycheck_receiver,\n \n-            vfs: Arc::new(RwLock::new((vfs::Vfs::default(), NoHashHashMap::default()))),\n+            vfs: Arc::new(RwLock::new((vfs::Vfs::default(), IntMap::default()))),\n             vfs_config_version: 0,\n             vfs_progress_config_version: 0,\n             vfs_progress_n_total: 0,"}, {"sha": "b9d853e202a2db5438585808a370401a0a1043f1", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -32,7 +32,7 @@ pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::P\n     match line_index.encoding {\n         PositionEncoding::Utf8 => lsp_types::Position::new(line_col.line, line_col.col),\n         PositionEncoding::Wide(enc) => {\n-            let line_col = line_index.index.to_wide(enc, line_col);\n+            let line_col = line_index.index.to_wide(enc, line_col).unwrap();\n             lsp_types::Position::new(line_col.line, line_col.col)\n         }\n     }"}, {"sha": "0c21d2674b1a05d0a09cae7b33c21f602774fced", "filename": "crates/stdx/src/hash.rs", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a10fd831209f97327f747ea095dd358057ed7891/crates%2Fstdx%2Fsrc%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10fd831209f97327f747ea095dd358057ed7891/crates%2Fstdx%2Fsrc%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fhash.rs?ref=a10fd831209f97327f747ea095dd358057ed7891", "patch": "@@ -1,80 +0,0 @@\n-//! A none hashing [`Hasher`] implementation.\n-use std::{\n-    hash::{BuildHasher, Hasher},\n-    marker::PhantomData,\n-};\n-\n-pub type NoHashHashMap<K, V> = std::collections::HashMap<K, V, NoHashHasherBuilder<K>>;\n-pub type NoHashHashSet<K> = std::collections::HashSet<K, NoHashHasherBuilder<K>>;\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct NoHashHasherBuilder<T>(PhantomData<T>);\n-\n-impl<T> Default for NoHashHasherBuilder<T> {\n-    fn default() -> Self {\n-        Self(Default::default())\n-    }\n-}\n-\n-pub trait NoHashHashable {}\n-impl NoHashHashable for usize {}\n-impl NoHashHashable for u32 {}\n-\n-pub struct NoHashHasher(u64);\n-\n-impl<T: NoHashHashable> BuildHasher for NoHashHasherBuilder<T> {\n-    type Hasher = NoHashHasher;\n-    fn build_hasher(&self) -> Self::Hasher {\n-        NoHashHasher(0)\n-    }\n-}\n-\n-impl Hasher for NoHashHasher {\n-    fn finish(&self) -> u64 {\n-        self.0\n-    }\n-\n-    fn write(&mut self, _: &[u8]) {\n-        unimplemented!(\"NoHashHasher should only be used for hashing primitive integers\")\n-    }\n-\n-    fn write_u8(&mut self, i: u8) {\n-        self.0 = i as u64;\n-    }\n-\n-    fn write_u16(&mut self, i: u16) {\n-        self.0 = i as u64;\n-    }\n-\n-    fn write_u32(&mut self, i: u32) {\n-        self.0 = i as u64;\n-    }\n-\n-    fn write_u64(&mut self, i: u64) {\n-        self.0 = i;\n-    }\n-\n-    fn write_usize(&mut self, i: usize) {\n-        self.0 = i as u64;\n-    }\n-\n-    fn write_i8(&mut self, i: i8) {\n-        self.0 = i as u64;\n-    }\n-\n-    fn write_i16(&mut self, i: i16) {\n-        self.0 = i as u64;\n-    }\n-\n-    fn write_i32(&mut self, i: i32) {\n-        self.0 = i as u64;\n-    }\n-\n-    fn write_i64(&mut self, i: i64) {\n-        self.0 = i as u64;\n-    }\n-\n-    fn write_isize(&mut self, i: isize) {\n-        self.0 = i as u64;\n-    }\n-}"}, {"sha": "8df86e810047f6b548bcce6b266b49ba93081bd9", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -7,7 +7,6 @@ use std::process::Command;\n use std::{cmp::Ordering, ops, time::Instant};\n \n mod macros;\n-pub mod hash;\n pub mod process;\n pub mod panic_context;\n pub mod non_empty_vec;"}, {"sha": "2b5b6f4956166d5380e92058d93cb456e30614e2", "filename": "crates/test-utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Ftest-utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Ftest-utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2FCargo.toml?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -14,7 +14,7 @@ doctest = false\n [dependencies]\n # Avoid adding deps here, this crate is widely used in tests it should compile fast!\n dissimilar = \"1.0.4\"\n-text-size = \"1.1.0\"\n+text-size.workspace = true\n rustc-hash = \"1.1.0\"\n \n stdx.workspace = true"}, {"sha": "76d0ca5ccb601f6173a5fc9552df4f4286fd0d0f", "filename": "crates/text-edit/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Ftext-edit%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Ftext-edit%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftext-edit%2FCargo.toml?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -13,4 +13,4 @@ doctest = false\n \n [dependencies]\n itertools = \"0.10.5\"\n-text-size = \"1.1.0\"\n+text-size.workspace = true"}, {"sha": "3ae3dc83ca9b373f52cd355ce6c281144bd49dcf", "filename": "crates/vfs/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fvfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fvfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2FCargo.toml?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -15,6 +15,7 @@ doctest = false\n rustc-hash = \"1.1.0\"\n fst = \"0.4.7\"\n indexmap = \"1.9.1\"\n+nohash-hasher.workspace = true\n \n paths.workspace = true\n stdx.workspace = true"}, {"sha": "0392ef3cebe96b698011f1b86516fcea8b3c73a3", "filename": "crates/vfs/src/file_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Ffile_set.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -5,16 +5,16 @@\n use std::fmt;\n \n use fst::{IntoStreamer, Streamer};\n+use nohash_hasher::IntMap;\n use rustc_hash::FxHashMap;\n-use stdx::hash::NoHashHashMap;\n \n use crate::{AnchoredPath, FileId, Vfs, VfsPath};\n \n /// A set of [`VfsPath`]s identified by [`FileId`]s.\n #[derive(Default, Clone, Eq, PartialEq)]\n pub struct FileSet {\n     files: FxHashMap<VfsPath, FileId>,\n-    paths: NoHashHashMap<FileId, VfsPath>,\n+    paths: IntMap<FileId, VfsPath>,\n }\n \n impl FileSet {"}, {"sha": "ff8a2b967338995741f2de11849aa31204a1c58d", "filename": "crates/vfs/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fvfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/crates%2Fvfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Flib.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -62,7 +62,8 @@ pub use paths::{AbsPath, AbsPathBuf};\n #[derive(Copy, Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]\n pub struct FileId(pub u32);\n \n-impl stdx::hash::NoHashHashable for FileId {}\n+/// safe because `FileId` is a newtype of `u32`\n+impl nohash_hasher::IsEnabled for FileId {}\n \n /// Storage for all files read by rust-analyzer.\n ///"}, {"sha": "019ad3a53ba0e7c5376eac96e873f59b4595cedc", "filename": "lib/line-index/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/lib%2Fline-index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/lib%2Fline-index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fline-index%2FCargo.toml?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -0,0 +1,11 @@\n+[package]\n+name = \"line-index\"\n+version = \"0.1.0-pre.1\"\n+description = \"Maps flat `TextSize` offsets to/from `(line, column)` representation.\"\n+license = \"MIT OR Apache-2.0\"\n+repository = \"https://github.com/rust-lang/rust-analyzer/tree/master/lib/line-index\"\n+edition = \"2021\"\n+\n+[dependencies]\n+text-size.workspace = true\n+nohash-hasher.workspace = true"}, {"sha": "ad67d3f246eca62dd9b39c1b777195dea3149f2a", "filename": "lib/line-index/src/lib.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/lib%2Fline-index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/lib%2Fline-index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fline-index%2Fsrc%2Flib.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -0,0 +1,237 @@\n+//! See [`LineIndex`].\n+\n+#![deny(missing_debug_implementations, missing_docs, rust_2018_idioms)]\n+\n+#[cfg(test)]\n+mod tests;\n+\n+use nohash_hasher::IntMap;\n+\n+pub use text_size::{TextRange, TextSize};\n+\n+/// `(line, column)` information in the native, UTF-8 encoding.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct LineCol {\n+    /// Zero-based.\n+    pub line: u32,\n+    /// Zero-based UTF-8 offset.\n+    pub col: u32,\n+}\n+\n+/// A kind of wide character encoding.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+#[non_exhaustive]\n+pub enum WideEncoding {\n+    /// UTF-16.\n+    Utf16,\n+    /// UTF-32.\n+    Utf32,\n+}\n+\n+impl WideEncoding {\n+    /// Returns the number of code units it takes to encode `text` in this encoding.\n+    pub fn measure(&self, text: &str) -> usize {\n+        match self {\n+            WideEncoding::Utf16 => text.encode_utf16().count(),\n+            WideEncoding::Utf32 => text.chars().count(),\n+        }\n+    }\n+}\n+\n+/// `(line, column)` information in wide encodings.\n+///\n+/// See [`WideEncoding`] for the kinds of wide encodings available.\n+//\n+// Deliberately not a generic type and different from `LineCol`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct WideLineCol {\n+    /// Zero-based.\n+    pub line: u32,\n+    /// Zero-based.\n+    pub col: u32,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+struct WideChar {\n+    /// Start offset of a character inside a line, zero-based.\n+    start: TextSize,\n+    /// End offset of a character inside a line, zero-based.\n+    end: TextSize,\n+}\n+\n+impl WideChar {\n+    /// Returns the length in 8-bit UTF-8 code units.\n+    fn len(&self) -> TextSize {\n+        self.end - self.start\n+    }\n+\n+    /// Returns the length in UTF-16 or UTF-32 code units.\n+    fn wide_len(&self, enc: WideEncoding) -> u32 {\n+        match enc {\n+            WideEncoding::Utf16 => {\n+                if self.len() == TextSize::from(4) {\n+                    2\n+                } else {\n+                    1\n+                }\n+            }\n+            WideEncoding::Utf32 => 1,\n+        }\n+    }\n+}\n+\n+/// Maps flat [`TextSize`] offsets to/from `(line, column)` representation.\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct LineIndex {\n+    /// Offset the beginning of each line (except the first, which always has offset 0).\n+    newlines: Box<[TextSize]>,\n+    /// List of non-ASCII characters on each line.\n+    line_wide_chars: IntMap<u32, Box<[WideChar]>>,\n+    /// The length of the entire text.\n+    len: TextSize,\n+}\n+\n+impl LineIndex {\n+    /// Returns a `LineIndex` for the `text`.\n+    pub fn new(text: &str) -> LineIndex {\n+        let mut newlines = Vec::<TextSize>::with_capacity(16);\n+        let mut line_wide_chars = IntMap::<u32, Box<[WideChar]>>::default();\n+\n+        let mut wide_chars = Vec::<WideChar>::new();\n+        let mut cur_row = TextSize::from(0);\n+        let mut cur_col = TextSize::from(0);\n+        let mut line = 0u32;\n+\n+        for c in text.chars() {\n+            let c_len = TextSize::of(c);\n+            cur_row += c_len;\n+            if c == '\\n' {\n+                newlines.push(cur_row);\n+\n+                // Save any wide characters seen in the previous line\n+                if !wide_chars.is_empty() {\n+                    let cs = std::mem::take(&mut wide_chars).into_boxed_slice();\n+                    line_wide_chars.insert(line, cs);\n+                }\n+\n+                // Prepare for processing the next line\n+                cur_col = TextSize::from(0);\n+                line += 1;\n+                continue;\n+            }\n+\n+            if !c.is_ascii() {\n+                wide_chars.push(WideChar { start: cur_col, end: cur_col + c_len });\n+            }\n+\n+            cur_col += c_len;\n+        }\n+\n+        // Save any wide characters seen in the last line\n+        if !wide_chars.is_empty() {\n+            line_wide_chars.insert(line, wide_chars.into_boxed_slice());\n+        }\n+\n+        LineIndex {\n+            newlines: newlines.into_boxed_slice(),\n+            line_wide_chars,\n+            len: TextSize::of(text),\n+        }\n+    }\n+\n+    /// Transforms the `TextSize` into a `LineCol`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If the offset is invalid. See [`Self::try_line_col`].\n+    pub fn line_col(&self, offset: TextSize) -> LineCol {\n+        self.try_line_col(offset).expect(\"invalid offset\")\n+    }\n+\n+    /// Transforms the `TextSize` into a `LineCol`.\n+    ///\n+    /// Returns `None` if the `offset` was invalid, e.g. if it extends past the end of the text or\n+    /// points to the middle of a multi-byte character.\n+    pub fn try_line_col(&self, offset: TextSize) -> Option<LineCol> {\n+        if offset > self.len {\n+            return None;\n+        }\n+        let line = self.newlines.partition_point(|&it| it <= offset);\n+        let start = self.start_offset(line)?;\n+        let col = offset - start;\n+        let ret = LineCol { line: line as u32, col: col.into() };\n+        self.line_wide_chars\n+            .get(&ret.line)\n+            .into_iter()\n+            .flat_map(|it| it.iter())\n+            .all(|it| col <= it.start || it.end <= col)\n+            .then_some(ret)\n+    }\n+\n+    /// Transforms the `LineCol` into a `TextSize`.\n+    pub fn offset(&self, line_col: LineCol) -> Option<TextSize> {\n+        self.start_offset(line_col.line as usize).map(|start| start + TextSize::from(line_col.col))\n+    }\n+\n+    fn start_offset(&self, line: usize) -> Option<TextSize> {\n+        match line.checked_sub(1) {\n+            None => Some(TextSize::from(0)),\n+            Some(it) => self.newlines.get(it).copied(),\n+        }\n+    }\n+\n+    /// Transforms the `LineCol` with the given `WideEncoding` into a `WideLineCol`.\n+    pub fn to_wide(&self, enc: WideEncoding, line_col: LineCol) -> Option<WideLineCol> {\n+        let mut col = line_col.col;\n+        if let Some(wide_chars) = self.line_wide_chars.get(&line_col.line) {\n+            for c in wide_chars.iter() {\n+                if u32::from(c.end) <= line_col.col {\n+                    col = col.checked_sub(u32::from(c.len()) - c.wide_len(enc))?;\n+                } else {\n+                    // From here on, all utf16 characters come *after* the character we are mapping,\n+                    // so we don't need to take them into account\n+                    break;\n+                }\n+            }\n+        }\n+        Some(WideLineCol { line: line_col.line, col })\n+    }\n+\n+    /// Transforms the `WideLineCol` with the given `WideEncoding` into a `LineCol`.\n+    pub fn to_utf8(&self, enc: WideEncoding, line_col: WideLineCol) -> Option<LineCol> {\n+        let mut col = line_col.col;\n+        if let Some(wide_chars) = self.line_wide_chars.get(&line_col.line) {\n+            for c in wide_chars.iter() {\n+                if col > u32::from(c.start) {\n+                    col = col.checked_add(u32::from(c.len()) - c.wide_len(enc))?;\n+                } else {\n+                    // From here on, all utf16 characters come *after* the character we are mapping,\n+                    // so we don't need to take them into account\n+                    break;\n+                }\n+            }\n+        }\n+        Some(LineCol { line: line_col.line, col })\n+    }\n+\n+    /// Given a range [start, end), returns a sorted iterator of non-empty ranges [start, x1), [x1,\n+    /// x2), ..., [xn, end) where all the xi, which are positions of newlines, are inside the range\n+    /// [start, end).\n+    pub fn lines(&self, range: TextRange) -> impl Iterator<Item = TextRange> + '_ {\n+        let lo = self.newlines.partition_point(|&it| it < range.start());\n+        let hi = self.newlines.partition_point(|&it| it <= range.end());\n+        let all = std::iter::once(range.start())\n+            .chain(self.newlines[lo..hi].iter().copied())\n+            .chain(std::iter::once(range.end()));\n+\n+        all.clone()\n+            .zip(all.skip(1))\n+            .map(|(lo, hi)| TextRange::new(lo, hi))\n+            .filter(|it| !it.is_empty())\n+    }\n+\n+    /// Returns the length of the original text.\n+    pub fn len(&self) -> TextSize {\n+        self.len\n+    }\n+}"}, {"sha": "31c01c20ee36fb8bcf326c7e3b73c8f3083f1eae", "filename": "lib/line-index/src/tests.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/lib%2Fline-index%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/lib%2Fline-index%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fline-index%2Fsrc%2Ftests.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -0,0 +1,11 @@\n+use super::LineIndex;\n+\n+#[test]\n+fn test_empty_index() {\n+    let col_index = LineIndex::new(\n+        \"\n+const C: char = 'x';\n+\",\n+    );\n+    assert_eq!(col_index.line_wide_chars.len(), 0);\n+}"}, {"sha": "ce1c0bc6f143d104c492753536b08c1ec39e7b34", "filename": "lib/line-index/tests/it.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/260e99614061943d68b0d78dfa27feec9a9f996f/lib%2Fline-index%2Ftests%2Fit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e99614061943d68b0d78dfa27feec9a9f996f/lib%2Fline-index%2Ftests%2Fit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fline-index%2Ftests%2Fit.rs?ref=260e99614061943d68b0d78dfa27feec9a9f996f", "patch": "@@ -0,0 +1,62 @@\n+use line_index::{LineCol, LineIndex, TextRange};\n+\n+#[test]\n+fn test_line_index() {\n+    let text = \"hello\\nworld\";\n+    let table = [\n+        (00, 0, 0),\n+        (01, 0, 1),\n+        (05, 0, 5),\n+        (06, 1, 0),\n+        (07, 1, 1),\n+        (08, 1, 2),\n+        (10, 1, 4),\n+        (11, 1, 5),\n+    ];\n+\n+    let index = LineIndex::new(text);\n+    for (offset, line, col) in table {\n+        assert_eq!(index.line_col(offset.into()), LineCol { line, col });\n+    }\n+\n+    let text = \"\\nhello\\nworld\";\n+    let table = [(0, 0, 0), (1, 1, 0), (2, 1, 1), (6, 1, 5), (7, 2, 0)];\n+    let index = LineIndex::new(text);\n+    for (offset, line, col) in table {\n+        assert_eq!(index.line_col(offset.into()), LineCol { line, col });\n+    }\n+}\n+\n+#[test]\n+fn test_char_len() {\n+    assert_eq!('\u30e1'.len_utf8(), 3);\n+    assert_eq!('\u30e1'.len_utf16(), 1);\n+}\n+\n+#[test]\n+fn test_splitlines() {\n+    fn r(lo: u32, hi: u32) -> TextRange {\n+        TextRange::new(lo.into(), hi.into())\n+    }\n+\n+    let text = \"a\\nbb\\nccc\\n\";\n+    let line_index = LineIndex::new(text);\n+\n+    let actual = line_index.lines(r(0, 9)).collect::<Vec<_>>();\n+    let expected = vec![r(0, 2), r(2, 5), r(5, 9)];\n+    assert_eq!(actual, expected);\n+\n+    let text = \"\";\n+    let line_index = LineIndex::new(text);\n+\n+    let actual = line_index.lines(r(0, 0)).collect::<Vec<_>>();\n+    let expected = vec![];\n+    assert_eq!(actual, expected);\n+\n+    let text = \"\\n\";\n+    let line_index = LineIndex::new(text);\n+\n+    let actual = line_index.lines(r(0, 1)).collect::<Vec<_>>();\n+    let expected = vec![r(0, 1)];\n+    assert_eq!(actual, expected)\n+}"}]}