{"sha": "e9ac7489b5032b4a922a0df1dd611471260b31ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5YWM3NDg5YjUwMzJiNGE5MjJhMGRmMWRkNjExNDcxMjYwYjMxZWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-29T02:31:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-29T12:27:43Z"}, "message": "Refactor representation of borrowing so that it is tracked by fn_ctxt and not infer", "tree": {"sha": "ebd94394b4afe40cf3e1b3151ac0dc21e7f81127", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebd94394b4afe40cf3e1b3151ac0dc21e7f81127"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9ac7489b5032b4a922a0df1dd611471260b31ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9ac7489b5032b4a922a0df1dd611471260b31ef", "html_url": "https://github.com/rust-lang/rust/commit/e9ac7489b5032b4a922a0df1dd611471260b31ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9ac7489b5032b4a922a0df1dd611471260b31ef/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e398a72c42856de4a047a463e721a18223d67e52", "url": "https://api.github.com/repos/rust-lang/rust/commits/e398a72c42856de4a047a463e721a18223d67e52", "html_url": "https://github.com/rust-lang/rust/commit/e398a72c42856de4a047a463e721a18223d67e52"}], "stats": {"total": 1000, "additions": 514, "deletions": 486}, "files": [{"sha": "2c055e497ddd037175ae7a7e31ba75105456f99e", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=e9ac7489b5032b4a922a0df1dd611471260b31ef", "patch": "@@ -106,6 +106,7 @@ fn run_tests_console(opts: test_opts,\n                      tests: ~[test_desc]) -> bool {\n \n     fn callback(event: testevent, st: console_test_state) {\n+        debug!(\"callback(event=%?)\", event);\n         match event {\n           te_filtered(filtered_tests) => {\n             st.total = vec::len(filtered_tests);"}, {"sha": "f6e2e4ac6f54ff045d626455b6bf90c20f397062", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 220, "deletions": 192, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=e9ac7489b5032b4a922a0df1dd611471260b31ef", "patch": "@@ -75,6 +75,7 @@ import rscope::{in_binding_rscope, region_scope, type_rscope,\n                 bound_self_region};\n import syntax::ast::ty_i;\n import typeck::infer::{resolve_type, force_tvar};\n+import result::{Result, Ok, Err};\n \n import std::map::{str_hash, uint_hash};\n \n@@ -85,6 +86,24 @@ type self_info = {\n     explicit_self: ast::self_ty\n };\n \n+/// Fields that are part of a `fn_ctxt` which are inherited by\n+/// closures defined within the function.  For example:\n+///\n+///     fn foo() {\n+///         do bar() { ... }\n+///     }\n+///\n+/// Here, the function `foo()` and the closure passed to\n+/// `bar()` will each have their own `fn_ctxt`, but they will\n+/// share the inherited fields.\n+struct inherited {\n+    infcx: infer::infer_ctxt;\n+    locals: hashmap<ast::node_id, tv_vid>;\n+    node_types: hashmap<ast::node_id, ty::t>;\n+    node_type_substs: hashmap<ast::node_id, ty::substs>;\n+    borrowings: hashmap<ast::node_id, ty::borrow>;\n+}\n+\n struct fn_ctxt {\n     // var_bindings, locals and next_var_id are shared\n     // with any nested functions that capture the environment\n@@ -94,8 +113,6 @@ struct fn_ctxt {\n     // Used by loop bodies that return from the outer function\n     indirect_ret_ty: Option<ty::t>;\n     purity: ast::purity;\n-    infcx: infer::infer_ctxt;\n-    locals: hashmap<ast::node_id, tv_vid>;\n \n     // Sometimes we generate region pointers where the precise region\n     // to use is not known. For example, an expression like `&x.f`\n@@ -114,12 +131,21 @@ struct fn_ctxt {\n \n     in_scope_regions: isr_alist;\n \n-    node_types: hashmap<ast::node_id, ty::t>;\n-    node_type_substs: hashmap<ast::node_id, ty::substs>;\n+    inh: @inherited;\n \n     ccx: @crate_ctxt;\n }\n \n+fn blank_inherited(ccx: @crate_ctxt) -> @inherited {\n+    @inherited {\n+        infcx: infer::new_infer_ctxt(ccx.tcx),\n+        locals: int_hash(),\n+        node_types: map::int_hash(),\n+        node_type_substs: map::int_hash(),\n+        borrowings: map::int_hash()\n+    }\n+}\n+\n // Used by check_const and check_enum_variants\n fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n                  region_bnd: ast::node_id) -> @fn_ctxt {\n@@ -130,12 +156,9 @@ fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n         ret_ty: rty,\n         indirect_ret_ty: None,\n         purity: ast::pure_fn,\n-        infcx: infer::new_infer_ctxt(ccx.tcx),\n-        locals: int_hash(),\n         mut region_lb: region_bnd,\n         in_scope_regions: @nil,\n-        node_types: map::int_hash(),\n-        node_type_substs: map::int_hash(),\n+        inh: blank_inherited(ccx),\n         ccx: ccx\n     }\n }\n@@ -220,23 +243,16 @@ fn check_fn(ccx: @crate_ctxt,\n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n     let fcx: @fn_ctxt = {\n-        let {infcx, locals, purity, node_types, node_type_substs} =\n-        match old_fcx {\n-          None => {\n-            {infcx: infer::new_infer_ctxt(tcx),\n-             locals: int_hash(),\n-             purity: fn_ty.purity,\n-             node_types: map::int_hash(),\n-             node_type_substs: map::int_hash()}\n-          }\n-          Some(fcx) => {\n-            {infcx: fcx.infcx,\n-             locals: fcx.locals,\n-             purity: ty::determine_inherited_purity(fcx.purity, fn_ty.purity,\n-                                                    fn_ty.proto),\n-             node_types: fcx.node_types,\n-             node_type_substs: fcx.node_type_substs}\n-          }\n+        let (purity, inherited) = match old_fcx {\n+            None => {\n+                (fn_ty.purity,\n+                 blank_inherited(ccx))\n+            }\n+            Some(fcx) => {\n+                (ty::determine_inherited_purity(fcx.purity, fn_ty.purity,\n+                                                fn_ty.proto),\n+                 fcx.inh)\n+            }\n         };\n \n         let indirect_ret_ty = if indirect_ret {\n@@ -252,12 +268,9 @@ fn check_fn(ccx: @crate_ctxt,\n             ret_ty: ret_ty,\n             indirect_ret_ty: indirect_ret_ty,\n             purity: purity,\n-            infcx: infcx,\n-            locals: locals,\n             mut region_lb: body.node.id,\n             in_scope_regions: isr,\n-            node_types: node_types,\n-            node_type_substs: node_type_substs,\n+            inh: inherited,\n             ccx: ccx\n         }\n     };\n@@ -316,14 +329,14 @@ fn check_fn(ccx: @crate_ctxt,\n \n         let assign = fn@(span: span, nid: ast::node_id,\n                          ty_opt: Option<ty::t>) {\n-            let var_id = fcx.infcx.next_ty_var_id();\n-            fcx.locals.insert(nid, var_id);\n+            let var_id = fcx.infcx().next_ty_var_id();\n+            fcx.inh.locals.insert(nid, var_id);\n             match ty_opt {\n-              None => {/* nothing to do */ }\n-              Some(typ) => {\n-                infer::mk_eqty(fcx.infcx, false, span,\n-                               ty::mk_var(tcx, var_id), typ);\n-              }\n+                None => {/* nothing to do */ }\n+                Some(typ) => {\n+                    infer::mk_eqty(fcx.infcx(), false, span,\n+                                   ty::mk_var(tcx, var_id), typ);\n+                }\n             }\n         };\n \n@@ -332,15 +345,15 @@ fn check_fn(ccx: @crate_ctxt,\n             assign(info.explicit_self.span,\n                    info.self_id, Some(info.self_ty));\n             debug!(\"self is assigned to %s\",\n-                   fcx.locals.get(info.self_id).to_str());\n+                   fcx.inh.locals.get(info.self_id).to_str());\n         }\n \n         // Add formal parameters.\n         do vec::iter2(arg_tys, decl.inputs) |arg_ty, input| {\n             assign(input.ty.span, input.id, Some(arg_ty));\n             debug!(\"Argument %s is assigned to %s\",\n                    tcx.sess.str_of(input.ident),\n-                   fcx.locals.get(input.id).to_str());\n+                   fcx.inh.locals.get(input.id).to_str());\n         }\n \n         // Add explicitly-declared locals.\n@@ -353,7 +366,7 @@ fn check_fn(ccx: @crate_ctxt,\n             assign(local.span, local.node.id, o_ty);\n             debug!(\"Local variable %s is assigned to %s\",\n                    pat_to_str(local.node.pat, tcx.sess.intr()),\n-                   fcx.locals.get(local.node.id).to_str());\n+                   fcx.inh.locals.get(local.node.id).to_str());\n             visit::visit_local(local, e, v);\n         };\n \n@@ -365,7 +378,7 @@ fn check_fn(ccx: @crate_ctxt,\n                 assign(p.span, p.id, None);\n                 debug!(\"Pattern binding %s is assigned to %s\",\n                        tcx.sess.str_of(path.idents[0]),\n-                       fcx.locals.get(p.id).to_str());\n+                       fcx.inh.locals.get(p.id).to_str());\n               }\n               _ => {}\n             }\n@@ -540,6 +553,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n }\n \n impl @fn_ctxt: ast_conv {\n+    fn infcx() -> infer::infer_ctxt { self.inh.infcx }\n     fn tcx() -> ty::ctxt { self.ccx.tcx }\n     fn ccx() -> @crate_ctxt { self.ccx }\n \n@@ -548,13 +562,13 @@ impl @fn_ctxt: ast_conv {\n     }\n \n     fn ty_infer(_span: span) -> ty::t {\n-        self.infcx.next_ty_var()\n+        self.infcx().next_ty_var()\n     }\n }\n \n impl @fn_ctxt: region_scope {\n     fn anon_region(span: span) -> Result<ty::region, ~str> {\n-        result::Ok(self.infcx.next_region_var_nb(span))\n+        result::Ok(self.infcx().next_region_var_nb(span))\n     }\n     fn named_region(span: span, id: ast::ident) -> Result<ty::region, ~str> {\n         do empty_rscope.named_region(span, id).chain_err |_e| {\n@@ -580,11 +594,11 @@ impl @fn_ctxt {\n     fn write_ty(node_id: ast::node_id, ty: ty::t) {\n         debug!(\"write_ty(%d, %s) in fcx %s\",\n                node_id, ty_to_str(self.tcx(), ty), self.tag());\n-        self.node_types.insert(node_id, ty);\n+        self.inh.node_types.insert(node_id, ty);\n     }\n     fn write_substs(node_id: ast::node_id, +substs: ty::substs) {\n         if !ty::substs_is_noop(&substs) {\n-            self.node_type_substs.insert(node_id, substs);\n+            self.inh.node_type_substs.insert(node_id, substs);\n         }\n     }\n     fn write_ty_substs(node_id: ast::node_id, ty: ty::t,\n@@ -605,87 +619,97 @@ impl @fn_ctxt {\n     }\n \n     fn expr_ty(ex: @ast::expr) -> ty::t {\n-        match self.node_types.find(ex.id) {\n-          Some(t) => t,\n-          None => {\n-            self.tcx().sess.bug(\n-                fmt!(\"no type for expr %d (%s) in fcx %s\",\n-                     ex.id, expr_to_str(ex, self.ccx.tcx.sess.intr()),\n-                     self.tag()));\n-          }\n+        match self.inh.node_types.find(ex.id) {\n+            Some(t) => t,\n+            None => {\n+                self.tcx().sess.bug(\n+                    fmt!(\"no type for expr %d (%s) in fcx %s\",\n+                         ex.id, expr_to_str(ex, self.ccx.tcx.sess.intr()),\n+                         self.tag()));\n+            }\n         }\n     }\n     fn node_ty(id: ast::node_id) -> ty::t {\n-        match self.node_types.find(id) {\n-          Some(t) => t,\n-          None => {\n-            self.tcx().sess.bug(\n-                fmt!(\"no type for node %d: %s in fcx %s\",\n-                     id, ast_map::node_id_to_str(\n-                         self.tcx().items, id,\n-                         self.tcx().sess.parse_sess.interner),\n-                     self.tag()));\n-          }\n+        match self.inh.node_types.find(id) {\n+            Some(t) => t,\n+            None => {\n+                self.tcx().sess.bug(\n+                    fmt!(\"no type for node %d: %s in fcx %s\",\n+                         id, ast_map::node_id_to_str(\n+                             self.tcx().items, id,\n+                             self.tcx().sess.parse_sess.interner),\n+                         self.tag()));\n+            }\n         }\n     }\n     fn node_ty_substs(id: ast::node_id) -> ty::substs {\n-        match self.node_type_substs.find(id) {\n-          Some(ts) => ts,\n-          None => {\n-            self.tcx().sess.bug(\n-                fmt!(\"no type substs for node %d: %s in fcx %s\",\n-                     id, ast_map::node_id_to_str(\n-                         self.tcx().items, id,\n-                         self.tcx().sess.parse_sess.interner),\n-                     self.tag()));\n-          }\n+        match self.inh.node_type_substs.find(id) {\n+            Some(ts) => ts,\n+            None => {\n+                self.tcx().sess.bug(\n+                    fmt!(\"no type substs for node %d: %s in fcx %s\",\n+                         id, ast_map::node_id_to_str(\n+                             self.tcx().items, id,\n+                             self.tcx().sess.parse_sess.interner),\n+                         self.tag()));\n+            }\n         }\n     }\n     fn opt_node_ty_substs(id: ast::node_id) -> Option<ty::substs> {\n-        self.node_type_substs.find(id)\n+        self.inh.node_type_substs.find(id)\n     }\n \n     fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n                                err: &ty::type_err) {\n         self.ccx.tcx.sess.span_err(\n             sp,\n             fmt!(\"mismatched types: expected `%s` but found `%s` (%s)\",\n-                 self.infcx.ty_to_str(e),\n-                 self.infcx.ty_to_str(a),\n+                 self.infcx().ty_to_str(e),\n+                 self.infcx().ty_to_str(a),\n                  ty::type_err_to_str(self.ccx.tcx, err)));\n     }\n \n     fn mk_subty(a_is_expected: bool, span: span,\n                 sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n-        infer::mk_subty(self.infcx, a_is_expected, span, sub, sup)\n+        infer::mk_subty(self.infcx(), a_is_expected, span, sub, sup)\n     }\n \n     fn can_mk_subty(sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n-        infer::can_mk_subty(self.infcx, sub, sup)\n+        infer::can_mk_subty(self.infcx(), sub, sup)\n     }\n \n     fn mk_assignty(expr: @ast::expr, borrow_lb: ast::node_id,\n                    sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n-        let anmnt = &{expr_id: expr.id, span: expr.span,\n-                      borrow_lb: borrow_lb};\n-        infer::mk_assignty(self.infcx, anmnt, sub, sup)\n+        match infer::mk_assignty(self.infcx(), false, expr.span, sub, sup) {\n+            Ok(None) => result::Ok(()),\n+            Err(e) => result::Err(e),\n+            Ok(Some(borrow)) => {\n+                match self.mk_subr(true, expr.span,\n+                                   ty::re_scope(borrow_lb), borrow.region) {\n+                    Err(e) => Err(e),\n+                    Ok(()) => {\n+                        debug!(\"inserting borrowing of expr %?: %?\",\n+                               expr.id, borrow);\n+                        self.inh.borrowings.insert(expr.id, borrow);\n+                        Ok(())\n+                    }\n+                }\n+            }\n+        }\n     }\n \n-    fn can_mk_assignty(expr: @ast::expr, borrow_lb: ast::node_id,\n-                       sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n-        let anmnt = &{expr_id: expr.id, span: expr.span,\n-                      borrow_lb: borrow_lb};\n-        infer::can_mk_assignty(self.infcx, anmnt, sub, sup)\n+    fn can_mk_assignty(sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n+        infer::can_mk_assignty(self.infcx(), sub, sup)\n     }\n \n     fn mk_eqty(a_is_expected: bool, span: span,\n                sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n-        infer::mk_eqty(self.infcx, a_is_expected, span, sub, sup)\n+        infer::mk_eqty(self.infcx(), a_is_expected, span, sub, sup)\n     }\n \n     fn mk_subr(a_is_expected: bool, span: span,\n                sub: ty::region, sup: ty::region) -> Result<(), ty::type_err> {\n-        infer::mk_subr(self.infcx, a_is_expected, span, sub, sup)\n+        infer::mk_subr(self.infcx(), a_is_expected, span, sub, sup)\n     }\n \n     fn require_unsafe(sp: span, op: ~str) {\n@@ -712,8 +736,7 @@ impl @fn_ctxt {\n         -> Option<ty::region>\n     {\n         rp.map(\n-            |_rp| self.infcx.next_region_var_with_lb(span,\n-                                                     lower_bound))\n+            |_rp| self.infcx().next_region_var_with_lb(span, lower_bound))\n     }\n }\n \n@@ -767,7 +790,7 @@ fn check_lit(fcx: @fn_ctxt, lit: @ast::lit) -> ty::t {\n       ast::lit_int_unsuffixed(_) => {\n         // An unsuffixed integer literal could have any integral type,\n         // so we create an integral type variable for it.\n-        ty::mk_var_integral(tcx, fcx.infcx.next_ty_var_integral_id())\n+        ty::mk_var_integral(tcx, fcx.infcx().next_ty_var_integral_id())\n       }\n       ast::lit_float(_, t) => ty::mk_mach_float(tcx, t),\n       ast::lit_nil => ty::mk_nil(tcx),\n@@ -836,11 +859,11 @@ fn impl_self_ty(fcx: @fn_ctxt,\n     };\n \n     let self_r = if region_param.is_some() || require_rp {\n-        Some(fcx.infcx.next_region_var(expr.span, expr.id))\n+        Some(fcx.infcx().next_region_var(expr.span, expr.id))\n     } else {\n         None\n     };\n-    let tps = fcx.infcx.next_ty_vars(n_tps);\n+    let tps = fcx.infcx().next_ty_vars(n_tps);\n \n     let substs = {self_r: self_r, self_ty: None, tps: tps};\n     let substd_ty = ty::subst(tcx, &substs, raw_ty);\n@@ -884,7 +907,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // type with fresh region variables.\n \n         debug!(\"check_call_inner: before universal quant., in_fty=%s\",\n-               fcx.infcx.ty_to_str(in_fty));\n+               fcx.infcx().ty_to_str(in_fty));\n \n         // This is subtle: we expect `fty` to be a function type, which\n         // normally introduce a level of binding.  In this case, we want to\n@@ -895,8 +918,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               ty::ty_fn(ref fn_ty) => {\n                 replace_bound_regions_in_fn_ty(\n                     fcx.ccx.tcx, @nil, None, fn_ty,\n-                    |_br| fcx.infcx.next_region_var(sp,\n-                                                    call_expr_id)).fn_ty\n+                    |_br| fcx.infcx().next_region_var(sp,\n+                                                      call_expr_id)).fn_ty\n               }\n               _ => {\n                 // I would like to make this span_err, but it's\n@@ -905,13 +928,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 fcx.ccx.tcx.sess.span_fatal(sp, ~\"mismatched types: \\\n                                             expected function or foreign \\\n                                             function but found \"\n-                                            + fcx.infcx.ty_to_str(in_fty));\n+                                            + fcx.infcx().ty_to_str(in_fty));\n               }\n             };\n \n         let fty = ty::mk_fn(fcx.tcx(), fn_ty);\n         debug!(\"check_call_inner: after universal quant., fty=%s\",\n-               fcx.infcx.ty_to_str(fty));\n+               fcx.infcx().ty_to_str(fty));\n \n         let supplied_arg_count = vec::len(args);\n \n@@ -935,7 +958,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                          } else {\n                              ~\"s were\"\n                          }));\n-            fcx.infcx.next_ty_vars(supplied_arg_count)\n+            fcx.infcx().next_ty_vars(supplied_arg_count)\n         };\n \n         // Check the arguments.\n@@ -1035,18 +1058,18 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                        _sp: span) -> bool {\n         let (if_t, if_bot) =\n             match elsopt {\n-              Some(els) => {\n-                let if_t = fcx.infcx.next_ty_var();\n-                let thn_bot = check_block(fcx, thn);\n-                let thn_t = fcx.node_ty(thn.node.id);\n-                demand::suptype(fcx, thn.span, if_t, thn_t);\n-                let els_bot = check_expr_with(fcx, els, if_t);\n-                (if_t, thn_bot & els_bot)\n-              }\n-              None => {\n-                check_block_no_value(fcx, thn);\n-                (ty::mk_nil(fcx.ccx.tcx), false)\n-              }\n+                Some(els) => {\n+                    let if_t = fcx.infcx().next_ty_var();\n+                    let thn_bot = check_block(fcx, thn);\n+                    let thn_t = fcx.node_ty(thn.node.id);\n+                    demand::suptype(fcx, thn.span, if_t, thn_t);\n+                    let els_bot = check_expr_with(fcx, els, if_t);\n+                    (if_t, thn_bot & els_bot)\n+                }\n+                None => {\n+                    check_block_no_value(fcx, thn);\n+                    (ty::mk_nil(fcx.ccx.tcx), false)\n+                }\n             };\n         fcx.write_ty(id, if_t);\n         return if_bot;\n@@ -1092,7 +1115,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n \n           (_, _) if ty::is_binopable(tcx, lhs_t, op) => {\n-            let tvar = fcx.infcx.next_ty_var();\n+            let tvar = fcx.infcx().next_ty_var();\n             demand::suptype(fcx, expr.span, tvar, lhs_t);\n             let rhs_bot = check_expr_with(fcx, rhs, tvar);\n             let rhs_t = match op {\n@@ -1139,7 +1162,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         tcx.sess.span_err(\n             ex.span, ~\"binary operation \" + ast_util::binop_to_str(op) +\n             ~\" cannot be applied to type `\" +\n-            fcx.infcx.ty_to_str(lhs_resolved_t) +\n+            fcx.infcx().ty_to_str(lhs_resolved_t) +\n             ~\"`\");\n \n         // If the or operator is used it might be that the user forgot to\n@@ -1165,7 +1188,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           _ => {\n             fcx.ccx.tcx.sess.span_err(\n                 ex.span, fmt!(\"cannot apply unary operator `%s` to type `%s`\",\n-                              op_str, fcx.infcx.ty_to_str(rhs_t)));\n+                              op_str, fcx.infcx().ty_to_str(rhs_t)));\n             rhs_t\n           }\n         }\n@@ -1179,13 +1202,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                 unpack: fn(ty::sty) -> Option<O>)\n         -> Option<O> {\n         match expected {\n-          Some(t) => {\n-            match resolve_type(fcx.infcx, t, force_tvar) {\n-              result::Ok(t) => unpack(ty::get(t).struct),\n-              _ => None\n+            Some(t) => {\n+                match resolve_type(fcx.infcx(), t, force_tvar) {\n+                    Ok(t) => unpack(ty::get(t).struct),\n+                    _ => None\n+                }\n             }\n-          }\n-          _ => None\n+            _ => None\n         }\n     }\n \n@@ -1249,7 +1272,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let fty = ty::mk_fn(tcx, fn_ty);\n \n         debug!(\"check_expr_fn_with_unifier %s fty=%s\",\n-               expr_to_str(expr, tcx.sess.intr()), fcx.infcx.ty_to_str(fty));\n+               expr_to_str(expr, tcx.sess.intr()),\n+               fcx.infcx().ty_to_str(fty));\n \n         fcx.write_ty(expr.id, fty);\n \n@@ -1326,29 +1350,32 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                       expr.id, field, expr_t, tps,\n                                       is_self_ref);\n             match lkup.method() {\n-              Some(entry) => {\n-                fcx.ccx.method_map.insert(expr.id, entry);\n-\n-                // If we have resolved to a method but this is not in\n-                // a callee position, error\n-                if !is_callee {\n-                    tcx.sess.span_err(\n-                        expr.span,\n-                        ~\"attempted to take value of method \\\n-                         (try writing an anonymous function)\");\n+                Some(entry) => {\n+                    fcx.ccx.method_map.insert(expr.id, entry);\n+\n+                    // If we have resolved to a method but this is not in\n+                    // a callee position, error\n+                    if !is_callee {\n+                        tcx.sess.span_err(\n+                            expr.span,\n+                            ~\"attempted to take value of method \\\n+                              (try writing an anonymous function)\");\n+                    }\n+                }\n+                None => {\n+                    let t_err =\n+                        fcx.infcx().resolve_type_vars_if_possible(expr_t);\n+                    let msg =\n+                        fmt!(\n+                            \"attempted access of field `%s` on type `%s`, \\\n+                             but no public field or method with that name \\\n+                             was found\",\n+                            tcx.sess.str_of(field),\n+                            fcx.infcx().ty_to_str(t_err));\n+                    tcx.sess.span_err(expr.span, msg);\n+                    // NB: Add bogus type to allow typechecking to continue\n+                    fcx.write_ty(expr.id, fcx.infcx().next_ty_var());\n                 }\n-              }\n-              None => {\n-                let t_err = fcx.infcx.resolve_type_vars_if_possible(expr_t);\n-                let msg = fmt!(\"attempted access of field `%s` on type `%s`, \\\n-                                but no public field or method with that name \\\n-                                was found\",\n-                                tcx.sess.str_of(field),\n-                                fcx.infcx.ty_to_str(t_err));\n-                tcx.sess.span_err(expr.span, msg);\n-                // NB: Adding a bogus type to allow typechecking to continue\n-                fcx.write_ty(expr.id, fcx.infcx.next_ty_var());\n-              }\n             }\n         }\n         return bot;\n@@ -1367,15 +1394,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n           ast::expr_vec(args, mutbl) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vec::len(args), vst);\n-            let t: ty::t = fcx.infcx.next_ty_var();\n+            let t: ty::t = fcx.infcx().next_ty_var();\n             for args.each |e| { bot |= check_expr_with(fcx, e, t); }\n             ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt)\n           }\n           ast::expr_repeat(element, count_expr, mutbl) => {\n             let count = ty::eval_repeat_count(tcx, count_expr, expr.span);\n             fcx.write_ty(count_expr.id, ty::mk_uint(tcx));\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, count, vst);\n-            let t: ty::t = fcx.infcx.next_ty_var();\n+            let t: ty::t = fcx.infcx().next_ty_var();\n             bot |= check_expr_with(fcx, element, t);\n             ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt)\n           }\n@@ -1404,7 +1431,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_binary(ast::gt, lhs, rhs) |\n       ast::expr_binary(ast::ge, lhs, rhs) => {\n         let tcx = fcx.ccx.tcx;\n-        let tvar = fcx.infcx.next_ty_var();\n+        let tvar = fcx.infcx().next_ty_var();\n         bot |= check_expr_with(fcx, lhs, tvar);\n         bot |= check_expr_with(fcx, rhs, tvar);\n         fcx.write_ty(id, ty::mk_bool(tcx));\n@@ -1472,7 +1499,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     tcx.sess.span_err(\n                         expr.span,\n                         fmt!(\"type %s cannot be dereferenced\",\n-                             fcx.infcx.ty_to_str(oprnd_t)));\n+                             fcx.infcx().ty_to_str(oprnd_t)));\n                   }\n                 }\n               }\n@@ -1516,7 +1543,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // borrowck is charged with guaranteeing that the value whose\n         // address was taken can actually be made to live as long as\n         // it needs to live.\n-        let region = fcx.infcx.next_region_var(expr.span, expr.id);\n+        let region = fcx.infcx().next_region_var(expr.span, expr.id);\n \n         let tm = { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n         let oprnd_t = ty::mk_rptr(tcx, region, tm);\n@@ -1631,7 +1658,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 tcx.sess.span_fatal(\n                     expr.span, fmt!(\"a `loop` function's last argument \\\n                                      should return `bool`, not `%s`\",\n-                                    fcx.infcx.ty_to_str(fty.output)));\n+                                    fcx.infcx().ty_to_str(fty.output)));\n               }\n             }\n             ty::mk_fn(tcx, {output: ty::mk_nil(tcx) with fty})\n@@ -1713,8 +1740,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n \n-        debug!(\"t_1=%s\", fcx.infcx.ty_to_str(t_1));\n-        debug!(\"t_e=%s\", fcx.infcx.ty_to_str(t_e));\n+        debug!(\"t_1=%s\", fcx.infcx().ty_to_str(t_1));\n+        debug!(\"t_e=%s\", fcx.infcx().ty_to_str(t_e));\n \n         match ty::get(t_1).struct {\n           // This will be looked up later on\n@@ -1723,12 +1750,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           _ => {\n             if ty::type_is_nil(t_e) {\n                 tcx.sess.span_err(expr.span, ~\"cast from nil: \" +\n-                                  fcx.infcx.ty_to_str(t_e) + ~\" as \" +\n-                                  fcx.infcx.ty_to_str(t_1));\n+                                  fcx.infcx().ty_to_str(t_e) + ~\" as \" +\n+                                  fcx.infcx().ty_to_str(t_1));\n             } else if ty::type_is_nil(t_1) {\n                 tcx.sess.span_err(expr.span, ~\"cast to nil: \" +\n-                                  fcx.infcx.ty_to_str(t_e) + ~\" as \" +\n-                                  fcx.infcx.ty_to_str(t_1));\n+                                  fcx.infcx().ty_to_str(t_e) + ~\" as \" +\n+                                  fcx.infcx().ty_to_str(t_1));\n             }\n \n             let t_1_is_scalar = type_is_scalar(fcx, expr.span, t_1);\n@@ -1742,15 +1769,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 */\n                 tcx.sess.span_err(expr.span,\n                                   ~\"non-scalar cast: \" +\n-                                  fcx.infcx.ty_to_str(t_e) + ~\" as \" +\n-                                  fcx.infcx.ty_to_str(t_1));\n+                                  fcx.infcx().ty_to_str(t_e) + ~\" as \" +\n+                                  fcx.infcx().ty_to_str(t_1));\n             }\n           }\n         }\n         fcx.write_ty(id, t_1);\n       }\n       ast::expr_vec(args, mutbl) => {\n-        let t: ty::t = fcx.infcx.next_ty_var();\n+        let t: ty::t = fcx.infcx().next_ty_var();\n         for args.each |e| { bot |= check_expr_with(fcx, e, t); }\n         let typ = ty::mk_evec(tcx, {ty: t, mutbl: mutbl},\n                               ty::vstore_fixed(args.len()));\n@@ -1759,7 +1786,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_repeat(element, count_expr, mutbl) => {\n         let count = ty::eval_repeat_count(tcx, count_expr, expr.span);\n         fcx.write_ty(count_expr.id, ty::mk_uint(tcx));\n-        let t: ty::t = fcx.infcx.next_ty_var();\n+        let t: ty::t = fcx.infcx().next_ty_var();\n         bot |= check_expr_with(fcx, element, t);\n         let t = ty::mk_evec(tcx, {ty: t, mutbl: mutbl},\n                             ty::vstore_fixed(count));\n@@ -1890,7 +1917,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             fcx.region_var_if_parameterized(region_parameterized,\n                                             expr.span,\n                                             ty::re_scope(expr.id));\n-        let type_parameters = fcx.infcx.next_ty_vars(type_parameter_count);\n+        let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = {\n             self_r: self_region,\n             self_ty: None,\n@@ -1995,7 +2022,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               _ => {\n                 tcx.sess.span_fatal(\n                     expr.span, ~\"cannot index a value of type `\" +\n-                    fcx.infcx.ty_to_str(base_t) + ~\"`\");\n+                    fcx.infcx().ty_to_str(base_t) + ~\"`\");\n               }\n             }\n           }\n@@ -2022,7 +2049,7 @@ fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.ccx.tcx.sess.span_err(sp, ~\"mismatched types: expected \\\n                                        integral type but found `\"\n-                                  + fcx.infcx.ty_to_str(t) + ~\"`\");\n+                                  + fcx.infcx().ty_to_str(t) + ~\"`\");\n     }\n }\n \n@@ -2035,7 +2062,7 @@ fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     let mut bot = false;\n \n-    let t = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(local.node.id));\n+    let t = ty::mk_var(fcx.ccx.tcx, fcx.inh.locals.get(local.node.id));\n     fcx.write_ty(local.node.id, t);\n     match local.node.init {\n       Some(init) => {\n@@ -2282,12 +2309,13 @@ fn self_ref(fcx: @fn_ctxt, id: ast::node_id) -> bool {\n }\n \n fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> tv_vid {\n-    match fcx.locals.find(id) {\n-      Some(x) => x,\n-      _ => {\n-        fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    ~\"internal error looking up a local var\")\n-      }\n+    match fcx.inh.locals.find(id) {\n+        Some(x) => x,\n+        _ => {\n+            fcx.ccx.tcx.sess.span_fatal(\n+                sp,\n+                ~\"internal error looking up a local var\")\n+        }\n     }\n }\n \n@@ -2302,7 +2330,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n     match defn {\n       ast::def_arg(nid, _) | ast::def_local(nid, _) |\n       ast::def_self(nid) | ast::def_binding(nid, _) => {\n-        assert (fcx.locals.contains_key(nid));\n+        assert (fcx.inh.locals.contains_key(nid));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, nid));\n         return no_params(typ);\n       }\n@@ -2392,19 +2420,19 @@ fn instantiate_path(fcx: @fn_ctxt,\n     // determine values for type parameters, using the values given by\n     // the user (if any) and otherwise using fresh type variables\n     let tps = if ty_substs_len == 0u {\n-        fcx.infcx.next_ty_vars(ty_param_count)\n+        fcx.infcx().next_ty_vars(ty_param_count)\n     } else if ty_param_count == 0u {\n         fcx.ccx.tcx.sess.span_err\n             (span, ~\"this item does not take type parameters\");\n-        fcx.infcx.next_ty_vars(ty_param_count)\n+        fcx.infcx().next_ty_vars(ty_param_count)\n     } else if ty_substs_len > ty_param_count {\n         fcx.ccx.tcx.sess.span_err\n             (span, ~\"too many type parameters provided for this item\");\n-        fcx.infcx.next_ty_vars(ty_param_count)\n+        fcx.infcx().next_ty_vars(ty_param_count)\n     } else if ty_substs_len < ty_param_count {\n         fcx.ccx.tcx.sess.span_err\n             (span, ~\"not enough type parameters provided for this item\");\n-        fcx.infcx.next_ty_vars(ty_param_count)\n+        fcx.infcx().next_ty_vars(ty_param_count)\n     } else {\n         pth.types.map(|aty| fcx.to_ty(aty))\n     };\n@@ -2416,12 +2444,12 @@ fn instantiate_path(fcx: @fn_ctxt,\n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n-    match infer::resolve_type(fcx.infcx, tp, force_tvar) {\n-      result::Ok(t_s) if !ty::type_is_var(t_s) => return t_s,\n-      _ => {\n-        fcx.ccx.tcx.sess.span_fatal\n-            (sp, ~\"the type of this value must be known in this context\");\n-      }\n+    match infer::resolve_type(fcx.infcx(), tp, force_tvar) {\n+        Ok(t_s) if !ty::type_is_var(t_s) => return t_s,\n+        _ => {\n+            fcx.ccx.tcx.sess.span_fatal\n+                (sp, ~\"the type of this value must be known in this context\");\n+        }\n     }\n }\n \n@@ -2448,20 +2476,20 @@ fn type_is_c_like_enum(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n                              v: ast::vstore) -> ty::vstore {\n     match v {\n-      ast::vstore_fixed(None) => ty::vstore_fixed(n),\n-      ast::vstore_fixed(Some(u)) => {\n-        if n != u {\n-            let s = fmt!(\"fixed-size sequence mismatch: %u vs. %u\",u, n);\n-            fcx.ccx.tcx.sess.span_err(e.span,s);\n+        ast::vstore_fixed(None) => ty::vstore_fixed(n),\n+        ast::vstore_fixed(Some(u)) => {\n+            if n != u {\n+                let s = fmt!(\"fixed-size sequence mismatch: %u vs. %u\",u, n);\n+                fcx.ccx.tcx.sess.span_err(e.span,s);\n+            }\n+            ty::vstore_fixed(u)\n+        }\n+        ast::vstore_uniq => ty::vstore_uniq,\n+        ast::vstore_box => ty::vstore_box,\n+        ast::vstore_slice(_) => {\n+            let r = fcx.infcx().next_region_var(e.span, e.id);\n+            ty::vstore_slice(r)\n         }\n-        ty::vstore_fixed(u)\n-      }\n-      ast::vstore_uniq => ty::vstore_uniq,\n-      ast::vstore_box => ty::vstore_box,\n-      ast::vstore_slice(_) => {\n-        let r = fcx.infcx.next_region_var(e.span, e.id);\n-        ty::vstore_slice(r)\n-      }\n     }\n }\n "}, {"sha": "00562144ef66e22ee42180718aff9d0e759d6cda", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=e9ac7489b5032b4a922a0df1dd611471260b31ef", "patch": "@@ -7,7 +7,7 @@ fn check_alt(fcx: @fn_ctxt,\n     let tcx = fcx.ccx.tcx;\n     let mut bot;\n \n-    let pattern_ty = fcx.infcx.next_ty_var();\n+    let pattern_ty = fcx.infcx().next_ty_var();\n     bot = check_expr_with(fcx, discrim, pattern_ty);\n     let is_lvalue = ty::expr_is_lval(fcx.ccx.method_map, discrim);\n \n@@ -30,7 +30,7 @@ fn check_alt(fcx: @fn_ctxt,\n         for arm.pats.each |p| { check_pat(pcx, p, pattern_ty);}\n     }\n     // Now typecheck the blocks.\n-    let mut result_ty = fcx.infcx.next_ty_var();\n+    let mut result_ty = fcx.infcx().next_ty_var();\n     let mut arm_non_bot = false;\n     for arms.each |arm| {\n         match arm.guard {\n@@ -128,7 +128,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n         tcx.sess.span_fatal\n             (pat.span,\n              fmt!(\"mismatched types: expected enum but found `%s`\",\n-                  fcx.infcx.ty_to_str(expected)));\n+                  fcx.infcx().ty_to_str(expected)));\n       }\n     }\n }\n@@ -151,14 +151,15 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         check_expr_with(fcx, begin, expected);\n         check_expr_with(fcx, end, expected);\n         let b_ty =\n-            fcx.infcx.resolve_type_vars_if_possible(fcx.expr_ty(begin));\n+            fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(begin));\n         let e_ty =\n-            fcx.infcx.resolve_type_vars_if_possible(fcx.expr_ty(end));\n+            fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(end));\n         debug!(\"pat_range beginning type: %?\", b_ty);\n         debug!(\"pat_range ending type: %?\", e_ty);\n         if !require_same_types(\n-            tcx, Some(fcx.infcx), false, pat.span, b_ty, e_ty,\n-            || ~\"mismatched types in range\") {\n+            tcx, Some(fcx.infcx()), false, pat.span, b_ty, e_ty,\n+            || ~\"mismatched types in range\")\n+        {\n             // no-op\n         } else if !ty::type_is_numeric(b_ty) {\n             tcx.sess.span_err(pat.span, ~\"non-numeric type used in range\");\n@@ -180,7 +181,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             // then the type of x is &M T where M is the mutability\n             // and T is the expected type\n             let region_var =\n-                fcx.infcx.next_region_var_with_lb(\n+                fcx.infcx().next_region_var_with_lb(\n                     pat.span, pcx.block_region);\n             let mt = {ty: expected, mutbl: mutbl};\n             let region_ty = ty::mk_rptr(tcx, region_var, mt);\n@@ -241,7 +242,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             tcx.sess.span_fatal\n                 (pat.span,\n                 fmt!(\"mismatched types: expected `%s` but found record\",\n-                     fcx.infcx.ty_to_str(expected)));\n+                     fcx.infcx().ty_to_str(expected)));\n           }\n         };\n         let f_count = vec::len(fields);\n@@ -284,7 +285,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                 tcx.sess.span_fatal(pat.span,\n                                     fmt!(\"mismatched types: expected `%s` \\\n                                           but found struct\",\n-                                         fcx.infcx.ty_to_str(expected)));\n+                                         fcx.infcx().ty_to_str(expected)));\n             }\n         }\n \n@@ -299,7 +300,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                 tcx.sess.span_err(pat.span,\n                                   fmt!(\"mismatched types: expected `%s` but \\\n                                         found `%s`\",\n-                                       fcx.infcx.ty_to_str(expected),\n+                                       fcx.infcx().ty_to_str(expected),\n                                        name));\n             }\n             _ => {\n@@ -364,7 +365,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             tcx.sess.span_fatal\n                 (pat.span,\n                  fmt!(\"mismatched types: expected `%s`, found tuple\",\n-                      fcx.infcx.ty_to_str(expected)));\n+                      fcx.infcx().ty_to_str(expected)));\n           }\n         };\n         let e_count = vec::len(elts);\n@@ -392,7 +393,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             tcx.sess.span_fatal(\n                 pat.span,\n                 ~\"mismatched types: expected `\" +\n-                fcx.infcx.ty_to_str(expected) +\n+                fcx.infcx().ty_to_str(expected) +\n                 ~\"` found box\");\n           }\n         }\n@@ -407,7 +408,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             tcx.sess.span_fatal(\n                 pat.span,\n                 ~\"mismatched types: expected `\" +\n-                fcx.infcx.ty_to_str(expected) +\n+                fcx.infcx().ty_to_str(expected) +\n                 ~\"` found uniq\");\n           }\n         }"}, {"sha": "55272b8c419efc1abc5a17f89a113023eddace41", "filename": "src/rustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=e9ac7489b5032b4a922a0df1dd611471260b31ef", "patch": "@@ -6,7 +6,7 @@ fn suptype(fcx: @fn_ctxt, sp: span,\n            expected: ty::t, actual: ty::t) {\n \n     // n.b.: order of actual, expected is reversed\n-    match infer::mk_subty(fcx.infcx, false, sp,\n+    match infer::mk_subty(fcx.infcx(), false, sp,\n                           actual, expected) {\n       result::Ok(()) => { /* ok */ }\n       result::Err(ref err) => {\n@@ -18,11 +18,11 @@ fn suptype(fcx: @fn_ctxt, sp: span,\n fn eqtype(fcx: @fn_ctxt, sp: span,\n           expected: ty::t, actual: ty::t) {\n \n-    match infer::mk_eqty(fcx.infcx, false, sp, actual, expected) {\n-      result::Ok(()) => { /* ok */ }\n-      result::Err(ref err) => {\n-        fcx.report_mismatched_types(sp, expected, actual, err);\n-      }\n+    match infer::mk_eqty(fcx.infcx(), false, sp, actual, expected) {\n+        Ok(()) => { /* ok */ }\n+        Err(ref err) => {\n+            fcx.report_mismatched_types(sp, expected, actual, err);\n+        }\n     }\n }\n "}, {"sha": "fb4d2565c44757fc5d5d7ee4c25531a827aa1ebb", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 38, "deletions": 50, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=e9ac7489b5032b4a922a0df1dd611471260b31ef", "patch": "@@ -108,14 +108,14 @@ struct lookup {\n     fn method() -> Option<method_map_entry> {\n         debug!(\"method lookup(m_name=%s, self_ty=%s, %?)\",\n                self.fcx.tcx().sess.str_of(self.m_name),\n-               self.fcx.infcx.ty_to_str(self.self_ty),\n+               self.fcx.infcx().ty_to_str(self.self_ty),\n                ty::get(self.self_ty).struct);\n \n         // Determine if there are any inherent methods we can call.\n         // (An inherent method is one that belongs to no trait, but is\n         // inherent to a class or impl.)\n         let optional_inherent_methods;\n-        match get_base_type_def_id(self.fcx.infcx,\n+        match get_base_type_def_id(self.fcx.infcx(),\n                                  self.self_expr.span,\n                                  self.self_ty) {\n           None => {\n@@ -438,35 +438,27 @@ struct lookup {\n         // Depending on our argument, we find potential matches by\n         // checking subtypability, type assignability, or reference\n         // subtypability. Collect the matches.\n-        let matches;\n         match mode {\n-          subtyping_mode => {\n-            matches = self.fcx.can_mk_subty(self.self_ty, impl_ty);\n-          }\n-          assignability_mode => {\n-            matches = self.fcx.can_mk_assignty(self.self_expr,\n-                                               self.borrow_lb,\n-                                               self.self_ty,\n-                                               impl_ty);\n-          }\n-          immutable_reference_mode => {\n-            let region = self.fcx.infcx.next_region_var(\n-                self.self_expr.span,\n-                self.self_expr.id);\n-            let tm = { ty: self.self_ty, mutbl: ast::m_imm };\n-            let ref_ty = ty::mk_rptr(self.tcx(), region, tm);\n-            matches = self.fcx.can_mk_subty(ref_ty, impl_ty);\n-          }\n-          mutable_reference_mode => {\n-            let region = self.fcx.infcx.next_region_var(\n-                self.self_expr.span,\n-                self.self_expr.id);\n-            let tm = { ty: self.self_ty, mutbl: ast::m_mutbl };\n-            let ref_ty = ty::mk_rptr(self.tcx(), region, tm);\n-            matches = self.fcx.can_mk_subty(ref_ty, impl_ty);\n-          }\n+            subtyping_mode => self.fcx.can_mk_subty(self.self_ty, impl_ty),\n+            assignability_mode => self.fcx.can_mk_assignty(self.self_ty,\n+                                                           impl_ty),\n+            immutable_reference_mode => {\n+                let region = self.fcx.infcx().next_region_var(\n+                    self.self_expr.span,\n+                    self.self_expr.id);\n+                let tm = { ty: self.self_ty, mutbl: ast::m_imm };\n+                let ref_ty = ty::mk_rptr(self.tcx(), region, tm);\n+                self.fcx.can_mk_subty(ref_ty, impl_ty)\n+            }\n+            mutable_reference_mode => {\n+                let region = self.fcx.infcx().next_region_var(\n+                    self.self_expr.span,\n+                    self.self_expr.id);\n+                let tm = { ty: self.self_ty, mutbl: ast::m_mutbl };\n+                let ref_ty = ty::mk_rptr(self.tcx(), region, tm);\n+                self.fcx.can_mk_subty(ref_ty, impl_ty)\n+            }\n         }\n-        matches\n     }\n \n     // Returns true if any were added and false otherwise.\n@@ -530,7 +522,7 @@ struct lookup {\n           None => {\n             match m.self_ty {\n               ast::sty_region(_) =>\n-                  Some(self.fcx.infcx.next_region_var(\n+                  Some(self.fcx.infcx().next_region_var(\n                       self.self_expr.span,\n                       self.self_expr.id)),\n               _ => None\n@@ -640,7 +632,7 @@ struct lookup {\n \n         debug!(\"write_mty_from_candidate(n_tps_m=%u, fty=%s, entry=%?)\",\n                cand.n_tps_m,\n-               self.fcx.infcx.ty_to_str(cand.fty),\n+               self.fcx.infcx().ty_to_str(cand.fty),\n                cand.entry);\n \n         match cand.mode {\n@@ -655,30 +647,18 @@ struct lookup {\n                     self.tcx().sess.span_bug(\n                         self.expr.span,\n                         fmt!(\"%s was assignable to %s but now is not?\",\n-                             self.fcx.infcx.ty_to_str(cand.self_ty),\n-                             self.fcx.infcx.ty_to_str(cand.rcvr_ty)));\n+                             self.fcx.infcx().ty_to_str(cand.self_ty),\n+                             self.fcx.infcx().ty_to_str(cand.rcvr_ty)));\n                   }\n                 }\n             }\n             immutable_reference_mode => {\n                 // Borrow as an immutable reference.\n-                let region_var = self.fcx.infcx.next_region_var(\n-                    self.self_expr.span,\n-                    self.self_expr.id);\n-                self.fcx.infcx.borrowings.push({expr_id: self.self_expr.id,\n-                                                span: self.self_expr.span,\n-                                                scope: region_var,\n-                                                mutbl: ast::m_imm});\n+                self.add_borrow(ast::m_imm);\n             }\n             mutable_reference_mode => {\n                 // Borrow as a mutable reference.\n-                let region_var = self.fcx.infcx.next_region_var(\n-                    self.self_expr.span,\n-                    self.self_expr.id);\n-                self.fcx.infcx.borrowings.push({expr_id: self.self_expr.id,\n-                                                span: self.self_expr.span,\n-                                                scope: region_var,\n-                                                mutbl: ast::m_mutbl});\n+                self.add_borrow(ast::m_mutbl);\n             }\n         }\n \n@@ -688,18 +668,18 @@ struct lookup {\n         let n_tps_m = cand.n_tps_m;\n         let m_substs = {\n             if n_tps_supplied == 0u {\n-                self.fcx.infcx.next_ty_vars(n_tps_m)\n+                self.fcx.infcx().next_ty_vars(n_tps_m)\n             } else if n_tps_m == 0u {\n                 tcx.sess.span_err(\n                     self.expr.span,\n                     ~\"this method does not take type parameters\");\n-                self.fcx.infcx.next_ty_vars(n_tps_m)\n+                self.fcx.infcx().next_ty_vars(n_tps_m)\n             } else if n_tps_supplied != n_tps_m {\n                 tcx.sess.span_err(\n                     self.expr.span,\n                     ~\"incorrect number of type \\\n                      parameters given for this method\");\n-                self.fcx.infcx.next_ty_vars(n_tps_m)\n+                self.fcx.infcx().next_ty_vars(n_tps_m)\n             } else {\n                 self.supplied_tps\n             }\n@@ -712,5 +692,13 @@ struct lookup {\n \n         return cand.entry;\n     }\n+\n+    fn add_borrow(mutbl: ast::mutability) {\n+        let region_var = self.fcx.infcx().next_region_var(\n+            self.self_expr.span,\n+            self.self_expr.id);\n+        self.fcx.inh.borrowings.insert(self.self_expr.id, {region: region_var,\n+                                                           mutbl: mutbl});\n+    }\n }\n "}, {"sha": "01286bff38a18ad963fd83e48265abfd5377aeb2", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=e9ac7489b5032b4a922a0df1dd611471260b31ef", "patch": "@@ -81,7 +81,7 @@ impl @rcx {\n     /// that `<R0>` be bigger than the let and the `*b` expression, so we\n     /// will effectively resolve `<R0>` to be the block B.\n     fn resolve_type(unresolved_ty: ty::t) -> fres<ty::t> {\n-        resolve_type(self.fcx.infcx, unresolved_ty,\n+        resolve_type(self.fcx.infcx(), unresolved_ty,\n                      resolve_and_force_all_but_regions)\n     }\n \n@@ -95,7 +95,7 @@ fn regionck_expr(fcx: @fn_ctxt, e: @ast::expr) {\n     let rcx = rcx_({fcx:fcx, mut errors_reported: 0u});\n     let v = regionck_visitor();\n     v.visit_expr(e, @rcx, v);\n-    fcx.infcx.resolve_regions();\n+    fcx.infcx().resolve_regions();\n }\n \n fn regionck_fn(fcx: @fn_ctxt,\n@@ -104,7 +104,7 @@ fn regionck_fn(fcx: @fn_ctxt,\n     let rcx = rcx_({fcx:fcx, mut errors_reported: 0u});\n     let v = regionck_visitor();\n     v.visit_block(blk, @rcx, v);\n-    fcx.infcx.resolve_regions();\n+    fcx.infcx().resolve_regions();\n }\n \n fn regionck_visitor() -> rvt {"}, {"sha": "b349d502b022c2645316108028c7401b80a024f2", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=e9ac7489b5032b4a922a0df1dd611471260b31ef", "patch": "@@ -3,6 +3,7 @@ import infer::{resolve_type, resolve_and_force_all_but_regions,\n                fixup_err_to_str};\n import ast_util::new_def_hash;\n import syntax::print::pprust;\n+import result::{Result, Ok, Err};\n \n // vtable resolution looks for places where trait bounds are\n // subsituted in and figures out which vtable is used. There is some\n@@ -85,7 +86,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n {\n \n     debug!(\"lookup_vtable(ty=%s, trait_ty=%s)\",\n-           fcx.infcx.ty_to_str(ty), fcx.infcx.ty_to_str(trait_ty));\n+           fcx.infcx().ty_to_str(ty), fcx.inh.infcx.ty_to_str(trait_ty));\n     let _i = indenter();\n \n     let tcx = fcx.ccx.tcx;\n@@ -253,8 +254,8 @@ fn lookup_vtable(fcx: @fn_ctxt,\n \n                         debug!(\"(checking vtable) @2 relating trait ty %s to \\\n                                 of_ty %s\",\n-                               fcx.infcx.ty_to_str(trait_ty),\n-                               fcx.infcx.ty_to_str(of_ty));\n+                               fcx.infcx().ty_to_str(trait_ty),\n+                               fcx.infcx().ty_to_str(of_ty));\n                         let of_ty = ty::subst(tcx, &substs, of_ty);\n                         relate_trait_tys(fcx, expr, trait_ty, of_ty);\n \n@@ -347,18 +348,18 @@ fn fixup_ty(fcx: @fn_ctxt,\n             is_early: bool) -> Option<ty::t>\n {\n     let tcx = fcx.ccx.tcx;\n-    match resolve_type(fcx.infcx, ty, resolve_and_force_all_but_regions) {\n-      result::Ok(new_type) => Some(new_type),\n-      result::Err(e) if !is_early => {\n-        tcx.sess.span_fatal(\n-            expr.span,\n-            fmt!(\"cannot determine a type \\\n-                  for this bounded type parameter: %s\",\n-                 fixup_err_to_str(e)))\n-      }\n-      result::Err(_) => {\n-        None\n-      }\n+    match resolve_type(fcx.infcx(), ty, resolve_and_force_all_but_regions) {\n+        Ok(new_type) => Some(new_type),\n+        Err(e) if !is_early => {\n+            tcx.sess.span_fatal(\n+                expr.span,\n+                fmt!(\"cannot determine a type \\\n+                      for this bounded type parameter: %s\",\n+                     fixup_err_to_str(e)))\n+        }\n+        Err(_) => {\n+            None\n+        }\n     }\n }\n "}, {"sha": "dfb807de9ca545c947e2309e9eb2e56e4ea3d764", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 63, "deletions": 39, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=e9ac7489b5032b4a922a0df1dd611471260b31ef", "patch": "@@ -3,30 +3,58 @@\n // substitutions.\n \n import check::{fn_ctxt, lookup_local};\n-import infer::{resolve_type, resolve_all, force_all};\n+import infer::{resolve_type, resolve_region, resolve_all, force_all};\n export resolve_type_vars_in_fn;\n export resolve_type_vars_in_expr;\n+import result::{Result, Ok, Err};\n \n-fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n-    Option<ty::t> {\n+fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t)\n+    -> Option<ty::t>\n+{\n     if !ty::type_needs_infer(typ) { return Some(typ); }\n-    match resolve_type(fcx.infcx, typ, resolve_all | force_all) {\n-      result::Ok(new_type) => return Some(new_type),\n-      result::Err(e) => {\n-        if !fcx.ccx.tcx.sess.has_errors() {\n-            fcx.ccx.tcx.sess.span_err(\n-                sp,\n-                fmt!(\"cannot determine a type \\\n-                      for this expression: %s\",\n-                     infer::fixup_err_to_str(e)))\n+    match resolve_type(fcx.infcx(), typ, resolve_all | force_all) {\n+        Ok(new_type) => return Some(new_type),\n+        Err(e) => {\n+            if !fcx.ccx.tcx.sess.has_errors() {\n+                fcx.ccx.tcx.sess.span_err(\n+                    sp,\n+                    fmt!(\"cannot determine a type \\\n+                          for this expression: %s\",\n+                         infer::fixup_err_to_str(e)))\n+            }\n+            return None;\n         }\n-        return None;\n-      }\n     }\n }\n+\n fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n-    -> Option<ty::t> {\n+    -> Option<ty::t>\n+{\n     let fcx = wbcx.fcx, tcx = fcx.ccx.tcx;\n+\n+    // Resolve any borrowings for the node with id `id`\n+    match fcx.inh.borrowings.find(id) {\n+        None => (),\n+        Some(borrow) => {\n+            match resolve_region(fcx.infcx(), borrow.region,\n+                                 resolve_all | force_all) {\n+                Err(e) => {\n+                    // This should not, I think, happen.\n+                    fcx.ccx.tcx.sess.span_err(\n+                        sp, fmt!(\"cannot resolve scope of borrow: %s\",\n+                                 infer::fixup_err_to_str(e)));\n+                }\n+                Ok(r) => {\n+                    debug!(\"Borrowing node %d -> region %?, mutbl %?\",\n+                           id, r, borrow.mutbl);\n+                    fcx.tcx().borrowings.insert(id, {region: r,\n+                                                     mutbl: borrow.mutbl});\n+                }\n+            }\n+        }\n+    }\n+\n+    // Resolve the type of the node with id `id`\n     let n_ty = fcx.node_ty(id);\n     match resolve_type_vars_in_type(fcx, sp, n_ty) {\n       None => {\n@@ -58,8 +86,9 @@ fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n \n fn maybe_resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span,\n                                     id: ast::node_id)\n-    -> Option<ty::t> {\n-    if wbcx.fcx.node_types.contains_key(id) {\n+    -> Option<ty::t>\n+{\n+    if wbcx.fcx.inh.node_types.contains_key(id) {\n         resolve_type_vars_for_node(wbcx, sp, id)\n     } else {\n         None\n@@ -118,7 +147,7 @@ fn visit_pat(p: @ast::pat, wbcx: wb_ctxt, v: wb_vt) {\n     resolve_type_vars_for_node(wbcx, p.span, p.id);\n     debug!(\"Type for pattern binding %s (id %d) resolved to %s\",\n            pat_to_str(p, wbcx.fcx.ccx.tcx.sess.intr()), p.id,\n-           wbcx.fcx.infcx.ty_to_str(\n+           wbcx.fcx.infcx().ty_to_str(\n                ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n                                    p.id)));\n     visit::visit_pat(p, wbcx, v);\n@@ -127,21 +156,22 @@ fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     let var_id = lookup_local(wbcx.fcx, l.span, l.node.id);\n     let var_ty = ty::mk_var(wbcx.fcx.tcx(), var_id);\n-    match resolve_type(wbcx.fcx.infcx, var_ty, resolve_all | force_all) {\n-      result::Ok(lty) => {\n-        debug!(\"Type for local %s (id %d) resolved to %s\",\n-               pat_to_str(l.node.pat, wbcx.fcx.ccx.tcx.sess.intr()),l.node.id,\n-               wbcx.fcx.infcx.ty_to_str(lty));\n-        write_ty_to_tcx(wbcx.fcx.ccx.tcx, l.node.id, lty);\n-      }\n-      result::Err(e) => {\n-        wbcx.fcx.ccx.tcx.sess.span_err(\n-            l.span,\n-            fmt!(\"cannot determine a type \\\n-                  for this local variable: %s\",\n-                 infer::fixup_err_to_str(e)));\n-        wbcx.success = false;\n-      }\n+    match resolve_type(wbcx.fcx.infcx(), var_ty, resolve_all | force_all) {\n+        Ok(lty) => {\n+            debug!(\"Type for local %s (id %d) resolved to %s\",\n+                   pat_to_str(l.node.pat, wbcx.fcx.tcx().sess.intr()),\n+                   l.node.id,\n+                   wbcx.fcx.infcx().ty_to_str(lty));\n+            write_ty_to_tcx(wbcx.fcx.ccx.tcx, l.node.id, lty);\n+        }\n+        Err(e) => {\n+            wbcx.fcx.ccx.tcx.sess.span_err(\n+                l.span,\n+                fmt!(\"cannot determine a type \\\n+                      for this local variable: %s\",\n+                     infer::fixup_err_to_str(e)));\n+            wbcx.success = false;\n+        }\n     }\n     visit::visit_local(l, wbcx, v);\n }\n@@ -163,9 +193,6 @@ fn resolve_type_vars_in_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n     let wbcx = {fcx: fcx, mut success: true};\n     let visit = mk_visitor();\n     visit.visit_expr(e, wbcx, visit);\n-    if wbcx.success {\n-        infer::resolve_borrowings(fcx.infcx);\n-    }\n     return wbcx.success;\n }\n \n@@ -184,8 +211,5 @@ fn resolve_type_vars_in_fn(fcx: @fn_ctxt,\n     for decl.inputs.each |arg| {\n         resolve_type_vars_for_node(wbcx, arg.ty.span, arg.id);\n     }\n-    if wbcx.success {\n-        infer::resolve_borrowings(fcx.infcx);\n-    }\n     return wbcx.success;\n }"}, {"sha": "ce52a2f7436c565c9f82c3eec1e713c5d869adb9", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 37, "deletions": 56, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=e9ac7489b5032b4a922a0df1dd611471260b31ef", "patch": "@@ -273,6 +273,7 @@ import resolve::{resolve_nested_tvar, resolve_rvar, resolve_ivar, resolve_all,\n import unify::{vals_and_bindings, root};\n import integral::{int_ty_set, int_ty_set_all};\n import combine::{combine_fields, eq_tys};\n+import assignment::Assign;\n \n import sub::Sub;\n import lub::Lub;\n@@ -296,20 +297,13 @@ export assignment;\n export root, to_str;\n export int_ty_set_all;\n \n-// Extra information needed to perform an assignment that may borrow.\n-// The `expr_id` and `span` are the id/span of the expression\n-// whose type is being assigned, and `borrow_scope` is the region\n-// scope to use if the value should be borrowed.\n-type assignment = {\n-    expr_id: ast::node_id,\n-    span: span,\n-    borrow_lb: ast::node_id,\n-};\n-\n type bound<T:copy> = Option<T>;\n type bounds<T:copy> = {lb: bound<T>, ub: bound<T>};\n \n-type cres<T> = Result<T,ty::type_err>;\n+type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n+type ures = cres<()>; // \"unify result\"\n+type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n+type ares = cres<Option<ty::borrow>>; // \"assignment result\"\n \n enum infer_ctxt = @{\n     tcx: ty::ctxt,\n@@ -329,12 +323,7 @@ enum infer_ctxt = @{\n     // For keeping track of existing type and region variables.\n     ty_var_counter: @mut uint,\n     ty_var_integral_counter: @mut uint,\n-    region_var_counter: @mut uint,\n-\n-    borrowings: DVec<{expr_id: ast::node_id,\n-                      span: span,\n-                      scope: ty::region,\n-                      mutbl: ast::mutability}>\n+    region_var_counter: @mut uint\n };\n \n enum fixup_err {\n@@ -358,9 +347,6 @@ fn fixup_err_to_str(f: fixup_err) -> ~str {\n     }\n }\n \n-type ures = result::Result<(), ty::type_err>;\n-type fres<T> = result::Result<T, fixup_err>;\n-\n fn new_vals_and_bindings<V:copy, T:copy>() -> vals_and_bindings<V, T> {\n     vals_and_bindings {\n         vals: smallintmap::mk(),\n@@ -375,19 +361,14 @@ fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n                  region_vars: RegionVarBindings(tcx),\n                  ty_var_counter: @mut 0u,\n                  ty_var_integral_counter: @mut 0u,\n-                 region_var_counter: @mut 0u,\n-                 borrowings: DVec()})}\n-\n-fn mk_sub(cx: infer_ctxt, a_is_expected: bool, span: span) -> Sub {\n-    Sub(combine_fields {infcx: cx, a_is_expected: a_is_expected, span: span})\n-}\n+                 region_var_counter: @mut 0u})}\n \n fn mk_subty(cx: infer_ctxt, a_is_expected: bool, span: span,\n             a: ty::t, b: ty::t) -> ures {\n     debug!(\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n     do indent {\n         do cx.commit {\n-            mk_sub(cx, a_is_expected, span).tys(a, b)\n+            cx.sub(a_is_expected, span).tys(a, b)\n         }\n     }.to_ures()\n }\n@@ -396,7 +377,7 @@ fn can_mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n     do indent {\n         do cx.probe {\n-            mk_sub(cx, true, ast_util::dummy_sp()).tys(a, b)\n+            cx.sub(true, ast_util::dummy_sp()).tys(a, b)\n         }\n     }.to_ures()\n }\n@@ -406,7 +387,7 @@ fn mk_subr(cx: infer_ctxt, a_is_expected: bool, span: span,\n     debug!(\"mk_subr(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n     do indent {\n         do cx.commit {\n-            mk_sub(cx, a_is_expected, span).regions(a, b)\n+            cx.sub(a_is_expected, span).regions(a, b)\n         }\n     }.to_ures()\n }\n@@ -416,37 +397,30 @@ fn mk_eqty(cx: infer_ctxt, a_is_expected: bool, span: span,\n     debug!(\"mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n     do indent {\n         do cx.commit {\n-            let suber = mk_sub(cx, a_is_expected, span);\n+            let suber = cx.sub(a_is_expected, span);\n             eq_tys(&suber, a, b)\n         }\n     }.to_ures()\n }\n \n-fn mk_assignty(cx: infer_ctxt, anmnt: &assignment,\n-               a: ty::t, b: ty::t) -> ures {\n-    debug!(\"mk_assignty(%? / %s <: %s)\",\n-           anmnt, a.to_str(cx), b.to_str(cx));\n+fn mk_assignty(cx: infer_ctxt, a_is_expected: bool, span: span,\n+               a: ty::t, b: ty::t) -> ares {\n+    debug!(\"mk_assignty(%s -> %s)\", a.to_str(cx), b.to_str(cx));\n     do indent {\n         do cx.commit {\n-            cx.assign_tys(anmnt, a, b)\n+            Assign(cx.combine_fields(a_is_expected, span)).tys(a, b)\n         }\n-    }.to_ures()\n+    }\n }\n \n-fn can_mk_assignty(cx: infer_ctxt, anmnt: &assignment,\n-                a: ty::t, b: ty::t) -> ures {\n-    debug!(\"can_mk_assignty(%? / %s <: %s)\",\n-           anmnt, a.to_str(cx), b.to_str(cx));\n-\n-    // FIXME(#2593)---this will not unroll any entries we make in the\n-    // borrowings table.  But this is OK for the moment because this\n-    // is only used in method lookup, and there must be exactly one\n-    // match or an error is reported. Still, it should be fixed. (#2593)\n-    // NDM OUTDATED\n-\n-    indent(|| cx.probe(||\n-        cx.assign_tys(anmnt, a, b)\n-    ) ).to_ures()\n+fn can_mk_assignty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n+    debug!(\"can_mk_assignty(%s -> %s)\", a.to_str(cx), b.to_str(cx));\n+    do indent {\n+        do cx.probe {\n+            let span = ast_util::dummy_sp();\n+            Assign(cx.combine_fields(true, span)).tys(a, b)\n+        }\n+    }.to_ures()\n }\n \n // See comment on the type `resolve_state` below\n@@ -460,6 +434,7 @@ fn resolve_region(cx: infer_ctxt, r: ty::region, modes: uint)\n     resolver(cx, modes).resolve_region_chk(r)\n }\n \n+/*\n fn resolve_borrowings(cx: infer_ctxt) {\n     for cx.borrowings.each |item| {\n         match resolve_region(cx, item.scope, resolve_all|force_all) {\n@@ -479,6 +454,7 @@ fn resolve_borrowings(cx: infer_ctxt) {\n         }\n     }\n }\n+*/\n \n trait then {\n     fn then<T:copy>(f: fn() -> Result<T,ty::type_err>)\n@@ -533,10 +509,20 @@ struct Snapshot {\n     ty_var_bindings_len: uint;\n     ty_var_integral_bindings_len: uint;\n     region_vars_snapshot: uint;\n-    borrowings_len: uint;\n }\n \n impl infer_ctxt {\n+    fn combine_fields(a_is_expected: bool,\n+                      span: span) -> combine_fields {\n+        combine_fields {infcx: self,\n+                        a_is_expected: a_is_expected,\n+                        span: span}\n+    }\n+\n+    fn sub(a_is_expected: bool, span: span) -> Sub {\n+        Sub(self.combine_fields(a_is_expected, span))\n+    }\n+\n     fn in_snapshot() -> bool {\n         self.region_vars.in_snapshot()\n     }\n@@ -549,8 +535,6 @@ impl infer_ctxt {\n                 self.ty_var_integral_bindings.bindings.len(),\n             region_vars_snapshot:\n                 self.region_vars.start_snapshot(),\n-            borrowings_len:\n-                self.borrowings.len()\n         }\n     }\n \n@@ -564,9 +548,6 @@ impl infer_ctxt {\n \n         self.region_vars.rollback_to(\n             snapshot.region_vars_snapshot);\n-        while self.borrowings.len() != snapshot.borrowings_len {\n-            self.borrowings.pop();\n-        }\n     }\n \n     /// Execute `f` and commit the bindings if successful"}, {"sha": "620929f4bd963c55e01b0d06fc1ab77582c02c77", "filename": "src/rustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 115, "deletions": 111, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ac7489b5032b4a922a0df1dd611471260b31ef/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=e9ac7489b5032b4a922a0df1dd611471260b31ef", "patch": "@@ -49,70 +49,74 @@\n // needed.\n \n import to_str::to_str;\n+import combine::combine_fields;\n \n-impl infer_ctxt {\n-    fn assign_tys(anmnt: &assignment, a: ty::t, b: ty::t) -> ures {\n+fn to_ares(+c: cres<ty::t>) -> ares {\n+    match c {\n+        Ok(_) => Ok(None),\n+        Err(e) => Err(e)\n+    }\n+}\n \n-        fn select(fst: Option<ty::t>, snd: Option<ty::t>) -> Option<ty::t> {\n-            match fst {\n-              Some(t) => Some(t),\n-              None => match snd {\n-                Some(t) => Some(t),\n-                None => None\n-              }\n-            }\n-        }\n+// Note: Assign is not actually a combiner, in that it does not\n+// conform to the same interface, though it performs a similar\n+// function.\n+enum Assign = combine_fields;\n \n-        debug!(\"assign_tys(anmnt=%?, %s -> %s)\",\n-               anmnt, a.to_str(self), b.to_str(self));\n+impl Assign {\n+    fn tys(a: ty::t, b: ty::t) -> ares {\n+        debug!(\"Assign.tys(%s -> %s)\",\n+               a.to_str(self.infcx),\n+               b.to_str(self.infcx));\n         let _r = indenter();\n \n         match (ty::get(a).struct, ty::get(b).struct) {\n-          (ty::ty_bot, _) => {\n-            uok()\n-          }\n-\n-          (ty::ty_var(a_id), ty::ty_var(b_id)) => {\n-            let nde_a = self.get(&self.ty_var_bindings, a_id);\n-            let nde_b = self.get(&self.ty_var_bindings, b_id);\n-            let a_bounds = nde_a.possible_types;\n-            let b_bounds = nde_b.possible_types;\n-\n-            let a_bnd = select(a_bounds.ub, a_bounds.lb);\n-            let b_bnd = select(b_bounds.lb, b_bounds.ub);\n-            self.assign_tys_or_sub(anmnt, a, b, a_bnd, b_bnd)\n-          }\n-\n-          (ty::ty_var(a_id), _) => {\n-            let nde_a = self.get(&self.ty_var_bindings, a_id);\n-            let a_bounds = nde_a.possible_types;\n-\n-            let a_bnd = select(a_bounds.ub, a_bounds.lb);\n-            self.assign_tys_or_sub(anmnt, a, b, a_bnd, Some(b))\n-          }\n-\n-          (_, ty::ty_var(b_id)) => {\n-            let nde_b = self.get(&self.ty_var_bindings, b_id);\n-            let b_bounds = nde_b.possible_types;\n-\n-            let b_bnd = select(b_bounds.lb, b_bounds.ub);\n-            self.assign_tys_or_sub(anmnt, a, b, Some(a), b_bnd)\n-          }\n-\n-          (_, _) => {\n-            self.assign_tys_or_sub(anmnt, a, b, Some(a), Some(b))\n-          }\n+            (ty::ty_bot, _) => {\n+                Ok(None)\n+            }\n+\n+            (ty::ty_var(a_id), ty::ty_var(b_id)) => {\n+                let nde_a = self.infcx.get(&self.infcx.ty_var_bindings, a_id);\n+                let nde_b = self.infcx.get(&self.infcx.ty_var_bindings, b_id);\n+                let a_bounds = nde_a.possible_types;\n+                let b_bounds = nde_b.possible_types;\n+\n+                let a_bnd = option::or(a_bounds.ub, a_bounds.lb);\n+                let b_bnd = option::or(b_bounds.lb, b_bounds.ub);\n+                self.assign_tys_or_sub(a, b, a_bnd, b_bnd)\n+            }\n+\n+            (ty::ty_var(a_id), _) => {\n+                let nde_a = self.infcx.get(&self.infcx.ty_var_bindings, a_id);\n+                let a_bounds = nde_a.possible_types;\n+\n+                let a_bnd = option::or(a_bounds.ub, a_bounds.lb);\n+                self.assign_tys_or_sub(a, b, a_bnd, Some(b))\n+            }\n+\n+            (_, ty::ty_var(b_id)) => {\n+                let nde_b = self.infcx.get(&self.infcx.ty_var_bindings, b_id);\n+                let b_bounds = nde_b.possible_types;\n+\n+                let b_bnd = option::or(b_bounds.lb, b_bounds.ub);\n+                self.assign_tys_or_sub(a, b, Some(a), b_bnd)\n+            }\n+\n+            (_, _) => {\n+                self.assign_tys_or_sub(a, b, Some(a), Some(b))\n+            }\n         }\n     }\n+}\n \n+priv impl Assign {\n     fn assign_tys_or_sub(\n-        anmnt: &assignment,\n         a: ty::t, b: ty::t,\n-        +a_bnd: Option<ty::t>, +b_bnd: Option<ty::t>) -> ures {\n+        +a_bnd: Option<ty::t>, +b_bnd: Option<ty::t>) -> ares {\n \n-        debug!(\"assign_tys_or_sub(anmnt=%?, %s -> %s, %s -> %s)\",\n-               anmnt, a.to_str(self), b.to_str(self),\n-               a_bnd.to_str(self), b_bnd.to_str(self));\n+        debug!(\"Assign.assign_tys_or_sub(%s -> %s, %s -> %s)\",\n+               a.to_str(self.infcx), b.to_str(self.infcx),\n+               a_bnd.to_str(self.infcx), b_bnd.to_str(self.infcx));\n         let _r = indenter();\n \n         fn is_borrowable(v: ty::vstore) -> bool {\n@@ -123,73 +127,73 @@ impl infer_ctxt {\n         }\n \n         match (a_bnd, b_bnd) {\n-          (Some(a_bnd), Some(b_bnd)) => {\n-            match (ty::get(a_bnd).struct, ty::get(b_bnd).struct) {\n-              (ty::ty_box(*), ty::ty_rptr(r_b, mt_b)) => {\n-                let nr_b = ty::mk_box(self.tcx, {ty: mt_b.ty,\n-                                                 mutbl: m_const});\n-                self.crosspollinate(anmnt, a, nr_b, mt_b.mutbl, r_b)\n-              }\n-              (ty::ty_uniq(*), ty::ty_rptr(r_b, mt_b)) => {\n-                let nr_b = ty::mk_uniq(self.tcx, {ty: mt_b.ty,\n-                                                  mutbl: m_const});\n-                self.crosspollinate(anmnt, a, nr_b, mt_b.mutbl, r_b)\n-              }\n-              (ty::ty_estr(vs_a),\n-               ty::ty_estr(ty::vstore_slice(r_b)))\n-              if is_borrowable(vs_a) => {\n-                let nr_b = ty::mk_estr(self.tcx, vs_a);\n-                self.crosspollinate(anmnt, a, nr_b, m_imm, r_b)\n-              }\n-\n-              (ty::ty_evec(_, vs_a),\n-               ty::ty_evec(mt_b, ty::vstore_slice(r_b)))\n-              if is_borrowable(vs_a) => {\n-                let nr_b = ty::mk_evec(self.tcx, {ty: mt_b.ty,\n-                                                  mutbl: m_const}, vs_a);\n-                self.crosspollinate(anmnt, a, nr_b, mt_b.mutbl, r_b)\n-              }\n-\n-              _ => {\n-                mk_sub(self, false, anmnt.span).tys(a, b).to_ures()\n-              }\n+            (Some(a_bnd), Some(b_bnd)) => {\n+                // check for a case where a non-region pointer (@, ~) is\n+                // being assigned to a region pointer:\n+                match (ty::get(a_bnd).struct, ty::get(b_bnd).struct) {\n+                    (ty::ty_box(_), ty::ty_rptr(r_b, mt_b)) => {\n+                        let nr_b = ty::mk_box(self.infcx.tcx,\n+                                              {ty: mt_b.ty, mutbl: m_const});\n+                        self.try_assign(a, nr_b, mt_b.mutbl, r_b)\n+                    }\n+                    (ty::ty_uniq(_), ty::ty_rptr(r_b, mt_b)) => {\n+                        let nr_b = ty::mk_uniq(self.infcx.tcx,\n+                                               {ty: mt_b.ty, mutbl: m_const});\n+                        self.try_assign(a, nr_b, mt_b.mutbl, r_b)\n+                    }\n+                    (ty::ty_estr(vs_a),\n+                     ty::ty_estr(ty::vstore_slice(r_b)))\n+                    if is_borrowable(vs_a) => {\n+                        let nr_b = ty::mk_estr(self.infcx.tcx, vs_a);\n+                        self.try_assign(a, nr_b, m_imm, r_b)\n+                    }\n+\n+                    (ty::ty_evec(_, vs_a),\n+                     ty::ty_evec(mt_b, ty::vstore_slice(r_b)))\n+                    if is_borrowable(vs_a) => {\n+                        let nr_b = ty::mk_evec(self.infcx.tcx,\n+                                               {ty: mt_b.ty, mutbl: m_const},\n+                                               vs_a);\n+                        self.try_assign(a, nr_b, mt_b.mutbl, r_b)\n+                    }\n+\n+                    _ => {\n+                        // otherwise, assignment follows normal subtype rules:\n+                        to_ares(Sub(*self).tys(a, b))\n+                    }\n+                }\n+            }\n+            _ => {\n+                // if insufficient bounds were available, just follow\n+                // normal subtype rules:\n+                to_ares(Sub(*self).tys(a, b))\n             }\n-          }\n-          _ => {\n-            mk_sub(self, false, anmnt.span).tys(a, b).to_ures()\n-          }\n         }\n     }\n \n-    fn crosspollinate(anmnt: &assignment,\n-                      a: ty::t,\n-                      nr_b: ty::t,\n-                      m: ast::mutability,\n-                      r_b: ty::region) -> ures {\n-\n-        debug!(\"crosspollinate(anmnt=%?, a=%s, nr_b=%s, r_b=%s)\",\n-               anmnt, a.to_str(self), nr_b.to_str(self),\n-               r_b.to_str(self));\n+    /// Given an assignment from a type like `@a` to `&r_b/m nr_b`,\n+    /// this function checks that `a <: nr_b`.  In that case, the\n+    /// assignment is permitted, so it constructs a fresh region\n+    /// variable `r_a >= r_b` and returns a corresponding assignment\n+    /// record.  See the discussion at the top of this file for more\n+    /// details.\n+    fn try_assign(a: ty::t,\n+                  nr_b: ty::t,\n+                  m: ast::mutability,\n+                  r_b: ty::region) -> ares {\n+\n+        debug!(\"try_assign(a=%s, nr_b=%s, m=%?, r_b=%s)\",\n+               a.to_str(self.infcx),\n+               nr_b.to_str(self.infcx),\n+               m,\n+               r_b.to_str(self.infcx));\n \n         do indent {\n-            let sub = mk_sub(self, false, anmnt.span);\n+            let sub = Sub(*self);\n             do sub.tys(a, nr_b).chain |_t| {\n-                // Create a fresh region variable `r_a` with the given\n-                // borrow bounds:\n-                let r_a = self.next_region_var(anmnt.span,\n-                                               anmnt.borrow_lb);\n-\n-                debug!(\"anmnt=%?\", anmnt);\n+                let r_a = self.infcx.next_region_var_nb(self.span);\n                 do sub.contraregions(r_a, r_b).chain |_r| {\n-                    // if successful, add an entry indicating that\n-                    // borrowing occurred\n-                    debug!(\"borrowing expression #%?, scope=%?, m=%?\",\n-                           anmnt, r_a, m);\n-                    self.borrowings.push({expr_id: anmnt.expr_id,\n-                                          span: anmnt.span,\n-                                          scope: r_a,\n-                                          mutbl: m});\n-                    uok()\n+                    Ok(Some({region: r_a, mutbl: m}))\n                 }\n             }\n         }"}]}