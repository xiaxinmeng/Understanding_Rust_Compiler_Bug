{"sha": "ff080d389dac079b3c7c8a7ad88b99660b05afa0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMDgwZDM4OWRhYzA3OWIzYzdjOGE3YWQ4OGI5OTY2MGIwNWFmYTA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-16T12:07:04Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-17T14:34:54Z"}, "message": "miri: track the Align instead of packedness in PtrAndAlign.", "tree": {"sha": "db742f700fac443675e2b0d9bcef609b43120da2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db742f700fac443675e2b0d9bcef609b43120da2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff080d389dac079b3c7c8a7ad88b99660b05afa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff080d389dac079b3c7c8a7ad88b99660b05afa0", "html_url": "https://github.com/rust-lang/rust/commit/ff080d389dac079b3c7c8a7ad88b99660b05afa0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff080d389dac079b3c7c8a7ad88b99660b05afa0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "html_url": "https://github.com/rust-lang/rust/commit/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd"}], "stats": {"total": 334, "additions": 152, "deletions": 182}, "files": [{"sha": "10da5e7843b5534cfbe2408ca69a566af8ac44e9", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff080d389dac079b3c7c8a7ad88b99660b05afa0/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff080d389dac079b3c7c8a7ad88b99660b05afa0/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=ff080d389dac079b3c7c8a7ad88b99660b05afa0", "patch": "@@ -1,6 +1,6 @@\n #![allow(unknown_lints)]\n \n-use ty::layout::HasDataLayout;\n+use ty::layout::{Align, HasDataLayout};\n \n use super::{EvalResult, MemoryPointer, PointerArithmetic};\n use syntax::ast::FloatTy;\n@@ -9,8 +9,7 @@ use rustc_const_math::ConstFloat;\n #[derive(Copy, Clone, Debug)]\n pub struct PtrAndAlign {\n     pub ptr: Pointer,\n-    /// Remember whether this place is *supposed* to be aligned.\n-    pub aligned: bool,\n+    pub align: Align,\n }\n \n impl PtrAndAlign {\n@@ -20,7 +19,7 @@ impl PtrAndAlign {\n     pub fn offset<'tcx, C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n         Ok(PtrAndAlign {\n             ptr: self.ptr.offset(i, cx)?,\n-            aligned: self.aligned,\n+            align: self.align,\n         })\n     }\n }\n@@ -182,13 +181,6 @@ pub enum PrimValKind {\n     Char,\n }\n \n-impl<'a, 'tcx: 'a> Value {\n-    #[inline]\n-    pub fn by_ref(ptr: Pointer) -> Self {\n-        Value::ByRef(PtrAndAlign { ptr, aligned: true })\n-    }\n-}\n-\n impl<'tcx> PrimVal {\n     pub fn from_u128(n: u128) -> Self {\n         PrimVal::Bytes(n)"}, {"sha": "4d9f55543e7cab0a65cd8702ae67cea9368d4934", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ff080d389dac079b3c7c8a7ad88b99660b05afa0/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff080d389dac079b3c7c8a7ad88b99660b05afa0/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=ff080d389dac079b3c7c8a7ad88b99660b05afa0", "patch": "@@ -77,7 +77,7 @@ pub fn eval_body<'a, 'tcx>(\n             instance,\n             mir.span,\n             mir,\n-            Place::from_ptr(ptr),\n+            Place::from_ptr(ptr, layout.align),\n             cleanup.clone(),\n         )?;\n \n@@ -357,10 +357,11 @@ pub fn const_eval_provider<'a, 'tcx>(\n             (_, Err(err)) => Err(err),\n             (Ok((miri_val, miri_ty)), Ok(ctfe)) => {\n                 let mut ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n-                check_ctfe_against_miri(&mut ecx, PtrAndAlign {\n+                let miri_ptr = PtrAndAlign {\n                     ptr: miri_val,\n-                    aligned: true\n-                }, miri_ty, ctfe.val);\n+                    align: ecx.layout_of(miri_ty).unwrap().align\n+                };\n+                check_ctfe_against_miri(&mut ecx, miri_ptr, miri_ty, ctfe.val);\n                 Ok(ctfe)\n             }\n         }\n@@ -380,7 +381,7 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n     use rustc::ty::TypeVariants::*;\n     match miri_ty.sty {\n         TyInt(int_ty) => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n+            let value = ecx.read_with_align(miri_val.align, |ectx| {\n                 ectx.try_read_value(miri_val.ptr, miri_ty)\n             });\n             let prim = get_prim(ecx, value);\n@@ -391,7 +392,7 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n             assert_eq!(c, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", c, ctfe);\n         },\n         TyUint(uint_ty) => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n+            let value = ecx.read_with_align(miri_val.align, |ectx| {\n                 ectx.try_read_value(miri_val.ptr, miri_ty)\n             });\n             let prim = get_prim(ecx, value);\n@@ -402,15 +403,15 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n             assert_eq!(c, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", c, ctfe);\n         },\n         TyFloat(ty) => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n+            let value = ecx.read_with_align(miri_val.align, |ectx| {\n                 ectx.try_read_value(miri_val.ptr, miri_ty)\n             });\n             let prim = get_prim(ecx, value);\n             let f = ConstVal::Float(ConstFloat { bits: prim, ty });\n             assert_eq!(f, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", f, ctfe);\n         },\n         TyBool => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n+            let value = ecx.read_with_align(miri_val.align, |ectx| {\n                 ectx.try_read_value(miri_val.ptr, miri_ty)\n             });\n             let bits = get_prim(ecx, value);\n@@ -421,7 +422,7 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n             assert_eq!(b, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", b, ctfe);\n         },\n         TyChar => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n+            let value = ecx.read_with_align(miri_val.align, |ectx| {\n                 ectx.try_read_value(miri_val.ptr, miri_ty)\n             });\n             let bits = get_prim(ecx, value);\n@@ -435,7 +436,7 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n             }\n         },\n         TyStr => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n+            let value = ecx.read_with_align(miri_val.align, |ectx| {\n                 ectx.try_read_value(miri_val.ptr, miri_ty)\n             });\n             if let Ok(Some(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)))) = value {\n@@ -522,8 +523,7 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n                     Field::new(field),\n                     layout,\n                 ).unwrap();\n-                let ptr = place.to_ptr_extra_aligned().0;\n-                check_ctfe_against_miri(ecx, ptr, elem.ty, elem.val);\n+                check_ctfe_against_miri(ecx, place.to_ptr_align(), elem.ty, elem.val);\n             }\n         },\n         TySlice(_) => bug!(\"miri produced a slice?\"),\n@@ -543,7 +543,7 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n         // should be fine\n         TyFnDef(..) => {}\n         TyFnPtr(_) => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n+            let value = ecx.read_with_align(miri_val.align, |ectx| {\n                 ectx.try_read_value(miri_val.ptr, miri_ty)\n             });\n             let ptr = match value {"}, {"sha": "b1febf5da5a149ae13c5b509d20812ac70925000", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 70, "deletions": 93, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/ff080d389dac079b3c7c8a7ad88b99660b05afa0/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff080d389dac079b3c7c8a7ad88b99660b05afa0/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=ff080d389dac079b3c7c8a7ad88b99660b05afa0", "patch": "@@ -241,7 +241,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         ))\n     }\n \n-    pub(super) fn const_to_value(&mut self, const_val: &ConstVal<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn const_to_value(&mut self, const_val: &ConstVal<'tcx>, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         use rustc::middle::const_val::ConstVal::*;\n \n         let primval = match *const_val {\n@@ -264,7 +264,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 return Ok(self.read_global_as_value(GlobalId {\n                     instance,\n                     promoted: None,\n-                }));\n+                }, self.layout_of(ty)?));\n             }\n \n             Aggregate(..) |\n@@ -637,7 +637,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let src = self.eval_place(place)?;\n                 // We ignore the alignment of the place here -- special handling for packed structs ends\n                 // at the `&` operator.\n-                let (ptr, extra) = self.force_allocation(src)?.to_ptr_extra_aligned();\n+                let (ptr, extra) = self.force_allocation(src)?.to_ptr_align_extra();\n \n                 let val = match extra {\n                     PlaceExtra::None => ptr.ptr.to_value(),\n@@ -677,7 +677,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 match kind {\n                     Unsize => {\n                         let src = self.eval_operand(operand)?;\n-                        self.unsize_into(src.value, src.ty, dest, dest_ty)?;\n+                        let src_layout = self.layout_of(src.ty)?;\n+                        let dst_layout = self.layout_of(dest_ty)?;\n+                        self.unsize_into(src.value, src_layout, dest, dst_layout)?;\n                     }\n \n                     Misc => {\n@@ -830,13 +832,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 use rustc::mir::Literal;\n                 let mir::Constant { ref literal, .. } = **constant;\n                 let value = match *literal {\n-                    Literal::Value { ref value } => self.const_to_value(&value.val)?,\n+                    Literal::Value { ref value } => self.const_to_value(&value.val, ty)?,\n \n                     Literal::Promoted { index } => {\n                         self.read_global_as_value(GlobalId {\n                             instance: self.frame().instance,\n                             promoted: Some(index),\n-                        })\n+                        }, self.layout_of(ty)?)\n                     }\n                 };\n \n@@ -948,10 +950,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_global_as_value(&self, gid: GlobalId) -> Value {\n+    pub fn read_global_as_value(&self, gid: GlobalId, layout: TyLayout) -> Value {\n         Value::ByRef(PtrAndAlign {\n             ptr: self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"global not cached\"),\n-            aligned: true\n+            align: layout.align\n         })\n     }\n \n@@ -979,11 +981,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     Some(val) => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n                         let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n+                        let layout = self.layout_of(ty)?;\n                         let ptr = self.alloc_ptr(ty)?;\n                         self.stack[frame].locals[local.index() - 1] =\n-                            Some(Value::by_ref(ptr.into())); // it stays live\n+                            Some(Value::ByRef(PtrAndAlign {\n+                                ptr: ptr.into(),\n+                                align: layout.align\n+                            })); // it stays live\n                         self.write_value_to_ptr(val, ptr.into(), ty)?;\n-                        Place::from_ptr(ptr)\n+                        Place::from_ptr(ptr, layout.align)\n                     }\n                 }\n             }\n@@ -999,8 +1005,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n         match value {\n-            Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n-                self.read_maybe_aligned(aligned, |ectx| ectx.read_value(ptr, ty))\n+            Value::ByRef(PtrAndAlign { ptr, align }) => {\n+                self.read_with_align(align, |ectx| ectx.read_value(ptr, ty))\n             }\n             other => Ok(other),\n         }\n@@ -1056,14 +1062,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n         match dest {\n             Place::Ptr {\n-                ptr: PtrAndAlign { ptr, aligned },\n+                ptr: PtrAndAlign { ptr, align },\n                 extra,\n             } => {\n                 assert_eq!(extra, PlaceExtra::None);\n-                self.write_maybe_aligned_mut(\n-                    aligned,\n-                    |ectx| ectx.write_value_to_ptr(src_val, ptr, dest_ty),\n-                )\n+                self.write_with_align_mut(align,\n+                    |ectx| ectx.write_value_to_ptr(src_val, ptr, dest_ty))\n             }\n \n             Place::Local { frame, local } => {\n@@ -1088,7 +1092,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     ) -> EvalResult<'tcx> {\n         if let Value::ByRef(PtrAndAlign {\n                                 ptr: dest_ptr,\n-                                aligned,\n+                                align,\n                             }) = old_dest_val\n         {\n             // If the value is already `ByRef` (that is, backed by an `Allocation`),\n@@ -1098,13 +1102,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             //\n             // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n             // knew for certain that there were no outstanding pointers to this allocation.\n-            self.write_maybe_aligned_mut(aligned, |ectx| {\n+            self.write_with_align_mut(align, |ectx| {\n                 ectx.write_value_to_ptr(src_val, dest_ptr, dest_ty)\n             })?;\n \n         } else if let Value::ByRef(PtrAndAlign {\n                                        ptr: src_ptr,\n-                                       aligned,\n+                                       align,\n                                    }) = src_val\n         {\n             // If the value is not `ByRef`, then we know there are no pointers to it\n@@ -1118,13 +1122,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // It is a valid optimization to attempt reading a primitive value out of the\n             // source and write that into the destination without making an allocation, so\n             // we do so here.\n-            self.read_maybe_aligned_mut(aligned, |ectx| {\n+            self.read_with_align_mut(align, |ectx| {\n                 if let Ok(Some(src_val)) = ectx.try_read_value(src_ptr, dest_ty) {\n                     write_dest(ectx, src_val)?;\n                 } else {\n                     let dest_ptr = ectx.alloc_ptr(dest_ty)?.into();\n                     ectx.copy(src_ptr, dest_ptr, dest_ty)?;\n-                    write_dest(ectx, Value::by_ref(dest_ptr))?;\n+                    let layout = ectx.layout_of(dest_ty)?;\n+                    write_dest(ectx, Value::ByRef(PtrAndAlign {\n+                        ptr: dest_ptr,\n+                        align: layout.align\n+                    }))?;\n                 }\n                 Ok(())\n             })?;\n@@ -1145,8 +1153,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     ) -> EvalResult<'tcx> {\n         trace!(\"write_value_to_ptr: {:#?}\", value);\n         match value {\n-            Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n-                self.read_maybe_aligned_mut(aligned, |ectx| ectx.copy(ptr, dest, dest_ty))\n+            Value::ByRef(PtrAndAlign { ptr, align }) => {\n+                self.read_with_align_mut(align, |ectx| ectx.copy(ptr, dest, dest_ty))\n             }\n             Value::ByVal(primval) => {\n                 let layout = self.layout_of(dest_ty)?;\n@@ -1441,101 +1449,71 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn unsize_into(\n         &mut self,\n         src: Value,\n-        src_ty: Ty<'tcx>,\n+        src_layout: TyLayout<'tcx>,\n         dst: Place,\n-        dst_ty: Ty<'tcx>,\n+        dst_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        let src_layout = self.layout_of(src_ty)?;\n-        let dst_layout = self.layout_of(dst_ty)?;\n-        match (&src_ty.sty, &dst_ty.sty) {\n+        match (&src_layout.ty.sty, &dst_layout.ty.sty) {\n             (&ty::TyRef(_, ref s), &ty::TyRef(_, ref d)) |\n             (&ty::TyRef(_, ref s), &ty::TyRawPtr(ref d)) |\n             (&ty::TyRawPtr(ref s), &ty::TyRawPtr(ref d)) => {\n-                self.unsize_into_ptr(src, src_ty, dst, dst_ty, s.ty, d.ty)\n+                self.unsize_into_ptr(src, src_layout.ty, dst, dst_layout.ty, s.ty, d.ty)\n             }\n             (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n+                assert_eq!(def_a, def_b);\n                 if def_a.is_box() || def_b.is_box() {\n                     if !def_a.is_box() || !def_b.is_box() {\n-                        panic!(\"invalid unsizing between {:?} -> {:?}\", src_ty, dst_ty);\n+                        bug!(\"invalid unsizing between {:?} -> {:?}\", src_layout, dst_layout);\n                     }\n                     return self.unsize_into_ptr(\n                         src,\n-                        src_ty,\n+                        src_layout.ty,\n                         dst,\n-                        dst_ty,\n-                        src_ty.boxed_ty(),\n-                        dst_ty.boxed_ty(),\n+                        dst_layout.ty,\n+                        src_layout.ty.boxed_ty(),\n+                        dst_layout.ty.boxed_ty(),\n                     );\n                 }\n-                if self.ty_to_primval_kind(src_ty).is_ok() {\n-                    // TODO: We ignore the packed flag here\n-                    let sty = src_layout.field(&self, 0)?.ty;\n-                    let dty = dst_layout.field(&self, 0)?.ty;\n-                    return self.unsize_into(src, sty, dst, dty);\n-                }\n+\n                 // unsizing of generic struct with pointer fields\n                 // Example: `Arc<T>` -> `Arc<Trait>`\n                 // here we need to increase the size of every &T thin ptr field to a fat ptr\n-\n-                assert_eq!(def_a, def_b);\n-\n-                let src_ptr = match src {\n-                    Value::ByRef(PtrAndAlign { ptr, aligned: true }) => ptr,\n-                    // the entire struct is just a pointer\n-                    Value::ByVal(_) => {\n-                        for i in 0..src_layout.fields.count() {\n-                            let src_field = src_layout.field(&self, i)?;\n-                            let dst_field = dst_layout.field(&self, i)?;\n-                            if dst_layout.is_zst() {\n-                                continue;\n-                            }\n-                            assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n-                            assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n-                            assert_eq!(src_field.size, src_layout.size);\n-                            assert_eq!(dst_field.size, dst_layout.size);\n-                            return self.unsize_into(\n-                                src,\n-                                src_field.ty,\n-                                dst,\n-                                dst_field.ty,\n-                            );\n-                        }\n-                        bug!(\"by val unsize into where the value doesn't cover the entire type\")\n-                    }\n-                    // TODO: Is it possible for unaligned pointers to occur here?\n-                    _ => bug!(\"expected aligned pointer, got {:?}\", src),\n-                };\n-\n-                // FIXME(solson)\n-                let dst = self.force_allocation(dst)?.to_ptr()?;\n                 for i in 0..src_layout.fields.count() {\n-                    let src_field = src_layout.field(&self, i)?;\n-                    let dst_field = dst_layout.field(&self, i)?;\n+                    let (dst_f_place, dst_field) =\n+                        self.place_field(dst, mir::Field::new(i), dst_layout)?;\n                     if dst_field.is_zst() {\n                         continue;\n                     }\n-                    let src_field_offset = src_layout.fields.offset(i).bytes();\n-                    let dst_field_offset = dst_layout.fields.offset(i).bytes();\n-                    let src_f_ptr = src_ptr.offset(src_field_offset, &self)?;\n-                    let dst_f_ptr = dst.offset(dst_field_offset, &self)?;\n+                    let (src_f_value, src_field) = match src {\n+                        Value::ByRef(PtrAndAlign { ptr, align }) => {\n+                            let src_place = Place::from_primval_ptr(ptr, align);\n+                            let (src_f_place, src_field) =\n+                                self.place_field(src_place, mir::Field::new(i), src_layout)?;\n+                            (self.read_place(src_f_place)?, src_field)\n+                        }\n+                        Value::ByVal(_) | Value::ByValPair(..) => {\n+                            let src_field = src_layout.field(&self, i)?;\n+                            assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n+                            assert_eq!(src_field.size, src_layout.size);\n+                            (src, src_field)\n+                        }\n+                    };\n                     if src_field.ty == dst_field.ty {\n-                        self.copy(src_f_ptr, dst_f_ptr.into(), src_field.ty)?;\n+                        self.write_value(ValTy {\n+                            value: src_f_value,\n+                            ty: src_field.ty,\n+                        }, dst_f_place)?;\n                     } else {\n-                        self.unsize_into(\n-                            Value::by_ref(src_f_ptr),\n-                            src_field.ty,\n-                            Place::from_ptr(dst_f_ptr),\n-                            dst_field.ty,\n-                        )?;\n+                        self.unsize_into(src_f_value, src_field, dst_f_place, dst_field)?;\n                     }\n                 }\n                 Ok(())\n             }\n             _ => {\n                 bug!(\n                     \"unsize_into: invalid conversion: {:?} -> {:?}\",\n-                    src_ty,\n-                    dst_ty\n+                    src_layout,\n+                    dst_layout\n                 )\n             }\n         }\n@@ -1559,11 +1537,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     Err(err) => {\n                         panic!(\"Failed to access local: {:?}\", err);\n                     }\n-                    Ok(Value::ByRef(PtrAndAlign { ptr, aligned })) => {\n+                    Ok(Value::ByRef(PtrAndAlign { ptr, align })) => {\n                         match ptr.into_inner_primval() {\n                             PrimVal::Ptr(ptr) => {\n-                                write!(msg, \" by {}ref:\", if aligned { \"\" } else { \"unaligned \" })\n-                                    .unwrap();\n+                                write!(msg, \" by align({}) ref:\", align.abi()).unwrap();\n                                 allocs.push(ptr.alloc_id);\n                             }\n                             ptr => write!(msg, \" integral by ref: {:?}\", ptr).unwrap(),\n@@ -1589,10 +1566,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 trace!(\"{}\", msg);\n                 self.memory.dump_allocs(allocs);\n             }\n-            Place::Ptr { ptr: PtrAndAlign { ptr, aligned }, .. } => {\n+            Place::Ptr { ptr: PtrAndAlign { ptr, align }, .. } => {\n                 match ptr.into_inner_primval() {\n                     PrimVal::Ptr(ptr) => {\n-                        trace!(\"by {}ref:\", if aligned { \"\" } else { \"unaligned \" });\n+                        trace!(\"by align({}) ref:\", align.abi());\n                         self.memory.dump_alloc(ptr.alloc_id);\n                     }\n                     ptr => trace!(\" integral by ref: {:?}\", ptr),"}, {"sha": "579977ba4a48cbbfc864b3db107301a3fa66aa61", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ff080d389dac079b3c7c8a7ad88b99660b05afa0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff080d389dac079b3c7c8a7ad88b99660b05afa0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=ff080d389dac079b3c7c8a7ad88b99660b05afa0", "patch": "@@ -4,7 +4,7 @@ use std::{ptr, mem, io};\n use std::cell::Cell;\n \n use rustc::ty::{Instance, TyCtxt};\n-use rustc::ty::layout::{self, TargetDataLayout};\n+use rustc::ty::layout::{self, Align, TargetDataLayout};\n use syntax::ast::Mutability;\n \n use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, UndefMask, PtrAndAlign, Value, Pointer,\n@@ -51,10 +51,10 @@ pub struct Memory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     /// Maximum number of virtual bytes that may be allocated.\n     memory_size: u64,\n \n-    /// To avoid having to pass flags to every single memory access, we have some global state saying whether\n+    /// To avoid having to pass flags to every single memory access, we have some global state saying how\n     /// alignment checking is currently enforced for read and/or write accesses.\n-    reads_are_aligned: Cell<bool>,\n-    writes_are_aligned: Cell<bool>,\n+    read_align_override: Cell<Option<Align>>,\n+    write_align_override: Cell<Option<Align>>,\n \n     /// The current stack frame.  Used to check accesses against locks.\n     pub cur_frame: usize,\n@@ -72,8 +72,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             tcx,\n             memory_size: max_memory,\n             memory_usage: 0,\n-            reads_are_aligned: Cell::new(true),\n-            writes_are_aligned: Cell::new(true),\n+            read_align_override: Cell::new(None),\n+            write_align_override: Cell::new(None),\n             cur_frame: usize::max_value(),\n         }\n     }\n@@ -272,14 +272,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             PrimVal::Undef => return err!(ReadUndefBytes),\n         };\n         // See if alignment checking is disabled\n-        let enforce_alignment = match access {\n-            Some(AccessKind::Read) => self.reads_are_aligned.get(),\n-            Some(AccessKind::Write) => self.writes_are_aligned.get(),\n-            None => true,\n+        let align_override = match access {\n+            Some(AccessKind::Read) => self.read_align_override.get(),\n+            Some(AccessKind::Write) => self.write_align_override.get(),\n+            None => None,\n         };\n-        if !enforce_alignment {\n-            return Ok(());\n-        }\n+        let align = align_override.map_or(align, |o| o.abi().min(align));\n         // Check alignment\n         if alloc_align < align {\n             return err!(AlignmentCheckFailed {\n@@ -1005,39 +1003,39 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     fn memory(&self) -> &Memory<'a, 'tcx, M>;\n \n     // These are not supposed to be overriden.\n-    fn read_maybe_aligned<F, T>(&self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n+    fn read_with_align<F, T>(&self, align: Align, f: F) -> EvalResult<'tcx, T>\n     where\n         F: FnOnce(&Self) -> EvalResult<'tcx, T>,\n     {\n-        let old = self.memory().reads_are_aligned.get();\n-        // Do alignment checking if *all* nested calls say it has to be aligned.\n-        self.memory().reads_are_aligned.set(old && aligned);\n+        let old = self.memory().read_align_override.get();\n+        // Do alignment checking for the minimum align out of *all* nested calls.\n+        self.memory().read_align_override.set(Some(old.map_or(align, |old| old.min(align))));\n         let t = f(self);\n-        self.memory().reads_are_aligned.set(old);\n+        self.memory().read_align_override.set(old);\n         t\n     }\n \n-    fn read_maybe_aligned_mut<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n+    fn read_with_align_mut<F, T>(&mut self, align: Align, f: F) -> EvalResult<'tcx, T>\n     where\n         F: FnOnce(&mut Self) -> EvalResult<'tcx, T>,\n     {\n-        let old = self.memory().reads_are_aligned.get();\n-        // Do alignment checking if *all* nested calls say it has to be aligned.\n-        self.memory().reads_are_aligned.set(old && aligned);\n+        let old = self.memory().read_align_override.get();\n+        // Do alignment checking for the minimum align out of *all* nested calls.\n+        self.memory().read_align_override.set(Some(old.map_or(align, |old| old.min(align))));\n         let t = f(self);\n-        self.memory().reads_are_aligned.set(old);\n+        self.memory().read_align_override.set(old);\n         t\n     }\n \n-    fn write_maybe_aligned_mut<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n+    fn write_with_align_mut<F, T>(&mut self, align: Align, f: F) -> EvalResult<'tcx, T>\n     where\n         F: FnOnce(&mut Self) -> EvalResult<'tcx, T>,\n     {\n-        let old = self.memory().writes_are_aligned.get();\n-        // Do alignment checking if *all* nested calls say it has to be aligned.\n-        self.memory().writes_are_aligned.set(old && aligned);\n+        let old = self.memory().write_align_override.get();\n+        // Do alignment checking for the minimum align out of *all* nested calls.\n+        self.memory().write_align_override.set(Some(old.map_or(align, |old| old.min(align))));\n         let t = f(self);\n-        self.memory().writes_are_aligned.set(old);\n+        self.memory().write_align_override.set(old);\n         t\n     }\n \n@@ -1048,8 +1046,8 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n         value: Value,\n     ) -> EvalResult<'tcx, Pointer> {\n         Ok(match value {\n-            Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n-                self.memory().read_maybe_aligned(aligned, |mem| mem.read_ptr_sized_unsigned(ptr.to_ptr()?))?\n+            Value::ByRef(PtrAndAlign { ptr, align }) => {\n+                self.memory().read_with_align(align, |mem| mem.read_ptr_sized_unsigned(ptr.to_ptr()?))?\n             }\n             Value::ByVal(ptr) |\n             Value::ByValPair(ptr, _) => ptr,\n@@ -1063,9 +1061,9 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n         match value {\n             Value::ByRef(PtrAndAlign {\n                       ptr: ref_ptr,\n-                      aligned,\n+                      align,\n                   }) => {\n-                self.memory().read_maybe_aligned(aligned, |mem| {\n+                self.memory().read_with_align(align, |mem| {\n                     let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n                     let vtable = mem.read_ptr_sized_unsigned(\n                         ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n@@ -1088,9 +1086,9 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n         match value {\n             Value::ByRef(PtrAndAlign {\n                       ptr: ref_ptr,\n-                      aligned,\n+                      align,\n                   }) => {\n-                self.memory().read_maybe_aligned(aligned, |mem| {\n+                self.memory().read_with_align(align, |mem| {\n                     let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n                     let len = mem.read_ptr_sized_unsigned(\n                         ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,"}, {"sha": "baccdd381d647abcf4647edb154e1c528c05c8e8", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ff080d389dac079b3c7c8a7ad88b99660b05afa0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff080d389dac079b3c7c8a7ad88b99660b05afa0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=ff080d389dac079b3c7c8a7ad88b99660b05afa0", "patch": "@@ -1,6 +1,6 @@\n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, LayoutOf, TyLayout};\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::mir::interpret::{GlobalId, PtrAndAlign};\n \n@@ -35,34 +35,37 @@ pub enum PlaceExtra {\n impl<'tcx> Place {\n     /// Produces an Place that will error if attempted to be read from\n     pub fn undef() -> Self {\n-        Self::from_primval_ptr(PrimVal::Undef.into())\n+        Self::from_primval_ptr(PrimVal::Undef.into(), Align::from_bytes(1, 1).unwrap())\n     }\n \n-    pub fn from_primval_ptr(ptr: Pointer) -> Self {\n+    pub fn from_primval_ptr(ptr: Pointer, align: Align) -> Self {\n         Place::Ptr {\n-            ptr: PtrAndAlign { ptr, aligned: true },\n+            ptr: PtrAndAlign { ptr, align },\n             extra: PlaceExtra::None,\n         }\n     }\n \n-    pub fn from_ptr(ptr: MemoryPointer) -> Self {\n-        Self::from_primval_ptr(ptr.into())\n+    pub fn from_ptr(ptr: MemoryPointer, align: Align) -> Self {\n+        Self::from_primval_ptr(ptr.into(), align)\n     }\n \n-    pub fn to_ptr_extra_aligned(self) -> (PtrAndAlign, PlaceExtra) {\n+    pub fn to_ptr_align_extra(self) -> (PtrAndAlign, PlaceExtra) {\n         match self {\n             Place::Ptr { ptr, extra } => (ptr, extra),\n             _ => bug!(\"to_ptr_and_extra: expected Place::Ptr, got {:?}\", self),\n \n         }\n     }\n \n+    pub fn to_ptr_align(self) -> PtrAndAlign {\n+        let (ptr, _extra) = self.to_ptr_align_extra();\n+        ptr\n+    }\n+\n     pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n-        let (ptr, extra) = self.to_ptr_extra_aligned();\n         // At this point, we forget about the alignment information -- the place has been turned into a reference,\n         // and no matter where it came from, it now must be aligned.\n-        assert_eq!(extra, PlaceExtra::None);\n-        ptr.to_ptr()\n+        self.to_ptr_align().to_ptr()\n     }\n \n     pub(super) fn elem_ty_and_len(self, ty: Ty<'tcx>) -> (Ty<'tcx>, u64) {\n@@ -102,11 +105,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // Directly reading a static will always succeed\n             Static(ref static_) => {\n                 let instance = ty::Instance::mono(self.tcx, static_.def_id);\n-                let cid = GlobalId {\n+                Ok(Some(self.read_global_as_value(GlobalId {\n                     instance,\n                     promoted: None,\n-                };\n-                Ok(Some(self.read_global_as_value(cid)))\n+                }, self.layout_of(self.place_ty(place))?)))\n             }\n             Projection(ref proj) => self.try_read_place_projection(proj),\n         }\n@@ -190,10 +192,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     instance,\n                     promoted: None,\n                 };\n+                let layout = self.layout_of(self.place_ty(mir_place))?;\n                 Place::Ptr {\n                     ptr: PtrAndAlign {\n                         ptr: self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"uncached global\"),\n-                        aligned: true\n+                        align: layout.align\n                     },\n                     extra: PlaceExtra::None,\n                 }\n@@ -241,7 +244,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     {\n                         return Ok((base, field));\n                     }\n-                    _ => self.force_allocation(base)?.to_ptr_extra_aligned(),\n+                    _ => self.force_allocation(base)?.to_ptr_align_extra(),\n                 }\n             }\n         };\n@@ -258,7 +261,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         };\n \n         let mut ptr = base_ptr.offset(offset, &self)?;\n-        ptr.aligned &= base_layout.align.abi() >= field.align.abi();\n+        ptr.align = ptr.align.min(base_layout.align).min(field.align);\n \n         let extra = if !field.is_unsized() {\n             PlaceExtra::None\n@@ -278,22 +281,23 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn val_to_place(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Place> {\n+        let layout = self.layout_of(ty)?;\n         Ok(match self.tcx.struct_tail(ty).sty {\n             ty::TyDynamic(..) => {\n                 let (ptr, vtable) = self.into_ptr_vtable_pair(val)?;\n                 Place::Ptr {\n-                    ptr: PtrAndAlign { ptr, aligned: true },\n+                    ptr: PtrAndAlign { ptr, align: layout.align },\n                     extra: PlaceExtra::Vtable(vtable),\n                 }\n             }\n             ty::TyStr | ty::TySlice(_) => {\n                 let (ptr, len) = self.into_slice(val)?;\n                 Place::Ptr {\n-                    ptr: PtrAndAlign { ptr, aligned: true },\n+                    ptr: PtrAndAlign { ptr, align: layout.align },\n                     extra: PlaceExtra::Length(len),\n                 }\n             }\n-            _ => Place::from_primval_ptr(self.into_ptr(val)?),\n+            _ => Place::from_primval_ptr(self.into_ptr(val)?, layout.align),\n         })\n     }\n \n@@ -305,7 +309,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     ) -> EvalResult<'tcx, Place> {\n         // Taking the outer type here may seem odd; it's needed because for array types, the outer type gives away the length.\n         let base = self.force_allocation(base)?;\n-        let (base_ptr, _) = base.to_ptr_extra_aligned();\n+        let base_ptr = base.to_ptr_align();\n \n         let (elem_ty, len) = base.elem_ty_and_len(outer_ty);\n         let elem_size = self.layout_of(elem_ty)?.size.bytes();\n@@ -329,7 +333,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     ) -> EvalResult<'tcx, Place> {\n         // FIXME(solson)\n         let base = self.force_allocation(base)?;\n-        let (ptr, _) = base.to_ptr_extra_aligned();\n+        let ptr = base.to_ptr_align();\n         let extra = PlaceExtra::DowncastVariant(variant);\n         Ok(Place::Ptr { ptr, extra })\n     }\n@@ -380,7 +384,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             } => {\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let (base_ptr, _) = base.to_ptr_extra_aligned();\n+                let base_ptr = base.to_ptr_align();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.layout_of(elem_ty)?.size.bytes();\n@@ -399,7 +403,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             Subslice { from, to } => {\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let (base_ptr, _) = base.to_ptr_extra_aligned();\n+                let base_ptr = base.to_ptr_align();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.layout_of(elem_ty)?.size.bytes();"}, {"sha": "23ef03b051027cade86c10c39689aab5f955e95f", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff080d389dac079b3c7c8a7ad88b99660b05afa0/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff080d389dac079b3c7c8a7ad88b99660b05afa0/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=ff080d389dac079b3c7c8a7ad88b99660b05afa0", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             instance,\n             span,\n             mir,\n-            Place::from_ptr(ptr),\n+            Place::from_ptr(ptr, layout.align),\n             cleanup,\n         )?;\n         Ok(true)\n@@ -273,7 +273,7 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                         this.instance,\n                         constant.span,\n                         mir,\n-                        Place::from_ptr(ptr),\n+                        Place::from_ptr(ptr, layout.align),\n                         StackPopCleanup::MarkStatic(Mutability::Immutable),\n                     )?;\n                     Ok(true)"}, {"sha": "64216b715a5ab08ec8ad6052e0219f9fa7fdcd56", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff080d389dac079b3c7c8a7ad88b99660b05afa0/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff080d389dac079b3c7c8a7ad88b99660b05afa0/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=ff080d389dac079b3c7c8a7ad88b99660b05afa0", "patch": "@@ -327,15 +327,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         if let ty::TyTuple(..) = args[1].ty.sty {\n                             if self.frame().mir.args_iter().count() == layout.fields.count() + 1 {\n                                 match args[1].value {\n-                                    Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n-                                        assert!(\n-                                            aligned,\n-                                            \"Unaligned ByRef-values cannot occur as function arguments\"\n-                                        );\n+                                    Value::ByRef(PtrAndAlign { ptr, align }) => {\n                                         for (i, arg_local) in arg_locals.enumerate() {\n                                             let field = layout.field(&self, i)?;\n                                             let offset = layout.fields.offset(i).bytes();\n-                                            let arg = Value::by_ref(ptr.offset(offset, &self)?);\n+                                            let arg = Value::ByRef(PtrAndAlign {\n+                                                ptr: ptr.offset(offset, &self)?,\n+                                                align: align.min(field.align)\n+                                            });\n                                             let dest =\n                                                 self.eval_place(&mir::Place::Local(arg_local))?;\n                                             trace!("}]}