{"sha": "6ddd011ce8875c6c5b119e5a8957a51d524a95da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZGQwMTFjZTg4NzVjNmM1YjExOWU1YTg5NTdhNTFkNTI0YTk1ZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-08T04:46:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-08T04:46:39Z"}, "message": "auto merge of #9735 : alexcrichton/rust/privacy, r=cmr\n\nThis is the culmination and attempted resolution of #8215. The commits have many more details about implementation details and the consequences of this refinement.\r\n\r\nI'll point out specific locations which may be possible causes for alarm. In general, I have been very happy with how things have turned out. I'm a little sad that I couldn't remove privacy from resolve as much as I did, but I blame glob imports (although in theory even some of this can be mitigated as well).", "tree": {"sha": "e9c5f3265e5d614bf9682dd09410978be2d0e39d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9c5f3265e5d614bf9682dd09410978be2d0e39d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ddd011ce8875c6c5b119e5a8957a51d524a95da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ddd011ce8875c6c5b119e5a8957a51d524a95da", "html_url": "https://github.com/rust-lang/rust/commit/6ddd011ce8875c6c5b119e5a8957a51d524a95da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ddd011ce8875c6c5b119e5a8957a51d524a95da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "132099950fc1d157b9af0130cf3f1eb20a263541", "url": "https://api.github.com/repos/rust-lang/rust/commits/132099950fc1d157b9af0130cf3f1eb20a263541", "html_url": "https://github.com/rust-lang/rust/commit/132099950fc1d157b9af0130cf3f1eb20a263541"}, {"sha": "7cd66924252a46c1b4524b9de4ad5e4cfc1c1faa", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cd66924252a46c1b4524b9de4ad5e4cfc1c1faa", "html_url": "https://github.com/rust-lang/rust/commit/7cd66924252a46c1b4524b9de4ad5e4cfc1c1faa"}], "stats": {"total": 3087, "additions": 1861, "deletions": 1226}, "files": [{"sha": "83833afb90e95f5609c80f6a3a388cfeee7c60af", "filename": "doc/rust.md", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -1501,6 +1501,171 @@ is `extern \"abi\" fn(A1, ..., An) -> R`,\n where `A1...An` are the declared types of its arguments\n and `R` is the decalred return type.\n \n+## Visibility and Privacy\n+\n+These two terms are often used interchangeably, and what they are attempting to\n+convey is the answer to the question \"Can this item be used at this location?\"\n+\n+Rust's name resolution operates on a global hierarchy of namespaces. Each level\n+in the hierarchy can be thought of as some item. The items are one of those\n+mentioned above, but also include external crates. Declaring or defining a new\n+module can be thought of as inserting a new tree into the hierarchy at the\n+location of the definition.\n+\n+To control whether interfaces can be used across modules, Rust checks each use\n+of an item to see whether it should be allowed or not. This is where privacy\n+warnings are generated, or otherwise \"you used a private item of another module\n+and weren't allowed to.\"\n+\n+By default, everything in rust is *private*, with two exceptions. The first\n+exception is that struct fields are public by default (but the struct itself is\n+still private by default), and the remaining exception is that enum variants in\n+a `pub` enum are the default visibility of the enum container itself.. You are\n+allowed to alter this default visibility with the `pub` keyword (or `priv`\n+keyword for struct fields and enum variants). When an item is declared as `pub`,\n+it can be thought of as being accessible to the outside world. For example:\n+\n+~~~\n+// Declare a private struct\n+struct Foo;\n+\n+// Declare a public struct with a private field\n+pub struct Bar {\n+    priv field: int\n+}\n+\n+// Declare a public enum with public and private variants\n+pub enum State {\n+    PubliclyAccessibleState,\n+    priv PrivatelyAccessibleState\n+}\n+~~~\n+\n+With the notion of an item being either public or private, Rust allows item\n+accesses in two cases:\n+\n+1. If an item is public, then it can be used externally through any of its\n+   public ancestors.\n+2. If an item is private, it may be accessed by the current module and its\n+   descendants.\n+\n+These two cases are surprisingly powerful for creating module hierarchies\n+exposing public APIs while hiding internal implementation details. To help\n+explain, here's a few use cases and what they would entail.\n+\n+* A library developer needs to expose functionality to crates which link against\n+  their library. As a consequence of the first case, this means that anything\n+  which is usable externally must be `pub` from the root down to the destination\n+  item. Any private item in the chain will disallow external accesses.\n+\n+* A crate needs a global available \"helper module\" to itself, but it doesn't\n+  want to expose the helper module as a public API. To accomplish this, the root\n+  of the crate's hierarchy would have a private module which then internally has\n+  a \"public api\". Because the entire crate is an ancestor of the root, then the\n+  entire local crate can access this private module through the second case.\n+\n+* When writing unit tests for a module, it's often a common idiom to have an\n+  immediate child of the module to-be-tested named `mod test`. This module could\n+  access any items of the parent module through the second case, meaning that\n+  internal implementation details could also be seamlessly tested from the child\n+  module.\n+\n+In the second case, it mentions that a private item \"can be accessed\" by the\n+current module and its descendants, but the exact meaning of accessing an item\n+depends on what the item is. Accessing a module, for example, would mean looking\n+inside of it (to import more items). On the other hand, accessing a function\n+would mean that it is invoked.\n+\n+Here's an example of a program which exemplifies the three cases outlined above.\n+\n+~~~\n+// This module is private, meaning that no external crate can access this\n+// module. Because it is private at the root of this current crate, however, any\n+// module in the crate may access any publicly visible item in this module.\n+mod crate_helper_module {\n+\n+    // This function can be used by anything in the current crate\n+    pub fn crate_helper() {}\n+\n+    // This function *cannot* be used by anything else in the crate. It is not\n+    // publicly visible outside of the `crate_helper_module`, so only this\n+    // current module and its descendants may access it.\n+    fn implementation_detail() {}\n+}\n+\n+// This function is \"public to the root\" meaning that it's available to external\n+// crates linking against this one.\n+pub fn public_api() {}\n+\n+// Similarly to 'public_api', this module is public so external crates may look\n+// inside of it.\n+pub mod submodule {\n+    use crate_helper_module;\n+\n+    pub fn my_method() {\n+        // Any item in the local crate may invoke the helper module's public\n+        // interface through a combination of the two rules above.\n+        crate_helper_module::crate_helper();\n+    }\n+\n+    // This function is hidden to any module which is not a descendant of\n+    // `submodule`\n+    fn my_implementation() {}\n+\n+    #[cfg(test)]\n+    mod test {\n+\n+        #[test]\n+        fn test_my_implementation() {\n+            // Because this module is a descendant of `submodule`, it's allowed\n+            // to access private items inside of `submodule` without a privacy\n+            // violation.\n+            super::my_implementation();\n+        }\n+    }\n+}\n+\n+# fn main() {}\n+~~~\n+\n+For a rust program to pass the privacy checking pass, all paths must be valid\n+accesses given the two rules above. This includes all use statements,\n+expressions, types, etc.\n+\n+### Re-exporting and Visibility\n+\n+Rust allows publicly re-exporting items through a `pub use` directive. Because\n+this is a public directive, this allows the item to be used in the current\n+module through the rules above. It essentially allows public access into the\n+re-exported item. For example, this program is valid:\n+\n+~~~\n+pub use api = self::implementation;\n+\n+mod implementation {\n+    pub fn f() {}\n+}\n+\n+# fn main() {}\n+~~~\n+\n+This means that any external crate referencing `implementation::f` would receive\n+a privacy violation, while the path `api::f` would be allowed.\n+\n+When re-exporting a private item, it can be thought of as allowing the \"privacy\n+chain\" being short-circuited through the reexport instead of passing through the\n+namespace hierarchy as it normally would.\n+\n+### Glob imports and Visibility\n+\n+Currently glob imports are considered an \"experimental\" language feature. For\n+sanity purpose along with helping the implementation, glob imports will only\n+import public items from their destination, not private items.\n+\n+> **Note:** This is subject to change, glob exports may be removed entirely or\n+> they could possibly import private items for a privacy error to later be\n+> issued if the item is used.\n+\n ## Attributes\n \n ~~~~~~~~{.ebnf .gram}"}, {"sha": "b2da355b12201a823ebaaa05c262ddcb1a5203e8", "filename": "doc/tutorial.md", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -2322,19 +2322,18 @@ fn main() {\n \n The `::farm::chicken` construct is what we call a 'path'.\n \n-Because it's starting with a `::`, it's also a 'global path',\n-which qualifies an item by its full path in the module hierarchy\n-relative to the crate root.\n+Because it's starting with a `::`, it's also a 'global path', which qualifies\n+an item by its full path in the module hierarchy relative to the crate root.\n \n-If the path were to start with a regular identifier, like `farm::chicken`, it would be\n-a 'local path' instead. We'll get to them later.\n+If the path were to start with a regular identifier, like `farm::chicken`, it\n+would be a 'local path' instead. We'll get to them later.\n \n-Now, if you actually tried to compile this code example, you'll notice\n-that you get a `unresolved name: 'farm::chicken'` error. That's because per default,\n-items (`fn`, `struct`, `static`, `mod`, ...) are only visible inside the module\n-they are defined in.\n+Now, if you actually tried to compile this code example, you'll notice that you\n+get a `function 'chicken' is private` error. That's because by default, items\n+(`fn`, `struct`, `static`, `mod`, ...) are private.\n \n-To make them visible outside their containing modules, you need to mark them _public_ with `pub`:\n+To make them visible outside their containing modules, you need to mark them\n+_public_ with `pub`:\n \n ~~~~\n mod farm {\n@@ -2356,7 +2355,8 @@ Rust doesn't support encapsulation: both struct fields and methods can\n be private. But this encapsulation is at the module level, not the\n struct level.\n \n-For convenience, fields are _public_ by default, and can be made _private_ with the `priv` keyword:\n+For convenience, fields are _public_ by default, and can be made _private_ with\n+the `priv` keyword:\n \n ~~~\n mod farm {\n@@ -2393,7 +2393,8 @@ fn main() {\n # fn make_me_a_chicken() -> farm::Chicken { 0 }\n ~~~\n \n-> ***Note:*** Visibility rules are currently buggy and not fully defined, you might have to add or remove `pub` along a path until it works.\n+Exact details and specifications about visibility rules can be found in the Rust\n+manual.\n \n ## Files and modules\n "}, {"sha": "cbc2f08679bb6e8dd2533b2f1c7f402e573f5918", "filename": "src/libextra/container.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibextra%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibextra%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcontainer.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -40,7 +40,7 @@ pub trait Deque<T> : Mutable {\n }\n \n #[cfg(test)]\n-mod bench {\n+pub mod bench {\n     use std::container::MutableMap;\n     use std::{vec, rand};\n     use std::rand::Rng;"}, {"sha": "f4bc87ae76392fddd14e1b93599782c5f33c719c", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -346,7 +346,7 @@ impl <T: FixedBuffer> StandardPadding for T {\n \n \n #[cfg(test)]\n-mod test {\n+pub mod test {\n     use std::rand::{IsaacRng, Rng};\n     use std::vec;\n "}, {"sha": "9ac0d73c2ecf51a800b6f9348dddd2488b97510b", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -101,7 +101,8 @@ pub trait Stats {\n \n /// Extracted collection of all the summary statistics of a sample set.\n #[deriving(Clone, Eq)]\n-struct Summary {\n+#[allow(missing_doc)]\n+pub struct Summary {\n     sum: f64,\n     min: f64,\n     max: f64,"}, {"sha": "4681c37fce833262a82827bb99c980fbf6bde94e", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -199,7 +199,6 @@ pub fn phase_2_configure_and_expand(sess: Session,\n \n pub struct CrateAnalysis {\n     exp_map2: middle::resolve::ExportMap2,\n-    exported_items: @middle::privacy::ExportedItems,\n     ty_cx: ty::ctxt,\n     maps: astencode::Maps,\n     reachable: @mut HashSet<ast::NodeId>\n@@ -229,7 +228,9 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     let middle::resolve::CrateMap {\n         def_map: def_map,\n         exp_map2: exp_map2,\n-        trait_map: trait_map\n+        trait_map: trait_map,\n+        external_exports: external_exports,\n+        last_private_map: last_private_map\n     } =\n         time(time_passes, \"resolution\", (), |_|\n              middle::resolve::resolve_crate(sess, lang_items, crate));\n@@ -261,9 +262,10 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n          middle::check_const::check_crate(sess, crate, ast_map, def_map,\n                                           method_map, ty_cx));\n \n-    let exported_items =\n-        time(time_passes, \"privacy checking\", (), |_|\n-             middle::privacy::check_crate(ty_cx, &method_map, &exp_map2, crate));\n+    let maps = (external_exports, last_private_map);\n+    time(time_passes, \"privacy checking\", maps, |(a, b)|\n+         middle::privacy::check_crate(ty_cx, &method_map, &exp_map2,\n+                                      a, b, crate));\n \n     time(time_passes, \"effect checking\", (), |_|\n          middle::effect::check_crate(ty_cx, method_map, crate));\n@@ -305,7 +307,6 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n \n     CrateAnalysis {\n         exp_map2: exp_map2,\n-        exported_items: @exported_items,\n         ty_cx: ty_cx,\n         maps: astencode::Maps {\n             root_map: root_map,"}, {"sha": "be01d3cbfc9d5b68adf691b77c51c58e26648ba4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -837,8 +837,9 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                 let def_like = item_to_def_like(child_item_doc,\n                                                 child_def_id,\n                                                 cdata.cnum);\n-                callback(def_like, token::str_to_ident(name),\n-                         item_visibility(child_item_doc));\n+                // These items have a public visibility because they're part of\n+                // a public re-export.\n+                callback(def_like, token::str_to_ident(name), ast::public);\n             }\n         }\n "}, {"sha": "3f2c55a55b838595e01fb7f1763bfc1286daba04", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -58,7 +58,6 @@ pub struct EncodeParams<'self> {\n     diag: @mut span_handler,\n     tcx: ty::ctxt,\n     reexports2: middle::resolve::ExportMap2,\n-    exported_items: @middle::privacy::ExportedItems,\n     item_symbols: &'self HashMap<ast::NodeId, ~str>,\n     discrim_symbols: &'self HashMap<ast::NodeId, @str>,\n     non_inlineable_statics: &'self HashSet<ast::NodeId>,\n@@ -89,7 +88,6 @@ pub struct EncodeContext<'self> {\n     tcx: ty::ctxt,\n     stats: @mut Stats,\n     reexports2: middle::resolve::ExportMap2,\n-    exported_items: @middle::privacy::ExportedItems,\n     item_symbols: &'self HashMap<ast::NodeId, ~str>,\n     discrim_symbols: &'self HashMap<ast::NodeId, @str>,\n     non_inlineable_statics: &'self HashSet<ast::NodeId>,\n@@ -625,6 +623,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     }\n \n     encode_path(ecx, ebml_w, path, ast_map::path_mod(name));\n+    encode_visibility(ebml_w, vis);\n \n     // Encode the reexports of this module, if this module is public.\n     if vis == public {\n@@ -1277,12 +1276,7 @@ fn my_visit_item(i:@item, items: ast_map::map, ebml_w:&writer::Encoder,\n             let mut ebml_w = ebml_w.clone();\n             // See above\n             let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n-            let vis = if ecx.exported_items.contains(&i.id) {\n-                ast::public\n-            } else {\n-                ast::inherited\n-            };\n-            encode_info_for_item(ecx, &mut ebml_w, i, index, *pt, vis);\n+            encode_info_for_item(ecx, &mut ebml_w, i, index, *pt, i.vis);\n         }\n         _ => fail2!(\"bad item\")\n     }\n@@ -1628,7 +1622,7 @@ impl<'self> Visitor<()> for ImplVisitor<'self> {\n \n                 // Load eagerly if this is an implementation of the Drop trait\n                 // or if the trait is not defined in this crate.\n-                if def_id == self.ecx.tcx.lang_items.drop_trait().unwrap() ||\n+                if Some(def_id) == self.ecx.tcx.lang_items.drop_trait() ||\n                         def_id.crate != LOCAL_CRATE {\n                     self.ebml_w.start_tag(tag_impls_impl);\n                     encode_def_id(self.ebml_w, local_def(item.id));\n@@ -1744,7 +1738,6 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n         diag,\n         tcx,\n         reexports2,\n-        exported_items,\n         discrim_symbols,\n         cstore,\n         encode_inlined_item,\n@@ -1760,7 +1753,6 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n         tcx: tcx,\n         stats: stats,\n         reexports2: reexports2,\n-        exported_items: exported_items,\n         item_symbols: item_symbols,\n         discrim_symbols: discrim_symbols,\n         non_inlineable_statics: non_inlineable_statics,"}, {"sha": "aaaa893c3e5c32b71de4e4ee496e8dee7c125c67", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -31,8 +31,8 @@ use syntax::ast_util::id_range;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n use syntax::visit;\n-use syntax::visit::Visitor;\n-use syntax::ast::{Expr, fn_kind, fn_decl, Block, NodeId, Stmt, Pat, Local};\n+use syntax::visit::{Visitor, fn_kind};\n+use syntax::ast::{Expr, fn_decl, Block, NodeId, Stmt, Pat, Local};\n \n mod lifetime;\n mod restrictions;"}, {"sha": "fb4b76c7c916e6411dd330e92d809450a2f5b5de", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 656, "deletions": 572, "changes": 1228, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -12,221 +12,374 @@\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n \n-use std::hashmap::HashSet;\n+use std::hashmap::{HashSet, HashMap};\n \n-use metadata::csearch;\n-use middle::resolve::ExportMap2;\n-use middle::ty::{ty_struct, ty_enum};\n+use middle::resolve;\n use middle::ty;\n use middle::typeck::{method_map, method_origin, method_param};\n use middle::typeck::{method_static, method_object};\n \n-use std::util::ignore;\n-use syntax::ast::{DeclItem, Def, DefFn, DefId, DefStaticMethod};\n-use syntax::ast::{DefVariant, ExprField, ExprMethodCall, ExprPath};\n-use syntax::ast::{ExprStruct, ExprUnary, Ident, inherited, item_enum};\n-use syntax::ast::{item_foreign_mod, item_fn, item_impl, item_struct};\n-use syntax::ast::{item_trait, LOCAL_CRATE, NodeId, PatStruct, Path};\n-use syntax::ast::{private, provided, public, required, StmtDecl, visibility};\n use syntax::ast;\n-use syntax::ast_map::{node_foreign_item, node_item, node_method};\n-use syntax::ast_map::{node_trait_method};\n use syntax::ast_map;\n-use syntax::ast_util::{Private, Public, is_local};\n-use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n+use syntax::ast_util::is_local;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n+use syntax::opt_vec;\n use syntax::visit;\n use syntax::visit::Visitor;\n-use syntax::ast::{_mod,Expr,item,Block,Pat};\n \n-// This set is a set of all item nodes which can be used by external crates if\n-// we're building a library. The necessary qualifications for this are that all\n-// items leading down to the current item (excluding an `impl`) must be `pub`.\n-pub type ExportedItems = HashSet<NodeId>;\n+type Context<'self> = (&'self method_map, &'self resolve::ExportMap2);\n \n-type Context<'self> = (&'self method_map, &'self ExportMap2);\n-\n-struct PrivacyVisitor {\n-    tcx: ty::ctxt,\n-    privileged_items: @mut ~[NodeId],\n-\n-    // A set of all items which are re-exported to be used across crates\n-    exported_items: ExportedItems,\n-\n-    // A flag as to whether the current path is public all the way down to the\n-    // current point or not\n-    path_all_public: bool,\n+// This visitor is used to determine the parent of all nodes in question when it\n+// comes to privacy. This is used to determine later on if a usage is actually\n+// valid or not.\n+struct ParentVisitor<'self> {\n+    parents: &'self mut HashMap<ast::NodeId, ast::NodeId>,\n+    curparent: ast::NodeId,\n }\n \n-impl PrivacyVisitor {\n-    // Adds an item to its scope.\n-    fn add_privileged_item(&mut self, item: @ast::item, count: &mut uint) {\n+impl<'self> Visitor<()> for ParentVisitor<'self> {\n+    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+        self.parents.insert(item.id, self.curparent);\n+\n+        let prev = self.curparent;\n         match item.node {\n-            item_struct(*) | item_trait(*) | item_enum(*) |\n-            item_fn(*) => {\n-                self.privileged_items.push(item.id);\n-                *count += 1;\n-            }\n-            item_impl(_, _, _, ref methods) => {\n-                for method in methods.iter() {\n-                    self.privileged_items.push(method.id);\n-                    *count += 1;\n+            ast::item_mod(*) => { self.curparent = item.id; }\n+            // Enum variants are parented to the enum definition itself beacuse\n+            // they inherit privacy\n+            ast::item_enum(ref def, _) => {\n+                for variant in def.variants.iter() {\n+                    // If variants are private, then their logical \"parent\" is\n+                    // the enclosing module because everyone in the enclosing\n+                    // module can still use the private variant\n+                    if variant.node.vis == ast::private {\n+                        self.parents.insert(variant.node.id, self.curparent);\n+\n+                    // Otherwise, if the variant is public, then the parent is\n+                    // considered the enclosing enum because the enum will\n+                    // dictate the privacy visibility of this variant instead.\n+                    } else {\n+                        self.parents.insert(variant.node.id, item.id);\n+                    }\n                 }\n-                self.privileged_items.push(item.id);\n-                *count += 1;\n             }\n-            item_foreign_mod(ref foreign_mod) => {\n-                for foreign_item in foreign_mod.items.iter() {\n-                    self.privileged_items.push(foreign_item.id);\n-                    *count += 1;\n+\n+            // Trait methods are always considered \"public\", but if the trait is\n+            // private then we need some private item in the chain from the\n+            // method to the root. In this case, if the trait is private, then\n+            // parent all the methods to the trait to indicate that they're\n+            // private.\n+            ast::item_trait(_, _, ref methods) if item.vis != ast::public => {\n+                for m in methods.iter() {\n+                    match *m {\n+                        ast::provided(ref m) => self.parents.insert(m.id, item.id),\n+                        ast::required(ref m) => self.parents.insert(m.id, item.id),\n+                    };\n                 }\n             }\n+\n             _ => {}\n         }\n+        visit::walk_item(self, item, ());\n+        self.curparent = prev;\n+    }\n+\n+    fn visit_foreign_item(&mut self, a: @ast::foreign_item, _: ()) {\n+        self.parents.insert(a.id, self.curparent);\n+        visit::walk_foreign_item(self, a, ());\n     }\n \n-    // Adds items that are privileged to this scope.\n-    fn add_privileged_items(&mut self, items: &[@ast::item]) -> uint {\n-        let mut count = 0;\n-        for &item in items.iter() {\n-            self.add_privileged_item(item, &mut count);\n+    fn visit_fn(&mut self, a: &visit::fn_kind, b: &ast::fn_decl,\n+                c: &ast::Block, d: Span, id: ast::NodeId, _: ()) {\n+        // We already took care of some trait methods above, otherwise things\n+        // like impl methods and pub trait methods are parented to the\n+        // containing module, not the containing trait.\n+        if !self.parents.contains_key(&id) {\n+            self.parents.insert(id, self.curparent);\n         }\n-        count\n+        visit::walk_fn(self, a, b, c, d, id, ());\n     }\n \n-    // Checks that an enum variant is in scope\n-    fn check_variant(&mut self, span: Span, enum_id: ast::DefId) {\n-        let variant_info = ty::enum_variants(self.tcx, enum_id)[0];\n-        let parental_privacy = if is_local(enum_id) {\n-            let parent_vis = ast_map::node_item_query(self.tcx.items,\n-                                                      enum_id.node,\n-                                   |it| { it.vis },\n-                                   ~\"unbound enum parent when checking \\\n-                                    dereference of enum type\");\n-            visibility_to_privacy(parent_vis)\n+    fn visit_struct_def(&mut self, s: @ast::struct_def, i: ast::Ident,\n+                        g: &ast::Generics, n: ast::NodeId, _: ()) {\n+        // Struct constructors are parented to their struct definitions because\n+        // they essentially are the struct definitions.\n+        match s.ctor_id {\n+            Some(id) => { self.parents.insert(id, n); }\n+            None => {}\n         }\n-        else {\n-            // WRONG\n-            Public\n-        };\n-        debug2!(\"parental_privacy = {:?}\", parental_privacy);\n-        debug2!(\"vis = {:?}, priv = {:?}\",\n-               variant_info.vis,\n-               visibility_to_privacy(variant_info.vis))\n-        // inherited => privacy of the enum item\n-        if variant_visibility_to_privacy(variant_info.vis,\n-                                         parental_privacy == Public)\n-                                         == Private {\n-            self.tcx.sess.span_err(span,\n-                \"can only dereference enums \\\n-                 with a single, public variant\");\n+\n+        // While we have the id of the struct definition, go ahead and parent\n+        // all the fields.\n+        for field in s.fields.iter() {\n+            let vis = match field.node.kind {\n+                ast::named_field(_, vis) => vis,\n+                ast::unnamed_field => continue\n+            };\n+\n+            // Private fields are scoped to this module, so parent them directly\n+            // to the module instead of the struct. This is similar to the case\n+            // of private enum variants.\n+            if vis == ast::private {\n+                self.parents.insert(field.node.id, self.curparent);\n+\n+            // Otherwise public fields are scoped to the visibility of the\n+            // struct itself\n+            } else {\n+                self.parents.insert(field.node.id, n);\n+            }\n         }\n+        visit::walk_struct_def(self, s, i, g, n, ())\n     }\n+}\n \n-    // Returns true if a crate-local method is private and false otherwise.\n-    fn method_is_private(&mut self, span: Span, method_id: NodeId) -> bool {\n-        let check = |vis: visibility, container_id: DefId| {\n-            let mut is_private = false;\n-            if vis == private {\n-                is_private = true;\n-            } else if vis == public {\n-                is_private = false;\n-            } else {\n-                // Look up the enclosing impl.\n-                if container_id.crate != LOCAL_CRATE {\n-                    self.tcx.sess.span_bug(span,\n-                                      \"local method isn't in local \\\n-                                       impl?!\");\n-                }\n+// This visitor is used to determine which items of the ast are embargoed,\n+// otherwise known as not exported.\n+struct EmbargoVisitor<'self> {\n+    exported_items: &'self mut HashSet<ast::NodeId>,\n+    exp_map2: &'self resolve::ExportMap2,\n+    path_all_public: bool,\n+}\n \n-                match self.tcx.items.find(&container_id.node) {\n-                    Some(&node_item(item, _)) => {\n-                        match item.node {\n-                            item_impl(_, None, _, _)\n-                                    if item.vis != public => {\n-                                is_private = true;\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n-                    Some(_) => {\n-                        self.tcx.sess.span_bug(span, \"impl wasn't an item?!\");\n-                    }\n-                    None => {\n-                        self.tcx.sess.span_bug(span, \"impl wasn't in AST map?!\");\n+impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n+    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+        let orig_all_pub = self.path_all_public;\n+        match item.node {\n+            // impls/extern blocks do not break the \"public chain\" because they\n+            // cannot have visibility qualifiers on them anyway\n+            ast::item_impl(*) | ast::item_foreign_mod(*) => {}\n+\n+            // Private by default, hence we only retain the \"public chain\" if\n+            // `pub` is explicitly listed.\n+            _ => {\n+                self.path_all_public = orig_all_pub && item.vis == ast::public;\n+            }\n+        }\n+\n+        if self.path_all_public {\n+            self.exported_items.insert(item.id);\n+        }\n+\n+        match item.node {\n+            // Enum variants inherit from their parent, so if the enum is\n+            // public all variants are public unless they're explicitly priv\n+            ast::item_enum(ref def, _) if self.path_all_public => {\n+                for variant in def.variants.iter() {\n+                    if variant.node.vis != ast::private {\n+                        self.exported_items.insert(variant.node.id);\n                     }\n                 }\n             }\n \n-            is_private\n-        };\n-\n-        match self.tcx.items.find(&method_id) {\n-            Some(&node_method(method, impl_id, _)) => {\n-                check(method.vis, impl_id)\n+            // Methods which are public at the source are totally public.\n+            ast::item_impl(_, None, _, ref methods) => {\n+                for method in methods.iter() {\n+                    let public = match method.explicit_self.node {\n+                        ast::sty_static => self.path_all_public,\n+                        _ => true,\n+                    } && method.vis == ast::public;\n+                    if public {\n+                        self.exported_items.insert(method.id);\n+                    }\n+                }\n             }\n-            Some(&node_trait_method(trait_method, trait_id, _)) => {\n-                match *trait_method {\n-                    required(_) => check(public, trait_id),\n-                    provided(method) => check(method.vis, trait_id),\n+\n+            // Trait implementation methods are all completely public\n+            ast::item_impl(_, Some(*), _, ref methods) => {\n+                for method in methods.iter() {\n+                    debug2!(\"exporting: {}\", method.id);\n+                    self.exported_items.insert(method.id);\n                 }\n             }\n-            Some(_) => {\n-                self.tcx.sess.span_bug(span,\n-                                  format!(\"method_is_private: method was a {}?!\",\n-                                       ast_map::node_id_to_str(\n-                                            self.tcx.items,\n-                                            method_id,\n-                                           token::get_ident_interner())));\n+\n+            // Default methods on traits are all public so long as the trait is\n+            // public\n+            ast::item_trait(_, _, ref methods) if self.path_all_public => {\n+                for method in methods.iter() {\n+                    match *method {\n+                        ast::provided(ref m) => {\n+                            debug2!(\"provided {}\", m.id);\n+                            self.exported_items.insert(m.id);\n+                        }\n+                        ast::required(ref m) => {\n+                            debug2!(\"required {}\", m.id);\n+                            self.exported_items.insert(m.id);\n+                        }\n+                    }\n+                }\n             }\n-            None => {\n-                self.tcx.sess.span_bug(span, \"method not found in \\\n-                                         AST map?!\");\n+\n+            // Default methods on traits are all public so long as the trait is\n+            // public\n+            ast::item_struct(ref def, _) if self.path_all_public => {\n+                match def.ctor_id {\n+                    Some(id) => { self.exported_items.insert(id); }\n+                    None => {}\n+                }\n             }\n+\n+            _ => {}\n+        }\n+\n+        visit::walk_item(self, item, ());\n+\n+        self.path_all_public = orig_all_pub;\n+    }\n+\n+    fn visit_foreign_item(&mut self, a: @ast::foreign_item, _: ()) {\n+        if self.path_all_public && a.vis == ast::public {\n+            self.exported_items.insert(a.id);\n         }\n     }\n+}\n+\n+struct PrivacyVisitor<'self> {\n+    tcx: ty::ctxt,\n+    curitem: ast::NodeId,\n+\n+    // Results of previous analyses necessary for privacy checking.\n+    exported_items: &'self HashSet<ast::NodeId>,\n+    method_map: &'self method_map,\n+    parents: &'self HashMap<ast::NodeId, ast::NodeId>,\n+    external_exports: resolve::ExternalExports,\n+    last_private_map: resolve::LastPrivateMap,\n+}\n+\n+impl<'self> PrivacyVisitor<'self> {\n+    // used when debugging\n+    fn nodestr(&self, id: ast::NodeId) -> ~str {\n+        ast_map::node_id_to_str(self.tcx.items, id, token::get_ident_interner())\n+    }\n \n-    // Returns true if the given local item is private and false otherwise.\n-    fn local_item_is_private(&mut self, span: Span, item_id: NodeId) -> bool {\n-        let mut f: &fn(NodeId) -> bool = |_| false;\n-        f = |item_id| {\n-            match self.tcx.items.find(&item_id) {\n-                Some(&node_item(item, _)) => item.vis != public,\n-                Some(&node_foreign_item(*)) => false,\n-                Some(&node_method(method, impl_did, _)) => {\n-                    match method.vis {\n-                        private => true,\n-                        public => false,\n-                        inherited => f(impl_did.node)\n+    // Determines whether the given definition is public from the point of view\n+    // of the current item.\n+    fn def_public(&self, did: ast::DefId) -> bool {\n+        if !is_local(did) {\n+            if self.external_exports.contains(&did) {\n+                debug2!(\"privacy - {:?} was externally exported\", did);\n+                return true;\n+            }\n+            debug2!(\"privacy - is {:?} a public method\", did);\n+            return match self.tcx.methods.find(&did) {\n+                Some(meth) => {\n+                    debug2!(\"privacy - well at least it's a method: {:?}\", meth);\n+                    match meth.container {\n+                        ty::TraitContainer(id) => {\n+                            debug2!(\"privacy - recursing on trait {:?}\", id);\n+                            self.def_public(id)\n+                        }\n+                        ty::ImplContainer(id) => {\n+                            match ty::impl_trait_ref(self.tcx, id) {\n+                                Some(t) => {\n+                                    debug2!(\"privacy - impl of trait {:?}\", id);\n+                                    self.def_public(t.def_id)\n+                                }\n+                                None => {\n+                                    debug2!(\"privacy - found a method {:?}\",\n+                                            meth.vis);\n+                                    meth.vis == ast::public\n+                                }\n+                            }\n+                        }\n                     }\n                 }\n-                Some(&node_trait_method(_, trait_did, _)) => f(trait_did.node),\n-                Some(_) => {\n-                    self.tcx.sess.span_bug(span,\n-                                      format!(\"local_item_is_private: item was \\\n-                                            a {}?!\",\n-                                           ast_map::node_id_to_str(\n-                                                self.tcx.items,\n-                                                item_id,\n-                                               token::get_ident_interner())));\n-                }\n                 None => {\n-                    self.tcx.sess.span_bug(span, \"item not found in AST map?!\");\n+                    debug2!(\"privacy - nope, not even a method\");\n+                    false\n                 }\n+            };\n+        } else if self.exported_items.contains(&did.node) {\n+            debug2!(\"privacy - exported item {}\", self.nodestr(did.node));\n+            return true;\n+        }\n+\n+        debug2!(\"privacy - local {:?} not public all the way down\", did);\n+        // return quickly for things in the same module\n+        if self.parents.find(&did.node) == self.parents.find(&self.curitem) {\n+            debug2!(\"privacy - same parent, we're done here\");\n+            return true;\n+        }\n+\n+        // We now know that there is at least one private member between the\n+        // destination and the root.\n+        let mut closest_private_id = did.node;\n+        loop {\n+            debug2!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n+            let vis = match self.tcx.items.find(&closest_private_id) {\n+                Some(&ast_map::node_item(it, _)) => it.vis,\n+                Some(&ast_map::node_method(ref m, _, _)) => m.vis,\n+                Some(&ast_map::node_foreign_item(_, _, v, _)) => v,\n+                Some(&ast_map::node_variant(ref v, _, _)) => {\n+                    // sadly enum variants still inherit visibility, so only\n+                    // break out of this is explicitly private\n+                    if v.node.vis == ast::private { break }\n+                    ast::public // need to move up a level (to the enum)\n+                }\n+                _ => ast::public,\n+            };\n+            if vis != ast::public { break }\n+            closest_private_id = *self.parents.get(&closest_private_id);\n+\n+            // If we reached the top, then we should have been public all the\n+            // way down in the first place...\n+            assert!(closest_private_id != ast::DUMMY_NODE_ID);\n+        }\n+        debug2!(\"privacy - closest priv {}\", self.nodestr(closest_private_id));\n+        return self.private_accessible(closest_private_id);\n+    }\n+\n+    /// For a local private node in the AST, this function will determine\n+    /// whether the node is accessible by the current module that iteration is\n+    /// inside.\n+    fn private_accessible(&self, id: ast::NodeId) -> bool {\n+        let parent = *self.parents.get(&id);\n+        debug2!(\"privacy - accessible parent {}\", self.nodestr(parent));\n+\n+        // After finding `did`'s closest private member, we roll ourselves back\n+        // to see if this private member's parent is anywhere in our ancestry.\n+        // By the privacy rules, we can access all of our ancestor's private\n+        // members, so that's why we test the parent, and not the did itself.\n+        let mut cur = self.curitem;\n+        loop {\n+            debug2!(\"privacy - questioning {}\", self.nodestr(cur));\n+            match cur {\n+                // If the relevant parent is in our history, then we're allowed\n+                // to look inside any of our ancestor's immediate private items,\n+                // so this access is valid.\n+                x if x == parent => return true,\n+\n+                // If we've reached the root, then we couldn't access this item\n+                // in the first place\n+                ast::DUMMY_NODE_ID => return false,\n+\n+                // Keep going up\n+                _ => {}\n             }\n-        };\n-        f(item_id)\n+\n+            cur = *self.parents.get(&cur);\n+        }\n+    }\n+\n+    // Checks that a dereference of a univariant enum can occur.\n+    fn check_variant(&self, span: Span, enum_id: ast::DefId) {\n+        let variant_info = ty::enum_variants(self.tcx, enum_id)[0];\n+        if !self.def_public(variant_info.id) {\n+            self.tcx.sess.span_err(span, \"can only dereference enums \\\n+                                          with a single, public variant\");\n+        }\n     }\n \n-    // Checks that a private field is in scope.\n+    // Checks that a field is in scope.\n     // FIXME #6993: change type (and name) from Ident to Name\n     fn check_field(&mut self, span: Span, id: ast::DefId, ident: ast::Ident) {\n         let fields = ty::lookup_struct_fields(self.tcx, id);\n         for field in fields.iter() {\n             if field.name != ident.name { continue; }\n-            if field.vis == private {\n+            // public fields are public everywhere\n+            if field.vis != ast::private { break }\n+            if !is_local(field.id) ||\n+               !self.private_accessible(field.id.node) {\n                 self.tcx.sess.span_err(span, format!(\"field `{}` is private\",\n                                              token::ident_to_str(&ident)));\n             }\n@@ -235,78 +388,59 @@ impl PrivacyVisitor {\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n-    fn check_method_common(&mut self, span: Span, method_id: DefId, name: &Ident) {\n+    fn check_static_method(&mut self, span: Span, method_id: ast::DefId,\n+                           name: &ast::Ident) {\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n-        // Having to do this this is really unfortunate.\n-        let method_id = ty::method(self.tcx, method_id).provided_source.unwrap_or(method_id);\n-\n-        if method_id.crate == LOCAL_CRATE {\n-            let is_private = self.method_is_private(span, method_id.node);\n-            let container_id = ty::method(self.tcx, method_id).container_id();\n-            if is_private &&\n-                    (container_id.crate != LOCAL_CRATE ||\n-                     !self.privileged_items.iter().any(|x| x == &(container_id.node))) {\n-                self.tcx.sess.span_err(span,\n-                                  format!(\"method `{}` is private\",\n-                                       token::ident_to_str(name)));\n-            }\n-        } else {\n-            let visibility =\n-                csearch::get_item_visibility(self.tcx.sess.cstore, method_id);\n-            if visibility != public {\n-                self.tcx.sess.span_err(span,\n-                                  format!(\"method `{}` is private\",\n-                                       token::ident_to_str(name)));\n-            }\n+        let method_id = ty::method(self.tcx, method_id).provided_source\n+                                                       .unwrap_or(method_id);\n+\n+        if !self.def_public(method_id) {\n+            debug2!(\"private: {:?}\", method_id);\n+            self.tcx.sess.span_err(span, format!(\"method `{}` is private\",\n+                                                 token::ident_to_str(name)));\n         }\n     }\n \n-    // Checks that a private path is in scope.\n-    fn check_path(&mut self, span: Span, def: Def, path: &Path) {\n-        debug2!(\"checking path\");\n-        match def {\n-            DefStaticMethod(method_id, _, _) => {\n-                debug2!(\"found static method def, checking it\");\n-                self.check_method_common(span,\n-                                         method_id,\n-                                         &path.segments.last().identifier)\n-            }\n-            DefFn(def_id, _) => {\n-                if def_id.crate == LOCAL_CRATE {\n-                    if self.local_item_is_private(span, def_id.node) &&\n-                            !self.privileged_items.iter().any(|x| x == &def_id.node) {\n-                        self.tcx.sess.span_err(span,\n-                                          format!(\"function `{}` is private\",\n-                                               token::ident_to_str(\n-                                                &path.segments\n-                                                     .last()\n-                                                     .identifier)));\n-                    }\n-                //} else if csearch::get_item_visibility(self.tcx.sess.cstore,\n-                //                                       def_id) != public {\n-                //    self.tcx.sess.span_err(span,\n-                //                      format!(\"function `{}` is private\",\n-                //                           token::ident_to_str(\n-                //                                &path.segments\n-                //                                     .last()\n-                //                                     .identifier)));\n-                }\n-                // If this is a function from a non-local crate, then the\n-                // privacy check is enforced during resolve. All public items\n-                // will be tagged as such in the crate metadata and then usage\n-                // of the private items will be blocked during resolve. Hence,\n-                // if this isn't from the local crate, nothing to check.\n+    // Checks that a path is in scope.\n+    fn check_path(&mut self, span: Span, path_id: ast::NodeId, path: &ast::Path) {\n+        debug2!(\"privacy - path {}\", self.nodestr(path_id));\n+        let ck = |tyname: &str| {\n+            let last_private = *self.last_private_map.get(&path_id);\n+            debug2!(\"privacy - {:?}\", last_private);\n+            let public = match last_private {\n+                resolve::AllPublic => true,\n+                resolve::DependsOn(def) => self.def_public(def),\n+            };\n+            if !public {\n+                debug2!(\"denying {:?}\", path);\n+                let name = token::ident_to_str(&path.segments.last()\n+                                                    .identifier);\n+                self.tcx.sess.span_err(span,\n+                                  format!(\"{} `{}` is private\", tyname, name));\n             }\n+        };\n+        match self.tcx.def_map.get_copy(&path_id) {\n+            ast::DefStaticMethod(*) => ck(\"static method\"),\n+            ast::DefFn(*) => ck(\"function\"),\n+            ast::DefStatic(*) => ck(\"static\"),\n+            ast::DefVariant(*) => ck(\"variant\"),\n+            ast::DefTy(*) => ck(\"type\"),\n+            ast::DefTrait(*) => ck(\"trait\"),\n+            ast::DefStruct(*) => ck(\"struct\"),\n+            ast::DefMethod(_, Some(*)) => ck(\"trait method\"),\n+            ast::DefMethod(*) => ck(\"method\"),\n+            ast::DefMod(*) => ck(\"module\"),\n             _ => {}\n         }\n     }\n \n-    // Checks that a private method is in scope.\n-    fn check_method(&mut self, span: Span, origin: &method_origin, ident: ast::Ident) {\n+    // Checks that a method is in scope.\n+    fn check_method(&mut self, span: Span, origin: &method_origin,\n+                    ident: ast::Ident) {\n         match *origin {\n             method_static(method_id) => {\n-                self.check_method_common(span, method_id, &ident)\n+                self.check_static_method(span, method_id, &ident)\n             }\n             method_param(method_param {\n                 trait_id: trait_id,\n@@ -318,426 +452,376 @@ impl PrivacyVisitor {\n                 method_num: method_num,\n                  _\n             }) => {\n-                if trait_id.crate == LOCAL_CRATE {\n-                    match self.tcx.items.find(&trait_id.node) {\n-                        Some(&node_item(item, _)) => {\n-                            match item.node {\n-                                item_trait(_, _, ref methods) => {\n-                                    if method_num >= (*methods).len() {\n-                                        self.tcx.sess.span_bug(span,\n-                                                               \"method number out of range?!\");\n+                if !self.def_public(trait_id) {\n+                    self.tcx.sess.span_err(span, \"source trait is private\");\n+                    return;\n+                }\n+                match self.tcx.items.find(&trait_id.node) {\n+                    Some(&ast_map::node_item(item, _)) => {\n+                        match item.node {\n+                            ast::item_trait(_, _, ref methods) => {\n+                                match methods[method_num] {\n+                                    ast::provided(ref method) => {\n+                                        let def = ast::DefId {\n+                                            node: method.id,\n+                                            crate: trait_id.crate,\n+                                        };\n+                                        if self.def_public(def) { return }\n+                                        let msg = format!(\"method `{}` is \\\n+                                                           private\",\n+                                                          token::ident_to_str(\n+                                                              &method.ident));\n+                                        self.tcx.sess.span_err(span, msg);\n                                     }\n-                                    match (*methods)[method_num] {\n-                                        provided(method)\n-                                             if method.vis == private &&\n-                                             !self.privileged_items.iter()\n-                                             .any(|x| x == &(trait_id.node)) => {\n-                                            self.tcx.sess.span_err(span,\n-                                                              format!(\"method `{}` is private\",\n-                                                                   token::ident_to_str(&method\n-                                                                                        .ident)));\n-                                        }\n-                                        provided(_) | required(_) => {\n-                                            // Required methods can't be\n-                                            // private.\n-                                        }\n+                                    ast::required(_) => {\n+                                        // Required methods can't be private.\n                                     }\n                                 }\n-                                _ => {\n-                                    self.tcx.sess.span_bug(span, \"trait wasn't actually a trait?!\");\n-                                }\n                             }\n-                        }\n-                        Some(_) => {\n-                            self.tcx.sess.span_bug(span, \"trait wasn't an item?!\");\n-                        }\n-                        None => {\n-                            self.tcx.sess.span_bug(span,\n-                                                   \"trait item wasn't found in the AST map?!\");\n+                            _ => self.tcx.sess.span_bug(span, \"trait wasn't \\\n+                                                               actually a trait?!\"),\n                         }\n                     }\n-                } else {\n-                    // FIXME #4732: External crates.\n+                    Some(_) => self.tcx.sess.span_bug(span, \"trait wasn't an \\\n+                                                             item?!\"),\n+                    None => self.tcx.sess.span_bug(span, \"trait item wasn't \\\n+                                                          found in the AST \\\n+                                                          map?!\"),\n                 }\n             }\n         }\n     }\n-}\n-\n-impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n \n-    fn visit_mod(&mut self, the_module:&_mod, _:Span, _:NodeId,\n-                 cx: Context<'self>) {\n-\n-            let n_added = self.add_privileged_items(the_module.items);\n-\n-            visit::walk_mod(self, the_module, cx);\n-\n-            do n_added.times {\n-                ignore(self.privileged_items.pop());\n+    /// Validates all of the visibility qualifers placed on the item given. This\n+    /// ensures that there are no extraneous qualifiers that don't actually do\n+    /// anything. In theory these qualifiers wouldn't parse, but that may happen\n+    /// later on down the road...\n+    fn check_sane_privacy(&self, item: @ast::item) {\n+        let tcx = self.tcx;\n+        let check_inherited = |sp: Span, vis: ast::visibility, note: &str| {\n+            if vis != ast::inherited {\n+                tcx.sess.span_err(sp, \"unnecessary visibility qualifier\");\n+                if note.len() > 0 {\n+                    tcx.sess.span_note(sp, note);\n+                }\n             }\n-    }\n-\n-    fn visit_item(&mut self, item:@item, cx: Context<'self>) {\n-\n-        // Do not check privacy inside items with the resolve_unexported\n-        // attribute. This is used for the test runner.\n-        if attr::contains_name(item.attrs, \"!resolve_unexported\") {\n-            return;\n-        }\n-\n-        // Disallow unnecessary visibility qualifiers\n-        check_sane_privacy(self.tcx, item);\n-\n-        // Keep track of whether this item is available for export or not.\n-        let orig_all_pub = self.path_all_public;\n+        };\n+        let check_not_priv = |sp: Span, vis: ast::visibility, note: &str| {\n+            if vis == ast::private {\n+                tcx.sess.span_err(sp, \"unnecessary `priv` qualifier\");\n+                if note.len() > 0 {\n+                    tcx.sess.span_note(sp, note);\n+                }\n+            }\n+        };\n         match item.node {\n-            // impls/extern blocks do not break the \"public chain\" because they\n-            // cannot have visibility qualifiers on them anyway\n-            ast::item_impl(*) | ast::item_foreign_mod(*) => {}\n-\n-            // Private by default, hence we only retain the \"public chain\" if\n-            // `pub` is explicitly listed.\n-            _ => {\n-                self.path_all_public = orig_all_pub && item.vis == ast::public;\n+            // implementations of traits don't need visibility qualifiers because\n+            // that's controlled by having the trait in scope.\n+            ast::item_impl(_, Some(*), _, ref methods) => {\n+                check_inherited(item.span, item.vis,\n+                                \"visibility qualifiers have no effect on trait \\\n+                                 impls\");\n+                for m in methods.iter() {\n+                    check_inherited(m.span, m.vis, \"\");\n+                }\n             }\n-        }\n-        debug2!(\"public path at {}: {}\", item.id, self.path_all_public);\n \n-        if self.path_all_public {\n-            debug2!(\"all the way public {}\", item.id);\n-            self.exported_items.insert(item.id);\n+            ast::item_impl(_, _, _, ref methods) => {\n+                check_inherited(item.span, item.vis,\n+                                \"place qualifiers on individual methods instead\");\n+                for i in methods.iter() {\n+                    check_not_priv(i.span, i.vis, \"functions are private by \\\n+                                                   default\");\n+                }\n+            }\n+            ast::item_foreign_mod(ref fm) => {\n+                check_inherited(item.span, item.vis,\n+                                \"place qualifiers on individual functions \\\n+                                 instead\");\n+                for i in fm.items.iter() {\n+                    check_not_priv(i.span, i.vis, \"functions are private by \\\n+                                                   default\");\n+                }\n+            }\n \n-            // All re-exported items in a module which is public should also be\n-            // public (in terms of how they should get encoded)\n-            match item.node {\n-                ast::item_mod(*) => {\n-                    let (_, exp_map2) = cx;\n-                    match exp_map2.find(&item.id) {\n-                        Some(exports) => {\n-                            for export in exports.iter() {\n-                                if export.reexport && is_local(export.def_id) {\n-                                    debug2!(\"found reexported {:?}\", export);\n-                                    let id = export.def_id.node;\n-                                    self.exported_items.insert(id);\n-                                }\n+            ast::item_enum(ref def, _) => {\n+                for v in def.variants.iter() {\n+                    match v.node.vis {\n+                        ast::public => {\n+                            if item.vis == ast::public {\n+                                tcx.sess.span_err(v.span, \"unnecessary `pub` \\\n+                                                           visibility\");\n                             }\n                         }\n-                        None => {}\n+                        ast::private => {\n+                            if item.vis != ast::public {\n+                                tcx.sess.span_err(v.span, \"unnecessary `priv` \\\n+                                                           visibility\");\n+                            }\n+                        }\n+                        ast::inherited => {}\n                     }\n                 }\n-                _ => {}\n             }\n-        }\n \n-        visit::walk_item(self, item, cx);\n-\n-        self.path_all_public = orig_all_pub;\n-    }\n-\n-    fn visit_block(&mut self, block:&Block, cx: Context<'self>) {\n-\n-            // Gather up all the privileged items.\n-            let mut n_added = 0;\n-            for stmt in block.stmts.iter() {\n-                match stmt.node {\n-                    StmtDecl(decl, _) => {\n-                        match decl.node {\n-                            DeclItem(item) => {\n-                                self.add_privileged_item(item, &mut n_added);\n-                            }\n-                            _ => {}\n+            ast::item_struct(ref def, _) => {\n+                for f in def.fields.iter() {\n+                   match f.node.kind {\n+                        ast::named_field(_, ast::public) => {\n+                            tcx.sess.span_err(f.span, \"unnecessary `pub` \\\n+                                                       visibility\");\n+                        }\n+                        ast::named_field(_, ast::private) => {\n+                            // Fields should really be private by default...\n                         }\n+                        ast::named_field(*) | ast::unnamed_field => {}\n                     }\n-                    _ => {}\n                 }\n             }\n \n-            visit::walk_block(self, block, cx);\n+            ast::item_trait(_, _, ref methods) => {\n+                for m in methods.iter() {\n+                    match *m {\n+                        ast::provided(ref m) => {\n+                            check_inherited(m.span, m.vis,\n+                                            \"unnecessary visibility\");\n+                        }\n+                        ast::required(*) => {}\n+                    }\n+                }\n+            }\n \n-            do n_added.times {\n-                ignore(self.privileged_items.pop());\n+            ast::item_static(*) |\n+            ast::item_fn(*) | ast::item_mod(*) | ast::item_ty(*) |\n+            ast::item_mac(*) => {\n+                check_not_priv(item.span, item.vis, \"items are private by \\\n+                                                     default\");\n             }\n+        }\n+    }\n+}\n \n+impl<'self> Visitor<()> for PrivacyVisitor<'self> {\n+    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+        // Do not check privacy inside items with the resolve_unexported\n+        // attribute. This is used for the test runner.\n+        if attr::contains_name(item.attrs, \"!resolve_unexported\") {\n+            return;\n+        }\n+\n+        // Disallow unnecessary visibility qualifiers\n+        self.check_sane_privacy(item);\n+\n+        let orig_curitem = self.curitem;\n+        self.curitem = item.id;\n+        visit::walk_item(self, item, ());\n+        self.curitem = orig_curitem;\n     }\n \n-    fn visit_expr(&mut self, expr:@Expr, cx: Context<'self>) {\n-        let (method_map, _) = cx;\n-            match expr.node {\n-                ExprField(base, ident, _) => {\n-                    // Method calls are now a special syntactic form,\n-                    // so `a.b` should always be a field.\n-                    assert!(!method_map.contains_key(&expr.id));\n-\n-                    // With type_autoderef, make sure we don't\n-                    // allow pointers to violate privacy\n-                    match ty::get(ty::type_autoderef(self.tcx, ty::expr_ty(self.tcx,\n-                                                          base))).sty {\n-                        ty_struct(id, _)\n-                        if id.crate != LOCAL_CRATE || !self.privileged_items.iter()\n-                                .any(|x| x == &(id.node)) => {\n-                            debug2!(\"(privacy checking) checking field access\");\n-                            self.check_field(expr.span, id, ident);\n-                        }\n-                        _ => {}\n-                    }\n+    fn visit_expr(&mut self, expr: @ast::Expr, _: ()) {\n+        match expr.node {\n+            ast::ExprField(base, ident, _) => {\n+                // Method calls are now a special syntactic form,\n+                // so `a.b` should always be a field.\n+                assert!(!self.method_map.contains_key(&expr.id));\n+\n+                // With type_autoderef, make sure we don't\n+                // allow pointers to violate privacy\n+                let t = ty::type_autoderef(self.tcx,\n+                                           ty::expr_ty(self.tcx, base));\n+                match ty::get(t).sty {\n+                    ty::ty_struct(id, _) => self.check_field(expr.span, id, ident),\n+                    _ => {}\n                 }\n-                ExprMethodCall(_, base, ident, _, _, _) => {\n-                    // Ditto\n-                    match ty::get(ty::type_autoderef(self.tcx, ty::expr_ty(self.tcx,\n-                                                          base))).sty {\n-                        ty_enum(id, _) |\n-                        ty_struct(id, _)\n-                        if id.crate != LOCAL_CRATE ||\n-                           !self.privileged_items.iter().any(|x| x == &(id.node)) => {\n-                            match method_map.find(&expr.id) {\n-                                None => {\n-                                    self.tcx.sess.span_bug(expr.span,\n-                                                      \"method call not in \\\n-                                                       method map\");\n-                                }\n-                                Some(ref entry) => {\n-                                    debug2!(\"(privacy checking) checking \\\n-                                            impl method\");\n-                                    self.check_method(expr.span, &entry.origin, ident);\n-                                }\n+            }\n+            ast::ExprMethodCall(_, base, ident, _, _, _) => {\n+                // see above\n+                let t = ty::type_autoderef(self.tcx,\n+                                           ty::expr_ty(self.tcx, base));\n+                match ty::get(t).sty {\n+                    ty::ty_enum(_, _) | ty::ty_struct(_, _) => {\n+                        let entry = match self.method_map.find(&expr.id) {\n+                            None => {\n+                                self.tcx.sess.span_bug(expr.span,\n+                                                       \"method call not in \\\n+                                                        method map\");\n                             }\n-                        }\n-                        _ => {}\n+                            Some(entry) => entry\n+                        };\n+                        debug2!(\"(privacy checking) checking impl method\");\n+                        self.check_method(expr.span, &entry.origin, ident);\n                     }\n+                    _ => {}\n                 }\n-                ExprPath(ref path) => {\n-                    self.check_path(expr.span, self.tcx.def_map.get_copy(&expr.id), path);\n-                }\n-                ExprStruct(_, ref fields, _) => {\n-                    match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n-                        ty_struct(id, _) => {\n-                            if id.crate != LOCAL_CRATE ||\n-                                    !self.privileged_items.iter().any(|x| x == &(id.node)) {\n-                                for field in (*fields).iter() {\n-                                        debug2!(\"(privacy checking) checking \\\n-                                                field in struct literal\");\n-                                    self.check_field(expr.span, id, field.ident);\n-                                }\n-                            }\n+            }\n+            ast::ExprPath(ref path) => {\n+                self.check_path(expr.span, expr.id, path);\n+            }\n+            ast::ExprStruct(_, ref fields, _) => {\n+                match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n+                    ty::ty_struct(id, _) => {\n+                        for field in (*fields).iter() {\n+                            self.check_field(expr.span, id, field.ident);\n                         }\n-                        ty_enum(id, _) => {\n-                            if id.crate != LOCAL_CRATE ||\n-                                    !self.privileged_items.iter().any(|x| x == &(id.node)) {\n-                                match self.tcx.def_map.get_copy(&expr.id) {\n-                                    DefVariant(_, variant_id, _) => {\n-                                        for field in (*fields).iter() {\n-                                                debug2!(\"(privacy checking) \\\n-                                                        checking field in \\\n-                                                        struct variant \\\n-                                                        literal\");\n-                                            self.check_field(expr.span, variant_id, field.ident);\n-                                        }\n-                                    }\n-                                    _ => {\n-                                        self.tcx.sess.span_bug(expr.span,\n-                                                          \"resolve didn't \\\n-                                                           map enum struct \\\n-                                                           constructor to a \\\n-                                                           variant def\");\n-                                    }\n+                    }\n+                    ty::ty_enum(_, _) => {\n+                        match self.tcx.def_map.get_copy(&expr.id) {\n+                            ast::DefVariant(_, variant_id, _) => {\n+                                for field in fields.iter() {\n+                                    self.check_field(expr.span, variant_id,\n+                                                     field.ident);\n                                 }\n                             }\n-                        }\n-                        _ => {\n-                            self.tcx.sess.span_bug(expr.span, \"struct expr \\\n-                                                          didn't have \\\n-                                                          struct type?!\");\n+                            _ => self.tcx.sess.span_bug(expr.span,\n+                                                        \"resolve didn't \\\n+                                                         map enum struct \\\n+                                                         constructor to a \\\n+                                                         variant def\"),\n                         }\n                     }\n+                    _ => self.tcx.sess.span_bug(expr.span, \"struct expr \\\n+                                                            didn't have \\\n+                                                            struct type?!\"),\n                 }\n-                ExprUnary(_, ast::UnDeref, operand) => {\n-                    // In *e, we need to check that if e's type is an\n-                    // enum type t, then t's first variant is public or\n-                    // privileged. (We can assume it has only one variant\n-                    // since typeck already happened.)\n-                    match ty::get(ty::expr_ty(self.tcx, operand)).sty {\n-                        ty_enum(id, _) => {\n-                            if id.crate != LOCAL_CRATE ||\n-                                !self.privileged_items.iter().any(|x| x == &(id.node)) {\n-                                self.check_variant(expr.span, id);\n-                            }\n-                        }\n-                        _ => { /* No check needed */ }\n+            }\n+            ast::ExprUnary(_, ast::UnDeref, operand) => {\n+                // In *e, we need to check that if e's type is an\n+                // enum type t, then t's first variant is public or\n+                // privileged. (We can assume it has only one variant\n+                // since typeck already happened.)\n+                match ty::get(ty::expr_ty(self.tcx, operand)).sty {\n+                    ty::ty_enum(id, _) => {\n+                        self.check_variant(expr.span, id);\n                     }\n+                    _ => { /* No check needed */ }\n                 }\n-                _ => {}\n             }\n+            _ => {}\n+        }\n \n-            visit::walk_expr(self, expr, cx);\n-\n+        visit::walk_expr(self, expr, ());\n     }\n \n-    fn visit_pat(&mut self, pattern:@Pat, cx: Context<'self>) {\n+    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n+        match t.node {\n+            ast::ty_path(ref path, _, id) => self.check_path(t.span, id, path),\n+            _ => {}\n+        }\n+        visit::walk_ty(self, t, ());\n+    }\n \n-            match pattern.node {\n-                PatStruct(_, ref fields, _) => {\n-                    match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n-                        ty_struct(id, _) => {\n-                            if id.crate != LOCAL_CRATE ||\n-                                    !self.privileged_items.iter().any(|x| x == &(id.node)) {\n-                                for field in fields.iter() {\n-                                        debug2!(\"(privacy checking) checking \\\n-                                                struct pattern\");\n-                                    self.check_field(pattern.span, id, field.ident);\n-                                }\n-                            }\n+    fn visit_view_item(&mut self, a: &ast::view_item, _: ()) {\n+        match a.node {\n+            ast::view_item_extern_mod(*) => {}\n+            ast::view_item_use(ref uses) => {\n+                for vpath in uses.iter() {\n+                    match vpath.node {\n+                        ast::view_path_simple(_, ref path, id) |\n+                        ast::view_path_glob(ref path, id) => {\n+                            debug2!(\"privacy - glob/simple {}\", id);\n+                            self.check_path(vpath.span, id, path);\n                         }\n-                        ty_enum(enum_id, _) => {\n-                            if enum_id.crate != LOCAL_CRATE ||\n-                                    !self.privileged_items.iter().any(|x| x == &enum_id.node) {\n-                                match self.tcx.def_map.find(&pattern.id) {\n-                                    Some(&DefVariant(_, variant_id, _)) => {\n-                                        for field in fields.iter() {\n-                                            debug2!(\"(privacy checking) \\\n-                                                    checking field in \\\n-                                                    struct variant pattern\");\n-                                            self.check_field(pattern.span, variant_id, field.ident);\n-                                        }\n-                                    }\n-                                    _ => {\n-                                        self.tcx.sess.span_bug(pattern.span,\n-                                                          \"resolve didn't \\\n-                                                           map enum struct \\\n-                                                           pattern to a \\\n-                                                           variant def\");\n-                                    }\n-                                }\n+                        ast::view_path_list(_, ref list, _) => {\n+                            for pid in list.iter() {\n+                                debug2!(\"privacy - list {}\", pid.node.id);\n+                                let seg = ast::PathSegment {\n+                                    identifier: pid.node.name,\n+                                    lifetime: None,\n+                                    types: opt_vec::Empty,\n+                                };\n+                                let segs = ~[seg];\n+                                let path = ast::Path {\n+                                    global: false,\n+                                    span: pid.span,\n+                                    segments: segs,\n+                                };\n+                                self.check_path(pid.span, pid.node.id, &path);\n                             }\n                         }\n-                        _ => {\n-                            self.tcx.sess.span_bug(pattern.span,\n-                                              \"struct pattern didn't have \\\n-                                               struct type?!\");\n-                        }\n                     }\n                 }\n-                _ => {}\n-            }\n-\n-            visit::walk_pat(self, pattern, cx);\n-    }\n-}\n-\n-pub fn check_crate(tcx: ty::ctxt,\n-                   method_map: &method_map,\n-                   exp_map2: &ExportMap2,\n-                   crate: &ast::Crate) -> ExportedItems {\n-    let privileged_items = @mut ~[];\n-\n-    let mut visitor = PrivacyVisitor {\n-        tcx: tcx,\n-        privileged_items: privileged_items,\n-        exported_items: HashSet::new(),\n-        path_all_public: true, // start out as public\n-    };\n-    visit::walk_crate(&mut visitor, crate, (method_map, exp_map2));\n-    return visitor.exported_items;\n-}\n-\n-/// Validates all of the visibility qualifers placed on the item given. This\n-/// ensures that there are no extraneous qualifiers that don't actually do\n-/// anything. In theory these qualifiers wouldn't parse, but that may happen\n-/// later on down the road...\n-fn check_sane_privacy(tcx: ty::ctxt, item: @ast::item) {\n-    let check_inherited = |sp: Span, vis: ast::visibility, note: &str| {\n-        if vis != ast::inherited {\n-            tcx.sess.span_err(sp, \"unnecessary visibility qualifier\");\n-            if note.len() > 0 {\n-                tcx.sess.span_note(sp, note);\n-            }\n-        }\n-    };\n-    let check_not_priv = |sp: Span, vis: ast::visibility, note: &str| {\n-        if vis == ast::private {\n-            tcx.sess.span_err(sp, \"unnecessary `priv` qualifier\");\n-            if note.len() > 0 {\n-                tcx.sess.span_note(sp, note);\n-            }\n-        }\n-    };\n-    match item.node {\n-        // implementations of traits don't need visibility qualifiers because\n-        // that's controlled by having the trait in scope.\n-        ast::item_impl(_, Some(*), _, ref methods) => {\n-            check_inherited(item.span, item.vis,\n-                            \"visibility qualifiers have no effect on trait impls\");\n-            for m in methods.iter() {\n-                check_inherited(m.span, m.vis, \"\");\n-            }\n-        }\n-\n-        ast::item_impl(_, _, _, ref methods) => {\n-            check_inherited(item.span, item.vis,\n-                            \"place qualifiers on individual methods instead\");\n-            for i in methods.iter() {\n-                check_not_priv(i.span, i.vis, \"functions are private by default\");\n-            }\n-        }\n-        ast::item_foreign_mod(ref fm) => {\n-            check_inherited(item.span, item.vis,\n-                            \"place qualifiers on individual functions instead\");\n-            for i in fm.items.iter() {\n-                check_not_priv(i.span, i.vis, \"functions are private by default\");\n             }\n         }\n+    }\n \n-        ast::item_enum(ref def, _) => {\n-            for v in def.variants.iter() {\n-                match v.node.vis {\n-                    ast::public => {\n-                        if item.vis == ast::public {\n-                            tcx.sess.span_err(v.span, \"unnecessary `pub` \\\n-                                                       visibility\");\n+    fn visit_pat(&mut self, pattern: @ast::Pat, _: ()) {\n+        match pattern.node {\n+            ast::PatStruct(_, ref fields, _) => {\n+                match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n+                    ty::ty_struct(id, _) => {\n+                        for field in fields.iter() {\n+                            self.check_field(pattern.span, id, field.ident);\n                         }\n                     }\n-                    ast::private => {\n-                        if item.vis != ast::public {\n-                            tcx.sess.span_err(v.span, \"unnecessary `priv` \\\n-                                                       visibility\");\n+                    ty::ty_enum(_, _) => {\n+                        match self.tcx.def_map.find(&pattern.id) {\n+                            Some(&ast::DefVariant(_, variant_id, _)) => {\n+                                for field in fields.iter() {\n+                                    self.check_field(pattern.span, variant_id,\n+                                                     field.ident);\n+                                }\n+                            }\n+                            _ => self.tcx.sess.span_bug(pattern.span,\n+                                                        \"resolve didn't \\\n+                                                         map enum struct \\\n+                                                         pattern to a \\\n+                                                         variant def\"),\n                         }\n                     }\n-                    ast::inherited => {}\n+                    _ => self.tcx.sess.span_bug(pattern.span,\n+                                                \"struct pattern didn't have \\\n+                                                 struct type?!\"),\n                 }\n             }\n+            _ => {}\n         }\n \n-        ast::item_struct(ref def, _) => {\n-            for f in def.fields.iter() {\n-                match f.node.kind {\n-                    ast::named_field(_, ast::public) => {\n-                        tcx.sess.span_err(f.span, \"unnecessary `pub` \\\n-                                                   visibility\");\n-                    }\n-                    ast::named_field(_, ast::private) => {\n-                        // Fields should really be private by default...\n-                    }\n-                    ast::named_field(*) | ast::unnamed_field => {}\n-                }\n-            }\n-        }\n+        visit::walk_pat(self, pattern, ());\n+    }\n+}\n \n-        ast::item_trait(_, _, ref methods) => {\n-            for m in methods.iter() {\n-                match *m {\n-                    ast::provided(ref m) => {\n-                        check_inherited(m.span, m.vis,\n-                                        \"unnecessary visibility\");\n-                    }\n-                    ast::required(*) => {}\n-                }\n-            }\n-        }\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: &method_map,\n+                   exp_map2: &resolve::ExportMap2,\n+                   external_exports: resolve::ExternalExports,\n+                   last_private_map: resolve::LastPrivateMap,\n+                   crate: &ast::Crate) {\n+    let mut parents = HashMap::new();\n+    let mut exported_items = HashSet::new();\n+\n+    // First, figure out who everyone's parent is\n+    {\n+        let mut visitor = ParentVisitor {\n+            parents: &mut parents,\n+            curparent: ast::DUMMY_NODE_ID,\n+        };\n+        visit::walk_crate(&mut visitor, crate, ());\n+    }\n \n-        ast::item_static(*) |\n-        ast::item_fn(*) | ast::item_mod(*) | ast::item_ty(*) |\n-        ast::item_mac(*) => {\n-            check_not_priv(item.span, item.vis, \"items are private by default\");\n-        }\n+    // Next, build up the list of all exported items from this crate\n+    {\n+        // Initialize the exported items with resolve's id for the \"root crate\"\n+        // to resolve references to `super` leading to the root and such.\n+        exported_items.insert(0);\n+        let mut visitor = EmbargoVisitor {\n+            exported_items: &mut exported_items,\n+            exp_map2: exp_map2,\n+            path_all_public: true, // start out as public\n+        };\n+        visit::walk_crate(&mut visitor, crate, ());\n+    }\n+\n+    // And then actually check the privacy of everything.\n+    {\n+        let mut visitor = PrivacyVisitor {\n+            curitem: ast::DUMMY_NODE_ID,\n+            tcx: tcx,\n+            exported_items: &exported_items,\n+            parents: &parents,\n+            method_map: method_map,\n+            external_exports: external_exports,\n+            last_private_map: last_private_map,\n+        };\n+        visit::walk_crate(&mut visitor, crate, ());\n     }\n }"}, {"sha": "156cb741af3e0f4bbac4d4a032725017edd75af6", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 496, "deletions": 479, "changes": 975, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da"}, {"sha": "73b197ec3619909700d2c084772d701dab4118c6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -3034,7 +3034,6 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::encode_\n             diag: diag,\n             tcx: cx.tcx,\n             reexports2: cx.exp_map2,\n-            exported_items: cx.exported_items,\n             item_symbols: item_symbols,\n             discrim_symbols: discrim_symbols,\n             non_inlineable_statics: &cx.non_inlineable_statics,\n@@ -3116,7 +3115,6 @@ pub fn trans_crate(sess: session::Session,\n                                      llmod_id,\n                                      analysis.ty_cx,\n                                      analysis.exp_map2,\n-                                     analysis.exported_items,\n                                      analysis.maps,\n                                      symbol_hasher,\n                                      link_meta,"}, {"sha": "bb1e32bf34e3dc6f647355939f62bda76a046898", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -16,7 +16,6 @@ use lib::llvm::{llvm, TargetData, TypeNames};\n use lib::llvm::mk_target_data;\n use metadata::common::LinkMeta;\n use middle::astencode;\n-use middle::privacy;\n use middle::resolve;\n use middle::trans::adt;\n use middle::trans::base;\n@@ -49,7 +48,6 @@ pub struct CrateContext {\n      intrinsics: HashMap<&'static str, ValueRef>,\n      item_vals: HashMap<ast::NodeId, ValueRef>,\n      exp_map2: resolve::ExportMap2,\n-     exported_items: @privacy::ExportedItems,\n      reachable: @mut HashSet<ast::NodeId>,\n      item_symbols: HashMap<ast::NodeId, ~str>,\n      link_meta: LinkMeta,\n@@ -125,7 +123,6 @@ impl CrateContext {\n                name: &str,\n                tcx: ty::ctxt,\n                emap2: resolve::ExportMap2,\n-               exported_items: @privacy::ExportedItems,\n                maps: astencode::Maps,\n                symbol_hasher: hash::State,\n                link_meta: LinkMeta,\n@@ -185,7 +182,6 @@ impl CrateContext {\n                   intrinsics: intrinsics,\n                   item_vals: HashMap::new(),\n                   exp_map2: emap2,\n-                  exported_items: exported_items,\n                   reachable: reachable,\n                   item_symbols: HashMap::new(),\n                   link_meta: link_meta,"}, {"sha": "3de3f99020e6549cdadeb31906bd801f6b5dcb94", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -581,7 +581,7 @@ impl Datum {\n \n         if !header && !ty::type_contents(bcx.tcx(), content_ty).contains_managed() {\n             let ptr = self.to_value_llval(bcx);\n-            let ty = type_of(bcx.ccx(), content_ty);\n+            let ty = type_of::type_of(bcx.ccx(), content_ty);\n             let body = PointerCast(bcx, ptr, ty.ptr_to());\n             Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n         } else { // has a header"}, {"sha": "a6cf63449990464f49beb0982969bba43b7f805a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -1026,7 +1026,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                         // which may not be equal to the enum's type for\n                         // non-C-like enums.\n                         let val = base::get_item_val(bcx.ccx(), did.node);\n-                        let pty = type_of(bcx.ccx(), const_ty).ptr_to();\n+                        let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n                         PointerCast(bcx, val, pty)\n                     } else {\n                         {\n@@ -1040,7 +1040,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                         }\n \n                         unsafe {\n-                            let llty = type_of(bcx.ccx(), const_ty);\n+                            let llty = type_of::type_of(bcx.ccx(), const_ty);\n                             let symbol = csearch::get_symbol(\n                                 bcx.ccx().sess.cstore,\n                                 did);\n@@ -1396,7 +1396,7 @@ fn trans_unary_datum(bcx: @mut Block,\n                         heap: heap) -> DatumBlock {\n         let _icx = push_ctxt(\"trans_boxed_expr\");\n         if heap == heap_exchange {\n-            let llty = type_of(bcx.ccx(), contents_ty);\n+            let llty = type_of::type_of(bcx.ccx(), contents_ty);\n             let size = llsize_of(bcx.ccx(), llty);\n             let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, contents_ty,\n                                                                heap_exchange, size);"}, {"sha": "01470b13e3ae79360bc14a0010a1a64f8dd292dd", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -203,7 +203,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n                                field: uint,\n                                ti: @mut tydesc_info) {\n     let _icx = push_ctxt(\"lazily_emit_tydesc_glue\");\n-    let llfnty = Type::glue_fn(type_of::type_of(ccx, ti.ty).ptr_to());\n+    let llfnty = Type::glue_fn(type_of(ccx, ti.ty).ptr_to());\n \n     if lazily_emit_simplified_tydesc_glue(ccx, field, ti) {\n         return;\n@@ -345,7 +345,7 @@ pub fn make_visit_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n                 bcx.tcx().sess.fatal(s);\n             }\n         };\n-        let v = PointerCast(bcx, v, type_of::type_of(bcx.ccx(), object_ty).ptr_to());\n+        let v = PointerCast(bcx, v, type_of(bcx.ccx(), object_ty).ptr_to());\n         bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, visitor_trait.def_id);\n         // The visitor is a boxed object and needs to be dropped\n         add_clean(bcx, v, object_ty);"}, {"sha": "ae8081df7bac25c66bea8739b9ea5c566870b439", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -330,8 +330,8 @@ impl CoherenceChecker {\n \n         let impl_poly_type = ty::lookup_item_type(tcx, impl_id);\n \n-        let provided = ty::provided_trait_methods(tcx, trait_ref.def_id);\n-        for trait_method in provided.iter() {\n+        let prov = ty::provided_trait_methods(tcx, trait_ref.def_id);\n+        for trait_method in prov.iter() {\n             // Synthesize an ID.\n             let new_id = tcx.sess.next_node_id();\n             let new_did = local_def(new_id);"}, {"sha": "acb8720c786b7fa37c518e9eab7e9ce04c566f1d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -126,7 +126,7 @@ enum Implementor {\n /// to be a fairly large and expensive structure to clone. Instead this adheres\n /// to both `Send` and `Freeze` so it may be stored in a `RWArc` instance and\n /// shared among the various rendering tasks.\n-struct Cache {\n+pub struct Cache {\n     /// Mapping of typaram ids to the name of the type parameter. This is used\n     /// when pretty-printing a type (so pretty printing doesn't have to\n     /// painfully maintain a context like this)"}, {"sha": "4ab9ac4aef5f362717aad896b30f35e1cad0cf62", "filename": "src/librusti/program.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -24,7 +24,7 @@ use utils::*;\n /// This structure keeps track of the state of the world for the code being\n /// executed in rusti.\n #[deriving(Clone)]\n-struct Program {\n+pub struct Program {\n     /// All known local variables\n     local_vars: HashMap<~str, LocalVariable>,\n     /// New variables which will be present (learned from typechecking)"}, {"sha": "0c515538266d5cbc3f72b13d26c13605c0964af0", "filename": "src/libstd/num/cmath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Fnum%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Fnum%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fcmath.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -36,10 +36,10 @@ pub mod c_double_utils {\n         pub fn exp(n: c_double) -> c_double;\n         // rename: for consistency with underscore usage elsewhere\n         #[link_name=\"expm1\"]\n-        fn exp_m1(n: c_double) -> c_double;\n+        pub fn exp_m1(n: c_double) -> c_double;\n         pub fn exp2(n: c_double) -> c_double;\n         #[link_name=\"fabs\"]\n-        fn abs(n: c_double) -> c_double;\n+        pub fn abs(n: c_double) -> c_double;\n         // rename: for clarity and consistency with add/sub/mul/div\n         #[link_name=\"fdim\"]\n         pub fn abs_sub(a: c_double, b: c_double) -> c_double;"}, {"sha": "2269469ee23cc224404922ff8fdba2d823bbf3ae", "filename": "src/libstd/rt/io/buffered.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -335,14 +335,15 @@ mod test {\n     // newtype struct autoderef weirdness\n     #[test]\n     fn test_buffered_stream() {\n+        use rt;\n         struct S;\n \n-        impl Writer for S {\n+        impl rt::io::Writer for S {\n             fn write(&mut self, _: &[u8]) {}\n             fn flush(&mut self) {}\n         }\n \n-        impl Reader for S {\n+        impl rt::io::Reader for S {\n             fn read(&mut self, _: &mut [u8]) -> Option<uint> { None }\n             fn eof(&mut self) -> bool { true }\n         }"}, {"sha": "a18f97930fa2f65ea3fd884c76d50028d0764d0d", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -300,7 +300,8 @@ pub mod comm_adapters;\n mod extensions;\n \n /// Non-I/O things needed by the I/O module\n-mod support;\n+// XXX: shouldn this really be pub?\n+pub mod support;\n \n /// Basic Timer\n pub mod timer;"}, {"sha": "c7c4d3fc4f6256d93518dc716fd7c24acaf5051e", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -67,14 +67,27 @@ use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown};\n use rt::sleeper_list::SleeperList;\n use rt::task::{Task, SchedTask, GreenTask, Sched};\n-use rt::thread::Thread;\n-use rt::work_queue::WorkQueue;\n use rt::uv::uvio::UvEventLoop;\n use unstable::atomics::{AtomicInt, SeqCst};\n use unstable::sync::UnsafeArc;\n use vec;\n use vec::{OwnedVector, MutableVector, ImmutableVector};\n \n+use self::thread::Thread;\n+use self::work_queue::WorkQueue;\n+\n+// XXX: these probably shouldn't be public...\n+#[doc(hidden)]\n+pub mod shouldnt_be_public {\n+    pub use super::sched::Scheduler;\n+    pub use super::kill::KillHandle;\n+    pub use super::thread::Thread;\n+    pub use super::work_queue::WorkQueue;\n+    pub use super::select::SelectInner;\n+    pub use super::rtio::EventLoop;\n+    pub use super::select::{SelectInner, SelectPortInner};\n+}\n+\n /// The global (exchange) heap.\n pub mod global_heap;\n "}, {"sha": "cbffec51cc96910aea8eeb2f4cf22e13bfa7cd5e", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -803,6 +803,12 @@ impl SchedHandle {\n         self.queue.push(msg);\n         self.remote.fire();\n     }\n+    pub fn send_task_from_friend(&mut self, friend: ~Task) {\n+        self.send(TaskFromFriend(friend));\n+    }\n+    pub fn send_shutdown(&mut self) {\n+        self.send(Shutdown);\n+    }\n }\n \n struct CleanupJob {"}, {"sha": "049b301144bedcea8bc05785abcf988096e6d0bb", "filename": "src/libstd/select.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -15,10 +15,8 @@ use iter::{Iterator, DoubleEndedIterator};\n use option::*;\n // use either::{Either, Left, Right};\n // use rt::kill::BlockedTask;\n-use rt::sched::Scheduler;\n-use rt::select::{SelectInner, SelectPortInner};\n use rt::local::Local;\n-use rt::rtio::EventLoop;\n+use rt::shouldnt_be_public::{EventLoop, Scheduler, SelectInner, SelectPortInner};\n use task;\n use unstable::finally::Finally;\n use vec::{OwnedVector, MutableVector};"}, {"sha": "a46e115a503cab08c133da7d54bc445adfaeda29", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -551,7 +551,7 @@ pub fn deschedule() {\n     //! Yield control to the task scheduler\n \n     use rt::local::Local;\n-    use rt::sched::Scheduler;\n+    use rt::shouldnt_be_public::Scheduler;\n \n     // FIXME(#7544): Optimize this, since we know we won't block.\n     let sched: ~Scheduler = Local::take();\n@@ -1069,7 +1069,7 @@ fn test_try_fail() {\n \n #[cfg(test)]\n fn get_sched_id() -> int {\n-    do Local::borrow |sched: &mut ::rt::sched::Scheduler| {\n+    do Local::borrow |sched: &mut ::rt::shouldnt_be_public::Scheduler| {\n         sched.sched_id() as int\n     }\n }"}, {"sha": "a801bf3328db20273a6441fd323e6df0d2f57055", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -89,11 +89,8 @@ use unstable::sync::Exclusive;\n use rt::in_green_task_context;\n use rt::local::Local;\n use rt::task::{Task, Sched};\n-use rt::kill::KillHandle;\n-use rt::sched::Scheduler;\n+use rt::shouldnt_be_public::{Scheduler, KillHandle, WorkQueue, Thread};\n use rt::uv::uvio::UvEventLoop;\n-use rt::thread::Thread;\n-use rt::work_queue::WorkQueue;\n \n #[cfg(test)] use task::default_task_opts;\n #[cfg(test)] use comm;\n@@ -556,8 +553,6 @@ fn enlist_many(child: &KillHandle, child_arc: &TaskGroupArc,\n }\n \n pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n-    use rt::sched::*;\n-\n     rtassert!(in_green_task_context());\n \n     let child_data = Cell::new(gen_child_taskgroup(opts.linked, opts.supervised));\n@@ -622,7 +617,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n             let mut new_sched_handle = new_sched.make_handle();\n \n             // Allow the scheduler to exit when the pinned task exits\n-            new_sched_handle.send(Shutdown);\n+            new_sched_handle.send_shutdown();\n \n             // Pin the new task to the new scheduler\n             let new_task = if opts.watched {\n@@ -660,7 +655,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n                 rtdebug!(\"enqueing join_task\");\n                 // Now tell the original scheduler to join with this thread\n                 // by scheduling a thread-joining task on the original scheduler\n-                orig_sched_handle.send(TaskFromFriend(join_task));\n+                orig_sched_handle.send_task_from_friend(join_task);\n \n                 // NB: We can't simply send a message from here to another task\n                 // because this code isn't running in a task and message passing doesn't"}, {"sha": "0e281f33e2a3d317836ff5a107e78b1ec6dcbe9a", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -38,7 +38,7 @@ a normal large stack.\n */\n pub fn run_in_bare_thread(f: ~fn()) {\n     use cell::Cell;\n-    use rt::thread::Thread;\n+    use rt::shouldnt_be_public::Thread;\n \n     let f_cell = Cell::new(f);\n     let (port, chan) = comm::stream();"}, {"sha": "44cfdb860576b27ea7b7673d1fa3e0aa774b3ad2", "filename": "src/libstd/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -90,10 +90,10 @@ mod tests {\n     use super::*;\n \n     use clone::Clone;\n+    use ops::Drop;\n     use option::{None, Some};\n     use either::{Either, Left, Right};\n     use sys::size_of;\n-    use kinds::Drop;\n \n     #[test]\n     fn identity_crisis() {"}, {"sha": "d9e24e045ffd27e46fab6177d6d9f3d7cff0199a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -702,32 +702,6 @@ pub fn struct_def_is_tuple_like(struct_def: &ast::struct_def) -> bool {\n     struct_def.ctor_id.is_some()\n }\n \n-pub fn visibility_to_privacy(visibility: visibility) -> Privacy {\n-    match visibility {\n-        public => Public,\n-        inherited | private => Private\n-    }\n-}\n-\n-pub fn variant_visibility_to_privacy(visibility: visibility,\n-                                     enclosing_is_public: bool)\n-                                  -> Privacy {\n-    if enclosing_is_public {\n-        match visibility {\n-            public | inherited => Public,\n-            private => Private\n-        }\n-    } else {\n-        visibility_to_privacy(visibility)\n-    }\n-}\n-\n-#[deriving(Eq)]\n-pub enum Privacy {\n-    Private,\n-    Public\n-}\n-\n /// Returns true if the given pattern consists solely of an identifier\n /// and false otherwise.\n pub fn pat_is_ident(pat: @ast::Pat) -> bool {\n@@ -990,7 +964,7 @@ mod test {\n     use super::*;\n     use std::io;\n     use opt_vec;\n-    use std::hash::HashMap;\n+    use std::hashmap::HashMap;\n \n     fn ident_to_segment(id : &Ident) -> PathSegment {\n         PathSegment{identifier:id.clone(), lifetime: None, types: opt_vec::Empty}"}, {"sha": "1039ec078049ffea139cb9f2f0982d7cd5964de2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -1551,7 +1551,8 @@ mod test {\n         let varrefs = @mut ~[];\n         visit::walk_crate(&mut new_path_finder(varrefs), &renamed_ast, ());\n         match varrefs {\n-            @[Path{segments:[ref seg],_}] => assert_eq!(mtwt_resolve(seg.identifier),a2_name),\n+            @[ast::Path{segments:[ref seg],_}] =>\n+                assert_eq!(mtwt_resolve(seg.identifier),a2_name),\n             _ => assert_eq!(0,1)\n         }\n \n@@ -1565,7 +1566,8 @@ mod test {\n         let varrefs = @mut ~[];\n         visit::walk_crate(&mut new_path_finder(varrefs), &double_renamed, ());\n         match varrefs {\n-            @[Path{segments:[ref seg],_}] => assert_eq!(mtwt_resolve(seg.identifier),a3_name),\n+            @[ast::Path{segments:[ref seg],_}] =>\n+                assert_eq!(mtwt_resolve(seg.identifier),a3_name),\n             _ => assert_eq!(0,1)\n         }\n     }"}, {"sha": "3877250126d34e2fa028bfef3ca958852293a950", "filename": "src/test/compile-fail/export-import.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fexport-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fexport-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-import.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: import\n-\n use m::unexported;\n+//~^ ERROR: is private\n \n mod m {\n     pub fn exported() { }"}, {"sha": "d92cd20485083fdb4fa6d278c88570d50c855422", "filename": "src/test/compile-fail/export-tag-variant.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: unresolved name\n-\n mod foo {\n     pub fn x() { }\n \n     enum y { y1, }\n }\n \n-fn main() { let z = foo::y1; }\n+fn main() { let z = foo::y1; } //~ ERROR: is private"}, {"sha": "7363fb6d0b2df27b429be1363821638aee26703e", "filename": "src/test/compile-fail/glob-resolve1.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure that globs only bring in public things.\n+\n+#[feature(globs)];\n+\n+use bar::*;\n+\n+mod bar {\n+    use import = self::fpriv;\n+    fn fpriv() {}\n+    extern {\n+        fn epriv();\n+    }\n+    enum A { A1 }\n+    pub enum B { B1 }\n+\n+    struct C;\n+\n+    type D = int;\n+}\n+\n+fn foo<T>() {}\n+\n+fn main() {\n+    fpriv(); //~ ERROR: unresolved\n+    epriv(); //~ ERROR: unresolved\n+    A1; //~ ERROR: unresolved\n+    B1;\n+    C; //~ ERROR: unresolved\n+    import(); //~ ERROR: unresolved\n+\n+    foo::<A>(); //~ ERROR: undeclared\n+    //~^ ERROR: undeclared\n+    foo::<C>(); //~ ERROR: undeclared\n+    //~^ ERROR: undeclared\n+    foo::<D>(); //~ ERROR: undeclared\n+    //~^ ERROR: undeclared\n+}"}, {"sha": "61980abdfe7af882486be4e7f9a338485883ceac", "filename": "src/test/compile-fail/issue-3993-2.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fissue-3993-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fissue-3993-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3993-2.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use zoo::{duck, goose}; //~ ERROR failed to resolve import\n-                        //~^ ERROR unresolved import: found `goose` in `zoo` but it is private\n+use zoo::{duck, goose}; //~ ERROR: variant `goose` is private\n \n mod zoo {\n     pub enum bird {\n-        pub duck,\n+        pub duck, //~ ERROR: unnecessary `pub` visibility\n         priv goose\n     }\n }"}, {"sha": "fae5eb51272374b280988cdfcffee58076de906c", "filename": "src/test/compile-fail/issue-3993-3.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fissue-3993-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fissue-3993-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3993-3.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use zoo::fly; //~ ERROR failed to resolve import\n-              //~^ ERROR unresolved import: found `fly` in `zoo` but it is private\n+use zoo::fly; //~ ERROR: function `fly` is private\n \n mod zoo {\n-    type fly = ();\n     fn fly() {}\n }\n \n \n-fn main() {}\n+fn main() {\n+    fly();\n+}"}, {"sha": "fae5eb51272374b280988cdfcffee58076de906c", "filename": "src/test/compile-fail/issue-3993.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fissue-3993.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fissue-3993.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3993.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use zoo::fly; //~ ERROR failed to resolve import\n-              //~^ ERROR unresolved import: found `fly` in `zoo` but it is private\n+use zoo::fly; //~ ERROR: function `fly` is private\n \n mod zoo {\n     fn fly() {}\n }\n \n \n-fn main() {}\n+fn main() {\n+    fly();\n+}"}, {"sha": "6764b489b6255cc6be332656dfe64e99513e3548", "filename": "src/test/compile-fail/issue-4366-2.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fissue-4366-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fissue-4366-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4366-2.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(globs)];\n+\n+// ensures that 'use foo:*' doesn't import non-public item\n+\n+use m1::*;\n+\n+mod foo {\n+    pub fn foo() {}\n+}\n+mod a {\n+    pub mod b {\n+        use foo::foo;\n+        type bar = int;\n+    }\n+    pub mod sub {\n+        use a::b::*;\n+        fn sub() -> bar { 1 }\n+        //~^ ERROR: undeclared type name\n+    }\n+}\n+\n+mod m1 {\n+    fn foo() {}\n+}\n+\n+fn main() {\n+    foo(); //~ ERROR: unresolved name\n+}\n+"}, {"sha": "e9c1092a4a55922cf8085dd5ebae446789ba0aec", "filename": "src/test/compile-fail/issue-4366.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fissue-4366.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fissue-4366.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4366.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -27,15 +27,12 @@ mod a {\n     }\n     pub mod sub {\n         use a::b::*;\n-        fn sub() -> bar { foo(); 1 } //~ ERROR: unresolved name `foo`\n-        //~^ ERROR: use of undeclared type name `bar`\n+        fn sub() -> int { foo(); 1 } //~ ERROR: unresolved name `foo`\n     }\n }\n \n mod m1 {\n     fn foo() {}\n }\n \n-fn main() {\n-    foo(); //~ ERROR: unresolved name `foo`\n-}\n+fn main() {}"}, {"sha": "e87d57aaa5623cd3beaa1a6b852f5b3b9acaca69", "filename": "src/test/compile-fail/macro-local-data-key-priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -18,5 +18,5 @@ mod bar {\n \n fn main() {\n     local_data::set(bar::baz, -10.0);\n-    //~^ ERROR unresolved name `bar::baz`\n+    //~^ ERROR static `baz` is private\n }"}, {"sha": "0d4dbc86dce4d6e1a89ea3bea9a9499f4a1a19ed", "filename": "src/test/compile-fail/privacy1.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -0,0 +1,169 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(globs)];\n+#[no_std]; // makes debugging this test *a lot* easier (during resolve)\n+\n+mod bar {\n+    // shouln't bring in too much\n+    pub use self::glob::*;\n+\n+    // can't publicly re-export private items\n+    pub use self::baz::{foo, bar};\n+    //~^ ERROR: function `bar` is private\n+\n+    pub use self::private::ppriv;\n+    //~^ ERROR: function `ppriv` is private\n+\n+    pub struct A;\n+    impl A {\n+        pub fn foo() {}\n+        fn bar() {}\n+\n+        pub fn foo2(&self) {}\n+        fn bar2(&self) {}\n+    }\n+\n+    pub enum Enum {\n+        priv Priv,\n+        Pub\n+    }\n+\n+    mod baz {\n+        pub struct A;\n+        impl A {\n+            pub fn foo() {}\n+            fn bar() {}\n+\n+            pub fn foo2(&self) {}\n+            fn bar2(&self) {}\n+        }\n+\n+        // both of these are re-exported by `bar`, but only one should be\n+        // validly re-exported\n+        pub fn foo() {}\n+        fn bar() {}\n+    }\n+\n+    extern {\n+        fn epriv();\n+        pub fn epub();\n+    }\n+\n+    fn test() {\n+        self::Priv;\n+        self::Pub;\n+        unsafe {\n+            epriv();\n+            epub();\n+        }\n+        self::baz::A;\n+        self::baz::A::foo();\n+        self::baz::A::bar(); //~ ERROR: method `bar` is private\n+        self::baz::A.foo2();\n+        self::baz::A.bar2(); //~ ERROR: method `bar2` is private\n+\n+        // this used to cause an ICE in privacy traversal.\n+        super::gpub();\n+    }\n+\n+    mod glob {\n+        pub fn gpub() {}\n+        fn gpriv() {}\n+    }\n+\n+    mod private {\n+        fn ppriv() {}\n+    }\n+}\n+\n+pub fn gpub() {}\n+\n+fn lol() {\n+    bar::A;\n+    bar::A::foo();\n+    bar::A::bar(); //~ ERROR: method `bar` is private\n+    bar::A.foo2();\n+    bar::A.bar2(); //~ ERROR: method `bar2` is private\n+}\n+\n+mod foo {\n+    fn test() {\n+        ::bar::A::foo();\n+        ::bar::A::bar();        //~ ERROR: method `bar` is private\n+        ::bar::A.foo2();\n+        ::bar::A.bar2();        //~ ERROR: method `bar2` is private\n+        ::bar::baz::A::foo();   //~ ERROR: method `foo` is private\n+        ::bar::baz::A::bar();   //~ ERROR: method `bar` is private\n+        ::bar::baz::A.foo2();   //~ ERROR: struct `A` is private\n+        ::bar::baz::A.bar2();   //~ ERROR: struct `A` is private\n+                                //~^ ERROR: method `bar2` is private\n+        ::lol();\n+\n+        ::bar::Priv; //~ ERROR: variant `Priv` is private\n+        ::bar::Pub;\n+\n+        unsafe {\n+            ::bar::epriv(); //~ ERROR: function `epriv` is private\n+            ::bar::epub();\n+        }\n+\n+        ::bar::foo();\n+        ::bar::bar();\n+\n+        ::bar::gpub();\n+\n+        ::bar::baz::foo(); //~ ERROR: function `foo` is private\n+        ::bar::baz::bar(); //~ ERROR: function `bar` is private\n+    }\n+\n+    fn test2() {\n+        use bar::baz::{foo, bar};\n+        //~^ ERROR: function `foo` is private\n+        //~^^ ERROR: function `bar` is private\n+        foo();\n+        bar();\n+    }\n+\n+    fn test3() {\n+        use bar::baz;\n+        //~^ ERROR: module `baz` is private\n+    }\n+\n+    fn test4() {\n+        use bar::{foo, bar};\n+        foo();\n+        bar();\n+    }\n+\n+    fn test5() {\n+        use bar;\n+        bar::foo();\n+        bar::bar();\n+    }\n+}\n+\n+pub mod mytest {\n+    // Even though the inner `A` struct is a publicly exported item (usable from\n+    // external crates through `foo::foo`, it should not be accessible through\n+    // its definition path (which has the private `i` module).\n+    use self::foo::foo;\n+    use self::foo::i::A; //~ ERROR: type `A` is private\n+\n+    pub mod foo {\n+        pub use foo = self::i::A;\n+\n+        mod i {\n+            pub struct A;\n+        }\n+    }\n+}\n+\n+#[start] fn main(_: int, _: **u8) -> int { 3 }"}, {"sha": "98772b0c67b82cc8ad59c04b761ed9c4b31e2164", "filename": "src/test/compile-fail/privacy2.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(globs)];\n+#[no_std]; // makes debugging this test *a lot* easier (during resolve)\n+\n+// Test to make sure that globs don't leak in regular `use` statements.\n+\n+mod bar {\n+    pub use self::glob::*;\n+\n+    mod glob {\n+        use foo;\n+    }\n+}\n+\n+pub fn foo() {}\n+\n+fn test1() {\n+    use bar::foo; //~ ERROR: unresolved import\n+    //~^ ERROR: failed to resolve\n+}\n+\n+fn test2() {\n+    use bar::glob::foo;\n+    //~^ ERROR: there is no\n+    //~^^ ERROR: failed to resolve\n+}\n+\n+#[start] fn main(_: int, _: **u8) -> int { 3 }\n+"}, {"sha": "3308be4a12e782946a7ad894f041e1afc8f5f0d6", "filename": "src/test/compile-fail/privacy3.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fprivacy3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fprivacy3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy3.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(globs)];\n+#[no_std]; // makes debugging this test *a lot* easier (during resolve)\n+\n+// Test to make sure that private items imported through globs remain private\n+// when  they're used.\n+\n+mod bar {\n+    pub use self::glob::*;\n+\n+    mod glob {\n+        fn gpriv() {}\n+    }\n+}\n+\n+pub fn foo() {}\n+\n+fn test1() {\n+    use bar::gpriv; //~ ERROR: unresolved import\n+    //~^ ERROR: failed to resolve\n+    gpriv();\n+}\n+\n+#[start] fn main(_: int, _: **u8) -> int { 3 }"}, {"sha": "4e33536b2b05f381b31d62645a4fb5bb87cecedf", "filename": "src/test/compile-fail/privacy4.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(globs)];\n+#[no_std]; // makes debugging this test *a lot* easier (during resolve)\n+\n+// Test to make sure that private items imported through globs remain private\n+// when  they're used.\n+\n+mod bar {\n+    pub use self::glob::*;\n+\n+    mod glob {\n+        fn gpriv() {}\n+    }\n+}\n+\n+pub fn foo() {}\n+\n+fn test2() {\n+    use bar::glob::gpriv; //~ ERROR: function `gpriv` is private\n+    gpriv();\n+}\n+\n+#[start] fn main(_: int, _: **u8) -> int { 3 }"}, {"sha": "2b9e32b8f58607d460932978bfe62682828fe251", "filename": "src/test/compile-fail/private-item-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fprivate-item-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fprivate-item-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-item-simple.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -13,5 +13,5 @@ mod a {\n }\n \n fn main() {\n-    a::f(); //~ ERROR unresolved name\n+    a::f(); //~ ERROR function `f` is private\n }"}, {"sha": "d63d04c90ccca85534cd29e993feaf6ee2ae220e", "filename": "src/test/compile-fail/private-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fprivate-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fprivate-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-variant.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -17,5 +17,5 @@ mod a {\n }\n \n fn main() {\n-    let x = a::Liege;   //~ ERROR unresolved name\n+    let x = a::Liege;   //~ ERROR variant `Liege` is private\n }"}, {"sha": "f447a6c547c7bb7774eac47bd271d24b83134f31", "filename": "src/test/compile-fail/static-priv-by-default.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -24,15 +24,15 @@ mod child {\n fn foo(_: int) {}\n \n fn full_ref() {\n-    foo(static_priv_by_default::private); //~ ERROR: unresolved name\n+    foo(static_priv_by_default::private); //~ ERROR: static `private` is private\n     foo(static_priv_by_default::public);\n-    foo(child::childs_child::private); //~ ERROR: unresolved name\n+    foo(child::childs_child::private); //~ ERROR: static `private` is private\n     foo(child::childs_child::public);\n }\n \n fn medium_ref() {\n     use child::childs_child;\n-    foo(childs_child::private); //~ ERROR: unresolved name\n+    foo(childs_child::private); //~ ERROR: static `private` is private\n     foo(childs_child::public);\n }\n "}, {"sha": "423d182dd69202aca3ee8c21d71ce01049477e7e", "filename": "src/test/compile-fail/static-priv-by-default2.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default2.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -19,11 +19,22 @@ mod child {\n     }\n }\n \n-fn main() {\n-    use static_priv_by_default::private; //~ ERROR: unresolved import\n-    //~^ ERROR: failed to resolve\n-    use static_priv_by_default::public;\n-    use child::childs_child::private; //~ ERROR: unresolved import\n-    //~^ ERROR: failed to resolve\n+fn foo<T>(_: T) {}\n+\n+fn test1() {\n+    use child::childs_child::private;\n+    //~^ ERROR: static `private` is private\n     use child::childs_child::public;\n+\n+    foo(private);\n+}\n+\n+fn test2() {\n+    use static_priv_by_default::private;\n+    //~^ ERROR: static `private` is private\n+    use static_priv_by_default::public;\n+\n+    foo(private);\n }\n+\n+fn main() {}"}, {"sha": "a0a411ec9b03ce4388b46e4c6332b10e9f603cb3", "filename": "src/test/compile-fail/xc-private-method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -15,8 +15,8 @@ extern mod xc_private_method_lib;\n \n fn main() {\n     let _ = xc_private_method_lib::Struct::static_meth_struct();\n-    //~^ ERROR: unresolved name\n+    //~^ ERROR: method `static_meth_struct` is private\n \n     let _ = xc_private_method_lib::Enum::static_meth_enum();\n-    //~^ ERROR: unresolved name\n+    //~^ ERROR: method `static_meth_enum` is private\n }"}, {"sha": "ca1221e7432f571381361fd3e4c218e250e2f332", "filename": "src/test/compile-fail/xcrate-private-by-default.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -10,15 +10,14 @@\n \n // aux-build:static_priv_by_default.rs\n \n-#[allow(unused_imports)];\n-#[no_std];\n+#[no_std]; // helps if debugging resolve\n \n extern mod static_priv_by_default;\n \n fn foo<T>() {}\n \n #[start]\n-fn main(_: int, _: **u8, _: *u8) -> int {\n+fn main(_: int, _: **u8) -> int {\n     // Actual public items should be public\n     static_priv_by_default::a;\n     static_priv_by_default::b;\n@@ -33,25 +32,23 @@ fn main(_: int, _: **u8, _: *u8) -> int {\n \n     // private items at the top should be inaccessible\n     static_priv_by_default::i;\n-    //~^ ERROR: unresolved name\n+    //~^ ERROR: static `i` is private\n     static_priv_by_default::j;\n-    //~^ ERROR: unresolved name\n+    //~^ ERROR: function `j` is private\n     static_priv_by_default::k;\n-    //~^ ERROR: unresolved name\n+    //~^ ERROR: struct `k` is private\n     foo::<static_priv_by_default::l>();\n-    //~^ ERROR: use of undeclared type name\n-    //~^^ ERROR: use of undeclared type name\n+    //~^ ERROR: type `l` is private\n \n     // public items in a private mod should be inaccessible\n     static_priv_by_default::foo::a;\n-    //~^ ERROR: unresolved name\n+    //~^ ERROR: static `a` is private\n     static_priv_by_default::foo::b;\n-    //~^ ERROR: unresolved name\n+    //~^ ERROR: function `b` is private\n     static_priv_by_default::foo::c;\n-    //~^ ERROR: unresolved name\n+    //~^ ERROR: struct `c` is private\n     foo::<static_priv_by_default::foo::d>();\n-    //~^ ERROR: use of undeclared type name\n-    //~^^ ERROR: use of undeclared type name\n+    //~^ ERROR: type `d` is private\n \n     3\n }"}, {"sha": "8fdc9c563156d27ba4fe8e9d40453e5cf11d4ab4", "filename": "src/test/run-pass/export-non-interference2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n mod foo {\n-    mod bar {\n+    pub mod bar {\n         pub fn y() { super::super::foo::x(); }\n     }\n "}, {"sha": "e8a9d666dcc0c2765236518fab87278789abfb15", "filename": "src/test/run-pass/foreign-dupe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -17,7 +17,7 @@ mod rustrt1 {\n     #[abi = \"cdecl\"]\n     #[link_name = \"rustrt\"]\n     extern {\n-        fn rust_get_test_int() -> libc::intptr_t;\n+        pub fn rust_get_test_int() -> libc::intptr_t;\n     }\n }\n \n@@ -27,7 +27,7 @@ mod rustrt2 {\n     #[abi = \"cdecl\"]\n     #[link_name = \"rustrt\"]\n     extern {\n-        fn rust_get_test_int() -> libc::intptr_t;\n+        pub fn rust_get_test_int() -> libc::intptr_t;\n     }\n }\n "}, {"sha": "6a7ee7101efcf1beb5c975ed2471810c1473a555", "filename": "src/test/run-pass/foreign-no-abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -14,7 +14,7 @@ mod rustrt {\n     use std::libc;\n \n     extern {\n-        fn rust_get_test_int() -> libc::intptr_t;\n+        pub fn rust_get_test_int() -> libc::intptr_t;\n     }\n }\n "}, {"sha": "53c9ed631417cb7e5c1d3b36e60c199e94b46517", "filename": "src/test/run-pass/intrinsic-uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Fintrinsic-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Fintrinsic-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-uninit.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -11,7 +11,7 @@\n mod rusti {\n     #[abi = \"rust-intrinsic\"]\n     extern \"rust-intrinsic\" {\n-        fn uninit<T>() -> T;\n+        pub fn uninit<T>() -> T;\n     }\n }\n pub fn main() {"}, {"sha": "2ca71866db8e0d4a15d4412656ec07a00e69c888", "filename": "src/test/run-pass/intrinsics-integer.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -17,24 +17,24 @@ extern mod extra;\n mod rusti {\n     #[abi = \"rust-intrinsic\"]\n     extern \"rust-intrinsic\" {\n-        fn ctpop8(x: i8) -> i8;\n-        fn ctpop16(x: i16) -> i16;\n-        fn ctpop32(x: i32) -> i32;\n-        fn ctpop64(x: i64) -> i64;\n-\n-        fn ctlz8(x: i8) -> i8;\n-        fn ctlz16(x: i16) -> i16;\n-        fn ctlz32(x: i32) -> i32;\n-        fn ctlz64(x: i64) -> i64;\n-\n-        fn cttz8(x: i8) -> i8;\n-        fn cttz16(x: i16) -> i16;\n-        fn cttz32(x: i32) -> i32;\n-        fn cttz64(x: i64) -> i64;\n-\n-        fn bswap16(x: i16) -> i16;\n-        fn bswap32(x: i32) -> i32;\n-        fn bswap64(x: i64) -> i64;\n+        pub fn ctpop8(x: i8) -> i8;\n+        pub fn ctpop16(x: i16) -> i16;\n+        pub fn ctpop32(x: i32) -> i32;\n+        pub fn ctpop64(x: i64) -> i64;\n+\n+        pub fn ctlz8(x: i8) -> i8;\n+        pub fn ctlz16(x: i16) -> i16;\n+        pub fn ctlz32(x: i32) -> i32;\n+        pub fn ctlz64(x: i64) -> i64;\n+\n+        pub fn cttz8(x: i8) -> i8;\n+        pub fn cttz16(x: i16) -> i16;\n+        pub fn cttz32(x: i32) -> i32;\n+        pub fn cttz64(x: i64) -> i64;\n+\n+        pub fn bswap16(x: i16) -> i16;\n+        pub fn bswap32(x: i32) -> i32;\n+        pub fn bswap64(x: i64) -> i64;\n     }\n }\n "}, {"sha": "c11b1e8c074695e5db7913f6542571cecf40cd00", "filename": "src/test/run-pass/mod_dir_simple/load_another_mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Fmod_dir_simple%2Fload_another_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Fmod_dir_simple%2Fload_another_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod_dir_simple%2Fload_another_mod.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-mod test;\n+pub mod test;"}, {"sha": "7a07c97090223c4434193ac6ae482b204db786f8", "filename": "src/test/run-pass/privacy1.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivacy1.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod test2 {\n+    // This used to generate an ICE (make sure that default functions are\n+    // parented to their trait to find the first private thing as the trait).\n+\n+    struct B;\n+    trait A { fn foo(&self) {} }\n+    impl A for B {}\n+\n+    mod tests {\n+        use super::A;\n+        fn foo() {\n+            let a = super::B;\n+            a.foo();\n+        }\n+    }\n+}\n+\n+\n+pub fn main() {}"}, {"sha": "e833f67b51edc1561697b7044a14d94d72a214b1", "filename": "src/test/run-pass/rec-align-u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddd011ce8875c6c5b119e5a8957a51d524a95da/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u64.rs?ref=6ddd011ce8875c6c5b119e5a8957a51d524a95da", "patch": "@@ -46,7 +46,7 @@ mod m {\n     }\n \n     #[cfg(target_arch = \"x86_64\")]\n-    mod m {\n+    pub mod m {\n         pub fn align() -> uint { 8u }\n         pub fn size() -> uint { 16u }\n     }"}]}