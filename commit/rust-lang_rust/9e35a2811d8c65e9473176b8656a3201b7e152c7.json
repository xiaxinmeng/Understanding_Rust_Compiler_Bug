{"sha": "9e35a2811d8c65e9473176b8656a3201b7e152c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMzVhMjgxMWQ4YzY1ZTk0NzMxNzZiODY1NmEzMjAxYjdlMTUyYzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-04T07:27:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-04T07:27:59Z"}, "message": "Auto merge of #65087 - Centril:rollup-skxq0zr, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #64749 (Fix most remaining Polonius test differences)\n - #64817 (Replace ClosureSubsts with SubstsRef)\n - #64874 (Simplify ExprUseVisitor)\n - #65026 (metadata: Some crate loading cleanup)\n - #65073 (Remove `borrowck_graphviz_postflow` from test)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "2d3c6267ad0c267bd7401d6b2b850eeb73888ab9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d3c6267ad0c267bd7401d6b2b850eeb73888ab9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e35a2811d8c65e9473176b8656a3201b7e152c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e35a2811d8c65e9473176b8656a3201b7e152c7", "html_url": "https://github.com/rust-lang/rust/commit/9e35a2811d8c65e9473176b8656a3201b7e152c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e35a2811d8c65e9473176b8656a3201b7e152c7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31d75c4e9c5318e880601d3c2cc71e5df094a120", "url": "https://api.github.com/repos/rust-lang/rust/commits/31d75c4e9c5318e880601d3c2cc71e5df094a120", "html_url": "https://github.com/rust-lang/rust/commit/31d75c4e9c5318e880601d3c2cc71e5df094a120"}, {"sha": "aacc89a1dde9aa7f3dc76c38c411a3d6df922aad", "url": "https://api.github.com/repos/rust-lang/rust/commits/aacc89a1dde9aa7f3dc76c38c411a3d6df922aad", "html_url": "https://github.com/rust-lang/rust/commit/aacc89a1dde9aa7f3dc76c38c411a3d6df922aad"}], "stats": {"total": 2673, "additions": 528, "deletions": 2145}, "files": [{"sha": "b89731273f7e22465ef00dc17e361a563d3970b8", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -220,7 +220,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         let ty_msg = match local_visitor.found_ty {\n             Some(ty::TyS { kind: ty::Closure(def_id, substs), .. }) => {\n-                let fn_sig = substs.closure_sig(*def_id, self.tcx);\n+                let fn_sig = substs.as_closure().sig(*def_id, self.tcx);\n                 let args = closure_args(&fn_sig);\n                 let ret = fn_sig.output().skip_binder().to_string();\n                 format!(\" for the closure `fn({}) -> {}`\", args, ret)\n@@ -255,7 +255,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         let suffix = match local_visitor.found_ty {\n             Some(ty::TyS { kind: ty::Closure(def_id, substs), .. }) => {\n-                let fn_sig = substs.closure_sig(*def_id, self.tcx);\n+                let fn_sig = substs.as_closure().sig(*def_id, self.tcx);\n                 let ret = fn_sig.output().skip_binder().to_string();\n \n                 if let Some(ExprKind::Closure(_, decl, body_id, ..)) = local_visitor.found_closure {"}, {"sha": "ea9e931ad838e83c71ec470ace67064e717acb08", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1504,9 +1504,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn closure_kind(\n         &self,\n         closure_def_id: DefId,\n-        closure_substs: ty::ClosureSubsts<'tcx>,\n+        closure_substs: SubstsRef<'tcx>,\n     ) -> Option<ty::ClosureKind> {\n-        let closure_kind_ty = closure_substs.closure_kind_ty(closure_def_id, self.tcx);\n+        let closure_kind_ty = closure_substs.as_closure().kind_ty(closure_def_id, self.tcx);\n         let closure_kind_ty = self.shallow_resolve(closure_kind_ty);\n         closure_kind_ty.to_opt_closure_kind()\n     }\n@@ -1518,9 +1518,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn closure_sig(\n         &self,\n         def_id: DefId,\n-        substs: ty::ClosureSubsts<'tcx>,\n+        substs: SubstsRef<'tcx>,\n     ) -> ty::PolyFnSig<'tcx> {\n-        let closure_sig_ty = substs.closure_sig_ty(def_id, self.tcx);\n+        let closure_sig_ty = substs.as_closure().sig_ty(def_id, self.tcx);\n         let closure_sig_ty = self.shallow_resolve(closure_sig_ty);\n         closure_sig_ty.fn_sig(self.tcx)\n     }"}, {"sha": "e7205dd47a6172c657913b72673d90e1c34ca56c", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -722,11 +722,11 @@ where\n             ty::Closure(def_id, ref substs) => {\n                 // Skip lifetime parameters of the enclosing item(s)\n \n-                for upvar_ty in substs.upvar_tys(def_id, self.tcx) {\n+                for upvar_ty in substs.as_closure().upvar_tys(def_id, self.tcx) {\n                     upvar_ty.visit_with(self);\n                 }\n \n-                substs.closure_sig_ty(def_id, self.tcx).visit_with(self);\n+                substs.as_closure().sig_ty(def_id, self.tcx).visit_with(self);\n             }\n \n             ty::Generator(def_id, ref substs, _) => {\n@@ -886,7 +886,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n \n                 let generics = self.tcx.generics_of(def_id);\n                 let substs =\n-                    self.tcx.mk_substs(substs.substs.iter().enumerate().map(|(index, &kind)| {\n+                    self.tcx.mk_substs(substs.iter().enumerate().map(|(index, &kind)| {\n                         if index < generics.parent_count {\n                             // Accommodate missing regions in the parent kinds...\n                             self.fold_kind_mapping_missing_regions_to_empty(kind)\n@@ -896,7 +896,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                         }\n                     }));\n \n-                self.tcx.mk_closure(def_id, ty::ClosureSubsts { substs })\n+                self.tcx.mk_closure(def_id, substs)\n             }\n \n             ty::Generator(def_id, substs, movability) => {"}, {"sha": "510787998ad071c969f8cab544042737ecbb4418", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -148,9 +148,7 @@ pub enum ExternCrateSource {\n         /// such ids\n         DefId,\n     ),\n-    // Crate is loaded by `use`.\n-    Use,\n-    /// Crate is implicitly loaded by an absolute path.\n+    /// Crate is implicitly loaded by a path resolving through extern prelude.\n     Path,\n }\n "}, {"sha": "bb7ac5d8dbe1a75c79af0ac5e89fabb49dd5d390", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 79, "deletions": 394, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -2,25 +2,20 @@\n //! normal visitor, which just walks the entire body in one shot, the\n //! `ExprUseVisitor` determines how expressions are being used.\n \n-pub use self::LoanCause::*;\n pub use self::ConsumeMode::*;\n-pub use self::MoveReason::*;\n-pub use self::MatchMode::*;\n-use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n-use crate::hir::def::{CtorOf, Res, DefKind};\n+use crate::hir::def::Res;\n use crate::hir::def_id::DefId;\n use crate::hir::ptr::P;\n use crate::infer::InferCtxt;\n use crate::middle::mem_categorization as mc;\n use crate::middle::region;\n-use crate::ty::{self, DefIdTree, TyCtxt, adjustment};\n+use crate::ty::{self, TyCtxt, adjustment};\n \n use crate::hir::{self, PatKind};\n use std::rc::Rc;\n use syntax_pos::Span;\n-use crate::util::nodemap::ItemLocalSet;\n \n ///////////////////////////////////////////////////////////////////////////\n // The Delegate trait\n@@ -30,161 +25,19 @@ use crate::util::nodemap::ItemLocalSet;\n pub trait Delegate<'tcx> {\n     // The value found at `cmt` is either copied or moved, depending\n     // on mode.\n-    fn consume(&mut self,\n-               consume_id: hir::HirId,\n-               consume_span: Span,\n-               cmt: &mc::cmt_<'tcx>,\n-               mode: ConsumeMode);\n-\n-    // The value found at `cmt` has been determined to match the\n-    // pattern binding `matched_pat`, and its subparts are being\n-    // copied or moved depending on `mode`.  Note that `matched_pat`\n-    // is called on all variant/structs in the pattern (i.e., the\n-    // interior nodes of the pattern's tree structure) while\n-    // consume_pat is called on the binding identifiers in the pattern\n-    // (which are leaves of the pattern's tree structure).\n-    //\n-    // Note that variants/structs and identifiers are disjoint; thus\n-    // `matched_pat` and `consume_pat` are never both called on the\n-    // same input pattern structure (though of `consume_pat` can be\n-    // called on a subpart of an input passed to `matched_pat).\n-    fn matched_pat(&mut self,\n-                   matched_pat: &hir::Pat,\n-                   cmt: &mc::cmt_<'tcx>,\n-                   mode: MatchMode);\n-\n-    // The value found at `cmt` is either copied or moved via the\n-    // pattern binding `consume_pat`, depending on mode.\n-    fn consume_pat(&mut self,\n-                   consume_pat: &hir::Pat,\n-                   cmt: &mc::cmt_<'tcx>,\n-                   mode: ConsumeMode);\n-\n-    // The value found at `borrow` is being borrowed at the point\n-    // `borrow_id` for the region `loan_region` with kind `bk`.\n-    fn borrow(&mut self,\n-              borrow_id: hir::HirId,\n-              borrow_span: Span,\n-              cmt: &mc::cmt_<'tcx>,\n-              loan_region: ty::Region<'tcx>,\n-              bk: ty::BorrowKind,\n-              loan_cause: LoanCause);\n-\n-    // The local variable `id` is declared but not initialized.\n-    fn decl_without_init(&mut self,\n-                         id: hir::HirId,\n-                         span: Span);\n+    fn consume(&mut self, cmt: &mc::cmt_<'tcx>, mode: ConsumeMode);\n \n-    // The path at `cmt` is being assigned to.\n-    fn mutate(&mut self,\n-              assignment_id: hir::HirId,\n-              assignment_span: Span,\n-              assignee_cmt: &mc::cmt_<'tcx>,\n-              mode: MutateMode);\n-\n-    // A nested closure or generator - only one layer deep.\n-    fn nested_body(&mut self, _body_id: hir::BodyId) {}\n-}\n+    // The value found at `cmt` is being borrowed with kind `bk`.\n+    fn borrow(&mut self, cmt: &mc::cmt_<'tcx>, bk: ty::BorrowKind);\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum LoanCause {\n-    ClosureCapture(Span),\n-    AddrOf,\n-    AutoRef,\n-    AutoUnsafe,\n-    RefBinding,\n-    OverloadedOperator,\n-    ClosureInvocation,\n-    ForLoop,\n-    MatchDiscriminant\n+    // The path at `cmt` is being assigned to.\n+    fn mutate(&mut self, assignee_cmt: &mc::cmt_<'tcx>);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum ConsumeMode {\n     Copy,                // reference to x where x has a type that copies\n-    Move(MoveReason),    // reference to x where x has a type that moves\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum MoveReason {\n-    DirectRefMove,\n-    PatBindingMove,\n-    CaptureMove,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum MatchMode {\n-    NonBindingMatch,\n-    BorrowingMatch,\n-    CopyingMatch,\n-    MovingMatch,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-enum TrackMatchMode {\n-    Unknown,\n-    Definite(MatchMode),\n-    Conflicting,\n-}\n-\n-impl TrackMatchMode {\n-    // Builds up the whole match mode for a pattern from its constituent\n-    // parts.  The lattice looks like this:\n-    //\n-    //          Conflicting\n-    //            /     \\\n-    //           /       \\\n-    //      Borrowing   Moving\n-    //           \\       /\n-    //            \\     /\n-    //            Copying\n-    //               |\n-    //          NonBinding\n-    //               |\n-    //            Unknown\n-    //\n-    // examples:\n-    //\n-    // * `(_, some_int)` pattern is Copying, since\n-    //   NonBinding + Copying => Copying\n-    //\n-    // * `(some_int, some_box)` pattern is Moving, since\n-    //   Copying + Moving => Moving\n-    //\n-    // * `(ref x, some_box)` pattern is Conflicting, since\n-    //   Borrowing + Moving => Conflicting\n-    //\n-    // Note that the `Unknown` and `Conflicting` states are\n-    // represented separately from the other more interesting\n-    // `Definite` states, which simplifies logic here somewhat.\n-    fn lub(&mut self, mode: MatchMode) {\n-        *self = match (*self, mode) {\n-            // Note that clause order below is very significant.\n-            (Unknown, new) => Definite(new),\n-            (Definite(old), new) if old == new => Definite(old),\n-\n-            (Definite(old), NonBindingMatch) => Definite(old),\n-            (Definite(NonBindingMatch), new) => Definite(new),\n-\n-            (Definite(old), CopyingMatch) => Definite(old),\n-            (Definite(CopyingMatch), new) => Definite(new),\n-\n-            (Definite(_), _) => Conflicting,\n-            (Conflicting, _) => *self,\n-        };\n-    }\n-\n-    fn match_mode(&self) -> MatchMode {\n-        match *self {\n-            Unknown => NonBindingMatch,\n-            Definite(mode) => mode,\n-            Conflicting => {\n-                // Conservatively return MovingMatch to let the\n-                // compiler continue to make progress.\n-                MovingMatch\n-            }\n-        }\n-    }\n+    Move,                // reference to x where x has a type that moves\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -261,9 +114,6 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// - `param_env` --- parameter environment for trait lookups (esp. pertaining to `Copy`)\n     /// - `region_scope_tree` --- region scope tree for the code being analyzed\n     /// - `tables` --- typeck results for the code being analyzed\n-    /// - `rvalue_promotable_map` --- if you care about rvalue promotion, then provide\n-    ///   the map here (it can be computed with `tcx.rvalue_promotable_map(def_id)`).\n-    ///   `None` means that rvalues will be given more conservative lifetimes.\n     ///\n     /// See also `with_infer`, which is used *during* typeck.\n     pub fn new(\n@@ -273,15 +123,13 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         region_scope_tree: &'a region::ScopeTree,\n         tables: &'a ty::TypeckTables<'tcx>,\n-        rvalue_promotable_map: Option<&'tcx ItemLocalSet>,\n     ) -> Self {\n         ExprUseVisitor {\n             mc: mc::MemCategorizationContext::new(tcx,\n                                                   param_env,\n                                                   body_owner,\n                                                   region_scope_tree,\n-                                                  tables,\n-                                                  rvalue_promotable_map),\n+                                                  tables),\n             delegate,\n             param_env,\n         }\n@@ -317,16 +165,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             let param_ty = return_if_err!(self.mc.pat_ty_adjusted(&param.pat));\n             debug!(\"consume_body: param_ty = {:?}\", param_ty);\n \n-            let fn_body_scope_r =\n-                self.tcx().mk_region(ty::ReScope(\n-                    region::Scope {\n-                        id: body.value.hir_id.local_id,\n-                        data: region::ScopeData::Node\n-                }));\n             let param_cmt = Rc::new(self.mc.cat_rvalue(\n                 param.hir_id,\n                 param.pat.span,\n-                fn_body_scope_r, // Parameters live only as long as the fn body.\n                 param_ty));\n \n             self.walk_irrefutable_pat(param_cmt, &param.pat);\n@@ -339,15 +180,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         self.mc.tcx\n     }\n \n-    fn delegate_consume(&mut self,\n-                        consume_id: hir::HirId,\n-                        consume_span: Span,\n-                        cmt: &mc::cmt_<'tcx>) {\n-        debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n-               consume_id, cmt);\n+    fn delegate_consume(&mut self, cmt: &mc::cmt_<'tcx>) {\n+        debug!(\"delegate_consume(cmt={:?})\", cmt);\n \n-        let mode = copy_or_move(&self.mc, self.param_env, cmt, DirectRefMove);\n-        self.delegate.consume(consume_id, consume_span, cmt, mode);\n+        let mode = copy_or_move(&self.mc, self.param_env, cmt);\n+        self.delegate.consume(cmt, mode);\n     }\n \n     fn consume_exprs(&mut self, exprs: &[hir::Expr]) {\n@@ -360,30 +197,21 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         debug!(\"consume_expr(expr={:?})\", expr);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate_consume(expr.hir_id, expr.span, &cmt);\n+        self.delegate_consume(&cmt);\n         self.walk_expr(expr);\n     }\n \n-    fn mutate_expr(&mut self,\n-                   span: Span,\n-                   assignment_expr: &hir::Expr,\n-                   expr: &hir::Expr,\n-                   mode: MutateMode) {\n+    fn mutate_expr(&mut self, expr: &hir::Expr) {\n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.mutate(assignment_expr.hir_id, span, &cmt, mode);\n+        self.delegate.mutate(&cmt);\n         self.walk_expr(expr);\n     }\n \n-    fn borrow_expr(&mut self,\n-                   expr: &hir::Expr,\n-                   r: ty::Region<'tcx>,\n-                   bk: ty::BorrowKind,\n-                   cause: LoanCause) {\n-        debug!(\"borrow_expr(expr={:?}, r={:?}, bk={:?})\",\n-               expr, r, bk);\n+    fn borrow_expr(&mut self, expr: &hir::Expr, bk: ty::BorrowKind) {\n+        debug!(\"borrow_expr(expr={:?}, bk={:?})\", expr, bk);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.borrow(expr.hir_id, expr.span, &cmt, r, bk, cause);\n+        self.delegate.borrow(&cmt, bk);\n \n         self.walk_expr(expr)\n     }\n@@ -401,24 +229,24 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             hir::ExprKind::Path(_) => { }\n \n             hir::ExprKind::Type(ref subexpr, _) => {\n-                self.walk_expr(&subexpr)\n+                self.walk_expr(subexpr)\n             }\n \n             hir::ExprKind::Unary(hir::UnDeref, ref base) => { // *base\n-                self.select_from_expr(&base);\n+                self.select_from_expr(base);\n             }\n \n             hir::ExprKind::Field(ref base, _) => { // base.f\n-                self.select_from_expr(&base);\n+                self.select_from_expr(base);\n             }\n \n             hir::ExprKind::Index(ref lhs, ref rhs) => { // lhs[rhs]\n-                self.select_from_expr(&lhs);\n-                self.consume_expr(&rhs);\n+                self.select_from_expr(lhs);\n+                self.consume_expr(rhs);\n             }\n \n             hir::ExprKind::Call(ref callee, ref args) => { // callee(args)\n-                self.walk_callee(expr, &callee);\n+                self.walk_callee(expr, callee);\n                 self.consume_exprs(args);\n             }\n \n@@ -436,14 +264,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n             hir::ExprKind::Match(ref discr, ref arms, _) => {\n                 let discr_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&discr)));\n-                let r = self.tcx().lifetimes.re_empty;\n-                self.borrow_expr(&discr, r, ty::ImmBorrow, MatchDiscriminant);\n+                self.borrow_expr(&discr, ty::ImmBorrow);\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms {\n-                    let mode = self.arm_move_mode(discr_cmt.clone(), arm);\n-                    let mode = mode.match_mode();\n-                    self.walk_arm(discr_cmt.clone(), arm, mode);\n+                    self.walk_arm(discr_cmt.clone(), arm);\n                 }\n             }\n \n@@ -454,28 +279,16 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             hir::ExprKind::AddrOf(m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n-                let expr_ty = return_if_err!(self.mc.expr_ty(expr));\n-                if let ty::Ref(r, _, _) = expr_ty.kind {\n-                    let bk = ty::BorrowKind::from_mutbl(m);\n-                    self.borrow_expr(&base, r, bk, AddrOf);\n-                }\n+                let bk = ty::BorrowKind::from_mutbl(m);\n+                self.borrow_expr(&base, bk);\n             }\n \n             hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n                 for (o, output) in ia.outputs.iter().zip(outputs) {\n                     if o.is_indirect {\n                         self.consume_expr(output);\n                     } else {\n-                        self.mutate_expr(\n-                            output.span,\n-                            expr,\n-                            output,\n-                            if o.is_rw {\n-                                MutateMode::WriteAndRead\n-                            } else {\n-                                MutateMode::JustWrite\n-                            },\n-                        );\n+                        self.mutate_expr(output);\n                     }\n                 }\n                 self.consume_exprs(inputs);\n@@ -486,65 +299,64 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             hir::ExprKind::Err => {}\n \n             hir::ExprKind::Loop(ref blk, _, _) => {\n-                self.walk_block(&blk);\n+                self.walk_block(blk);\n             }\n \n             hir::ExprKind::Unary(_, ref lhs) => {\n-                self.consume_expr(&lhs);\n+                self.consume_expr(lhs);\n             }\n \n             hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n-                self.consume_expr(&lhs);\n-                self.consume_expr(&rhs);\n+                self.consume_expr(lhs);\n+                self.consume_expr(rhs);\n             }\n \n             hir::ExprKind::Block(ref blk, _) => {\n-                self.walk_block(&blk);\n+                self.walk_block(blk);\n             }\n \n             hir::ExprKind::Break(_, ref opt_expr) | hir::ExprKind::Ret(ref opt_expr) => {\n                 if let Some(ref expr) = *opt_expr {\n-                    self.consume_expr(&expr);\n+                    self.consume_expr(expr);\n                 }\n             }\n \n             hir::ExprKind::Assign(ref lhs, ref rhs) => {\n-                self.mutate_expr(expr.span, expr, &lhs, MutateMode::JustWrite);\n-                self.consume_expr(&rhs);\n+                self.mutate_expr(lhs);\n+                self.consume_expr(rhs);\n             }\n \n             hir::ExprKind::Cast(ref base, _) => {\n-                self.consume_expr(&base);\n+                self.consume_expr(base);\n             }\n \n             hir::ExprKind::DropTemps(ref expr) => {\n-                self.consume_expr(&expr);\n+                self.consume_expr(expr);\n             }\n \n             hir::ExprKind::AssignOp(_, ref lhs, ref rhs) => {\n                 if self.mc.tables.is_method_call(expr) {\n                     self.consume_expr(lhs);\n                 } else {\n-                    self.mutate_expr(expr.span, expr, &lhs, MutateMode::WriteAndRead);\n+                    self.mutate_expr(lhs);\n                 }\n-                self.consume_expr(&rhs);\n+                self.consume_expr(rhs);\n             }\n \n             hir::ExprKind::Repeat(ref base, _) => {\n-                self.consume_expr(&base);\n+                self.consume_expr(base);\n             }\n \n-            hir::ExprKind::Closure(_, _, body_id, fn_decl_span, _) => {\n-                self.delegate.nested_body(body_id);\n+            hir::ExprKind::Closure(_, _, _, fn_decl_span, _) => {\n                 self.walk_captures(expr, fn_decl_span);\n             }\n \n             hir::ExprKind::Box(ref base) => {\n-                self.consume_expr(&base);\n+                self.consume_expr(base);\n             }\n \n             hir::ExprKind::Yield(ref value, _) => {\n-                self.consume_expr(&value);\n+                self.consume_expr(value);\n             }\n         }\n     }\n@@ -560,24 +372,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             ty::Error => { }\n             _ => {\n                 if let Some(def_id) = self.mc.tables.type_dependent_def_id(call.hir_id) {\n-                    let call_scope = region::Scope {\n-                        id: call.hir_id.local_id,\n-                        data: region::ScopeData::Node\n-                    };\n                     match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                         FnMutOverloadedCall => {\n-                            let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n-                            self.borrow_expr(callee,\n-                                            call_scope_r,\n-                                            ty::MutBorrow,\n-                                            ClosureInvocation);\n+                            self.borrow_expr(callee, ty::MutBorrow);\n                         }\n                         FnOverloadedCall => {\n-                            let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n-                            self.borrow_expr(callee,\n-                                            call_scope_r,\n-                                            ty::ImmBorrow,\n-                                            ClosureInvocation);\n+                            self.borrow_expr(callee, ty::ImmBorrow);\n                         }\n                         FnOnceOverloadedCall => self.consume_expr(callee),\n                     }\n@@ -608,22 +408,14 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     }\n \n     fn walk_local(&mut self, local: &hir::Local) {\n-        match local.init {\n-            None => {\n-                local.pat.each_binding(|_, hir_id, span, _| {\n-                    self.delegate.decl_without_init(hir_id, span);\n-                })\n-            }\n-\n-            Some(ref expr) => {\n-                // Variable declarations with\n-                // initializers are considered\n-                // \"assigns\", which is handled by\n-                // `walk_pat`:\n-                self.walk_expr(&expr);\n-                let init_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&expr)));\n-                self.walk_irrefutable_pat(init_cmt, &local.pat);\n-            }\n+        if let Some(ref expr) = local.init {\n+            // Variable declarations with\n+            // initializers are considered\n+            // \"assigns\", which is handled by\n+            // `walk_pat`:\n+            self.walk_expr(&expr);\n+            let init_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&expr)));\n+            self.walk_irrefutable_pat(init_cmt, &local.pat);\n         }\n     }\n \n@@ -673,7 +465,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                             with_field.ident,\n                             with_field.ty(self.tcx(), substs)\n                         );\n-                        self.delegate_consume(with_expr.hir_id, with_expr.span, &cmt_field);\n+                        self.delegate_consume(&cmt_field);\n                     }\n                 }\n             }\n@@ -708,7 +500,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 adjustment::Adjust::Pointer(_)  => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n-                    self.delegate_consume(expr.hir_id, expr.span, &cmt);\n+                    self.delegate_consume(&cmt);\n                 }\n \n                 adjustment::Adjust::Deref(None) => {}\n@@ -720,7 +512,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 // this is an autoref of `x`.\n                 adjustment::Adjust::Deref(Some(ref deref)) => {\n                     let bk = ty::BorrowKind::from_mutbl(deref.mutbl);\n-                    self.delegate.borrow(expr.hir_id, expr.span, &cmt, deref.region, bk, AutoRef);\n+                    self.delegate.borrow(&cmt, bk);\n                 }\n \n                 adjustment::Adjust::Borrow(ref autoref) => {\n@@ -744,47 +536,23 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                autoref);\n \n         match *autoref {\n-            adjustment::AutoBorrow::Ref(r, m) => {\n-                self.delegate.borrow(expr.hir_id,\n-                                     expr.span,\n-                                     cmt_base,\n-                                     r,\n-                                     ty::BorrowKind::from_mutbl(m.into()),\n-                                     AutoRef);\n+            adjustment::AutoBorrow::Ref(_, m) => {\n+                self.delegate.borrow(cmt_base, ty::BorrowKind::from_mutbl(m.into()));\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {\n                 debug!(\"walk_autoref: expr.hir_id={} cmt_base={:?}\",\n                        expr.hir_id,\n                        cmt_base);\n \n-                // Converting from a &T to *T (or &mut T to *mut T) is\n-                // treated as borrowing it for the enclosing temporary\n-                // scope.\n-                let r = self.tcx().mk_region(ty::ReScope(\n-                    region::Scope {\n-                        id: expr.hir_id.local_id,\n-                        data: region::ScopeData::Node\n-                    }));\n-\n-                self.delegate.borrow(expr.hir_id,\n-                                     expr.span,\n-                                     cmt_base,\n-                                     r,\n-                                     ty::BorrowKind::from_mutbl(m),\n-                                     AutoUnsafe);\n+\n+                self.delegate.borrow(cmt_base, ty::BorrowKind::from_mutbl(m));\n             }\n         }\n     }\n \n-    fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm) -> TrackMatchMode {\n-        let mut mode = Unknown;\n-        self.determine_pat_move_mode(discr_cmt.clone(), &arm.pat, &mut mode);\n-        mode\n-    }\n-\n-    fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm, mode: MatchMode) {\n-        self.walk_pat(discr_cmt.clone(), &arm.pat, mode);\n+    fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm) {\n+        self.walk_pat(discr_cmt.clone(), &arm.pat);\n \n         if let Some(hir::Guard::If(ref e)) = arm.guard {\n             self.consume_expr(e)\n@@ -796,55 +564,22 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n     /// let binding, and *not* a match arm or nested pat.)\n     fn walk_irrefutable_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat) {\n-        let mut mode = Unknown;\n-        self.determine_pat_move_mode(cmt_discr.clone(), pat, &mut mode);\n-        let mode = mode.match_mode();\n-        self.walk_pat(cmt_discr, pat, mode);\n+        self.walk_pat(cmt_discr, pat);\n     }\n \n-    /// Identifies any bindings within `pat` and accumulates within\n-    /// `mode` whether the overall pattern/match structure is a move,\n-    /// copy, or borrow.\n-    fn determine_pat_move_mode(&mut self,\n-                               cmt_discr: mc::cmt<'tcx>,\n-                               pat: &hir::Pat,\n-                               mode: &mut TrackMatchMode) {\n-        debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr, pat);\n-\n-        return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n-            if let PatKind::Binding(..) = pat.kind {\n-                let bm = *self.mc.tables.pat_binding_modes()\n-                                        .get(pat.hir_id)\n-                                        .expect(\"missing binding mode\");\n-                match bm {\n-                    ty::BindByReference(..) =>\n-                        mode.lub(BorrowingMatch),\n-                    ty::BindByValue(..) => {\n-                        match copy_or_move(&self.mc, self.param_env, &cmt_pat, PatBindingMove) {\n-                            Copy => mode.lub(CopyingMatch),\n-                            Move(..) => mode.lub(MovingMatch),\n-                        }\n-                    }\n-                }\n-            }\n-        }));\n-    }\n \n-    /// The core driver for walking a pattern; `match_mode` must be\n-    /// established up front, e.g., via `determine_pat_move_mode` (see\n-    /// also `walk_irrefutable_pat` for patterns that stand alone).\n-    fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat, match_mode: MatchMode) {\n+    /// The core driver for walking a pattern\n+    fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat) {\n         debug!(\"walk_pat(cmt_discr={:?}, pat={:?})\", cmt_discr, pat);\n \n         let tcx = self.tcx();\n         let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n             if let PatKind::Binding(_, canonical_id, ..) = pat.kind {\n                 debug!(\n-                    \"walk_pat: binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n+                    \"walk_pat: binding cmt_pat={:?} pat={:?}\",\n                     cmt_pat,\n                     pat,\n-                    match_mode,\n                 );\n                 if let Some(&bm) = mc.tables.pat_binding_modes().get(pat.hir_id) {\n                     debug!(\"walk_pat: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n@@ -857,75 +592,34 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     // binding being produced.\n                     let def = Res::Local(canonical_id);\n                     if let Ok(ref binding_cmt) = mc.cat_res(pat.hir_id, pat.span, pat_ty, def) {\n-                        delegate.mutate(pat.hir_id, pat.span, binding_cmt, MutateMode::Init);\n+                        delegate.mutate(binding_cmt);\n                     }\n \n                     // It is also a borrow or copy/move of the value being matched.\n                     match bm {\n                         ty::BindByReference(m) => {\n-                            if let ty::Ref(r, _, _) = pat_ty.kind {\n-                                let bk = ty::BorrowKind::from_mutbl(m);\n-                                delegate.borrow(pat.hir_id, pat.span, &cmt_pat, r, bk, RefBinding);\n-                            }\n+                            let bk = ty::BorrowKind::from_mutbl(m);\n+                            delegate.borrow(&cmt_pat, bk);\n                         }\n                         ty::BindByValue(..) => {\n-                            let mode = copy_or_move(mc, param_env, &cmt_pat, PatBindingMove);\n+                            let mode = copy_or_move(mc, param_env, &cmt_pat);\n                             debug!(\"walk_pat binding consuming pat\");\n-                            delegate.consume_pat(pat, &cmt_pat, mode);\n+                            delegate.consume(&cmt_pat, mode);\n                         }\n                     }\n                 } else {\n                     tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                 }\n             }\n         }));\n-\n-        // Do a second pass over the pattern, calling `matched_pat` on\n-        // the interior nodes (enum variants and structs), as opposed\n-        // to the above loop's visit of than the bindings that form\n-        // the leaves of the pattern tree structure.\n-        return_if_err!(mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n-            let qpath = match pat.kind {\n-                PatKind::Path(ref qpath) |\n-                PatKind::TupleStruct(ref qpath, ..) |\n-                PatKind::Struct(ref qpath, ..) => qpath,\n-                _ => return\n-            };\n-            let res = mc.tables.qpath_res(qpath, pat.hir_id);\n-            match res {\n-                Res::Def(DefKind::Ctor(CtorOf::Variant, ..), variant_ctor_did) => {\n-                    let variant_did = mc.tcx.parent(variant_ctor_did).unwrap();\n-                    let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n-\n-                    debug!(\"variantctor downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n-                    delegate.matched_pat(pat, &downcast_cmt, match_mode);\n-                }\n-                Res::Def(DefKind::Variant, variant_did) => {\n-                    let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n-\n-                    debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n-                    delegate.matched_pat(pat, &downcast_cmt, match_mode);\n-                }\n-                Res::Def(DefKind::Struct, _)\n-                | Res::Def(DefKind::Ctor(..), _)\n-                | Res::Def(DefKind::Union, _)\n-                | Res::Def(DefKind::TyAlias, _)\n-                | Res::Def(DefKind::AssocTy, _)\n-                | Res::SelfTy(..) => {\n-                    debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n-                    delegate.matched_pat(pat, &cmt_pat, match_mode);\n-                }\n-                _ => {}\n-            }\n-        }));\n     }\n \n     fn walk_captures(&mut self, closure_expr: &hir::Expr, fn_decl_span: Span) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n         let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id);\n         if let Some(upvars) = self.tcx().upvars(closure_def_id) {\n-            for (&var_id, upvar) in upvars.iter() {\n+            for &var_id in upvars.keys() {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_id },\n                     closure_expr_id: closure_def_id.to_local(),\n@@ -936,19 +630,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                                                                    var_id));\n                 match upvar_capture {\n                     ty::UpvarCapture::ByValue => {\n-                        let mode = copy_or_move(&self.mc,\n-                                                self.param_env,\n-                                                &cmt_var,\n-                                                CaptureMove);\n-                        self.delegate.consume(closure_expr.hir_id, upvar.span, &cmt_var, mode);\n+                        let mode = copy_or_move(&self.mc, self.param_env, &cmt_var);\n+                        self.delegate.consume(&cmt_var, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                        self.delegate.borrow(closure_expr.hir_id,\n-                                             fn_decl_span,\n-                                             &cmt_var,\n-                                             upvar_borrow.region,\n-                                             upvar_borrow.kind,\n-                                             ClosureCapture(upvar.span));\n+                        self.delegate.borrow(&cmt_var, upvar_borrow.kind);\n                     }\n                 }\n             }\n@@ -971,10 +657,9 @@ fn copy_or_move<'a, 'tcx>(\n     mc: &mc::MemCategorizationContext<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cmt: &mc::cmt_<'tcx>,\n-    move_reason: MoveReason,\n ) -> ConsumeMode {\n     if !mc.type_is_copy_modulo_regions(param_env, cmt.ty, cmt.span) {\n-        Move(move_reason)\n+        Move\n     } else {\n         Copy\n     }"}, {"sha": "8f79b8aa29529696db470624c7a43a62a16c5ce1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 17, "deletions": 59, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -79,12 +79,11 @@ use std::fmt;\n use std::hash::{Hash, Hasher};\n use rustc_data_structures::fx::FxIndexMap;\n use std::rc::Rc;\n-use crate::util::nodemap::ItemLocalSet;\n \n #[derive(Clone, Debug, PartialEq)]\n pub enum Categorization<'tcx> {\n-    Rvalue(ty::Region<'tcx>),            // temporary val, argument is its scope\n-    ThreadLocal(ty::Region<'tcx>),       // value that cannot move, but still restricted in scope\n+    Rvalue,                              // temporary val\n+    ThreadLocal,                         // value that cannot move, but still restricted in scope\n     StaticItem,\n     Upvar(Upvar),                        // upvar referenced by closure env\n     Local(hir::HirId),                   // local variable\n@@ -219,7 +218,6 @@ pub struct MemCategorizationContext<'a, 'tcx> {\n     pub upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n     pub region_scope_tree: &'a region::ScopeTree,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n-    rvalue_promotable_map: Option<&'tcx ItemLocalSet>,\n     infcx: Option<&'a InferCtxt<'a, 'tcx>>,\n }\n \n@@ -335,15 +333,13 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         body_owner: DefId,\n         region_scope_tree: &'a region::ScopeTree,\n         tables: &'a ty::TypeckTables<'tcx>,\n-        rvalue_promotable_map: Option<&'tcx ItemLocalSet>,\n     ) -> MemCategorizationContext<'a, 'tcx> {\n         MemCategorizationContext {\n             tcx,\n             body_owner,\n             upvars: tcx.upvars(body_owner),\n             region_scope_tree,\n             tables,\n-            rvalue_promotable_map,\n             infcx: None,\n             param_env,\n         }\n@@ -369,19 +365,12 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ) -> MemCategorizationContext<'a, 'tcx> {\n         let tcx = infcx.tcx;\n \n-        // Subtle: we can't do rvalue promotion analysis until the\n-        // typeck phase is complete, which means that you can't trust\n-        // the rvalue lifetimes that result, but that's ok, since we\n-        // don't need to know those during type inference.\n-        let rvalue_promotable_map = None;\n-\n         MemCategorizationContext {\n             tcx,\n             body_owner,\n             upvars: tcx.upvars(body_owner),\n             region_scope_tree,\n             tables,\n-            rvalue_promotable_map,\n             infcx: Some(infcx),\n             param_env,\n         }\n@@ -664,8 +653,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                     .any(|attr| attr.check_name(sym::thread_local));\n \n                 let cat = if is_thread_local {\n-                    let re = self.temporary_scope(hir_id.local_id);\n-                    Categorization::ThreadLocal(re)\n+                    Categorization::ThreadLocal\n                 } else {\n                     Categorization::StaticItem\n                 };\n@@ -740,16 +728,18 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         let ty = self.node_ty(fn_hir_id)?;\n         let kind = match ty.kind {\n             ty::Generator(..) => ty::ClosureKind::FnOnce,\n-            ty::Closure(closure_def_id, closure_substs) => {\n+            ty::Closure(closure_def_id, substs) => {\n                 match self.infcx {\n                     // During upvar inference we may not know the\n                     // closure kind, just use the LATTICE_BOTTOM value.\n                     Some(infcx) =>\n-                        infcx.closure_kind(closure_def_id, closure_substs)\n-                             .unwrap_or(ty::ClosureKind::LATTICE_BOTTOM),\n+                        infcx.closure_kind(\n+                            closure_def_id,\n+                            substs\n+                        ).unwrap_or(ty::ClosureKind::LATTICE_BOTTOM),\n \n                     None =>\n-                        closure_substs.closure_kind(closure_def_id, self.tcx),\n+                        substs.as_closure().kind(closure_def_id, self.tcx),\n                 }\n             }\n             _ => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", ty),\n@@ -876,16 +866,6 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         ret\n     }\n \n-    /// Returns the lifetime of a temporary created by expr with id `id`.\n-    /// This could be `'static` if `id` is part of a constant expression.\n-    pub fn temporary_scope(&self, id: hir::ItemLocalId) -> ty::Region<'tcx> {\n-        let scope = self.region_scope_tree.temporary_scope(id);\n-        self.tcx.mk_region(match scope {\n-            Some(scope) => ty::ReScope(scope),\n-            None => ty::ReStatic\n-        })\n-    }\n-\n     pub fn cat_rvalue_node(&self,\n                            hir_id: hir::HirId,\n                            span: Span,\n@@ -894,41 +874,19 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         debug!(\"cat_rvalue_node(id={:?}, span={:?}, expr_ty={:?})\",\n                hir_id, span, expr_ty);\n \n-        let promotable = self.rvalue_promotable_map.as_ref().map(|m| m.contains(&hir_id.local_id))\n-                                                            .unwrap_or(false);\n-\n-        debug!(\"cat_rvalue_node: promotable = {:?}\", promotable);\n-\n-        // Always promote `[T; 0]` (even when e.g., borrowed mutably).\n-        let promotable = match expr_ty.kind {\n-            ty::Array(_, len) if len.try_eval_usize(self.tcx, self.param_env) == Some(0) => true,\n-            _ => promotable,\n-        };\n-\n-        debug!(\"cat_rvalue_node: promotable = {:?} (2)\", promotable);\n-\n-        // Compute maximum lifetime of this rvalue. This is 'static if\n-        // we can promote to a constant, otherwise equal to enclosing temp\n-        // lifetime.\n-        let re = if promotable {\n-            self.tcx.lifetimes.re_static\n-        } else {\n-            self.temporary_scope(hir_id.local_id)\n-        };\n-        let ret = self.cat_rvalue(hir_id, span, re, expr_ty);\n+        let ret = self.cat_rvalue(hir_id, span, expr_ty);\n         debug!(\"cat_rvalue_node ret {:?}\", ret);\n         ret\n     }\n \n     pub fn cat_rvalue(&self,\n                       cmt_hir_id: hir::HirId,\n                       span: Span,\n-                      temp_scope: ty::Region<'tcx>,\n                       expr_ty: Ty<'tcx>) -> cmt_<'tcx> {\n         let ret = cmt_ {\n             hir_id: cmt_hir_id,\n             span:span,\n-            cat:Categorization::Rvalue(temp_scope),\n+            cat:Categorization::Rvalue,\n             mutbl:McDeclared,\n             ty:expr_ty,\n             note: NoteNone\n@@ -1376,9 +1334,9 @@ impl<'tcx> cmt_<'tcx> {\n         //! determines how long the value in `self` remains live.\n \n         match self.cat {\n-            Categorization::Rvalue(..) |\n+            Categorization::Rvalue |\n             Categorization::StaticItem |\n-            Categorization::ThreadLocal(..) |\n+            Categorization::ThreadLocal |\n             Categorization::Local(..) |\n             Categorization::Deref(_, UnsafePtr(..)) |\n             Categorization::Deref(_, BorrowedPtr(..)) |\n@@ -1409,8 +1367,8 @@ impl<'tcx> cmt_<'tcx> {\n                 b.freely_aliasable()\n             }\n \n-            Categorization::Rvalue(..) |\n-            Categorization::ThreadLocal(..) |\n+            Categorization::Rvalue |\n+            Categorization::ThreadLocal |\n             Categorization::Local(..) |\n             Categorization::Upvar(..) |\n             Categorization::Deref(_, UnsafePtr(..)) => { // yes, it's aliasable, but...\n@@ -1457,10 +1415,10 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::StaticItem => {\n                 \"static item\".into()\n             }\n-            Categorization::ThreadLocal(..) => {\n+            Categorization::ThreadLocal => {\n                 \"thread-local static item\".into()\n             }\n-            Categorization::Rvalue(..) => {\n+            Categorization::Rvalue => {\n                 \"non-place\".into()\n             }\n             Categorization::Local(vid) => {"}, {"sha": "59b4f24073398bfd2ae2f221793137b98aae414c", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -15,7 +15,7 @@ use crate::ty::layout::VariantIdx;\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::{\n-    self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n+    self, AdtDef, CanonicalUserTypeAnnotations, GeneratorSubsts, Region, Ty, TyCtxt,\n     UserTypeAnnotationIndex,\n };\n \n@@ -2188,7 +2188,7 @@ pub enum AggregateKind<'tcx> {\n     /// active field index would identity the field `c`\n     Adt(&'tcx AdtDef, VariantIdx, SubstsRef<'tcx>, Option<UserTypeAnnotationIndex>, Option<usize>),\n \n-    Closure(DefId, ClosureSubsts<'tcx>),\n+    Closure(DefId, SubstsRef<'tcx>),\n     Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n }\n "}, {"sha": "ed8086b8fafec5c200d9de0388681102237f9ce0", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1,5 +1,5 @@\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{CanonicalUserTypeAnnotation, ClosureSubsts, GeneratorSubsts, Ty};\n+use crate::ty::{CanonicalUserTypeAnnotation, GeneratorSubsts, Ty};\n use crate::mir::*;\n use syntax_pos::Span;\n \n@@ -230,12 +230,6 @@ macro_rules! make_mir_visitor {\n                 self.super_substs(substs);\n             }\n \n-            fn visit_closure_substs(&mut self,\n-                                    substs: & $($mutability)? ClosureSubsts<'tcx>,\n-                                    _: Location) {\n-                self.super_closure_substs(substs);\n-            }\n-\n             fn visit_generator_substs(&mut self,\n                                       substs: & $($mutability)? GeneratorSubsts<'tcx>,\n                                     _: Location) {\n@@ -627,7 +621,7 @@ macro_rules! make_mir_visitor {\n                                 _,\n                                 closure_substs\n                             ) => {\n-                                self.visit_closure_substs(closure_substs, location);\n+                                self.visit_substs(closure_substs, location);\n                             }\n                             AggregateKind::Generator(\n                                 _,\n@@ -856,10 +850,6 @@ macro_rules! make_mir_visitor {\n                                       _substs: & $($mutability)? GeneratorSubsts<'tcx>) {\n             }\n \n-            fn super_closure_substs(&mut self,\n-                                    _substs: & $($mutability)? ClosureSubsts<'tcx>) {\n-            }\n-\n             // Convenience methods\n \n             fn visit_location(&mut self, body: & $($mutability)? Body<'tcx>, location: Location) {"}, {"sha": "c95652f274e36540a24fd5f2f24fe04957588363", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -94,6 +94,7 @@ rustc_queries! {\n         /// of the MIR qualify_consts pass. The actual meaning of\n         /// the value isn't known except to the pass itself.\n         query mir_const_qualif(key: DefId) -> (u8, &'tcx BitSet<mir::Local>) {\n+            desc { |tcx| \"const checking `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }\n \n@@ -530,19 +531,6 @@ rustc_queries! {\n \n     TypeChecking {\n         query trait_of_item(_: DefId) -> Option<DefId> {}\n-        query const_is_rvalue_promotable_to_static(key: DefId) -> bool {\n-            desc { |tcx|\n-                \"const checking if rvalue is promotable to static `{}`\",\n-                tcx.def_path_str(key)\n-            }\n-            cache_on_disk_if { true }\n-        }\n-        query rvalue_promotable_map(key: DefId) -> &'tcx ItemLocalSet {\n-            desc { |tcx|\n-                \"checking which parts of `{}` are promotable to static\",\n-                tcx.def_path_str(key)\n-            }\n-        }\n     }\n \n     Codegen {"}, {"sha": "7f194c2fbbc0f1b6099d3d68aa1dd1108d73b44c", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -619,7 +619,7 @@ pub struct VtableGeneratorData<'tcx, N> {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableClosureData<'tcx, N> {\n     pub closure_def_id: DefId,\n-    pub substs: ty::ClosureSubsts<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n     /// Nested obligations. This can be non-empty if the closure\n     /// signature contains associated types.\n     pub nested: Vec<N>"}, {"sha": "a7bb29c699e0e59c7a50589806ef2577adba53b9", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1334,7 +1334,8 @@ fn confirm_closure_candidate<'cx, 'tcx>(\n ) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n     let infcx = selcx.infcx();\n-    let closure_sig_ty = vtable.substs.closure_sig_ty(vtable.closure_def_id, tcx);\n+    let closure_sig_ty = vtable.substs\n+        .as_closure().sig_ty(vtable.closure_def_id, tcx);\n     let closure_sig = infcx.shallow_resolve(closure_sig_ty).fn_sig(tcx);\n     let Normalized {\n         value: closure_sig,"}, {"sha": "eaf5971e4592f32044765236d47701f36a4e49a6", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -213,6 +213,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         // check if *any* of those are trivial.\n         ty::Tuple(ref tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t.expect_ty())),\n         ty::Closure(def_id, ref substs) => substs\n+            .as_closure()\n             .upvar_tys(def_id, tcx)\n             .all(|t| trivial_dropck_outlives(tcx, t)),\n "}, {"sha": "1fae2a2fe8dbffc783595f05aacbf58e5f2541a7", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -2051,7 +2051,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     \"assemble_unboxed_candidates: kind={:?} obligation={:?}\",\n                     kind, obligation\n                 );\n-                match self.infcx.closure_kind(closure_def_id, closure_substs) {\n+                match self.infcx.closure_kind(\n+                    closure_def_id,\n+                    closure_substs\n+                ) {\n                     Some(closure_kind) => {\n                         debug!(\n                             \"assemble_unboxed_candidates: closure_kind = {:?}\",\n@@ -2669,7 +2672,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::Closure(def_id, substs) => {\n                 // (*) binder moved here\n                 Where(ty::Binder::bind(\n-                    substs.upvar_tys(def_id, self.tcx()).collect(),\n+                    substs.as_closure().upvar_tys(def_id, self.tcx()).collect(),\n                 ))\n             }\n \n@@ -2753,7 +2756,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 tys.iter().map(|k| k.expect_ty()).collect()\n             }\n \n-            ty::Closure(def_id, ref substs) => substs.upvar_tys(def_id, self.tcx()).collect(),\n+            ty::Closure(def_id, ref substs) => substs.as_closure()\n+                .upvar_tys(def_id, self.tcx())\n+                .collect(),\n \n             ty::Generator(def_id, ref substs, _) => {\n                 let witness = substs.witness(def_id, self.tcx());\n@@ -3370,17 +3375,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         )?);\n \n         // FIXME: chalk\n+\n         if !self.tcx().sess.opts.debugging_opts.chalk {\n             obligations.push(Obligation::new(\n                 obligation.cause.clone(),\n                 obligation.param_env,\n-                ty::Predicate::ClosureKind(closure_def_id, substs, kind),\n+                ty::Predicate::ClosureKind(\n+                    closure_def_id,\n+                    substs,\n+                    kind\n+                ),\n             ));\n         }\n \n         Ok(VtableClosureData {\n             closure_def_id,\n-            substs: substs.clone(),\n+            substs: substs,\n             nested: obligations,\n         })\n     }\n@@ -3869,7 +3879,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         closure_def_id: DefId,\n-        substs: ty::ClosureSubsts<'tcx>,\n+        substs: SubstsRef<'tcx>,\n     ) -> ty::PolyTraitRef<'tcx> {\n         debug!(\n             \"closure_trait_ref_unnormalized(obligation={:?}, closure_def_id={:?}, substs={:?})\","}, {"sha": "5aad6c1dc18322825a760050565cb4701c5e0355", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -29,7 +29,7 @@ use crate::traits;\n use crate::traits::{Clause, Clauses, GoalKind, Goal, Goals};\n use crate::ty::{self, DefIdTree, Ty, TypeAndMut};\n use crate::ty::{TyS, TyKind, List};\n-use crate::ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorSubsts, Region, Const};\n+use crate::ty::{AdtKind, AdtDef, GeneratorSubsts, Region, Const};\n use crate::ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use crate::ty::RegionKind;\n use crate::ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid, ConstVid};\n@@ -2502,7 +2502,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n \n     #[inline]\n-    pub fn mk_closure(self, closure_id: DefId, closure_substs: ClosureSubsts<'tcx>)\n+    pub fn mk_closure(self, closure_id: DefId, closure_substs: SubstsRef<'tcx>)\n                       -> Ty<'tcx> {\n         self.mk_ty(Closure(closure_id, closure_substs))\n     }"}, {"sha": "b513ef5a96670213afccf3b7a18f388526b0da18", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -106,7 +106,7 @@ impl FlagComputation {\n             &ty::Closure(_, ref substs) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n-                self.add_substs(&substs.substs);\n+                self.add_substs(substs);\n             }\n \n             &ty::Bound(debruijn, _) => {"}, {"sha": "34f806b15c0c6c32defa00f6855279fbab99eb36", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> Instance<'tcx> {\n             // Shims currently have type FnPtr. Not sure this should remain.\n             ty::FnPtr(_) => ty.fn_sig(tcx),\n             ty::Closure(def_id, substs) => {\n-                let sig = substs.closure_sig(def_id, tcx);\n+                let sig = substs.as_closure().sig(def_id, tcx);\n \n                 let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n                 sig.map_bound(|sig| tcx.mk_fn_sig(\n@@ -315,14 +315,14 @@ impl<'tcx> Instance<'tcx> {\n     pub fn resolve_closure(\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n-        substs: ty::ClosureSubsts<'tcx>,\n+        substs: ty::SubstsRef<'tcx>,\n         requested_kind: ty::ClosureKind,\n     ) -> Instance<'tcx> {\n-        let actual_kind = substs.closure_kind(def_id, tcx);\n+        let actual_kind = substs.as_closure().kind(def_id, tcx);\n \n         match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n             Ok(true) => Instance::fn_once_adapter_instance(tcx, def_id, substs),\n-            _ => Instance::new(def_id, substs.substs)\n+            _ => Instance::new(def_id, substs)\n         }\n     }\n \n@@ -335,7 +335,7 @@ impl<'tcx> Instance<'tcx> {\n     pub fn fn_once_adapter_instance(\n         tcx: TyCtxt<'tcx>,\n         closure_did: DefId,\n-        substs: ty::ClosureSubsts<'tcx>,\n+        substs: ty::SubstsRef<'tcx>,\n     ) -> Instance<'tcx> {\n         debug!(\"fn_once_adapter_shim({:?}, {:?})\",\n                closure_did,\n@@ -348,7 +348,7 @@ impl<'tcx> Instance<'tcx> {\n \n         let self_ty = tcx.mk_closure(closure_did, substs);\n \n-        let sig = substs.closure_sig(closure_did, tcx);\n+        let sig = substs.as_closure().sig(closure_did, tcx);\n         let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n         assert_eq!(sig.inputs().len(), 1);\n         let substs = tcx.mk_substs_trait(self_ty, &[sig.inputs()[0].into()]);"}, {"sha": "6e01e1bf26a53cd2363c61a91464b36888fce6d6", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -674,7 +674,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             ty::Generator(def_id, substs, _) => self.generator_layout(ty, def_id, &substs)?,\n \n             ty::Closure(def_id, ref substs) => {\n-                let tys = substs.upvar_tys(def_id, tcx);\n+                let tys = substs.as_closure().upvar_tys(def_id, tcx);\n                 univariant(&tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n                     StructKind::AlwaysSized)?\n@@ -2147,7 +2147,7 @@ where\n \n             // Tuples, generators and closures.\n             ty::Closure(def_id, ref substs) => {\n-                substs.upvar_tys(def_id, tcx).nth(i).unwrap()\n+                substs.as_closure().upvar_tys(def_id, tcx).nth(i).unwrap()\n             }\n \n             ty::Generator(def_id, ref substs, _) => {"}, {"sha": "cfd859c33c2ef179c6242b0da1ed6d6e8cabf418", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1111,7 +1111,7 @@ pub enum Predicate<'tcx> {\n     /// No direct syntax. May be thought of as `where T: FnFoo<...>`\n     /// for some substitutions `...` and `T` being a closure type.\n     /// Satisfied (or refuted) once we know the closure's kind.\n-    ClosureKind(DefId, ClosureSubsts<'tcx>, ClosureKind),\n+    ClosureKind(DefId, SubstsRef<'tcx>, ClosureKind),\n \n     /// `T1 <: T2`\n     Subtype(PolySubtypePredicate<'tcx>),\n@@ -1458,7 +1458,7 @@ impl<'tcx> Predicate<'tcx> {\n                 WalkTysIter::None\n             }\n             ty::Predicate::ClosureKind(_closure_def_id, closure_substs, _kind) => {\n-                WalkTysIter::Types(closure_substs.substs.types())\n+                WalkTysIter::Types(closure_substs.types())\n             }\n             ty::Predicate::ConstEvaluatable(_, substs) => {\n                 WalkTysIter::Types(substs.types())"}, {"sha": "3ea767d5115984e067baf243e82c2d2bb95abb25", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // projection).\n         match ty.kind {\n             ty::Closure(def_id, ref substs) => {\n-                for upvar_ty in substs.upvar_tys(def_id, *self) {\n+                for upvar_ty in substs.as_closure().upvar_tys(def_id, *self) {\n                     self.compute_components(upvar_ty, out);\n                 }\n             }"}, {"sha": "21c018d9ee6de5a3e2719f52ceacd8221be5beda", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -8,7 +8,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::ConstValue;\n use rustc::ty::subst::SubstsRef;\n-use rustc::ty::{self, ClosureSubsts, Const, GeneratorSubsts, Instance, Ty, TyCtxt};\n+use rustc::ty::{self, Const, GeneratorSubsts, Instance, Ty, TyCtxt};\n use rustc::{bug, hir};\n use std::fmt::Write;\n use std::iter;\n@@ -154,8 +154,8 @@ impl DefPathBasedNames<'tcx> {\n                     self.push_type_name(sig.output(), output, debug);\n                 }\n             }\n-            ty::Generator(def_id, GeneratorSubsts { ref substs }, _)\n-            | ty::Closure(def_id, ClosureSubsts { ref substs }) => {\n+            ty::Generator(def_id, GeneratorSubsts { substs }, _)\n+            | ty::Closure(def_id, substs) => {\n                 self.push_def_path(def_id, output);\n                 let generics = self.tcx.generics_of(self.tcx.closure_base_def_id(def_id));\n                 let substs = substs.truncate_to(self.tcx, generics);"}, {"sha": "ad4be788dae4e49cdde02124c17b5381d8b9c7a0", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -649,7 +649,7 @@ pub trait PrettyPrinter<'tcx>:\n                 p!(in_binder(&types));\n             }\n             ty::Closure(did, substs) => {\n-                let upvar_tys = substs.upvar_tys(did, self.tcx());\n+                let upvar_tys = substs.as_closure().upvar_tys(did, self.tcx());\n                 p!(write(\"[closure\"));\n \n                 // FIXME(eddyb) should use `def_span`.\n@@ -689,8 +689,8 @@ pub trait PrettyPrinter<'tcx>:\n                 if self.tcx().sess.verbose() {\n                     p!(write(\n                         \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n-                        substs.closure_kind_ty(did, self.tcx()),\n-                        substs.closure_sig_ty(did, self.tcx())\n+                        substs.as_closure().kind(did, self.tcx()),\n+                        substs.as_closure().sig_ty(did, self.tcx())\n                     ));\n                 }\n "}, {"sha": "4279ca8c3daf65f5210be3d9f4cdf770c305b23d", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -37,7 +37,7 @@ use crate::ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt, AdtSizedConst\n use crate::ty::steal::Steal;\n use crate::ty::util::NeedsDrop;\n use crate::ty::subst::SubstsRef;\n-use crate::util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n+use crate::util::nodemap::{DefIdSet, DefIdMap};\n use crate::util::common::ErrorReported;\n use crate::util::profiling::ProfileCategory::*;\n "}, {"sha": "5489c6f5d5afba67540fe5e12aaad357c952cb7c", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -442,7 +442,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n             let substs = relation.relate(&a_substs, &b_substs)?;\n-            Ok(tcx.mk_closure(a_id, substs))\n+            Ok(tcx.mk_closure(a_id, &substs))\n         }\n \n         (&ty::RawPtr(ref a_mt), &ty::RawPtr(ref b_mt)) =>"}, {"sha": "3f09bf749edc8a6eb71b74c05c07b9bf488375c1", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -159,7 +159,7 @@ pub enum TyKind<'tcx> {\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n-    Closure(DefId, ClosureSubsts<'tcx>),\n+    Closure(DefId, SubstsRef<'tcx>),\n \n     /// The anonymous type of a generator. Used to represent the type of\n     /// `|a| yield a`.\n@@ -305,8 +305,8 @@ static_assert_size!(TyKind<'_>, 24);\n /// type parameters is similar, but the role of CK and CS are\n /// different. CK represents the \"yield type\" and CS represents the\n /// \"return type\" of the generator.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n-         Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function,\n     /// concatenated with the types of the upvars.\n@@ -357,15 +357,15 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// Returns the closure kind for this closure; may return a type\n     /// variable during inference. To get the closure kind during\n     /// inference, use `infcx.closure_kind(def_id, substs)`.\n-    pub fn closure_kind_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n+    pub fn kind_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n         self.split(def_id, tcx).closure_kind_ty\n     }\n \n     /// Returns the type representing the closure signature for this\n     /// closure; may contain type variables during inference. To get\n     /// the closure signature during inference, use\n     /// `infcx.fn_sig(def_id)`.\n-    pub fn closure_sig_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n+    pub fn sig_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n         self.split(def_id, tcx).closure_sig_ty\n     }\n \n@@ -374,7 +374,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// there are no type variables.\n     ///\n     /// If you have an inference context, use `infcx.closure_kind()`.\n-    pub fn closure_kind(self, def_id: DefId, tcx: TyCtxt<'tcx>) -> ty::ClosureKind {\n+    pub fn kind(self, def_id: DefId, tcx: TyCtxt<'tcx>) -> ty::ClosureKind {\n         self.split(def_id, tcx).closure_kind_ty.to_opt_closure_kind().unwrap()\n     }\n \n@@ -383,8 +383,8 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// there are no type variables.\n     ///\n     /// If you have an inference context, use `infcx.closure_sig()`.\n-    pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        let ty = self.closure_sig_ty(def_id, tcx);\n+    pub fn sig(&self, def_id: DefId, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n+        let ty = self.sig_ty(def_id, tcx);\n         match ty.kind {\n             ty::FnPtr(sig) => sig,\n             _ => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", ty.kind),\n@@ -569,7 +569,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n \n #[derive(Debug, Copy, Clone)]\n pub enum UpvarSubsts<'tcx> {\n-    Closure(ClosureSubsts<'tcx>),\n+    Closure(SubstsRef<'tcx>),\n     Generator(GeneratorSubsts<'tcx>),\n }\n \n@@ -578,10 +578,10 @@ impl<'tcx> UpvarSubsts<'tcx> {\n     pub fn upvar_tys(\n         self,\n         def_id: DefId,\n-        tcx: TyCtxt<'_>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         let upvar_kinds = match self {\n-            UpvarSubsts::Closure(substs) => substs.split(def_id, tcx).upvar_kinds,\n+            UpvarSubsts::Closure(substs) => substs.as_closure().split(def_id, tcx).upvar_kinds,\n             UpvarSubsts::Generator(substs) => substs.split(def_id, tcx).upvar_kinds,\n         };\n         upvar_kinds.iter().map(|t| {\n@@ -2148,7 +2148,7 @@ impl<'tcx> TyS<'tcx> {\n             Adt(_, substs) | Opaque(_, substs) => {\n                 out.extend(substs.regions())\n             }\n-            Closure(_, ClosureSubsts { ref substs }) |\n+            Closure(_, ref substs ) |\n             Generator(_, GeneratorSubsts { ref substs }, _) => {\n                 out.extend(substs.regions())\n             }"}, {"sha": "537192b0a2e58dccf61c50aaa0a09a033b97ac46", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -5,6 +5,7 @@ use crate::infer::canonical::Canonical;\n use crate::ty::{self, Lift, List, Ty, TyCtxt, InferConst, ParamConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::mir::interpret::ConstValue;\n+use crate::ty::sty::ClosureSubsts;\n \n use rustc_serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -183,6 +184,16 @@ pub type InternalSubsts<'tcx> = List<GenericArg<'tcx>>;\n pub type SubstsRef<'tcx> = &'tcx InternalSubsts<'tcx>;\n \n impl<'a, 'tcx> InternalSubsts<'tcx> {\n+    /// Interpret these substitutions as the substitutions of a closure type.\n+    /// Closure substitutions have a particular structure controlled by the\n+    /// compiler that encodes information like the signature and closure kind;\n+    /// see `ty::ClosureSubsts` struct for more comments.\n+    pub fn as_closure(&'a self) -> ClosureSubsts<'a> {\n+        ClosureSubsts {\n+            substs: self,\n+        }\n+    }\n+\n     /// Creates a `InternalSubsts` that maps each generic parameter to itself.\n     pub fn identity_for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n         Self::for_item(tcx, def_id, |param, _| {"}, {"sha": "d0e95a18c59fcb046656a17cbe36d376b25530a0", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -642,12 +642,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// wrapped in a binder.\n     pub fn closure_env_ty(self,\n                           closure_def_id: DefId,\n-                          closure_substs: ty::ClosureSubsts<'tcx>)\n+                          closure_substs: SubstsRef<'tcx>)\n                           -> Option<ty::Binder<Ty<'tcx>>>\n     {\n         let closure_ty = self.mk_closure(closure_def_id, closure_substs);\n         let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n-        let closure_kind_ty = closure_substs.closure_kind_ty(closure_def_id, self);\n+        let closure_kind_ty = closure_substs.as_closure().kind_ty(closure_def_id, self);\n         let closure_kind = closure_kind_ty.to_opt_closure_kind()?;\n         let env_ty = match closure_kind {\n             ty::ClosureKind::Fn => self.mk_imm_ref(self.mk_region(env_region), closure_ty),\n@@ -1108,7 +1108,9 @@ fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>\n         // Structural recursion.\n         ty::Array(ty, _) | ty::Slice(ty) => needs_drop(ty),\n \n-        ty::Closure(def_id, ref substs) => substs.upvar_tys(def_id, tcx).any(needs_drop),\n+        ty::Closure(def_id, ref substs) => {\n+            substs.as_closure().upvar_tys(def_id, tcx).any(needs_drop)\n+        }\n \n         // Pessimistically assume that all generators will require destructors\n         // as we don't know if a destructor is a noop or not until after the MIR"}, {"sha": "1895ab83674eb634384c0c53734db9fb1bfaa385", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -111,7 +111,7 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n             stack.extend(substs.types().rev());\n         }\n         ty::Closure(_, ref substs) => {\n-            stack.extend(substs.substs.types().rev());\n+            stack.extend(substs.types().rev());\n         }\n         ty::Generator(_, ref substs, _) => {\n             stack.extend(substs.substs.types().rev());"}, {"sha": "ecb075e30b14d11508499b0196fd5b43764071fe", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -347,7 +347,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // anyway, except via auto trait matching (which\n                     // only inspects the upvar types).\n                     subtys.skip_current_subtree(); // subtree handled by compute_projection\n-                    for upvar_ty in substs.upvar_tys(def_id, self.infcx.tcx) {\n+                    for upvar_ty in substs.as_closure().upvar_tys(def_id, self.infcx.tcx) {\n                         self.compute(upvar_ty);\n                     }\n                 }"}, {"sha": "e69f4b6aca19a9e9d45b596e44966fe5dc25858b", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -6,7 +6,7 @@ use super::utils::{debug_context, DIB, span_start,\n                    get_namespace_for_item, create_DIArray, is_node_local_to_unit};\n use super::namespace::mangled_name_of_instance;\n use super::type_names::compute_debuginfo_type_name;\n-use super::{CrateDebugContext};\n+use super::CrateDebugContext;\n use crate::abi;\n use crate::value::Value;\n use rustc_codegen_ssa::traits::*;\n@@ -682,7 +682,7 @@ pub fn type_metadata(\n \n         }\n         ty::Closure(def_id, substs) => {\n-            let upvar_tys : Vec<_> = substs.upvar_tys(def_id, cx.tcx).collect();\n+            let upvar_tys : Vec<_> = substs.as_closure().upvar_tys(def_id, cx.tcx).collect();\n             let containing_scope = get_namespace_for_item(cx, def_id);\n             prepare_tuple_metadata(cx,\n                                    t,"}, {"sha": "5787447d6230fc2aa100f72ff363a9afb7d05577", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -615,7 +615,8 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             };\n \n             let (def_id, upvar_substs) = match closure_layout.ty.kind {\n-                ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n+                ty::Closure(def_id, substs) => (def_id,\n+                    UpvarSubsts::Closure(substs)),\n                 ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n                 _ => bug!(\"upvar debuginfo with non-closure arg0 type `{}`\", closure_layout.ty)\n             };"}, {"sha": "6ffa561f3fecf456627d8b29474e15cd26c45d33", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -201,7 +201,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         match operand.layout.ty.kind {\n                             ty::Closure(def_id, substs) => {\n                                 let instance = Instance::resolve_closure(\n-                                    bx.cx().tcx(), def_id, substs, ty::ClosureKind::FnOnce);\n+                                    bx.cx().tcx(),\n+                                    def_id,\n+                                    substs,\n+                                    ty::ClosureKind::FnOnce);\n                                 OperandValue::Immediate(bx.cx().get_fn(instance))\n                             }\n                             _ => {"}, {"sha": "5bcb3b4ceb3ba33f06d3bc0331e52fad0fe4e3a8", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -224,7 +224,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n             ty::Opaque(def_id, substs) |\n             ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n             ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n-            ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n+            ty::Closure(def_id, substs) |\n             ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n                 self.print_def_path(def_id, substs)\n             }"}, {"sha": "2ad699d7c6f08808ab46a3f060940556ca5e1d95", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -414,7 +414,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             ty::Opaque(def_id, substs) |\n             ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n             ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n-            ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n+            ty::Closure(def_id, substs) |\n             ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n                 self = self.print_def_path(def_id, substs)?;\n             }"}, {"sha": "bf5e86017fc7b6e7d311fef436b12a7b04466c9a", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -917,9 +917,8 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n \n     time(sess, \"misc checking 2\", || {\n         parallel!({\n-            time(sess, \"rvalue promotion + match checking\", || {\n+            time(sess, \"match checking\", || {\n                 tcx.par_body_owners(|def_id| {\n-                    tcx.ensure().const_is_rvalue_promotable_to_static(def_id);\n                     tcx.ensure().check_match(def_id);\n                 });\n             });"}, {"sha": "042252bc13e615c9a052a6328e6567f6b4445e1b", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 62, "deletions": 87, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -2,7 +2,7 @@\n \n use crate::cstore::{self, CStore, CrateSource, MetadataBlob};\n use crate::locator::{self, CratePaths};\n-use crate::schema::{CrateRoot};\n+use crate::schema::{CrateRoot, CrateDep};\n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n \n use rustc::hir::def_id::CrateNum;\n@@ -20,7 +20,7 @@ use rustc::hir::map::Definitions;\n use rustc::hir::def_id::LOCAL_CRATE;\n \n use std::ops::Deref;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::{cmp, fs};\n \n use syntax::ast;\n@@ -112,7 +112,7 @@ impl<'a> CrateLoader<'a> {\n                       -> Option<CrateNum> {\n         let mut ret = None;\n         self.cstore.iter_crate_data(|cnum, data| {\n-            if data.name != name { return }\n+            if data.root.name != name { return }\n \n             match hash {\n                 Some(hash) if *hash == data.root.hash => { ret = Some(cnum); return }\n@@ -190,8 +190,7 @@ impl<'a> CrateLoader<'a> {\n     fn register_crate(\n         &mut self,\n         host_lib: Option<Library>,\n-        root: &Option<CratePaths>,\n-        ident: Symbol,\n+        root: Option<&CratePaths>,\n         span: Span,\n         lib: Library,\n         dep_kind: DepKind,\n@@ -204,40 +203,40 @@ impl<'a> CrateLoader<'a> {\n             .map(|e| e.is_private_dep)\n             .unwrap_or(false);\n \n-        info!(\"register crate `extern crate {} as {}` (private_dep = {})\",\n-            crate_root.name, ident, private_dep);\n-\n+        info!(\"register crate `{}` (private_dep = {})\", crate_root.name, private_dep);\n \n         // Claim this crate number and cache it\n         let cnum = self.cstore.alloc_new_crate_num();\n \n+        // Maintain a reference to the top most crate.\n         // Stash paths for top-most crate locally if necessary.\n-        let crate_paths = if root.is_none() {\n-            Some(CratePaths {\n-                ident: ident.to_string(),\n+        let crate_paths;\n+        let root = if let Some(root) = root {\n+            root\n+        } else {\n+            crate_paths = CratePaths {\n+                ident: crate_root.name.to_string(),\n                 dylib: lib.dylib.clone().map(|p| p.0),\n                 rlib:  lib.rlib.clone().map(|p| p.0),\n                 rmeta: lib.rmeta.clone().map(|p| p.0),\n-            })\n-        } else {\n-            None\n+            };\n+            &crate_paths\n         };\n-        // Maintain a reference to the top most crate.\n-        let root = if root.is_some() { root } else { &crate_paths };\n \n         let Library { dylib, rlib, rmeta, metadata } = lib;\n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n \n         let raw_proc_macros =  crate_root.proc_macro_data.map(|_| {\n-            if self.sess.opts.debugging_opts.dual_proc_macros {\n-                let host_lib = host_lib.as_ref().unwrap();\n-                self.dlsym_proc_macros(host_lib.dylib.as_ref().map(|p| p.0.clone()),\n-                                       &host_lib.metadata.get_root(), span)\n-            } else {\n-                self.dlsym_proc_macros(dylib.clone().map(|p| p.0), &crate_root, span)\n-            }\n+            let temp_root;\n+            let (dlsym_dylib, dlsym_root) = match &host_lib {\n+                Some(host_lib) =>\n+                    (&host_lib.dylib, { temp_root = host_lib.metadata.get_root(); &temp_root }),\n+                None => (&dylib, &crate_root),\n+            };\n+            let dlsym_dylib = dlsym_dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n+            self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator, span)\n         });\n \n         let interpret_alloc_index: Vec<u32> = crate_root.interpret_alloc_index\n@@ -254,8 +253,6 @@ impl<'a> CrateLoader<'a> {\n         });\n \n         let cmeta = cstore::CrateMetadata {\n-            name: crate_root.name,\n-            imported_name: ident,\n             extern_crate: Lock::new(None),\n             def_path_table: Lrc::new(def_path_table),\n             trait_impls,\n@@ -274,7 +271,6 @@ impl<'a> CrateLoader<'a> {\n             },\n             private_dep,\n             span,\n-            host_lib,\n             raw_proc_macros\n         };\n \n@@ -340,24 +336,34 @@ impl<'a> CrateLoader<'a> {\n \n     fn resolve_crate<'b>(\n         &'b mut self,\n-        root: &'b Option<CratePaths>,\n-        ident: Symbol,\n         name: Symbol,\n-        hash: Option<&'b Svh>,\n-        extra_filename: Option<&'b str>,\n         span: Span,\n-        path_kind: PathKind,\n+        dep_kind: DepKind,\n+        dep: Option<(&'b CratePaths, &'b CrateDep)>,\n+    ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n+        self.maybe_resolve_crate(name, span, dep_kind, dep).unwrap_or_else(|err| err.report())\n+    }\n+\n+    fn maybe_resolve_crate<'b>(\n+        &'b mut self,\n+        name: Symbol,\n+        span: Span,\n         mut dep_kind: DepKind,\n+        dep: Option<(&'b CratePaths, &'b CrateDep)>,\n     ) -> Result<(CrateNum, Lrc<cstore::CrateMetadata>), LoadError<'b>> {\n-        info!(\"resolving crate `extern crate {} as {}`\", name, ident);\n+        info!(\"resolving crate `{}`\", name);\n+        let (root, hash, extra_filename, path_kind) = match dep {\n+            Some((root, dep)) =>\n+                (Some(root), Some(&dep.hash), Some(&dep.extra_filename[..]), PathKind::Dependency),\n+            None => (None, None, None, PathKind::Crate),\n+        };\n         let result = if let Some(cnum) = self.existing_match(name, hash, path_kind) {\n             (LoadResult::Previous(cnum), None)\n         } else {\n             info!(\"falling back to a load\");\n             let mut locate_ctxt = locator::Context {\n                 sess: self.sess,\n                 span,\n-                ident,\n                 crate_name: name,\n                 hash,\n                 extra_filename,\n@@ -393,7 +399,7 @@ impl<'a> CrateLoader<'a> {\n                 Ok((cnum, data))\n             }\n             (LoadResult::Loaded(library), host_library) => {\n-                Ok(self.register_crate(host_library, root, ident, span, library, dep_kind, name))\n+                Ok(self.register_crate(host_library, root, span, library, dep_kind, name))\n             }\n             _ => panic!()\n         }\n@@ -469,7 +475,7 @@ impl<'a> CrateLoader<'a> {\n \n     // Go through the crate metadata and load any crates that it references\n     fn resolve_crate_deps(&mut self,\n-                          root: &Option<CratePaths>,\n+                          root: &CratePaths,\n                           crate_root: &CrateRoot<'_>,\n                           metadata: &MetadataBlob,\n                           krate: CrateNum,\n@@ -484,9 +490,7 @@ impl<'a> CrateLoader<'a> {\n         // The map from crate numbers in the crate we're resolving to local crate numbers.\n         // We map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n-        std::iter::once(krate).chain(crate_root.crate_deps\n-                                                 .decode(metadata)\n-                                                 .map(|dep| {\n+        std::iter::once(krate).chain(crate_root.crate_deps.decode(metadata).map(|dep| {\n             info!(\"resolving dep crate {} hash: `{}` extra filename: `{}`\", dep.name, dep.hash,\n                   dep.extra_filename);\n             if dep.kind == DepKind::UnexportedMacrosOnly {\n@@ -496,32 +500,26 @@ impl<'a> CrateLoader<'a> {\n                 DepKind::MacrosOnly => DepKind::MacrosOnly,\n                 _ => dep.kind,\n             };\n-            let (local_cnum, ..) = self.resolve_crate(\n-                root, dep.name, dep.name, Some(&dep.hash), Some(&dep.extra_filename), span,\n-                PathKind::Dependency, dep_kind,\n-            ).unwrap_or_else(|err| err.report());\n-            local_cnum\n+            self.resolve_crate(dep.name, span, dep_kind, Some((root, &dep))).0\n         })).collect()\n     }\n \n-    fn read_extension_crate(&mut self, span: Span, orig_name: Symbol, rename: Symbol)\n-                            -> ExtensionCrate {\n-        info!(\"read extension crate `extern crate {} as {}`\", orig_name, rename);\n+    fn read_extension_crate(&mut self, name: Symbol, span: Span) -> ExtensionCrate {\n+        info!(\"read extension crate `{}`\", name);\n         let target_triple = self.sess.opts.target_triple.clone();\n         let host_triple = TargetTriple::from_triple(config::host_triple());\n         let is_cross = target_triple != host_triple;\n         let mut target_only = false;\n         let mut locate_ctxt = locator::Context {\n             sess: self.sess,\n             span,\n-            ident: orig_name,\n-            crate_name: rename,\n+            crate_name: name,\n             hash: None,\n             extra_filename: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             target: &self.sess.host,\n             triple: host_triple,\n-            root: &None,\n+            root: None,\n             rejected_via_hash: vec![],\n             rejected_via_triple: vec![],\n             rejected_via_kind: vec![],\n@@ -570,25 +568,21 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn dlsym_proc_macros(&self,\n-                         dylib: Option<PathBuf>,\n-                         root: &CrateRoot<'_>,\n+                         path: &Path,\n+                         disambiguator: CrateDisambiguator,\n                          span: Span\n     ) -> &'static [ProcMacro] {\n         use std::env;\n         use crate::dynamic_lib::DynamicLibrary;\n \n-        let path = match dylib {\n-            Some(dylib) => dylib,\n-            None => span_bug!(span, \"proc-macro crate not dylib\"),\n-        };\n         // Make sure the path contains a / or the linker will search for it.\n         let path = env::current_dir().unwrap().join(path);\n         let lib = match DynamicLibrary::open(Some(&path)) {\n             Ok(lib) => lib,\n             Err(err) => self.sess.span_fatal(span, &err),\n         };\n \n-        let sym = self.sess.generate_proc_macro_decls_symbol(root.disambiguator);\n+        let sym = self.sess.generate_proc_macro_decls_symbol(disambiguator);\n         let decls = unsafe {\n             let sym = match lib.symbol(&sym) {\n                 Ok(f) => f,\n@@ -610,7 +604,7 @@ impl<'a> CrateLoader<'a> {\n                                  span: Span,\n                                  name: Symbol)\n                                  -> Option<(PathBuf, CrateDisambiguator)> {\n-        let ekrate = self.read_extension_crate(span, name, name);\n+        let ekrate = self.read_extension_crate(name, span);\n \n         if ekrate.target_only {\n             // Need to abort before syntax expansion.\n@@ -701,10 +695,7 @@ impl<'a> CrateLoader<'a> {\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n-        let dep_kind = DepKind::Implicit;\n-        let (cnum, data) =\n-            self.resolve_crate(&None, name, name, None, None, DUMMY_SP, PathKind::Crate, dep_kind)\n-                .unwrap_or_else(|err| err.report());\n+        let (cnum, data) = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n@@ -794,26 +785,21 @@ impl<'a> CrateLoader<'a> {\n \n             let mut uses_std = false;\n             self.cstore.iter_crate_data(|_, data| {\n-                if data.name == sym::std {\n+                if data.root.name == sym::std {\n                     uses_std = true;\n                 }\n             });\n \n             if uses_std {\n-                let name = match *sanitizer {\n+                let name = Symbol::intern(match sanitizer {\n                     Sanitizer::Address => \"rustc_asan\",\n                     Sanitizer::Leak => \"rustc_lsan\",\n                     Sanitizer::Memory => \"rustc_msan\",\n                     Sanitizer::Thread => \"rustc_tsan\",\n-                };\n+                });\n                 info!(\"loading sanitizer: {}\", name);\n \n-                let symbol = Symbol::intern(name);\n-                let dep_kind = DepKind::Explicit;\n-                let (_, data) =\n-                    self.resolve_crate(&None, symbol, symbol, None, None, DUMMY_SP,\n-                                       PathKind::Crate, dep_kind)\n-                        .unwrap_or_else(|err| err.report());\n+                let data = self.resolve_crate(name, DUMMY_SP, DepKind::Explicit, None).1;\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n                 if !data.root.sanitizer_runtime {\n@@ -832,12 +818,8 @@ impl<'a> CrateLoader<'a> {\n         {\n             info!(\"loading profiler\");\n \n-            let symbol = Symbol::intern(\"profiler_builtins\");\n-            let dep_kind = DepKind::Implicit;\n-            let (_, data) =\n-                self.resolve_crate(&None, symbol, symbol, None, None, DUMMY_SP,\n-                                   PathKind::Crate, dep_kind)\n-                    .unwrap_or_else(|err| err.report());\n+            let name = Symbol::intern(\"profiler_builtins\");\n+            let data = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None).1;\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n             if !data.root.profiler_runtime {\n@@ -1004,7 +986,7 @@ impl<'a> CrateLoader<'a> {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 debug!(\"resolving extern crate stmt. ident: {} orig_name: {:?}\",\n                        item.ident, orig_name);\n-                let orig_name = match orig_name {\n+                let name = match orig_name {\n                     Some(orig_name) => {\n                         crate::validate_crate_name(Some(self.sess), &orig_name.as_str(),\n                                             Some(item.span));\n@@ -1018,10 +1000,7 @@ impl<'a> CrateLoader<'a> {\n                     DepKind::Explicit\n                 };\n \n-                let (cnum, ..) = self.resolve_crate(\n-                    &None, item.ident.name, orig_name, None, None,\n-                    item.span, PathKind::Crate, dep_kind,\n-                ).unwrap_or_else(|err| err.report());\n+                let cnum = self.resolve_crate(name, item.span, dep_kind, None).0;\n \n                 let def_id = definitions.opt_local_def_id(item.id).unwrap();\n                 let path_len = definitions.def_path(def_id.index).data.len();\n@@ -1047,9 +1026,7 @@ impl<'a> CrateLoader<'a> {\n         name: Symbol,\n         span: Span,\n     ) -> CrateNum {\n-        let cnum = self.resolve_crate(\n-            &None, name, name, None, None, span, PathKind::Crate, DepKind::Explicit\n-        ).unwrap_or_else(|err| err.report()).0;\n+        let cnum = self.resolve_crate(name, span, DepKind::Explicit, None).0;\n \n         self.update_extern_crate(\n             cnum,\n@@ -1071,9 +1048,7 @@ impl<'a> CrateLoader<'a> {\n         name: Symbol,\n         span: Span,\n     ) -> Option<CrateNum> {\n-        let cnum = self.resolve_crate(\n-            &None, name, name, None, None, span, PathKind::Crate, DepKind::Explicit\n-        ).ok()?.0;\n+        let cnum = self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()?.0;\n \n         self.update_extern_crate(\n             cnum,"}, {"sha": "833c846573f6339176a752d8b68cae94792921eb", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -12,7 +12,6 @@ use rustc::util::nodemap::{FxHashMap, NodeMap};\n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n use syntax::ast;\n use syntax::ext::base::SyntaxExtension;\n-use syntax::symbol::Symbol;\n use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind, LinkagePreference};\n@@ -28,7 +27,6 @@ pub use crate::cstore_impl::{provide, provide_extern};\n pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n pub use rustc_data_structures::sync::MetadataRef;\n-use crate::creader::Library;\n use syntax_pos::Span;\n use proc_macro::bridge::client::ProcMacro;\n \n@@ -46,13 +44,6 @@ pub struct ImportedSourceFile {\n }\n \n pub struct CrateMetadata {\n-    /// Original name of the crate.\n-    pub name: Symbol,\n-\n-    /// Name of the crate as imported. I.e., if imported with\n-    /// `extern crate foo as bar;` this will be `bar`.\n-    pub imported_name: Symbol,\n-\n     /// Information about the extern crate that caused this crate to\n     /// be loaded. If this is `None`, then the crate was injected\n     /// (e.g., by the allocator)\n@@ -89,7 +80,6 @@ pub struct CrateMetadata {\n     /// for purposes of the 'exported_private_dependencies' lint\n     pub private_dep: bool,\n \n-    pub host_lib: Option<Library>,\n     pub span: Span,\n \n     pub raw_proc_macros: Option<&'static [ProcMacro]>,"}, {"sha": "91532d84473ab173338a8b120bc7e283388afb9c", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -154,9 +154,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     rendered_const => { cdata.get_rendered_const(def_id.index) }\n     impl_parent => { cdata.get_parent_impl(def_id.index) }\n     trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n-    const_is_rvalue_promotable_to_static => {\n-        cdata.const_is_rvalue_promotable_to_static(def_id.index)\n-    }\n     is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n \n     dylib_dependency_formats => { cdata.get_dylib_dependency_formats(tcx) }\n@@ -220,7 +217,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         let r = *cdata.dep_kind.lock();\n         r\n     }\n-    crate_name => { cdata.name }\n+    crate_name => { cdata.root.name }\n     item_children => {\n         let mut result = SmallVec::<[_; 8]>::new();\n         cdata.each_child_of_item(def_id.index, |child| result.push(child), tcx.sess);\n@@ -453,8 +450,7 @@ impl cstore::CStore {\n         }\n \n         let def = data.get_macro(id.index);\n-        let macro_full_name = data.def_path(id.index)\n-            .to_string_friendly(|_| data.imported_name);\n+        let macro_full_name = data.def_path(id.index).to_string_friendly(|_| data.root.name);\n         let source_name = FileName::Macros(macro_full_name);\n \n         let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);\n@@ -504,7 +500,7 @@ impl CrateStore for cstore::CStore {\n \n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol\n     {\n-        self.get_crate_data(cnum).name\n+        self.get_crate_data(cnum).root.name\n     }\n \n     fn crate_is_private_dep_untracked(&self, cnum: CrateNum) -> bool {"}, {"sha": "34f86707ad3222606bbb5960daf50db4c8d6fc28", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -473,7 +473,7 @@ impl<'a, 'tcx> CrateMetadata {\n             None => {\n                 bug!(\"entry: id not found: {:?} in crate {:?} with number {}\",\n                      item_id,\n-                     self.name,\n+                     self.root.name,\n                      self.cnum)\n             }\n             Some(d) => d.decode(self),\n@@ -543,18 +543,13 @@ impl<'a, 'tcx> CrateMetadata {\n                 name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n             )\n         };\n-        let edition = if sess.opts.debugging_opts.dual_proc_macros {\n-            self.host_lib.as_ref().unwrap().metadata.get_root().edition\n-        } else {\n-            self.root.edition\n-        };\n \n         SyntaxExtension::new(\n             &sess.parse_sess,\n             kind,\n             self.get_span(id, sess),\n             helper_attrs,\n-            edition,\n+            self.root.edition,\n             Symbol::intern(name),\n             &self.get_attributes(&self.entry(id), sess),\n         )\n@@ -915,14 +910,6 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn const_is_rvalue_promotable_to_static(&self, id: DefIndex) -> bool {\n-        match self.entry(id).kind {\n-            EntryKind::AssocConst(_, data, _) |\n-            EntryKind::Const(data, _) => data.ast_promotable,\n-            _ => bug!(),\n-        }\n-    }\n-\n     pub fn is_item_mir_available(&self, id: DefIndex) -> bool {\n         !self.is_proc_macro(id) &&\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()"}, {"sha": "bbfbba2e0d8f4c7a6140d4f1b45c8f95764ad410", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -861,18 +861,11 @@ impl EncodeContext<'tcx> {\n \n         let kind = match trait_item.kind {\n             ty::AssocKind::Const => {\n-                let const_qualif =\n-                    if let hir::TraitItemKind::Const(_, Some(body)) = ast_item.kind {\n-                        self.const_qualif(0, body)\n-                    } else {\n-                        ConstQualif { mir: 0, ast_promotable: false }\n-                    };\n-\n                 let rendered =\n                     hir::print::to_string(self.tcx.hir(), |s| s.print_trait_item(ast_item));\n                 let rendered_const = self.lazy(RenderedConst(rendered));\n \n-                EntryKind::AssocConst(container, const_qualif, rendered_const)\n+                EntryKind::AssocConst(container, ConstQualif { mir: 0 }, rendered_const)\n             }\n             ty::AssocKind::Method => {\n                 let fn_data = if let hir::TraitItemKind::Method(method_sig, m) = &ast_item.kind {\n@@ -946,13 +939,6 @@ impl EncodeContext<'tcx> {\n         !self.tcx.sess.opts.output_types.should_codegen()\n     }\n \n-    fn const_qualif(&self, mir: u8, body_id: hir::BodyId) -> ConstQualif {\n-        let body_owner_def_id = self.tcx.hir().body_owner_def_id(body_id);\n-        let ast_promotable = self.tcx.const_is_rvalue_promotable_to_static(body_owner_def_id);\n-\n-        ConstQualif { mir, ast_promotable }\n-    }\n-\n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n         debug!(\"EncodeContext::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -974,7 +960,7 @@ impl EncodeContext<'tcx> {\n                     let mir = self.tcx.at(ast_item.span).mir_const_qualif(def_id).0;\n \n                     EntryKind::AssocConst(container,\n-                        self.const_qualif(mir, body_id),\n+                        ConstQualif { mir },\n                         self.encode_rendered_const_for_body(body_id))\n                 } else {\n                     bug!()\n@@ -1123,7 +1109,7 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Const(_, body_id) => {\n                 let mir = tcx.at(item.span).mir_const_qualif(def_id).0;\n                 EntryKind::Const(\n-                    self.const_qualif(mir, body_id),\n+                    ConstQualif { mir },\n                     self.encode_rendered_const_for_body(body_id)\n                 )\n             }\n@@ -1437,7 +1423,7 @@ impl EncodeContext<'tcx> {\n             }\n \n             ty::Closure(def_id, substs) => {\n-                let sig = substs.closure_sig(def_id, self.tcx);\n+                let sig = substs.as_closure().sig(def_id, self.tcx);\n                 let data = ClosureData { sig: self.lazy(sig) };\n                 EntryKind::Closure(self.lazy(data))\n             }\n@@ -1475,7 +1461,7 @@ impl EncodeContext<'tcx> {\n         let mir = tcx.mir_const_qualif(def_id).0;\n \n         Entry {\n-            kind: EntryKind::Const(self.const_qualif(mir, body_id), const_data),\n+            kind: EntryKind::Const(ConstQualif { mir }, const_data),\n             visibility: self.lazy(ty::Visibility::Public),\n             span: self.lazy(tcx.def_span(def_id)),\n             attributes: Lazy::empty(),"}, {"sha": "8df236c41cfb888a88bf0556bec35a2d1046ee1b", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -254,15 +254,14 @@ pub struct CrateMismatch {\n pub struct Context<'a> {\n     pub sess: &'a Session,\n     pub span: Span,\n-    pub ident: Symbol,\n     pub crate_name: Symbol,\n     pub hash: Option<&'a Svh>,\n     pub extra_filename: Option<&'a str>,\n     // points to either self.sess.target.target or self.sess.host, must match triple\n     pub target: &'a Target,\n     pub triple: TargetTriple,\n     pub filesearch: FileSearch<'a>,\n-    pub root: &'a Option<CratePaths>,\n+    pub root: Option<&'a CratePaths>,\n     pub rejected_via_hash: Vec<CrateMismatch>,\n     pub rejected_via_triple: Vec<CrateMismatch>,\n     pub rejected_via_kind: Vec<CrateMismatch>,\n@@ -323,25 +322,25 @@ impl<'a> Context<'a> {\n \n     pub fn report_errs(self) -> ! {\n         let add = match self.root {\n-            &None => String::new(),\n-            &Some(ref r) => format!(\" which `{}` depends on\", r.ident),\n+            None => String::new(),\n+            Some(r) => format!(\" which `{}` depends on\", r.ident),\n         };\n         let mut msg = \"the following crate versions were found:\".to_string();\n         let mut err = if !self.rejected_via_hash.is_empty() {\n             let mut err = struct_span_err!(self.sess,\n                                            self.span,\n                                            E0460,\n                                            \"found possibly newer version of crate `{}`{}\",\n-                                           self.ident,\n+                                           self.crate_name,\n                                            add);\n             err.note(\"perhaps that crate needs to be recompiled?\");\n             let mismatches = self.rejected_via_hash.iter();\n             for &CrateMismatch { ref path, .. } in mismatches {\n-                msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.ident, path.display()));\n+                msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.crate_name, path.display()));\n             }\n             match self.root {\n-                &None => {}\n-                &Some(ref r) => {\n+                None => {}\n+                Some(r) => {\n                     for path in r.paths().iter() {\n                         msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.ident, path.display()));\n                     }\n@@ -355,13 +354,13 @@ impl<'a> Context<'a> {\n                                            E0461,\n                                            \"couldn't find crate `{}` \\\n                                             with expected target triple {}{}\",\n-                                           self.ident,\n+                                           self.crate_name,\n                                            self.triple,\n                                            add);\n             let mismatches = self.rejected_via_triple.iter();\n             for &CrateMismatch { ref path, ref got } in mismatches {\n                 msg.push_str(&format!(\"\\ncrate `{}`, target triple {}: {}\",\n-                                      self.ident,\n+                                      self.crate_name,\n                                       got,\n                                       path.display()));\n             }\n@@ -372,12 +371,12 @@ impl<'a> Context<'a> {\n                                            self.span,\n                                            E0462,\n                                            \"found staticlib `{}` instead of rlib or dylib{}\",\n-                                           self.ident,\n+                                           self.crate_name,\n                                            add);\n             err.help(\"please recompile that crate using --crate-type lib\");\n             let mismatches = self.rejected_via_kind.iter();\n             for &CrateMismatch { ref path, .. } in mismatches {\n-                msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.ident, path.display()));\n+                msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.crate_name, path.display()));\n             }\n             err.note(&msg);\n             err\n@@ -387,14 +386,14 @@ impl<'a> Context<'a> {\n                                            E0514,\n                                            \"found crate `{}` compiled by an incompatible version \\\n                                             of rustc{}\",\n-                                           self.ident,\n+                                           self.crate_name,\n                                            add);\n             err.help(&format!(\"please recompile that crate using this compiler ({})\",\n                               rustc_version()));\n             let mismatches = self.rejected_via_version.iter();\n             for &CrateMismatch { ref path, ref got } in mismatches {\n                 msg.push_str(&format!(\"\\ncrate `{}` compiled by {}: {}\",\n-                                      self.ident,\n+                                      self.crate_name,\n                                       got,\n                                       path.display()));\n             }\n@@ -405,10 +404,10 @@ impl<'a> Context<'a> {\n                                            self.span,\n                                            E0463,\n                                            \"can't find crate for `{}`{}\",\n-                                           self.ident,\n+                                           self.crate_name,\n                                            add);\n \n-            if (self.ident == sym::std || self.ident == sym::core)\n+            if (self.crate_name == sym::std || self.crate_name == sym::core)\n                 && self.triple != TargetTriple::from_triple(config::host_triple()) {\n                 err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n             }"}, {"sha": "4fe9c466cb6dafa0dd568526de2edfe856a1c14f", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -274,7 +274,6 @@ pub enum EntryKind<'tcx> {\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable)]\n pub struct ConstQualif {\n     pub mir: u8,\n-    pub ast_promotable: bool,\n }\n \n /// Contains a constant which has been rendered to a String."}, {"sha": "431361fa5a87b09a984415d8ac764184a48aeebe", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -341,7 +341,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             ty::Closure(def_id, closure_substs)\n                 if def_id == self.mir_def_id && upvar_field.is_some()\n             => {\n-                let closure_kind_ty = closure_substs.closure_kind_ty(def_id, self.infcx.tcx);\n+                let closure_kind_ty = closure_substs\n+                    .as_closure().kind_ty(def_id, self.infcx.tcx);\n                 let closure_kind = closure_kind_ty.to_opt_closure_kind();\n                 let capture_description = match closure_kind {\n                     Some(ty::ClosureKind::Fn) => {"}, {"sha": "0e22ead62d1c0b747b6976e71b77ffab2ecd65b7", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -12,7 +12,7 @@ use rustc::mir::{\n     SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n };\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid, Ty};\n+use rustc::ty::{self, GeneratorSubsts, RegionVid, Ty};\n use rustc::ty::subst::SubstsRef;\n \n pub(super) fn generate_constraints<'cx, 'tcx>(\n@@ -98,13 +98,6 @@ impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n         self.super_generator_substs(substs);\n     }\n \n-    /// We sometimes have `closure_substs` within an rvalue, or within a\n-    /// call. Make them live at the location where they appear.\n-    fn visit_closure_substs(&mut self, substs: &ClosureSubsts<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*substs, location);\n-        self.super_closure_substs(substs);\n-    }\n-\n     fn visit_statement(\n         &mut self,\n         statement: &Statement<'tcx>,"}, {"sha": "7362ae9c638b137504897716006d9bba859c8957", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -875,7 +875,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n             if let ty::BoundRegion::BrEnv = free_region.bound_region {\n                 if let DefiningTy::Closure(def_id, substs) = self.universal_regions.defining_ty {\n-                    let closure_kind_ty = substs.closure_kind_ty(def_id, infcx.tcx);\n+                    let closure_kind_ty = substs.as_closure().kind_ty(def_id, infcx.tcx);\n                     return Some(ty::ClosureKind::FnMut) == closure_kind_ty.to_opt_closure_kind();\n                 }\n             }"}, {"sha": "6fb976e0d84b291f9a584454a5afb53ae0f33a92", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -300,7 +300,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         };\n                         let region_name = self.synthesize_region_name(renctx);\n \n-                        let closure_kind_ty = substs.closure_kind_ty(def_id, tcx);\n+                        let closure_kind_ty = substs.as_closure().kind_ty(def_id, tcx);\n                         let note = match closure_kind_ty.to_opt_closure_kind() {\n                             Some(ty::ClosureKind::Fn) => {\n                                 \"closure implements `Fn`, so references to captured variables \\"}, {"sha": "014335711a5114bba2f1ad119645a356c9cc2d39", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1,5 +1,5 @@\n use rustc::ty::subst::SubstsRef;\n-use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable};\n+use rustc::ty::{self, GeneratorSubsts, Ty, TypeFoldable};\n use rustc::mir::{Location, Body, Promoted};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n@@ -96,16 +96,4 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'tcx> {\n \n         debug!(\"visit_generator_substs: substs={:?}\", substs);\n     }\n-\n-    fn visit_closure_substs(&mut self, substs: &mut ClosureSubsts<'tcx>, location: Location) {\n-        debug!(\n-            \"visit_closure_substs(substs={:?}, location={:?})\",\n-            substs,\n-            location\n-        );\n-\n-        *substs = self.renumber_regions(substs);\n-\n-        debug!(\"visit_closure_substs: substs={:?}\", substs);\n-    }\n }"}, {"sha": "7dee00b3eca674f9b0e3d49f0aed5bbe7d94c257", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -70,6 +70,10 @@ impl LocalUseMap {\n             appearances: IndexVec::new(),\n         };\n \n+        if live_locals.is_empty() {\n+            return local_use_map;\n+        }\n+\n         let mut locals_with_use_data: IndexVec<Local, bool> =\n             IndexVec::from_elem_n(false, body.local_decls.len());\n         live_locals.iter().for_each(|&local| locals_with_use_data[local] = true);"}, {"sha": "a01b528833b2d01314564b502172dc2c4a9aff0f", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -36,31 +36,39 @@ pub(super) fn generate<'tcx>(\n ) {\n     debug!(\"liveness::generate\");\n \n-    let live_locals: Vec<Local> = if AllFacts::enabled(typeck.tcx()) {\n-        // If \"dump facts from NLL analysis\" was requested perform\n-        // the liveness analysis for all `Local`s. This case opens\n-        // the possibility of the variables being analyzed in `trace`\n-        // to be *any* `Local`, not just the \"live\" ones, so we can't\n-        // make any assumptions past this point as to the characteristics\n-        // of the `live_locals`.\n-        // FIXME: Review \"live\" terminology past this point, we should\n-        // not be naming the `Local`s as live.\n-        body.local_decls.indices().collect()\n+    let free_regions = regions_that_outlive_free_regions(\n+        typeck.infcx.num_region_vars(),\n+        &typeck.borrowck_context.universal_regions,\n+        &typeck.borrowck_context.constraints.outlives_constraints,\n+    );\n+    let live_locals = compute_live_locals(typeck.tcx(), &free_regions, body);\n+    let facts_enabled = AllFacts::enabled(typeck.tcx());\n+\n+\n+    let polonius_drop_used = if facts_enabled {\n+        let mut drop_used = Vec::new();\n+        polonius::populate_access_facts(\n+            typeck,\n+            body,\n+            location_table,\n+            move_data,\n+            &mut drop_used,\n+        );\n+        Some(drop_used)\n     } else {\n-        let free_regions = {\n-            regions_that_outlive_free_regions(\n-                typeck.infcx.num_region_vars(),\n-                &typeck.borrowck_context.universal_regions,\n-                &typeck.borrowck_context.constraints.outlives_constraints,\n-            )\n-        };\n-        compute_live_locals(typeck.tcx(), &free_regions, body)\n+        None\n     };\n \n-    if !live_locals.is_empty() {\n-        trace::trace(typeck, body, elements, flow_inits, move_data, live_locals);\n-\n-        polonius::populate_access_facts(typeck, body, location_table, move_data);\n+    if !live_locals.is_empty() || facts_enabled {\n+        trace::trace(\n+            typeck,\n+            body,\n+            elements,\n+            flow_inits,\n+            move_data,\n+            live_locals,\n+            polonius_drop_used,\n+        );\n     }\n }\n "}, {"sha": "526ad7fb905bb6b3152d89b6e9ec82200be98ff9", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/polonius.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -16,7 +16,7 @@ struct UseFactsExtractor<'me> {\n     var_defined: &'me mut VarPointRelations,\n     var_used: &'me mut VarPointRelations,\n     location_table: &'me LocationTable,\n-    var_drop_used: &'me mut VarPointRelations,\n+    var_drop_used: &'me mut Vec<(Local, Location)>,\n     move_data: &'me MoveData<'me>,\n     path_accessed_at: &'me mut MovePathPointRelations,\n }\n@@ -39,7 +39,7 @@ impl UseFactsExtractor<'_> {\n \n     fn insert_drop_use(&mut self, local: Local, location: Location) {\n         debug!(\"LivenessFactsExtractor::insert_drop_use()\");\n-        self.var_drop_used.push((local, self.location_to_index(location)));\n+        self.var_drop_used.push((local, location));\n     }\n \n     fn insert_path_access(&mut self, path: MovePathIndex, location: Location) {\n@@ -100,19 +100,24 @@ pub(super) fn populate_access_facts(\n     body: &Body<'tcx>,\n     location_table: &LocationTable,\n     move_data: &MoveData<'_>,\n+    drop_used: &mut Vec<(Local, Location)>,\n ) {\n     debug!(\"populate_var_liveness_facts()\");\n \n     if let Some(facts) = typeck.borrowck_context.all_facts.as_mut() {\n         UseFactsExtractor {\n             var_defined: &mut facts.var_defined,\n             var_used: &mut facts.var_used,\n-            var_drop_used: &mut facts.var_drop_used,\n+            var_drop_used: drop_used,\n             path_accessed_at: &mut facts.path_accessed_at,\n             location_table,\n             move_data,\n         }\n         .visit_body(body);\n+\n+        facts.var_drop_used.extend(drop_used.iter().map(|&(local, location)| {\n+            (local, location_table.mid_index(location))\n+        }));\n     }\n \n     for (local, local_decl) in body.local_decls.iter_enumerated() {"}, {"sha": "eacc4d084dbb808d58ea8c726f213c2fc3657784", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -13,7 +13,7 @@ use rustc::traits::query::type_op::outlives::DropckOutlives;\n use rustc::traits::query::type_op::TypeOp;\n use rustc::ty::{Ty, TypeFoldable};\n use rustc_index::bit_set::HybridBitSet;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::rc::Rc;\n \n /// This is the heart of the liveness computation. For each variable X\n@@ -37,6 +37,7 @@ pub(super) fn trace(\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     live_locals: Vec<Local>,\n+    polonius_drop_used: Option<Vec<(Local, Location)>>,\n ) {\n     debug!(\"trace()\");\n \n@@ -52,7 +53,13 @@ pub(super) fn trace(\n         drop_data: FxHashMap::default(),\n     };\n \n-    LivenessResults::new(cx).compute_for_all_locals(live_locals);\n+    let mut results = LivenessResults::new(cx);\n+\n+    if let Some(drop_used) = polonius_drop_used {\n+        results.add_extra_drop_facts(drop_used, live_locals.iter().copied().collect())\n+    }\n+\n+    results.compute_for_all_locals(live_locals);\n }\n \n /// Contextual state for the type-liveness generator.\n@@ -145,6 +152,32 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         }\n     }\n \n+    /// Add extra drop facts needed for Polonius.\n+    ///\n+    /// Add facts for all locals with free regions, since regions may outlive\n+    /// the function body only at certain nodes in the CFG.\n+    fn add_extra_drop_facts(\n+        &mut self,\n+        drop_used: Vec<(Local, Location)>,\n+        live_locals: FxHashSet<Local>,\n+    ) {\n+        let locations = HybridBitSet::new_empty(self.cx.elements.num_points());\n+\n+        for (local, location) in drop_used {\n+            if !live_locals.contains(&local) {\n+                let local_ty = self.cx.body.local_decls[local].ty;\n+                if local_ty.has_free_regions() {\n+                    self.cx.add_drop_live_facts_for(\n+                        local,\n+                        local_ty,\n+                        &[location],\n+                        &locations,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n     /// Clear the value of fields that are \"per local variable\".\n     fn reset_local_state(&mut self) {\n         self.defs.clear();"}, {"sha": "f55889794c24db9e386ff86b9a7862702de5e877", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 47, "deletions": 29, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -276,7 +276,17 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n \n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n-        self.sanitize_type(constant, constant.literal.ty);\n+        let ty = self.sanitize_type(constant, constant.literal.ty);\n+\n+        self.cx.infcx.tcx.for_each_free_region(&ty, |live_region| {\n+            let live_region_vid =\n+                self.cx.borrowck_context.universal_regions.to_region_vid(live_region);\n+            self.cx\n+                .borrowck_context\n+                .constraints\n+                .liveness_constraints\n+                .add_element(live_region_vid, location);\n+        });\n \n         if let Some(annotation_index) = constant.user_ty {\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n@@ -528,56 +538,64 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         let parent_body = mem::replace(&mut self.body, promoted_body);\n \n+        // Use new sets of constraints and closure bounds so that we can\n+        // modify their locations.\n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n         let mut closure_bounds = Default::default();\n+        let mut liveness_constraints = LivenessValues::new(\n+            Rc::new(RegionValueElements::new(promoted_body)),\n+        );\n         // Don't try to add borrow_region facts for the promoted MIR\n-        mem::swap(self.cx.borrowck_context.all_facts, all_facts);\n \n-        // Use a new sets of constraints and closure bounds so that we can\n-        // modify their locations.\n-        mem::swap(\n-            &mut self.cx.borrowck_context.constraints.outlives_constraints,\n-            &mut constraints\n-        );\n-        mem::swap(\n-            &mut self.cx.borrowck_context.constraints.closure_bounds_mapping,\n-            &mut closure_bounds\n-        );\n+        let mut swap_constraints = |this: &mut Self| {\n+            mem::swap(this.cx.borrowck_context.all_facts, all_facts);\n+            mem::swap(\n+                &mut this.cx.borrowck_context.constraints.outlives_constraints,\n+                &mut constraints\n+            );\n+            mem::swap(\n+                &mut this.cx.borrowck_context.constraints.closure_bounds_mapping,\n+                &mut closure_bounds\n+            );\n+            mem::swap(\n+                &mut this.cx.borrowck_context.constraints.liveness_constraints,\n+                &mut liveness_constraints\n+            );\n+        };\n+\n+        swap_constraints(self);\n \n         self.visit_body(promoted_body);\n \n+\n         if !self.errors_reported {\n             // if verifier failed, don't do further checks to avoid ICEs\n             self.cx.typeck_mir(promoted_body);\n         }\n \n         self.body = parent_body;\n         // Merge the outlives constraints back in, at the given location.\n-        mem::swap(self.cx.borrowck_context.all_facts, all_facts);\n-        mem::swap(\n-            &mut self.cx.borrowck_context.constraints.outlives_constraints,\n-            &mut constraints\n-        );\n-        mem::swap(\n-            &mut self.cx.borrowck_context.constraints.closure_bounds_mapping,\n-            &mut closure_bounds\n-        );\n+        swap_constraints(self);\n \n         let locations = location.to_locations();\n         for constraint in constraints.outlives().iter() {\n             let mut constraint = *constraint;\n             constraint.locations = locations;\n             if let ConstraintCategory::Return\n-                | ConstraintCategory::UseAsConst\n-                | ConstraintCategory::UseAsStatic = constraint.category\n+            | ConstraintCategory::UseAsConst\n+            | ConstraintCategory::UseAsStatic = constraint.category\n             {\n                 // \"Returning\" from a promoted is an assigment to a\n                 // temporary from the user's point of view.\n                 constraint.category = ConstraintCategory::Boring;\n             }\n             self.cx.borrowck_context.constraints.outlives_constraints.push(constraint)\n         }\n+        for live_region in liveness_constraints.rows() {\n+            self.cx.borrowck_context.constraints.liveness_constraints\n+                .add_element(live_region, location);\n+        }\n \n         if !closure_bounds.is_empty() {\n             let combined_bounds_mapping = closure_bounds\n@@ -763,10 +781,10 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 ty::Adt(adt_def, substs) if !adt_def.is_enum() =>\n                     (&adt_def.variants[VariantIdx::new(0)], substs),\n                 ty::Closure(def_id, substs) => {\n-                    return match substs.upvar_tys(def_id, tcx).nth(field.index()) {\n+                    return match substs.as_closure().upvar_tys(def_id, tcx).nth(field.index()) {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n-                            field_count: substs.upvar_tys(def_id, tcx).count(),\n+                            field_count: substs.as_closure().upvar_tys(def_id, tcx).count(),\n                         }),\n                     }\n                 }\n@@ -1934,10 +1952,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n             AggregateKind::Closure(def_id, substs) => {\n-                match substs.upvar_tys(def_id, tcx).nth(field_index) {\n+                match substs.as_closure().upvar_tys(def_id, tcx).nth(field_index) {\n                     Some(ty) => Ok(ty),\n                     None => Err(FieldAccessError::OutOfRange {\n-                        field_count: substs.upvar_tys(def_id, tcx).count(),\n+                        field_count: substs.as_closure().upvar_tys(def_id, tcx).count(),\n                     }),\n                 }\n             }\n@@ -2050,7 +2068,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     CastKind::Pointer(PointerCast::ClosureFnPointer(unsafety)) => {\n                         let sig = match op.ty(body, tcx).kind {\n                             ty::Closure(def_id, substs) => {\n-                                substs.closure_sig_ty(def_id, tcx).fn_sig(tcx)\n+                                substs.as_closure().sig_ty(def_id, tcx).fn_sig(tcx)\n                             }\n                             _ => bug!(),\n                         };\n@@ -2522,7 +2540,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             // desugaring. A closure gets desugared to a struct, and\n             // these extra requirements are basically like where\n             // clauses on the struct.\n-            AggregateKind::Closure(def_id, ty::ClosureSubsts { substs })\n+            AggregateKind::Closure(def_id, substs)\n             | AggregateKind::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n                 self.prove_closure_bounds(tcx, *def_id, substs, location)\n             }"}, {"sha": "e3efacff66a2fa50b9afafe9b1461dcfc4fb4fda", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -19,7 +19,7 @@ use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::middle::lang_items;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{InternalSubsts, SubstsRef, Subst};\n-use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid, Ty, TyCtxt};\n+use rustc::ty::{self, GeneratorSubsts, RegionVid, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_errors::DiagnosticBuilder;\n@@ -85,7 +85,7 @@ pub struct UniversalRegions<'tcx> {\n pub enum DefiningTy<'tcx> {\n     /// The MIR is a closure. The signature is found via\n     /// `ClosureSubsts::closure_sig_ty`.\n-    Closure(DefId, ty::ClosureSubsts<'tcx>),\n+    Closure(DefId, SubstsRef<'tcx>),\n \n     /// The MIR is a generator. The signature is that generators take\n     /// no parameters and return the result of\n@@ -109,7 +109,9 @@ impl<'tcx> DefiningTy<'tcx> {\n     /// match up with the upvar order in the HIR, typesystem, and MIR.\n     pub fn upvar_tys(self, tcx: TyCtxt<'tcx>) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         match self {\n-            DefiningTy::Closure(def_id, substs) => Either::Left(substs.upvar_tys(def_id, tcx)),\n+            DefiningTy::Closure(def_id, substs) => Either::Left(\n+                substs.as_closure().upvar_tys(def_id, tcx)\n+            ),\n             DefiningTy::Generator(def_id, substs, _) => {\n                 Either::Right(Either::Left(substs.upvar_tys(def_id, tcx)))\n             }\n@@ -312,7 +314,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n                 err.note(&format!(\n                     \"defining type: {:?} with closure substs {:#?}\",\n                     def_id,\n-                    &substs.substs[..]\n+                    &substs[..]\n                 ));\n \n                 // FIXME: It'd be nice to print the late-bound regions\n@@ -546,7 +548,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n         let identity_substs = InternalSubsts::identity_for_item(tcx, closure_base_def_id);\n         let fr_substs = match defining_ty {\n-            DefiningTy::Closure(_, ClosureSubsts { ref substs })\n+            DefiningTy::Closure(_, ref substs)\n             | DefiningTy::Generator(_, GeneratorSubsts { ref substs }, _) => {\n                 // In the case of closures, we rely on the fact that\n                 // the first N elements in the ClosureSubsts are\n@@ -582,7 +584,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         match defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n                 assert_eq!(self.mir_def_id, def_id);\n-                let closure_sig = substs.closure_sig_ty(def_id, tcx).fn_sig(tcx);\n+                let closure_sig = substs.as_closure().sig_ty(def_id, tcx).fn_sig(tcx);\n                 let inputs_and_output = closure_sig.inputs_and_output();\n                 let closure_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n                 ty::Binder::fuse("}, {"sha": "e6f7a042f1c2b2ef17ebadedbe393b54418dfa10", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -506,7 +506,8 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         hir::ExprKind::Closure(..) => {\n             let closure_ty = cx.tables().expr_ty(expr);\n             let (def_id, substs, movability) = match closure_ty.kind {\n-                ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n+                ty::Closure(def_id, substs) => (def_id,\n+                    UpvarSubsts::Closure(substs), None),\n                 ty::Generator(def_id, substs, movability) => {\n                     (def_id, UpvarSubsts::Generator(substs), Some(movability))\n                 }\n@@ -1011,7 +1012,7 @@ fn convert_var(\n                                                            });\n                         Expr {\n                             ty: closure_ty,\n-                            temp_lifetime: temp_lifetime,\n+                            temp_lifetime,\n                             span: expr.span,\n                             kind: ExprKind::Deref {\n                                 arg: Expr {"}, {"sha": "dc3b7694c35c9b3800f588fab44a00d8da7ec210", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -67,7 +67,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n             | ty::Opaque(def_id, substs)\n             | ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs })\n             | ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs })\n-            | ty::Closure(def_id, ty::ClosureSubsts { substs })\n+            | ty::Closure(def_id, substs)\n             | ty::Generator(def_id, ty::GeneratorSubsts { substs }, _)\n             => self.print_def_path(def_id, substs),\n             ty::Foreign(def_id) => self.print_def_path(def_id, &[]),"}, {"sha": "3ac837dd330fd0ffe22adec26fcfadeca21613c0", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -581,7 +581,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 match source_ty.kind {\n                     ty::Closure(def_id, substs) => {\n                         let instance = Instance::resolve_closure(\n-                            self.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n+                            self.tcx, def_id,\n+                            substs, ty::ClosureKind::FnOnce);\n                         if should_monomorphize_locally(self.tcx, &instance) {\n                             self.output.push(create_fn_mono_item(instance));\n                         }"}, {"sha": "d089eafbb0798138acd0a854cc4ac56221d7f697", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -320,7 +320,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n         ty::Closure(def_id, substs) => {\n             builder.tuple_like_shim(\n                 dest, src,\n-                substs.upvar_tys(def_id, tcx)\n+                substs.as_closure().upvar_tys(def_id, tcx)\n             )\n         }\n         ty::Tuple(..) => builder.tuple_like_shim(dest, src, self_ty.tuple_fields()),"}, {"sha": "bdbf040276d22eee0df4adcab73e994f1da244fd", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -788,7 +788,7 @@ where\n         let ty = self.place_ty(self.place);\n         match ty.kind {\n             ty::Closure(def_id, substs) => {\n-                let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n+                let tys : Vec<_> = substs.as_closure().upvar_tys(def_id, self.tcx()).collect();\n                 self.open_drop_for_tuple(&tys)\n             }\n             // Note that `elaborate_drops` only drops the upvars of a generator,"}, {"sha": "6c7958fb365dd1ddac040a0b202583642a59a1e4", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -19,12 +19,10 @@ use rustc::ty::query::Providers;\n pub mod error_codes;\n \n pub mod ast_validation;\n-pub mod rvalue_promotion;\n pub mod hir_stats;\n pub mod layout_test;\n pub mod loops;\n \n pub fn provide(providers: &mut Providers<'_>) {\n-    rvalue_promotion::provide(providers);\n     loops::provide(providers);\n }"}, {"sha": "a93ca7847d68a9597366d1b657621429f557ce16", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "removed", "additions": 0, "deletions": 658, "changes": 658, "blob_url": "https://github.com/rust-lang/rust/blob/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=31d75c4e9c5318e880601d3c2cc71e5df094a120", "patch": "@@ -1,658 +0,0 @@\n-// Verifies that the types and values of const and static items\n-// are safe. The rules enforced by this module are:\n-//\n-// - For each *mutable* static item, it checks that its **type**:\n-//     - doesn't have a destructor\n-//     - doesn't own a box\n-//\n-// - For each *immutable* static item, it checks that its **value**:\n-//       - doesn't own a box\n-//       - doesn't contain a struct literal or a call to an enum variant / struct constructor where\n-//           - the type of the struct/enum has a dtor\n-//\n-// Rules Enforced Elsewhere:\n-// - It's not possible to take the address of a static item with unsafe interior. This is enforced\n-// by borrowck::gather_loans\n-\n-use rustc::ty::cast::CastTy;\n-use rustc::hir::def::{Res, DefKind, CtorKind};\n-use rustc::hir::def_id::DefId;\n-use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::query::Providers;\n-use rustc::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc::util::nodemap::{ItemLocalSet, HirIdSet};\n-use rustc::hir;\n-use syntax::symbol::sym;\n-use syntax_pos::{Span, DUMMY_SP};\n-use log::debug;\n-use Promotability::*;\n-use std::ops::{BitAnd, BitAndAssign, BitOr};\n-\n-pub fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers {\n-        rvalue_promotable_map,\n-        const_is_rvalue_promotable_to_static,\n-        ..*providers\n-    };\n-}\n-\n-fn const_is_rvalue_promotable_to_static(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    assert!(def_id.is_local());\n-\n-    let hir_id = tcx.hir().as_local_hir_id(def_id)\n-        .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n-    let body_id = tcx.hir().body_owned_by(hir_id);\n-    tcx.rvalue_promotable_map(def_id).contains(&body_id.hir_id.local_id)\n-}\n-\n-fn rvalue_promotable_map(tcx: TyCtxt<'_>, def_id: DefId) -> &ItemLocalSet {\n-    let outer_def_id = tcx.closure_base_def_id(def_id);\n-    if outer_def_id != def_id {\n-        return tcx.rvalue_promotable_map(outer_def_id);\n-    }\n-\n-    let mut visitor = CheckCrateVisitor {\n-        tcx,\n-        tables: &ty::TypeckTables::empty(None),\n-        in_fn: false,\n-        in_static: false,\n-        mut_rvalue_borrows: Default::default(),\n-        param_env: ty::ParamEnv::empty(),\n-        identity_substs: InternalSubsts::empty(),\n-        result: ItemLocalSet::default(),\n-    };\n-\n-    // `def_id` should be a `Body` owner\n-    let hir_id = tcx.hir().as_local_hir_id(def_id)\n-        .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n-    let body_id = tcx.hir().body_owned_by(hir_id);\n-    let _ = visitor.check_nested_body(body_id);\n-\n-    tcx.arena.alloc(visitor.result)\n-}\n-\n-struct CheckCrateVisitor<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    in_fn: bool,\n-    in_static: bool,\n-    mut_rvalue_borrows: HirIdSet,\n-    param_env: ty::ParamEnv<'tcx>,\n-    identity_substs: SubstsRef<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n-    result: ItemLocalSet,\n-}\n-\n-#[must_use]\n-#[derive(Debug, Clone, Copy, PartialEq)]\n-enum Promotability {\n-    Promotable,\n-    NotPromotable\n-}\n-\n-impl BitAnd for Promotability {\n-    type Output = Self;\n-\n-    fn bitand(self, rhs: Self) -> Self {\n-        match (self, rhs) {\n-            (Promotable, Promotable) => Promotable,\n-            _ => NotPromotable,\n-        }\n-    }\n-}\n-\n-impl BitAndAssign for Promotability {\n-    fn bitand_assign(&mut self, rhs: Self) {\n-        *self = *self & rhs\n-    }\n-}\n-\n-impl BitOr for Promotability {\n-    type Output = Self;\n-\n-    fn bitor(self, rhs: Self) -> Self {\n-        match (self, rhs) {\n-            (NotPromotable, NotPromotable) => NotPromotable,\n-            _ => Promotable,\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n-    // Returns true iff all the values of the type are promotable.\n-    fn type_promotability(&mut self, ty: Ty<'tcx>) -> Promotability {\n-        debug!(\"type_promotability({})\", ty);\n-\n-        if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) &&\n-            !ty.needs_drop(self.tcx, self.param_env) {\n-            Promotable\n-        } else {\n-            NotPromotable\n-        }\n-    }\n-\n-    fn handle_const_fn_call(\n-        &mut self,\n-        def_id: DefId,\n-    ) -> Promotability {\n-        if self.tcx.is_promotable_const_fn(def_id) {\n-            Promotable\n-        } else {\n-            NotPromotable\n-        }\n-    }\n-\n-    /// While the `ExprUseVisitor` walks, we will identify which\n-    /// expressions are borrowed, and insert their IDs into this\n-    /// table. Actually, we insert the \"borrow-id\", which is normally\n-    /// the ID of the expression being borrowed: but in the case of\n-    /// `ref mut` borrows, the `id` of the pattern is\n-    /// inserted. Therefore, later we remove that entry from the table\n-    /// and transfer it over to the value being matched. This will\n-    /// then prevent said value from being promoted.\n-    fn remove_mut_rvalue_borrow(&mut self, pat: &hir::Pat) -> bool {\n-        let mut any_removed = false;\n-        pat.walk(|p| {\n-            any_removed |= self.mut_rvalue_borrows.remove(&p.hir_id);\n-            true\n-        });\n-        any_removed\n-    }\n-}\n-\n-impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n-    fn check_nested_body(&mut self, body_id: hir::BodyId) -> Promotability {\n-        let item_id = self.tcx.hir().body_owner(body_id);\n-        let item_def_id = self.tcx.hir().local_def_id(item_id);\n-\n-        let outer_in_fn = self.in_fn;\n-        let outer_tables = self.tables;\n-        let outer_param_env = self.param_env;\n-        let outer_identity_substs = self.identity_substs;\n-\n-        self.in_fn = false;\n-        self.in_static = false;\n-\n-        match self.tcx.hir().body_owner_kind(item_id) {\n-            hir::BodyOwnerKind::Closure |\n-            hir::BodyOwnerKind::Fn => self.in_fn = true,\n-            hir::BodyOwnerKind::Static(_) => self.in_static = true,\n-            _ => {}\n-        };\n-\n-\n-        self.tables = self.tcx.typeck_tables_of(item_def_id);\n-        self.param_env = self.tcx.param_env(item_def_id);\n-        self.identity_substs = InternalSubsts::identity_for_item(self.tcx, item_def_id);\n-\n-        let body = self.tcx.hir().body(body_id);\n-\n-        let tcx = self.tcx;\n-        let param_env = self.param_env;\n-        let region_scope_tree = self.tcx.region_scope_tree(item_def_id);\n-        let tables = self.tables;\n-        euv::ExprUseVisitor::new(\n-            self,\n-            tcx,\n-            item_def_id,\n-            param_env,\n-            &region_scope_tree,\n-            tables,\n-            None,\n-        ).consume_body(body);\n-\n-        let body_promotable = self.check_expr(&body.value);\n-        self.in_fn = outer_in_fn;\n-        self.tables = outer_tables;\n-        self.param_env = outer_param_env;\n-        self.identity_substs = outer_identity_substs;\n-        body_promotable\n-    }\n-\n-    fn check_stmt(&mut self, stmt: &'tcx hir::Stmt) -> Promotability {\n-        match stmt.kind {\n-            hir::StmtKind::Local(ref local) => {\n-                if self.remove_mut_rvalue_borrow(&local.pat) {\n-                    if let Some(init) = &local.init {\n-                        self.mut_rvalue_borrows.insert(init.hir_id);\n-                    }\n-                }\n-\n-                if let Some(ref expr) = local.init {\n-                    let _ = self.check_expr(&expr);\n-                }\n-                NotPromotable\n-            }\n-            // Item statements are allowed\n-            hir::StmtKind::Item(..) => Promotable,\n-            hir::StmtKind::Expr(ref box_expr) |\n-            hir::StmtKind::Semi(ref box_expr) => {\n-                let _ = self.check_expr(box_expr);\n-                NotPromotable\n-            }\n-        }\n-    }\n-\n-    fn check_expr(&mut self, ex: &'tcx hir::Expr) -> Promotability {\n-        let node_ty = self.tables.node_type(ex.hir_id);\n-        let mut outer = check_expr_kind(self, ex, node_ty);\n-        outer &= check_adjustments(self, ex);\n-\n-        // Handle borrows on (or inside the autorefs of) this expression.\n-        if self.mut_rvalue_borrows.remove(&ex.hir_id) {\n-            outer = NotPromotable\n-        }\n-\n-        if outer == Promotable {\n-            self.result.insert(ex.hir_id.local_id);\n-        }\n-        outer\n-    }\n-\n-    fn check_block(&mut self, block: &'tcx hir::Block) -> Promotability {\n-        let mut iter_result = Promotable;\n-        for index in block.stmts.iter() {\n-            iter_result &= self.check_stmt(index);\n-        }\n-        match block.expr {\n-            Some(ref box_expr) => iter_result & self.check_expr(&*box_expr),\n-            None => iter_result,\n-        }\n-    }\n-}\n-\n-/// This function is used to enforce the constraints on\n-/// const/static items. It walks through the *value*\n-/// of the item walking down the expression and evaluating\n-/// every nested expression. If the expression is not part\n-/// of a const/static item, it is qualified for promotion\n-/// instead of producing errors.\n-fn check_expr_kind<'a, 'tcx>(\n-    v: &mut CheckCrateVisitor<'a, 'tcx>,\n-    e: &'tcx hir::Expr, node_ty: Ty<'tcx>) -> Promotability {\n-\n-    let ty_result = match node_ty.kind {\n-        ty::Adt(def, _) if def.has_dtor(v.tcx) => {\n-            NotPromotable\n-        }\n-        _ => Promotable\n-    };\n-\n-    let kind_result = match e.kind {\n-        hir::ExprKind::Box(ref expr) => {\n-            let _ = v.check_expr(&expr);\n-            NotPromotable\n-        }\n-        hir::ExprKind::Unary(op, ref expr) => {\n-            let expr_promotability = v.check_expr(expr);\n-            if v.tables.is_method_call(e) || op == hir::UnDeref {\n-                return NotPromotable;\n-            }\n-            expr_promotability\n-        }\n-        hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-            let lefty = v.check_expr(lhs);\n-            let righty = v.check_expr(rhs);\n-            if v.tables.is_method_call(e) {\n-                return NotPromotable;\n-            }\n-            match v.tables.node_type(lhs.hir_id).kind {\n-                ty::RawPtr(_) | ty::FnPtr(..) => {\n-                    assert!(op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne ||\n-                            op.node == hir::BinOpKind::Le || op.node == hir::BinOpKind::Lt ||\n-                            op.node == hir::BinOpKind::Ge || op.node == hir::BinOpKind::Gt);\n-\n-                    NotPromotable\n-                }\n-                _ => lefty & righty\n-            }\n-        }\n-        hir::ExprKind::Cast(ref from, _) => {\n-            let expr_promotability = v.check_expr(from);\n-            debug!(\"checking const cast(id={})\", from.hir_id);\n-            let cast_in = CastTy::from_ty(v.tables.expr_ty(from));\n-            let cast_out = CastTy::from_ty(v.tables.expr_ty(e));\n-            match (cast_in, cast_out) {\n-                (Some(CastTy::FnPtr), Some(CastTy::Int(_))) |\n-                (Some(CastTy::Ptr(_)), Some(CastTy::Int(_))) => NotPromotable,\n-                (_, _) => expr_promotability\n-            }\n-        }\n-        hir::ExprKind::Path(ref qpath) => {\n-            let res = v.tables.qpath_res(qpath, e.hir_id);\n-            match res {\n-                Res::Def(DefKind::Ctor(..), _)\n-                | Res::Def(DefKind::Fn, _)\n-                | Res::Def(DefKind::Method, _)\n-                | Res::SelfCtor(..) =>\n-                    Promotable,\n-\n-                // References to a static that are themselves within a static\n-                // are inherently promotable with the exception\n-                //  of \"#[thread_local]\" statics, which may not\n-                // outlive the current function\n-                Res::Def(DefKind::Static, did) => {\n-\n-                    if v.in_static {\n-                        for attr in &v.tcx.get_attrs(did)[..] {\n-                            if attr.check_name(sym::thread_local) {\n-                                debug!(\"reference to `Static(id={:?})` is unpromotable \\\n-                                        due to a `#[thread_local]` attribute\", did);\n-                                return NotPromotable;\n-                            }\n-                        }\n-                        Promotable\n-                    } else {\n-                        debug!(\"reference to `Static(id={:?})` is unpromotable as it is not \\\n-                                referenced from a static\", did);\n-                        NotPromotable\n-                    }\n-                }\n-\n-                Res::Def(DefKind::Const, did) |\n-                Res::Def(DefKind::AssocConst, did) => {\n-                    let promotable = if v.tcx.trait_of_item(did).is_some() {\n-                        // Don't peek inside trait associated constants.\n-                        NotPromotable\n-                    } else if v.tcx.at(e.span).const_is_rvalue_promotable_to_static(did) {\n-                        Promotable\n-                    } else {\n-                        NotPromotable\n-                    };\n-                    // Just in case the type is more specific than the definition,\n-                    // e.g., impl associated const with type parameters, check it.\n-                    // Also, trait associated consts are relaxed by this.\n-                    promotable | v.type_promotability(node_ty)\n-                }\n-                _ => NotPromotable\n-            }\n-        }\n-        hir::ExprKind::Call(ref callee, ref hirvec) => {\n-            let mut call_result = v.check_expr(callee);\n-            for index in hirvec.iter() {\n-                call_result &= v.check_expr(index);\n-            }\n-            let mut callee = &**callee;\n-            loop {\n-                callee = match callee.kind {\n-                    hir::ExprKind::Block(ref block, _) => match block.expr {\n-                        Some(ref tail) => &tail,\n-                        None => break\n-                    },\n-                    _ => break\n-                };\n-            }\n-            // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n-            let def = if let hir::ExprKind::Path(ref qpath) = callee.kind {\n-                v.tables.qpath_res(qpath, callee.hir_id)\n-            } else {\n-                Res::Err\n-            };\n-            let def_result = match def {\n-                Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) |\n-                Res::SelfCtor(..) => Promotable,\n-                Res::Def(DefKind::Fn, did) => v.handle_const_fn_call(did),\n-                Res::Def(DefKind::Method, did) => {\n-                    match v.tcx.associated_item(did).container {\n-                        ty::ImplContainer(_) => v.handle_const_fn_call(did),\n-                        ty::TraitContainer(_) => NotPromotable,\n-                    }\n-                }\n-                _ => NotPromotable,\n-            };\n-            def_result & call_result\n-        }\n-        hir::ExprKind::MethodCall(ref _pathsegment, ref _span, ref hirvec) => {\n-            let mut method_call_result = Promotable;\n-            for index in hirvec.iter() {\n-                method_call_result &= v.check_expr(index);\n-            }\n-            if let Some(def_id) = v.tables.type_dependent_def_id(e.hir_id) {\n-                match v.tcx.associated_item(def_id).container {\n-                    ty::ImplContainer(_) => method_call_result & v.handle_const_fn_call(def_id),\n-                    ty::TraitContainer(_) => NotPromotable,\n-                }\n-            } else {\n-                v.tcx.sess.delay_span_bug(e.span, \"no type-dependent def for method call\");\n-                NotPromotable\n-            }\n-        }\n-        hir::ExprKind::Struct(ref _qpath, ref hirvec, ref option_expr) => {\n-            let mut struct_result = Promotable;\n-            for index in hirvec.iter() {\n-                struct_result &= v.check_expr(&index.expr);\n-            }\n-            if let Some(ref expr) = *option_expr {\n-                struct_result &= v.check_expr(&expr);\n-            }\n-            if let ty::Adt(adt, ..) = v.tables.expr_ty(e).kind {\n-                // unsafe_cell_type doesn't necessarily exist with no_core\n-                if Some(adt.did) == v.tcx.lang_items().unsafe_cell_type() {\n-                    return NotPromotable;\n-                }\n-            }\n-            struct_result\n-        }\n-\n-        hir::ExprKind::Lit(_) |\n-        hir::ExprKind::Err => Promotable,\n-\n-        hir::ExprKind::AddrOf(_, ref expr) |\n-        hir::ExprKind::Repeat(ref expr, _) |\n-        hir::ExprKind::Type(ref expr, _) |\n-        hir::ExprKind::DropTemps(ref expr) => {\n-            v.check_expr(&expr)\n-        }\n-\n-        hir::ExprKind::Closure(_capture_clause, ref _box_fn_decl,\n-                               body_id, _span, _option_generator_movability) => {\n-            let nested_body_promotable = v.check_nested_body(body_id);\n-            // Paths in constant contexts cannot refer to local variables,\n-            // as there are none, and thus closures can't have upvars there.\n-            let closure_def_id = v.tcx.hir().local_def_id(e.hir_id);\n-            if !v.tcx.upvars(closure_def_id).map_or(true, |v| v.is_empty()) {\n-                NotPromotable\n-            } else {\n-                nested_body_promotable\n-            }\n-        }\n-\n-        hir::ExprKind::Field(ref expr, _ident) => {\n-            let expr_promotability = v.check_expr(&expr);\n-            if let Some(def) = v.tables.expr_ty(expr).ty_adt_def() {\n-                if def.is_union() {\n-                    return NotPromotable;\n-                }\n-            }\n-            expr_promotability\n-        }\n-\n-        hir::ExprKind::Block(ref box_block, ref _option_label) => {\n-            v.check_block(box_block)\n-        }\n-\n-        hir::ExprKind::Index(ref lhs, ref rhs) => {\n-            let lefty = v.check_expr(lhs);\n-            let righty = v.check_expr(rhs);\n-            if v.tables.is_method_call(e) {\n-                return NotPromotable;\n-            }\n-            lefty & righty\n-        }\n-\n-        hir::ExprKind::Array(ref hirvec) => {\n-            let mut array_result = Promotable;\n-            for index in hirvec.iter() {\n-                array_result &= v.check_expr(index);\n-            }\n-            array_result\n-        }\n-\n-        hir::ExprKind::Tup(ref hirvec) => {\n-            let mut tup_result = Promotable;\n-            for index in hirvec.iter() {\n-                tup_result &= v.check_expr(index);\n-            }\n-            tup_result\n-        }\n-\n-        // Conditional control flow (possible to implement).\n-        hir::ExprKind::Match(ref expr, ref arms, ref _match_source) => {\n-            // Compute the most demanding borrow from all the arms'\n-            // patterns and set that on the discriminator.\n-            if arms.iter().fold(false, |_, arm| v.remove_mut_rvalue_borrow(&arm.pat)) {\n-                v.mut_rvalue_borrows.insert(expr.hir_id);\n-            }\n-\n-            let _ = v.check_expr(expr);\n-            for index in arms.iter() {\n-                let _ = v.check_expr(&*index.body);\n-                if let Some(hir::Guard::If(ref expr)) = index.guard {\n-                    let _ = v.check_expr(&expr);\n-                }\n-            }\n-            NotPromotable\n-        }\n-\n-        hir::ExprKind::Loop(ref box_block, ref _option_label, ref _loop_source) => {\n-            let _ = v.check_block(box_block);\n-            NotPromotable\n-        }\n-\n-        // More control flow (also not very meaningful).\n-        hir::ExprKind::Break(_, ref option_expr) | hir::ExprKind::Ret(ref option_expr) => {\n-            if let Some(ref expr) = *option_expr {\n-                 let _ = v.check_expr(&expr);\n-            }\n-            NotPromotable\n-        }\n-\n-        hir::ExprKind::Continue(_) => {\n-            NotPromotable\n-        }\n-\n-        // Generator expressions\n-        hir::ExprKind::Yield(ref expr, _) => {\n-            let _ = v.check_expr(&expr);\n-            NotPromotable\n-        }\n-\n-        // Expressions with side-effects.\n-        hir::ExprKind::AssignOp(_, ref lhs, ref rhs) | hir::ExprKind::Assign(ref lhs, ref rhs) => {\n-            let _ = v.check_expr(lhs);\n-            let _ = v.check_expr(rhs);\n-            NotPromotable\n-        }\n-\n-        hir::ExprKind::InlineAsm(ref _inline_asm, ref hirvec_lhs, ref hirvec_rhs) => {\n-            for index in hirvec_lhs.iter().chain(hirvec_rhs.iter()) {\n-                let _ = v.check_expr(index);\n-            }\n-            NotPromotable\n-        }\n-    };\n-    ty_result & kind_result\n-}\n-\n-/// Checks the adjustments of an expression.\n-fn check_adjustments<'a, 'tcx>(\n-    v: &mut CheckCrateVisitor<'a, 'tcx>,\n-    e: &hir::Expr) -> Promotability {\n-    use rustc::ty::adjustment::*;\n-\n-    let mut adjustments = v.tables.expr_adjustments(e).iter().peekable();\n-    while let Some(adjustment) = adjustments.next() {\n-        match adjustment.kind {\n-            Adjust::NeverToAny |\n-            Adjust::Pointer(_) |\n-            Adjust::Borrow(_) => {}\n-\n-            Adjust::Deref(_) => {\n-                if let Some(next_adjustment) = adjustments.peek() {\n-                    if let Adjust::Borrow(_) = next_adjustment.kind {\n-                        continue;\n-                    }\n-                }\n-                return NotPromotable;\n-            }\n-        }\n-    }\n-    Promotable\n-}\n-\n-impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n-    fn consume(&mut self,\n-               _consume_id: hir::HirId,\n-               _consume_span: Span,\n-               _cmt: &mc::cmt_<'_>,\n-               _mode: euv::ConsumeMode) {}\n-\n-    fn borrow(&mut self,\n-              borrow_id: hir::HirId,\n-              _borrow_span: Span,\n-              cmt: &mc::cmt_<'tcx>,\n-              _loan_region: ty::Region<'tcx>,\n-              bk: ty::BorrowKind,\n-              loan_cause: euv::LoanCause) {\n-        debug!(\n-            \"borrow(borrow_id={:?}, cmt={:?}, bk={:?}, loan_cause={:?})\",\n-            borrow_id,\n-            cmt,\n-            bk,\n-            loan_cause,\n-        );\n-\n-        // Kind of hacky, but we allow Unsafe coercions in constants.\n-        // These occur when we convert a &T or *T to a *U, as well as\n-        // when making a thin pointer (e.g., `*T`) into a fat pointer\n-        // (e.g., `*Trait`).\n-        if let euv::LoanCause::AutoUnsafe = loan_cause {\n-            return;\n-        }\n-\n-        let mut cur = cmt;\n-        loop {\n-            match cur.cat {\n-                Categorization::ThreadLocal(..) |\n-                Categorization::Rvalue(..) => {\n-                    if loan_cause == euv::MatchDiscriminant {\n-                        // Ignore the dummy immutable borrow created by EUV.\n-                        break;\n-                    }\n-                    if bk.to_mutbl_lossy() == hir::MutMutable {\n-                        self.mut_rvalue_borrows.insert(borrow_id);\n-                    }\n-                    break;\n-                }\n-                Categorization::StaticItem => {\n-                    break;\n-                }\n-                Categorization::Deref(ref cmt, _) |\n-                Categorization::Downcast(ref cmt, _) |\n-                Categorization::Interior(ref cmt, _) => {\n-                    cur = cmt;\n-                }\n-\n-                Categorization::Upvar(..) |\n-                Categorization::Local(..) => break,\n-            }\n-        }\n-    }\n-\n-    fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) {}\n-    fn mutate(&mut self,\n-              _assignment_id: hir::HirId,\n-              _assignment_span: Span,\n-              _assignee_cmt: &mc::cmt_<'_>,\n-              _mode: euv::MutateMode) {\n-    }\n-\n-    fn matched_pat(&mut self, _: &hir::Pat, _: &mc::cmt_<'_>, _: euv::MatchMode) {}\n-\n-    fn consume_pat(&mut self,\n-                   _consume_pat: &hir::Pat,\n-                   _cmt: &mc::cmt_<'_>,\n-                   _mode: euv::ConsumeMode) {}\n-}"}, {"sha": "13bbe021ccf34417e89f74300a5dfd7fd4e31017", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -266,7 +266,10 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n             let closure_ty = generic_types::closure(tcx, def_id);\n             let upvar_tys: Vec<_> = match &closure_ty.kind {\n                 ty::Closure(_, substs) => {\n-                    substs.upvar_tys(def_id, tcx).map(|ty| GenericArg::from(ty)).collect()\n+                    substs.as_closure()\n+                          .upvar_tys(def_id, tcx)\n+                          .map(|ty| GenericArg::from(ty))\n+                          .collect()\n                 },\n                 _ => bug!(),\n             };"}, {"sha": "7db1a7413c7be27351560ea7a5555cdeda478388", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -193,7 +193,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n             .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty.expect_ty()))\n             .collect(),\n \n-        ty::Closure(def_id, substs) => substs\n+        ty::Closure(def_id, substs) => substs.as_closure()\n             .upvar_tys(def_id, tcx)\n             .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n             .collect(),"}, {"sha": "91ca6415bdcb94b84e0d9307ebbbb0ce6aef6f51", "filename": "src/librustc_traits/generic_types.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_traits%2Fgeneric_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_traits%2Fgeneric_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fgeneric_types.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -69,9 +69,7 @@ crate fn fn_def(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'tcx> {\n }\n \n crate fn closure(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'tcx> {\n-    tcx.mk_closure(def_id, ty::ClosureSubsts {\n-        substs: InternalSubsts::bound_vars_for_item(tcx, def_id),\n-    })\n+    tcx.mk_closure(def_id, InternalSubsts::bound_vars_for_item(tcx, def_id))\n }\n \n crate fn generator(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'tcx> {"}, {"sha": "300b730b5bbfad920eb9e02dcf475e3c06d95c12", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -7,6 +7,7 @@ use hir::def::Res;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::subst::SubstsRef;\n use rustc::{infer, traits};\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_target::spec::abi;\n@@ -480,7 +481,7 @@ pub struct DeferredCallResolution<'tcx> {\n     adjustments: Vec<Adjustment<'tcx>>,\n     fn_sig: ty::FnSig<'tcx>,\n     closure_def_id: DefId,\n-    closure_substs: ty::ClosureSubsts<'tcx>,\n+    closure_substs: SubstsRef<'tcx>,\n }\n \n impl<'a, 'tcx> DeferredCallResolution<'tcx> {"}, {"sha": "03f0860c6605589637bcc7ba68bbd77621bc2a94", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -132,7 +132,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return self.tcx.mk_generator(expr_def_id, substs, movability);\n         }\n \n-        let substs = ty::ClosureSubsts { substs };\n         let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n \n         debug!(\n@@ -161,14 +160,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.demand_eqtype(\n             expr.span,\n             sig_fn_ptr_ty,\n-            substs.closure_sig_ty(expr_def_id, self.tcx),\n+            substs.as_closure().sig_ty(expr_def_id, self.tcx),\n         );\n \n         if let Some(kind) = opt_kind {\n             self.demand_eqtype(\n                 expr.span,\n                 kind.to_ty(self.tcx),\n-                substs.closure_kind_ty(expr_def_id, self.tcx),\n+                substs.as_closure().kind_ty(expr_def_id, self.tcx),\n             );\n         }\n "}, {"sha": "3a89cddda2362c8b47eff94d3e9d5cab6eef876f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -61,7 +61,7 @@ use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{\n     Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast\n };\n-use rustc::ty::{self, TypeAndMut, Ty, ClosureSubsts};\n+use rustc::ty::{self, TypeAndMut, Ty, subst::SubstsRef};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n use rustc::ty::relate::RelateResult;\n@@ -727,7 +727,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     fn coerce_closure_to_fn(&self,\n                            a: Ty<'tcx>,\n                            def_id_a: DefId,\n-                           substs_a: ClosureSubsts<'tcx>,\n+                           substs_a: SubstsRef<'tcx>,\n                            b: Ty<'tcx>)\n                            -> CoerceResult<'tcx> {\n         //! Attempts to coerce from the type of a non-capturing closure"}, {"sha": "d46ac4a39a33765866decdc23cf54e1016a7f5f3", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 9, "deletions": 75, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -3,10 +3,10 @@ use crate::check::regionck::RegionCtxt;\n use crate::hir;\n use crate::hir::def_id::DefId;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n-use rustc::infer::{self, InferOk, SuppressRegionErrors};\n+use rustc::infer::{InferOk, SuppressRegionErrors};\n use rustc::middle::region;\n use rustc::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n-use rustc::ty::subst::{Subst, SubstsRef, GenericArgKind};\n+use rustc::ty::subst::{Subst, SubstsRef};\n use rustc::ty::{self, Ty, TyCtxt};\n use crate::util::common::ErrorReported;\n \n@@ -233,87 +233,21 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     result\n }\n \n-/// This function confirms that the type\n-/// expression `typ` conforms to the \"Drop Check Rule\" from the Sound\n-/// Generic Drop RFC (#769).\n-///\n-/// ----\n-///\n-/// The simplified (*) Drop Check Rule is the following:\n-///\n-/// Let `v` be some value (either temporary or named) and 'a be some\n-/// lifetime (scope). If the type of `v` owns data of type `D`, where\n-///\n-/// * (1.) `D` has a lifetime- or type-parametric Drop implementation,\n-///        (where that `Drop` implementation does not opt-out of\n-///         this check via the `may_dangle`\n-///         attribute), and\n-/// * (2.) the structure of `D` can reach a reference of type `&'a _`,\n-///\n-/// then 'a must strictly outlive the scope of v.\n-///\n-/// ----\n-///\n-/// This function is meant to by applied to the type for every\n-/// expression in the program.\n-///\n-/// ----\n-///\n-/// (*) The qualifier \"simplified\" is attached to the above\n-/// definition of the Drop Check Rule, because it is a simplification\n-/// of the original Drop Check rule, which attempted to prove that\n-/// some `Drop` implementations could not possibly access data even if\n-/// it was technically reachable, due to parametricity.\n-///\n-/// However, (1.) parametricity on its own turned out to be a\n-/// necessary but insufficient condition, and (2.)  future changes to\n-/// the language are expected to make it impossible to ensure that a\n-/// `Drop` implementation is actually parametric with respect to any\n-/// particular type parameter. (In particular, impl specialization is\n-/// expected to break the needed parametricity property beyond\n-/// repair.)\n-///\n-/// Therefore, we have scaled back Drop-Check to a more conservative\n-/// rule that does not attempt to deduce whether a `Drop`\n-/// implementation could not possible access data of a given lifetime;\n-/// instead Drop-Check now simply assumes that if a destructor has\n-/// access (direct or indirect) to a lifetime parameter, then that\n-/// lifetime must be forced to outlive that destructor's dynamic\n-/// extent. We then provide the `may_dangle`\n-/// attribute as a way for destructor implementations to opt-out of\n-/// this conservative assumption (and thus assume the obligation of\n-/// ensuring that they do not access data nor invoke methods of\n-/// values that have been previously dropped).\n-pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(\n+/// This function is not only checking that the dropck obligations are met for\n+/// the given type, but it's also currently preventing non-regular recursion in\n+/// types from causing stack overflows (dropck_no_diverge_on_nonregular_*.rs).\n+crate fn check_drop_obligations<'a, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'tcx>,\n     ty: Ty<'tcx>,\n     span: Span,\n     body_id: hir::HirId,\n-    scope: region::Scope,\n ) -> Result<(), ErrorReported> {\n-    debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n-           ty, scope);\n+    debug!(\"check_drop_obligations typ: {:?}\", ty);\n \n-    let parent_scope = match rcx.region_scope_tree.opt_encl_scope(scope) {\n-        Some(parent_scope) => parent_scope,\n-        // If no enclosing scope, then it must be the root scope\n-        // which cannot be outlived.\n-        None => return Ok(()),\n-    };\n-    let parent_scope = rcx.tcx.mk_region(ty::ReScope(parent_scope));\n-    let origin = || infer::SubregionOrigin::SafeDestructor(span);\n     let cause = &ObligationCause::misc(span, body_id);\n     let infer_ok = rcx.infcx.at(cause, rcx.fcx.param_env).dropck_outlives(ty);\n     debug!(\"dropck_outlives = {:#?}\", infer_ok);\n-    let kinds = rcx.fcx.register_infer_ok_obligations(infer_ok);\n-    for kind in kinds {\n-        match kind.unpack() {\n-            GenericArgKind::Lifetime(r) => rcx.sub_regions(origin(), parent_scope, r),\n-            GenericArgKind::Type(ty) => rcx.type_must_outlive(origin(), ty, parent_scope),\n-            GenericArgKind::Const(_) => {\n-                // Generic consts don't add constraints.\n-            }\n-        }\n-    }\n+    rcx.fcx.register_infer_ok_obligations(infer_ok);\n+\n     Ok(())\n }"}, {"sha": "7380bf7536de587f76ddd6cebbb51cedd2b832cd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -4217,7 +4217,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Closure(def_id, substs) => {\n                 // We don't use `closure_sig` to account for malformed closures like\n                 // `|_: [_; continue]| {}` and instead we don't suggest anything.\n-                let closure_sig_ty = substs.closure_sig_ty(def_id, self.tcx);\n+                let closure_sig_ty = substs.as_closure().sig_ty(def_id, self.tcx);\n                 (def_id, match closure_sig_ty.kind {\n                     ty::FnPtr(sig) => sig,\n                     _ => return false,"}, {"sha": "2f9091282b7075762501f2fa672878350e17dd0f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 16, "deletions": 38, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -347,13 +347,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         );\n         self.outlives_environment\n             .save_implied_bounds(body_id.hir_id);\n-        self.link_fn_params(\n-            region::Scope {\n-                id: body.value.hir_id.local_id,\n-                data: region::ScopeData::Node,\n-            },\n-            &body.params,\n-        );\n+        self.link_fn_params(&body.params);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.hir_id);\n \n@@ -430,8 +424,8 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n             let typ = self.resolve_node_type(hir_id);\n             let body_id = self.body_id;\n-            let _ = dropck::check_safety_of_destructor_if_necessary(\n-                self, typ, span, body_id, var_scope,\n+            let _ = dropck::check_drop_obligations(\n+                self, typ, span, body_id,\n             );\n         })\n     }\n@@ -928,29 +922,15 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     }\n \n     fn check_safety_of_rvalue_destructor_if_necessary(&mut self, cmt: &mc::cmt_<'tcx>, span: Span) {\n-        if let Categorization::Rvalue(region) = cmt.cat {\n-            match *region {\n-                ty::ReScope(rvalue_scope) => {\n-                    let typ = self.resolve_type(cmt.ty);\n-                    let body_id = self.body_id;\n-                    let _ = dropck::check_safety_of_destructor_if_necessary(\n-                        self,\n-                        typ,\n-                        span,\n-                        body_id,\n-                        rvalue_scope,\n-                    );\n-                }\n-                ty::ReStatic => {}\n-                _ => {\n-                    span_bug!(\n-                        span,\n-                        \"unexpected rvalue region in rvalue \\\n-                         destructor safety checking: `{:?}`\",\n-                        region\n-                    );\n-                }\n-            }\n+        if let Categorization::Rvalue = cmt.cat {\n+            let typ = self.resolve_type(cmt.ty);\n+            let body_id = self.body_id;\n+            let _ = dropck::check_drop_obligations(\n+                self,\n+                typ,\n+                span,\n+                body_id,\n+            );\n         }\n     }\n \n@@ -1074,13 +1054,11 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n-    fn link_fn_params(&self, body_scope: region::Scope, params: &[hir::Param]) {\n-        debug!(\"regionck::link_fn_params(body_scope={:?})\", body_scope);\n+    fn link_fn_params(&self, params: &[hir::Param]) {\n         for param in params {\n             let param_ty = self.node_ty(param.hir_id);\n-            let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n             let param_cmt = self.with_mc(|mc| {\n-                Rc::new(mc.cat_rvalue(param.hir_id, param.pat.span, re_scope, param_ty))\n+                Rc::new(mc.cat_rvalue(param.hir_id, param.pat.span, param_ty))\n             });\n             debug!(\"param_ty={:?} param_cmt={:?} param={:?}\", param_ty, param_cmt, param);\n             self.link_pattern(param_cmt, &param.pat);\n@@ -1222,8 +1200,8 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                 | Categorization::StaticItem\n                 | Categorization::Upvar(..)\n                 | Categorization::Local(..)\n-                | Categorization::ThreadLocal(..)\n-                | Categorization::Rvalue(..) => {\n+                | Categorization::ThreadLocal\n+                | Categorization::Rvalue => {\n                     // These are all \"base cases\" with independent lifetimes\n                     // that are not subject to inference\n                     return;"}, {"sha": "97e59664df0c06b63bf9bd162298ee607563682b", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 15, "deletions": 54, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -96,7 +96,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Extract the type of the closure.\n         let ty = self.node_ty(closure_hir_id);\n         let (closure_def_id, substs) = match ty.kind {\n-            ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n+            ty::Closure(def_id, substs) => (\n+                def_id,\n+                UpvarSubsts::Closure(substs)\n+            ),\n             ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n             ty::Error => {\n                 // #51714: skip analysis when we have already encountered type errors\n@@ -190,7 +193,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Unify the (as yet unbound) type variable in the closure\n             // substs with the kind we inferred.\n             let inferred_kind = delegate.current_closure_kind;\n-            let closure_kind_ty = closure_substs.closure_kind_ty(closure_def_id, self.tcx);\n+            let closure_kind_ty = closure_substs\n+                .as_closure().kind_ty(closure_def_id, self.tcx);\n             self.demand_eqtype(span, inferred_kind.to_ty(self.tcx), closure_kind_ty);\n \n             // If we have an origin, store it.\n@@ -321,7 +325,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             euv::Copy => {\n                 return;\n             }\n-            euv::Move(_) => {}\n+            euv::Move => {}\n         }\n \n         let tcx = self.fcx.tcx;\n@@ -408,8 +412,8 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n             Categorization::Deref(_, mc::UnsafePtr(..))\n             | Categorization::StaticItem\n-            | Categorization::ThreadLocal(..)\n-            | Categorization::Rvalue(..)\n+            | Categorization::ThreadLocal\n+            | Categorization::Rvalue\n             | Categorization::Local(_)\n             | Categorization::Upvar(..) => {\n                 return;\n@@ -439,8 +443,8 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n             Categorization::Deref(_, mc::UnsafePtr(..))\n             | Categorization::StaticItem\n-            | Categorization::ThreadLocal(..)\n-            | Categorization::Rvalue(..)\n+            | Categorization::ThreadLocal\n+            | Categorization::Rvalue\n             | Categorization::Local(_)\n             | Categorization::Upvar(..) => {}\n         }\n@@ -582,48 +586,13 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n-    fn consume(\n-        &mut self,\n-        _consume_id: hir::HirId,\n-        _consume_span: Span,\n-        cmt: &mc::cmt_<'tcx>,\n-        mode: euv::ConsumeMode,\n-    ) {\n+    fn consume(&mut self, cmt: &mc::cmt_<'tcx>,mode: euv::ConsumeMode) {\n         debug!(\"consume(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n-    fn matched_pat(\n-        &mut self,\n-        _matched_pat: &hir::Pat,\n-        _cmt: &mc::cmt_<'tcx>,\n-        _mode: euv::MatchMode,\n-    ) {\n-    }\n-\n-    fn consume_pat(\n-        &mut self,\n-        _consume_pat: &hir::Pat,\n-        cmt: &mc::cmt_<'tcx>,\n-        mode: euv::ConsumeMode,\n-    ) {\n-        debug!(\"consume_pat(cmt={:?},mode={:?})\", cmt, mode);\n-        self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n-    }\n-\n-    fn borrow(\n-        &mut self,\n-        borrow_id: hir::HirId,\n-        _borrow_span: Span,\n-        cmt: &mc::cmt_<'tcx>,\n-        _loan_region: ty::Region<'tcx>,\n-        bk: ty::BorrowKind,\n-        _loan_cause: euv::LoanCause,\n-    ) {\n-        debug!(\n-            \"borrow(borrow_id={}, cmt={:?}, bk={:?})\",\n-            borrow_id, cmt, bk\n-        );\n+    fn borrow(&mut self, cmt: &mc::cmt_<'tcx>, bk: ty::BorrowKind) {\n+        debug!(\"borrow(cmt={:?}, bk={:?})\", cmt, bk);\n \n         match bk {\n             ty::ImmBorrow => {}\n@@ -636,15 +605,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         }\n     }\n \n-    fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) {}\n-\n-    fn mutate(\n-        &mut self,\n-        _assignment_id: hir::HirId,\n-        _assignment_span: Span,\n-        assignee_cmt: &mc::cmt_<'tcx>,\n-        _mode: euv::MutateMode,\n-    ) {\n+    fn mutate(&mut self, assignee_cmt: &mc::cmt_<'tcx>) {\n         debug!(\"mutate(assignee_cmt={:?})\", assignee_cmt);\n \n         self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);"}, {"sha": "d973106058eafc37b5bc2ffe5ef615bf59780294", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1362,10 +1362,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                 return Some(tcx.typeck_tables_of(def_id).node_type(hir_id));\n             }\n \n-            let substs = ty::ClosureSubsts {\n-                substs: InternalSubsts::identity_for_item(tcx, def_id),\n-            };\n-\n+            let substs = InternalSubsts::identity_for_item(tcx, def_id);\n             tcx.mk_closure(def_id, substs)\n         }\n \n@@ -1858,7 +1855,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             // the signature of a closure, you should use the\n             // `closure_sig` method on the `ClosureSubsts`:\n             //\n-            //    closure_substs.closure_sig(def_id, tcx)\n+            //    closure_substs.sig(def_id, tcx)\n             //\n             // or, inside of an inference context, you can use\n             //"}, {"sha": "5f20367b6aba97e8c68dfcb74974fbe9a9c76cf5", "filename": "src/test/ui/async-await/async-borrowck-escaping-closure-error.polonius.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.polonius.stderr?ref=31d75c4e9c5318e880601d3c2cc71e5df094a120", "patch": "@@ -1,16 +0,0 @@\n-error[E0597]: `x` does not live long enough\n-  --> $DIR/async-borrowck-escaping-closure-error.rs:5:24\n-   |\n-LL |     Box::new((async || x)())\n-   |     -------------------^----\n-   |     |         |        |\n-   |     |         |        borrowed value does not live long enough\n-   |     |         value captured here\n-   |     borrow later used here\n-LL |\n-LL | }\n-   | - `x` dropped here while still borrowed\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0597`."}, {"sha": "89af8764557ff58e29428659c9e67dcc989b80d9", "filename": "src/test/ui/borrowck/borrowck-escaping-closure-error-2.polonius.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-escaping-closure-error-2.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-escaping-closure-error-2.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-escaping-closure-error-2.polonius.stderr?ref=31d75c4e9c5318e880601d3c2cc71e5df094a120", "patch": "@@ -1,16 +0,0 @@\n-error[E0597]: `books` does not live long enough\n-  --> $DIR/borrowck-escaping-closure-error-2.rs:11:17\n-   |\n-LL |     Box::new(|| books.push(4))\n-   |     ------------^^^^^---------\n-   |     |        |  |\n-   |     |        |  borrowed value does not live long enough\n-   |     |        value captured here\n-   |     borrow later used here\n-LL |\n-LL | }\n-   | - `books` dropped here while still borrowed\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0597`."}, {"sha": "a5b2e8762746c70deb6b760cf67cd9ce62b558d5", "filename": "src/test/ui/borrowck/promote-ref-mut-in-let-issue-46557.polonius.stderr", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.polonius.stderr?ref=31d75c4e9c5318e880601d3c2cc71e5df094a120", "patch": "@@ -1,59 +0,0 @@\n-error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/promote-ref-mut-in-let-issue-46557.rs:5:21\n-   |\n-LL |     let ref mut x = 1234543;\n-   |                     ^^^^^^^ creates a temporary which is freed while still in use\n-LL |     x\n-   |     - borrow later used here\n-LL | }\n-   | - temporary value is freed at the end of this statement\n-   |\n-   = note: consider using a `let` binding to create a longer lived value\n-\n-error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/promote-ref-mut-in-let-issue-46557.rs:10:25\n-   |\n-LL |     let (ref mut x, ) = (1234543, );\n-   |                         ^^^^^^^^^^^ creates a temporary which is freed while still in use\n-LL |     x\n-   |     - borrow later used here\n-LL | }\n-   | - temporary value is freed at the end of this statement\n-   |\n-   = note: consider using a `let` binding to create a longer lived value\n-\n-error[E0515]: cannot return value referencing temporary value\n-  --> $DIR/promote-ref-mut-in-let-issue-46557.rs:15:5\n-   |\n-LL |       match 1234543 {\n-   |       ^     ------- temporary value created here\n-   |  _____|\n-   | |\n-LL | |         ref mut x => x\n-LL | |     }\n-   | |_____^ returns a value referencing data owned by the current function\n-\n-error[E0515]: cannot return value referencing temporary value\n-  --> $DIR/promote-ref-mut-in-let-issue-46557.rs:21:5\n-   |\n-LL |       match (123443,) {\n-   |       ^     --------- temporary value created here\n-   |  _____|\n-   | |\n-LL | |         (ref mut x,) => x,\n-LL | |     }\n-   | |_____^ returns a value referencing data owned by the current function\n-\n-error[E0515]: cannot return reference to temporary value\n-  --> $DIR/promote-ref-mut-in-let-issue-46557.rs:27:5\n-   |\n-LL |     &mut 1234543\n-   |     ^^^^^-------\n-   |     |    |\n-   |     |    temporary value created here\n-   |     returns a reference to data owned by the current function\n-\n-error: aborting due to 5 previous errors\n-\n-Some errors have detailed explanations: E0515, E0716.\n-For more information about an error, try `rustc --explain E0515`."}, {"sha": "c818379762c9df661067128c0557dfab0b019a0b", "filename": "src/test/ui/borrowck/return-local-binding-from-desugaring.polonius.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fborrowck%2Freturn-local-binding-from-desugaring.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fborrowck%2Freturn-local-binding-from-desugaring.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Freturn-local-binding-from-desugaring.polonius.stderr?ref=31d75c4e9c5318e880601d3c2cc71e5df094a120", "patch": "@@ -1,16 +0,0 @@\n-error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/return-local-binding-from-desugaring.rs:26:18\n-   |\n-LL |     for ref x in xs {\n-   |                  ^^ creates a temporary which is freed while still in use\n-...\n-LL |     }\n-   |     - temporary value is freed at the end of this statement\n-LL |     result\n-   |     ------ borrow later used here\n-   |\n-   = note: consider using a `let` binding to create a longer lived value\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0716`."}, {"sha": "7b246426a23334c8e6fbf0b74bf38ed56bc7f0bc", "filename": "src/test/ui/borrowck/two-phase-surprise-no-conflict.polonius.stderr", "status": "removed", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.polonius.stderr?ref=31d75c4e9c5318e880601d3c2cc71e5df094a120", "patch": "@@ -1,148 +0,0 @@\n-error[E0503]: cannot use `self.cx` because it was mutably borrowed\n-  --> $DIR/two-phase-surprise-no-conflict.rs:21:23\n-   |\n-LL |         let _mut_borrow = &mut *self;\n-   |                           ---------- borrow of `*self` occurs here\n-LL |         let _access = self.cx;\n-   |                       ^^^^^^^ use of borrowed `*self`\n-LL |\n-LL |         _mut_borrow;\n-   |         ----------- borrow later used here\n-\n-error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable\n-  --> $DIR/two-phase-surprise-no-conflict.rs:57:17\n-   |\n-LL |                 self.hash_expr(&self.cx_mut.body(eid).value);\n-   |                 ^^^^^---------^^-----------^^^^^^^^^^^^^^^^^\n-   |                 |    |          |\n-   |                 |    |          immutable borrow occurs here\n-   |                 |    immutable borrow later used by call\n-   |                 mutable borrow occurs here\n-\n-error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n-  --> $DIR/two-phase-surprise-no-conflict.rs:119:51\n-   |\n-LL |     reg.register_static(Box::new(TrivialPass::new(&mut reg.sess_mut)));\n-   |     --- ---------------                           ^^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n-   |     |   |\n-   |     |   first borrow later used by call\n-   |     first mutable borrow occurs here\n-\n-error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n-  --> $DIR/two-phase-surprise-no-conflict.rs:122:54\n-   |\n-LL |     reg.register_bound(Box::new(TrivialPass::new_mut(&mut reg.sess_mut)));\n-   |     --- --------------                               ^^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n-   |     |   |\n-   |     |   first borrow later used by call\n-   |     first mutable borrow occurs here\n-\n-error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n-  --> $DIR/two-phase-surprise-no-conflict.rs:125:53\n-   |\n-LL |     reg.register_univ(Box::new(TrivialPass::new_mut(&mut reg.sess_mut)));\n-   |     --- -------------                               ^^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n-   |     |   |\n-   |     |   first borrow later used by call\n-   |     first mutable borrow occurs here\n-\n-error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n-  --> $DIR/two-phase-surprise-no-conflict.rs:128:44\n-   |\n-LL |     reg.register_ref(&TrivialPass::new_mut(&mut reg.sess_mut));\n-   |     --- ------------                       ^^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n-   |     |   |\n-   |     |   first borrow later used by call\n-   |     first mutable borrow occurs here\n-\n-error[E0502]: cannot borrow `*reg` as mutable because it is also borrowed as immutable\n-  --> $DIR/two-phase-surprise-no-conflict.rs:138:5\n-   |\n-LL |     reg.register_bound(Box::new(CapturePass::new(&reg.sess_mut)));\n-   |     ^^^^--------------^^^^^^^^^^^^^^^^^^^^^^^^^^^-------------^^^\n-   |     |   |                                        |\n-   |     |   |                                        immutable borrow occurs here\n-   |     |   immutable borrow later used by call\n-   |     mutable borrow occurs here\n-\n-error[E0502]: cannot borrow `*reg` as mutable because it is also borrowed as immutable\n-  --> $DIR/two-phase-surprise-no-conflict.rs:141:5\n-   |\n-LL |     reg.register_univ(Box::new(CapturePass::new(&reg.sess_mut)));\n-   |     ^^^^-------------^^^^^^^^^^^^^^^^^^^^^^^^^^^-------------^^^\n-   |     |   |                                       |\n-   |     |   |                                       immutable borrow occurs here\n-   |     |   immutable borrow later used by call\n-   |     mutable borrow occurs here\n-\n-error[E0502]: cannot borrow `*reg` as mutable because it is also borrowed as immutable\n-  --> $DIR/two-phase-surprise-no-conflict.rs:144:5\n-   |\n-LL |     reg.register_ref(&CapturePass::new(&reg.sess_mut));\n-   |     ^^^^------------^^^^^^^^^^^^^^^^^^^-------------^^\n-   |     |   |                              |\n-   |     |   |                              immutable borrow occurs here\n-   |     |   immutable borrow later used by call\n-   |     mutable borrow occurs here\n-\n-error[E0499]: cannot borrow `*reg` as mutable more than once at a time\n-  --> $DIR/two-phase-surprise-no-conflict.rs:154:5\n-   |\n-LL |     reg.register_bound(Box::new(CapturePass::new_mut(&mut reg.sess_mut)));\n-   |     ^^^^--------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-----------------^^^\n-   |     |   |                                            |\n-   |     |   |                                            first mutable borrow occurs here\n-   |     |   first borrow later used by call\n-   |     second mutable borrow occurs here\n-\n-error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n-  --> $DIR/two-phase-surprise-no-conflict.rs:154:54\n-   |\n-LL |     reg.register_bound(Box::new(CapturePass::new_mut(&mut reg.sess_mut)));\n-   |     --- --------------                               ^^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n-   |     |   |\n-   |     |   first borrow later used by call\n-   |     first mutable borrow occurs here\n-\n-error[E0499]: cannot borrow `*reg` as mutable more than once at a time\n-  --> $DIR/two-phase-surprise-no-conflict.rs:158:5\n-   |\n-LL |     reg.register_univ(Box::new(CapturePass::new_mut(&mut reg.sess_mut)));\n-   |     ^^^^-------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-----------------^^^\n-   |     |   |                                           |\n-   |     |   |                                           first mutable borrow occurs here\n-   |     |   first borrow later used by call\n-   |     second mutable borrow occurs here\n-\n-error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n-  --> $DIR/two-phase-surprise-no-conflict.rs:158:53\n-   |\n-LL |     reg.register_univ(Box::new(CapturePass::new_mut(&mut reg.sess_mut)));\n-   |     --- -------------                               ^^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n-   |     |   |\n-   |     |   first borrow later used by call\n-   |     first mutable borrow occurs here\n-\n-error[E0499]: cannot borrow `*reg` as mutable more than once at a time\n-  --> $DIR/two-phase-surprise-no-conflict.rs:162:5\n-   |\n-LL |     reg.register_ref(&CapturePass::new_mut(&mut reg.sess_mut));\n-   |     ^^^^------------^^^^^^^^^^^^^^^^^^^^^^^-----------------^^\n-   |     |   |                                  |\n-   |     |   |                                  first mutable borrow occurs here\n-   |     |   first borrow later used by call\n-   |     second mutable borrow occurs here\n-\n-error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n-  --> $DIR/two-phase-surprise-no-conflict.rs:162:44\n-   |\n-LL |     reg.register_ref(&CapturePass::new_mut(&mut reg.sess_mut));\n-   |     --- ------------                       ^^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n-   |     |   |\n-   |     |   first borrow later used by call\n-   |     first mutable borrow occurs here\n-\n-error: aborting due to 15 previous errors\n-\n-Some errors have detailed explanations: E0499, E0502, E0503.\n-For more information about an error, try `rustc --explain E0499`."}, {"sha": "cf41bd7bdb1ebb3b1502fa9a6c9bd3a2f2b609b2", "filename": "src/test/ui/consts/promote_const_let.polonius.stderr", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fconsts%2Fpromote_const_let.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fconsts%2Fpromote_const_let.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromote_const_let.polonius.stderr?ref=31d75c4e9c5318e880601d3c2cc71e5df094a120", "patch": "@@ -1,29 +0,0 @@\n-error[E0597]: `y` does not live long enough\n-  --> $DIR/promote_const_let.rs:4:9\n-   |\n-LL |     let x: &'static u32 = {\n-   |         - borrow later stored here\n-LL |         let y = 42;\n-LL |         &y\n-   |         ^^ borrowed value does not live long enough\n-LL |     };\n-   |     - `y` dropped here while still borrowed\n-\n-error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/promote_const_let.rs:6:28\n-   |\n-LL |       let x: &'static u32 = &{\n-   |  ____________------------____^\n-   | |            |\n-   | |            type annotation requires that borrow lasts for `'static`\n-LL | |         let y = 42;\n-LL | |         y\n-LL | |     };\n-   | |_____^ creates a temporary which is freed while still in use\n-LL |   }\n-   |   - temporary value is freed at the end of this statement\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0597, E0716.\n-For more information about an error, try `rustc --explain E0597`."}, {"sha": "5e93a0234259c154435e3cffd30e060a233403ce", "filename": "src/test/ui/dropck/dropck_trait_cycle_checked.polonius.stderr", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fdropck%2Fdropck_trait_cycle_checked.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fdropck%2Fdropck_trait_cycle_checked.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck_trait_cycle_checked.polonius.stderr?ref=31d75c4e9c5318e880601d3c2cc71e5df094a120", "patch": "@@ -1,78 +0,0 @@\n-error[E0597]: `o2` does not live long enough\n-  --> $DIR/dropck_trait_cycle_checked.rs:111:13\n-   |\n-LL |     o1.set0(&o2);\n-   |             ^^^ borrowed value does not live long enough\n-...\n-LL | }\n-   | -\n-   | |\n-   | `o2` dropped here while still borrowed\n-   | borrow might be used here, when `o1` is dropped and runs the destructor for type `std::boxed::Box<dyn Obj<'_>>`\n-   |\n-   = note: values in a scope are dropped in the opposite order they are defined\n-\n-error[E0597]: `o3` does not live long enough\n-  --> $DIR/dropck_trait_cycle_checked.rs:112:13\n-   |\n-LL |     o1.set1(&o3);\n-   |             ^^^ borrowed value does not live long enough\n-...\n-LL | }\n-   | -\n-   | |\n-   | `o3` dropped here while still borrowed\n-   | borrow might be used here, when `o1` is dropped and runs the destructor for type `std::boxed::Box<dyn Obj<'_>>`\n-   |\n-   = note: values in a scope are dropped in the opposite order they are defined\n-\n-error[E0597]: `o2` does not live long enough\n-  --> $DIR/dropck_trait_cycle_checked.rs:113:13\n-   |\n-LL |     let (o1, o2, o3): (Box<dyn Obj>, Box<dyn Obj>, Box<dyn Obj>) = (O::new(), O::new(), O::new());\n-   |                                                                               -------- cast requires that `o2` is borrowed for `'static`\n-...\n-LL |     o2.set0(&o2);\n-   |             ^^^ borrowed value does not live long enough\n-...\n-LL | }\n-   | - `o2` dropped here while still borrowed\n-\n-error[E0597]: `o3` does not live long enough\n-  --> $DIR/dropck_trait_cycle_checked.rs:114:13\n-   |\n-LL |     let (o1, o2, o3): (Box<dyn Obj>, Box<dyn Obj>, Box<dyn Obj>) = (O::new(), O::new(), O::new());\n-   |                                                                               -------- cast requires that `o3` is borrowed for `'static`\n-...\n-LL |     o2.set1(&o3);\n-   |             ^^^ borrowed value does not live long enough\n-...\n-LL | }\n-   | - `o3` dropped here while still borrowed\n-\n-error[E0597]: `o1` does not live long enough\n-  --> $DIR/dropck_trait_cycle_checked.rs:115:13\n-   |\n-LL |     o3.set0(&o1);\n-   |             ^^^ borrowed value does not live long enough\n-LL |     o3.set1(&o2);\n-LL | }\n-   | -\n-   | |\n-   | `o1` dropped here while still borrowed\n-   | borrow might be used here, when `o1` is dropped and runs the destructor for type `std::boxed::Box<dyn Obj<'_>>`\n-\n-error[E0597]: `o2` does not live long enough\n-  --> $DIR/dropck_trait_cycle_checked.rs:116:13\n-   |\n-LL |     let (o1, o2, o3): (Box<dyn Obj>, Box<dyn Obj>, Box<dyn Obj>) = (O::new(), O::new(), O::new());\n-   |                                                                                         -------- cast requires that `o2` is borrowed for `'static`\n-...\n-LL |     o3.set1(&o2);\n-   |             ^^^ borrowed value does not live long enough\n-LL | }\n-   | - `o2` dropped here while still borrowed\n-\n-error: aborting due to 6 previous errors\n-\n-For more information about this error, try `rustc --explain E0597`."}, {"sha": "530bf368f676e41476eb9948e91e939a268c5e97", "filename": "src/test/ui/generator/ref-escapes-but-not-over-yield.polonius.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.polonius.stderr?ref=31d75c4e9c5318e880601d3c2cc71e5df094a120", "patch": "@@ -1,20 +0,0 @@\n-error[E0597]: `b` does not live long enough\n-  --> $DIR/ref-escapes-but-not-over-yield.rs:11:13\n-   |\n-LL |       let mut b = move || {\n-   |  _________________-\n-LL | |         yield();\n-LL | |         let b = 5;\n-LL | |         a = &b;\n-   | |             ^^ borrowed value does not live long enough\n-LL | |\n-LL | |     };\n-   | |     -\n-   | |     |\n-   | |     `b` dropped here while still borrowed\n-   | |_____... and the borrow might be used here, when that temporary is dropped and runs the destructor for generator\n-   |       a temporary with access to the borrow is created here ...\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0597`."}, {"sha": "e476047a7a644358b1a9040183e6993c5d4a83d1", "filename": "src/test/ui/hrtb/due-to-where-clause.nll.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.nll.stderr?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/due-to-where-clause.rs:2:5\n+   |\n+LL |     test::<FooS>(&mut 42);\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "1afd15613b51c301643befc0db04542813a037c9", "filename": "src/test/ui/hrtb/due-to-where-clause.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1,6 +1,3 @@\n-// ignore-compare-mode-nll\n-// ^ This code works in nll mode.\n-\n fn main() {\n     test::<FooS>(&mut 42); //~ ERROR implementation of `Foo` is not general enough\n }"}, {"sha": "e4096ec059a6e9c52a488da06575525b2096344a", "filename": "src/test/ui/hrtb/due-to-where-clause.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.stderr?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1,5 +1,5 @@\n error: implementation of `Foo` is not general enough\n-  --> $DIR/due-to-where-clause.rs:5:5\n+  --> $DIR/due-to-where-clause.rs:2:5\n    |\n LL |     test::<FooS>(&mut 42);\n    |     ^^^^^^^^^^^^ implementation of `Foo` is not general enough"}, {"sha": "8fd67b19d6a5a7d16ea805481b211714f3dc9332", "filename": "src/test/ui/issues/issue-17252.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1,11 +1,11 @@\n-error[E0391]: cycle detected when processing `FOO`\n+error[E0391]: cycle detected when const checking `FOO`\n   --> $DIR/issue-17252.rs:1:20\n    |\n LL | const FOO: usize = FOO;\n    |                    ^^^\n    |\n-   = note: ...which again requires processing `FOO`, completing the cycle\n-note: cycle used when processing `main::{{constant}}#0`\n+   = note: ...which again requires const checking `FOO`, completing the cycle\n+note: cycle used when const checking `main::{{constant}}#0`\n   --> $DIR/issue-17252.rs:4:18\n    |\n LL |     let _x: [u8; FOO]; // caused stack overflow prior to fix"}, {"sha": "f2457774326ddb2a4d940e14b9430520e7ae52b2", "filename": "src/test/ui/issues/issue-23302-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1,10 +1,10 @@\n-error[E0391]: cycle detected when processing `X::A::{{constant}}#0`\n+error[E0391]: cycle detected when const checking `X::A::{{constant}}#0`\n   --> $DIR/issue-23302-1.rs:4:9\n    |\n LL |     A = X::A as isize,\n    |         ^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires processing `X::A::{{constant}}#0`, completing the cycle\n+   = note: ...which again requires const checking `X::A::{{constant}}#0`, completing the cycle\n note: cycle used when processing `X::A::{{constant}}#0`\n   --> $DIR/issue-23302-1.rs:4:9\n    |"}, {"sha": "c121c17b904ea19191fa8df2cd878a771aa9a34f", "filename": "src/test/ui/issues/issue-23302-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1,10 +1,10 @@\n-error[E0391]: cycle detected when processing `Y::A::{{constant}}#0`\n+error[E0391]: cycle detected when const checking `Y::A::{{constant}}#0`\n   --> $DIR/issue-23302-2.rs:4:9\n    |\n LL |     A = Y::B as isize,\n    |         ^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires processing `Y::A::{{constant}}#0`, completing the cycle\n+   = note: ...which again requires const checking `Y::A::{{constant}}#0`, completing the cycle\n note: cycle used when processing `Y::A::{{constant}}#0`\n   --> $DIR/issue-23302-2.rs:4:9\n    |"}, {"sha": "0229469f04140e670fe9a0ec689e03809b92a3d7", "filename": "src/test/ui/issues/issue-23302-3.stderr", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1,26 +1,20 @@\n-error[E0391]: cycle detected when const checking if rvalue is promotable to static `A`\n-  --> $DIR/issue-23302-3.rs:1:1\n-   |\n-LL | const A: i32 = B;\n-   | ^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires checking which parts of `A` are promotable to static...\n+error[E0391]: cycle detected when const checking `A`\n   --> $DIR/issue-23302-3.rs:1:16\n    |\n LL | const A: i32 = B;\n    |                ^\n-note: ...which requires const checking if rvalue is promotable to static `B`...\n-  --> $DIR/issue-23302-3.rs:3:1\n    |\n-LL | const B: i32 = A;\n-   | ^^^^^^^^^^^^^^^^^\n-note: ...which requires checking which parts of `B` are promotable to static...\n+note: ...which requires const checking `B`...\n   --> $DIR/issue-23302-3.rs:3:16\n    |\n LL | const B: i32 = A;\n    |                ^\n-   = note: ...which again requires const checking if rvalue is promotable to static `A`, completing the cycle\n-   = note: cycle used when running analysis passes on this crate\n+   = note: ...which again requires const checking `A`, completing the cycle\n+note: cycle used when processing `A`\n+  --> $DIR/issue-23302-3.rs:1:1\n+   |\n+LL | const A: i32 = B;\n+   | ^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "3866243914b89ad5e15434cbf36fa37da0cab535", "filename": "src/test/ui/issues/issue-36163.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1,15 +1,15 @@\n-error[E0391]: cycle detected when processing `Foo::B::{{constant}}#0`\n+error[E0391]: cycle detected when const checking `Foo::B::{{constant}}#0`\n   --> $DIR/issue-36163.rs:4:9\n    |\n LL |     B = A,\n    |         ^\n    |\n-note: ...which requires processing `A`...\n+note: ...which requires const checking `A`...\n   --> $DIR/issue-36163.rs:1:18\n    |\n LL | const A: isize = Foo::B as isize;\n    |                  ^^^^^^^^^^^^^^^\n-   = note: ...which again requires processing `Foo::B::{{constant}}#0`, completing the cycle\n+   = note: ...which again requires const checking `Foo::B::{{constant}}#0`, completing the cycle\n note: cycle used when processing `Foo::B::{{constant}}#0`\n   --> $DIR/issue-36163.rs:4:9\n    |"}, {"sha": "8087a3e139915aa74257189f25be6f828474e8b3", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -12,7 +12,6 @@ struct PartialInteriorMut {\n }\n \n #[rustc_mir(rustc_peek_indirectly_mutable,stop_after_dataflow)]\n-#[rustc_mir(borrowck_graphviz_postflow=\"indirect.dot\")]\n const BOO: i32 = {\n     let x = PartialInteriorMut {\n         zst: [],"}, {"sha": "0ae9a40c96aaaf577980973b3f6224da1cad2ab2", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1,5 +1,5 @@\n error: rustc_peek: bit not set\n-  --> $DIR/indirect-mutation-offset.rs:35:14\n+  --> $DIR/indirect-mutation-offset.rs:34:14\n    |\n LL |     unsafe { rustc_peek(x) };\n    |              ^^^^^^^^^^^^^"}, {"sha": "476d86cfba9c326082ff0bf7c7da9d9ddba9cba0", "filename": "src/test/ui/nll/get_default.polonius.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fnll%2Fget_default.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fnll%2Fget_default.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.polonius.stderr?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1,14 +1,17 @@\n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable\n   --> $DIR/get_default.rs:32:17\n    |\n+LL | fn err(map: &mut Map) -> &String {\n+   |             - let's call the lifetime of this reference `'1`\n+LL |     loop {\n LL |         match map.get() {\n    |               --- immutable borrow occurs here\n LL |             Some(v) => {\n LL |                 map.set(String::new()); // Both AST and MIR error here\n    |                 ^^^ mutable borrow occurs here\n LL |\n LL |                 return v;\n-   |                        - immutable borrow later used here\n+   |                        - returning this value requires that `*map` is borrowed for `'1`\n \n error: aborting due to previous error\n "}, {"sha": "eb8442b31d7c73b323076b65fee62c112f77bfa5", "filename": "src/test/ui/nll/loan_ends_mid_block_pair.polonius.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.polonius.stderr?ref=31d75c4e9c5318e880601d3c2cc71e5df094a120", "patch": "@@ -1,15 +0,0 @@\n-error[E0506]: cannot assign to `data.0` because it is borrowed\n-  --> $DIR/loan_ends_mid_block_pair.rs:12:5\n-   |\n-LL |     let c = &mut data.0;\n-   |             ----------- borrow of `data.0` occurs here\n-LL |     capitalize(c);\n-LL |     data.0 = 'e';\n-   |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n-...\n-LL |     capitalize(c);\n-   |                - borrow later used here\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0506`."}, {"sha": "1faf8e2212aab753c56bb043d1e5965d58b5d771", "filename": "src/test/ui/nll/polonius/polonius-smoke-test.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fpolonius-smoke-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fpolonius-smoke-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fpolonius-smoke-test.stderr?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -17,12 +17,14 @@ LL |     let w = y;\n error[E0505]: cannot move out of `x` because it is borrowed\n   --> $DIR/polonius-smoke-test.rs:19:13\n    |\n+LL | pub fn use_while_mut_fr(x: &mut i32) -> &mut i32 {\n+   |                            - let's call the lifetime of this reference `'1`\n LL |     let y = &mut *x;\n    |             ------- borrow of `*x` occurs here\n LL |     let z = x;\n    |             ^ move out of `x` occurs here\n LL |     y\n-   |     - borrow later used here\n+   |     - returning this value requires that `*x` is borrowed for `'1`\n \n error[E0505]: cannot move out of `s` because it is borrowed\n   --> $DIR/polonius-smoke-test.rs:43:5"}, {"sha": "e5a8e1e5c2fccd1c2c616f67941e42addffc000a", "filename": "src/test/ui/nll/promoted-liveness.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fnll%2Fpromoted-liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fnll%2Fpromoted-liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpromoted-liveness.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -0,0 +1,8 @@\n+// Test that promoted that have larger mir bodies than their containing function\n+// don't cause an ICE.\n+\n+// check-pass\n+\n+fn main() {\n+    &[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"];\n+}"}, {"sha": "8e3cf59cffb44392efef77e735cec8d45d4b0892", "filename": "src/test/ui/nll/return-ref-mut-issue-46557.polonius.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.polonius.stderr?ref=31d75c4e9c5318e880601d3c2cc71e5df094a120", "patch": "@@ -1,15 +0,0 @@\n-error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/return-ref-mut-issue-46557.rs:4:21\n-   |\n-LL |     let ref mut x = 1234543;\n-   |                     ^^^^^^^ creates a temporary which is freed while still in use\n-LL |     x\n-   |     - borrow later used here\n-LL | }\n-   | - temporary value is freed at the end of this statement\n-   |\n-   = note: consider using a `let` binding to create a longer lived value\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0716`."}, {"sha": "4b906f75149af30ca900d06094f67c4190775ccc", "filename": "src/test/ui/unboxed-closures/unboxed-closures-failed-recursive-fn-1.polonius.stderr", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-failed-recursive-fn-1.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31d75c4e9c5318e880601d3c2cc71e5df094a120/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-failed-recursive-fn-1.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-failed-recursive-fn-1.polonius.stderr?ref=31d75c4e9c5318e880601d3c2cc71e5df094a120", "patch": "@@ -1,60 +0,0 @@\n-error[E0597]: `factorial` does not live long enough\n-  --> $DIR/unboxed-closures-failed-recursive-fn-1.rs:15:17\n-   |\n-LL |     let f = |x: u32| -> u32 {\n-   |             --------------- value captured here\n-LL |         let g = factorial.as_ref().unwrap();\n-   |                 ^^^^^^^^^ borrowed value does not live long enough\n-...\n-LL | }\n-   | -\n-   | |\n-   | `factorial` dropped here while still borrowed\n-   | borrow might be used here, when `factorial` is dropped and runs the destructor for type `std::option::Option<std::boxed::Box<dyn std::ops::Fn(u32) -> u32>>`\n-\n-error[E0506]: cannot assign to `factorial` because it is borrowed\n-  --> $DIR/unboxed-closures-failed-recursive-fn-1.rs:20:5\n-   |\n-LL |     let f = |x: u32| -> u32 {\n-   |             --------------- borrow of `factorial` occurs here\n-LL |         let g = factorial.as_ref().unwrap();\n-   |                 --------- borrow occurs due to use in closure\n-...\n-LL |     factorial = Some(Box::new(f));\n-   |     ^^^^^^^^^\n-   |     |\n-   |     assignment to borrowed `factorial` occurs here\n-   |     borrow later used here\n-\n-error[E0597]: `factorial` does not live long enough\n-  --> $DIR/unboxed-closures-failed-recursive-fn-1.rs:28:17\n-   |\n-LL |     let f = |x: u32| -> u32 {\n-   |             --------------- value captured here\n-LL |         let g = factorial.as_ref().unwrap();\n-   |                 ^^^^^^^^^ borrowed value does not live long enough\n-...\n-LL | }\n-   | -\n-   | |\n-   | `factorial` dropped here while still borrowed\n-   | borrow might be used here, when `factorial` is dropped and runs the destructor for type `std::option::Option<std::boxed::Box<dyn std::ops::Fn(u32) -> u32>>`\n-\n-error[E0506]: cannot assign to `factorial` because it is borrowed\n-  --> $DIR/unboxed-closures-failed-recursive-fn-1.rs:33:5\n-   |\n-LL |     let f = |x: u32| -> u32 {\n-   |             --------------- borrow of `factorial` occurs here\n-LL |         let g = factorial.as_ref().unwrap();\n-   |                 --------- borrow occurs due to use in closure\n-...\n-LL |     factorial = Some(Box::new(f));\n-   |     ^^^^^^^^^\n-   |     |\n-   |     assignment to borrowed `factorial` occurs here\n-   |     borrow later used here\n-\n-error: aborting due to 4 previous errors\n-\n-Some errors have detailed explanations: E0506, E0597.\n-For more information about an error, try `rustc --explain E0506`."}, {"sha": "975209efb0c1ba2c63d6646fb9d79e0c622bffdf", "filename": "src/test/ui/use/use-meta-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fuse%2Fuse-meta-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fuse%2Fuse-meta-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-meta-mismatch.rs?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:can't find crate for `extra`\n+// error-pattern:can't find crate for `fake_crate`\n \n extern crate fake_crate as extra;\n "}, {"sha": "62b71fe8e12f497809f8795a6f026f7f60ad7ea0", "filename": "src/test/ui/use/use-meta-mismatch.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fuse%2Fuse-meta-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e35a2811d8c65e9473176b8656a3201b7e152c7/src%2Ftest%2Fui%2Fuse%2Fuse-meta-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-meta-mismatch.stderr?ref=9e35a2811d8c65e9473176b8656a3201b7e152c7", "patch": "@@ -1,4 +1,4 @@\n-error[E0463]: can't find crate for `extra`\n+error[E0463]: can't find crate for `fake_crate`\n   --> $DIR/use-meta-mismatch.rs:3:1\n    |\n LL | extern crate fake_crate as extra;"}]}