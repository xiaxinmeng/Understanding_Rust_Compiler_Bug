{"sha": "fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYmM5MTBkZGMwMGE5Yjg4MDcxYWFlMGFhMGQ5YmNlNjRhM2ExY2M=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-20T18:11:06Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-20T18:30:56Z"}, "message": "[OPT] Emit stack_{load,store} where possible", "tree": {"sha": "30ad01fc1163e463cdb58065009d43292633aaea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30ad01fc1163e463cdb58065009d43292633aaea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc", "html_url": "https://github.com/rust-lang/rust/commit/fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f5ef6172c520df95779e5da509989e8233053bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5ef6172c520df95779e5da509989e8233053bf", "html_url": "https://github.com/rust-lang/rust/commit/8f5ef6172c520df95779e5da509989e8233053bf"}], "stats": {"total": 108, "additions": 81, "deletions": 27}, "files": [{"sha": "3899dd15fa43d0f2711e1a6c1dbb906f65614a53", "filename": "src/pointer.rs", "status": "modified", "additions": 72, "deletions": 19, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc/src%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc/src%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpointer.rs?ref=fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc", "patch": "@@ -4,37 +4,58 @@ use cranelift::codegen::ir::immediates::Offset32;\n \n #[derive(Copy, Clone, Debug)]\n pub struct Pointer {\n-    base_addr: Value,\n+    base: PointerBase,\n     offset: Offset32,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+enum PointerBase {\n+    Addr(Value),\n+    Stack(StackSlot),\n+}\n+\n impl Pointer {\n     pub fn new(addr: Value) -> Self {\n         Pointer {\n-            base_addr: addr,\n+            base: PointerBase::Addr(addr),\n+            offset: Offset32::new(0),\n+        }\n+    }\n+\n+    pub fn stack_slot(stack_slot: StackSlot) -> Self {\n+        Pointer {\n+            base: PointerBase::Stack(stack_slot),\n             offset: Offset32::new(0),\n         }\n     }\n \n     pub fn const_addr<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx, impl Backend>, addr: i64) -> Self {\n         let addr = fx.bcx.ins().iconst(fx.pointer_type, addr);\n         Pointer {\n-            base_addr: addr,\n+            base: PointerBase::Addr(addr),\n             offset: Offset32::new(0),\n         }\n     }\n \n     pub fn get_addr<'a, 'tcx>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> Value {\n-        let offset: i64 = self.offset.into();\n-        if offset == 0 {\n-            self.base_addr\n-        } else {\n-            fx.bcx.ins().iadd_imm(self.base_addr, offset)\n+        match self.base {\n+            PointerBase::Addr(base_addr) => {\n+                let offset: i64 = self.offset.into();\n+                if offset == 0 {\n+                    base_addr\n+                } else {\n+                    fx.bcx.ins().iadd_imm(base_addr, offset)\n+                }\n+            }\n+            PointerBase::Stack(stack_slot) => fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, self.offset),\n         }\n     }\n \n-    pub fn get_addr_and_offset(self) -> (Value, Offset32) {\n-        (self.base_addr, self.offset)\n+    pub fn try_get_addr_and_offset(self) -> Option<(Value, Offset32)> {\n+        match self.base {\n+            PointerBase::Addr(addr) => Some((addr, self.offset)),\n+            PointerBase::Stack(_) => None,\n+        }\n     }\n \n     pub fn offset<'a, 'tcx>(\n@@ -52,15 +73,19 @@ impl Pointer {\n     ) -> Self {\n         if let Some(new_offset) = self.offset.try_add_i64(extra_offset) {\n             Pointer {\n-                base_addr: self.base_addr,\n+                base: self.base,\n                 offset: new_offset,\n             }\n         } else {\n             let base_offset: i64 = self.offset.into();\n             if let Some(new_offset) = base_offset.checked_add(extra_offset){\n-                let addr = fx.bcx.ins().iadd_imm(self.base_addr, new_offset);\n+                let base_addr = match self.base {\n+                    PointerBase::Addr(addr) => addr,\n+                    PointerBase::Stack(stack_slot) => fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n+                };\n+                let addr = fx.bcx.ins().iadd_imm(base_addr, new_offset);\n                 Pointer {\n-                    base_addr: addr,\n+                    base: PointerBase::Addr(addr),\n                     offset: Offset32::new(0),\n                 }\n             } else {\n@@ -74,10 +99,18 @@ impl Pointer {\n         fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n         extra_offset: Value,\n     ) -> Self {\n-        let base_addr = fx.bcx.ins().iadd(self.base_addr, extra_offset);\n-        Pointer {\n-            base_addr,\n-            offset: self.offset,\n+        match self.base {\n+            PointerBase::Addr(addr) => Pointer {\n+                base: PointerBase::Addr(fx.bcx.ins().iadd(addr, extra_offset)),\n+                offset: self.offset,\n+            },\n+            PointerBase::Stack(stack_slot) => {\n+                let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, self.offset);\n+                Pointer {\n+                    base: PointerBase::Addr(fx.bcx.ins().iadd(base_addr, extra_offset)),\n+                    offset: Offset32::new(0),\n+                }\n+            }\n         }\n     }\n \n@@ -87,7 +120,16 @@ impl Pointer {\n         ty: Type,\n         flags: MemFlags,\n     ) -> Value {\n-        fx.bcx.ins().load(ty, flags, self.base_addr, self.offset)\n+        match self.base {\n+            PointerBase::Addr(base_addr) => fx.bcx.ins().load(ty, flags, base_addr, self.offset),\n+            PointerBase::Stack(stack_slot) => if ty == types::I128 {\n+                // WORKAROUND for stack_load.i128 not being implemented\n+                let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n+                fx.bcx.ins().load(ty, flags, base_addr, self.offset)\n+            } else {\n+                fx.bcx.ins().stack_load(ty, stack_slot, self.offset)\n+            }\n+        }\n     }\n \n     pub fn store<'a, 'tcx>(\n@@ -96,6 +138,17 @@ impl Pointer {\n         value: Value,\n         flags: MemFlags,\n     ) {\n-        fx.bcx.ins().store(flags, value, self.base_addr, self.offset);\n+        match self.base {\n+            PointerBase::Addr(base_addr) => {\n+                fx.bcx.ins().store(flags, value, base_addr, self.offset);\n+            }\n+            PointerBase::Stack(stack_slot) => if fx.bcx.func.dfg.value_type(value) == types::I128 {\n+                // WORKAROUND for stack_load.i128 not being implemented\n+                let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n+                fx.bcx.ins().store(flags, value, base_addr, self.offset);\n+            } else {\n+                fx.bcx.ins().stack_store(value, stack_slot, self.offset);\n+            }\n+        }\n     }\n }"}, {"sha": "8a497df1e7e9327bf7d20756717b8de192677709", "filename": "src/value_and_place.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc", "patch": "@@ -103,9 +103,12 @@ impl<'tcx> CValue<'tcx> {\n     pub fn try_to_addr(self) -> Option<Value> {\n         match self.0 {\n             CValueInner::ByRef(ptr) => {\n-                let (base_addr, offset) = ptr.get_addr_and_offset();\n-                if offset == Offset32::new(0) {\n-                    Some(base_addr)\n+                if let Some((base_addr, offset)) = ptr.try_get_addr_and_offset() {\n+                    if offset == Offset32::new(0) {\n+                        Some(base_addr)\n+                    } else {\n+                        None\n+                    }\n                 } else {\n                     None\n                 }\n@@ -314,7 +317,7 @@ impl<'tcx> CPlace<'tcx> {\n                 CValue::by_ref(ptr, layout)\n             }\n             CPlaceInner::Stack(stack_slot) => CValue::by_ref(\n-                Pointer::new(fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0)),\n+                Pointer::stack_slot(stack_slot),\n                 layout,\n             ),\n             CPlaceInner::NoPlace => CValue::by_ref(\n@@ -338,7 +341,7 @@ impl<'tcx> CPlace<'tcx> {\n         match self.inner {\n             CPlaceInner::Addr(ptr, extra) => (ptr, extra),\n             CPlaceInner::Stack(stack_slot) => (\n-                Pointer::new(fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0)),\n+                Pointer::stack_slot(stack_slot),\n                 None,\n             ),\n             CPlaceInner::NoPlace => {\n@@ -428,9 +431,7 @@ impl<'tcx> CPlace<'tcx> {\n                 return;\n             }\n             CPlaceInner::Addr(ptr, None) => ptr,\n-            CPlaceInner::Stack(stack_slot) => {\n-                Pointer::new(fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0))\n-            }\n+            CPlaceInner::Stack(stack_slot) => Pointer::stack_slot(stack_slot),\n             CPlaceInner::NoPlace => {\n                 if dst_layout.abi != Abi::Uninhabited {\n                     assert_eq!(dst_layout.size.bytes(), 0, \"{:?}\", dst_layout);"}]}