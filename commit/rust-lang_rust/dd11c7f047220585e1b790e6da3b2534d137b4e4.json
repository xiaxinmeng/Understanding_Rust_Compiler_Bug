{"sha": "dd11c7f047220585e1b790e6da3b2534d137b4e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMTFjN2YwNDcyMjA1ODVlMWI3OTBlNmRhM2IyNTM0ZDEzN2I0ZTQ=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-05-13T04:52:49Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-05-13T04:52:49Z"}, "message": "Rollup merge of #25348 - geofft:trpl-fix-enums, r=steveklabnik\n\nThe enums chapter at the moment is ... weird. The examples aren't about enums, they're about structs, and most of the chapter talks about how enums don't support comparison operators by default (which is also true of other compound data types.) I think there was a story here once, but some coherency got lost in refactoring.\r\n\r\nThere are two preliminary patches here, one to combine the struct and tuple-struct chapters, and one to document unit-like structs, because enum syntax is easier to explain once you have those three. The final patch moves the enum chapter after the struct chapter, and rewrites most of it to talk about enums usefully (including covering matches on enums).\r\n\r\nr? @steveklabnik", "tree": {"sha": "ac90cb8261ac37254f6aa8a897d8ff4643174356", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac90cb8261ac37254f6aa8a897d8ff4643174356"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd11c7f047220585e1b790e6da3b2534d137b4e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd11c7f047220585e1b790e6da3b2534d137b4e4", "html_url": "https://github.com/rust-lang/rust/commit/dd11c7f047220585e1b790e6da3b2534d137b4e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd11c7f047220585e1b790e6da3b2534d137b4e4/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8c69e54061a6bfc964c588adebaf90a6b983581", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8c69e54061a6bfc964c588adebaf90a6b983581", "html_url": "https://github.com/rust-lang/rust/commit/e8c69e54061a6bfc964c588adebaf90a6b983581"}, {"sha": "f59f41e04c044f322285f80d17916bd207d8ed04", "url": "https://api.github.com/repos/rust-lang/rust/commits/f59f41e04c044f322285f80d17916bd207d8ed04", "html_url": "https://github.com/rust-lang/rust/commit/f59f41e04c044f322285f80d17916bd207d8ed04"}], "stats": {"total": 274, "additions": 162, "deletions": 112}, "files": [{"sha": "03350de4af530a61e5d275b427ebb0a65e4d26a4", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd11c7f047220585e1b790e6da3b2534d137b4e4/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/dd11c7f047220585e1b790e6da3b2534d137b4e4/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=dd11c7f047220585e1b790e6da3b2534d137b4e4", "patch": "@@ -29,9 +29,9 @@\n     * [References and Borrowing](references-and-borrowing.md)\n     * [Lifetimes](lifetimes.md)\n     * [Mutability](mutability.md)\n+    * [Structs](structs.md)\n     * [Enums](enums.md)\n     * [Match](match.md)\n-    * [Structs](structs.md)\n     * [Patterns](patterns.md)\n     * [Method Syntax](method-syntax.md)\n     * [Vectors](vectors.md)\n@@ -45,7 +45,6 @@\n     * [Universal Function Call Syntax](ufcs.md)\n     * [Crates and Modules](crates-and-modules.md)\n     * [`const` and `static`](const-and-static.md)\n-    * [Tuple Structs](tuple-structs.md)\n     * [Attributes](attributes.md)\n     * [`type` aliases](type-aliases.md)\n     * [Casting between types](casting-between-types.md)"}, {"sha": "443f569a3e5abbac21baa3a07c7c106d9f184fc8", "filename": "src/doc/trpl/enums.md", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/dd11c7f047220585e1b790e6da3b2534d137b4e4/src%2Fdoc%2Ftrpl%2Fenums.md", "raw_url": "https://github.com/rust-lang/rust/raw/dd11c7f047220585e1b790e6da3b2534d137b4e4/src%2Fdoc%2Ftrpl%2Fenums.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fenums.md?ref=dd11c7f047220585e1b790e6da3b2534d137b4e4", "patch": "@@ -1,68 +1,63 @@\n % Enums\n \n-Rust has a \u2018sum type\u2019, an `enum`. Enums are an incredibly useful feature of\n-Rust, and are used throughout the standard library. An `enum` is a type which\n-relates a set of alternates to a specific name. For example, below we define\n-`Character` to be either a `Digit` or something else.\n+An `enum` in Rust is a type that represents data that could be one of\n+several possible variants:\n \n ```rust\n-enum Character {\n-    Digit(i32),\n-    Other,\n+enum Message {\n+    Quit,\n+    ChangeColor(i32, i32, i32),\n+    Move { x: i32, y: i32 },\n+    Write(String),\n }\n ```\n \n-Most types are allowed as the variant components of an `enum`. Here are some\n-examples:\n+Each variant can optionally have data associated with it. The syntax for\n+defining variants resembles the syntaxes used to define structs: you can\n+have variants with no data (like unit-like structs), variants with named\n+data, and variants with unnamed data (like tuple structs). Unlike\n+separate struct definitions, however, an `enum` is a single type. A\n+value of the enum can match any of the variants. For this reason, an\n+enum is sometimes called a \u2018sum type\u2019: the set of possible values of the\n+enum is the sum of the sets of possible values for each variant.\n \n-```rust\n-struct Empty;\n-struct Color(i32, i32, i32);\n-struct Length(i32);\n-struct Stats { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n-struct HeightDatabase(Vec<i32>);\n-```\n-\n-You see that, depending on its type, an `enum` variant may or may not hold data.\n-In `Character`, for instance, `Digit` gives a meaningful name for an `i32`\n-value, where `Other` is only a name. However, the fact that they represent\n-distinct categories of `Character` is a very useful property.\n-\n-The variants of an `enum` by default are not comparable with equality operators\n-(`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not support other\n-binary operations such as `*` and `+`. As such, the following code is invalid\n-for the example `Character` type:\n-\n-```rust,ignore\n-// These assignments both succeed\n-let ten  = Character::Digit(10);\n-let four = Character::Digit(4);\n-\n-// Error: `*` is not implemented for type `Character`\n-let forty = ten * four;\n+We use the `::` syntax to use the name of each variant: they\u2019re scoped by the name\n+of the `enum` itself. This allows both of these to work:\n \n-// Error: `<=` is not implemented for type `Character`\n-let four_is_smaller = four <= ten;\n+```rust\n+# enum Message {\n+#     Move { x: i32, y: i32 },\n+# }\n+let x: Message = Message::Move { x: 3, y: 4 };\n+\n+enum BoardGameTurn {\n+    Move { squares: i32 },\n+    Pass,\n+}\n \n-// Error: `==` is not implemented for type `Character`\n-let four_equals_ten = four == ten;\n+let y: BoardGameTurn = BoardGameTurn::Move { squares: 1 };\n ```\n \n-We use the `::` syntax to use the name of each variant: They\u2019re scoped by the name\n-of the `enum` itself. This allows both of these to work:\n+Both variants are named `Move`, but since they\u2019re scoped to the name of\n+the enum, they can both be used without conflict.\n+\n+A value of an enum type contains information about which variant it is,\n+in addition to any data associated with that variant. This is sometimes\n+referred to as a \u2018tagged union\u2019, since the data includes a \u2018tag\u2019\n+indicating what type it is. The compiler uses this information to\n+enforce that you\u2019re accessing the data in the enum safely. For instance,\n+you can\u2019t simply try to destructure a value as if it were one of the\n+possible variants:\n \n ```rust,ignore\n-Character::Digit(10);\n-Hand::Digit;\n+fn process_color_change(msg: Message) {\n+    let Message::ChangeColor(r, g, b) = msg; // compile-time error\n+}\n ```\n \n-Both variants are named `Digit`, but since they\u2019re scoped to the `enum` name,\n-\n-Not supporting these operations may seem rather limiting, but it\u2019s a limitation\n-which we can overcome. There are two ways: by implementing equality ourselves,\n-or by pattern matching variants with [`match`][match] expressions, which you\u2019ll\n-learn in the next section. We don\u2019t know enough about Rust to implement\n-equality yet, but we\u2019ll find out in the [`traits`][traits] section.\n+We\u2019ll see how to safely get data out of enums when we learn about the\n+[`match`][match] and [`if let`][if-let] statements in the next few\n+chapters.\n \n [match]: match.html\n-[traits]: traits.html\n+[if-let]: if-let.html"}, {"sha": "2bb2359ba5a01f82b98af858b81f2303d0bd7aaa", "filename": "src/doc/trpl/match.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dd11c7f047220585e1b790e6da3b2534d137b4e4/src%2Fdoc%2Ftrpl%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/dd11c7f047220585e1b790e6da3b2534d137b4e4/src%2Fdoc%2Ftrpl%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmatch.md?ref=dd11c7f047220585e1b790e6da3b2534d137b4e4", "patch": "@@ -61,3 +61,40 @@ let number = match x {\n ```\n \n Sometimes it\u2019s a nice way of converting something from one type to another.\n+\n+# Matching on enums\n+\n+Another important use of the `match` keyword is to process the possible\n+variants of an enum:\n+\n+```rust\n+enum Message {\n+    Quit,\n+    ChangeColor(i32, i32, i32),\n+    Move { x: i32, y: i32 },\n+    Write(String),\n+}\n+\n+fn quit() { /* ... */ }\n+fn change_color(r: i32, g: i32, b: i32) { /* ... */ }\n+fn move_cursor(x: i32, y: i32) { /* ... */ }\n+\n+fn process_message(msg: Message) {\n+    match msg {\n+        Message::Quit => quit(),\n+        Message::ChangeColor(r, g, b) => change_color(r, g, b),\n+        Message::Move { x: x, y: y } => move_cursor(x, y),\n+        Message::Write(s) => println!(\"{}\", s),\n+    };\n+}\n+```\n+\n+Again, the Rust compiler checks exhaustiveness, so it demands that you\n+have a match arm for every variant of the enum. If you leave one off, it\n+will give you a compile-time error unless you use `_`.\n+\n+Unlike the previous uses of `match`, you can\u2019t use the normal `if`\n+statement to do this. You can use the [`if let`][if-let] statement,\n+which can be seen as an abbreviated form of `match`.\n+\n+[if-let][if-let.html]"}, {"sha": "ad7ead9319989f2339a5dae9f0b89bb15812ffa4", "filename": "src/doc/trpl/structs.md", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/dd11c7f047220585e1b790e6da3b2534d137b4e4/src%2Fdoc%2Ftrpl%2Fstructs.md", "raw_url": "https://github.com/rust-lang/rust/raw/dd11c7f047220585e1b790e6da3b2534d137b4e4/src%2Fdoc%2Ftrpl%2Fstructs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstructs.md?ref=dd11c7f047220585e1b790e6da3b2534d137b4e4", "patch": "@@ -117,3 +117,82 @@ ones, and it will copy the values you don\u2019t specify:\n let origin = Point3d { x: 0, y: 0, z: 0 };\n let point = Point3d { z: 1, x: 2, .. origin };\n ```\n+\n+# Tuple structs\n+\n+Rust has another data type that\u2019s like a hybrid between a [tuple][tuple] and a\n+struct, called a \u2018tuple struct\u2019. Tuple structs have a name, but\n+their fields don\u2019t:\n+\n+```rust\n+struct Color(i32, i32, i32);\n+struct Point(i32, i32, i32);\n+```\n+\n+[tuple]: primitive-types.html#tuples\n+\n+These two will not be equal, even if they have the same values:\n+\n+```rust\n+# struct Color(i32, i32, i32);\n+# struct Point(i32, i32, i32);\n+let black = Color(0, 0, 0);\n+let origin = Point(0, 0, 0);\n+```\n+\n+It is almost always better to use a struct than a tuple struct. We would write\n+`Color` and `Point` like this instead:\n+\n+```rust\n+struct Color {\n+    red: i32,\n+    blue: i32,\n+    green: i32,\n+}\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+    z: i32,\n+}\n+```\n+\n+Now, we have actual names, rather than positions. Good names are important,\n+and with a struct, we have actual names.\n+\n+There _is_ one case when a tuple struct is very useful, though, and that\u2019s a\n+tuple struct with only one element. We call this the \u2018newtype\u2019 pattern, because\n+it allows you to create a new type, distinct from that of its contained value\n+and expressing its own semantic meaning:\n+\n+```rust\n+struct Inches(i32);\n+\n+let length = Inches(10);\n+\n+let Inches(integer_length) = length;\n+println!(\"length is {} inches\", integer_length);\n+```\n+\n+As you can see here, you can extract the inner integer type through a\n+destructuring `let`, just as with regular tuples. In this case, the\n+`let Inches(integer_length)` assigns `10` to `integer_length`.\n+\n+# Unit-like structs\n+\n+You can define a struct with no members at all:\n+\n+```rust\n+struct Electron;\n+```\n+\n+Such a struct is called \u2018unit-like\u2019 because it resembles the empty\n+tuple, `()`, sometimes called \u2018unit\u2019. Like a tuple struct, it defines a\n+new type.\n+\n+This is rarely useful on its own (although sometimes it can serve as a\n+marker type), but in combination with other features, it can become\n+useful. For instance, a library may ask you to create a structure that\n+implements a certain [trait][trait] to handle events. If you don\u2019t have\n+any data you need to store in the structure, you can just create a\n+unit-like struct."}, {"sha": "bdaef70711ae418990568151a86fa624d00f135a", "filename": "src/doc/trpl/tuple-structs.md", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e8c69e54061a6bfc964c588adebaf90a6b983581/src%2Fdoc%2Ftrpl%2Ftuple-structs.md", "raw_url": "https://github.com/rust-lang/rust/raw/e8c69e54061a6bfc964c588adebaf90a6b983581/src%2Fdoc%2Ftrpl%2Ftuple-structs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftuple-structs.md?ref=e8c69e54061a6bfc964c588adebaf90a6b983581", "patch": "@@ -1,60 +0,0 @@\n-% Tuple Structs\n-\n-Rust has another data type that's like a hybrid between a [tuple][tuple] and a\n-[struct][struct], called a \u2018tuple struct\u2019. Tuple structs have a name, but\n-their fields don\u2019t:\n-\n-```rust\n-struct Color(i32, i32, i32);\n-struct Point(i32, i32, i32);\n-```\n-\n-[tuple]: primitive-types.html#tuples\n-[struct]: structs.html\n-\n-These two will not be equal, even if they have the same values:\n-\n-```rust\n-# struct Color(i32, i32, i32);\n-# struct Point(i32, i32, i32);\n-let black = Color(0, 0, 0);\n-let origin = Point(0, 0, 0);\n-```\n-\n-It is almost always better to use a struct than a tuple struct. We would write\n-`Color` and `Point` like this instead:\n-\n-```rust\n-struct Color {\n-    red: i32,\n-    blue: i32,\n-    green: i32,\n-}\n-\n-struct Point {\n-    x: i32,\n-    y: i32,\n-    z: i32,\n-}\n-```\n-\n-Now, we have actual names, rather than positions. Good names are important,\n-and with a struct, we have actual names.\n-\n-There _is_ one case when a tuple struct is very useful, though, and that\u2019s a\n-tuple struct with only one element. We call this the \u2018newtype\u2019 pattern, because\n-it allows you to create a new type, distinct from that of its contained value\n-and expressing its own semantic meaning:\n-\n-```rust\n-struct Inches(i32);\n-\n-let length = Inches(10);\n-\n-let Inches(integer_length) = length;\n-println!(\"length is {} inches\", integer_length);\n-```\n-\n-As you can see here, you can extract the inner integer type through a\n-destructuring `let`, as we discussed previously in \u2018tuples\u2019. In this case, the\n-`let Inches(integer_length)` assigns `10` to `integer_length`."}]}