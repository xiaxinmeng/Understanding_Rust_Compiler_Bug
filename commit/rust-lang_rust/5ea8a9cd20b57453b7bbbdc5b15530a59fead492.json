{"sha": "5ea8a9cd20b57453b7bbbdc5b15530a59fead492", "node_id": "C_kwDOAAsO6NoAKDVlYThhOWNkMjBiNTc0NTNiN2JiYmRjNWIxNTUzMGE1OWZlYWQ0OTI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-26T00:52:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-26T00:52:02Z"}, "message": "Merge #10863\n\n10863: internal: build per-block `ItemTree`s r=Veykril a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/7717\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/8911\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/8614\r\n\r\n`ItemTree`s are now flat lists of items, so they should probably be renamed at some point.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "e16d8286b67099b7232c0ad6bd26de025215d16a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e16d8286b67099b7232c0ad6bd26de025215d16a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ea8a9cd20b57453b7bbbdc5b15530a59fead492", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhoC+yCRBK7hj4Ov3rIwAAq/MIAFZYlTPwfExyIbxkMthNz22b\nCkiIJi2YInEoBhIh1g5FDkpblPbN736eCUaF8KdivC9+pm75EIlnEJJThGiuXiR7\nnvl2qI19C6SNI053tqN3q8+OklS3re1bKtQ0CRpOA4Ci73P9yW8WPhNjdTkhjd7R\n9sFQmp0t8xtUpys3gfCvP70c2UHxbLrCCL8Kgk1MfQarEl8UmOiKuLxAIaljaORY\nWi4U3+th2013PI5p7VcBFapGo91nPXgITOsa7fkeY2ctM7zcCMKm7B2yeVY1bCvX\nqlv0fDgA4chzBy5MMpV8cLrTodMstUHyVZFuZJo/XL9Vu0MFp3DEg13rkBDoMPk=\n=zA7J\n-----END PGP SIGNATURE-----\n", "payload": "tree e16d8286b67099b7232c0ad6bd26de025215d16a\nparent 91cb422e1a3cd96926af9203ab925ac6a90192b5\nparent 3bb6f506eeab0909b69d110bf7d80610dc0a4b0e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1637887922 +0000\ncommitter GitHub <noreply@github.com> 1637887922 +0000\n\nMerge #10863\n\n10863: internal: build per-block `ItemTree`s r=Veykril a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/7717\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/8911\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/8614\r\n\r\n`ItemTree`s are now flat lists of items, so they should probably be renamed at some point.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ea8a9cd20b57453b7bbbdc5b15530a59fead492", "html_url": "https://github.com/rust-lang/rust/commit/5ea8a9cd20b57453b7bbbdc5b15530a59fead492", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ea8a9cd20b57453b7bbbdc5b15530a59fead492/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91cb422e1a3cd96926af9203ab925ac6a90192b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/91cb422e1a3cd96926af9203ab925ac6a90192b5", "html_url": "https://github.com/rust-lang/rust/commit/91cb422e1a3cd96926af9203ab925ac6a90192b5"}, {"sha": "3bb6f506eeab0909b69d110bf7d80610dc0a4b0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bb6f506eeab0909b69d110bf7d80610dc0a4b0e", "html_url": "https://github.com/rust-lang/rust/commit/3bb6f506eeab0909b69d110bf7d80610dc0a4b0e"}], "stats": {"total": 234, "additions": 57, "deletions": 177}, "files": [{"sha": "da1e99c829d56af50aef5a89390c77a60bd7b3de", "filename": "crates/hir_def/src/body/tests/block.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5ea8a9cd20b57453b7bbbdc5b15530a59fead492/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea8a9cd20b57453b7bbbdc5b15530a59fead492/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs?ref=5ea8a9cd20b57453b7bbbdc5b15530a59fead492", "patch": "@@ -148,13 +148,11 @@ fn f() {\n }\n     \"#,\n         expect![[r#\"\n-            BlockId(1) in ModuleId { krate: CrateId(0), block: Some(BlockId(0)), local_id: Idx::<ModuleData>(0) }\n+            BlockId(1) in ModuleId { krate: CrateId(0), block: Some(BlockId(0)), local_id: Idx::<ModuleData>(1) }\n             BlockId(0) in ModuleId { krate: CrateId(0), block: None, local_id: Idx::<ModuleData>(0) }\n             crate scope\n         \"#]],\n     );\n-    // FIXME: The module nesting here is wrong!\n-    // The first block map should be located in module #1 (`mod module`), not #0 (BlockId(0) root module)\n }\n \n #[test]\n@@ -352,25 +350,18 @@ fn is_visible_from_same_def_map() {\n     check_at(\n         r#\"\n fn outer() {\n-    mod command {\n-        use crate::name;\n-    }\n-\n     mod tests {\n         use super::*;\n     }\n+    use crate::name;\n     $0\n }\n         \"#,\n         expect![[r#\"\n             block scope\n-            command: t\n             name: _\n             tests: t\n \n-            block scope::command\n-            name: _\n-\n             block scope::tests\n             name: _\n             outer: v\n@@ -379,6 +370,4 @@ fn outer() {\n             outer: v\n         \"#]],\n     );\n-    // FIXME: `name` should not be visible in the block scope. This happens because ItemTrees store\n-    // inner items incorrectly.\n }"}, {"sha": "12fa34b73abbec84041d5c79cd583efb960cbb63", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5ea8a9cd20b57453b7bbbdc5b15530a59fead492/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea8a9cd20b57453b7bbbdc5b15530a59fead492/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=5ea8a9cd20b57453b7bbbdc5b15530a59fead492", "patch": "@@ -132,21 +132,6 @@ impl ItemTree {\n                     // items.\n                     ctx.lower_macro_stmts(stmts)\n                 },\n-                ast::Pat(_pat) => {\n-                    // FIXME: This occurs because macros in pattern position are treated as inner\n-                    // items and expanded during block DefMap computation\n-                    return Default::default();\n-                },\n-                ast::Type(ty) => {\n-                    // Types can contain inner items. We return an empty item tree in this case, but\n-                    // still need to collect inner items.\n-                    ctx.lower_inner_items(ty.syntax())\n-                },\n-                ast::Expr(e) => {\n-                    // Macros can expand to expressions. We return an empty item tree in this case, but\n-                    // still need to collect inner items.\n-                    ctx.lower_inner_items(e.syntax())\n-                },\n                 _ => {\n                     panic!(\"cannot create item tree from {:?} {}\", syntax, syntax);\n                 },\n@@ -160,6 +145,14 @@ impl ItemTree {\n         Arc::new(item_tree)\n     }\n \n+    fn block_item_tree(db: &dyn DefDatabase, block: BlockId) -> Arc<ItemTree> {\n+        let loc = db.lookup_intern_block(block);\n+        let block = loc.ast_id.to_node(db.upcast());\n+        let hygiene = Hygiene::new(db.upcast(), loc.ast_id.file_id);\n+        let ctx = lower::Ctx::new(db, hygiene.clone(), loc.ast_id.file_id);\n+        Arc::new(ctx.lower_block(&block))\n+    }\n+\n     fn shrink_to_fit(&mut self) {\n         if let Some(data) = &mut self.data {\n             let ItemTreeData {\n@@ -183,7 +176,6 @@ impl ItemTree {\n                 macro_rules,\n                 macro_defs,\n                 vis,\n-                inner_items,\n             } = &mut **data;\n \n             imports.shrink_to_fit();\n@@ -207,8 +199,6 @@ impl ItemTree {\n             macro_defs.shrink_to_fit();\n \n             vis.arena.shrink_to_fit();\n-\n-            inner_items.shrink_to_fit();\n         }\n     }\n \n@@ -231,13 +221,6 @@ impl ItemTree {\n         self.raw_attrs(of).clone().filter(db, krate)\n     }\n \n-    pub fn inner_items_of_block(&self, block: FileAstId<ast::BlockExpr>) -> &[ModItem] {\n-        match &self.data {\n-            Some(data) => data.inner_items.get(&block).map(|it| &**it).unwrap_or(&[]),\n-            None => &[],\n-        }\n-    }\n-\n     pub fn pretty_print(&self) -> String {\n         pretty::print_item_tree(self)\n     }\n@@ -297,8 +280,6 @@ struct ItemTreeData {\n     macro_defs: Arena<MacroDef>,\n \n     vis: ItemVisibilities,\n-\n-    inner_items: FxHashMap<FileAstId<ast::BlockExpr>, SmallVec<[ModItem; 1]>>,\n }\n \n #[derive(Debug, Eq, PartialEq, Hash)]\n@@ -388,14 +369,18 @@ impl TreeId {\n \n     pub(crate) fn item_tree(&self, db: &dyn DefDatabase) -> Arc<ItemTree> {\n         match self.block {\n-            Some(_) => unreachable!(\"per-block ItemTrees are not yet implemented\"),\n+            Some(block) => ItemTree::block_item_tree(db, block),\n             None => db.file_item_tree(self.file),\n         }\n     }\n \n     pub(crate) fn file_id(self) -> HirFileId {\n         self.file\n     }\n+\n+    pub(crate) fn is_block(self) -> bool {\n+        self.block.is_some()\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "bb224f57b23354334bd9eee84e2c2cde0d5f26fc", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 22, "deletions": 118, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/5ea8a9cd20b57453b7bbbdc5b15530a59fead492/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea8a9cd20b57453b7bbbdc5b15530a59fead492/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=5ea8a9cd20b57453b7bbbdc5b15530a59fead492", "patch": "@@ -3,10 +3,7 @@\n use std::{collections::hash_map::Entry, mem, sync::Arc};\n \n use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, name::known, HirFileId};\n-use syntax::{\n-    ast::{self, HasModuleItem},\n-    SyntaxNode, WalkEvent,\n-};\n+use syntax::ast::{self, HasModuleItem};\n \n use crate::{\n     generics::{GenericParams, TypeParamData, TypeParamProvenance},\n@@ -42,7 +39,7 @@ impl<'a> Ctx<'a> {\n \n     pub(super) fn lower_module_items(mut self, item_owner: &dyn HasModuleItem) -> ItemTree {\n         self.tree.top_level =\n-            item_owner.items().flat_map(|item| self.lower_mod_item(&item, false)).collect();\n+            item_owner.items().flat_map(|item| self.lower_mod_item(&item)).collect();\n         self.tree\n     }\n \n@@ -62,63 +59,35 @@ impl<'a> Ctx<'a> {\n                 },\n                 _ => None,\n             })\n-            .flat_map(|item| self.lower_mod_item(&item, false))\n+            .flat_map(|item| self.lower_mod_item(&item))\n             .collect();\n \n-        // Non-items need to have their inner items collected.\n-        for stmt in stmts.statements() {\n-            match stmt {\n-                ast::Stmt::ExprStmt(_) | ast::Stmt::LetStmt(_) => {\n-                    self.collect_inner_items(stmt.syntax())\n-                }\n-                _ => {}\n-            }\n-        }\n-        if let Some(expr) = stmts.expr() {\n-            self.collect_inner_items(expr.syntax());\n-        }\n         self.tree\n     }\n \n-    pub(super) fn lower_inner_items(mut self, within: &SyntaxNode) -> ItemTree {\n-        self.collect_inner_items(within);\n+    pub(super) fn lower_block(mut self, block: &ast::BlockExpr) -> ItemTree {\n+        self.tree.top_level = block\n+            .statements()\n+            .filter_map(|stmt| match stmt {\n+                ast::Stmt::Item(item) => self.lower_mod_item(&item),\n+                // Macro calls can be both items and expressions. The syntax library always treats\n+                // them as expressions here, so we undo that.\n+                ast::Stmt::ExprStmt(es) => match es.expr()? {\n+                    ast::Expr::MacroCall(call) => self.lower_mod_item(&call.into()),\n+                    _ => None,\n+                },\n+                _ => None,\n+            })\n+            .collect();\n+\n         self.tree\n     }\n \n     fn data(&mut self) -> &mut ItemTreeData {\n         self.tree.data_mut()\n     }\n \n-    fn lower_mod_item(&mut self, item: &ast::Item, inner: bool) -> Option<ModItem> {\n-        // Collect inner items for 1-to-1-lowered items.\n-        match item {\n-            ast::Item::Struct(_)\n-            | ast::Item::Union(_)\n-            | ast::Item::Enum(_)\n-            | ast::Item::Fn(_)\n-            | ast::Item::TypeAlias(_)\n-            | ast::Item::Const(_)\n-            | ast::Item::Static(_) => {\n-                // Skip this if we're already collecting inner items. We'll descend into all nodes\n-                // already.\n-                if !inner {\n-                    self.collect_inner_items(item.syntax());\n-                }\n-            }\n-\n-            // These are handled in their respective `lower_X` method (since we can't just blindly\n-            // walk them).\n-            ast::Item::Trait(_) | ast::Item::Impl(_) | ast::Item::ExternBlock(_) => {}\n-\n-            // These don't have inner items.\n-            ast::Item::Module(_)\n-            | ast::Item::ExternCrate(_)\n-            | ast::Item::Use(_)\n-            | ast::Item::MacroCall(_)\n-            | ast::Item::MacroRules(_)\n-            | ast::Item::MacroDef(_) => {}\n-        };\n-\n+    fn lower_mod_item(&mut self, item: &ast::Item) -> Option<ModItem> {\n         let attrs = RawAttrs::new(self.db, item, &self.hygiene);\n         let item: ModItem = match item {\n             ast::Item::Struct(ast) => self.lower_struct(ast)?.into(),\n@@ -155,47 +124,6 @@ impl<'a> Ctx<'a> {\n         }\n     }\n \n-    fn collect_inner_items(&mut self, container: &SyntaxNode) {\n-        let forced_vis = self.forced_visibility.take();\n-\n-        let mut block_stack = Vec::new();\n-\n-        // if container itself is block, add it to the stack\n-        if let Some(block) = ast::BlockExpr::cast(container.clone()) {\n-            block_stack.push(self.source_ast_id_map.ast_id(&block));\n-        }\n-\n-        for event in container.preorder().skip(1) {\n-            match event {\n-                WalkEvent::Enter(node) => {\n-                    match_ast! {\n-                        match node {\n-                            ast::BlockExpr(block) => {\n-                                block_stack.push(self.source_ast_id_map.ast_id(&block));\n-                            },\n-                            ast::Item(item) => {\n-                                // FIXME: This triggers for macro calls in expression/pattern/type position\n-                                let mod_item = self.lower_mod_item(&item, true);\n-                                let current_block = block_stack.last();\n-                                if let (Some(mod_item), Some(block)) = (mod_item, current_block) {\n-                                        self.data().inner_items.entry(*block).or_default().push(mod_item);\n-                                }\n-                            },\n-                            _ => {}\n-                        }\n-                    }\n-                }\n-                WalkEvent::Leave(node) => {\n-                    if ast::BlockExpr::cast(node).is_some() {\n-                        block_stack.pop();\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.forced_visibility = forced_vis;\n-    }\n-\n     fn lower_assoc_item(&mut self, item: &ast::AssocItem) -> Option<AssocItem> {\n         match item {\n             ast::AssocItem::Fn(ast) => self.lower_function(ast).map(Into::into),\n@@ -470,9 +398,7 @@ impl<'a> Ctx<'a> {\n             ModKind::Inline {\n                 items: module\n                     .item_list()\n-                    .map(|list| {\n-                        list.items().flat_map(|item| self.lower_mod_item(&item, false)).collect()\n-                    })\n+                    .map(|list| list.items().flat_map(|item| self.lower_mod_item(&item)).collect())\n                     .unwrap_or_else(|| {\n                         cov_mark::hit!(name_res_works_for_broken_modules);\n                         Box::new([]) as Box<[_]>\n@@ -487,8 +413,7 @@ impl<'a> Ctx<'a> {\n     fn lower_trait(&mut self, trait_def: &ast::Trait) -> Option<FileItemTreeId<Trait>> {\n         let name = trait_def.name()?.as_name();\n         let visibility = self.lower_visibility(trait_def);\n-        let generic_params =\n-            self.lower_generic_params_and_inner_items(GenericsOwner::Trait(trait_def), trait_def);\n+        let generic_params = self.lower_generic_params(GenericsOwner::Trait(trait_def), trait_def);\n         let is_auto = trait_def.auto_token().is_some();\n         let is_unsafe = trait_def.unsafe_token().is_some();\n         let items = trait_def.assoc_item_list().map(|list| {\n@@ -497,7 +422,6 @@ impl<'a> Ctx<'a> {\n                 list.assoc_items()\n                     .filter_map(|item| {\n                         let attrs = RawAttrs::new(db, &item, &this.hygiene);\n-                        this.collect_inner_items(item.syntax());\n                         this.lower_assoc_item(&item).map(|item| {\n                             this.add_attrs(ModItem::from(item).into(), attrs);\n                             item\n@@ -520,8 +444,7 @@ impl<'a> Ctx<'a> {\n     }\n \n     fn lower_impl(&mut self, impl_def: &ast::Impl) -> Option<FileItemTreeId<Impl>> {\n-        let generic_params =\n-            self.lower_generic_params_and_inner_items(GenericsOwner::Impl, impl_def);\n+        let generic_params = self.lower_generic_params(GenericsOwner::Impl, impl_def);\n         // FIXME: If trait lowering fails, due to a non PathType for example, we treat this impl\n         // as if it was an non-trait impl. Ideally we want to create a unique missing ref that only\n         // equals itself.\n@@ -535,7 +458,6 @@ impl<'a> Ctx<'a> {\n             .into_iter()\n             .flat_map(|it| it.assoc_items())\n             .filter_map(|item| {\n-                self.collect_inner_items(item.syntax());\n                 let assoc = self.lower_assoc_item(&item)?;\n                 let attrs = RawAttrs::new(self.db, &item, &self.hygiene);\n                 self.add_attrs(ModItem::from(assoc).into(), attrs);\n@@ -603,7 +525,6 @@ impl<'a> Ctx<'a> {\n         let children: Box<[_]> = block.extern_item_list().map_or(Box::new([]), |list| {\n             list.extern_items()\n                 .filter_map(|item| {\n-                    self.collect_inner_items(item.syntax());\n                     let attrs = RawAttrs::new(self.db, &item, &self.hygiene);\n                     let id: ModItem = match item {\n                         ast::ExternItem::Fn(ast) => {\n@@ -641,23 +562,6 @@ impl<'a> Ctx<'a> {\n         id(self.data().extern_blocks.alloc(res))\n     }\n \n-    /// Lowers generics defined on `node` and collects inner items defined within.\n-    fn lower_generic_params_and_inner_items(\n-        &mut self,\n-        owner: GenericsOwner<'_>,\n-        node: &dyn ast::HasGenericParams,\n-    ) -> Interned<GenericParams> {\n-        // Generics are part of item headers and may contain inner items we need to collect.\n-        if let Some(params) = node.generic_param_list() {\n-            self.collect_inner_items(params.syntax());\n-        }\n-        if let Some(clause) = node.where_clause() {\n-            self.collect_inner_items(clause.syntax());\n-        }\n-\n-        self.lower_generic_params(owner, node)\n-    }\n-\n     fn lower_generic_params(\n         &mut self,\n         owner: GenericsOwner<'_>,"}, {"sha": "882d54c996abbfa6a962ac8fbcc5907949e17083", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5ea8a9cd20b57453b7bbbdc5b15530a59fead492/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea8a9cd20b57453b7bbbdc5b15530a59fead492/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=5ea8a9cd20b57453b7bbbdc5b15530a59fead492", "patch": "@@ -69,6 +69,7 @@ use syntax::ast;\n use crate::{\n     db::DefDatabase,\n     item_scope::{BuiltinShadowMode, ItemScope},\n+    item_tree::TreeId,\n     nameres::{diagnostics::DefDiagnostic, path_resolution::ResolveMode},\n     path::ModPath,\n     per_ns::PerNs,\n@@ -214,7 +215,11 @@ impl DefMap {\n         let edition = crate_graph[krate].edition;\n         let origin = ModuleOrigin::CrateRoot { definition: crate_graph[krate].root_file_id };\n         let def_map = DefMap::empty(krate, edition, origin);\n-        let def_map = collector::collect_defs(db, def_map, None);\n+        let def_map = collector::collect_defs(\n+            db,\n+            def_map,\n+            TreeId::new(crate_graph[krate].root_file_id.into(), None),\n+        );\n \n         Arc::new(def_map)\n     }\n@@ -225,8 +230,9 @@ impl DefMap {\n     ) -> Option<Arc<DefMap>> {\n         let block: BlockLoc = db.lookup_intern_block(block_id);\n \n-        let item_tree = db.file_item_tree(block.ast_id.file_id);\n-        if item_tree.inner_items_of_block(block.ast_id.value).is_empty() {\n+        let tree_id = TreeId::new(block.ast_id.file_id, Some(block_id));\n+        let item_tree = tree_id.item_tree(db);\n+        if item_tree.top_level_items().is_empty() {\n             return None;\n         }\n \n@@ -240,7 +246,7 @@ impl DefMap {\n         );\n         def_map.block = Some(block_info);\n \n-        let def_map = collector::collect_defs(db, def_map, Some(block.ast_id));\n+        let def_map = collector::collect_defs(db, def_map, tree_id);\n         Some(Arc::new(def_map))\n     }\n "}, {"sha": "9f691178055e8ffdade128e07491e47adc21882c", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5ea8a9cd20b57453b7bbbdc5b15530a59fead492/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea8a9cd20b57453b7bbbdc5b15530a59fead492/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=5ea8a9cd20b57453b7bbbdc5b15530a59fead492", "patch": "@@ -53,11 +53,7 @@ static GLOB_RECURSION_LIMIT: Limit = Limit::new(100);\n static EXPANSION_DEPTH_LIMIT: Limit = Limit::new(128);\n static FIXED_POINT_LIMIT: Limit = Limit::new(8192);\n \n-pub(super) fn collect_defs(\n-    db: &dyn DefDatabase,\n-    mut def_map: DefMap,\n-    block: Option<AstId<ast::BlockExpr>>,\n-) -> DefMap {\n+pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: TreeId) -> DefMap {\n     let crate_graph = db.crate_graph();\n \n     let mut deps = FxHashMap::default();\n@@ -69,7 +65,7 @@ pub(super) fn collect_defs(\n \n         deps.insert(dep.as_name(), dep_root.into());\n \n-        if dep.is_prelude() && block.is_none() {\n+        if dep.is_prelude() && !tree_id.is_block() {\n             def_map.extern_prelude.insert(dep.as_name(), dep_root.into());\n         }\n     }\n@@ -104,9 +100,10 @@ pub(super) fn collect_defs(\n         registered_attrs: Default::default(),\n         registered_tools: Default::default(),\n     };\n-    match block {\n-        Some(block) => collector.seed_with_inner(block),\n-        None => collector.seed_with_top_level(),\n+    if tree_id.is_block() {\n+        collector.seed_with_inner(tree_id);\n+    } else {\n+        collector.seed_with_top_level();\n     }\n     collector.collect();\n     let mut def_map = collector.finish();\n@@ -313,8 +310,8 @@ impl DefCollector<'_> {\n         }\n     }\n \n-    fn seed_with_inner(&mut self, block: AstId<ast::BlockExpr>) {\n-        let item_tree = self.db.file_item_tree(block.file_id);\n+    fn seed_with_inner(&mut self, tree_id: TreeId) {\n+        let item_tree = tree_id.item_tree(self.db);\n         let module_id = self.def_map.root;\n \n         let is_cfg_enabled = item_tree\n@@ -326,12 +323,11 @@ impl DefCollector<'_> {\n                 def_collector: self,\n                 macro_depth: 0,\n                 module_id,\n-                // FIXME: populate block once we have per-block ItemTrees\n-                tree_id: TreeId::new(block.file_id, None),\n+                tree_id,\n                 item_tree: &item_tree,\n                 mod_dir: ModDir::root(),\n             }\n-            .collect(item_tree.inner_items_of_block(block.value));\n+            .collect(item_tree.top_level_items());\n         }\n     }\n "}]}