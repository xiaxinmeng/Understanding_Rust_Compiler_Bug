{"sha": "1dd92c4a7000822612e553a121f09bb3e9a55793", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZDkyYzRhNzAwMDgyMjYxMmU1NTNhMTIxZjA5YmIzZTlhNTU3OTM=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-16T16:36:44Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-16T20:14:07Z"}, "message": "Remove HybridBitSet::dummy", "tree": {"sha": "7967a29e77edb5908db8e191524b549efb831872", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7967a29e77edb5908db8e191524b549efb831872"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dd92c4a7000822612e553a121f09bb3e9a55793", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dd92c4a7000822612e553a121f09bb3e9a55793", "html_url": "https://github.com/rust-lang/rust/commit/1dd92c4a7000822612e553a121f09bb3e9a55793", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dd92c4a7000822612e553a121f09bb3e9a55793/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ea8eb55cd9f4547b332f43c9f723de30187c223", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ea8eb55cd9f4547b332f43c9f723de30187c223", "html_url": "https://github.com/rust-lang/rust/commit/5ea8eb55cd9f4547b332f43c9f723de30187c223"}], "stats": {"total": 50, "additions": 14, "deletions": 36}, "files": [{"sha": "28aad49b09b998678ca52d7574718636c6c10ded", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1dd92c4a7000822612e553a121f09bb3e9a55793/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd92c4a7000822612e553a121f09bb3e9a55793/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=1dd92c4a7000822612e553a121f09bb3e9a55793", "patch": "@@ -423,15 +423,6 @@ pub enum HybridBitSet<T: Idx> {\n }\n \n impl<T: Idx> HybridBitSet<T> {\n-    // FIXME: This function is used in conjunction with `mem::replace()` in\n-    // several pieces of awful code below. I can't work out how else to appease\n-    // the borrow checker.\n-    fn dummy() -> Self {\n-        // The cheapest HybridBitSet to construct, which is only used to get\n-        // around the borrow checker.\n-        HybridBitSet::Sparse(SparseBitSet::new_empty(0))\n-    }\n-\n     pub fn new_empty(domain_size: usize) -> Self {\n         HybridBitSet::Sparse(SparseBitSet::new_empty(domain_size))\n     }\n@@ -487,20 +478,14 @@ impl<T: Idx> HybridBitSet<T> {\n                 // that doesn't matter because `elem` is already present.\n                 false\n             }\n-            HybridBitSet::Sparse(_) => {\n+            HybridBitSet::Sparse(sparse) => {\n                 // The set is sparse and full. Convert to a dense set.\n-                match mem::replace(self, HybridBitSet::dummy()) {\n-                    HybridBitSet::Sparse(sparse) => {\n-                        let mut dense = sparse.to_dense();\n-                        let changed = dense.insert(elem);\n-                        assert!(changed);\n-                        *self = HybridBitSet::Dense(dense);\n-                        changed\n-                    }\n-                    _ => unreachable!()\n-                }\n+                let mut dense = sparse.to_dense();\n+                let changed = dense.insert(elem);\n+                assert!(changed);\n+                *self = HybridBitSet::Dense(dense);\n+                changed\n             }\n-\n             HybridBitSet::Dense(dense) => dense.insert(elem),\n         }\n     }\n@@ -525,33 +510,26 @@ impl<T: Idx> HybridBitSet<T> {\n \n     pub fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n         match self {\n-            HybridBitSet::Sparse(_) => {\n+            HybridBitSet::Sparse(self_sparse) => {\n                 match other {\n                     HybridBitSet::Sparse(other_sparse) => {\n                         // Both sets are sparse. Add the elements in\n-                        // `other_sparse` to `self_hybrid` one at a time. This\n-                        // may or may not cause `self_hybrid` to be densified.\n+                        // `other_sparse` to `self` one at a time. This\n+                        // may or may not cause `self` to be densified.\n                         assert_eq!(self.domain_size(), other.domain_size());\n-                        let mut self_hybrid = mem::replace(self, HybridBitSet::dummy());\n                         let mut changed = false;\n                         for elem in other_sparse.iter() {\n-                            changed |= self_hybrid.insert(*elem);\n+                            changed |= self.insert(*elem);\n                         }\n-                        *self = self_hybrid;\n                         changed\n                     }\n                     HybridBitSet::Dense(other_dense) => {\n                         // `self` is sparse and `other` is dense. Densify\n                         // `self` and then do the bitwise union.\n-                        match mem::replace(self, HybridBitSet::dummy()) {\n-                            HybridBitSet::Sparse(self_sparse) => {\n-                                let mut new_dense = self_sparse.to_dense();\n-                                let changed = new_dense.union(other_dense);\n-                                *self = HybridBitSet::Dense(new_dense);\n-                                changed\n-                            }\n-                            _ => unreachable!()\n-                        }\n+                        let mut new_dense = self_sparse.to_dense();\n+                        let changed = new_dense.union(other_dense);\n+                        *self = HybridBitSet::Dense(new_dense);\n+                        changed\n                     }\n                 }\n             }"}]}