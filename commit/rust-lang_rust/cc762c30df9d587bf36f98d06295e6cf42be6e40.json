{"sha": "cc762c30df9d587bf36f98d06295e6cf42be6e40", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNzYyYzMwZGY5ZDU4N2JmMzZmOThkMDYyOTVlNmNmNDJiZTZlNDA=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-03T14:22:24Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-03T14:22:24Z"}, "message": "Prefix/suffix parameter inlay hint hiding heuristic is more strict", "tree": {"sha": "cf7c7f8ed03b9f7c895ec683a1bcd51e4a4c8197", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf7c7f8ed03b9f7c895ec683a1bcd51e4a4c8197"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc762c30df9d587bf36f98d06295e6cf42be6e40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc762c30df9d587bf36f98d06295e6cf42be6e40", "html_url": "https://github.com/rust-lang/rust/commit/cc762c30df9d587bf36f98d06295e6cf42be6e40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc762c30df9d587bf36f98d06295e6cf42be6e40/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5be653d426e3e3fd253f41f85e7d280a82037da9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5be653d426e3e3fd253f41f85e7d280a82037da9", "html_url": "https://github.com/rust-lang/rust/commit/5be653d426e3e3fd253f41f85e7d280a82037da9"}], "stats": {"total": 127, "additions": 57, "deletions": 70}, "files": [{"sha": "d6dfa0183989bfc4889e93892a5afad1eeb12ce8", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 57, "deletions": 70, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/cc762c30df9d587bf36f98d06295e6cf42be6e40/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc762c30df9d587bf36f98d06295e6cf42be6e40/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=cc762c30df9d587bf36f98d06295e6cf42be6e40", "patch": "@@ -150,17 +150,11 @@ fn get_param_name_hints(\n         return None;\n     }\n \n-    let args = match &expr {\n-        ast::Expr::CallExpr(expr) => expr.arg_list()?.args(),\n-        ast::Expr::MethodCallExpr(expr) => expr.arg_list()?.args(),\n-        _ => return None,\n-    };\n-\n-    let callable = get_callable(sema, &expr)?;\n+    let (callable, arg_list) = get_callable(sema, &expr)?;\n     let hints = callable\n         .params(sema.db)\n         .into_iter()\n-        .zip(args)\n+        .zip(arg_list.args())\n         .filter_map(|((param, _ty), arg)| {\n             let param_name = match param? {\n                 Either::Left(_) => \"self\".to_string(),\n@@ -171,7 +165,7 @@ fn get_param_name_hints(\n             };\n             Some((param_name, arg))\n         })\n-        .filter(|(param_name, arg)| should_show_param_name_hint(sema, &callable, param_name, &arg))\n+        .filter(|(param_name, arg)| !should_hide_param_name_hint(sema, &callable, param_name, &arg))\n         .map(|(param_name, arg)| InlayHint {\n             range: arg.syntax().text_range(),\n             kind: InlayKind::ParameterHint,\n@@ -289,15 +283,9 @@ fn should_not_display_type_hint(\n     for node in bind_pat.syntax().ancestors() {\n         match_ast! {\n             match node {\n-                ast::LetStmt(it) => {\n-                    return it.ty().is_some()\n-                },\n-                ast::Param(it) => {\n-                    return it.ty().is_some()\n-                },\n-                ast::MatchArm(_it) => {\n-                    return pat_is_enum_variant(db, bind_pat, pat_ty);\n-                },\n+                ast::LetStmt(it) => return it.ty().is_some(),\n+                ast::Param(it) => return it.ty().is_some(),\n+                ast::MatchArm(_it) => return pat_is_enum_variant(db, bind_pat, pat_ty),\n                 ast::IfExpr(it) => {\n                     return it.condition().and_then(|condition| condition.pat()).is_some()\n                         && pat_is_enum_variant(db, bind_pat, pat_ty);\n@@ -322,76 +310,66 @@ fn should_not_display_type_hint(\n     false\n }\n \n-fn should_show_param_name_hint(\n+fn should_hide_param_name_hint(\n     sema: &Semantics<RootDatabase>,\n     callable: &hir::Callable,\n     param_name: &str,\n     argument: &ast::Expr,\n ) -> bool {\n+    // hide when:\n+    // - the parameter name is a suffix of the function's name\n+    // - the argument is an enum whose name is equal to the parameter\n+    // - exact argument<->parameter match(ignoring leading underscore) or argument is a prefix/suffix\n+    //   of parameter with _ splitting it off\n+    // - param starts with `ra_fixture`\n+    // - param is a well known name in an unary function\n+\n     let param_name = param_name.trim_start_matches('_');\n+    if param_name.is_empty() {\n+        return true;\n+    }\n+\n     let fn_name = match callable.kind() {\n         hir::CallableKind::Function(it) => Some(it.name(sema.db).to_string()),\n-        hir::CallableKind::TupleStruct(_)\n-        | hir::CallableKind::TupleEnumVariant(_)\n-        | hir::CallableKind::Closure => None,\n+        _ => None,\n     };\n-\n-    if param_name.is_empty()\n-        || Some(param_name) == fn_name.as_ref().map(|s| s.trim_start_matches('_'))\n-        || is_argument_similar_to_param_name(sema, argument, param_name)\n-        || is_param_name_similar_to_fn_name(param_name, callable, fn_name.as_ref())\n+    let fn_name = fn_name.as_deref();\n+    is_param_name_suffix_of_fn_name(param_name, callable, fn_name)\n+        || is_enum_name_similar_to_param_name(sema, argument, param_name)\n+        || is_argument_similar_to_param_name(argument, param_name)\n         || param_name.starts_with(\"ra_fixture\")\n-    {\n-        return false;\n-    }\n-\n-    // avoid displaying hints for common functions like map, filter, etc.\n-    // or other obvious words used in std\n-    !(callable.n_params() == 1 && is_obvious_param(param_name))\n+        || (callable.n_params() == 1 && is_obvious_param(param_name))\n }\n \n-fn is_argument_similar_to_param_name(\n-    sema: &Semantics<RootDatabase>,\n-    argument: &ast::Expr,\n-    param_name: &str,\n-) -> bool {\n-    if is_enum_name_similar_to_param_name(sema, argument, param_name) {\n-        return true;\n-    }\n+fn is_argument_similar_to_param_name(argument: &ast::Expr, param_name: &str) -> bool {\n     match get_string_representation(argument) {\n         None => false,\n-        Some(argument_string) => {\n-            let num_leading_underscores =\n-                argument_string.bytes().take_while(|&c| c == b'_').count();\n-\n-            // Does the argument name begin with the parameter name? Ignore leading underscores.\n-            let mut arg_bytes = argument_string.bytes().skip(num_leading_underscores);\n-            let starts_with_pattern = param_name.bytes().all(\n-                |expected| matches!(arg_bytes.next(), Some(actual) if expected.eq_ignore_ascii_case(&actual)),\n-            );\n-\n-            if starts_with_pattern {\n-                return true;\n+        Some(argument) => {\n+            let mut res = false;\n+            if let Some(first) = argument.bytes().skip_while(|&c| c == b'_').position(|c| c == b'_')\n+            {\n+                res |= param_name == argument[..first].trim_start_matches('_');\n             }\n-\n-            // Does the argument name end with the parameter name?\n-            let mut arg_bytes = argument_string.bytes().skip(num_leading_underscores);\n-            param_name.bytes().rev().all(\n-                |expected| matches!(arg_bytes.next_back(), Some(actual) if expected.eq_ignore_ascii_case(&actual)),\n-            )\n+            if let Some(last) =\n+                argument.bytes().rev().skip_while(|&c| c == b'_').position(|c| c == b'_')\n+            {\n+                res |= param_name == argument[last..].trim_end_matches('_');\n+            }\n+            res |= argument == param_name;\n+            res\n         }\n     }\n }\n \n-fn is_param_name_similar_to_fn_name(\n+/// Hide the parameter name of an unary function if it is a `_` - prefixed suffix of the function's name, or equal.\n+///\n+/// `fn strip_suffix(suffix)` will be hidden.\n+/// `fn stripsuffix(suffix)` will not be hidden.\n+fn is_param_name_suffix_of_fn_name(\n     param_name: &str,\n     callable: &Callable,\n-    fn_name: Option<&String>,\n+    fn_name: Option<&str>,\n ) -> bool {\n-    // if it's the only parameter, don't show it if:\n-    // - is the same as the function name, or\n-    // - the function ends with '_' + param_name\n-\n     match (callable.n_params(), fn_name) {\n         (1, Some(function)) => {\n             function == param_name\n@@ -424,23 +402,32 @@ fn get_string_representation(expr: &ast::Expr) -> Option<String> {\n             }\n         }\n         ast::Expr::FieldExpr(field_expr) => Some(field_expr.name_ref()?.to_string()),\n-        ast::Expr::PathExpr(path_expr) => Some(path_expr.to_string()),\n+        ast::Expr::PathExpr(path_expr) => Some(path_expr.path()?.segment()?.to_string()),\n         ast::Expr::PrefixExpr(prefix_expr) => get_string_representation(&prefix_expr.expr()?),\n         ast::Expr::RefExpr(ref_expr) => get_string_representation(&ref_expr.expr()?),\n         _ => None,\n     }\n }\n \n fn is_obvious_param(param_name: &str) -> bool {\n+    // avoid displaying hints for common functions like map, filter, etc.\n+    // or other obvious words used in std\n     let is_obvious_param_name =\n         matches!(param_name, \"predicate\" | \"value\" | \"pat\" | \"rhs\" | \"other\");\n     param_name.len() == 1 || is_obvious_param_name\n }\n \n-fn get_callable(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<hir::Callable> {\n+fn get_callable(\n+    sema: &Semantics<RootDatabase>,\n+    expr: &ast::Expr,\n+) -> Option<(hir::Callable, ast::ArgList)> {\n     match expr {\n-        ast::Expr::CallExpr(expr) => sema.type_of_expr(&expr.expr()?)?.as_callable(sema.db),\n-        ast::Expr::MethodCallExpr(expr) => sema.resolve_method_call_as_callable(expr),\n+        ast::Expr::CallExpr(expr) => {\n+            sema.type_of_expr(&expr.expr()?)?.as_callable(sema.db).zip(expr.arg_list())\n+        }\n+        ast::Expr::MethodCallExpr(expr) => {\n+            sema.resolve_method_call_as_callable(expr).zip(expr.arg_list())\n+        }\n         _ => None,\n     }\n }"}]}