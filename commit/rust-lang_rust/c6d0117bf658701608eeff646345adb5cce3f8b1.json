{"sha": "c6d0117bf658701608eeff646345adb5cce3f8b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZDAxMTdiZjY1ODcwMTYwOGVlZmY2NDYzNDVhZGI1Y2NlM2Y4YjE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-11-09T01:00:55Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-11-13T16:57:31Z"}, "message": "rustc: add new token-tree based quasiquoter.", "tree": {"sha": "506311ab9ad1187b2b7717660d52718f09fdabd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/506311ab9ad1187b2b7717660d52718f09fdabd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6d0117bf658701608eeff646345adb5cce3f8b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6d0117bf658701608eeff646345adb5cce3f8b1", "html_url": "https://github.com/rust-lang/rust/commit/c6d0117bf658701608eeff646345adb5cce3f8b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6d0117bf658701608eeff646345adb5cce3f8b1/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12b212f38c4f9633d9f0898fd726e43a1eff9405", "url": "https://api.github.com/repos/rust-lang/rust/commits/12b212f38c4f9633d9f0898fd726e43a1eff9405", "html_url": "https://github.com/rust-lang/rust/commit/12b212f38c4f9633d9f0898fd726e43a1eff9405"}], "stats": {"total": 387, "additions": 368, "deletions": 19}, "files": [{"sha": "3f5d0f13b31c6fe35cb570623c6a44b98ec34b97", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6d0117bf658701608eeff646345adb5cce3f8b1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d0117bf658701608eeff646345adb5cce3f8b1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c6d0117bf658701608eeff646345adb5cce3f8b1", "patch": "@@ -96,6 +96,8 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n                                 ext::log_syntax::expand_syntax_ext));\n     syntax_expanders.insert(~\"ast\",\n                             builtin(ext::qquote::expand_ast));\n+    syntax_expanders.insert(~\"quote\",\n+                            builtin_expr_tt(ext::quote::expand_quote));\n     syntax_expanders.insert(~\"line\",\n                             builtin(ext::source_util::expand_line));\n     syntax_expanders.insert(~\"col\","}, {"sha": "10f853495e3cefb29e8e08786430b3cb8c609107", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c6d0117bf658701608eeff646345adb5cce3f8b1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d0117bf658701608eeff646345adb5cce3f8b1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=c6d0117bf658701608eeff646345adb5cce3f8b1", "patch": "@@ -34,12 +34,14 @@ fn mk_unary(cx: ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n     cx.next_id(); // see ast_util::op_expr_callee_id\n     mk_expr(cx, sp, ast::expr_unary(op, e))\n }\n+fn mk_raw_path(sp: span, idents: ~[ast::ident]) -> @ast::path {\n+    let p : @ast::path = @{span: sp, global: false, idents: idents,\n+                           rp: None, types: ~[]};\n+    return p;\n+}\n fn mk_path(cx: ext_ctxt, sp: span, idents: ~[ast::ident]) ->\n     @ast::expr {\n-    let path = @{span: sp, global: false, idents: idents,\n-                 rp: None, types: ~[]};\n-    let pathexpr = ast::expr_path(path);\n-    mk_expr(cx, sp, pathexpr)\n+    mk_expr(cx, sp, ast::expr_path(mk_raw_path(sp, idents)))\n }\n fn mk_access_(cx: ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n     -> @ast::expr {\n@@ -53,7 +55,6 @@ fn mk_access(cx: ext_ctxt, sp: span, p: ~[ast::ident], m: ast::ident)\n fn mk_addr_of(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     return mk_expr(cx, sp, ast::expr_addr_of(ast::m_imm, e));\n }\n-\n fn mk_call_(cx: ext_ctxt, sp: span, fn_expr: @ast::expr,\n             args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_call(fn_expr, args, false))\n@@ -90,19 +91,54 @@ fn mk_base_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n fn mk_uniq_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::expr_vstore_uniq)\n }\n-\n+fn mk_field(sp: span, f: &{ident: ast::ident, ex: @ast::expr})\n+    -> ast::field {\n+    {node: {mutbl: ast::m_imm, ident: f.ident, expr: f.ex}, span: sp}\n+}\n+fn mk_fields(sp: span, fields: ~[{ident: ast::ident, ex: @ast::expr}]) ->\n+    ~[ast::field] {\n+    move fields.map(|f| mk_field(sp, f))\n+}\n fn mk_rec_e(cx: ext_ctxt, sp: span,\n             fields: ~[{ident: ast::ident, ex: @ast::expr}]) ->\n     @ast::expr {\n-    let mut astfields: ~[ast::field] = ~[];\n-    for fields.each |field| {\n-        let ident = field.ident;\n-        let val = field.ex;\n-        let astfield =\n-            {node: {mutbl: ast::m_imm, ident: ident, expr: val}, span: sp};\n-        astfields.push(astfield);\n-    }\n-    let recexpr = ast::expr_rec(astfields, option::None::<@ast::expr>);\n-    mk_expr(cx, sp, recexpr)\n+    mk_expr(cx, sp, ast::expr_rec(mk_fields(sp, fields),\n+                                  option::None::<@ast::expr>))\n+}\n+fn mk_struct_e(cx: ext_ctxt, sp: span,\n+               ctor_path: ~[ast::ident],\n+               fields: ~[{ident: ast::ident, ex: @ast::expr}]) ->\n+    @ast::expr {\n+    mk_expr(cx, sp,\n+            ast::expr_struct(mk_raw_path(sp, ctor_path),\n+                             mk_fields(sp, fields),\n+                                    option::None::<@ast::expr>))\n+}\n+fn mk_glob_use(cx: ext_ctxt, sp: span,\n+               path: ~[ast::ident]) -> @ast::view_item {\n+    let glob = @{node: ast::view_path_glob(mk_raw_path(sp, path),\n+                                          cx.next_id()),\n+                span: sp};\n+    @{node: ast::view_item_import(~[glob]),\n+      attrs: ~[],\n+      vis: ast::private,\n+      span: sp}\n+}\n+fn mk_block(cx: ext_ctxt, sp: span,\n+            view_items: ~[@ast::view_item],\n+            stmts: ~[@ast::stmt],\n+            expr: Option<@ast::expr>) -> @ast::expr {\n+    let blk = {node: {view_items: view_items,\n+                      stmts: stmts,\n+                      expr: expr,\n+                      id: cx.next_id(),\n+                      rules: ast::default_blk },\n+               span: sp };\n+    mk_expr(cx, sp, ast::expr_block(blk))\n+}\n+fn mk_copy(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+    mk_expr(cx, sp, ast::expr_copy(e))\n+}\n+fn mk_managed(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+    mk_expr(cx, sp, ast::expr_unary(ast::box(ast::m_imm), e))\n }\n-"}, {"sha": "68a3c4a139962ae1d6d3503ff24180a92d20f1bb", "filename": "src/libsyntax/ext/quote.rs", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/c6d0117bf658701608eeff646345adb5cce3f8b1/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d0117bf658701608eeff646345adb5cce3f8b1/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=c6d0117bf658701608eeff646345adb5cce3f8b1", "patch": "@@ -0,0 +1,307 @@\n+use mod ast;\n+use mod parse::token;\n+\n+use codemap::span;\n+use ext::base::ext_ctxt;\n+use token::*;\n+\n+/**\n+*\n+* Quasiquoting works via token trees.\n+*\n+* This is registered as a expression syntax extension called quote! that lifts\n+* its argument token-tree to an AST representing the construction of the same\n+* token tree, with ast::tt_nonterminal nodes interpreted as antiquotes\n+* (splices).\n+*\n+*/\n+\n+pub fn expand_quote(cx: ext_ctxt,\n+                    sp: span,\n+                    tts: ~[ast::token_tree]) -> base::mac_result\n+{\n+\n+    // NB: It appears that the main parser loses its mind if we consider\n+    // $foo as a tt_nonterminal during the main parse, so we have to re-parse\n+    // under quote_depth > 0. This is silly and should go away; the _guess_ is\n+    // it has to do with transition away from supporting old-style macros, so\n+    // try removing it when enough of them are gone.\n+    let p = parse::new_parser_from_tt(cx.parse_sess(), cx.cfg(), tts);\n+    p.quote_depth += 1u;\n+    let tq = dvec::DVec();\n+    while p.token != token::EOF {\n+        tq.push(p.parse_token_tree());\n+    }\n+    let tts = tq.get();\n+\n+    // We want to emit a block expression that does a sequence of 'use's to\n+    // import the AST and token constructors, followed by a tt expression.\n+    let uses = ~[ build::mk_glob_use(cx, sp, ids_ext(cx, ~[~\"syntax\",\n+                                                           ~\"ast\"])),\n+                  build::mk_glob_use(cx, sp, ids_ext(cx, ~[~\"syntax\",\n+                                                           ~\"parse\",\n+                                                           ~\"token\"])) ];\n+    base::mr_expr(build::mk_block(cx, sp, uses, ~[],\n+                                  Some(mk_tt(cx, sp, &ast::tt_delim(tts)))))\n+}\n+\n+fn ids_ext(cx: ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n+    strs.map(|str| cx.parse_sess().interner.intern(@*str))\n+}\n+\n+fn id_ext(cx: ext_ctxt, str: ~str) -> ast::ident {\n+    cx.parse_sess().interner.intern(@str)\n+}\n+\n+fn mk_option_span(cx: ext_ctxt,\n+                  qsp: span,\n+                  sp: Option<span>) -> @ast::expr {\n+    match sp {\n+        None => build::mk_path(cx, qsp, ids_ext(cx, ~[~\"None\"])),\n+        Some(sp) => {\n+            build::mk_call(cx, qsp,\n+                           ids_ext(cx, ~[~\"Some\"]),\n+                           ~[build::mk_managed(cx, qsp,\n+                                               mk_span(cx, qsp, sp))])\n+        }\n+    }\n+}\n+\n+fn mk_span(cx: ext_ctxt, qsp: span, sp: span) -> @ast::expr {\n+\n+    let e_expn_info = match sp.expn_info {\n+        None => build::mk_path(cx, qsp, ids_ext(cx, ~[~\"None\"])),\n+        Some(@codemap::expanded_from(cr)) => {\n+            let e_callee =\n+                build::mk_rec_e(\n+                    cx, qsp,\n+                    ~[{ident: id_ext(cx, ~\"name\"),\n+                       ex: build::mk_uniq_str(cx, qsp,\n+                                              cr.callie.name)},\n+                      {ident: id_ext(cx, ~\"span\"),\n+                       ex: mk_option_span(cx, qsp, cr.callie.span)}]);\n+\n+            let e_expn_info_ =\n+                build::mk_call(\n+                    cx, qsp,\n+                    ids_ext(cx, ~[~\"expanded_from\"]),\n+                    ~[build::mk_rec_e(\n+                        cx, qsp,\n+                        ~[{ident: id_ext(cx, ~\"call_site\"),\n+                           ex: mk_span(cx, qsp, cr.call_site)},\n+                          {ident: id_ext(cx, ~\"callie\"),\n+                           ex: e_callee}])]);\n+\n+            build::mk_call(cx, qsp,\n+                           ids_ext(cx, ~[~\"Some\"]),\n+                           ~[build::mk_managed(cx, qsp, e_expn_info_)])\n+        }\n+    };\n+\n+    build::mk_rec_e(cx, qsp,\n+                    ~[{ident: id_ext(cx, ~\"lo\"),\n+                       ex: build::mk_uint(cx, qsp, sp.lo) },\n+\n+                      {ident: id_ext(cx, ~\"hi\"),\n+                       ex: build::mk_uint(cx, qsp, sp.hi) },\n+\n+                      {ident: id_ext(cx, ~\"expn_info\"),\n+                       ex: e_expn_info}])\n+}\n+\n+// Lift an ident to the expr that evaluates to that ident.\n+//\n+// NB: this identifies the interner used when re-parsing the token tree\n+// with the interner used during initial parse. This is _wrong_ and we\n+// should be emitting a &str here and the token type should be ok with\n+// &static/str or &session/str. Longer-term issue.\n+fn mk_ident(cx: ext_ctxt, sp: span, ident: ast::ident) -> @ast::expr {\n+    build::mk_struct_e(cx, sp,\n+                       ids_ext(cx, ~[~\"ident\"]),\n+                       ~[{ident: id_ext(cx, ~\"repr\"),\n+                          ex: build::mk_uint(cx, sp, ident.repr) }])\n+}\n+\n+\n+fn mk_binop(cx: ext_ctxt, sp: span, bop: token::binop) -> @ast::expr {\n+    let name = match bop {\n+        PLUS => \"PLUS\",\n+        MINUS => \"MINUS\",\n+        STAR => \"STAR\",\n+        SLASH => \"SLASH\",\n+        PERCENT => \"PERCENT\",\n+        CARET => \"CARET\",\n+        AND => \"AND\",\n+        OR => \"OR\",\n+        SHL => \"SHL\",\n+        SHR => \"SHR\"\n+    };\n+    build::mk_path(cx, sp,\n+                   ids_ext(cx, ~[name.to_owned()]))\n+}\n+\n+fn mk_token(cx: ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n+\n+    match tok {\n+        BINOP(binop) => {\n+            return build::mk_call(cx, sp,\n+                                  ids_ext(cx, ~[~\"BINOP\"]),\n+                                  ~[mk_binop(cx, sp, binop)]);\n+        }\n+        BINOPEQ(binop) => {\n+            return build::mk_call(cx, sp,\n+                                  ids_ext(cx, ~[~\"BINOPEQ\"]),\n+                                  ~[mk_binop(cx, sp, binop)]);\n+        }\n+\n+        LIT_INT(i, ity) => {\n+            let s_ity = match ity {\n+                ast::ty_i => ~\"ty_i\",\n+                ast::ty_char => ~\"ty_char\",\n+                ast::ty_i8 => ~\"ty_i8\",\n+                ast::ty_i16 => ~\"ty_i16\",\n+                ast::ty_i32 => ~\"ty_i32\",\n+                ast::ty_i64 => ~\"ty_i64\"\n+            };\n+            let e_ity =\n+                build::mk_path(cx, sp,\n+                               ids_ext(cx, ~[s_ity]));\n+\n+            let e_i64 = build::mk_lit(cx, sp, ast::lit_int(i, ast::ty_i64));\n+\n+            return build::mk_call(cx, sp,\n+                                  ids_ext(cx, ~[~\"LIT_INT\"]),\n+                                  ~[e_i64, e_ity]);\n+        }\n+\n+        LIT_UINT(u, uty) => {\n+            let s_uty = match uty {\n+                ast::ty_u => ~\"ty_u\",\n+                ast::ty_u8 => ~\"ty_u8\",\n+                ast::ty_u16 => ~\"ty_u16\",\n+                ast::ty_u32 => ~\"ty_u32\",\n+                ast::ty_u64 => ~\"ty_u64\"\n+            };\n+            let e_uty =\n+                build::mk_path(cx, sp,\n+                               ids_ext(cx, ~[s_uty]));\n+\n+            let e_u64 = build::mk_lit(cx, sp, ast::lit_uint(u, ast::ty_u64));\n+\n+            return build::mk_call(cx, sp,\n+                                  ids_ext(cx, ~[~\"LIT_UINT\"]),\n+                                  ~[e_u64, e_uty]);\n+        }\n+\n+        LIT_INT_UNSUFFIXED(i) => {\n+            let e_i64 = build::mk_lit(cx, sp,\n+                                      ast::lit_int(i, ast::ty_i64));\n+\n+            return build::mk_call(cx, sp,\n+                                  ids_ext(cx, ~[~\"LIT_INT_UNSUFFIXED\"]),\n+                                  ~[e_i64]);\n+        }\n+\n+        LIT_FLOAT(fident, fty) => {\n+            let s_fty = match fty {\n+                ast::ty_f => ~\"ty_f\",\n+                ast::ty_f32 => ~\"ty_f32\",\n+                ast::ty_f64 => ~\"ty_f64\"\n+            };\n+            let e_fty =\n+                build::mk_path(cx, sp,\n+                               ids_ext(cx, ~[s_fty]));\n+\n+            let e_fident = mk_ident(cx, sp, fident);\n+\n+            return build::mk_call(cx, sp,\n+                                  ids_ext(cx, ~[~\"LIT_FLOAT\"]),\n+                                  ~[e_fident, e_fty]);\n+        }\n+\n+        LIT_STR(ident) => {\n+            return build::mk_call(cx, sp,\n+                                  ids_ext(cx, ~[~\"LIT_STR\"]),\n+                                  ~[mk_ident(cx, sp, ident)]);\n+        }\n+\n+        IDENT(ident, b) => {\n+            return build::mk_call(cx, sp,\n+                                  ids_ext(cx, ~[~\"IDENT\"]),\n+                                  ~[mk_ident(cx, sp, ident),\n+                                    build::mk_lit(cx, sp, ast::lit_bool(b))]);\n+        }\n+\n+        DOC_COMMENT(ident) => {\n+            return build::mk_call(cx, sp,\n+                                  ids_ext(cx, ~[~\"DOC_COMMENT\"]),\n+                                  ~[mk_ident(cx, sp, ident)]);\n+        }\n+\n+        INTERPOLATED(_) => fail ~\"quote! with interpolated token\",\n+\n+        _ => ()\n+    }\n+\n+    let name = match tok {\n+        EQ => \"EQ\",\n+        LT => \"LT\",\n+        LE => \"LE\",\n+        EQEQ => \"EQEQ\",\n+        NE => \"NE\",\n+        GE => \"GE\",\n+        GT => \"GT\",\n+        ANDAND => \"ANDAND\",\n+        OROR => \"OROR\",\n+        NOT => \"NOT\",\n+        TILDE => \"TILDE\",\n+        AT => \"AT\",\n+        DOT => \"DOT\",\n+        DOTDOT => \"DOTDOT\",\n+        ELLIPSIS => \"ELLIPSIS\",\n+        COMMA => \"COMMA\",\n+        SEMI => \"SEMI\",\n+        COLON => \"COLON\",\n+        MOD_SEP => \"MOD_SEP\",\n+        RARROW => \"RARROW\",\n+        LARROW => \"LARROW\",\n+        DARROW => \"DARROW\",\n+        FAT_ARROW => \"FAT_ARROW\",\n+        LPAREN => \"LPAREN\",\n+        RPAREN => \"RPAREN\",\n+        LBRACKET => \"LBRACKET\",\n+        RBRACKET => \"RBRACKET\",\n+        LBRACE => \"LBRACE\",\n+        RBRACE => \"RBRACE\",\n+        POUND => \"POUND\",\n+        DOLLAR => \"DOLLAR\",\n+        UNDERSCORE => \"UNDERSCORE\",\n+        EOF => \"EOF\",\n+        _ => fail\n+    };\n+    build::mk_path(cx, sp,\n+                   ids_ext(cx, ~[name.to_owned()]))\n+}\n+\n+\n+fn mk_tt(cx: ext_ctxt, sp: span, tt: &ast::token_tree) -> @ast::expr {\n+    match *tt {\n+        ast::tt_tok(sp, tok) =>\n+        build::mk_call(cx, sp,\n+                       ids_ext(cx, ~[~\"tt_tok\"]),\n+                       ~[mk_span(cx, sp, sp),\n+                         mk_token(cx, sp, tok)]),\n+\n+        ast::tt_delim(tts) => {\n+            let e_tts = tts.map(|tt| mk_tt(cx, sp, tt));\n+            build::mk_call(cx, sp,\n+                           ids_ext(cx, ~[~\"tt_delim\"]),\n+                           ~[build::mk_uniq_vec_e(cx, sp, e_tts)])\n+        }\n+\n+        ast::tt_seq(*) => fail ~\"tt_seq in quote!\",\n+\n+        ast::tt_nonterminal(sp, ident) =>\n+        build::mk_copy(cx, sp, build::mk_path(cx, sp, ~[ident]))\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "c5f3b1b5306181158affc3545bb10c9e7d0a4e1a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6d0117bf658701608eeff646345adb5cce3f8b1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d0117bf658701608eeff646345adb5cce3f8b1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c6d0117bf658701608eeff646345adb5cce3f8b1", "patch": "@@ -1084,7 +1084,7 @@ impl Parser {\n                 self.bump();\n                 let tts = match self.token {\n                   token::LPAREN | token::LBRACE => {\n-                    let ket = token::flip_delimiter(self.token);\n+                    let ket = token::flip_delimiter(copy self.token);\n                     self.parse_unspanned_seq(copy self.token, ket,\n                                              seq_sep_none(),\n                                              |p| p.parse_token_tree())\n@@ -1279,6 +1279,7 @@ impl Parser {\n         maybe_whole!(deref self, nt_tt);\n \n         fn parse_tt_tok(p: Parser, delim_ok: bool) -> token_tree {\n+            maybe_whole!(deref p, nt_tt);\n             match p.token {\n               token::RPAREN | token::RBRACE | token::RBRACKET\n               if !delim_ok => {\n@@ -3419,7 +3420,7 @@ impl Parser {\n             let id = self.parse_ident();\n             let tts = match self.token {\n               token::LPAREN | token::LBRACE => {\n-                let ket = token::flip_delimiter(self.token);\n+                let ket = token::flip_delimiter(copy self.token);\n                 self.parse_unspanned_seq(copy self.token, ket,\n                                          seq_sep_none(),\n                                          |p| p.parse_token_tree())"}, {"sha": "d0a9154b00e27b946a356227974f534fbf86a012", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6d0117bf658701608eeff646345adb5cce3f8b1/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c6d0117bf658701608eeff646345adb5cce3f8b1/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=c6d0117bf658701608eeff646345adb5cce3f8b1", "patch": "@@ -102,6 +102,9 @@ mod ext {\n     mod expand;\n     #[legacy_exports]\n     mod qquote;\n+\n+    mod quote;\n+\n     #[legacy_exports]\n     mod build;\n "}]}