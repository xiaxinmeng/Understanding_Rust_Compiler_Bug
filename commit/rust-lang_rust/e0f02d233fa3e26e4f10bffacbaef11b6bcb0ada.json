{"sha": "e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZjAyZDIzM2ZhM2UyNmU0ZjEwYmZmYWNiYWVmMTFiNmJjYjBhZGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-10T13:54:05Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-10T14:10:28Z"}, "message": "Remove dead code", "tree": {"sha": "bf4919cd65406f457db73e18702d3fb90f6ba9f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf4919cd65406f457db73e18702d3fb90f6ba9f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada", "html_url": "https://github.com/rust-lang/rust/commit/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4560fe2abffde05e6ceb084e6d42207e0ce84b68", "url": "https://api.github.com/repos/rust-lang/rust/commits/4560fe2abffde05e6ceb084e6d42207e0ce84b68", "html_url": "https://github.com/rust-lang/rust/commit/4560fe2abffde05e6ceb084e6d42207e0ce84b68"}], "stats": {"total": 397, "additions": 191, "deletions": 206}, "files": [{"sha": "99c6b72197ca83ff4e7395be12bb5bd00f56835b", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada", "patch": "@@ -90,7 +90,7 @@ mod support {\n         AstChildren::new(parent)\n     }\n \n-    pub(super) fn token2(parent: &SyntaxNode, kind: SyntaxKind) -> Option<SyntaxToken> {\n+    pub(super) fn token(parent: &SyntaxNode, kind: SyntaxKind) -> Option<SyntaxToken> {\n         parent.children_with_tokens().filter_map(|it| it.into_token()).find(|it| it.kind() == kind)\n     }\n }"}, {"sha": "87c92880c82f19854b7ed8aaf81f3d836a092d4a", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada", "patch": "@@ -343,7 +343,7 @@ impl ast::TypeBound {\n                 .skip_while(|it| it.kind() != T![const])\n                 .find(|it| it.kind() == T![?])\n         } else {\n-            support::token2(&self.syntax, T![?])\n+            support::token(&self.syntax, T![?])\n         }\n     }\n }"}, {"sha": "65b87bb6e26ed786f61c3c8952e91bd02ed39fca", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 184, "deletions": 192, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada", "patch": "@@ -47,17 +47,15 @@ impl ast::DocCommentsOwner for FnDef {}\n impl ast::AttrsOwner for FnDef {}\n impl FnDef {\n     pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![const]) }\n-    pub fn default_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, T![default])\n-    }\n-    pub fn async_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![async]) }\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![unsafe]) }\n-    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![fn]) }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n+    pub fn default_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![default]) }\n+    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n+    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fn]) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![;]) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RetType {\n@@ -75,7 +73,7 @@ impl AstNode for RetType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RetType {\n-    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![->]) }\n+    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![->]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -99,9 +97,9 @@ impl ast::TypeParamsOwner for StructDef {}\n impl ast::AttrsOwner for StructDef {}\n impl ast::DocCommentsOwner for StructDef {}\n impl StructDef {\n-    pub fn struct_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![struct]) }\n+    pub fn struct_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![struct]) }\n     pub fn field_def_list(&self) -> Option<FieldDefList> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![;]) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UnionDef {\n@@ -124,7 +122,7 @@ impl ast::TypeParamsOwner for UnionDef {}\n impl ast::AttrsOwner for UnionDef {}\n impl ast::DocCommentsOwner for UnionDef {}\n impl UnionDef {\n-    pub fn union_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![union]) }\n+    pub fn union_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![union]) }\n     pub fn record_field_def_list(&self) -> Option<RecordFieldDefList> {\n         support::child(&self.syntax)\n     }\n@@ -145,9 +143,9 @@ impl AstNode for RecordFieldDefList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RecordFieldDefList {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['{']) }\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn fields(&self) -> AstChildren<RecordFieldDef> { support::children(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['}']) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldDef {\n@@ -186,9 +184,9 @@ impl AstNode for TupleFieldDefList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TupleFieldDefList {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n     pub fn fields(&self) -> AstChildren<TupleFieldDef> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleFieldDef {\n@@ -231,7 +229,7 @@ impl ast::TypeParamsOwner for EnumDef {}\n impl ast::AttrsOwner for EnumDef {}\n impl ast::DocCommentsOwner for EnumDef {}\n impl EnumDef {\n-    pub fn enum_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![enum]) }\n+    pub fn enum_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![enum]) }\n     pub fn variant_list(&self) -> Option<EnumVariantList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -250,9 +248,9 @@ impl AstNode for EnumVariantList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl EnumVariantList {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['{']) }\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn variants(&self) -> AstChildren<EnumVariant> { support::children(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['}']) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EnumVariant {\n@@ -275,7 +273,7 @@ impl ast::DocCommentsOwner for EnumVariant {}\n impl ast::AttrsOwner for EnumVariant {}\n impl EnumVariant {\n     pub fn field_def_list(&self) -> Option<FieldDefList> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -300,9 +298,9 @@ impl ast::DocCommentsOwner for TraitDef {}\n impl ast::TypeParamsOwner for TraitDef {}\n impl ast::TypeBoundsOwner for TraitDef {}\n impl TraitDef {\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![unsafe]) }\n-    pub fn auto_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![auto]) }\n-    pub fn trait_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![trait]) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n+    pub fn auto_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![auto]) }\n+    pub fn trait_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![trait]) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -325,9 +323,9 @@ impl ast::NameOwner for Module {}\n impl ast::AttrsOwner for Module {}\n impl ast::DocCommentsOwner for Module {}\n impl Module {\n-    pub fn mod_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mod]) }\n+    pub fn mod_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mod]) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![;]) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ItemList {\n@@ -346,9 +344,9 @@ impl AstNode for ItemList {\n }\n impl ast::ModuleItemOwner for ItemList {}\n impl ItemList {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['{']) }\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn impl_items(&self) -> AstChildren<ImplItem> { support::children(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['}']) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstDef {\n@@ -372,13 +370,11 @@ impl ast::AttrsOwner for ConstDef {}\n impl ast::DocCommentsOwner for ConstDef {}\n impl ast::TypeAscriptionOwner for ConstDef {}\n impl ConstDef {\n-    pub fn default_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, T![default])\n-    }\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![const]) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=]) }\n+    pub fn default_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![default]) }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![;]) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct StaticDef {\n@@ -402,11 +398,11 @@ impl ast::AttrsOwner for StaticDef {}\n impl ast::DocCommentsOwner for StaticDef {}\n impl ast::TypeAscriptionOwner for StaticDef {}\n impl StaticDef {\n-    pub fn static_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![static]) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=]) }\n+    pub fn static_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![static]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![;]) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeAliasDef {\n@@ -430,13 +426,11 @@ impl ast::AttrsOwner for TypeAliasDef {}\n impl ast::DocCommentsOwner for TypeAliasDef {}\n impl ast::TypeBoundsOwner for TypeAliasDef {}\n impl TypeAliasDef {\n-    pub fn default_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, T![default])\n-    }\n-    pub fn type_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![type]) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=]) }\n+    pub fn default_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![default]) }\n+    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![type]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![;]) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ImplDef {\n@@ -456,14 +450,12 @@ impl AstNode for ImplDef {\n impl ast::TypeParamsOwner for ImplDef {}\n impl ast::AttrsOwner for ImplDef {}\n impl ImplDef {\n-    pub fn default_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, T![default])\n-    }\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![const]) }\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![unsafe]) }\n-    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![impl]) }\n-    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![!]) }\n-    pub fn for_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![for]) }\n+    pub fn default_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![default]) }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n+    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![impl]) }\n+    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n+    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -482,9 +474,9 @@ impl AstNode for ParenType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ParenType {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleType {\n@@ -502,9 +494,9 @@ impl AstNode for TupleType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TupleType {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n     pub fn fields(&self) -> AstChildren<TypeRef> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NeverType {\n@@ -522,7 +514,7 @@ impl AstNode for NeverType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl NeverType {\n-    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![!]) }\n+    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathType {\n@@ -558,9 +550,9 @@ impl AstNode for PointerType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PointerType {\n-    pub fn star_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![*]) }\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![const]) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n+    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![*]) }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -579,11 +571,11 @@ impl AstNode for ArrayType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ArrayType {\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['[']) }\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![;]) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![']']) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SliceType {\n@@ -601,9 +593,9 @@ impl AstNode for SliceType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl SliceType {\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['[']) }\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![']']) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ReferenceType {\n@@ -621,11 +613,11 @@ impl AstNode for ReferenceType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ReferenceType {\n-    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![&]) }\n+    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, T![lifetime])\n+        support::token(&self.syntax, T![lifetime])\n     }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -644,7 +636,7 @@ impl AstNode for PlaceholderType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PlaceholderType {\n-    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![_]) }\n+    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FnPointerType {\n@@ -663,8 +655,8 @@ impl AstNode for FnPointerType {\n }\n impl FnPointerType {\n     pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![unsafe]) }\n-    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![fn]) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n+    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fn]) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n }\n@@ -684,7 +676,7 @@ impl AstNode for ForType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ForType {\n-    pub fn for_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![for]) }\n+    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n     pub fn type_param_list(&self) -> Option<TypeParamList> { support::child(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n@@ -705,7 +697,7 @@ impl AstNode for ImplTraitType {\n }\n impl ast::TypeBoundsOwner for ImplTraitType {}\n impl ImplTraitType {\n-    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![impl]) }\n+    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![impl]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DynTraitType {\n@@ -724,7 +716,7 @@ impl AstNode for DynTraitType {\n }\n impl ast::TypeBoundsOwner for DynTraitType {}\n impl DynTraitType {\n-    pub fn dyn_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![dyn]) }\n+    pub fn dyn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![dyn]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleExpr {\n@@ -743,9 +735,9 @@ impl AstNode for TupleExpr {\n }\n impl ast::AttrsOwner for TupleExpr {}\n impl TupleExpr {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n     pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArrayExpr {\n@@ -764,10 +756,10 @@ impl AstNode for ArrayExpr {\n }\n impl ast::AttrsOwner for ArrayExpr {}\n impl ArrayExpr {\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['[']) }\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n     pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![;]) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![']']) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenExpr {\n@@ -786,9 +778,9 @@ impl AstNode for ParenExpr {\n }\n impl ast::AttrsOwner for ParenExpr {}\n impl ParenExpr {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathExpr {\n@@ -825,9 +817,9 @@ impl AstNode for LambdaExpr {\n }\n impl ast::AttrsOwner for LambdaExpr {}\n impl LambdaExpr {\n-    pub fn static_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![static]) }\n-    pub fn async_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![async]) }\n-    pub fn move_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![move]) }\n+    pub fn static_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![static]) }\n+    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n+    pub fn move_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![move]) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n@@ -849,7 +841,7 @@ impl AstNode for IfExpr {\n }\n impl ast::AttrsOwner for IfExpr {}\n impl IfExpr {\n-    pub fn if_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![if]) }\n+    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -870,7 +862,7 @@ impl AstNode for LoopExpr {\n impl ast::AttrsOwner for LoopExpr {}\n impl ast::LoopBodyOwner for LoopExpr {}\n impl LoopExpr {\n-    pub fn loop_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![loop]) }\n+    pub fn loop_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![loop]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TryBlockExpr {\n@@ -889,7 +881,7 @@ impl AstNode for TryBlockExpr {\n }\n impl ast::AttrsOwner for TryBlockExpr {}\n impl TryBlockExpr {\n-    pub fn try_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![try]) }\n+    pub fn try_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![try]) }\n     pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -910,9 +902,9 @@ impl AstNode for ForExpr {\n impl ast::AttrsOwner for ForExpr {}\n impl ast::LoopBodyOwner for ForExpr {}\n impl ForExpr {\n-    pub fn for_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![for]) }\n+    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn in_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![in]) }\n+    pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }\n     pub fn iterable(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -933,7 +925,7 @@ impl AstNode for WhileExpr {\n impl ast::AttrsOwner for WhileExpr {}\n impl ast::LoopBodyOwner for WhileExpr {}\n impl WhileExpr {\n-    pub fn while_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![while]) }\n+    pub fn while_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![while]) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -954,10 +946,10 @@ impl AstNode for ContinueExpr {\n impl ast::AttrsOwner for ContinueExpr {}\n impl ContinueExpr {\n     pub fn continue_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, T![continue])\n+        support::token(&self.syntax, T![continue])\n     }\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, T![lifetime])\n+        support::token(&self.syntax, T![lifetime])\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -977,9 +969,9 @@ impl AstNode for BreakExpr {\n }\n impl ast::AttrsOwner for BreakExpr {}\n impl BreakExpr {\n-    pub fn break_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![break]) }\n+    pub fn break_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![break]) }\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, T![lifetime])\n+        support::token(&self.syntax, T![lifetime])\n     }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n@@ -1000,7 +992,7 @@ impl AstNode for Label {\n }\n impl Label {\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, T![lifetime])\n+        support::token(&self.syntax, T![lifetime])\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1021,7 +1013,7 @@ impl AstNode for BlockExpr {\n impl ast::AttrsOwner for BlockExpr {}\n impl BlockExpr {\n     pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![unsafe]) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n     pub fn block(&self) -> Option<Block> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1081,7 +1073,7 @@ impl ast::AttrsOwner for MethodCallExpr {}\n impl ast::ArgListOwner for MethodCallExpr {}\n impl MethodCallExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![.]) }\n+    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n }\n@@ -1102,8 +1094,8 @@ impl AstNode for IndexExpr {\n }\n impl ast::AttrsOwner for IndexExpr {}\n impl IndexExpr {\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['[']) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![']']) }\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FieldExpr {\n@@ -1123,7 +1115,7 @@ impl AstNode for FieldExpr {\n impl ast::AttrsOwner for FieldExpr {}\n impl FieldExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![.]) }\n+    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1144,8 +1136,8 @@ impl AstNode for AwaitExpr {\n impl ast::AttrsOwner for AwaitExpr {}\n impl AwaitExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![.]) }\n-    pub fn await_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![await]) }\n+    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n+    pub fn await_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![await]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TryExpr {\n@@ -1164,7 +1156,7 @@ impl AstNode for TryExpr {\n }\n impl ast::AttrsOwner for TryExpr {}\n impl TryExpr {\n-    pub fn try_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![try]) }\n+    pub fn try_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![try]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1185,7 +1177,7 @@ impl AstNode for CastExpr {\n impl ast::AttrsOwner for CastExpr {}\n impl CastExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn as_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![as]) }\n+    pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1205,9 +1197,9 @@ impl AstNode for RefExpr {\n }\n impl ast::AttrsOwner for RefExpr {}\n impl RefExpr {\n-    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![&]) }\n-    pub fn raw_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![raw]) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n+    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n+    pub fn raw_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![raw]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1246,7 +1238,7 @@ impl AstNode for BoxExpr {\n }\n impl ast::AttrsOwner for BoxExpr {}\n impl BoxExpr {\n-    pub fn box_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![box]) }\n+    pub fn box_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![box]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1316,7 +1308,7 @@ impl AstNode for MatchExpr {\n }\n impl ast::AttrsOwner for MatchExpr {}\n impl MatchExpr {\n-    pub fn match_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![match]) }\n+    pub fn match_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![match]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn match_arm_list(&self) -> Option<MatchArmList> { support::child(&self.syntax) }\n }\n@@ -1337,9 +1329,9 @@ impl AstNode for MatchArmList {\n }\n impl ast::AttrsOwner for MatchArmList {}\n impl MatchArmList {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['{']) }\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn arms(&self) -> AstChildren<MatchArm> { support::children(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['}']) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchArm {\n@@ -1360,7 +1352,7 @@ impl ast::AttrsOwner for MatchArm {}\n impl MatchArm {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn guard(&self) -> Option<MatchGuard> { support::child(&self.syntax) }\n-    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=>]) }\n+    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=>]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1379,7 +1371,7 @@ impl AstNode for MatchGuard {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl MatchGuard {\n-    pub fn if_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![if]) }\n+    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1417,11 +1409,11 @@ impl AstNode for RecordFieldList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RecordFieldList {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['{']) }\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn fields(&self) -> AstChildren<RecordField> { support::children(&self.syntax) }\n-    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![..]) }\n+    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n     pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['}']) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordField {\n@@ -1441,7 +1433,7 @@ impl AstNode for RecordField {\n impl ast::AttrsOwner for RecordField {}\n impl RecordField {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![:]) }\n+    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1478,9 +1470,9 @@ impl AstNode for ParenPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ParenPat {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefPat {\n@@ -1498,8 +1490,8 @@ impl AstNode for RefPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RefPat {\n-    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![&]) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n+    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1518,7 +1510,7 @@ impl AstNode for BoxPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl BoxPat {\n-    pub fn box_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![box]) }\n+    pub fn box_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![box]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1539,9 +1531,9 @@ impl AstNode for BindPat {\n impl ast::AttrsOwner for BindPat {}\n impl ast::NameOwner for BindPat {}\n impl BindPat {\n-    pub fn ref_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![ref]) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n-    pub fn at_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![@]) }\n+    pub fn ref_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ref]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n+    pub fn at_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![@]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1560,7 +1552,7 @@ impl AstNode for PlaceholderPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PlaceholderPat {\n-    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![_]) }\n+    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DotDotPat {\n@@ -1578,7 +1570,7 @@ impl AstNode for DotDotPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl DotDotPat {\n-    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![..]) }\n+    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathPat {\n@@ -1614,9 +1606,9 @@ impl AstNode for SlicePat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl SlicePat {\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['[']) }\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![']']) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RangePat {\n@@ -1707,14 +1699,14 @@ impl AstNode for RecordFieldPatList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RecordFieldPatList {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['{']) }\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn pats(&self) -> AstChildren<RecordInnerPat> { support::children(&self.syntax) }\n     pub fn record_field_pats(&self) -> AstChildren<RecordFieldPat> {\n         support::children(&self.syntax)\n     }\n     pub fn bind_pats(&self) -> AstChildren<BindPat> { support::children(&self.syntax) }\n-    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![..]) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['}']) }\n+    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldPat {\n@@ -1734,7 +1726,7 @@ impl AstNode for RecordFieldPat {\n impl ast::AttrsOwner for RecordFieldPat {}\n impl ast::NameOwner for RecordFieldPat {}\n impl RecordFieldPat {\n-    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![:]) }\n+    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1754,9 +1746,9 @@ impl AstNode for TupleStructPat {\n }\n impl TupleStructPat {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TuplePat {\n@@ -1774,9 +1766,9 @@ impl AstNode for TuplePat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TuplePat {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Visibility {\n@@ -1794,10 +1786,10 @@ impl AstNode for Visibility {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Visibility {\n-    pub fn pub_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![pub]) }\n-    pub fn super_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![super]) }\n-    pub fn self_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![self]) }\n-    pub fn crate_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![crate]) }\n+    pub fn pub_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![pub]) }\n+    pub fn super_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![super]) }\n+    pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }\n+    pub fn crate_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![crate]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Name {\n@@ -1815,7 +1807,7 @@ impl AstNode for Name {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Name {\n-    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![ident]) }\n+    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NameRef {\n@@ -1853,9 +1845,9 @@ impl ast::AttrsOwner for MacroCall {}\n impl ast::DocCommentsOwner for MacroCall {}\n impl MacroCall {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![!]) }\n+    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n     pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![;]) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Attr {\n@@ -1873,13 +1865,13 @@ impl AstNode for Attr {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Attr {\n-    pub fn pound_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![#]) }\n-    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![!]) }\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['[']) }\n+    pub fn pound_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![#]) }\n+    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn input(&self) -> Option<AttrInput> { support::child(&self.syntax) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![']']) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TokenTree {\n@@ -1913,12 +1905,12 @@ impl AstNode for TypeParamList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TypeParamList {\n-    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![<]) }\n+    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n     pub fn generic_params(&self) -> AstChildren<GenericParam> { support::children(&self.syntax) }\n     pub fn type_params(&self) -> AstChildren<TypeParam> { support::children(&self.syntax) }\n     pub fn lifetime_params(&self) -> AstChildren<LifetimeParam> { support::children(&self.syntax) }\n     pub fn const_params(&self) -> AstChildren<ConstParam> { support::children(&self.syntax) }\n-    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![>]) }\n+    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeParam {\n@@ -1939,7 +1931,7 @@ impl ast::NameOwner for TypeParam {}\n impl ast::AttrsOwner for TypeParam {}\n impl ast::TypeBoundsOwner for TypeParam {}\n impl TypeParam {\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn default_type(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1961,7 +1953,7 @@ impl ast::NameOwner for ConstParam {}\n impl ast::AttrsOwner for ConstParam {}\n impl ast::TypeAscriptionOwner for ConstParam {}\n impl ConstParam {\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn default_val(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1982,7 +1974,7 @@ impl AstNode for LifetimeParam {\n impl ast::AttrsOwner for LifetimeParam {}\n impl LifetimeParam {\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, T![lifetime])\n+        support::token(&self.syntax, T![lifetime])\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2002,9 +1994,9 @@ impl AstNode for TypeBound {\n }\n impl TypeBound {\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, T![lifetime])\n+        support::token(&self.syntax, T![lifetime])\n     }\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![const]) }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2043,7 +2035,7 @@ impl AstNode for WherePred {\n impl ast::TypeBoundsOwner for WherePred {}\n impl WherePred {\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, T![lifetime])\n+        support::token(&self.syntax, T![lifetime])\n     }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n@@ -2063,7 +2055,7 @@ impl AstNode for WhereClause {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl WhereClause {\n-    pub fn where_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![where]) }\n+    pub fn where_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![where]) }\n     pub fn predicates(&self) -> AstChildren<WherePred> { support::children(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2100,7 +2092,7 @@ impl AstNode for ExprStmt {\n impl ast::AttrsOwner for ExprStmt {}\n impl ExprStmt {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![;]) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LetStmt {\n@@ -2120,11 +2112,11 @@ impl AstNode for LetStmt {\n impl ast::AttrsOwner for LetStmt {}\n impl ast::TypeAscriptionOwner for LetStmt {}\n impl LetStmt {\n-    pub fn let_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![let]) }\n+    pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn initializer(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![;]) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Condition {\n@@ -2142,9 +2134,9 @@ impl AstNode for Condition {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Condition {\n-    pub fn let_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![let]) }\n+    pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2165,10 +2157,10 @@ impl AstNode for Block {\n impl ast::AttrsOwner for Block {}\n impl ast::ModuleItemOwner for Block {}\n impl Block {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['{']) }\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['}']) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParamList {\n@@ -2186,10 +2178,10 @@ impl AstNode for ParamList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ParamList {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n     pub fn self_param(&self) -> Option<SelfParam> { support::child(&self.syntax) }\n     pub fn params(&self) -> AstChildren<Param> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SelfParam {\n@@ -2209,11 +2201,11 @@ impl AstNode for SelfParam {\n impl ast::TypeAscriptionOwner for SelfParam {}\n impl ast::AttrsOwner for SelfParam {}\n impl SelfParam {\n-    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![&]) }\n+    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, T![lifetime])\n+        support::token(&self.syntax, T![lifetime])\n     }\n-    pub fn self_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![self]) }\n+    pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Param {\n@@ -2234,7 +2226,7 @@ impl ast::TypeAscriptionOwner for Param {}\n impl ast::AttrsOwner for Param {}\n impl Param {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn dotdotdot_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![...]) }\n+    pub fn dotdotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![...]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseItem {\n@@ -2254,7 +2246,7 @@ impl AstNode for UseItem {\n impl ast::AttrsOwner for UseItem {}\n impl ast::VisibilityOwner for UseItem {}\n impl UseItem {\n-    pub fn use_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![use]) }\n+    pub fn use_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![use]) }\n     pub fn use_tree(&self) -> Option<UseTree> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2274,7 +2266,7 @@ impl AstNode for UseTree {\n }\n impl UseTree {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn star_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![*]) }\n+    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![*]) }\n     pub fn use_tree_list(&self) -> Option<UseTreeList> { support::child(&self.syntax) }\n     pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n }\n@@ -2295,7 +2287,7 @@ impl AstNode for Alias {\n }\n impl ast::NameOwner for Alias {}\n impl Alias {\n-    pub fn as_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![as]) }\n+    pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseTreeList {\n@@ -2313,9 +2305,9 @@ impl AstNode for UseTreeList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl UseTreeList {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['{']) }\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn use_trees(&self) -> AstChildren<UseTree> { support::children(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['}']) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternCrateItem {\n@@ -2335,8 +2327,8 @@ impl AstNode for ExternCrateItem {\n impl ast::AttrsOwner for ExternCrateItem {}\n impl ast::VisibilityOwner for ExternCrateItem {}\n impl ExternCrateItem {\n-    pub fn extern_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![extern]) }\n-    pub fn crate_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![crate]) }\n+    pub fn extern_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![extern]) }\n+    pub fn crate_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![crate]) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n }\n@@ -2356,9 +2348,9 @@ impl AstNode for ArgList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ArgList {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n     pub fn args(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n@@ -2395,14 +2387,14 @@ impl AstNode for PathSegment {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PathSegment {\n-    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![::]) }\n-    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![<]) }\n+    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n+    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn path_type(&self) -> Option<PathType> { support::child(&self.syntax) }\n-    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![>]) }\n+    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArgList {\n@@ -2420,14 +2412,14 @@ impl AstNode for TypeArgList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TypeArgList {\n-    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![::]) }\n-    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![<]) }\n+    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n+    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n     pub fn generic_args(&self) -> AstChildren<GenericArg> { support::children(&self.syntax) }\n     pub fn type_args(&self) -> AstChildren<TypeArg> { support::children(&self.syntax) }\n     pub fn lifetime_args(&self) -> AstChildren<LifetimeArg> { support::children(&self.syntax) }\n     pub fn assoc_type_args(&self) -> AstChildren<AssocTypeArg> { support::children(&self.syntax) }\n     pub fn const_args(&self) -> AstChildren<ConstArg> { support::children(&self.syntax) }\n-    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![>]) }\n+    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArg {\n@@ -2465,7 +2457,7 @@ impl AstNode for AssocTypeArg {\n impl ast::TypeBoundsOwner for AssocTypeArg {}\n impl AssocTypeArg {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2485,7 +2477,7 @@ impl AstNode for LifetimeArg {\n }\n impl LifetimeArg {\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, T![lifetime])\n+        support::token(&self.syntax, T![lifetime])\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2505,7 +2497,7 @@ impl AstNode for ConstArg {\n }\n impl ConstArg {\n     pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2561,9 +2553,9 @@ impl AstNode for ExternItemList {\n }\n impl ast::ModuleItemOwner for ExternItemList {}\n impl ExternItemList {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['{']) }\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn extern_items(&self) -> AstChildren<ExternItem> { support::children(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['}']) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternBlock {\n@@ -2601,7 +2593,7 @@ impl AstNode for MetaItem {\n }\n impl MetaItem {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn attr_input(&self) -> Option<AttrInput> { support::child(&self.syntax) }\n     pub fn nested_meta_items(&self) -> AstChildren<MetaItem> { support::children(&self.syntax) }\n }"}, {"sha": "bfc05e08bf2438f37e08573c9de7767099f4108a", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada", "patch": "@@ -65,7 +65,7 @@ pub trait TypeBoundsOwner: AstNode {\n     }\n \n     fn colon_token(&self) -> Option<SyntaxToken> {\n-        support::token2(self.syntax(), T![:])\n+        support::token(self.syntax(), T![:])\n     }\n }\n "}, {"sha": "7dc7f396cdfe0c1a0289fcd6f12b0a661ba193b3", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada", "patch": "@@ -3,7 +3,7 @@\n //! Specifically, it generates the `SyntaxKind` enum and a number of newtype\n //! wrappers around `SyntaxNode` which implement `ra_syntax::AstNode`.\n \n-use std::collections::{BTreeSet, HashSet};\n+use std::collections::HashSet;\n \n use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n@@ -20,7 +20,7 @@ pub fn generate_syntax(mode: Mode) -> Result<()> {\n     update(syntax_kinds_file.as_path(), &syntax_kinds, mode)?;\n \n     let ast_tokens_file = project_root().join(codegen::AST_TOKENS);\n-    let contents = generate_tokens(KINDS_SRC, AST_SRC)?;\n+    let contents = generate_tokens(AST_SRC)?;\n     update(ast_tokens_file.as_path(), &contents, mode)?;\n \n     let ast_nodes_file = project_root().join(codegen::AST_NODES);\n@@ -30,14 +30,7 @@ pub fn generate_syntax(mode: Mode) -> Result<()> {\n     Ok(())\n }\n \n-#[derive(Debug, Default, Clone)]\n-struct ElementKinds {\n-    kinds: BTreeSet<proc_macro2::Ident>,\n-    has_nodes: bool,\n-    has_tokens: bool,\n-}\n-\n-fn generate_tokens(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n+fn generate_tokens(grammar: AstSrc<'_>) -> Result<String> {\n     let tokens = grammar.tokens.iter().map(|token| {\n         let name = format_ident!(\"{}\", token);\n         let kind = format_ident!(\"{}\", to_upper_snake_case(token));\n@@ -91,7 +84,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                 if let Some(token_kind) = field.token_kind() {\n                     quote! {\n                         pub fn #method_name(&self) -> Option<#ty> {\n-                            support::token2(&self.syntax, #token_kind)\n+                            support::token(&self.syntax, #token_kind)\n                         }\n                     }\n                 } else {"}]}