{"sha": "7bea518d3a792d9c8df508b0af83ceb857ce75b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiZWE1MThkM2E3OTJkOWM4ZGY1MDhiMGFmODNjZWI4NTdjZTc1Yjc=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2018-07-22T13:25:00Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2018-07-31T23:55:12Z"}, "message": "Remove global derive_id and reset_ids functions\n\nPreviously these functions relied on TLS but we can instead thread the\nrelevant state through explicitly.", "tree": {"sha": "340f650dcce53231b9de42ffcba447189cb12b02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/340f650dcce53231b9de42ffcba447189cb12b02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bea518d3a792d9c8df508b0af83ceb857ce75b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bea518d3a792d9c8df508b0af83ceb857ce75b7", "html_url": "https://github.com/rust-lang/rust/commit/7bea518d3a792d9c8df508b0af83ceb857ce75b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bea518d3a792d9c8df508b0af83ceb857ce75b7/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2216db9de78f2da623bea80594f1d9a7b54ddb54", "url": "https://api.github.com/repos/rust-lang/rust/commits/2216db9de78f2da623bea80594f1d9a7b54ddb54", "html_url": "https://github.com/rust-lang/rust/commit/2216db9de78f2da623bea80594f1d9a7b54ddb54"}], "stats": {"total": 343, "additions": 190, "deletions": 153}, "files": [{"sha": "9631ea059cc4300f0337ac755716024033e3133a", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bea518d3a792d9c8df508b0af83ceb857ce75b7/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bea518d3a792d9c8df508b0af83ceb857ce75b7/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=7bea518d3a792d9c8df508b0af83ceb857ce75b7", "patch": "@@ -13,7 +13,8 @@ use std::path::Path;\n use std::str;\n use errors;\n use syntax::feature_gate::UnstableFeatures;\n-use html::markdown::{ErrorCodes, Markdown};\n+use html::markdown::{IdMap, ErrorCodes, Markdown};\n+use std::cell::RefCell;\n \n #[derive(Clone)]\n pub struct ExternalHtml {\n@@ -30,7 +31,8 @@ pub struct ExternalHtml {\n \n impl ExternalHtml {\n     pub fn load(in_header: &[String], before_content: &[String], after_content: &[String],\n-                md_before_content: &[String], md_after_content: &[String], diag: &errors::Handler)\n+                md_before_content: &[String], md_after_content: &[String], diag: &errors::Handler,\n+                id_map: &mut IdMap)\n             -> Option<ExternalHtml> {\n         let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n         load_external_files(in_header, diag)\n@@ -40,15 +42,17 @@ impl ExternalHtml {\n             )\n             .and_then(|(ih, bc)|\n                 load_external_files(md_before_content, diag)\n-                    .map(|m_bc| (ih, format!(\"{}{}\", bc, Markdown(&m_bc, &[], codes))))\n+                    .map(|m_bc| (ih,\n+                            format!(\"{}{}\", bc, Markdown(&m_bc, &[], RefCell::new(id_map), codes))))\n             )\n             .and_then(|(ih, bc)|\n                 load_external_files(after_content, diag)\n                     .map(|ac| (ih, bc, ac))\n             )\n             .and_then(|(ih, bc, ac)|\n                 load_external_files(md_after_content, diag)\n-                    .map(|m_ac| (ih, bc, format!(\"{}{}\", ac, Markdown(&m_ac, &[], codes))))\n+                    .map(|m_ac| (ih, bc,\n+                            format!(\"{}{}\", ac, Markdown(&m_ac, &[], RefCell::new(id_map), codes))))\n             )\n             .map(|(ih, bc, ac)|\n                 ExternalHtml {"}, {"sha": "706671f21eff5356b4008bc47f44335aa606464c", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 105, "deletions": 49, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/7bea518d3a792d9c8df508b0af83ceb857ce75b7/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bea518d3a792d9c8df508b0af83ceb857ce75b7/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=7bea518d3a792d9c8df508b0af83ceb857ce75b7", "patch": "@@ -18,10 +18,12 @@\n //! ```\n //! #![feature(rustc_private)]\n //!\n-//! use rustdoc::html::markdown::{Markdown, ErrorCodes};\n+//! use rustdoc::html::markdown::{IdMap, Markdown, ErrorCodes};\n+//! use std::cell::RefCell;\n //!\n //! let s = \"My *markdown* _text_\";\n-//! let html = format!(\"{}\", Markdown(s, &[], ErrorCodes::Yes));\n+//! let mut id_map = IdMap::new();\n+//! let html = format!(\"{}\", Markdown(s, &[], RefCell::new(&mut id_map), ErrorCodes::Yes));\n //! // ... something using html\n //! ```\n \n@@ -35,7 +37,6 @@ use std::borrow::Cow;\n use std::ops::Range;\n use std::str;\n \n-use html::render::derive_id;\n use html::toc::TocBuilder;\n use html::highlight;\n use test;\n@@ -47,12 +48,13 @@ use pulldown_cmark::{Options, OPTION_ENABLE_FOOTNOTES, OPTION_ENABLE_TABLES};\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n /// The second parameter is a list of link replacements\n-pub struct Markdown<'a>(pub &'a str, pub &'a [(String, String)], pub ErrorCodes);\n+pub struct Markdown<'a>(\n+    pub &'a str, pub &'a [(String, String)], pub RefCell<&'a mut IdMap>, pub ErrorCodes);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n-pub struct MarkdownWithToc<'a>(pub &'a str, pub ErrorCodes);\n+pub struct MarkdownWithToc<'a>(pub &'a str, pub RefCell<&'a mut IdMap>, pub ErrorCodes);\n /// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n-pub struct MarkdownHtml<'a>(pub &'a str, pub ErrorCodes);\n+pub struct MarkdownHtml<'a>(pub &'a str, pub RefCell<&'a mut IdMap>, pub ErrorCodes);\n /// A unit struct like `Markdown`, that renders only the first paragraph.\n pub struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [(String, String)]);\n \n@@ -287,23 +289,25 @@ impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, 'b, I>\n }\n \n /// Make headings links with anchor ids and build up TOC.\n-struct HeadingLinks<'a, 'b, I: Iterator<Item = Event<'a>>> {\n+struct HeadingLinks<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> {\n     inner: I,\n     toc: Option<&'b mut TocBuilder>,\n     buf: VecDeque<Event<'a>>,\n+    id_map: &'ids mut IdMap,\n }\n \n-impl<'a, 'b, I: Iterator<Item = Event<'a>>> HeadingLinks<'a, 'b, I> {\n-    fn new(iter: I, toc: Option<&'b mut TocBuilder>) -> Self {\n+impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> HeadingLinks<'a, 'b, 'ids, I> {\n+    fn new(iter: I, toc: Option<&'b mut TocBuilder>, ids: &'ids mut IdMap) -> Self {\n         HeadingLinks {\n             inner: iter,\n             toc,\n             buf: VecDeque::new(),\n+            id_map: ids,\n         }\n     }\n }\n \n-impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, I> {\n+impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, 'ids, I> {\n     type Item = Event<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -322,7 +326,7 @@ impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, I>\n                 }\n                 self.buf.push_back(event);\n             }\n-            let id = derive_id(id);\n+            let id = self.id_map.derive(id);\n \n             if let Some(ref mut builder) = self.toc {\n                 let mut html_header = String::new();\n@@ -641,7 +645,8 @@ impl LangString {\n \n impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Markdown(md, links, codes) = *self;\n+        let Markdown(md, links, ref ids, codes) = *self;\n+        let mut ids = ids.borrow_mut();\n \n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n@@ -661,7 +666,7 @@ impl<'a> fmt::Display for Markdown<'a> {\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n-        let p = HeadingLinks::new(p, None);\n+        let p = HeadingLinks::new(p, None, &mut ids);\n         let p = LinkReplacer::new(p, links);\n         let p = CodeBlocks::new(p, codes);\n         let p = Footnotes::new(p);\n@@ -673,7 +678,8 @@ impl<'a> fmt::Display for Markdown<'a> {\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let MarkdownWithToc(md, codes) = *self;\n+        let MarkdownWithToc(md, ref ids, codes) = *self;\n+        let mut ids = ids.borrow_mut();\n \n         let mut opts = Options::empty();\n         opts.insert(OPTION_ENABLE_TABLES);\n@@ -686,7 +692,7 @@ impl<'a> fmt::Display for MarkdownWithToc<'a> {\n         let mut toc = TocBuilder::new();\n \n         {\n-            let p = HeadingLinks::new(p, Some(&mut toc));\n+            let p = HeadingLinks::new(p, Some(&mut toc), &mut ids);\n             let p = CodeBlocks::new(p, codes);\n             let p = Footnotes::new(p);\n             html::push_html(&mut s, p);\n@@ -700,7 +706,8 @@ impl<'a> fmt::Display for MarkdownWithToc<'a> {\n \n impl<'a> fmt::Display for MarkdownHtml<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let MarkdownHtml(md, codes) = *self;\n+        let MarkdownHtml(md, ref ids, codes) = *self;\n+        let mut ids = ids.borrow_mut();\n \n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n@@ -718,7 +725,7 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n-        let p = HeadingLinks::new(p, None);\n+        let p = HeadingLinks::new(p, None, &mut ids);\n         let p = CodeBlocks::new(p, codes);\n         let p = Footnotes::new(p);\n         html::push_html(&mut s, p);\n@@ -835,7 +842,10 @@ pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n         let p = Parser::new_with_broken_link_callback(md, opts,\n             Some(&push));\n \n-        let iter = Footnotes::new(HeadingLinks::new(p, None));\n+        // There's no need to thread an IdMap through to here because\n+        // the IDs generated aren't going to be emitted anywhere.\n+        let mut ids = IdMap::new();\n+        let iter = Footnotes::new(HeadingLinks::new(p, None, &mut ids));\n \n         for ev in iter {\n             if let Event::Start(Tag::Link(dest, _)) = ev {\n@@ -854,11 +864,67 @@ pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n     links\n }\n \n+#[derive(Default)]\n+pub struct IdMap {\n+    map: HashMap<String, usize>,\n+}\n+\n+impl IdMap {\n+    pub fn new() -> Self {\n+        IdMap::default()\n+    }\n+\n+    pub fn populate<I: IntoIterator<Item=String>>(&mut self, ids: I) {\n+        for id in ids {\n+            let _ = self.derive(id);\n+        }\n+    }\n+\n+    pub fn reset(&mut self) {\n+        self.map = HashMap::new();\n+    }\n+\n+    pub fn derive(&mut self, candidate: String) -> String {\n+        let id = match self.map.get_mut(&candidate) {\n+            None => candidate,\n+            Some(a) => {\n+                let id = format!(\"{}-{}\", candidate, *a);\n+                *a += 1;\n+                id\n+            }\n+        };\n+\n+        self.map.insert(id.clone(), 1);\n+        id\n+    }\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_unique_id() {\n+    let input = [\"foo\", \"examples\", \"examples\", \"method.into_iter\",\"examples\",\n+                 \"method.into_iter\", \"foo\", \"main\", \"search\", \"methods\",\n+                 \"examples\", \"method.into_iter\", \"assoc_type.Item\", \"assoc_type.Item\"];\n+    let expected = [\"foo\", \"examples\", \"examples-1\", \"method.into_iter\", \"examples-2\",\n+                    \"method.into_iter-1\", \"foo-1\", \"main\", \"search\", \"methods\",\n+                    \"examples-3\", \"method.into_iter-2\", \"assoc_type.Item\", \"assoc_type.Item-1\"];\n+\n+    let map = RefCell::new(IdMap::new());\n+    let test = || {\n+        let mut map = map.borrow_mut();\n+        let actual: Vec<String> = input.iter().map(|s| map.derive(s.to_string())).collect();\n+        assert_eq!(&actual[..], expected);\n+    };\n+    test();\n+    map.borrow_mut().reset();\n+    test();\n+}\n+\n #[cfg(test)]\n mod tests {\n-    use super::{ErrorCodes, LangString, Markdown, MarkdownHtml};\n+    use super::{ErrorCodes, LangString, Markdown, MarkdownHtml, IdMap};\n     use super::plain_summary_line;\n-    use html::render::reset_ids;\n+    use std::cell::RefCell;\n \n     #[test]\n     fn test_lang_string_parse() {\n@@ -901,19 +967,12 @@ mod tests {\n         t(\"text,no_run\",           false,        true,   false,  false, false, false, false, v());\n     }\n \n-    #[test]\n-    fn issue_17736() {\n-        let markdown = \"# title\";\n-        Markdown(markdown, &[], ErrorCodes::Yes).to_string();\n-        reset_ids(true);\n-    }\n-\n     #[test]\n     fn test_header() {\n         fn t(input: &str, expect: &str) {\n-            let output = Markdown(input, &[], ErrorCodes::Yes).to_string();\n+            let mut map = IdMap::new();\n+            let output = Markdown(input, &[], RefCell::new(&mut map), ErrorCodes::Yes).to_string();\n             assert_eq!(output, expect, \"original: {}\", input);\n-            reset_ids(true);\n         }\n \n         t(\"# Foo bar\", \"<h1 id=\\\"foo-bar\\\" class=\\\"section-header\\\">\\\n@@ -932,28 +991,24 @@ mod tests {\n \n     #[test]\n     fn test_header_ids_multiple_blocks() {\n-        fn t(input: &str, expect: &str) {\n-            let output = Markdown(input, &[], ErrorCodes::Yes).to_string();\n+        let mut map = IdMap::new();\n+        fn t(map: &mut IdMap, input: &str, expect: &str) {\n+            let output = Markdown(input, &[], RefCell::new(map), ErrorCodes::Yes).to_string();\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n-        let test = || {\n-            t(\"# Example\", \"<h1 id=\\\"example\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#example\\\">Example</a></h1>\");\n-            t(\"# Panics\", \"<h1 id=\\\"panics\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#panics\\\">Panics</a></h1>\");\n-            t(\"# Example\", \"<h1 id=\\\"example-1\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#example-1\\\">Example</a></h1>\");\n-            t(\"# Main\", \"<h1 id=\\\"main-1\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#main-1\\\">Main</a></h1>\");\n-            t(\"# Example\", \"<h1 id=\\\"example-2\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#example-2\\\">Example</a></h1>\");\n-            t(\"# Panics\", \"<h1 id=\\\"panics-1\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#panics-1\\\">Panics</a></h1>\");\n-        };\n-        test();\n-        reset_ids(true);\n-        test();\n+        t(&mut map, \"# Example\", \"<h1 id=\\\"example\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#example\\\">Example</a></h1>\");\n+        t(&mut map, \"# Panics\", \"<h1 id=\\\"panics\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#panics\\\">Panics</a></h1>\");\n+        t(&mut map, \"# Example\", \"<h1 id=\\\"example-1\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#example-1\\\">Example</a></h1>\");\n+        t(&mut map, \"# Main\", \"<h1 id=\\\"main\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#main\\\">Main</a></h1>\");\n+        t(&mut map, \"# Example\", \"<h1 id=\\\"example-2\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#example-2\\\">Example</a></h1>\");\n+        t(&mut map, \"# Panics\", \"<h1 id=\\\"panics-1\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#panics-1\\\">Panics</a></h1>\");\n     }\n \n     #[test]\n@@ -974,7 +1029,8 @@ mod tests {\n     #[test]\n     fn test_markdown_html_escape() {\n         fn t(input: &str, expect: &str) {\n-            let output = MarkdownHtml(input, ErrorCodes::Yes).to_string();\n+            let mut idmap = IdMap::new();\n+            let output = MarkdownHtml(input, RefCell::new(&mut idmap), ErrorCodes::Yes).to_string();\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n "}, {"sha": "c1375fd37fd697532f152fd7b9194f075f824965", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 59, "deletions": 88, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/7bea518d3a792d9c8df508b0af83ceb857ce75b7/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bea518d3a792d9c8df508b0af83ceb857ce75b7/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7bea518d3a792d9c8df508b0af83ceb857ce75b7", "patch": "@@ -50,6 +50,7 @@ use std::mem;\n use std::path::{PathBuf, Path, Component};\n use std::str;\n use std::sync::Arc;\n+use std::rc::Rc;\n \n use externalfiles::ExternalHtml;\n \n@@ -73,7 +74,7 @@ use html::format::{GenericBounds, WhereClause, href, AbiSpace};\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n use html::item_type::ItemType;\n-use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes};\n+use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n use html::{highlight, layout};\n \n use minifier;\n@@ -89,7 +90,7 @@ pub type NameDoc = (String, Option<String>);\n /// easily cloned because it is cloned per work-job (about once per item in the\n /// rustdoc tree).\n #[derive(Clone)]\n-pub struct Context {\n+struct Context {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n     pub current: Vec<String>,\n@@ -101,10 +102,12 @@ pub struct Context {\n     /// publicly reused items to redirect to the right location.\n     pub render_redirect_pages: bool,\n     pub codes: ErrorCodes,\n+    /// The map used to ensure all generated 'id=' attributes are unique.\n+    id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n }\n \n-pub struct SharedContext {\n+struct SharedContext {\n     /// The path to the crate root source minus the file name.\n     /// Used for simplifying paths to the highlighted source code files.\n     pub src_root: PathBuf,\n@@ -452,9 +455,8 @@ impl ToJson for IndexItemFunctionType {\n \n thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> = RefCell::new(Vec::new()));\n-thread_local!(pub static USED_ID_MAP: RefCell<FxHashMap<String, usize>> = RefCell::new(init_ids()));\n \n-fn init_ids() -> FxHashMap<String, usize> {\n+pub fn initial_ids() -> Vec<String> {\n     [\n      \"main\",\n      \"search\",\n@@ -472,36 +474,7 @@ fn init_ids() -> FxHashMap<String, usize> {\n      \"methods\",\n      \"deref-methods\",\n      \"implementations\",\n-    ].into_iter().map(|id| (String::from(*id), 1)).collect()\n-}\n-\n-/// This method resets the local table of used ID attributes. This is typically\n-/// used at the beginning of rendering an entire HTML page to reset from the\n-/// previous state (if any).\n-pub fn reset_ids(embedded: bool) {\n-    USED_ID_MAP.with(|s| {\n-        *s.borrow_mut() = if embedded {\n-            init_ids()\n-        } else {\n-            FxHashMap()\n-        };\n-    });\n-}\n-\n-pub fn derive_id(candidate: String) -> String {\n-    USED_ID_MAP.with(|map| {\n-        let id = match map.borrow_mut().get_mut(&candidate) {\n-            None => candidate,\n-            Some(a) => {\n-                let id = format!(\"{}-{}\", candidate, *a);\n-                *a += 1;\n-                id\n-            }\n-        };\n-\n-        map.borrow_mut().insert(id.clone(), 1);\n-        id\n-    })\n+    ].into_iter().map(|id| (String::from(*id))).collect()\n }\n \n /// Generates the documentation for `crate` into the directory `dst`\n@@ -515,7 +488,8 @@ pub fn run(mut krate: clean::Crate,\n            renderinfo: RenderInfo,\n            sort_modules_alphabetically: bool,\n            themes: Vec<PathBuf>,\n-           enable_minification: bool) -> Result<(), Error> {\n+           enable_minification: bool,\n+           id_map: IdMap) -> Result<(), Error> {\n     let src_root = match krate.src {\n         FileName::Real(ref p) => match p.parent() {\n             Some(p) => p.to_path_buf(),\n@@ -584,6 +558,7 @@ pub fn run(mut krate: clean::Crate,\n         dst,\n         render_redirect_pages: false,\n         codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n+        id_map: Rc::new(RefCell::new(id_map)),\n         shared: Arc::new(scx),\n     };\n \n@@ -1711,6 +1686,11 @@ impl<'a> fmt::Display for Settings<'a> {\n }\n \n impl Context {\n+    fn derive_id(&self, id: String) -> String {\n+        let mut map = self.id_map.borrow_mut();\n+        map.derive(id)\n+    }\n+\n     /// String representation of how to get back to the root path of the 'doc/'\n     /// folder in terms of a relative URL.\n     fn root_path(&self) -> String {\n@@ -1865,7 +1845,10 @@ impl Context {\n             resource_suffix: &self.shared.resource_suffix,\n         };\n \n-        reset_ids(true);\n+        {\n+            self.id_map.borrow_mut().reset();\n+            self.id_map.borrow_mut().populate(initial_ids());\n+        }\n \n         if !self.render_redirect_pages {\n             layout::render(writer, &self.shared.layout, &page,\n@@ -2222,24 +2205,26 @@ fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Re\n \n /// Render md_text as markdown.\n fn render_markdown(w: &mut fmt::Formatter,\n+                   cx: &Context,\n                    md_text: &str,\n                    links: Vec<(String, String)>,\n-                   prefix: &str,\n-                   codes: ErrorCodes)\n+                   prefix: &str)\n                    -> fmt::Result {\n-    write!(w, \"<div class='docblock'>{}{}</div>\", prefix, Markdown(md_text, &links, codes))\n+    let mut ids = cx.id_map.borrow_mut();\n+    write!(w, \"<div class='docblock'>{}{}</div>\",\n+        prefix, Markdown(md_text, &links, RefCell::new(&mut ids), cx.codes))\n }\n \n-fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLink,\n-                  prefix: &str, codes: ErrorCodes) -> fmt::Result {\n+fn document_short(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item, link: AssocItemLink,\n+                  prefix: &str) -> fmt::Result {\n     if let Some(s) = item.doc_value() {\n         let markdown = if s.contains('\\n') {\n             format!(\"{} [Read more]({})\",\n                     &plain_summary_line(Some(s)), naive_assoc_href(item, link))\n         } else {\n             plain_summary_line(Some(s)).to_string()\n         };\n-        render_markdown(w, &markdown, item.links(), prefix, codes)?;\n+        render_markdown(w, cx, &markdown, item.links(), prefix)?;\n     } else if !prefix.is_empty() {\n         write!(w, \"<div class='docblock'>{}</div>\", prefix)?;\n     }\n@@ -2265,7 +2250,7 @@ fn document_full(w: &mut fmt::Formatter, item: &clean::Item,\n                  cx: &Context, prefix: &str) -> fmt::Result {\n     if let Some(s) = cx.shared.maybe_collapsed_doc_value(item) {\n         debug!(\"Doc block: =====\\n{}\\n=====\", s);\n-        render_markdown(w, &*s, item.links(), prefix, cx.codes)?;\n+        render_markdown(w, cx, &*s, item.links(), prefix)?;\n     } else if !prefix.is_empty() {\n         write!(w, \"<div class='docblock'>{}</div>\", prefix)?;\n     }\n@@ -2431,7 +2416,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n             let (short, name) = item_ty_to_strs(&myty.unwrap());\n             write!(w, \"<h2 id='{id}' class='section-header'>\\\n                        <a href=\\\"#{id}\\\">{name}</a></h2>\\n<table>\",\n-                   id = derive_id(short.to_owned()), name = name)?;\n+                   id = cx.derive_id(short.to_owned()), name = name)?;\n         }\n \n         match myitem.inner {\n@@ -2526,7 +2511,8 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n             } else {\n                 String::new()\n             };\n-            let html = MarkdownHtml(&deprecated_reason, error_codes);\n+            let mut ids = cx.id_map.borrow_mut();\n+            let html = MarkdownHtml(&deprecated_reason, RefCell::new(&mut ids), error_codes);\n             let text = if stability::deprecation_in_effect(&stab.deprecated_since) {\n                 format!(\"Deprecated{}{}\", since, html)\n             } else {\n@@ -2557,12 +2543,14 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n                                             </div>\",\n                                            unstable_extra));\n                 } else {\n+                    let mut ids = cx.id_map.borrow_mut();\n                     let text = format!(\"<summary><span class=microscope>\ud83d\udd2c</span> \\\n                                         This is a nightly-only experimental API. {}\\\n                                         </summary>{}\",\n                                        unstable_extra,\n                                        MarkdownHtml(\n                                            &stab.unstable_reason,\n+                                           RefCell::new(&mut ids),\n                                            error_codes));\n                     stability.push(format!(\"<div class='stab unstable'><details>{}</details></div>\",\n                                    text));\n@@ -2583,14 +2571,15 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n             String::new()\n         };\n \n+        let mut ids = cx.id_map.borrow_mut();\n         let text = if stability::deprecation_in_effect(&depr.since) {\n             format!(\"Deprecated{}{}\",\n                     since,\n-                    MarkdownHtml(&note, error_codes))\n+                    MarkdownHtml(&note, RefCell::new(&mut ids), error_codes))\n         } else {\n             format!(\"Deprecating in {}{}\",\n                     Escape(&depr.since),\n-                    MarkdownHtml(&note, error_codes))\n+                    MarkdownHtml(&note, RefCell::new(&mut ids), error_codes))\n         };\n         stability.push(format!(\"<div class='stab deprecated'>{}</div>\", text))\n     }\n@@ -2831,8 +2820,8 @@ fn item_trait(\n                   -> fmt::Result {\n         let name = m.name.as_ref().unwrap();\n         let item_type = m.type_();\n-        let id = derive_id(format!(\"{}.{}\", item_type, name));\n-        let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+        let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+        let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n         write!(w, \"{extra}<h3 id='{id}' class='method'>\\\n                    <span id='{ns_id}' class='invisible'><code>\",\n                extra = render_spotlight_traits(m)?,\n@@ -3187,10 +3176,10 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                        document_non_exhaustive_header(it))?;\n             document_non_exhaustive(w, it)?;\n             for (field, ty) in fields {\n-                let id = derive_id(format!(\"{}.{}\",\n+                let id = cx.derive_id(format!(\"{}.{}\",\n                                            ItemType::StructField,\n                                            field.name.as_ref().unwrap()));\n-                let ns_id = derive_id(format!(\"{}.{}\",\n+                let ns_id = cx.derive_id(format!(\"{}.{}\",\n                                               field.name.as_ref().unwrap(),\n                                               ItemType::StructField.name_space()));\n                 write!(w, \"<span id=\\\"{id}\\\" class=\\\"{item_type} small-section-header\\\">\n@@ -3321,10 +3310,10 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                    document_non_exhaustive_header(it))?;\n         document_non_exhaustive(w, it)?;\n         for variant in &e.variants {\n-            let id = derive_id(format!(\"{}.{}\",\n+            let id = cx.derive_id(format!(\"{}.{}\",\n                                        ItemType::Variant,\n                                        variant.name.as_ref().unwrap()));\n-            let ns_id = derive_id(format!(\"{}.{}\",\n+            let ns_id = cx.derive_id(format!(\"{}.{}\",\n                                           variant.name.as_ref().unwrap(),\n                                           ItemType::Variant.name_space()));\n             write!(w, \"<span id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n@@ -3352,7 +3341,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             if let clean::VariantItem(Variant {\n                 kind: VariantKind::Struct(ref s)\n             }) = variant.inner {\n-                let variant_id = derive_id(format!(\"{}.{}.fields\",\n+                let variant_id = cx.derive_id(format!(\"{}.{}.fields\",\n                                                    ItemType::Variant,\n                                                    variant.name.as_ref().unwrap()));\n                 write!(w, \"<span class='docblock autohide sub-variant' id='{id}'>\",\n@@ -3362,10 +3351,10 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 for field in &s.fields {\n                     use clean::StructFieldItem;\n                     if let StructFieldItem(ref ty) = field.inner {\n-                        let id = derive_id(format!(\"variant.{}.field.{}\",\n+                        let id = cx.derive_id(format!(\"variant.{}.field.{}\",\n                                                    variant.name.as_ref().unwrap(),\n                                                    field.name.as_ref().unwrap()));\n-                        let ns_id = derive_id(format!(\"{}.{}.{}.{}\",\n+                        let ns_id = cx.derive_id(format!(\"{}.{}.{}.{}\",\n                                                       variant.name.as_ref().unwrap(),\n                                                       ItemType::Variant.name_space(),\n                                                       field.name.as_ref().unwrap(),\n@@ -3794,7 +3783,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                render_mode: RenderMode, outer_version: Option<&str>,\n                show_def_docs: bool) -> fmt::Result {\n     if render_mode == RenderMode::Normal {\n-        let id = derive_id(match i.inner_impl().trait_ {\n+        let id = cx.derive_id(match i.inner_impl().trait_ {\n             Some(ref t) => format!(\"impl-{}\", small_url_encode(&format!(\"{:#}\", t))),\n             None => \"impl\".to_string(),\n         });\n@@ -3814,8 +3803,9 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         }\n         write!(w, \"</span></td></tr></tbody></table></h3>\")?;\n         if let Some(ref dox) = cx.shared.maybe_collapsed_doc_value(&i.impl_item) {\n+            let mut ids = cx.id_map.borrow_mut();\n             write!(w, \"<div class='docblock'>{}</div>\",\n-                   Markdown(&*dox, &i.impl_item.links(), cx.codes))?;\n+                   Markdown(&*dox, &i.impl_item.links(), RefCell::new(&mut ids), cx.codes))?;\n         }\n     }\n \n@@ -3836,8 +3826,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             clean::TyMethodItem(clean::TyMethod{ ref decl, .. }) => {\n                 // Only render when the method is not static or we allow static methods\n                 if render_method_item {\n-                    let id = derive_id(format!(\"{}.{}\", item_type, name));\n-                    let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                    let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+                    let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                     write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                     write!(w, \"{}\", spotlight_decl(decl)?)?;\n                     write!(w, \"<span id='{}' class='invisible'>\", ns_id)?;\n@@ -3858,24 +3848,24 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                 }\n             }\n             clean::TypedefItem(ref tydef, _) => {\n-                let id = derive_id(format!(\"{}.{}\", ItemType::AssociatedType, name));\n-                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                let id = cx.derive_id(format!(\"{}.{}\", ItemType::AssociatedType, name));\n+                let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                 write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n-                let id = derive_id(format!(\"{}.{}\", item_type, name));\n-                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+                let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                 write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n-                let id = derive_id(format!(\"{}.{}\", item_type, name));\n-                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+                let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                 write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id))?;\n@@ -3901,7 +3891,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                         } else if show_def_docs {\n                             // In case the item isn't documented,\n                             // provide short documentation from the trait.\n-                            document_short(w, it, link, &prefix, cx.codes)?;\n+                            document_short(w, cx, it, link, &prefix)?;\n                         }\n                     }\n                 } else {\n@@ -3913,7 +3903,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             } else {\n                 document_stability(w, cx, item)?;\n                 if show_def_docs {\n-                    document_short(w, item, link, &prefix, cx.codes)?;\n+                    document_short(w, cx, item, link, &prefix)?;\n                 }\n             }\n         }\n@@ -4719,25 +4709,6 @@ pub fn cache() -> Arc<Cache> {\n     CACHE_KEY.with(|c| c.borrow().clone())\n }\n \n-#[cfg(test)]\n-#[test]\n-fn test_unique_id() {\n-    let input = [\"foo\", \"examples\", \"examples\", \"method.into_iter\",\"examples\",\n-                 \"method.into_iter\", \"foo\", \"main\", \"search\", \"methods\",\n-                 \"examples\", \"method.into_iter\", \"assoc_type.Item\", \"assoc_type.Item\"];\n-    let expected = [\"foo\", \"examples\", \"examples-1\", \"method.into_iter\", \"examples-2\",\n-                    \"method.into_iter-1\", \"foo-1\", \"main-1\", \"search-1\", \"methods-1\",\n-                    \"examples-3\", \"method.into_iter-2\", \"assoc_type.Item\", \"assoc_type.Item-1\"];\n-\n-    let test = || {\n-        let actual: Vec<String> = input.iter().map(|s| derive_id(s.to_string())).collect();\n-        assert_eq!(&actual[..], expected);\n-    };\n-    test();\n-    reset_ids(true);\n-    test();\n-}\n-\n #[cfg(test)]\n #[test]\n fn test_name_key() {"}, {"sha": "0a4955f4fbd10a83448eaee3a115d719b5191233", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bea518d3a792d9c8df508b0af83ceb857ce75b7/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bea518d3a792d9c8df508b0af83ceb857ce75b7/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=7bea518d3a792d9c8df508b0af83ceb857ce75b7", "patch": "@@ -500,12 +500,14 @@ fn main_args(args: &[String]) -> isize {\n         }\n     }\n \n+    let mut id_map = html::markdown::IdMap::new();\n+    id_map.populate(html::render::initial_ids());\n     let external_html = match ExternalHtml::load(\n             &matches.opt_strs(\"html-in-header\"),\n             &matches.opt_strs(\"html-before-content\"),\n             &matches.opt_strs(\"html-after-content\"),\n             &matches.opt_strs(\"markdown-before-content\"),\n-            &matches.opt_strs(\"markdown-after-content\"), &diag) {\n+            &matches.opt_strs(\"markdown-after-content\"), &diag, &mut id_map) {\n         Some(eh) => eh,\n         None => return 3,\n     };\n@@ -562,7 +564,7 @@ fn main_args(args: &[String]) -> isize {\n                                   renderinfo,\n                                   sort_modules_alphabetically,\n                                   themes,\n-                                  enable_minification)\n+                                  enable_minification, id_map)\n                     .expect(\"failed to generate documentation\");\n                 0\n             }"}, {"sha": "05661dc6856637f0c97410136318d2e60e26da26", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7bea518d3a792d9c8df508b0af83ceb857ce75b7/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bea518d3a792d9c8df508b0af83ceb857ce75b7/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=7bea518d3a792d9c8df508b0af83ceb857ce75b7", "patch": "@@ -12,6 +12,7 @@ use std::default::Default;\n use std::fs::File;\n use std::io::prelude::*;\n use std::path::{PathBuf, Path};\n+use std::cell::RefCell;\n \n use errors;\n use getopts;\n@@ -24,10 +25,9 @@ use syntax::edition::Edition;\n \n use externalfiles::{ExternalHtml, LoadStringError, load_string};\n \n-use html::render::reset_ids;\n use html::escape::Escape;\n use html::markdown;\n-use html::markdown::{ErrorCodes, Markdown, MarkdownWithToc, find_testable_code};\n+use html::markdown::{ErrorCodes, IdMap, Markdown, MarkdownWithToc, find_testable_code};\n use test::{TestOptions, Collector};\n \n /// Separate any lines at the start of the file that begin with `# ` or `%`.\n@@ -87,13 +87,12 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n     }\n     let title = metadata[0];\n \n-    reset_ids(false);\n-\n+    let mut ids = IdMap::new();\n     let error_codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n     let text = if include_toc {\n-        MarkdownWithToc(text, error_codes).to_string()\n+        MarkdownWithToc(text, RefCell::new(&mut ids), error_codes).to_string()\n     } else {\n-        Markdown(text, &[], error_codes).to_string()\n+        Markdown(text, &[], RefCell::new(&mut ids), error_codes).to_string()\n     };\n \n     let err = write!("}, {"sha": "40917cc5db0d5f6eba8086615706c1774d4d9793", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bea518d3a792d9c8df508b0af83ceb857ce75b7/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bea518d3a792d9c8df508b0af83ceb857ce75b7/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=7bea518d3a792d9c8df508b0af83ceb857ce75b7", "patch": "@@ -21,10 +21,11 @@ use std::fs::{read_dir, File};\n use std::io::{Read, Write};\n use std::path::Path;\n use std::path::PathBuf;\n+use std::cell::RefCell;\n \n use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap, ErrorMetadata};\n \n-use rustdoc::html::markdown::{Markdown, ErrorCodes, PLAYGROUND};\n+use rustdoc::html::markdown::{Markdown, IdMap, ErrorCodes, PLAYGROUND};\n use rustc_serialize::json;\n \n enum OutputFormat {\n@@ -36,7 +37,7 @@ enum OutputFormat {\n impl OutputFormat {\n     fn from(format: &str) -> OutputFormat {\n         match &*format.to_lowercase() {\n-            \"html\"     => OutputFormat::HTML(HTMLFormatter),\n+            \"html\"     => OutputFormat::HTML(HTMLFormatter(RefCell::new(IdMap::new()))),\n             \"markdown\" => OutputFormat::Markdown(MarkdownFormatter),\n             s          => OutputFormat::Unknown(s.to_owned()),\n         }\n@@ -51,7 +52,7 @@ trait Formatter {\n     fn footer(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>>;\n }\n \n-struct HTMLFormatter;\n+struct HTMLFormatter(RefCell<IdMap>);\n struct MarkdownFormatter;\n \n impl Formatter for HTMLFormatter {\n@@ -100,7 +101,11 @@ impl Formatter for HTMLFormatter {\n \n         // Description rendered as markdown.\n         match info.description {\n-            Some(ref desc) => write!(output, \"{}\", Markdown(desc, &[], ErrorCodes::Yes))?,\n+            Some(ref desc) => {\n+                let mut id_map = self.0.borrow_mut();\n+                write!(output, \"{}\",\n+                    Markdown(desc, &[], RefCell::new(&mut id_map), ErrorCodes::Yes))?\n+            },\n             None => write!(output, \"<p>No description.</p>\\n\")?,\n         }\n "}]}