{"sha": "18bf9dd4b7e9834bc6981ee413f025f3b2f7e386", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YmY5ZGQ0YjdlOTgzNGJjNjk4MWVlNDEzZjAyNWYzYjJmN2UzODY=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-07-28T21:57:04Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-07-28T22:02:16Z"}, "message": "Properly check the defining scope of existential types\n\nFixes #52632\n\nExistential types (soon to be 'impl trait' aliases) can either be\ndelcared at a top-level crate/module scope, or within another item such\nas an fn. Previously, we were handling the second case incorrectly when\nrecursively searching for defining usages - we would check children of\nthe item, but not the item itself. This lead to us missing closures\nthat consituted a defining use of the existential type, as their opaque\ntype instantiations are stored in the TypeckTables of their parent\nfunction.\n\nThis commit ensures that we explicitly visit the defining item itself,\nnot just its children.", "tree": {"sha": "d66149ce2d46c15ac1280acfdcf31a605caf3b99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d66149ce2d46c15ac1280acfdcf31a605caf3b99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18bf9dd4b7e9834bc6981ee413f025f3b2f7e386", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl0+G2gACgkQtAh+UQ6Y\nsWSXEA//agOqjxSG5I3tlIqvF27xYYZddFsW/jPSv8wr/5bQJXLBOeXkw/TqoxMv\nBZIO0zUTvjOrYRErinmSFsjbnOJjem9gxLdcp5jip9Q22w7TkaxJ0MbHFvdfUxUL\ns6WiEQWlMa/IkfgScfcS4gYsqxOR+JKH4PezajtCxmlKmMcs8AjTrCXU6df7YBCx\nJviCLAjHc0YMoZAoyYmAZMiiJfY2gaU1EmFj19m2exXRlof6r90bSJIwOC3XVwhW\nSiDiMu3s1XBL/B3+gmsi4qWV9t5Yr/mGOfEoiB64YhuyLo/0G1tQBe1aTUhpqdYE\niNDpwHTZ/w6P/pTJCjVkXbbp8Mble7FMPE+N56ZWahhiSISmJI8mAmB/zrpEns3m\nnveJZPcViEJ7YodMAq4q51mEwZE3ckiFkV3vpPhUDgJYXAdXc70PeK/wk+Kf3lzm\nRW8ej2qOkd2cI1aSUWeSfNBT7bGE2yARj4OezI0UFxrirTEPzWTWyLggsScBsTkh\nwwdemqxfNAKrWF0wfOaGB+KJCkHSmjeAMZknxBjJb7zPVdnd5bd9T8sDazUKg02L\nX0LiM2UcRmNbIymelLrUFks0oR1Id+o/ieW3kUejuU+tJZ4aF9V86lGFqnWf6KEo\no6GyzTISXqrRtpDoarx5joTAtZTnjiDF20EzsGtXiCJdFlVR/OE=\n=nNhp\n-----END PGP SIGNATURE-----", "payload": "tree d66149ce2d46c15ac1280acfdcf31a605caf3b99\nparent 023525dbda35748a10713471b948974b68a1c2cc\nauthor Aaron Hill <aa1ronham@gmail.com> 1564351024 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1564351336 -0400\n\nProperly check the defining scope of existential types\n\nFixes #52632\n\nExistential types (soon to be 'impl trait' aliases) can either be\ndelcared at a top-level crate/module scope, or within another item such\nas an fn. Previously, we were handling the second case incorrectly when\nrecursively searching for defining usages - we would check children of\nthe item, but not the item itself. This lead to us missing closures\nthat consituted a defining use of the existential type, as their opaque\ntype instantiations are stored in the TypeckTables of their parent\nfunction.\n\nThis commit ensures that we explicitly visit the defining item itself,\nnot just its children.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18bf9dd4b7e9834bc6981ee413f025f3b2f7e386", "html_url": "https://github.com/rust-lang/rust/commit/18bf9dd4b7e9834bc6981ee413f025f3b2f7e386", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18bf9dd4b7e9834bc6981ee413f025f3b2f7e386/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "023525dbda35748a10713471b948974b68a1c2cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/023525dbda35748a10713471b948974b68a1c2cc", "html_url": "https://github.com/rust-lang/rust/commit/023525dbda35748a10713471b948974b68a1c2cc"}], "stats": {"total": 67, "additions": 58, "deletions": 9}, "files": [{"sha": "73a76ebcb74f412e95b6212a7f00ec9e2f32181e", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/18bf9dd4b7e9834bc6981ee413f025f3b2f7e386/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf9dd4b7e9834bc6981ee413f025f3b2f7e386/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=18bf9dd4b7e9834bc6981ee413f025f3b2f7e386", "patch": "@@ -1189,11 +1189,7 @@ pub fn may_define_existential_type(\n     opaque_hir_id: hir::HirId,\n ) -> bool {\n     let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    trace!(\n-        \"may_define_existential_type(def={:?}, opaque_node={:?})\",\n-        tcx.hir().get(hir_id),\n-        tcx.hir().get(opaque_hir_id)\n-    );\n+\n \n     // Named existential types can be defined by any siblings or children of siblings.\n     let scope = tcx.hir().get_defining_scope(opaque_hir_id).expect(\"could not get defining scope\");\n@@ -1202,5 +1198,12 @@ pub fn may_define_existential_type(\n         hir_id = tcx.hir().get_parent_item(hir_id);\n     }\n     // Syntactically, we are allowed to define the concrete type if:\n-    hir_id == scope\n+    let res = hir_id == scope;\n+    trace!(\n+        \"may_define_existential_type(def={:?}, opaque_node={:?}) = {}\",\n+        tcx.hir().get(hir_id),\n+        tcx.hir().get(opaque_hir_id),\n+        res\n+    );\n+    res\n }"}, {"sha": "0f0cbd5d76b4bc342181a036a45f39e1c705727c", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/18bf9dd4b7e9834bc6981ee413f025f3b2f7e386/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf9dd4b7e9834bc6981ee413f025f3b2f7e386/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=18bf9dd4b7e9834bc6981ee413f025f3b2f7e386", "patch": "@@ -1664,6 +1664,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             intravisit::NestedVisitorMap::All(&self.tcx.hir())\n         }\n         fn visit_item(&mut self, it: &'tcx Item) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The existential type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n@@ -1672,6 +1673,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The existential type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n@@ -1680,6 +1682,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             self.check(def_id);\n             intravisit::walk_trait_item(self, it);\n@@ -1703,9 +1706,21 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     } else {\n         debug!(\"find_existential_constraints: scope={:?}\", tcx.hir().get(scope));\n         match tcx.hir().get(scope) {\n-            Node::Item(ref it) => intravisit::walk_item(&mut locator, it),\n-            Node::ImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n-            Node::TraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n+            // We explicitly call 'visit_*' methods, instead of using intravisit::walk_* methods\n+            // This allows our visitor to process the defining item itself, causing\n+            // it to pick up any 'sibling' defining uses.\n+            //\n+            // For example, this code:\n+            // fn foo() {\n+            //     existential type Blah: Debug;\n+            //     let my_closure = || -> Blah { true };\n+            // }\n+            //\n+            // requires us to explicitly process 'foo()' in order\n+            // to notice the defining usage of 'Blah'\n+            Node::Item(ref it) => locator.visit_item(it),\n+            Node::ImplItem(ref it) => locator.visit_impl_item(it),\n+            Node::TraitItem(ref it) => locator.visit_trait_item(it),\n             other => bug!(\n                 \"{:?} is not a valid scope for an existential type item\",\n                 other"}, {"sha": "c625909e478318b23541cbeceba5ee621768799e", "filename": "src/test/ui/existential-type/issue-52843.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/18bf9dd4b7e9834bc6981ee413f025f3b2f7e386/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf9dd4b7e9834bc6981ee413f025f3b2f7e386/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843.rs?ref=18bf9dd4b7e9834bc6981ee413f025f3b2f7e386", "patch": "@@ -0,0 +1,11 @@\n+#![feature(existential_type)]\n+\n+use std::fmt::Debug;\n+\n+fn main() {\n+    existential type Existential: Debug;\n+    fn _unused() -> Existential { String::new() }\n+    //~^ ERROR: concrete type differs from previous defining existential type use\n+    let null = || -> Existential { 0 };\n+    println!(\"{:?}\", null());\n+}"}, {"sha": "337e84bb8f50aab4cde14f05a3575ba0904902d5", "filename": "src/test/ui/existential-type/issue-52843.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/18bf9dd4b7e9834bc6981ee413f025f3b2f7e386/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18bf9dd4b7e9834bc6981ee413f025f3b2f7e386/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843.stderr?ref=18bf9dd4b7e9834bc6981ee413f025f3b2f7e386", "patch": "@@ -0,0 +1,20 @@\n+error: concrete type differs from previous defining existential type use\n+  --> $DIR/issue-52843.rs:7:5\n+   |\n+LL |     fn _unused() -> Existential { String::new() }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, got `std::string::String`\n+   |\n+note: previous use here\n+  --> $DIR/issue-52843.rs:5:1\n+   |\n+LL | / fn main() {\n+LL | |     existential type Existential: Debug;\n+LL | |     fn _unused() -> Existential { String::new() }\n+LL | |\n+LL | |     let null = || -> Existential { 0 };\n+LL | |     println!(\"{:?}\", null());\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}]}