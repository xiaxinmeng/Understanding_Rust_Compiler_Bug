{"sha": "ffee9566bbd7728e6411e6094105d6905373255d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZWU5NTY2YmJkNzcyOGU2NDExZTYwOTQxMDVkNjkwNTM3MzI1NWQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-02-08T17:31:03Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-18T00:53:04Z"}, "message": "move Instance to rustc and use it in the collector", "tree": {"sha": "96836781c5aed1483587679de034efefdd82344b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96836781c5aed1483587679de034efefdd82344b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffee9566bbd7728e6411e6094105d6905373255d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffee9566bbd7728e6411e6094105d6905373255d", "html_url": "https://github.com/rust-lang/rust/commit/ffee9566bbd7728e6411e6094105d6905373255d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffee9566bbd7728e6411e6094105d6905373255d/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0af3775dd2c93cdaf8902f83eb21037e474e058f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0af3775dd2c93cdaf8902f83eb21037e474e058f", "html_url": "https://github.com/rust-lang/rust/commit/0af3775dd2c93cdaf8902f83eb21037e474e058f"}], "stats": {"total": 954, "additions": 522, "deletions": 432}, "files": [{"sha": "399af258e925167767be1ea6f3417141bfee6ae4", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -89,6 +89,7 @@ pub enum DepNode<D: Clone + Debug> {\n     // things read/modify that MIR.\n     MirKrate,\n     Mir(D),\n+    MirShim(Vec<D>),\n \n     BorrowCheckKrate,\n     BorrowCheck(D),\n@@ -258,6 +259,10 @@ impl<D: Clone + Debug> DepNode<D> {\n             IntrinsicCheck(ref d) => op(d).map(IntrinsicCheck),\n             MatchCheck(ref d) => op(d).map(MatchCheck),\n             Mir(ref d) => op(d).map(Mir),\n+            MirShim(ref def_ids) => {\n+                let def_ids: Option<Vec<E>> = def_ids.iter().map(op).collect();\n+                def_ids.map(MirShim)\n+            }\n             BorrowCheck(ref d) => op(d).map(BorrowCheck),\n             RvalueCheck(ref d) => op(d).map(RvalueCheck),\n             StabilityCheck(ref d) => op(d).map(StabilityCheck),"}, {"sha": "fdcfb3ebd3ce50c8110c2d0a0375f35857077d09", "filename": "src/librustc/ty/instance.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dep_graph::DepNode;\n+use hir::def_id::DefId;\n+use ty::{self, Ty, TypeFoldable, Substs};\n+use util::ppaux;\n+\n+use std::borrow::Cow;\n+use std::fmt;\n+use syntax::ast;\n+\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct Instance<'tcx> {\n+    pub def: InstanceDef<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum InstanceDef<'tcx> {\n+    Item(DefId),\n+    // <fn() as FnTrait>::call_*\n+    FnPtrShim(DefId, Ty<'tcx>),\n+}\n+\n+impl<'tcx> InstanceDef<'tcx> {\n+    #[inline]\n+    pub fn def_id(&self) -> DefId {\n+        match *self {\n+            InstanceDef::Item(def_id) |\n+            InstanceDef::FnPtrShim(def_id, _)\n+                => def_id\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn def_ty<'a>(&self, tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+        tcx.item_type(self.def_id())\n+    }\n+\n+    #[inline]\n+    pub fn attrs<'a>(&self, tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> Cow<'tcx, [ast::Attribute]> {\n+        tcx.get_attrs(self.def_id())\n+    }\n+\n+    pub(crate) fn dep_node(&self) -> DepNode<DefId> {\n+        // HACK: def-id binning, project-style; someone replace this with\n+        // real on-demand.\n+        let ty = match self {\n+            &InstanceDef::FnPtrShim(_, ty) => Some(ty),\n+            _ => None\n+        }.into_iter();\n+\n+        DepNode::MirShim(\n+            Some(self.def_id()).into_iter().chain(\n+                ty.flat_map(|t| t.walk()).flat_map(|t| match t.sty {\n+                   ty::TyAdt(adt_def, _) => Some(adt_def.did),\n+                   ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n+                   _ => None,\n+               })\n+            ).collect()\n+        )\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for Instance<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.def {\n+            InstanceDef::Item(def) => {\n+                ppaux::parameterized(f, self.substs, def, &[])\n+            }\n+            InstanceDef::FnPtrShim(def, ty) => {\n+                ppaux::parameterized(f, self.substs, def, &[])?;\n+                write!(f, \" - shim({:?})\", ty)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> Instance<'tcx> {\n+    pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>)\n+               -> Instance<'tcx> {\n+        assert!(substs.is_normalized_for_trans() && !substs.has_escaping_regions(),\n+                \"substs of instance {:?} not normalized for trans: {:?}\",\n+                def_id, substs);\n+        Instance { def: InstanceDef::Item(def_id), substs: substs }\n+    }\n+\n+    pub fn mono(tcx: ty::TyCtxt<'a, 'tcx, 'b>, def_id: DefId) -> Instance<'tcx> {\n+        Instance::new(def_id, tcx.global_tcx().empty_substs_for_def_id(def_id))\n+    }\n+\n+    #[inline]\n+    pub fn def_id(&self) -> DefId {\n+        self.def.def_id()\n+    }\n+}"}, {"sha": "ac8c38c7d585664d05d58efd4832d59e7a61e38e", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n-use hir::def_id::{CrateNum, DefId};\n+use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use middle::const_val::ConstVal;\n use mir;\n use ty::{self, Ty, TyCtxt};\n@@ -24,6 +24,16 @@ trait Key {\n     fn default_span(&self, tcx: TyCtxt) -> Span;\n }\n \n+impl<'tcx> Key for ty::InstanceDef<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(self.def_id())\n+    }\n+}\n+\n impl Key for CrateNum {\n     fn map_crate(&self) -> CrateNum {\n         *self\n@@ -83,9 +93,9 @@ impl<'tcx> Value<'tcx> for Ty<'tcx> {\n     }\n }\n \n-pub struct CycleError<'a> {\n+pub struct CycleError<'a, 'tcx: 'a> {\n     span: Span,\n-    cycle: RefMut<'a, [(Span, Query)]>,\n+    cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -110,8 +120,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    fn cycle_check<F, R>(self, span: Span, query: Query, compute: F)\n-                         -> Result<R, CycleError<'a>>\n+    fn cycle_check<F, R>(self, span: Span, query: Query<'gcx>, compute: F)\n+                         -> Result<R, CycleError<'a, 'gcx>>\n         where F: FnOnce() -> R\n     {\n         {\n@@ -172,13 +182,20 @@ impl<'tcx> QueryDescription for queries::coherent_inherent_impls<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::mir_shims<'tcx> {\n+    fn describe(tcx: TyCtxt, def: ty::InstanceDef<'tcx>) -> String {\n+        format!(\"generating MIR shim for `{}`\",\n+                tcx.item_path_str(def.def_id()))\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n        pub $name:ident: $node:ident($K:ty) -> $V:ty),*) => {\n         pub struct Maps<$tcx> {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n-            query_stack: RefCell<Vec<(Span, Query)>>,\n+            query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n             $($(#[$attr])* pub $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>),*\n         }\n \n@@ -196,11 +213,11 @@ macro_rules! define_maps {\n \n         #[allow(bad_style)]\n         #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-        pub enum Query {\n+        pub enum Query<$tcx> {\n             $($(#[$attr])* $name($K)),*\n         }\n \n-        impl Query {\n+        impl<$tcx> Query<$tcx> {\n             pub fn describe(&self, tcx: TyCtxt) -> String {\n                 match *self {\n                     $(Query::$name(key) => queries::$name::describe(tcx, key)),*\n@@ -233,7 +250,7 @@ macro_rules! define_maps {\n                                   mut span: Span,\n                                   key: $K,\n                                   f: F)\n-                                  -> Result<R, CycleError<'a>>\n+                                  -> Result<R, CycleError<'a, $tcx>>\n                 where F: FnOnce(&$V) -> R\n             {\n                 if let Some(result) = tcx.maps.$name.borrow().get(&key) {\n@@ -256,7 +273,7 @@ macro_rules! define_maps {\n             }\n \n             pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n-                           -> Result<$V, CycleError<'a>> {\n+                           -> Result<$V, CycleError<'a, $tcx>> {\n                 Self::try_get_with(tcx, span, key, Clone::clone)\n             }\n \n@@ -387,7 +404,9 @@ define_maps! { <'tcx>\n \n     /// Results of evaluating monomorphic constants embedded in\n     /// other items, such as enum variant explicit discriminants.\n-    pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> Result<ConstVal<'tcx>, ()>\n+    pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> Result<ConstVal<'tcx>, ()>,\n+\n+    pub mir_shims: mir_shim(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -397,3 +416,7 @@ fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n fn coherent_inherent_impls_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::Coherence\n }\n+\n+fn mir_shim(instance: ty::InstanceDef) -> DepNode<DefId> {\n+    instance.dep_node()\n+}"}, {"sha": "c4192ffc697cecefaad97bae83db8aaddf5b5be1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -73,6 +73,8 @@ pub use self::contents::TypeContents;\n pub use self::context::{TyCtxt, GlobalArenas, tls};\n pub use self::context::{Lift, TypeckTables};\n \n+pub use self::instance::{Instance, InstanceDef};\n+\n pub use self::trait_def::{TraitDef, TraitFlags};\n \n pub use self::maps::queries;\n@@ -98,6 +100,7 @@ pub mod util;\n mod contents;\n mod context;\n mod flags;\n+mod instance;\n mod structural_impls;\n mod sty;\n \n@@ -2309,6 +2312,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         queries::mir::get(self, DUMMY_SP, did).borrow()\n     }\n \n+    /// Return the possibly-auto-generated MIR of a (DefId, Subst) pair.\n+    pub fn instance_mir(self, instance: ty::InstanceDef<'gcx>)\n+                        -> Ref<'gcx, Mir<'gcx>>\n+    {\n+        match instance {\n+            ty::InstanceDef::Item(did) if true => self.item_mir(did),\n+            _ => queries::mir_shims::get(self, DUMMY_SP, instance).borrow(),\n+        }\n+    }\n+\n     /// Given the DefId of an item, returns its MIR, borrowed immutably.\n     /// Returns None if there is no MIR for the DefId\n     pub fn maybe_item_mir(self, did: DefId) -> Option<Ref<'gcx, Mir<'gcx>>> {"}, {"sha": "2344305fa9a7ec19c1f9732de0a5ab4f4e063814", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -398,6 +398,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n         def_id\n     }\n+\n+    /// Given the def-id of some item that has no type parameters, make\n+    /// a suitable \"empty substs\" for it.\n+    pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> &'tcx ty::Substs<'tcx> {\n+        ty::Substs::for_item(self, item_def_id,\n+                             |_, _| self.mk_region(ty::ReErased),\n+                             |_, _| {\n+            bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n+        })\n+    }\n+\n+\n }\n \n pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, W> {"}, {"sha": "9e6b77dbabdef628bca02bb3b8d1adbdbee8a948", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -60,5 +60,6 @@ use rustc::ty::maps::Providers;\n \n pub fn provide(providers: &mut Providers) {\n     mir_map::provide(providers);\n+    shim::provide(providers);\n     transform::qualify_consts::provide(providers);\n }\n\\ No newline at end of file"}, {"sha": "0fbd488ffa360610b1a2ef35019dc8a004a88a38", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -13,14 +13,31 @@ use rustc::infer;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use rustc::ty;\n+use rustc::ty::maps::Providers;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n use syntax::ast;\n use syntax_pos::Span;\n \n+use std::cell::RefCell;\n use std::iter;\n \n+pub fn provide(providers: &mut Providers) {\n+    providers.mir_shims = make_shim;\n+}\n+\n+fn make_shim<'a, 'tcx>(_tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+                       instance: ty::InstanceDef<'tcx>)\n+                       -> &'tcx RefCell<Mir<'tcx>>\n+{\n+    match instance {\n+        ty::InstanceDef::Item(..) =>\n+            bug!(\"item {:?} passed to make_shim\", instance),\n+        ty::InstanceDef::FnPtrShim(..) => unimplemented!()\n+    }\n+}\n+\n fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>)\n     -> IndexVec<Local, LocalDecl<'tcx>>\n {"}, {"sha": "005fb3533ab0b793510bdec9fde95630c2a46744", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -11,6 +11,7 @@\n use context::SharedCrateContext;\n use monomorphize::Instance;\n use symbol_map::SymbolMap;\n+use back::symbol_names::symbol_name;\n use util::nodemap::FxHashMap;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::session::config;\n@@ -106,7 +107,7 @@ impl ExportedSymbols {\n                 .exported_symbols(cnum)\n                 .iter()\n                 .map(|&def_id| {\n-                    let name = Instance::mono(scx, def_id).symbol_name(scx);\n+                    let name = symbol_name(Instance::mono(scx.tcx(), def_id), scx);\n                     let export_level = if special_runtime_crate {\n                         // We can probably do better here by just ensuring that\n                         // it has hidden visibility rather than public\n@@ -218,9 +219,9 @@ fn symbol_for_def_id<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n     }\n \n-    let instance = Instance::mono(scx, def_id);\n+    let instance = Instance::mono(scx.tcx(), def_id);\n \n     symbol_map.get(TransItem::Fn(instance))\n               .map(str::to_owned)\n-              .unwrap_or_else(|| instance.symbol_name(scx))\n+              .unwrap_or_else(|| symbol_name(instance, scx))\n }"}, {"sha": "518995dfedcc282fac84b41ada9f0ebb288837be", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -168,105 +168,105 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     format!(\"h{:016x}\", hasher.finish())\n }\n \n-impl<'a, 'tcx> Instance<'tcx> {\n-    pub fn symbol_name(self, scx: &SharedCrateContext<'a, 'tcx>) -> String {\n-        let Instance { def: def_id, substs } = self;\n+pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n+                             scx: &SharedCrateContext<'a, 'tcx>) -> String {\n+    let def_id = instance.def_id();\n+    let substs = instance.substs;\n \n-        debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n-               def_id, substs);\n+    debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n+           def_id, substs);\n \n-        let node_id = scx.tcx().hir.as_local_node_id(def_id);\n+    let node_id = scx.tcx().hir.as_local_node_id(def_id);\n \n-        if let Some(id) = node_id {\n-            if scx.sess().plugin_registrar_fn.get() == Some(id) {\n-                let svh = &scx.link_meta().crate_hash;\n-                let idx = def_id.index;\n-                return scx.sess().generate_plugin_registrar_symbol(svh, idx);\n-            }\n-            if scx.sess().derive_registrar_fn.get() == Some(id) {\n-                let svh = &scx.link_meta().crate_hash;\n-                let idx = def_id.index;\n-                return scx.sess().generate_derive_registrar_symbol(svh, idx);\n-            }\n+    if let Some(id) = node_id {\n+        if scx.sess().plugin_registrar_fn.get() == Some(id) {\n+            let svh = &scx.link_meta().crate_hash;\n+            let idx = def_id.index;\n+            return scx.sess().generate_plugin_registrar_symbol(svh, idx);\n         }\n-\n-        // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n-        let attrs = scx.tcx().get_attrs(def_id);\n-        let is_foreign = if let Some(id) = node_id {\n-            match scx.tcx().hir.get(id) {\n-                hir_map::NodeForeignItem(_) => true,\n-                _ => false\n-            }\n-        } else {\n-            scx.sess().cstore.is_foreign_item(def_id)\n-        };\n-\n-        if let Some(name) = weak_lang_items::link_name(&attrs) {\n-            return name.to_string();\n+        if scx.sess().derive_registrar_fn.get() == Some(id) {\n+            let svh = &scx.link_meta().crate_hash;\n+            let idx = def_id.index;\n+            return scx.sess().generate_derive_registrar_symbol(svh, idx);\n         }\n+    }\n \n-        if is_foreign {\n-            if let Some(name) = attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n-                return name.to_string();\n-            }\n-            // Don't mangle foreign items.\n-            return scx.tcx().item_name(def_id).as_str().to_string();\n+    // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n+    let attrs = scx.tcx().get_attrs(def_id);\n+    let is_foreign = if let Some(id) = node_id {\n+        match scx.tcx().hir.get(id) {\n+            hir_map::NodeForeignItem(_) => true,\n+            _ => false\n         }\n+    } else {\n+        scx.sess().cstore.is_foreign_item(def_id)\n+    };\n \n-        if let Some(name) = attr::find_export_name_attr(scx.sess().diagnostic(), &attrs) {\n-            // Use provided name\n+    if let Some(name) = weak_lang_items::link_name(&attrs) {\n+        return name.to_string();\n+    }\n+\n+    if is_foreign {\n+        if let Some(name) = attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n             return name.to_string();\n         }\n+        // Don't mangle foreign items.\n+        return scx.tcx().item_name(def_id).as_str().to_string();\n+    }\n \n-        if attr::contains_name(&attrs, \"no_mangle\") {\n-            // Don't mangle\n-            return scx.tcx().item_name(def_id).as_str().to_string();\n-        }\n+    if let Some(name) = attr::find_export_name_attr(scx.sess().diagnostic(), &attrs) {\n+        // Use provided name\n+        return name.to_string();\n+    }\n \n-        let def_path = scx.tcx().def_path(def_id);\n-\n-        // We want to compute the \"type\" of this item. Unfortunately, some\n-        // kinds of items (e.g., closures) don't have an entry in the\n-        // item-type array. So walk back up the find the closest parent\n-        // that DOES have an entry.\n-        let mut ty_def_id = def_id;\n-        let instance_ty;\n-        loop {\n-            let key = scx.tcx().def_key(ty_def_id);\n-            match key.disambiguated_data.data {\n-                DefPathData::TypeNs(_) |\n-                DefPathData::ValueNs(_) => {\n-                    instance_ty = scx.tcx().item_type(ty_def_id);\n-                    break;\n-                }\n-                _ => {\n-                    // if we're making a symbol for something, there ought\n-                    // to be a value or type-def or something in there\n-                    // *somewhere*\n-                    ty_def_id.index = key.parent.unwrap_or_else(|| {\n-                        bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                             parent\", def_id, ty_def_id);\n-                    });\n-                }\n+    if attr::contains_name(&attrs, \"no_mangle\") {\n+        // Don't mangle\n+        return scx.tcx().item_name(def_id).as_str().to_string();\n+    }\n+\n+    let def_path = scx.tcx().def_path(def_id);\n+\n+    // We want to compute the \"type\" of this item. Unfortunately, some\n+    // kinds of items (e.g., closures) don't have an entry in the\n+    // item-type array. So walk back up the find the closest parent\n+    // that DOES have an entry.\n+    let mut ty_def_id = def_id;\n+    let instance_ty;\n+    loop {\n+        let key = scx.tcx().def_key(ty_def_id);\n+        match key.disambiguated_data.data {\n+            DefPathData::TypeNs(_) |\n+            DefPathData::ValueNs(_) => {\n+                instance_ty = scx.tcx().item_type(ty_def_id);\n+                break;\n+            }\n+            _ => {\n+                // if we're making a symbol for something, there ought\n+                // to be a value or type-def or something in there\n+                // *somewhere*\n+                ty_def_id.index = key.parent.unwrap_or_else(|| {\n+                    bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n+                          parent\", def_id, ty_def_id);\n+                });\n             }\n         }\n+    }\n \n-        // Erase regions because they may not be deterministic when hashed\n-        // and should not matter anyhow.\n-        let instance_ty = scx.tcx().erase_regions(&instance_ty);\n+    // Erase regions because they may not be deterministic when hashed\n+    // and should not matter anyhow.\n+    let instance_ty = scx.tcx().erase_regions(&instance_ty);\n \n-        let hash = get_symbol_hash(scx, &def_path, instance_ty, Some(substs));\n+    let hash = get_symbol_hash(scx, &def_path, instance_ty, Some(substs));\n \n-        let mut buffer = SymbolPathBuffer {\n-            names: Vec::with_capacity(def_path.data.len())\n-        };\n+    let mut buffer = SymbolPathBuffer {\n+        names: Vec::with_capacity(def_path.data.len())\n+    };\n \n-        item_path::with_forced_absolute_paths(|| {\n-            scx.tcx().push_item_path(&mut buffer, def_id);\n-        });\n+    item_path::with_forced_absolute_paths(|| {\n+        scx.tcx().push_item_path(&mut buffer, def_id);\n+    });\n \n-        mangle(buffer.names.into_iter(), &hash)\n-    }\n+    mangle(buffer.names.into_iter(), &hash)\n }\n \n struct SymbolPathBuffer {"}, {"sha": "ce767468c012bfb61bbe162716d8e8fd9fba953f", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -565,11 +565,11 @@ pub fn memcpy_ty<'a, 'tcx>(\n }\n \n pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n-                               ptr: ValueRef,\n-                               fill_byte: ValueRef,\n-                               size: ValueRef,\n-                               align: ValueRef,\n-                               volatile: bool) -> ValueRef {\n+                             ptr: ValueRef,\n+                             fill_byte: ValueRef,\n+                             size: ValueRef,\n+                             align: ValueRef,\n+                             volatile: bool) -> ValueRef {\n     let ptr_width = &b.ccx.sess().target.target.target_pointer_width[..];\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n     let llintrinsicfn = b.ccx.get_intrinsic(&intrinsic_key);\n@@ -581,7 +581,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     let _s = if ccx.sess().trans_stats() {\n         let mut instance_name = String::new();\n         DefPathBasedNames::new(ccx.tcx(), true, true)\n-            .push_def_path(instance.def, &mut instance_name);\n+            .push_def_path(instance.def_id(), &mut instance_name);\n         Some(StatRecorder::new(ccx, instance_name))\n     } else {\n         None\n@@ -592,7 +592,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     // release builds.\n     info!(\"trans_instance({})\", instance);\n \n-    let fn_ty = common::def_ty(ccx.shared(), instance.def, instance.substs);\n+    let fn_ty = common::instance_ty(ccx.shared(), &instance);\n     let sig = common::ty_fn_sig(ccx, fn_ty);\n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n \n@@ -607,7 +607,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n         attributes::emit_uwtable(lldecl, true);\n     }\n \n-    let mir = ccx.tcx().item_mir(instance.def);\n+    let mir = ccx.tcx().instance_mir(instance.def);\n     mir::trans_mir(ccx, lldecl, &mir, instance, sig);\n }\n \n@@ -668,7 +668,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n         ccx.tcx().sess.span_fatal(span, \"compilation successful\");\n     }\n \n-    let instance = Instance::mono(ccx.shared(), main_def_id);\n+    let instance = Instance::mono(ccx.tcx(), main_def_id);\n \n     if !ccx.codegen_unit().contains_item(&TransItem::Fn(instance)) {\n         // We want to create the wrapper in the same codegen unit as Rust's main"}, {"sha": "19fc4e013fae1f7f401f534894c78223a9723005", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -27,11 +27,12 @@ use common::{self, CrateContext};\n use cleanup::CleanupScope;\n use mir::lvalue::LvalueRef;\n use consts;\n-use common::def_ty;\n+use common::instance_ty;\n use declare;\n use value::Value;\n use meth;\n use monomorphize::Instance;\n+use back::symbol_names::symbol_name;\n use trans_item::TransItem;\n use type_of;\n use rustc::ty::{self, Ty, TypeFoldable};\n@@ -77,7 +78,8 @@ impl<'tcx> Callee<'tcx> {\n             return Callee::trait_method(ccx, trait_id, def_id, substs);\n         }\n \n-        let fn_ty = def_ty(ccx.shared(), def_id, substs);\n+        let instance = ty::Instance::new(def_id, substs);\n+        let fn_ty = instance_ty(ccx.shared(), &instance);\n         if let ty::TyFnDef(.., f) = fn_ty.sty {\n             if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n                 return Callee {\n@@ -87,7 +89,7 @@ impl<'tcx> Callee<'tcx> {\n             }\n         }\n \n-        let (llfn, ty) = get_fn(ccx, def_id, substs);\n+        let (llfn, ty) = get_fn(ccx, instance);\n         Callee::ptr(llfn, ty)\n     }\n \n@@ -104,13 +106,13 @@ impl<'tcx> Callee<'tcx> {\n         match common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref) {\n             traits::VtableImpl(vtable_impl) => {\n                 let name = tcx.item_name(def_id);\n-                let (def_id, substs) = traits::find_method(tcx, name, substs, &vtable_impl);\n+                let instance = common::find_method(tcx, name, substs, &vtable_impl);\n \n                 // Translate the function, bypassing Callee::def.\n                 // That is because default methods have the same ID as the\n                 // trait method used to look up the impl method that ended\n                 // up here, so calling Callee::def would infinitely recurse.\n-                let (llfn, ty) = get_fn(ccx, def_id, substs);\n+                let (llfn, ty) = get_fn(ccx, instance);\n                 Callee::ptr(llfn, ty)\n             }\n             traits::VtableClosure(vtable_closure) => {\n@@ -125,7 +127,7 @@ impl<'tcx> Callee<'tcx> {\n                     instance,\n                     trait_closure_kind);\n \n-                let method_ty = def_ty(ccx.shared(), def_id, substs);\n+                let method_ty = instance_ty(ccx.shared(), &instance);\n                 Callee::ptr(llfn, method_ty)\n             }\n             traits::VtableFnPointer(vtable_fn_pointer) => {\n@@ -135,13 +137,13 @@ impl<'tcx> Callee<'tcx> {\n                                                  trait_closure_kind,\n                                                  vtable_fn_pointer.fn_ty);\n \n-                let method_ty = def_ty(ccx.shared(), def_id, substs);\n+                let method_ty = instance_ty(ccx.shared(), &instance);\n                 Callee::ptr(llfn, method_ty)\n             }\n             traits::VtableObject(ref data) => {\n                 Callee {\n                     data: Virtual(tcx.get_vtable_index_of_object_method(data, def_id)),\n-                    ty: def_ty(ccx.shared(), def_id, substs)\n+                    ty: instance_ty(ccx.shared(), &Instance::new(def_id, substs))\n                 }\n             }\n             vtable => {\n@@ -183,7 +185,7 @@ fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                                   -> ValueRef\n {\n     // If this is a closure, redirect to it.\n-    let (llfn, _) = get_fn(ccx, def_id, substs.substs);\n+    let (llfn, _) = get_fn(ccx, Instance::new(def_id, substs.substs));\n \n     // If the closure is a Fn closure, but a FnOnce is needed (etc),\n     // then adapt the self type\n@@ -292,7 +294,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let llonce_fn_ty = tcx.mk_fn_ptr(ty::Binder(sig));\n \n     // Create the by-value helper.\n-    let function_name = method_instance.symbol_name(ccx.shared());\n+    let function_name = symbol_name(method_instance, ccx.shared());\n     let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, lloncefn);\n \n@@ -438,7 +440,7 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n     debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n \n     //\n-    let function_name = method_instance.symbol_name(ccx.shared());\n+    let function_name = symbol_name(method_instance, ccx.shared());\n     let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n     //\n@@ -489,21 +491,17 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n /// - `def_id`: def id of the fn or method item being referenced\n /// - `substs`: values for each of the fn/method's parameters\n fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                    def_id: DefId,\n-                    substs: &'tcx Substs<'tcx>)\n+                    instance: Instance<'tcx>)\n                     -> (ValueRef, Ty<'tcx>) {\n     let tcx = ccx.tcx();\n \n-    debug!(\"get_fn(def_id={:?}, substs={:?})\", def_id, substs);\n+    debug!(\"get_fn(instance={:?})\", instance);\n \n-    assert!(!substs.needs_infer());\n-    assert!(!substs.has_escaping_regions());\n-    assert!(!substs.has_param_types());\n-\n-    let substs = tcx.normalize_associated_type(&substs);\n-    let instance = Instance::new(def_id, substs);\n-    let fn_ty = common::def_ty(ccx.shared(), def_id, substs);\n+    assert!(!instance.substs.needs_infer());\n+    assert!(!instance.substs.has_escaping_regions());\n+    assert!(!instance.substs.has_param_types());\n \n+    let fn_ty = common::instance_ty(ccx.shared(), &instance);\n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n         return (llfn, fn_ty);\n     }\n@@ -553,7 +551,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         assert_eq!(common::val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n \n-        let attrs = ccx.tcx().get_attrs(def_id);\n+        let attrs = instance.def.attrs(ccx.tcx());\n         attributes::from_fn_attrs(ccx, &attrs, llfn);\n \n         let is_local_def = ccx.shared().translation_items().borrow()\n@@ -565,7 +563,9 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n             }\n         }\n-        if ccx.use_dll_storage_attrs() && ccx.sess().cstore.is_dllimport_foreign_item(def_id) {\n+        if ccx.use_dll_storage_attrs() &&\n+            ccx.sess().cstore.is_dllimport_foreign_item(instance.def_id())\n+        {\n             unsafe {\n                 llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);\n             }"}, {"sha": "271f91f9adbdb53c3dfcfd1cb5c60d4d82867dbb", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 110, "deletions": 190, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -207,7 +207,7 @@ use syntax_pos::DUMMY_SP;\n use base::custom_coerce_unsize_info;\n use callee::needs_fn_once_adapter_shim;\n use context::SharedCrateContext;\n-use common::{def_ty, fulfill_obligation};\n+use common::{def_ty, find_method, instance_ty, fulfill_obligation};\n use glue::{self, DropGlueKind};\n use monomorphize::{self, Instance};\n use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n@@ -337,21 +337,22 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n         TransItem::Static(node_id) => {\n             let def_id = scx.tcx().hir.local_def_id(node_id);\n+            let instance = Instance::mono(scx.tcx(), def_id);\n \n             // Sanity check whether this ended up being collected accidentally\n-            debug_assert!(should_trans_locally(scx.tcx(), def_id));\n+            debug_assert!(should_trans_locally(scx.tcx(), &instance));\n \n-            let ty = def_ty(scx, def_id, Substs::empty());\n+            let ty = instance_ty(scx, &instance);\n             let ty = glue::get_drop_glue_type(scx, ty);\n             neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n \n             recursion_depth_reset = None;\n \n-            collect_neighbours(scx, Instance::mono(scx, def_id), &mut neighbors);\n+            collect_neighbours(scx, instance, &mut neighbors);\n         }\n         TransItem::Fn(instance) => {\n             // Sanity check whether this ended up being collected accidentally\n-            debug_assert!(should_trans_locally(scx.tcx(), instance.def));\n+            debug_assert!(should_trans_locally(scx.tcx(), &instance));\n \n             // Keep track of the monomorphization recursion depth\n             recursion_depth_reset = Some(check_recursion_limit(scx.tcx(),\n@@ -395,9 +396,8 @@ fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    instance: Instance<'tcx>,\n                                    recursion_depths: &mut DefIdMap<usize>)\n                                    -> (DefId, usize) {\n-    let recursion_depth = recursion_depths.get(&instance.def)\n-                                          .map(|x| *x)\n-                                          .unwrap_or(0);\n+    let def_id = instance.def_id();\n+    let recursion_depth = recursion_depths.get(&def_id).cloned().unwrap_or(0);\n     debug!(\" => recursion depth={}\", recursion_depth);\n \n     // Code that needs to instantiate the same function recursively\n@@ -406,16 +406,16 @@ fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if recursion_depth > tcx.sess.recursion_limit.get() {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\",\n                             instance);\n-        if let Some(node_id) = tcx.hir.as_local_node_id(instance.def) {\n+        if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n             tcx.sess.span_fatal(tcx.hir.span(node_id), &error);\n         } else {\n             tcx.sess.fatal(&error);\n         }\n     }\n \n-    recursion_depths.insert(instance.def, recursion_depth + 1);\n+    recursion_depths.insert(def_id, recursion_depth + 1);\n \n-    (instance.def, recursion_depth)\n+    (def_id, recursion_depth)\n }\n \n fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -438,7 +438,7 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let instance_name = instance.to_string();\n         let msg = format!(\"reached the type-length limit while instantiating `{:.64}...`\",\n                           instance_name);\n-        let mut diag = if let Some(node_id) = tcx.hir.as_local_node_id(instance.def) {\n+        let mut diag = if let Some(node_id) = tcx.hir.as_local_node_id(instance.def_id()) {\n             tcx.sess.struct_span_fatal(tcx.hir.span(node_id), &msg)\n         } else {\n             tcx.sess.struct_fatal(&msg)\n@@ -493,33 +493,24 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 let source_ty = operand.ty(self.mir, self.scx.tcx());\n                 match source_ty.sty {\n                     ty::TyClosure(def_id, substs) => {\n-                        let closure_trans_item =\n-                            create_fn_trans_item(self.scx,\n-                                                 def_id,\n-                                                 substs.substs,\n-                                                 self.param_substs);\n-                        self.output.push(closure_trans_item);\n+                        let substs = monomorphize::apply_param_substs(\n+                            self.scx, self.param_substs, &substs.substs);\n+                        self.output.push(create_fn_trans_item(\n+                            Instance::new(def_id, substs)\n+                        ));\n                     }\n                     _ => bug!(),\n                 }\n             }\n             mir::Rvalue::Box(..) => {\n-                let exchange_malloc_fn_def_id =\n-                    self.scx\n-                        .tcx()\n-                        .lang_items\n-                        .require(ExchangeMallocFnLangItem)\n-                        .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n-\n-                if should_trans_locally(self.scx.tcx(), exchange_malloc_fn_def_id) {\n-                    let empty_substs = self.scx.empty_substs_for_def_id(exchange_malloc_fn_def_id);\n-                    let exchange_malloc_fn_trans_item =\n-                        create_fn_trans_item(self.scx,\n-                                             exchange_malloc_fn_def_id,\n-                                             empty_substs,\n-                                             self.param_substs);\n-\n-                    self.output.push(exchange_malloc_fn_trans_item);\n+                let tcx = self.scx.tcx();\n+                let exchange_malloc_fn_def_id = tcx\n+                    .lang_items\n+                    .require(ExchangeMallocFnLangItem)\n+                    .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n+                let instance = Instance::mono(tcx, exchange_malloc_fn_def_id);\n+                if should_trans_locally(tcx, &instance) {\n+                    self.output.push(create_fn_trans_item(instance));\n                 }\n             }\n             _ => { /* not interesting */ }\n@@ -564,8 +555,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                         let substs = monomorphize::apply_param_substs(self.scx,\n                                                                       self.param_substs,\n                                                                       &substs);\n-\n-                        let instance = Instance::new(def_id, substs).resolve_const(self.scx);\n+                        let instance = monomorphize::resolve_const(self.scx, def_id, substs);\n                         collect_neighbours(self.scx, instance, self.output);\n                     }\n \n@@ -586,28 +576,24 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             //\n             // Calling do_static_dispatch() here will map the def_id of\n             // `std::cmp::partial_cmp` to the def_id of `i32::partial_cmp<i32>`\n+\n+            let callee_substs = monomorphize::apply_param_substs(self.scx,\n+                                                                 self.param_substs,\n+                                                                 &callee_substs);\n             let dispatched = do_static_dispatch(self.scx,\n                                                 callee_def_id,\n-                                                callee_substs,\n-                                                self.param_substs);\n+                                                callee_substs);\n \n             if let StaticDispatchResult::Dispatched {\n-                    def_id: callee_def_id,\n-                    substs: callee_substs,\n-                    fn_once_adjustment,\n-                } = dispatched {\n+                instance, fn_once_adjustment\n+            } = dispatched {\n                 // if we have a concrete impl (which we might not have\n                 // in the case of something compiler generated like an\n                 // object shim or a closure that is handled differently),\n                 // we check if the callee is something that will actually\n                 // result in a translation item ...\n-                if can_result_in_trans_item(self.scx.tcx(), callee_def_id) {\n-                    // ... and create one if it does.\n-                    let trans_item = create_fn_trans_item(self.scx,\n-                                                          callee_def_id,\n-                                                          callee_substs,\n-                                                          self.param_substs);\n-                    self.output.push(trans_item);\n+                if should_trans_locally(self.scx.tcx(), &instance) {\n+                    self.output.push(create_fn_trans_item(instance));\n \n                     // This call will instantiate an FnOnce adapter, which drops\n                     // the closure environment. Therefore we need to make sure\n@@ -624,26 +610,6 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         }\n \n         self.super_operand(operand, location);\n-\n-        fn can_result_in_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                              def_id: DefId)\n-                                              -> bool {\n-            match tcx.item_type(def_id).sty {\n-                ty::TyFnDef(def_id, _, _) => {\n-                    // foreign items are linked from another library, not\n-                    // translated locally.\n-                    if let Some(hir_map::NodeForeignItem(_)) = tcx.hir.get_if_local(def_id) {\n-                        return false;\n-                    }\n-                }\n-                ty::TyClosure(..) => {\n-                    // TODO: trans items for closures\n-                }\n-                _ => return false\n-            }\n-\n-            should_trans_locally(tcx, def_id)\n-        }\n     }\n \n     // This takes care of the \"drop_in_place\" intrinsic for which we otherwise\n@@ -695,22 +661,30 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n // Returns true if we should translate an instance in the local crate.\n // Returns false if we can just link to the upstream crate and therefore don't\n // need a translation item.\n-fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  def_id: DefId)\n+fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instance<'tcx>)\n                                   -> bool {\n-    if def_id.is_local() {\n-        true\n-    } else {\n-        if tcx.sess.cstore.is_exported_symbol(def_id) ||\n-           tcx.sess.cstore.is_foreign_item(def_id) {\n-            // We can link to the item in question, no instance needed in this\n-            // crate\n-            false\n-        } else {\n-            if !tcx.sess.cstore.is_item_mir_available(def_id) {\n-                bug!(\"Cannot create local trans-item for {:?}\", def_id)\n+    let def_id = match instance.def {\n+        ty::InstanceDef::Item(def_id) => def_id,\n+        ty::InstanceDef::FnPtrShim(..) => return true\n+    };\n+    match tcx.hir.get_if_local(def_id) {\n+        Some(hir_map::NodeForeignItem(..)) => {\n+            false // foreign items are linked against, not translated.\n+        }\n+        Some(_) => true,\n+        None => {\n+            if tcx.sess.cstore.is_exported_symbol(def_id) ||\n+                tcx.sess.cstore.is_foreign_item(def_id)\n+            {\n+                // We can link to the item in question, no instance needed\n+                // in this crate\n+                false\n+            } else {\n+                if !tcx.sess.cstore.is_item_mir_available(def_id) {\n+                    bug!(\"Cannot create local trans-item for {:?}\", def_id)\n+                }\n+                true\n             }\n-            true\n         }\n     }\n }\n@@ -731,14 +705,14 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n     // Make sure the BoxFreeFn lang-item gets translated if there is a boxed value.\n     if ty.is_box() {\n-        let def_id = scx.tcx().require_lang_item(BoxFreeFnLangItem);\n-        if should_trans_locally(scx.tcx(), def_id) {\n-            let box_free_fn_trans_item =\n-                create_fn_trans_item(scx,\n-                                     def_id,\n-                                     scx.tcx().mk_substs(iter::once(Kind::from(ty.boxed_ty()))),\n-                                     scx.tcx().intern_substs(&[]));\n-            output.push(box_free_fn_trans_item);\n+        let tcx = scx.tcx();\n+        let def_id = tcx.require_lang_item(BoxFreeFnLangItem);\n+        let box_free_instance = Instance::new(\n+            def_id,\n+            tcx.mk_substs(iter::once(Kind::from(ty.boxed_ty())))\n+        );\n+        if should_trans_locally(tcx, &box_free_instance) {\n+            output.push(create_fn_trans_item(box_free_instance));\n         }\n     }\n \n@@ -768,13 +742,9 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             traits::VtableImpl(data) => data.substs,\n             _ => bug!()\n         };\n-\n-        if should_trans_locally(scx.tcx(), destructor.did) {\n-            let trans_item = create_fn_trans_item(scx,\n-                                                  destructor.did,\n-                                                  substs,\n-                                                  scx.tcx().intern_substs(&[]));\n-            output.push(trans_item);\n+        let instance = Instance::new(destructor.did, substs);\n+        if should_trans_locally(scx.tcx(), &instance) {\n+            output.push(create_fn_trans_item(instance));\n         }\n \n         // This type has a Drop implementation, we'll need the contents-only\n@@ -847,86 +817,68 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     }\n }\n \n+enum StaticDispatchResult<'tcx> {\n+    // The call could be resolved statically as going to the method with\n+    // `instance`.\n+    Dispatched {\n+        instance: Instance<'tcx>,\n+        // If this is a call to a closure that needs an FnOnce adjustment,\n+        // this contains the new self type of the call (= type of the closure\n+        // environment)\n+        fn_once_adjustment: Option<ty::Ty<'tcx>>,\n+    },\n+    // This goes to somewhere that we don't know at compile-time\n+    Unknown\n+}\n+\n fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                 fn_def_id: DefId,\n-                                fn_substs: &'tcx Substs<'tcx>,\n-                                param_substs: &'tcx Substs<'tcx>)\n+                                fn_substs: &'tcx Substs<'tcx>)\n                                 -> StaticDispatchResult<'tcx> {\n-    debug!(\"do_static_dispatch(fn_def_id={}, fn_substs={:?}, param_substs={:?})\",\n+    debug!(\"do_static_dispatch(fn_def_id={}, fn_substs={:?})\",\n            def_id_to_string(scx.tcx(), fn_def_id),\n-           fn_substs,\n-           param_substs);\n-\n+           fn_substs);\n     if let Some(trait_def_id) = scx.tcx().trait_of_item(fn_def_id) {\n         debug!(\" => trait method, attempting to find impl\");\n         do_static_trait_method_dispatch(scx,\n                                         &scx.tcx().associated_item(fn_def_id),\n                                         trait_def_id,\n-                                        fn_substs,\n-                                        param_substs)\n+                                        fn_substs)\n     } else {\n         debug!(\" => regular function\");\n         // The function is not part of an impl or trait, no dispatching\n         // to be done\n         StaticDispatchResult::Dispatched {\n-            def_id: fn_def_id,\n-            substs: fn_substs,\n+            instance: Instance::new(fn_def_id, fn_substs),\n             fn_once_adjustment: None,\n         }\n     }\n }\n \n-enum StaticDispatchResult<'tcx> {\n-    // The call could be resolved statically as going to the method with\n-    // `def_id` and `substs`.\n-    Dispatched {\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n-\n-        // If this is a call to a closure that needs an FnOnce adjustment,\n-        // this contains the new self type of the call (= type of the closure\n-        // environment)\n-        fn_once_adjustment: Option<ty::Ty<'tcx>>,\n-    },\n-    // This goes to somewhere that we don't know at compile-time\n-    Unknown\n-}\n-\n // Given a trait-method and substitution information, find out the actual\n // implementation of the trait method.\n fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                              trait_method: &ty::AssociatedItem,\n                                              trait_id: DefId,\n-                                             callee_substs: &'tcx Substs<'tcx>,\n-                                             param_substs: &'tcx Substs<'tcx>)\n+                                             rcvr_substs: &'tcx Substs<'tcx>)\n                                              -> StaticDispatchResult<'tcx> {\n     let tcx = scx.tcx();\n     debug!(\"do_static_trait_method_dispatch(trait_method={}, \\\n                                             trait_id={}, \\\n-                                            callee_substs={:?}, \\\n-                                            param_substs={:?}\",\n+                                            rcvr_substs={:?})\",\n            def_id_to_string(scx.tcx(), trait_method.def_id),\n            def_id_to_string(scx.tcx(), trait_id),\n-           callee_substs,\n-           param_substs);\n+           rcvr_substs);\n \n-    let rcvr_substs = monomorphize::apply_param_substs(scx,\n-                                                       param_substs,\n-                                                       &callee_substs);\n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n     let vtbl = fulfill_obligation(scx, DUMMY_SP, ty::Binder(trait_ref));\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n     match vtbl {\n         traits::VtableImpl(impl_data) => {\n-            let (def_id, substs) = traits::find_method(tcx,\n-                                                       trait_method.name,\n-                                                       rcvr_substs,\n-                                                       &impl_data);\n             StaticDispatchResult::Dispatched {\n-                def_id: def_id,\n-                substs: substs,\n+                instance: find_method(tcx, trait_method.name, rcvr_substs, &impl_data),\n                 fn_once_adjustment: None,\n             }\n         }\n@@ -950,8 +902,7 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             };\n \n             StaticDispatchResult::Dispatched {\n-                def_id: closure_def_id,\n-                substs: closure_data.substs.substs,\n+                instance: Instance::new(closure_def_id, closure_data.substs.substs),\n                 fn_once_adjustment: fn_once_adjustment,\n             }\n         }\n@@ -961,7 +912,7 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             if let ty::TyFnDef(def_id, substs, _) = data.fn_ty.sty {\n                 // The destination of the pointer might be something that needs\n                 // further dispatching, such as a trait method, so we do that.\n-                do_static_dispatch(scx, def_id, substs, param_substs)\n+                do_static_dispatch(scx, def_id, substs)\n             } else {\n                 StaticDispatchResult::Unknown\n             }\n@@ -1066,28 +1017,9 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     }\n }\n \n-fn create_fn_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                  def_id: DefId,\n-                                  fn_substs: &'tcx Substs<'tcx>,\n-                                  param_substs: &'tcx Substs<'tcx>)\n-                                  -> TransItem<'tcx> {\n-    let tcx = scx.tcx();\n-\n-    debug!(\"create_fn_trans_item(def_id={}, fn_substs={:?}, param_substs={:?})\",\n-            def_id_to_string(tcx, def_id),\n-            fn_substs,\n-            param_substs);\n-\n-    // We only get here, if fn_def_id either designates a local item or\n-    // an inlineable external item. Non-inlineable external items are\n-    // ignored because we don't want to generate any code for them.\n-    let concrete_substs = monomorphize::apply_param_substs(scx,\n-                                                           param_substs,\n-                                                           &fn_substs);\n-    assert!(concrete_substs.is_normalized_for_trans(),\n-            \"concrete_substs not normalized for trans: {:?}\",\n-            concrete_substs);\n-    TransItem::Fn(Instance::new(def_id, concrete_substs))\n+fn create_fn_trans_item<'a, 'tcx>(instance: Instance<'tcx>) -> TransItem<'tcx> {\n+    debug!(\"create_fn_trans_item(instance={})\", instance);\n+    TransItem::Fn(instance)\n }\n \n /// Creates a `TransItem` for each method that is referenced by the vtable for\n@@ -1102,28 +1034,25 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n     if let ty::TyDynamic(ref trait_ty, ..) = trait_ty.sty {\n         if let Some(principal) = trait_ty.principal() {\n             let poly_trait_ref = principal.with_self_ty(scx.tcx(), impl_ty);\n-            let param_substs = scx.tcx().intern_substs(&[]);\n-\n             assert!(!poly_trait_ref.has_escaping_regions());\n \n             // Walk all methods of the trait, including those of its supertraits\n             let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n             let methods = methods.filter_map(|method| method)\n                 .filter_map(|(def_id, substs)| {\n                     if let StaticDispatchResult::Dispatched {\n-                        def_id,\n-                        substs,\n+                        instance,\n                         // We already add the drop-glue for the closure env\n                         // unconditionally below.\n                         fn_once_adjustment: _ ,\n-                    } = do_static_dispatch(scx, def_id, substs, param_substs) {\n-                        Some((def_id, substs))\n+                    } = do_static_dispatch(scx, def_id, substs) {\n+                        Some(instance)\n                     } else {\n                         None\n                     }\n                 })\n-                .filter(|&(def_id, _)| should_trans_locally(scx.tcx(), def_id))\n-                .map(|(def_id, substs)| create_fn_trans_item(scx, def_id, substs, param_substs));\n+                .filter(|&instance| should_trans_locally(scx.tcx(), &instance))\n+                .map(|instance| create_fn_trans_item(instance));\n             output.extend(methods);\n         }\n         // Also add the destructor\n@@ -1195,7 +1124,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                     debug!(\"RootCollector: ItemFn({})\",\n                            def_id_to_string(self.scx.tcx(), def_id));\n \n-                    let instance = Instance::mono(self.scx, def_id);\n+                    let instance = Instance::mono(self.scx.tcx(), def_id);\n                     self.output.push(TransItem::Fn(instance));\n                 }\n             }\n@@ -1233,7 +1162,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                     debug!(\"RootCollector: MethodImplItem({})\",\n                            def_id_to_string(self.scx.tcx(), def_id));\n \n-                    let instance = Instance::mono(self.scx, def_id);\n+                    let instance = Instance::mono(self.scx.tcx(), def_id);\n                     self.output.push(TransItem::Fn(instance));\n                 }\n             }\n@@ -1278,31 +1207,22 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n \n                     // The substitutions we have are on the impl, so we grab\n                     // the method type from the impl to substitute into.\n-                    let impl_substs = Substs::for_item(tcx, impl_def_id,\n-                                                       |_, _| tcx.mk_region(ty::ReErased),\n-                                                       |_, _| tcx.types.err);\n+                    let impl_substs = tcx.empty_substs_for_def_id(impl_def_id);\n                     let impl_data = traits::VtableImplData {\n                         impl_def_id: impl_def_id,\n                         substs: impl_substs,\n                         nested: vec![]\n                     };\n-                    let (def_id, substs) = traits::find_method(tcx,\n-                                                               method.name,\n-                                                               callee_substs,\n-                                                               &impl_data);\n+                    let instance = find_method(tcx, method.name, callee_substs, &impl_data);\n \n-                    let predicates = tcx.item_predicates(def_id).predicates\n-                                        .subst(tcx, substs);\n+                    let predicates = tcx.item_predicates(instance.def_id()).predicates\n+                        .subst(tcx, impl_substs);\n                     if !traits::normalize_and_test_predicates(tcx, predicates) {\n                         continue;\n                     }\n \n-                    if should_trans_locally(tcx, method.def_id) {\n-                        let item = create_fn_trans_item(scx,\n-                                                        method.def_id,\n-                                                        callee_substs,\n-                                                        tcx.erase_regions(&substs));\n-                        output.push(item);\n+                    if should_trans_locally(tcx, &instance) {\n+                        output.push(create_fn_trans_item(instance));\n                     }\n                 }\n             }\n@@ -1318,7 +1238,7 @@ fn collect_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                 instance: Instance<'tcx>,\n                                 output: &mut Vec<TransItem<'tcx>>)\n {\n-    let mir = scx.tcx().item_mir(instance.def);\n+    let mir = scx.tcx().instance_mir(instance.def);\n \n     let mut visitor = MirNeighborCollector {\n         scx: scx,"}, {"sha": "4389207cdf294c40f9f76560037a197f6189db8f", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -602,15 +602,21 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn requests_inline(tcx: TyCtxt, def_id: DefId) -> bool {\n+pub fn requests_inline<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    instance: &ty::Instance<'tcx>\n+) -> bool {\n+    let def_id = match instance.def {\n+        ty::InstanceDef::Item(def_id) => def_id,\n+        _ => return true\n+    };\n     match tcx.def_key(def_id).disambiguated_data.data {\n         DefPathData::StructCtor |\n         DefPathData::EnumVariant(..) |\n         DefPathData::ClosureExpr => true,\n         _ => attr::requests_inline(&tcx.get_attrs(def_id)[..]),\n     }\n }\n-\n /// Given a DefId and some Substs, produces the monomorphic item type.\n pub fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n                         def_id: DefId,\n@@ -620,3 +626,23 @@ pub fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n     let ty = shared.tcx().item_type(def_id);\n     monomorphize::apply_param_substs(shared, substs, &ty)\n }\n+\n+/// Return the substituted type of an instance.\n+pub fn instance_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n+                             instance: &ty::Instance<'tcx>)\n+                             -> Ty<'tcx>\n+{\n+    let ty = instance.def.def_ty(shared.tcx());\n+    monomorphize::apply_param_substs(shared, instance.substs, &ty)\n+}\n+\n+pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             name: ast::Name,\n+                             substs: &'tcx Substs<'tcx>,\n+                             impl_data: &traits::VtableImplData<'tcx, ()>)\n+                             -> ty::Instance<'tcx>\n+{\n+    let (def_id, substs) = traits::find_method(tcx, name, substs, impl_data);\n+    let substs = tcx.erase_regions(&substs);\n+    ty::Instance::new(def_id, substs)\n+}"}, {"sha": "0c3d211912add2498885a63f8b2cda61c15ba02e", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n \n+use back::symbol_names;\n use llvm;\n use llvm::{SetUnnamedAddr};\n use llvm::{ValueRef, True};\n@@ -24,7 +25,6 @@ use monomorphize::Instance;\n use type_::Type;\n use type_of;\n use rustc::ty;\n-use rustc::ty::subst::Substs;\n \n use rustc::hir;\n \n@@ -80,12 +80,12 @@ pub fn addr_of(ccx: &CrateContext,\n }\n \n pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n-    let instance = Instance::mono(ccx.shared(), def_id);\n+    let instance = Instance::mono(ccx.tcx(), def_id);\n     if let Some(&g) = ccx.instances().borrow().get(&instance) {\n         return g;\n     }\n \n-    let ty = common::def_ty(ccx.shared(), def_id, Substs::empty());\n+    let ty = common::instance_ty(ccx.shared(), &instance);\n     let g = if let Some(id) = ccx.tcx().hir.as_local_node_id(def_id) {\n \n         let llty = type_of::type_of(ccx, ty);\n@@ -114,7 +114,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let sym = instance.symbol_name(ccx.shared());\n+                let sym = symbol_names::symbol_name(instance, ccx.shared());\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -174,7 +174,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n         g\n     } else {\n-        let sym = instance.symbol_name(ccx.shared());\n+        let sym = symbol_names::symbol_name(instance, ccx.shared());\n \n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n@@ -235,7 +235,8 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             v\n         };\n \n-        let ty = common::def_ty(ccx.shared(), def_id, Substs::empty());\n+        let instance = Instance::mono(ccx.tcx(), def_id);\n+        let ty = common::instance_ty(ccx.shared(), &instance);\n         let llty = type_of::type_of(ccx, ty);\n         let g = if val_llty == llty {\n             g"}, {"sha": "b7381dd07dcfa7083efc5385780fd7cda920998b", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -546,16 +546,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.translation_items\n     }\n \n-    /// Given the def-id of some item that has no type parameters, make\n-    /// a suitable \"empty substs\" for it.\n-    pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n-        Substs::for_item(self.tcx(), item_def_id,\n-                         |_, _| self.tcx().mk_region(ty::ReErased),\n-                         |_, _| {\n-            bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n-        })\n-    }\n-\n     pub fn metadata_symbol_name(&self) -> String {\n         format!(\"rust_metadata_{}_{}\",\n                 self.link_meta().crate_name,\n@@ -886,7 +876,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     /// Given the def-id of some item that has no type parameters, make\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n-        self.shared().empty_substs_for_def_id(item_def_id)\n+        self.tcx().empty_substs_for_def_id(item_def_id)\n     }\n \n     /// Generate a new symbol name with the given prefix. This symbol name must"}, {"sha": "8e86b50b3f7dd7c39e6c23a9df91ed679c64cfaf", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -205,7 +205,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return FunctionDebugContext::DebugInfoDisabled;\n     }\n \n-    for attr in cx.tcx().get_attrs(instance.def).iter() {\n+    for attr in instance.def.attrs(cx.tcx()).iter() {\n         if attr.check_name(\"no_debug\") {\n             return FunctionDebugContext::FunctionWithoutDebugInfo;\n         }\n@@ -229,11 +229,11 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     };\n \n     // Find the enclosing function, in case this is a closure.\n-    let def_key = cx.tcx().def_key(instance.def);\n+    let def_key = cx.tcx().def_key(instance.def_id());\n     let mut name = def_key.disambiguated_data.data.to_string();\n     let name_len = name.len();\n \n-    let fn_def_id = cx.tcx().closure_base_def_id(instance.def);\n+    let fn_def_id = cx.tcx().closure_base_def_id(instance.def_id());\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n@@ -246,11 +246,11 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                       &mut name);\n \n     // Build the linkage_name out of the item path and \"template\" parameters.\n-    let linkage_name = mangled_name_of_item(cx, instance.def, &name[name_len..]);\n+    let linkage_name = mangled_name_of_item(cx, instance.def_id(), &name[name_len..]);\n \n     let scope_line = span_start(cx, span).line;\n \n-    let local_id = cx.tcx().hir.as_local_node_id(instance.def);\n+    let local_id = cx.tcx().hir.as_local_node_id(instance.def_id());\n     let is_local_to_unit = local_id.map_or(false, |id| is_node_local_to_unit(cx, id));\n \n     let function_name = CString::new(name).unwrap();\n@@ -394,7 +394,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         // First, let's see if this is a method within an inherent impl. Because\n         // if yes, we want to make the result subroutine DIE a child of the\n         // subroutine's self-type.\n-        let self_type = cx.tcx().impl_of_method(instance.def).and_then(|impl_def_id| {\n+        let self_type = cx.tcx().impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n             // If the method does *not* belong to a trait, proceed\n             if cx.tcx().trait_id_of_impl(impl_def_id).is_none() {\n                 let impl_self_ty =\n@@ -417,9 +417,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         self_type.unwrap_or_else(|| {\n             namespace::item_namespace(cx, DefId {\n-                krate: instance.def.krate,\n+                krate: instance.def_id().krate,\n                 index: cx.tcx()\n-                         .def_key(instance.def)\n+                         .def_key(instance.def_id())\n                          .parent\n                          .expect(\"get_containing_scope: missing parent?\")\n             })"}, {"sha": "bfd9f69a922188f89c6eb3cefdd70f8058d4e35b", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -21,6 +21,7 @@ use machine;\n use monomorphize::Instance;\n use type_::Type;\n use type_of::*;\n+use back::symbol_names;\n use value::Value;\n use rustc::ty;\n \n@@ -70,7 +71,7 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let function_name = match callee.ty.sty {\n         ty::TyFnDef(def_id, substs, _) => {\n             let instance = Instance::new(def_id, substs);\n-            instance.symbol_name(ccx.shared())\n+            symbol_names::symbol_name(instance, ccx.shared())\n         }\n         _ => bug!()\n     };"}, {"sha": "deb1073cf9aedd1e29db25a04bb1749d551ca5ab", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -30,7 +30,7 @@ use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral, C_big_integra\n use common::{C_null, C_struct, C_str_slice, C_undef, C_uint, C_vector, is_undef};\n use common::const_to_opt_u128;\n use consts;\n-use monomorphize::{self, Instance};\n+use monomorphize;\n use type_of;\n use type_::Type;\n use value::Value;\n@@ -245,11 +245,12 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n-                 instance: Instance<'tcx>,\n+                 def_id: DefId,\n+                 substs: &'tcx Substs<'tcx>,\n                  args: IndexVec<mir::Local, Const<'tcx>>)\n                  -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let instance = instance.resolve_const(ccx.shared());\n-        let mir = ccx.tcx().item_mir(instance.def);\n+        let instance = monomorphize::resolve_const(ccx.shared(), def_id, substs);\n+        let mir = ccx.tcx().instance_mir(instance.def);\n         MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n     }\n \n@@ -332,10 +333,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 mir::TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n                     let fn_ty = func.ty(self.mir, tcx);\n                     let fn_ty = self.monomorphize(&fn_ty);\n-                    let instance = match fn_ty.sty {\n-                        ty::TyFnDef(def_id, substs, _) => {\n-                            Instance::new(def_id, substs)\n-                        }\n+                    let (def_id, substs) = match fn_ty.sty {\n+                        ty::TyFnDef(def_id, substs, _) => (def_id, substs),\n                         _ => span_bug!(span, \"calling {:?} (of type {}) in constant\",\n                                        func, fn_ty)\n                     };\n@@ -348,7 +347,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                     }\n                     if let Some((ref dest, target)) = *destination {\n-                        match MirConstContext::trans_def(self.ccx, instance, const_args) {\n+                        match MirConstContext::trans_def(self.ccx, def_id, substs, const_args) {\n                             Ok(value) => self.store(dest, value, span),\n                             Err(err) => if failure.is_ok() { failure = Err(err); }\n                         }\n@@ -485,8 +484,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n \n                         let substs = self.monomorphize(&substs);\n-                        let instance = Instance::new(def_id, substs);\n-                        MirConstContext::trans_def(self.ccx, instance, IndexVec::new())\n+                        MirConstContext::trans_def(self.ccx, def_id, substs, IndexVec::new())\n                     }\n                     mir::Literal::Promoted { index } => {\n                         let mir = &self.mir.promoted[index];\n@@ -588,7 +586,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 // Now create its substs [Closure, Tuple]\n                                 let input = tcx.closure_type(def_id)\n                                     .subst(tcx, substs.substs).input(0);\n-                                let substs = tcx.mk_substs([operand.ty, input.skip_binder()]\n+                                let input = tcx.erase_late_bound_regions_and_normalize(&input);\n+                                let substs = tcx.mk_substs([operand.ty, input]\n                                     .iter().cloned().map(Kind::from));\n                                 Callee::def(self.ccx, call_once, substs)\n                                     .reify(self.ccx)\n@@ -935,8 +934,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 let substs = self.monomorphize(&substs);\n-                let instance = Instance::new(def_id, substs);\n-                MirConstContext::trans_def(bcx.ccx, instance, IndexVec::new())\n+                MirConstContext::trans_def(bcx.ccx, def_id, substs, IndexVec::new())\n             }\n             mir::Literal::Promoted { index } => {\n                 let mir = &self.mir.promoted[index];\n@@ -964,8 +962,8 @@ pub fn trans_static_initializer<'a, 'tcx>(\n     def_id: DefId)\n     -> Result<ValueRef, ConstEvalErr<'tcx>>\n {\n-    let instance = Instance::mono(ccx.shared(), def_id);\n-    MirConstContext::trans_def(ccx, instance, IndexVec::new()).map(|c| c.llval)\n+    MirConstContext::trans_def(ccx, def_id, Substs::empty(), IndexVec::new())\n+        .map(|c| c.llval)\n }\n \n /// Construct a constant value, suitable for initializing a"}, {"sha": "bbaf0f9d35fa6c6e6403e3fe9c7f9e30fab52076", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -203,7 +203,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 // Now create its substs [Closure, Tuple]\n                                 let input = bcx.tcx().closure_type(def_id)\n                                     .subst(bcx.tcx(), substs.substs).input(0);\n-                                let substs = bcx.tcx().mk_substs([operand.ty, input.skip_binder()]\n+                                let input =\n+                                    bcx.tcx().erase_late_bound_regions_and_normalize(&input);\n+                                let substs = bcx.tcx().mk_substs([operand.ty, input]\n                                     .iter().cloned().map(Kind::from));\n                                 OperandValue::Immediate(\n                                     Callee::def(bcx.ccx, call_once, substs)"}, {"sha": "3b746af275a2aed41b471c9ccb160af6109b09c0", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 18, "deletions": 41, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -15,54 +15,31 @@ use rustc::traits;\n use rustc::ty::fold::{TypeFolder, TypeFoldable};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::util::ppaux;\n use rustc::util::common::MemoizationMap;\n \n use syntax::codemap::DUMMY_SP;\n \n-use std::fmt;\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct Instance<'tcx> {\n-    pub def: DefId,\n-    pub substs: &'tcx Substs<'tcx>,\n-}\n-\n-impl<'tcx> fmt::Display for Instance<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ppaux::parameterized(f, &self.substs, self.def, &[])\n-    }\n-}\n-\n-impl<'a, 'tcx> Instance<'tcx> {\n-    pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>)\n-               -> Instance<'tcx> {\n-        assert!(substs.regions().all(|&r| r == ty::ReErased));\n-        Instance { def: def_id, substs: substs }\n-    }\n-\n-    pub fn mono(scx: &SharedCrateContext<'a, 'tcx>, def_id: DefId) -> Instance<'tcx> {\n-        Instance::new(def_id, scx.empty_substs_for_def_id(def_id))\n-    }\n-\n-    /// For associated constants from traits, return the impl definition.\n-    pub fn resolve_const(&self, scx: &SharedCrateContext<'a, 'tcx>) -> Self {\n-        if let Some(trait_id) = scx.tcx().trait_of_item(self.def) {\n-            let trait_ref = ty::TraitRef::new(trait_id, self.substs);\n-            let trait_ref = ty::Binder(trait_ref);\n-            let vtable = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n-            if let traits::VtableImpl(vtable_impl) = vtable {\n-                let name = scx.tcx().item_name(self.def);\n-                let ac = scx.tcx().associated_items(vtable_impl.impl_def_id)\n-                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n-                if let Some(ac) = ac {\n-                    return Instance::new(ac.def_id, vtable_impl.substs);\n-                }\n+pub use rustc::ty::Instance;\n+\n+/// For associated constants from traits, return the impl definition.\n+pub fn resolve_const<'a, 'tcx>(\n+    scx: &SharedCrateContext<'a, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>\n+) -> Instance<'tcx> {\n+    if let Some(trait_id) = scx.tcx().trait_of_item(def_id) {\n+        let trait_ref = ty::TraitRef::new(trait_id, substs);\n+        let trait_ref = ty::Binder(trait_ref);\n+        let vtable = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n+        if let traits::VtableImpl(vtable_impl) = vtable {\n+            let name = scx.tcx().item_name(def_id);\n+            let ac = scx.tcx().associated_items(vtable_impl.impl_def_id)\n+                .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n+            if let Some(ac) = ac {\n+                return Instance::new(ac.def_id, vtable_impl.substs);\n             }\n         }\n-\n-        *self\n     }\n+\n+    Instance::new(def_id, substs)\n }\n \n /// Monomorphizes a type from the AST by first applying the in-scope"}, {"sha": "1232c6cd28e52988f06bfedf3898988b3825d225", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -110,7 +110,7 @@ use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use rustc_incremental::IchHasher;\n use std::cmp::Ordering;\n@@ -186,7 +186,8 @@ impl<'tcx> CodegenUnit<'tcx> {\n             symbol_name.hash(&mut state);\n             let exported = match item {\n                TransItem::Fn(ref instance) => {\n-                    let node_id = scx.tcx().hir.as_local_node_id(instance.def);\n+                   let node_id =\n+                       scx.tcx().hir.as_local_node_id(instance.def_id());\n                     node_id.map(|node_id| exported_symbols.contains(&node_id))\n                            .unwrap_or(false)\n                }\n@@ -241,7 +242,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         fn local_node_id(tcx: TyCtxt, trans_item: TransItem) -> Option<NodeId> {\n             match trans_item {\n                 TransItem::Fn(instance) => {\n-                    tcx.hir.as_local_node_id(instance.def)\n+                    tcx.hir.as_local_node_id(instance.def_id())\n                 }\n                 TransItem::Static(node_id) => Some(node_id),\n                 TransItem::DropGlue(_) => None,\n@@ -455,17 +456,22 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n     let tcx = scx.tcx();\n     match trans_item {\n         TransItem::Fn(instance) => {\n+            let def_id = match instance.def {\n+                ty::InstanceDef::Item(def_id) => def_id,\n+                ty::InstanceDef::FnPtrShim(..) => return None\n+            };\n+\n             // If this is a method, we want to put it into the same module as\n             // its self-type. If the self-type does not provide a characteristic\n             // DefId, we use the location of the impl after all.\n \n-            if tcx.trait_of_item(instance.def).is_some() {\n+            if tcx.trait_of_item(def_id).is_some() {\n                 let self_ty = instance.substs.type_at(0);\n                 // This is an implementation of a trait method.\n-                return characteristic_def_id_of_type(self_ty).or(Some(instance.def));\n+                return characteristic_def_id_of_type(self_ty).or(Some(def_id));\n             }\n \n-            if let Some(impl_def_id) = tcx.impl_of_method(instance.def) {\n+            if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n                 // This is a method within an inherent impl, find out what the\n                 // self-type is:\n                 let impl_self_ty = common::def_ty(scx, impl_def_id, instance.substs);\n@@ -474,7 +480,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n                 }\n             }\n \n-            Some(instance.def)\n+            Some(def_id)\n         }\n         TransItem::DropGlue(dg) => characteristic_def_id_of_type(dg.ty()),\n         TransItem::Static(node_id) => Some(tcx.hir.local_def_id(node_id)),"}, {"sha": "cd285bfaa6010352bb48bac747b02c31f86da075", "filename": "src/librustc_trans/symbol_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -97,7 +97,7 @@ impl<'tcx> SymbolMap<'tcx> {\n                               trans_item: TransItem<'tcx>) -> Option<Span> {\n             match trans_item {\n                 TransItem::Fn(Instance { def, .. }) => {\n-                    tcx.hir.as_local_node_id(def)\n+                    tcx.hir.as_local_node_id(def.def_id())\n                 }\n                 TransItem::Static(node_id) => Some(node_id),\n                 TransItem::DropGlue(_) => None,"}, {"sha": "fe551b06b3d95cff1b7e774139d7fbd99f5a19d9", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -14,6 +14,7 @@\n //! item-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n+use back::symbol_names;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use syntax::ast;\n@@ -51,8 +52,8 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n         for attr in tcx.get_attrs(def_id).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n-                let instance = Instance::mono(self.scx, def_id);\n-                let name = instance.symbol_name(self.scx);\n+                let instance = Instance::mono(tcx, def_id);\n+                let name = symbol_names::symbol_name(instance, self.scx);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n             } else if attr.check_name(ITEM_PATH) {\n                 let path = tcx.item_path_str(def_id);\n@@ -86,4 +87,3 @@ impl<'a, 'tcx> Visitor<'tcx> for SymbolNamesTest<'a, 'tcx> {\n         intravisit::walk_impl_item(self, ii)\n     }\n }\n-"}, {"sha": "13af081e0b698482bb417a090f93e3d9b64bdc88", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffee9566bbd7728e6411e6094105d6905373255d/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=ffee9566bbd7728e6411e6094105d6905373255d", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             }\n             TransItem::Fn(instance) => {\n                 let _task = ccx.tcx().dep_graph.in_task(\n-                    DepNode::TransCrateItem(instance.def)); // (*)\n+                    DepNode::TransCrateItem(instance.def_id())); // (*)\n \n                 base::trans_instance(&ccx, instance);\n             }\n@@ -147,7 +147,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                         linkage: llvm::Linkage,\n                         symbol_name: &str) {\n         let def_id = ccx.tcx().hir.local_def_id(node_id);\n-        let ty = common::def_ty(ccx.shared(), def_id, Substs::empty());\n+        let instance = Instance::mono(ccx.tcx(), def_id);\n+        let ty = common::instance_ty(ccx.shared(), &instance);\n         let llty = type_of::type_of(ccx, ty);\n \n         let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n@@ -157,7 +158,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         unsafe { llvm::LLVMRustSetLinkage(g, linkage) };\n \n-        let instance = Instance::mono(ccx.shared(), def_id);\n         ccx.instances().borrow_mut().insert(instance, g);\n         ccx.statics().borrow_mut().insert(g, def_id);\n     }\n@@ -169,8 +169,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         assert!(!instance.substs.needs_infer() &&\n                 !instance.substs.has_param_types());\n \n-        let mono_ty = common::def_ty(ccx.shared(), instance.def, instance.substs);\n-        let attrs = ccx.tcx().get_attrs(instance.def);\n+        let mono_ty = common::instance_ty(ccx.shared(), &instance);\n+        let attrs = instance.def.attrs(ccx.tcx());\n         let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n         unsafe { llvm::LLVMRustSetLinkage(lldecl, linkage) };\n         base::set_link_section(ccx, lldecl, &attrs);\n@@ -180,7 +180,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n \n         debug!(\"predefine_fn: mono_ty = {:?} instance = {:?}\", mono_ty, instance);\n-        match ccx.tcx().def_key(instance.def).disambiguated_data.data {\n+        match ccx.tcx().def_key(instance.def_id()).disambiguated_data.data {\n             DefPathData::StructCtor |\n             DefPathData::EnumVariant(..) |\n             DefPathData::ClosureExpr => {\n@@ -229,10 +229,10 @@ impl<'a, 'tcx> TransItem<'tcx> {\n     pub fn compute_symbol_name(&self,\n                                scx: &SharedCrateContext<'a, 'tcx>) -> String {\n         match *self {\n-            TransItem::Fn(instance) => instance.symbol_name(scx),\n+            TransItem::Fn(instance) => symbol_names::symbol_name(instance, scx),\n             TransItem::Static(node_id) => {\n                 let def_id = scx.tcx().hir.local_def_id(node_id);\n-                Instance::mono(scx, def_id).symbol_name(scx)\n+                symbol_names::symbol_name(Instance::mono(scx.tcx(), def_id), scx)\n             }\n             TransItem::DropGlue(dg) => {\n                 let prefix = match dg {\n@@ -244,21 +244,13 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn is_from_extern_crate(&self) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => !instance.def.is_local(),\n-            TransItem::DropGlue(..) |\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n     pub fn instantiation_mode(&self,\n                               tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                               -> InstantiationMode {\n         match *self {\n             TransItem::Fn(ref instance) => {\n                 if self.explicit_linkage(tcx).is_none() &&\n-                    common::requests_inline(tcx, instance.def)\n+                    common::requests_inline(tcx, instance)\n                 {\n                     InstantiationMode::LocalCopy\n                 } else {\n@@ -282,7 +274,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n         let def_id = match *self {\n-            TransItem::Fn(ref instance) => instance.def,\n+            TransItem::Fn(ref instance) => instance.def_id(),\n             TransItem::Static(node_id) => tcx.hir.local_def_id(node_id),\n             TransItem::DropGlue(..) => return None,\n         };\n@@ -587,7 +579,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n     pub fn push_instance_as_string(&self,\n                                    instance: Instance<'tcx>,\n                                    output: &mut String) {\n-        self.push_def_path(instance.def, output);\n+        self.push_def_path(instance.def_id(), output);\n         self.push_type_params(instance.substs, iter::empty(), output);\n     }\n }"}]}