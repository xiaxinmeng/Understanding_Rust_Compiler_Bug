{"sha": "491ed7f12c2c9adf186599ac5294cb24825ad36b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5MWVkN2YxMmMyYzlhZGYxODY1OTlhYzUyOTRjYjI0ODI1YWQzNmI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2011-08-04T23:20:53Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-09T22:53:26Z"}, "message": "Port the fuzzer and tests to ivec type [T] syntax.", "tree": {"sha": "f084a97edc66c3ae45b64d5286a016a6db35322b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f084a97edc66c3ae45b64d5286a016a6db35322b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/491ed7f12c2c9adf186599ac5294cb24825ad36b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/491ed7f12c2c9adf186599ac5294cb24825ad36b", "html_url": "https://github.com/rust-lang/rust/commit/491ed7f12c2c9adf186599ac5294cb24825ad36b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/491ed7f12c2c9adf186599ac5294cb24825ad36b/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b15045224ff1a0a051e513bc35561abee7a6f65", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b15045224ff1a0a051e513bc35561abee7a6f65", "html_url": "https://github.com/rust-lang/rust/commit/8b15045224ff1a0a051e513bc35561abee7a6f65"}], "stats": {"total": 80, "additions": 36, "deletions": 44}, "files": [{"sha": "0aede0667b8511d8f09b1ed46d78d1c3caee4ac5", "filename": "src/fuzzer/ast_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ffuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ffuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fast_match.rs?ref=491ed7f12c2c9adf186599ac5294cb24825ad36b", "patch": "@@ -1,7 +1,7 @@\n use std;\n import std::ivec;\n \n-fn ivec_equal[T](v: &T[], u: &T[], element_equality_test: fn(&T, &T) -> bool )\n+fn ivec_equal[T](v: &[T], u: &[T], element_equality_test: fn(&T, &T) -> bool )\n    -> bool {\n     let Lv = ivec::len(v);\n     if Lv != ivec::len(u) { ret false; }\n@@ -24,4 +24,4 @@ fn main() {\n     assert (ivec_equal(~[5, 5], ~[5, 5], builtin_equal));\n \n     log_err \"Pass\";\n-}\n\\ No newline at end of file\n+}"}, {"sha": "1f7c2c45eccc8bb82bea31d03280a7dd3a3dfd59", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=491ed7f12c2c9adf186599ac5294cb24825ad36b", "patch": "@@ -38,7 +38,7 @@ fn contains(haystack: &str, needle: &str) -> bool {\n     str::find(haystack, needle) != -1\n }\n \n-fn find_rust_files(files: &mutable str[], path: str) {\n+fn find_rust_files(files: &mutable [str], path: str) {\n     if str::ends_with(path, \".rs\") {\n         if file_contains(path, \"xfail-stage1\") {\n             //log_err \"Skipping \" + path + \" because it is marked as xfail-stage1\";\n@@ -89,10 +89,10 @@ fn safe_to_steal(e: ast::expr_) -> bool {\n     }\n }\n \n-fn steal_exprs(crate: &ast::crate) -> ast::expr[] {\n-    let exprs: @mutable ast::expr[] = @mutable ~[];\n+fn steal_exprs(crate: &ast::crate) -> [ast::expr] {\n+    let exprs: @mutable [ast::expr] = @mutable ~[];\n     // \"Stash\" is not type-parameterized because of the need for safe_to_steal\n-    fn stash_expr(es: @mutable ast::expr[], e: &@ast::expr) {\n+    fn stash_expr(es: @mutable [ast::expr], e: &@ast::expr) {\n         if safe_to_steal(e.node) {\n             *es += ~[*e];\n         } else {/* now my indices are wrong :( */ }\n@@ -316,7 +316,7 @@ fn check_roundtrip_convergence(code: &str, maxIters: uint) {\n     }\n }\n \n-fn check_convergence(files: &str[]) {\n+fn check_convergence(files: &[str]) {\n     log_err #fmt(\"pp convergence tests: %u files\", ivec::len(files));\n     for file in files {\n         if !file_is_confusing(file) {\n@@ -330,7 +330,7 @@ fn check_convergence(files: &str[]) {\n     }\n }\n \n-fn check_variants(files: &str[]) {\n+fn check_variants(files: &[str]) {\n     for file in files {\n         if !file_is_confusing(file) {\n             let s = ioivec::read_whole_file_str(file);"}, {"sha": "8448ef1dadfba3a2f6454a308ed91c046feabb1a", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=491ed7f12c2c9adf186599ac5294cb24825ad36b", "patch": "@@ -7,8 +7,8 @@ Idea: provide functions for 'exhaustive' and 'random' modification of vecs.\n   two functions, \"return the number of possible edits\" and \"return edit #n\"\n \n It would be nice if this could be data-driven, so the two functions could share information:\n-  type vec_modifier = rec(fn (&T[] v, uint i) -> T[] fun, uint lo, uint di);\n-  const vec_modifier[] vec_modifiers = ~[rec(fun=vec_omit, 0u, 1u), ...];\n+  type vec_modifier = rec(fn (&[T] v, uint i) -> [T] fun, uint lo, uint di);\n+  const [vec_modifier] vec_modifiers = ~[rec(fun=vec_omit, 0u, 1u), ...];\n But that gives me \"error: internal compiler error unimplemented consts that's not a plain literal\".\n https://github.com/graydon/rust/issues/570\n \n@@ -26,24 +26,24 @@ import std::ivec::slice;\n import std::ivec::len;\n import std::int;\n \n-//fn vec_reverse(&T[] v) -> T[] { ... }\n+//fn vec_reverse(&[T] v) -> [T] { ... }\n \n-fn vec_omit[T](v: &T[], i: uint) -> T[] {\n+fn vec_omit[T](v: &[T], i: uint) -> [T] {\n     slice(v, 0u, i) + slice(v, i + 1u, len(v))\n }\n-fn vec_dup[T](v: &T[], i: uint) -> T[] {\n+fn vec_dup[T](v: &[T], i: uint) -> [T] {\n     slice(v, 0u, i) + ~[v.(i)] + slice(v, i, len(v))\n }\n-fn vec_swadj[T](v: &T[], i: uint) -> T[] {\n+fn vec_swadj[T](v: &[T], i: uint) -> [T] {\n     slice(v, 0u, i) + ~[v.(i + 1u), v.(i)] + slice(v, i + 2u, len(v))\n }\n-fn vec_prefix[T](v: &T[], i: uint) -> T[] { slice(v, 0u, i) }\n-fn vec_suffix[T](v: &T[], i: uint) -> T[] { slice(v, i, len(v)) }\n+fn vec_prefix[T](v: &[T], i: uint) -> [T] { slice(v, 0u, i) }\n+fn vec_suffix[T](v: &[T], i: uint) -> [T] { slice(v, i, len(v)) }\n \n-fn vec_poke[T](v: &T[], i: uint, x: &T) -> T[] {\n+fn vec_poke[T](v: &[T], i: uint, x: &T) -> [T] {\n     slice(v, 0u, i) + ~[x] + slice(v, i + 1u, len(v))\n }\n-fn vec_insert[T](v: &T[], i: uint, x: &T) -> T[] {\n+fn vec_insert[T](v: &[T], i: uint, x: &T) -> [T] {\n     slice(v, 0u, i) + ~[x] + slice(v, i, len(v))\n }\n \n@@ -54,8 +54,8 @@ iter ix(skip_low: uint, skip_high: uint, length: uint) -> uint {\n }\n \n // Returns a bunch of modified versions of v, some of which introduce new elements (borrowed from xs).\n-fn vec_edits[T](v: &T[], xs: &T[]) -> T[][] {\n-    let edits: T[][] = ~[];\n+fn vec_edits[T](v: &[T], xs: &[T]) -> [[T]] {\n+    let edits: [[T]] = ~[];\n     let Lv: uint = len(v);\n \n     if Lv != 1u {\n@@ -85,7 +85,7 @@ fn vec_edits[T](v: &T[], xs: &T[]) -> T[][] {\n }\n \n // Would be nice if this were built in: https://github.com/graydon/rust/issues/424\n-fn vec_to_str(v: &int[]) -> str {\n+fn vec_to_str(v: &[int]) -> str {\n     let i = 0u;\n     let s = \"[\";\n     while i < len(v) {\n@@ -96,7 +96,7 @@ fn vec_to_str(v: &int[]) -> str {\n     ret s + \"]\";\n }\n \n-fn show_edits(a: &int[], xs: &int[]) {\n+fn show_edits(a: &[int], xs: &[int]) {\n     log_err \"=== Edits of \" + vec_to_str(a) + \" ===\";\n     let b = vec_edits(a, xs);\n     for each i: uint  in ix(0u, 1u, len(b)) { log_err vec_to_str(b.(i)); }\n@@ -111,4 +111,4 @@ fn demo_edits() {\n     show_edits(~[1, 2, 3, 4], xs);\n }\n \n-fn main() { demo_edits(); }\n\\ No newline at end of file\n+fn main() { demo_edits(); }"}, {"sha": "717b50be9e3d43ecd5001d69571256eeb0a194bc", "filename": "src/test/pretty/ivec-type.pp", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ftest%2Fpretty%2Fivec-type.pp", "raw_url": "https://github.com/rust-lang/rust/raw/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ftest%2Fpretty%2Fivec-type.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fivec-type.pp?ref=491ed7f12c2c9adf186599ac5294cb24825ad36b", "patch": "@@ -3,7 +3,3 @@\n fn f1(x: [int]) { }\n \n fn g1() { f1(~[1, 2, 3]); }\n-\n-fn f2(x: [int]) { }\n-\n-fn g2() { f2(~[1, 2, 3]); }"}, {"sha": "717b50be9e3d43ecd5001d69571256eeb0a194bc", "filename": "src/test/pretty/ivec-type.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ftest%2Fpretty%2Fivec-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ftest%2Fpretty%2Fivec-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fivec-type.rs?ref=491ed7f12c2c9adf186599ac5294cb24825ad36b", "patch": "@@ -1,9 +1,5 @@\n // pp-exact:ivec-type.pp\n \n-fn f1(x: int[]) { }\n+fn f1(x: [int]) { }\n \n fn g1() { f1(~[1, 2, 3]); }\n-\n-fn f2(x: [int]) { }\n-\n-fn g2() { f2(~[1, 2, 3]); }"}, {"sha": "f2b81d41b0b156e3996beed5562b49c12371eea9", "filename": "src/test/run-pass/alloca-from-derived-tydesc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs?ref=491ed7f12c2c9adf186599ac5294cb24825ad36b", "patch": "@@ -1,6 +1,6 @@\n tag option[T] { some(T); none; }\n \n-type r[T] = {mutable v: (option[T])[]};\n+type r[T] = {mutable v: [option[T]]};\n \n fn f[T]() -> [T] { ret ~[]; }\n "}, {"sha": "24c27b5212ce377d80812fbf1cbe5b2a02bef738", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=491ed7f12c2c9adf186599ac5294cb24825ad36b", "patch": "@@ -1,14 +1,14 @@\n use std;\n \n-fn producer(c: chan[u8[]]) {\n+fn producer(c: chan[[u8]]) {\n     c <| ~[1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8,\n            8u8, 9u8, 10u8, 11u8, 12u8, 13u8 ];\n }\n \n fn main() {\n-    let p: port[u8[]] = port();\n+    let p: port[[u8]] = port();\n     let prod: task = spawn producer(chan(p));\n \n-    let data: u8[];\n+    let data: [u8];\n     p |> data;\n }"}, {"sha": "677abeda4125b8324c971d2c52e20a5dab3f0268", "filename": "src/test/stdtest/either.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ftest%2Fstdtest%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491ed7f12c2c9adf186599ac5294cb24825ad36b/src%2Ftest%2Fstdtest%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Feither.rs?ref=491ed7f12c2c9adf186599ac5294cb24825ad36b", "patch": "@@ -27,14 +27,14 @@ fn test_lefts() {\n \n #[test]\n fn test_lefts_none() {\n-    let input: (t[int, int])[] = ~[right(10), right(10)];\n+    let input: [t[int, int]] = ~[right(10), right(10)];\n     let result = lefts(input);\n     assert (len(result) == 0u);\n }\n \n #[test]\n fn test_lefts_empty() {\n-    let input: (t[int, int])[] = ~[];\n+    let input: [t[int, int]] = ~[];\n     let result = lefts(input);\n     assert (len(result) == 0u);\n }\n@@ -48,14 +48,14 @@ fn test_rights() {\n \n #[test]\n fn test_rights_none() {\n-    let input: (t[int, int])[] = ~[left(10), left(10)];\n+    let input: [t[int, int]] = ~[left(10), left(10)];\n     let result = rights(input);\n     assert (len(result) == 0u);\n }\n \n #[test]\n fn test_rights_empty() {\n-    let input: (t[int, int])[] = ~[];\n+    let input: [t[int, int]] = ~[];\n     let result = rights(input);\n     assert (len(result) == 0u);\n }\n@@ -73,24 +73,24 @@ fn test_partition() {\n \n #[test]\n fn test_partition_no_lefts() {\n-    let input: (t[int, int])[] = ~[right(10), right(11)];\n+    let input: [t[int, int]] = ~[right(10), right(11)];\n     let result = partition(input);\n     assert (len(result.lefts) == 0u);\n     assert (len(result.rights) == 2u);\n }\n \n #[test]\n fn test_partition_no_rights() {\n-    let input: (t[int, int])[] = ~[left(10), left(11)];\n+    let input: [t[int, int]] = ~[left(10), left(11)];\n     let result = partition(input);\n     assert (len(result.lefts) == 2u);\n     assert (len(result.rights) == 0u);\n }\n \n #[test]\n fn test_partition_empty() {\n-    let input: (t[int, int])[] = ~[];\n+    let input: [t[int, int]] = ~[];\n     let result = partition(input);\n     assert (len(result.lefts) == 0u);\n     assert (len(result.rights) == 0u);\n-}\n\\ No newline at end of file\n+}"}]}