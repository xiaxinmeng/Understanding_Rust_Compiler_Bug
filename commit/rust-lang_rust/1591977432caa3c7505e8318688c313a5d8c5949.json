{"sha": "1591977432caa3c7505e8318688c313a5d8c5949", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OTE5Nzc0MzJjYWEzYzc1MDVlODMxODY4OGMzMTNhNWQ4YzU5NDk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-09-09T08:56:33Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-09-09T09:18:02Z"}, "message": "clean up suspensions when function ends", "tree": {"sha": "2ea8d87a54884fdd1f419cc43b771c2594b02cc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ea8d87a54884fdd1f419cc43b771c2594b02cc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1591977432caa3c7505e8318688c313a5d8c5949", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1591977432caa3c7505e8318688c313a5d8c5949", "html_url": "https://github.com/rust-lang/rust/commit/1591977432caa3c7505e8318688c313a5d8c5949", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1591977432caa3c7505e8318688c313a5d8c5949/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc2f9259e609d6027a651c790ccf76f62ab5cd34", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc2f9259e609d6027a651c790ccf76f62ab5cd34", "html_url": "https://github.com/rust-lang/rust/commit/bc2f9259e609d6027a651c790ccf76f62ab5cd34"}], "stats": {"total": 57, "additions": 33, "deletions": 24}, "files": [{"sha": "bd7a42cca1fe29dbaf3e8e235a874c867d3dac64", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1591977432caa3c7505e8318688c313a5d8c5949/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591977432caa3c7505e8318688c313a5d8c5949/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=1591977432caa3c7505e8318688c313a5d8c5949", "patch": "@@ -508,8 +508,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             stmt: 0,\n         });\n \n-        let cur_frame = self.cur_frame();\n-        self.memory.set_cur_frame(cur_frame);\n+        self.memory.cur_frame = self.cur_frame();\n \n         if self.stack.len() > self.stack_limit {\n             err!(StackFrameLimitReached)\n@@ -520,14 +519,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation -= 1;\n-        self.memory.locks_lifetime_ended(None);\n+        self.end_region(None)?;\n         let frame = self.stack.pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n         );\n         if !self.stack.is_empty() {\n-            // TODO: IS this the correct time to start considering these accesses as originating from the returned-to stack frame?\n-            let cur_frame = self.cur_frame();\n-            self.memory.set_cur_frame(cur_frame);\n+            // TODO: Is this the correct time to start considering these accesses as originating from the returned-to stack frame?\n+            self.memory.cur_frame = self.cur_frame();\n         }\n         match frame.return_to_block {\n             StackPopCleanup::MarkStatic(mutable) => {"}, {"sha": "71bb4b4ecd14e8d6a3f08a08ad6d99a37636fc7a", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1591977432caa3c7505e8318688c313a5d8c5949/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591977432caa3c7505e8318688c313a5d8c5949/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=1591977432caa3c7505e8318688c313a5d8c5949", "patch": "@@ -268,7 +268,7 @@ pub struct Memory<'a, 'tcx, M: Machine<'tcx>> {\n     writes_are_aligned: Cell<bool>,\n \n     /// The current stack frame.  Used to check accesses against locks.\n-    cur_frame: usize,\n+    pub cur_frame: usize,\n }\n \n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n@@ -530,10 +530,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n         Ok(())\n     }\n-\n-    pub(crate) fn set_cur_frame(&mut self, cur_frame: usize) {\n-        self.cur_frame = cur_frame;\n-    }\n }\n \n /// Locking"}, {"sha": "3dc74368fe830ef9bf051819ddadfd3623a67b99", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1591977432caa3c7505e8318688c313a5d8c5949/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591977432caa3c7505e8318688c313a5d8c5949/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=1591977432caa3c7505e8318688c313a5d8c5949", "patch": "@@ -164,7 +164,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 }\n             }\n             EndRegion(ce) => {\n-                self.end_region(ce)?;\n+                self.end_region(Some(ce))?;\n             }\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the"}, {"sha": "878ec3e191112c5b47bd8a62e6c5e3288beebae2", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1591977432caa3c7505e8318688c313a5d8c5949/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591977432caa3c7505e8318688c313a5d8c5949/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=1591977432caa3c7505e8318688c313a5d8c5949", "patch": "@@ -45,6 +45,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         if self.tcx.sess.opts.debugging_opts.mir_emit_validate == 0 {\n             return Ok(());\n         }\n+        debug_assert!(self.memory.cur_frame == self.cur_frame());\n \n         // HACK: Determine if this method is whitelisted and hence we do not perform any validation.\n         // We currently insta-UB on anything passing around uninitialized memory, so we have to whitelist\n@@ -93,7 +94,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 if query.mutbl == MutMutable {\n                     let lft = DynamicLifetime {\n                         frame: self.cur_frame(),\n-                        region: Some(scope),\n+                        region: Some(scope), // Notably, we only ever suspend things for given regions.\n+                        // Suspending for the entire function does not make any sense.\n                     };\n                     trace!(\"Suspending {:?} until {:?}\", query, scope);\n                     self.suspended.entry(lft).or_insert_with(Vec::new).push(\n@@ -106,17 +108,30 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.validate(query, mode)\n     }\n \n-    pub(crate) fn end_region(&mut self, scope: region::Scope) -> EvalResult<'tcx> {\n-        self.memory.locks_lifetime_ended(Some(scope));\n-        // Recover suspended lvals\n-        let lft = DynamicLifetime {\n-            frame: self.cur_frame(),\n-            region: Some(scope),\n-        };\n-        if let Some(queries) = self.suspended.remove(&lft) {\n-            for query in queries {\n-                trace!(\"Recovering {:?} from suspension\", query);\n-                self.validate(query, ValidationMode::Recover(scope))?;\n+    /// Release locks and executes suspensions of the given region (or the entire fn, in case of None).\n+    pub(crate) fn end_region(&mut self, scope: Option<region::Scope>) -> EvalResult<'tcx> {\n+        debug_assert!(self.memory.cur_frame == self.cur_frame());\n+        self.memory.locks_lifetime_ended(scope);\n+        match scope {\n+            Some(scope) => {\n+                // Recover suspended lvals\n+                let lft = DynamicLifetime {\n+                    frame: self.cur_frame(),\n+                    region: Some(scope),\n+                };\n+                if let Some(queries) = self.suspended.remove(&lft) {\n+                    for query in queries {\n+                        trace!(\"Recovering {:?} from suspension\", query);\n+                        self.validate(query, ValidationMode::Recover(scope))?;\n+                    }\n+                }\n+            }\n+            None => {\n+                // Clean suspension table of current frame\n+                let cur_frame = self.cur_frame();\n+                self.suspended.retain(|lft, _| {\n+                    lft.frame != cur_frame // keep only what is in the other (lower) frames\n+                });\n             }\n         }\n         Ok(())"}]}