{"sha": "ae861f0288c4773a004967123ad5eb4000989dde", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlODYxZjAyODhjNDc3M2EwMDQ5NjcxMjNhZDVlYjQwMDA5ODlkZGU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-10T21:28:43Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-10T21:29:16Z"}, "message": "Copyedit sections 5 and 6 of the borrowed pointer tutorial", "tree": {"sha": "48a2dcc027bc54f79e308ce22d5228390911de3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48a2dcc027bc54f79e308ce22d5228390911de3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae861f0288c4773a004967123ad5eb4000989dde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae861f0288c4773a004967123ad5eb4000989dde", "html_url": "https://github.com/rust-lang/rust/commit/ae861f0288c4773a004967123ad5eb4000989dde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae861f0288c4773a004967123ad5eb4000989dde/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbd16a0aba779cd10d342ef8f86f97e3767601af", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbd16a0aba779cd10d342ef8f86f97e3767601af", "html_url": "https://github.com/rust-lang/rust/commit/bbd16a0aba779cd10d342ef8f86f97e3767601af"}], "stats": {"total": 148, "additions": 77, "deletions": 71}, "files": [{"sha": "50d6f9f4c6509d56442537df7e51a17969f8efda", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 77, "deletions": 71, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/ae861f0288c4773a004967123ad5eb4000989dde/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae861f0288c4773a004967123ad5eb4000989dde/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=ae861f0288c4773a004967123ad5eb4000989dde", "patch": "@@ -178,25 +178,27 @@ as well as from the managed box, and then compute the distance between them.\n \n # Borrowing managed boxes and rooting\n \n-We\u2019ve seen a few examples so far where heap boxes (both managed and\n-unique) are borrowed. Up till this point, we\u2019ve glossed over issues of\n+We\u2019ve seen a few examples so far of borrowing heap boxes, both managed\n+and unique. Up till this point, we\u2019ve glossed over issues of\n safety. As stated in the introduction, at runtime a borrowed pointer\n-is simply a pointer, nothing more. Therefore, if we wish to avoid the\n-issues that C has with dangling pointers (and we do!), a compile-time\n-safety check is required.\n-\n-The basis for the check is the notion of _lifetimes_. A lifetime is\n-basically a static approximation of the period in which the pointer is\n-valid: it always corresponds to some expression or block within the\n-program. Within that expression, the pointer can be used freely, but\n-if the pointer somehow leaks outside of that expression, the compiler\n-will report an error. We\u2019ll be discussing lifetimes more in the\n-examples to come, and a more thorough introduction is also available.\n-\n-When a borrowed pointer is created, the compiler must ensure that it\n-will remain valid for its entire lifetime. Sometimes this is\n-relatively easy, such as when taking the address of a local variable\n-or a field that is stored on the stack:\n+is simply a pointer, nothing more. Therefore, avoiding C's problems\n+with dangling pointers requires a compile-time safety check.\n+\n+The basis for the check is the notion of _lifetimes_. A lifetime is a\n+static approximation of the span of execution during which the pointer\n+is valid: it always corresponds to some expression or block within the\n+program. Code inside that expression can use the pointer without\n+restrictions. But if the pointer escapes from that expression (for\n+example, if the expression contains an assignment expression that\n+assigns the pointer to a mutable field of a data structure with a\n+broader scope than the pointer itself), the compiler reports an\n+error. We'll be discussing lifetimes more in the examples to come, and\n+a more thorough introduction is also available.\n+\n+When the `&` operator creates a borrowed pointer, the compiler must\n+ensure that the pointer remains valid for its entire\n+lifetime. Sometimes this is relatively easy, such as when taking the\n+address of a local variable or a field that is stored on the stack:\n \n ~~~\n struct X { f: int }\n@@ -207,12 +209,12 @@ fn example1() {\n }                      // -+\n ~~~\n \n-Here, the lifetime of the borrowed pointer is simply L, the remainder\n-of the function body. No extra work is required to ensure that `x.f`\n-will not be freed. This is true even if `x` is mutated.\n+Here, the lifetime of the borrowed pointer `y` is simply L, the\n+remainder of the function body. The compiler need not do any other\n+work to prove that code will not free `x.f`. This is true even if the\n+code mutates `x`.\n \n-The situation gets more complex when borrowing data that resides in\n-heap boxes:\n+The situation gets more complex when borrowing data inside heap boxes:\n \n ~~~\n # struct X { f: int }\n@@ -223,20 +225,25 @@ fn example2() {\n }                      // -+\n ~~~\n \n-In this example, the value `x` is in fact a heap box, and `y` is\n-therefore a pointer into that heap box. Again the lifetime of `y` will\n-be L, the remainder of the function body. But there is a crucial\n-difference: suppose `x` were reassigned during the lifetime L? If\n-we\u2019re not careful, that could mean that the managed box would become\n-unrooted and therefore be subject to garbage collection\n+In this example, the value `x` is a heap box, and `y` is therefore a\n+pointer into that heap box. Again the lifetime of `y` is L, the\n+remainder of the function body. But there is a crucial difference:\n+suppose `x` were to be reassigned during the lifetime L? If the\n+compiler isn't careful, the managed box could become *unrooted*, and\n+would therefore be subject to garbage collection. A heap box that is\n+unrooted is one such that no pointer values in the heap point to\n+it. It would violate memory safety for the box that was originally\n+assigned to `x` to be garbage-collected, since a non-heap\n+pointer---`y`---still points into it.\n \n-> ***Note:***In our current implementation, the garbage collector is\n-> implemented using reference counting and cycle detection.\n+> ***Note:*** Our current implementation implements the garbage collector\n+> using reference counting and cycle detection.\n \n-For this reason, whenever the interior of a managed box stored in a\n-mutable location is borrowed, the compiler will insert a temporary\n-that ensures that the managed box remains live for the entire\n-lifetime. So, the above example would be compiled as:\n+For this reason, whenever an `&` expression borrows the interior of a\n+managed box stored in a mutable location, the compiler inserts a\n+temporary that ensures that the managed box remains live for the\n+entire lifetime. So, the above example would be compiled as if it were\n+written\n \n ~~~\n # struct X { f: int }\n@@ -255,9 +262,9 @@ process is called *rooting*.\n \n The previous example demonstrated *rooting*, the process by which the\n compiler ensures that managed boxes remain live for the duration of a\n-borrow. Unfortunately, rooting does not work if the data being\n-borrowed is a unique box, as it is not possible to have two references\n-to a unique box.\n+borrow. Unfortunately, rooting does not work for borrows of unique\n+boxes, because it is not possible to have two references to a unique\n+box.\n \n For unique boxes, therefore, the compiler will only allow a borrow *if\n the compiler can guarantee that the unique box will not be reassigned\n@@ -280,14 +287,14 @@ fn example3() -> int {\n ~~~\n \n Here, as before, the interior of the variable `x` is being borrowed\n-and `x` is declared as mutable. However, the compiler can clearly see\n-that `x` is not assigned anywhere in the lifetime L of the variable\n+and `x` is declared as mutable. However, the compiler can prove that\n+`x` is not assigned anywhere in the lifetime L of the variable\n `y`. Therefore, it accepts the function, even though `x` is mutable\n and in fact is mutated later in the function.\n \n-It may not be clear why we are so concerned about the variable which\n-was borrowed being mutated. The reason is that unique boxes are freed\n-_as soon as their owning reference is changed or goes out of\n+It may not be clear why we are so concerned about mutating a borrowed\n+variable. The reason is that the runtime system frees any unique box\n+_as soon as its owning reference changes or goes out of\n scope_. Therefore, a program like this is illegal (and would be\n rejected by the compiler):\n \n@@ -332,11 +339,11 @@ Once the reassignment occurs, the memory will look like this:\n Here you can see that the variable `y` still points at the old box,\n which has been freed.\n \n-In fact, the compiler can apply this same kind of reasoning can be\n-applied to any memory which is _(uniquely) owned by the stack\n-frame_. So we could modify the previous example to introduce\n-additional unique pointers and structs, and the compiler will still be\n-able to detect possible mutations:\n+In fact, the compiler can apply the same kind of reasoning to any\n+memory that is _(uniquely) owned by the stack frame_. So we could\n+modify the previous example to introduce additional unique pointers\n+and structs, and the compiler will still be able to detect possible\n+mutations:\n \n ~~~ {.xfail-test}\n fn example3() -> int {\n@@ -353,11 +360,11 @@ fn example3() -> int {\n \n In this case, two errors are reported, one when the variable `x` is\n modified and another when `x.f` is modified. Either modification would\n-cause the pointer `y` to be invalidated.\n+invalidate the pointer `y`.\n \n-Things get tricker when the unique box is not uniquely owned by the\n-stack frame (or when the compiler doesn\u2019t know who the owner\n-is). Consider a program like this:\n+Things get trickier when the unique box is not uniquely owned by the\n+stack frame, or when there is no way for the compiler to determine the\n+box's owner. Consider a program like this:\n \n ~~~\n struct R { g: int }\n@@ -381,18 +388,18 @@ Here the heap looks something like:\n     +------+\n ~~~\n \n-In this case, the owning reference to the value being borrowed is in\n-fact `x.f`. Moreover, `x.f` is both mutable and aliasable. Aliasable\n-means that it is possible that there are other pointers to that same\n-managed box, so even if the compiler were to prevent `x.f` from being\n-mutated, the field might still be changed through some alias of\n-`x`. Therefore, to be safe, the compiler only accepts pure actions\n-during the lifetime of `y`. We\u2019ll have a final example on purity but\n-inn unique fields, as in the following example:\n+In this case, the owning reference to the value being borrowed is\n+`x.f`. Moreover, `x.f` is both mutable and *aliasable*. Aliasable\n+means that there may be other pointers to that same managed box, so\n+even if the compiler were to prove an absence of mutations to `x.f`,\n+code could mutate `x.f` indirectly by changing an alias of\n+`x`. Therefore, to be safe, the compiler only accepts *pure* actions\n+during the lifetime of `y`. We define what \"pure\" means in the section\n+on [purity](#purity).\n \n Besides ensuring purity, the only way to borrow the interior of a\n-unique found in aliasable memory is to ensure that it is stored within\n-unique fields, as in the following example:\n+unique found in aliasable memory is to ensure that the borrowed field\n+itself is also unique, as in the following example:\n \n ~~~\n struct R { g: int }\n@@ -409,7 +416,7 @@ the compiler to know that, even if aliases to `x` exist, the field `f`\n cannot be changed and hence the unique box `g` will remain valid.\n \n If you do have a unique box in a mutable field, and you wish to borrow\n-it, one option is to use the swap operator to bring that unique box\n+it, one option is to use the swap operator to move that unique box\n onto your stack:\n \n ~~~\n@@ -430,14 +437,13 @@ fn example5c(x: @S) -> int {\n \n Of course, this has the side effect of modifying your managed box for\n the duration of the borrow, so it only works when you know that you\n-won\u2019t be accessing that same box for the duration of the loan.  Note\n-also that sometimes it is necessary to introduce additional blocks to\n-constrain the scope of the loan.  In this example, the borrowed\n-pointer `y` would still be in scope when you moved the value `v` back\n-into `x.f`, and hence moving `v` would be considered illegal.  You\n-cannot move values if they are outstanding loans which are still\n-valid.  By introducing the block, the scope of `y` is restricted and so\n-the move is legal.\n+won't be accessing that same box for the duration of the loan. Also,\n+it is sometimes necessary to introduce additional blocks to constrain\n+the scope of the loan.  In this example, the borrowed pointer `y`\n+would still be in scope when you moved the value `v` back into `x.f`,\n+and hence moving `v` would be considered illegal.  You cannot move\n+values if they are the targets of valid outstanding loans. Introducing\n+the block restricts the scope of `y`, making the move legal.\n \n # Borrowing and enums\n "}]}