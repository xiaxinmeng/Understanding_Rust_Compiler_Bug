{"sha": "420ada6f8a29e0dcb8d97a22df1a361336faa521", "node_id": "C_kwDOAAsO6NoAKDQyMGFkYTZmOGEyOWUwZGNiOGQ5N2EyMmRmMWEzNjEzMzZmYWE1MjE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-19T09:42:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-19T09:42:18Z"}, "message": "Rollup merge of #92920 - dtolnay:printtidy, r=cjgillot\n\nMove expr- and item-related pretty printing functions to modules\n\nCurrently *compiler/rustc_ast_pretty/src/pprust/state.rs* is 2976 lines on master. The `tidy` limit is 3000, which is blocking #92243.\n\nThis PR adds a `mod expr;` and `mod item;` to move logic related to those AST nodes out of the single huge file.", "tree": {"sha": "a8bdea223eea1dbe77e239cdaa6f27a30175cfd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8bdea223eea1dbe77e239cdaa6f27a30175cfd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/420ada6f8a29e0dcb8d97a22df1a361336faa521", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh59z6CRBK7hj4Ov3rIwAAcv4IAGUsVtnHVlYXf7jcRdK64olU\nwUqUKuNxM2wSDiPqJ7WcE0vtiyFKuFpaKdYCv9Bb/nDylW2T6SqoB+it+P6aX2OX\n1lD+DDfxLVMDUtDyGXVbyOGI98xydC/bKuwk4z8gNhgkDbqJNEs6+dHLu045MJ17\nCQ61dJMiMiVYzZXhYsykOCEzSbSiY0+KHSWsoqV7mGV5X08tpUUE0c1/kJlYbF+H\nvK/xn+vEhA24rjytyEFvdUmqTwZkJPaeM/rYsCjGY74NsTbMPZ3XaVSb+FFdy+8U\nWBxlLukfregpqqtIH8cL/qKMzAmVGk6upidQTdXLXl2DOnbpxrQ8jGamNGQkhZs=\n=8je1\n-----END PGP SIGNATURE-----\n", "payload": "tree a8bdea223eea1dbe77e239cdaa6f27a30175cfd8\nparent 7f2dbcba38c4bcd7f8397b056f2d8ea76447629e\nparent 07a0325137b3e7e1c036d5301e03cf590ea1ce1e\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642585338 +0100\ncommitter GitHub <noreply@github.com> 1642585338 +0100\n\nRollup merge of #92920 - dtolnay:printtidy, r=cjgillot\n\nMove expr- and item-related pretty printing functions to modules\n\nCurrently *compiler/rustc_ast_pretty/src/pprust/state.rs* is 2976 lines on master. The `tidy` limit is 3000, which is blocking #92243.\n\nThis PR adds a `mod expr;` and `mod item;` to move logic related to those AST nodes out of the single huge file.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/420ada6f8a29e0dcb8d97a22df1a361336faa521", "html_url": "https://github.com/rust-lang/rust/commit/420ada6f8a29e0dcb8d97a22df1a361336faa521", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/420ada6f8a29e0dcb8d97a22df1a361336faa521/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f2dbcba38c4bcd7f8397b056f2d8ea76447629e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f2dbcba38c4bcd7f8397b056f2d8ea76447629e", "html_url": "https://github.com/rust-lang/rust/commit/7f2dbcba38c4bcd7f8397b056f2d8ea76447629e"}, {"sha": "07a0325137b3e7e1c036d5301e03cf590ea1ce1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/07a0325137b3e7e1c036d5301e03cf590ea1ce1e", "html_url": "https://github.com/rust-lang/rust/commit/07a0325137b3e7e1c036d5301e03cf590ea1ce1e"}], "stats": {"total": 2420, "additions": 1220, "deletions": 1200}, "files": [{"sha": "487451466f1f0af80fbb27ac16cd710029ac3e2e", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 5, "deletions": 1200, "changes": 1205, "blob_url": "https://github.com/rust-lang/rust/blob/420ada6f8a29e0dcb8d97a22df1a361336faa521/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/420ada6f8a29e0dcb8d97a22df1a361336faa521/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=420ada6f8a29e0dcb8d97a22df1a361336faa521", "patch": "@@ -1,3 +1,6 @@\n+mod expr;\n+mod item;\n+\n use crate::pp::Breaks::{Consistent, Inconsistent};\n use crate::pp::{self, Breaks};\n \n@@ -6,10 +9,10 @@ use rustc_ast::token::{self, BinOpToken, CommentKind, DelimToken, Nonterminal, T\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n-use rustc_ast::util::parser::{self, AssocOp, Fixity};\n+use rustc_ast::util::parser;\n use rustc_ast::{self as ast, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use rustc_ast::{attr, Term};\n-use rustc_ast::{GenericArg, MacArgs, ModKind};\n+use rustc_ast::{GenericArg, MacArgs};\n use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n@@ -210,10 +213,6 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n     out\n }\n \n-fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n-    format!(\"{}{}\", State::to_string(|s| s.print_visibility(vis)), s)\n-}\n-\n impl std::ops::Deref for State<'_> {\n     type Target = pp::Printer;\n     fn deref(&self) -> &Self::Target {\n@@ -938,13 +937,6 @@ impl<'a> State<'a> {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(e), |e| e.span)\n     }\n \n-    crate fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[ast::Attribute]) {\n-        self.print_inner_attributes(attrs);\n-        for item in &nmod.items {\n-            self.print_foreign_item(item);\n-        }\n-    }\n-\n     pub fn print_opt_lifetime(&mut self, lifetime: &Option<ast::Lifetime>) {\n         if let Some(lt) = *lifetime {\n             self.print_lifetime(lt);\n@@ -1057,343 +1049,6 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    crate fn print_foreign_item(&mut self, item: &ast::ForeignItem) {\n-        let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n-        self.ann.pre(self, AnnNode::SubItem(id));\n-        self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(span.lo());\n-        self.print_outer_attributes(attrs);\n-        match kind {\n-            ast::ForeignItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n-                self.print_fn_full(sig, ident, generics, vis, *defaultness, body.as_deref(), attrs);\n-            }\n-            ast::ForeignItemKind::Static(ty, mutbl, body) => {\n-                let def = ast::Defaultness::Final;\n-                self.print_item_const(ident, Some(*mutbl), ty, body.as_deref(), vis, def);\n-            }\n-            ast::ForeignItemKind::TyAlias(box ast::TyAlias {\n-                defaultness,\n-                generics,\n-                bounds,\n-                ty,\n-            }) => {\n-                self.print_associated_type(\n-                    ident,\n-                    generics,\n-                    bounds,\n-                    ty.as_deref(),\n-                    vis,\n-                    *defaultness,\n-                );\n-            }\n-            ast::ForeignItemKind::MacCall(m) => {\n-                self.print_mac(m);\n-                if m.args.need_semicolon() {\n-                    self.word(\";\");\n-                }\n-            }\n-        }\n-        self.ann.post(self, AnnNode::SubItem(id))\n-    }\n-\n-    fn print_item_const(\n-        &mut self,\n-        ident: Ident,\n-        mutbl: Option<ast::Mutability>,\n-        ty: &ast::Ty,\n-        body: Option<&ast::Expr>,\n-        vis: &ast::Visibility,\n-        defaultness: ast::Defaultness,\n-    ) {\n-        self.head(\"\");\n-        self.print_visibility(vis);\n-        self.print_defaultness(defaultness);\n-        let leading = match mutbl {\n-            None => \"const\",\n-            Some(ast::Mutability::Not) => \"static\",\n-            Some(ast::Mutability::Mut) => \"static mut\",\n-        };\n-        self.word_space(leading);\n-        self.print_ident(ident);\n-        self.word_space(\":\");\n-        self.print_type(ty);\n-        if body.is_some() {\n-            self.space();\n-        }\n-        self.end(); // end the head-ibox\n-        if let Some(body) = body {\n-            self.word_space(\"=\");\n-            self.print_expr(body);\n-        }\n-        self.word(\";\");\n-        self.end(); // end the outer cbox\n-    }\n-\n-    fn print_associated_type(\n-        &mut self,\n-        ident: Ident,\n-        generics: &ast::Generics,\n-        bounds: &ast::GenericBounds,\n-        ty: Option<&ast::Ty>,\n-        vis: &ast::Visibility,\n-        defaultness: ast::Defaultness,\n-    ) {\n-        self.head(\"\");\n-        self.print_visibility(vis);\n-        self.print_defaultness(defaultness);\n-        self.word_space(\"type\");\n-        self.print_ident(ident);\n-        self.print_generic_params(&generics.params);\n-        self.print_type_bounds(\":\", bounds);\n-        self.print_where_clause(&generics.where_clause);\n-        if let Some(ty) = ty {\n-            self.space();\n-            self.word_space(\"=\");\n-            self.print_type(ty);\n-        }\n-        self.word(\";\");\n-        self.end(); // end inner head-block\n-        self.end(); // end outer head-block\n-    }\n-\n-    /// Pretty-prints an item.\n-    crate fn print_item(&mut self, item: &ast::Item) {\n-        self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(item.span.lo());\n-        self.print_outer_attributes(&item.attrs);\n-        self.ann.pre(self, AnnNode::Item(item));\n-        match item.kind {\n-            ast::ItemKind::ExternCrate(orig_name) => {\n-                self.head(visibility_qualified(&item.vis, \"extern crate\"));\n-                if let Some(orig_name) = orig_name {\n-                    self.print_name(orig_name);\n-                    self.space();\n-                    self.word(\"as\");\n-                    self.space();\n-                }\n-                self.print_ident(item.ident);\n-                self.word(\";\");\n-                self.end(); // end inner head-block\n-                self.end(); // end outer head-block\n-            }\n-            ast::ItemKind::Use(ref tree) => {\n-                self.head(visibility_qualified(&item.vis, \"use\"));\n-                self.print_use_tree(tree);\n-                self.word(\";\");\n-                self.end(); // end inner head-block\n-                self.end(); // end outer head-block\n-            }\n-            ast::ItemKind::Static(ref ty, mutbl, ref body) => {\n-                let def = ast::Defaultness::Final;\n-                self.print_item_const(item.ident, Some(mutbl), ty, body.as_deref(), &item.vis, def);\n-            }\n-            ast::ItemKind::Const(def, ref ty, ref body) => {\n-                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis, def);\n-            }\n-            ast::ItemKind::Fn(box ast::Fn { defaultness, ref sig, ref generics, ref body }) => {\n-                let body = body.as_deref();\n-                self.print_fn_full(\n-                    sig,\n-                    item.ident,\n-                    generics,\n-                    &item.vis,\n-                    defaultness,\n-                    body,\n-                    &item.attrs,\n-                );\n-            }\n-            ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n-                self.head(Self::to_string(|s| {\n-                    s.print_visibility(&item.vis);\n-                    s.print_unsafety(unsafety);\n-                    s.word(\"mod\");\n-                }));\n-                self.print_ident(item.ident);\n-\n-                match mod_kind {\n-                    ModKind::Loaded(items, ..) => {\n-                        self.nbsp();\n-                        self.bopen();\n-                        self.print_inner_attributes(&item.attrs);\n-                        for item in items {\n-                            self.print_item(item);\n-                        }\n-                        let empty = item.attrs.is_empty() && items.is_empty();\n-                        self.bclose(item.span, empty);\n-                    }\n-                    ModKind::Unloaded => {\n-                        self.word(\";\");\n-                        self.end(); // end inner head-block\n-                        self.end(); // end outer head-block\n-                    }\n-                }\n-            }\n-            ast::ItemKind::ForeignMod(ref nmod) => {\n-                self.head(Self::to_string(|s| {\n-                    s.print_unsafety(nmod.unsafety);\n-                    s.word(\"extern\");\n-                }));\n-                if let Some(abi) = nmod.abi {\n-                    self.print_literal(&abi.as_lit());\n-                    self.nbsp();\n-                }\n-                self.bopen();\n-                self.print_foreign_mod(nmod, &item.attrs);\n-                let empty = item.attrs.is_empty() && nmod.items.is_empty();\n-                self.bclose(item.span, empty);\n-            }\n-            ast::ItemKind::GlobalAsm(ref asm) => {\n-                self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n-                self.print_inline_asm(asm);\n-                self.end();\n-            }\n-            ast::ItemKind::TyAlias(box ast::TyAlias {\n-                defaultness,\n-                ref generics,\n-                ref bounds,\n-                ref ty,\n-            }) => {\n-                let ty = ty.as_deref();\n-                self.print_associated_type(\n-                    item.ident,\n-                    generics,\n-                    bounds,\n-                    ty,\n-                    &item.vis,\n-                    defaultness,\n-                );\n-            }\n-            ast::ItemKind::Enum(ref enum_definition, ref params) => {\n-                self.print_enum_def(enum_definition, params, item.ident, item.span, &item.vis);\n-            }\n-            ast::ItemKind::Struct(ref struct_def, ref generics) => {\n-                self.head(visibility_qualified(&item.vis, \"struct\"));\n-                self.print_struct(struct_def, generics, item.ident, item.span, true);\n-            }\n-            ast::ItemKind::Union(ref struct_def, ref generics) => {\n-                self.head(visibility_qualified(&item.vis, \"union\"));\n-                self.print_struct(struct_def, generics, item.ident, item.span, true);\n-            }\n-            ast::ItemKind::Impl(box ast::Impl {\n-                unsafety,\n-                polarity,\n-                defaultness,\n-                constness,\n-                ref generics,\n-                ref of_trait,\n-                ref self_ty,\n-                ref items,\n-            }) => {\n-                self.head(\"\");\n-                self.print_visibility(&item.vis);\n-                self.print_defaultness(defaultness);\n-                self.print_unsafety(unsafety);\n-                self.word(\"impl\");\n-\n-                if generics.params.is_empty() {\n-                    self.nbsp();\n-                } else {\n-                    self.print_generic_params(&generics.params);\n-                    self.space();\n-                }\n-\n-                self.print_constness(constness);\n-\n-                if let ast::ImplPolarity::Negative(_) = polarity {\n-                    self.word(\"!\");\n-                }\n-\n-                if let Some(ref t) = *of_trait {\n-                    self.print_trait_ref(t);\n-                    self.space();\n-                    self.word_space(\"for\");\n-                }\n-\n-                self.print_type(self_ty);\n-                self.print_where_clause(&generics.where_clause);\n-\n-                self.space();\n-                self.bopen();\n-                self.print_inner_attributes(&item.attrs);\n-                for impl_item in items {\n-                    self.print_assoc_item(impl_item);\n-                }\n-                let empty = item.attrs.is_empty() && items.is_empty();\n-                self.bclose(item.span, empty);\n-            }\n-            ast::ItemKind::Trait(box ast::Trait {\n-                is_auto,\n-                unsafety,\n-                ref generics,\n-                ref bounds,\n-                ref items,\n-                ..\n-            }) => {\n-                self.head(\"\");\n-                self.print_visibility(&item.vis);\n-                self.print_unsafety(unsafety);\n-                self.print_is_auto(is_auto);\n-                self.word_nbsp(\"trait\");\n-                self.print_ident(item.ident);\n-                self.print_generic_params(&generics.params);\n-                let mut real_bounds = Vec::with_capacity(bounds.len());\n-                for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n-                        self.space();\n-                        self.word_space(\"for ?\");\n-                        self.print_trait_ref(&ptr.trait_ref);\n-                    } else {\n-                        real_bounds.push(b.clone());\n-                    }\n-                }\n-                self.print_type_bounds(\":\", &real_bounds);\n-                self.print_where_clause(&generics.where_clause);\n-                self.word(\" \");\n-                self.bopen();\n-                self.print_inner_attributes(&item.attrs);\n-                for trait_item in items {\n-                    self.print_assoc_item(trait_item);\n-                }\n-                let empty = item.attrs.is_empty() && items.is_empty();\n-                self.bclose(item.span, empty);\n-            }\n-            ast::ItemKind::TraitAlias(ref generics, ref bounds) => {\n-                self.head(visibility_qualified(&item.vis, \"trait\"));\n-                self.print_ident(item.ident);\n-                self.print_generic_params(&generics.params);\n-                let mut real_bounds = Vec::with_capacity(bounds.len());\n-                // FIXME(durka) this seems to be some quite outdated syntax\n-                for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n-                        self.space();\n-                        self.word_space(\"for ?\");\n-                        self.print_trait_ref(&ptr.trait_ref);\n-                    } else {\n-                        real_bounds.push(b.clone());\n-                    }\n-                }\n-                self.nbsp();\n-                self.print_type_bounds(\"=\", &real_bounds);\n-                self.print_where_clause(&generics.where_clause);\n-                self.word(\";\");\n-                self.end(); // end inner head-block\n-                self.end(); // end outer head-block\n-            }\n-            ast::ItemKind::MacCall(ref mac) => {\n-                self.print_mac(mac);\n-                if mac.args.need_semicolon() {\n-                    self.word(\";\");\n-                }\n-            }\n-            ast::ItemKind::MacroDef(ref macro_def) => {\n-                self.print_mac_def(macro_def, &item.ident, &item.span, |state| {\n-                    state.print_visibility(&item.vis)\n-                });\n-            }\n-        }\n-        self.ann.post(self, AnnNode::Item(item))\n-    }\n-\n     fn print_trait_ref(&mut self, t: &ast::TraitRef) {\n         self.print_path(&t.path, false, 0)\n     }\n@@ -1411,167 +1066,6 @@ impl<'a> State<'a> {\n         self.print_trait_ref(&t.trait_ref)\n     }\n \n-    crate fn print_enum_def(\n-        &mut self,\n-        enum_definition: &ast::EnumDef,\n-        generics: &ast::Generics,\n-        ident: Ident,\n-        span: rustc_span::Span,\n-        visibility: &ast::Visibility,\n-    ) {\n-        self.head(visibility_qualified(visibility, \"enum\"));\n-        self.print_ident(ident);\n-        self.print_generic_params(&generics.params);\n-        self.print_where_clause(&generics.where_clause);\n-        self.space();\n-        self.print_variants(&enum_definition.variants, span)\n-    }\n-\n-    crate fn print_variants(&mut self, variants: &[ast::Variant], span: rustc_span::Span) {\n-        self.bopen();\n-        for v in variants {\n-            self.space_if_not_bol();\n-            self.maybe_print_comment(v.span.lo());\n-            self.print_outer_attributes(&v.attrs);\n-            self.ibox(INDENT_UNIT);\n-            self.print_variant(v);\n-            self.word(\",\");\n-            self.end();\n-            self.maybe_print_trailing_comment(v.span, None);\n-        }\n-        let empty = variants.is_empty();\n-        self.bclose(span, empty)\n-    }\n-\n-    crate fn print_visibility(&mut self, vis: &ast::Visibility) {\n-        match vis.kind {\n-            ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n-            ast::VisibilityKind::Crate(sugar) => match sugar {\n-                ast::CrateSugar::PubCrate => self.word_nbsp(\"pub(crate)\"),\n-                ast::CrateSugar::JustCrate => self.word_nbsp(\"crate\"),\n-            },\n-            ast::VisibilityKind::Restricted { ref path, .. } => {\n-                let path = Self::to_string(|s| s.print_path(path, false, 0));\n-                if path == \"self\" || path == \"super\" {\n-                    self.word_nbsp(format!(\"pub({})\", path))\n-                } else {\n-                    self.word_nbsp(format!(\"pub(in {})\", path))\n-                }\n-            }\n-            ast::VisibilityKind::Inherited => {}\n-        }\n-    }\n-\n-    crate fn print_defaultness(&mut self, defaultness: ast::Defaultness) {\n-        if let ast::Defaultness::Default(_) = defaultness {\n-            self.word_nbsp(\"default\");\n-        }\n-    }\n-\n-    crate fn print_record_struct_body(&mut self, fields: &[ast::FieldDef], span: rustc_span::Span) {\n-        self.nbsp();\n-        self.bopen();\n-\n-        let empty = fields.is_empty();\n-        if !empty {\n-            self.hardbreak_if_not_bol();\n-\n-            for field in fields {\n-                self.hardbreak_if_not_bol();\n-                self.maybe_print_comment(field.span.lo());\n-                self.print_outer_attributes(&field.attrs);\n-                self.print_visibility(&field.vis);\n-                self.print_ident(field.ident.unwrap());\n-                self.word_nbsp(\":\");\n-                self.print_type(&field.ty);\n-                self.word(\",\");\n-            }\n-        }\n-\n-        self.bclose(span, empty);\n-    }\n-\n-    crate fn print_struct(\n-        &mut self,\n-        struct_def: &ast::VariantData,\n-        generics: &ast::Generics,\n-        ident: Ident,\n-        span: rustc_span::Span,\n-        print_finalizer: bool,\n-    ) {\n-        self.print_ident(ident);\n-        self.print_generic_params(&generics.params);\n-        match struct_def {\n-            ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n-                if let ast::VariantData::Tuple(..) = struct_def {\n-                    self.popen();\n-                    self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n-                        s.maybe_print_comment(field.span.lo());\n-                        s.print_outer_attributes(&field.attrs);\n-                        s.print_visibility(&field.vis);\n-                        s.print_type(&field.ty)\n-                    });\n-                    self.pclose();\n-                }\n-                self.print_where_clause(&generics.where_clause);\n-                if print_finalizer {\n-                    self.word(\";\");\n-                }\n-                self.end();\n-                self.end(); // Close the outer-box.\n-            }\n-            ast::VariantData::Struct(ref fields, ..) => {\n-                self.print_where_clause(&generics.where_clause);\n-                self.print_record_struct_body(fields, span);\n-            }\n-        }\n-    }\n-\n-    crate fn print_variant(&mut self, v: &ast::Variant) {\n-        self.head(\"\");\n-        self.print_visibility(&v.vis);\n-        let generics = ast::Generics::default();\n-        self.print_struct(&v.data, &generics, v.ident, v.span, false);\n-        if let Some(ref d) = v.disr_expr {\n-            self.space();\n-            self.word_space(\"=\");\n-            self.print_expr(&d.value)\n-        }\n-    }\n-\n-    crate fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n-        let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n-        self.ann.pre(self, AnnNode::SubItem(id));\n-        self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(span.lo());\n-        self.print_outer_attributes(attrs);\n-        match kind {\n-            ast::AssocItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n-                self.print_fn_full(sig, ident, generics, vis, *defaultness, body.as_deref(), attrs);\n-            }\n-            ast::AssocItemKind::Const(def, ty, body) => {\n-                self.print_item_const(ident, None, ty, body.as_deref(), vis, *def);\n-            }\n-            ast::AssocItemKind::TyAlias(box ast::TyAlias { defaultness, generics, bounds, ty }) => {\n-                self.print_associated_type(\n-                    ident,\n-                    generics,\n-                    bounds,\n-                    ty.as_deref(),\n-                    vis,\n-                    *defaultness,\n-                );\n-            }\n-            ast::AssocItemKind::MacCall(m) => {\n-                self.print_mac(m);\n-                if m.args.need_semicolon() {\n-                    self.word(\";\");\n-                }\n-            }\n-        }\n-        self.ann.post(self, AnnNode::SubItem(id))\n-    }\n-\n     crate fn print_stmt(&mut self, st: &ast::Stmt) {\n         self.maybe_print_comment(st.span.lo());\n         match st.kind {\n@@ -1682,42 +1176,6 @@ impl<'a> State<'a> {\n         self.print_expr_cond_paren(expr, Self::cond_needs_par(expr) || npals())\n     }\n \n-    fn print_else(&mut self, els: Option<&ast::Expr>) {\n-        if let Some(_else) = els {\n-            match _else.kind {\n-                // Another `else if` block.\n-                ast::ExprKind::If(ref i, ref then, ref e) => {\n-                    self.cbox(INDENT_UNIT - 1);\n-                    self.ibox(0);\n-                    self.word(\" else if \");\n-                    self.print_expr_as_cond(i);\n-                    self.space();\n-                    self.print_block(then);\n-                    self.print_else(e.as_deref())\n-                }\n-                // Final `else` block.\n-                ast::ExprKind::Block(ref b, _) => {\n-                    self.cbox(INDENT_UNIT - 1);\n-                    self.ibox(0);\n-                    self.word(\" else \");\n-                    self.print_block(b)\n-                }\n-                // Constraints would be great here!\n-                _ => {\n-                    panic!(\"print_if saw if with weird alternative\");\n-                }\n-            }\n-        }\n-    }\n-\n-    crate fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block, elseopt: Option<&ast::Expr>) {\n-        self.head(\"if\");\n-        self.print_expr_as_cond(test);\n-        self.space();\n-        self.print_block(blk);\n-        self.print_else(elseopt)\n-    }\n-\n     crate fn print_mac(&mut self, m: &ast::MacCall) {\n         self.print_mac_common(\n             Some(MacHeader::Path(&m.path)),\n@@ -1730,477 +1188,6 @@ impl<'a> State<'a> {\n         );\n     }\n \n-    fn print_call_post(&mut self, args: &[P<ast::Expr>]) {\n-        self.popen();\n-        self.commasep_exprs(Inconsistent, args);\n-        self.pclose()\n-    }\n-\n-    crate fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) {\n-        self.print_expr_cond_paren(expr, expr.precedence().order() < prec)\n-    }\n-\n-    /// Prints an expr using syntax that's acceptable in a condition position, such as the `cond` in\n-    /// `if cond { ... }`.\n-    crate fn print_expr_as_cond(&mut self, expr: &ast::Expr) {\n-        self.print_expr_cond_paren(expr, Self::cond_needs_par(expr))\n-    }\n-\n-    // Does `expr` need parentheses when printed in a condition position?\n-    //\n-    // These cases need parens due to the parse error observed in #26461: `if return {}`\n-    // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n-    fn cond_needs_par(expr: &ast::Expr) -> bool {\n-        match expr.kind {\n-            ast::ExprKind::Break(..) | ast::ExprKind::Closure(..) | ast::ExprKind::Ret(..) => true,\n-            _ => parser::contains_exterior_struct_lit(expr),\n-        }\n-    }\n-\n-    /// Prints `expr` or `(expr)` when `needs_par` holds.\n-    fn print_expr_cond_paren(&mut self, expr: &ast::Expr, needs_par: bool) {\n-        if needs_par {\n-            self.popen();\n-        }\n-        self.print_expr(expr);\n-        if needs_par {\n-            self.pclose();\n-        }\n-    }\n-\n-    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) {\n-        self.ibox(INDENT_UNIT);\n-        self.word(\"[\");\n-        self.commasep_exprs(Inconsistent, exprs);\n-        self.word(\"]\");\n-        self.end();\n-    }\n-\n-    fn print_expr_anon_const(&mut self, expr: &ast::AnonConst) {\n-        self.ibox(INDENT_UNIT);\n-        self.word(\"const\");\n-        self.print_expr(&expr.value);\n-        self.end();\n-    }\n-\n-    fn print_expr_repeat(&mut self, element: &ast::Expr, count: &ast::AnonConst) {\n-        self.ibox(INDENT_UNIT);\n-        self.word(\"[\");\n-        self.print_expr(element);\n-        self.word_space(\";\");\n-        self.print_expr(&count.value);\n-        self.word(\"]\");\n-        self.end();\n-    }\n-\n-    fn print_expr_struct(\n-        &mut self,\n-        qself: &Option<ast::QSelf>,\n-        path: &ast::Path,\n-        fields: &[ast::ExprField],\n-        rest: &ast::StructRest,\n-    ) {\n-        if let Some(qself) = qself {\n-            self.print_qpath(path, qself, true);\n-        } else {\n-            self.print_path(path, true, 0);\n-        }\n-        self.word(\"{\");\n-        self.commasep_cmnt(\n-            Consistent,\n-            fields,\n-            |s, field| {\n-                s.print_outer_attributes(&field.attrs);\n-                s.ibox(INDENT_UNIT);\n-                if !field.is_shorthand {\n-                    s.print_ident(field.ident);\n-                    s.word_space(\":\");\n-                }\n-                s.print_expr(&field.expr);\n-                s.end();\n-            },\n-            |f| f.span,\n-        );\n-        match rest {\n-            ast::StructRest::Base(_) | ast::StructRest::Rest(_) => {\n-                self.ibox(INDENT_UNIT);\n-                if !fields.is_empty() {\n-                    self.word(\",\");\n-                    self.space();\n-                }\n-                self.word(\"..\");\n-                if let ast::StructRest::Base(ref expr) = *rest {\n-                    self.print_expr(expr);\n-                }\n-                self.end();\n-            }\n-            ast::StructRest::None if !fields.is_empty() => self.word(\",\"),\n-            _ => {}\n-        }\n-        self.word(\"}\");\n-    }\n-\n-    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) {\n-        self.popen();\n-        self.commasep_exprs(Inconsistent, exprs);\n-        if exprs.len() == 1 {\n-            self.word(\",\");\n-        }\n-        self.pclose()\n-    }\n-\n-    fn print_expr_call(&mut self, func: &ast::Expr, args: &[P<ast::Expr>]) {\n-        let prec = match func.kind {\n-            ast::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n-            _ => parser::PREC_POSTFIX,\n-        };\n-\n-        self.print_expr_maybe_paren(func, prec);\n-        self.print_call_post(args)\n-    }\n-\n-    fn print_expr_method_call(&mut self, segment: &ast::PathSegment, args: &[P<ast::Expr>]) {\n-        let base_args = &args[1..];\n-        self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n-        self.word(\".\");\n-        self.print_ident(segment.ident);\n-        if let Some(ref args) = segment.args {\n-            self.print_generic_args(args, true);\n-        }\n-        self.print_call_post(base_args)\n-    }\n-\n-    fn print_expr_binary(&mut self, op: ast::BinOp, lhs: &ast::Expr, rhs: &ast::Expr) {\n-        let assoc_op = AssocOp::from_ast_binop(op.node);\n-        let prec = assoc_op.precedence() as i8;\n-        let fixity = assoc_op.fixity();\n-\n-        let (left_prec, right_prec) = match fixity {\n-            Fixity::Left => (prec, prec + 1),\n-            Fixity::Right => (prec + 1, prec),\n-            Fixity::None => (prec + 1, prec + 1),\n-        };\n-\n-        let left_prec = match (&lhs.kind, op.node) {\n-            // These cases need parens: `x as i32 < y` has the parser thinking that `i32 < y` is\n-            // the beginning of a path type. It starts trying to parse `x as (i32 < y ...` instead\n-            // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n-            (&ast::ExprKind::Cast { .. }, ast::BinOpKind::Lt | ast::BinOpKind::Shl) => {\n-                parser::PREC_FORCE_PAREN\n-            }\n-            // We are given `(let _ = a) OP b`.\n-            //\n-            // - When `OP <= LAnd` we should print `let _ = a OP b` to avoid redundant parens\n-            //   as the parser will interpret this as `(let _ = a) OP b`.\n-            //\n-            // - Otherwise, e.g. when we have `(let a = b) < c` in AST,\n-            //   parens are required since the parser would interpret `let a = b < c` as\n-            //   `let a = (b < c)`. To achieve this, we force parens.\n-            (&ast::ExprKind::Let { .. }, _) if !parser::needs_par_as_let_scrutinee(prec) => {\n-                parser::PREC_FORCE_PAREN\n-            }\n-            _ => left_prec,\n-        };\n-\n-        self.print_expr_maybe_paren(lhs, left_prec);\n-        self.space();\n-        self.word_space(op.node.to_string());\n-        self.print_expr_maybe_paren(rhs, right_prec)\n-    }\n-\n-    fn print_expr_unary(&mut self, op: ast::UnOp, expr: &ast::Expr) {\n-        self.word(ast::UnOp::to_string(op));\n-        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n-    }\n-\n-    fn print_expr_addr_of(\n-        &mut self,\n-        kind: ast::BorrowKind,\n-        mutability: ast::Mutability,\n-        expr: &ast::Expr,\n-    ) {\n-        self.word(\"&\");\n-        match kind {\n-            ast::BorrowKind::Ref => self.print_mutability(mutability, false),\n-            ast::BorrowKind::Raw => {\n-                self.word_nbsp(\"raw\");\n-                self.print_mutability(mutability, true);\n-            }\n-        }\n-        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n-    }\n-\n-    pub fn print_expr(&mut self, expr: &ast::Expr) {\n-        self.print_expr_outer_attr_style(expr, true)\n-    }\n-\n-    fn print_expr_outer_attr_style(&mut self, expr: &ast::Expr, is_inline: bool) {\n-        self.maybe_print_comment(expr.span.lo());\n-\n-        let attrs = &expr.attrs;\n-        if is_inline {\n-            self.print_outer_attributes_inline(attrs);\n-        } else {\n-            self.print_outer_attributes(attrs);\n-        }\n-\n-        self.ibox(INDENT_UNIT);\n-        self.ann.pre(self, AnnNode::Expr(expr));\n-        match expr.kind {\n-            ast::ExprKind::Box(ref expr) => {\n-                self.word_space(\"box\");\n-                self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n-            }\n-            ast::ExprKind::Array(ref exprs) => {\n-                self.print_expr_vec(exprs);\n-            }\n-            ast::ExprKind::ConstBlock(ref anon_const) => {\n-                self.print_expr_anon_const(anon_const);\n-            }\n-            ast::ExprKind::Repeat(ref element, ref count) => {\n-                self.print_expr_repeat(element, count);\n-            }\n-            ast::ExprKind::Struct(ref se) => {\n-                self.print_expr_struct(&se.qself, &se.path, &se.fields, &se.rest);\n-            }\n-            ast::ExprKind::Tup(ref exprs) => {\n-                self.print_expr_tup(exprs);\n-            }\n-            ast::ExprKind::Call(ref func, ref args) => {\n-                self.print_expr_call(func, &args);\n-            }\n-            ast::ExprKind::MethodCall(ref segment, ref args, _) => {\n-                self.print_expr_method_call(segment, &args);\n-            }\n-            ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-                self.print_expr_binary(op, lhs, rhs);\n-            }\n-            ast::ExprKind::Unary(op, ref expr) => {\n-                self.print_expr_unary(op, expr);\n-            }\n-            ast::ExprKind::AddrOf(k, m, ref expr) => {\n-                self.print_expr_addr_of(k, m, expr);\n-            }\n-            ast::ExprKind::Lit(ref lit) => {\n-                self.print_literal(lit);\n-            }\n-            ast::ExprKind::Cast(ref expr, ref ty) => {\n-                let prec = AssocOp::As.precedence() as i8;\n-                self.print_expr_maybe_paren(expr, prec);\n-                self.space();\n-                self.word_space(\"as\");\n-                self.print_type(ty);\n-            }\n-            ast::ExprKind::Type(ref expr, ref ty) => {\n-                let prec = AssocOp::Colon.precedence() as i8;\n-                self.print_expr_maybe_paren(expr, prec);\n-                self.word_space(\":\");\n-                self.print_type(ty);\n-            }\n-            ast::ExprKind::Let(ref pat, ref scrutinee, _) => {\n-                self.print_let(pat, scrutinee);\n-            }\n-            ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n-                self.print_if(test, blk, elseopt.as_deref())\n-            }\n-            ast::ExprKind::While(ref test, ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-                self.head(\"while\");\n-                self.print_expr_as_cond(test);\n-                self.space();\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-                self.head(\"for\");\n-                self.print_pat(pat);\n-                self.space();\n-                self.word_space(\"in\");\n-                self.print_expr_as_cond(iter);\n-                self.space();\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::Loop(ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-                self.head(\"loop\");\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::Match(ref expr, ref arms) => {\n-                self.cbox(INDENT_UNIT);\n-                self.ibox(INDENT_UNIT);\n-                self.word_nbsp(\"match\");\n-                self.print_expr_as_cond(expr);\n-                self.space();\n-                self.bopen();\n-                self.print_inner_attributes_no_trailing_hardbreak(attrs);\n-                for arm in arms {\n-                    self.print_arm(arm);\n-                }\n-                let empty = attrs.is_empty() && arms.is_empty();\n-                self.bclose(expr.span, empty);\n-            }\n-            ast::ExprKind::Closure(\n-                capture_clause,\n-                asyncness,\n-                movability,\n-                ref decl,\n-                ref body,\n-                _,\n-            ) => {\n-                self.print_movability(movability);\n-                self.print_asyncness(asyncness);\n-                self.print_capture_clause(capture_clause);\n-\n-                self.print_fn_params_and_ret(decl, true);\n-                self.space();\n-                self.print_expr(body);\n-                self.end(); // need to close a box\n-\n-                // a box will be closed by print_expr, but we didn't want an overall\n-                // wrapper so we closed the corresponding opening. so create an\n-                // empty box to satisfy the close.\n-                self.ibox(0);\n-            }\n-            ast::ExprKind::Block(ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-                // containing cbox, will be closed by print-block at }\n-                self.cbox(INDENT_UNIT);\n-                // head-box, will be closed by print-block after {\n-                self.ibox(0);\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::Async(capture_clause, _, ref blk) => {\n-                self.word_nbsp(\"async\");\n-                self.print_capture_clause(capture_clause);\n-                // cbox/ibox in analogy to the `ExprKind::Block` arm above\n-                self.cbox(INDENT_UNIT);\n-                self.ibox(0);\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::Await(ref expr) => {\n-                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.word(\".await\");\n-            }\n-            ast::ExprKind::Assign(ref lhs, ref rhs, _) => {\n-                let prec = AssocOp::Assign.precedence() as i8;\n-                self.print_expr_maybe_paren(lhs, prec + 1);\n-                self.space();\n-                self.word_space(\"=\");\n-                self.print_expr_maybe_paren(rhs, prec);\n-            }\n-            ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-                let prec = AssocOp::Assign.precedence() as i8;\n-                self.print_expr_maybe_paren(lhs, prec + 1);\n-                self.space();\n-                self.word(op.node.to_string());\n-                self.word_space(\"=\");\n-                self.print_expr_maybe_paren(rhs, prec);\n-            }\n-            ast::ExprKind::Field(ref expr, ident) => {\n-                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.word(\".\");\n-                self.print_ident(ident);\n-            }\n-            ast::ExprKind::Index(ref expr, ref index) => {\n-                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.word(\"[\");\n-                self.print_expr(index);\n-                self.word(\"]\");\n-            }\n-            ast::ExprKind::Range(ref start, ref end, limits) => {\n-                // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n-                // than `Assign`, but `x .. x = x` gives a parse error instead of `x .. (x = x)`.\n-                // Here we use a fake precedence value so that any child with lower precedence than\n-                // a \"normal\" binop gets parenthesized.  (`LOr` is the lowest-precedence binop.)\n-                let fake_prec = AssocOp::LOr.precedence() as i8;\n-                if let Some(ref e) = *start {\n-                    self.print_expr_maybe_paren(e, fake_prec);\n-                }\n-                if limits == ast::RangeLimits::HalfOpen {\n-                    self.word(\"..\");\n-                } else {\n-                    self.word(\"..=\");\n-                }\n-                if let Some(ref e) = *end {\n-                    self.print_expr_maybe_paren(e, fake_prec);\n-                }\n-            }\n-            ast::ExprKind::Underscore => self.word(\"_\"),\n-            ast::ExprKind::Path(None, ref path) => self.print_path(path, true, 0),\n-            ast::ExprKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, true),\n-            ast::ExprKind::Break(opt_label, ref opt_expr) => {\n-                self.word(\"break\");\n-                if let Some(label) = opt_label {\n-                    self.space();\n-                    self.print_ident(label.ident);\n-                }\n-                if let Some(ref expr) = *opt_expr {\n-                    self.space();\n-                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                }\n-            }\n-            ast::ExprKind::Continue(opt_label) => {\n-                self.word(\"continue\");\n-                if let Some(label) = opt_label {\n-                    self.space();\n-                    self.print_ident(label.ident);\n-                }\n-            }\n-            ast::ExprKind::Ret(ref result) => {\n-                self.word(\"return\");\n-                if let Some(ref expr) = *result {\n-                    self.word(\" \");\n-                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                }\n-            }\n-            ast::ExprKind::InlineAsm(ref a) => {\n-                self.word(\"asm!\");\n-                self.print_inline_asm(a);\n-            }\n-            ast::ExprKind::MacCall(ref m) => self.print_mac(m),\n-            ast::ExprKind::Paren(ref e) => {\n-                self.popen();\n-                self.print_expr(e);\n-                self.pclose();\n-            }\n-            ast::ExprKind::Yield(ref e) => {\n-                self.word(\"yield\");\n-\n-                if let Some(ref expr) = *e {\n-                    self.space();\n-                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                }\n-            }\n-            ast::ExprKind::Try(ref e) => {\n-                self.print_expr_maybe_paren(e, parser::PREC_POSTFIX);\n-                self.word(\"?\")\n-            }\n-            ast::ExprKind::TryBlock(ref blk) => {\n-                self.head(\"try\");\n-                self.print_block_with_attrs(blk, attrs)\n-            }\n-            ast::ExprKind::Err => {\n-                self.popen();\n-                self.word(\"/*ERROR*/\");\n-                self.pclose()\n-            }\n-        }\n-        self.ann.post(self, AnnNode::Expr(expr));\n-        self.end();\n-    }\n-\n     fn print_inline_asm(&mut self, asm: &ast::InlineAsm) {\n         enum AsmArg<'a> {\n             Template(String),\n@@ -2496,48 +1483,6 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n-    fn print_arm(&mut self, arm: &ast::Arm) {\n-        // Note, I have no idea why this check is necessary, but here it is.\n-        if arm.attrs.is_empty() {\n-            self.space();\n-        }\n-        self.cbox(INDENT_UNIT);\n-        self.ibox(0);\n-        self.maybe_print_comment(arm.pat.span.lo());\n-        self.print_outer_attributes(&arm.attrs);\n-        self.print_pat(&arm.pat);\n-        self.space();\n-        if let Some(ref e) = arm.guard {\n-            self.word_space(\"if\");\n-            self.print_expr(e);\n-            self.space();\n-        }\n-        self.word_space(\"=>\");\n-\n-        match arm.body.kind {\n-            ast::ExprKind::Block(ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-\n-                // The block will close the pattern's ibox.\n-                self.print_block_unclosed_indent(blk);\n-\n-                // If it is a user-provided unsafe block, print a comma after it.\n-                if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n-                    self.word(\",\");\n-                }\n-            }\n-            _ => {\n-                self.end(); // Close the ibox for the pattern.\n-                self.print_expr(&arm.body);\n-                self.word(\",\");\n-            }\n-        }\n-        self.end(); // Close enclosing cbox.\n-    }\n-\n     fn print_explicit_self(&mut self, explicit_self: &ast::ExplicitSelf) {\n         match explicit_self.node {\n             SelfKind::Value(m) => {\n@@ -2559,75 +1504,12 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_fn_full(\n-        &mut self,\n-        sig: &ast::FnSig,\n-        name: Ident,\n-        generics: &ast::Generics,\n-        vis: &ast::Visibility,\n-        defaultness: ast::Defaultness,\n-        body: Option<&ast::Block>,\n-        attrs: &[ast::Attribute],\n-    ) {\n-        if body.is_some() {\n-            self.head(\"\");\n-        }\n-        self.print_visibility(vis);\n-        self.print_defaultness(defaultness);\n-        self.print_fn(&sig.decl, sig.header, Some(name), generics);\n-        if let Some(body) = body {\n-            self.nbsp();\n-            self.print_block_with_attrs(body, attrs);\n-        } else {\n-            self.word(\";\");\n-        }\n-    }\n-\n-    crate fn print_fn(\n-        &mut self,\n-        decl: &ast::FnDecl,\n-        header: ast::FnHeader,\n-        name: Option<Ident>,\n-        generics: &ast::Generics,\n-    ) {\n-        self.print_fn_header_info(header);\n-        if let Some(name) = name {\n-            self.nbsp();\n-            self.print_ident(name);\n-        }\n-        self.print_generic_params(&generics.params);\n-        self.print_fn_params_and_ret(decl, false);\n-        self.print_where_clause(&generics.where_clause)\n-    }\n-\n-    crate fn print_fn_params_and_ret(&mut self, decl: &ast::FnDecl, is_closure: bool) {\n-        let (open, close) = if is_closure { (\"|\", \"|\") } else { (\"(\", \")\") };\n-        self.word(open);\n-        self.commasep(Inconsistent, &decl.inputs, |s, param| s.print_param(param, is_closure));\n-        self.word(close);\n-        self.print_fn_ret_ty(&decl.output)\n-    }\n-\n-    crate fn print_movability(&mut self, movability: ast::Movability) {\n-        match movability {\n-            ast::Movability::Static => self.word_space(\"static\"),\n-            ast::Movability::Movable => {}\n-        }\n-    }\n-\n     crate fn print_asyncness(&mut self, asyncness: ast::Async) {\n         if asyncness.is_async() {\n             self.word_nbsp(\"async\");\n         }\n     }\n \n-    crate fn print_capture_clause(&mut self, capture_clause: ast::CaptureBy) {\n-        match capture_clause {\n-            ast::CaptureBy::Value => self.word_space(\"move\"),\n-            ast::CaptureBy::Ref => {}\n-        }\n-    }\n-\n     pub fn print_type_bounds(&mut self, prefix: &'static str, bounds: &[ast::GenericBound]) {\n         if !bounds.is_empty() {\n             self.word(prefix);\n@@ -2722,83 +1604,6 @@ impl<'a> State<'a> {\n         self.word(\">\");\n     }\n \n-    crate fn print_where_clause(&mut self, where_clause: &ast::WhereClause) {\n-        if where_clause.predicates.is_empty() && !where_clause.has_where_token {\n-            return;\n-        }\n-\n-        self.space();\n-        self.word_space(\"where\");\n-\n-        for (i, predicate) in where_clause.predicates.iter().enumerate() {\n-            if i != 0 {\n-                self.word_space(\",\");\n-            }\n-\n-            self.print_where_predicate(predicate);\n-        }\n-    }\n-\n-    pub fn print_where_predicate(&mut self, predicate: &ast::WherePredicate) {\n-        match predicate {\n-            ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n-                bound_generic_params,\n-                bounded_ty,\n-                bounds,\n-                ..\n-            }) => {\n-                self.print_formal_generic_params(bound_generic_params);\n-                self.print_type(bounded_ty);\n-                self.print_type_bounds(\":\", bounds);\n-            }\n-            ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n-                lifetime,\n-                bounds,\n-                ..\n-            }) => {\n-                self.print_lifetime_bounds(*lifetime, bounds);\n-            }\n-            ast::WherePredicate::EqPredicate(ast::WhereEqPredicate { lhs_ty, rhs_ty, .. }) => {\n-                self.print_type(lhs_ty);\n-                self.space();\n-                self.word_space(\"=\");\n-                self.print_type(rhs_ty);\n-            }\n-        }\n-    }\n-\n-    crate fn print_use_tree(&mut self, tree: &ast::UseTree) {\n-        match tree.kind {\n-            ast::UseTreeKind::Simple(rename, ..) => {\n-                self.print_path(&tree.prefix, false, 0);\n-                if let Some(rename) = rename {\n-                    self.space();\n-                    self.word_space(\"as\");\n-                    self.print_ident(rename);\n-                }\n-            }\n-            ast::UseTreeKind::Glob => {\n-                if !tree.prefix.segments.is_empty() {\n-                    self.print_path(&tree.prefix, false, 0);\n-                    self.word(\"::\");\n-                }\n-                self.word(\"*\");\n-            }\n-            ast::UseTreeKind::Nested(ref items) => {\n-                if tree.prefix.segments.is_empty() {\n-                    self.word(\"{\");\n-                } else {\n-                    self.print_path(&tree.prefix, false, 0);\n-                    self.word(\"::{\");\n-                }\n-                self.commasep(Inconsistent, &items, |this, &(ref tree, _)| {\n-                    this.print_use_tree(tree)\n-                });\n-                self.word(\"}\");\n-            }\n-        }\n-    }\n-\n     pub fn print_mutability(&mut self, mutbl: ast::Mutability, print_const: bool) {\n         match mutbl {\n             ast::Mutability::Mut => self.word_nbsp(\"mut\"),"}, {"sha": "956200d60f5078940b1c7bc2188793ba61580397", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "added", "additions": 571, "deletions": 0, "changes": 571, "blob_url": "https://github.com/rust-lang/rust/blob/420ada6f8a29e0dcb8d97a22df1a361336faa521/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/420ada6f8a29e0dcb8d97a22df1a361336faa521/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=420ada6f8a29e0dcb8d97a22df1a361336faa521", "patch": "@@ -0,0 +1,571 @@\n+use crate::pp::Breaks::{Consistent, Inconsistent};\n+use crate::pprust::state::{AnnNode, PrintState, State, INDENT_UNIT};\n+\n+use rustc_ast::ptr::P;\n+use rustc_ast::util::parser::{self, AssocOp, Fixity};\n+use rustc_ast::{self as ast, BlockCheckMode};\n+\n+impl<'a> State<'a> {\n+    fn print_else(&mut self, els: Option<&ast::Expr>) {\n+        if let Some(_else) = els {\n+            match _else.kind {\n+                // Another `else if` block.\n+                ast::ExprKind::If(ref i, ref then, ref e) => {\n+                    self.cbox(INDENT_UNIT - 1);\n+                    self.ibox(0);\n+                    self.word(\" else if \");\n+                    self.print_expr_as_cond(i);\n+                    self.space();\n+                    self.print_block(then);\n+                    self.print_else(e.as_deref())\n+                }\n+                // Final `else` block.\n+                ast::ExprKind::Block(ref b, _) => {\n+                    self.cbox(INDENT_UNIT - 1);\n+                    self.ibox(0);\n+                    self.word(\" else \");\n+                    self.print_block(b)\n+                }\n+                // Constraints would be great here!\n+                _ => {\n+                    panic!(\"print_if saw if with weird alternative\");\n+                }\n+            }\n+        }\n+    }\n+\n+    fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block, elseopt: Option<&ast::Expr>) {\n+        self.head(\"if\");\n+        self.print_expr_as_cond(test);\n+        self.space();\n+        self.print_block(blk);\n+        self.print_else(elseopt)\n+    }\n+\n+    fn print_call_post(&mut self, args: &[P<ast::Expr>]) {\n+        self.popen();\n+        self.commasep_exprs(Inconsistent, args);\n+        self.pclose()\n+    }\n+\n+    fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) {\n+        self.print_expr_cond_paren(expr, expr.precedence().order() < prec)\n+    }\n+\n+    /// Prints an expr using syntax that's acceptable in a condition position, such as the `cond` in\n+    /// `if cond { ... }`.\n+    fn print_expr_as_cond(&mut self, expr: &ast::Expr) {\n+        self.print_expr_cond_paren(expr, Self::cond_needs_par(expr))\n+    }\n+\n+    // Does `expr` need parentheses when printed in a condition position?\n+    //\n+    // These cases need parens due to the parse error observed in #26461: `if return {}`\n+    // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n+    pub(super) fn cond_needs_par(expr: &ast::Expr) -> bool {\n+        match expr.kind {\n+            ast::ExprKind::Break(..) | ast::ExprKind::Closure(..) | ast::ExprKind::Ret(..) => true,\n+            _ => parser::contains_exterior_struct_lit(expr),\n+        }\n+    }\n+\n+    /// Prints `expr` or `(expr)` when `needs_par` holds.\n+    pub(super) fn print_expr_cond_paren(&mut self, expr: &ast::Expr, needs_par: bool) {\n+        if needs_par {\n+            self.popen();\n+        }\n+        self.print_expr(expr);\n+        if needs_par {\n+            self.pclose();\n+        }\n+    }\n+\n+    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) {\n+        self.ibox(INDENT_UNIT);\n+        self.word(\"[\");\n+        self.commasep_exprs(Inconsistent, exprs);\n+        self.word(\"]\");\n+        self.end();\n+    }\n+\n+    pub(super) fn print_expr_anon_const(&mut self, expr: &ast::AnonConst) {\n+        self.ibox(INDENT_UNIT);\n+        self.word(\"const\");\n+        self.print_expr(&expr.value);\n+        self.end();\n+    }\n+\n+    fn print_expr_repeat(&mut self, element: &ast::Expr, count: &ast::AnonConst) {\n+        self.ibox(INDENT_UNIT);\n+        self.word(\"[\");\n+        self.print_expr(element);\n+        self.word_space(\";\");\n+        self.print_expr(&count.value);\n+        self.word(\"]\");\n+        self.end();\n+    }\n+\n+    fn print_expr_struct(\n+        &mut self,\n+        qself: &Option<ast::QSelf>,\n+        path: &ast::Path,\n+        fields: &[ast::ExprField],\n+        rest: &ast::StructRest,\n+    ) {\n+        if let Some(qself) = qself {\n+            self.print_qpath(path, qself, true);\n+        } else {\n+            self.print_path(path, true, 0);\n+        }\n+        self.word(\"{\");\n+        self.commasep_cmnt(\n+            Consistent,\n+            fields,\n+            |s, field| {\n+                s.print_outer_attributes(&field.attrs);\n+                s.ibox(INDENT_UNIT);\n+                if !field.is_shorthand {\n+                    s.print_ident(field.ident);\n+                    s.word_space(\":\");\n+                }\n+                s.print_expr(&field.expr);\n+                s.end();\n+            },\n+            |f| f.span,\n+        );\n+        match rest {\n+            ast::StructRest::Base(_) | ast::StructRest::Rest(_) => {\n+                self.ibox(INDENT_UNIT);\n+                if !fields.is_empty() {\n+                    self.word(\",\");\n+                    self.space();\n+                }\n+                self.word(\"..\");\n+                if let ast::StructRest::Base(ref expr) = *rest {\n+                    self.print_expr(expr);\n+                }\n+                self.end();\n+            }\n+            ast::StructRest::None if !fields.is_empty() => self.word(\",\"),\n+            _ => {}\n+        }\n+        self.word(\"}\");\n+    }\n+\n+    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) {\n+        self.popen();\n+        self.commasep_exprs(Inconsistent, exprs);\n+        if exprs.len() == 1 {\n+            self.word(\",\");\n+        }\n+        self.pclose()\n+    }\n+\n+    fn print_expr_call(&mut self, func: &ast::Expr, args: &[P<ast::Expr>]) {\n+        let prec = match func.kind {\n+            ast::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n+            _ => parser::PREC_POSTFIX,\n+        };\n+\n+        self.print_expr_maybe_paren(func, prec);\n+        self.print_call_post(args)\n+    }\n+\n+    fn print_expr_method_call(&mut self, segment: &ast::PathSegment, args: &[P<ast::Expr>]) {\n+        let base_args = &args[1..];\n+        self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n+        self.word(\".\");\n+        self.print_ident(segment.ident);\n+        if let Some(ref args) = segment.args {\n+            self.print_generic_args(args, true);\n+        }\n+        self.print_call_post(base_args)\n+    }\n+\n+    fn print_expr_binary(&mut self, op: ast::BinOp, lhs: &ast::Expr, rhs: &ast::Expr) {\n+        let assoc_op = AssocOp::from_ast_binop(op.node);\n+        let prec = assoc_op.precedence() as i8;\n+        let fixity = assoc_op.fixity();\n+\n+        let (left_prec, right_prec) = match fixity {\n+            Fixity::Left => (prec, prec + 1),\n+            Fixity::Right => (prec + 1, prec),\n+            Fixity::None => (prec + 1, prec + 1),\n+        };\n+\n+        let left_prec = match (&lhs.kind, op.node) {\n+            // These cases need parens: `x as i32 < y` has the parser thinking that `i32 < y` is\n+            // the beginning of a path type. It starts trying to parse `x as (i32 < y ...` instead\n+            // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n+            (&ast::ExprKind::Cast { .. }, ast::BinOpKind::Lt | ast::BinOpKind::Shl) => {\n+                parser::PREC_FORCE_PAREN\n+            }\n+            // We are given `(let _ = a) OP b`.\n+            //\n+            // - When `OP <= LAnd` we should print `let _ = a OP b` to avoid redundant parens\n+            //   as the parser will interpret this as `(let _ = a) OP b`.\n+            //\n+            // - Otherwise, e.g. when we have `(let a = b) < c` in AST,\n+            //   parens are required since the parser would interpret `let a = b < c` as\n+            //   `let a = (b < c)`. To achieve this, we force parens.\n+            (&ast::ExprKind::Let { .. }, _) if !parser::needs_par_as_let_scrutinee(prec) => {\n+                parser::PREC_FORCE_PAREN\n+            }\n+            _ => left_prec,\n+        };\n+\n+        self.print_expr_maybe_paren(lhs, left_prec);\n+        self.space();\n+        self.word_space(op.node.to_string());\n+        self.print_expr_maybe_paren(rhs, right_prec)\n+    }\n+\n+    fn print_expr_unary(&mut self, op: ast::UnOp, expr: &ast::Expr) {\n+        self.word(ast::UnOp::to_string(op));\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n+    }\n+\n+    fn print_expr_addr_of(\n+        &mut self,\n+        kind: ast::BorrowKind,\n+        mutability: ast::Mutability,\n+        expr: &ast::Expr,\n+    ) {\n+        self.word(\"&\");\n+        match kind {\n+            ast::BorrowKind::Ref => self.print_mutability(mutability, false),\n+            ast::BorrowKind::Raw => {\n+                self.word_nbsp(\"raw\");\n+                self.print_mutability(mutability, true);\n+            }\n+        }\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n+    }\n+\n+    pub fn print_expr(&mut self, expr: &ast::Expr) {\n+        self.print_expr_outer_attr_style(expr, true)\n+    }\n+\n+    pub(super) fn print_expr_outer_attr_style(&mut self, expr: &ast::Expr, is_inline: bool) {\n+        self.maybe_print_comment(expr.span.lo());\n+\n+        let attrs = &expr.attrs;\n+        if is_inline {\n+            self.print_outer_attributes_inline(attrs);\n+        } else {\n+            self.print_outer_attributes(attrs);\n+        }\n+\n+        self.ibox(INDENT_UNIT);\n+        self.ann.pre(self, AnnNode::Expr(expr));\n+        match expr.kind {\n+            ast::ExprKind::Box(ref expr) => {\n+                self.word_space(\"box\");\n+                self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n+            }\n+            ast::ExprKind::Array(ref exprs) => {\n+                self.print_expr_vec(exprs);\n+            }\n+            ast::ExprKind::ConstBlock(ref anon_const) => {\n+                self.print_expr_anon_const(anon_const);\n+            }\n+            ast::ExprKind::Repeat(ref element, ref count) => {\n+                self.print_expr_repeat(element, count);\n+            }\n+            ast::ExprKind::Struct(ref se) => {\n+                self.print_expr_struct(&se.qself, &se.path, &se.fields, &se.rest);\n+            }\n+            ast::ExprKind::Tup(ref exprs) => {\n+                self.print_expr_tup(exprs);\n+            }\n+            ast::ExprKind::Call(ref func, ref args) => {\n+                self.print_expr_call(func, &args);\n+            }\n+            ast::ExprKind::MethodCall(ref segment, ref args, _) => {\n+                self.print_expr_method_call(segment, &args);\n+            }\n+            ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n+                self.print_expr_binary(op, lhs, rhs);\n+            }\n+            ast::ExprKind::Unary(op, ref expr) => {\n+                self.print_expr_unary(op, expr);\n+            }\n+            ast::ExprKind::AddrOf(k, m, ref expr) => {\n+                self.print_expr_addr_of(k, m, expr);\n+            }\n+            ast::ExprKind::Lit(ref lit) => {\n+                self.print_literal(lit);\n+            }\n+            ast::ExprKind::Cast(ref expr, ref ty) => {\n+                let prec = AssocOp::As.precedence() as i8;\n+                self.print_expr_maybe_paren(expr, prec);\n+                self.space();\n+                self.word_space(\"as\");\n+                self.print_type(ty);\n+            }\n+            ast::ExprKind::Type(ref expr, ref ty) => {\n+                let prec = AssocOp::Colon.precedence() as i8;\n+                self.print_expr_maybe_paren(expr, prec);\n+                self.word_space(\":\");\n+                self.print_type(ty);\n+            }\n+            ast::ExprKind::Let(ref pat, ref scrutinee, _) => {\n+                self.print_let(pat, scrutinee);\n+            }\n+            ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n+                self.print_if(test, blk, elseopt.as_deref())\n+            }\n+            ast::ExprKind::While(ref test, ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+                self.head(\"while\");\n+                self.print_expr_as_cond(test);\n+                self.space();\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+                self.head(\"for\");\n+                self.print_pat(pat);\n+                self.space();\n+                self.word_space(\"in\");\n+                self.print_expr_as_cond(iter);\n+                self.space();\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::Loop(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+                self.head(\"loop\");\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::Match(ref expr, ref arms) => {\n+                self.cbox(INDENT_UNIT);\n+                self.ibox(INDENT_UNIT);\n+                self.word_nbsp(\"match\");\n+                self.print_expr_as_cond(expr);\n+                self.space();\n+                self.bopen();\n+                self.print_inner_attributes_no_trailing_hardbreak(attrs);\n+                for arm in arms {\n+                    self.print_arm(arm);\n+                }\n+                let empty = attrs.is_empty() && arms.is_empty();\n+                self.bclose(expr.span, empty);\n+            }\n+            ast::ExprKind::Closure(\n+                capture_clause,\n+                asyncness,\n+                movability,\n+                ref decl,\n+                ref body,\n+                _,\n+            ) => {\n+                self.print_movability(movability);\n+                self.print_asyncness(asyncness);\n+                self.print_capture_clause(capture_clause);\n+\n+                self.print_fn_params_and_ret(decl, true);\n+                self.space();\n+                self.print_expr(body);\n+                self.end(); // need to close a box\n+\n+                // a box will be closed by print_expr, but we didn't want an overall\n+                // wrapper so we closed the corresponding opening. so create an\n+                // empty box to satisfy the close.\n+                self.ibox(0);\n+            }\n+            ast::ExprKind::Block(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+                // containing cbox, will be closed by print-block at }\n+                self.cbox(INDENT_UNIT);\n+                // head-box, will be closed by print-block after {\n+                self.ibox(0);\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::Async(capture_clause, _, ref blk) => {\n+                self.word_nbsp(\"async\");\n+                self.print_capture_clause(capture_clause);\n+                // cbox/ibox in analogy to the `ExprKind::Block` arm above\n+                self.cbox(INDENT_UNIT);\n+                self.ibox(0);\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::Await(ref expr) => {\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n+                self.word(\".await\");\n+            }\n+            ast::ExprKind::Assign(ref lhs, ref rhs, _) => {\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(lhs, prec + 1);\n+                self.space();\n+                self.word_space(\"=\");\n+                self.print_expr_maybe_paren(rhs, prec);\n+            }\n+            ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(lhs, prec + 1);\n+                self.space();\n+                self.word(op.node.to_string());\n+                self.word_space(\"=\");\n+                self.print_expr_maybe_paren(rhs, prec);\n+            }\n+            ast::ExprKind::Field(ref expr, ident) => {\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n+                self.word(\".\");\n+                self.print_ident(ident);\n+            }\n+            ast::ExprKind::Index(ref expr, ref index) => {\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n+                self.word(\"[\");\n+                self.print_expr(index);\n+                self.word(\"]\");\n+            }\n+            ast::ExprKind::Range(ref start, ref end, limits) => {\n+                // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n+                // than `Assign`, but `x .. x = x` gives a parse error instead of `x .. (x = x)`.\n+                // Here we use a fake precedence value so that any child with lower precedence than\n+                // a \"normal\" binop gets parenthesized.  (`LOr` is the lowest-precedence binop.)\n+                let fake_prec = AssocOp::LOr.precedence() as i8;\n+                if let Some(ref e) = *start {\n+                    self.print_expr_maybe_paren(e, fake_prec);\n+                }\n+                if limits == ast::RangeLimits::HalfOpen {\n+                    self.word(\"..\");\n+                } else {\n+                    self.word(\"..=\");\n+                }\n+                if let Some(ref e) = *end {\n+                    self.print_expr_maybe_paren(e, fake_prec);\n+                }\n+            }\n+            ast::ExprKind::Underscore => self.word(\"_\"),\n+            ast::ExprKind::Path(None, ref path) => self.print_path(path, true, 0),\n+            ast::ExprKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, true),\n+            ast::ExprKind::Break(opt_label, ref opt_expr) => {\n+                self.word(\"break\");\n+                if let Some(label) = opt_label {\n+                    self.space();\n+                    self.print_ident(label.ident);\n+                }\n+                if let Some(ref expr) = *opt_expr {\n+                    self.space();\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n+                }\n+            }\n+            ast::ExprKind::Continue(opt_label) => {\n+                self.word(\"continue\");\n+                if let Some(label) = opt_label {\n+                    self.space();\n+                    self.print_ident(label.ident);\n+                }\n+            }\n+            ast::ExprKind::Ret(ref result) => {\n+                self.word(\"return\");\n+                if let Some(ref expr) = *result {\n+                    self.word(\" \");\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n+                }\n+            }\n+            ast::ExprKind::InlineAsm(ref a) => {\n+                self.word(\"asm!\");\n+                self.print_inline_asm(a);\n+            }\n+            ast::ExprKind::MacCall(ref m) => self.print_mac(m),\n+            ast::ExprKind::Paren(ref e) => {\n+                self.popen();\n+                self.print_expr(e);\n+                self.pclose();\n+            }\n+            ast::ExprKind::Yield(ref e) => {\n+                self.word(\"yield\");\n+\n+                if let Some(ref expr) = *e {\n+                    self.space();\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n+                }\n+            }\n+            ast::ExprKind::Try(ref e) => {\n+                self.print_expr_maybe_paren(e, parser::PREC_POSTFIX);\n+                self.word(\"?\")\n+            }\n+            ast::ExprKind::TryBlock(ref blk) => {\n+                self.head(\"try\");\n+                self.print_block_with_attrs(blk, attrs)\n+            }\n+            ast::ExprKind::Err => {\n+                self.popen();\n+                self.word(\"/*ERROR*/\");\n+                self.pclose()\n+            }\n+        }\n+        self.ann.post(self, AnnNode::Expr(expr));\n+        self.end();\n+    }\n+\n+    fn print_arm(&mut self, arm: &ast::Arm) {\n+        // Note, I have no idea why this check is necessary, but here it is.\n+        if arm.attrs.is_empty() {\n+            self.space();\n+        }\n+        self.cbox(INDENT_UNIT);\n+        self.ibox(0);\n+        self.maybe_print_comment(arm.pat.span.lo());\n+        self.print_outer_attributes(&arm.attrs);\n+        self.print_pat(&arm.pat);\n+        self.space();\n+        if let Some(ref e) = arm.guard {\n+            self.word_space(\"if\");\n+            self.print_expr(e);\n+            self.space();\n+        }\n+        self.word_space(\"=>\");\n+\n+        match arm.body.kind {\n+            ast::ExprKind::Block(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+\n+                // The block will close the pattern's ibox.\n+                self.print_block_unclosed_indent(blk);\n+\n+                // If it is a user-provided unsafe block, print a comma after it.\n+                if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n+                    self.word(\",\");\n+                }\n+            }\n+            _ => {\n+                self.end(); // Close the ibox for the pattern.\n+                self.print_expr(&arm.body);\n+                self.word(\",\");\n+            }\n+        }\n+        self.end(); // Close enclosing cbox.\n+    }\n+\n+    fn print_movability(&mut self, movability: ast::Movability) {\n+        match movability {\n+            ast::Movability::Static => self.word_space(\"static\"),\n+            ast::Movability::Movable => {}\n+        }\n+    }\n+\n+    fn print_capture_clause(&mut self, capture_clause: ast::CaptureBy) {\n+        match capture_clause {\n+            ast::CaptureBy::Value => self.word_space(\"move\"),\n+            ast::CaptureBy::Ref => {}\n+        }\n+    }\n+}"}, {"sha": "c756b946b1e4ae9acf7f311d8319c20bbf1355e6", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "added", "additions": 644, "deletions": 0, "changes": 644, "blob_url": "https://github.com/rust-lang/rust/blob/420ada6f8a29e0dcb8d97a22df1a361336faa521/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/420ada6f8a29e0dcb8d97a22df1a361336faa521/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=420ada6f8a29e0dcb8d97a22df1a361336faa521", "patch": "@@ -0,0 +1,644 @@\n+use crate::pp::Breaks::Inconsistent;\n+use crate::pprust::state::{AnnNode, PrintState, State, INDENT_UNIT};\n+\n+use rustc_ast as ast;\n+use rustc_ast::GenericBound;\n+use rustc_ast::ModKind;\n+use rustc_span::symbol::Ident;\n+\n+fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n+    format!(\"{}{}\", State::to_string(|s| s.print_visibility(vis)), s)\n+}\n+\n+impl<'a> State<'a> {\n+    fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[ast::Attribute]) {\n+        self.print_inner_attributes(attrs);\n+        for item in &nmod.items {\n+            self.print_foreign_item(item);\n+        }\n+    }\n+\n+    fn print_foreign_item(&mut self, item: &ast::ForeignItem) {\n+        let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n+        self.ann.pre(self, AnnNode::SubItem(id));\n+        self.hardbreak_if_not_bol();\n+        self.maybe_print_comment(span.lo());\n+        self.print_outer_attributes(attrs);\n+        match kind {\n+            ast::ForeignItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n+                self.print_fn_full(sig, ident, generics, vis, *defaultness, body.as_deref(), attrs);\n+            }\n+            ast::ForeignItemKind::Static(ty, mutbl, body) => {\n+                let def = ast::Defaultness::Final;\n+                self.print_item_const(ident, Some(*mutbl), ty, body.as_deref(), vis, def);\n+            }\n+            ast::ForeignItemKind::TyAlias(box ast::TyAlias {\n+                defaultness,\n+                generics,\n+                bounds,\n+                ty,\n+            }) => {\n+                self.print_associated_type(\n+                    ident,\n+                    generics,\n+                    bounds,\n+                    ty.as_deref(),\n+                    vis,\n+                    *defaultness,\n+                );\n+            }\n+            ast::ForeignItemKind::MacCall(m) => {\n+                self.print_mac(m);\n+                if m.args.need_semicolon() {\n+                    self.word(\";\");\n+                }\n+            }\n+        }\n+        self.ann.post(self, AnnNode::SubItem(id))\n+    }\n+\n+    fn print_item_const(\n+        &mut self,\n+        ident: Ident,\n+        mutbl: Option<ast::Mutability>,\n+        ty: &ast::Ty,\n+        body: Option<&ast::Expr>,\n+        vis: &ast::Visibility,\n+        defaultness: ast::Defaultness,\n+    ) {\n+        self.head(\"\");\n+        self.print_visibility(vis);\n+        self.print_defaultness(defaultness);\n+        let leading = match mutbl {\n+            None => \"const\",\n+            Some(ast::Mutability::Not) => \"static\",\n+            Some(ast::Mutability::Mut) => \"static mut\",\n+        };\n+        self.word_space(leading);\n+        self.print_ident(ident);\n+        self.word_space(\":\");\n+        self.print_type(ty);\n+        if body.is_some() {\n+            self.space();\n+        }\n+        self.end(); // end the head-ibox\n+        if let Some(body) = body {\n+            self.word_space(\"=\");\n+            self.print_expr(body);\n+        }\n+        self.word(\";\");\n+        self.end(); // end the outer cbox\n+    }\n+\n+    fn print_associated_type(\n+        &mut self,\n+        ident: Ident,\n+        generics: &ast::Generics,\n+        bounds: &ast::GenericBounds,\n+        ty: Option<&ast::Ty>,\n+        vis: &ast::Visibility,\n+        defaultness: ast::Defaultness,\n+    ) {\n+        self.head(\"\");\n+        self.print_visibility(vis);\n+        self.print_defaultness(defaultness);\n+        self.word_space(\"type\");\n+        self.print_ident(ident);\n+        self.print_generic_params(&generics.params);\n+        self.print_type_bounds(\":\", bounds);\n+        self.print_where_clause(&generics.where_clause);\n+        if let Some(ty) = ty {\n+            self.space();\n+            self.word_space(\"=\");\n+            self.print_type(ty);\n+        }\n+        self.word(\";\");\n+        self.end(); // end inner head-block\n+        self.end(); // end outer head-block\n+    }\n+\n+    /// Pretty-prints an item.\n+    crate fn print_item(&mut self, item: &ast::Item) {\n+        self.hardbreak_if_not_bol();\n+        self.maybe_print_comment(item.span.lo());\n+        self.print_outer_attributes(&item.attrs);\n+        self.ann.pre(self, AnnNode::Item(item));\n+        match item.kind {\n+            ast::ItemKind::ExternCrate(orig_name) => {\n+                self.head(visibility_qualified(&item.vis, \"extern crate\"));\n+                if let Some(orig_name) = orig_name {\n+                    self.print_name(orig_name);\n+                    self.space();\n+                    self.word(\"as\");\n+                    self.space();\n+                }\n+                self.print_ident(item.ident);\n+                self.word(\";\");\n+                self.end(); // end inner head-block\n+                self.end(); // end outer head-block\n+            }\n+            ast::ItemKind::Use(ref tree) => {\n+                self.head(visibility_qualified(&item.vis, \"use\"));\n+                self.print_use_tree(tree);\n+                self.word(\";\");\n+                self.end(); // end inner head-block\n+                self.end(); // end outer head-block\n+            }\n+            ast::ItemKind::Static(ref ty, mutbl, ref body) => {\n+                let def = ast::Defaultness::Final;\n+                self.print_item_const(item.ident, Some(mutbl), ty, body.as_deref(), &item.vis, def);\n+            }\n+            ast::ItemKind::Const(def, ref ty, ref body) => {\n+                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis, def);\n+            }\n+            ast::ItemKind::Fn(box ast::Fn { defaultness, ref sig, ref generics, ref body }) => {\n+                let body = body.as_deref();\n+                self.print_fn_full(\n+                    sig,\n+                    item.ident,\n+                    generics,\n+                    &item.vis,\n+                    defaultness,\n+                    body,\n+                    &item.attrs,\n+                );\n+            }\n+            ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n+                self.head(Self::to_string(|s| {\n+                    s.print_visibility(&item.vis);\n+                    s.print_unsafety(unsafety);\n+                    s.word(\"mod\");\n+                }));\n+                self.print_ident(item.ident);\n+\n+                match mod_kind {\n+                    ModKind::Loaded(items, ..) => {\n+                        self.nbsp();\n+                        self.bopen();\n+                        self.print_inner_attributes(&item.attrs);\n+                        for item in items {\n+                            self.print_item(item);\n+                        }\n+                        let empty = item.attrs.is_empty() && items.is_empty();\n+                        self.bclose(item.span, empty);\n+                    }\n+                    ModKind::Unloaded => {\n+                        self.word(\";\");\n+                        self.end(); // end inner head-block\n+                        self.end(); // end outer head-block\n+                    }\n+                }\n+            }\n+            ast::ItemKind::ForeignMod(ref nmod) => {\n+                self.head(Self::to_string(|s| {\n+                    s.print_unsafety(nmod.unsafety);\n+                    s.word(\"extern\");\n+                }));\n+                if let Some(abi) = nmod.abi {\n+                    self.print_literal(&abi.as_lit());\n+                    self.nbsp();\n+                }\n+                self.bopen();\n+                self.print_foreign_mod(nmod, &item.attrs);\n+                let empty = item.attrs.is_empty() && nmod.items.is_empty();\n+                self.bclose(item.span, empty);\n+            }\n+            ast::ItemKind::GlobalAsm(ref asm) => {\n+                self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n+                self.print_inline_asm(asm);\n+                self.end();\n+            }\n+            ast::ItemKind::TyAlias(box ast::TyAlias {\n+                defaultness,\n+                ref generics,\n+                ref bounds,\n+                ref ty,\n+            }) => {\n+                let ty = ty.as_deref();\n+                self.print_associated_type(\n+                    item.ident,\n+                    generics,\n+                    bounds,\n+                    ty,\n+                    &item.vis,\n+                    defaultness,\n+                );\n+            }\n+            ast::ItemKind::Enum(ref enum_definition, ref params) => {\n+                self.print_enum_def(enum_definition, params, item.ident, item.span, &item.vis);\n+            }\n+            ast::ItemKind::Struct(ref struct_def, ref generics) => {\n+                self.head(visibility_qualified(&item.vis, \"struct\"));\n+                self.print_struct(struct_def, generics, item.ident, item.span, true);\n+            }\n+            ast::ItemKind::Union(ref struct_def, ref generics) => {\n+                self.head(visibility_qualified(&item.vis, \"union\"));\n+                self.print_struct(struct_def, generics, item.ident, item.span, true);\n+            }\n+            ast::ItemKind::Impl(box ast::Impl {\n+                unsafety,\n+                polarity,\n+                defaultness,\n+                constness,\n+                ref generics,\n+                ref of_trait,\n+                ref self_ty,\n+                ref items,\n+            }) => {\n+                self.head(\"\");\n+                self.print_visibility(&item.vis);\n+                self.print_defaultness(defaultness);\n+                self.print_unsafety(unsafety);\n+                self.word(\"impl\");\n+\n+                if generics.params.is_empty() {\n+                    self.nbsp();\n+                } else {\n+                    self.print_generic_params(&generics.params);\n+                    self.space();\n+                }\n+\n+                self.print_constness(constness);\n+\n+                if let ast::ImplPolarity::Negative(_) = polarity {\n+                    self.word(\"!\");\n+                }\n+\n+                if let Some(ref t) = *of_trait {\n+                    self.print_trait_ref(t);\n+                    self.space();\n+                    self.word_space(\"for\");\n+                }\n+\n+                self.print_type(self_ty);\n+                self.print_where_clause(&generics.where_clause);\n+\n+                self.space();\n+                self.bopen();\n+                self.print_inner_attributes(&item.attrs);\n+                for impl_item in items {\n+                    self.print_assoc_item(impl_item);\n+                }\n+                let empty = item.attrs.is_empty() && items.is_empty();\n+                self.bclose(item.span, empty);\n+            }\n+            ast::ItemKind::Trait(box ast::Trait {\n+                is_auto,\n+                unsafety,\n+                ref generics,\n+                ref bounds,\n+                ref items,\n+                ..\n+            }) => {\n+                self.head(\"\");\n+                self.print_visibility(&item.vis);\n+                self.print_unsafety(unsafety);\n+                self.print_is_auto(is_auto);\n+                self.word_nbsp(\"trait\");\n+                self.print_ident(item.ident);\n+                self.print_generic_params(&generics.params);\n+                let mut real_bounds = Vec::with_capacity(bounds.len());\n+                for b in bounds.iter() {\n+                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n+                        self.space();\n+                        self.word_space(\"for ?\");\n+                        self.print_trait_ref(&ptr.trait_ref);\n+                    } else {\n+                        real_bounds.push(b.clone());\n+                    }\n+                }\n+                self.print_type_bounds(\":\", &real_bounds);\n+                self.print_where_clause(&generics.where_clause);\n+                self.word(\" \");\n+                self.bopen();\n+                self.print_inner_attributes(&item.attrs);\n+                for trait_item in items {\n+                    self.print_assoc_item(trait_item);\n+                }\n+                let empty = item.attrs.is_empty() && items.is_empty();\n+                self.bclose(item.span, empty);\n+            }\n+            ast::ItemKind::TraitAlias(ref generics, ref bounds) => {\n+                self.head(visibility_qualified(&item.vis, \"trait\"));\n+                self.print_ident(item.ident);\n+                self.print_generic_params(&generics.params);\n+                let mut real_bounds = Vec::with_capacity(bounds.len());\n+                // FIXME(durka) this seems to be some quite outdated syntax\n+                for b in bounds.iter() {\n+                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n+                        self.space();\n+                        self.word_space(\"for ?\");\n+                        self.print_trait_ref(&ptr.trait_ref);\n+                    } else {\n+                        real_bounds.push(b.clone());\n+                    }\n+                }\n+                self.nbsp();\n+                self.print_type_bounds(\"=\", &real_bounds);\n+                self.print_where_clause(&generics.where_clause);\n+                self.word(\";\");\n+                self.end(); // end inner head-block\n+                self.end(); // end outer head-block\n+            }\n+            ast::ItemKind::MacCall(ref mac) => {\n+                self.print_mac(mac);\n+                if mac.args.need_semicolon() {\n+                    self.word(\";\");\n+                }\n+            }\n+            ast::ItemKind::MacroDef(ref macro_def) => {\n+                self.print_mac_def(macro_def, &item.ident, &item.span, |state| {\n+                    state.print_visibility(&item.vis)\n+                });\n+            }\n+        }\n+        self.ann.post(self, AnnNode::Item(item))\n+    }\n+\n+    fn print_enum_def(\n+        &mut self,\n+        enum_definition: &ast::EnumDef,\n+        generics: &ast::Generics,\n+        ident: Ident,\n+        span: rustc_span::Span,\n+        visibility: &ast::Visibility,\n+    ) {\n+        self.head(visibility_qualified(visibility, \"enum\"));\n+        self.print_ident(ident);\n+        self.print_generic_params(&generics.params);\n+        self.print_where_clause(&generics.where_clause);\n+        self.space();\n+        self.print_variants(&enum_definition.variants, span)\n+    }\n+\n+    fn print_variants(&mut self, variants: &[ast::Variant], span: rustc_span::Span) {\n+        self.bopen();\n+        for v in variants {\n+            self.space_if_not_bol();\n+            self.maybe_print_comment(v.span.lo());\n+            self.print_outer_attributes(&v.attrs);\n+            self.ibox(INDENT_UNIT);\n+            self.print_variant(v);\n+            self.word(\",\");\n+            self.end();\n+            self.maybe_print_trailing_comment(v.span, None);\n+        }\n+        let empty = variants.is_empty();\n+        self.bclose(span, empty)\n+    }\n+\n+    crate fn print_visibility(&mut self, vis: &ast::Visibility) {\n+        match vis.kind {\n+            ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n+            ast::VisibilityKind::Crate(sugar) => match sugar {\n+                ast::CrateSugar::PubCrate => self.word_nbsp(\"pub(crate)\"),\n+                ast::CrateSugar::JustCrate => self.word_nbsp(\"crate\"),\n+            },\n+            ast::VisibilityKind::Restricted { ref path, .. } => {\n+                let path = Self::to_string(|s| s.print_path(path, false, 0));\n+                if path == \"self\" || path == \"super\" {\n+                    self.word_nbsp(format!(\"pub({})\", path))\n+                } else {\n+                    self.word_nbsp(format!(\"pub(in {})\", path))\n+                }\n+            }\n+            ast::VisibilityKind::Inherited => {}\n+        }\n+    }\n+\n+    fn print_defaultness(&mut self, defaultness: ast::Defaultness) {\n+        if let ast::Defaultness::Default(_) = defaultness {\n+            self.word_nbsp(\"default\");\n+        }\n+    }\n+\n+    fn print_record_struct_body(&mut self, fields: &[ast::FieldDef], span: rustc_span::Span) {\n+        self.nbsp();\n+        self.bopen();\n+\n+        let empty = fields.is_empty();\n+        if !empty {\n+            self.hardbreak_if_not_bol();\n+\n+            for field in fields {\n+                self.hardbreak_if_not_bol();\n+                self.maybe_print_comment(field.span.lo());\n+                self.print_outer_attributes(&field.attrs);\n+                self.print_visibility(&field.vis);\n+                self.print_ident(field.ident.unwrap());\n+                self.word_nbsp(\":\");\n+                self.print_type(&field.ty);\n+                self.word(\",\");\n+            }\n+        }\n+\n+        self.bclose(span, empty);\n+    }\n+\n+    fn print_struct(\n+        &mut self,\n+        struct_def: &ast::VariantData,\n+        generics: &ast::Generics,\n+        ident: Ident,\n+        span: rustc_span::Span,\n+        print_finalizer: bool,\n+    ) {\n+        self.print_ident(ident);\n+        self.print_generic_params(&generics.params);\n+        match struct_def {\n+            ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n+                if let ast::VariantData::Tuple(..) = struct_def {\n+                    self.popen();\n+                    self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n+                        s.maybe_print_comment(field.span.lo());\n+                        s.print_outer_attributes(&field.attrs);\n+                        s.print_visibility(&field.vis);\n+                        s.print_type(&field.ty)\n+                    });\n+                    self.pclose();\n+                }\n+                self.print_where_clause(&generics.where_clause);\n+                if print_finalizer {\n+                    self.word(\";\");\n+                }\n+                self.end();\n+                self.end(); // Close the outer-box.\n+            }\n+            ast::VariantData::Struct(ref fields, ..) => {\n+                self.print_where_clause(&generics.where_clause);\n+                self.print_record_struct_body(fields, span);\n+            }\n+        }\n+    }\n+\n+    crate fn print_variant(&mut self, v: &ast::Variant) {\n+        self.head(\"\");\n+        self.print_visibility(&v.vis);\n+        let generics = ast::Generics::default();\n+        self.print_struct(&v.data, &generics, v.ident, v.span, false);\n+        if let Some(ref d) = v.disr_expr {\n+            self.space();\n+            self.word_space(\"=\");\n+            self.print_expr(&d.value)\n+        }\n+    }\n+\n+    fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n+        let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n+        self.ann.pre(self, AnnNode::SubItem(id));\n+        self.hardbreak_if_not_bol();\n+        self.maybe_print_comment(span.lo());\n+        self.print_outer_attributes(attrs);\n+        match kind {\n+            ast::AssocItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n+                self.print_fn_full(sig, ident, generics, vis, *defaultness, body.as_deref(), attrs);\n+            }\n+            ast::AssocItemKind::Const(def, ty, body) => {\n+                self.print_item_const(ident, None, ty, body.as_deref(), vis, *def);\n+            }\n+            ast::AssocItemKind::TyAlias(box ast::TyAlias { defaultness, generics, bounds, ty }) => {\n+                self.print_associated_type(\n+                    ident,\n+                    generics,\n+                    bounds,\n+                    ty.as_deref(),\n+                    vis,\n+                    *defaultness,\n+                );\n+            }\n+            ast::AssocItemKind::MacCall(m) => {\n+                self.print_mac(m);\n+                if m.args.need_semicolon() {\n+                    self.word(\";\");\n+                }\n+            }\n+        }\n+        self.ann.post(self, AnnNode::SubItem(id))\n+    }\n+\n+    fn print_fn_full(\n+        &mut self,\n+        sig: &ast::FnSig,\n+        name: Ident,\n+        generics: &ast::Generics,\n+        vis: &ast::Visibility,\n+        defaultness: ast::Defaultness,\n+        body: Option<&ast::Block>,\n+        attrs: &[ast::Attribute],\n+    ) {\n+        if body.is_some() {\n+            self.head(\"\");\n+        }\n+        self.print_visibility(vis);\n+        self.print_defaultness(defaultness);\n+        self.print_fn(&sig.decl, sig.header, Some(name), generics);\n+        if let Some(body) = body {\n+            self.nbsp();\n+            self.print_block_with_attrs(body, attrs);\n+        } else {\n+            self.word(\";\");\n+        }\n+    }\n+\n+    crate fn print_fn(\n+        &mut self,\n+        decl: &ast::FnDecl,\n+        header: ast::FnHeader,\n+        name: Option<Ident>,\n+        generics: &ast::Generics,\n+    ) {\n+        self.print_fn_header_info(header);\n+        if let Some(name) = name {\n+            self.nbsp();\n+            self.print_ident(name);\n+        }\n+        self.print_generic_params(&generics.params);\n+        self.print_fn_params_and_ret(decl, false);\n+        self.print_where_clause(&generics.where_clause)\n+    }\n+\n+    crate fn print_fn_params_and_ret(&mut self, decl: &ast::FnDecl, is_closure: bool) {\n+        let (open, close) = if is_closure { (\"|\", \"|\") } else { (\"(\", \")\") };\n+        self.word(open);\n+        self.commasep(Inconsistent, &decl.inputs, |s, param| s.print_param(param, is_closure));\n+        self.word(close);\n+        self.print_fn_ret_ty(&decl.output)\n+    }\n+\n+    fn print_where_clause(&mut self, where_clause: &ast::WhereClause) {\n+        if where_clause.predicates.is_empty() && !where_clause.has_where_token {\n+            return;\n+        }\n+\n+        self.space();\n+        self.word_space(\"where\");\n+\n+        for (i, predicate) in where_clause.predicates.iter().enumerate() {\n+            if i != 0 {\n+                self.word_space(\",\");\n+            }\n+\n+            self.print_where_predicate(predicate);\n+        }\n+    }\n+\n+    pub fn print_where_predicate(&mut self, predicate: &ast::WherePredicate) {\n+        match predicate {\n+            ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                bound_generic_params,\n+                bounded_ty,\n+                bounds,\n+                ..\n+            }) => {\n+                self.print_formal_generic_params(bound_generic_params);\n+                self.print_type(bounded_ty);\n+                self.print_type_bounds(\":\", bounds);\n+            }\n+            ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n+                lifetime,\n+                bounds,\n+                ..\n+            }) => {\n+                self.print_lifetime_bounds(*lifetime, bounds);\n+            }\n+            ast::WherePredicate::EqPredicate(ast::WhereEqPredicate { lhs_ty, rhs_ty, .. }) => {\n+                self.print_type(lhs_ty);\n+                self.space();\n+                self.word_space(\"=\");\n+                self.print_type(rhs_ty);\n+            }\n+        }\n+    }\n+\n+    fn print_use_tree(&mut self, tree: &ast::UseTree) {\n+        match tree.kind {\n+            ast::UseTreeKind::Simple(rename, ..) => {\n+                self.print_path(&tree.prefix, false, 0);\n+                if let Some(rename) = rename {\n+                    self.space();\n+                    self.word_space(\"as\");\n+                    self.print_ident(rename);\n+                }\n+            }\n+            ast::UseTreeKind::Glob => {\n+                if !tree.prefix.segments.is_empty() {\n+                    self.print_path(&tree.prefix, false, 0);\n+                    self.word(\"::\");\n+                }\n+                self.word(\"*\");\n+            }\n+            ast::UseTreeKind::Nested(ref items) => {\n+                if tree.prefix.segments.is_empty() {\n+                    self.word(\"{\");\n+                } else {\n+                    self.print_path(&tree.prefix, false, 0);\n+                    self.word(\"::{\");\n+                }\n+                self.commasep(Inconsistent, &items, |this, &(ref tree, _)| {\n+                    this.print_use_tree(tree)\n+                });\n+                self.word(\"}\");\n+            }\n+        }\n+    }\n+}"}]}