{"sha": "522d52cef72dac365354e12e01e9ffac6c541220", "node_id": "C_kwDOAAsO6NoAKDUyMmQ1MmNlZjcyZGFjMzY1MzU0ZTEyZTAxZTlmZmFjNmM1NDEyMjA", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-05T05:12:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-05T05:12:55Z"}, "message": "Rollup merge of #98811 - RalfJung:interpret-alloc-range, r=oli-obk\n\nInterpret: AllocRange Debug impl, and use it more consistently\n\nThe two commits are pretty independent but it did not seem worth having two PRs for them.\nr? ``@oli-obk``", "tree": {"sha": "2438515270e52b1fe6bf8c3139793d492cced9ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2438515270e52b1fe6bf8c3139793d492cced9ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/522d52cef72dac365354e12e01e9ffac6c541220", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiw8hYCRBK7hj4Ov3rIwAAjvMIAGEM7g4h9Ov4TnoO40JmCqVT\ncdynQJB+2t2jLReZ1v300X9eqX9pdQRq5QTTWXiCk84CqsLfvoWyx54tMCbyx4VE\nxfcO043xKq2vQbTMIRyDxD+GvoifSqFT9gTOKvXgxh7PoHABF3MorGnHnjOtgBJC\nLNv2Wx+OurKB6pPMCv4TOGtJB0VY16TiQwYKYpjvMNPC/VDkM814TnmU0Ch4MYK0\ndSibohvsn/Q7kg96UHkAvZp0yXZ5s1y68eGZe2LfgIgT8NJGl9CMqtfk9ufB0u7c\nIfrSg5PcIvN5pNi8IjAuVNN/tvjRmDVxS3NqAaqevD0z5wwYwR1q7xL2zscFlVY=\n=5m7g\n-----END PGP SIGNATURE-----\n", "payload": "tree 2438515270e52b1fe6bf8c3139793d492cced9ed\nparent 6a9db39f6ccf25e97d0017a6921d95c3534bd714\nparent 0832d1d02280e17cfa083b068d2def4b1844cd10\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1656997975 +0530\ncommitter GitHub <noreply@github.com> 1656997975 +0530\n\nRollup merge of #98811 - RalfJung:interpret-alloc-range, r=oli-obk\n\nInterpret: AllocRange Debug impl, and use it more consistently\n\nThe two commits are pretty independent but it did not seem worth having two PRs for them.\nr? ``@oli-obk``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/522d52cef72dac365354e12e01e9ffac6c541220", "html_url": "https://github.com/rust-lang/rust/commit/522d52cef72dac365354e12e01e9ffac6c541220", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/522d52cef72dac365354e12e01e9ffac6c541220/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a9db39f6ccf25e97d0017a6921d95c3534bd714", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a9db39f6ccf25e97d0017a6921d95c3534bd714", "html_url": "https://github.com/rust-lang/rust/commit/6a9db39f6ccf25e97d0017a6921d95c3534bd714"}, {"sha": "0832d1d02280e17cfa083b068d2def4b1844cd10", "url": "https://api.github.com/repos/rust-lang/rust/commits/0832d1d02280e17cfa083b068d2def4b1844cd10", "html_url": "https://github.com/rust-lang/rust/commit/0832d1d02280e17cfa083b068d2def4b1844cd10"}], "stats": {"total": 112, "additions": 49, "deletions": 63}, "files": [{"sha": "509fe576893b7637baceceb7a190d3374339b3cf", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=522d52cef72dac365354e12e01e9ffac6c541220", "patch": "@@ -276,7 +276,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx> {\n         let (alloc_id, offset, tag) = self.ptr_get_alloc_id(ptr)?;\n-        trace!(\"deallocating: {}\", alloc_id);\n+        trace!(\"deallocating: {alloc_id:?}\");\n \n         if offset.bytes() != 0 {\n             throw_ub_format!(\n@@ -289,10 +289,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Deallocating global memory -- always an error\n             return Err(match self.tcx.get_global_alloc(alloc_id) {\n                 Some(GlobalAlloc::Function(..)) => {\n-                    err_ub_format!(\"deallocating {}, which is a function\", alloc_id)\n+                    err_ub_format!(\"deallocating {alloc_id:?}, which is a function\")\n                 }\n                 Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n-                    err_ub_format!(\"deallocating {}, which is static memory\", alloc_id)\n+                    err_ub_format!(\"deallocating {alloc_id:?}, which is static memory\")\n                 }\n                 None => err_ub!(PointerUseAfterFree(alloc_id)),\n             }\n@@ -302,21 +302,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         debug!(?alloc);\n \n         if alloc.mutability == Mutability::Not {\n-            throw_ub_format!(\"deallocating immutable allocation {}\", alloc_id);\n+            throw_ub_format!(\"deallocating immutable allocation {alloc_id:?}\");\n         }\n         if alloc_kind != kind {\n             throw_ub_format!(\n-                \"deallocating {}, which is {} memory, using {} deallocation operation\",\n-                alloc_id,\n-                alloc_kind,\n-                kind\n+                \"deallocating {alloc_id:?}, which is {alloc_kind} memory, using {kind} deallocation operation\"\n             );\n         }\n         if let Some((size, align)) = old_size_and_align {\n             if size != alloc.size() || align != alloc.align {\n                 throw_ub_format!(\n-                    \"incorrect layout on deallocation: {} has size {} and alignment {}, but gave size {} and alignment {}\",\n-                    alloc_id,\n+                    \"incorrect layout on deallocation: {alloc_id:?} has size {} and alignment {}, but gave size {} and alignment {}\",\n                     alloc.size().bytes(),\n                     alloc.align.bytes(),\n                     size.bytes(),\n@@ -815,7 +811,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n                 continue;\n             }\n \n-            write!(fmt, \"{}\", id)?;\n+            write!(fmt, \"{id:?}\")?;\n             match self.ecx.memory.alloc_map.get(id) {\n                 Some(&(kind, ref alloc)) => {\n                     // normal alloc\n@@ -859,25 +855,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n \n /// Reading and writing.\n impl<'tcx, 'a, Tag: Provenance, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n+    /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn write_scalar(\n         &mut self,\n         range: AllocRange,\n         val: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx> {\n         let range = self.range.subrange(range);\n-        debug!(\n-            \"write_scalar in {} at {:#x}, size {}: {:?}\",\n-            self.alloc_id,\n-            range.start.bytes(),\n-            range.size.bytes(),\n-            val\n-        );\n+        debug!(\"write_scalar at {:?}{range:?}: {val:?}\", self.alloc_id);\n         Ok(self\n             .alloc\n             .write_scalar(&self.tcx, range, val)\n             .map_err(|e| e.to_interp_error(self.alloc_id))?)\n     }\n \n+    /// `offset` is relative to this allocation reference, not the base of the allocation.\n     pub fn write_ptr_sized(\n         &mut self,\n         offset: Size,\n@@ -896,6 +888,7 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n }\n \n impl<'tcx, 'a, Tag: Provenance, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n+    /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn read_scalar(\n         &self,\n         range: AllocRange,\n@@ -906,31 +899,24 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n             .alloc\n             .read_scalar(&self.tcx, range, read_provenance)\n             .map_err(|e| e.to_interp_error(self.alloc_id))?;\n-        debug!(\n-            \"read_scalar in {} at {:#x}, size {}: {:?}\",\n-            self.alloc_id,\n-            range.start.bytes(),\n-            range.size.bytes(),\n-            res\n-        );\n+        debug!(\"read_scalar at {:?}{range:?}: {res:?}\", self.alloc_id);\n         Ok(res)\n     }\n \n-    pub fn read_integer(\n-        &self,\n-        offset: Size,\n-        size: Size,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-        self.read_scalar(alloc_range(offset, size), /*read_provenance*/ false)\n+    /// `range` is relative to this allocation reference, not the base of the allocation.\n+    pub fn read_integer(&self, range: AllocRange) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+        self.read_scalar(range, /*read_provenance*/ false)\n     }\n \n+    /// `offset` is relative to this allocation reference, not the base of the allocation.\n     pub fn read_pointer(&self, offset: Size) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         self.read_scalar(\n             alloc_range(offset, self.tcx.data_layout().pointer_size),\n             /*read_provenance*/ true,\n         )\n     }\n \n+    /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn check_bytes(\n         &self,\n         range: AllocRange,"}, {"sha": "22c23df7b1ab34185c1a5ba01604e76faad1f180", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=522d52cef72dac365354e12e01e9ffac6c541220", "patch": "@@ -1,6 +1,6 @@\n use std::convert::TryFrom;\n \n-use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic};\n+use rustc_middle::mir::interpret::{alloc_range, InterpResult, Pointer, PointerArithmetic};\n use rustc_middle::ty::{\n     self, Ty, TyCtxt, COMMON_VTABLE_ENTRIES_ALIGN, COMMON_VTABLE_ENTRIES_DROPINPLACE,\n     COMMON_VTABLE_ENTRIES_SIZE,\n@@ -102,18 +102,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             )?\n             .expect(\"cannot be a ZST\");\n         let size = vtable\n-            .read_integer(\n+            .read_integer(alloc_range(\n                 pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_SIZE).unwrap(),\n                 pointer_size,\n-            )?\n+            ))?\n             .check_init()?;\n         let size = size.to_machine_usize(self)?;\n         let size = Size::from_bytes(size);\n         let align = vtable\n-            .read_integer(\n+            .read_integer(alloc_range(\n                 pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_ALIGN).unwrap(),\n                 pointer_size,\n-            )?\n+            ))?\n             .check_init()?;\n         let align = align.to_machine_usize(self)?;\n         let align = Align::from_bytes(align).map_err(|e| err_ub!(InvalidVtableAlignment(e)))?;"}, {"sha": "1bbd71c3f1f517d45d1d1e7fbd1c762701c3cf47", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=522d52cef72dac365354e12e01e9ffac6c541220", "patch": "@@ -160,12 +160,18 @@ impl AllocError {\n }\n \n /// The information that makes up a memory access: offset and size.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone)]\n pub struct AllocRange {\n     pub start: Size,\n     pub size: Size,\n }\n \n+impl fmt::Debug for AllocRange {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"[{:#x}..{:#x}]\", self.start.bytes(), self.end().bytes())\n+    }\n+}\n+\n /// Free-starting constructor for less syntactic overhead.\n #[inline(always)]\n pub fn alloc_range(start: Size, size: Size) -> AllocRange {"}, {"sha": "f30769248c0747fb3c2e6922f94d2c3dafe0f525", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=522d52cef72dac365354e12e01e9ffac6c541220", "patch": "@@ -334,45 +334,39 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n                 p,\n             ),\n             PointerUseAfterFree(a) => {\n-                write!(f, \"pointer to {} was dereferenced after this allocation got freed\", a)\n+                write!(f, \"pointer to {a:?} was dereferenced after this allocation got freed\")\n             }\n             PointerOutOfBounds { alloc_id, alloc_size, ptr_offset, ptr_size: Size::ZERO, msg } => {\n                 write!(\n                     f,\n-                    \"{}{alloc_id} has size {alloc_size}, so pointer at offset {ptr_offset} is out-of-bounds\",\n-                    msg,\n-                    alloc_id = alloc_id,\n+                    \"{msg}{alloc_id:?} has size {alloc_size}, so pointer at offset {ptr_offset} is out-of-bounds\",\n                     alloc_size = alloc_size.bytes(),\n-                    ptr_offset = ptr_offset,\n                 )\n             }\n             PointerOutOfBounds { alloc_id, alloc_size, ptr_offset, ptr_size, msg } => write!(\n                 f,\n-                \"{}{alloc_id} has size {alloc_size}, so pointer to {ptr_size} byte{ptr_size_p} starting at offset {ptr_offset} is out-of-bounds\",\n-                msg,\n-                alloc_id = alloc_id,\n+                \"{msg}{alloc_id:?} has size {alloc_size}, so pointer to {ptr_size} byte{ptr_size_p} starting at offset {ptr_offset} is out-of-bounds\",\n                 alloc_size = alloc_size.bytes(),\n                 ptr_size = ptr_size.bytes(),\n                 ptr_size_p = pluralize!(ptr_size.bytes()),\n-                ptr_offset = ptr_offset,\n             ),\n             DanglingIntPointer(0, CheckInAllocMsg::InboundsTest) => {\n                 write!(f, \"null pointer is not a valid pointer for this operation\")\n             }\n             DanglingIntPointer(0, msg) => {\n-                write!(f, \"{}null pointer is not a valid pointer\", msg)\n+                write!(f, \"{msg}null pointer is not a valid pointer\")\n             }\n             DanglingIntPointer(i, msg) => {\n-                write!(f, \"{}0x{:x} is not a valid pointer\", msg, i)\n+                write!(f, \"{msg}{i:#x} is not a valid pointer\")\n             }\n             AlignmentCheckFailed { required, has } => write!(\n                 f,\n                 \"accessing memory with alignment {}, but alignment {} is required\",\n                 has.bytes(),\n                 required.bytes()\n             ),\n-            WriteToReadOnly(a) => write!(f, \"writing to {} which is read-only\", a),\n-            DerefFunctionPointer(a) => write!(f, \"accessing {} which contains a function\", a),\n+            WriteToReadOnly(a) => write!(f, \"writing to {a:?} which is read-only\"),\n+            DerefFunctionPointer(a) => write!(f, \"accessing {a:?} which contains a function\"),\n             ValidationFailure { path: None, msg } => {\n                 write!(f, \"constructing invalid value: {}\", msg)\n             }"}, {"sha": "698024b23301ea054e9f71dabe38c86525bc8898", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=522d52cef72dac365354e12e01e9ffac6c541220", "patch": "@@ -190,11 +190,7 @@ impl fmt::Debug for AllocId {\n     }\n }\n \n-impl fmt::Display for AllocId {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Debug::fmt(self, f)\n-    }\n-}\n+// No \"Display\" since AllocIds are not usually user-visible.\n \n #[derive(TyDecodable, TyEncodable)]\n enum AllocDiscriminant {\n@@ -470,7 +466,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             return alloc_id;\n         }\n         let id = alloc_map.reserve();\n-        debug!(\"creating alloc {:?} with id {}\", alloc, id);\n+        debug!(\"creating alloc {alloc:?} with id {id:?}\");\n         alloc_map.alloc_map.insert(id, alloc.clone());\n         alloc_map.dedup.insert(alloc, id);\n         id\n@@ -538,15 +534,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn global_alloc(self, id: AllocId) -> GlobalAlloc<'tcx> {\n         match self.get_global_alloc(id) {\n             Some(alloc) => alloc,\n-            None => bug!(\"could not find allocation for {}\", id),\n+            None => bug!(\"could not find allocation for {id:?}\"),\n         }\n     }\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n     pub fn set_alloc_id_memory(self, id: AllocId, mem: ConstAllocation<'tcx>) {\n         if let Some(old) = self.alloc_map.lock().alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n-            bug!(\"tried to set allocation ID {}, but it was already existing as {:#?}\", id, old);\n+            bug!(\"tried to set allocation ID {id:?}, but it was already existing as {old:#?}\");\n         }\n     }\n "}, {"sha": "81d744107fd569a288423ff27a2fa02039481b21", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=522d52cef72dac365354e12e01e9ffac6c541220", "patch": "@@ -144,7 +144,7 @@ impl Provenance for AllocId {\n         }\n         // Print offset only if it is non-zero.\n         if ptr.offset.bytes() > 0 {\n-            write!(f, \"+0x{:x}\", ptr.offset.bytes())?;\n+            write!(f, \"+{:#x}\", ptr.offset.bytes())?;\n         }\n         Ok(())\n     }\n@@ -181,7 +181,7 @@ impl<Tag: Provenance> fmt::Debug for Pointer<Option<Tag>> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.provenance {\n             Some(tag) => Provenance::fmt(&Pointer::new(tag, self.offset), f),\n-            None => write!(f, \"0x{:x}\", self.offset.bytes()),\n+            None => write!(f, \"{:#x}\", self.offset.bytes()),\n         }\n     }\n }"}, {"sha": "8ecbb5ab0b31f70f068a02d770e3c6be2fae10d3", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=522d52cef72dac365354e12e01e9ffac6c541220", "patch": "@@ -167,7 +167,7 @@ impl<Tag: Provenance> fmt::LowerHex for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(ptr, _size) => write!(f, \"pointer to {:?}\", ptr),\n-            Scalar::Int(int) => write!(f, \"0x{:x}\", int),\n+            Scalar::Int(int) => write!(f, \"{:#x}\", int),\n         }\n     }\n }"}, {"sha": "24c6cd91d0a54cfef880baf7fdb5686409544773", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=522d52cef72dac365354e12e01e9ffac6c541220", "patch": "@@ -716,12 +716,12 @@ pub fn write_allocations<'tcx>(\n                 }\n                 write!(w, \"{}\", display_allocation(tcx, alloc.inner()))\n             };\n-        write!(w, \"\\n{}\", id)?;\n+        write!(w, \"\\n{id:?}\")?;\n         match tcx.get_global_alloc(id) {\n             // This can't really happen unless there are bugs, but it doesn't cost us anything to\n             // gracefully handle it and allow buggy rustc to be debugged via allocation printing.\n             None => write!(w, \" (deallocated)\")?,\n-            Some(GlobalAlloc::Function(inst)) => write!(w, \" (fn: {})\", inst)?,\n+            Some(GlobalAlloc::Function(inst)) => write!(w, \" (fn: {inst})\")?,\n             Some(GlobalAlloc::Static(did)) if !tcx.is_foreign_item(did) => {\n                 match tcx.eval_static_initializer(did) {\n                     Ok(alloc) => {"}, {"sha": "c7c2692281ebb9580ac2871dcfa874403eb9ccaf", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d52cef72dac365354e12e01e9ffac6c541220/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=522d52cef72dac365354e12e01e9ffac6c541220", "patch": "@@ -452,6 +452,10 @@ impl fmt::Debug for ScalarInt {\n impl fmt::LowerHex for ScalarInt {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.check_data();\n+        if f.alternate() {\n+            // Like regular ints, alternate flag adds leading `0x`.\n+            write!(f, \"0x\")?;\n+        }\n         // Format as hex number wide enough to fit any value of the given `size`.\n         // So data=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n         // Using a block `{self.data}` here to force a copy instead of using `self.data`"}]}