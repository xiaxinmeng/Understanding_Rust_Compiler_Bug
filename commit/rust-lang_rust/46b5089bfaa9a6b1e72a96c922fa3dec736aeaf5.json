{"sha": "46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "node_id": "C_kwDOAAsO6NoAKDQ2YjUwODliZmFhOWE2YjFlNzJhOTZjOTIyZmEzZGVjNzM2YWVhZjU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-03T12:21:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-03T12:21:18Z"}, "message": "Merge #11399\n\n11399: Fix assoc type shorthand from method bounds r=flodiebold a=flodiebold\n\nIn code like this:\r\n```rust\r\nimpl<T> Option<T> {\r\n    fn as_deref(&self) -> T::Target where T: Deref {}\r\n}\r\n```\r\n\r\nwhen trying to resolve the associated type `T::Target`, we were only\r\nlooking at the bounds on the impl (where the type parameter is defined),\r\nbut the method can add additional bounds that can also be used to refer\r\nto associated types. Hence, when resolving such an associated type, it's\r\nnot enough to just know the type parameter T, we also need to know\r\nexactly where we are currently.\r\n\r\nThis fixes #11364 (beta apparently switched some bounds around).\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "9c2b6398f5418b07c6f0a1d28d91cffa07d0ce4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c2b6398f5418b07c6f0a1d28d91cffa07d0ce4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh+8i+CRBK7hj4Ov3rIwAA7pEIAIFt/gb7K4Fp7qvvC6GELo8i\nWdsvaL1QfsfHep3wiWiuL19MFqPDlkoKtmatfT4QR9+uGCMozXL5UHz1FfDYLrz/\nAuqHvk2C1FZAok3CLnakHulEX4QXZOT+gq/xc2F4WDNl8FblKjK5WN7XY8DdSRku\nMSpjRttupUVoCcXFp8mmU7O5gDNS9gxQLWrEmDT1REyTtUZD/PT7NyNqOccMQaLH\nx7i7F64eK5Hd83o6cGrFPyaysj2B6Qh259aW1ZGpm7ZfFYzvYlp13HdJIiunrpBN\n/YWrP8uMoGpuh27xUIgmaRNIey+gM1q/Tyj85RN4rSrB539yM7bM4v5W/4VrPZc=\n=VO/Q\n-----END PGP SIGNATURE-----\n", "payload": "tree 9c2b6398f5418b07c6f0a1d28d91cffa07d0ce4d\nparent 9cb6e3a190f7781cb7e243837b47e6889d204d52\nparent 4ed5fe1554ad0133b7eaec0c93c72a69b2aab271\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1643890878 +0000\ncommitter GitHub <noreply@github.com> 1643890878 +0000\n\nMerge #11399\n\n11399: Fix assoc type shorthand from method bounds r=flodiebold a=flodiebold\n\nIn code like this:\r\n```rust\r\nimpl<T> Option<T> {\r\n    fn as_deref(&self) -> T::Target where T: Deref {}\r\n}\r\n```\r\n\r\nwhen trying to resolve the associated type `T::Target`, we were only\r\nlooking at the bounds on the impl (where the type parameter is defined),\r\nbut the method can add additional bounds that can also be used to refer\r\nto associated types. Hence, when resolving such an associated type, it's\r\nnot enough to just know the type parameter T, we also need to know\r\nexactly where we are currently.\r\n\r\nThis fixes #11364 (beta apparently switched some bounds around).\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "html_url": "https://github.com/rust-lang/rust/commit/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cb6e3a190f7781cb7e243837b47e6889d204d52", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cb6e3a190f7781cb7e243837b47e6889d204d52", "html_url": "https://github.com/rust-lang/rust/commit/9cb6e3a190f7781cb7e243837b47e6889d204d52"}, {"sha": "4ed5fe1554ad0133b7eaec0c93c72a69b2aab271", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ed5fe1554ad0133b7eaec0c93c72a69b2aab271", "html_url": "https://github.com/rust-lang/rust/commit/4ed5fe1554ad0133b7eaec0c93c72a69b2aab271"}], "stats": {"total": 174, "additions": 107, "deletions": 67}, "files": [{"sha": "d94f55e32627f6147620a86acdff44757d66d728", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "patch": "@@ -239,7 +239,7 @@ impl HirDisplay for TypeParam {\n             return Ok(());\n         }\n \n-        let bounds = f.db.generic_predicates_for_param(self.id, None);\n+        let bounds = f.db.generic_predicates_for_param(self.id.parent, self.id, None);\n         let substs = TyBuilder::type_params_subst(f.db, self.id.parent);\n         let predicates: Vec<_> =\n             bounds.iter().cloned().map(|b| b.substitute(Interner, &substs)).collect();"}, {"sha": "918cadc8696d3bc249271c6a0ebaffb6c95b80cd", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "patch": "@@ -2235,8 +2235,11 @@ impl TypeParam {\n         Type::new_with_resolver_inner(db, krate, &resolver, ty)\n     }\n \n+    /// FIXME: this only lists trait bounds from the item defining the type\n+    /// parameter, not additional bounds that might be added e.g. by a method if\n+    /// the parameter comes from an impl!\n     pub fn trait_bounds(self, db: &dyn HirDatabase) -> Vec<Trait> {\n-        db.generic_predicates_for_param(self.id, None)\n+        db.generic_predicates_for_param(self.id.parent, self.id, None)\n             .iter()\n             .filter_map(|pred| match &pred.skip_binders().skip_binders() {\n                 hir_ty::WhereClause::Implemented(trait_ref) => {"}, {"sha": "9ac88e260c408191ee1a230b6de3c1477871b590", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "patch": "@@ -12,7 +12,7 @@ use hir_def::{\n     AsMacroCall, FunctionId, TraitId, VariantId,\n };\n use hir_expand::{name::AsName, ExpansionInfo, MacroCallId};\n-use hir_ty::{associated_type_shorthand_candidates, Interner};\n+use hir_ty::Interner;\n use itertools::Itertools;\n use rustc_hash::{FxHashMap, FxHashSet};\n use smallvec::{smallvec, SmallVec};\n@@ -50,7 +50,7 @@ pub enum PathResolution {\n }\n \n impl PathResolution {\n-    fn in_type_ns(&self) -> Option<TypeNs> {\n+    pub(crate) fn in_type_ns(&self) -> Option<TypeNs> {\n         match self {\n             PathResolution::Def(ModuleDef::Adt(adt)) => Some(TypeNs::AdtId((*adt).into())),\n             PathResolution::Def(ModuleDef::BuiltinType(builtin)) => {\n@@ -80,18 +80,6 @@ impl PathResolution {\n             }\n         }\n     }\n-\n-    /// Returns an iterator over associated types that may be specified after this path (using\n-    /// `Ty::Assoc` syntax).\n-    pub fn assoc_type_shorthand_candidates<R>(\n-        &self,\n-        db: &dyn HirDatabase,\n-        mut cb: impl FnMut(&Name, TypeAlias) -> Option<R>,\n-    ) -> Option<R> {\n-        associated_type_shorthand_candidates(db, self.in_type_ns()?, |name, _, id| {\n-            cb(name, id.into())\n-        })\n-    }\n }\n \n #[derive(Debug)]\n@@ -1314,4 +1302,20 @@ impl<'a> SemanticsScope<'a> {\n         let path = Path::from_src(path.clone(), &ctx)?;\n         resolve_hir_path(self.db, &self.resolver, &path)\n     }\n+\n+    /// Iterates over associated types that may be specified after the given path (using\n+    /// `Ty::Assoc` syntax).\n+    pub fn assoc_type_shorthand_candidates<R>(\n+        &self,\n+        resolution: &PathResolution,\n+        mut cb: impl FnMut(&Name, TypeAlias) -> Option<R>,\n+    ) -> Option<R> {\n+        let def = self.resolver.generic_def()?;\n+        hir_ty::associated_type_shorthand_candidates(\n+            self.db,\n+            def,\n+            resolution.in_type_ns()?,\n+            |name, _, id| cb(name, id.into()),\n+        )\n+    }\n }"}, {"sha": "03e4420985ed4bc868f2343c1dbe9435668c8dc6", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "patch": "@@ -619,9 +619,15 @@ fn resolve_hir_path_(\n             TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n         };\n         match unresolved {\n-            Some(unresolved) => res\n-                .assoc_type_shorthand_candidates(db, |name, alias| {\n-                    (name == unresolved.name).then(|| alias)\n+            Some(unresolved) => resolver\n+                .generic_def()\n+                .and_then(|def| {\n+                    hir_ty::associated_type_shorthand_candidates(\n+                        db,\n+                        def,\n+                        res.in_type_ns()?,\n+                        |name, _, id| (name == unresolved.name).then(|| id),\n+                    )\n                 })\n                 .map(TypeAlias::from)\n                 .map(Into::into)"}, {"sha": "c3b9255baf4206c47cca81484e00781f8b449b40", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "patch": "@@ -60,6 +60,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::cycle(crate::lower::generic_predicates_for_param_recover)]\n     fn generic_predicates_for_param(\n         &self,\n+        def: GenericDefId,\n         param_id: TypeParamId,\n         assoc_name: Option<Name>,\n     ) -> Arc<[Binders<QuantifiedWhereClause>]>;"}, {"sha": "55b1a67ea7bad9e6a7d931a32f562de126b45ac3", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 53, "deletions": 46, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "patch": "@@ -530,49 +530,50 @@ impl<'a> TyLoweringContext<'a> {\n     }\n \n     fn select_associated_type(&self, res: Option<TypeNs>, segment: PathSegment<'_>) -> Ty {\n-        if let Some(res) = res {\n-            let ty = named_associated_type_shorthand_candidates(\n-                self.db,\n-                res,\n-                Some(segment.name.clone()),\n-                move |name, t, associated_ty| {\n-                    if name == segment.name {\n-                        let substs = match self.type_param_mode {\n-                            TypeParamLoweringMode::Placeholder => {\n-                                // if we're lowering to placeholders, we have to put\n-                                // them in now\n-                                let generics = generics(\n-                                    self.db.upcast(),\n-                                    self.resolver.generic_def().expect(\n-                                        \"there should be generics if there's a generic param\",\n-                                    ),\n-                                );\n-                                let s = generics.type_params_subst(self.db);\n-                                s.apply(t.substitution.clone(), Interner)\n-                            }\n-                            TypeParamLoweringMode::Variable => t.substitution.clone(),\n-                        };\n-                        // We need to shift in the bound vars, since\n-                        // associated_type_shorthand_candidates does not do that\n-                        let substs = substs.shifted_in_from(Interner, self.in_binders);\n-                        // FIXME handle type parameters on the segment\n-                        Some(\n-                            TyKind::Alias(AliasTy::Projection(ProjectionTy {\n-                                associated_ty_id: to_assoc_type_id(associated_ty),\n-                                substitution: substs,\n-                            }))\n-                            .intern(Interner),\n-                        )\n-                    } else {\n-                        None\n-                    }\n-                },\n-            );\n+        let (def, res) = match (self.resolver.generic_def(), res) {\n+            (Some(def), Some(res)) => (def, res),\n+            _ => return TyKind::Error.intern(Interner),\n+        };\n+        let ty = named_associated_type_shorthand_candidates(\n+            self.db,\n+            def,\n+            res,\n+            Some(segment.name.clone()),\n+            move |name, t, associated_ty| {\n+                if name == segment.name {\n+                    let substs = match self.type_param_mode {\n+                        TypeParamLoweringMode::Placeholder => {\n+                            // if we're lowering to placeholders, we have to put\n+                            // them in now\n+                            let generics = generics(\n+                                self.db.upcast(),\n+                                self.resolver\n+                                    .generic_def()\n+                                    .expect(\"there should be generics if there's a generic param\"),\n+                            );\n+                            let s = generics.type_params_subst(self.db);\n+                            s.apply(t.substitution.clone(), Interner)\n+                        }\n+                        TypeParamLoweringMode::Variable => t.substitution.clone(),\n+                    };\n+                    // We need to shift in the bound vars, since\n+                    // associated_type_shorthand_candidates does not do that\n+                    let substs = substs.shifted_in_from(Interner, self.in_binders);\n+                    // FIXME handle type parameters on the segment\n+                    Some(\n+                        TyKind::Alias(AliasTy::Projection(ProjectionTy {\n+                            associated_ty_id: to_assoc_type_id(associated_ty),\n+                            substitution: substs,\n+                        }))\n+                        .intern(Interner),\n+                    )\n+                } else {\n+                    None\n+                }\n+            },\n+        );\n \n-            ty.unwrap_or_else(|| TyKind::Error.intern(Interner))\n-        } else {\n-            TyKind::Error.intern(Interner)\n-        }\n+        ty.unwrap_or_else(|| TyKind::Error.intern(Interner))\n     }\n \n     fn lower_path_inner(\n@@ -934,14 +935,18 @@ pub fn callable_item_sig(db: &dyn HirDatabase, def: CallableDefId) -> PolyFnSig\n \n pub fn associated_type_shorthand_candidates<R>(\n     db: &dyn HirDatabase,\n+    def: GenericDefId,\n     res: TypeNs,\n     cb: impl FnMut(&Name, &TraitRef, TypeAliasId) -> Option<R>,\n ) -> Option<R> {\n-    named_associated_type_shorthand_candidates(db, res, None, cb)\n+    named_associated_type_shorthand_candidates(db, def, res, None, cb)\n }\n \n fn named_associated_type_shorthand_candidates<R>(\n     db: &dyn HirDatabase,\n+    // If the type parameter is defined in an impl and we're in a method, there\n+    // might be additional where clauses to consider\n+    def: GenericDefId,\n     res: TypeNs,\n     assoc_name: Option<Name>,\n     mut cb: impl FnMut(&Name, &TraitRef, TypeAliasId) -> Option<R>,\n@@ -968,7 +973,7 @@ fn named_associated_type_shorthand_candidates<R>(\n             db.impl_trait(impl_id)?.into_value_and_skipped_binders().0,\n         ),\n         TypeNs::GenericParam(param_id) => {\n-            let predicates = db.generic_predicates_for_param(param_id, assoc_name);\n+            let predicates = db.generic_predicates_for_param(def, param_id, assoc_name);\n             let res = predicates.iter().find_map(|pred| match pred.skip_binders().skip_binders() {\n                 // FIXME: how to correctly handle higher-ranked bounds here?\n                 WhereClause::Implemented(tr) => search(\n@@ -1030,13 +1035,14 @@ pub(crate) fn field_types_query(\n /// these are fine: `T: Foo<U::Item>, U: Foo<()>`.\n pub(crate) fn generic_predicates_for_param_query(\n     db: &dyn HirDatabase,\n+    def: GenericDefId,\n     param_id: TypeParamId,\n     assoc_name: Option<Name>,\n ) -> Arc<[Binders<QuantifiedWhereClause>]> {\n-    let resolver = param_id.parent.resolver(db.upcast());\n+    let resolver = def.resolver(db.upcast());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n-    let generics = generics(db.upcast(), param_id.parent);\n+    let generics = generics(db.upcast(), def);\n     let mut predicates: Vec<_> = resolver\n         .where_predicates_in_scope()\n         // we have to filter out all other predicates *first*, before attempting to lower them\n@@ -1098,6 +1104,7 @@ pub(crate) fn generic_predicates_for_param_query(\n pub(crate) fn generic_predicates_for_param_recover(\n     _db: &dyn HirDatabase,\n     _cycle: &[String],\n+    _def: &GenericDefId,\n     _param_id: &TypeParamId,\n     _assoc_name: &Option<Name>,\n ) -> Arc<[Binders<QuantifiedWhereClause>]> {"}, {"sha": "c2669646e224566e18e9ad61539d73a058912b61", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "patch": "@@ -392,6 +392,25 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn associated_type_shorthand_from_method_bound() {\n+    check_types(\n+        r#\"\n+trait Iterable {\n+    type Item;\n+}\n+struct S<T>;\n+impl<T> S<T> {\n+    fn foo(self) -> T::Item where T: Iterable { loop {} }\n+}\n+fn test<T: Iterable>() {\n+    let s: S<T>;\n+    s.foo();\n+ // ^^^^^^^ Iterable::Item<T>\n+}\"#,\n+    );\n+}\n+\n #[test]\n fn infer_associated_type_bound() {\n     check_types("}, {"sha": "c5646e08e6cf8e7fde930c3e9d63f82998251799", "filename": "crates/hir_ty/src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "patch": "@@ -83,7 +83,7 @@ fn direct_super_trait_refs(db: &dyn HirDatabase, trait_ref: &TraitRef) -> Vec<Tr\n         Some(p) => TypeParamId { parent: trait_ref.hir_trait_id().into(), local_id: p },\n         None => return Vec::new(),\n     };\n-    db.generic_predicates_for_param(trait_self, None)\n+    db.generic_predicates_for_param(trait_self.parent, trait_self, None)\n         .iter()\n         .filter_map(|pred| {\n             pred.as_ref().filter_map(|pred| match pred.skip_binders() {"}, {"sha": "2c6899ff0cd93a2e034f35f6f98fb90da25a9ed7", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "patch": "@@ -119,7 +119,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n \n     if !matches!(kind, Some(PathKind::Pat)) {\n         // Add associated types on type parameters and `Self`.\n-        resolution.assoc_type_shorthand_candidates(ctx.db, |_, alias| {\n+        ctx.scope.assoc_type_shorthand_candidates(&resolution, |_, alias| {\n             acc.add_type_alias(ctx, alias);\n             None::<()>\n         });"}]}