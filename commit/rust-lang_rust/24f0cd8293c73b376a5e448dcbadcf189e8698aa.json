{"sha": "24f0cd8293c73b376a5e448dcbadcf189e8698aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZjBjZDgyOTNjNzNiMzc2YTVlNDQ4ZGNiYWRjZjE4OWU4Njk4YWE=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2021-01-22T22:29:51Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2021-01-22T22:29:51Z"}, "message": "replace_if_let_with_match: don't assume sad pattern", "tree": {"sha": "b71a6ee26c86248d3e8ddb779b3194851f3c52d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b71a6ee26c86248d3e8ddb779b3194851f3c52d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24f0cd8293c73b376a5e448dcbadcf189e8698aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24f0cd8293c73b376a5e448dcbadcf189e8698aa", "html_url": "https://github.com/rust-lang/rust/commit/24f0cd8293c73b376a5e448dcbadcf189e8698aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24f0cd8293c73b376a5e448dcbadcf189e8698aa/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f301da3c3d1c73dd9d438cb0736e23430287dba7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f301da3c3d1c73dd9d438cb0736e23430287dba7", "html_url": "https://github.com/rust-lang/rust/commit/f301da3c3d1c73dd9d438cb0736e23430287dba7"}], "stats": {"total": 105, "additions": 103, "deletions": 2}, "files": [{"sha": "abebd4b6a4a89dfaff1d564d38cff0efa51fbee2", "filename": "crates/assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 88, "deletions": 2, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/24f0cd8293c73b376a5e448dcbadcf189e8698aa/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24f0cd8293c73b376a5e448dcbadcf189e8698aa/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=24f0cd8293c73b376a5e448dcbadcf189e8698aa", "patch": "@@ -5,7 +5,7 @@ use syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n-        make,\n+        make, Pat,\n     },\n     AstNode,\n };\n@@ -66,7 +66,13 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext)\n                         .sema\n                         .type_of_pat(&pat)\n                         .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n-                        .map(|it| it.sad_pattern())\n+                        .map(|it| {\n+                            if does_pat_match_variant(&pat, &it.sad_pattern()) {\n+                                it.happy_pattern()\n+                            } else {\n+                                it.sad_pattern()\n+                            }\n+                        })\n                         .unwrap_or_else(|| make::wildcard_pat().into());\n                     let else_expr = unwrap_trivial_block(else_block);\n                     make::match_arm(vec![pattern], else_expr)\n@@ -81,6 +87,26 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext)\n     )\n }\n \n+fn does_pat_match_variant(pat: &Pat, var: &Pat) -> bool {\n+    let first_node_text = |pat: &Pat| pat.syntax().first_child().map(|node| node.text());\n+\n+    let pat_head = match pat {\n+        Pat::IdentPat(bind_pat) => {\n+            if let Some(p) = bind_pat.pat() {\n+                first_node_text(&p)\n+            } else {\n+                return pat.syntax().text() == var.syntax().text();\n+            }\n+        }\n+        pat => first_node_text(pat),\n+    };\n+\n+    let var_head = first_node_text(var);\n+    println!(\"{:?} {:?}\", pat_head, var_head);\n+\n+    pat_head == var_head\n+}\n+\n // Assist: replace_match_with_if_let\n //\n // Replaces a binary `match` with a wildcard pattern and no guards with an `if let` expression.\n@@ -278,6 +304,36 @@ fn foo(x: Option<i32>) {\n         );\n     }\n \n+    #[test]\n+    fn special_case_inverted_option() {\n+        check_assist(\n+            replace_if_let_with_match,\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn foo(x: Option<i32>) {\n+    $0if let None = x {\n+        println!(\"none\")\n+    } else {\n+        println!(\"some\")\n+    }\n+}\n+           \"#,\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn foo(x: Option<i32>) {\n+    match x {\n+        None => println!(\"none\"),\n+        Some(_) => println!(\"some\"),\n+    }\n+}\n+           \"#,\n+        );\n+    }\n+\n     #[test]\n     fn special_case_result() {\n         check_assist(\n@@ -308,6 +364,36 @@ fn foo(x: Result<i32, ()>) {\n         );\n     }\n \n+    #[test]\n+    fn special_case_inverted_result() {\n+        check_assist(\n+            replace_if_let_with_match,\n+            r#\"\n+enum Result<T, E> { Ok(T), Err(E) }\n+use Result::*;\n+\n+fn foo(x: Result<i32, ()>) {\n+    $0if let Err(x) = x {\n+        println!(\"{}\", x)\n+    } else {\n+        println!(\"ok\")\n+    }\n+}\n+           \"#,\n+            r#\"\n+enum Result<T, E> { Ok(T), Err(E) }\n+use Result::*;\n+\n+fn foo(x: Result<i32, ()>) {\n+    match x {\n+        Err(x) => println!(\"{}\", x),\n+        Ok(_) => println!(\"ok\"),\n+    }\n+}\n+           \"#,\n+        );\n+    }\n+\n     #[test]\n     fn nested_indent() {\n         check_assist("}, {"sha": "f8406851bd5405e9945ccf02d2010d3e9dbb7118", "filename": "crates/ide_db/src/ty_filter.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24f0cd8293c73b376a5e448dcbadcf189e8698aa/crates%2Fide_db%2Fsrc%2Fty_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24f0cd8293c73b376a5e448dcbadcf189e8698aa/crates%2Fide_db%2Fsrc%2Fty_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fty_filter.rs?ref=24f0cd8293c73b376a5e448dcbadcf189e8698aa", "patch": "@@ -49,6 +49,21 @@ impl TryEnum {\n         }\n     }\n \n+    pub fn happy_pattern(self) -> ast::Pat {\n+        match self {\n+            TryEnum::Result => make::tuple_struct_pat(\n+                make::path_unqualified(make::path_segment(make::name_ref(\"Ok\"))),\n+                iter::once(make::wildcard_pat().into()),\n+            )\n+            .into(),\n+            TryEnum::Option => make::tuple_struct_pat(\n+                make::path_unqualified(make::path_segment(make::name_ref(\"Some\"))),\n+                iter::once(make::wildcard_pat().into()),\n+            )\n+            .into(),\n+        }\n+    }\n+\n     fn type_name(self) -> &'static str {\n         match self {\n             TryEnum::Result => \"Result\","}]}