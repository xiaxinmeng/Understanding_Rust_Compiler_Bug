{"sha": "99b1f9c9c864c86acc733429c1c170af5a45e0e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5YjFmOWM5Yzg2NGM4NmFjYzczMzQyOWMxYzE3MGFmNWE0NWUwZTk=", "commit": {"author": {"name": "Tshepang Lekhonkhobe", "email": "tshepang@gmail.com", "date": "2016-11-17T06:32:04Z"}, "committer": {"name": "Tshepang Lekhonkhobe", "email": "tshepang@gmail.com", "date": "2016-11-17T06:32:17Z"}, "message": "doc: nits and typos on comments", "tree": {"sha": "551de0683ad0a82d4629acd5aad8fcfeca8fed77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/551de0683ad0a82d4629acd5aad8fcfeca8fed77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99b1f9c9c864c86acc733429c1c170af5a45e0e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99b1f9c9c864c86acc733429c1c170af5a45e0e9", "html_url": "https://github.com/rust-lang/rust/commit/99b1f9c9c864c86acc733429c1c170af5a45e0e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99b1f9c9c864c86acc733429c1c170af5a45e0e9/comments", "author": {"login": "tshepang", "id": 588486, "node_id": "MDQ6VXNlcjU4ODQ4Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/588486?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tshepang", "html_url": "https://github.com/tshepang", "followers_url": "https://api.github.com/users/tshepang/followers", "following_url": "https://api.github.com/users/tshepang/following{/other_user}", "gists_url": "https://api.github.com/users/tshepang/gists{/gist_id}", "starred_url": "https://api.github.com/users/tshepang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tshepang/subscriptions", "organizations_url": "https://api.github.com/users/tshepang/orgs", "repos_url": "https://api.github.com/users/tshepang/repos", "events_url": "https://api.github.com/users/tshepang/events{/privacy}", "received_events_url": "https://api.github.com/users/tshepang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tshepang", "id": 588486, "node_id": "MDQ6VXNlcjU4ODQ4Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/588486?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tshepang", "html_url": "https://github.com/tshepang", "followers_url": "https://api.github.com/users/tshepang/followers", "following_url": "https://api.github.com/users/tshepang/following{/other_user}", "gists_url": "https://api.github.com/users/tshepang/gists{/gist_id}", "starred_url": "https://api.github.com/users/tshepang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tshepang/subscriptions", "organizations_url": "https://api.github.com/users/tshepang/orgs", "repos_url": "https://api.github.com/users/tshepang/repos", "events_url": "https://api.github.com/users/tshepang/events{/privacy}", "received_events_url": "https://api.github.com/users/tshepang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d88d06448e1ad928d22cf0a511f1edae91b646d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d88d06448e1ad928d22cf0a511f1edae91b646d5", "html_url": "https://github.com/rust-lang/rust/commit/d88d06448e1ad928d22cf0a511f1edae91b646d5"}], "stats": {"total": 34, "additions": 17, "deletions": 17}, "files": [{"sha": "7395cc42ac578d7d17d3d9447c6a5cd0b232b6cf", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/99b1f9c9c864c86acc733429c1c170af5a45e0e9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b1f9c9c864c86acc733429c1c170af5a45e0e9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=99b1f9c9c864c86acc733429c1c170af5a45e0e9", "patch": "@@ -874,12 +874,12 @@ fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n impl<'a> DocFolder for SourceCollector<'a> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         // If we're including source files, and we haven't seen this file yet,\n-        // then we need to render it out to the filesystem\n+        // then we need to render it out to the filesystem.\n         if self.scx.include_sources\n             // skip all invalid spans\n             && item.source.filename != \"\"\n-            // macros from other libraries get special filenames which we can\n-            // safely ignore\n+            // Macros from other libraries get special filenames which we can\n+            // safely ignore.\n             && !(item.source.filename.starts_with(\"<\")\n                 && item.source.filename.ends_with(\"macros>\")) {\n \n@@ -974,13 +974,13 @@ impl DocFolder for Cache {\n         };\n \n         // Register any generics to their corresponding string. This is used\n-        // when pretty-printing types\n+        // when pretty-printing types.\n         if let Some(generics) = item.inner.generics() {\n             self.generics(generics);\n         }\n \n-        // Propagate a trait methods' documentation to all implementors of the\n-        // trait\n+        // Propagate a trait method's documentation to all implementors of the\n+        // trait.\n         if let clean::TraitItem(ref t) = item.inner {\n             self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n         }\n@@ -996,7 +996,7 @@ impl DocFolder for Cache {\n             }\n         }\n \n-        // Index this method for searching later on\n+        // Index this method for searching later on.\n         if let Some(ref s) = item.name {\n             let (parent, is_inherent_impl_item) = match item.inner {\n                 clean::StrippedItem(..) => ((None, None), false),\n@@ -1097,8 +1097,8 @@ impl DocFolder for Cache {\n                                       (self.stack.clone(), item.type_()));\n                 }\n             }\n-            // link variants to their parent enum because pages aren't emitted\n-            // for each variant\n+            // Link variants to their parent enum because pages aren't emitted\n+            // for each variant.\n             clean::VariantItem(..) if !self.stripped_mod => {\n                 let mut stack = self.stack.clone();\n                 stack.pop();\n@@ -1144,8 +1144,8 @@ impl DocFolder for Cache {\n             _ => false\n         };\n \n-        // Once we've recursively found all the generics, then hoard off all the\n-        // implementations elsewhere\n+        // Once we've recursively found all the generics, hoard off all the\n+        // implementations elsewhere.\n         let ret = self.fold_item_recur(item).and_then(|item| {\n             if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n                 // Figure out the id of this impl. This may map to a\n@@ -1206,7 +1206,7 @@ impl Context {\n     }\n \n     /// Recurse in the directory structure and change the \"root path\" to make\n-    /// sure it always points to the top (relatively)\n+    /// sure it always points to the top (relatively).\n     fn recurse<T, F>(&mut self, s: String, f: F) -> T where\n         F: FnOnce(&mut Context) -> T,\n     {\n@@ -1237,11 +1237,11 @@ impl Context {\n     fn krate(self, mut krate: clean::Crate) -> Result<(), Error> {\n         let mut item = match krate.module.take() {\n             Some(i) => i,\n-            None => return Ok(())\n+            None => return Ok(()),\n         };\n         item.name = Some(krate.name);\n \n-        // render the crate documentation\n+        // Render the crate documentation\n         let mut work = vec![(self, item)];\n \n         while let Some((mut cx, item)) = work.pop() {\n@@ -2987,7 +2987,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n         let it = self.item;\n         let parentlen = cx.current.len() - if it.is_mod() {1} else {0};\n \n-        // the sidebar is designed to display sibling functions, modules and\n+        // The sidebar is designed to display sibling functions, modules and\n         // other miscellaneous information. since there are lots of sibling\n         // items (and that causes quadratic growth in large modules),\n         // we refactor common parts into a shared JavaScript file per module.\n@@ -3006,7 +3006,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n         }\n         write!(fmt, \"</p>\")?;\n \n-        // sidebar refers to the enclosing module, not this module\n+        // Sidebar refers to the enclosing module, not this module.\n         let relpath = if it.is_mod() { \"../\" } else { \"\" };\n         write!(fmt,\n                \"<script>window.sidebarCurrent = {{\\\n@@ -3018,7 +3018,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                ty = it.type_().css_class(),\n                path = relpath)?;\n         if parentlen == 0 {\n-            // there is no sidebar-items.js beyond the crate root path\n+            // There is no sidebar-items.js beyond the crate root path\n             // FIXME maybe dynamic crate loading can be merged here\n         } else {\n             write!(fmt, \"<script defer src=\\\"{path}sidebar-items.js\\\"></script>\","}]}