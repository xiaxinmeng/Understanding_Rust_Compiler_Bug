{"sha": "51b2c86b358a69b88bddf92cd1078500c233ba66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxYjJjODZiMzU4YTY5Yjg4YmRkZjkyY2QxMDc4NTAwYzIzM2JhNjY=", "commit": {"author": {"name": "unexge", "email": "unexge@gmail.com", "date": "2020-06-11T21:40:59Z"}, "committer": {"name": "unexge", "email": "unexge@gmail.com", "date": "2020-06-11T21:40:59Z"}, "message": "Fix renaming mod in use tree", "tree": {"sha": "e15fbde01989534e448a15a2214e5b3a73021ccd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e15fbde01989534e448a15a2214e5b3a73021ccd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51b2c86b358a69b88bddf92cd1078500c233ba66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51b2c86b358a69b88bddf92cd1078500c233ba66", "html_url": "https://github.com/rust-lang/rust/commit/51b2c86b358a69b88bddf92cd1078500c233ba66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51b2c86b358a69b88bddf92cd1078500c233ba66/comments", "author": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36353bb1827dbd2efcde2d18c8598c4cc5e2e296", "url": "https://api.github.com/repos/rust-lang/rust/commits/36353bb1827dbd2efcde2d18c8598c4cc5e2e296", "html_url": "https://github.com/rust-lang/rust/commit/36353bb1827dbd2efcde2d18c8598c4cc5e2e296"}], "stats": {"total": 201, "additions": 146, "deletions": 55}, "files": [{"sha": "546224b50fa1a88b136e7be16b7065574b3d6e0f", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 146, "deletions": 55, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/51b2c86b358a69b88bddf92cd1078500c233ba66/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b2c86b358a69b88bddf92cd1078500c233ba66/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=51b2c86b358a69b88bddf92cd1078500c233ba66", "patch": "@@ -1,11 +1,14 @@\n //! FIXME: write short doc here\n \n-use hir::{ModuleSource, Semantics};\n+use hir::{Module, ModuleDef, ModuleSource, Semantics};\n use ra_db::{RelativePath, RelativePathBuf, SourceDatabaseExt};\n-use ra_ide_db::RootDatabase;\n+use ra_ide_db::{\n+    defs::{classify_name, classify_name_ref, Definition, NameClass, NameRefClass},\n+    RootDatabase,\n+};\n use ra_syntax::{\n-    algo::find_node_at_offset, ast, ast::TypeAscriptionOwner, lex_single_valid_syntax_kind,\n-    AstNode, SyntaxKind, SyntaxNode, SyntaxToken,\n+    algo::find_node_at_offset, ast, ast::NameOwner, ast::TypeAscriptionOwner,\n+    lex_single_valid_syntax_kind, match_ast, AstNode, SyntaxKind, SyntaxNode, SyntaxToken,\n };\n use ra_text_edit::TextEdit;\n use std::convert::TryInto;\n@@ -30,10 +33,8 @@ pub(crate) fn rename(\n     let sema = Semantics::new(db);\n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax();\n-    if let Some((ast_name, ast_module)) = find_name_and_module_at_offset(syntax, position) {\n-        let range = ast_name.syntax().text_range();\n-        rename_mod(&sema, &ast_name, &ast_module, position, new_name)\n-            .map(|info| RangeInfo::new(range, info))\n+    if let Some(module) = find_module_at_offset(&sema, position, syntax) {\n+        rename_mod(db, position, module, new_name)\n     } else if let Some(self_token) =\n         syntax.token_at_offset(position.offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n     {\n@@ -43,13 +44,32 @@ pub(crate) fn rename(\n     }\n }\n \n-fn find_name_and_module_at_offset(\n-    syntax: &SyntaxNode,\n+fn find_module_at_offset(\n+    sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n-) -> Option<(ast::Name, ast::Module)> {\n-    let ast_name = find_node_at_offset::<ast::Name>(syntax, position.offset)?;\n-    let ast_module = ast::Module::cast(ast_name.syntax().parent()?)?;\n-    Some((ast_name, ast_module))\n+    syntax: &SyntaxNode,\n+) -> Option<Module> {\n+    let ident = syntax.token_at_offset(position.offset).find(|t| t.kind() == SyntaxKind::IDENT)?;\n+\n+    let module = match_ast! {\n+        match (ident.parent()) {\n+            ast::NameRef(name_ref) => {\n+                match classify_name_ref(sema, &name_ref)? {\n+                    NameRefClass::Definition(Definition::ModuleDef(ModuleDef::Module(module))) => module,\n+                    _ => return None,\n+                }\n+            },\n+            ast::Name(name) => {\n+                match classify_name(&sema, &name)? {\n+                    NameClass::Definition(Definition::ModuleDef(ModuleDef::Module(module))) => module,\n+                    _ => return None,\n+                }\n+            },\n+            _ => return None,\n+        }\n+    };\n+\n+    Some(module)\n }\n \n fn source_edit_from_reference(reference: Reference, new_name: &str) -> SourceFileEdit {\n@@ -77,58 +97,59 @@ fn source_edit_from_reference(reference: Reference, new_name: &str) -> SourceFil\n }\n \n fn rename_mod(\n-    sema: &Semantics<RootDatabase>,\n-    ast_name: &ast::Name,\n-    ast_module: &ast::Module,\n+    db: &RootDatabase,\n     position: FilePosition,\n+    module: Module,\n     new_name: &str,\n-) -> Option<SourceChange> {\n+) -> Option<RangeInfo<SourceChange>> {\n     let mut source_file_edits = Vec::new();\n     let mut file_system_edits = Vec::new();\n-    if let Some(module) = sema.to_def(ast_module) {\n-        let src = module.definition_source(sema.db);\n-        let file_id = src.file_id.original_file(sema.db);\n-        match src.value {\n-            ModuleSource::SourceFile(..) => {\n-                let mod_path: RelativePathBuf = sema.db.file_relative_path(file_id);\n-                // mod is defined in path/to/dir/mod.rs\n-                let dst_path = if mod_path.file_stem() == Some(\"mod\") {\n-                    mod_path\n-                        .parent()\n-                        .and_then(|p| p.parent())\n-                        .or_else(|| Some(RelativePath::new(\"\")))\n-                        .map(|p| p.join(new_name).join(\"mod.rs\"))\n-                } else {\n-                    Some(mod_path.with_file_name(new_name).with_extension(\"rs\"))\n+\n+    let src = module.definition_source(db);\n+    let file_id = src.file_id.original_file(db);\n+    match src.value {\n+        ModuleSource::SourceFile(..) => {\n+            let mod_path: RelativePathBuf = db.file_relative_path(file_id);\n+            // mod is defined in path/to/dir/mod.rs\n+            let dst_path = if mod_path.file_stem() == Some(\"mod\") {\n+                mod_path\n+                    .parent()\n+                    .and_then(|p| p.parent())\n+                    .or_else(|| Some(RelativePath::new(\"\")))\n+                    .map(|p| p.join(new_name).join(\"mod.rs\"))\n+            } else {\n+                Some(mod_path.with_file_name(new_name).with_extension(\"rs\"))\n+            };\n+            if let Some(path) = dst_path {\n+                let move_file = FileSystemEdit::MoveFile {\n+                    src: file_id,\n+                    dst_source_root: db.file_source_root(position.file_id),\n+                    dst_path: path,\n                 };\n-                if let Some(path) = dst_path {\n-                    let move_file = FileSystemEdit::MoveFile {\n-                        src: file_id,\n-                        dst_source_root: sema.db.file_source_root(position.file_id),\n-                        dst_path: path,\n-                    };\n-                    file_system_edits.push(move_file);\n-                }\n+                file_system_edits.push(move_file);\n             }\n-            ModuleSource::Module(..) => {}\n         }\n+        ModuleSource::Module(..) => {}\n     }\n \n-    let edit = SourceFileEdit {\n-        file_id: position.file_id,\n-        edit: TextEdit::replace(ast_name.syntax().text_range(), new_name.into()),\n-    };\n-    source_file_edits.push(edit);\n-\n-    if let Some(RangeInfo { range: _, info: refs }) = find_all_refs(sema.db, position, None) {\n-        let ref_edits = refs\n-            .references\n-            .into_iter()\n-            .map(|reference| source_edit_from_reference(reference, new_name));\n-        source_file_edits.extend(ref_edits);\n+    if let Some(src) = module.declaration_source(db) {\n+        let file_id = src.file_id.original_file(db);\n+        let name = src.value.name()?;\n+        let edit = SourceFileEdit {\n+            file_id: file_id,\n+            edit: TextEdit::replace(name.syntax().text_range(), new_name.into()),\n+        };\n+        source_file_edits.push(edit);\n     }\n \n-    Some(SourceChange::from_edits(source_file_edits, file_system_edits))\n+    let RangeInfo { range, info: refs } = find_all_refs(db, position, None)?;\n+    let ref_edits = refs\n+        .references\n+        .into_iter()\n+        .map(|reference| source_edit_from_reference(reference, new_name));\n+    source_file_edits.extend(ref_edits);\n+\n+    Some(RangeInfo::new(range, SourceChange::from_edits(source_file_edits, file_system_edits)))\n }\n \n fn rename_to_self(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo<SourceChange>> {\n@@ -675,6 +696,76 @@ mod tests {\n         \"###);\n     }\n \n+    #[test]\n+    fn test_rename_mod_in_use_tree() {\n+        let (analysis, position) = analysis_and_position(\n+            \"\n+            //- /main.rs\n+            pub mod foo;\n+            pub mod bar;\n+            fn main() {}\n+\n+            //- /foo.rs\n+            pub struct FooContent;\n+\n+            //- /bar.rs\n+            use crate::foo<|>::FooContent;\n+            \",\n+        );\n+        let new_name = \"qux\";\n+        let source_change = analysis.rename(position, new_name).unwrap();\n+        assert_debug_snapshot!(&source_change,\n+@r###\"\n+        Some(\n+            RangeInfo {\n+                range: 11..14,\n+                info: SourceChange {\n+                    source_file_edits: [\n+                        SourceFileEdit {\n+                            file_id: FileId(\n+                                1,\n+                            ),\n+                            edit: TextEdit {\n+                                indels: [\n+                                    Indel {\n+                                        insert: \"qux\",\n+                                        delete: 8..11,\n+                                    },\n+                                ],\n+                            },\n+                        },\n+                        SourceFileEdit {\n+                            file_id: FileId(\n+                                3,\n+                            ),\n+                            edit: TextEdit {\n+                                indels: [\n+                                    Indel {\n+                                        insert: \"qux\",\n+                                        delete: 11..14,\n+                                    },\n+                                ],\n+                            },\n+                        },\n+                    ],\n+                    file_system_edits: [\n+                        MoveFile {\n+                            src: FileId(\n+                                2,\n+                            ),\n+                            dst_source_root: SourceRootId(\n+                                0,\n+                            ),\n+                            dst_path: \"qux.rs\",\n+                        },\n+                    ],\n+                    is_snippet: false,\n+                },\n+            },\n+        )\n+        \"###);\n+    }\n+\n     #[test]\n     fn test_rename_mod_in_dir() {\n         let (analysis, position) = analysis_and_position("}]}