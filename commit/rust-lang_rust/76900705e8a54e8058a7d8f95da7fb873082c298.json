{"sha": "76900705e8a54e8058a7d8f95da7fb873082c298", "node_id": "C_kwDOAAsO6NoAKDc2OTAwNzA1ZThhNTRlODA1OGE3ZDhmOTVkYTdmYjg3MzA4MmMyOTg", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-06-05T08:55:43Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-06-05T15:33:54Z"}, "message": "Implement all vendor intrinsics used by regex on AVX2 systems\n\nThis allows it to work with --sysroot llvm", "tree": {"sha": "17dd4ff76f14f923284d8dbd1746f4593c0ccdaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17dd4ff76f14f923284d8dbd1746f4593c0ccdaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76900705e8a54e8058a7d8f95da7fb873082c298", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76900705e8a54e8058a7d8f95da7fb873082c298", "html_url": "https://github.com/rust-lang/rust/commit/76900705e8a54e8058a7d8f95da7fb873082c298", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76900705e8a54e8058a7d8f95da7fb873082c298/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e369cce377219a8432b0e0748620aa6e455e1aea", "url": "https://api.github.com/repos/rust-lang/rust/commits/e369cce377219a8432b0e0748620aa6e455e1aea", "html_url": "https://github.com/rust-lang/rust/commit/e369cce377219a8432b0e0748620aa6e455e1aea"}], "stats": {"total": 226, "additions": 225, "deletions": 1}, "files": [{"sha": "811dbb267cdd79ca645ffdb2938e9787be488366", "filename": "example/std_example.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/76900705e8a54e8058a7d8f95da7fb873082c298/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76900705e8a54e8058a7d8f95da7fb873082c298/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=76900705e8a54e8058a7d8f95da7fb873082c298", "patch": "@@ -198,6 +198,9 @@ unsafe fn test_simd() {\n     test_mm_extract_epi8();\n     test_mm_insert_epi16();\n \n+    test_mm256_shuffle_epi8();\n+    test_mm256_permute2x128_si256();\n+\n     #[rustfmt::skip]\n     let mask1 = _mm_movemask_epi8(dbg!(_mm_setr_epi8(255u8 as i8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)));\n     assert_eq!(mask1, 1);\n@@ -293,6 +296,12 @@ pub unsafe fn assert_eq_m128d(a: __m128d, b: __m128d) {\n     }\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"avx\")]\n+pub unsafe fn assert_eq_m256i(a: __m256i, b: __m256i) {\n+    assert_eq!(std::mem::transmute::<_, [u64; 4]>(a), std::mem::transmute::<_, [u64; 4]>(b))\n+}\n+\n #[cfg(target_arch = \"x86_64\")]\n #[target_feature(enable = \"sse2\")]\n unsafe fn test_mm_cvtsi128_si64() {\n@@ -336,6 +345,44 @@ unsafe fn test_mm_insert_epi16() {\n     assert_eq_m128i(r, e);\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"avx2\")]\n+unsafe fn test_mm256_shuffle_epi8() {\n+    #[rustfmt::skip]\n+    let a = _mm256_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8,\n+        9, 10, 11, 12, 13, 14, 15, 16,\n+        17, 18, 19, 20, 21, 22, 23, 24,\n+        25, 26, 27, 28, 29, 30, 31, 32,\n+    );\n+    #[rustfmt::skip]\n+    let b = _mm256_setr_epi8(\n+        4, 128u8 as i8, 4, 3, 24, 12, 6, 19,\n+        12, 5, 5, 10, 4, 1, 8, 0,\n+        4, 128u8 as i8, 4, 3, 24, 12, 6, 19,\n+        12, 5, 5, 10, 4, 1, 8, 0,\n+    );\n+    #[rustfmt::skip]\n+    let expected = _mm256_setr_epi8(\n+        5, 0, 5, 4, 9, 13, 7, 4,\n+        13, 6, 6, 11, 5, 2, 9, 1,\n+        21, 0, 21, 20, 25, 29, 23, 20,\n+        29, 22, 22, 27, 21, 18, 25, 17,\n+    );\n+    let r = _mm256_shuffle_epi8(a, b);\n+    assert_eq_m256i(r, expected);\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"avx2\")]\n+unsafe fn test_mm256_permute2x128_si256() {\n+    let a = _mm256_setr_epi64x(100, 200, 500, 600);\n+    let b = _mm256_setr_epi64x(300, 400, 700, 800);\n+    let r = _mm256_permute2x128_si256::<0b00_01_00_11>(a, b);\n+    let e = _mm256_setr_epi64x(700, 800, 500, 600);\n+    assert_eq_m256i(r, e);\n+}\n+\n fn test_checked_mul() {\n     let u: Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n     assert_eq!(u, None);"}, {"sha": "bd80559abec732545533b98cebf0c2e389c643c4", "filename": "src/intrinsics/llvm_x86.rs", "status": "modified", "additions": 157, "deletions": 1, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/76900705e8a54e8058a7d8f95da7fb873082c298/src%2Fintrinsics%2Fllvm_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76900705e8a54e8058a7d8f95da7fb873082c298/src%2Fintrinsics%2Fllvm_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fllvm_x86.rs?ref=76900705e8a54e8058a7d8f95da7fb873082c298", "patch": "@@ -110,7 +110,41 @@ pub(crate) fn codegen_x86_llvm_intrinsic_call<'tcx>(\n             };\n             let a = codegen_operand(fx, a);\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8)\n-                .expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n+                .expect(\"llvm.x86.sse2.pslli.d imm8 not const\");\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm8\n+                .try_to_bits(Size::from_bytes(4))\n+                .unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8))\n+            {\n+                imm8 if imm8 < 32 => fx.bcx.ins().ishl_imm(lane, i64::from(imm8 as u8)),\n+                _ => fx.bcx.ins().iconst(types::I32, 0),\n+            });\n+        }\n+        \"llvm.x86.avx.psrli.d\" => {\n+            let (a, imm8) = match args {\n+                [a, imm8] => (a, imm8),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let a = codegen_operand(fx, a);\n+            let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8)\n+                .expect(\"llvm.x86.avx.psrli.d imm8 not const\");\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm8\n+                .try_to_bits(Size::from_bytes(4))\n+                .unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8))\n+            {\n+                imm8 if imm8 < 32 => fx.bcx.ins().ushr_imm(lane, i64::from(imm8 as u8)),\n+                _ => fx.bcx.ins().iconst(types::I32, 0),\n+            });\n+        }\n+        \"llvm.x86.avx.pslli.d\" => {\n+            let (a, imm8) = match args {\n+                [a, imm8] => (a, imm8),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let a = codegen_operand(fx, a);\n+            let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8)\n+                .expect(\"llvm.x86.avx.pslli.d imm8 not const\");\n \n             simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm8\n                 .try_to_bits(Size::from_bytes(4))\n@@ -120,6 +154,128 @@ pub(crate) fn codegen_x86_llvm_intrinsic_call<'tcx>(\n                 _ => fx.bcx.ins().iconst(types::I32, 0),\n             });\n         }\n+        \"llvm.x86.avx2.psrli.w\" => {\n+            let (a, imm8) = match args {\n+                [a, imm8] => (a, imm8),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let a = codegen_operand(fx, a);\n+            let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8)\n+                .expect(\"llvm.x86.avx.psrli.w imm8 not const\");\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm8\n+                .try_to_bits(Size::from_bytes(4))\n+                .unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8))\n+            {\n+                imm8 if imm8 < 16 => fx.bcx.ins().ushr_imm(lane, i64::from(imm8 as u8)),\n+                _ => fx.bcx.ins().iconst(types::I32, 0),\n+            });\n+        }\n+        \"llvm.x86.avx2.pslli.w\" => {\n+            let (a, imm8) = match args {\n+                [a, imm8] => (a, imm8),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let a = codegen_operand(fx, a);\n+            let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8)\n+                .expect(\"llvm.x86.avx.pslli.w imm8 not const\");\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm8\n+                .try_to_bits(Size::from_bytes(4))\n+                .unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8))\n+            {\n+                imm8 if imm8 < 16 => fx.bcx.ins().ishl_imm(lane, i64::from(imm8 as u8)),\n+                _ => fx.bcx.ins().iconst(types::I32, 0),\n+            });\n+        }\n+        \"llvm.x86.avx2.pshuf.b\" => {\n+            let (a, b) = match args {\n+                [a, b] => (a, b),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let a = codegen_operand(fx, a);\n+            let b = codegen_operand(fx, b);\n+\n+            // Based on the pseudocode at https://github.com/rust-lang/stdarch/blob/1cfbca8b38fd9b4282b2f054f61c6ca69fc7ce29/crates/core_arch/src/x86/avx2.rs#L2319-L2332\n+            let zero = fx.bcx.ins().iconst(types::I8, 0);\n+            for i in 0..16 {\n+                let b_lane = b.value_lane(fx, i).load_scalar(fx);\n+                let is_zero = fx.bcx.ins().band_imm(b_lane, 0x80);\n+                let a_idx = fx.bcx.ins().band_imm(b_lane, 0xf);\n+                let a_idx = fx.bcx.ins().uextend(fx.pointer_type, a_idx);\n+                let a_lane = a.value_lane_dyn(fx, a_idx).load_scalar(fx);\n+                let res = fx.bcx.ins().select(is_zero, zero, a_lane);\n+                ret.place_lane(fx, i).to_ptr().store(fx, res, MemFlags::trusted());\n+            }\n+            for i in 16..32 {\n+                let b_lane = b.value_lane(fx, i).load_scalar(fx);\n+                let is_zero = fx.bcx.ins().band_imm(b_lane, 0x80);\n+                let b_lane_masked = fx.bcx.ins().band_imm(b_lane, 0xf);\n+                let a_idx = fx.bcx.ins().iadd_imm(b_lane_masked, 16);\n+                let a_idx = fx.bcx.ins().uextend(fx.pointer_type, a_idx);\n+                let a_lane = a.value_lane_dyn(fx, a_idx).load_scalar(fx);\n+                let res = fx.bcx.ins().select(is_zero, zero, a_lane);\n+                ret.place_lane(fx, i).to_ptr().store(fx, res, MemFlags::trusted());\n+            }\n+        }\n+        \"llvm.x86.avx2.vperm2i128\" => {\n+            // https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm256_permute2x128_si256\n+            let (a, b, imm8) = match args {\n+                [a, b, imm8] => (a, b, imm8),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let a = codegen_operand(fx, a);\n+            let b = codegen_operand(fx, b);\n+            let imm8 = codegen_operand(fx, imm8).load_scalar(fx);\n+\n+            let a_0 = a.value_lane(fx, 0).load_scalar(fx);\n+            let a_1 = a.value_lane(fx, 1).load_scalar(fx);\n+            let a_low = fx.bcx.ins().iconcat(a_0, a_1);\n+            let a_2 = a.value_lane(fx, 2).load_scalar(fx);\n+            let a_3 = a.value_lane(fx, 3).load_scalar(fx);\n+            let a_high = fx.bcx.ins().iconcat(a_2, a_3);\n+\n+            let b_0 = b.value_lane(fx, 0).load_scalar(fx);\n+            let b_1 = b.value_lane(fx, 1).load_scalar(fx);\n+            let b_low = fx.bcx.ins().iconcat(b_0, b_1);\n+            let b_2 = b.value_lane(fx, 2).load_scalar(fx);\n+            let b_3 = b.value_lane(fx, 3).load_scalar(fx);\n+            let b_high = fx.bcx.ins().iconcat(b_2, b_3);\n+\n+            fn select4(\n+                fx: &mut FunctionCx<'_, '_, '_>,\n+                a_high: Value,\n+                a_low: Value,\n+                b_high: Value,\n+                b_low: Value,\n+                control: Value,\n+            ) -> Value {\n+                let a_or_b = fx.bcx.ins().band_imm(control, 0b0010);\n+                let high_or_low = fx.bcx.ins().band_imm(control, 0b0001);\n+                let is_zero = fx.bcx.ins().band_imm(control, 0b1000);\n+\n+                let zero = fx.bcx.ins().iconst(types::I64, 0);\n+                let zero = fx.bcx.ins().iconcat(zero, zero);\n+\n+                let res_a = fx.bcx.ins().select(high_or_low, a_high, a_low);\n+                let res_b = fx.bcx.ins().select(high_or_low, b_high, b_low);\n+                let res = fx.bcx.ins().select(a_or_b, res_b, res_a);\n+                fx.bcx.ins().select(is_zero, zero, res)\n+            }\n+\n+            let control0 = imm8;\n+            let res_low = select4(fx, a_high, a_low, b_high, b_low, control0);\n+            let (res_0, res_1) = fx.bcx.ins().isplit(res_low);\n+\n+            let control1 = fx.bcx.ins().ushr_imm(imm8, 4);\n+            let res_high = select4(fx, a_high, a_low, b_high, b_low, control1);\n+            let (res_2, res_3) = fx.bcx.ins().isplit(res_high);\n+\n+            ret.place_lane(fx, 0).to_ptr().store(fx, res_0, MemFlags::trusted());\n+            ret.place_lane(fx, 1).to_ptr().store(fx, res_1, MemFlags::trusted());\n+            ret.place_lane(fx, 2).to_ptr().store(fx, res_2, MemFlags::trusted());\n+            ret.place_lane(fx, 3).to_ptr().store(fx, res_3, MemFlags::trusted());\n+        }\n         \"llvm.x86.sse2.storeu.dq\" => {\n             intrinsic_args!(fx, args => (mem_addr, a); intrinsic);\n             let mem_addr = mem_addr.load_scalar(fx);"}, {"sha": "133c989b6864303d50949240c3f424197ed8df8c", "filename": "src/value_and_place.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/76900705e8a54e8058a7d8f95da7fb873082c298/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76900705e8a54e8058a7d8f95da7fb873082c298/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=76900705e8a54e8058a7d8f95da7fb873082c298", "patch": "@@ -258,6 +258,27 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n+    /// Like [`CValue::value_lane`] except allowing a dynamically calculated lane index.\n+    pub(crate) fn value_lane_dyn(\n+        self,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n+        lane_idx: Value,\n+    ) -> CValue<'tcx> {\n+        let layout = self.1;\n+        assert!(layout.ty.is_simd());\n+        let (_lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+        let lane_layout = fx.layout_of(lane_ty);\n+        match self.0 {\n+            CValueInner::ByVal(_) | CValueInner::ByValPair(_, _) => unreachable!(),\n+            CValueInner::ByRef(ptr, None) => {\n+                let field_offset = fx.bcx.ins().imul_imm(lane_idx, lane_layout.size.bytes() as i64);\n+                let field_ptr = ptr.offset_value(fx, field_offset);\n+                CValue::by_ref(field_ptr, lane_layout)\n+            }\n+            CValueInner::ByRef(_, Some(_)) => unreachable!(),\n+        }\n+    }\n+\n     /// If `ty` is signed, `const_val` must already be sign extended.\n     pub(crate) fn const_val(\n         fx: &mut FunctionCx<'_, '_, 'tcx>,"}]}