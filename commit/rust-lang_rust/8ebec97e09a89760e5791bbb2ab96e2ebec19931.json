{"sha": "8ebec97e09a89760e5791bbb2ab96e2ebec19931", "node_id": "C_kwDOAAsO6NoAKDhlYmVjOTdlMDlhODk3NjBlNTc5MWJiYjJhYjk2ZTJlYmVjMTk5MzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-24T01:26:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-24T01:26:57Z"}, "message": "Auto merge of #93438 - spastorino:node_id_to_hir_id_refactor, r=oli-obk\n\nNode id to hir id refactor\n\nRelated to #89278\n\nr? `@oli-obk`", "tree": {"sha": "e3cee787918871b396f89729ca53f8d97a051f26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3cee787918871b396f89729ca53f8d97a051f26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ebec97e09a89760e5791bbb2ab96e2ebec19931", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ebec97e09a89760e5791bbb2ab96e2ebec19931", "html_url": "https://github.com/rust-lang/rust/commit/8ebec97e09a89760e5791bbb2ab96e2ebec19931", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ebec97e09a89760e5791bbb2ab96e2ebec19931/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "532d3cda90b8a729cd982548649d32803d265052", "url": "https://api.github.com/repos/rust-lang/rust/commits/532d3cda90b8a729cd982548649d32803d265052", "html_url": "https://github.com/rust-lang/rust/commit/532d3cda90b8a729cd982548649d32803d265052"}, {"sha": "d82a7bc1b5615548811d2c50cc64f6d486ef1d02", "url": "https://api.github.com/repos/rust-lang/rust/commits/d82a7bc1b5615548811d2c50cc64f6d486ef1d02", "html_url": "https://github.com/rust-lang/rust/commit/d82a7bc1b5615548811d2c50cc64f6d486ef1d02"}], "stats": {"total": 133, "additions": 74, "deletions": 59}, "files": [{"sha": "a86333365128d5ba2dc52338edfcf8109a49212a", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ebec97e09a89760e5791bbb2ab96e2ebec19931/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebec97e09a89760e5791bbb2ab96e2ebec19931/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=8ebec97e09a89760e5791bbb2ab96e2ebec19931", "patch": "@@ -360,7 +360,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // method, it will not be considered an in-band\n                 // lifetime to be added, but rather a reference to a\n                 // parent lifetime.\n-                let lowered_trait_def_id = self.lower_node_id(id).expect_owner();\n+                let lowered_trait_def_id = hir_id.expect_owner();\n                 let (generics, (trait_ref, lowered_ty)) = self.add_in_band_defs(\n                     ast_generics,\n                     lowered_trait_def_id,\n@@ -509,10 +509,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let new_id = self.resolver.local_def_id(new_node_id);\n                     let Some(res) = resolutions.next() else {\n                         // Associate an HirId to both ids even if there is no resolution.\n-                        let _old = self\n-                            .node_id_to_hir_id\n-                            .insert(new_node_id, hir::HirId::make_owner(new_id));\n-                        debug_assert!(_old.is_none());\n                         self.owners.ensure_contains_elem(new_id, || hir::MaybeOwner::Phantom);\n                         let _old = std::mem::replace(\n                             &mut self.owners[new_id],"}, {"sha": "0a59e3c2e3f829ac66d9e71aa404638c5d95fbb0", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 60, "deletions": 54, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/8ebec97e09a89760e5791bbb2ab96e2ebec19931/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebec97e09a89760e5791bbb2ab96e2ebec19931/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=8ebec97e09a89760e5791bbb2ab96e2ebec19931", "patch": "@@ -44,7 +44,7 @@ use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n@@ -54,7 +54,7 @@ use rustc_hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{DefId, DefPathHash, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n use rustc_hir::intravisit;\n-use rustc_hir::{ConstArg, GenericArg, ParamName};\n+use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::lint::LintBuffer;\n@@ -67,6 +67,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n use smallvec::SmallVec;\n+use std::collections::hash_map::Entry;\n use tracing::{debug, trace};\n \n macro_rules! arena_vec {\n@@ -154,10 +155,11 @@ struct LoweringContext<'a, 'hir: 'a> {\n \n     current_hir_id_owner: LocalDefId,\n     item_local_id_counter: hir::ItemLocalId,\n-    node_id_to_hir_id: IndexVec<NodeId, Option<hir::HirId>>,\n+    local_id_to_def_id: SortedMap<ItemLocalId, LocalDefId>,\n+    trait_map: FxHashMap<ItemLocalId, Box<[TraitCandidate]>>,\n \n     /// NodeIds that are lowered inside the current HIR owner.\n-    local_node_ids: Vec<NodeId>,\n+    node_id_to_local_id: FxHashMap<NodeId, hir::ItemLocalId>,\n \n     allow_try_trait: Option<Lrc<[Symbol]>>,\n     allow_gen_future: Option<Lrc<[Symbol]>>,\n@@ -368,8 +370,9 @@ pub fn lower_crate<'a, 'hir>(\n         anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n         current_hir_id_owner: CRATE_DEF_ID,\n         item_local_id_counter: hir::ItemLocalId::new(0),\n-        node_id_to_hir_id: IndexVec::new(),\n-        local_node_ids: Vec::new(),\n+        node_id_to_local_id: FxHashMap::default(),\n+        local_id_to_def_id: SortedMap::new(),\n+        trait_map: FxHashMap::default(),\n         generator_kind: None,\n         task_context: None,\n         current_item: None,\n@@ -496,23 +499,26 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let current_attrs = std::mem::take(&mut self.attrs);\n         let current_bodies = std::mem::take(&mut self.bodies);\n-        let current_node_ids = std::mem::take(&mut self.local_node_ids);\n+        let current_node_ids = std::mem::take(&mut self.node_id_to_local_id);\n+        let current_id_to_def_id = std::mem::take(&mut self.local_id_to_def_id);\n+        let current_trait_map = std::mem::take(&mut self.trait_map);\n         let current_owner = std::mem::replace(&mut self.current_hir_id_owner, def_id);\n         let current_local_counter =\n             std::mem::replace(&mut self.item_local_id_counter, hir::ItemLocalId::new(1));\n \n         // Always allocate the first `HirId` for the owner itself.\n-        let _old = self.node_id_to_hir_id.insert(owner, hir::HirId::make_owner(def_id));\n+        let _old = self.node_id_to_local_id.insert(owner, hir::ItemLocalId::new(0));\n         debug_assert_eq!(_old, None);\n-        self.local_node_ids.push(owner);\n \n         let item = f(self);\n         debug_assert_eq!(def_id, item.def_id());\n         let info = self.make_owner_info(item);\n \n         self.attrs = current_attrs;\n         self.bodies = current_bodies;\n-        self.local_node_ids = current_node_ids;\n+        self.node_id_to_local_id = current_node_ids;\n+        self.local_id_to_def_id = current_id_to_def_id;\n+        self.trait_map = current_trait_map;\n         self.current_hir_id_owner = current_owner;\n         self.item_local_id_counter = current_local_counter;\n \n@@ -525,34 +531,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn make_owner_info(&mut self, node: hir::OwnerNode<'hir>) -> hir::OwnerInfo<'hir> {\n         let attrs = std::mem::take(&mut self.attrs);\n         let mut bodies = std::mem::take(&mut self.bodies);\n-        let local_node_ids = std::mem::take(&mut self.local_node_ids);\n-\n-        let local_id_to_def_id = local_node_ids\n-            .iter()\n-            .filter_map(|&node_id| {\n-                let hir_id = self.node_id_to_hir_id[node_id]?;\n-                if hir_id.local_id == hir::ItemLocalId::new(0) {\n-                    None\n-                } else {\n-                    let def_id = self.resolver.opt_local_def_id(node_id)?;\n-                    self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n-                    if let o @ hir::MaybeOwner::Phantom = &mut self.owners[def_id] {\n-                        // Do not override a `MaybeOwner::Owner` that may already here.\n-                        *o = hir::MaybeOwner::NonOwner(hir_id);\n-                    }\n-                    Some((hir_id.local_id, def_id))\n-                }\n-            })\n-            .collect();\n-\n-        let trait_map = local_node_ids\n-            .into_iter()\n-            .filter_map(|node_id| {\n-                let hir_id = self.node_id_to_hir_id[node_id]?;\n-                let traits = self.resolver.take_trait_map(node_id)?;\n-                Some((hir_id.local_id, traits.into_boxed_slice()))\n-            })\n-            .collect();\n \n         #[cfg(debug_assertions)]\n         for (id, attrs) in attrs.iter() {\n@@ -572,7 +550,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hash_without_bodies,\n             nodes,\n             bodies,\n-            local_id_to_def_id,\n+            local_id_to_def_id: std::mem::take(&mut self.local_id_to_def_id),\n         };\n         let attrs = {\n             let mut hcx = self.resolver.create_stable_hashing_context();\n@@ -582,7 +560,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir::AttributeMap { map: attrs, hash }\n         };\n \n-        hir::OwnerInfo { nodes, parenting, attrs, trait_map }\n+        hir::OwnerInfo { nodes, parenting, attrs, trait_map: std::mem::take(&mut self.trait_map) }\n     }\n \n     /// Hash the HIR node twice, one deep and one shallow hash.  This allows to differentiate\n@@ -615,14 +593,36 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_node_id(&mut self, ast_node_id: NodeId) -> hir::HirId {\n         assert_ne!(ast_node_id, DUMMY_NODE_ID);\n \n-        *self.node_id_to_hir_id.get_or_insert_with(ast_node_id, || {\n-            // Generate a new `HirId`.\n-            let owner = self.current_hir_id_owner;\n-            let local_id = self.item_local_id_counter;\n-            self.item_local_id_counter.increment_by(1);\n-            self.local_node_ids.push(ast_node_id);\n-            hir::HirId { owner, local_id }\n-        })\n+        match self.node_id_to_local_id.entry(ast_node_id) {\n+            Entry::Occupied(o) => {\n+                hir::HirId { owner: self.current_hir_id_owner, local_id: *o.get() }\n+            }\n+            Entry::Vacant(v) => {\n+                // Generate a new `HirId`.\n+                let owner = self.current_hir_id_owner;\n+                let local_id = self.item_local_id_counter;\n+                let hir_id = hir::HirId { owner, local_id };\n+\n+                v.insert(local_id);\n+                self.item_local_id_counter.increment_by(1);\n+\n+                assert_ne!(local_id, hir::ItemLocalId::new(0));\n+                if let Some(def_id) = self.resolver.opt_local_def_id(ast_node_id) {\n+                    self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n+                    if let o @ hir::MaybeOwner::Phantom = &mut self.owners[def_id] {\n+                        // Do not override a `MaybeOwner::Owner` that may already here.\n+                        *o = hir::MaybeOwner::NonOwner(hir_id);\n+                    }\n+                    self.local_id_to_def_id.insert(local_id, def_id);\n+                }\n+\n+                if let Some(traits) = self.resolver.take_trait_map(ast_node_id) {\n+                    self.trait_map.insert(hir_id.local_id, traits.into_boxed_slice());\n+                }\n+\n+                hir_id\n+            }\n+        }\n     }\n \n     fn next_id(&mut self) -> hir::HirId {\n@@ -631,11 +631,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_res(&mut self, res: Res<NodeId>) -> Res {\n-        res.map_id(|id| {\n-            self.node_id_to_hir_id.get(id).copied().flatten().unwrap_or_else(|| {\n-                panic!(\"expected `NodeId` to be lowered already for res {:#?}\", res);\n-            })\n-        })\n+        let res: Result<Res, ()> = res.apply_id(|id| {\n+            let owner = self.current_hir_id_owner;\n+            let local_id = self.node_id_to_local_id.get(&id).copied().ok_or(())?;\n+            Ok(hir::HirId { owner, local_id })\n+        });\n+        // We may fail to find a HirId when the Res points to a Local from an enclosing HIR owner.\n+        // This can happen when trying to lower the return type `x` in erroneous code like\n+        //   async fn foo(x: u8) -> x {}\n+        // In that case, `x` is lowered as a function parameter, and the return type is lowered as\n+        // an opaque type as a synthetized HIR owner.\n+        res.unwrap_or(Res::Err)\n     }\n \n     fn expect_full_res(&mut self, id: NodeId) -> Res<NodeId> {\n@@ -1476,14 +1482,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let lifetime_defs =\n                 lctx.arena.alloc_from_iter(collected_lifetimes.iter().map(|&(name, span)| {\n                     let def_node_id = lctx.resolver.next_node_id();\n-                    let hir_id = lctx.lower_node_id(def_node_id);\n                     lctx.resolver.create_def(\n                         opaque_ty_def_id,\n                         def_node_id,\n                         DefPathData::LifetimeNs(name.ident().name),\n                         ExpnId::root(),\n                         span.with_parent(None),\n                     );\n+                    let hir_id = lctx.lower_node_id(def_node_id);\n \n                     let (name, kind) = match name {\n                         hir::LifetimeName::Underscore => ("}, {"sha": "a2f97f65708570468e0aa2dd1d9cb35151e6494b", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8ebec97e09a89760e5791bbb2ab96e2ebec19931/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebec97e09a89760e5791bbb2ab96e2ebec19931/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=8ebec97e09a89760e5791bbb2ab96e2ebec19931", "patch": "@@ -611,6 +611,19 @@ impl<Id> Res<Id> {\n         }\n     }\n \n+    pub fn apply_id<R, E>(self, mut map: impl FnMut(Id) -> Result<R, E>) -> Result<Res<R>, E> {\n+        Ok(match self {\n+            Res::Def(kind, id) => Res::Def(kind, id),\n+            Res::SelfCtor(id) => Res::SelfCtor(id),\n+            Res::PrimTy(id) => Res::PrimTy(id),\n+            Res::Local(id) => Res::Local(map(id)?),\n+            Res::SelfTy { trait_, alias_to } => Res::SelfTy { trait_, alias_to },\n+            Res::ToolMod => Res::ToolMod,\n+            Res::NonMacroAttr(attr_kind) => Res::NonMacroAttr(attr_kind),\n+            Res::Err => Res::Err,\n+        })\n+    }\n+\n     #[track_caller]\n     pub fn expect_non_local<OtherId>(self) -> Res<OtherId> {\n         self.map_id(|_| panic!(\"unexpected `Res::Local`\"))"}]}