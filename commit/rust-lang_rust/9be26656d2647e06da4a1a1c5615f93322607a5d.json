{"sha": "9be26656d2647e06da4a1a1c5615f93322607a5d", "node_id": "C_kwDOAAsO6NoAKDliZTI2NjU2ZDI2NDdlMDZkYTRhMWExYzU2MTVmOTMzMjI2MDdhNWQ", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-09-29T05:43:28Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-10-03T21:33:56Z"}, "message": "Rewrite gather/scatter docs\n\nHeadings with # Safety and # Examples are more \"std style\".\nUse terms like \"enable\" and \"disable\", rather than \"mask\" jargon.", "tree": {"sha": "09cd468c97a5a6aa5b4b23d9bf89615420c1bc82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09cd468c97a5a6aa5b4b23d9bf89615420c1bc82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9be26656d2647e06da4a1a1c5615f93322607a5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9be26656d2647e06da4a1a1c5615f93322607a5d", "html_url": "https://github.com/rust-lang/rust/commit/9be26656d2647e06da4a1a1c5615f93322607a5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9be26656d2647e06da4a1a1c5615f93322607a5d/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01e9816ace1b30935a076395e23a239bd08ea1a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/01e9816ace1b30935a076395e23a239bd08ea1a4", "html_url": "https://github.com/rust-lang/rust/commit/01e9816ace1b30935a076395e23a239bd08ea1a4"}], "stats": {"total": 109, "additions": 69, "deletions": 40}, "files": [{"sha": "a043ef2074e8d202f297524c51c870edcb1e45c1", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 69, "deletions": 40, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/9be26656d2647e06da4a1a1c5615f93322607a5d/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be26656d2647e06da4a1a1c5615f93322607a5d/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=9be26656d2647e06da4a1a1c5615f93322607a5d", "patch": "@@ -57,8 +57,10 @@ where\n         self.0\n     }\n \n-    /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n-    /// If an index is out of bounds, that lane instead selects the value from the \"or\" vector.\n+    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n+    /// Lanes given an out-of-bounds index instead select values from the `or` vector.\n+    ///\n+    /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n@@ -76,8 +78,10 @@ where\n         Self::gather_select(slice, Mask::splat(true), idxs, or)\n     }\n \n-    /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n-    /// Out-of-bounds indices instead use the default value for that lane (0).\n+    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n+    /// Lanes given an out-of-bounds index instead are set the default value for the type.\n+    ///\n+    /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n@@ -97,69 +101,82 @@ where\n         Self::gather_or(slice, idxs, Self::splat(T::default()))\n     }\n \n-    /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n-    /// Out-of-bounds or masked indices instead select the value from the \"or\" vector.\n+    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n+    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n+    /// If an index is disabled or is out-of-bounds, the lane is selected from the `or` vector.\n+    ///\n+    /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n     /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 5]);\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n-    /// let mask = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n     ///\n-    /// let result = Simd::gather_select(&vec, mask, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// let result = Simd::gather_select(&vec, enable, idxs, alt); // Note the lane that is out-of-bounds.\n     /// assert_eq!(result, Simd::from_array([-5, 13, 10, -2]));\n     /// ```\n     #[must_use]\n     #[inline]\n     pub fn gather_select(\n         slice: &[T],\n-        mask: Mask<isize, LANES>,\n+        enable: Mask<isize, LANES>,\n         idxs: Simd<usize, LANES>,\n         or: Self,\n     ) -> Self {\n-        let mask: Mask<isize, LANES> = mask & idxs.lanes_lt(Simd::splat(slice.len()));\n+        let enable: Mask<isize, LANES> = enable & idxs.lanes_lt(Simd::splat(slice.len()));\n         // SAFETY: We have masked-off out-of-bounds lanes.\n-        unsafe { Self::gather_select_unchecked(slice, mask, idxs, or) }\n+        unsafe { Self::gather_select_unchecked(slice, enable, idxs, or) }\n     }\n \n-    /// Unsafe SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n-    /// Masked indices instead select the value from the \"or\" vector.\n-    /// `gather_select_unchecked` is unsound if any unmasked index is out-of-bounds of the slice.\n+    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n+    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n+    /// If an index is disabled, the lane is selected from the `or` vector.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Calling this function with an `enable`d out-of-bounds index is *[undefined behavior]*\n+    /// even if the resulting value is not used.\n+    ///\n+    /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n     /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 5]);\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n-    /// let mask = Mask::from_array([true, true, true, false]); // Note the final mask lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Note the final mask lane.\n     /// // If this mask was used to gather, it would be unsound. Let's fix that.\n-    /// let mask = mask & idxs.lanes_lt(Simd::splat(vec.len()));\n+    /// let enable = enable & idxs.lanes_lt(Simd::splat(vec.len()));\n     ///\n     /// // We have masked the OOB lane, so it's safe to gather now.\n-    /// let result = unsafe { Simd::gather_select_unchecked(&vec, mask, idxs, alt) };\n+    /// let result = unsafe { Simd::gather_select_unchecked(&vec, enable, idxs, alt) };\n     /// assert_eq!(result, Simd::from_array([-5, 13, 10, -2]));\n     /// ```\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     #[must_use]\n     #[inline]\n     pub unsafe fn gather_select_unchecked(\n         slice: &[T],\n-        mask: Mask<isize, LANES>,\n+        enable: Mask<isize, LANES>,\n         idxs: Simd<usize, LANES>,\n         or: Self,\n     ) -> Self {\n         let base_ptr = crate::simd::ptr::SimdConstPtr::splat(slice.as_ptr());\n         // Ferris forgive me, I have done pointer arithmetic here.\n         let ptrs = base_ptr.wrapping_add(idxs);\n         // SAFETY: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n-        unsafe { intrinsics::simd_gather(or, ptrs, mask.to_int()) }\n+        unsafe { intrinsics::simd_gather(or, ptrs, enable.to_int()) }\n     }\n \n-    /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n-    /// Out-of-bounds indices are not written.\n-    /// `scatter` writes \"in order\", so if an index receives two writes, only the last is guaranteed.\n+    /// Writes the values in a SIMD vector to potentially discontiguous indices in `slice`.\n+    /// If two lanes in the scattered vector would write to the same index\n+    /// only the last lane is guaranteed to actually be written.\n+    ///\n+    /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n@@ -176,58 +193,70 @@ where\n         self.scatter_select(slice, Mask::splat(true), idxs)\n     }\n \n-    /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n-    /// Out-of-bounds or masked indices are not written.\n-    /// `scatter_select` writes \"in order\", so if an index receives two writes, only the last is guaranteed.\n+    /// Writes the values in a SIMD vector to multiple potentially discontiguous indices in `slice`.\n+    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n+    /// If an enabled index is out-of-bounds, the lane is not written.\n+    /// If two enabled lanes in the scattered vector would write to the same index,\n+    /// only the last lane is guaranteed to actually be written.\n+    ///\n+    /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n     /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 0]);\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n-    /// let mask = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n     ///\n-    /// vals.scatter_select(&mut vec, mask, idxs); // index 0's second write is masked, thus omitted.\n+    /// vals.scatter_select(&mut vec, enable, idxs); // index 0's second write is masked, thus omitted.\n     /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n     /// ```\n     #[inline]\n     pub fn scatter_select(\n         self,\n         slice: &mut [T],\n-        mask: Mask<isize, LANES>,\n+        enable: Mask<isize, LANES>,\n         idxs: Simd<usize, LANES>,\n     ) {\n-        let mask: Mask<isize, LANES> = mask & idxs.lanes_lt(Simd::splat(slice.len()));\n+        let enable: Mask<isize, LANES> = enable & idxs.lanes_lt(Simd::splat(slice.len()));\n         // SAFETY: We have masked-off out-of-bounds lanes.\n-        unsafe { self.scatter_select_unchecked(slice, mask, idxs) }\n+        unsafe { self.scatter_select_unchecked(slice, enable, idxs) }\n     }\n \n-    /// Unsafe SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n-    /// Out-of-bounds or masked indices are not written.\n-    /// `scatter_select_unchecked` is unsound if any unmasked index is out of bounds of the slice.\n-    /// `scatter_select_unchecked` writes \"in order\", so if the same index receives two writes, only the last is guaranteed.\n+    /// Writes the values in a SIMD vector to multiple potentially discontiguous indices in `slice`.\n+    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n+    /// If two enabled lanes in the scattered vector would write to the same index,\n+    /// only the last lane is guaranteed to actually be written.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Calling this function with an enabled out-of-bounds index is *[undefined behavior]*,\n+    /// and may lead to memory corruption.\n+    ///\n+    /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n     /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 0]);\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n-    /// let mask = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n     /// // If this mask was used to scatter, it would be unsound. Let's fix that.\n-    /// let mask = mask & idxs.lanes_lt(Simd::splat(vec.len()));\n+    /// let enable = enable & idxs.lanes_lt(Simd::splat(vec.len()));\n     ///\n     /// // We have masked the OOB lane, so it's safe to scatter now.\n-    /// unsafe { vals.scatter_select_unchecked(&mut vec, mask, idxs); }\n+    /// unsafe { vals.scatter_select_unchecked(&mut vec, enable, idxs); }\n     /// // index 0's second write is masked, thus was omitted.\n     /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n     /// ```\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     #[inline]\n     pub unsafe fn scatter_select_unchecked(\n         self,\n         slice: &mut [T],\n-        mask: Mask<isize, LANES>,\n+        enable: Mask<isize, LANES>,\n         idxs: Simd<usize, LANES>,\n     ) {\n         // SAFETY: This block works with *mut T derived from &mut 'a [T],\n@@ -237,7 +266,7 @@ where\n         // to prevent invalidating the raw ptrs while they're live.\n         // Thus, entering this block requires all values to use being already ready:\n         // 0. idxs we want to write to, which are used to construct the mask.\n-        // 1. mask, which depends on an initial &'a [T] and the idxs.\n+        // 1. enable, which depends on an initial &'a [T] and the idxs.\n         // 2. actual values to scatter (self).\n         // 3. &mut [T] which will become our base ptr.\n         unsafe {\n@@ -246,7 +275,7 @@ where\n             // Ferris forgive me, I have done pointer arithmetic here.\n             let ptrs = base_ptr.wrapping_add(idxs);\n             // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n-            intrinsics::simd_scatter(self, ptrs, mask.to_int())\n+            intrinsics::simd_scatter(self, ptrs, enable.to_int())\n             // Cleared \u2622\ufe0f *mut T Zone\n         }\n     }"}]}