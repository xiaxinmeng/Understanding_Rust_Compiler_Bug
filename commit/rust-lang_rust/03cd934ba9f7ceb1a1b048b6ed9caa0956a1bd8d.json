{"sha": "03cd934ba9f7ceb1a1b048b6ed9caa0956a1bd8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzY2Q5MzRiYTlmN2NlYjFhMWIwNDhiNmVkOWNhYTA5NTZhMWJkOGQ=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2018-12-20T09:02:12Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-01-04T02:58:21Z"}, "message": "Ensure that we properly increment obligation depth", "tree": {"sha": "6cf2205d90ab3604c0b15f4fdf888ae0d45914e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cf2205d90ab3604c0b15f4fdf888ae0d45914e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03cd934ba9f7ceb1a1b048b6ed9caa0956a1bd8d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAlwuy80ACgkQtAh+UQ6Y\nsWRmdg/8DxZPiMicxTA90fpLe4cXVWja2ZIK69iEjeSzIBFyu7ppJLmc2QwFxoAZ\nxGJw43FCeICoyYE2g+kxPE6+rKV7uaZmiqhxeudHsK2lEzUb4P6fijm1Kz6QVMkO\nt2kfDGKwwfu6rcQLUlNP8AuS6C2C6aQikHL7ozAPJUtAYt2QEpk/RarLXlRG9/Xx\nIXObGAWs9TUenod6RCNJ7YVQp5IaQeEPR61/a43S8v2Qsx4L08iM2uVK4wooA7t0\nJejjB0DQD33hgvEMpgtJ1W8jrgy0mOVFLG0Xmx0eg9CfndIg48v+r2b6gHqblv2a\noPtrofI+Xwz6KFAjQhkT4YrToc5FAsRzspsjhmXz9ohtczfaWDUmTmbCQdvKoYI1\nBTkuIzxuSrCy6fPbAuxz2t6xbxUxTmqhG0YD0I7Yk3UXQrzPXtUYLkaws8P8pVHU\n+ZLVojnGRgSONrg29YOtX15CfCvXHcIuOtUyykJYQ3aOPfrOJReCjKUX27/3TLF+\nJA0k/8bkWSyPCMzUH4QD7luxzKsRFKIZIuGRlivRU/kGjpngtCt8/IBSdAXKQGZZ\nBlbg7/eP0xIHRT//sg4tvEQdhz4C7SiEorSuMYW18XdiMEy3We1Dr6UZAGVZG8eo\nFr0kpspnyFtJrdrQwldqrj0W0CLweCP4NXcYTzVQUza6GObJV14=\n=wzof\n-----END PGP SIGNATURE-----", "payload": "tree 6cf2205d90ab3604c0b15f4fdf888ae0d45914e7\nparent 54fd8caddc980a6ad47069d9674b4f59b1cd7da0\nauthor Aaron Hill <aa1ronham@gmail.com> 1545296532 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1546570701 -0500\n\nEnsure that we properly increment obligation depth\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03cd934ba9f7ceb1a1b048b6ed9caa0956a1bd8d", "html_url": "https://github.com/rust-lang/rust/commit/03cd934ba9f7ceb1a1b048b6ed9caa0956a1bd8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03cd934ba9f7ceb1a1b048b6ed9caa0956a1bd8d/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54fd8caddc980a6ad47069d9674b4f59b1cd7da0", "url": "https://api.github.com/repos/rust-lang/rust/commits/54fd8caddc980a6ad47069d9674b4f59b1cd7da0", "html_url": "https://github.com/rust-lang/rust/commit/54fd8caddc980a6ad47069d9674b4f59b1cd7da0"}], "stats": {"total": 45, "additions": 24, "deletions": 21}, "files": [{"sha": "2eb717c7c7f5f1a645b9e836e8539d1c8dcfbce0", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/03cd934ba9f7ceb1a1b048b6ed9caa0956a1bd8d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03cd934ba9f7ceb1a1b048b6ed9caa0956a1bd8d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=03cd934ba9f7ceb1a1b048b6ed9caa0956a1bd8d", "patch": "@@ -42,7 +42,7 @@ use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::Lock;\n use rustc_target::spec::abi::Abi;\n use std::cmp;\n-use std::fmt;\n+use std::fmt::{self, Display};\n use std::iter;\n use std::rc::Rc;\n use util::nodemap::{FxHashMap, FxHashSet};\n@@ -660,7 +660,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in predicates {\n-            let eval = self.evaluate_predicate_recursively(stack, obligation)?;\n+            let eval = self.evaluate_predicate_recursively(stack, obligation.clone())?;\n             debug!(\n                 \"evaluate_predicate_recursively({:?}) = {:?}\",\n                 obligation, eval\n@@ -682,13 +682,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         obligation: PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n         debug!(\"evaluate_predicate_recursively({:?})\", obligation);\n-        self.check_recursion_limit(obligation)?;\n+        self.check_recursion_limit(&obligation)?;\n \n         match obligation.predicate {\n             ty::Predicate::Trait(ref t) => {\n                 debug_assert!(!t.has_escaping_bound_vars());\n                 let mut obligation = obligation.with(t.clone());\n-                obligation.recursion_depth += 1\n+                obligation.recursion_depth += 1;\n                 self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n             }\n \n@@ -697,11 +697,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 match self.infcx\n                     .subtype_predicate(&obligation.cause, obligation.param_env, p)\n                 {\n-                    Some(Ok(InferOk { obligations, .. })) => {\n-                        for o in obligations.iter_mut() {\n-                            o.recursion_depth += 1\n-                        }\n-                        self.evaluate_predicates_recursively(previous_stack, obligation.into_iter())\n+                    Some(Ok(InferOk { mut obligations, .. })) => {\n+                        self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n+                        self.evaluate_predicates_recursively(previous_stack, obligations.into_iter())\n                     }\n                     Some(Err(_)) => Ok(EvaluatedToErr),\n                     None => Ok(EvaluatedToAmbig),\n@@ -715,11 +713,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 ty,\n                 obligation.cause.span,\n             ) {\n-                Some(obligations) => {\n-                    for o in obligations.iter_mut() {\n-                        o.recursion_depth += 1\n-                    }\n-                    self.evaluate_predicates_recursively(previous_stack, obligations.iter())\n+                Some(mut obligations) => {\n+                    self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n+                    self.evaluate_predicates_recursively(previous_stack, obligations.into_iter())\n                 }\n                 None => Ok(EvaluatedToAmbig),\n             },\n@@ -741,10 +737,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::Predicate::Projection(ref data) => {\n                 let project_obligation = obligation.with(data.clone());\n                 match project::poly_project_and_unify_type(self, &project_obligation) {\n-                    Ok(Some(subobligations)) => {\n-                        for o in subobligations.iter_mut() {\n-                            o.recursion_depth += 1\n-                        }\n+                    Ok(Some(mut subobligations)) => {\n+                        self.add_depth(subobligations.iter_mut(), obligation.recursion_depth);\n                         let result = self.evaluate_predicates_recursively(\n                             previous_stack,\n                             subobligations.into_iter(),\n@@ -1016,7 +1010,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             match this.confirm_candidate(stack.obligation, candidate) {\n                 Ok(selection) => this.evaluate_predicates_recursively(\n                     stack.list(),\n-                    selection.nested_obligations().iter(),\n+                    selection.nested_obligations().into_iter(),\n                 ),\n                 Err(..) => Ok(EvaluatedToErr),\n             }\n@@ -1091,14 +1085,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .insert(trait_ref, WithDepNode::new(dep_node, result));\n     }\n \n+    // Due to caching of projection results, it's possible for a subobligation\n+    // to have a *lower* recursion_depth than the obligation used to create it.\n+    // To ensure that obligation_depth never decreasees, we force all subobligations\n+    // to have at least the depth of the original obligation.\n+    fn add_depth<T: 'cx, I: Iterator<Item = &'cx mut Obligation<'tcx, T>>>(&self, it: I,\n+                                                                           min_depth: usize) {\n+        it.for_each(|o| o.recursion_depth = cmp::max(min_depth, o.recursion_depth) + 1);\n+    }\n+\n     // Check that the recursion limit has not been exceeded.\n     //\n     // The weird return type of this function allows it to be used with the 'try' (?)\n     // operator within certain functions\n     fn check_recursion_limit<T: Display + TypeFoldable<'tcx>>(&self, obligation: &Obligation<'tcx, T>,\n     ) -> Result<(), OverflowError>  {\n         let recursion_limit = *self.infcx.tcx.sess.recursion_limit.get();\n-        if obligaton.recursion_depth >= recursion_limit {\n+        if obligation.recursion_depth >= recursion_limit {\n             match self.query_mode {\n                 TraitQueryMode::Standard => {\n                     self.infcx().report_overflow_error(obligation, true);\n@@ -1796,7 +1799,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.evaluation_probe(|this| {\n             match this.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n-                    this.evaluate_predicates_recursively(stack.list(), obligations.iter())\n+                    this.evaluate_predicates_recursively(stack.list(), obligations.into_iter())\n                 }\n                 Err(()) => Ok(EvaluatedToErr),\n             }"}]}