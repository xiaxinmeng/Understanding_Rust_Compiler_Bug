{"sha": "1b7b8cbed32987eda783dae0739b9e52edc8db5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiN2I4Y2JlZDMyOTg3ZWRhNzgzZGFlMDczOWI5ZTUyZWRjOGRiNWU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-01-15T17:19:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-15T17:19:24Z"}, "message": "Rollup merge of #68123 - crlf0710:linked_list_cursor, r=Amanieu\n\nImplement Cursor for linked lists. (RFC 2570).\n\ncc. #58533 cc. @Gankra\n\nr? @Amanieu", "tree": {"sha": "1e2e7864bb678d5ead73e945888e9788915e8843", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e2e7864bb678d5ead73e945888e9788915e8843"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b7b8cbed32987eda783dae0739b9e52edc8db5e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeH0mcCRBK7hj4Ov3rIwAAdHIIACYdUHp4hD/xOKkNs6leyujc\nzSkhUv5T/UfMJ5pv2HpLVG2SSFaF9Zr6f9Mfm/Nsx3zZwZ7qdyFgs28N/WZtazrb\n1PKPL8Mh/r4hjlQkD3d7QM7SvZT/C2cibQhHBSKe8PWnKBMEny20s2e+/ii5jFNM\nsoFVUvzlMDpSU2dHeD6jNa2oJ+WzXQL8m7AZE5epbUhOs2bTqW6ASbFqE9nuG2qf\nFhDTk6V0avwhi7LSa+i/xQojLg9mRXnPXF2lNXO9MIOcD2WlkmKO0hplF3wDrDMQ\nh30gh1xp7laxTDvlepm54W3Bq2kaPVTLb2rjlnPoOZhweyxD0b1So8ZLfMLoYnw=\n=zzrS\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e2e7864bb678d5ead73e945888e9788915e8843\nparent 6d0bb91bcba33a70fae4b0c663fb4403ed78f071\nparent 06b9a73cfa5ef1cb6fb9160d61f1beada2b81b79\nauthor Dylan DPC <dylan.dpc@gmail.com> 1579108764 +0530\ncommitter GitHub <noreply@github.com> 1579108764 +0530\n\nRollup merge of #68123 - crlf0710:linked_list_cursor, r=Amanieu\n\nImplement Cursor for linked lists. (RFC 2570).\n\ncc. #58533 cc. @Gankra\n\nr? @Amanieu\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b7b8cbed32987eda783dae0739b9e52edc8db5e", "html_url": "https://github.com/rust-lang/rust/commit/1b7b8cbed32987eda783dae0739b9e52edc8db5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b7b8cbed32987eda783dae0739b9e52edc8db5e/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d0bb91bcba33a70fae4b0c663fb4403ed78f071", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d0bb91bcba33a70fae4b0c663fb4403ed78f071", "html_url": "https://github.com/rust-lang/rust/commit/6d0bb91bcba33a70fae4b0c663fb4403ed78f071"}, {"sha": "06b9a73cfa5ef1cb6fb9160d61f1beada2b81b79", "url": "https://api.github.com/repos/rust-lang/rust/commits/06b9a73cfa5ef1cb6fb9160d61f1beada2b81b79", "html_url": "https://github.com/rust-lang/rust/commit/06b9a73cfa5ef1cb6fb9160d61f1beada2b81b79"}], "stats": {"total": 731, "additions": 707, "deletions": 24}, "files": [{"sha": "b88ca8a0fb0d10870be027d9863fe7224ad61aba", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 555, "deletions": 24, "changes": 579, "blob_url": "https://github.com/rust-lang/rust/blob/1b7b8cbed32987eda783dae0739b9e52edc8db5e/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7b8cbed32987eda783dae0739b9e52edc8db5e/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=1b7b8cbed32987eda783dae0739b9e52edc8db5e", "patch": "@@ -242,6 +242,121 @@ impl<T> LinkedList<T> {\n \n         self.len -= 1;\n     }\n+\n+    /// Splices a series of nodes between two existing nodes.\n+    ///\n+    /// Warning: this will not check that the provided node belongs to the two existing lists.\n+    #[inline]\n+    unsafe fn splice_nodes(\n+        &mut self,\n+        existing_prev: Option<NonNull<Node<T>>>,\n+        existing_next: Option<NonNull<Node<T>>>,\n+        mut splice_start: NonNull<Node<T>>,\n+        mut splice_end: NonNull<Node<T>>,\n+        splice_length: usize,\n+    ) {\n+        // This method takes care not to create multiple mutable references to whole nodes at the same time,\n+        // to maintain validity of aliasing pointers into `element`.\n+        if let Some(mut existing_prev) = existing_prev {\n+            existing_prev.as_mut().next = Some(splice_start);\n+        } else {\n+            self.head = Some(splice_start);\n+        }\n+        if let Some(mut existing_next) = existing_next {\n+            existing_next.as_mut().prev = Some(splice_end);\n+        } else {\n+            self.tail = Some(splice_end);\n+        }\n+        splice_start.as_mut().prev = existing_prev;\n+        splice_end.as_mut().next = existing_next;\n+\n+        self.len += splice_length;\n+    }\n+\n+    /// Detaches all nodes from a linked list as a series of nodes.\n+    #[inline]\n+    fn detach_all_nodes(mut self) -> Option<(NonNull<Node<T>>, NonNull<Node<T>>, usize)> {\n+        let head = self.head.take();\n+        let tail = self.tail.take();\n+        let len = mem::replace(&mut self.len, 0);\n+        if let Some(head) = head {\n+            let tail = tail.unwrap_or_else(|| unsafe { core::hint::unreachable_unchecked() });\n+            Some((head, tail, len))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn split_off_before_node(\n+        &mut self,\n+        split_node: Option<NonNull<Node<T>>>,\n+        at: usize,\n+    ) -> Self {\n+        // The split node is the new head node of the second part\n+        if let Some(mut split_node) = split_node {\n+            let first_part_head;\n+            let first_part_tail;\n+            first_part_tail = split_node.as_mut().prev.take();\n+            if let Some(mut tail) = first_part_tail {\n+                tail.as_mut().next = None;\n+                first_part_head = self.head;\n+            } else {\n+                first_part_head = None;\n+            }\n+\n+            let first_part = LinkedList {\n+                head: first_part_head,\n+                tail: first_part_tail,\n+                len: at,\n+                marker: PhantomData,\n+            };\n+\n+            // Fix the head ptr of the second part\n+            self.head = Some(split_node);\n+            self.len = self.len - at;\n+\n+            first_part\n+        } else {\n+            mem::replace(self, LinkedList::new())\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn split_off_after_node(\n+        &mut self,\n+        split_node: Option<NonNull<Node<T>>>,\n+        at: usize,\n+    ) -> Self {\n+        // The split node is the new tail node of the first part and owns\n+        // the head of the second part.\n+        if let Some(mut split_node) = split_node {\n+            let second_part_head;\n+            let second_part_tail;\n+            second_part_head = split_node.as_mut().next.take();\n+            if let Some(mut head) = second_part_head {\n+                head.as_mut().prev = None;\n+                second_part_tail = self.tail;\n+            } else {\n+                second_part_tail = None;\n+            }\n+\n+            let second_part = LinkedList {\n+                head: second_part_head,\n+                tail: second_part_tail,\n+                len: self.len - at,\n+                marker: PhantomData,\n+            };\n+\n+            // Fix the tail ptr of the first part\n+            self.tail = Some(split_node);\n+            self.len = at;\n+\n+            second_part\n+        } else {\n+            mem::replace(self, LinkedList::new())\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -319,6 +434,27 @@ impl<T> LinkedList<T> {\n         }\n     }\n \n+    /// Moves all elements from `other` to the begin of the list.\n+    #[unstable(feature = \"linked_list_prepend\", issue = \"none\")]\n+    pub fn prepend(&mut self, other: &mut Self) {\n+        match self.head {\n+            None => mem::swap(self, other),\n+            Some(mut head) => {\n+                // `as_mut` is okay here because we have exclusive access to the entirety\n+                // of both lists.\n+                if let Some(mut other_tail) = other.tail.take() {\n+                    unsafe {\n+                        head.as_mut().prev = Some(other_tail);\n+                        other_tail.as_mut().next = Some(head);\n+                    }\n+\n+                    self.head = other.head.take();\n+                    self.len += mem::replace(&mut other.len, 0);\n+                }\n+            }\n+        }\n+    }\n+\n     /// Provides a forward iterator.\n     ///\n     /// # Examples\n@@ -373,6 +509,42 @@ impl<T> LinkedList<T> {\n         IterMut { head: self.head, tail: self.tail, len: self.len, list: self }\n     }\n \n+    /// Provides a cursor at the front element.\n+    ///\n+    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n+    #[inline]\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn cursor_front(&self) -> Cursor<'_, T> {\n+        Cursor { index: 0, current: self.head, list: self }\n+    }\n+\n+    /// Provides a cursor with editing operations at the front element.\n+    ///\n+    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n+    #[inline]\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn cursor_front_mut(&mut self) -> CursorMut<'_, T> {\n+        CursorMut { index: 0, current: self.head, list: self }\n+    }\n+\n+    /// Provides a cursor at the back element.\n+    ///\n+    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n+    #[inline]\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn cursor_back(&self) -> Cursor<'_, T> {\n+        Cursor { index: self.len.checked_sub(1).unwrap_or(0), current: self.tail, list: self }\n+    }\n+\n+    /// Provides a cursor with editing operations at the back element.\n+    ///\n+    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n+    #[inline]\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn cursor_back_mut(&mut self) -> CursorMut<'_, T> {\n+        CursorMut { index: self.len.checked_sub(1).unwrap_or(0), current: self.tail, list: self }\n+    }\n+\n     /// Returns `true` if the `LinkedList` is empty.\n     ///\n     /// This operation should compute in O(1) time.\n@@ -703,30 +875,7 @@ impl<T> LinkedList<T> {\n             }\n             iter.tail\n         };\n-\n-        // The split node is the new tail node of the first part and owns\n-        // the head of the second part.\n-        let second_part_head;\n-\n-        unsafe {\n-            second_part_head = split_node.unwrap().as_mut().next.take();\n-            if let Some(mut head) = second_part_head {\n-                head.as_mut().prev = None;\n-            }\n-        }\n-\n-        let second_part = LinkedList {\n-            head: second_part_head,\n-            tail: self.tail,\n-            len: len - at,\n-            marker: PhantomData,\n-        };\n-\n-        // Fix the tail ptr of the first part\n-        self.tail = split_node;\n-        self.len = at;\n-\n-        second_part\n+        unsafe { self.split_off_after_node(split_node, at) }\n     }\n \n     /// Creates an iterator which uses a closure to determine if an element should be removed.\n@@ -986,6 +1135,388 @@ impl<T> IterMut<'_, T> {\n     }\n }\n \n+/// A cursor over a `LinkedList`.\n+///\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth.\n+///\n+/// Cursors always rest between two elements in the list, and index in a logically circular way.\n+/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the head and\n+/// tail of the list.\n+///\n+/// When created, cursors start at the front of the list, or the \"ghost\" non-element if the list is empty.\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+pub struct Cursor<'a, T: 'a> {\n+    index: usize,\n+    current: Option<NonNull<Node<T>>>,\n+    list: &'a LinkedList<T>,\n+}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+impl<T: fmt::Debug> fmt::Debug for Cursor<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Cursor\").field(&self.list).field(&self.index()).finish()\n+    }\n+}\n+\n+/// A cursor over a `LinkedList` with editing operations.\n+///\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth, and can\n+/// safely mutate the list during iteration. This is because the lifetime of its yielded\n+/// references is tied to its own lifetime, instead of just the underlying list. This means\n+/// cursors cannot yield multiple elements at once.\n+///\n+/// Cursors always rest between two elements in the list, and index in a logically circular way.\n+/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the head and\n+/// tail of the list.\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+pub struct CursorMut<'a, T: 'a> {\n+    index: usize,\n+    current: Option<NonNull<Node<T>>>,\n+    list: &'a mut LinkedList<T>,\n+}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+impl<T: fmt::Debug> fmt::Debug for CursorMut<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"CursorMut\").field(&self.list).field(&self.index()).finish()\n+    }\n+}\n+\n+impl<'a, T> Cursor<'a, T> {\n+    /// Returns the cursor position index within the `LinkedList`.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn index(&self) -> Option<usize> {\n+        let _ = self.current?;\n+        Some(self.index)\n+    }\n+\n+    /// Moves the cursor to the next element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_next(&mut self) {\n+        match self.current.take() {\n+            // We had no current element; the cursor was sitting at the start position\n+            // Next element should be the head of the list\n+            None => {\n+                self.current = self.list.head;\n+                self.index = 0;\n+            }\n+            // We had a previous element, so let's go to its next\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().next;\n+                self.index += 1;\n+            },\n+        }\n+    }\n+\n+    /// Moves the cursor to the previous element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_prev(&mut self) {\n+        match self.current.take() {\n+            // No current. We're at the start of the list. Yield None and jump to the end.\n+            None => {\n+                self.current = self.list.tail;\n+                self.index = self.list.len().checked_sub(1).unwrap_or(0);\n+            }\n+            // Have a prev. Yield it and go to the previous element.\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().prev;\n+                self.index = self.index.checked_sub(1).unwrap_or_else(|| self.list.len());\n+            },\n+        }\n+    }\n+\n+    /// Returns a reference to the element that the cursor is currently\n+    /// pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn current(&self) -> Option<&'a T> {\n+        unsafe { self.current.map(|current| &(*current.as_ptr()).element) }\n+    }\n+\n+    /// Returns a reference to the next element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this returns `None`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_next(&self) -> Option<&'a T> {\n+        unsafe {\n+            let next = match self.current {\n+                None => self.list.head,\n+                Some(current) => current.as_ref().next,\n+            };\n+            next.map(|next| &(*next.as_ptr()).element)\n+        }\n+    }\n+\n+    /// Returns a reference to the previous element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this returns `None`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_prev(&self) -> Option<&'a T> {\n+        unsafe {\n+            let prev = match self.current {\n+                None => self.list.tail,\n+                Some(current) => current.as_ref().prev,\n+            };\n+            prev.map(|prev| &(*prev.as_ptr()).element)\n+        }\n+    }\n+}\n+\n+impl<'a, T> CursorMut<'a, T> {\n+    /// Returns the cursor position index within the `LinkedList`.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn index(&self) -> Option<usize> {\n+        let _ = self.current?;\n+        Some(self.index)\n+    }\n+\n+    /// Moves the cursor to the next element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_next(&mut self) {\n+        match self.current.take() {\n+            // We had no current element; the cursor was sitting at the start position\n+            // Next element should be the head of the list\n+            None => {\n+                self.current = self.list.head;\n+                self.index = 0;\n+            }\n+            // We had a previous element, so let's go to its next\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().next;\n+                self.index += 1;\n+            },\n+        }\n+    }\n+\n+    /// Moves the cursor to the previous element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_prev(&mut self) {\n+        match self.current.take() {\n+            // No current. We're at the start of the list. Yield None and jump to the end.\n+            None => {\n+                self.current = self.list.tail;\n+                self.index = self.list.len().checked_sub(1).unwrap_or(0);\n+            }\n+            // Have a prev. Yield it and go to the previous element.\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().prev;\n+                self.index = self.index.checked_sub(1).unwrap_or_else(|| self.list.len());\n+            },\n+        }\n+    }\n+\n+    /// Returns a reference to the element that the cursor is currently\n+    /// pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn current(&mut self) -> Option<&mut T> {\n+        unsafe { self.current.map(|current| &mut (*current.as_ptr()).element) }\n+    }\n+\n+    /// Returns a reference to the next element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this returns `None`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_next(&mut self) -> Option<&mut T> {\n+        unsafe {\n+            let next = match self.current {\n+                None => self.list.head,\n+                Some(current) => current.as_ref().next,\n+            };\n+            next.map(|next| &mut (*next.as_ptr()).element)\n+        }\n+    }\n+\n+    /// Returns a reference to the previous element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this returns `None`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_prev(&mut self) -> Option<&mut T> {\n+        unsafe {\n+            let prev = match self.current {\n+                None => self.list.tail,\n+                Some(current) => current.as_ref().prev,\n+            };\n+            prev.map(|prev| &mut (*prev.as_ptr()).element)\n+        }\n+    }\n+\n+    /// Returns a read-only cursor pointing to the current element.\n+    ///\n+    /// The lifetime of the returned `Cursor` is bound to that of the\n+    /// `CursorMut`, which means it cannot outlive the `CursorMut` and that the\n+    /// `CursorMut` is frozen for the lifetime of the `Cursor`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn as_cursor<'cm>(&'cm self) -> Cursor<'cm, T> {\n+        Cursor { list: self.list, current: self.current, index: self.index }\n+    }\n+}\n+\n+// Now the list editing operations\n+\n+impl<'a, T> CursorMut<'a, T> {\n+    /// Inserts a new element into the `LinkedList` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the front of the `LinkedList`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn insert_after(&mut self, item: T) {\n+        unsafe {\n+            let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n+            let node_next = match self.current {\n+                None => self.list.head,\n+                Some(node) => node.as_ref().next,\n+            };\n+            self.list.splice_nodes(self.current, node_next, spliced_node, spliced_node, 1);\n+            if self.current.is_none() {\n+                // The \"ghost\" non-element's index has changed.\n+                self.index = self.list.len;\n+            }\n+        }\n+    }\n+\n+    /// Inserts a new element into the `LinkedList` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the end of the `LinkedList`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn insert_before(&mut self, item: T) {\n+        unsafe {\n+            let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n+            let node_prev = match self.current {\n+                None => self.list.tail,\n+                Some(node) => node.as_ref().prev,\n+            };\n+            self.list.splice_nodes(node_prev, self.current, spliced_node, spliced_node, 1);\n+            self.index += 1;\n+        }\n+    }\n+\n+    /// Removes the current element from the `LinkedList`.\n+    ///\n+    /// The element that was removed is returned, and the cursor is\n+    /// moved to point to the next element in the `LinkedList`.\n+    ///\n+    /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n+    /// is removed and `None` is returned.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn remove_current(&mut self) -> Option<T> {\n+        let unlinked_node = self.current?;\n+        unsafe {\n+            self.current = unlinked_node.as_ref().next;\n+            self.list.unlink_node(unlinked_node);\n+            let unlinked_node = Box::from_raw(unlinked_node.as_ptr());\n+            Some(unlinked_node.element)\n+        }\n+    }\n+\n+    /// Inserts the elements from the given `LinkedList` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n+    /// inserted at the start of the `LinkedList`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn splice_after(&mut self, list: LinkedList<T>) {\n+        unsafe {\n+            let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {\n+                Some(parts) => parts,\n+                _ => return,\n+            };\n+            let node_next = match self.current {\n+                None => self.list.head,\n+                Some(node) => node.as_ref().next,\n+            };\n+            self.list.splice_nodes(self.current, node_next, splice_head, splice_tail, splice_len);\n+            if self.current.is_none() {\n+                // The \"ghost\" non-element's index has changed.\n+                self.index = self.list.len;\n+            }\n+        }\n+    }\n+\n+    /// Inserts the elements from the given `LinkedList` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n+    /// inserted at the end of the `LinkedList`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn splice_before(&mut self, list: LinkedList<T>) {\n+        unsafe {\n+            let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {\n+                Some(parts) => parts,\n+                _ => return,\n+            };\n+            let node_prev = match self.current {\n+                None => self.list.tail,\n+                Some(node) => node.as_ref().prev,\n+            };\n+            self.list.splice_nodes(node_prev, self.current, splice_head, splice_tail, splice_len);\n+            self.index += splice_len;\n+        }\n+    }\n+\n+    /// Splits the list into two after the current element. This will return a\n+    /// new list consisting of everything after the cursor, with the original\n+    /// list retaining everything before.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the entire contents\n+    /// of the `LinkedList` are moved.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn split_after(&mut self) -> LinkedList<T> {\n+        let split_off_idx = if self.index == self.list.len { 0 } else { self.index + 1 };\n+        if self.index == self.list.len {\n+            // The \"ghost\" non-element's index has changed to 0.\n+            self.index = 0;\n+        }\n+        unsafe { self.list.split_off_after_node(self.current, split_off_idx) }\n+    }\n+\n+    /// Splits the list into two before the current element. This will return a\n+    /// new list consisting of everything before the cursor, with the original\n+    /// list retaining everything after.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the entire contents\n+    /// of the `LinkedList` are moved.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn split_before(&mut self) -> LinkedList<T> {\n+        let split_off_idx = self.index;\n+        self.index = 0;\n+        unsafe { self.list.split_off_before_node(self.current, split_off_idx) }\n+    }\n+}\n+\n /// An iterator produced by calling `drain_filter` on LinkedList.\n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n pub struct DrainFilter<'a, T: 'a, F: 'a>"}, {"sha": "085f734ed916a0ca43cc92ad4e257268d48e5ff7", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/1b7b8cbed32987eda783dae0739b9e52edc8db5e/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7b8cbed32987eda783dae0739b9e52edc8db5e/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=1b7b8cbed32987eda783dae0739b9e52edc8db5e", "patch": "@@ -304,3 +304,155 @@ fn drain_to_empty_test() {\n     assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n     assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n }\n+\n+#[test]\n+fn test_cursor_move_peek() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front();\n+    assert_eq!(cursor.current(), Some(&1));\n+    assert_eq!(cursor.peek_next(), Some(&2));\n+    assert_eq!(cursor.peek_prev(), None);\n+    assert_eq!(cursor.index(), Some(0));\n+    cursor.move_prev();\n+    assert_eq!(cursor.current(), None);\n+    assert_eq!(cursor.peek_next(), Some(&1));\n+    assert_eq!(cursor.peek_prev(), Some(&6));\n+    assert_eq!(cursor.index(), None);\n+    cursor.move_next();\n+    cursor.move_next();\n+    assert_eq!(cursor.current(), Some(&2));\n+    assert_eq!(cursor.peek_next(), Some(&3));\n+    assert_eq!(cursor.peek_prev(), Some(&1));\n+    assert_eq!(cursor.index(), Some(1));\n+\n+    let mut cursor = m.cursor_back();\n+    assert_eq!(cursor.current(), Some(&6));\n+    assert_eq!(cursor.peek_next(), None);\n+    assert_eq!(cursor.peek_prev(), Some(&5));\n+    assert_eq!(cursor.index(), Some(5));\n+    cursor.move_next();\n+    assert_eq!(cursor.current(), None);\n+    assert_eq!(cursor.peek_next(), Some(&1));\n+    assert_eq!(cursor.peek_prev(), Some(&6));\n+    assert_eq!(cursor.index(), None);\n+    cursor.move_prev();\n+    cursor.move_prev();\n+    assert_eq!(cursor.current(), Some(&5));\n+    assert_eq!(cursor.peek_next(), Some(&6));\n+    assert_eq!(cursor.peek_prev(), Some(&4));\n+    assert_eq!(cursor.index(), Some(4));\n+\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front_mut();\n+    assert_eq!(cursor.current(), Some(&mut 1));\n+    assert_eq!(cursor.peek_next(), Some(&mut 2));\n+    assert_eq!(cursor.peek_prev(), None);\n+    assert_eq!(cursor.index(), Some(0));\n+    cursor.move_prev();\n+    assert_eq!(cursor.current(), None);\n+    assert_eq!(cursor.peek_next(), Some(&mut 1));\n+    assert_eq!(cursor.peek_prev(), Some(&mut 6));\n+    assert_eq!(cursor.index(), None);\n+    cursor.move_next();\n+    cursor.move_next();\n+    assert_eq!(cursor.current(), Some(&mut 2));\n+    assert_eq!(cursor.peek_next(), Some(&mut 3));\n+    assert_eq!(cursor.peek_prev(), Some(&mut 1));\n+    assert_eq!(cursor.index(), Some(1));\n+    let mut cursor2 = cursor.as_cursor();\n+    assert_eq!(cursor2.current(), Some(&2));\n+    assert_eq!(cursor2.index(), Some(1));\n+    cursor2.move_next();\n+    assert_eq!(cursor2.current(), Some(&3));\n+    assert_eq!(cursor2.index(), Some(2));\n+    assert_eq!(cursor.current(), Some(&mut 2));\n+    assert_eq!(cursor.index(), Some(1));\n+\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_back_mut();\n+    assert_eq!(cursor.current(), Some(&mut 6));\n+    assert_eq!(cursor.peek_next(), None);\n+    assert_eq!(cursor.peek_prev(), Some(&mut 5));\n+    assert_eq!(cursor.index(), Some(5));\n+    cursor.move_next();\n+    assert_eq!(cursor.current(), None);\n+    assert_eq!(cursor.peek_next(), Some(&mut 1));\n+    assert_eq!(cursor.peek_prev(), Some(&mut 6));\n+    assert_eq!(cursor.index(), None);\n+    cursor.move_prev();\n+    cursor.move_prev();\n+    assert_eq!(cursor.current(), Some(&mut 5));\n+    assert_eq!(cursor.peek_next(), Some(&mut 6));\n+    assert_eq!(cursor.peek_prev(), Some(&mut 4));\n+    assert_eq!(cursor.index(), Some(4));\n+    let mut cursor2 = cursor.as_cursor();\n+    assert_eq!(cursor2.current(), Some(&5));\n+    assert_eq!(cursor2.index(), Some(4));\n+    cursor2.move_prev();\n+    assert_eq!(cursor2.current(), Some(&4));\n+    assert_eq!(cursor2.index(), Some(3));\n+    assert_eq!(cursor.current(), Some(&mut 5));\n+    assert_eq!(cursor.index(), Some(4));\n+}\n+\n+#[test]\n+fn test_cursor_mut_insert() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.insert_before(7);\n+    cursor.insert_after(8);\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[7, 1, 8, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.move_prev();\n+    cursor.insert_before(9);\n+    cursor.insert_after(10);\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[10, 7, 1, 8, 2, 3, 4, 5, 6, 9]);\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.move_prev();\n+    assert_eq!(cursor.remove_current(), None);\n+    cursor.move_next();\n+    cursor.move_next();\n+    assert_eq!(cursor.remove_current(), Some(7));\n+    cursor.move_prev();\n+    cursor.move_prev();\n+    cursor.move_prev();\n+    assert_eq!(cursor.remove_current(), Some(9));\n+    cursor.move_next();\n+    assert_eq!(cursor.remove_current(), Some(10));\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[1, 8, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front_mut();\n+    let mut p: LinkedList<u32> = LinkedList::new();\n+    p.extend(&[100, 101, 102, 103]);\n+    let mut q: LinkedList<u32> = LinkedList::new();\n+    q.extend(&[200, 201, 202, 203]);\n+    cursor.splice_after(p);\n+    cursor.splice_before(q);\n+    check_links(&m);\n+    assert_eq!(\n+        m.iter().cloned().collect::<Vec<_>>(),\n+        &[200, 201, 202, 203, 1, 100, 101, 102, 103, 8, 2, 3, 4, 5, 6]\n+    );\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.move_prev();\n+    let tmp = cursor.split_before();\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n+    m = tmp;\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    let tmp = cursor.split_after();\n+    assert_eq!(tmp.into_iter().collect::<Vec<_>>(), &[102, 103, 8, 2, 3, 4, 5, 6]);\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[200, 201, 202, 203, 1, 100, 101]);\n+}"}]}