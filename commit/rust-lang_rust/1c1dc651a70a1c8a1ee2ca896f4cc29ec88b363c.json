{"sha": "1c1dc651a70a1c8a1ee2ca896f4cc29ec88b363c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMWRjNjUxYTcwYTFjOGExZWUyY2E4OTZmNGNjMjllYzg4YjM2M2M=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-07-17T01:36:13Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2010-07-18T06:25:43Z"}, "message": "Stub an interface to the (as-yet-nonexistent) structural comparison glue in trans", "tree": {"sha": "762f1a42b6c4093904de4bd305582384f78e7830", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/762f1a42b6c4093904de4bd305582384f78e7830"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c1dc651a70a1c8a1ee2ca896f4cc29ec88b363c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c1dc651a70a1c8a1ee2ca896f4cc29ec88b363c", "html_url": "https://github.com/rust-lang/rust/commit/1c1dc651a70a1c8a1ee2ca896f4cc29ec88b363c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c1dc651a70a1c8a1ee2ca896f4cc29ec88b363c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22eca31d98ce3e1bc5690799e669911e4d06a5aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/22eca31d98ce3e1bc5690799e669911e4d06a5aa", "html_url": "https://github.com/rust-lang/rust/commit/22eca31d98ce3e1bc5690799e669911e4d06a5aa"}], "stats": {"total": 123, "additions": 99, "deletions": 24}, "files": [{"sha": "c3e722936c0c0760ea0aacac98ec4ed2ceb3afd7", "filename": "src/boot/be/abi.ml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c1dc651a70a1c8a1ee2ca896f4cc29ec88b363c/src%2Fboot%2Fbe%2Fabi.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1c1dc651a70a1c8a1ee2ca896f4cc29ec88b363c/src%2Fboot%2Fbe%2Fabi.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fabi.ml?ref=1c1dc651a70a1c8a1ee2ca896f4cc29ec88b363c", "patch": "@@ -77,6 +77,8 @@ let tydesc_field_free_glue = 5;;\n let tydesc_field_sever_glue = 6;;\n let tydesc_field_mark_glue = 7;;\n let tydesc_field_obj_drop_glue = 8;;\n+let tydesc_field_cmp_glue = 9;;\n+let tydesc_field_hash_glue = 10;;\n \n let vec_elt_rc = 0;;\n let vec_elt_alloc = 1;;"}, {"sha": "d3413bebae33357486ea31f0718ddd672837803b", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 97, "deletions": 24, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/1c1dc651a70a1c8a1ee2ca896f4cc29ec88b363c/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1c1dc651a70a1c8a1ee2ca896f4cc29ec88b363c/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=1c1dc651a70a1c8a1ee2ca896f4cc29ec88b363c", "patch": "@@ -964,7 +964,7 @@ let trans_visitor\n       lea base (fst (need_mem_cell data));\n       add elt (Il.Cell base) mul_idx;\n       emit (Il.binary Il.SUB diff (Il.Cell elt) (Il.Cell base));\n-      let jmp = trans_compare Il.JB (Il.Cell diff) (Il.Cell len) in\n+      let jmp = trans_compare_simple Il.JB (Il.Cell diff) (Il.Cell len) in\n         trans_cond_fail \"bounds check\" jmp;\n         based elt_reg\n \n@@ -1714,6 +1714,8 @@ let trans_visitor\n     in\n       get_typed_mem_glue g fty inner\n \n+  and get_cmp_glue _ = failwith \"TODO\"\n+\n \n   (* Glue functions use mostly the same calling convention as ordinary\n    * functions.\n@@ -1821,18 +1823,88 @@ let trans_visitor\n         (Array.append [| ty_params_ptr |] args)\n         clo\n \n-  (* trans_compare returns a quad number of the cjmp, which the caller\n-     patches to the cjmp destination.  *)\n-  and trans_compare\n+  (* [trans_compare_full] returns the quad number of the cjmp, which the\n+   * caller patches to the cjmp destination.\n+   *\n+   * We assume that the LHS and RHS of the comparison have the same type, an\n+   * invariant that the typechecker enforces. *)\n+  and trans_compare_full\n+      ~cjmp:(cjmp:Il.jmpop)\n+      ~ty_params:(ty_params:Il.cell)\n+      ~ty:(ty:Ast.ty)\n+      ~curr_iso:(curr_iso:Ast.ty_iso option)\n+      (lhs:Il.cell)\n+      (rhs:Il.cell)\n+      : quad_idx list =\n+    let ty = strip_mutable_or_constrained_ty (maybe_iso curr_iso ty) in\n+    let (result:Il.cell) = next_vreg_cell (Il.ValTy Il.Bits32) in\n+    begin\n+      match ty with\n+          Ast.TY_obj _ ->\n+            let lhs_binding = get_element_ptr lhs Abi.obj_field_body_box in\n+            let rhs_binding = get_element_ptr rhs Abi.obj_field_body_box in\n+            let lhs_box, rhs_box = deref lhs_binding, deref rhs_binding in\n+            let lhs_obj = get_element_ptr lhs_box Abi.box_rc_field_body in\n+            let rhs_obj = get_element_ptr rhs_box Abi.box_rc_field_body in\n+            let tydesc = get_element_ptr lhs_obj Abi.obj_body_elt_tydesc in\n+            let lhs_body = get_element_ptr lhs_obj Abi.obj_body_elt_fields in\n+            let rhs_body = get_element_ptr rhs_obj Abi.obj_body_elt_fields in\n+            trans_call_dynamic_glue\n+              tydesc\n+              Abi.tydesc_field_cmp_glue\n+              (Some result)\n+              [| alias lhs_body; alias rhs_body |]\n+              None\n+\n+        | Ast.TY_param (i, _) ->\n+            trans_call_simple_dynamic_glue\n+              i\n+              Abi.tydesc_field_cmp_glue\n+              ty_params\n+              [| alias lhs; alias rhs |]\n+              None\n+\n+        | _ ->\n+            trans_call_static_glue\n+              (code_fixup_to_ptr_operand (get_cmp_glue ty curr_iso))\n+              (Some result)\n+              [| lhs; rhs |]\n+              None\n+    end;\n+    emit (Il.cmp (Il.Cell result) zero);\n+    let jmp = mark() in\n+    emit (Il.jmp cjmp Il.CodeNone);\n+    [ jmp ]\n+\n+  (* Like [trans_compare_full], returns the address of the jump, which the\n+   * caller patches to the destination. Only use this function if you are sure\n+   * that the LHS and RHS have the same type and that both will fit in a\n+   * machine register; otherwise, use [trans_compare] instead. *)\n+  and trans_compare_simple\n       (cjmp:Il.jmpop)\n       (lhs:Il.operand)\n       (rhs:Il.operand)\n       : quad_idx list =\n-    (* FIXME: this is an x86-ism; abstract via ABI. *)\n     emit (Il.cmp (Il.Cell (Il.Reg (force_to_reg lhs))) rhs);\n     let jmp = mark() in\n-      emit (Il.jmp cjmp Il.CodeNone);\n-      [jmp]\n+    emit (Il.jmp cjmp Il.CodeNone);\n+    [ jmp ]\n+\n+  and trans_compare\n+      ?ty_params:(ty_params=get_ty_params_of_current_frame())\n+      ~cjmp:(cjmp:Il.jmpop)\n+      ~ty:(ty:Ast.ty)\n+      ~curr_iso:(curr_iso:Ast.ty_iso option)\n+      (lhs:Il.operand)\n+      (rhs:Il.operand)\n+      : quad_idx list =\n+    ignore (trans_compare ~cjmp:cjmp ~ty:ty ~curr_iso:curr_iso lhs rhs);\n+      (* TODO *)\n+    match lhs, rhs with\n+        Il.Cell lhs, Il.Cell rhs ->\n+          trans_compare_full\n+            ~cjmp:cjmp ~ty_params:ty_params ~ty:ty ~curr_iso:curr_iso lhs rhs\n+      | _ -> trans_compare_simple cjmp lhs rhs\n \n   and trans_cond (invert:bool) (expr:Ast.expr) : quad_idx list =\n \n@@ -1864,12 +1936,12 @@ let trans_visitor\n               cjmp\n           in\n             anno ();\n-            trans_compare cjmp' lhs rhs\n+            trans_compare_simple cjmp' lhs rhs\n \n       | _ ->\n           let bool_operand = trans_expr expr in\n             anno ();\n-            trans_compare Il.JNE bool_operand\n+            trans_compare_simple Il.JNE bool_operand\n               (if invert then imm_true else imm_false)\n \n   and trans_binop (binop:Ast.binop) : Il.binop =\n@@ -1915,7 +1987,7 @@ let trans_visitor\n \n       | _ -> let dst = Il.Reg (Il.next_vreg (emitter()), Il.ValTy Il.Bits8) in\n           mov dst imm_true;\n-          let jmps = trans_compare (binop_to_jmpop binop) lhs rhs in\n+          let jmps = trans_compare_simple (binop_to_jmpop binop) lhs rhs in\n             mov dst imm_false;\n             List.iter patch jmps;\n             Il.Cell dst\n@@ -2330,7 +2402,7 @@ let trans_visitor\n                       annotate (Printf.sprintf \"tag case #%i == %a\" i\n                                   Ast.sprintf_name key)));\n             let jmps =\n-              trans_compare Il.JNE (Il.Cell tmp) (imm (Int64.of_int i))\n+              trans_compare_simple Il.JNE (Il.Cell tmp) (imm (Int64.of_int i))\n             in\n             let ttup = Hashtbl.find ttag key in\n               iter_tup_parts\n@@ -2383,7 +2455,9 @@ let trans_visitor\n             mov ptr (Il.Cell lim);\n             add_to lim (Il.Cell len);\n             let back_jmp_target = mark () in\n-            let fwd_jmps = trans_compare Il.JAE (Il.Cell ptr) (Il.Cell lim) in\n+            let fwd_jmps =\n+              trans_compare_simple Il.JAE (Il.Cell ptr) (Il.Cell lim)\n+            in\n             let unit_cell =\n               deref (ptr_cast ptr (referent_type abi unit_ty))\n             in\n@@ -2737,9 +2811,7 @@ let trans_visitor\n         MEM_gc ->\n           let tmp = next_vreg_cell Il.voidptr_t in\n             trans_upcall \"upcall_mark\" tmp [| Il.Cell cell |];\n-            let marked_jump =\n-              trans_compare Il.JE (Il.Cell tmp) zero;\n-            in\n+            let marked_jump = trans_compare_simple Il.JE (Il.Cell tmp) zero in\n               (* Iterate over box parts marking outgoing links. *)\n             let (body_mem, _) =\n               need_mem_cell\n@@ -3455,7 +3527,7 @@ let trans_visitor\n       in\n         call_code (code_of_operand fn_ptr);\n         iflog (fun _ -> annotate \"predicate check/fail\");\n-        let jmp = trans_compare Il.JE (Il.Cell dst_cell) imm_true in\n+        let jmp = trans_compare_simple Il.JE (Il.Cell dst_cell) imm_true in\n         let errstr = Printf.sprintf \"predicate check: %a\"\n           Ast.sprintf_constr constr\n         in\n@@ -3956,7 +4028,7 @@ let trans_visitor\n       let rec trans_pat pat src_cell src_ty =\n         match pat with\n             Ast.PAT_lit lit ->\n-              trans_compare Il.JNE (trans_lit lit) (Il.Cell src_cell)\n+              trans_compare_simple Il.JNE (trans_lit lit) (Il.Cell src_cell)\n \n           | Ast.PAT_tag (lval, pats) ->\n               let tag_name = tag_ctor_name_to_tag_name (lval_to_name lval) in\n@@ -3980,7 +4052,7 @@ let trans_visitor\n               in\n \n               let next_jumps =\n-                trans_compare Il.JNE\n+                trans_compare_simple Il.JNE\n                   (Il.Cell tag_cell) (imm (Int64.of_int tag_number))\n               in\n \n@@ -4233,12 +4305,13 @@ let trans_visitor\n                     patch fwd_jmp;\n                     check_interrupt_flag ();\n                     let back_jmp =\n-                      trans_compare Il.JB (Il.Cell dptr) (Il.Cell dlim) in\n-                      List.iter\n-                        (fun j -> patch_existing j back_jmp_targ) back_jmp;\n-                      let v = next_vreg_cell word_sty in\n-                        mov v (Il.Cell src_fill);\n-                        add_to dst_fill (Il.Cell v);\n+                      trans_compare_simple Il.JB (Il.Cell dptr) (Il.Cell dlim)\n+                    in\n+                    List.iter\n+                      (fun j -> patch_existing j back_jmp_targ) back_jmp;\n+                    let v = next_vreg_cell word_sty in\n+                      mov v (Il.Cell src_fill);\n+                      add_to dst_fill (Il.Cell v);\n         | t ->\n             begin\n               bug () \"unsupported vector-append type %a\" Ast.sprintf_ty t"}]}