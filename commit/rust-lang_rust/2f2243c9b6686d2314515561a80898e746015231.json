{"sha": "2f2243c9b6686d2314515561a80898e746015231", "node_id": "C_kwDOAAsO6NoAKDJmMjI0M2M5YjY2ODZkMjMxNDUxNTU2MWE4MDg5OGU3NDYwMTUyMzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-04T07:35:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-04T07:35:33Z"}, "message": "Auto merge of #99843 - oli-obk:is_useful_perf, r=compiler-errors\n\nSome `is_useful` cleanups\n\n#98582 was reverted because it was a perf regression.\n\nhttps://github.com/rust-lang/rust/pull/99806 reintroduces the changes, but this PR picks individual ones that have no regressions.", "tree": {"sha": "47de5cdaacdfe3126d46c70c355ffd1b02e36deb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47de5cdaacdfe3126d46c70c355ffd1b02e36deb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f2243c9b6686d2314515561a80898e746015231", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f2243c9b6686d2314515561a80898e746015231", "html_url": "https://github.com/rust-lang/rust/commit/2f2243c9b6686d2314515561a80898e746015231", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f2243c9b6686d2314515561a80898e746015231/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caee496150a551fe1b9f77b3a58f7e66d54bc824", "url": "https://api.github.com/repos/rust-lang/rust/commits/caee496150a551fe1b9f77b3a58f7e66d54bc824", "html_url": "https://github.com/rust-lang/rust/commit/caee496150a551fe1b9f77b3a58f7e66d54bc824"}, {"sha": "803d374f9b937fcaacc9fef643a270ecaf66b878", "url": "https://api.github.com/repos/rust-lang/rust/commits/803d374f9b937fcaacc9fef643a270ecaf66b878", "html_url": "https://github.com/rust-lang/rust/commit/803d374f9b937fcaacc9fef643a270ecaf66b878"}], "stats": {"total": 89, "additions": 43, "deletions": 46}, "files": [{"sha": "98eb6e170ab76f237462798b95959548851b6392", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2f2243c9b6686d2314515561a80898e746015231/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2243c9b6686d2314515561a80898e746015231/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=2f2243c9b6686d2314515561a80898e746015231", "patch": "@@ -261,7 +261,7 @@ impl IntRange {\n     /// Lint on likely incorrect range patterns (#63987)\n     pub(super) fn lint_overlapping_range_endpoints<'a, 'p: 'a, 'tcx: 'a>(\n         &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        pcx: &PatCtxt<'_, 'p, 'tcx>,\n         pats: impl Iterator<Item = &'a DeconstructedPat<'p, 'tcx>>,\n         column_count: usize,\n         hir_id: HirId,\n@@ -696,7 +696,7 @@ impl<'tcx> Constructor<'tcx> {\n     /// `EvalResult::Deny { .. }`.\n     ///\n     /// This means that the variant has a stdlib unstable feature marking it.\n-    pub(super) fn is_unstable_variant(&self, pcx: PatCtxt<'_, '_, 'tcx>) -> bool {\n+    pub(super) fn is_unstable_variant(&self, pcx: &PatCtxt<'_, '_, 'tcx>) -> bool {\n         if let Constructor::Variant(idx) = self && let ty::Adt(adt, _) = pcx.ty.kind() {\n             let variant_def_id = adt.variant(*idx).def_id;\n             // Filter variants that depend on a disabled unstable feature.\n@@ -710,7 +710,7 @@ impl<'tcx> Constructor<'tcx> {\n \n     /// Checks if the `Constructor` is a `Constructor::Variant` with a `#[doc(hidden)]`\n     /// attribute from a type not local to the current crate.\n-    pub(super) fn is_doc_hidden_variant(&self, pcx: PatCtxt<'_, '_, 'tcx>) -> bool {\n+    pub(super) fn is_doc_hidden_variant(&self, pcx: &PatCtxt<'_, '_, 'tcx>) -> bool {\n         if let Constructor::Variant(idx) = self && let ty::Adt(adt, _) = pcx.ty.kind() {\n             let variant_def_id = adt.variants()[*idx].def_id;\n             return pcx.cx.tcx.is_doc_hidden(variant_def_id) && !variant_def_id.is_local();\n@@ -731,7 +731,7 @@ impl<'tcx> Constructor<'tcx> {\n \n     /// The number of fields for this constructor. This must be kept in sync with\n     /// `Fields::wildcards`.\n-    pub(super) fn arity(&self, pcx: PatCtxt<'_, '_, 'tcx>) -> usize {\n+    pub(super) fn arity(&self, pcx: &PatCtxt<'_, '_, 'tcx>) -> usize {\n         match self {\n             Single | Variant(_) => match pcx.ty.kind() {\n                 ty::Tuple(fs) => fs.len(),\n@@ -775,7 +775,7 @@ impl<'tcx> Constructor<'tcx> {\n     /// matrix, unless all of them are.\n     pub(super) fn split<'a>(\n         &self,\n-        pcx: PatCtxt<'_, '_, 'tcx>,\n+        pcx: &PatCtxt<'_, '_, 'tcx>,\n         ctors: impl Iterator<Item = &'a Constructor<'tcx>> + Clone,\n     ) -> SmallVec<[Self; 1]>\n     where\n@@ -811,7 +811,7 @@ impl<'tcx> Constructor<'tcx> {\n     /// this checks for inclusion.\n     // We inline because this has a single call site in `Matrix::specialize_constructor`.\n     #[inline]\n-    pub(super) fn is_covered_by<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>, other: &Self) -> bool {\n+    pub(super) fn is_covered_by<'p>(&self, pcx: &PatCtxt<'_, 'p, 'tcx>, other: &Self) -> bool {\n         // This must be kept in sync with `is_covered_by_any`.\n         match (self, other) {\n             // Wildcards cover anything\n@@ -865,7 +865,7 @@ impl<'tcx> Constructor<'tcx> {\n     /// assumed to have been split from a wildcard.\n     fn is_covered_by_any<'p>(\n         &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        pcx: &PatCtxt<'_, 'p, 'tcx>,\n         used_ctors: &[Constructor<'tcx>],\n     ) -> bool {\n         if used_ctors.is_empty() {\n@@ -918,7 +918,7 @@ pub(super) struct SplitWildcard<'tcx> {\n }\n \n impl<'tcx> SplitWildcard<'tcx> {\n-    pub(super) fn new<'p>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Self {\n+    pub(super) fn new<'p>(pcx: &PatCtxt<'_, 'p, 'tcx>) -> Self {\n         debug!(\"SplitWildcard::new({:?})\", pcx.ty);\n         let cx = pcx.cx;\n         let make_range = |start, end| {\n@@ -1044,7 +1044,7 @@ impl<'tcx> SplitWildcard<'tcx> {\n     /// do what you want.\n     pub(super) fn split<'a>(\n         &mut self,\n-        pcx: PatCtxt<'_, '_, 'tcx>,\n+        pcx: &PatCtxt<'_, '_, 'tcx>,\n         ctors: impl Iterator<Item = &'a Constructor<'tcx>> + Clone,\n     ) where\n         'tcx: 'a,\n@@ -1056,21 +1056,21 @@ impl<'tcx> SplitWildcard<'tcx> {\n     }\n \n     /// Whether there are any value constructors for this type that are not present in the matrix.\n-    fn any_missing(&self, pcx: PatCtxt<'_, '_, 'tcx>) -> bool {\n+    fn any_missing(&self, pcx: &PatCtxt<'_, '_, 'tcx>) -> bool {\n         self.iter_missing(pcx).next().is_some()\n     }\n \n     /// Iterate over the constructors for this type that are not present in the matrix.\n     pub(super) fn iter_missing<'a, 'p>(\n         &'a self,\n-        pcx: PatCtxt<'a, 'p, 'tcx>,\n+        pcx: &'a PatCtxt<'a, 'p, 'tcx>,\n     ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'p> {\n         self.all_ctors.iter().filter(move |ctor| !ctor.is_covered_by_any(pcx, &self.matrix_ctors))\n     }\n \n     /// Return the set of constructors resulting from splitting the wildcard. As explained at the\n     /// top of the file, if any constructors are missing we can ignore the present ones.\n-    fn into_ctors(self, pcx: PatCtxt<'_, '_, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n+    fn into_ctors(self, pcx: &PatCtxt<'_, '_, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n         if self.any_missing(pcx) {\n             // Some constructors are missing, thus we can specialize with the special `Missing`\n             // constructor, which stands for those constructors that are not seen in the matrix,\n@@ -1202,35 +1202,32 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n \n     /// Creates a new list of wildcard fields for a given constructor. The result must have a\n     /// length of `constructor.arity()`.\n-    pub(super) fn wildcards(\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        ty: Ty<'tcx>,\n-        constructor: &Constructor<'tcx>,\n-    ) -> Self {\n+    #[instrument(level = \"trace\")]\n+    pub(super) fn wildcards(pcx: &PatCtxt<'_, 'p, 'tcx>, constructor: &Constructor<'tcx>) -> Self {\n         let ret = match constructor {\n-            Single | Variant(_) => match ty.kind() {\n-                ty::Tuple(fs) => Fields::wildcards_from_tys(cx, fs.iter()),\n-                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(cx, once(*rty)),\n+            Single | Variant(_) => match pcx.ty.kind() {\n+                ty::Tuple(fs) => Fields::wildcards_from_tys(pcx.cx, fs.iter()),\n+                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(pcx.cx, once(*rty)),\n                 ty::Adt(adt, substs) => {\n                     if adt.is_box() {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n-                        Fields::wildcards_from_tys(cx, once(substs.type_at(0)))\n+                        Fields::wildcards_from_tys(pcx.cx, once(substs.type_at(0)))\n                     } else {\n                         let variant = &adt.variant(constructor.variant_index_for_adt(*adt));\n-                        let tys = Fields::list_variant_nonhidden_fields(cx, ty, variant)\n+                        let tys = Fields::list_variant_nonhidden_fields(pcx.cx, pcx.ty, variant)\n                             .map(|(_, ty)| ty);\n-                        Fields::wildcards_from_tys(cx, tys)\n+                        Fields::wildcards_from_tys(pcx.cx, tys)\n                     }\n                 }\n-                _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", ty),\n+                _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", pcx),\n             },\n-            Slice(slice) => match *ty.kind() {\n+            Slice(slice) => match *pcx.ty.kind() {\n                 ty::Slice(ty) | ty::Array(ty, _) => {\n                     let arity = slice.arity();\n-                    Fields::wildcards_from_tys(cx, (0..arity).map(|_| ty))\n+                    Fields::wildcards_from_tys(pcx.cx, (0..arity).map(|_| ty))\n                 }\n-                _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, pcx),\n             },\n             Str(..)\n             | FloatRange(..)\n@@ -1243,7 +1240,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 bug!(\"called `Fields::wildcards` on an `Or` ctor\")\n             }\n         };\n-        debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n+        debug!(?ret);\n         ret\n     }\n \n@@ -1285,8 +1282,8 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n     /// Construct a pattern that matches everything that starts with this constructor.\n     /// For example, if `ctor` is a `Constructor::Variant` for `Option::Some`, we get the pattern\n     /// `Some(_)`.\n-    pub(super) fn wild_from_ctor(pcx: PatCtxt<'_, 'p, 'tcx>, ctor: Constructor<'tcx>) -> Self {\n-        let fields = Fields::wildcards(pcx.cx, pcx.ty, &ctor);\n+    pub(super) fn wild_from_ctor(pcx: &PatCtxt<'_, 'p, 'tcx>, ctor: Constructor<'tcx>) -> Self {\n+        let fields = Fields::wildcards(pcx, &ctor);\n         DeconstructedPat::new(ctor, fields, pcx.ty, DUMMY_SP)\n     }\n \n@@ -1553,13 +1550,13 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n     /// `other_ctor` can be different from `self.ctor`, but must be covered by it.\n     pub(super) fn specialize<'a>(\n         &'a self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: &PatCtxt<'_, 'p, 'tcx>,\n         other_ctor: &Constructor<'tcx>,\n     ) -> SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]> {\n         match (&self.ctor, other_ctor) {\n             (Wildcard, _) => {\n                 // We return a wildcard for each field of `other_ctor`.\n-                Fields::wildcards(cx, self.ty, other_ctor).iter_patterns().collect()\n+                Fields::wildcards(pcx, other_ctor).iter_patterns().collect()\n             }\n             (Slice(self_slice), Slice(other_slice))\n                 if self_slice.arity() != other_slice.arity() =>\n@@ -1578,7 +1575,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                         let prefix = &self.fields.fields[..prefix];\n                         let suffix = &self.fields.fields[self_slice.arity() - suffix..];\n                         let wildcard: &_ =\n-                            cx.pattern_arena.alloc(DeconstructedPat::wildcard(inner_ty));\n+                            pcx.cx.pattern_arena.alloc(DeconstructedPat::wildcard(inner_ty));\n                         let extra_wildcards = other_slice.arity() - self_slice.arity();\n                         let extra_wildcards = (0..extra_wildcards).map(|_| wildcard);\n                         prefix.iter().chain(extra_wildcards).chain(suffix).collect()"}, {"sha": "0a660ef30c88ee333bfc4cf6fc58bc77bc0b711a", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2f2243c9b6686d2314515561a80898e746015231/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2243c9b6686d2314515561a80898e746015231/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=2f2243c9b6686d2314515561a80898e746015231", "patch": "@@ -411,12 +411,12 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     /// This is roughly the inverse of `Constructor::apply`.\n     fn pop_head_constructor(\n         &self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: &PatCtxt<'_, 'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n     ) -> PatStack<'p, 'tcx> {\n         // We pop the head pattern and push the new fields extracted from the arguments of\n         // `self.head()`.\n-        let mut new_fields: SmallVec<[_; 2]> = self.head().specialize(cx, ctor);\n+        let mut new_fields: SmallVec<[_; 2]> = self.head().specialize(pcx, ctor);\n         new_fields.extend_from_slice(&self.pats[1..]);\n         PatStack::from_vec(new_fields)\n     }\n@@ -469,13 +469,13 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n     fn specialize_constructor(\n         &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        pcx: &PatCtxt<'_, 'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n     ) -> Matrix<'p, 'tcx> {\n         let mut matrix = Matrix::empty();\n         for row in &self.patterns {\n             if ctor.is_covered_by(pcx, row.head().ctor()) {\n-                let new_row = row.pop_head_constructor(pcx.cx, ctor);\n+                let new_row = row.pop_head_constructor(pcx, ctor);\n                 matrix.push(new_row);\n             }\n         }\n@@ -575,7 +575,7 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n     /// with the results of specializing with the other constructors.\n     fn apply_constructor(\n         self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        pcx: &PatCtxt<'_, 'p, 'tcx>,\n         matrix: &Matrix<'p, 'tcx>, // used to compute missing ctors\n         ctor: &Constructor<'tcx>,\n     ) -> Self {\n@@ -713,7 +713,7 @@ impl<'p, 'tcx> Witness<'p, 'tcx> {\n     ///\n     /// left_ty: struct X { a: (bool, &'static str), b: usize}\n     /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n-    fn apply_constructor(mut self, pcx: PatCtxt<'_, 'p, 'tcx>, ctor: &Constructor<'tcx>) -> Self {\n+    fn apply_constructor(mut self, pcx: &PatCtxt<'_, 'p, 'tcx>, ctor: &Constructor<'tcx>) -> Self {\n         let pat = {\n             let len = self.0.len();\n             let arity = ctor.arity(pcx);\n@@ -786,7 +786,7 @@ fn is_useful<'p, 'tcx>(\n     is_under_guard: bool,\n     is_top_level: bool,\n ) -> Usefulness<'p, 'tcx> {\n-    debug!(\"matrix,v={:?}{:?}\", matrix, v);\n+    debug!(?matrix, ?v);\n     let Matrix { patterns: rows, .. } = matrix;\n \n     // The base case. We are pattern-matching on () and the return value is\n@@ -806,11 +806,6 @@ fn is_useful<'p, 'tcx>(\n \n     debug_assert!(rows.iter().all(|r| r.len() == v.len()));\n \n-    let ty = v.head().ty();\n-    let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n-    debug!(\"v.head: {:?}, v.span: {:?}\", v.head(), v.head().span());\n-    let pcx = PatCtxt { cx, ty, span: v.head().span(), is_top_level, is_non_exhaustive };\n-\n     // If the first pattern is an or-pattern, expand it.\n     let mut ret = Usefulness::new_not_useful(witness_preference);\n     if v.head().is_or_pat() {\n@@ -832,6 +827,11 @@ fn is_useful<'p, 'tcx>(\n             }\n         }\n     } else {\n+        let ty = v.head().ty();\n+        let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n+        debug!(\"v.head: {:?}, v.span: {:?}\", v.head(), v.head().span());\n+        let pcx = &PatCtxt { cx, ty, span: v.head().span(), is_top_level, is_non_exhaustive };\n+\n         let v_ctor = v.head().ctor();\n         debug!(?v_ctor);\n         if let Constructor::IntRange(ctor_range) = &v_ctor {\n@@ -853,7 +853,7 @@ fn is_useful<'p, 'tcx>(\n             debug!(\"specialize({:?})\", ctor);\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n             let spec_matrix = start_matrix.specialize_constructor(pcx, &ctor);\n-            let v = v.pop_head_constructor(cx, &ctor);\n+            let v = v.pop_head_constructor(pcx, &ctor);\n             let usefulness = ensure_sufficient_stack(|| {\n                 is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false)\n             });"}]}