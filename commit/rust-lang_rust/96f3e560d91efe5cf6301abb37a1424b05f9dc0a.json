{"sha": "96f3e560d91efe5cf6301abb37a1424b05f9dc0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2ZjNlNTYwZDkxZWZlNWNmNjMwMWFiYjM3YTE0MjRiMDVmOWRjMGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-29T06:43:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-29T17:32:12Z"}, "message": "remove dependency map and instead use a linked list of constraints", "tree": {"sha": "09d10ad00189453d44b7f6694e2ee8365c75e216", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09d10ad00189453d44b7f6694e2ee8365c75e216"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96f3e560d91efe5cf6301abb37a1424b05f9dc0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96f3e560d91efe5cf6301abb37a1424b05f9dc0a", "html_url": "https://github.com/rust-lang/rust/commit/96f3e560d91efe5cf6301abb37a1424b05f9dc0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96f3e560d91efe5cf6301abb37a1424b05f9dc0a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ef1b92379c302c769be2240050080ad0bd763b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ef1b92379c302c769be2240050080ad0bd763b6", "html_url": "https://github.com/rust-lang/rust/commit/1ef1b92379c302c769be2240050080ad0bd763b6"}], "stats": {"total": 72, "additions": 55, "deletions": 17}, "files": [{"sha": "b0346abee5a5fbe83c67aee6fab39a668ecdb453", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96f3e560d91efe5cf6301abb37a1424b05f9dc0a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96f3e560d91efe5cf6301abb37a1424b05f9dc0a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=96f3e560d91efe5cf6301abb37a1424b05f9dc0a", "patch": "@@ -84,6 +84,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 sub,\n                 point,\n                 span,\n+                next: _,\n             } = constraint;\n             with_msg(&format!(\n                 \"{:?}: {:?} @ {:?} due to {:?}\","}, {"sha": "6c4c02a36a0d73c3e0205145bccf8f0be1820542", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96f3e560d91efe5cf6301abb37a1424b05f9dc0a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96f3e560d91efe5cf6301abb37a1424b05f9dc0a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=96f3e560d91efe5cf6301abb37a1424b05f9dc0a", "patch": "@@ -55,7 +55,7 @@ impl<'this, 'tcx> dot::GraphWalk<'this> for RegionInferenceContext<'tcx> {\n         vids.into_cow()\n     }\n     fn edges(&'this self) -> dot::Edges<'this, Constraint> {\n-        (&self.constraints[..]).into_cow()\n+        (&self.constraints.raw[..]).into_cow()\n     }\n \n     // Render `a: b` as `a <- b`, indicating the flow"}, {"sha": "822f504321940706e24e2a32885bc0b44ecf06f5", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 53, "deletions": 16, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/96f3e560d91efe5cf6301abb37a1424b05f9dc0a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96f3e560d91efe5cf6301abb37a1424b05f9dc0a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=96f3e560d91efe5cf6301abb37a1424b05f9dc0a", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::collections::HashMap;\n-\n use super::universal_regions::UniversalRegions;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n@@ -23,9 +21,9 @@ use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegi\n                  Local, Location, Mir};\n use rustc::traits::ObligationCause;\n use rustc::ty::{self, RegionVid, Ty, TypeFoldable};\n-use rustc::util::common::ErrorReported;\n+use rustc::util::common::{self, ErrorReported};\n use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n@@ -61,8 +59,15 @@ pub struct RegionInferenceContext<'tcx> {\n     /// until `solve` is invoked.\n     inferred_values: Option<RegionValues>,\n \n+    /// For each variable, stores the index of the first constraint\n+    /// where that variable appears on the RHS. This is the start of a\n+    /// 'linked list' threaded by the `next` field in `Constraint`.\n+    ///\n+    /// This map is build when values are inferred.\n+    dependency_map: Option<IndexVec<RegionVid, Option<ConstraintIndex>>>,\n+\n     /// The constraints we have accumulated and used during solving.\n-    constraints: Vec<Constraint>,\n+    constraints: IndexVec<ConstraintIndex, Constraint>,\n \n     /// Type constraints that we check after solving.\n     type_tests: Vec<TypeTest<'tcx>>,\n@@ -143,10 +148,22 @@ pub struct Constraint {\n     /// At this location.\n     point: Location,\n \n+    /// Later on, we thread the constraints onto a linked list\n+    /// sorted by their `sub` field. So if you had:\n+    ///\n+    /// Index | Constraint | Next Field\n+    /// ----- | ---------- | ----------\n+    /// 0     | `'a: 'b`   | Some(2)\n+    /// 1     | `'b: 'c`   | None\n+    /// 2     | `'c: 'b`   | None\n+    next: Option<ConstraintIndex>,\n+\n     /// Where did this constraint arise?\n     span: Span,\n }\n \n+newtype_index!(ConstraintIndex { DEBUG_FORMAT = \"ConstraintIndex({})\" });\n+\n /// A \"type test\" corresponds to an outlives constraint between a type\n /// and a lifetime, like `T: 'x` or `<T as Foo>::Bar: 'x`.  They are\n /// translated from the `Verify` region constraints in the ordinary\n@@ -259,7 +276,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             elements: elements.clone(),\n             liveness_constraints: RegionValues::new(elements, num_region_variables),\n             inferred_values: None,\n-            constraints: Vec::new(),\n+            dependency_map: None,\n+            constraints: IndexVec::new(),\n             type_tests: Vec::new(),\n             universal_regions,\n         };\n@@ -387,6 +405,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             sup,\n             sub,\n             point,\n+            next: None,\n         });\n     }\n \n@@ -403,6 +422,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n+    ) -> Option<ClosureRegionRequirements<'gcx>> {\n+        common::time(infcx.tcx.sess, &format!(\"solve({:?})\", mir_def_id), || {\n+            self.solve_inner(infcx, mir, mir_def_id)\n+        })\n+    }\n+\n+    fn solve_inner<'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n \n@@ -448,6 +478,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n     fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n+        self.dependency_map = Some(self.build_dependency_map());\n         let inferred_values = self.compute_region_values(mir, TrackCauses(false));\n         self.inferred_values = Some(inferred_values);\n     }\n@@ -465,17 +496,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // constraints we have accumulated.\n         let mut inferred_values = self.liveness_constraints.duplicate(track_causes);\n \n-        let dependency_map = self.build_dependency_map();\n+        let dependency_map = self.dependency_map.as_ref().unwrap();\n \n         // Constraints that may need to be repropagated (initially all):\n-        let mut dirty_list: Vec<_> = (0..self.constraints.len()).collect();\n+        let mut dirty_list: Vec<_> = self.constraints.indices().collect();\n \n         // Set to 0 for each constraint that is on the dirty list:\n         let mut clean_bit_vec = BitVector::new(dirty_list.len());\n \n         debug!(\"propagate_constraints: --------------------\");\n         while let Some(constraint_idx) = dirty_list.pop() {\n-            clean_bit_vec.insert(constraint_idx);\n+            clean_bit_vec.insert(constraint_idx.index());\n \n             let constraint = &self.constraints[constraint_idx];\n             debug!(\"propagate_constraints: constraint={:?}\", constraint);\n@@ -497,10 +528,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n                 debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n \n-                for &dep_idx in dependency_map.get(&constraint.sup).unwrap_or(&vec![]) {\n-                    if clean_bit_vec.remove(dep_idx) {\n+                let mut opt_dep_idx = dependency_map[constraint.sup];\n+                while let Some(dep_idx) = opt_dep_idx {\n+                    if clean_bit_vec.remove(dep_idx.index()) {\n                         dirty_list.push(dep_idx);\n                     }\n+                    opt_dep_idx = self.constraints[dep_idx].next;\n                 }\n             }\n \n@@ -514,11 +547,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// indices of constraints that need to be re-evaluated when X changes.\n     /// These are constraints like Y: X @ P -- so if X changed, we may\n     /// need to grow Y.\n-    fn build_dependency_map(&self) -> HashMap<RegionVid, Vec<usize>> {\n-        let mut map = HashMap::new();\n-\n-        for (idx, constraint) in self.constraints.iter().enumerate() {\n-            map.entry(constraint.sub).or_insert(Vec::new()).push(idx);\n+    #[inline(never)]\n+    fn build_dependency_map(&mut self) -> IndexVec<RegionVid, Option<ConstraintIndex>> {\n+        let mut map = IndexVec::from_elem(None, &self.definitions);\n+\n+        for (idx, constraint) in self.constraints.iter_enumerated_mut().rev() {\n+            let mut head = &mut map[constraint.sub];\n+            debug_assert!(constraint.next.is_none());\n+            constraint.next = *head;\n+            *head = Some(idx);\n         }\n \n         map"}]}