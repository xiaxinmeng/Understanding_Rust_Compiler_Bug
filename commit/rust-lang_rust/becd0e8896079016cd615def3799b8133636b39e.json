{"sha": "becd0e8896079016cd615def3799b8133636b39e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlY2QwZTg4OTYwNzkwMTZjZDYxNWRlZjM3OTliODEzMzYzNmIzOWU=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-12-14T14:10:15Z"}, "committer": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-12-14T14:10:15Z"}, "message": "Replace some `println!` with `tidy_error!` to simplify", "tree": {"sha": "1a3b6ea1de74c1d1b1aa81417d75f682c9af223e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a3b6ea1de74c1d1b1aa81417d75f682c9af223e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/becd0e8896079016cd615def3799b8133636b39e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/becd0e8896079016cd615def3799b8133636b39e", "html_url": "https://github.com/rust-lang/rust/commit/becd0e8896079016cd615def3799b8133636b39e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/becd0e8896079016cd615def3799b8133636b39e/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c45bff23dfbb13d9d28afe5dba57c028ba156da", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c45bff23dfbb13d9d28afe5dba57c028ba156da", "html_url": "https://github.com/rust-lang/rust/commit/3c45bff23dfbb13d9d28afe5dba57c028ba156da"}], "stats": {"total": 43, "additions": 20, "deletions": 23}, "files": [{"sha": "952782175f13c3d7c9f66041850e42d9e159f138", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/becd0e8896079016cd615def3799b8133636b39e/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becd0e8896079016cd615def3799b8133636b39e/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=becd0e8896079016cd615def3799b8133636b39e", "patch": "@@ -214,12 +214,12 @@ fn check_exceptions(metadata: &Metadata, bad: &mut bool) {\n     for (name, license) in EXCEPTIONS {\n         // Check that the package actually exists.\n         if !metadata.packages.iter().any(|p| p.name == *name) {\n-            println!(\n+            tidy_error!(\n+                bad,\n                 \"could not find exception package `{}`\\n\\\n                 Remove from EXCEPTIONS list if it is no longer used.\",\n                 name\n             );\n-            *bad = true;\n         }\n         // Check that the license hasn't changed.\n         for pkg in metadata.packages.iter().filter(|p| p.name == *name) {\n@@ -232,11 +232,11 @@ fn check_exceptions(metadata: &Metadata, bad: &mut bool) {\n             }\n             match &pkg.license {\n                 None => {\n-                    println!(\n+                    tidy_error!(\n+                        bad,\n                         \"dependency exception `{}` does not declare a license expression\",\n                         pkg.id\n                     );\n-                    *bad = true;\n                 }\n                 Some(pkg_license) => {\n                     if pkg_license.as_str() != *license {\n@@ -273,8 +273,7 @@ fn check_exceptions(metadata: &Metadata, bad: &mut bool) {\n         let license = match &pkg.license {\n             Some(license) => license,\n             None => {\n-                println!(\"dependency `{}` does not define a license expression\", pkg.id,);\n-                *bad = true;\n+                tidy_error!(bad, \"dependency `{}` does not define a license expression\", pkg.id);\n                 continue;\n             }\n         };\n@@ -286,8 +285,7 @@ fn check_exceptions(metadata: &Metadata, bad: &mut bool) {\n                 // general, these should never be added.\n                 continue;\n             }\n-            println!(\"invalid license `{}` in `{}`\", license, pkg.id);\n-            *bad = true;\n+            tidy_error!(bad, \"invalid license `{}` in `{}`\", license, pkg.id);\n         }\n     }\n }\n@@ -300,12 +298,12 @@ fn check_dependencies(metadata: &Metadata, bad: &mut bool) {\n     // Check that the PERMITTED_DEPENDENCIES does not have unused entries.\n     for name in PERMITTED_DEPENDENCIES {\n         if !metadata.packages.iter().any(|p| p.name == *name) {\n-            println!(\n+            tidy_error!(\n+                bad,\n                 \"could not find allowed package `{}`\\n\\\n                 Remove from PERMITTED_DEPENDENCIES list if it is no longer used.\",\n                 name\n             );\n-            *bad = true;\n         }\n     }\n     // Get the list in a convenient form.\n@@ -322,11 +320,10 @@ fn check_dependencies(metadata: &Metadata, bad: &mut bool) {\n     }\n \n     if !unapproved.is_empty() {\n-        println!(\"Dependencies not explicitly permitted:\");\n+        tidy_error!(bad, \"Dependencies not explicitly permitted:\");\n         for dep in unapproved {\n             println!(\"* {}\", dep);\n         }\n-        *bad = true;\n     }\n }\n \n@@ -381,16 +378,17 @@ fn check_crate_duplicate(metadata: &Metadata, bad: &mut bool) {\n         let matches: Vec<_> = metadata.packages.iter().filter(|pkg| pkg.name == name).collect();\n         match matches.len() {\n             0 => {\n-                println!(\n+                tidy_error!(\n+                    bad,\n                     \"crate `{}` is missing, update `check_crate_duplicate` \\\n                     if it is no longer used\",\n                     name\n                 );\n-                *bad = true;\n             }\n             1 => {}\n             _ => {\n-                println!(\n+                tidy_error!(\n+                    bad,\n                     \"crate `{}` is duplicated in `Cargo.lock`, \\\n                     it is too expensive to build multiple times, \\\n                     so make sure only one version appears across all dependencies\",\n@@ -399,7 +397,6 @@ fn check_crate_duplicate(metadata: &Metadata, bad: &mut bool) {\n                 for pkg in matches {\n                     println!(\"  * {}\", pkg.id);\n                 }\n-                *bad = true;\n             }\n         }\n     }"}, {"sha": "aad57cacbb41ee2eba3acef9a98b3e8c33bc5ea9", "filename": "src/tools/tidy/src/extdeps.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/becd0e8896079016cd615def3799b8133636b39e/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becd0e8896079016cd615def3799b8133636b39e/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs?ref=becd0e8896079016cd615def3799b8133636b39e", "patch": "@@ -27,8 +27,7 @@ pub fn check(root: &Path, bad: &mut bool) {\n \n         // Ensure source is allowed.\n         if !ALLOWED_SOURCES.contains(&&*source) {\n-            println!(\"invalid source: {}\", source);\n-            *bad = true;\n+            tidy_error!(bad, \"invalid source: {}\", source);\n         }\n     }\n }"}, {"sha": "d78af2cd6164c7b844f7830bdca285694e67b846", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/becd0e8896079016cd615def3799b8133636b39e/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becd0e8896079016cd615def3799b8133636b39e/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=becd0e8896079016cd615def3799b8133636b39e", "patch": "@@ -330,7 +330,6 @@ fn collect_lang_features_in(base: &Path, file: &str, bad: &mut bool) -> Features\n             let issue_str = parts.next().unwrap().trim();\n             let tracking_issue = if issue_str.starts_with(\"None\") {\n                 if level == Status::Unstable && !next_feature_omits_tracking_issue {\n-                    *bad = true;\n                     tidy_error!(\n                         bad,\n                         \"{}:{}: no tracking issue for feature {}\","}, {"sha": "d282d240d8234746c95d81696945aa7df2fedc54", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/becd0e8896079016cd615def3799b8133636b39e/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becd0e8896079016cd615def3799b8133636b39e/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=becd0e8896079016cd615def3799b8133636b39e", "patch": "@@ -28,6 +28,10 @@ macro_rules! t {\n }\n \n macro_rules! tidy_error {\n+    ($bad:expr, $fmt:expr) => ({\n+        *$bad = true;\n+        eprintln!(\"tidy error: {}\", $fmt);\n+    });\n     ($bad:expr, $fmt:expr, $($arg:tt)*) => ({\n         *$bad = true;\n         eprint!(\"tidy error: \");"}, {"sha": "d8d2b449fee8789f2bcdd9384d4b842268389ea7", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/becd0e8896079016cd615def3799b8133636b39e/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becd0e8896079016cd615def3799b8133636b39e/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=becd0e8896079016cd615def3799b8133636b39e", "patch": "@@ -67,14 +67,12 @@ pub fn check(path: &Path, bad: &mut bool) {\n                     let testname =\n                         file_path.file_name().unwrap().to_str().unwrap().split_once('.').unwrap().0;\n                     if !file_path.with_file_name(testname).with_extension(\"rs\").exists() {\n-                        println!(\"Stray file with UI testing output: {:?}\", file_path);\n-                        *bad = true;\n+                        tidy_error!(bad, \"Stray file with UI testing output: {:?}\", file_path);\n                     }\n \n                     if let Ok(metadata) = fs::metadata(file_path) {\n                         if metadata.len() == 0 {\n-                            println!(\"Empty file with UI testing output: {:?}\", file_path);\n-                            *bad = true;\n+                            tidy_error!(bad, \"Empty file with UI testing output: {:?}\", file_path);\n                         }\n                     }\n                 }"}]}