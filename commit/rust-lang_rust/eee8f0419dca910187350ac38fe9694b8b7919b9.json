{"sha": "eee8f0419dca910187350ac38fe9694b8b7919b9", "node_id": "C_kwDOAAsO6NoAKGVlZThmMDQxOWRjYTkxMDE4NzM1MGFjMzhmZTk2OTRiOGI3OTE5Yjk", "commit": {"author": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2021-11-17T18:51:37Z"}, "committer": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2021-11-17T19:57:25Z"}, "message": "refactor: cleanup duplicative Impl handling code", "tree": {"sha": "ef4c89ab6c56f3e2bc177263ae80829c0e533185", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef4c89ab6c56f3e2bc177263ae80829c0e533185"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eee8f0419dca910187350ac38fe9694b8b7919b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eee8f0419dca910187350ac38fe9694b8b7919b9", "html_url": "https://github.com/rust-lang/rust/commit/eee8f0419dca910187350ac38fe9694b8b7919b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eee8f0419dca910187350ac38fe9694b8b7919b9/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6d1bf5acba29a8944f3bd537bcefb5e5972e5f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6d1bf5acba29a8944f3bd537bcefb5e5972e5f1", "html_url": "https://github.com/rust-lang/rust/commit/e6d1bf5acba29a8944f3bd537bcefb5e5972e5f1"}], "stats": {"total": 457, "additions": 212, "deletions": 245}, "files": [{"sha": "849e6c06218f83651a7b33507b1de89952a6a358", "filename": "src/items.rs", "status": "modified", "additions": 210, "deletions": 243, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/eee8f0419dca910187350ac38fe9694b8b7919b9/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee8f0419dca910187350ac38fe9694b8b7919b9/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=eee8f0419dca910187350ac38fe9694b8b7919b9", "patch": "@@ -579,6 +579,25 @@ impl<'a> FmtVisitor<'a> {\n \n     fn visit_impl_items(&mut self, items: &[ptr::P<ast::AssocItem>]) {\n         if self.get_context().config.reorder_impl_items() {\n+            type TyOpt = Option<ptr::P<ast::Ty>>;\n+            use crate::ast::AssocItemKind::*;\n+            let is_type = |ty: &TyOpt| {\n+                ty.as_ref()\n+                    .map_or(true, |t| !matches!(t.kind, ast::TyKind::ImplTrait(..)))\n+            };\n+            let is_opaque = |ty: &TyOpt| !is_type(ty);\n+            let both_type = |left: &TyOpt, right: &TyOpt| is_type(left) && is_type(right);\n+            let both_opaque = |left: &TyOpt, right: &TyOpt| is_opaque(left) && is_opaque(right);\n+            let need_empty_line = |a: &ast::AssocItemKind, b: &ast::AssocItemKind| match (a, b) {\n+                (TyAlias(lty), TyAlias(rty))\n+                    if both_type(&lty.ty, &rty.ty) || both_opaque(&lty.ty, &rty.ty) =>\n+                {\n+                    false\n+                }\n+                (Const(..), Const(..)) => false,\n+                _ => true,\n+            };\n+\n             // Create visitor for each items, then reorder them.\n             let mut buffer = vec![];\n             for item in items {\n@@ -587,50 +606,6 @@ impl<'a> FmtVisitor<'a> {\n                 self.buffer.clear();\n             }\n \n-            fn is_type(ty: &Option<rustc_ast::ptr::P<ast::Ty>>) -> bool {\n-                if let Some(lty) = ty {\n-                    if let ast::TyKind::ImplTrait(..) = lty.kind {\n-                        return false;\n-                    }\n-                }\n-                true\n-            }\n-\n-            fn is_opaque(ty: &Option<rustc_ast::ptr::P<ast::Ty>>) -> bool {\n-                !is_type(ty)\n-            }\n-\n-            fn both_type(\n-                a: &Option<rustc_ast::ptr::P<ast::Ty>>,\n-                b: &Option<rustc_ast::ptr::P<ast::Ty>>,\n-            ) -> bool {\n-                is_type(a) && is_type(b)\n-            }\n-\n-            fn both_opaque(\n-                a: &Option<rustc_ast::ptr::P<ast::Ty>>,\n-                b: &Option<rustc_ast::ptr::P<ast::Ty>>,\n-            ) -> bool {\n-                is_opaque(a) && is_opaque(b)\n-            }\n-\n-            // In rustc-ap-v638 the `OpaqueTy` AssocItemKind variant was removed but\n-            // we still need to differentiate to maintain sorting order.\n-\n-            // type -> opaque -> const -> macro -> method\n-            use crate::ast::AssocItemKind::*;\n-            fn need_empty_line(a: &ast::AssocItemKind, b: &ast::AssocItemKind) -> bool {\n-                match (a, b) {\n-                    (TyAlias(lty), TyAlias(rty))\n-                        if both_type(&lty.ty, &rty.ty) || both_opaque(&lty.ty, &rty.ty) =>\n-                    {\n-                        false\n-                    }\n-                    (Const(..), Const(..)) => false,\n-                    _ => true,\n-                }\n-            }\n-\n             buffer.sort_by(|(_, a), (_, b)| match (&a.kind, &b.kind) {\n                 (TyAlias(lty), TyAlias(rty))\n                     if both_type(&lty.ty, &rty.ty) || both_opaque(&lty.ty, &rty.ty) =>\n@@ -676,136 +651,133 @@ impl<'a> FmtVisitor<'a> {\n pub(crate) fn format_impl(\n     context: &RewriteContext<'_>,\n     item: &ast::Item,\n+    iimpl: &ast::Impl,\n     offset: Indent,\n ) -> Option<String> {\n-    if let ast::ItemKind::Impl(impl_kind) = &item.kind {\n-        let ast::Impl {\n-            ref generics,\n-            ref self_ty,\n-            ref items,\n-            ..\n-        } = **impl_kind;\n-        let mut result = String::with_capacity(128);\n-        let ref_and_type = format_impl_ref_and_type(context, item, offset)?;\n-        let sep = offset.to_string_with_newline(context.config);\n-        result.push_str(&ref_and_type);\n+    let ast::Impl {\n+        generics,\n+        self_ty,\n+        items,\n+        ..\n+    } = iimpl;\n+    let mut result = String::with_capacity(128);\n+    let ref_and_type = format_impl_ref_and_type(context, item, iimpl, offset)?;\n+    let sep = offset.to_string_with_newline(context.config);\n+    result.push_str(&ref_and_type);\n \n-        let where_budget = if result.contains('\\n') {\n-            context.config.max_width()\n-        } else {\n-            context.budget(last_line_width(&result))\n-        };\n+    let where_budget = if result.contains('\\n') {\n+        context.config.max_width()\n+    } else {\n+        context.budget(last_line_width(&result))\n+    };\n \n-        let mut option = WhereClauseOption::snuggled(&ref_and_type);\n-        let snippet = context.snippet(item.span);\n-        let open_pos = snippet.find_uncommented(\"{\")? + 1;\n-        if !contains_comment(&snippet[open_pos..])\n-            && items.is_empty()\n-            && generics.where_clause.predicates.len() == 1\n-            && !result.contains('\\n')\n-        {\n-            option.suppress_comma();\n-            option.snuggle();\n-            option.allow_single_line();\n-        }\n+    let mut option = WhereClauseOption::snuggled(&ref_and_type);\n+    let snippet = context.snippet(item.span);\n+    let open_pos = snippet.find_uncommented(\"{\")? + 1;\n+    if !contains_comment(&snippet[open_pos..])\n+        && items.is_empty()\n+        && generics.where_clause.predicates.len() == 1\n+        && !result.contains('\\n')\n+    {\n+        option.suppress_comma();\n+        option.snuggle();\n+        option.allow_single_line();\n+    }\n \n-        let missing_span = mk_sp(self_ty.span.hi(), item.span.hi());\n-        let where_span_end = context.snippet_provider.opt_span_before(missing_span, \"{\");\n-        let where_clause_str = rewrite_where_clause(\n-            context,\n-            &generics.where_clause,\n-            context.config.brace_style(),\n-            Shape::legacy(where_budget, offset.block_only()),\n-            false,\n-            \"{\",\n-            where_span_end,\n-            self_ty.span.hi(),\n-            option,\n-        )?;\n+    let missing_span = mk_sp(self_ty.span.hi(), item.span.hi());\n+    let where_span_end = context.snippet_provider.opt_span_before(missing_span, \"{\");\n+    let where_clause_str = rewrite_where_clause(\n+        context,\n+        &generics.where_clause,\n+        context.config.brace_style(),\n+        Shape::legacy(where_budget, offset.block_only()),\n+        false,\n+        \"{\",\n+        where_span_end,\n+        self_ty.span.hi(),\n+        option,\n+    )?;\n \n-        // If there is no where-clause, we may have missing comments between the trait name and\n-        // the opening brace.\n-        if generics.where_clause.predicates.is_empty() {\n-            if let Some(hi) = where_span_end {\n-                match recover_missing_comment_in_span(\n-                    mk_sp(self_ty.span.hi(), hi),\n-                    Shape::indented(offset, context.config),\n-                    context,\n-                    last_line_width(&result),\n-                ) {\n-                    Some(ref missing_comment) if !missing_comment.is_empty() => {\n-                        result.push_str(missing_comment);\n-                    }\n-                    _ => (),\n+    // If there is no where-clause, we may have missing comments between the trait name and\n+    // the opening brace.\n+    if generics.where_clause.predicates.is_empty() {\n+        if let Some(hi) = where_span_end {\n+            match recover_missing_comment_in_span(\n+                mk_sp(self_ty.span.hi(), hi),\n+                Shape::indented(offset, context.config),\n+                context,\n+                last_line_width(&result),\n+            ) {\n+                Some(ref missing_comment) if !missing_comment.is_empty() => {\n+                    result.push_str(missing_comment);\n                 }\n+                _ => (),\n             }\n         }\n+    }\n \n-        if is_impl_single_line(context, items.as_slice(), &result, &where_clause_str, item)? {\n-            result.push_str(&where_clause_str);\n-            if where_clause_str.contains('\\n') || last_line_contains_single_line_comment(&result) {\n-                // if the where_clause contains extra comments AND\n-                // there is only one where-clause predicate\n-                // recover the suppressed comma in single line where_clause formatting\n-                if generics.where_clause.predicates.len() == 1 {\n-                    result.push(',');\n-                }\n-                result.push_str(&format!(\"{}{{{}}}\", sep, sep));\n-            } else {\n-                result.push_str(\" {}\");\n+    if is_impl_single_line(context, items.as_slice(), &result, &where_clause_str, item)? {\n+        result.push_str(&where_clause_str);\n+        if where_clause_str.contains('\\n') || last_line_contains_single_line_comment(&result) {\n+            // if the where_clause contains extra comments AND\n+            // there is only one where-clause predicate\n+            // recover the suppressed comma in single line where_clause formatting\n+            if generics.where_clause.predicates.len() == 1 {\n+                result.push(',');\n             }\n-            return Some(result);\n+            result.push_str(&format!(\"{}{{{}}}\", sep, sep));\n+        } else {\n+            result.push_str(\" {}\");\n         }\n+        return Some(result);\n+    }\n \n-        result.push_str(&where_clause_str);\n+    result.push_str(&where_clause_str);\n \n-        let need_newline = last_line_contains_single_line_comment(&result) || result.contains('\\n');\n-        match context.config.brace_style() {\n-            _ if need_newline => result.push_str(&sep),\n-            BraceStyle::AlwaysNextLine => result.push_str(&sep),\n-            BraceStyle::PreferSameLine => result.push(' '),\n-            BraceStyle::SameLineWhere => {\n-                if !where_clause_str.is_empty() {\n-                    result.push_str(&sep);\n-                } else {\n-                    result.push(' ');\n-                }\n+    let need_newline = last_line_contains_single_line_comment(&result) || result.contains('\\n');\n+    match context.config.brace_style() {\n+        _ if need_newline => result.push_str(&sep),\n+        BraceStyle::AlwaysNextLine => result.push_str(&sep),\n+        BraceStyle::PreferSameLine => result.push(' '),\n+        BraceStyle::SameLineWhere => {\n+            if !where_clause_str.is_empty() {\n+                result.push_str(&sep);\n+            } else {\n+                result.push(' ');\n             }\n         }\n+    }\n \n-        result.push('{');\n-        // this is an impl body snippet(impl SampleImpl { /* here */ })\n-        let lo = max(self_ty.span.hi(), generics.where_clause.span.hi());\n-        let snippet = context.snippet(mk_sp(lo, item.span.hi()));\n-        let open_pos = snippet.find_uncommented(\"{\")? + 1;\n+    result.push('{');\n+    // this is an impl body snippet(impl SampleImpl { /* here */ })\n+    let lo = max(self_ty.span.hi(), generics.where_clause.span.hi());\n+    let snippet = context.snippet(mk_sp(lo, item.span.hi()));\n+    let open_pos = snippet.find_uncommented(\"{\")? + 1;\n \n-        if !items.is_empty() || contains_comment(&snippet[open_pos..]) {\n-            let mut visitor = FmtVisitor::from_context(context);\n-            let item_indent = offset.block_only().block_indent(context.config);\n-            visitor.block_indent = item_indent;\n-            visitor.last_pos = lo + BytePos(open_pos as u32);\n+    if !items.is_empty() || contains_comment(&snippet[open_pos..]) {\n+        let mut visitor = FmtVisitor::from_context(context);\n+        let item_indent = offset.block_only().block_indent(context.config);\n+        visitor.block_indent = item_indent;\n+        visitor.last_pos = lo + BytePos(open_pos as u32);\n \n-            visitor.visit_attrs(&item.attrs, ast::AttrStyle::Inner);\n-            visitor.visit_impl_items(items);\n+        visitor.visit_attrs(&item.attrs, ast::AttrStyle::Inner);\n+        visitor.visit_impl_items(items);\n \n-            visitor.format_missing(item.span.hi() - BytePos(1));\n+        visitor.format_missing(item.span.hi() - BytePos(1));\n \n-            let inner_indent_str = visitor.block_indent.to_string_with_newline(context.config);\n-            let outer_indent_str = offset.block_only().to_string_with_newline(context.config);\n+        let inner_indent_str = visitor.block_indent.to_string_with_newline(context.config);\n+        let outer_indent_str = offset.block_only().to_string_with_newline(context.config);\n \n-            result.push_str(&inner_indent_str);\n-            result.push_str(visitor.buffer.trim());\n-            result.push_str(&outer_indent_str);\n-        } else if need_newline || !context.config.empty_item_single_line() {\n-            result.push_str(&sep);\n-        }\n+        result.push_str(&inner_indent_str);\n+        result.push_str(visitor.buffer.trim());\n+        result.push_str(&outer_indent_str);\n+    } else if need_newline || !context.config.empty_item_single_line() {\n+        result.push_str(&sep);\n+    }\n \n-        result.push('}');\n+    result.push('}');\n \n-        Some(result)\n-    } else {\n-        unreachable!();\n-    }\n+    Some(result)\n }\n \n fn is_impl_single_line(\n@@ -830,111 +802,106 @@ fn is_impl_single_line(\n fn format_impl_ref_and_type(\n     context: &RewriteContext<'_>,\n     item: &ast::Item,\n+    iimpl: &ast::Impl,\n     offset: Indent,\n ) -> Option<String> {\n-    if let ast::ItemKind::Impl(impl_kind) = &item.kind {\n-        let ast::Impl {\n-            unsafety,\n-            polarity,\n-            defaultness,\n-            constness,\n-            ref generics,\n-            of_trait: ref trait_ref,\n-            ref self_ty,\n-            ..\n-        } = **impl_kind;\n-        let mut result = String::with_capacity(128);\n+    let ast::Impl {\n+        unsafety,\n+        polarity,\n+        defaultness,\n+        constness,\n+        ref generics,\n+        of_trait: ref trait_ref,\n+        ref self_ty,\n+        ..\n+    } = *iimpl;\n+    let mut result = String::with_capacity(128);\n \n-        result.push_str(&format_visibility(context, &item.vis));\n-        result.push_str(format_defaultness(defaultness));\n-        result.push_str(format_unsafety(unsafety));\n+    result.push_str(&format_visibility(context, &item.vis));\n+    result.push_str(format_defaultness(defaultness));\n+    result.push_str(format_unsafety(unsafety));\n \n-        let shape = if context.config.version() == Version::Two {\n-            Shape::indented(offset + last_line_width(&result), context.config)\n-        } else {\n-            generics_shape_from_config(\n-                context.config,\n-                Shape::indented(offset + last_line_width(&result), context.config),\n-                0,\n-            )?\n-        };\n-        let generics_str = rewrite_generics(context, \"impl\", generics, shape)?;\n-        result.push_str(&generics_str);\n-        result.push_str(format_constness_right(constness));\n+    let shape = if context.config.version() == Version::Two {\n+        Shape::indented(offset + last_line_width(&result), context.config)\n+    } else {\n+        generics_shape_from_config(\n+            context.config,\n+            Shape::indented(offset + last_line_width(&result), context.config),\n+            0,\n+        )?\n+    };\n+    let generics_str = rewrite_generics(context, \"impl\", generics, shape)?;\n+    result.push_str(&generics_str);\n+    result.push_str(format_constness_right(constness));\n \n-        let polarity_str = match polarity {\n-            ast::ImplPolarity::Negative(_) => \"!\",\n-            ast::ImplPolarity::Positive => \"\",\n-        };\n+    let polarity_str = match polarity {\n+        ast::ImplPolarity::Negative(_) => \"!\",\n+        ast::ImplPolarity::Positive => \"\",\n+    };\n \n-        let polarity_overhead;\n-        let trait_ref_overhead;\n-        if let Some(ref trait_ref) = *trait_ref {\n-            let result_len = last_line_width(&result);\n-            result.push_str(&rewrite_trait_ref(\n-                context,\n-                trait_ref,\n-                offset,\n-                polarity_str,\n-                result_len,\n-            )?);\n-            polarity_overhead = 0; // already written\n-            trait_ref_overhead = \" for\".len();\n-        } else {\n-            polarity_overhead = polarity_str.len();\n-            trait_ref_overhead = 0;\n-        }\n+    let polarity_overhead;\n+    let trait_ref_overhead;\n+    if let Some(ref trait_ref) = *trait_ref {\n+        let result_len = last_line_width(&result);\n+        result.push_str(&rewrite_trait_ref(\n+            context,\n+            trait_ref,\n+            offset,\n+            polarity_str,\n+            result_len,\n+        )?);\n+        polarity_overhead = 0; // already written\n+        trait_ref_overhead = \" for\".len();\n+    } else {\n+        polarity_overhead = polarity_str.len();\n+        trait_ref_overhead = 0;\n+    }\n \n-        // Try to put the self type in a single line.\n-        let curly_brace_overhead = if generics.where_clause.predicates.is_empty() {\n-            // If there is no where-clause adapt budget for type formatting to take space and curly\n-            // brace into account.\n-            match context.config.brace_style() {\n-                BraceStyle::AlwaysNextLine => 0,\n-                _ => 2,\n-            }\n-        } else {\n-            0\n-        };\n-        let used_space = last_line_width(&result)\n-            + polarity_overhead\n-            + trait_ref_overhead\n-            + curly_brace_overhead;\n-        // 1 = space before the type.\n-        let budget = context.budget(used_space + 1);\n-        if let Some(self_ty_str) = self_ty.rewrite(context, Shape::legacy(budget, offset)) {\n-            if !self_ty_str.contains('\\n') {\n-                if trait_ref.is_some() {\n-                    result.push_str(\" for \");\n-                } else {\n-                    result.push(' ');\n-                    result.push_str(polarity_str);\n-                }\n-                result.push_str(&self_ty_str);\n-                return Some(result);\n+    // Try to put the self type in a single line.\n+    let curly_brace_overhead = if generics.where_clause.predicates.is_empty() {\n+        // If there is no where-clause adapt budget for type formatting to take space and curly\n+        // brace into account.\n+        match context.config.brace_style() {\n+            BraceStyle::AlwaysNextLine => 0,\n+            _ => 2,\n+        }\n+    } else {\n+        0\n+    };\n+    let used_space =\n+        last_line_width(&result) + polarity_overhead + trait_ref_overhead + curly_brace_overhead;\n+    // 1 = space before the type.\n+    let budget = context.budget(used_space + 1);\n+    if let Some(self_ty_str) = self_ty.rewrite(context, Shape::legacy(budget, offset)) {\n+        if !self_ty_str.contains('\\n') {\n+            if trait_ref.is_some() {\n+                result.push_str(\" for \");\n+            } else {\n+                result.push(' ');\n+                result.push_str(polarity_str);\n             }\n+            result.push_str(&self_ty_str);\n+            return Some(result);\n         }\n+    }\n \n-        // Couldn't fit the self type on a single line, put it on a new line.\n-        result.push('\\n');\n-        // Add indentation of one additional tab.\n-        let new_line_offset = offset.block_indent(context.config);\n-        result.push_str(&new_line_offset.to_string(context.config));\n-        if trait_ref.is_some() {\n-            result.push_str(\"for \");\n-        } else {\n-            result.push_str(polarity_str);\n-        }\n-        let budget = context.budget(last_line_width(&result) + polarity_overhead);\n-        let type_offset = match context.config.indent_style() {\n-            IndentStyle::Visual => new_line_offset + trait_ref_overhead,\n-            IndentStyle::Block => new_line_offset,\n-        };\n-        result.push_str(&*self_ty.rewrite(context, Shape::legacy(budget, type_offset))?);\n-        Some(result)\n+    // Couldn't fit the self type on a single line, put it on a new line.\n+    result.push('\\n');\n+    // Add indentation of one additional tab.\n+    let new_line_offset = offset.block_indent(context.config);\n+    result.push_str(&new_line_offset.to_string(context.config));\n+    if trait_ref.is_some() {\n+        result.push_str(\"for \");\n     } else {\n-        unreachable!();\n+        result.push_str(polarity_str);\n     }\n+    let budget = context.budget(last_line_width(&result) + polarity_overhead);\n+    let type_offset = match context.config.indent_style() {\n+        IndentStyle::Visual => new_line_offset + trait_ref_overhead,\n+        IndentStyle::Block => new_line_offset,\n+    };\n+    result.push_str(&*self_ty.rewrite(context, Shape::legacy(budget, type_offset))?);\n+    Some(result)\n }\n \n fn rewrite_trait_ref("}, {"sha": "e4a7be742abcbace1602fad9b5b45593b2dd71ad", "filename": "src/visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eee8f0419dca910187350ac38fe9694b8b7919b9/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee8f0419dca910187350ac38fe9694b8b7919b9/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=eee8f0419dca910187350ac38fe9694b8b7919b9", "patch": "@@ -485,9 +485,9 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         if should_visit_node_again {\n             match item.kind {\n                 ast::ItemKind::Use(ref tree) => self.format_import(item, tree),\n-                ast::ItemKind::Impl { .. } => {\n+                ast::ItemKind::Impl(ref iimpl) => {\n                     let block_indent = self.block_indent;\n-                    let rw = self.with_context(|ctx| format_impl(ctx, item, block_indent));\n+                    let rw = self.with_context(|ctx| format_impl(ctx, item, iimpl, block_indent));\n                     self.push_rewrite(item.span, rw);\n                 }\n                 ast::ItemKind::Trait(..) => {"}]}