{"sha": "75f97db36765eadb51d7d920068ade34000cdabf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1Zjk3ZGIzNjc2NWVhZGI1MWQ3ZDkyMDA2OGFkZTM0MDAwY2RhYmY=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-08T15:19:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-08T15:19:50Z"}, "message": "Rollup merge of #39557 - bjorn3:pp-docs, r=jseyfried\n\nA few documentation improvements for `syntax::print::pp`\n\n* Moved algorithm explanation to module docs\n* Added ``` before and after the examples\n* Explanation of the `rbox`, `ibox` and `cbox` names\n* Added docs about the breaking types to `Breaks`", "tree": {"sha": "0638509b5f1903fa2bb0a158a18c300c2fdcc55f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0638509b5f1903fa2bb0a158a18c300c2fdcc55f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75f97db36765eadb51d7d920068ade34000cdabf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75f97db36765eadb51d7d920068ade34000cdabf", "html_url": "https://github.com/rust-lang/rust/commit/75f97db36765eadb51d7d920068ade34000cdabf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75f97db36765eadb51d7d920068ade34000cdabf/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7709c4d2b90f42569a1c4c96262cd0c41a71514b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7709c4d2b90f42569a1c4c96262cd0c41a71514b", "html_url": "https://github.com/rust-lang/rust/commit/7709c4d2b90f42569a1c4c96262cd0c41a71514b"}, {"sha": "1ee88e516c367660f263f4db354602c5b848a2ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ee88e516c367660f263f4db354602c5b848a2ca", "html_url": "https://github.com/rust-lang/rust/commit/1ee88e516c367660f263f4db354602c5b848a2ca"}], "stats": {"total": 167, "additions": 89, "deletions": 78}, "files": [{"sha": "1d67c2a2c2b74023c8f1fa1c7c5e4dc4ca8d9e6b", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 89, "deletions": 78, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/75f97db36765eadb51d7d920068ade34000cdabf/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f97db36765eadb51d7d920068ade34000cdabf/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=75f97db36765eadb51d7d920068ade34000cdabf", "patch": "@@ -60,11 +60,95 @@\n //! by two zero-length breaks. The algorithm will try its best to fit it on a\n //! line (which it can't) and so naturally place the content on its own line to\n //! avoid combining it with other lines and making matters even worse.\n+//!\n+//! # Explanation\n+//!\n+//! In case you do not have the paper, here is an explanation of what's going\n+//! on.\n+//!\n+//! There is a stream of input tokens flowing through this printer.\n+//!\n+//! The printer buffers up to 3N tokens inside itself, where N is linewidth.\n+//! Yes, linewidth is chars and tokens are multi-char, but in the worst\n+//! case every token worth buffering is 1 char long, so it's ok.\n+//!\n+//! Tokens are String, Break, and Begin/End to delimit blocks.\n+//!\n+//! Begin tokens can carry an offset, saying \"how far to indent when you break\n+//! inside here\", as well as a flag indicating \"consistent\" or \"inconsistent\"\n+//! breaking. Consistent breaking means that after the first break, no attempt\n+//! will be made to flow subsequent breaks together onto lines. Inconsistent\n+//! is the opposite. Inconsistent breaking example would be, say:\n+//!\n+//! ```\n+//! foo(hello, there, good, friends)\n+//! ```\n+//!\n+//! breaking inconsistently to become\n+//!\n+//! ```\n+//! foo(hello, there\n+//!     good, friends);\n+//! ```\n+//!\n+//! whereas a consistent breaking would yield:\n+//!\n+//! ```\n+//! foo(hello,\n+//!     there\n+//!     good,\n+//!     friends);\n+//! ```\n+//!\n+//! That is, in the consistent-break blocks we value vertical alignment\n+//! more than the ability to cram stuff onto a line. But in all cases if it\n+//! can make a block a one-liner, it'll do so.\n+//!\n+//! Carrying on with high-level logic:\n+//!\n+//! The buffered tokens go through a ring-buffer, 'tokens'. The 'left' and\n+//! 'right' indices denote the active portion of the ring buffer as well as\n+//! describing hypothetical points-in-the-infinite-stream at most 3N tokens\n+//! apart (i.e. \"not wrapped to ring-buffer boundaries\"). The paper will switch\n+//! between using 'left' and 'right' terms to denote the wrapped-to-ring-buffer\n+//! and point-in-infinite-stream senses freely.\n+//!\n+//! There is a parallel ring buffer, 'size', that holds the calculated size of\n+//! each token. Why calculated? Because for Begin/End pairs, the \"size\"\n+//! includes everything between the pair. That is, the \"size\" of Begin is\n+//! actually the sum of the sizes of everything between Begin and the paired\n+//! End that follows. Since that is arbitrarily far in the future, 'size' is\n+//! being rewritten regularly while the printer runs; in fact most of the\n+//! machinery is here to work out 'size' entries on the fly (and give up when\n+//! they're so obviously over-long that \"infinity\" is a good enough\n+//! approximation for purposes of line breaking).\n+//!\n+//! The \"input side\" of the printer is managed as an abstract process called\n+//! SCAN, which uses 'scan_stack', to manage calculating 'size'. SCAN is, in\n+//! other words, the process of calculating 'size' entries.\n+//!\n+//! The \"output side\" of the printer is managed by an abstract process called\n+//! PRINT, which uses 'print_stack', 'margin' and 'space' to figure out what to\n+//! do with each token/size pair it consumes as it goes. It's trying to consume\n+//! the entire buffered window, but can't output anything until the size is >=\n+//! 0 (sizes are set to negative while they're pending calculation).\n+//!\n+//! So SCAN takes input and buffers tokens and pending calculations, while\n+//! PRINT gobbles up completed calculations and tokens from the buffer. The\n+//! theory is that the two can never get more than 3N tokens apart, because\n+//! once there's \"obviously\" too much data to fit on a line, in a size\n+//! calculation, SCAN will write \"infinity\" to the size and let PRINT consume\n+//! it.\n+//!\n+//! In this implementation (following the paper, again) the SCAN process is\n+//! the method called `Printer::pretty_print`, and the 'PRINT' process is the method\n+//! called `Printer::print`.\n \n use std::collections::VecDeque;\n use std::fmt;\n use std::io;\n \n+/// How to break. Described in more detail in the module docs.\n #[derive(Clone, Copy, PartialEq)]\n pub enum Breaks {\n     Consistent,\n@@ -177,81 +261,6 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n     }\n }\n \n-\n-/// In case you do not have the paper, here is an explanation of what's going\n-/// on.\n-///\n-/// There is a stream of input tokens flowing through this printer.\n-///\n-/// The printer buffers up to 3N tokens inside itself, where N is linewidth.\n-/// Yes, linewidth is chars and tokens are multi-char, but in the worst\n-/// case every token worth buffering is 1 char long, so it's ok.\n-///\n-/// Tokens are String, Break, and Begin/End to delimit blocks.\n-///\n-/// Begin tokens can carry an offset, saying \"how far to indent when you break\n-/// inside here\", as well as a flag indicating \"consistent\" or \"inconsistent\"\n-/// breaking. Consistent breaking means that after the first break, no attempt\n-/// will be made to flow subsequent breaks together onto lines. Inconsistent\n-/// is the opposite. Inconsistent breaking example would be, say:\n-///\n-///  foo(hello, there, good, friends)\n-///\n-/// breaking inconsistently to become\n-///\n-///  foo(hello, there\n-///      good, friends);\n-///\n-/// whereas a consistent breaking would yield:\n-///\n-///  foo(hello,\n-///      there\n-///      good,\n-///      friends);\n-///\n-/// That is, in the consistent-break blocks we value vertical alignment\n-/// more than the ability to cram stuff onto a line. But in all cases if it\n-/// can make a block a one-liner, it'll do so.\n-///\n-/// Carrying on with high-level logic:\n-///\n-/// The buffered tokens go through a ring-buffer, 'tokens'. The 'left' and\n-/// 'right' indices denote the active portion of the ring buffer as well as\n-/// describing hypothetical points-in-the-infinite-stream at most 3N tokens\n-/// apart (i.e. \"not wrapped to ring-buffer boundaries\"). The paper will switch\n-/// between using 'left' and 'right' terms to denote the wrapped-to-ring-buffer\n-/// and point-in-infinite-stream senses freely.\n-///\n-/// There is a parallel ring buffer, 'size', that holds the calculated size of\n-/// each token. Why calculated? Because for Begin/End pairs, the \"size\"\n-/// includes everything between the pair. That is, the \"size\" of Begin is\n-/// actually the sum of the sizes of everything between Begin and the paired\n-/// End that follows. Since that is arbitrarily far in the future, 'size' is\n-/// being rewritten regularly while the printer runs; in fact most of the\n-/// machinery is here to work out 'size' entries on the fly (and give up when\n-/// they're so obviously over-long that \"infinity\" is a good enough\n-/// approximation for purposes of line breaking).\n-///\n-/// The \"input side\" of the printer is managed as an abstract process called\n-/// SCAN, which uses 'scan_stack', to manage calculating 'size'. SCAN is, in\n-/// other words, the process of calculating 'size' entries.\n-///\n-/// The \"output side\" of the printer is managed by an abstract process called\n-/// PRINT, which uses 'print_stack', 'margin' and 'space' to figure out what to\n-/// do with each token/size pair it consumes as it goes. It's trying to consume\n-/// the entire buffered window, but can't output anything until the size is >=\n-/// 0 (sizes are set to negative while they're pending calculation).\n-///\n-/// So SCAN takes input and buffers tokens and pending calculations, while\n-/// PRINT gobbles up completed calculations and tokens from the buffer. The\n-/// theory is that the two can never get more than 3N tokens apart, because\n-/// once there's \"obviously\" too much data to fit on a line, in a size\n-/// calculation, SCAN will write \"infinity\" to the size and let PRINT consume\n-/// it.\n-///\n-/// In this implementation (following the paper, again) the SCAN process is\n-/// the method called 'pretty_print', and the 'PRINT' process is the method\n-/// called 'print'.\n pub struct Printer<'a> {\n     pub out: Box<io::Write+'a>,\n     buf_len: usize,\n@@ -292,7 +301,7 @@ impl<'a> Printer<'a> {\n     pub fn last_token(&mut self) -> Token {\n         self.buf[self.right].token.clone()\n     }\n-    // be very careful with this!\n+    /// be very careful with this!\n     pub fn replace_last_token(&mut self, t: Token) {\n         self.buf[self.right].token = t;\n     }\n@@ -571,19 +580,21 @@ impl<'a> Printer<'a> {\n }\n \n // Convenience functions to talk to the printer.\n-//\n-// \"raw box\"\n+\n+/// \"raw box\"\n pub fn rbox(p: &mut Printer, indent: usize, b: Breaks) -> io::Result<()> {\n     p.pretty_print(Token::Begin(BeginToken {\n         offset: indent as isize,\n         breaks: b\n     }))\n }\n \n+/// Inconsistent breaking box\n pub fn ibox(p: &mut Printer, indent: usize) -> io::Result<()> {\n     rbox(p, indent, Breaks::Inconsistent)\n }\n \n+/// Consistent breaking box\n pub fn cbox(p: &mut Printer, indent: usize) -> io::Result<()> {\n     rbox(p, indent, Breaks::Consistent)\n }"}]}