{"sha": "5b2adcce115ee0e3fe4e53b57a2b9f168c26b288", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMmFkY2NlMTE1ZWUwZTNmZTRlNTNiNTdhMmI5ZjE2OGMyNmIyODg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-25T16:09:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-31T16:41:39Z"}, "message": "factor out NLL invocation interface", "tree": {"sha": "835e338d2a9b53f3283e40ef09dbdb7402968da2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/835e338d2a9b53f3283e40ef09dbdb7402968da2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b2adcce115ee0e3fe4e53b57a2b9f168c26b288", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b2adcce115ee0e3fe4e53b57a2b9f168c26b288", "html_url": "https://github.com/rust-lang/rust/commit/5b2adcce115ee0e3fe4e53b57a2b9f168c26b288", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b2adcce115ee0e3fe4e53b57a2b9f168c26b288/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74140603444716b257a060c3c467295d580c9afc", "url": "https://api.github.com/repos/rust-lang/rust/commits/74140603444716b257a060c3c467295d580c9afc", "html_url": "https://github.com/rust-lang/rust/commit/74140603444716b257a060c3c467295d580c9afc"}], "stats": {"total": 199, "additions": 123, "deletions": 76}, "files": [{"sha": "8a62533ba337f538d9037c345524857e762c7293", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 79, "deletions": 45, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/5b2adcce115ee0e3fe4e53b57a2b9f168c26b288/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2adcce115ee0e3fe4e53b57a2b9f168c26b288/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=5b2adcce115ee0e3fe4e53b57a2b9f168c26b288", "patch": "@@ -42,44 +42,70 @@ impl MirPass for NLL {\n             return;\n         }\n \n-        tcx.infer_ctxt().enter(|ref infcx| {\n-            // Clone mir so we can mutate it without disturbing the rest of the compiler\n-            let mir = &mut input_mir.clone();\n-\n-            // Replace all regions with fresh inference variables.\n-            let num_region_variables = renumber::renumber_mir(infcx, mir);\n-\n-            // Compute what is live where.\n-            let liveness = &LivenessResults {\n-                regular: liveness::liveness_of_locals(\n-                    mir,\n-                    LivenessMode {\n-                        include_regular_use: true,\n-                        include_drops: false,\n-                    },\n-                ),\n-\n-                drop: liveness::liveness_of_locals(\n-                    mir,\n-                    LivenessMode {\n-                        include_regular_use: false,\n-                        include_drops: true,\n-                    },\n-                ),\n-            };\n-\n-            // Create the region inference context, generate the constraints,\n-            // and then solve them.\n-            let regioncx = &mut RegionInferenceContext::new(num_region_variables);\n-            constraint_generation::generate_constraints(infcx, regioncx, mir, source, liveness);\n-            regioncx.solve(infcx, mir);\n-\n-            // Dump MIR results into a file, if that is enabled.\n-            dump_mir_results(infcx, liveness, source, regioncx, mir);\n-        })\n+        tcx.infer_ctxt()\n+            .enter(|ref infcx| drop(compute_regions(infcx, source, input_mir)));\n     }\n }\n \n+pub struct RegionComputation<'tcx> {\n+    /// A rewritten version of the input MIR where all the regions are\n+    /// rewritten to refer to inference variables.\n+    pub mir: Mir<'tcx>,\n+\n+    /// The definitions (along with their final values) for all regions.\n+    pub regioncx: RegionInferenceContext,\n+}\n+\n+/// Computes the (non-lexical) regions from the input MIR.\n+///\n+/// This may result in errors being reported.\n+pub fn compute_regions<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    source: MirSource,\n+    input_mir: &Mir<'tcx>,\n+) -> RegionComputation<'tcx> {\n+    // Clone mir so we can mutate it without disturbing the rest of the compiler\n+    let mut mir = input_mir.clone();\n+\n+    // Replace all regions with fresh inference variables.\n+    let num_region_variables = renumber::renumber_mir(infcx, &mut mir);\n+\n+    // Compute what is live where.\n+    let liveness = &LivenessResults {\n+        regular: liveness::liveness_of_locals(\n+            &mir,\n+            LivenessMode {\n+                include_regular_use: true,\n+                include_drops: false,\n+            },\n+        ),\n+\n+        drop: liveness::liveness_of_locals(\n+            &mir,\n+            LivenessMode {\n+                include_regular_use: false,\n+                include_drops: true,\n+            },\n+        ),\n+    };\n+\n+    // Create the region inference context, generate the constraints,\n+    // and then solve them.\n+    let mut regioncx = RegionInferenceContext::new(num_region_variables);\n+    constraint_generation::generate_constraints(infcx, &mut regioncx, &mir, source, liveness);\n+    let errors = regioncx.solve(infcx, &mir);\n+\n+    assert!(errors.is_empty(), \"FIXME: report region inference failures\");\n+\n+    let computation = RegionComputation { mir, regioncx };\n+\n+    // Dump MIR results into a file, if that is enabled. This let us\n+    // write unit-tests.\n+    dump_mir_results(infcx, liveness, source, &computation);\n+\n+    computation\n+}\n+\n struct LivenessResults {\n     regular: LivenessResult,\n     drop: LivenessResult,\n@@ -89,13 +115,17 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     liveness: &LivenessResults,\n     source: MirSource,\n-    regioncx: &RegionInferenceContext,\n-    mir: &Mir<'tcx>,\n+    computation: &RegionComputation<'tcx>,\n ) {\n     if !mir_util::dump_enabled(infcx.tcx, \"nll\", source) {\n         return;\n     }\n \n+    let RegionComputation {\n+        ref mir,\n+        ref regioncx,\n+    } = *computation;\n+\n     let regular_liveness_per_location: FxHashMap<_, _> = mir.basic_blocks()\n         .indices()\n         .flat_map(|bb| {\n@@ -126,7 +156,12 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n         match pass_where {\n             // Before the CFG, dump out the values for each region variable.\n             PassWhere::BeforeCFG => for region in regioncx.regions() {\n-                writeln!(out, \"| {:?}: {:?}\", region, regioncx.region_value(region))?;\n+                writeln!(\n+                    out,\n+                    \"| {:?}: {:?}\",\n+                    region,\n+                    regioncx.region_value(region)\n+                )?;\n             },\n \n             // Before each basic block, dump out the values\n@@ -141,12 +176,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n                     &regular_liveness_per_location[&location],\n                     &drop_liveness_per_location[&location],\n                 );\n-                writeln!(\n-                    out,\n-                    \"            | Live variables at {:?}: {}\",\n-                    location,\n-                    s\n-                )?;\n+                writeln!(out, \"            | Live variables at {:?}: {}\", location, s)?;\n             }\n \n             PassWhere::AfterCFG => {}\n@@ -217,7 +247,11 @@ fn live_variable_set(regular: &LocalSet, drops: &LocalSet) -> String {\n         string.push_str(\", \");\n     }\n \n-    let len = if string.is_empty() { 0 } else { string.len() - 2  };\n+    let len = if string.is_empty() {\n+        0\n+    } else {\n+        string.len() - 2\n+    };\n \n     format!(\"[{}]\", &string[..len])\n }"}, {"sha": "c23d73e784ae9d04b4325e244feab9f66d95b5ef", "filename": "src/librustc_mir/transform/nll/region_infer.rs", "status": "modified", "additions": 44, "deletions": 31, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5b2adcce115ee0e3fe4e53b57a2b9f168c26b288/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2adcce115ee0e3fe4e53b57a2b9f168c26b288/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs?ref=5b2adcce115ee0e3fe4e53b57a2b9f168c26b288", "patch": "@@ -12,24 +12,31 @@ use super::{Region, RegionIndex};\n use std::mem;\n use rustc::infer::InferCtxt;\n use rustc::mir::{Location, Mir};\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashSet;\n \n pub struct RegionInferenceContext {\n-    definitions: IndexVec<RegionIndex, VarDefinition>,\n-    constraints: IndexVec<ConstraintIndex, Constraint>,\n-    errors: IndexVec<InferenceErrorIndex, InferenceError>,\n+    /// Contains the definition for every region variable.  Region\n+    /// variables are identified by their index (`RegionIndex`). The\n+    /// definition contains information about where the region came\n+    /// from as well as its final inferred value.\n+    definitions: IndexVec<RegionIndex, RegionDefinition>,\n+\n+    /// The constraints we have accumulated and used during solving.\n+    constraints: Vec<Constraint>,\n+\n+    /// List of errors we have accumulated as we add constraints.\n+    /// After solving is done, this is replaced with an empty vector.\n+    errors: Vec<InferenceError>,\n }\n \n pub struct InferenceError {\n     pub constraint_point: Location,\n     pub name: (), // FIXME(nashenas88) RegionName\n }\n \n-newtype_index!(InferenceErrorIndex);\n-\n #[derive(Default)]\n-struct VarDefinition {\n+struct RegionDefinition {\n     name: (), // FIXME(nashenas88) RegionName\n     value: Region,\n     capped: bool,\n@@ -42,26 +49,43 @@ pub struct Constraint {\n     point: Location,\n }\n \n-newtype_index!(ConstraintIndex);\n-\n impl RegionInferenceContext {\n     pub fn new(num_region_variables: usize) -> Self {\n         Self {\n             definitions: (0..num_region_variables)\n-                .map(|_| VarDefinition::default())\n+                .map(|_| RegionDefinition::default())\n                 .collect(),\n-            constraints: IndexVec::new(),\n-            errors: IndexVec::new(),\n+            constraints: Vec::new(),\n+            errors: Vec::new(),\n         }\n     }\n \n+\n+    /// Returns an iterator over all the region indices.\n+    pub fn regions(&self) -> impl Iterator<Item = RegionIndex> {\n+        self.definitions.indices()\n+    }\n+\n+    /// Returns the inferred value for the region `r`.\n+    ///\n+    /// Until `solve()` executes, this value is not particularly meaningful.\n+    pub fn region_value(&self, r: RegionIndex) -> &Region {\n+        &self.definitions[r].value\n+    }\n+\n+    /// Flags a region as being \"capped\" -- this means that if its\n+    /// value is required to grow as a result of some constraint\n+    /// (e.g., `add_live_point` or `add_outlives`), that indicates an\n+    /// error. This is used for the regions representing named\n+    /// lifetime parameters on a function: they get initialized to\n+    /// their complete value, and then \"capped\" so that they can no\n+    /// longer grow.\n     #[allow(dead_code)]\n-    pub fn cap_var(&mut self, v: RegionIndex) {\n+    pub(super) fn cap_var(&mut self, v: RegionIndex) {\n         self.definitions[v].capped = true;\n     }\n \n-    #[allow(dead_code)]\n-    pub fn add_live_point(&mut self, v: RegionIndex, point: Location) {\n+    pub(super) fn add_live_point(&mut self, v: RegionIndex, point: Location) {\n         debug!(\"add_live_point({:?}, {:?})\", v, point);\n         let definition = &mut self.definitions[v];\n         if definition.value.add_point(point) {\n@@ -74,28 +98,17 @@ impl RegionInferenceContext {\n         }\n     }\n \n-    #[allow(dead_code)]\n-    pub fn add_outlives(&mut self, sup: RegionIndex, sub: RegionIndex, point: Location) {\n+    pub(super) fn add_outlives(&mut self, sup: RegionIndex, sub: RegionIndex, point: Location) {\n         debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n         self.constraints.push(Constraint { sup, sub, point });\n     }\n \n-    /// Returns an iterator over all the region indices.\n-    pub fn regions(&self) -> impl Iterator<Item = RegionIndex> {\n-        self.definitions.indices()\n-    }\n-\n-    /// Returns the current value for the region `v`. This is only\n-    /// really meaningful after `solve` has executed.\n-    pub fn region_value(&self, v: RegionIndex) -> &Region {\n-        &self.definitions[v].value\n-    }\n-\n-    pub fn solve<'a, 'gcx, 'tcx>(\n+    /// Perform region inference.\n+    pub(super) fn solve<'a, 'gcx, 'tcx>(\n         &mut self,\n         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n         mir: &'a Mir<'tcx>,\n-    ) -> IndexVec<InferenceErrorIndex, InferenceError>\n+    ) -> Vec<InferenceError>\n     where\n         'gcx: 'tcx + 'a,\n         'tcx: 'a,\n@@ -138,7 +151,7 @@ impl RegionInferenceContext {\n             debug!(\"\\n\");\n         }\n \n-        mem::replace(&mut self.errors, IndexVec::new())\n+        mem::replace(&mut self.errors, Vec::new())\n     }\n }\n "}]}