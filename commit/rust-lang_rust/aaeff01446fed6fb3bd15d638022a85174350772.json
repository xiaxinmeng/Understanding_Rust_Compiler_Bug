{"sha": "aaeff01446fed6fb3bd15d638022a85174350772", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhZWZmMDE0NDZmZWQ2ZmIzYmQxNWQ2MzgwMjJhODUxNzQzNTA3NzI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-14T20:56:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-14T20:56:21Z"}, "message": "Rollup merge of #63490 - Centril:cleanup-pat-parser, r=petrochenkov\n\nlibsyntax: cleanup and refactor `pat.rs`\n\nA smaller refactoring & cleanup of `pat.rs` (best read commit by commit).\n\nr? @petrochenkov", "tree": {"sha": "63bda69b09883b1efd829a0921bdd1d9cd614967", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63bda69b09883b1efd829a0921bdd1d9cd614967"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aaeff01446fed6fb3bd15d638022a85174350772", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdVHV1CRBK7hj4Ov3rIwAAdHIIAHKUPJG5jQgONAP9F6bq2iPf\noFVULqqfpcENrWOMIaFiLi1A6jncW+7Z7/tzM6IrN4EQWq51n7C9/TZTg0AR2d1t\ntlpdqzfadiFBwoUoeUinTBx7Rp5BvNfnODP1sLKmZqA3MBrQV5Vw/au8cwSCLnlZ\n2qLvEs2StB/4yzBGZycD6s0U98dLzRD+jtOgZRvoaVQdxc8ZokiAjDPzeTIVBkO6\nGgZjId/hfV/NUcurUyFO1mz87+OCP1d2dPg1u1Uvp/Y6ZDvm4TDEKLUP5S74nLHz\nEp3tXOuZ0zG3agtu7fYknWVnyDpzN8pOzaK1nhxQECEmpp0xAh36umRDyZr2Xsc=\n=Znhu\n-----END PGP SIGNATURE-----\n", "payload": "tree 63bda69b09883b1efd829a0921bdd1d9cd614967\nparent c358476c1bcb195ad4808605626856691282190d\nparent c8fc4c106cfb7594dedf3372e33959e9b859c228\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1565816181 +0200\ncommitter GitHub <noreply@github.com> 1565816181 +0200\n\nRollup merge of #63490 - Centril:cleanup-pat-parser, r=petrochenkov\n\nlibsyntax: cleanup and refactor `pat.rs`\n\nA smaller refactoring & cleanup of `pat.rs` (best read commit by commit).\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aaeff01446fed6fb3bd15d638022a85174350772", "html_url": "https://github.com/rust-lang/rust/commit/aaeff01446fed6fb3bd15d638022a85174350772", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aaeff01446fed6fb3bd15d638022a85174350772/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c358476c1bcb195ad4808605626856691282190d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c358476c1bcb195ad4808605626856691282190d", "html_url": "https://github.com/rust-lang/rust/commit/c358476c1bcb195ad4808605626856691282190d"}, {"sha": "c8fc4c106cfb7594dedf3372e33959e9b859c228", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8fc4c106cfb7594dedf3372e33959e9b859c228", "html_url": "https://github.com/rust-lang/rust/commit/c8fc4c106cfb7594dedf3372e33959e9b859c228"}], "stats": {"total": 425, "additions": 235, "deletions": 190}, "files": [{"sha": "53f4d0998c3e1b7df6f3e2a28ecd573c006de91b", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 235, "deletions": 190, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/aaeff01446fed6fb3bd15d638022a85174350772/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaeff01446fed6fb3bd15d638022a85174350772/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=aaeff01446fed6fb3bd15d638022a85174350772", "patch": "@@ -3,7 +3,7 @@ use super::{Parser, PResult, PathStyle};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use crate::ptr::P;\n use crate::ast::{self, Attribute, Pat, PatKind, FieldPat, RangeEnd, RangeSyntax, Mac_};\n-use crate::ast::{BindingMode, Ident, Mutability, Expr, ExprKind};\n+use crate::ast::{BindingMode, Ident, Mutability, Path, QSelf, Expr, ExprKind};\n use crate::parse::token::{self};\n use crate::print::pprust;\n use crate::source_map::{respan, Span, Spanned};\n@@ -108,93 +108,52 @@ impl<'a> Parser<'a> {\n         maybe_whole!(self, NtPat, |x| x);\n \n         let lo = self.token.span;\n-        let pat;\n-        match self.token.kind {\n-            token::BinOp(token::And) | token::AndAnd => {\n-                // Parse &pat / &mut pat\n-                self.expect_and()?;\n-                let mutbl = self.parse_mutability();\n-                if let token::Lifetime(name) = self.token.kind {\n-                    let mut err = self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", name));\n-                    err.span_label(self.token.span, \"unexpected lifetime\");\n-                    return Err(err);\n-                }\n-                let subpat = self.parse_pat_with_range_pat(false, expected)?;\n-                pat = PatKind::Ref(subpat, mutbl);\n-            }\n-            token::OpenDelim(token::Paren) => {\n-                // Parse a tuple or parenthesis pattern.\n-                let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n-\n-                // Here, `(pat,)` is a tuple pattern.\n-                // For backward compatibility, `(..)` is a tuple pattern as well.\n-                pat = if fields.len() == 1 && !(trailing_comma || fields[0].is_rest()) {\n-                    PatKind::Paren(fields.into_iter().nth(0).unwrap())\n-                } else {\n-                    PatKind::Tuple(fields)\n-                };\n-            }\n+        let pat = match self.token.kind {\n+            token::BinOp(token::And) | token::AndAnd => self.parse_pat_deref(expected)?,\n+            token::OpenDelim(token::Paren) => self.parse_pat_tuple_or_parens()?,\n             token::OpenDelim(token::Bracket) => {\n                 // Parse `[pat, pat,...]` as a slice pattern.\n-                let (slice, _) = self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat(None))?;\n-                pat = PatKind::Slice(slice);\n+                PatKind::Slice(self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat(None))?.0)\n             }\n             token::DotDot => {\n                 self.bump();\n-                pat = if self.is_pat_range_end_start() {\n+                if self.is_pat_range_end_start() {\n                     // Parse `..42` for recovery.\n                     self.parse_pat_range_to(RangeEnd::Excluded, \"..\")?\n                 } else {\n                     // A rest pattern `..`.\n                     PatKind::Rest\n-                };\n+                }\n             }\n             token::DotDotEq => {\n                 // Parse `..=42` for recovery.\n                 self.bump();\n-                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")?;\n+                self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")?\n             }\n             token::DotDotDot => {\n                 // Parse `...42` for recovery.\n                 self.bump();\n-                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?;\n+                self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?\n             }\n             // At this point, token != &, &&, (, [\n             _ => if self.eat_keyword(kw::Underscore) {\n                 // Parse _\n-                pat = PatKind::Wild;\n+                PatKind::Wild\n             } else if self.eat_keyword(kw::Mut) {\n-                // Parse mut ident @ pat / mut ref ident @ pat\n-                let mutref_span = self.prev_span.to(self.token.span);\n-                let binding_mode = if self.eat_keyword(kw::Ref) {\n-                    self.diagnostic()\n-                        .struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n-                        .span_suggestion(\n-                            mutref_span,\n-                            \"try switching the order\",\n-                            \"ref mut\".into(),\n-                            Applicability::MachineApplicable\n-                        ).emit();\n-                    BindingMode::ByRef(Mutability::Mutable)\n-                } else {\n-                    BindingMode::ByValue(Mutability::Mutable)\n-                };\n-                pat = self.parse_pat_ident(binding_mode)?;\n+                self.recover_pat_ident_mut_first()?\n             } else if self.eat_keyword(kw::Ref) {\n                 // Parse ref ident @ pat / ref mut ident @ pat\n                 let mutbl = self.parse_mutability();\n-                pat = self.parse_pat_ident(BindingMode::ByRef(mutbl))?;\n+                self.parse_pat_ident(BindingMode::ByRef(mutbl))?\n             } else if self.eat_keyword(kw::Box) {\n-                // Parse box pat\n-                let subpat = self.parse_pat_with_range_pat(false, None)?;\n-                pat = PatKind::Box(subpat);\n+                // Parse `box pat`\n+                PatKind::Box(self.parse_pat_with_range_pat(false, None)?)\n             } else if self.token.is_ident() && !self.token.is_reserved_ident() &&\n                       self.parse_as_ident() {\n-                // Parse ident @ pat\n+                // Parse `ident @ pat`\n                 // This can give false positives and parse nullary enums,\n-                // they are dealt with later in resolve\n-                let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n-                pat = self.parse_pat_ident(binding_mode)?;\n+                // they are dealt with later in resolve.\n+                self.parse_pat_ident(BindingMode::ByValue(Mutability::Immutable))?\n             } else if self.token.is_path_start() {\n                 // Parse pattern starting with a path\n                 let (qself, path) = if self.eat_lt() {\n@@ -206,136 +165,186 @@ impl<'a> Parser<'a> {\n                     (None, self.parse_path(PathStyle::Expr)?)\n                 };\n                 match self.token.kind {\n-                    token::Not if qself.is_none() => {\n-                        // Parse macro invocation\n-                        self.bump();\n-                        let (delim, tts) = self.expect_delimited_token_tree()?;\n-                        let mac = respan(lo.to(self.prev_span), Mac_ {\n-                            path,\n-                            tts,\n-                            delim,\n-                            prior_type_ascription: self.last_type_ascription,\n-                        });\n-                        pat = PatKind::Mac(mac);\n-                    }\n+                    token::Not if qself.is_none() => self.parse_pat_mac_invoc(lo, path)?,\n                     token::DotDotDot | token::DotDotEq | token::DotDot => {\n-                        let (end_kind, form) = match self.token.kind {\n-                            token::DotDot => (RangeEnd::Excluded, \"..\"),\n-                            token::DotDotDot => (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\"),\n-                            token::DotDotEq => (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\"),\n-                            _ => panic!(\"can only parse `..`/`...`/`..=` for ranges \\\n-                                         (checked above)\"),\n-                        };\n-                        let op_span = self.token.span;\n-                        // Parse range\n-                        let span = lo.to(self.prev_span);\n-                        let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n-                        self.bump();\n-                        let end = self.parse_pat_range_end_opt(&begin, form)?;\n-                        pat = PatKind::Range(begin, end, respan(op_span, end_kind));\n-                    }\n-                    token::OpenDelim(token::Brace) => {\n-                        if qself.is_some() {\n-                            let msg = \"unexpected `{` after qualified path\";\n-                            let mut err = self.fatal(msg);\n-                            err.span_label(self.token.span, msg);\n-                            return Err(err);\n-                        }\n-                        // Parse struct pattern\n-                        self.bump();\n-                        let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n-                            e.emit();\n-                            self.recover_stmt();\n-                            (vec![], true)\n-                        });\n-                        self.bump();\n-                        pat = PatKind::Struct(path, fields, etc);\n-                    }\n-                    token::OpenDelim(token::Paren) => {\n-                        if qself.is_some() {\n-                            let msg = \"unexpected `(` after qualified path\";\n-                            let mut err = self.fatal(msg);\n-                            err.span_label(self.token.span, msg);\n-                            return Err(err);\n-                        }\n-                        // Parse tuple struct or enum pattern\n-                        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n-                        pat = PatKind::TupleStruct(path, fields)\n+                        self.parse_pat_range_starting_with_path(lo, qself, path)?\n                     }\n-                    _ => pat = PatKind::Path(qself, path),\n+                    token::OpenDelim(token::Brace) => self.parse_pat_struct(qself, path)?,\n+                    token::OpenDelim(token::Paren) => self.parse_pat_tuple_struct(qself, path)?,\n+                    _ => PatKind::Path(qself, path),\n                 }\n             } else {\n                 // Try to parse everything else as literal with optional minus\n                 match self.parse_literal_maybe_minus() {\n-                    Ok(begin) => {\n-                        let op_span = self.token.span;\n-                        if self.check(&token::DotDot) || self.check(&token::DotDotEq) ||\n-                                self.check(&token::DotDotDot) {\n-                            let (end_kind, form) = if self.eat(&token::DotDotDot) {\n-                                (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")\n-                            } else if self.eat(&token::DotDotEq) {\n-                                (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")\n-                            } else if self.eat(&token::DotDot) {\n-                                (RangeEnd::Excluded, \"..\")\n-                            } else {\n-                                panic!(\"impossible case: we already matched \\\n-                                        on a range-operator token\")\n-                            };\n-                            let end = self.parse_pat_range_end_opt(&begin, form)?;\n-                            pat = PatKind::Range(begin, end, respan(op_span, end_kind))\n-                        } else {\n-                            pat = PatKind::Lit(begin);\n-                        }\n-                    }\n-                    Err(mut err) => {\n-                        self.cancel(&mut err);\n-                        let expected = expected.unwrap_or(\"pattern\");\n-                        let msg = format!(\n-                            \"expected {}, found {}\",\n-                            expected,\n-                            self.this_token_descr(),\n-                        );\n-                        let mut err = self.fatal(&msg);\n-                        err.span_label(self.token.span, format!(\"expected {}\", expected));\n-                        let sp = self.sess.source_map().start_point(self.token.span);\n-                        if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n-                            self.sess.expr_parentheses_needed(&mut err, *sp, None);\n-                        }\n-                        return Err(err);\n+                    Ok(begin)\n+                        if self.check(&token::DotDot)\n+                            || self.check(&token::DotDotEq)\n+                            || self.check(&token::DotDotDot) =>\n+                    {\n+                        self.parse_pat_range_starting_with_lit(begin)?\n                     }\n+                    Ok(begin) => PatKind::Lit(begin),\n+                    Err(err) => return self.fatal_unexpected_non_pat(err, expected),\n                 }\n             }\n-        }\n+        };\n \n         let pat = self.mk_pat(lo.to(self.prev_span), pat);\n         let pat = self.maybe_recover_from_bad_qpath(pat, true)?;\n \n         if !allow_range_pat {\n-            match pat.node {\n-                PatKind::Range(\n-                    _, _, Spanned { node: RangeEnd::Included(RangeSyntax::DotDotDot), .. }\n-                ) => {},\n-                PatKind::Range(..) => {\n-                    let mut err = self.struct_span_err(\n-                        pat.span,\n-                        \"the range pattern here has ambiguous interpretation\",\n-                    );\n-                    err.span_suggestion(\n-                        pat.span,\n-                        \"add parentheses to clarify the precedence\",\n-                        format!(\"({})\", pprust::pat_to_string(&pat)),\n-                        // \"ambiguous interpretation\" implies that we have to be guessing\n-                        Applicability::MaybeIncorrect\n-                    );\n-                    return Err(err);\n-                }\n-                _ => {}\n-            }\n+            self.ban_pat_range_if_ambiguous(&pat)?\n         }\n \n         Ok(pat)\n     }\n \n+    /// Ban a range pattern if it has an ambiguous interpretation.\n+    fn ban_pat_range_if_ambiguous(&self, pat: &Pat) -> PResult<'a, ()> {\n+        match pat.node {\n+            PatKind::Range(\n+                .., Spanned { node: RangeEnd::Included(RangeSyntax::DotDotDot), .. }\n+            ) => return Ok(()),\n+            PatKind::Range(..) => {}\n+            _ => return Ok(()),\n+        }\n+\n+        let mut err = self.struct_span_err(\n+            pat.span,\n+            \"the range pattern here has ambiguous interpretation\",\n+        );\n+        err.span_suggestion(\n+            pat.span,\n+            \"add parentheses to clarify the precedence\",\n+            format!(\"({})\", pprust::pat_to_string(&pat)),\n+            // \"ambiguous interpretation\" implies that we have to be guessing\n+            Applicability::MaybeIncorrect\n+        );\n+        Err(err)\n+    }\n+\n+    /// Parse `&pat` / `&mut pat`.\n+    fn parse_pat_deref(&mut self, expected: Option<&'static str>) -> PResult<'a, PatKind> {\n+        self.expect_and()?;\n+        let mutbl = self.parse_mutability();\n+\n+        if let token::Lifetime(name) = self.token.kind {\n+            let mut err = self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", name));\n+            err.span_label(self.token.span, \"unexpected lifetime\");\n+            return Err(err);\n+        }\n+\n+        let subpat = self.parse_pat_with_range_pat(false, expected)?;\n+        Ok(PatKind::Ref(subpat, mutbl))\n+    }\n+\n+    /// Parse a tuple or parenthesis pattern.\n+    fn parse_pat_tuple_or_parens(&mut self) -> PResult<'a, PatKind> {\n+        let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+\n+        // Here, `(pat,)` is a tuple pattern.\n+        // For backward compatibility, `(..)` is a tuple pattern as well.\n+        Ok(if fields.len() == 1 && !(trailing_comma || fields[0].is_rest()) {\n+            PatKind::Paren(fields.into_iter().nth(0).unwrap())\n+        } else {\n+            PatKind::Tuple(fields)\n+        })\n+    }\n+\n+    /// Recover on `mut ref? ident @ pat` and suggest\n+    /// that the order of `mut` and `ref` is incorrect.\n+    fn recover_pat_ident_mut_first(&mut self) -> PResult<'a, PatKind> {\n+        let mutref_span = self.prev_span.to(self.token.span);\n+        let binding_mode = if self.eat_keyword(kw::Ref) {\n+            self.struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n+                .span_suggestion(\n+                    mutref_span,\n+                    \"try switching the order\",\n+                    \"ref mut\".into(),\n+                    Applicability::MachineApplicable\n+                )\n+                .emit();\n+            BindingMode::ByRef(Mutability::Mutable)\n+        } else {\n+            BindingMode::ByValue(Mutability::Mutable)\n+        };\n+        self.parse_pat_ident(binding_mode)\n+    }\n+\n+    /// Parse macro invocation\n+    fn parse_pat_mac_invoc(&mut self, lo: Span, path: Path) -> PResult<'a, PatKind> {\n+        self.bump();\n+        let (delim, tts) = self.expect_delimited_token_tree()?;\n+        let mac = respan(lo.to(self.prev_span), Mac_ {\n+            path,\n+            tts,\n+            delim,\n+            prior_type_ascription: self.last_type_ascription,\n+        });\n+        Ok(PatKind::Mac(mac))\n+    }\n+\n+    /// Parse a range pattern `$path $form $end?` where `$form = \"..\" | \"...\" | \"..=\" ;`.\n+    /// The `$path` has already been parsed and the next token is the `$form`.\n+    fn parse_pat_range_starting_with_path(\n+        &mut self,\n+        lo: Span,\n+        qself: Option<QSelf>,\n+        path: Path\n+    ) -> PResult<'a, PatKind> {\n+        let (end_kind, form) = match self.token.kind {\n+            token::DotDot => (RangeEnd::Excluded, \"..\"),\n+            token::DotDotDot => (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\"),\n+            token::DotDotEq => (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\"),\n+            _ => panic!(\"can only parse `..`/`...`/`..=` for ranges (checked above)\"),\n+        };\n+        let op_span = self.token.span;\n+        // Parse range\n+        let span = lo.to(self.prev_span);\n+        let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n+        self.bump();\n+        let end = self.parse_pat_range_end_opt(&begin, form)?;\n+        Ok(PatKind::Range(begin, end, respan(op_span, end_kind)))\n+    }\n+\n+    /// Parse a range pattern `$literal $form $end?` where `$form = \"..\" | \"...\" | \"..=\" ;`.\n+    /// The `$path` has already been parsed and the next token is the `$form`.\n+    fn parse_pat_range_starting_with_lit(&mut self, begin: P<Expr>) -> PResult<'a, PatKind> {\n+        let op_span = self.token.span;\n+        let (end_kind, form) = if self.eat(&token::DotDotDot) {\n+            (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")\n+        } else if self.eat(&token::DotDotEq) {\n+            (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")\n+        } else if self.eat(&token::DotDot) {\n+            (RangeEnd::Excluded, \"..\")\n+        } else {\n+            panic!(\"impossible case: we already matched on a range-operator token\")\n+        };\n+        let end = self.parse_pat_range_end_opt(&begin, form)?;\n+        Ok(PatKind::Range(begin, end, respan(op_span, end_kind)))\n+    }\n+\n+    fn fatal_unexpected_non_pat(\n+        &mut self,\n+        mut err: DiagnosticBuilder<'a>,\n+        expected: Option<&'static str>,\n+    ) -> PResult<'a, P<Pat>> {\n+        self.cancel(&mut err);\n+\n+        let expected = expected.unwrap_or(\"pattern\");\n+        let msg = format!(\"expected {}, found {}\", expected, self.this_token_descr());\n+\n+        let mut err = self.fatal(&msg);\n+        err.span_label(self.token.span, format!(\"expected {}\", expected));\n+\n+        let sp = self.sess.source_map().start_point(self.token.span);\n+        if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n+            self.sess.expr_parentheses_needed(&mut err, *sp, None);\n+        }\n+\n+        Err(err)\n+    }\n+\n     // Helper function to decide whether to parse as ident binding\n     // or to try to do something more complex like range patterns.\n     fn parse_as_ident(&mut self) -> bool {\n@@ -421,33 +430,62 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `ident` or `ident @ pat`.\n-    /// used by the copy foo and ref foo patterns to give a good\n+    /// Used by the copy foo and ref foo patterns to give a good\n     /// error message when parsing mistakes like `ref foo(a, b)`.\n-    fn parse_pat_ident(&mut self,\n-                       binding_mode: ast::BindingMode)\n-                       -> PResult<'a, PatKind> {\n+    fn parse_pat_ident(&mut self, binding_mode: BindingMode) -> PResult<'a, PatKind> {\n         let ident = self.parse_ident()?;\n         let sub = if self.eat(&token::At) {\n             Some(self.parse_pat(Some(\"binding pattern\"))?)\n         } else {\n             None\n         };\n \n-        // just to be friendly, if they write something like\n-        //   ref Some(i)\n-        // we end up here with ( as the current token.  This shortly\n-        // leads to a parse error.  Note that if there is no explicit\n+        // Just to be friendly, if they write something like `ref Some(i)`,\n+        // we end up here with `(` as the current token.\n+        // This shortly leads to a parse error. Note that if there is no explicit\n         // binding mode then we do not end up here, because the lookahead\n-        // will direct us over to parse_enum_variant()\n+        // will direct us over to `parse_enum_variant()`.\n         if self.token == token::OpenDelim(token::Paren) {\n             return Err(self.span_fatal(\n                 self.prev_span,\n-                \"expected identifier, found enum pattern\"))\n+                \"expected identifier, found enum pattern\",\n+            ))\n         }\n \n         Ok(PatKind::Ident(binding_mode, ident, sub))\n     }\n \n+    /// Parse a struct (\"record\") pattern (e.g. `Foo { ... }` or `Foo::Bar { ... }`).\n+    fn parse_pat_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n+        if qself.is_some() {\n+            let msg = \"unexpected `{` after qualified path\";\n+            let mut err = self.fatal(msg);\n+            err.span_label(self.token.span, msg);\n+            return Err(err);\n+        }\n+\n+        self.bump();\n+        let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n+            e.emit();\n+            self.recover_stmt();\n+            (vec![], true)\n+        });\n+        self.bump();\n+        Ok(PatKind::Struct(path, fields, etc))\n+    }\n+\n+    /// Parse tuple struct or tuple variant pattern (e.g. `Foo(...)` or `Foo::Bar(...)`).\n+    fn parse_pat_tuple_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n+        if qself.is_some() {\n+            let msg = \"unexpected `(` after qualified path\";\n+            let mut err = self.fatal(msg);\n+            err.span_label(self.token.span, msg);\n+            return Err(err);\n+        }\n+        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+        Ok(PatKind::TupleStruct(path, fields))\n+    }\n+\n     /// Parses the fields of a struct-like pattern.\n     fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<Spanned<FieldPat>>, bool)> {\n         let mut fields = Vec::new();\n@@ -482,17 +520,7 @@ impl<'a> Parser<'a> {\n                 etc = true;\n                 let mut etc_sp = self.token.span;\n \n-                if self.token == token::DotDotDot { // Issue #46718\n-                    // Accept `...` as if it were `..` to avoid further errors\n-                    self.struct_span_err(self.token.span, \"expected field pattern, found `...`\")\n-                        .span_suggestion(\n-                            self.token.span,\n-                            \"to omit remaining fields, use one fewer `.`\",\n-                            \"..\".to_owned(),\n-                            Applicability::MachineApplicable\n-                        )\n-                        .emit();\n-                }\n+                self.recover_one_fewer_dotdot();\n                 self.bump();  // `..` || `...`\n \n                 if self.token == token::CloseDelim(token::Brace) {\n@@ -574,6 +602,23 @@ impl<'a> Parser<'a> {\n         return Ok((fields, etc));\n     }\n \n+    /// Recover on `...` as if it were `..` to avoid further errors.\n+    /// See issue #46718.\n+    fn recover_one_fewer_dotdot(&self) {\n+        if self.token != token::DotDotDot {\n+            return;\n+        }\n+\n+        self.struct_span_err(self.token.span, \"expected field pattern, found `...`\")\n+            .span_suggestion(\n+                self.token.span,\n+                \"to omit remaining fields, use one fewer `.`\",\n+                \"..\".to_owned(),\n+                Applicability::MachineApplicable\n+            )\n+            .emit();\n+    }\n+\n     fn parse_pat_field(\n         &mut self,\n         lo: Span,"}]}