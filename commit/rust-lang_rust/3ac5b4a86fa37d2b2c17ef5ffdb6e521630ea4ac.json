{"sha": "3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYzViNGE4NmZhMzdkMmIyYzE3ZWY1ZmZkYjZlNTIxNjMwZWE0YWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-18T16:31:53Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-18T23:05:17Z"}, "message": "syntax: Parse multiple trait refs in a single implementation", "tree": {"sha": "0613184ab1f468f2a1b776c1d4c6df4ac15d69db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0613184ab1f468f2a1b776c1d4c6df4ac15d69db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "html_url": "https://github.com/rust-lang/rust/commit/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1528256fdc26199dd58b390e42e2d0dc53b9703d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1528256fdc26199dd58b390e42e2d0dc53b9703d", "html_url": "https://github.com/rust-lang/rust/commit/1528256fdc26199dd58b390e42e2d0dc53b9703d"}], "stats": {"total": 189, "additions": 126, "deletions": 63}, "files": [{"sha": "79523acb99ba678c76313f1d749b92fb1c920e41", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "patch": "@@ -635,8 +635,10 @@ enum item_ {\n                option<class_dtor>\n                ),\n     item_trait(~[ty_param], ~[trait_method]),\n-    item_impl(~[ty_param], option<@trait_ref> /* trait */,\n-              @ty /* self */, ~[@method]),\n+    item_impl(~[ty_param],\n+              ~[@trait_ref], /* traits this impl implements */\n+              @ty, /* self */\n+              ~[@method]),\n     item_mac(mac),\n }\n "}, {"sha": "df5df748a74b2891e69e2c3ebbe4f2eeb111f6aa", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "patch": "@@ -21,6 +21,7 @@ import ast_builder::append_types;\n import ast_builder::ast_builder;\n import ast_builder::methods;\n import ast_builder::path;\n+import ast_builder::path_concat;\n \n trait gen_send {\n     fn gen_send(cx: ext_ctxt) -> @ast::item;"}, {"sha": "6bcf22c8220628e90fefa377d0e03680f7d34dae", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "patch": "@@ -2085,13 +2085,22 @@ class parser {\n                 (some(id), self.parse_ty_params())\n             }\n         };\n-        let ifce = if self.eat_keyword(~\"of\") {\n-            let path = self.parse_path_with_tps(false);\n-            if option::is_none(ident) {\n-                ident = some(vec::last(path.idents));\n+        let traits;\n+        if self.eat_keyword(~\"of\") {\n+            let for_atom = interner::intern(*self.reader.interner(), @~\"for\");\n+            traits = self.parse_trait_ref_list(token::IDENT(for_atom, false));\n+            if traits.len() >= 1 && option::is_none(ident) {\n+                ident = some(vec::last(traits[0].path.idents));\n             }\n-            some(@{path: path, ref_id: self.get_id(), impl_id: self.get_id()})\n-        } else { none };\n+            if traits.len() == 0 {\n+                self.fatal(~\"BUG: 'of' but no trait\");\n+            }\n+            if traits.len() > 1 {\n+                self.fatal(~\"BUG: multiple traits\");\n+            }\n+        } else {\n+            traits = ~[];\n+        };\n         let ident = alt ident {\n           some(name) { name }\n           none { self.expect_keyword(~\"of\"); fail; }\n@@ -2103,7 +2112,7 @@ class parser {\n         while !self.eat(token::RBRACE) {\n             vec::push(meths, self.parse_method(public));\n         }\n-        (ident, item_impl(tps, ifce, ty, meths), none)\n+        (ident, item_impl(tps, traits, ty, meths), none)\n     }\n \n     // Instantiates ident <i> with references to <typarams> as arguments.\n@@ -2127,9 +2136,9 @@ class parser {\n           ref_id: self.get_id(), impl_id: self.get_id()}\n     }\n \n-    fn parse_trait_ref_list() -> ~[@trait_ref] {\n+    fn parse_trait_ref_list(ket: token::token) -> ~[@trait_ref] {\n         self.parse_seq_to_before_end(\n-            token::LBRACE, seq_sep_trailing_disallowed(token::COMMA),\n+            ket, seq_sep_trailing_disallowed(token::COMMA),\n             |p| p.parse_trait_ref())\n     }\n \n@@ -2139,7 +2148,7 @@ class parser {\n         let ty_params = self.parse_ty_params();\n         let class_path = self.ident_to_path_tys(class_name, ty_params);\n         let traits : ~[@trait_ref] = if self.eat(token::COLON)\n-            { self.parse_trait_ref_list() }\n+            { self.parse_trait_ref_list(token::LBRACE) }\n         else { ~[] };\n         self.expect(token::LBRACE);\n         let mut ms: ~[@class_member] = ~[];"}, {"sha": "b1730bfc587637c87bb9794fc20ee32e8c913628", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "patch": "@@ -558,16 +558,18 @@ fn print_item(s: ps, &&item: @ast::item) {\n           }\n           bclose(s, item.span);\n        }\n-      ast::item_impl(tps, ifce, ty, methods) {\n+      ast::item_impl(tps, traits, ty, methods) {\n         head(s, ~\"impl\");\n         word(s.s, *item.ident);\n         print_type_params(s, tps);\n         space(s.s);\n-        option::iter(ifce, |p| {\n+        if vec::len(traits) != 0u {\n             word_nbsp(s, ~\"of\");\n-            print_path(s, p.path, false);\n+            do commasep(s, inconsistent, traits) |s, p| {\n+                print_path(s, p.path, false);\n+            }\n             space(s.s);\n-            });\n+        }\n         word_nbsp(s, ~\"for\");\n         print_type(s, ty);\n         space(s.s);"}, {"sha": "14fe18edd094a6f9c19511373d7b7a3014d97357", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "patch": "@@ -135,9 +135,11 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n             for vr.node.args.each |va| { v.visit_ty(va.ty, e, v); }\n         }\n       }\n-      item_impl(tps, ifce, ty, methods) {\n+      item_impl(tps, traits, ty, methods) {\n         v.visit_ty_params(tps, e, v);\n-        option::iter(ifce, |p| visit_path(p.path, e, v));\n+        for traits.each |p| {\n+            visit_path(p.path, e, v);\n+        }\n         v.visit_ty(ty, e, v);\n         for methods.each |m| {\n             visit_method_helper(m, e, v)"}, {"sha": "e11008f4d6fe5f755e813deb437e24c2d1ece5d4", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "patch": "@@ -410,14 +410,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n         ref, we need to map it to its parent class */\n             ebml_w.wr_str(def_to_str(local_def(it.id)));\n           }\n-          some(ast_map::node_item(@{node: item_impl(_,\n-                                               some(ifce),_,_),_},_)) {\n-            ebml_w.wr_str(def_to_str(did));\n-          }\n-          some(_) {\n-            ebml_w.wr_str(def_to_str(did));\n-          }\n-          none {\n+          _ {\n             // Must be a re-export, then!\n             // ...or an iface ref\n             ebml_w.wr_str(def_to_str(did));\n@@ -715,7 +708,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n       }\n-      item_impl(tps, ifce, _, methods) {\n+      item_impl(tps, traits, _, methods) {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -729,9 +722,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             ebml_w.writer.write(str::bytes(def_to_str(local_def(m.id))));\n             ebml_w.end_tag();\n         }\n-        do option::iter(ifce) |t| {\n-           encode_trait_ref(ebml_w, ecx, t)\n-        };\n+        if traits.len() > 1 {\n+            fail ~\"multiple traits!!\";\n+        }\n+        for traits.each |associated_trait| {\n+           encode_trait_ref(ebml_w, ecx, associated_trait)\n+        }\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n "}, {"sha": "55bc99fa68812ff7a71eed4ddceb95b1915fee7e", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "patch": "@@ -2966,16 +2966,20 @@ class Resolver {\n                 }\n             }\n \n-            item_impl(type_parameters, interface_reference, self_type,\n+            item_impl(type_parameters, implemented_traits, self_type,\n                       methods) {\n \n-                self.resolve_implementation(item.id,\n-                                            item.span,\n-                                            type_parameters,\n-                                            interface_reference,\n-                                            self_type,\n-                                            methods,\n-                                            visitor);\n+                // XXX: Should take an array of traits.\n+                let trait_reference;\n+                if implemented_traits.len() == 0 {\n+                    trait_reference = none;\n+                } else {\n+                    trait_reference = some(implemented_traits[0]);\n+                }\n+\n+                self.resolve_implementation(item.id, item.span,\n+                                            type_parameters, trait_reference,\n+                                            self_type, methods, visitor);\n             }\n \n             item_trait(type_parameters, methods) {"}, {"sha": "b750870ff86833eada94cea0dff86c1c1c646e12", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "patch": "@@ -2474,13 +2474,16 @@ fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n     result\n }\n \n+// XXX: Needs to return an array of traits.\n fn impl_trait(cx: ctxt, id: ast::def_id) -> option<t> {\n     if id.crate == ast::local_crate {\n         #debug(\"(impl_trait) searching for trait impl %?\", id);\n         alt cx.items.find(id.node) {\n-           some(ast_map::node_item(@{node: ast::item_impl(\n-              _, some(@{ref_id: id, _}), _, _), _}, _)) {\n-              some(node_id_to_type(cx, id))\n+           some(ast_map::node_item(@{\n+                    node: ast::item_impl(_, traits, _, _),\n+                    _},\n+                _)) if traits.len() >= 1 {\n+              some(node_id_to_type(cx, traits[0].ref_id))\n            }\n            some(ast_map::node_item(@{node: ast::item_class(*),\n                            _},_)) {"}, {"sha": "7f269944059fc9a8419d760663e1d4b07005f637", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "patch": "@@ -454,7 +454,7 @@ class lookup {\n                 for (*trait_ids).each |trait_id| {\n                     #debug(\"(adding inherent and extension candidates) \\\n                             trying trait: %s\",\n-                           node_id_to_str(self.tcx().items, trait_id.node));\n+                           self.def_id_to_str(trait_id));\n \n                     let coherence_info = self.fcx.ccx.coherence_info;\n                     alt coherence_info.extension_methods.find(trait_id) {\n@@ -463,6 +463,10 @@ class lookup {\n                         }\n                         some(extension_methods) {\n                             for extension_methods.each |implementation| {\n+                                #debug(\"(adding inherent and extension \\\n+                                         candidates) adding impl %s\",\n+                                       self.def_id_to_str\n+                                        (implementation.did));\n                                 self.add_candidates_from_impl\n                                     (implementation, use_assignability);\n                             }\n@@ -473,6 +477,14 @@ class lookup {\n         }\n     }\n \n+    fn def_id_to_str(def_id: ast::def_id) -> ~str {\n+        if def_id.crate == ast::local_crate {\n+            node_id_to_str(self.tcx().items, def_id.node)\n+        } else {\n+            ast_map::path_to_str(csearch::get_item_path(self.tcx(), def_id))\n+        }\n+    }\n+\n     fn write_mty_from_candidate(cand: candidate) -> method_map_entry {\n         let tcx = self.fcx.ccx.tcx;\n "}, {"sha": "f0c70cbc3a9e9eda056b2938a1859a9ca046b864", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "patch": "@@ -154,9 +154,21 @@ class CoherenceChecker {\n \n         visit_crate(*crate, (), mk_simple_visitor(@{\n             visit_item: |item| {\n+                #debug(\"(checking coherence) item '%s'\", *item.ident);\n+\n                 alt item.node {\n-                    item_impl(_, associated_trait, self_type, _) {\n-                        self.check_implementation(item, associated_trait);\n+                    item_impl(_, associated_traits, self_type, _) {\n+                        // XXX: Accept an array of traits.\n+                        let optional_associated_trait;\n+                        if associated_traits.len() == 0 {\n+                            optional_associated_trait = none;\n+                        } else {\n+                            optional_associated_trait =\n+                                some(associated_traits[0]);\n+                        }\n+\n+                        self.check_implementation(item,\n+                                                  optional_associated_trait);\n                     }\n                     _ {\n                         // Nothing to do.\n@@ -189,6 +201,10 @@ class CoherenceChecker {\n         let self_type = self.crate_context.tcx.tcache.get(local_def(item.id));\n         alt optional_associated_trait {\n             none {\n+                #debug(\"(checking implementation) no associated trait for \\\n+                        item '%s'\",\n+                       *item.ident);\n+\n                 alt get_base_type_def_id(self.inference_context,\n                                          item.span,\n                                          self_type.ty) {\n@@ -207,6 +223,12 @@ class CoherenceChecker {\n             some(associated_trait) {\n                 let def = self.crate_context.tcx.def_map.get\n                     (associated_trait.ref_id);\n+                #debug(\"(checking implementation) adding impl for trait \\\n+                        '%s', item '%s'\",\n+                       ast_map::node_id_to_str(self.crate_context.tcx.items,\n+                                               associated_trait.ref_id),\n+                       *item.ident);\n+\n                 let implementation = self.create_impl_from_item(item);\n                 self.add_trait_method(def_id_of_def(def), implementation);\n             }\n@@ -362,7 +384,15 @@ class CoherenceChecker {\n                             self.privileged_types.remove(privileged_type);\n                         }\n                     }\n-                    item_impl(_, optional_trait_ref, _, _) {\n+                    item_impl(_, associated_traits, _, _) {\n+                        // XXX: Accept an array of traits.\n+                        let optional_trait_ref;\n+                        if associated_traits.len() == 0 {\n+                            optional_trait_ref = none;\n+                        } else {\n+                            optional_trait_ref = some(associated_traits[0]);\n+                        }\n+\n                         alt self.base_type_def_ids.find(local_def(item.id)) {\n                             none {\n                                 // Nothing to do."}, {"sha": "e6c780e6e08245033c96c5cd8298c16e9d38d845", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "patch": "@@ -110,7 +110,7 @@ type methoddoc = {\n \n type impldoc = {\n     item: itemdoc,\n-    trait_ty: option<~str>,\n+    trait_types: ~[~str],\n     self_ty: option<~str>,\n     methods: ~[methoddoc]\n };"}, {"sha": "bdcfb8cc5903e2bc7f9158dfb613888757e336fe", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "patch": "@@ -235,7 +235,7 @@ fn impldoc_from_impl(\n ) -> doc::impldoc {\n     {\n         item: itemdoc,\n-        trait_ty: none,\n+        trait_types: ~[],\n         self_ty: none,\n         methods: do vec::map(methods) |method| {\n             {"}, {"sha": "b04210f4d31ba65ebd3dfbcd85c31ed6b7396343", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "patch": "@@ -224,14 +224,16 @@ fn header_name(doc: doc::itemtag) -> ~str {\n       doc::impltag(doc) {\n         assert option::is_some(doc.self_ty);\n         let self_ty = option::get(doc.self_ty);\n-        alt doc.trait_ty {\n-          some(trait_ty) {\n-            #fmt(\"%s of %s for %s\", doc.name(), trait_ty, self_ty)\n-          }\n-          none {\n-            #fmt(\"%s for %s\", doc.name(), self_ty)\n-          }\n+        let mut trait_part = ~\"\";\n+        for doc.trait_types.eachi |i, trait_type| {\n+            if i == 0 {\n+                trait_part += ~\" of \";\n+            } else {\n+                trait_part += \", \";\n+            }\n+            trait_part += trait_type;\n         }\n+        #fmt(\"%s%s for %s\", doc.name(), trait_part, self_ty)\n       }\n       _ {\n         doc.name()"}, {"sha": "774106a6fb41ab4335fc36f24734aa6de7bd1ee3", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=3ac5b4a86fa37d2b2c17ef5ffdb6e521630ea4ac", "patch": "@@ -230,38 +230,38 @@ fn fold_impl(\n \n     let srv = fold.ctxt;\n \n-    let (trait_ty, self_ty) = do astsrv::exec(srv) |ctxt| {\n+    let (trait_types, self_ty) = do astsrv::exec(srv) |ctxt| {\n         alt ctxt.ast_map.get(doc.id()) {\n           ast_map::node_item(@{\n-            node: ast::item_impl(_, trait_ty, self_ty, _), _\n+            node: ast::item_impl(_, trait_types, self_ty, _), _\n           }, _) {\n-            let trait_ty = option::map(trait_ty, |p| {\n+            let trait_types = vec::map(trait_types, |p| {\n                 pprust::path_to_str(p.path)\n             });\n-            (trait_ty, some(pprust::ty_to_str(self_ty)))\n+            (trait_types, some(pprust::ty_to_str(self_ty)))\n           }\n           _ { fail ~\"expected impl\" }\n         }\n     };\n \n     {\n-        trait_ty: trait_ty,\n+        trait_types: trait_types,\n         self_ty: self_ty,\n         methods: merge_methods(fold.ctxt, doc.id(), doc.methods)\n         with doc\n     }\n }\n \n #[test]\n-fn should_add_impl_trait_ty() {\n+fn should_add_impl_trait_types() {\n     let doc = test::mk_doc(~\"impl i of j for int { fn a<T>() { } }\");\n-    assert doc.cratemod().impls()[0].trait_ty == some(~\"j\");\n+    assert doc.cratemod().impls()[0].trait_types[0] == ~\"j\";\n }\n \n #[test]\n-fn should_not_add_impl_trait_ty_if_none() {\n+fn should_not_add_impl_trait_types_if_none() {\n     let doc = test::mk_doc(~\"impl i for int { fn a() { } }\");\n-    assert doc.cratemod().impls()[0].trait_ty == none;\n+    assert vec::len(doc.cratemod().impls()[0].trait_types) == 0;\n }\n \n #[test]"}]}