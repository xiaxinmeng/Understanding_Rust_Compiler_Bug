{"sha": "5c6069c7a90761c120cecbd8e18317bce21dd213", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNjA2OWM3YTkwNzYxYzEyMGNlY2JkOGUxODMxN2JjZTIxZGQyMTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-01T09:37:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-01T09:37:36Z"}, "message": "auto merge of #8184 : thestinger/rust/retreat, r=huonw", "tree": {"sha": "62ecb0b11716c84c2f9c161576b547674b2a6b8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62ecb0b11716c84c2f9c161576b547674b2a6b8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c6069c7a90761c120cecbd8e18317bce21dd213", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c6069c7a90761c120cecbd8e18317bce21dd213", "html_url": "https://github.com/rust-lang/rust/commit/5c6069c7a90761c120cecbd8e18317bce21dd213", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c6069c7a90761c120cecbd8e18317bce21dd213/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b018dd9bacab613c9627e2cc2c3491cb86042ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b018dd9bacab613c9627e2cc2c3491cb86042ee", "html_url": "https://github.com/rust-lang/rust/commit/1b018dd9bacab613c9627e2cc2c3491cb86042ee"}, {"sha": "1fc4db2d086fd068a934c9ed2ccf25456fedc216", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fc4db2d086fd068a934c9ed2ccf25456fedc216", "html_url": "https://github.com/rust-lang/rust/commit/1fc4db2d086fd068a934c9ed2ccf25456fedc216"}], "stats": {"total": 2626, "additions": 1312, "deletions": 1314}, "files": [{"sha": "ce68fb4179df977e4527d7e89e86cce9f178496e", "filename": "doc/po/rust.md.pot", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Fpo%2Frust.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Fpo%2Frust.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Frust.md.pot?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -1792,11 +1792,11 @@ msgstr \"\"\n msgid \"\"\n \"~~~~ {.xfail-test}\\n\"\n \"fn iter<T>(seq: &[T], f: &fn(T)) {\\n\"\n-\"    for seq.iter().advance |elt| { f(elt); }\\n\"\n+\"    foreach elt in seq.iter() { f(elt); }\\n\"\n \"}\\n\"\n \"fn map<T, U>(seq: &[T], f: &fn(T) -> U) -> ~[U] {\\n\"\n \"    let mut acc = ~[];\\n\"\n-\"    for seq.iter().advance |elt| { acc.push(f(elt)); }\\n\"\n+\"    foreach elt in seq.iter() { acc.push(f(elt)); }\\n\"\n \"    acc\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n@@ -4570,7 +4570,7 @@ msgstr \"\"\n #: doc/rust.md:2405\n #, no-wrap\n msgid \"\"\n-\"for v.iter().advance |e| {\\n\"\n+\"foreach e in v.iter() {\\n\"\n \"    bar(*e);\\n\"\n \"}\\n\"\n \"~~~~\\n\""}, {"sha": "841e6a233935804363c05f39e35b97a945a35b35", "filename": "doc/po/tutorial-container.md.pot", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Fpo%2Ftutorial-container.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Fpo%2Ftutorial-container.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-container.md.pot?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -376,7 +376,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"// print out all the elements in the vector\\n\"\n-\"for xs.iter().advance |x| {\\n\"\n+\"foreach x in xs.iter() {\\n\"\n \"    println(x.to_str())\\n\"\n \"}\\n\"\n msgstr \"\"\n@@ -386,7 +386,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"// print out all but the first 3 elements in the vector\\n\"\n-\"for xs.iter().skip(3).advance |x| {\\n\"\n+\"foreach x in xs.iter().skip(3) {\\n\"\n \"    println(x.to_str())\\n\"\n \"}\\n\"\n \"~~~\\n\"\n@@ -418,7 +418,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"// print out the pairs of elements up to (&3, &\\\"baz\\\")\\n\"\n-\"for it.advance |(x, y)| {\\n\"\n+\"foreach (x, y) in it {\\n\"\n \"    println(fmt!(\\\"%d %s\\\", *x, *y));\\n\"\n msgstr \"\"\n \n@@ -487,7 +487,7 @@ msgid \"\"\n \"    pub fn from_iterator(iterator: &mut T) -> ~[A] {\\n\"\n \"        let (lower, _) = iterator.size_hint();\\n\"\n \"        let mut xs = with_capacity(lower);\\n\"\n-\"        for iterator.advance |x| {\\n\"\n+\"        foreach x in iterator {\\n\"\n \"            xs.push(x);\\n\"\n \"        }\\n\"\n \"        xs\\n\"\n@@ -587,7 +587,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"// prints `5`, `4` and `3`\\n\"\n-\"for it.invert().advance |&x| {\\n\"\n+\"foreach &x in it.invert() {\\n\"\n \"    println(fmt!(\\\"%?\\\", x))\\n\"\n \"}\\n\"\n \"~~~\\n\""}, {"sha": "fb7d60716bf6144a9cb57f7d8422c5fdee9a1d8e", "filename": "doc/po/tutorial-tasks.md.pot", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Fpo%2Ftutorial-tasks.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Fpo%2Ftutorial-tasks.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-tasks.md.pot?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -587,7 +587,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"    let mut final_res = 0f64;\\n\"\n-\"    for futures.mut_iter().advance |ft|  {\\n\"\n+\"    foreach ft in futures.mut_iter()  {\\n\"\n \"        final_res += ft.get();\\n\"\n \"    }\\n\"\n \"    println(fmt!(\\\"^2/6 is not far from : %?\\\", final_res));\\n\""}, {"sha": "2b24d688a96f6ffdcacebaecd9a96337bf8b8895", "filename": "doc/po/tutorial.md.pot", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Fpo%2Ftutorial.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Fpo%2Ftutorial.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial.md.pot?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -2501,7 +2501,7 @@ msgstr \"\"\n msgid \"\"\n \"// Iterate over a vector, obtaining a pointer to each element\\n\"\n \"// (`for` is explained in the next section)\\n\"\n-\"for crayons.iter().advance |crayon| {\\n\"\n+\"foreach crayon in crayons.iter() {\\n\"\n \"    let delicious_crayon_wax = unwrap_crayon(*crayon);\\n\"\n \"    eat_crayon_wax(delicious_crayon_wax);\\n\"\n \"}\\n\"\n@@ -3101,7 +3101,7 @@ msgid \"\"\n \"~~~~\\n\"\n \"fn map<T, U>(vector: &[T], function: &fn(v: &T) -> U) -> ~[U] {\\n\"\n \"    let mut accumulator = ~[];\\n\"\n-\"    for vector.iter().advance |element| {\\n\"\n+\"    foreach element in vector.iter() {\\n\"\n \"        accumulator.push(function(element));\\n\"\n \"    }\\n\"\n \"    return accumulator;\\n\"\n@@ -3570,7 +3570,7 @@ msgid \"\"\n \"~~~~\\n\"\n \"# trait Printable { fn print(&self); }\\n\"\n \"fn print_all<T: Printable>(printable_things: ~[T]) {\\n\"\n-\"    for printable_things.iter().advance |thing| {\\n\"\n+\"    foreach thing in printable_things.iter() {\\n\"\n \"        thing.print();\\n\"\n \"    }\\n\"\n \"}\\n\"\n@@ -3650,7 +3650,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"fn draw_all<T: Drawable>(shapes: ~[T]) {\\n\"\n-\"    for shapes.iter().advance |shape| { shape.draw(); }\\n\"\n+\"    foreach shape in shapes.iter() { shape.draw(); }\\n\"\n \"}\\n\"\n \"# let c: Circle = new_circle();\\n\"\n \"# draw_all(~[c]);\\n\"\n@@ -3673,7 +3673,7 @@ msgid \"\"\n \"~~~~\\n\"\n \"# trait Drawable { fn draw(&self); }\\n\"\n \"fn draw_all(shapes: &[@Drawable]) {\\n\"\n-\"    for shapes.iter().advance |shape| { shape.draw(); }\\n\"\n+\"    foreach shape in shapes.iter() { shape.draw(); }\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n msgstr \"\""}, {"sha": "51b2786746a33996408fd6c12aa4a09f4492e8d1", "filename": "doc/rust.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -880,11 +880,11 @@ the function name.\n \n ~~~~ {.xfail-test}\n fn iter<T>(seq: &[T], f: &fn(T)) {\n-    for seq.iter().advance |elt| { f(elt); }\n+    foreach elt in seq.iter() { f(elt); }\n }\n fn map<T, U>(seq: &[T], f: &fn(T) -> U) -> ~[U] {\n     let mut acc = ~[];\n-    for seq.iter().advance |elt| { acc.push(f(elt)); }\n+    foreach elt in seq.iter() { acc.push(f(elt)); }\n     acc\n }\n ~~~~\n@@ -2378,7 +2378,7 @@ An example of a for loop over the contents of a vector:\n \n let v: &[foo] = &[a, b, c];\n \n-for v.iter().advance |e| {\n+foreach e in v.iter() {\n     bar(*e);\n }\n ~~~~"}, {"sha": "b7465ddb4df7f14b68621a92c67df3e23c3ec1ea", "filename": "doc/tutorial-container.md", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Ftutorial-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Ftutorial-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-container.md?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -164,20 +164,19 @@ dropped when they become unnecessary.\n \n ## For loops\n \n-The `for` loop syntax is currently in transition, and will switch from the old\n-closure-based iteration protocol to iterator objects. For now, the `advance`\n-adaptor is required as a compatibility shim to use iterators with for loops.\n+The `foreach` keyword is transitional, and is going to replace the current\n+obsolete `for` loop.\n \n ~~~\n let xs = [2, 3, 5, 7, 11, 13, 17];\n \n // print out all the elements in the vector\n-for xs.iter().advance |x| {\n+foreach x in xs.iter() {\n     println(x.to_str())\n }\n \n // print out all but the first 3 elements in the vector\n-for xs.iter().skip(3).advance |x| {\n+foreach x in xs.iter().skip(3) {\n     println(x.to_str())\n }\n ~~~\n@@ -193,7 +192,7 @@ let ys = [\"foo\", \"bar\", \"baz\", \"foobar\"];\n let mut it = xs.iter().zip(ys.iter());\n \n // print out the pairs of elements up to (&3, &\"baz\")\n-for it.advance |(x, y)| {\n+foreach (x, y) in it {\n     printfln!(\"%d %s\", *x, *y);\n \n     if *x == 3 {\n@@ -230,7 +229,7 @@ impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n     pub fn from_iterator(iterator: &mut T) -> ~[A] {\n         let (lower, _) = iterator.size_hint();\n         let mut xs = with_capacity(lower);\n-        for iterator.advance |x| {\n+        foreach x in iterator {\n             xs.push(x);\n         }\n         xs\n@@ -301,7 +300,7 @@ printfln!(\"%?\", it.next()); // prints `Some(&2)`\n printfln!(\"%?\", it.next_back()); // prints `Some(&6)`\n \n // prints `5`, `4` and `3`\n-for it.invert().advance |&x| {\n+foreach &x in it.invert() {\n     printfln!(\"%?\", x)\n }\n ~~~\n@@ -320,7 +319,7 @@ let mut it = xs.iter().chain_(ys.iter()).transform(|&x| x * 2);\n printfln!(\"%?\", it.next()); // prints `Some(2)`\n \n // prints `16`, `14`, `12`, `10`, `8`, `6`, `4`\n-for it.invert().advance |x| {\n+foreach x in it.invert() {\n     printfln!(\"%?\", x);\n }\n ~~~"}, {"sha": "3092dfff56e9f17d45cf77e3ae1df072690d389c", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -327,7 +327,7 @@ fn main() {\n     let mut futures = vec::from_fn(1000, |ind| do extra::future::spawn { partial_sum(ind) });\n \n     let mut final_res = 0f64;\n-    for futures.mut_iter().advance |ft|  {\n+    foreach ft in futures.mut_iter()  {\n         final_res += ft.get();\n     }\n     println(fmt!(\"\u03c0^2/6 is not far from : %?\", final_res));"}, {"sha": "a8ace8558b5a64a8c076c085cf0ede2008c658f7", "filename": "doc/tutorial.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -1398,7 +1398,7 @@ assert!(!crayons.is_empty());\n \n // Iterate over a vector, obtaining a pointer to each element\n // (`for` is explained in the next section)\n-for crayons.iter().advance |crayon| {\n+foreach crayon in crayons.iter() {\n     let delicious_crayon_wax = unwrap_crayon(*crayon);\n     eat_crayon_wax(delicious_crayon_wax);\n }\n@@ -1749,7 +1749,7 @@ of `vector`:\n ~~~~\n fn map<T, U>(vector: &[T], function: &fn(v: &T) -> U) -> ~[U] {\n     let mut accumulator = ~[];\n-    for vector.iter().advance |element| {\n+    foreach element in vector.iter() {\n         accumulator.push(function(element));\n     }\n     return accumulator;\n@@ -2027,7 +2027,7 @@ generic types.\n ~~~~\n # trait Printable { fn print(&self); }\n fn print_all<T: Printable>(printable_things: ~[T]) {\n-    for printable_things.iter().advance |thing| {\n+    foreach thing in printable_things.iter() {\n         thing.print();\n     }\n }\n@@ -2073,7 +2073,7 @@ However, consider this function:\n trait Drawable { fn draw(&self); }\n \n fn draw_all<T: Drawable>(shapes: ~[T]) {\n-    for shapes.iter().advance |shape| { shape.draw(); }\n+    foreach shape in shapes.iter() { shape.draw(); }\n }\n # let c: Circle = new_circle();\n # draw_all(~[c]);\n@@ -2088,7 +2088,7 @@ an _object_.\n ~~~~\n # trait Drawable { fn draw(&self); }\n fn draw_all(shapes: &[@Drawable]) {\n-    for shapes.iter().advance |shape| { shape.draw(); }\n+    foreach shape in shapes.iter() { shape.draw(); }\n }\n ~~~~\n "}, {"sha": "4b9a48ed445365460af324d20d01764207b2dc36", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -243,7 +243,7 @@ pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n            config.src_base.to_str());\n     let mut tests = ~[];\n     let dirs = os::list_dir_path(&config.src_base);\n-    for dirs.iter().advance |file| {\n+    foreach file in dirs.iter() {\n         let file = file.clone();\n         debug!(\"inspecting file %s\", file.to_str());\n         if is_test(config, &file) {\n@@ -271,11 +271,11 @@ pub fn is_test(config: &config, testfile: &Path) -> bool {\n \n     let mut valid = false;\n \n-    for valid_extensions.iter().advance |ext| {\n+    foreach ext in valid_extensions.iter() {\n         if name.ends_with(*ext) { valid = true; }\n     }\n \n-    for invalid_prefixes.iter().advance |pre| {\n+    foreach pre in invalid_prefixes.iter() {\n         if name.starts_with(*pre) { valid = false; }\n     }\n "}, {"sha": "48c467c34b6de2b337e8f4a3a3e909f7dfec52e6", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -56,7 +56,7 @@ pub fn run(lib_path: &str,\n         err_fd: None\n     });\n \n-    for input.iter().advance |input| {\n+    foreach input in input.iter() {\n         proc.input().write_str(*input);\n     }\n     let output = proc.finish_with_output();"}, {"sha": "f984473a4c7ac16af4d4ae23f88ebb8ddad9c4c0", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -283,7 +283,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n-        for ProcRes.stdout.line_iter().advance |line| {\n+        foreach line in ProcRes.stdout.line_iter() {\n             if check_lines[i].trim() == line.trim() {\n                 i += 1u;\n             }\n@@ -313,7 +313,7 @@ fn check_error_patterns(props: &TestProps,\n     let mut next_err_idx = 0u;\n     let mut next_err_pat = &props.error_patterns[next_err_idx];\n     let mut done = false;\n-    for ProcRes.stderr.line_iter().advance |line| {\n+    foreach line in ProcRes.stderr.line_iter() {\n         if line.contains(*next_err_pat) {\n             debug!(\"found error pattern %s\", *next_err_pat);\n             next_err_idx += 1u;\n@@ -333,7 +333,7 @@ fn check_error_patterns(props: &TestProps,\n         fatal_ProcRes(fmt!(\"error pattern '%s' not found!\",\n                            missing_patterns[0]), ProcRes);\n     } else {\n-        for missing_patterns.iter().advance |pattern| {\n+        foreach pattern in missing_patterns.iter() {\n             error(fmt!(\"error pattern '%s' not found!\", *pattern));\n         }\n         fatal_ProcRes(~\"multiple error patterns not found\", ProcRes);\n@@ -386,9 +386,9 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for ProcRes.stderr.line_iter().advance |line| {\n+    foreach line in ProcRes.stderr.line_iter() {\n         let mut was_expected = false;\n-        for expected_errors.iter().enumerate().advance |(i, ee)| {\n+        foreach (i, ee) in expected_errors.iter().enumerate() {\n             if !found_flags[i] {\n                 debug!(\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n                        prefixes[i], ee.kind, ee.msg, line);\n@@ -559,7 +559,7 @@ fn compose_and_run_compiler(\n     let extra_link_args = ~[~\"-L\",\n                             aux_output_dir_name(config, testfile).to_str()];\n \n-    for props.aux_builds.iter().advance |rel_ab| {\n+    foreach rel_ab in props.aux_builds.iter() {\n         let abs_ab = config.aux_base.push_rel(&Path(*rel_ab));\n         let aux_args =\n             make_compile_args(config, props, ~[~\"--lib\"] + extra_link_args,\n@@ -786,7 +786,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     runargs.push(fmt!(\"%s\", config.adb_test_dir));\n     runargs.push(fmt!(\"%s\", prog_short));\n \n-    for args.args.iter().advance |tv| {\n+    foreach tv in args.args.iter() {\n         runargs.push(tv.to_owned());\n     }\n \n@@ -803,7 +803,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n                      Some(~\"\"));\n \n     let mut exitcode : int = 0;\n-    for exitcode_out.iter().advance |c| {\n+    foreach c in exitcode_out.iter() {\n         if !c.is_digit() { break; }\n         exitcode = exitcode * 10 + match c {\n             '0' .. '9' => c as int - ('0' as int),\n@@ -852,7 +852,7 @@ fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n     let tstr = aux_output_dir_name(config, testfile).to_str();\n \n     let dirs = os::list_dir_path(&Path(tstr));\n-    for dirs.iter().advance |file| {\n+    foreach file in dirs.iter() {\n \n         if (file.filetype() == Some(~\".so\")) {\n "}, {"sha": "9e622b78fff4a9a5b014cf0293f871345d590da7", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -789,7 +789,7 @@ mod tests {\n         }\n \n         // Wait for children to pass their asserts\n-        for children.iter().advance |r| {\n+        foreach r in children.iter() {\n             r.recv();\n         }\n "}, {"sha": "5061dbf401b37f898bf264644c7c229f81e589f0", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -206,7 +206,7 @@ impl<'self> FromBase64 for &'self [u8] {\n         let mut modulus = 0;\n \n         let mut it = self.iter();\n-        for it.advance |&byte| {\n+        foreach &byte in it {\n             let ch = byte as char;\n             let val = byte as u32;\n "}, {"sha": "4d2d5635effe93541bcabacb438d36592cac40dc", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -398,7 +398,7 @@ impl Bitv {\n       match self.rep {\n         Small(ref b) => b.is_true(self.nbits),\n         _ => {\n-          for self.iter().advance |i| { if !i { return false; } }\n+          foreach i in self.iter() { if !i { return false; } }\n           true\n         }\n       }\n@@ -419,7 +419,7 @@ impl Bitv {\n       match self.rep {\n         Small(ref b) => b.is_false(self.nbits),\n         Big(_) => {\n-          for self.iter().advance |i| { if i { return false; } }\n+          foreach i in self.iter() { if i { return false; } }\n           true\n         }\n       }\n@@ -483,7 +483,7 @@ impl Bitv {\n      */\n      pub fn to_str(&self) -> ~str {\n         let mut rs = ~\"\";\n-        for self.iter().advance |i| {\n+        foreach i in self.iter() {\n             if i {\n                 rs.push_char('1');\n             } else {\n@@ -684,7 +684,7 @@ impl BitvSet {\n         if self.capacity() < other.capacity() {\n             self.bitv.storage.grow(other.capacity() / uint::bits, &0);\n         }\n-        for other.bitv.storage.iter().enumerate().advance |(i, &w)| {\n+        foreach (i, &w) in other.bitv.storage.iter().enumerate() {\n             let old = self.bitv.storage[i];\n             let new = f(old, w);\n             self.bitv.storage[i] = new;\n@@ -883,12 +883,12 @@ impl BitvSet {\n         let min = num::min(len1, len2);\n \n         /* only one of these loops will execute and that's the point */\n-        for self.bitv.storage.slice(min, len1).iter().enumerate().advance |(i, &w)| {\n+        foreach (i, &w) in self.bitv.storage.slice(min, len1).iter().enumerate() {\n             if !f(true, (i + min) * uint::bits, w) {\n                 return false;\n             }\n         }\n-        for other.bitv.storage.slice(min, len2).iter().enumerate().advance |(i, &w)| {\n+        foreach (i, &w) in other.bitv.storage.slice(min, len2).iter().enumerate() {\n             if !f(false, (i + min) * uint::bits, w) {\n                 return false;\n             }\n@@ -1308,7 +1308,7 @@ mod tests {\n         let bools = [true, false, true, true];\n         let bitv = from_bools(bools);\n \n-        for bitv.iter().zip(bools.iter()).advance |(act, &ex)| {\n+        foreach (act, &ex) in bitv.iter().zip(bools.iter()) {\n             assert_eq!(ex, act);\n         }\n     }\n@@ -1610,7 +1610,7 @@ mod tests {\n         let bitv = Bitv::new(uint::bits, false);\n         do b.iter {\n             let mut sum = 0;\n-            for bitv.iter().advance |pres| {\n+            foreach pres in bitv.iter() {\n                 sum += pres as uint;\n             }\n         }\n@@ -1621,7 +1621,7 @@ mod tests {\n         let bitv = Bitv::new(BENCH_BITS, false);\n         do b.iter {\n             let mut sum = 0;\n-            for bitv.iter().advance |pres| {\n+            foreach pres in bitv.iter() {\n                 sum += pres as uint;\n             }\n         }\n@@ -1633,7 +1633,7 @@ mod tests {\n                                               |idx| {idx % 3 == 0}));\n         do b.iter {\n             let mut sum = 0;\n-            for bitv.iter().advance |idx| {\n+            foreach idx in bitv.iter() {\n                 sum += idx;\n             }\n         }"}, {"sha": "0ca992fdacd53be44afb9386b9c2ec47ad38ac5b", "filename": "src/libextra/container.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcontainer.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -91,7 +91,7 @@ mod bench {\n         let mut rng = rand::XorShiftRng::new();\n         let mut keys = vec::from_fn(n, |_| rng.gen::<uint>() % n);\n \n-        for keys.iter().advance() |k| {\n+        foreach k in keys.iter() {\n             map.insert(*k, 1);\n         }\n "}, {"sha": "0efd88fdf504310b7189a1ca0803eaa8c5ea346f", "filename": "src/libextra/crypto/digest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fcrypto%2Fdigest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fcrypto%2Fdigest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fdigest.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -45,7 +45,7 @@ pub trait Digest {\n \n fn to_hex(rr: &[u8]) -> ~str {\n     let mut s = ~\"\";\n-    for rr.iter().advance() |b| {\n+    foreach b in rr.iter() {\n         let hex = uint::to_str_radix(*b as uint, 16u);\n         if hex.len() == 1 {\n             s.push_char('0');"}, {"sha": "7ede1978495c6149be9f2ac46abf21c62309234b", "filename": "src/libextra/crypto/sha1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -53,7 +53,7 @@ pub struct Sha1 {\n \n fn add_input(st: &mut Sha1, msg: &[u8]) {\n     assert!((!st.computed));\n-    for msg.iter().advance |element| {\n+    foreach element in msg.iter() {\n         st.msg_block[st.msg_block_idx] = *element;\n         st.msg_block_idx += 1;\n         st.len_low += 8;\n@@ -150,7 +150,7 @@ fn circular_shift(bits: u32, word: u32) -> u32 {\n fn mk_result(st: &mut Sha1, rs: &mut [u8]) {\n     if !st.computed { pad_msg(st); st.computed = true; }\n     let mut i = 0;\n-    for st.h.mut_iter().advance |ptr_hpart| {\n+    foreach ptr_hpart in st.h.mut_iter() {\n         let hpart = *ptr_hpart;\n         rs[i]   = (hpart >> 24u32 & 0xFFu32) as u8;\n         rs[i+1] = (hpart >> 16u32 & 0xFFu32) as u8;\n@@ -334,7 +334,7 @@ mod tests {\n         let mut out = [0u8, ..20];\n \n         let mut sh = ~Sha1::new();\n-        for tests.iter().advance |t| {\n+        foreach t in tests.iter() {\n             (*sh).input_str(t.input);\n             sh.result(out);\n             assert!(t.output.as_slice() == out);\n@@ -348,7 +348,7 @@ mod tests {\n \n \n         // Test that it works when accepting the message in pieces\n-        for tests.iter().advance |t| {\n+        foreach t in tests.iter() {\n             let len = t.input.len();\n             let mut left = len;\n             while left > 0u {"}, {"sha": "27612b00f610a1d4945178f548d76d788b19e680", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -939,7 +939,7 @@ mod tests {\n \n     fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n         // Test that it works when accepting the message all at once\n-        for tests.iter().advance() |t| {\n+        foreach t in tests.iter() {\n             sh.input_str(t.input);\n \n             let out_str = sh.result_str();\n@@ -949,7 +949,7 @@ mod tests {\n         }\n \n         // Test that it works when accepting the message in pieces\n-        for tests.iter().advance() |t| {\n+        foreach t in tests.iter() {\n             let len = t.input.len();\n             let mut left = len;\n             while left > 0u {"}, {"sha": "c684ff14615c732e71f65b25b3b4b24271b97fb6", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -548,7 +548,7 @@ impl<A, T: Iterator<A>> FromIterator<A, T> for DList<A> {\n \n impl<A, T: Iterator<A>> Extendable<A, T> for DList<A> {\n     fn extend(&mut self, iterator: &mut T) {\n-        for iterator.advance |elt| { self.push_back(elt); }\n+        foreach elt in *iterator { self.push_back(elt); }\n     }\n }\n \n@@ -688,7 +688,7 @@ mod tests {\n         check_links(&m);\n         let sum = v + u;\n         assert_eq!(sum.len(), m.len());\n-        for sum.consume_iter().advance |elt| {\n+        foreach elt in sum.consume_iter() {\n             assert_eq!(m.pop_front(), Some(elt))\n         }\n     }\n@@ -712,7 +712,7 @@ mod tests {\n         check_links(&m);\n         let sum = u + v;\n         assert_eq!(sum.len(), m.len());\n-        for sum.consume_iter().advance |elt| {\n+        foreach elt in sum.consume_iter() {\n             assert_eq!(m.pop_front(), Some(elt))\n         }\n     }\n@@ -743,7 +743,7 @@ mod tests {\n     #[test]\n     fn test_iterator() {\n         let m = generate_test();\n-        for m.iter().enumerate().advance |(i, elt)| {\n+        foreach (i, elt) in m.iter().enumerate() {\n             assert_eq!(i as int, *elt);\n         }\n         let mut n = DList::new();\n@@ -791,7 +791,7 @@ mod tests {\n     #[test]\n     fn test_rev_iter() {\n         let m = generate_test();\n-        for m.rev_iter().enumerate().advance |(i, elt)| {\n+        foreach (i, elt) in m.rev_iter().enumerate() {\n             assert_eq!((6 - i) as int, *elt);\n         }\n         let mut n = DList::new();\n@@ -808,7 +808,7 @@ mod tests {\n     fn test_mut_iter() {\n         let mut m = generate_test();\n         let mut len = m.len();\n-        for m.mut_iter().enumerate().advance |(i, elt)| {\n+        foreach (i, elt) in m.mut_iter().enumerate() {\n             assert_eq!(i as int, *elt);\n             len -= 1;\n         }\n@@ -900,7 +900,7 @@ mod tests {\n     #[test]\n     fn test_mut_rev_iter() {\n         let mut m = generate_test();\n-        for m.mut_rev_iter().enumerate().advance |(i, elt)| {\n+        foreach (i, elt) in m.mut_rev_iter().enumerate() {\n             assert_eq!((6-i) as int, *elt);\n         }\n         let mut n = DList::new();\n@@ -970,7 +970,7 @@ mod tests {\n         check_links(&m);\n \n         let mut i = 0u;\n-        for m.consume_iter().zip(v.iter()).advance |(a, &b)| {\n+        foreach (a, &b) in m.consume_iter().zip(v.iter()) {\n             i += 1;\n             assert_eq!(a, b);\n         }"}, {"sha": "04bddeccf127a759cce11b301ef88aa8e2f1dff1", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -419,7 +419,7 @@ mod test {\n     fn make_file(path : &Path, contents: &[~str]) {\n         let file = io::file_writer(path, [io::Create, io::Truncate]).unwrap();\n \n-        for contents.iter().advance |str| {\n+        foreach str in contents.iter() {\n             file.write_str(*str);\n             file.write_char('\\n');\n         }\n@@ -446,13 +446,13 @@ mod test {\n             |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-byte-%u.tmp\", i)), true);\n \n         // 3 files containing 0\\n, 1\\n, and 2\\n respectively\n-        for filenames.iter().enumerate().advance |(i, filename)| {\n+        foreach (i, filename) in filenames.iter().enumerate() {\n             make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n         let fi = FileInput::from_vec(filenames.clone());\n \n-        for \"012\".iter().enumerate().advance |(line, c)| {\n+        foreach (line, c) in \"012\".iter().enumerate() {\n             assert_eq!(fi.read_byte(), c as int);\n             assert_eq!(fi.state().line_num, line);\n             assert_eq!(fi.state().line_num_file, 0);\n@@ -476,7 +476,7 @@ mod test {\n             |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-%u.tmp\", i)), true);\n \n         // 3 files containing 1\\n, 2\\n, and 3\\n respectively\n-        for filenames.iter().enumerate().advance |(i, filename)| {\n+        foreach (i, filename) in filenames.iter().enumerate() {\n             make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n@@ -496,7 +496,7 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-input-vec-%u.tmp\", i)), true);\n \n-        for filenames.iter().enumerate().advance |(i, filename)| {\n+        foreach (i, filename) in filenames.iter().enumerate() {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j));\n             make_file(filename.get_ref(), contents);\n@@ -517,7 +517,7 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-input-vec-state-%u.tmp\", i)),true);\n \n-        for filenames.iter().enumerate().advance |(i, filename)| {\n+        foreach (i, filename) in filenames.iter().enumerate() {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n             make_file(filename.get_ref(), contents);\n@@ -583,7 +583,7 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-next-file-%u.tmp\", i)),true);\n \n-        for filenames.iter().enumerate().advance |(i, filename)| {\n+        foreach (i, filename) in filenames.iter().enumerate() {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n             make_file(filename.get_ref(), contents);"}, {"sha": "b0e6f82322b6110f7204a77f6930cb1eabee546a", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -307,7 +307,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                 }\n             }\n             let mut name_pos = 0;\n-            for names.iter().advance() |nm| {\n+            foreach nm in names.iter() {\n                 name_pos += 1;\n                 let optid = match find_opt(opts, (*nm).clone()) {\n                   Some(id) => id,\n@@ -392,7 +392,7 @@ pub fn opt_count(mm: &Matches, nm: &str) -> uint {\n \n /// Returns true if any of several options were matched\n pub fn opts_present(mm: &Matches, names: &[~str]) -> bool {\n-    for names.iter().advance |nm| {\n+    foreach nm in names.iter() {\n         match find_opt(mm.opts, mkname(*nm)) {\n             Some(id) if !mm.vals[id].is_empty() => return true,\n             _ => (),\n@@ -422,7 +422,7 @@ pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n  * option took an argument\n  */\n pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n-    for names.iter().advance |nm| {\n+    foreach nm in names.iter() {\n         match opt_val(mm, *nm) {\n           Some(Val(ref s)) => return (*s).clone(),\n           _ => ()\n@@ -441,7 +441,7 @@ pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n pub fn opt_strs(mm: &Matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n     let r = opt_vals(mm, nm);\n-    for r.iter().advance |v| {\n+    foreach v in r.iter() {\n         match *v { Val(ref s) => acc.push((*s).clone()), _ => () }\n     }\n     acc\n@@ -671,7 +671,7 @@ pub mod groups {\n \n             // Normalize desc to contain words separated by one space character\n             let mut desc_normalized_whitespace = ~\"\";\n-            for desc.word_iter().advance |word| {\n+            foreach word in desc.word_iter() {\n                 desc_normalized_whitespace.push_str(word);\n                 desc_normalized_whitespace.push_char(' ');\n             }"}, {"sha": "3552ff59783a936ce6dcf2503d5d5b30d010af73", "filename": "src/libextra/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fiter.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -27,7 +27,7 @@ internal iterator by calling the `advance` method. For example:\n let xs = [0u, 1, 2, 3, 4, 5];\n let ys = [30, 40, 50, 60];\n let mut it = xs.iter().chain(ys.iter());\n-for it.advance |&x: &uint| {\n+foreach &x: &uint in it {\n     println(x.to_str());\n }\n ~~~"}, {"sha": "f0d5b336e308397b5471f7e6585d5fafc262b03a", "filename": "src/libextra/json.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -57,7 +57,7 @@ pub struct Error {\n \n fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n-    for s.iter().advance |c| {\n+    foreach c in s.iter() {\n         match c {\n           '\"' => escaped.push_str(\"\\\\\\\"\"),\n           '\\\\' => escaped.push_str(\"\\\\\\\\\"),\n@@ -923,7 +923,7 @@ impl serialize::Decoder for Decoder {\n     fn read_char(&mut self) -> char {\n         let mut v = ~[];\n         let s = self.read_str();\n-        for s.iter().advance |c| { v.push(c) }\n+        foreach c in s.iter() { v.push(c) }\n         if v.len() != 1 { fail!(\"string must have one character\") }\n         v[0]\n     }\n@@ -949,7 +949,7 @@ impl serialize::Decoder for Decoder {\n         let name = match self.stack.pop() {\n             String(s) => s,\n             List(list) => {\n-                for list.consume_rev_iter().advance |v| {\n+                foreach v in list.consume_rev_iter() {\n                     self.stack.push(v);\n                 }\n                 match self.stack.pop() {\n@@ -1067,7 +1067,7 @@ impl serialize::Decoder for Decoder {\n         let len = match self.stack.pop() {\n             List(list) => {\n                 let len = list.len();\n-                for list.consume_rev_iter().advance |v| {\n+                foreach v in list.consume_rev_iter() {\n                     self.stack.push(v);\n                 }\n                 len\n@@ -1087,7 +1087,7 @@ impl serialize::Decoder for Decoder {\n         let len = match self.stack.pop() {\n             Object(obj) => {\n                 let len = obj.len();\n-                for obj.consume_iter().advance |(key, value)| {\n+                foreach (key, value) in obj.consume_iter() {\n                     self.stack.push(value);\n                     self.stack.push(String(key));\n                 }\n@@ -1157,12 +1157,12 @@ impl Ord for Json {\n                         let mut d1_flat = ~[];\n \n                         // FIXME #4430: this is horribly inefficient...\n-                        for d0.iter().advance |(k, v)| {\n+                        foreach (k, v) in d0.iter() {\n                              d0_flat.push((@(*k).clone(), @(*v).clone()));\n                         }\n                         d0_flat.qsort();\n \n-                        for d1.iter().advance |(k, v)| {\n+                        foreach (k, v) in d1.iter() {\n                             d1_flat.push((@(*k).clone(), @(*v).clone()));\n                         }\n                         d1_flat.qsort();\n@@ -1297,7 +1297,7 @@ impl<A:ToJson> ToJson for ~[A] {\n impl<A:ToJson> ToJson for TreeMap<~str, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n-        for self.iter().advance |(key, value)| {\n+        foreach (key, value) in self.iter() {\n             d.insert((*key).clone(), value.to_json());\n         }\n         Object(~d)\n@@ -1307,7 +1307,7 @@ impl<A:ToJson> ToJson for TreeMap<~str, A> {\n impl<A:ToJson> ToJson for HashMap<~str, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n-        for self.iter().advance |(key, value)| {\n+        foreach (key, value) in self.iter() {\n             d.insert((*key).clone(), value.to_json());\n         }\n         Object(~d)\n@@ -1339,7 +1339,6 @@ mod tests {\n     use super::*;\n \n     use std::io;\n-    use std::result;\n \n     use serialize::Decodable;\n     use treemap::TreeMap;\n@@ -1365,7 +1364,7 @@ mod tests {\n     fn mk_object(items: &[(~str, Json)]) -> Json {\n         let mut d = ~TreeMap::new();\n \n-        for items.iter().advance |item| {\n+        foreach item in items.iter() {\n             match *item {\n                 (ref key, ref value) => { d.insert((*key).clone(), (*value).clone()); },\n             }"}, {"sha": "453ad857a05688dcd313390fdf4435cc4d9ea062", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -131,7 +131,7 @@ impl TotalOrd for BigUint {\n         if s_len < o_len { return Less; }\n         if s_len > o_len { return Greater;  }\n \n-        for self.data.rev_iter().zip(other.data.rev_iter()).advance |(&self_i, &other_i)| {\n+        foreach (&self_i, &other_i) in self.data.rev_iter().zip(other.data.rev_iter()) {\n             cond!((self_i < other_i) { return Less; }\n                   (self_i > other_i) { return Greater; })\n         }\n@@ -420,7 +420,7 @@ impl Integer for BigUint {\n             let bn = *b.data.last();\n             let mut d = ~[];\n             let mut carry = 0;\n-            for an.rev_iter().advance |elt| {\n+            foreach elt in an.rev_iter() {\n                 let ai = BigDigit::to_uint(carry, *elt);\n                 let di = ai / (bn as uint);\n                 assert!(di < BigDigit::base);\n@@ -524,7 +524,7 @@ impl ToStrRadix for BigUint {\n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n             let mut s = str::with_capacity(v.len() * l);\n-            for v.rev_iter().advance |n| {\n+            foreach n in v.rev_iter() {\n                 let ss = uint::to_str_radix(*n as uint, radix);\n                 s.push_str(\"0\".repeat(l - ss.len()));\n                 s.push_str(ss);\n@@ -651,7 +651,7 @@ impl BigUint {\n \n         let mut borrow = 0;\n         let mut shifted = ~[];\n-        for self.data.rev_iter().advance |elem| {\n+        foreach elem in self.data.rev_iter() {\n             shifted = ~[(*elem >> n_bits) | borrow] + shifted;\n             borrow = *elem << (BigDigit::bits - n_bits);\n         }\n@@ -1186,8 +1186,8 @@ mod biguint_tests {\n     fn test_cmp() {\n         let data: ~[BigUint] = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n             .map(|v| BigUint::from_slice(*v));\n-        for data.iter().enumerate().advance |(i, ni)| {\n-            for data.slice(i, data.len()).iter().enumerate().advance |(j0, nj)| {\n+        foreach (i, ni) in data.iter().enumerate() {\n+            foreach (j0, nj) in data.slice(i, data.len()).iter().enumerate() {\n                 let j = j0 + i;\n                 if i == j {\n                     assert_eq!(ni.cmp(nj), Equal);\n@@ -1360,7 +1360,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_add() {\n-        for sum_triples.iter().advance |elm| {\n+        foreach elm in sum_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1373,7 +1373,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_sub() {\n-        for sum_triples.iter().advance |elm| {\n+        foreach elm in sum_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1424,7 +1424,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_mul() {\n-        for mul_triples.iter().advance |elm| {\n+        foreach elm in mul_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1434,7 +1434,7 @@ mod biguint_tests {\n             assert!(b * a == c);\n         }\n \n-        for div_rem_quadruples.iter().advance |elm| {\n+        foreach elm in div_rem_quadruples.iter() {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1448,7 +1448,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_div_rem() {\n-        for mul_triples.iter().advance |elm| {\n+        foreach elm in mul_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1462,7 +1462,7 @@ mod biguint_tests {\n             }\n         }\n \n-        for div_rem_quadruples.iter().advance |elm| {\n+        foreach elm in div_rem_quadruples.iter() {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1579,9 +1579,9 @@ mod biguint_tests {\n     #[test]\n     fn test_to_str_radix() {\n         let r = to_str_pairs();\n-        for r.iter().advance |num_pair| {\n+        foreach num_pair in r.iter() {\n             let &(ref n, ref rs) = num_pair;\n-            for rs.iter().advance |str_pair| {\n+            foreach str_pair in rs.iter() {\n                 let &(ref radix, ref str) = str_pair;\n                 assert_eq!(&n.to_str_radix(*radix), str);\n             }\n@@ -1591,9 +1591,9 @@ mod biguint_tests {\n     #[test]\n     fn test_from_str_radix() {\n         let r = to_str_pairs();\n-        for r.iter().advance |num_pair| {\n+        foreach num_pair in r.iter() {\n             let &(ref n, ref rs) = num_pair;\n-            for rs.iter().advance |str_pair| {\n+            foreach str_pair in rs.iter() {\n                 let &(ref radix, ref str) = str_pair;\n                 assert_eq!(n, &FromStrRadix::from_str_radix(*str, *radix).get());\n             }\n@@ -1658,14 +1658,14 @@ mod bigint_tests {\n     fn test_cmp() {\n         let vs = [ &[2 as BigDigit], &[1, 1], &[2, 1], &[1, 1, 1] ];\n         let mut nums = ~[];\n-        for vs.rev_iter().advance |s| {\n+        foreach s in vs.rev_iter() {\n             nums.push(BigInt::from_slice(Minus, *s));\n         }\n         nums.push(Zero::zero());\n         nums.push_all_move(vs.map(|s| BigInt::from_slice(Plus, *s)));\n \n-        for nums.iter().enumerate().advance |(i, ni)| {\n-            for nums.slice(i, nums.len()).iter().enumerate().advance |(j0, nj)| {\n+        foreach (i, ni) in nums.iter().enumerate() {\n+            foreach (j0, nj) in nums.slice(i, nums.len()).iter().enumerate() {\n                 let j = i + j0;\n                 if i == j {\n                     assert_eq!(ni.cmp(nj), Equal);\n@@ -1769,7 +1769,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_add() {\n-        for sum_triples.iter().advance |elm| {\n+        foreach elm in sum_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1788,7 +1788,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_sub() {\n-        for sum_triples.iter().advance |elm| {\n+        foreach elm in sum_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1845,7 +1845,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_mul() {\n-        for mul_triples.iter().advance |elm| {\n+        foreach elm in mul_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1858,7 +1858,7 @@ mod bigint_tests {\n             assert!((-b) * a == -c);\n         }\n \n-        for div_rem_quadruples.iter().advance |elm| {\n+        foreach elm in div_rem_quadruples.iter() {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1897,7 +1897,7 @@ mod bigint_tests {\n             }\n         }\n \n-        for mul_triples.iter().advance |elm| {\n+        foreach elm in mul_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1907,7 +1907,7 @@ mod bigint_tests {\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        for div_rem_quadruples.iter().advance |elm| {\n+        foreach elm in div_rem_quadruples.iter() {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1940,7 +1940,7 @@ mod bigint_tests {\n             check_sub(&a.neg(), b, &q.neg(), &r.neg());\n             check_sub(&a.neg(), &b.neg(), q, &r.neg());\n         }\n-        for mul_triples.iter().advance |elm| {\n+        foreach elm in mul_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1950,7 +1950,7 @@ mod bigint_tests {\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        for div_rem_quadruples.iter().advance |elm| {\n+        foreach elm in div_rem_quadruples.iter() {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);"}, {"sha": "82b0808b788c0cb3f47206a6e8d311297de142e7", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -239,14 +239,14 @@ mod test {\n     fn test_scale_unscale() {\n         assert_eq!(_05_05i.scale(2f), _1_1i);\n         assert_eq!(_1_1i.unscale(2f), _05_05i);\n-        for all_consts.iter().advance |&c| {\n+        foreach &c in all_consts.iter() {\n             assert_eq!(c.scale(2f).unscale(2f), c);\n         }\n     }\n \n     #[test]\n     fn test_conj() {\n-        for all_consts.iter().advance |&c| {\n+        foreach &c in all_consts.iter() {\n             assert_eq!(c.conj(), Cmplx::new(c.re, -c.im));\n             assert_eq!(c.conj().conj(), c);\n         }\n@@ -283,7 +283,7 @@ mod test {\n             let (r, theta) = c.to_polar();\n             assert!((c - Cmplx::from_polar(&r, &theta)).norm() < 1e-6);\n         }\n-        for all_consts.iter().advance |&c| { test(c); }\n+        foreach &c in all_consts.iter() { test(c); }\n     }\n \n     mod arith {\n@@ -296,7 +296,7 @@ mod test {\n             assert_eq!(_0_1i + _1_0i, _1_1i);\n             assert_eq!(_1_0i + _neg1_1i, _0_1i);\n \n-            for all_consts.iter().advance |&c| {\n+            foreach &c in all_consts.iter() {\n                 assert_eq!(_0_0i + c, c);\n                 assert_eq!(c + _0_0i, c);\n             }\n@@ -308,7 +308,7 @@ mod test {\n             assert_eq!(_0_1i - _1_0i, _neg1_1i);\n             assert_eq!(_0_1i - _neg1_1i, _1_0i);\n \n-            for all_consts.iter().advance |&c| {\n+            foreach &c in all_consts.iter() {\n                 assert_eq!(c - _0_0i, c);\n                 assert_eq!(c - c, _0_0i);\n             }\n@@ -323,15 +323,15 @@ mod test {\n             assert_eq!(_0_1i * _0_1i, -_1_0i);\n             assert_eq!(_0_1i * _0_1i * _0_1i * _0_1i, _1_0i);\n \n-            for all_consts.iter().advance |&c| {\n+            foreach &c in all_consts.iter() {\n                 assert_eq!(c * _1_0i, c);\n                 assert_eq!(_1_0i * c, c);\n             }\n         }\n         #[test]\n         fn test_div() {\n             assert_eq!(_neg1_1i / _0_1i, _1_1i);\n-            for all_consts.iter().advance |&c| {\n+            foreach &c in all_consts.iter() {\n                 if c != Zero::zero() {\n                     assert_eq!(c / c, _1_0i);\n                 }\n@@ -341,7 +341,7 @@ mod test {\n         fn test_neg() {\n             assert_eq!(-_1_0i + _0_1i, _neg1_1i);\n             assert_eq!((-_0_1i) * _0_1i, _1_0i);\n-            for all_consts.iter().advance |&c| {\n+            foreach &c in all_consts.iter() {\n                 assert_eq!(-(-c), c);\n             }\n         }"}, {"sha": "af09ba42b807e03d151f4a3d1e4fb6e9119821c4", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -500,7 +500,7 @@ mod test {\n         }\n \n         let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\"];\n-        for xs.iter().advance |&s| {\n+        foreach &s in xs.iter() {\n             test(s);\n         }\n     }\n@@ -540,7 +540,7 @@ mod test {\n         }\n \n         let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\", \"3/2\"];\n-        for xs.iter().advance |&s| {\n+        foreach &s in xs.iter() {\n             test(s);\n         }\n     }"}, {"sha": "9873ab3d858dca972294008560242ddca071c635", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -206,7 +206,7 @@ impl<T: Ord, Iter: Iterator<T>> Extendable<T, Iter> for PriorityQueue<T> {\n         let len = self.capacity();\n         self.reserve_at_least(len + lower);\n \n-        for iter.advance |elem| {\n+        foreach elem in *iter {\n             self.push(elem);\n         }\n     }\n@@ -223,7 +223,7 @@ mod tests {\n         let iterout = ~[9, 5, 3];\n         let pq = PriorityQueue::from_vec(data);\n         let mut i = 0;\n-        for pq.iter().advance |el| {\n+        foreach el in pq.iter() {\n             assert_eq!(*el, iterout[i]);\n             i += 1;\n         }\n@@ -369,7 +369,7 @@ mod tests {\n \n         let mut q: PriorityQueue<uint> = xs.rev_iter().transform(|&x| x).collect();\n \n-        for xs.iter().advance |&x| {\n+        foreach &x in xs.iter() {\n             assert_eq!(q.pop(), x);\n         }\n     }"}, {"sha": "86fbbd4c3cc597f62e4978a9e26904cd295d7b65", "filename": "src/libextra/rc.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frc.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -53,13 +53,13 @@ impl<T> Rc<T> {\n }\n \n impl<T: Send> Rc<T> {\n-    pub fn from_owned(value: T) -> Rc<T> {\n+    pub fn from_send(value: T) -> Rc<T> {\n         unsafe { Rc::new(value) }\n     }\n }\n \n impl<T: Freeze> Rc<T> {\n-    pub fn from_const(value: T) -> Rc<T> {\n+    pub fn from_freeze(value: T) -> Rc<T> {\n         unsafe { Rc::new(value) }\n     }\n }\n@@ -111,7 +111,7 @@ mod test_rc {\n \n     #[test]\n     fn test_clone() {\n-        let x = Rc::from_owned(Cell::new(5));\n+        let x = Rc::from_send(Cell::new(5));\n         let y = x.clone();\n         do x.borrow().with_mut_ref |inner| {\n             *inner = 20;\n@@ -121,7 +121,7 @@ mod test_rc {\n \n     #[test]\n     fn test_deep_clone() {\n-        let x = Rc::from_owned(Cell::new(5));\n+        let x = Rc::from_send(Cell::new(5));\n         let y = x.deep_clone();\n         do x.borrow().with_mut_ref |inner| {\n             *inner = 20;\n@@ -131,21 +131,21 @@ mod test_rc {\n \n     #[test]\n     fn test_simple() {\n-        let x = Rc::from_const(5);\n+        let x = Rc::from_freeze(5);\n         assert_eq!(*x.borrow(), 5);\n     }\n \n     #[test]\n     fn test_simple_clone() {\n-        let x = Rc::from_const(5);\n+        let x = Rc::from_freeze(5);\n         let y = x.clone();\n         assert_eq!(*x.borrow(), 5);\n         assert_eq!(*y.borrow(), 5);\n     }\n \n     #[test]\n     fn test_destructor() {\n-        let x = Rc::from_owned(~5);\n+        let x = Rc::from_send(~5);\n         assert_eq!(**x.borrow(), 5);\n     }\n }\n@@ -178,13 +178,13 @@ impl<T> RcMut<T> {\n }\n \n impl<T: Send> RcMut<T> {\n-    pub fn from_owned(value: T) -> RcMut<T> {\n+    pub fn from_send(value: T) -> RcMut<T> {\n         unsafe { RcMut::new(value) }\n     }\n }\n \n impl<T: Freeze> RcMut<T> {\n-    pub fn from_const(value: T) -> RcMut<T> {\n+    pub fn from_freeze(value: T) -> RcMut<T> {\n         unsafe { RcMut::new(value) }\n     }\n }\n@@ -258,7 +258,7 @@ mod test_rc_mut {\n \n     #[test]\n     fn test_clone() {\n-        let x = RcMut::from_owned(5);\n+        let x = RcMut::from_send(5);\n         let y = x.clone();\n         do x.with_mut_borrow |value| {\n             *value = 20;\n@@ -270,7 +270,7 @@ mod test_rc_mut {\n \n     #[test]\n     fn test_deep_clone() {\n-        let x = RcMut::from_const(5);\n+        let x = RcMut::from_freeze(5);\n         let y = x.deep_clone();\n         do x.with_mut_borrow |value| {\n             *value = 20;\n@@ -282,7 +282,7 @@ mod test_rc_mut {\n \n     #[test]\n     fn borrow_many() {\n-        let x = RcMut::from_owned(5);\n+        let x = RcMut::from_send(5);\n         let y = x.clone();\n \n         do x.with_borrow |a| {\n@@ -298,7 +298,7 @@ mod test_rc_mut {\n \n     #[test]\n     fn modify() {\n-        let x = RcMut::from_const(5);\n+        let x = RcMut::from_freeze(5);\n         let y = x.clone();\n \n         do y.with_mut_borrow |a| {\n@@ -313,22 +313,22 @@ mod test_rc_mut {\n \n     #[test]\n     fn release_immutable() {\n-        let x = RcMut::from_owned(5);\n+        let x = RcMut::from_send(5);\n         do x.with_borrow |_| {}\n         do x.with_mut_borrow |_| {}\n     }\n \n     #[test]\n     fn release_mutable() {\n-        let x = RcMut::from_const(5);\n+        let x = RcMut::from_freeze(5);\n         do x.with_mut_borrow |_| {}\n         do x.with_borrow |_| {}\n     }\n \n     #[test]\n     #[should_fail]\n     fn frozen() {\n-        let x = RcMut::from_owned(5);\n+        let x = RcMut::from_send(5);\n         let y = x.clone();\n \n         do x.with_borrow |_| {\n@@ -340,7 +340,7 @@ mod test_rc_mut {\n     #[test]\n     #[should_fail]\n     fn mutable_dupe() {\n-        let x = RcMut::from_const(5);\n+        let x = RcMut::from_freeze(5);\n         let y = x.clone();\n \n         do x.with_mut_borrow |_| {\n@@ -352,7 +352,7 @@ mod test_rc_mut {\n     #[test]\n     #[should_fail]\n     fn mutable_freeze() {\n-        let x = RcMut::from_owned(5);\n+        let x = RcMut::from_send(5);\n         let y = x.clone();\n \n         do x.with_mut_borrow |_| {\n@@ -364,7 +364,7 @@ mod test_rc_mut {\n     #[test]\n     #[should_fail]\n     fn restore_freeze() {\n-        let x = RcMut::from_const(5);\n+        let x = RcMut::from_freeze(5);\n         let y = x.clone();\n \n         do x.with_borrow |_| {"}, {"sha": "e2950293719b376a6df102b9e7602604f5f98eec", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -39,7 +39,7 @@ impl<T> Container for RingBuf<T> {\n impl<T> Mutable for RingBuf<T> {\n     /// Clear the RingBuf, removing all values.\n     fn clear(&mut self) {\n-        for self.elts.mut_iter().advance |x| { *x = None }\n+        foreach x in self.elts.mut_iter() { *x = None }\n         self.nelts = 0;\n         self.lo = 0;\n     }\n@@ -334,7 +334,7 @@ impl<A, T: Iterator<A>> FromIterator<A, T> for RingBuf<A> {\n \n impl<A, T: Iterator<A>> Extendable<A, T> for RingBuf<A> {\n     fn extend(&mut self, iterator: &mut T) {\n-        for iterator.advance |elt| {\n+        foreach elt in *iterator {\n             self.push_back(elt);\n         }\n     }\n@@ -653,7 +653,7 @@ mod tests {\n             d.push_front(i);\n         }\n \n-        for d.mut_iter().enumerate().advance |(i, elt)| {\n+        foreach (i, elt) in d.mut_iter().enumerate() {\n             assert_eq!(*elt, 2 - i);\n             *elt = i;\n         }\n@@ -676,7 +676,7 @@ mod tests {\n             d.push_front(i);\n         }\n \n-        for d.mut_rev_iter().enumerate().advance |(i, elt)| {\n+        foreach (i, elt) in d.mut_rev_iter().enumerate() {\n             assert_eq!(*elt, i);\n             *elt = i;\n         }\n@@ -700,7 +700,7 @@ mod tests {\n \n         let mut seq = iterator::Counter::new(0u, 2).take_(256);\n         let deq: RingBuf<uint> = seq.collect();\n-        for deq.iter().enumerate().advance |(i, &x)| {\n+        foreach (i, &x) in deq.iter().enumerate() {\n             assert_eq!(2*i, x);\n         }\n         assert_eq!(deq.len(), 256);"}, {"sha": "0c8821e753e3a71cd6b2771424638bf0316ea77f", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -444,7 +444,7 @@ impl<D:Decoder,T:Decodable<D> + 'static> Decodable<D> for @mut T {\n impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            for self.iter().enumerate().advance |(i, e)| {\n+            foreach (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n@@ -454,7 +454,7 @@ impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            for self.iter().enumerate().advance |(i, e)| {\n+            foreach (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n@@ -474,7 +474,7 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            for self.iter().enumerate().advance |(i, e)| {\n+            foreach (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n@@ -668,7 +668,7 @@ impl<\n > Encodable<S> for DList<T> {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            for self.iter().enumerate().advance |(i, e)| {\n+            foreach (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n             }\n         }\n@@ -693,7 +693,7 @@ impl<\n > Encodable<S> for RingBuf<T> {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            for self.iter().enumerate().advance |(i, e)| {\n+            foreach (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n             }\n         }\n@@ -720,7 +720,7 @@ impl<\n     fn encode(&self, e: &mut E) {\n         do e.emit_map(self.len()) |e| {\n             let mut i = 0;\n-            for self.iter().advance |(key, val)| {\n+            foreach (key, val) in self.iter() {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n@@ -754,7 +754,7 @@ impl<\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n-            for self.iter().advance |e| {\n+            foreach e in self.iter() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n@@ -842,7 +842,7 @@ impl<\n     fn encode(&self, e: &mut E) {\n         do e.emit_map(self.len()) |e| {\n             let mut i = 0;\n-            for self.iter().advance |(key, val)| {\n+            foreach (key, val) in self.iter() {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n@@ -876,7 +876,7 @@ impl<\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n-            for self.iter().advance |e| {\n+            foreach e in self.iter() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n@@ -911,7 +911,7 @@ pub trait EncoderHelpers {\n impl<S:Encoder> EncoderHelpers for S {\n     fn emit_from_vec<T>(&mut self, v: &[T], f: &fn(&mut S, &T)) {\n         do self.emit_seq(v.len()) |this| {\n-            for v.iter().enumerate().advance |(i, e)| {\n+            foreach (i, e) in v.iter().enumerate() {\n                 do this.emit_seq_elt(i) |this| {\n                     f(this, e)\n                 }"}, {"sha": "eba9e1a4ed15a4f3743e864094fb5be7f25c918b", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -447,7 +447,7 @@ mod test_map {\n         assert!(m.insert(6, 10));\n         assert!(m.insert(10, 11));\n \n-        for m.mut_iter().advance |(k, v)| {\n+        foreach (k, v) in m.mut_iter() {\n             *v += k as int;\n         }\n \n@@ -489,7 +489,7 @@ mod test_map {\n         assert!(m.insert(6, 10));\n         assert!(m.insert(10, 11));\n \n-        for m.mut_rev_iter().advance |(k, v)| {\n+        foreach (k, v) in m.mut_rev_iter() {\n             *v += k as int;\n         }\n \n@@ -507,7 +507,7 @@ mod test_map {\n         let mut m = SmallIntMap::new();\n         m.insert(1, ~2);\n         let mut called = false;\n-        for m.consume().advance |(k, v)| {\n+        foreach (k, v) in m.consume() {\n             assert!(!called);\n             called = true;\n             assert_eq!(k, 1);"}, {"sha": "9cce19da524d7264b79f65e1bcaadadfe892159a", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -733,7 +733,7 @@ fn copy_vec<T:Clone>(dest: &mut [T],\n                     from: &[T]) {\n     assert!(s1+from.len() <= dest.len());\n \n-    for from.iter().enumerate().advance |(i, v)| {\n+    foreach (i, v) in from.iter().enumerate() {\n         dest[s1+i] = (*v).clone();\n     }\n }\n@@ -843,7 +843,7 @@ mod test_qsort {\n         let immut_names = names;\n \n         let pairs = vec::zip_slice(expected, immut_names);\n-        for pairs.iter().advance |p| {\n+        foreach p in pairs.iter() {\n             let (a, b) = *p;\n             debug!(\"%d %d\", a, b);\n             assert_eq!(a, b);"}, {"sha": "69d0a343424a75a2c77ace571f84590aa7a40a74", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -167,7 +167,7 @@ impl<'self> Stats for &'self [f64] {\n         } else {\n             let mean = self.mean();\n             let mut v = 0.0;\n-            for self.iter().advance |s| {\n+            foreach s in self.iter() {\n                 let x = *s - mean;\n                 v += x*x;\n             }\n@@ -254,7 +254,7 @@ pub fn winsorize(samples: &mut [f64], pct: f64) {\n     sort::tim_sort(tmp);\n     let lo = percentile_of_sorted(tmp, pct);\n     let hi = percentile_of_sorted(tmp, 100.0-pct);\n-    for samples.mut_iter().advance |samp| {\n+    foreach samp in samples.mut_iter() {\n         if *samp > hi {\n             *samp = hi\n         } else if *samp < lo {"}, {"sha": "dc26d1e36ce130706fb241f688c4ad5e3c50b106", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -989,13 +989,13 @@ mod tests {\n         }\n \n         // wait until all children get in the mutex\n-        for ports.iter().advance |port| { let _ = port.recv(); }\n+        foreach port in ports.iter() { let _ = port.recv(); }\n         do m.lock_cond |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         }\n         // wait until all children wake up\n-        for ports.iter().advance |port| { let _ = port.recv(); }\n+        foreach port in ports.iter() { let _ = port.recv(); }\n     }\n     #[test]\n     fn test_mutex_cond_broadcast() {\n@@ -1080,7 +1080,7 @@ mod tests {\n                     }\n                 }\n             }\n-            for sibling_convos.iter().advance |p| {\n+            foreach p in sibling_convos.iter() {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n             do m2.lock { }\n@@ -1090,7 +1090,7 @@ mod tests {\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n         let r = p.recv();\n-        for r.iter().advance |p| { p.recv(); } // wait on all its siblings\n+        foreach p in r.iter() { p.recv(); } // wait on all its siblings\n         do m.lock_cond |cond| {\n             let woken = cond.broadcast();\n             assert_eq!(woken, 0);\n@@ -1357,13 +1357,13 @@ mod tests {\n         }\n \n         // wait until all children get in the mutex\n-        for ports.iter().advance |port| { let _ = port.recv(); }\n+        foreach port in ports.iter() { let _ = port.recv(); }\n         do lock_cond(x, dg2) |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         }\n         // wait until all children wake up\n-        for ports.iter().advance |port| { let _ = port.recv(); }\n+        foreach port in ports.iter() { let _ = port.recv(); }\n     }\n     #[test]\n     fn test_rwlock_cond_broadcast() {"}, {"sha": "523e11e810c8747bf8ea058adb3fb3e192ae1852", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -35,7 +35,7 @@ pub struct TaskPool<T> {\n #[unsafe_destructor]\n impl<T> Drop for TaskPool<T> {\n     fn drop(&self) {\n-        for self.channels.iter().advance |channel| {\n+        foreach channel in self.channels.iter() {\n             channel.send(Quit);\n         }\n     }"}, {"sha": "3669c1ea0a3579a71061e253e032839fdbfbc7be", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -102,11 +102,11 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n         Number(0), Number(0), Number(0), Number(0), Number(0),\n         Number(0), Number(0), Number(0), Number(0),\n     ];\n-    for mparams.mut_iter().zip(params.iter()).advance |(dst, src)| {\n+    foreach (dst, src) in mparams.mut_iter().zip(params.iter()) {\n         *dst = (*src).clone();\n     }\n \n-    for cap.iter().transform(|&x| x).advance |c| {\n+    foreach c in cap.iter().transform(|&x| x) {\n         let cur = c as char;\n         let mut old_state = state;\n         match state {\n@@ -605,7 +605,7 @@ mod test {\n         let mut varstruct = Variables::new();\n         let vars = &mut varstruct;\n         let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n-        for caps.iter().advance |cap| {\n+        foreach cap in caps.iter() {\n             let res = expand(cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n                     \"Op %s succeeded incorrectly with 0 stack entries\", *cap);\n@@ -615,7 +615,7 @@ mod test {\n                     \"Op %s failed with 1 stack entry: %s\", *cap, res.unwrap_err());\n         }\n         let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n-        for caps.iter().advance |cap| {\n+        foreach cap in caps.iter() {\n             let res = expand(cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n                     \"Binop %s succeeded incorrectly with 0 stack entries\", *cap);\n@@ -636,7 +636,7 @@ mod test {\n     #[test]\n     fn test_comparison_ops() {\n         let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n-        for v.iter().advance |&(op, bs)| {\n+        foreach &(op, bs) in v.iter() {\n             let s = fmt!(\"%%{1}%%{2}%%%c%%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());"}, {"sha": "a6ed88fa559f1a2629696ad67aa671900efa2ddd", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -272,7 +272,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n             return Err(~\"error: hit EOF before end of string table\");\n         }\n \n-        for string_offsets.iter().enumerate().advance |(i, v)| {\n+        foreach (i, v) in string_offsets.iter().enumerate() {\n             let offset = *v;\n             if offset == 0xFFFF { // non-entry\n                 loop;"}, {"sha": "175cf836c477d5e5540e2f98c514130f9849f068", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -35,7 +35,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n                 dirs_to_search.push(homedir.unwrap().push(\".terminfo\")); // ncurses compatability\n             }\n             match getenv(\"TERMINFO_DIRS\") {\n-                Some(dirs) => for dirs.split_iter(':').advance |i| {\n+                Some(dirs) => foreach i in dirs.split_iter(':') {\n                     if i == \"\" {\n                         dirs_to_search.push(path(\"/usr/share/terminfo\"));\n                     } else {\n@@ -54,7 +54,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n     };\n \n     // Look for the terminal in all of the search directories\n-    for dirs_to_search.iter().advance |p| {\n+    foreach p in dirs_to_search.iter() {\n         let newp = ~p.push_many(&[str::from_char(first_char), term.to_owned()]);\n         if os::path_exists(p) && os::path_exists(newp) {\n             return Some(newp);"}, {"sha": "37d833cc82496adf1075d565ce76b8aba1b7e398", "filename": "src/libextra/test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -430,11 +430,11 @@ impl ConsoleTestState {\n     pub fn write_failures(&self) {\n         self.out.write_line(\"\\nfailures:\");\n         let mut failures = ~[];\n-        for self.failures.iter().advance() |f| {\n+        foreach f in self.failures.iter() {\n             failures.push(f.name.to_str());\n         }\n         sort::tim_sort(failures);\n-        for failures.iter().advance |name| {\n+        foreach name in failures.iter() {\n             self.out.write_line(fmt!(\"    %s\", name.to_str()));\n         }\n     }\n@@ -446,7 +446,7 @@ impl ConsoleTestState {\n         let mut added = 0;\n         let mut removed = 0;\n \n-        for diff.iter().advance() |(k, v)| {\n+        foreach (k, v) in diff.iter() {\n             match *v {\n                 LikelyNoise => noise += 1,\n                 MetricAdded => {\n@@ -566,7 +566,7 @@ pub fn run_tests_console(opts: &TestOpts,\n                     TrIgnored => st.ignored += 1,\n                     TrMetrics(mm) => {\n                         let tname = test.name.to_str();\n-                        for mm.iter().advance() |(k,v)| {\n+                        foreach (k,v) in mm.iter() {\n                             st.metrics.insert_metric(tname + \".\" + *k,\n                                                      v.value, v.noise);\n                         }\n@@ -700,7 +700,7 @@ fn run_tests(opts: &TestOpts,\n \n     // All benchmarks run at the end, in serial.\n     // (this includes metric fns)\n-    for filtered_benchs_and_metrics.consume_iter().advance |b| {\n+    foreach b in filtered_benchs_and_metrics.consume_iter() {\n         callback(TeWait(b.desc.clone()));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n         let (test, result) = p.recv();\n@@ -888,7 +888,7 @@ impl MetricMap {\n     pub fn compare_to_old(&self, old: &MetricMap,\n                           noise_pct: Option<f64>) -> MetricDiff {\n         let mut diff : MetricDiff = TreeMap::new();\n-        for old.iter().advance |(k, vold)| {\n+        foreach (k, vold) in old.iter() {\n             let r = match self.find(k) {\n                 None => MetricRemoved,\n                 Some(v) => {\n@@ -925,7 +925,7 @@ impl MetricMap {\n             };\n             diff.insert((*k).clone(), r);\n         }\n-        for self.iter().advance |(k, _)| {\n+        foreach (k, _) in self.iter() {\n             if !diff.contains_key(k) {\n                 diff.insert((*k).clone(), MetricAdded);\n             }\n@@ -1040,15 +1040,15 @@ impl BenchHarness {\n         loop {\n             let loop_start = precise_time_ns();\n \n-            for samples.mut_iter().advance() |p| {\n+            foreach p in samples.mut_iter() {\n                 self.bench_n(n as u64, |x| f(x));\n                 *p = self.ns_per_iter() as f64;\n             };\n \n             stats::winsorize(samples, 5.0);\n             let summ = stats::Summary::new(samples);\n \n-            for samples.mut_iter().advance() |p| {\n+            foreach p in samples.mut_iter() {\n                 self.bench_n(5 * n as u64, |x| f(x));\n                 *p = self.ns_per_iter() as f64;\n             };\n@@ -1288,7 +1288,7 @@ mod tests {\n         {\n             fn testfn() { }\n             let mut tests = ~[];\n-            for names.iter().advance |name| {\n+            foreach name in names.iter() {\n                 let test = TestDescAndFn {\n                     desc: TestDesc {\n                         name: DynTestName((*name).clone()),\n@@ -1314,7 +1314,7 @@ mod tests {\n \n         let pairs = vec::zip(expected, filtered);\n \n-        for pairs.iter().advance |p| {\n+        foreach p in pairs.iter() {\n             match *p {\n                 (ref a, ref b) => {\n                     assert!(*a == b.desc.name.to_str());"}, {"sha": "6595904a082c786e44818eeead2e4199d2f56c7b", "filename": "src/libextra/time.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -260,7 +260,7 @@ impl Tm {\n priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n         let mut i = pos;\n-        for needle.byte_iter().advance |ch| {\n+        foreach ch in needle.byte_iter() {\n             if s[i] != ch {\n                 return false;\n             }\n@@ -863,9 +863,7 @@ mod tests {\n \n     use std::float;\n     use std::os;\n-    use std::result;\n     use std::result::{Err, Ok};\n-    use std::str;\n \n     fn test_get_time() {\n         static SOME_RECENT_DATE: i64 = 1325376000i64; // 2012-01-01T00:00:00Z\n@@ -1041,7 +1039,7 @@ mod tests {\n             ~\"Friday\",\n             ~\"Saturday\"\n         ];\n-        for days.iter().advance |day| {\n+        foreach day in days.iter() {\n             assert!(test(*day, \"%A\"));\n         }\n \n@@ -1054,7 +1052,7 @@ mod tests {\n             ~\"Fri\",\n             ~\"Sat\"\n         ];\n-        for days.iter().advance |day| {\n+        foreach day in days.iter() {\n             assert!(test(*day, \"%a\"));\n         }\n \n@@ -1072,7 +1070,7 @@ mod tests {\n             ~\"November\",\n             ~\"December\"\n         ];\n-        for months.iter().advance |day| {\n+        foreach day in months.iter() {\n             assert!(test(*day, \"%B\"));\n         }\n \n@@ -1090,7 +1088,7 @@ mod tests {\n             ~\"Nov\",\n             ~\"Dec\"\n         ];\n-        for months.iter().advance |day| {\n+        foreach day in months.iter() {\n             assert!(test(*day, \"%b\"));\n         }\n "}, {"sha": "50ad5c77fbac9f766e3bb9c55e5232333ef03bdd", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -674,7 +674,7 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n     fn heir_swap<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>,\n                                  child: &mut Option<~TreeNode<K, V>>) {\n         // *could* be done without recursion, but it won't borrow check\n-        for child.mut_iter().advance |x| {\n+        foreach x in child.mut_iter() {\n             if x.right.is_some() {\n                 heir_swap(node, &mut x.right);\n             } else {\n@@ -729,18 +729,18 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n                 save.level -= 1;\n \n                 if right_level > save.level {\n-                    for save.right.mut_iter().advance |x| { x.level = save.level }\n+                    foreach x in save.right.mut_iter() { x.level = save.level }\n                 }\n \n                 skew(save);\n \n-                for save.right.mut_iter().advance |right| {\n+                foreach right in save.right.mut_iter() {\n                     skew(right);\n-                    for right.right.mut_iter().advance |x| { skew(x) }\n+                    foreach x in right.right.mut_iter() { skew(x) }\n                 }\n \n                 split(save);\n-                for save.right.mut_iter().advance |x| { split(x) }\n+                foreach x in save.right.mut_iter() { split(x) }\n             }\n \n             return ret;\n@@ -763,7 +763,7 @@ impl<K: TotalOrd, V, T: Iterator<(K, V)>> FromIterator<(K, V), T> for TreeMap<K,\n impl<K: TotalOrd, V, T: Iterator<(K, V)>> Extendable<(K, V), T> for TreeMap<K, V> {\n     #[inline]\n     fn extend(&mut self, iter: &mut T) {\n-        for iter.advance |(k, v)| {\n+        foreach (k, v) in *iter {\n             self.insert(k, v);\n         }\n     }\n@@ -780,7 +780,7 @@ impl<T: TotalOrd, Iter: Iterator<T>> FromIterator<T, Iter> for TreeSet<T> {\n impl<T: TotalOrd, Iter: Iterator<T>> Extendable<T, Iter> for TreeSet<T> {\n     #[inline]\n     fn extend(&mut self, iter: &mut Iter) {\n-        for iter.advance |elem| {\n+        foreach elem in *iter {\n             self.insert(elem);\n         }\n     }\n@@ -863,13 +863,13 @@ mod test_treemap {\n     fn check_equal<K: Eq + TotalOrd, V: Eq>(ctrl: &[(K, V)],\n                                             map: &TreeMap<K, V>) {\n         assert_eq!(ctrl.is_empty(), map.is_empty());\n-        for ctrl.iter().advance |x| {\n+        foreach x in ctrl.iter() {\n             let &(ref k, ref v) = x;\n             assert!(map.find(k).unwrap() == v)\n         }\n-        for map.iter().advance |(map_k, map_v)| {\n+        foreach (map_k, map_v) in map.iter() {\n             let mut found = false;\n-            for ctrl.iter().advance |x| {\n+            foreach x in ctrl.iter() {\n                 let &(ref ctrl_k, ref ctrl_v) = x;\n                 if *map_k == *ctrl_k {\n                     assert!(*map_v == *ctrl_v);\n@@ -983,7 +983,7 @@ mod test_treemap {\n         assert!(m.insert(1, 2));\n \n         let mut n = 0;\n-        for m.iter().advance |(k, v)| {\n+        foreach (k, v) in m.iter() {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n += 1;\n@@ -1090,7 +1090,7 @@ mod test_treemap {\n                         (&x5, &y5)];\n         let mut i = 0;\n \n-        for b.advance |x| {\n+        foreach x in b {\n             assert_eq!(expected[i], x);\n             i += 1;\n \n@@ -1099,7 +1099,7 @@ mod test_treemap {\n             }\n         }\n \n-        for b.advance |x| {\n+        foreach x in b {\n             assert_eq!(expected[i], x);\n             i += 1;\n         }\n@@ -1111,7 +1111,7 @@ mod test_treemap {\n \n         let map: TreeMap<int, int> = xs.iter().transform(|&x| x).collect();\n \n-        for xs.iter().advance |&(k, v)| {\n+        foreach &(k, v) in xs.iter() {\n             assert_eq!(map.find(&k), Some(&v));\n         }\n     }\n@@ -1259,7 +1259,7 @@ mod test_set {\n         assert!(m.insert(1));\n \n         let mut n = 0;\n-        for m.iter().advance |x| {\n+        foreach x in m.iter() {\n             printfln!(x);\n             assert_eq!(*x, n);\n             n += 1\n@@ -1288,8 +1288,8 @@ mod test_set {\n         let mut set_a = TreeSet::new();\n         let mut set_b = TreeSet::new();\n \n-        for a.iter().advance |x| { assert!(set_a.insert(*x)) }\n-        for b.iter().advance |y| { assert!(set_b.insert(*y)) }\n+        foreach x in a.iter() { assert!(set_a.insert(*x)) }\n+        foreach y in b.iter() { assert!(set_b.insert(*y)) }\n \n         let mut i = 0;\n         for f(&set_a, &set_b) |x| {\n@@ -1410,7 +1410,7 @@ mod test_set {\n \n         let set: TreeSet<int> = xs.iter().transform(|&x| x).collect();\n \n-        for xs.iter().advance |x: &int| {\n+        foreach x in xs.iter() {\n             assert!(set.contains(x));\n         }\n     }"}, {"sha": "9b4bf9d0ad4d8ba7e962351275bd2e11e2858240", "filename": "src/libextra/url.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -206,10 +206,10 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n     let mut out = ~\"\";\n     let mut first = true;\n \n-    for m.iter().advance |(key, values)| {\n+    foreach (key, values) in m.iter() {\n         let key = encode_plus(*key);\n \n-        for values.iter().advance |value| {\n+        foreach value in values.iter() {\n             if first {\n                 first = false;\n             } else {\n@@ -331,7 +331,7 @@ fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n     if !rawquery.is_empty() {\n-        for rawquery.split_iter('&').advance |p| {\n+        foreach p in rawquery.split_iter('&') {\n             let (k, v) = split_char_first(p, '=');\n             query.push((decode_component(k), decode_component(v)));\n         };\n@@ -341,7 +341,7 @@ fn query_from_str(rawquery: &str) -> Query {\n \n pub fn query_to_str(query: &Query) -> ~str {\n     let mut strvec = ~[];\n-    for query.iter().advance |kv| {\n+    foreach kv in query.iter() {\n         match kv {\n             &(ref k, ref v) => {\n                 strvec.push(fmt!(\"%s=%s\",\n@@ -356,7 +356,7 @@ pub fn query_to_str(query: &Query) -> ~str {\n \n // returns the scheme and the rest of the url, or a parsing error\n pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n-    for rawurl.iter().enumerate().advance |(i,c)| {\n+    foreach (i,c) in rawurl.iter().enumerate() {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => loop,\n           '0' .. '9' | '+' | '-' | '.' => {\n@@ -418,7 +418,7 @@ fn get_authority(rawurl: &str) ->\n     let mut begin = 2;\n     let mut end = len;\n \n-    for rawurl.iter().enumerate().advance |(i,c)| {\n+    foreach (i,c) in rawurl.iter().enumerate() {\n         if i < 2 { loop; } // ignore the leading //\n \n         // deal with input class first\n@@ -563,7 +563,7 @@ fn get_path(rawurl: &str, authority: bool) ->\n     Result<(~str, ~str), ~str> {\n     let len = rawurl.len();\n     let mut end = len;\n-    for rawurl.iter().enumerate().advance |(i,c)| {\n+    foreach (i,c) in rawurl.iter().enumerate() {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '&' |'\\'' | '(' | ')' | '.'\n           | '@' | ':' | '%' | '/' | '+' | '!' | '*' | ',' | ';' | '='"}, {"sha": "4cfe77273541a2435b6fd61c180b243e9c76abeb", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -287,7 +287,7 @@ impl<'self> Prep<'self> {\n     }\n \n     fn all_fresh(&self, cat: &str, map: &WorkMap) -> bool {\n-        for map.iter().advance |(k, v)| {\n+        foreach (k, v) in map.iter() {\n             if ! self.is_fresh(cat, k.kind, k.name, *v) {\n                 return false;\n             }"}, {"sha": "0d2148c4a12337718cca2f49895112e65bb7e4d4", "filename": "src/librust/rust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrust%2Frust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrust%2Frust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -215,7 +215,7 @@ fn usage() {\n         \\n\"\n     );\n \n-    for COMMANDS.iter().advance |command| {\n+    foreach command in COMMANDS.iter() {\n         let padding = \" \".repeat(INDENT - command.cmd.len());\n         printfln!(\"    %s%s%s\", command.cmd, padding, command.usage_line);\n     }\n@@ -240,7 +240,7 @@ pub fn main() {\n \n     if !args.is_empty() {\n         let r = find_cmd(*args.head());\n-        for r.iter().advance |command| {\n+        foreach command in r.iter() {\n             let result = do_command(command, args.tail());\n             match result {\n                 Valid(exit_code) => unsafe { exit(exit_code.to_i32()) },"}, {"sha": "02cb7f168ce7b34862b40c014ac6ddb2f1c69e38", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -141,7 +141,7 @@ pub mod jit {\n \n             let cstore = sess.cstore;\n             let r = cstore::get_used_crate_files(cstore);\n-            for r.iter().advance |cratepath| {\n+            foreach cratepath in r.iter() {\n                 let path = cratepath.to_str();\n \n                 debug!(\"linking: %s\", path);\n@@ -507,7 +507,7 @@ pub fn build_link_meta(sess: Session,\n         let mut cmh_items = ~[];\n         let linkage_metas = attr::find_linkage_metas(c.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n-        for linkage_metas.iter().advance |meta| {\n+        foreach meta in linkage_metas.iter() {\n             match meta.name_str_pair() {\n                 Some((n, value)) if \"name\" == n => name = Some(value),\n                 Some((n, value)) if \"vers\" == n => vers = Some(value),\n@@ -547,19 +547,19 @@ pub fn build_link_meta(sess: Session,\n               }\n               ast::MetaList(name, ref mis) => {\n                 write_string(symbol_hasher, len_and_str(name));\n-                for mis.iter().advance |m_| {\n+                foreach m_ in mis.iter() {\n                     hash(symbol_hasher, m_);\n                 }\n               }\n             }\n         }\n \n         symbol_hasher.reset();\n-        for cmh_items.iter().advance |m| {\n+        foreach m in cmh_items.iter() {\n             hash(symbol_hasher, m);\n         }\n \n-        for dep_hashes.iter().advance |dh| {\n+        foreach dh in dep_hashes.iter() {\n             write_string(symbol_hasher, len_and_str(*dh));\n         }\n \n@@ -665,7 +665,7 @@ pub fn get_symbol_hash(ccx: &mut CrateContext, t: ty::t) -> @str {\n // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n pub fn sanitize(s: &str) -> ~str {\n     let mut result = ~\"\";\n-    for s.iter().advance |c| {\n+    foreach c in s.iter() {\n         match c {\n             // Escape these with $ sequences\n             '@' => result.push_str(\"$SP$\"),\n@@ -712,7 +712,7 @@ pub fn mangle(sess: Session, ss: path) -> ~str {\n \n     let mut n = ~\"_ZN\"; // Begin name-sequence.\n \n-    for ss.iter().advance |s| {\n+    foreach s in ss.iter() {\n         match *s {\n             path_name(s) | path_mod(s) => {\n                 let sani = sanitize(sess.str_of(s));\n@@ -905,7 +905,7 @@ pub fn link_args(sess: Session,\n \n     let cstore = sess.cstore;\n     let r = cstore::get_used_crate_files(cstore);\n-    for r.iter().advance |cratepath| {\n+    foreach cratepath in r.iter() {\n         if cratepath.filetype() == Some(~\".rlib\") {\n             args.push(cratepath.to_str());\n             loop;\n@@ -917,12 +917,12 @@ pub fn link_args(sess: Session,\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for ula.iter().advance |arg| { args.push(arg.to_owned()); }\n+    foreach arg in ula.iter() { args.push(arg.to_owned()); }\n \n     // Add all the link args for external crates.\n     do cstore::iter_crate_data(cstore) |crate_num, _| {\n         let link_args = csearch::get_link_args_for_crate(cstore, crate_num);\n-        for link_args.consume_iter().advance |link_arg| {\n+        foreach link_arg in link_args.consume_iter() {\n             args.push(link_arg);\n         }\n     }\n@@ -935,13 +935,13 @@ pub fn link_args(sess: Session,\n     // to be found at compile time so it is still entirely up to outside\n     // forces to make sure that library can be found at runtime.\n \n-    for sess.opts.addl_lib_search_paths.iter().advance |path| {\n+    foreach path in sess.opts.addl_lib_search_paths.iter() {\n         args.push(~\"-L\" + path.to_str());\n     }\n \n     // The names of the extern libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n-    for used_libs.iter().advance |l| { args.push(~\"-l\" + *l); }\n+    foreach l in used_libs.iter() { args.push(~\"-l\" + *l); }\n \n     if *sess.building_library {\n         args.push(lib_cmd);"}, {"sha": "831719135b13d9f365ba30966e7061c46ccf6723", "filename": "src/librustc/back/passes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fback%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fback%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fpasses.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -164,7 +164,7 @@ pub fn create_standard_passes(level: OptLevel) -> ~[~str] {\n }\n \n pub fn populate_pass_manager(sess: Session, pm: &mut PassManager, pass_list:&[~str]) {\n-    for pass_list.iter().advance |nm| {\n+    foreach nm in pass_list.iter() {\n         match create_pass(*nm) {\n             Some(p) => pm.add_pass(p),\n             None    => sess.warn(fmt!(\"Unknown pass %s\", *nm))\n@@ -189,15 +189,15 @@ pub fn list_passes() {\n     io::println(\"\\nAvailable Passes:\");\n \n     io::println(\"\\nAnalysis Passes:\");\n-    for analysis_passes.iter().advance |&(name, desc)| {\n+    foreach &(name, desc) in analysis_passes.iter() {\n         printfln!(\"    %-30s -- %s\", name, desc);\n     }\n     io::println(\"\\nTransformation Passes:\");\n-    for transform_passes.iter().advance |&(name, desc)| {\n+    foreach &(name, desc) in transform_passes.iter() {\n         printfln!(\"    %-30s -- %s\", name, desc);\n     }\n     io::println(\"\\nUtility Passes:\");\n-    for utility_passes.iter().advance |&(name, desc)| {\n+    foreach &(name, desc) in utility_passes.iter() {\n         printfln!(\"    %-30s -- %s\", name, desc);\n     }\n }\n@@ -315,23 +315,23 @@ static utility_passes : &'static [(&'static str, &'static str)] = &'static [\n fn passes_exist() {\n     let mut failed = ~[];\n     unsafe { llvm::LLVMInitializePasses(); }\n-    for analysis_passes.iter().advance |&(name,_)| {\n+    foreach &(name,_) in analysis_passes.iter() {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n         } else {\n             unsafe { llvm::LLVMDestroyPass(pass.get()) }\n         }\n     }\n-    for transform_passes.iter().advance |&(name,_)| {\n+    foreach &(name,_) in transform_passes.iter() {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n         } else {\n             unsafe { llvm::LLVMDestroyPass(pass.get()) }\n         }\n     }\n-    for utility_passes.iter().advance |&(name,_)| {\n+    foreach &(name,_) in utility_passes.iter() {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n@@ -342,7 +342,7 @@ fn passes_exist() {\n \n     if failed.len() > 0 {\n         io::println(\"Some passes don't exist:\");\n-        for failed.iter().advance |&n| {\n+        foreach &n in failed.iter() {\n             printfln!(\"    %s\", n);\n         }\n         fail!();"}, {"sha": "0bfbe1a80c5e71f32e72f9702ecc232c4f1a72ef", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -64,7 +64,7 @@ fn get_rpaths(os: session::os,\n     debug!(\"sysroot: %s\", sysroot.to_str());\n     debug!(\"output: %s\", output.to_str());\n     debug!(\"libs:\");\n-    for libs.iter().advance |libpath| {\n+    foreach libpath in libs.iter() {\n         debug!(\"    %s\", libpath.to_str());\n     }\n     debug!(\"target_triple: %s\", target_triple);\n@@ -83,7 +83,7 @@ fn get_rpaths(os: session::os,\n \n     fn log_rpaths(desc: &str, rpaths: &[Path]) {\n         debug!(\"%s rpaths:\", desc);\n-        for rpaths.iter().advance |rpath| {\n+        foreach rpath in rpaths.iter() {\n             debug!(\"    %s\", rpath.to_str());\n         }\n     }\n@@ -183,7 +183,7 @@ pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n     let mut set = HashSet::new();\n     let mut minimized = ~[];\n-    for rpaths.iter().advance |rpath| {\n+    foreach rpath in rpaths.iter() {\n         if set.insert(rpath.to_str()) {\n             minimized.push(rpath.clone());\n         }"}, {"sha": "f4fb65c2a836c52b624ec5ca6e3e7b6279d3c4d3", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -508,7 +508,7 @@ pub fn pretty_print_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n }\n \n pub fn get_os(triple: &str) -> Option<session::os> {\n-    for os_names.iter().advance |&(name, os)| {\n+    foreach &(name, os) in os_names.iter() {\n         if triple.contains(name) { return Some(os) }\n     }\n     None\n@@ -522,7 +522,7 @@ static os_names : &'static [(&'static str, session::os)] = &'static [\n     (\"freebsd\", session::os_freebsd)];\n \n pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n-    for architecture_abis.iter().advance |&(arch, abi)| {\n+    foreach &(arch, abi) in architecture_abis.iter() {\n         if triple.contains(arch) { return Some(abi) }\n     }\n     None\n@@ -611,7 +611,7 @@ pub fn build_session_options(binary: @str,\n                        lint::deny, lint::forbid];\n     let mut lint_opts = ~[];\n     let lint_dict = lint::get_lint_dict();\n-    for lint_levels.iter().advance |level| {\n+    foreach level in lint_levels.iter() {\n         let level_name = lint::level_to_str(*level);\n \n         // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n@@ -620,7 +620,7 @@ pub fn build_session_options(binary: @str,\n         let level_short = level_short.to_ascii().to_upper().to_str_ascii();\n         let flags = vec::append(getopts::opt_strs(matches, level_short),\n                                 getopts::opt_strs(matches, level_name));\n-        for flags.iter().advance |lint_name| {\n+        foreach lint_name in flags.iter() {\n             let lint_name = lint_name.replace(\"-\", \"_\");\n             match lint_dict.find_equiv(&lint_name) {\n               None => {\n@@ -637,9 +637,9 @@ pub fn build_session_options(binary: @str,\n     let mut debugging_opts = 0u;\n     let debug_flags = getopts::opt_strs(matches, \"Z\");\n     let debug_map = session::debugging_opts_map();\n-    for debug_flags.iter().advance |debug_flag| {\n+    foreach debug_flag in debug_flags.iter() {\n         let mut this_bit = 0u;\n-        for debug_map.iter().advance |tuple| {\n+        foreach tuple in debug_map.iter() {\n             let (name, bit) = match *tuple { (ref a, _, b) => (a, b) };\n             if name == debug_flag { this_bit = bit; break; }\n         }"}, {"sha": "2730858d498bbcdf0bd3387e20ee518eba499b52", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -380,7 +380,7 @@ fn is_extra(cx: &TestCtxt) -> bool {\n fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n     debug!(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n-    for cx.testfns.iter().advance |test| {\n+    foreach test in cx.testfns.iter() {\n         descs.push(mk_test_desc_and_fn_rec(cx, test));\n     }\n "}, {"sha": "1ce6f664c27ca283d4ffb82f374d11d8600fdfc9", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -65,7 +65,7 @@ struct cache_entry {\n \n fn dump_crates(crate_cache: &[cache_entry]) {\n     debug!(\"resolved crates:\");\n-    for crate_cache.iter().advance |entry| {\n+    foreach entry in crate_cache.iter() {\n         debug!(\"cnum: %?\", entry.cnum);\n         debug!(\"span: %?\", entry.span);\n         debug!(\"hash: %?\", entry.hash);\n@@ -97,7 +97,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n         if matches.len() != 1u {\n             diag.handler().warn(\n                 fmt!(\"using multiple versions of crate `%s`\", name));\n-            for matches.iter().advance |match_| {\n+            foreach match_ in matches.iter() {\n                 diag.span_note(match_.span, \"used here\");\n                 let attrs = ~[\n                     attr::mk_attr(attr::mk_list_item(@\"link\",\n@@ -125,7 +125,7 @@ struct Env {\n fn visit_crate(e: &Env, c: &ast::Crate) {\n     let cstore = e.cstore;\n \n-    for c.attrs.iter().filter(|m| \"link_args\" == m.name()).advance |a| {\n+    foreach a in c.attrs.iter().filter(|m| \"link_args\" == m.name()) {\n         match a.value_str() {\n           Some(ref linkarg) => {\n             cstore::add_used_link_args(cstore, *linkarg);\n@@ -194,7 +194,7 @@ fn visit_item(e: &Env, i: @ast::item) {\n             ast::anonymous => { /* do nothing */ }\n         }\n \n-        for link_args.iter().advance |m| {\n+        foreach m in link_args.iter() {\n             match m.value_str() {\n                 Some(linkarg) => {\n                     cstore::add_used_link_args(cstore, linkarg);\n@@ -223,7 +223,7 @@ fn metas_with_ident(ident: @str, metas: ~[@ast::MetaItem])\n \n fn existing_match(e: &Env, metas: &[@ast::MetaItem], hash: &str)\n                -> Option<int> {\n-    for e.crate_cache.iter().advance |c| {\n+    foreach c in e.crate_cache.iter() {\n         if loader::metadata_matches(*c.metas, metas)\n             && (hash.is_empty() || c.hash.as_slice() == hash) {\n             return Some(c.cnum);\n@@ -306,7 +306,7 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     // numbers\n     let mut cnum_map = HashMap::new();\n     let r = decoder::get_crate_deps(cdata);\n-    for r.iter().advance |dep| {\n+    foreach dep in r.iter() {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n         let cname_str = token::ident_to_str(&dep.name);"}, {"sha": "b69b2f8067d0c405cd91d23cd0d57884754433ae", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -84,7 +84,7 @@ pub fn have_crate_data(cstore: &CStore, cnum: ast::CrateNum) -> bool {\n \n pub fn iter_crate_data(cstore: &CStore,\n                        i: &fn(ast::CrateNum, @crate_metadata)) {\n-    for cstore.metas.iter().advance |(&k, &v)| {\n+    foreach (&k, &v) in cstore.metas.iter() {\n         i(k, v);\n     }\n }\n@@ -114,7 +114,7 @@ pub fn get_used_libraries<'a>(cstore: &'a CStore) -> &'a [@str] {\n }\n \n pub fn add_used_link_args(cstore: &mut CStore, args: &str) {\n-    for args.split_iter(' ').advance |s| {\n+    foreach s in args.split_iter(' ') {\n         cstore.used_link_args.push(s.to_managed());\n     }\n }\n@@ -165,7 +165,7 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n     };\n \n     debug!(\"sorted:\");\n-    for sorted.iter().advance |x| {\n+    foreach x in sorted.iter() {\n         debug!(\"  hash[%s]: %s\", x.name, x.hash);\n     }\n "}, {"sha": "6086758524814ffae3a5b3aa3f2714d903a9872d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -762,7 +762,7 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n     let mut infos: ~[@ty::VariantInfo] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n     let mut disr_val = 0;\n-    for variant_ids.iter().advance |did| {\n+    foreach did in variant_ids.iter() {\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type(ast::def_id { crate: cdata.cnum, node: id},\n                                 item, tcx, cdata);\n@@ -966,7 +966,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n     }\n \n     let mut static_impl_methods = ~[];\n-    for impl_method_ids.iter().advance |impl_method_id| {\n+    foreach impl_method_id in impl_method_ids.iter() {\n         let impl_method_doc = lookup_item(impl_method_id.node, cdata.data);\n         let family = item_family(impl_method_doc);\n         match family {\n@@ -1155,7 +1155,7 @@ fn list_meta_items(intr: @ident_interner,\n                    meta_items: ebml::Doc,\n                    out: @io::Writer) {\n     let r = get_meta_items(meta_items);\n-    for r.iter().advance |mi| {\n+    foreach mi in r.iter() {\n         out.write_str(fmt!(\"%s\\n\", pprust::meta_item_to_str(*mi, intr)));\n     }\n }\n@@ -1165,7 +1165,7 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n     out.write_str(fmt!(\"=Crate Attributes (%s)=\\n\", hash));\n \n     let r = get_attributes(md);\n-    for r.iter().advance |attr| {\n+    foreach attr in r.iter() {\n         out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(attr, intr)));\n     }\n \n@@ -1207,7 +1207,7 @@ fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n     let r = get_crate_deps(data);\n-    for r.iter().advance |dep| {\n+    foreach dep in r.iter() {\n         out.write_str(\n             fmt!(\"%d %s-%s-%s\\n\",\n                  dep.cnum, token::ident_to_str(&dep.name), dep.hash, dep.vers));"}, {"sha": "9f67d922c11ad422f5efdb41b969fcef238115d8", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -120,7 +120,7 @@ fn encode_region_param(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n-    for opt_rp.iter().advance |rp| {\n+    foreach rp in opt_rp.iter() {\n         ebml_w.start_tag(tag_region_param);\n         rp.encode(ebml_w);\n         ebml_w.end_tag();\n@@ -193,7 +193,7 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n         tcx: ecx.tcx,\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n     };\n-    for params.iter().advance |param| {\n+    foreach param in params.iter() {\n         ebml_w.start_tag(tag);\n         tyencode::enc_type_param_def(ebml_w.writer, ty_str_ctxt, param);\n         ebml_w.end_tag();\n@@ -250,7 +250,7 @@ fn encode_type(ecx: &EncodeContext,\n fn encode_transformed_self_ty(ecx: &EncodeContext,\n                               ebml_w: &mut writer::Encoder,\n                               opt_typ: Option<ty::t>) {\n-    for opt_typ.iter().advance |&typ| {\n+    foreach &typ in opt_typ.iter() {\n         ebml_w.start_tag(tag_item_method_transformed_self_ty);\n         write_type(ecx, ebml_w, typ);\n         ebml_w.end_tag();\n@@ -327,7 +327,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx,\n                                ast::def_id { crate: LOCAL_CRATE, node: id });\n-    for variants.iter().advance |variant| {\n+    foreach variant in variants.iter() {\n         let def_id = local_def(variant.node.id);\n         index.push(entry {val: variant.node.id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n@@ -375,7 +375,7 @@ fn encode_path(ecx: &EncodeContext,\n \n     ebml_w.start_tag(tag_path);\n     ebml_w.wr_tagged_u32(tag_path_len, (path.len() + 1) as u32);\n-    for path.iter().advance |pe| {\n+    foreach pe in path.iter() {\n         encode_path_elt(ecx, ebml_w, *pe);\n     }\n     encode_path_elt(ecx, ebml_w, name);\n@@ -405,8 +405,8 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          -> bool {\n     match ecx.tcx.inherent_impls.find(&exp.def_id) {\n         Some(implementations) => {\n-            for implementations.iter().advance |&base_impl| {\n-                for base_impl.methods.iter().advance |&m| {\n+            foreach &base_impl in implementations.iter() {\n+                foreach &m in base_impl.methods.iter() {\n                     if m.explicit_self == ast::sty_static {\n                         encode_reexported_static_method(ecx, ebml_w, exp,\n                                                         m.def_id, m.ident);\n@@ -426,7 +426,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           -> bool {\n     match ecx.tcx.trait_methods_cache.find(&exp.def_id) {\n         Some(methods) => {\n-            for methods.iter().advance |&m| {\n+            foreach &m in methods.iter() {\n                 if m.explicit_self == ast::sty_static {\n                     encode_reexported_static_method(ecx, ebml_w, exp,\n                                                     m.def_id, m.ident);\n@@ -486,7 +486,7 @@ fn each_auxiliary_node_id(item: @item, callback: &fn(NodeId) -> bool)\n     let mut continue = true;\n     match item.node {\n         item_enum(ref enum_def, _) => {\n-            for enum_def.variants.iter().advance |variant| {\n+            foreach variant in enum_def.variants.iter() {\n                 continue = callback(variant.node.id);\n                 if !continue {\n                     break\n@@ -518,7 +518,7 @@ fn encode_reexports(ecx: &EncodeContext,\n     match ecx.reexports2.find(&id) {\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for %d\", id);\n-            for exports.iter().advance |exp| {\n+            foreach exp in exports.iter() {\n                 debug!(\"(encoding info for module) reexport '%s' for %d\",\n                        exp.name, id);\n                 ebml_w.start_tag(tag_items_data_item_reexport);\n@@ -553,7 +553,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     debug!(\"(encoding info for module) encoding info for module ID %d\", id);\n \n     // Encode info about all the module children.\n-    for md.items.iter().advance |item| {\n+    foreach item in md.items.iter() {\n         ebml_w.start_tag(tag_mod_child);\n         ebml_w.wr_str(def_to_str(local_def(item.id)));\n         ebml_w.end_tag();\n@@ -663,7 +663,7 @@ fn encode_method_sort(ebml_w: &mut writer::Encoder, sort: char) {\n \n fn encode_provided_source(ebml_w: &mut writer::Encoder,\n                           source_opt: Option<def_id>) {\n-    for source_opt.iter().advance |source| {\n+    foreach source in source_opt.iter() {\n         ebml_w.start_tag(tag_item_method_provided_source);\n         let s = def_to_str(*source);\n         ebml_w.writer.write(s.as_bytes());\n@@ -684,7 +684,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n     let tcx = ecx.tcx;\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n-    for fields.iter().advance |field| {\n+    foreach field in fields.iter() {\n         let (nm, vis) = match field.node.kind {\n             named_field(nm, vis) => (nm, vis),\n             unnamed_field => (special_idents::unnamed_field, inherited)\n@@ -771,7 +771,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n \n     encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n \n-    for ast_method_opt.iter().advance |ast_method| {\n+    foreach ast_method in ast_method_opt.iter() {\n         let num_params = tpt.generics.type_param_defs.len();\n         if num_params > 0u || is_default_impl\n             || should_inline(ast_method.attrs) {\n@@ -881,7 +881,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n \n         // Encode all the items in this module.\n-        for fm.items.iter().advance |foreign_item| {\n+        foreach foreign_item in fm.items.iter() {\n             ebml_w.start_tag(tag_mod_child);\n             ebml_w.wr_str(def_to_str(local_def(foreign_item.id)));\n             ebml_w.end_tag();\n@@ -908,7 +908,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(ebml_w, 't');\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n-        for (*enum_definition).variants.iter().advance |v| {\n+        foreach v in (*enum_definition).variants.iter() {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n         (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n@@ -949,7 +949,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        for struct_def.fields.iter().advance |f| {\n+        foreach f in struct_def.fields.iter() {\n             match f.node.kind {\n                 named_field(ident, vis) => {\n                    ebml_w.start_tag(tag_item_field);\n@@ -1009,13 +1009,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             _ => {}\n         }\n-        for imp.methods.iter().advance |method| {\n+        foreach method in imp.methods.iter() {\n             ebml_w.start_tag(tag_item_impl_method);\n             let s = def_to_str(method.def_id);\n             ebml_w.writer.write(s.as_bytes());\n             ebml_w.end_tag();\n         }\n-        for opt_trait.iter().advance |ast_trait_ref| {\n+        foreach ast_trait_ref in opt_trait.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(\n                 tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_trait_ref);\n@@ -1034,7 +1034,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // appear first in the impl structure, in the same order they do\n         // in the ast. This is a little sketchy.\n         let num_implemented_methods = ast_methods.len();\n-        for imp.methods.iter().enumerate().advance |(i, m)| {\n+        foreach (i, m) in imp.methods.iter().enumerate() {\n             let ast_method = if i < num_implemented_methods {\n                 Some(ast_methods[i])\n             } else { None };\n@@ -1062,7 +1062,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n-        for ty::trait_method_def_ids(tcx, def_id).iter().advance |&method_def_id| {\n+        foreach &method_def_id in ty::trait_method_def_ids(tcx, def_id).iter() {\n             ebml_w.start_tag(tag_item_trait_method);\n             encode_def_id(ebml_w, method_def_id);\n             ebml_w.end_tag();\n@@ -1072,15 +1072,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             ebml_w.end_tag();\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        for super_traits.iter().advance |ast_trait_ref| {\n+        foreach ast_trait_ref in super_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_super_trait_ref);\n         }\n         ebml_w.end_tag();\n \n         // Now output the method info for each method.\n         let r = ty::trait_method_def_ids(tcx, def_id);\n-        for r.iter().enumerate().advance |(i, &method_def_id)| {\n+        foreach (i, &method_def_id) in r.iter().enumerate() {\n             assert_eq!(method_def_id.crate, ast::LOCAL_CRATE);\n \n             let method_ty = ty::method(tcx, method_def_id);\n@@ -1257,13 +1257,13 @@ fn create_index<T:Clone + Hash + IterBytes + 'static>(\n                 -> ~[@~[entry<T>]] {\n     let mut buckets: ~[@mut ~[entry<T>]] = ~[];\n     for uint::range(0u, 256u) |_i| { buckets.push(@mut ~[]); };\n-    for index.iter().advance |elt| {\n+    foreach elt in index.iter() {\n         let h = elt.val.hash() as uint;\n         buckets[h % 256].push((*elt).clone());\n     }\n \n     let mut buckets_frozen = ~[];\n-    for buckets.iter().advance |bucket| {\n+    foreach bucket in buckets.iter() {\n         buckets_frozen.push(@/*bad*/(**bucket).clone());\n     }\n     return buckets_frozen;\n@@ -1277,10 +1277,10 @@ fn encode_index<T:'static>(\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs: ~[uint] = ~[];\n     ebml_w.start_tag(tag_index_buckets);\n-    for buckets.iter().advance |bucket| {\n+    foreach bucket in buckets.iter() {\n         bucket_locs.push(ebml_w.writer.tell());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n-        for (**bucket).iter().advance |elt| {\n+        foreach elt in (**bucket).iter() {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             writer.write_be_u32(elt.pos as u32);\n@@ -1291,7 +1291,7 @@ fn encode_index<T:'static>(\n     }\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_index_table);\n-    for bucket_locs.iter().advance |pos| {\n+    foreach pos in bucket_locs.iter() {\n         assert!(*pos < 0xffff_ffff);\n         writer.write_be_u32(*pos as u32);\n     }\n@@ -1337,7 +1337,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n         ebml_w.start_tag(tag_meta_item_name);\n         ebml_w.writer.write(name.as_bytes());\n         ebml_w.end_tag();\n-        for items.iter().advance |inner_item| {\n+        foreach inner_item in items.iter() {\n             encode_meta_item(ebml_w, *inner_item);\n         }\n         ebml_w.end_tag();\n@@ -1347,7 +1347,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n \n fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[Attribute]) {\n     ebml_w.start_tag(tag_attributes);\n-    for attrs.iter().advance |attr| {\n+    foreach attr in attrs.iter() {\n         ebml_w.start_tag(tag_attribute);\n         encode_meta_item(ebml_w, attr.node.value);\n         ebml_w.end_tag();\n@@ -1389,7 +1389,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n \n     let mut attrs = ~[];\n     let mut found_link_attr = false;\n-    for crate.attrs.iter().advance |attr| {\n+    foreach attr in crate.attrs.iter() {\n         attrs.push(\n             if \"link\" != attr.name()  {\n                 *attr\n@@ -1431,7 +1431,7 @@ fn encode_crate_deps(ecx: &EncodeContext,\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n-        for deps.iter().advance |n| {\n+        foreach n in deps.iter() {\n             assert_eq!(n.cnum, expected_cnum);\n             expected_cnum += 1;\n         }\n@@ -1445,7 +1445,7 @@ fn encode_crate_deps(ecx: &EncodeContext,\n     // but is enough to get transitive crate dependencies working.\n     ebml_w.start_tag(tag_crate_deps);\n     let r = get_ordered_deps(ecx, cstore);\n-    for r.iter().advance |dep| {\n+    foreach dep in r.iter() {\n         encode_crate_dep(ecx, ebml_w, *dep);\n     }\n     ebml_w.end_tag();\n@@ -1482,7 +1482,7 @@ fn encode_link_args(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_link_args);\n \n     let link_args = cstore::get_used_link_args(ecx.cstore);\n-    for link_args.iter().advance |link_arg| {\n+    foreach link_arg in link_args.iter() {\n         ebml_w.start_tag(tag_link_args_arg);\n         ebml_w.writer.write_str(link_arg.to_str());\n         ebml_w.end_tag();\n@@ -1496,7 +1496,7 @@ fn encode_misc_info(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_misc_info);\n     ebml_w.start_tag(tag_misc_info_crate_items);\n-    for crate.module.items.iter().advance |&item| {\n+    foreach &item in crate.module.items.iter() {\n         ebml_w.start_tag(tag_mod_child);\n         ebml_w.wr_str(def_to_str(local_def(item.id)));\n         ebml_w.end_tag();\n@@ -1632,7 +1632,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n     ecx.stats.total_bytes = *wr.pos;\n \n     if (tcx.sess.meta_stats()) {\n-        for wr.bytes.iter().advance |e| {\n+        foreach e in wr.bytes.iter() {\n             if *e == 0 {\n                 ecx.stats.zero_bytes += 1;\n             }"}, {"sha": "9891adc3b1b38c6b382c37f08308496fcd670f83", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -91,7 +91,7 @@ pub fn search<T>(filesearch: @FileSearch, pick: pick<T>) -> Option<T> {\n     for filesearch.for_each_lib_search_path() |lib_search_path| {\n         debug!(\"searching %s\", lib_search_path.to_str());\n         let r = os::list_dir_path(lib_search_path);\n-        for r.iter().advance |path| {\n+        foreach path in r.iter() {\n             debug!(\"testing %s\", path.to_str());\n             let maybe_picked = pick(path);\n             if maybe_picked.is_some() {"}, {"sha": "89a53df731695f46b221395b507a23a79303abd7", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -128,7 +128,7 @@ fn find_library_crate_aux(\n             cx.diag.span_err(\n                     cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n                 cx.diag.handler().note(\"candidates:\");\n-                for matches.iter().advance |pair| {\n+                foreach pair in matches.iter() {\n                     let ident = pair.first();\n                     let data = pair.second();\n                     cx.diag.handler().note(fmt!(\"path: %s\", ident));\n@@ -142,7 +142,7 @@ fn find_library_crate_aux(\n }\n \n pub fn crate_name_from_metas(metas: &[@ast::MetaItem]) -> @str {\n-    for metas.iter().advance |m| {\n+    foreach m in metas.iter() {\n         match m.name_str_pair() {\n             Some((name, s)) if \"name\" == name => { return s; }\n             _ => {}\n@@ -155,7 +155,7 @@ pub fn note_linkage_attrs(intr: @ident_interner,\n                           diag: @span_handler,\n                           attrs: ~[ast::Attribute]) {\n     let r = attr::find_linkage_metas(attrs);\n-    for r.iter().advance |mi| {\n+    foreach mi in r.iter() {\n         diag.handler().note(fmt!(\"meta: %s\", pprust::meta_item_to_str(*mi,intr)));\n     }\n }"}, {"sha": "b80af865e43737820b9c4b8011c5d219435e9510", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -123,7 +123,7 @@ fn enc_substs(w: @io::Writer, cx: @ctxt, substs: &ty::substs) {\n     enc_region_substs(w, cx, &substs.regions);\n     do enc_opt(w, substs.self_ty) |t| { enc_ty(w, cx, t) }\n     w.write_char('[');\n-    for substs.tps.iter().advance |t| { enc_ty(w, cx, *t); }\n+    foreach t in substs.tps.iter() { enc_ty(w, cx, *t); }\n     w.write_char(']');\n }\n \n@@ -134,7 +134,7 @@ fn enc_region_substs(w: @io::Writer, cx: @ctxt, substs: &ty::RegionSubsts) {\n         }\n         ty::NonerasedRegions(ref regions) => {\n             w.write_char('n');\n-            for regions.iter().advance |&r| {\n+            foreach &r in regions.iter() {\n                 enc_region(w, cx, r);\n             }\n             w.write_char('.');\n@@ -288,7 +288,7 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: &ty::sty) {\n       }\n       ty::ty_tup(ref ts) => {\n         w.write_str(&\"T[\");\n-        for ts.iter().advance |t| { enc_ty(w, cx, *t); }\n+        foreach t in ts.iter() { enc_ty(w, cx, *t); }\n         w.write_char(']');\n       }\n       ty::ty_box(mt) => { w.write_char('@'); enc_mt(w, cx, mt); }\n@@ -404,7 +404,7 @@ fn enc_closure_ty(w: @io::Writer, cx: @ctxt, ft: &ty::ClosureTy) {\n \n fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n     w.write_char('[');\n-    for fsig.inputs.iter().advance |ty| {\n+    foreach ty in fsig.inputs.iter() {\n         enc_ty(w, cx, *ty);\n     }\n     w.write_char(']');\n@@ -421,7 +421,7 @@ fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: &ty::ParamBounds) {\n         }\n     }\n \n-    for bs.trait_bounds.iter().advance |&tp| {\n+    foreach &tp in bs.trait_bounds.iter() {\n         w.write_char('I');\n         enc_trait_ref(w, cx, tp);\n     }"}, {"sha": "74ef9612500c6b61306e3fdb460a5c12670b940b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -855,7 +855,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = tcx.def_map.find(&id);\n-        for r.iter().advance |def| {\n+        foreach def in r.iter() {\n             do ebml_w.tag(c::tag_table_def) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -867,7 +867,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = tcx.node_types.find(&(id as uint));\n-        for r.iter().advance |&ty| {\n+        foreach &ty in r.iter() {\n             do ebml_w.tag(c::tag_table_node_type) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -879,7 +879,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = tcx.node_type_substs.find(&id);\n-        for r.iter().advance |tys| {\n+        foreach tys in r.iter() {\n             do ebml_w.tag(c::tag_table_node_type_subst) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -891,7 +891,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = tcx.freevars.find(&id);\n-        for r.iter().advance |&fv| {\n+        foreach &fv in r.iter() {\n             do ebml_w.tag(c::tag_table_freevars) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -906,7 +906,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     let lid = ast::def_id { crate: ast::LOCAL_CRATE, node: id };\n     {\n         let r = tcx.tcache.find(&lid);\n-        for r.iter().advance |&tpbt| {\n+        foreach &tpbt in r.iter() {\n             do ebml_w.tag(c::tag_table_tcache) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -918,7 +918,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = tcx.ty_param_defs.find(&id);\n-        for r.iter().advance |&type_param_def| {\n+        foreach &type_param_def in r.iter() {\n             do ebml_w.tag(c::tag_table_param_defs) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -930,7 +930,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = maps.method_map.find(&id);\n-        for r.iter().advance |&mme| {\n+        foreach &mme in r.iter() {\n             do ebml_w.tag(c::tag_table_method_map) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -942,7 +942,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = maps.vtable_map.find(&id);\n-        for r.iter().advance |&dr| {\n+        foreach &dr in r.iter() {\n             do ebml_w.tag(c::tag_table_vtable_map) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -954,7 +954,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = tcx.adjustments.find(&id);\n-        for r.iter().advance |adj| {\n+        foreach adj in r.iter() {\n             do ebml_w.tag(c::tag_table_adjustments) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -966,7 +966,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = maps.capture_map.find(&id);\n-        for r.iter().advance |&cap_vars| {\n+        foreach &cap_vars in r.iter() {\n             do ebml_w.tag(c::tag_table_capture_map) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {"}, {"sha": "b9f9d7c45f5d1da870bf0864b504040de1fb3fcc", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -118,7 +118,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! given `loan_path`\n \n         for self.each_in_scope_loan(scope_id) |loan| {\n-            for loan.restrictions.iter().advance |restr| {\n+            foreach restr in loan.restrictions.iter() {\n                 if restr.loan_path == loan_path {\n                     if !op(loan, restr) {\n                         return false;\n@@ -152,7 +152,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         debug!(\"new_loan_indices = %?\", new_loan_indices);\n \n         for self.each_issued_loan(scope_id) |issued_loan| {\n-            for new_loan_indices.iter().advance |&new_loan_index| {\n+            foreach &new_loan_index in new_loan_indices.iter() {\n                 let new_loan = &self.all_loans[new_loan_index];\n                 self.report_error_if_loans_conflict(issued_loan, new_loan);\n             }\n@@ -210,7 +210,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         };\n         debug!(\"illegal_if=%?\", illegal_if);\n \n-        for loan1.restrictions.iter().advance |restr| {\n+        foreach restr in loan1.restrictions.iter() {\n             if !restr.set.intersects(illegal_if) { loop; }\n             if restr.loan_path != loan2.loan_path { loop; }\n \n@@ -639,7 +639,7 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n                                 closure_id: ast::NodeId,\n                                 span: span) {\n         let cap_vars = this.bccx.capture_map.get(&closure_id);\n-        for cap_vars.iter().advance |cap_var| {\n+        foreach cap_var in cap_vars.iter() {\n             let var_id = ast_util::def_id_of_def(cap_var.def).node;\n             let var_path = @LpVar(var_id);\n             this.check_if_path_is_moved(closure_id, span,\n@@ -700,7 +700,7 @@ fn check_loans_in_expr<'a>(expr: @ast::expr,\n               let cmt = this.bccx.cat_expr_unadjusted(expr);\n               debug!(\"path cmt=%s\", cmt.repr(this.tcx()));\n               let r = opt_loan_path(cmt);\n-              for r.iter().advance |&lp| {\n+              foreach &lp in r.iter() {\n                   this.check_if_path_is_moved(expr.id, expr.span, MovedInUse, lp);\n               }\n           }"}, {"sha": "7c24b30743d21590895e8086612f7aa64f0d9122", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -70,7 +70,7 @@ pub fn gather_captures(bccx: @BorrowckCtxt,\n                        move_data: &mut MoveData,\n                        closure_expr: @ast::expr) {\n     let captured_vars = bccx.capture_map.get(&closure_expr.id);\n-    for captured_vars.iter().advance |captured_var| {\n+    foreach captured_var in captured_vars.iter() {\n         match captured_var.mode {\n             moves::CapMove => {\n                 let fvar_id = ast_util::def_id_of_def(captured_var.def).node;"}, {"sha": "4c4a5648c8b4dc201178fb578f711f6ef3881250", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -187,15 +187,15 @@ fn gather_loans_in_expr(ex: @ast::expr,\n \n     {\n         let r = ex.get_callee_id();\n-        for r.iter().advance |callee_id| {\n+        foreach callee_id in r.iter() {\n             this.id_range.add(*callee_id);\n         }\n     }\n \n     // If this expression is borrowed, have to ensure it remains valid:\n     {\n         let r = tcx.adjustments.find(&ex.id);\n-        for r.iter().advance |&adjustments| {\n+        foreach &adjustments in r.iter() {\n             this.guarantee_adjustments(ex, *adjustments);\n         }\n     }\n@@ -238,8 +238,8 @@ fn gather_loans_in_expr(ex: @ast::expr,\n \n       ast::expr_match(ex_v, ref arms) => {\n         let cmt = this.bccx.cat_expr(ex_v);\n-        for arms.iter().advance |arm| {\n-            for arm.pats.iter().advance |pat| {\n+        foreach arm in arms.iter() {\n+            foreach pat in arm.pats.iter() {\n                 this.gather_pat(cmt, *pat, Some((arm.body.id, ex.id)));\n             }\n         }\n@@ -617,7 +617,7 @@ impl GatherLoanCtxt {\n          */\n \n         let mc_ctxt = self.bccx.mc_ctxt();\n-        for decl.inputs.iter().advance |arg| {\n+        foreach arg in decl.inputs.iter() {\n             let arg_ty = ty::node_id_to_type(self.tcx(), arg.pat.id);\n \n             let arg_cmt = mc_ctxt.cat_rvalue("}, {"sha": "9e4e85c3a5e536edcf034b9da5c1f49b82375b60", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -139,7 +139,7 @@ impl RestrictionsContext {\n                 // static errors. For example, if there is code like\n                 //\n                 //    let v = @mut ~[1, 2, 3];\n-                //    for v.iter().advance |e| {\n+                //    foreach e in v.iter() {\n                 //        v.push(e + 1);\n                 //    }\n                 //\n@@ -151,7 +151,7 @@ impl RestrictionsContext {\n                 //\n                 //    let v = @mut ~[1, 2, 3];\n                 //    let w = v;\n-                //    for v.iter().advance |e| {\n+                //    foreach e in v.iter() {\n                 //        w.push(e + 1);\n                 //    }\n                 //\n@@ -164,7 +164,7 @@ impl RestrictionsContext {\n                 //    }\n                 //    ...\n                 //    let v: &V = ...;\n-                //    for v.get_list().iter().advance |e| {\n+                //    foreach e in v.get_list().iter() {\n                 //        v.get_list().push(e + 1);\n                 //    }\n                 match opt_loan_path(cmt_base) {"}, {"sha": "8ddf1a6c1d8174b78f88997f27c522969ff8153c", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -139,7 +139,7 @@ fn borrowck_fn(fk: &visit::fn_kind,\n                                      LoanDataFlowOperator,\n                                      id_range,\n                                      all_loans.len());\n-            for all_loans.iter().enumerate().advance |(loan_idx, loan)| {\n+            foreach (loan_idx, loan) in all_loans.iter().enumerate() {\n                 loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n                 loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n             }"}, {"sha": "07c8b7ad06c7faba57f92e203afa9f48cb621c8a", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -371,22 +371,22 @@ impl MoveData {\n          * killed by scoping. See `doc.rs` for more details.\n          */\n \n-        for self.moves.iter().enumerate().advance |(i, move)| {\n+        foreach (i, move) in self.moves.iter().enumerate() {\n             dfcx_moves.add_gen(move.id, i);\n         }\n \n-        for self.var_assignments.iter().enumerate().advance |(i, assignment)| {\n+        foreach (i, assignment) in self.var_assignments.iter().enumerate() {\n             dfcx_assign.add_gen(assignment.id, i);\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n-        for self.path_assignments.iter().advance |assignment| {\n+        foreach assignment in self.path_assignments.iter() {\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n         // Kill all moves related to a variable `x` when it goes out\n         // of scope:\n-        for self.paths.iter().advance |path| {\n+        foreach path in self.paths.iter() {\n             match *path.loan_path {\n                 LpVar(id) => {\n                     let kill_id = tcx.region_maps.encl_scope(id);\n@@ -398,7 +398,7 @@ impl MoveData {\n         }\n \n         // Kill all assignments when the variable goes out of scope:\n-        for self.var_assignments.iter().enumerate().advance |(assignment_index, assignment)| {\n+        foreach (assignment_index, assignment) in self.var_assignments.iter().enumerate() {\n             match *self.path(assignment.path).loan_path {\n                 LpVar(id) => {\n                     let kill_id = tcx.region_maps.encl_scope(id);\n@@ -557,7 +557,7 @@ impl FlowedMoveData {\n                 loop;\n             }\n \n-            for opt_loan_path_index.iter().advance |&loan_path_index| {\n+            foreach &loan_path_index in opt_loan_path_index.iter() {\n                 for self.move_data.each_base_path(moved_path) |p| {\n                     if p == loan_path_index {\n                         // Scenario 3: some extension of `loan_path`"}, {"sha": "c1a44cc56da2342b0f1f3df86cb51fa3b6ca1a06", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -53,7 +53,7 @@ pub fn construct(tcx: ty::ctxt,\n impl CFGBuilder {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n-        for blk.stmts.iter().advance |&stmt| {\n+        foreach &stmt in blk.stmts.iter() {\n             stmts_exit = self.stmt(stmt, stmts_exit);\n         }\n \n@@ -151,7 +151,7 @@ impl CFGBuilder {\n             self.pat(pats[0], pred)\n         } else {\n             let collect = self.add_dummy_node([]);\n-            for pats.iter().advance |&pat| {\n+            foreach &pat in pats.iter() {\n                 let pat_exit = self.pat(pat, pred);\n                 self.add_contained_edge(pat_exit, collect);\n             }\n@@ -297,7 +297,7 @@ impl CFGBuilder {\n \n                 let expr_exit = self.add_node(expr.id, []);\n                 let mut guard_exit = discr_exit;\n-                for arms.iter().advance |arm| {\n+                foreach arm in arms.iter() {\n                     guard_exit = self.opt_expr(arm.guard, guard_exit); // 2\n                     let pats_exit = self.pats_any(arm.pats, guard_exit); // 3\n                     let body_exit = self.block(&arm.body, pats_exit);    // 4\n@@ -460,7 +460,7 @@ impl CFGBuilder {\n         assert!(!self.exit_map.contains_key(&id));\n         let node = self.graph.add_node(CFGNodeData {id: id});\n         self.exit_map.insert(id, node);\n-        for preds.iter().advance |&pred| {\n+        foreach &pred in preds.iter() {\n             self.add_contained_edge(pred, node);\n         }\n         node\n@@ -498,7 +498,7 @@ impl CFGBuilder {\n             Some(_) => {\n                 match self.tcx.def_map.find(&expr.id) {\n                     Some(&ast::def_label(loop_id)) => {\n-                        for self.loop_scopes.iter().advance |l| {\n+                        foreach l in self.loop_scopes.iter() {\n                             if l.loop_id == loop_id {\n                                 return *l;\n                             }"}, {"sha": "11d2268725de188c16a8234462f0b8db65dc859f", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -47,8 +47,8 @@ pub fn check_item(sess: Session,\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n       item_enum(ref enum_definition, _) => {\n-        for (*enum_definition).variants.iter().advance |var| {\n-            for var.node.disr_expr.iter().advance |ex| {\n+        foreach var in (*enum_definition).variants.iter() {\n+            foreach ex in var.node.disr_expr.iter() {\n                 (v.visit_expr)(*ex, (true, v));\n             }\n         }"}, {"sha": "e52c0b949dcc7cc58195734e48d9f82b304a56e5", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -55,7 +55,7 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, (s, v): ((), visit::vt<()>)) {\n     match ex.node {\n       expr_match(scrut, ref arms) => {\n         // First, check legality of move bindings.\n-        for arms.iter().advance |arm| {\n+        foreach arm in arms.iter() {\n             check_legality_of_move_bindings(cx,\n                                             arm.guard.is_some(),\n                                             arm.pats);\n@@ -100,8 +100,8 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, (s, v): ((), visit::vt<()>)) {\n // Check for unreachable patterns\n pub fn check_arms(cx: &MatchCheckCtxt, arms: &[arm]) {\n     let mut seen = ~[];\n-    for arms.iter().advance |arm| {\n-        for arm.pats.iter().advance |pat| {\n+    foreach arm in arms.iter() {\n+        foreach pat in arm.pats.iter() {\n \n             // Check that we do not match against a static NaN (#6804)\n             let pat_matches_nan: &fn(@pat) -> bool = |p| {\n@@ -243,7 +243,7 @@ pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n                 }\n               }\n               ty::ty_enum(eid, _) => {\n-                for (*ty::enum_variants(cx.tcx, eid)).iter().advance |va| {\n+                foreach va in (*ty::enum_variants(cx.tcx, eid)).iter() {\n                     match is_useful_specialized(cx, m, v, variant(va.id),\n                                                 va.args.len(), left_ty) {\n                       not_useful => (),\n@@ -365,24 +365,24 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n     match ty::get(left_ty).sty {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) | ty::ty_tup(_) |\n       ty::ty_struct(*) => {\n-        for m.iter().advance |r| {\n+        foreach r in m.iter() {\n             if !is_wild(cx, r[0]) { return None; }\n         }\n         return Some(single);\n       }\n       ty::ty_enum(eid, _) => {\n         let mut found = ~[];\n-        for m.iter().advance |r| {\n+        foreach r in m.iter() {\n             let r = pat_ctor_id(cx, r[0]);\n-            for r.iter().advance |id| {\n+            foreach id in r.iter() {\n                 if !found.contains(id) {\n                     found.push(*id);\n                 }\n             }\n         }\n         let variants = ty::enum_variants(cx.tcx, eid);\n         if found.len() != (*variants).len() {\n-            for (*variants).iter().advance |v| {\n+            foreach v in (*variants).iter() {\n                 if !found.iter().any(|x| x == &(variant(v.id))) {\n                     return Some(variant(v.id));\n                 }\n@@ -394,7 +394,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n       ty::ty_bool => {\n         let mut true_found = false;\n         let mut false_found = false;\n-        for m.iter().advance |r| {\n+        foreach r in m.iter() {\n             match pat_ctor_id(cx, r[0]) {\n               None => (),\n               Some(val(const_bool(true))) => true_found = true,\n@@ -434,7 +434,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n         let mut found_slice = false;\n         let mut next = 0;\n         let mut missing = None;\n-        for sorted_vec_lens.iter().advance |&(length, slice)| {\n+        foreach &(length, slice) in sorted_vec_lens.iter() {\n             if length != next {\n                 missing = Some(next);\n                 break;\n@@ -781,7 +781,7 @@ pub fn check_fn(cx: &MatchCheckCtxt,\n                 (s, v): ((),\n                          visit::vt<()>)) {\n     visit::visit_fn(kind, decl, body, sp, id, (s, v));\n-    for decl.inputs.iter().advance |input| {\n+    foreach input in decl.inputs.iter() {\n         if is_refutable(cx, input.pat) {\n             cx.tcx.sess.span_err(input.pat.span,\n                                  \"refutable pattern in function argument\");\n@@ -834,7 +834,7 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     let def_map = tcx.def_map;\n     let mut by_ref_span = None;\n     let mut any_by_move = false;\n-    for pats.iter().advance |pat| {\n+    foreach pat in pats.iter() {\n         do pat_bindings(def_map, *pat) |bm, id, span, _path| {\n             match bm {\n                 bind_by_ref(_) => {\n@@ -871,7 +871,7 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     };\n \n     if !any_by_move { return; } // pointless micro-optimization\n-    for pats.iter().advance |pat| {\n+    foreach pat in pats.iter() {\n         for walk_pat(*pat) |p| {\n             if pat_is_binding(def_map, p) {\n                 match p.node {"}, {"sha": "957a59cdaa0bfa9dd9f6a334cf41ce210d5eafb7", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -176,7 +176,7 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n                             variant_def: ast::def_id)\n                        -> Option<@expr> {\n     fn variant_expr(variants: &[ast::variant], id: ast::NodeId) -> Option<@expr> {\n-        for variants.iter().advance |variant| {\n+        foreach variant in variants.iter() {\n             if variant.node.id == id {\n                 return variant.node.disr_expr;\n             }"}, {"sha": "44ebca8c1bf365f0748d924f748100339feb4840", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -266,7 +266,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                 f: &fn(uint) -> bool) -> bool {\n         //! Helper for iterating over the bits in a bit set.\n \n-        for words.iter().enumerate().advance |(word_index, &word)| {\n+        foreach (word_index, &word) in words.iter().enumerate() {\n             if word != 0 {\n                 let base_index = word_index * uint::bits;\n                 for uint::range(0, uint::bits) |offset| {\n@@ -391,7 +391,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n         self.merge_with_entry_set(blk.id, in_out);\n \n-        for blk.stmts.iter().advance |&stmt| {\n+        foreach &stmt in blk.stmts.iter() {\n             self.walk_stmt(stmt, in_out, loop_scopes);\n         }\n \n@@ -512,7 +512,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                         loop_kind: ForLoop,\n                         break_bits: reslice(in_out).to_owned()\n                     });\n-                    for decl.inputs.iter().advance |input| {\n+                    foreach input in decl.inputs.iter() {\n                         self.walk_pat(input.pat, func_bits, loop_scopes);\n                     }\n                     self.walk_block(body, func_bits, loop_scopes);\n@@ -631,7 +631,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 // together the bits from each arm:\n                 self.reset(in_out);\n \n-                for arms.iter().advance |arm| {\n+                foreach arm in arms.iter() {\n                     // in_out reflects the discr and all guards to date\n                     self.walk_opt_expr(arm.guard, guards, loop_scopes);\n \n@@ -706,7 +706,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_struct(_, ref fields, with_expr) => {\n-                for fields.iter().advance |field| {\n+                foreach field in fields.iter() {\n                     self.walk_expr(field.expr, in_out, loop_scopes);\n                 }\n                 self.walk_opt_expr(with_expr, in_out, loop_scopes);\n@@ -767,10 +767,10 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_inline_asm(ref inline_asm) => {\n-                for inline_asm.inputs.iter().advance |&(_, expr)| {\n+                foreach &(_, expr) in inline_asm.inputs.iter() {\n                     self.walk_expr(expr, in_out, loop_scopes);\n                 }\n-                for inline_asm.outputs.iter().advance |&(_, expr)| {\n+                foreach &(_, expr) in inline_asm.outputs.iter() {\n                     self.walk_expr(expr, in_out, loop_scopes);\n                 }\n             }\n@@ -838,7 +838,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                   exprs: &[@ast::expr],\n                   in_out: &mut [uint],\n                   loop_scopes: &mut ~[LoopScope]) {\n-        for exprs.iter().advance |&expr| {\n+        foreach &expr in exprs.iter() {\n             self.walk_expr(expr, in_out, loop_scopes);\n         }\n     }\n@@ -847,7 +847,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                      opt_expr: Option<@ast::expr>,\n                      in_out: &mut [uint],\n                      loop_scopes: &mut ~[LoopScope]) {\n-        for opt_expr.iter().advance |&expr| {\n+        foreach &expr in opt_expr.iter() {\n             self.walk_expr(expr, in_out, loop_scopes);\n         }\n     }\n@@ -900,7 +900,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         // alternatives, so we must treat this like an N-way select\n         // statement.\n         let initial_state = reslice(in_out).to_owned();\n-        for pats.iter().advance |&pat| {\n+        foreach &pat in pats.iter() {\n             let mut temp = initial_state.clone();\n             self.walk_pat(pat, temp, loop_scopes);\n             join_bits(&self.dfcx.oper, temp, in_out);\n@@ -948,7 +948,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n     fn reset(&mut self, bits: &mut [uint]) {\n         let e = if self.dfcx.oper.initial_value() {uint::max_value} else {0};\n-        for bits.mut_iter().advance |b| { *b = e; }\n+        foreach b in bits.mut_iter() { *b = e; }\n     }\n \n     fn add_to_entry_set(&mut self, id: ast::NodeId, pred_bits: &[uint]) {\n@@ -996,7 +996,7 @@ fn bits_to_str(words: &[uint]) -> ~str {\n \n     // Note: this is a little endian printout of bytes.\n \n-    for words.iter().advance |&word| {\n+    foreach &word in words.iter() {\n         let mut v = word;\n         for uint::range(0, uint::bytes) |_| {\n             result.push_char(sep);"}, {"sha": "73ead06bf076e9bf4b598a8e54b6077f792dfe5d", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -137,7 +137,7 @@ fn configure_main(ctxt: @mut EntryContext) {\n                                    but you have one or more functions named 'main' that are not \\\n                                    defined at the crate level. Either move the definition or \\\n                                    attach the `#[main]` attribute to override this behavior.\");\n-                for this.non_main_fns.iter().advance |&(_, span)| {\n+                foreach &(_, span) in this.non_main_fns.iter() {\n                     this.session.span_note(span, \"here is a function named 'main'\");\n                 }\n             }"}, {"sha": "afb0254ac1b975d228cccd61f6659e66f17c6af9", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -251,7 +251,7 @@ impl<N,E> Graph<N,E> {\n         while changed {\n             changed = false;\n             iteration += 1;\n-            for self.edges.iter().enumerate().advance |(i, edge)| {\n+            foreach (i, edge) in self.edges.iter().enumerate() {\n                 changed |= op(iteration, EdgeIndex(i), edge);\n             }\n         }"}, {"sha": "a992e9fb0f04148cb337614d73a47fb5ec92aedb", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -237,7 +237,7 @@ fn check_fn(\n     // Check kinds on free variables:\n     do with_appropriate_checker(cx, fn_id) |chk| {\n         let r = freevars::get_freevars(cx.tcx, fn_id);\n-        for r.iter().advance |fv| {\n+        foreach fv in r.iter() {\n             chk(cx, *fv);\n         }\n     }\n@@ -255,7 +255,7 @@ pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n     };\n     {\n         let r = cx.tcx.node_type_substs.find(&type_parameter_id);\n-        for r.iter().advance |ts| {\n+        foreach ts in r.iter() {\n             let type_param_defs = match e.node {\n               expr_path(_) => {\n                 let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&e.id));\n@@ -279,7 +279,7 @@ pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n                       ts.repr(cx.tcx),\n                       type_param_defs.repr(cx.tcx));\n             }\n-            for ts.iter().zip(type_param_defs.iter()).advance |(&ty, type_param_def)| {\n+            foreach (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {\n                 check_typaram_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n             }\n         }\n@@ -317,11 +317,11 @@ fn check_ty(aty: &Ty, (cx, v): (Context, visit::vt<Context>)) {\n     match aty.node {\n       ty_path(_, _, id) => {\n           let r = cx.tcx.node_type_substs.find(&id);\n-          for r.iter().advance |ts| {\n+          foreach ts in r.iter() {\n               let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&id));\n               let type_param_defs =\n                   ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n-              for ts.iter().zip(type_param_defs.iter()).advance |(&ty, type_param_def)| {\n+              foreach (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {\n                   check_typaram_bounds(cx, aty.id, aty.span, ty, type_param_def)\n               }\n           }"}, {"sha": "0c54da66d73835ae3806c8cb841b440ce40a90da", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -412,7 +412,7 @@ impl<'self> LanguageItemCollector<'self> {\n         let this: *mut LanguageItemCollector = &mut *self;\n         visit_crate(self.crate, ((), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n-                for item.attrs.iter().advance |attribute| {\n+                foreach attribute in item.attrs.iter() {\n                     unsafe {\n                         (*this).match_and_collect_meta_item(\n                             local_def(item.id),"}, {"sha": "cb1ceef18ed31ca79991d380d49b54f46720312d", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -284,7 +284,7 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n  */\n pub fn get_lint_dict() -> LintDict {\n     let mut map = HashMap::new();\n-    for lint_table.iter().advance |&(k, v)| {\n+    foreach &(k, v) in lint_table.iter() {\n         map.insert(k, v);\n     }\n     return map;\n@@ -348,7 +348,7 @@ impl Context {\n     }\n \n     fn lint_to_str(&self, lint: lint) -> &'static str {\n-        for self.dict.iter().advance |(k, v)| {\n+        foreach (k, v) in self.dict.iter() {\n             if v.lint == lint {\n                 return *k;\n             }\n@@ -384,7 +384,7 @@ impl Context {\n             allow => fail!(),\n         }\n \n-        for note.iter().advance |&span| {\n+        foreach &span in note.iter() {\n             self.tcx.sess.span_note(span, \"lint level defined here\");\n         }\n     }\n@@ -466,12 +466,12 @@ impl Context {\n         // pair instead of just one visitor.\n         match n {\n             Item(it) => {\n-                for self.visitors.iter().advance |&(orig, stopping)| {\n+                foreach &(orig, stopping) in self.visitors.iter() {\n                     (orig.visit_item)(it, (self, stopping));\n                 }\n             }\n             Crate(c) => {\n-                for self.visitors.iter().advance |&(_, stopping)| {\n+                foreach &(_, stopping) in self.visitors.iter() {\n                     visit::visit_crate(c, (self, stopping));\n                 }\n             }\n@@ -480,7 +480,7 @@ impl Context {\n             // to be a no-op, so manually invoke visit_fn.\n             Method(m) => {\n                 let fk = visit::fk_method(m.ident, &m.generics, m);\n-                for self.visitors.iter().advance |&(orig, stopping)| {\n+                foreach &(orig, stopping) in self.visitors.iter() {\n                     (orig.visit_fn)(&fk, &m.decl, &m.body, m.span, m.id,\n                                     (self, stopping));\n                 }\n@@ -493,9 +493,9 @@ pub fn each_lint(sess: session::Session,\n                  attrs: &[ast::Attribute],\n                  f: &fn(@ast::MetaItem, level, @str) -> bool) -> bool {\n     let xs = [allow, warn, deny, forbid];\n-    for xs.iter().advance |&level| {\n+    foreach &level in xs.iter() {\n         let level_name = level_to_str(level);\n-        for attrs.iter().filter(|m| level_name == m.name()).advance |attr| {\n+        foreach attr in attrs.iter().filter(|m| level_name == m.name()) {\n             let meta = attr.node.value;\n             let metas = match meta.node {\n                 ast::MetaList(_, ref metas) => metas,\n@@ -504,7 +504,7 @@ pub fn each_lint(sess: session::Session,\n                     loop;\n                 }\n             };\n-            for metas.iter().advance |meta| {\n+            foreach meta in metas.iter() {\n                 match meta.node {\n                     ast::MetaWord(lintname) => {\n                         if !f(*meta, level, lintname) {\n@@ -706,15 +706,15 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n     }\n \n     fn check_foreign_fn(cx: &Context, decl: &ast::fn_decl) {\n-        for decl.inputs.iter().advance |input| {\n+        foreach input in decl.inputs.iter() {\n             check_ty(cx, &input.ty);\n         }\n         check_ty(cx, &decl.output)\n     }\n \n     match it.node {\n       ast::item_foreign_mod(ref nmod) if !nmod.abis.is_intrinsic() => {\n-        for nmod.items.iter().advance |ni| {\n+        foreach ni in nmod.items.iter() {\n             match ni.node {\n                 ast::foreign_item_fn(ref decl, _, _) => {\n                     check_foreign_fn(cx, decl);\n@@ -756,7 +756,7 @@ fn check_type_for_lint(cx: &Context, lint: lint, span: span, ty: ty::t) {\n \n fn check_type(cx: &Context, span: span, ty: ty::t) {\n     let xs = [managed_heap_memory, owned_heap_memory, heap_memory];\n-    for xs.iter().advance |lint| {\n+    foreach lint in xs.iter() {\n         check_type_for_lint(cx, *lint, span, ty);\n     }\n }\n@@ -775,7 +775,7 @@ fn check_item_heap(cx: &Context, it: &ast::item) {\n     // If it's a struct, we also have to check the fields' types\n     match it.node {\n         ast::item_struct(struct_def, _) => {\n-            for struct_def.fields.iter().advance |struct_field| {\n+            foreach struct_field in struct_def.fields.iter() {\n                 check_type(cx, struct_field.span,\n                            ty::node_id_to_type(cx.tcx,\n                                                struct_field.node.id));\n@@ -845,7 +845,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n         }\n         ast::item_enum(ref enum_definition, _) => {\n             check_case(cx, \"type\", it.ident, it.span);\n-            for enum_definition.variants.iter().advance |variant| {\n+            foreach variant in enum_definition.variants.iter() {\n                 check_case(cx, \"variant\", variant.node.name, variant.span);\n             }\n         }\n@@ -907,7 +907,7 @@ fn lint_unused_mut() -> visit::vt<@mut Context> {\n     }\n \n     fn visit_fn_decl(cx: &Context, fd: &ast::fn_decl) {\n-        for fd.inputs.iter().advance |arg| {\n+        foreach arg in fd.inputs.iter() {\n             if arg.is_mutbl {\n                 check_pat(cx, arg.pat);\n             }\n@@ -945,7 +945,7 @@ fn lint_session() -> visit::vt<@mut Context> {\n         match cx.tcx.sess.lints.pop(&id) {\n             None => {},\n             Some(l) => {\n-                for l.consume_iter().advance |(lint, span, msg)| {\n+                foreach (lint, span, msg) in l.consume_iter() {\n                     cx.span_lint(lint, span, msg)\n                 }\n             }\n@@ -1042,7 +1042,7 @@ fn lint_missing_doc() -> visit::vt<@mut Context> {\n                 ast::item_struct(sdef, _) if it.vis == ast::public => {\n                     check_attrs(cx, it.attrs, it.span,\n                                 \"missing documentation for a struct\");\n-                    for sdef.fields.iter().advance |field| {\n+                    foreach field in sdef.fields.iter() {\n                         match field.node.kind {\n                             ast::named_field(_, vis) if vis != ast::private => {\n                                 check_attrs(cx, field.node.attrs, field.span,\n@@ -1090,7 +1090,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::Crate) {\n     }\n \n     // Install command-line options, overriding defaults.\n-    for tcx.sess.opts.lint_opts.iter().advance |&(lint, level)| {\n+    foreach &(lint, level) in tcx.sess.opts.lint_opts.iter() {\n         cx.set_level(lint, level, CommandLine);\n     }\n \n@@ -1147,8 +1147,8 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::Crate) {\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n-    for tcx.sess.lints.iter().advance |(_, v)| {\n-        for v.iter().advance |t| {\n+    foreach (_, v) in tcx.sess.lints.iter() {\n+        foreach t in v.iter() {\n             match *t {\n                 (lint, span, ref msg) =>\n                     tcx.sess.span_bug(span, fmt!(\"unprocessed lint %?: %s\","}, {"sha": "a5335d209fa5fd4ec715953a3758ab7bb6c66ba0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -360,7 +360,7 @@ fn visit_fn(fk: &visit::fn_kind,\n         debug!(\"creating fn_maps: %x\", transmute(&*fn_maps));\n     }\n \n-    for decl.inputs.iter().advance |arg| {\n+    foreach arg in decl.inputs.iter() {\n         do pat_util::pat_bindings(this.tcx.def_map, arg.pat)\n                 |_bm, arg_id, _x, path| {\n             debug!(\"adding argument %d\", arg_id);\n@@ -436,7 +436,7 @@ fn visit_local(local: @Local, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n \n fn visit_arm(arm: &arm, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n     let def_map = this.tcx.def_map;\n-    for arm.pats.iter().advance |pat| {\n+    foreach pat in arm.pats.iter() {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n             debug!(\"adding local variable %d from match with bm %?\",\n                    p_id, bm);\n@@ -475,7 +475,7 @@ fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n         // construction site.\n         let cvs = this.capture_map.get(&expr.id);\n         let mut call_caps = ~[];\n-        for cvs.iter().advance |cv| {\n+        foreach cv in cvs.iter() {\n             match moves::moved_variable_node_id_from_def(cv.def) {\n               Some(rv) => {\n                 let cv_ln = this.add_live_node(FreeVarNode(cv.span));\n@@ -1084,7 +1084,7 @@ impl Liveness {\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_empty(ln, succ);\n             let mut first_merge = true;\n-            for arms.iter().advance |arm| {\n+            foreach arm in arms.iter() {\n                 let body_succ =\n                     self.propagate_through_block(&arm.body, succ);\n                 let guard_succ =\n@@ -1461,12 +1461,12 @@ fn check_expr(expr: @expr, (this, vt): (@Liveness, vt<@Liveness>)) {\n       }\n \n       expr_inline_asm(ref ia) => {\n-        for ia.inputs.iter().advance |&(_, input)| {\n+        foreach &(_, input) in ia.inputs.iter() {\n           (vt.visit_expr)(input, (this, vt));\n         }\n \n         // Output operands must be lvalues\n-        for ia.outputs.iter().advance |&(_, out)| {\n+        foreach &(_, out) in ia.outputs.iter() {\n           match out.node {\n             expr_addr_of(_, inner) => {\n               this.check_lvalue(inner, vt);\n@@ -1603,7 +1603,7 @@ impl Liveness {\n     }\n \n     pub fn warn_about_unused_args(&self, decl: &fn_decl, entry_ln: LiveNode) {\n-        for decl.inputs.iter().advance |arg| {\n+        foreach arg in decl.inputs.iter() {\n             do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n                     |_bm, p_id, sp, _n| {\n                 let var = self.variable(p_id, sp);\n@@ -1628,7 +1628,7 @@ impl Liveness {\n                              -> bool {\n         if !self.used_on_entry(ln, var) {\n             let r = self.should_warn(var);\n-            for r.iter().advance |name| {\n+            foreach name in r.iter() {\n \n                 // annoying: for parameters in funcs like `fn(x: int)\n                 // {ret}`, there is only one node, so asking about\n@@ -1661,7 +1661,7 @@ impl Liveness {\n                                   var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n             let r = self.should_warn(var);\n-            for r.iter().advance |name| {\n+            foreach name in r.iter() {\n                 self.tcx.sess.add_lint(dead_assignment, id, sp,\n                     fmt!(\"value assigned to `%s` is never read\", *name));\n             }"}, {"sha": "059f3a05d9c71dfa6d69ff212b37833c08ba8f59", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -907,7 +907,7 @@ impl mem_categorization_ctxt {\n                         }\n                     };\n \n-                    for subpats.iter().enumerate().advance |(i, &subpat)| {\n+                    foreach (i, &subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = self.pat_ty(subpat); // see (*)\n \n                         let subcmt =\n@@ -920,7 +920,7 @@ impl mem_categorization_ctxt {\n                 }\n                 Some(&ast::def_fn(*)) |\n                 Some(&ast::def_struct(*)) => {\n-                    for subpats.iter().enumerate().advance |(i, &subpat)| {\n+                    foreach (i, &subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = self.pat_ty(subpat); // see (*)\n                         let cmt_field =\n                             self.cat_imm_interior(\n@@ -930,7 +930,7 @@ impl mem_categorization_ctxt {\n                     }\n                 }\n                 Some(&ast::def_static(*)) => {\n-                    for subpats.iter().advance |&subpat| {\n+                    foreach &subpat in subpats.iter() {\n                         self.cat_pattern(cmt, subpat, |x,y| op(x,y));\n                     }\n                 }\n@@ -952,7 +952,7 @@ impl mem_categorization_ctxt {\n \n           ast::pat_struct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n-            for field_pats.iter().advance |fp| {\n+            foreach fp in field_pats.iter() {\n                 let field_ty = self.pat_ty(fp.pat); // see (*)\n                 let cmt_field = self.cat_field(pat, cmt, fp.ident, field_ty);\n                 self.cat_pattern(cmt_field, fp.pat, |x,y| op(x,y));\n@@ -961,7 +961,7 @@ impl mem_categorization_ctxt {\n \n           ast::pat_tup(ref subpats) => {\n             // (p1, ..., pN)\n-            for subpats.iter().enumerate().advance |(i, &subpat)| {\n+            foreach (i, &subpat) in subpats.iter().enumerate() {\n                 let subpat_ty = self.pat_ty(subpat); // see (*)\n                 let subcmt =\n                     self.cat_imm_interior(\n@@ -980,15 +980,15 @@ impl mem_categorization_ctxt {\n \n           ast::pat_vec(ref before, slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, cmt, 0);\n-              for before.iter().advance |&before_pat| {\n+              foreach &before_pat in before.iter() {\n                   self.cat_pattern(elt_cmt, before_pat, |x,y| op(x,y));\n               }\n-              for slice.iter().advance |&slice_pat| {\n+              foreach &slice_pat in slice.iter() {\n                   let slice_ty = self.pat_ty(slice_pat);\n                   let slice_cmt = self.cat_rvalue_node(pat, slice_ty);\n                   self.cat_pattern(slice_cmt, slice_pat, |x,y| op(x,y));\n               }\n-              for after.iter().advance |&after_pat| {\n+              foreach &after_pat in after.iter() {\n                   self.cat_pattern(elt_cmt, after_pat, |x,y| op(x,y));\n               }\n           }\n@@ -1077,7 +1077,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n     match ty::get(base_ty).sty {\n       ty::ty_struct(did, _) => {\n         let r = ty::lookup_struct_fields(tcx, did);\n-        for r.iter().advance |fld| {\n+        foreach fld in r.iter() {\n             if fld.ident == f_name {\n                 return Some(ast::m_imm);\n             }\n@@ -1087,7 +1087,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n         match tcx.def_map.get_copy(&node_id) {\n           ast::def_variant(_, variant_id) => {\n             let r = ty::lookup_struct_fields(tcx, variant_id);\n-            for r.iter().advance |fld| {\n+            foreach fld in r.iter() {\n                 if fld.ident == f_name {\n                     return Some(ast::m_imm);\n                 }"}, {"sha": "a31003d8a16cb304700d028d629b689d6e3a042f", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -231,7 +231,7 @@ fn compute_modes_for_local<'a>(local: @Local,\n                                (cx, v): (VisitContext,\n                                          vt<VisitContext>)) {\n     cx.use_pat(local.pat);\n-    for local.init.iter().advance |&init| {\n+    foreach &init in local.init.iter() {\n         cx.use_expr(init, Read, v);\n     }\n }\n@@ -243,7 +243,7 @@ fn compute_modes_for_fn(fk: &visit::fn_kind,\n                         id: NodeId,\n                         (cx, v): (VisitContext,\n                                   vt<VisitContext>)) {\n-    for decl.inputs.iter().advance |a| {\n+    foreach a in decl.inputs.iter() {\n         cx.use_pat(a.pat);\n     }\n     visit::visit_fn(fk, decl, body, span, id, (cx, v));\n@@ -258,7 +258,7 @@ fn compute_modes_for_expr(expr: @expr,\n \n impl VisitContext {\n     pub fn consume_exprs(&self, exprs: &[@expr], visitor: vt<VisitContext>) {\n-        for exprs.iter().advance |expr| {\n+        foreach expr in exprs.iter() {\n             self.consume_expr(*expr, visitor);\n         }\n     }\n@@ -289,11 +289,11 @@ impl VisitContext {\n \n         debug!(\"consume_block(blk.id=%?)\", blk.id);\n \n-        for blk.stmts.iter().advance |stmt| {\n+        foreach stmt in blk.stmts.iter() {\n             (visitor.visit_stmt)(*stmt, (*self, visitor));\n         }\n \n-        for blk.expr.iter().advance |tail_expr| {\n+        foreach tail_expr in blk.expr.iter() {\n             self.consume_expr(*tail_expr, visitor);\n         }\n     }\n@@ -329,7 +329,7 @@ impl VisitContext {\n                     Move => {\n                         let def = self.tcx.def_map.get_copy(&expr.id);\n                         let r = moved_variable_node_id_from_def(def);\n-                        for r.iter().advance |&id| {\n+                        foreach &id in r.iter() {\n                             self.move_maps.moved_variables_set.insert(id);\n                         }\n                     }\n@@ -393,11 +393,11 @@ impl VisitContext {\n             }\n \n             expr_struct(_, ref fields, opt_with) => {\n-                for fields.iter().advance |field| {\n+                foreach field in fields.iter() {\n                     self.consume_expr(field.expr, visitor);\n                 }\n \n-                for opt_with.iter().advance |with_expr| {\n+                foreach with_expr in opt_with.iter() {\n                     // If there are any fields whose type is move-by-default,\n                     // then `with` is consumed, otherwise it is only read\n                     let with_ty = ty::expr_ty(self.tcx, *with_expr);\n@@ -436,15 +436,15 @@ impl VisitContext {\n             expr_if(cond_expr, ref then_blk, opt_else_expr) => {\n                 self.consume_expr(cond_expr, visitor);\n                 self.consume_block(then_blk, visitor);\n-                for opt_else_expr.iter().advance |else_expr| {\n+                foreach else_expr in opt_else_expr.iter() {\n                     self.consume_expr(*else_expr, visitor);\n                 }\n             }\n \n             expr_match(discr, ref arms) => {\n                 // We must do this first so that `arms_have_by_move_bindings`\n                 // below knows which bindings are moves.\n-                for arms.iter().advance |arm| {\n+                foreach arm in arms.iter() {\n                     self.consume_arm(arm, visitor);\n                 }\n \n@@ -511,7 +511,7 @@ impl VisitContext {\n             }\n \n             expr_ret(ref opt_expr) => {\n-                for opt_expr.iter().advance |expr| {\n+                foreach expr in opt_expr.iter() {\n                     self.consume_expr(*expr, visitor);\n                 }\n             }\n@@ -547,7 +547,7 @@ impl VisitContext {\n             }\n \n             expr_fn_block(ref decl, ref body) => {\n-                for decl.inputs.iter().advance |a| {\n+                foreach a in decl.inputs.iter() {\n                     self.use_pat(a.pat);\n                 }\n                 let cap_vars = self.compute_captures(expr.id);\n@@ -581,19 +581,19 @@ impl VisitContext {\n \n         // for overloaded operatrs, we are always passing in a\n         // borrowed pointer, so it's always read mode:\n-        for arg_exprs.iter().advance |arg_expr| {\n+        foreach arg_expr in arg_exprs.iter() {\n             self.use_expr(*arg_expr, Read, visitor);\n         }\n \n         return true;\n     }\n \n     pub fn consume_arm(&self, arm: &arm, visitor: vt<VisitContext>) {\n-        for arm.pats.iter().advance |pat| {\n+        foreach pat in arm.pats.iter() {\n             self.use_pat(*pat);\n         }\n \n-        for arm.guard.iter().advance |guard| {\n+        foreach guard in arm.guard.iter() {\n             self.consume_expr(*guard, visitor);\n         }\n \n@@ -640,7 +640,7 @@ impl VisitContext {\n                        arg_exprs: &[@expr],\n                        visitor: vt<VisitContext>) {\n         //! Uses the argument expressions.\n-        for arg_exprs.iter().advance |arg_expr| {\n+        foreach arg_expr in arg_exprs.iter() {\n             self.use_fn_arg(*arg_expr, visitor);\n         }\n     }\n@@ -654,8 +654,8 @@ impl VisitContext {\n                                       moves_map: MovesMap,\n                                       arms: &[arm])\n                                       -> Option<@pat> {\n-        for arms.iter().advance |arm| {\n-            for arm.pats.iter().advance |&pat| {\n+        foreach arm in arms.iter() {\n+            foreach &pat in arm.pats.iter() {\n                 for ast_util::walk_pat(pat) |p| {\n                     if moves_map.contains(&p.id) {\n                         return Some(p);"}, {"sha": "d5855dac177b90ebaf79286579ee3e96aa41562b", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -50,15 +50,15 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 *count += 1;\n             }\n             item_impl(_, _, _, ref methods) => {\n-                for methods.iter().advance |method| {\n+                foreach method in methods.iter() {\n                     privileged_items.push(method.id);\n                     *count += 1;\n                 }\n                 privileged_items.push(item.id);\n                 *count += 1;\n             }\n             item_foreign_mod(ref foreign_mod) => {\n-                for foreign_mod.items.iter().advance |foreign_item| {\n+                foreach foreign_item in foreign_mod.items.iter() {\n                     privileged_items.push(foreign_item.id);\n                     *count += 1;\n                 }\n@@ -70,7 +70,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n     // Adds items that are privileged to this scope.\n     let add_privileged_items: @fn(&[@ast::item]) -> uint = |items| {\n         let mut count = 0;\n-        for items.iter().advance |&item| {\n+        foreach &item in items.iter() {\n             add_privileged_item(item, &mut count);\n         }\n         count\n@@ -206,7 +206,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n     let check_field: @fn(span: span, id: ast::def_id, ident: ast::ident) =\n             |span, id, ident| {\n         let fields = ty::lookup_struct_fields(tcx, id);\n-        for fields.iter().advance |field| {\n+        foreach field in fields.iter() {\n             if field.ident != ident { loop; }\n             if field.vis == private {\n                 tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n@@ -354,7 +354,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n         visit_block: |block, (method_map, visitor)| {\n             // Gather up all the privileged items.\n             let mut n_added = 0;\n-            for block.stmts.iter().advance |stmt| {\n+            foreach stmt in block.stmts.iter() {\n                 match stmt.node {\n                     stmt_decl(decl, _) => {\n                         match decl.node {\n@@ -425,7 +425,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         ty_struct(id, _) => {\n                             if id.crate != LOCAL_CRATE ||\n                                     !privileged_items.iter().any(|x| x == &(id.node)) {\n-                                for (*fields).iter().advance |field| {\n+                                foreach field in (*fields).iter() {\n                                         debug!(\"(privacy checking) checking \\\n                                                 field in struct literal\");\n                                     check_field(expr.span, id, field.ident);\n@@ -437,7 +437,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                     !privileged_items.iter().any(|x| x == &(id.node)) {\n                                 match tcx.def_map.get_copy(&expr.id) {\n                                     def_variant(_, variant_id) => {\n-                                        for (*fields).iter().advance |field| {\n+                                        foreach field in (*fields).iter() {\n                                                 debug!(\"(privacy checking) \\\n                                                         checking field in \\\n                                                         struct variant \\\n@@ -489,7 +489,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         ty_struct(id, _) => {\n                             if id.crate != LOCAL_CRATE ||\n                                     !privileged_items.iter().any(|x| x == &(id.node)) {\n-                                for fields.iter().advance |field| {\n+                                foreach field in fields.iter() {\n                                         debug!(\"(privacy checking) checking \\\n                                                 struct pattern\");\n                                     check_field(pattern.span, id, field.ident);\n@@ -501,7 +501,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                     !privileged_items.iter().any(|x| x == &enum_id.node) {\n                                 match tcx.def_map.find(&pattern.id) {\n                                     Some(&def_variant(_, variant_id)) => {\n-                                        for fields.iter().advance |field| {\n+                                        foreach field in fields.iter() {\n                                             debug!(\"(privacy checking) \\\n                                                     checking field in \\\n                                                     struct variant pattern\");"}, {"sha": "681fc0316cafadfb8e1bf64b3d6b6c51d3c97b81", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -136,7 +136,7 @@ impl ReachableContext {\n                     }\n                     item_enum(ref enum_def, _) => {\n                         if privacy_context == PublicContext {\n-                            for enum_def.variants.iter().advance |variant| {\n+                            foreach variant in enum_def.variants.iter() {\n                                 reachable_symbols.insert(variant.node.id);\n                             }\n                         }\n@@ -155,7 +155,7 @@ impl ReachableContext {\n                         };\n \n                         // Mark all public methods as reachable.\n-                        for methods.iter().advance |&method| {\n+                        foreach &method in methods.iter() {\n                             if should_be_considered_public(method) {\n                                 reachable_symbols.insert(method.id);\n                             }\n@@ -164,15 +164,15 @@ impl ReachableContext {\n                         if generics_require_inlining(generics) {\n                             // If the impl itself has generics, add all public\n                             // symbols to the worklist.\n-                            for methods.iter().advance |&method| {\n+                            foreach &method in methods.iter() {\n                                 if should_be_considered_public(method) {\n                                     worklist.push(method.id)\n                                 }\n                             }\n                         } else {\n                             // Otherwise, add only public methods that have\n                             // generics to the worklist.\n-                            for methods.iter().advance |method| {\n+                            foreach method in methods.iter() {\n                                 let generics = &method.generics;\n                                 let attrs = &method.attrs;\n                                 if generics_require_inlining(generics) ||\n@@ -186,7 +186,7 @@ impl ReachableContext {\n                     item_trait(_, _, ref trait_methods) => {\n                         // Mark all provided methods as reachable.\n                         if privacy_context == PublicContext {\n-                            for trait_methods.iter().advance |trait_method| {\n+                            foreach trait_method in trait_methods.iter() {\n                                 match *trait_method {\n                                     provided(method) => {\n                                         reachable_symbols.insert(method.id);"}, {"sha": "0a50a88a6ed40dec449c7b9c15d8119b722c4f2c", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -198,7 +198,7 @@ impl RegionMaps {\n         while i < queue.len() {\n             match self.free_region_map.find(&queue[i]) {\n                 Some(parents) => {\n-                    for parents.iter().advance |parent| {\n+                    foreach parent in parents.iter() {\n                         if *parent == sup {\n                             return true;\n                         }\n@@ -318,7 +318,7 @@ impl RegionMaps {\n fn parent_to_expr(cx: Context, child_id: ast::NodeId, sp: span) {\n     debug!(\"region::parent_to_expr(span=%?)\",\n            cx.sess.codemap.span_to_str(sp));\n-    for cx.parent.iter().advance |parent_id| {\n+    foreach parent_id in cx.parent.iter() {\n         cx.region_maps.record_parent(child_id, *parent_id);\n     }\n }\n@@ -713,7 +713,7 @@ fn determine_rp_in_fn(fk: &visit::fn_kind,\n                                       visit::vt<@mut DetermineRpCtxt>)) {\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n-            for decl.inputs.iter().advance |a| {\n+            foreach a in decl.inputs.iter() {\n                 (visitor.visit_ty)(&a.ty, (cx, visitor));\n             }\n         }\n@@ -824,7 +824,7 @@ fn determine_rp_in_ty(ty: &ast::Ty,\n       ast::ty_path(ref path, _, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n-            for path.types.iter().advance |tp| {\n+            foreach tp in path.types.iter() {\n                 (visitor.visit_ty)(tp, (cx, visitor));\n             }\n         }\n@@ -837,7 +837,7 @@ fn determine_rp_in_ty(ty: &ast::Ty,\n         do cx.with(cx.item_id, false) {\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n-                for decl.inputs.iter().advance |a| {\n+                foreach a in decl.inputs.iter() {\n                     (visitor.visit_ty)(&a.ty, (cx, visitor));\n                 }\n             }\n@@ -917,7 +917,7 @@ pub fn determine_rp_in_crate(sess: Session,\n             match cx.dep_map.find(&c_id) {\n               None => {}\n               Some(deps) => {\n-                for deps.iter().advance |dep| {\n+                foreach dep in deps.iter() {\n                     let v = add_variance(dep.ambient_variance, c_variance);\n                     cx.add_rp(dep.id, v);\n                 }\n@@ -929,7 +929,7 @@ pub fn determine_rp_in_crate(sess: Session,\n     debug!(\"%s\", {\n         debug!(\"Region variance results:\");\n         let region_paramd_items = cx.region_paramd_items;\n-        for region_paramd_items.iter().advance |(&key, &value)| {\n+        foreach (&key, &value) in region_paramd_items.iter() {\n             debug!(\"item %? (%s) is parameterized with variance %?\",\n                    key,\n                    ast_map::node_id_to_str(ast_map, key,"}, {"sha": "b92960a49fac0075cf8172283277c3f0ee8b3bfe", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -1037,7 +1037,7 @@ impl Resolver {\n                              self.session.str_of(name)));\n                     {\n                         let r = child.span_for_namespace(ns);\n-                        for r.iter().advance |sp| {\n+                        foreach sp in r.iter() {\n                             self.session.span_note(*sp,\n                                  fmt!(\"first definition of %s `%s` here\",\n                                       namespace_error_to_str(duplicate_type),\n@@ -1057,7 +1057,7 @@ impl Resolver {\n         }\n \n         // Check each statement.\n-        for block.stmts.iter().advance |statement| {\n+        foreach statement in block.stmts.iter() {\n             match statement.node {\n                 stmt_decl(declaration, _) => {\n                     match declaration.node {\n@@ -1179,7 +1179,7 @@ impl Resolver {\n                 name_bindings.define_type\n                     (privacy, def_ty(local_def(item.id)), sp);\n \n-                for (*enum_definition).variants.iter().advance |variant| {\n+                foreach variant in (*enum_definition).variants.iter() {\n                     self.build_reduced_graph_for_variant(\n                         variant,\n                         local_def(item.id),\n@@ -1264,7 +1264,7 @@ impl Resolver {\n                         };\n \n                         // For each method...\n-                        for methods.iter().advance |method| {\n+                        foreach method in methods.iter() {\n                             // Add the method to the module.\n                             let ident = method.ident;\n                             let (method_name_bindings, _) =\n@@ -1316,7 +1316,7 @@ impl Resolver {\n \n                 // Add the names of all the methods to the trait info.\n                 let mut method_names = HashMap::new();\n-                for methods.iter().advance |method| {\n+                foreach method in methods.iter() {\n                     let ty_m = trait_method_to_ty_method(method);\n \n                     let ident = ty_m.ident;\n@@ -1353,7 +1353,7 @@ impl Resolver {\n                 }\n \n                 let def_id = local_def(item.id);\n-                for method_names.iter().advance |(name, _)| {\n+                foreach (name, _) in method_names.iter() {\n                     if !self.method_map.contains_key(name) {\n                         self.method_map.insert(*name, HashSet::new());\n                     }\n@@ -1422,7 +1422,7 @@ impl Resolver {\n         let privacy = visibility_to_privacy(view_item.vis);\n         match view_item.node {\n             view_item_use(ref view_paths) => {\n-                for view_paths.iter().advance |view_path| {\n+                foreach view_path in view_paths.iter() {\n                     // Extract and intern the module part of the path. For\n                     // globs and lists, the path is found directly in the AST;\n                     // for simple paths we have to munge the path a little.\n@@ -1433,7 +1433,7 @@ impl Resolver {\n                             let path_len = full_path.idents.len();\n                             assert!(path_len != 0);\n \n-                            for full_path.idents.iter().enumerate().advance |(i, ident)| {\n+                            foreach (i, ident) in full_path.idents.iter().enumerate() {\n                                 if i != path_len - 1 {\n                                     module_path.push(*ident);\n                                 }\n@@ -1442,7 +1442,7 @@ impl Resolver {\n \n                         view_path_glob(ref module_ident_path, _) |\n                         view_path_list(ref module_ident_path, _, _) => {\n-                            for module_ident_path.idents.iter().advance |ident| {\n+                            foreach ident in module_ident_path.idents.iter() {\n                                 module_path.push(*ident);\n                             }\n                         }\n@@ -1463,7 +1463,7 @@ impl Resolver {\n                                                         id);\n                         }\n                         view_path_list(_, ref source_idents, _) => {\n-                            for source_idents.iter().advance |source_ident| {\n+                            foreach source_ident in source_idents.iter() {\n                                 let name = source_ident.node.name;\n                                 let subclass = @SingleImport(name, name);\n                                 self.build_import_directive(\n@@ -1657,7 +1657,7 @@ impl Resolver {\n               let method_def_ids =\n                 get_trait_method_def_ids(self.session.cstore, def_id);\n               let mut interned_method_names = HashSet::new();\n-              for method_def_ids.iter().advance |&method_def_id| {\n+              foreach &method_def_id in method_def_ids.iter() {\n                   let (method_name, explicit_self) =\n                       get_method_name_and_explicit_self(self.session.cstore,\n                                                         method_def_id);\n@@ -1672,7 +1672,7 @@ impl Resolver {\n                       interned_method_names.insert(method_name);\n                   }\n               }\n-              for interned_method_names.iter().advance |name| {\n+              foreach name in interned_method_names.iter() {\n                   if !self.method_map.contains_key(name) {\n                       self.method_map.insert(*name, HashSet::new());\n                   }\n@@ -1741,7 +1741,7 @@ impl Resolver {\n             // need to.\n \n             let mut current_module = root;\n-            for pieces.iter().advance |ident_str| {\n+            foreach ident_str in pieces.iter() {\n                 let ident = self.session.ident_of(*ident_str);\n                 // Create or reuse a graph node for the child.\n                 let (child_name_bindings, new_parent) =\n@@ -1861,7 +1861,7 @@ impl Resolver {\n                                     // Add each static method to the module.\n                                     let new_parent = ModuleReducedGraphParent(\n                                         type_module);\n-                                    for static_methods.iter().advance |static_method_info| {\n+                                    foreach static_method_info in static_methods.iter() {\n                                         let ident = static_method_info.ident;\n                                         debug!(\"(building reduced graph for \\\n                                                  external crate) creating \\\n@@ -2047,7 +2047,7 @@ impl Resolver {\n     pub fn idents_to_str(@mut self, idents: &[ident]) -> ~str {\n         let mut first = true;\n         let mut result = ~\"\";\n-        for idents.iter().advance |ident| {\n+        foreach ident in idents.iter() {\n             if first {\n                 first = false\n             } else {\n@@ -2531,7 +2531,7 @@ impl Resolver {\n         };\n \n         // Add all children from the containing module.\n-        for containing_module.children.iter().advance |(&ident, name_bindings)| {\n+        foreach (&ident, name_bindings) in containing_module.children.iter() {\n             merge_import_resolution(ident, *name_bindings);\n         }\n \n@@ -3237,7 +3237,7 @@ impl Resolver {\n                 loop;\n             }\n             let xs = [TypeNS, ValueNS];\n-            for xs.iter().advance |ns| {\n+            foreach ns in xs.iter() {\n                 match importresolution.target_for_namespace(*ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe reexport '%s'\",\n@@ -3485,8 +3485,8 @@ impl Resolver {\n             // enum item: resolve all the variants' discrs,\n             // then resolve the ty params\n             item_enum(ref enum_def, ref generics) => {\n-                for (*enum_def).variants.iter().advance |variant| {\n-                    for variant.node.disr_expr.iter().advance |dis_expr| {\n+                foreach variant in (*enum_def).variants.iter() {\n+                    foreach dis_expr in variant.node.disr_expr.iter() {\n                         // resolve the discriminator expr\n                         // as a constant\n                         self.with_constant_rib(|| {\n@@ -3543,11 +3543,11 @@ impl Resolver {\n                                                  visitor);\n \n                     // Resolve derived traits.\n-                    for traits.iter().advance |trt| {\n+                    foreach trt in traits.iter() {\n                         self.resolve_trait_reference(item.id, trt, visitor, TraitDerivation);\n                     }\n \n-                    for (*methods).iter().advance |method| {\n+                    foreach method in (*methods).iter() {\n                         // Create a new rib for the method-specific type\n                         // parameters.\n                         //\n@@ -3567,7 +3567,7 @@ impl Resolver {\n                                     &ty_m.generics.ty_params,\n                                     visitor);\n \n-                                for ty_m.decl.inputs.iter().advance |argument| {\n+                                foreach argument in ty_m.decl.inputs.iter() {\n                                     self.resolve_type(&argument.ty, visitor);\n                                 }\n \n@@ -3604,7 +3604,7 @@ impl Resolver {\n \n             item_foreign_mod(ref foreign_module) => {\n                 do self.with_scope(Some(item.ident)) {\n-                    for foreign_module.items.iter().advance |foreign_item| {\n+                    foreach foreign_item in foreign_module.items.iter() {\n                         match foreign_item.node {\n                             foreign_item_fn(_, _, ref generics) => {\n                                 self.with_type_parameter_rib(\n@@ -3660,7 +3660,7 @@ impl Resolver {\n                 let function_type_rib = @Rib(rib_kind);\n                 self.type_ribs.push(function_type_rib);\n \n-                for generics.ty_params.iter().enumerate().advance |(index, type_parameter)| {\n+                foreach (index, type_parameter) in generics.ty_params.iter().enumerate() {\n                     let name = type_parameter.ident;\n                     debug!(\"with_type_parameter_rib: %d %d\", node_id,\n                            type_parameter.id);\n@@ -3751,7 +3751,7 @@ impl Resolver {\n                     // Nothing to do.\n                 }\n                 Some(declaration) => {\n-                    for declaration.inputs.iter().advance |argument| {\n+                    foreach argument in declaration.inputs.iter() {\n                         let binding_mode = ArgumentIrrefutableMode;\n                         let mutability =\n                             if argument.is_mutbl {Mutable} else {Immutable};\n@@ -3783,8 +3783,8 @@ impl Resolver {\n     pub fn resolve_type_parameters(@mut self,\n                                    type_parameters: &OptVec<TyParam>,\n                                    visitor: ResolveVisitor) {\n-        for type_parameters.iter().advance |type_parameter| {\n-            for type_parameter.bounds.iter().advance |bound| {\n+        foreach type_parameter in type_parameters.iter() {\n+            foreach bound in type_parameter.bounds.iter() {\n                 self.resolve_type_parameter_bound(type_parameter.id, bound, visitor);\n             }\n         }\n@@ -3833,7 +3833,7 @@ impl Resolver {\n                           fields: &[@struct_field],\n                           visitor: ResolveVisitor) {\n         let mut ident_map = HashMap::new::<ast::ident, @struct_field>();\n-        for fields.iter().advance |&field| {\n+        foreach &field in fields.iter() {\n             match field.node.kind {\n                 named_field(ident, _) => {\n                     match ident_map.find(&ident) {\n@@ -3862,7 +3862,7 @@ impl Resolver {\n             self.resolve_type_parameters(&generics.ty_params, visitor);\n \n             // Resolve fields.\n-            for fields.iter().advance |field| {\n+            foreach field in fields.iter() {\n                 self.resolve_type(&field.node.ty, visitor);\n             }\n         }\n@@ -3922,7 +3922,7 @@ impl Resolver {\n                     let mut new_trait_refs = ~[];\n                     {\n                         let r = self.def_map.find(&trait_reference.ref_id);\n-                        for r.iter().advance |&def| {\n+                        foreach &def in r.iter() {\n                             new_trait_refs.push(def_id_of_def(*def));\n                         }\n                     }\n@@ -3938,7 +3938,7 @@ impl Resolver {\n             // Resolve the self type.\n             self.resolve_type(self_type, visitor);\n \n-            for methods.iter().advance |method| {\n+            foreach method in methods.iter() {\n                 // We also need a new scope for the method-specific\n                 // type parameters.\n                 self.resolve_method(MethodRibKind(\n@@ -4018,10 +4018,10 @@ impl Resolver {\n     pub fn check_consistent_bindings(@mut self, arm: &arm) {\n         if arm.pats.len() == 0 { return; }\n         let map_0 = self.binding_mode_map(arm.pats[0]);\n-        for arm.pats.iter().enumerate().advance |(i, p)| {\n+        foreach (i, p) in arm.pats.iter().enumerate() {\n             let map_i = self.binding_mode_map(*p);\n \n-            for map_0.iter().advance |(&key, &binding_0)| {\n+            foreach (&key, &binding_0) in map_0.iter() {\n                 match map_i.find(&key) {\n                   None => {\n                     self.session.span_err(\n@@ -4042,7 +4042,7 @@ impl Resolver {\n                 }\n             }\n \n-            for map_i.iter().advance |(&key, &binding)| {\n+            foreach (&key, &binding) in map_i.iter() {\n                 if !map_0.contains_key(&key) {\n                     self.session.span_err(\n                         binding.span,\n@@ -4058,7 +4058,7 @@ impl Resolver {\n         self.value_ribs.push(@Rib(NormalRibKind));\n \n         let bindings_list = @mut HashMap::new();\n-        for arm.pats.iter().advance |pattern| {\n+        foreach pattern in arm.pats.iter() {\n             self.resolve_pattern(*pattern, RefutableMode, Immutable,\n                                  Some(bindings_list), visitor);\n         }\n@@ -4164,15 +4164,15 @@ impl Resolver {\n                 }\n \n                 do bounds.map |bound_vec| {\n-                    for bound_vec.iter().advance |bound| {\n+                    foreach bound in bound_vec.iter() {\n                         self.resolve_type_parameter_bound(ty.id, bound, visitor);\n                     }\n                 };\n             }\n \n             ty_closure(c) => {\n                 do c.bounds.map |bounds| {\n-                    for bounds.iter().advance |bound| {\n+                    foreach bound in bounds.iter() {\n                         self.resolve_type_parameter_bound(ty.id, bound, visitor);\n                     }\n                 };\n@@ -4319,7 +4319,7 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for path.types.iter().advance |ty| {\n+                    foreach ty in path.types.iter() {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4352,7 +4352,7 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for path.types.iter().advance |ty| {\n+                    foreach ty in path.types.iter() {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4381,7 +4381,7 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for path.types.iter().advance |ty| {\n+                    foreach ty in path.types.iter() {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4477,7 +4477,7 @@ impl Resolver {\n                         visitor: ResolveVisitor)\n                         -> Option<def> {\n         // First, resolve the types.\n-        for path.types.iter().advance |ty| {\n+        foreach ty in path.types.iter() {\n             self.resolve_type(ty, visitor);\n         }\n \n@@ -4607,7 +4607,7 @@ impl Resolver {\n \n     pub fn intern_module_part_of_path(@mut self, path: &Path) -> ~[ident] {\n         let mut module_path_idents = ~[];\n-        for path.idents.iter().enumerate().advance |(index, ident)| {\n+        foreach (index, ident) in path.idents.iter().enumerate() {\n             if index == path.idents.len() - 1 {\n                 break;\n             }\n@@ -4845,7 +4845,7 @@ impl Resolver {\n         }\n \n         let mut smallest = 0;\n-        for maybes.iter().enumerate().advance |(i, &other)| {\n+        foreach (i, &other) in maybes.iter().enumerate() {\n             values[i] = name.lev_distance(other);\n \n             if values[i] <= values[smallest] {\n@@ -4874,11 +4874,11 @@ impl Resolver {\n           i -= 1;\n           match this.type_ribs[i].kind {\n             MethodRibKind(node_id, _) =>\n-              for this.crate.module.items.iter().advance |item| {\n+              foreach item in this.crate.module.items.iter() {\n                 if item.id == node_id {\n                   match item.node {\n                     item_struct(class_def, _) => {\n-                      for class_def.fields.iter().advance |field| {\n+                      foreach field in class_def.fields.iter() {\n                         match field.node.kind {\n                           unnamed_field => {},\n                           named_field(ident, _) => {\n@@ -5152,7 +5152,7 @@ impl Resolver {\n                 // Look for the current trait.\n                 match self.current_trait_refs {\n                     Some(ref trait_def_ids) => {\n-                        for trait_def_ids.iter().advance |trait_def_id| {\n+                        foreach trait_def_id in trait_def_ids.iter() {\n                             if candidate_traits.contains(trait_def_id) {\n                                 self.add_trait_info(&mut found_traits,\n                                                     *trait_def_id,\n@@ -5308,7 +5308,7 @@ impl Resolver {\n         match vi.node {\n             view_item_extern_mod(*) => {} // ignore\n             view_item_use(ref path) => {\n-                for path.iter().advance |p| {\n+                foreach p in path.iter() {\n                     match p.node {\n                         view_path_simple(_, _, id) | view_path_glob(_, id) => {\n                             if !self.used_imports.contains(&id) {\n@@ -5319,7 +5319,7 @@ impl Resolver {\n                         }\n \n                         view_path_list(_, ref list, _) => {\n-                            for list.iter().advance |i| {\n+                            foreach i in list.iter() {\n                                 if !self.used_imports.contains(&i.node.id) {\n                                     self.session.add_lint(unused_imports,\n                                                           i.node.id, i.span,\n@@ -5375,7 +5375,7 @@ impl Resolver {\n         }\n \n         debug!(\"Import resolutions:\");\n-        for module_.import_resolutions.iter().advance |(name, import_resolution)| {\n+        foreach (name, import_resolution) in module_.import_resolutions.iter() {\n             let value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n                 None => { value_repr = ~\"\"; }"}, {"sha": "8a8dfbc8fb926560baa7f5b776fb8a3e81040b40", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -298,7 +298,7 @@ pub fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n     match ccx.tcx.def_map.get_copy(&pat_id) {\n         ast::def_variant(enum_id, var_id) => {\n             let variants = ty::enum_variants(ccx.tcx, enum_id);\n-            for (*variants).iter().advance |v| {\n+            foreach v in (*variants).iter() {\n                 if var_id == v.id {\n                     return var(v.disr_val,\n                                adt::represent_node(bcx, pat_id))\n@@ -367,7 +367,7 @@ pub fn matches_to_str(bcx: @mut Block, m: &[Match]) -> ~str {\n }\n \n pub fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n-    for m.iter().advance |br| {\n+    foreach br in m.iter() {\n         match br.pats[col].node {\n           ast::pat_ident(_, _, Some(_)) => return true,\n           _ => ()\n@@ -437,7 +437,7 @@ pub fn enter_match<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let mut result = ~[];\n-    for m.iter().advance |br| {\n+    foreach br in m.iter() {\n         match e(br.pats[col]) {\n             Some(sub) => {\n                 let pats =\n@@ -589,7 +589,7 @@ pub fn enter_opt<'r>(bcx: @mut Block,\n                     // unspecified fields with dummy.\n                     let mut reordered_patterns = ~[];\n                     let r = ty::lookup_struct_fields(tcx, struct_id);\n-                    for r.iter().advance |field| {\n+                    foreach field in r.iter() {\n                             match field_pats.iter().find_(|p| p.ident == field.ident) {\n                                 None => reordered_patterns.push(dummy),\n                                 Some(fp) => reordered_patterns.push(fp.pat)\n@@ -649,7 +649,7 @@ pub fn enter_rec_or_struct<'r>(bcx: @mut Block,\n         match p.node {\n             ast::pat_struct(_, ref fpats, _) => {\n                 let mut pats = ~[];\n-                for fields.iter().advance |fname| {\n+                foreach fname in fields.iter() {\n                     match fpats.iter().find_(|p| p.ident == *fname) {\n                         None => pats.push(dummy),\n                         Some(pat) => pats.push(pat.pat)\n@@ -809,7 +809,7 @@ pub fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n     }\n \n     let mut found = ~[];\n-    for m.iter().advance |br| {\n+    foreach br in m.iter() {\n         let cur = br.pats[col];\n         match cur.node {\n             ast::pat_lit(l) => {\n@@ -955,7 +955,7 @@ pub fn collect_record_or_struct_fields(bcx: @mut Block,\n                                        col: uint)\n                                     -> ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n-    for m.iter().advance |br| {\n+    foreach br in m.iter() {\n         match br.pats[col].node {\n           ast::pat_struct(_, ref fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n@@ -969,7 +969,7 @@ pub fn collect_record_or_struct_fields(bcx: @mut Block,\n     return fields;\n \n     fn extend(idents: &mut ~[ast::ident], field_pats: &[ast::field_pat]) {\n-        for field_pats.iter().advance |field_pat| {\n+        foreach field_pat in field_pats.iter() {\n             let field_ident = field_pat.ident;\n             if !idents.iter().any(|x| *x == field_ident) {\n                 idents.push(field_ident);\n@@ -994,7 +994,7 @@ pub fn root_pats_as_necessary(mut bcx: @mut Block,\n                               col: uint,\n                               val: ValueRef)\n                            -> @mut Block {\n-    for m.iter().advance |br| {\n+    foreach br in m.iter() {\n         let pat_id = br.pats[col].id;\n         if pat_id != 0 {\n             let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n@@ -1063,14 +1063,14 @@ pub fn pick_col(m: &[Match]) -> uint {\n         }\n     }\n     let mut scores = vec::from_elem(m[0].pats.len(), 0u);\n-    for m.iter().advance |br| {\n+    foreach br in m.iter() {\n         let mut i = 0u;\n-        for br.pats.iter().advance |p| { scores[i] += score(*p); i += 1u; }\n+        foreach p in br.pats.iter() { scores[i] += score(*p); i += 1u; }\n     }\n     let mut max_score = 0u;\n     let mut best_col = 0u;\n     let mut i = 0u;\n-    for scores.iter().advance |score| {\n+    foreach score in scores.iter() {\n         let score = *score;\n \n         // Irrefutable columns always go first, they'd only be duplicated in\n@@ -1236,7 +1236,7 @@ pub fn compile_guard(bcx: @mut Block,\n     let val = bool_to_i1(bcx, val);\n \n     // Revoke the temp cleanups now that the guard successfully executed.\n-    for temp_cleanups.iter().advance |llval| {\n+    foreach llval in temp_cleanups.iter() {\n         revoke_clean(bcx, *llval);\n     }\n \n@@ -1325,7 +1325,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n     let mut pat_span = dummy_sp();\n-    for m.iter().advance |br| {\n+    foreach br in m.iter() {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n         if pat_id == 0 {\n@@ -1434,7 +1434,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n             var(_, repr) => {\n                 let (the_kind, val_opt) = adt::trans_switch(bcx, repr, val);\n                 kind = the_kind;\n-                for val_opt.iter().advance |&tval| { test_val = tval; }\n+                foreach &tval in val_opt.iter() { test_val = tval; }\n             }\n             lit(_) => {\n                 let pty = node_id_type(bcx, pat_id);\n@@ -1457,7 +1457,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n             }\n         }\n     }\n-    for opts.iter().advance |o| {\n+    foreach o in opts.iter() {\n         match *o {\n             range(_, _) => { kind = compare; break }\n             _ => ()\n@@ -1479,7 +1479,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n     let mut i = 0u;\n \n     // Compile subtrees for each option\n-    for opts.iter().advance |opt| {\n+    foreach opt in opts.iter() {\n         i += 1u;\n         let mut opt_cx = else_cx;\n         if !exhaustive || i < len {\n@@ -1688,7 +1688,7 @@ pub fn trans_match_inner(scope_cx: @mut Block,\n \n     let mut arm_datas = ~[];\n     let mut matches = ~[];\n-    for arms.iter().advance |arm| {\n+    foreach arm in arms.iter() {\n         let body = scope_block(bcx, arm.body.info(), \"case_body\");\n         let bindings_map = create_bindings_map(bcx, arm.pats[0]);\n         let arm_data = ArmData {\n@@ -1697,7 +1697,7 @@ pub fn trans_match_inner(scope_cx: @mut Block,\n             bindings_map: @bindings_map\n         };\n         arm_datas.push(arm_data.clone());\n-        for arm.pats.iter().advance |p| {\n+        foreach p in arm.pats.iter() {\n             matches.push(Match {\n                 pats: ~[*p],\n                 data: arm_data.clone(),\n@@ -1721,7 +1721,7 @@ pub fn trans_match_inner(scope_cx: @mut Block,\n     compile_submatch(bcx, matches, [lldiscr], chk);\n \n     let mut arm_cxs = ~[];\n-    for arm_datas.iter().advance |arm_data| {\n+    foreach arm_data in arm_datas.iter() {\n         let mut bcx = arm_data.bodycx;\n \n         // If this arm has a guard, then the various by-value bindings have\n@@ -1957,7 +1957,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n                     });\n             }\n \n-            for inner.iter().advance |&inner_pat| {\n+            foreach &inner_pat in inner.iter() {\n                 bcx = bind_irrefutable_pat(bcx, inner_pat, val, binding_mode);\n             }\n         }\n@@ -1972,8 +1972,8 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n                                                     repr,\n                                                     vinfo.disr_val,\n                                                     val);\n-                    for sub_pats.iter().advance |sub_pat| {\n-                        for args.vals.iter().enumerate().advance |(i, argval)| {\n+                    foreach sub_pat in sub_pats.iter() {\n+                        foreach (i, argval) in args.vals.iter().enumerate() {\n                             bcx = bind_irrefutable_pat(bcx, sub_pat[i],\n                                                        *argval, binding_mode);\n                         }\n@@ -1988,7 +1988,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n                         Some(ref elems) => {\n                             // This is the tuple struct case.\n                             let repr = adt::represent_node(bcx, pat.id);\n-                            for elems.iter().enumerate().advance |(i, elem)| {\n+                            foreach (i, elem) in elems.iter().enumerate() {\n                                 let fldptr = adt::trans_field_ptr(bcx, repr,\n                                                                   val, 0, i);\n                                 bcx = bind_irrefutable_pat(bcx, *elem,\n@@ -2009,7 +2009,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n-                for fields.iter().advance |f| {\n+                foreach f in fields.iter() {\n                     let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n                                                       discr, ix);\n@@ -2019,7 +2019,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n         }\n         ast::pat_tup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n-            for elems.iter().enumerate().advance |(i, elem)| {\n+            foreach (i, elem) in elems.iter().enumerate() {\n                 let fldptr = adt::trans_field_ptr(bcx, repr, val, 0, i);\n                 bcx = bind_irrefutable_pat(bcx, *elem, fldptr, binding_mode);\n             }"}, {"sha": "6c37fd18f69e88ba55ee1f3b4e96a129bffd20dc", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -249,7 +249,7 @@ fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n             let mut most_aligned = None;\n             let mut largest_align = 0;\n             let mut largest_size = 0;\n-            for sts.iter().advance |st| {\n+            foreach st in sts.iter() {\n                 if largest_size < st.size {\n                     largest_size = st.size;\n                 }\n@@ -545,7 +545,7 @@ fn build_const_struct(ccx: &mut CrateContext, st: &Struct, vals: &[ValueRef])\n \n     let mut offset = 0;\n     let mut cfields = ~[];\n-    for st.fields.iter().enumerate().advance |(i, &ty)| {\n+    foreach (i, &ty) in st.fields.iter().enumerate() {\n         let llty = type_of::sizing_type_of(ccx, ty);\n         let type_align = machine::llalign_of_min(ccx, llty)\n             /*bad*/as u64;"}, {"sha": "2c7e3ae0043c0f42c0986b80a0a179137caf7334", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -62,7 +62,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n \n     };\n \n-    for cleanups.iter().advance |c| {\n+    foreach c in cleanups.iter() {\n         revoke_clean(bcx, *c);\n     }\n     cleanups.clear();\n@@ -83,7 +83,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n \n     };\n \n-    for cleanups.iter().advance |c| {\n+    foreach c in cleanups.iter() {\n         revoke_clean(bcx, *c);\n     }\n \n@@ -133,7 +133,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n         let op = PointerCast(bcx, aoutputs[0], val_ty(outputs[0]).ptr_to());\n         Store(bcx, r, op);\n     } else {\n-        for aoutputs.iter().enumerate().advance |(i, o)| {\n+        foreach (i, o) in aoutputs.iter().enumerate() {\n             let v = ExtractValue(bcx, r, i);\n             let op = PointerCast(bcx, *o, val_ty(outputs[i]).ptr_to());\n             Store(bcx, v, op);"}, {"sha": "b683014cccff69f7ee0b76eb969e382c24bc5db9", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -675,7 +675,7 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n         let tcx = cx.tcx();\n         let mut cx = cx;\n \n-        for variant.args.iter().enumerate().advance |(i, &arg)| {\n+        foreach (i, &arg) in variant.args.iter().enumerate() {\n             cx = f(cx,\n                    adt::trans_field_ptr(cx, repr, av, variant.disr_val, i),\n                    ty::subst_tps(tcx, tps, None, arg));\n@@ -688,7 +688,7 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n       ty::ty_struct(*) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           do expr::with_field_tys(cx.tcx(), t, None) |discr, field_tys| {\n-              for field_tys.iter().enumerate().advance |(i, field_ty)| {\n+              foreach (i, field_ty) in field_tys.iter().enumerate() {\n                   let llfld_a = adt::trans_field_ptr(cx, repr, av, discr, i);\n                   cx = f(cx, llfld_a, field_ty.mt.ty);\n               }\n@@ -701,7 +701,7 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n       }\n       ty::ty_tup(ref args) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          for args.iter().enumerate().advance |(i, arg)| {\n+          foreach (i, arg) in args.iter().enumerate() {\n               let llfld_a = adt::trans_field_ptr(cx, repr, av, 0, i);\n               cx = f(cx, llfld_a, *arg);\n           }\n@@ -729,7 +729,7 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n                                         n_variants);\n                   let next_cx = sub_block(cx, \"enum-iter-next\");\n \n-                  for (*variants).iter().advance |variant| {\n+                  foreach variant in (*variants).iter() {\n                       let variant_cx =\n                           sub_block(cx, ~\"enum-iter-variant-\" +\n                                     uint::to_str(variant.disr_val));\n@@ -863,7 +863,7 @@ pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef])\n             debug!(\"invoking %x at %x\",\n                    ::std::cast::transmute(llfn),\n                    ::std::cast::transmute(bcx.llbb));\n-            for llargs.iter().advance |&llarg| {\n+            foreach &llarg in llargs.iter() {\n                 debug!(\"arg: %x\", ::std::cast::transmute(llarg));\n             }\n         }\n@@ -879,7 +879,7 @@ pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef])\n             debug!(\"calling %x at %x\",\n                    ::std::cast::transmute(llfn),\n                    ::std::cast::transmute(bcx.llbb));\n-            for llargs.iter().advance |&llarg| {\n+            foreach &llarg in llargs.iter() {\n                 debug!(\"arg: %x\", ::std::cast::transmute(llarg));\n             }\n         }\n@@ -908,7 +908,7 @@ pub fn need_invoke(bcx: @mut Block) -> bool {\n     loop {\n         cur_scope = match cur_scope {\n             Some(inf) => {\n-                for inf.cleanups.iter().advance |cleanup| {\n+                foreach cleanup in inf.cleanups.iter() {\n                     match *cleanup {\n                         clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n                             if cleanup_type == normal_exit_and_unwind {\n@@ -1171,7 +1171,7 @@ pub fn new_block(cx: @mut FunctionContext,\n                                   opt_node_info,\n                                   cx);\n         bcx.scope = scope;\n-        for parent.iter().advance |cx| {\n+        foreach cx in parent.iter() {\n             if cx.unreachable {\n                 Unreachable(bcx);\n                 break;\n@@ -1261,7 +1261,7 @@ pub fn trans_block_cleanups_(bcx: @mut Block,\n         bcx.ccx().sess.opts.debugging_opts & session::no_landing_pads != 0;\n     if bcx.unreachable && !no_lpads { return bcx; }\n     let mut bcx = bcx;\n-    for cleanups.rev_iter().advance |cu| {\n+    foreach cu in cleanups.rev_iter() {\n         match *cu {\n             clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) => {\n                 // Some types don't need to be cleaned up during\n@@ -1304,7 +1304,7 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n                         let mut dest = None;\n                         {\n                             let r = (*inf).cleanup_paths.rev_iter().find_(|cp| cp.target == leave);\n-                            for r.iter().advance |cp| {\n+                            foreach cp in r.iter() {\n                                 if cp.size == inf.cleanups.len() {\n                                     Br(bcx, cp.dest);\n                                     return;\n@@ -1326,7 +1326,7 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n                     bcx = trans_block_cleanups_(sub_cx,\n                                                 inf_cleanups,\n                                                 is_lpad);\n-                    for dest.iter().advance |&dest| {\n+                    foreach &dest in dest.iter() {\n                         Br(bcx, dest);\n                         return;\n                     }\n@@ -1449,7 +1449,7 @@ pub fn with_scope_datumblock(bcx: @mut Block, opt_node_info: Option<NodeInfo>,\n }\n \n pub fn block_locals(b: &ast::Block, it: &fn(@ast::Local)) {\n-    for b.stmts.iter().advance |s| {\n+    foreach s in b.stmts.iter() {\n         match s.node {\n           ast::stmt_decl(d, _) => {\n             match d.node {\n@@ -1624,7 +1624,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                         opt_node_info: Option<NodeInfo>,\n                         sp: Option<span>)\n                      -> @mut FunctionContext {\n-    for param_substs.iter().advance |p| { p.validate(); }\n+    foreach p in param_substs.iter() { p.validate(); }\n \n     debug!(\"new_fn_ctxt_w_id(path=%s, id=%?, \\\n             param_substs=%s)\",\n@@ -1901,7 +1901,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     // Put return block after all other blocks.\n     // This somewhat improves single-stepping experience in debugger.\n     unsafe {\n-        for fcx.llreturn.iter().advance |&llreturn| {\n+        foreach &llreturn in fcx.llreturn.iter() {\n             llvm::LLVMMoveBasicBlockAfter(llreturn, bcx.llbb);\n         }\n     }\n@@ -2090,7 +2090,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n \n     let repr = adt::represent_type(ccx, result_ty);\n     adt::trans_start_init(bcx, repr, fcx.llretptr.get(), disr);\n-    for fn_args.iter().enumerate().advance |(i, fn_arg)| {\n+    foreach (i, fn_arg) in fn_args.iter().enumerate() {\n         let lldestptr = adt::trans_field_ptr(bcx,\n                                              repr,\n                                              fcx.llretptr.get(),\n@@ -2106,7 +2106,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n                       id: ast::NodeId, vi: @~[@ty::VariantInfo],\n                       i: &mut uint) {\n-    for enum_definition.variants.iter().advance |variant| {\n+    foreach variant in enum_definition.variants.iter() {\n         let disr_val = vi[*i].disr_val;\n         *i += 1;\n \n@@ -2156,7 +2156,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n                      item.id,\n                      item.attrs);\n         } else {\n-            for body.stmts.iter().advance |stmt| {\n+            foreach stmt in body.stmts.iter() {\n                 match stmt.node {\n                   ast::stmt_decl(@codemap::spanned { node: ast::decl_item(i),\n                                                  _ }, _) => {\n@@ -2189,7 +2189,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n           consts::trans_const(ccx, m, item.id);\n           // Do static_assert checking. It can't really be done much earlier because we need to get\n           // the value of the bool out of LLVM\n-          for item.attrs.iter().advance |attr| {\n+          foreach attr in item.attrs.iter() {\n               if \"static_assert\" == attr.name() {\n                   if m == ast::m_mutbl {\n                       ccx.sess.span_fatal(expr.span,\n@@ -2237,7 +2237,7 @@ pub fn trans_struct_def(ccx: @mut CrateContext, struct_def: @ast::struct_def) {\n // and control visibility.\n pub fn trans_mod(ccx: @mut CrateContext, m: &ast::_mod) {\n     let _icx = push_ctxt(\"trans_mod\");\n-    for m.items.iter().advance |item| {\n+    foreach item in m.items.iter() {\n         trans_item(ccx, *item);\n     }\n }\n@@ -2625,7 +2625,7 @@ pub fn trans_constant(ccx: &mut CrateContext, it: @ast::item) {\n                                                  node: it.id });\n         let mut i = 0;\n         let path = item_path(ccx, &it.id);\n-        for (*enum_definition).variants.iter().advance |variant| {\n+        foreach variant in (*enum_definition).variants.iter() {\n             let p = vec::append(path.clone(), [\n                 path_name(variant.node.name),\n                 path_name(special_idents::descrim)\n@@ -2805,7 +2805,7 @@ pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n         keys.push(k.to_managed());\n     }\n \n-    for keys.iter().advance |key| {\n+    foreach key in keys.iter() {\n         let val = *ccx.module_data.find_equiv(key).get();\n         let s_const = C_cstr(ccx, *key);\n         let s_ptr = p2i(ccx, s_const);\n@@ -3032,7 +3032,7 @@ pub fn trans_crate(sess: session::Session,\n         do sort::quick_sort(ccx.stats.fn_stats) |&(_, _, insns_a), &(_, _, insns_b)| {\n             insns_a > insns_b\n         }\n-        for ccx.stats.fn_stats.iter().advance |tuple| {\n+        foreach tuple in ccx.stats.fn_stats.iter() {\n             match *tuple {\n                 (ref name, ms, insns) => {\n                     printfln!(\"%u insns, %u ms, %s\", insns, ms, *name);\n@@ -3041,7 +3041,7 @@ pub fn trans_crate(sess: session::Session,\n         }\n     }\n     if ccx.sess.count_llvm_insns() {\n-        for ccx.stats.llvm_insns.iter().advance |(k, v)| {\n+        foreach (k, v) in ccx.stats.llvm_insns.iter() {\n             printfln!(\"%-7u %s\", *v, *k);\n         }\n     }"}, {"sha": "9d44dacfd68542faea349d41682dbb98e540b4a5", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -516,7 +516,7 @@ impl Builder {\n         // we care about.\n         if ixs.len() < 16 {\n             let mut small_vec = [ C_i32(0), ..16 ];\n-            for small_vec.mut_iter().zip(ixs.iter()).advance |(small_vec_e, &ix)| {\n+            foreach (small_vec_e, &ix) in small_vec.mut_iter().zip(ixs.iter()) {\n                 *small_vec_e = C_i32(ix as i32);\n             }\n             self.inbounds_gep(base, small_vec.slice(0, ixs.len()))"}, {"sha": "2fcdf885aadcb8684353ac86092e19406163a5b2", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -42,7 +42,7 @@ impl FnType {\n         let fnty = Type::func(atys, &rty);\n         let llfn = decl(fnty);\n \n-        for self.attrs.iter().enumerate().advance |(i, a)| {\n+        foreach (i, a) in self.attrs.iter().enumerate() {\n             match *a {\n                 option::Some(attr) => {\n                     unsafe {\n@@ -92,7 +92,7 @@ impl FnType {\n \n     pub fn build_shim_ret(&self, bcx: @mut Block, arg_tys: &[Type], ret_def: bool,\n                           llargbundle: ValueRef, llretval: ValueRef) {\n-        for self.attrs.iter().enumerate().advance |(i, a)| {\n+        foreach (i, a) in self.attrs.iter().enumerate() {\n             match *a {\n                 option::Some(attr) => {\n                     unsafe {"}, {"sha": "4ad4400e98227baee26bdebf14b3a17e56132f60", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -133,7 +133,7 @@ impl ABIInfo for ARM_ABIInfo {\n                     ret_def: bool) -> FnType {\n         let mut arg_tys = ~[];\n         let mut attrs = ~[];\n-        for atys.iter().advance |&aty| {\n+        foreach &aty in atys.iter() {\n             let (ty, attr) = classify_arg_ty(aty);\n             arg_tys.push(ty);\n             attrs.push(attr);"}, {"sha": "b863447a0b4266e9d5d5beef7580dc0fa0b9752d", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -190,7 +190,7 @@ impl ABIInfo for MIPS_ABIInfo {\n         let mut attrs = ~[];\n         let mut offset = if sret { 4 } else { 0 };\n \n-        for atys.iter().advance |aty| {\n+        foreach aty in atys.iter() {\n             let (ty, attr) = classify_arg_ty(*aty, &mut offset);\n             arg_tys.push(ty);\n             attrs.push(attr);"}, {"sha": "7796f05249d5ae888ff3648c9ef0101a6c223adf", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -180,7 +180,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                        cls: &mut [RegClass], i: uint,\n                        off: uint) {\n         let mut field_off = off;\n-        for tys.iter().advance |ty| {\n+        foreach ty in tys.iter() {\n             field_off = align(field_off, *ty);\n             classify(*ty, cls, i, field_off);\n             field_off += ty_size(*ty);\n@@ -295,7 +295,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n fn llreg_ty(cls: &[RegClass]) -> Type {\n     fn llvec_len(cls: &[RegClass]) -> uint {\n         let mut len = 1u;\n-        for cls.iter().advance |c| {\n+        foreach c in cls.iter() {\n             if *c != SSEUp {\n                 break;\n             }\n@@ -356,7 +356,7 @@ fn x86_64_tys(atys: &[Type],\n \n     let mut arg_tys = ~[];\n     let mut attrs = ~[];\n-    for atys.iter().advance |t| {\n+    foreach t in atys.iter() {\n         let (ty, attr) = x86_64_ty(*t, |cls| cls.is_pass_byval(), ByValAttribute);\n         arg_tys.push(ty);\n         attrs.push(attr);"}, {"sha": "6492c8a1cf21ed7dcee839489c36c55e8345cdd8", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -618,7 +618,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n         // the cleanup for the self argument\n         match callee.data {\n             Method(d) => {\n-                for d.temp_cleanup.iter().advance |&v| {\n+                foreach &v in d.temp_cleanup.iter() {\n                     revoke_clean(bcx, v);\n                 }\n             }\n@@ -628,7 +628,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n         // Uncomment this to debug calls.\n         /*\n         printfln!(\"calling: %s\", bcx.val_to_str(llfn));\n-        for llargs.iter().advance |llarg| {\n+        foreach llarg in llargs.iter() {\n             printfln!(\"arg: %s\", bcx.val_to_str(*llarg));\n         }\n         io::println(\"---\");\n@@ -671,7 +671,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n             bcx = do with_cond(bcx, ret_flag_result) |bcx| {\n                 {\n                     let r = bcx.fcx.loop_ret;\n-                    for r.iter().advance |&(flagptr, _)| {\n+                    foreach &(flagptr, _) in r.iter() {\n                         Store(bcx, C_bool(true), flagptr);\n                         Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n                     }\n@@ -728,7 +728,7 @@ pub fn trans_args(cx: @mut Block,\n     match args {\n       ArgExprs(arg_exprs) => {\n         let last = arg_exprs.len() - 1u;\n-        for arg_exprs.iter().enumerate().advance |(i, arg_expr)| {\n+        foreach (i, arg_expr) in arg_exprs.iter().enumerate() {\n             let arg_val = unpack_result!(bcx, {\n                 trans_arg_expr(bcx,\n                                arg_tys[i],\n@@ -749,7 +749,7 @@ pub fn trans_args(cx: @mut Block,\n     // now that all arguments have been successfully built, we can revoke any\n     // temporary cleanups, as they are only needed if argument construction\n     // should fail (for example, cleanup of copy mode args).\n-    for temp_cleanups.iter().advance |c| {\n+    foreach c in temp_cleanups.iter() {\n         revoke_clean(bcx, *c)\n     }\n "}, {"sha": "713d502c3fb40df2a507c6b12eb434e49b3ebfe0", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -228,7 +228,7 @@ pub fn store_environment(bcx: @mut Block,\n \n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n-    for bound_values.iter().enumerate().advance |(i, bv)| {\n+    foreach (i, bv) in bound_values.iter().enumerate() {\n         debug!(\"Copy %s into closure\", bv.to_str(ccx));\n \n         if ccx.sess.asm_comments() {\n@@ -268,7 +268,7 @@ pub fn build_closure(bcx0: @mut Block,\n \n     // Package up the captured upvars\n     let mut env_vals = ~[];\n-    for cap_vars.iter().advance |cap_var| {\n+    foreach cap_var in cap_vars.iter() {\n         debug!(\"Building closure: captured variable %?\", *cap_var);\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n@@ -290,7 +290,7 @@ pub fn build_closure(bcx0: @mut Block,\n \n     // If this is a `for` loop body, add two special environment\n     // variables:\n-    for include_ret_handle.iter().advance |flagptr| {\n+    foreach flagptr in include_ret_handle.iter() {\n         // Flag indicating we have returned (a by-ref bool):\n         let flag_datum = Datum {val: *flagptr, ty: ty::mk_bool(),\n                                 mode: ByRef(ZeroMem)};\n@@ -337,7 +337,7 @@ pub fn load_environment(fcx: @mut FunctionContext,\n \n     // Populate the upvars from the environment.\n     let mut i = 0u;\n-    for cap_vars.iter().advance |cap_var| {\n+    foreach cap_var in cap_vars.iter() {\n         let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n         match sigil {\n             ast::BorrowedSigil => { upvarptr = Load(bcx, upvarptr); }"}, {"sha": "df59133d9706e71c298337ddd4c89e2f902c134a", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -138,8 +138,8 @@ pub struct param_substs {\n \n impl param_substs {\n     pub fn validate(&self) {\n-        for self.tys.iter().advance |t| { assert!(!ty::type_needs_infer(*t)); }\n-        for self.self_ty.iter().advance |t| { assert!(!ty::type_needs_infer(*t)); }\n+        foreach t in self.tys.iter() { assert!(!ty::type_needs_infer(*t)); }\n+        foreach t in self.self_ty.iter() { assert!(!ty::type_needs_infer(*t)); }\n     }\n }\n \n@@ -437,7 +437,7 @@ pub fn revoke_clean(cx: @mut Block, val: ValueRef) {\n                 clean_temp(v, _, _) if v == val => true,\n                 _ => false\n             });\n-        for cleanup_pos.iter().advance |i| {\n+        foreach i in cleanup_pos.iter() {\n             scope_info.cleanups =\n                 vec::append(scope_info.cleanups.slice(0u, *i).to_owned(),\n                             scope_info.cleanups.slice(*i + 1u,\n@@ -943,7 +943,7 @@ pub fn align_to(cx: @mut Block, off: ValueRef, align: ValueRef) -> ValueRef {\n pub fn path_str(sess: session::Session, p: &[path_elt]) -> ~str {\n     let mut r = ~\"\";\n     let mut first = true;\n-    for p.iter().advance |e| {\n+    foreach e in p.iter() {\n         match *e {\n             ast_map::path_name(s) | ast_map::path_mod(s) => {\n                 if first {"}, {"sha": "7d9eb95505bb7d4887b936bbac26bbfd3e51900c", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -36,7 +36,7 @@ use syntax::codemap::span;\n pub fn trans_block(bcx: @mut Block, b: &ast::Block, dest: expr::Dest) -> @mut Block {\n     let _icx = push_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n-    for b.stmts.iter().advance |s| {\n+    foreach s in b.stmts.iter() {\n         debuginfo::update_source_pos(bcx, b.span);\n         bcx = trans_stmt(bcx, *s);\n     }\n@@ -144,7 +144,7 @@ pub fn trans_if(bcx: @mut Block,\n pub fn join_blocks(parent_bcx: @mut Block, in_cxs: &[@mut Block]) -> @mut Block {\n     let out = sub_block(parent_bcx, \"join\");\n     let mut reachable = false;\n-    for in_cxs.iter().advance |bcx| {\n+    foreach bcx in in_cxs.iter() {\n         if !bcx.unreachable {\n             Br(*bcx, out.llbb);\n             reachable = true;\n@@ -223,7 +223,7 @@ pub fn trans_log(log_ex: &ast::expr,\n     let (modpath, modname) = {\n         let path = &mut bcx.fcx.path;\n         let mut modpath = ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name))];\n-        for path.iter().advance |e| {\n+        foreach e in path.iter() {\n             match *e {\n                 path_mod(_) => { modpath.push(*e) }\n                 _ => {}"}, {"sha": "5ad18b63c767dc6b5a0455af80ee3648dbf810ba", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -1154,7 +1154,7 @@ fn trans_rec_or_struct(bcx: @mut Block,\n         let optbase = match base {\n             Some(base_expr) => {\n                 let mut leftovers = ~[];\n-                for need_base.iter().enumerate().advance |(i, b)| {\n+                foreach (i, b) in need_base.iter().enumerate() {\n                     if *b {\n                         leftovers.push((i, field_tys[i].mt.ty))\n                     }\n@@ -1208,10 +1208,10 @@ fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: uint,\n     let mut bcx = bcx;\n     let addr = match dest {\n         Ignore => {\n-            for fields.iter().advance |&(_i, e)| {\n+            foreach &(_i, e) in fields.iter() {\n                 bcx = trans_into(bcx, e, Ignore);\n             }\n-            for optbase.iter().advance |sbi| {\n+            foreach sbi in optbase.iter() {\n                 // FIXME #7261: this moves entire base, not just certain fields\n                 bcx = trans_into(bcx, sbi.expr, Ignore);\n             }\n@@ -1221,18 +1221,18 @@ fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: uint,\n     };\n     let mut temp_cleanups = ~[];\n     adt::trans_start_init(bcx, repr, addr, discr);\n-    for fields.iter().advance |&(i, e)| {\n+    foreach &(i, e) in fields.iter() {\n         let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n         let e_ty = expr_ty(bcx, e);\n         bcx = trans_into(bcx, e, SaveIn(dest));\n         add_clean_temp_mem(bcx, dest, e_ty);\n         temp_cleanups.push(dest);\n     }\n-    for optbase.iter().advance |base| {\n+    foreach base in optbase.iter() {\n         // FIXME #6573: is it sound to use the destination's repr on the base?\n         // And, would it ever be reasonable to be here with discr != 0?\n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base.expr));\n-        for base.fields.iter().advance |&(i, t)| {\n+        foreach &(i, t) in base.fields.iter() {\n             let datum = do base_datum.get_element(bcx, t, ZeroMem) |srcval| {\n                 adt::trans_field_ptr(bcx, repr, srcval, discr, i)\n             };\n@@ -1241,7 +1241,7 @@ fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: uint,\n         }\n     }\n \n-    for temp_cleanups.iter().advance |cleanup| {\n+    foreach cleanup in temp_cleanups.iter() {\n         revoke_clean(bcx, *cleanup);\n     }\n     return bcx;"}, {"sha": "066979b0b2073506db18256ddc9994f9dc779cdd", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -287,7 +287,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         Some(abi) => abi,\n     };\n \n-    for foreign_mod.items.iter().advance |&foreign_item| {\n+    foreach &foreign_item in foreign_mod.items.iter() {\n         match foreign_item.node {\n             ast::foreign_item_fn(*) => {\n                 let id = foreign_item.id;\n@@ -513,7 +513,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                 store_inbounds(bcx, llargval, llargbundle, [0u, i]);\n             }\n \n-            for bcx.fcx.llretptr.iter().advance |&retptr| {\n+            foreach &retptr in bcx.fcx.llretptr.iter() {\n                 store_inbounds(bcx, retptr, llargbundle, [0u, n]);\n             }\n         }\n@@ -523,7 +523,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                      llargbundle: ValueRef) {\n             let _icx = push_ctxt(\"foreign::wrap::build_ret\");\n             let arg_count = shim_types.fn_sig.inputs.len();\n-            for bcx.fcx.llretptr.iter().advance |&retptr| {\n+            foreach &retptr in bcx.fcx.llretptr.iter() {\n                 let llretptr = load_inbounds(bcx, llargbundle, [0, arg_count]);\n                 Store(bcx, Load(bcx, llretptr), retptr);\n             }"}, {"sha": "b9c20893c8e311bce8ee360a9d0a07eb098f74c8", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -426,7 +426,7 @@ pub fn trans_struct_drop_flag(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did:\n \n         // Drop the fields\n         let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n-        for field_tys.iter().enumerate().advance |(i, fld)| {\n+        foreach (i, fld) in field_tys.iter().enumerate() {\n             let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n             bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n         }\n@@ -461,7 +461,7 @@ pub fn trans_struct_drop(mut bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did:\n \n     // Drop the fields\n     let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n-    for field_tys.iter().enumerate().advance |(i, fld)| {\n+    foreach (i, fld) in field_tys.iter().enumerate() {\n         let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n         bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n     }"}, {"sha": "32d50ef9fd3ca603b230c12e3266f83c47718264", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -68,7 +68,7 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::def_id)\n             ast::item_enum(_, _) => {\n               let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n               let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n-              for vs_here.iter().zip(vs_there.iter()).advance |(here, there)| {\n+              foreach (here, there) in vs_here.iter().zip(vs_there.iter()) {\n                   if there.id == fn_id { my_id = here.id.node; }\n                   ccx.external.insert(there.id, Some(here.id.node));\n               }"}, {"sha": "debaf0f04a7df67b9f2baa8c844fe74babff8c38", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -57,7 +57,7 @@ pub fn trans_impl(ccx: @mut CrateContext,\n \n     if !generics.ty_params.is_empty() { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n-    for methods.iter().advance |method| {\n+    foreach method in methods.iter() {\n         if method.generics.ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n             let path = vec::append_one(sub_path.clone(),\n@@ -599,7 +599,7 @@ pub fn make_vtable(ccx: &mut CrateContext,\n         let _icx = push_ctxt(\"impl::make_vtable\");\n \n         let mut components = ~[ tydesc.tydesc ];\n-        for ptrs.iter().advance |&ptr| {\n+        foreach &ptr in ptrs.iter() {\n             components.push(ptr)\n         }\n "}, {"sha": "272c72f03eaee73932dd1bd44068a560cf0da48f", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -75,8 +75,8 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n         self_vtables: self_vtables\n     };\n \n-    for real_substs.tps.iter().advance |s| { assert!(!ty::type_has_params(*s)); }\n-    for psubsts.tys.iter().advance |s| { assert!(!ty::type_has_params(*s)); }\n+    foreach s in real_substs.tps.iter() { assert!(!ty::type_has_params(*s)); }\n+    foreach s in psubsts.tys.iter() { assert!(!ty::type_has_params(*s)); }\n     let param_uses = type_use::type_uses_for(ccx, fn_id, psubsts.tys.len());\n \n "}, {"sha": "93b2e8a6665df25816d513630a9c929217c3ae8d", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -96,7 +96,7 @@ impl Reflector {\n         let v = self.visitor_val;\n         debug!(\"passing %u args:\", args.len());\n         let mut bcx = self.bcx;\n-        for args.iter().enumerate().advance |(i, a)| {\n+        foreach (i, a) in args.iter().enumerate() {\n             debug!(\"arg %u: %s\", i, bcx.val_to_str(*a));\n         }\n         let bool_ty = ty::mk_bool();\n@@ -214,7 +214,7 @@ impl Reflector {\n               let extra = ~[self.c_uint(tys.len())]\n                   + self.c_size_and_align(t);\n               do self.bracketed(\"tup\", extra) |this| {\n-                  for tys.iter().enumerate().advance |(i, t)| {\n+                  foreach (i, t) in tys.iter().enumerate() {\n                       let extra = ~[this.c_uint(i), this.c_tydesc(*t)];\n                       this.visit(\"tup_field\", extra);\n                   }\n@@ -259,7 +259,7 @@ impl Reflector {\n               let extra = ~[self.c_uint(fields.len())]\n                   + self.c_size_and_align(t);\n               do self.bracketed(\"class\", extra) |this| {\n-                  for fields.iter().enumerate().advance |(i, field)| {\n+                  foreach (i, field) in fields.iter().enumerate() {\n                       let extra = ~[this.c_uint(i),\n                                     this.c_slice(\n                                         bcx.ccx().sess.str_of(field.ident))]\n@@ -318,14 +318,14 @@ impl Reflector {\n             let enum_args = ~[self.c_uint(variants.len()), make_get_disr()]\n                 + self.c_size_and_align(t);\n             do self.bracketed(\"enum\", enum_args) |this| {\n-                for variants.iter().enumerate().advance |(i, v)| {\n+                foreach (i, v) in variants.iter().enumerate() {\n                     let name = ccx.sess.str_of(v.name);\n                     let variant_args = ~[this.c_uint(i),\n                                          this.c_uint(v.disr_val),\n                                          this.c_uint(v.args.len()),\n                                          this.c_slice(name)];\n                     do this.bracketed(\"enum_variant\", variant_args) |this| {\n-                        for v.args.iter().enumerate().advance |(j, a)| {\n+                        foreach (j, a) in v.args.iter().enumerate() {\n                             let bcx = this.bcx;\n                             let null = C_null(llptrty);\n                             let ptr = adt::trans_field_ptr(bcx, repr, null, v.disr_val, j);\n@@ -360,7 +360,7 @@ impl Reflector {\n     }\n \n     pub fn visit_sig(&mut self, retval: uint, sig: &ty::FnSig) {\n-        for sig.inputs.iter().enumerate().advance |(i, arg)| {\n+        foreach (i, arg) in sig.inputs.iter().enumerate() {\n             let modeval = 5u;   // \"by copy\"\n             let extra = ~[self.c_uint(i),\n                          self.c_uint(modeval),"}, {"sha": "b37a99771bde0cd5edd523ef6d068d655b1eaa36", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -374,14 +374,14 @@ pub fn write_content(bcx: @mut Block,\n         ast::expr_vec(ref elements, _) => {\n             match dest {\n                 Ignore => {\n-                    for elements.iter().advance |element| {\n+                    foreach element in elements.iter() {\n                         bcx = expr::trans_into(bcx, *element, Ignore);\n                     }\n                 }\n \n                 SaveIn(lldest) => {\n                     let mut temp_cleanups = ~[];\n-                    for elements.iter().enumerate().advance |(i, element)| {\n+                    foreach (i, element) in elements.iter().enumerate() {\n                         let lleltptr = GEPi(bcx, lldest, [i]);\n                         debug!(\"writing index %? with lleltptr=%?\",\n                                i, bcx.val_to_str(lleltptr));\n@@ -390,7 +390,7 @@ pub fn write_content(bcx: @mut Block,\n                         add_clean_temp_mem(bcx, lleltptr, vt.unit_ty);\n                         temp_cleanups.push(lleltptr);\n                     }\n-                    for temp_cleanups.iter().advance |cleanup| {\n+                    foreach cleanup in temp_cleanups.iter() {\n                         revoke_clean(bcx, *cleanup);\n                     }\n                 }"}, {"sha": "52db07f24289d451436212e60de0755d681a2744", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -194,7 +194,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n     match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n         ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n         ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n-            for sig.inputs.iter().advance |arg| {\n+            foreach arg in sig.inputs.iter() {\n                 type_needs(&cx, use_repr, *arg);\n             }\n         }\n@@ -241,8 +241,8 @@ pub fn type_needs_inner(cx: &Context,\n                 if list::find(enums_seen, |id| *id == did).is_none() {\n                     let seen = @Cons(did, enums_seen);\n                     let r = ty::enum_variants(cx.ccx.tcx, did);\n-                    for r.iter().advance |v| {\n-                        for v.args.iter().advance |aty| {\n+                    foreach v in r.iter() {\n+                        foreach aty in v.args.iter() {\n                             let t = ty::subst(cx.ccx.tcx, &(*substs), *aty);\n                             type_needs_inner(cx, use_, t, seen);\n                         }\n@@ -268,7 +268,7 @@ pub fn mark_for_method_call(cx: &Context, e_id: NodeId, callee_id: NodeId) {\n     let mut opt_static_did = None;\n     {\n         let r = cx.ccx.maps.method_map.find(&e_id);\n-        for r.iter().advance |mth| {\n+        foreach mth in r.iter() {\n             match mth.origin {\n               typeck::method_static(did) => {\n                   opt_static_did = Some(did);\n@@ -288,12 +288,12 @@ pub fn mark_for_method_call(cx: &Context, e_id: NodeId, callee_id: NodeId) {\n     // above because the recursive call to `type_needs` can trigger\n     // inlining and hence can cause `method_map` and\n     // `node_type_substs` to be modified.\n-    for opt_static_did.iter().advance |&did| {\n+    foreach &did in opt_static_did.iter() {\n         {\n             let r = cx.ccx.tcx.node_type_substs.find_copy(&callee_id);\n-            for r.iter().advance |ts| {\n+            foreach ts in r.iter() {\n                 let type_uses = type_uses_for(cx.ccx, did, ts.len());\n-                for type_uses.iter().zip(ts.iter()).advance |(uses, subst)| {\n+                foreach (uses, subst) in type_uses.iter().zip(ts.iter()) {\n                     type_needs(cx, *uses, *subst)\n                 }\n             }\n@@ -329,10 +329,10 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n       }\n       expr_path(_) | expr_self => {\n         let opt_ts = cx.ccx.tcx.node_type_substs.find_copy(&e.id);\n-        for opt_ts.iter().advance |ts| {\n+        foreach ts in opt_ts.iter() {\n             let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get_copy(&e.id));\n             let uses_for_ts = type_uses_for(cx.ccx, id, ts.len());\n-            for uses_for_ts.iter().zip(ts.iter()).advance |(uses, subst)| {\n+            foreach (uses, subst) in uses_for_ts.iter().zip(ts.iter()) {\n                 type_needs(cx, *uses, *subst)\n             }\n         }\n@@ -341,7 +341,7 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n           match ty::ty_closure_sigil(ty::expr_ty(cx.ccx.tcx, e)) {\n               ast::OwnedSigil => {}\n               ast::BorrowedSigil | ast::ManagedSigil => {\n-                  for freevars::get_freevars(cx.ccx.tcx, e.id).iter().advance |fv| {\n+                  foreach fv in freevars::get_freevars(cx.ccx.tcx, e.id).iter() {\n                       let node_id = ast_util::def_id_of_def(fv.def).node;\n                       node_type_needs(cx, use_repr, node_id);\n                   }\n@@ -372,7 +372,7 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n       }\n       expr_call(f, _, _) => {\n           let r = ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id));\n-          for r.iter().advance |a| {\n+          foreach a in r.iter() {\n               type_needs(cx, use_repr, *a);\n           }\n       }\n@@ -381,17 +381,17 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n \n         let r = ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, callee_id));\n-        for r.iter().advance |a| {\n+        foreach a in r.iter() {\n             type_needs(cx, use_repr, *a);\n         }\n         mark_for_method_call(cx, e.id, callee_id);\n       }\n \n       expr_inline_asm(ref ia) => {\n-        for ia.inputs.iter().advance |&(_, input)| {\n+        foreach &(_, input) in ia.inputs.iter() {\n           node_type_needs(cx, use_repr, input.id);\n         }\n-        for ia.outputs.iter().advance |&(_, out)| {\n+        foreach &(_, out) in ia.outputs.iter() {\n           node_type_needs(cx, use_repr, out.id);\n         }\n       }\n@@ -423,7 +423,7 @@ pub fn handle_body(cx: &Context, body: &Block) {\n         },\n         visit_block: |b, (cx, v)| {\n             visit::visit_block(b, (cx, v));\n-            for b.expr.iter().advance |e| {\n+            foreach e in b.expr.iter() {\n                 node_type_needs(cx, use_repr, e.id);\n             }\n         },"}, {"sha": "1215097025fb184a6da5340af8814321a5134835", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -959,11 +959,11 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n     }\n     fn sflags(substs: &substs) -> uint {\n         let mut f = 0u;\n-        for substs.tps.iter().advance |tt| { f |= get(*tt).flags; }\n+        foreach tt in substs.tps.iter() { f |= get(*tt).flags; }\n         match substs.regions {\n             ErasedRegions => {}\n             NonerasedRegions(ref regions) => {\n-                for regions.iter().advance |r| {\n+                foreach r in regions.iter() {\n                     f |= rflags(*r)\n                 }\n             }\n@@ -1005,16 +1005,16 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n         flags |= rflags(r);\n         flags |= get(m.ty).flags;\n       }\n-      &ty_tup(ref ts) => for ts.iter().advance |tt| { flags |= get(*tt).flags; },\n+      &ty_tup(ref ts) => foreach tt in ts.iter() { flags |= get(*tt).flags; },\n       &ty_bare_fn(ref f) => {\n-        for f.sig.inputs.iter().advance |a| { flags |= get(*a).flags; }\n-         flags |= get(f.sig.output).flags;\n-         // T -> _|_ is *not* _|_ !\n-         flags &= !(has_ty_bot as uint);\n+        foreach a in f.sig.inputs.iter() { flags |= get(*a).flags; }\n+        flags |= get(f.sig.output).flags;\n+        // T -> _|_ is *not* _|_ !\n+        flags &= !(has_ty_bot as uint);\n       }\n       &ty_closure(ref f) => {\n         flags |= rflags(f.region);\n-        for f.sig.inputs.iter().advance |a| { flags |= get(*a).flags; }\n+        foreach a in f.sig.inputs.iter() { flags |= get(*a).flags; }\n         flags |= get(f.sig.output).flags;\n         // T -> _|_ is *not* _|_ !\n         flags &= !(has_ty_bot as uint);\n@@ -1269,15 +1269,15 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n       }\n       ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n       ty_trait(_, ref substs, _, _, _) => {\n-        for (*substs).tps.iter().advance |subty| { maybe_walk_ty(*subty, |x| f(x)); }\n+        foreach subty in (*substs).tps.iter() { maybe_walk_ty(*subty, |x| f(x)); }\n       }\n-      ty_tup(ref ts) => { for ts.iter().advance |tt| { maybe_walk_ty(*tt, |x| f(x)); } }\n+      ty_tup(ref ts) => { foreach tt in ts.iter() { maybe_walk_ty(*tt, |x| f(x)); } }\n       ty_bare_fn(ref ft) => {\n-        for ft.sig.inputs.iter().advance |a| { maybe_walk_ty(*a, |x| f(x)); }\n+        foreach a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n       ty_closure(ref ft) => {\n-        for ft.sig.inputs.iter().advance |a| { maybe_walk_ty(*a, |x| f(x)); }\n+        foreach a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n     }\n@@ -1766,8 +1766,8 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n             true\n           }\n           ty_enum(did, ref substs) => {\n-            for (*enum_variants(cx, did)).iter().advance |v| {\n-                for v.args.iter().advance |aty| {\n+            foreach v in (*enum_variants(cx, did)).iter() {\n+                foreach aty in v.args.iter() {\n                     let t = subst(cx, substs, *aty);\n                     needs_unwind_cleanup |=\n                         type_needs_unwind_cleanup_(cx, t, tycache,\n@@ -2435,8 +2435,8 @@ pub fn type_structurally_contains(cx: ctxt,\n     if test(sty) { return true; }\n     match *sty {\n       ty_enum(did, ref substs) => {\n-        for (*enum_variants(cx, did)).iter().advance |variant| {\n-            for variant.args.iter().advance |aty| {\n+        foreach variant in (*enum_variants(cx, did)).iter() {\n+            foreach aty in variant.args.iter() {\n                 let sty = subst(cx, substs, *aty);\n                 if type_structurally_contains(cx, sty, |x| test(x)) { return true; }\n             }\n@@ -2445,15 +2445,15 @@ pub fn type_structurally_contains(cx: ctxt,\n       }\n       ty_struct(did, ref substs) => {\n         let r = lookup_struct_fields(cx, did);\n-        for r.iter().advance |field| {\n+        foreach field in r.iter() {\n             let ft = lookup_field_type(cx, did, field.id, substs);\n             if type_structurally_contains(cx, ft, |x| test(x)) { return true; }\n         }\n         return false;\n       }\n \n       ty_tup(ref ts) => {\n-        for ts.iter().advance |tt| {\n+        foreach tt in ts.iter() {\n             if type_structurally_contains(cx, *tt, |x| test(x)) { return true; }\n         }\n         return false;\n@@ -2532,7 +2532,7 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       // Structural types\n       ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n-        for (*variants).iter().advance |variant| {\n+        foreach variant in (*variants).iter() {\n             // XXX(pcwalton): This is an inefficient way to do this. Don't\n             // synthesize a tuple!\n             //\n@@ -2543,7 +2543,7 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n         }\n       }\n       ty_tup(ref elts) => {\n-        for elts.iter().advance |elt| { if !type_is_pod(cx, *elt) { result = false; } }\n+        foreach elt in elts.iter() { if !type_is_pod(cx, *elt) { result = false; } }\n       }\n       ty_estr(vstore_fixed(_)) => result = true,\n       ty_evec(ref mt, vstore_fixed(_)) | ty_unboxed_vec(ref mt) => {\n@@ -3273,14 +3273,14 @@ pub fn stmt_node_id(s: &ast::stmt) -> ast::NodeId {\n \n pub fn field_idx(id: ast::ident, fields: &[field]) -> Option<uint> {\n     let mut i = 0u;\n-    for fields.iter().advance |f| { if f.ident == id { return Some(i); } i += 1u; }\n+    foreach f in fields.iter() { if f.ident == id { return Some(i); } i += 1u; }\n     return None;\n }\n \n pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n-    for fields.iter().advance |f| { if f.ident == id { return i; } i += 1u; }\n+    foreach f in fields.iter() { if f.ident == id { return i; } i += 1u; }\n     tcx.sess.bug(fmt!(\n         \"No field named `%s` found in the list of fields `%?`\",\n         tcx.sess.str_of(id),\n@@ -4383,7 +4383,7 @@ pub fn determine_inherited_purity(parent: (ast::purity, ast::NodeId),\n pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n                                         bounds: &[@TraitRef],\n                                         f: &fn(@TraitRef) -> bool) -> bool {\n-    for bounds.iter().advance |&bound_trait_ref| {\n+    foreach &bound_trait_ref in bounds.iter() {\n         let mut supertrait_set = HashMap::new();\n         let mut trait_refs = ~[];\n         let mut i = 0;\n@@ -4403,7 +4403,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n \n             // Add supertraits to supertrait_set\n             let supertrait_refs = trait_ref_supertraits(tcx, trait_refs[i]);\n-            for supertrait_refs.iter().advance |&supertrait_ref| {\n+            foreach &supertrait_ref in supertrait_refs.iter() {\n                 debug!(\"each_bound_trait_and_supertraits(supertrait_ref=%s)\",\n                        supertrait_ref.repr(tcx));\n \n@@ -4424,7 +4424,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n pub fn count_traits_and_supertraits(tcx: ctxt,\n                                     type_param_defs: &[TypeParameterDef]) -> uint {\n     let mut total = 0;\n-    for type_param_defs.iter().advance |type_param_def| {\n+    foreach type_param_def in type_param_defs.iter() {\n         for each_bound_trait_and_supertraits(\n             tcx, type_param_def.bounds.trait_bounds) |_| {\n             total += 1;"}, {"sha": "8a8b3a07c5d8b437f7e80c97a5b4f6e23c92b3f5", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -768,7 +768,7 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n     match (ast_bounds, store) {\n         (&Some(ref bound_vec), _) => {\n             let mut builtin_bounds = ty::EmptyBuiltinBounds();\n-            for bound_vec.iter().advance |ast_bound| {\n+            foreach ast_bound in bound_vec.iter() {\n                 match *ast_bound {\n                     ast::TraitTyParamBound(ref b) => {\n                         match lookup_def_tcx(tcx, b.path.span, b.ref_id) {"}, {"sha": "9555a58fff34722731b7eff7faf318f36b776241", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -35,13 +35,13 @@ pub fn check_match(fcx: @mut FnCtxt,\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n-    for arms.iter().advance |arm| {\n+    foreach arm in arms.iter() {\n         let pcx = pat_ctxt {\n             fcx: fcx,\n             map: pat_id_map(tcx.def_map, arm.pats[0]),\n         };\n \n-        for arm.pats.iter().advance |p| { check_pat(&pcx, *p, discrim_ty);}\n+        foreach p in arm.pats.iter() { check_pat(&pcx, *p, discrim_ty);}\n     }\n \n     // The result of the match is the common supertype of all the\n@@ -55,7 +55,7 @@ pub fn check_match(fcx: @mut FnCtxt,\n \n     // Now typecheck the blocks.\n     let mut saw_err = ty::type_is_error(discrim_ty);\n-    for arms.iter().advance |arm| {\n+    foreach arm in arms.iter() {\n         let mut guard_err = false;\n         let mut guard_bot = false;\n         match arm.guard {\n@@ -239,8 +239,8 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n         }\n \n         if !error_happened {\n-            for subpats.iter().advance |pats| {\n-                for pats.iter().zip(arg_types.iter()).advance |(subpat, arg_ty)| {\n+            foreach pats in subpats.iter() {\n+                foreach (subpat, arg_ty) in pats.iter().zip(arg_types.iter()) {\n                     check_pat(pcx, *subpat, *arg_ty);\n                 }\n             }\n@@ -256,8 +256,8 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n     }\n \n     if error_happened {\n-        for subpats.iter().advance |pats| {\n-            for pats.iter().advance |pat| {\n+        foreach pats in subpats.iter() {\n+            foreach pat in pats.iter() {\n                 check_pat(pcx, *pat, ty::mk_err());\n             }\n         }\n@@ -283,13 +283,13 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n \n     // Index the class fields.\n     let mut field_map = HashMap::new();\n-    for class_fields.iter().enumerate().advance |(i, class_field)| {\n+    foreach (i, class_field) in class_fields.iter().enumerate() {\n         field_map.insert(class_field.ident, i);\n     }\n \n     // Typecheck each field.\n     let mut found_fields = HashSet::new();\n-    for fields.iter().advance |field| {\n+    foreach field in fields.iter() {\n         match field_map.find(&field.ident) {\n             Some(&index) => {\n                 let class_field = class_fields[index];\n@@ -312,7 +312,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n \n     // Report an error if not all the fields were specified.\n     if !etc {\n-        for class_fields.iter().enumerate().advance |(i, field)| {\n+        foreach (i, field) in class_fields.iter().enumerate() {\n             if found_fields.contains(&i) {\n                 loop;\n             }\n@@ -518,13 +518,13 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         let e_count = elts.len();\n         match *s {\n             ty::ty_tup(ref ex_elts) if e_count == ex_elts.len() => {\n-                for elts.iter().enumerate().advance |(i, elt)| {\n+                foreach (i, elt) in elts.iter().enumerate() {\n                     check_pat(pcx, *elt, ex_elts[i]);\n                 }\n                 fcx.write_ty(pat.id, expected);\n             }\n             _ => {\n-                for elts.iter().advance |elt| {\n+                foreach elt in elts.iter() {\n                     check_pat(pcx, *elt, ty::mk_err());\n                 }\n                 // use terr_tuple_size if both types are tuples\n@@ -572,13 +572,13 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             (mt, default_region_var)\n           },\n           _ => {\n-              for before.iter().advance |&elt| {\n+              foreach &elt in before.iter() {\n                   check_pat(pcx, elt, ty::mk_err());\n               }\n-              for slice.iter().advance |&elt| {\n+              foreach &elt in slice.iter() {\n                   check_pat(pcx, elt, ty::mk_err());\n               }\n-              for after.iter().advance |&elt| {\n+              foreach &elt in after.iter() {\n                   check_pat(pcx, elt, ty::mk_err());\n               }\n               fcx.infcx().type_error_message_str_with_expected(\n@@ -594,7 +594,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n               return;\n           }\n         };\n-        for before.iter().advance |elt| {\n+        foreach elt in before.iter() {\n             check_pat(pcx, *elt, elt_type.ty);\n         }\n         match slice {\n@@ -607,7 +607,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             }\n             None => ()\n         }\n-        for after.iter().advance |elt| {\n+        foreach elt in after.iter() {\n             check_pat(pcx, *elt, elt_type.ty);\n         }\n         fcx.write_ty(pat.id, expected);"}, {"sha": "51d454e45a0c4e109c766f3051b86455f0c28dd3", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -314,12 +314,12 @@ impl<'self> LookupContext<'self> {\n         // candidates.\n         let trait_map: &mut resolve::TraitMap = &mut self.fcx.ccx.trait_map;\n         let opt_applicable_traits = trait_map.find(&self.expr.id);\n-        for opt_applicable_traits.iter().advance |applicable_traits| {\n-            for applicable_traits.iter().advance |trait_did| {\n+        foreach applicable_traits in opt_applicable_traits.iter() {\n+            foreach trait_did in applicable_traits.iter() {\n                 // Look for explicit implementations.\n                 let opt_impl_infos = self.tcx().trait_impls.find(trait_did);\n-                for opt_impl_infos.iter().advance |impl_infos| {\n-                    for impl_infos.iter().advance |impl_info| {\n+                foreach impl_infos in opt_impl_infos.iter() {\n+                    foreach impl_info in impl_infos.iter() {\n                         self.push_candidates_from_impl(\n                             self.extension_candidates, *impl_info);\n \n@@ -464,8 +464,8 @@ impl<'self> LookupContext<'self> {\n \n     pub fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n         let opt_impl_infos = self.tcx().inherent_impls.find(&did);\n-        for opt_impl_infos.iter().advance |impl_infos| {\n-            for impl_infos.iter().advance |impl_info| {\n+        foreach impl_infos in opt_impl_infos.iter() {\n+            foreach impl_info in impl_infos.iter() {\n                 self.push_candidates_from_impl(\n                     self.inherent_candidates, *impl_info);\n             }\n@@ -711,7 +711,7 @@ impl<'self> LookupContext<'self> {\n         let region =\n             self.infcx().next_region_var(\n                 infer::Autoref(self.expr.span));\n-        for mutbls.iter().advance |mutbl| {\n+        foreach mutbl in mutbls.iter() {\n             let autoref_ty = mk_autoref_ty(*mutbl, region);\n             match self.search_for_method(autoref_ty) {\n                 None => {}"}, {"sha": "a8d1a1d49d75e99fba54b6db998b32df2d058f1b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -428,10 +428,10 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n       None => ()\n     }\n \n-    for opt_self_info.iter().advance |self_info| {\n+    foreach self_info in opt_self_info.iter() {\n         fcx.write_ty(self_info.self_id, self_info.self_ty);\n     }\n-    for decl.inputs.iter().zip(arg_tys.iter()).advance |(input, arg)| {\n+    foreach (input, arg) in decl.inputs.iter().zip(arg_tys.iter()) {\n         fcx.write_ty(input.id, *arg);\n     }\n \n@@ -460,15 +460,15 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         };\n \n         // Add the self parameter\n-        for opt_self_info.iter().advance |self_info| {\n+        foreach self_info in opt_self_info.iter() {\n             assign(self_info.self_id, Some(self_info.self_ty));\n             debug!(\"self is assigned to %s\",\n                    fcx.infcx().ty_to_str(\n                        fcx.inh.locals.get_copy(&self_info.self_id)));\n         }\n \n         // Add formal parameters.\n-        for arg_tys.iter().zip(decl.inputs.iter()).advance |(arg_ty, input)| {\n+        foreach (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n             do pat_util::pat_bindings(tcx.def_map, input.pat)\n                     |_bm, pat_id, _sp, _path| {\n@@ -566,7 +566,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n                                  fields: ~[(ast::ident, span)]) {\n     let mut field_names = HashMap::new();\n \n-    for fields.iter().advance |p| {\n+    foreach p in fields.iter() {\n         let (id, sp) = *p;\n         let orig_sp = field_names.find(&id).map_consume(|x| *x);\n         match orig_sp {\n@@ -615,13 +615,13 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n         debug!(\"item_impl %s with id %d rp %?\",\n                ccx.tcx.sess.str_of(it.ident), it.id, rp);\n-        for ms.iter().advance |m| {\n+        foreach m in ms.iter() {\n             check_method(ccx, *m);\n         }\n         vtable::resolve_impl(ccx, it);\n       }\n       ast::item_trait(_, _, ref trait_methods) => {\n-        for (*trait_methods).iter().advance |trait_method| {\n+        foreach trait_method in (*trait_methods).iter() {\n             match *trait_method {\n               required(*) => {\n                 // Nothing to do, since required methods don't have\n@@ -642,11 +642,11 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       }\n       ast::item_foreign_mod(ref m) => {\n         if m.abis.is_intrinsic() {\n-            for m.items.iter().advance |item| {\n+            foreach item in m.items.iter() {\n                 check_intrinsic_type(ccx, *item);\n             }\n         } else {\n-            for m.items.iter().advance |item| {\n+            foreach item in m.items.iter() {\n                 let tpt = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n                 if tpt.generics.has_type_params() {\n                     ccx.tcx.sess.span_err(\n@@ -1257,7 +1257,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // of arguments when we typecheck the functions. This isn't really the\n         // right way to do this.\n         let xs = [false, true];\n-        for xs.iter().advance |check_blocks| {\n+        foreach check_blocks in xs.iter() {\n             let check_blocks = *check_blocks;\n             debug!(\"check_blocks=%b\", check_blocks);\n \n@@ -1268,7 +1268,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 vtable::early_resolve_expr(callee_expr, fcx, true);\n             }\n \n-            for args.iter().enumerate().advance |(i, arg)| {\n+            foreach (i, arg) in args.iter().enumerate() {\n                 let is_block = match arg.node {\n                     ast::expr_fn_block(*) | ast::expr_loop_body(*) |\n                     ast::expr_do_body(*) => true,\n@@ -1883,14 +1883,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         let mut class_field_map = HashMap::new();\n         let mut fields_found = 0;\n-        for field_types.iter().advance |field| {\n+        foreach field in field_types.iter() {\n             class_field_map.insert(field.ident, (field.id, false));\n         }\n \n         let mut error_happened = false;\n \n         // Typecheck each field.\n-        for ast_fields.iter().advance |field| {\n+        foreach field in ast_fields.iter() {\n             let mut expected_field_type = ty::mk_err();\n \n             let pair = class_field_map.find(&field.ident).\n@@ -1936,7 +1936,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             assert!(fields_found <= field_types.len());\n             if fields_found < field_types.len() {\n                 let mut missing_fields = ~[];\n-                for field_types.iter().advance |class_field| {\n+                foreach class_field in field_types.iter() {\n                     let name = class_field.ident;\n                     let (_, seen) = *class_field_map.get(&name);\n                     if !seen {\n@@ -2258,7 +2258,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 _ => mutability = mutbl\n             }\n             let t: ty::t = fcx.infcx().next_ty_var();\n-            for args.iter().advance |e| {\n+            foreach e in args.iter() {\n                 check_expr_has_type(fcx, *e, t);\n                 let arg_t = fcx.expr_ty(*e);\n                 if ty::type_is_error(arg_t) {\n@@ -2478,10 +2478,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, ty_param_bounds_and_ty.ty);\n       }\n       ast::expr_inline_asm(ref ia) => {\n-          for ia.inputs.iter().advance |&(_, input)| {\n+          foreach &(_, input) in ia.inputs.iter() {\n               check_expr(fcx, input);\n           }\n-          for ia.outputs.iter().advance |&(_, out)| {\n+          foreach &(_, out) in ia.outputs.iter() {\n               check_expr(fcx, out);\n           }\n           fcx.write_nil(id);\n@@ -2748,7 +2748,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let t: ty::t = fcx.infcx().next_ty_var();\n         let mut arg_is_bot = false;\n         let mut arg_is_err = false;\n-        for args.iter().advance |e| {\n+        foreach e in args.iter() {\n             check_expr_has_type(fcx, *e, t);\n             let arg_t = fcx.expr_ty(*e);\n             arg_is_bot |= ty::type_is_bot(arg_t);\n@@ -3009,7 +3009,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n         let mut last_was_bot = false;\n         let mut any_bot = false;\n         let mut any_err = false;\n-        for blk.stmts.iter().advance |s| {\n+        foreach s in blk.stmts.iter() {\n             check_stmt(fcx, *s);\n             let s_id = ast_util::stmt_id(*s);\n             let s_ty = fcx.node_ty(s_id);\n@@ -3148,7 +3148,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n         let mut disr_vals: ~[uint] = ~[];\n         let mut prev_disr_val: Option<uint> = None;\n \n-        for vs.iter().advance |v| {\n+        foreach v in vs.iter() {\n \n             // If the discriminant value is specified explicitly in the enum check whether the\n             // initialization expression is valid, otherwise use the last value plus one.\n@@ -3476,7 +3476,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n             true\n         });\n \n-    for tps_used.iter().enumerate().advance |(i, b)| {\n+    foreach (i, b) in tps_used.iter().enumerate() {\n         if !*b {\n             ccx.tcx.sess.span_err(\n                 span, fmt!(\"type parameter `%s` is unused\","}, {"sha": "d09ca1c25e4887d797c20f369561db6cf71a6681", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -194,7 +194,7 @@ fn visit_block(b: &ast::Block, (rcx, v): (@mut Rcx, rvt)) {\n \n fn visit_arm(arm: &ast::arm, (rcx, v): (@mut Rcx, rvt)) {\n     // see above\n-    for arm.pats.iter().advance |&p| {\n+    foreach &p in arm.pats.iter() {\n         constrain_bindings_in_pat(p, rcx);\n     }\n \n@@ -280,8 +280,8 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n         }\n         ast::expr_match(_, ref arms) => {\n             tcx.region_maps.record_cleanup_scope(expr.id);\n-            for arms.iter().advance |arm| {\n-                for arm.guard.iter().advance |guard| {\n+            foreach arm in arms.iter() {\n+                foreach guard in arm.guard.iter() {\n                     tcx.region_maps.record_cleanup_scope(guard.id);\n                 }\n             }\n@@ -299,15 +299,15 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n     // Check any autoderefs or autorefs that appear.\n     {\n         let r = rcx.fcx.inh.adjustments.find(&expr.id);\n-        for r.iter().advance |&adjustment| {\n+        foreach &adjustment in r.iter() {\n             debug!(\"adjustment=%?\", adjustment);\n             match *adjustment {\n                 @ty::AutoDerefRef(\n                     ty::AutoDerefRef {autoderefs: autoderefs, autoref: opt_autoref}) =>\n                 {\n                     let expr_ty = rcx.resolve_node_type(expr.id);\n                     constrain_derefs(rcx, expr, autoderefs, expr_ty);\n-                    for opt_autoref.iter().advance |autoref| {\n+                    foreach autoref in opt_autoref.iter() {\n                         guarantor::for_autoref(rcx, expr, autoderefs, autoref);\n \n                         // Require that the resulting region encompasses\n@@ -555,7 +555,7 @@ fn constrain_call(rcx: @mut Rcx,\n     let callee_scope = call_expr.id;\n     let callee_region = ty::re_scope(callee_scope);\n \n-    for arg_exprs.iter().advance |&arg_expr| {\n+    foreach &arg_expr in arg_exprs.iter() {\n         // ensure that any regions appearing in the argument type are\n         // valid for at least the lifetime of the function:\n         constrain_regions_in_type_of_node(\n@@ -572,7 +572,7 @@ fn constrain_call(rcx: @mut Rcx,\n     }\n \n     // as loop above, but for receiver\n-    for receiver.iter().advance |&r| {\n+    foreach &r in receiver.iter() {\n         constrain_regions_in_type_of_node(\n             rcx, r.id, callee_region, infer::CallRcvr(r.span));\n         if implicitly_ref_args {\n@@ -668,7 +668,7 @@ fn constrain_free_variables(rcx: @mut Rcx,\n     let tcx = rcx.fcx.ccx.tcx;\n     debug!(\"constrain_free_variables(%s, %s)\",\n            region.repr(tcx), expr.repr(tcx));\n-    for get_freevars(tcx, expr.id).iter().advance |freevar| {\n+    foreach freevar in get_freevars(tcx, expr.id).iter() {\n         debug!(\"freevar def is %?\", freevar.def);\n         let def = freevar.def;\n         let en_region = encl_region_of_def(rcx.fcx, def);\n@@ -835,8 +835,8 @@ pub mod guarantor {\n         debug!(\"regionck::for_match()\");\n         let discr_guarantor = guarantor(rcx, discr);\n         debug!(\"discr_guarantor=%s\", discr_guarantor.repr(rcx.tcx()));\n-        for arms.iter().advance |arm| {\n-            for arm.pats.iter().advance |pat| {\n+        foreach arm in arms.iter() {\n+            foreach pat in arm.pats.iter() {\n                 link_ref_bindings_in_pat(rcx, *pat, discr_guarantor);\n             }\n         }\n@@ -886,7 +886,7 @@ pub mod guarantor {\n             sub_region: ty::Region,\n             sup_region: Option<ty::Region>)\n         {\n-            for sup_region.iter().advance |r| {\n+            foreach r in sup_region.iter() {\n                 rcx.fcx.mk_subr(true, infer::Reborrow(expr.span),\n                                 sub_region, *r);\n             }\n@@ -909,7 +909,7 @@ pub mod guarantor {\n         debug!(\"guarantor::for_by_ref(expr=%?, callee_scope=%?) category=%?\",\n                expr.id, callee_scope, expr_cat);\n         let minimum_lifetime = ty::re_scope(callee_scope);\n-        for expr_cat.guarantor.iter().advance |guarantor| {\n+        foreach guarantor in expr_cat.guarantor.iter() {\n             mk_subregion_due_to_derefence(rcx, expr.span,\n                                           minimum_lifetime, *guarantor);\n         }\n@@ -1215,12 +1215,12 @@ pub mod guarantor {\n             ast::pat_ident(ast::bind_by_ref(_), _, opt_p) => {\n                 link(rcx, pat.span, pat.id, guarantor);\n \n-                for opt_p.iter().advance |p| {\n+                foreach p in opt_p.iter() {\n                     link_ref_bindings_in_pat(rcx, *p, guarantor);\n                 }\n             }\n             ast::pat_ident(_, _, opt_p) => {\n-                for opt_p.iter().advance |p| {\n+                foreach p in opt_p.iter() {\n                     link_ref_bindings_in_pat(rcx, *p, guarantor);\n                 }\n             }\n@@ -1229,7 +1229,7 @@ pub mod guarantor {\n                 link_ref_bindings_in_pats(rcx, pats, guarantor);\n             }\n             ast::pat_struct(_, ref fpats, _) => {\n-                for fpats.iter().advance |fpat| {\n+                foreach fpat in fpats.iter() {\n                     link_ref_bindings_in_pat(rcx, fpat.pat, guarantor);\n                 }\n             }\n@@ -1259,7 +1259,7 @@ pub mod guarantor {\n                 };\n \n                 link_ref_bindings_in_pats(rcx, before, guarantor1);\n-                for slice.iter().advance |&p| {\n+                foreach &p in slice.iter() {\n                     link_ref_bindings_in_pat(rcx, p, guarantor);\n                 }\n                 link_ref_bindings_in_pats(rcx, after, guarantor1);\n@@ -1270,7 +1270,7 @@ pub mod guarantor {\n     fn link_ref_bindings_in_pats(rcx: @mut Rcx,\n                                  pats: &~[@ast::pat],\n                                  guarantor: Option<ty::Region>) {\n-        for pats.iter().advance |pat| {\n+        foreach pat in pats.iter() {\n             link_ref_bindings_in_pat(rcx, *pat, guarantor);\n         }\n     }"}, {"sha": "cefe0045cb04eb7465c0ae30a8c0062126a062dd", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -32,11 +32,11 @@ pub fn replace_bound_regions_in_fn_sig(\n {\n     let mut all_tys = ty::tys_in_fn_sig(fn_sig);\n \n-    for opt_self_ty.iter().advance |&self_ty| {\n+    foreach &self_ty in opt_self_ty.iter() {\n         all_tys.push(self_ty);\n     }\n \n-    for opt_self_ty.iter().advance |&t| { all_tys.push(t) }\n+    foreach &t in opt_self_ty.iter() { all_tys.push(t) }\n \n     debug!(\"replace_bound_regions_in_fn_sig(self_ty=%?, fn_sig=%s, \\\n             all_tys=%?)\",\n@@ -199,7 +199,7 @@ pub fn relate_nested_regions(\n      */\n \n     let mut the_stack = ~[];\n-    for opt_region.iter().advance |&r| { the_stack.push(r); }\n+    foreach &r in opt_region.iter() { the_stack.push(r); }\n     walk_ty(tcx, &mut the_stack, ty, relate_op);\n \n     fn walk_ty(tcx: ty::ctxt,\n@@ -230,7 +230,7 @@ pub fn relate_nested_regions(\n               r_sub: ty::Region,\n               relate_op: &fn(ty::Region, ty::Region))\n     {\n-        for the_stack.iter().advance |&r| {\n+        foreach &r in the_stack.iter() {\n             if !r.is_bound() && !r_sub.is_bound() {\n                 relate_op(r, r_sub);\n             }\n@@ -258,14 +258,14 @@ pub fn relate_free_regions(\n     debug!(\"relate_free_regions >>\");\n \n     let mut all_tys = ~[];\n-    for fn_sig.inputs.iter().advance |arg| {\n+    foreach arg in fn_sig.inputs.iter() {\n         all_tys.push(*arg);\n     }\n-    for self_ty.iter().advance |&t| {\n+    foreach &t in self_ty.iter() {\n         all_tys.push(t);\n     }\n \n-    for all_tys.iter().advance |&t| {\n+    foreach &t in all_tys.iter() {\n         debug!(\"relate_free_regions(t=%s)\", ppaux::ty_to_str(tcx, t));\n         relate_nested_regions(tcx, None, t, |a, b| {\n             match (&a, &b) {"}, {"sha": "ec86945887e482af6421a288cc6d7bdf33308091", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -324,7 +324,7 @@ fn search_for_vtable(vcx: &VtableContext,\n     let impls = tcx.trait_impls.find(&trait_ref.def_id)\n         .map_default(@mut ~[], |x| **x);\n     // impls is the list of all impls in scope for trait_ref.\n-    for impls.iter().advance |im| {\n+    foreach im in impls.iter() {\n         // im is one specific impl of trait_ref.\n \n         // First, ensure we haven't processed this impl yet."}, {"sha": "b46df585b73d75481c54f6ee35f72e69d793aa3c", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -66,7 +66,7 @@ fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::NodeId) {\n         Some(mme) => {\n             {\n                 let r = resolve_type_vars_in_type(fcx, sp, mme.self_ty);\n-                for r.iter().advance |t| {\n+                foreach t in r.iter() {\n                     let method_map = fcx.ccx.method_map;\n                     let new_entry = method_map_entry { self_ty: *t, ..*mme };\n                     debug!(\"writeback::resolve_method_map_entry(id=%?, \\\n@@ -180,7 +180,7 @@ fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::NodeId)\n         write_ty_to_tcx(tcx, id, t);\n         for fcx.opt_node_ty_substs(id) |substs| {\n           let mut new_tps = ~[];\n-          for substs.tps.iter().advance |subst| {\n+          foreach subst in substs.tps.iter() {\n               match resolve_type_vars_in_type(fcx, sp, *subst) {\n                 Some(t) => new_tps.push(t),\n                 None => { wbcx.success = false; return None; }\n@@ -230,22 +230,22 @@ fn visit_expr(e: @ast::expr, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n     resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n     {\n         let r = e.get_callee_id();\n-        for r.iter().advance |callee_id| {\n+        foreach callee_id in r.iter() {\n             resolve_method_map_entry(wbcx.fcx, e.span, *callee_id);\n         }\n     }\n \n     resolve_vtable_map_entry(wbcx.fcx, e.span, e.id);\n     {\n         let r = e.get_callee_id();\n-        for r.iter().advance |callee_id| {\n+        foreach callee_id in r.iter() {\n             resolve_vtable_map_entry(wbcx.fcx, e.span, *callee_id);\n         }\n     }\n \n     match e.node {\n         ast::expr_fn_block(ref decl, _) => {\n-            for decl.inputs.iter().advance |input| {\n+            foreach input in decl.inputs.iter() {\n                 let _ = resolve_type_vars_for_node(wbcx, e.span, input.id);\n             }\n         }\n@@ -341,12 +341,12 @@ pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n     let wbcx = @mut WbCtxt { fcx: fcx, success: true };\n     let visit = mk_visitor();\n     (visit.visit_block)(blk, (wbcx, visit));\n-    for self_info.iter().advance |self_info| {\n+    foreach self_info in self_info.iter() {\n         resolve_type_vars_for_node(wbcx,\n                                    self_info.span,\n                                    self_info.self_id);\n     }\n-    for decl.inputs.iter().advance |arg| {\n+    foreach arg in decl.inputs.iter() {\n         (visit.visit_pat)(arg.pat, (wbcx, visit));\n         // Privacy needs the type for the whole pattern, not just each binding\n         if !pat_util::pat_is_binding(fcx.tcx().def_map, arg.pat) {"}, {"sha": "950c836e03210a0b8d56e729eb59fd4fca058734", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -243,7 +243,7 @@ impl CoherenceChecker {\n \n         let implementation = self.create_impl_from_item(item);\n \n-        for associated_traits.iter().advance |associated_trait| {\n+        foreach associated_trait in associated_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(\n                 self.crate_context.tcx, associated_trait.ref_id);\n             debug!(\"(checking implementation) adding impl for trait '%s', item '%s'\",\n@@ -290,7 +290,7 @@ impl CoherenceChecker {\n         let impl_poly_type = ty::lookup_item_type(tcx, impl_id);\n \n         let provided = ty::provided_trait_methods(tcx, trait_ref.def_id);\n-        for provided.iter().advance |trait_method| {\n+        foreach trait_method in provided.iter() {\n             // Synthesize an ID.\n             let new_id = parse::next_node_id(tcx.sess.parse_sess);\n             let new_did = local_def(new_id);\n@@ -409,7 +409,7 @@ impl CoherenceChecker {\n     pub fn iter_impls_of_trait(&self, trait_def_id: def_id, f: &fn(@Impl)) {\n         match self.crate_context.tcx.trait_impls.find(&trait_def_id) {\n             Some(impls) => {\n-                for impls.iter().advance |&im| {\n+                foreach &im in impls.iter() {\n                     f(im);\n                 }\n             }\n@@ -556,7 +556,7 @@ impl CoherenceChecker {\n         }\n \n         let r = ty::trait_methods(tcx, trait_did);\n-        for r.iter().advance |method| {\n+        foreach method in r.iter() {\n             debug!(\"checking for %s\", method.ident.repr(tcx));\n             if provided_names.contains(&method.ident) { loop; }\n \n@@ -612,11 +612,11 @@ impl CoherenceChecker {\n         match item.node {\n             item_impl(_, ref trait_refs, _, ref ast_methods) => {\n                 let mut methods = ~[];\n-                for ast_methods.iter().advance |ast_method| {\n+                foreach ast_method in ast_methods.iter() {\n                     methods.push(ty::method(tcx, local_def(ast_method.id)));\n                 }\n \n-                for trait_refs.iter().advance |trait_ref| {\n+                foreach trait_ref in trait_refs.iter() {\n                     let ty_trait_ref = ty::node_id_to_trait_ref(\n                         self.crate_context.tcx,\n                         trait_ref.ref_id);\n@@ -698,14 +698,14 @@ impl CoherenceChecker {\n         }\n \n         // Record all the trait methods.\n-        for associated_traits.iter().advance |trait_ref| {\n+        foreach trait_ref in associated_traits.iter() {\n               self.add_trait_impl(trait_ref.def_id, implementation);\n         }\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for implementation.methods.iter().advance |method| {\n-            for method.provided_source.iter().advance |source| {\n+        foreach method in implementation.methods.iter() {\n+            foreach source in method.provided_source.iter() {\n                 tcx.provided_method_sources.insert(method.def_id, *source);\n             }\n         }\n@@ -767,7 +767,7 @@ impl CoherenceChecker {\n             Some(found_impls) => impls = found_impls\n         }\n \n-        for impls.iter().advance |impl_info| {\n+        foreach impl_info in impls.iter() {\n             if impl_info.methods.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n                 loop;"}, {"sha": "63c14dd82883450d1753d1e5533df1bae2e49fcb", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -143,7 +143,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n-    for variants.iter().advance |variant| {\n+    foreach variant in variants.iter() {\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n \n@@ -208,7 +208,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n \n             // For each method, construct a suitable ty::Method and\n             // store it into the `tcx.methods` table:\n-            for ms.iter().advance |m| {\n+            foreach m in ms.iter() {\n                 let ty_method = @match m {\n                     &ast::required(ref m) => {\n                         ty_method_of_trait_method(\n@@ -395,7 +395,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n     let mut ty_trait_refs: ~[@ty::TraitRef] = ~[];\n-    for ast_trait_refs.iter().advance |ast_trait_ref| {\n+    foreach ast_trait_ref in ast_trait_refs.iter() {\n         let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, rp,\n                                               generics, self_ty);\n \n@@ -494,7 +494,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         return;\n     }\n \n-    for trait_m.generics.type_param_defs.iter().enumerate().advance |(i, trait_param_def)| {\n+    foreach (i, trait_param_def) in trait_m.generics.type_param_defs.iter().enumerate() {\n         // For each of the corresponding impl ty param's bounds...\n         let impl_param_def = &impl_m.generics.type_param_defs[i];\n \n@@ -558,10 +558,10 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // For both the trait and the impl, create an argument to\n     // represent the self argument (unless this is a static method).\n     // This argument will have the *transformed* self type.\n-    for trait_m.transformed_self_ty.iter().advance |&t| {\n+    foreach &t in trait_m.transformed_self_ty.iter() {\n         trait_fn_args.push(t);\n     }\n-    for impl_m.transformed_self_ty.iter().advance |&t| {\n+    foreach &t in impl_m.transformed_self_ty.iter() {\n         impl_fn_args.push(t);\n     }\n \n@@ -674,7 +674,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n     // Trait methods we don't implement must be default methods, but if not\n     // we'll catch it in coherence\n     let trait_ms = ty::trait_methods(tcx, trait_ref.def_id);\n-    for impl_ms.iter().advance |impl_m| {\n+    foreach impl_m in impl_ms.iter() {\n         match trait_ms.iter().find_(|trait_m| trait_m.ident == impl_m.mty.ident) {\n             Some(trait_m) => {\n                 let num_impl_tps = generics.ty_params.len();\n@@ -805,7 +805,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n                                  span: span,\n                                  generics: &ast::Generics,\n                                  thing: &'static str) {\n-    for generics.ty_params.iter().advance |ty_param| {\n+    foreach ty_param in generics.ty_params.iter() {\n         if ty_param.bounds.len() > 0 {\n             ccx.tcx.sess.span_err(\n                 span,\n@@ -858,7 +858,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n         let cms = convert_methods(ccx, it.id, *ms, selfty,\n                                   &i_ty_generics, generics,\n                                   parent_visibility);\n-        for opt_trait_ref.iter().advance |t| {\n+        foreach t in opt_trait_ref.iter() {\n             check_methods_against_trait(ccx, generics, rp, selfty, t, cms);\n         }\n       }\n@@ -912,7 +912,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members\n-    for struct_def.fields.iter().advance |f| {\n+    foreach f in struct_def.fields.iter() {\n        convert_field(ccx, rp, tpt.generics.type_param_defs, *f, generics);\n     }\n     let (_, substs) = mk_item_substs(ccx, generics, rp, None);\n@@ -1203,7 +1203,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n             builtin_bounds: ty::EmptyBuiltinBounds(),\n             trait_bounds: ~[]\n         };\n-        for ast_bounds.iter().advance |ast_bound| {\n+        foreach ast_bound in ast_bounds.iter() {\n             match *ast_bound {\n                 TraitTyParamBound(ref b) => {\n                     let ty = ty::mk_param(ccx.tcx, param_ty.idx, param_ty.def_id);"}, {"sha": "a59db0bfd9e21b28d15ae7b590ddb7ccffd5a64b", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -114,7 +114,7 @@ pub trait ErrorReporting {\n impl ErrorReporting for InferCtxt {\n     pub fn report_region_errors(@mut self,\n                                 errors: &OptVec<RegionResolutionError>) {\n-        for errors.iter().advance |error| {\n+        foreach error in errors.iter() {\n             match *error {\n                 ConcreteFailure(origin, sub, sup) => {\n                     self.report_concrete_failure(origin, sub, sup);"}, {"sha": "84a2215fbfef1c99f4340de5ac4d4c29c3741d87", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -219,7 +219,7 @@ impl Combine for Glb {\n             let mut a_r = None;\n             let mut b_r = None;\n             let mut only_new_vars = true;\n-            for tainted.iter().advance |r| {\n+            foreach r in tainted.iter() {\n                 if is_var_in_set(a_vars, *r) {\n                     if a_r.is_some() {\n                         return fresh_bound_variable(this);"}, {"sha": "e487ca03c862164548c2ee4c4f442fc29d790bd2", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -730,7 +730,7 @@ impl InferCtxt {\n                         fmt!(\"%s%s\", mk_msg(Some(self.ty_to_str(e)), actual_ty), error_str));\n                 }\n             }\n-            for err.iter().advance |err| {\n+            foreach err in err.iter() {\n                 ty::note_and_explain_type_err(self.tcx, *err)\n             }\n         }"}, {"sha": "500f8e4fe48060f238e32913face76408f634560", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -916,7 +916,7 @@ impl RegionVarBindings {\n         &self,\n         errors: &mut OptVec<RegionResolutionError>)\n     {\n-        for self.constraints.iter().advance |(constraint, _)| {\n+        foreach (constraint, _) in self.constraints.iter() {\n             let (sub, sup) = match *constraint {\n                 ConstrainVarSubVar(*) |\n                 ConstrainRegSubVar(*) |\n@@ -1032,7 +1032,7 @@ impl RegionVarBindings {\n         }\n         let dummy_idx = graph.add_node(());\n \n-        for self.constraints.iter().advance |(constraint, _)| {\n+        foreach (constraint, _) in self.constraints.iter() {\n             match *constraint {\n                 ConstrainVarSubVar(a_id, b_id) => {\n                     graph.add_edge(NodeIndex(a_id.to_uint()),\n@@ -1080,8 +1080,8 @@ impl RegionVarBindings {\n             return;\n         }\n \n-        for lower_bounds.iter().advance |lower_bound| {\n-            for upper_bounds.iter().advance |upper_bound| {\n+        foreach lower_bound in lower_bounds.iter() {\n+            foreach upper_bound in upper_bounds.iter() {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n                     errors.push(SubSupConflict(\n@@ -1122,8 +1122,8 @@ impl RegionVarBindings {\n             return;\n         }\n \n-        for upper_bounds.iter().advance |upper_bound_1| {\n-            for upper_bounds.iter().advance |upper_bound_2| {\n+        foreach upper_bound_1 in upper_bounds.iter() {\n+            foreach upper_bound_2 in upper_bounds.iter() {\n                 match self.glb_concrete_regions(upper_bound_1.region,\n                                                 upper_bound_2.region) {\n                   Ok(_) => {}\n@@ -1242,7 +1242,7 @@ impl RegionVarBindings {\n             changed = false;\n             iteration += 1;\n             debug!(\"---- %s Iteration #%u\", tag, iteration);\n-            for self.constraints.iter().advance |(constraint, _)| {\n+            foreach (constraint, _) in self.constraints.iter() {\n                 let edge_changed = body(constraint);\n                 if edge_changed {\n                     debug!(\"Updated due to constraint %s\","}, {"sha": "cb8f7ddb222da32dd8f318cfcff86a78764cd6ba", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -194,7 +194,7 @@ impl Combine for Sub {\n         for list::each(skol_isr) |pair| {\n             let (skol_br, skol) = *pair;\n             let tainted = self.infcx.region_vars.tainted(snapshot, skol);\n-            for tainted.iter().advance |tainted_region| {\n+            foreach tainted_region in tainted.iter() {\n                 // Each skolemized should only be relatable to itself\n                 // or new variables:\n                 match *tainted_region {"}, {"sha": "b8477149430fab8cfc52844f093684bfa0c5a4d8", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -79,7 +79,7 @@ fn setup_env(test_name: &str, source_string: &str) -> Env {\n \n impl Env {\n     pub fn create_region_hierarchy(&self, rh: &RH) {\n-        for rh.sub.iter().advance |child_rh| {\n+        foreach child_rh in rh.sub.iter() {\n             self.create_region_hierarchy(child_rh);\n             self.tcx.region_map.insert(child_rh.id, rh.id);\n         }\n@@ -109,7 +109,7 @@ impl Env {\n                       idx: uint,\n                       names: &[~str]) -> Option<ast::node_id> {\n             assert!(idx < names.len());\n-            for m.items.iter().advance |item| {\n+            foreach item in m.items.iter() {\n                 if self.tcx.sess.str_of(item.ident) == names[idx] {\n                     return search(self, *item, idx+1, names);\n                 }\n@@ -227,7 +227,7 @@ impl Env {\n \n         self.infcx.resolve_regions();\n         if self.err_messages.len() != exp_count {\n-            for self.err_messages.iter().advance |msg| {\n+            foreach msg in self.err_messages.iter() {\n                 debug!(\"Error encountered: %s\", *msg);\n             }\n             fmt!(\"Resolving regions encountered %u errors but expected %u!\","}, {"sha": "16740d3ce4e5ac0ef91788f8ef240d5fb2f99f3c", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -58,7 +58,7 @@ impl RegionParamNames {\n     }\n \n     fn has_ident(&self, ident: ast::ident) -> bool {\n-        for self.iter().advance |region_param_name| {\n+        foreach region_param_name in self.iter() {\n             if *region_param_name == ident {\n                 return true;\n             }\n@@ -76,7 +76,7 @@ impl RegionParamNames {\n                             opt_vec::Vec(new_lifetimes.map(|lt| lt.ident)));\n                     }\n                     opt_vec::Vec(ref mut existing_lifetimes) => {\n-                        for new_lifetimes.iter().advance |new_lifetime| {\n+                        foreach new_lifetime in new_lifetimes.iter() {\n                             existing_lifetimes.push(new_lifetime.ident);\n                         }\n                     }"}, {"sha": "a9531f33b5e5d9a11eed0c838fb6ecb394730829", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -152,7 +152,7 @@ Available lint options:\n     lint_dict.qsort();\n \n     let mut max_key = 0;\n-    for lint_dict.iter().advance |&(_, name)| {\n+    foreach &(_, name) in lint_dict.iter() {\n         max_key = num::max(name.len(), max_key);\n     }\n     fn padded(max: uint, s: &str) -> ~str {\n@@ -163,7 +163,7 @@ Available lint options:\n               padded(max_key, \"name\"), \"default\", \"meaning\");\n     printfln!(\"    %s  %7.7s  %s\\n\",\n               padded(max_key, \"----\"), \"-------\", \"-------\");\n-    for lint_dict.consume_iter().advance |(spec, name)| {\n+    foreach (spec, name) in lint_dict.consume_iter() {\n         let name = name.replace(\"_\", \"-\");\n         printfln!(\"    %s  %7.7s  %s\",\n                   padded(max_key, name),\n@@ -176,7 +176,7 @@ Available lint options:\n pub fn describe_debug_flags() {\n     printfln!(\"\\nAvailable debug options:\\n\");\n     let r = session::debugging_opts_map();\n-    for r.iter().advance |tuple| {\n+    foreach tuple in r.iter() {\n         match *tuple {\n             (ref name, ref desc, _) => {\n                 printfln!(\"    -Z %-20s -- %s\", *name, *desc);\n@@ -350,7 +350,7 @@ pub fn monitor(f: ~fn(diagnostic::Emitter)) {\n                      to get further details and report the results \\\n                      to github.com/mozilla/rust/issues\"\n                 ];\n-                for xs.iter().advance |note| {\n+                foreach note in xs.iter() {\n                     diagnostic::emit(None, *note, diagnostic::note)\n                 }\n             }"}, {"sha": "595748390ebfdb1c4eec23ac25a597f8f29dad9c", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -398,7 +398,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     }\n \n     // if there is an id, print that instead of the structural type:\n-    /*for ty::type_def_id(typ).iter().advance |def_id| {\n+    /*foreach def_id in ty::type_def_id(typ).iter() {\n         // note that this typedef cannot have type parameters\n         return ast_map::path_to_str(ty::item_path(cx, *def_id),\n                                     cx.sess.intr());\n@@ -484,13 +484,13 @@ pub fn parameterized(cx: ctxt,\n     match *regions {\n         ty::ErasedRegions => { }\n         ty::NonerasedRegions(ref regions) => {\n-            for regions.iter().advance |&r| {\n+            foreach &r in regions.iter() {\n                 strs.push(region_to_str(cx, \"\", false, r))\n             }\n         }\n     }\n \n-    for tps.iter().advance |t| {\n+    foreach t in tps.iter() {\n         strs.push(ty_to_str(cx, *t))\n     }\n \n@@ -597,7 +597,7 @@ impl Repr for ty::ParamBounds {\n                 ty::BoundSized => ~\"Sized\",\n             });\n         }\n-        for self.trait_bounds.iter().advance |t| {\n+        foreach t in self.trait_bounds.iter() {\n             res.push(t.repr(tcx));\n         }\n         res.connect(\"+\")\n@@ -846,7 +846,7 @@ impl UserString for ty::TraitRef {\n         let base = ast_map::path_to_str(path, tcx.sess.intr());\n         if tcx.sess.verbose() && self.substs.self_ty.is_some() {\n             let mut all_tps = self.substs.tps.clone();\n-            for self.substs.self_ty.iter().advance |&t| { all_tps.push(t); }\n+            foreach &t in self.substs.self_ty.iter() { all_tps.push(t); }\n             parameterized(tcx, base, &self.substs.regions, all_tps)\n         } else {\n             parameterized(tcx, base, &self.substs.regions, self.substs.tps)"}, {"sha": "3cc243d6917886f6543a7892aa27be8d0602e5ab", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -73,7 +73,7 @@ pub fn usage() {\n     println(\"Usage: rustdoc [options] <cratefile>\\n\");\n     println(\"Options:\\n\");\n     let r = opts();\n-    for r.iter().advance |opt| {\n+    foreach opt in r.iter() {\n         printfln!(\"    %s\", opt.second());\n     }\n     println(\"\");"}, {"sha": "3e608fc6ef89eda08219993cff234069a04b7463", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -142,7 +142,7 @@ fn nmoddoc_from_mod(\n     module_: ast::foreign_mod\n ) -> doc::NmodDoc {\n     let mut fns = ~[];\n-    for module_.items.iter().advance |item| {\n+    foreach item in module_.items.iter() {\n         let ItemDoc = mk_itemdoc(item.id, to_str(item.ident));\n         match item.node {\n           ast::foreign_item_fn(*) => {"}, {"sha": "0706cd98e5816414a5bb291f2865c00c9976b72c", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -189,7 +189,7 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n             };\n             let self_ty = doc.self_ty.get_ref();\n             let mut trait_part = ~\"\";\n-            for doc.trait_types.iter().enumerate().advance |(i, trait_type)| {\n+            foreach (i, trait_type) in doc.trait_types.iter().enumerate() {\n                 if i == 0 {\n                     trait_part.push_str(\" of \");\n                 } else {\n@@ -279,7 +279,7 @@ fn write_desc(\n }\n \n fn write_sections(ctxt: &Ctxt, sections: &[doc::Section]) {\n-    for sections.iter().advance |section| {\n+    foreach section in sections.iter() {\n         write_section(ctxt, (*section).clone());\n     }\n }\n@@ -299,7 +299,7 @@ fn write_mod_contents(\n         write_index(ctxt, doc.index.get_ref());\n     }\n \n-    for doc.items.iter().advance |itemTag| {\n+    foreach itemTag in doc.items.iter() {\n         write_item(ctxt, (*itemTag).clone());\n     }\n }\n@@ -349,7 +349,7 @@ fn write_index(ctxt: &Ctxt, index: &doc::Index) {\n     ctxt.w.put_line(~\"<div class='index'>\");\n     ctxt.w.put_line(~\"\");\n \n-    for index.entries.iter().advance |entry| {\n+    foreach entry in index.entries.iter() {\n         let header = header_text_(entry.kind, entry.name);\n         let id = entry.link.clone();\n         if entry.brief.is_some() {\n@@ -370,7 +370,7 @@ fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n         write_index(ctxt, doc.index.get_ref());\n     }\n \n-    for doc.fns.iter().advance |FnDoc| {\n+    foreach FnDoc in doc.fns.iter() {\n         write_item_header(ctxt, doc::FnTag((*FnDoc).clone()));\n         write_fn(ctxt, (*FnDoc).clone());\n     }\n@@ -435,7 +435,7 @@ fn write_variants(\n \n     write_header_(ctxt, H4, ~\"Variants\");\n \n-    for docs.iter().advance |variant| {\n+    foreach variant in docs.iter() {\n         write_variant(ctxt, (*variant).clone());\n     }\n \n@@ -474,7 +474,7 @@ fn write_trait(ctxt: &Ctxt, doc: doc::TraitDoc) {\n }\n \n fn write_methods(ctxt: &Ctxt, docs: &[doc::MethodDoc]) {\n-    for docs.iter().advance |doc| {\n+    foreach doc in docs.iter() {\n         write_method(ctxt, (*doc).clone());\n     }\n }"}, {"sha": "da73027a4abc01620d93a27cf450ae3971671dc3", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -18,8 +18,6 @@ use fold::Fold;\n use fold;\n use pass::Pass;\n \n-use std::iterator::IteratorUtil;\n-\n pub fn mk_pass() -> Pass {\n     Pass {\n         name: ~\"sectionalize\",\n@@ -108,7 +106,7 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n     let mut current_section: Option<doc::Section> = None;\n     let mut sections = ~[];\n \n-    for desc.get_ref().any_line_iter().advance |line| {\n+    foreach line in desc.get_ref().any_line_iter() {\n         match parse_header(line) {\n           Some(header) => {\n             if current_section.is_some() {"}, {"sha": "40390d67a0dae29219cba04b931ecf74a87d7ff5", "filename": "src/librusti/program.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -98,7 +98,7 @@ impl Program {\n \n         code.push_str(\"fn main() {\\n\");\n         // It's easy to initialize things if we don't run things...\n-        for self.local_vars.iter().advance |(name, var)| {\n+        foreach (name, var) in self.local_vars.iter() {\n             let mt = var.mt();\n             code.push_str(fmt!(\"let%s %s: %s = fail!();\\n\", mt, *name, var.ty));\n             var.alter(*name, &mut code);\n@@ -114,7 +114,7 @@ impl Program {\n             None => {}\n         }\n \n-        for new_locals.iter().advance |p| {\n+        foreach p in new_locals.iter() {\n             code.push_str(fmt!(\"assert_encodable(&%s);\\n\", *p.first_ref()));\n         }\n         code.push_str(\"};}\");\n@@ -146,7 +146,7 @@ impl Program {\n \n         // Using this __tls_map handle, deserialize each variable binding that\n         // we know about\n-        for self.local_vars.iter().advance |(name, var)| {\n+        foreach (name, var) in self.local_vars.iter() {\n             let mt = var.mt();\n             code.push_str(fmt!(\"let%s %s: %s = {\n                 let data = __tls_map.get_copy(&~\\\"%s\\\");\n@@ -167,13 +167,13 @@ impl Program {\n         }\n \n         let newvars = util::replace(&mut self.newvars, HashMap::new());\n-        for newvars.consume().advance |(name, var)| {\n+        foreach (name, var) in newvars.consume() {\n             self.local_vars.insert(name, var);\n         }\n \n         // After the input code is run, we can re-serialize everything back out\n         // into tls map (to be read later on by this task)\n-        for self.local_vars.iter().advance |(name, var)| {\n+        foreach (name, var) in self.local_vars.iter() {\n             code.push_str(fmt!(\"{\n                 let local: %s = %s;\n                 let bytes = do ::std::io::with_bytes_writer |io| {\n@@ -221,7 +221,7 @@ impl Program {\n     /// program starts\n     pub fn set_cache(&self) {\n         let map = @mut HashMap::new();\n-        for self.local_vars.iter().advance |(name, value)| {\n+        foreach (name, value) in self.local_vars.iter() {\n             map.insert((*name).clone(), @(value.data).clone());\n         }\n         local_data::set(tls_key, map);\n@@ -233,7 +233,7 @@ impl Program {\n     pub fn consume_cache(&mut self) {\n         let map = local_data::pop(tls_key).expect(\"tls is empty\");\n         let cons_map = util::replace(map, HashMap::new());\n-        for cons_map.consume().advance |(name, value)| {\n+        foreach (name, value) in cons_map.consume() {\n             match self.local_vars.find_mut(&name) {\n                 Some(v) => { v.data = (*value).clone(); }\n                 None => { fail!(\"unknown variable %s\", name) }\n@@ -345,14 +345,14 @@ impl Program {\n \n         // I'm not an @ pointer, so this has to be done outside.\n         let cons_newvars = util::replace(newvars, HashMap::new());\n-        for cons_newvars.consume().advance |(k, v)| {\n+        foreach (k, v) in cons_newvars.consume() {\n             self.newvars.insert(k, v);\n         }\n \n         // helper functions to perform ast iteration\n         fn each_user_local(blk: &ast::Block, f: &fn(@ast::Local)) {\n             do find_user_block(blk) |blk| {\n-                for blk.stmts.iter().advance |stmt| {\n+                foreach stmt in blk.stmts.iter() {\n                     match stmt.node {\n                         ast::stmt_decl(d, _) => {\n                             match d.node {\n@@ -367,7 +367,7 @@ impl Program {\n         }\n \n         fn find_user_block(blk: &ast::Block, f: &fn(&ast::Block)) {\n-            for blk.stmts.iter().advance |stmt| {\n+            foreach stmt in blk.stmts.iter() {\n                 match stmt.node {\n                     ast::stmt_semi(e, _) => {\n                         match e.node {"}, {"sha": "58732a7a96a818990b609f075ac5d09878497d26", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -149,7 +149,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     do find_main(crate, sess) |blk| {\n         // Fish out all the view items, be sure to record 'extern mod' items\n         // differently beause they must appear before all 'use' statements\n-        for blk.view_items.iter().advance |vi| {\n+        foreach vi in blk.view_items.iter() {\n             let s = do with_pp(intr) |pp, _| {\n                 pprust::print_view_item(pp, vi);\n             };\n@@ -163,7 +163,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n \n         // Iterate through all of the block's statements, inserting them into\n         // the correct portions of the program\n-        for blk.stmts.iter().advance |stmt| {\n+        foreach stmt in blk.stmts.iter() {\n             let s = do with_pp(intr) |pp, _| { pprust::print_stmt(pp, *stmt); };\n             match stmt.node {\n                 ast::stmt_decl(d, _) => {\n@@ -276,7 +276,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n \n     fn find_main(crate: @ast::Crate, sess: session::Session,\n                  f: &fn(&ast::Block)) {\n-        for crate.module.items.iter().advance |item| {\n+        foreach item in crate.module.items.iter() {\n             match item.node {\n                 ast::item_fn(_, _, _, _, ref blk) => {\n                     if item.ident == sess.ident_of(\"main\") {\n@@ -396,7 +396,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n         }\n         ~\"load\" => {\n             let mut loaded_crates: ~[~str] = ~[];\n-            for args.iter().advance |arg| {\n+            foreach arg in args.iter() {\n                 let (crate, filename) =\n                     if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n                     (arg.slice_to(arg.len() - 3).to_owned(), (*arg).clone())\n@@ -408,7 +408,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n                     None => { }\n                 }\n             }\n-            for loaded_crates.iter().advance |crate| {\n+            foreach crate in loaded_crates.iter() {\n                 let crate_path = Path(*crate);\n                 let crate_dir = crate_path.dirname();\n                 repl.program.record_extern(fmt!(\"extern mod %s;\", *crate));\n@@ -571,7 +571,7 @@ mod tests {\n     #[cfg(thiswillneverbeacfgflag)]\n     fn run_program(prog: &str) {\n         let mut r = repl();\n-        for prog.split_iter('\\n').advance |cmd| {\n+        foreach cmd in prog.split_iter('\\n') {\n             assert!(run_line(&mut r, io::stdin(), io::stdout(),\n                              cmd.to_owned(), false),\n                     \"the command '%s' failed\", cmd);"}, {"sha": "942e622b140bc9d513cc673a91761fbdfea9727f", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -15,16 +15,16 @@ use std::os;\n \n pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n     let workspaces = rust_path();\n-    for workspaces.iter().advance |p| {\n+    foreach p in workspaces.iter() {\n         let binfiles = os::list_dir(&p.push(\"bin\"));\n-        for binfiles.iter().advance() |exec| {\n+        foreach exec in binfiles.iter() {\n             let exec_path = Path(*exec).filestem();\n             do exec_path.iter().advance |s| {\n                 f(&PkgId::new(*s, p))\n             };\n         }\n         let libfiles = os::list_dir(&p.push(\"lib\"));\n-        for libfiles.iter().advance() |lib| {\n+        foreach lib in libfiles.iter() {\n             debug!(\"Full name: %s\", *lib);\n             let lib_path = Path(*lib).filestem();\n             do lib_path.iter().advance |s| {"}, {"sha": "07e8de35fd6de8a17fa4e5bc6ec792bb41c21d89", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -135,7 +135,7 @@ impl PkgSrc {\n             return true;\n         }\n         else {\n-            for self_id.iter().advance |pth| {\n+            foreach pth in self_id.iter() {\n                 if pth.starts_with(\"rust_\") // because p is already normalized\n                     && match p.filestem() {\n                            Some(s) => str::eq_slice(s, pth.slice(5, pth.len())),\n@@ -149,7 +149,7 @@ impl PkgSrc {\n     fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n         assert!(p.components.len() > prefix);\n         let mut sub = Path(\"\");\n-        for p.components.slice(prefix, p.components.len()).iter().advance |c| {\n+        foreach c in p.components.slice(prefix, p.components.len()).iter() {\n             sub = sub.push(*c);\n         }\n         debug!(\"found crate %s\", sub.to_str());\n@@ -206,7 +206,7 @@ impl PkgSrc {\n                     crates: &[Crate],\n                     cfgs: &[~str],\n                     what: OutputType) {\n-        for crates.iter().advance |crate| {\n+        foreach crate in crates.iter() {\n             let path = &src_dir.push_rel(&crate.file).normalize();\n             note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n             note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));"}, {"sha": "ef95adf8c17056c759ed0666dfdbd9006296aa90", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -61,7 +61,7 @@ pub fn rust_path() -> ~[Path] {\n     // Avoid adding duplicates\n     // could still add dups if someone puts one of these in the RUST_PATH\n     // manually, though...\n-    for h.iter().advance |hdir| {\n+    foreach hdir in h.iter() {\n         if !(cwd.is_ancestor_of(hdir) || hdir.is_ancestor_of(&cwd)) {\n             push_if_exists(&mut env_rust_path, hdir);\n         }\n@@ -100,7 +100,7 @@ pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, U_RWX) }\n pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n     let src_dir = workspace.push(\"src\");\n     let dirs = os::list_dir(&src_dir);\n-    for dirs.iter().advance |p| {\n+    foreach p in dirs.iter() {\n         let p = Path((*p).clone());\n         debug!(\"=> p = %s\", p.to_str());\n         if !os::path_is_dir(&src_dir.push_rel(&p)) {\n@@ -113,7 +113,7 @@ pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n         }\n         else {\n             let pf = p.filename();\n-            for pf.iter().advance |pf| {\n+            foreach pf in pf.iter() {\n                 let f_ = (*pf).clone();\n                 let g = f_.to_str();\n                 match split_version_general(g, '-') {\n@@ -150,7 +150,7 @@ pub fn pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> ~[Path] {\n /// Returns a src for pkgid that does exist -- None if none of them do\n pub fn first_pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let rs = pkgid_src_in_workspace(pkgid, workspace);\n-    for rs.iter().advance |p| {\n+    foreach p in rs.iter() {\n         if os::path_exists(p) {\n             return Some((*p).clone());\n         }\n@@ -246,7 +246,7 @@ pub fn library_in_workspace(path: &LocalPath, short_name: &str, where: Target,\n     debug!(\"lib_prefix = %s and lib_filetype = %s\", lib_prefix, lib_filetype);\n \n     let mut result_filename = None;\n-    for dir_contents.iter().advance |p| {\n+    foreach p in dir_contents.iter() {\n         let mut which = 0;\n         let mut hash = None;\n         let p_path = Path((*p).clone());\n@@ -261,7 +261,7 @@ pub fn library_in_workspace(path: &LocalPath, short_name: &str, where: Target,\n         let f_name = match p_path.filename() {\n             Some(s) => s, None => loop\n         };\n-        for f_name.split_iter('-').advance |piece| {\n+        foreach piece in f_name.split_iter('-') {\n             debug!(\"a piece = %s\", piece);\n             if which == 0 && piece != lib_prefix {\n                 break;"}, {"sha": "29c0380948fa6d777498be5fcca5acfdf7d0b66d", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -430,14 +430,14 @@ impl CtxMethods for Ctx {\n                target_exec.to_str(), target_lib,\n                maybe_executable, maybe_library);\n \n-        for maybe_executable.iter().advance |exec| {\n+        foreach exec in maybe_executable.iter() {\n             debug!(\"Copying: %s -> %s\", exec.to_str(), target_exec.to_str());\n             if !(os::mkdir_recursive(&target_exec.dir_path(), U_RWX) &&\n                  os::copy_file(exec, &target_exec)) {\n                 cond.raise(((*exec).clone(), target_exec.clone()));\n             }\n         }\n-        for maybe_library.iter().advance |lib| {\n+        foreach lib in maybe_library.iter() {\n             let target_lib = target_lib.clone().expect(fmt!(\"I built %s but apparently \\\n                                                 didn't install it!\", lib.to_str()));\n             debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());"}, {"sha": "6b174836a68dcc9ba42383ccc0c38ba0c77dbf72", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -356,7 +356,7 @@ fn command_line_test_output(args: &[~str]) -> ~[~str] {\n     let mut result = ~[];\n     let p_output = command_line_test(args, &os::getcwd());\n     let test_output = str::from_bytes(p_output.output);\n-    for test_output.split_iter('\\n').advance |s| {\n+    foreach s in test_output.split_iter('\\n') {\n         result.push(s.to_owned());\n     }\n     result\n@@ -366,7 +366,7 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n     let mut result = ~[];\n     let p_output = command_line_test_with_env(args, &os::getcwd(), Some(env));\n     let test_output = str::from_bytes(p_output.output);\n-    for test_output.split_iter('\\n').advance |s| {\n+    foreach s in test_output.split_iter('\\n') {\n         result.push(s.to_owned());\n     }\n     result\n@@ -391,7 +391,7 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n     use conditions::bad_path::cond;\n     let pkg_src_dir = workspace.push(\"src\").push(pkgid.to_str());\n     let contents = os::list_dir_path(&pkg_src_dir);\n-    for contents.iter().advance |p| {\n+    foreach p in contents.iter() {\n         if p.filetype() == Some(~\".rs\") {\n             // should be able to do this w/o a process\n             if run::process_output(\"touch\", [p.to_str()]).status != 0 {\n@@ -408,7 +408,7 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId) {\n     let pkg_src_dir = workspace.push(\"src\").push(pkgid.to_str());\n     let contents = os::list_dir_path(&pkg_src_dir);\n     let mut maybe_p = None;\n-    for contents.iter().advance |p| {\n+    foreach p in contents.iter() {\n         if p.filetype() == Some(~\".rs\") {\n             maybe_p = Some(p);\n             break;\n@@ -811,7 +811,7 @@ fn rust_path_contents() {\n         assert!(p.contains(&cwd));\n         assert!(p.contains(&parent));\n         assert!(p.contains(&grandparent));\n-        for p.iter().advance() |a_path| {\n+        foreach a_path in p.iter() {\n             assert!(!a_path.components.is_empty());\n         }\n     });"}, {"sha": "570a9091d180a8eaeedceefd19e91ec408a1895e", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -104,12 +104,12 @@ fn fold_item(ctx: @mut ReadyCtx,\n     let mut cmds = ~[];\n     let mut had_pkg_do = false;\n \n-    for item.attrs.iter().advance |attr| {\n+    foreach attr in item.attrs.iter() {\n         if \"pkg_do\" == attr.name() {\n             had_pkg_do = true;\n             match attr.node.value.node {\n                 ast::MetaList(_, ref mis) => {\n-                    for mis.iter().advance |mi| {\n+                    foreach mi in mis.iter() {\n                         match mi.node {\n                             ast::MetaWord(cmd) => cmds.push(cmd.to_owned()),\n                             _ => {}\n@@ -210,7 +210,7 @@ pub fn compile_input(ctxt: &Ctx,\n     let addl_lib_search_paths = @mut options.addl_lib_search_paths;\n     // Make sure all the library directories actually exist, since the linker will complain\n     // otherwise\n-    for addl_lib_search_paths.iter().advance |p| {\n+    foreach p in addl_lib_search_paths.iter() {\n         assert!(os::path_is_dir(p));\n     }\n \n@@ -274,7 +274,7 @@ pub fn compile_crate_from_input(input: &driver::input,\n \n     debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n     debug!(\"additional libraries:\");\n-    for sess.opts.addl_lib_search_paths.iter().advance |lib| {\n+    foreach lib in sess.opts.addl_lib_search_paths.iter() {\n         debug!(\"an additional library: %s\", lib.to_str());\n     }\n     let analysis = driver::phase_3_run_analysis_passes(sess, crate);\n@@ -303,7 +303,7 @@ pub fn compile_crate(ctxt: &Ctx, pkg_id: &PkgId,\n                      what: OutputType) -> bool {\n     debug!(\"compile_crate: crate=%s, dir=%s\", crate.to_str(), dir.to_str());\n     debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n-    for flags.iter().advance |fl| {\n+    foreach fl in flags.iter() {\n         debug!(\"+++ %s\", *fl);\n     }\n     compile_input(ctxt, pkg_id, crate, dir, flags, cfgs, opt, what)"}, {"sha": "d0c5c099ec455764b9fbc202af29855ea658e836", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -108,7 +108,7 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n \n     let mut output = None;\n     let output_text = str::from_bytes(outp.output);\n-    for output_text.line_iter().advance |l| {\n+    foreach l in output_text.line_iter() {\n         if !l.is_whitespace() {\n             output = Some(l);\n         }\n@@ -142,7 +142,7 @@ pub fn try_getting_version(remote_path: &RemotePath) -> Option<Version> {\n                                             ~\"tag\", ~\"-l\"]);\n             let output_text = str::from_bytes(outp.output);\n             debug!(\"Full output: ( %s ) [%?]\", output_text, outp.status);\n-            for output_text.line_iter().advance |l| {\n+            foreach l in output_text.line_iter() {\n                 debug!(\"A line of output: %s\", l);\n                 if !l.is_whitespace() {\n                     output = Some(l);\n@@ -172,7 +172,7 @@ fn try_parsing_version(s: &str) -> Option<Version> {\n     let s = s.trim();\n     debug!(\"Attempting to parse: %s\", s);\n     let mut parse_state = Start;\n-    for s.iter().advance |c| {\n+    foreach c in s.iter() {\n         if char::is_digit(c) {\n             parse_state = SawDigit;\n         }\n@@ -204,7 +204,7 @@ pub fn split_version<'a>(s: &'a str) -> Option<(&'a str, Version)> {\n \n pub fn split_version_general<'a>(s: &'a str, sep: char) -> Option<(&'a str, Version)> {\n     // reject strings with multiple '#'s\n-    for s.split_iter(sep).advance |st| {\n+    foreach st in s.split_iter(sep) {\n         debug!(\"whole = %s part = %s\", s, st);\n     }\n     if s.split_iter(sep).len_() > 2 {"}, {"sha": "3417d051e6290f28c2b5fc0cbd4ae3eb95a83e99", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -26,7 +26,7 @@ pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> b\n                    pkgid.remote_path.to_str(),\n                    rust_path().to_str());\n     }\n-    for workspaces.iter().advance |ws| {\n+    foreach ws in workspaces.iter() {\n         if action(ws) {\n             break;\n         }"}, {"sha": "22cbcb0d6d4745f35fa8a35dfd1d3c9ec2ef6c16", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -12,8 +12,8 @@\n \n use clone::Clone;\n use container::Container;\n-use iterator::IteratorUtil;\n-use option::Option;\n+use iterator::Iterator;\n+use option::{Option, Some, None};\n use sys;\n use uint;\n use unstable::raw::Repr;\n@@ -92,7 +92,7 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n #[inline]\n pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n-        for lhs.iter().advance |x| {\n+        foreach x in lhs.iter() {\n             push((*x).clone());\n         }\n         for uint::range(0, rhs.len()) |i| {\n@@ -105,7 +105,7 @@ pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n /// Apply a function to each element of a vector and return the results\n pub fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n     do build_sized(v.len()) |push| {\n-        for v.iter().advance |elem| {\n+        foreach elem in v.iter() {\n             push(f(elem));\n         }\n     }\n@@ -148,7 +148,7 @@ pub fn to_managed_consume<T>(v: ~[T]) -> @[T] {\n     let mut av = @[];\n     unsafe {\n         raw::reserve(&mut av, v.len());\n-        for v.consume_iter().advance |x| {\n+        foreach x in v.consume_iter() {\n             raw::push(&mut av, x);\n         }\n         av"}, {"sha": "d0378fa947b2b776c0d700c345998558ef617c9b", "filename": "src/libstd/either.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -12,10 +12,11 @@\n \n #[allow(missing_doc)];\n \n+use option::{Some, None};\n use clone::Clone;\n use container::Container;\n use cmp::Eq;\n-use iterator::IteratorUtil;\n+use iterator::Iterator;\n use result::Result;\n use result;\n use str::StrSlice;\n@@ -46,7 +47,7 @@ pub fn either<T, U, V>(f_left: &fn(&T) -> V,\n /// Extracts from a vector of either all the left values\n pub fn lefts<T:Clone,U>(eithers: &[Either<T, U>]) -> ~[T] {\n     do vec::build_sized(eithers.len()) |push| {\n-        for eithers.iter().advance |elt| {\n+        foreach elt in eithers.iter() {\n             match *elt {\n                 Left(ref l) => { push((*l).clone()); }\n                 _ => { /* fallthrough */ }\n@@ -58,7 +59,7 @@ pub fn lefts<T:Clone,U>(eithers: &[Either<T, U>]) -> ~[T] {\n /// Extracts from a vector of either all the right values\n pub fn rights<T, U: Clone>(eithers: &[Either<T, U>]) -> ~[U] {\n     do vec::build_sized(eithers.len()) |push| {\n-        for eithers.iter().advance |elt| {\n+        foreach elt in eithers.iter() {\n             match *elt {\n                 Right(ref r) => { push((*r).clone()); }\n                 _ => { /* fallthrough */ }\n@@ -74,7 +75,7 @@ pub fn rights<T, U: Clone>(eithers: &[Either<T, U>]) -> ~[U] {\n pub fn partition<T, U>(eithers: ~[Either<T, U>]) -> (~[T], ~[U]) {\n     let mut lefts: ~[T] = ~[];\n     let mut rights: ~[U] = ~[];\n-    for eithers.consume_iter().advance |elt| {\n+    foreach elt in eithers.consume_iter() {\n         match elt {\n             Left(l) => lefts.push(l),\n             Right(r) => rights.push(r)"}, {"sha": "16d138d4e1fbeed9c7785859cc76e84be9b9cffb", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -22,7 +22,8 @@\n #[allow(missing_doc)];\n \n use container::Container;\n-use iterator::IteratorUtil;\n+use iterator::Iterator;\n+use option::{Some, None};\n use rt::io::Writer;\n use str::OwnedStr;\n use to_bytes::IterBytes;\n@@ -369,7 +370,7 @@ impl Streaming for SipState {\n     fn result_str(&mut self) -> ~str {\n         let r = self.result_bytes();\n         let mut s = ~\"\";\n-        for r.iter().advance |b| {\n+        foreach b in r.iter() {\n             s.push_str(uint::to_str_radix(*b as uint, 16u));\n         }\n         s\n@@ -471,7 +472,7 @@ mod tests {\n \n         fn to_hex_str(r: &[u8, ..8]) -> ~str {\n             let mut s = ~\"\";\n-            for r.iter().advance |b| {\n+            foreach b in r.iter() {\n                 s.push_str(uint::to_str_radix(*b as uint, 16u));\n             }\n             s"}, {"sha": "b162869201d39f4fa45f0912603f3051be7fb093", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -177,7 +177,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n \n         self.size = 0;\n         // consume_rev_iter is more efficient\n-        for old_buckets.consume_rev_iter().advance |bucket| {\n+        foreach bucket in old_buckets.consume_rev_iter() {\n             self.insert_opt_bucket(bucket);\n         }\n     }\n@@ -518,7 +518,7 @@ impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n impl<K:Hash + Eq + Clone,V:Clone> Clone for HashMap<K,V> {\n     fn clone(&self) -> HashMap<K,V> {\n         let mut new_map = HashMap::with_capacity(self.len());\n-        for self.iter().advance |(key, value)| {\n+        foreach (key, value) in self.iter() {\n             new_map.insert((*key).clone(), (*value).clone());\n         }\n         new_map\n@@ -555,7 +555,7 @@ pub struct HashSetConsumeIterator<K> {\n impl<'self, K, V> Iterator<(&'self K, &'self V)> for HashMapIterator<'self, K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(&'self K, &'self V)> {\n-        for self.iter.advance |elt| {\n+        foreach elt in self.iter {\n             match elt {\n                 &Some(ref bucket) => return Some((&bucket.key, &bucket.value)),\n                 &None => {},\n@@ -568,7 +568,7 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for HashMapIterator<'self, K, V\n impl<'self, K, V> Iterator<(&'self K, &'self mut V)> for HashMapMutIterator<'self, K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(&'self K, &'self mut V)> {\n-        for self.iter.advance |elt| {\n+        foreach elt in self.iter {\n             match elt {\n                 &Some(ref mut bucket) => return Some((&bucket.key, &mut bucket.value)),\n                 &None => {},\n@@ -581,7 +581,7 @@ impl<'self, K, V> Iterator<(&'self K, &'self mut V)> for HashMapMutIterator<'sel\n impl<K, V> Iterator<(K, V)> for HashMapConsumeIterator<K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(K, V)> {\n-        for self.iter.advance |elt| {\n+        foreach elt in self.iter {\n             match elt {\n                 Some(Bucket {key, value, _}) => return Some((key, value)),\n                 None => {},\n@@ -594,7 +594,7 @@ impl<K, V> Iterator<(K, V)> for HashMapConsumeIterator<K, V> {\n impl<'self, K> Iterator<&'self K> for HashSetIterator<'self, K> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self K> {\n-        for self.iter.advance |elt| {\n+        foreach elt in self.iter {\n             match elt {\n                 &Some(ref bucket) => return Some(&bucket.key),\n                 &None => {},\n@@ -607,7 +607,7 @@ impl<'self, K> Iterator<&'self K> for HashSetIterator<'self, K> {\n impl<K> Iterator<K> for HashSetConsumeIterator<K> {\n     #[inline]\n     fn next(&mut self) -> Option<K> {\n-        for self.iter.advance |elt| {\n+        foreach elt in self.iter {\n             match elt {\n                 Some(bucket) => return Some(bucket.key),\n                 None => {},\n@@ -628,7 +628,7 @@ impl<K: Eq + Hash, V, T: Iterator<(K, V)>> FromIterator<(K, V), T> for HashMap<K\n \n impl<K: Eq + Hash, V, T: Iterator<(K, V)>> Extendable<(K, V), T> for HashMap<K, V> {\n     fn extend(&mut self, iter: &mut T) {\n-        for iter.advance |(k, v)| {\n+        foreach (k, v) in *iter {\n             self.insert(k, v);\n         }\n     }\n@@ -785,7 +785,7 @@ impl<K: Eq + Hash, T: Iterator<K>> FromIterator<K, T> for HashSet<K> {\n \n impl<K: Eq + Hash, T: Iterator<K>> Extendable<K, T> for HashSet<K> {\n     fn extend(&mut self, iter: &mut T) {\n-        for iter.advance |k| {\n+        foreach k in *iter {\n             self.insert(k);\n         }\n     }\n@@ -959,7 +959,7 @@ mod test_map {\n             assert!(m.insert(i, i*2));\n         }\n         let mut observed = 0;\n-        for m.iter().advance |(k, v)| {\n+        foreach (k, v) in m.iter() {\n             assert_eq!(*v, *k * 2);\n             observed |= (1 << *k);\n         }\n@@ -1036,7 +1036,7 @@ mod test_map {\n \n         let map: HashMap<int, int> = xs.iter().transform(|&x| x).collect();\n \n-        for xs.iter().advance |&(k, v)| {\n+        foreach &(k, v) in xs.iter() {\n             assert_eq!(map.find(&k), Some(&v));\n         }\n     }\n@@ -1045,6 +1045,7 @@ mod test_map {\n #[cfg(test)]\n mod test_set {\n     use super::*;\n+    use prelude::*;\n     use container::Container;\n     use vec::ImmutableEqVector;\n     use uint;\n@@ -1107,7 +1108,7 @@ mod test_set {\n             assert!(a.insert(i));\n         }\n         let mut observed = 0;\n-        for a.iter().advance |k| {\n+        foreach k in a.iter() {\n             observed |= (1 << *k);\n         }\n         assert_eq!(observed, 0xFFFF_FFFF);\n@@ -1136,7 +1137,7 @@ mod test_set {\n \n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n-        for a.intersection_iter(&b).advance |x| {\n+        foreach x in a.intersection_iter(&b) {\n             assert!(expected.contains(x));\n             i += 1\n         }\n@@ -1159,7 +1160,7 @@ mod test_set {\n \n         let mut i = 0;\n         let expected = [1, 5, 11];\n-        for a.difference_iter(&b).advance |x| {\n+        foreach x in a.difference_iter(&b) {\n             assert!(expected.contains(x));\n             i += 1\n         }\n@@ -1185,7 +1186,7 @@ mod test_set {\n \n         let mut i = 0;\n         let expected = [-2, 1, 5, 11, 14, 22];\n-        for a.symmetric_difference_iter(&b).advance |x| {\n+        foreach x in a.symmetric_difference_iter(&b) {\n             assert!(expected.contains(x));\n             i += 1\n         }\n@@ -1215,7 +1216,7 @@ mod test_set {\n \n         let mut i = 0;\n         let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n-        for a.union_iter(&b).advance |x| {\n+        foreach x in a.union_iter(&b) {\n             assert!(expected.contains(x));\n             i += 1\n         }\n@@ -1228,7 +1229,7 @@ mod test_set {\n \n         let set: HashSet<int> = xs.iter().transform(|&x| x).collect();\n \n-        for xs.iter().advance |x: &int| {\n+        foreach x in xs.iter() {\n             assert!(set.contains(x));\n         }\n     }"}, {"sha": "cef183d04291d1b533d9c5cc4337781f980743e2", "filename": "src/libstd/io.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -50,12 +50,13 @@ use cast;\n use clone::Clone;\n use container::Container;\n use int;\n-use iterator::IteratorUtil;\n+use iterator::Iterator;\n use libc::consts::os::posix88::*;\n use libc::{c_int, c_long, c_void, size_t, ssize_t};\n use libc;\n use num;\n use ops::Drop;\n+use option::{Some, None};\n use os;\n use path::Path;\n use ptr;\n@@ -1279,7 +1280,7 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n     fn wb() -> c_int { O_WRONLY as c_int }\n \n     let mut fflags: c_int = wb();\n-    for flags.iter().advance |f| {\n+    foreach f in flags.iter() {\n         match *f {\n           Append => fflags |= O_APPEND as c_int,\n           Create => fflags |= O_CREAT as c_int,\n@@ -1841,12 +1842,12 @@ pub mod fsync {\n \n #[cfg(test)]\n mod tests {\n+    use prelude::*;\n     use i32;\n     use io::{BytesWriter, SeekCur, SeekEnd, SeekSet};\n     use io;\n     use path::Path;\n     use result::{Ok, Err};\n-    use result;\n     use u64;\n     use vec;\n \n@@ -1938,7 +1939,7 @@ mod tests {\n                 if len <= ivals.len() {\n                     assert_eq!(res.len(), len);\n                 }\n-                for ivals.iter().zip(res.iter()).advance |(iv, c)| {\n+                foreach (iv, c) in ivals.iter().zip(res.iter()) {\n                     assert!(*iv == *c as int)\n                 }\n             }\n@@ -2052,15 +2053,15 @@ mod tests {\n         // write the ints to the file\n         {\n             let file = io::file_writer(&path, [io::Create]).unwrap();\n-            for uints.iter().advance |i| {\n+            foreach i in uints.iter() {\n                 file.write_le_u64(*i);\n             }\n         }\n \n         // then read them back and check that they are the same\n         {\n             let file = io::file_reader(&path).unwrap();\n-            for uints.iter().advance |i| {\n+            foreach i in uints.iter() {\n                 assert_eq!(file.read_le_u64(), *i);\n             }\n         }\n@@ -2074,15 +2075,15 @@ mod tests {\n         // write the ints to the file\n         {\n             let file = io::file_writer(&path, [io::Create]).unwrap();\n-            for uints.iter().advance |i| {\n+            foreach i in uints.iter() {\n                 file.write_be_u64(*i);\n             }\n         }\n \n         // then read them back and check that they are the same\n         {\n             let file = io::file_reader(&path).unwrap();\n-            for uints.iter().advance |i| {\n+            foreach i in uints.iter() {\n                 assert_eq!(file.read_be_u64(), *i);\n             }\n         }\n@@ -2096,15 +2097,15 @@ mod tests {\n         // write the ints to the file\n         {\n             let file = io::file_writer(&path, [io::Create]).unwrap();\n-            for ints.iter().advance |i| {\n+            foreach i in ints.iter() {\n                 file.write_be_i32(*i);\n             }\n         }\n \n         // then read them back and check that they are the same\n         {\n             let file = io::file_reader(&path).unwrap();\n-            for ints.iter().advance |i| {\n+            foreach i in ints.iter() {\n                 // this tests that the sign extension is working\n                 // (comparing the values as i32 would not test this)\n                 assert_eq!(file.read_be_int_n(4), *i as i64);"}, {"sha": "84923876cbf6444ccb882f7dc4901cab1ac9e192", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -295,7 +295,7 @@ pub trait IteratorUtil<A> {\n     /// let mut it = xs.iter().flat_map_(|&x| Counter::new(0u, 1).take_(x));\n     /// // Check that `it` has the same elements as `ys`\n     /// let mut i = 0;\n-    /// for it.advance |x: uint| {\n+    /// foreach x: uint in it {\n     ///     assert_eq!(x, ys[i]);\n     ///     i += 1;\n     /// }\n@@ -330,7 +330,7 @@ pub trait IteratorUtil<A> {\n     /// ~~~ {.rust}\n     /// use std::iterator::Counter;\n     ///\n-    /// for Counter::new(0, 10).advance |i| {\n+    /// foreach i in Counter::new(0, 10) {\n     ///     printfln!(\"%d\", i);\n     /// }\n     /// ~~~\n@@ -577,7 +577,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     #[inline]\n     fn last_(&mut self) -> Option<A> {\n         let mut last = None;\n-        for self.advance |x| { last = Some(x); }\n+        foreach x in *self { last = Some(x); }\n         last\n     }\n \n@@ -600,20 +600,20 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n \n     #[inline]\n     fn all(&mut self, f: &fn(A) -> bool) -> bool {\n-        for self.advance |x| { if !f(x) { return false; } }\n+        foreach x in *self { if !f(x) { return false; } }\n         true\n     }\n \n     #[inline]\n     fn any(&mut self, f: &fn(A) -> bool) -> bool {\n-        for self.advance |x| { if f(x) { return true; } }\n+        foreach x in *self { if f(x) { return true; } }\n         false\n     }\n \n     /// Return the first element satisfying the specified predicate\n     #[inline]\n     fn find_(&mut self, predicate: &fn(&A) -> bool) -> Option<A> {\n-        for self.advance |x| {\n+        foreach x in *self {\n             if predicate(&x) { return Some(x) }\n         }\n         None\n@@ -623,7 +623,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     #[inline]\n     fn position(&mut self, predicate: &fn(A) -> bool) -> Option<uint> {\n         let mut i = 0;\n-        for self.advance |x| {\n+        foreach x in *self {\n             if predicate(x) {\n                 return Some(i);\n             }\n@@ -635,7 +635,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     #[inline]\n     fn count(&mut self, predicate: &fn(A) -> bool) -> uint {\n         let mut i = 0;\n-        for self.advance |x| {\n+        foreach x in *self {\n             if predicate(x) { i += 1 }\n         }\n         i\n@@ -1024,7 +1024,7 @@ pub struct Filter<'self, A, T> {\n impl<'self, A, T: Iterator<A>> Iterator<A> for Filter<'self, A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        for self.iter.advance |x| {\n+        foreach x in self.iter {\n             if (self.predicate)(&x) {\n                 return Some(x);\n             } else {\n@@ -1068,7 +1068,7 @@ pub struct FilterMap<'self, A, B, T> {\n impl<'self, A, B, T: Iterator<A>> Iterator<B> for FilterMap<'self, A, B, T> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n-        for self.iter.advance |x| {\n+        foreach x in self.iter {\n             match (self.f)(x) {\n                 Some(y) => return Some(y),\n                 None => ()\n@@ -1372,8 +1372,8 @@ impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         loop {\n-            for self.frontiter.mut_iter().advance |inner| {\n-                for inner.advance |x| {\n+            foreach inner in self.frontiter.mut_iter() {\n+                foreach x in *inner {\n                     return Some(x)\n                 }\n             }\n@@ -1402,7 +1402,7 @@ impl<'self,\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n         loop {\n-            for self.backiter.mut_iter().advance |inner| {\n+            foreach inner in self.backiter.mut_iter() {\n                 match inner.next_back() {\n                     None => (),\n                     y => return y\n@@ -1549,7 +1549,7 @@ mod tests {\n         let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n         let mut it = xs.iter().chain_(ys.iter());\n         let mut i = 0;\n-        for it.advance |&x| {\n+        foreach &x in it {\n             assert_eq!(x, expected[i]);\n             i += 1;\n         }\n@@ -1558,7 +1558,7 @@ mod tests {\n         let ys = Counter::new(30u, 10).take_(4);\n         let mut it = xs.iter().transform(|&x| x).chain_(ys);\n         let mut i = 0;\n-        for it.advance |x| {\n+        foreach x in it {\n             assert_eq!(x, expected[i]);\n             i += 1;\n         }\n@@ -1576,7 +1576,7 @@ mod tests {\n     fn test_iterator_enumerate() {\n         let xs = [0u, 1, 2, 3, 4, 5];\n         let mut it = xs.iter().enumerate();\n-        for it.advance |(i, &x)| {\n+        foreach (i, &x) in it {\n             assert_eq!(i, x);\n         }\n     }\n@@ -1587,7 +1587,7 @@ mod tests {\n         let ys = [0u, 1, 2, 3, 5, 13];\n         let mut it = xs.iter().take_while(|&x| *x < 15u);\n         let mut i = 0;\n-        for it.advance |&x| {\n+        foreach &x in it {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -1600,7 +1600,7 @@ mod tests {\n         let ys = [15, 16, 17, 19];\n         let mut it = xs.iter().skip_while(|&x| *x < 15u);\n         let mut i = 0;\n-        for it.advance |&x| {\n+        foreach &x in it {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -1613,7 +1613,7 @@ mod tests {\n         let ys = [13, 15, 16, 17, 19, 20, 30];\n         let mut it = xs.iter().skip(5);\n         let mut i = 0;\n-        for it.advance |&x| {\n+        foreach &x in it {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -1626,7 +1626,7 @@ mod tests {\n         let ys = [0u, 1, 2, 3, 5];\n         let mut it = xs.iter().take_(5);\n         let mut i = 0;\n-        for it.advance |&x| {\n+        foreach &x in it {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -1645,7 +1645,7 @@ mod tests {\n \n         let mut it = xs.iter().scan(0, add);\n         let mut i = 0;\n-        for it.advance |x| {\n+        foreach x in it {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -1658,7 +1658,7 @@ mod tests {\n         let ys = [0u, 1, 2, 3, 4, 5, 6, 7, 8];\n         let mut it = xs.iter().flat_map_(|&x| Counter::new(x, 1).take_(3));\n         let mut i = 0;\n-        for it.advance |x: uint| {\n+        foreach x in it {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -1693,7 +1693,7 @@ mod tests {\n \n         let mut it = Unfoldr::new(0, count);\n         let mut i = 0;\n-        for it.advance |counted| {\n+        foreach counted in it {\n             assert_eq!(counted, i);\n             i += 1;\n         }\n@@ -1705,7 +1705,7 @@ mod tests {\n         let cycle_len = 3;\n         let it = Counter::new(0u,1).take_(cycle_len).cycle();\n         assert_eq!(it.size_hint(), (uint::max_value, None));\n-        for it.take_(100).enumerate().advance |(i, x)| {\n+        foreach (i, x) in it.take_(100).enumerate() {\n             assert_eq!(i % cycle_len, x);\n         }\n \n@@ -1931,7 +1931,7 @@ mod tests {\n         let mut b = a.clone();\n         assert_eq!(len, b.indexable());\n         let mut n = 0;\n-        for a.enumerate().advance |(i, elt)| {\n+        foreach (i, elt) in a.enumerate() {\n             assert_eq!(Some(elt), b.idx(i));\n             n += 1;\n         }\n@@ -2021,7 +2021,7 @@ mod tests {\n         // test .transform and .peek_ that don't implement Clone\n         let it = xs.iter().peek_(|_| {});\n         assert_eq!(xs.len(), it.indexable());\n-        for xs.iter().enumerate().advance |(i, elt)| {\n+        foreach (i, elt) in xs.iter().enumerate() {\n             assert_eq!(Some(elt), it.idx(i));\n         }\n \n@@ -2034,7 +2034,7 @@ mod tests {\n         // test .transform and .peek_ that don't implement Clone\n         let it = xs.iter().transform(|x| *x);\n         assert_eq!(xs.len(), it.indexable());\n-        for xs.iter().enumerate().advance |(i, elt)| {\n+        foreach (i, elt) in xs.iter().enumerate() {\n             assert_eq!(Some(*elt), it.idx(i));\n         }\n     }"}, {"sha": "7eca47743d6a6136882a187134912b12f99f3f3d", "filename": "src/libstd/option.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -50,8 +50,6 @@ use iterator::Iterator;\n use str::StrSlice;\n use clone::DeepClone;\n \n-#[cfg(test)] use iterator::IteratorUtil;\n-\n /// The option type\n #[deriving(Clone, DeepClone, Eq)]\n pub enum Option<T> {\n@@ -499,7 +497,7 @@ mod tests {\n         let x = Some(());\n         let mut y = Some(5);\n         let mut y2 = 0;\n-        for x.iter().advance |_x| {\n+        foreach _x in x.iter() {\n             y2 = y.take_unwrap();\n         }\n         assert_eq!(y2, 5);"}, {"sha": "3afd946ee264b15f12d885f0c8f85264ad084974", "filename": "src/libstd/os.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -220,7 +220,7 @@ pub fn env() -> ~[(~str,~str)] {\n \n         fn env_convert(input: ~[~str]) -> ~[(~str, ~str)] {\n             let mut pairs = ~[];\n-            for input.iter().advance |p| {\n+            foreach p in input.iter() {\n                 let vs: ~[&str] = p.splitn_iter('=', 1).collect();\n                 debug!(\"splitting: len: %u\",\n                     vs.len());\n@@ -1419,7 +1419,7 @@ impl MemoryMap {\n         let mut offset: off_t = 0;\n         let len = round_up(min_len, page_size()) as size_t;\n \n-        for options.iter().advance |&o| {\n+        foreach &o in options.iter() {\n             match o {\n                 MapReadable => { prot |= libc::PROT_READ; },\n                 MapWritable => { prot |= libc::PROT_WRITE; },\n@@ -1492,7 +1492,7 @@ impl MemoryMap {\n         let mut offset: uint = 0;\n         let len = round_up(min_len, page_size()) as SIZE_T;\n \n-        for options.iter().advance |&o| {\n+        foreach &o in options.iter() {\n             match o {\n                 MapReadable => { readable = true; },\n                 MapWritable => { writable = true; },\n@@ -1788,7 +1788,7 @@ mod tests {\n     fn test_env_getenv() {\n         let e = env();\n         assert!(e.len() > 0u);\n-        for e.iter().advance |p| {\n+        foreach p in e.iter() {\n             let (n, v) = (*p).clone();\n             debug!(n.clone());\n             let v2 = getenv(n);\n@@ -1832,7 +1832,7 @@ mod tests {\n         setenv(\"HOME\", \"\");\n         assert!(os::homedir().is_none());\n \n-        for oldhome.iter().advance |s| { setenv(\"HOME\", *s) }\n+        foreach s in oldhome.iter() { setenv(\"HOME\", *s) }\n     }\n \n     #[test]\n@@ -1880,7 +1880,7 @@ mod tests {\n         // Just assuming that we've got some contents in the current directory\n         assert!(dirs.len() > 0u);\n \n-        for dirs.iter().advance |dir| {\n+        foreach dir in dirs.iter() {\n             debug!((*dir).clone());\n         }\n     }"}, {"sha": "989a5cbd35b3b79729567f2471bcfeafb4cd449e", "filename": "src/libstd/path.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -19,7 +19,7 @@ Cross-platform file path handling\n use clone::Clone;\n use container::Container;\n use cmp::Eq;\n-use iterator::IteratorUtil;\n+use iterator::{Iterator, IteratorUtil};\n use libc;\n use option::{None, Option, Some};\n use str::{OwnedStr, Str, StrSlice, StrVector};\n@@ -647,8 +647,8 @@ impl GenericPath for PosixPath {\n \n     fn push_many<S: Str>(&self, cs: &[S]) -> PosixPath {\n         let mut v = self.components.clone();\n-        for cs.iter().advance |e| {\n-            for e.as_slice().split_iter(posix::is_sep).advance |s| {\n+        foreach e in cs.iter() {\n+            foreach s in e.as_slice().split_iter(posix::is_sep) {\n                 if !s.is_empty() {\n                     v.push(s.to_owned())\n                 }\n@@ -662,7 +662,7 @@ impl GenericPath for PosixPath {\n \n     fn push(&self, s: &str) -> PosixPath {\n         let mut v = self.components.clone();\n-        for s.split_iter(posix::is_sep).advance |s| {\n+        foreach s in s.split_iter(posix::is_sep) {\n             if !s.is_empty() {\n                 v.push(s.to_owned())\n             }\n@@ -922,8 +922,8 @@ impl GenericPath for WindowsPath {\n \n     fn push_many<S: Str>(&self, cs: &[S]) -> WindowsPath {\n         let mut v = self.components.clone();\n-        for cs.iter().advance |e| {\n-            for e.as_slice().split_iter(windows::is_sep).advance |s| {\n+        foreach e in cs.iter() {\n+            foreach s in e.as_slice().split_iter(windows::is_sep) {\n                 if !s.is_empty() {\n                     v.push(s.to_owned())\n                 }\n@@ -940,7 +940,7 @@ impl GenericPath for WindowsPath {\n \n     fn push(&self, s: &str) -> WindowsPath {\n         let mut v = self.components.clone();\n-        for s.split_iter(windows::is_sep).advance |s| {\n+        foreach s in s.split_iter(windows::is_sep) {\n             if !s.is_empty() {\n                 v.push(s.to_owned())\n             }\n@@ -989,7 +989,7 @@ impl GenericPath for WindowsPath {\n \n pub fn normalize(components: &[~str]) -> ~[~str] {\n     let mut cs = ~[];\n-    for components.iter().advance |c| {\n+    foreach c in components.iter() {\n         if *c == ~\".\" && components.len() > 1 { loop; }\n         if *c == ~\"\" { loop; }\n         if *c == ~\"..\" && cs.len() != 0 {"}, {"sha": "a2ad2eb5e7621af42b4d743b938bd68838ced520", "filename": "src/libstd/pipes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -87,7 +87,7 @@ bounded and unbounded protocols allows for less code duplication.\n use container::Container;\n use cast::{forget, transmute, transmute_copy, transmute_mut};\n use either::{Either, Left, Right};\n-use iterator::IteratorUtil;\n+use iterator::{Iterator, IteratorUtil};\n use kinds::Send;\n use libc;\n use ops::Drop;\n@@ -600,7 +600,7 @@ pub fn wait_many<T: Selectable>(pkts: &mut [T]) -> uint {\n \n     let mut data_avail = false;\n     let mut ready_packet = pkts.len();\n-    for pkts.mut_iter().enumerate().advance |(i, p)| {\n+    foreach (i, p) in pkts.mut_iter().enumerate() {\n         unsafe {\n             let p = &mut *p.header();\n             let old = p.mark_blocked(this);\n@@ -622,7 +622,7 @@ pub fn wait_many<T: Selectable>(pkts: &mut [T]) -> uint {\n         let event = wait_event(this) as *PacketHeader;\n \n         let mut pos = None;\n-        for pkts.mut_iter().enumerate().advance |(i, p)| {\n+        foreach (i, p) in pkts.mut_iter().enumerate() {\n             if p.header() == event {\n                 pos = Some(i);\n                 break;\n@@ -640,7 +640,7 @@ pub fn wait_many<T: Selectable>(pkts: &mut [T]) -> uint {\n \n     debug!(\"%?\", &mut pkts[ready_packet]);\n \n-    for pkts.mut_iter().advance |p| {\n+    foreach p in pkts.mut_iter() {\n         unsafe {\n             (*p.header()).unblock()\n         }\n@@ -851,7 +851,7 @@ pub fn select<T:Send,Tb:Send>(mut endpoints: ~[RecvPacketBuffered<T, Tb>])\n                                     Option<T>,\n                                     ~[RecvPacketBuffered<T, Tb>]) {\n     let mut endpoint_headers = ~[];\n-    for endpoints.mut_iter().advance |endpoint| {\n+    foreach endpoint in endpoints.mut_iter() {\n         endpoint_headers.push(endpoint.header());\n     }\n "}, {"sha": "aed68f47fdf393bad23d6f421b049f4356a64916", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -48,7 +48,6 @@ use clone::Clone;\n use cmp;\n use container::Container;\n use int;\n-use iterator::IteratorUtil;\n use local_data;\n use num;\n use prelude::*;\n@@ -495,7 +494,7 @@ impl<R: Rng> RngUtil for R {\n     fn gen_char_from(&mut self, chars: &str) -> char {\n         assert!(!chars.is_empty());\n         let mut cs = ~[];\n-        for chars.iter().advance |c| { cs.push(c) }\n+        foreach c in chars.iter() { cs.push(c) }\n         self.choose(cs)\n     }\n \n@@ -559,15 +558,15 @@ impl<R: Rng> RngUtil for R {\n     fn choose_weighted_option<T:Clone>(&mut self, v: &[Weighted<T>])\n                                        -> Option<T> {\n         let mut total = 0u;\n-        for v.iter().advance |item| {\n+        foreach item in v.iter() {\n             total += item.weight;\n         }\n         if total == 0u {\n             return None;\n         }\n         let chosen = self.gen_uint_range(0u, total);\n         let mut so_far = 0u;\n-        for v.iter().advance |item| {\n+        foreach item in v.iter() {\n             so_far += item.weight;\n             if so_far > chosen {\n                 return Some(item.item.clone());\n@@ -582,7 +581,7 @@ impl<R: Rng> RngUtil for R {\n      */\n     fn weighted_vec<T:Clone>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n         let mut r = ~[];\n-        for v.iter().advance |item| {\n+        foreach item in v.iter() {\n             for uint::range(0u, item.weight) |_i| {\n                 r.push(item.item.clone());\n             }\n@@ -763,7 +762,7 @@ impl IsaacRng {\n         );\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n-        for r.iter().advance |&(mr_offset, m2_offset)| {\n+        foreach &(mr_offset, m2_offset) in r.iter() {\n             for uint::range_step(0, MIDPOINT, 4) |base| {\n                 rngstep!(0, 13);\n                 rngstep!(1, -6);\n@@ -1142,4 +1141,4 @@ mod bench {\n             rng.shuffle_mut(x);\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "edab639dfbe8b867e95fa0c721c464b4d28a5ee9", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -20,8 +20,9 @@ use cast::transmute;\n use char;\n use container::Container;\n use io::{Writer, WriterUtil};\n-use iterator::IteratorUtil;\n+use iterator::Iterator;\n use libc::c_void;\n+use option::{Some, None};\n use ptr;\n use reflect;\n use reflect::{MovePtr, align};\n@@ -175,7 +176,7 @@ impl ReprVisitor {\n \n     pub fn write_escaped_slice(&self, slice: &str) {\n         self.writer.write_char('\"');\n-        for slice.iter().advance |ch| {\n+        foreach ch in slice.iter() {\n             self.writer.write_escaped_char(ch);\n         }\n         self.writer.write_char('\"');"}, {"sha": "89803d022f84401c7601ac8fb97bfc6fdc1307e9", "filename": "src/libstd/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -15,7 +15,7 @@\n use clone::Clone;\n use cmp::Eq;\n use either;\n-use iterator::IteratorUtil;\n+use iterator::Iterator;\n use option::{None, Option, Some};\n use vec;\n use vec::{OwnedVector, ImmutableVector};\n@@ -263,7 +263,7 @@ impl<T, E: Clone> Result<T, E> {\n pub fn map_vec<T,U,V>(ts: &[T], op: &fn(&T) -> Result<V,U>)\n                       -> Result<~[V],U> {\n     let mut vs: ~[V] = vec::with_capacity(ts.len());\n-    for ts.iter().advance |t| {\n+    foreach t in ts.iter() {\n         match op(t) {\n           Ok(v) => vs.push(v),\n           Err(u) => return Err(u)"}, {"sha": "bb66a90123428a81d37384bf1184e669b6163eac", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -83,7 +83,7 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) {\n         Some(borrow_list) => { // recording borrows\n             let mut msg = ~\"borrowed\";\n             let mut sep = \" at \";\n-            for borrow_list.rev_iter().advance |entry| {\n+            foreach entry in borrow_list.rev_iter() {\n                 if entry.box == box {\n                     msg.push_str(sep);\n                     let filename = str::raw::from_c_str(entry.file);"}, {"sha": "44418001f14bb97247454e8d85236d7f76d6f40a", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -64,7 +64,7 @@ use cell::Cell;\n use clone::Clone;\n use container::Container;\n use iter::Times;\n-use iterator::IteratorUtil;\n+use iterator::{Iterator, IteratorUtil};\n use option::{Some, None};\n use ptr::RawPtr;\n use rt::sched::{Scheduler, Shutdown};\n@@ -291,7 +291,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     let on_exit: ~fn(bool) = |exit_success| {\n \n         let mut handles = handles.take();\n-        for handles.mut_iter().advance |handle| {\n+        foreach handle in handles.mut_iter() {\n             handle.send(Shutdown);\n         }\n \n@@ -346,7 +346,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     }\n \n     // Wait for schedulers\n-    for threads.consume_iter().advance() |thread| {\n+    foreach thread in threads.consume_iter() {\n         thread.join();\n     }\n "}, {"sha": "6296186aa4913dfed8e4a49d7f4a351dfb42417b", "filename": "src/libstd/rt/select.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fselect.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -37,7 +37,7 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n         fail!(\"can't select on an empty list\");\n     }\n \n-    for ports.mut_iter().enumerate().advance |(index, port)| {\n+    foreach (index, port) in ports.mut_iter().enumerate() {\n         if port.optimistic_check() {\n             return index;\n         }\n@@ -66,7 +66,7 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n     // Task resumes. Now unblock ourselves from all the ports we blocked on.\n     // If the success index wasn't reset, 'take' will just take all of them.\n     // Iterate in reverse so the 'earliest' index that's ready gets returned.\n-    for ports.mut_slice(0, ready_index).mut_rev_iter().enumerate().advance |(index, port)| {\n+    foreach (index, port) in ports.mut_slice(0, ready_index).mut_rev_iter().enumerate() {\n         if port.unblock_from() {\n             ready_index = index;\n         }\n@@ -127,7 +127,7 @@ mod test {\n         let (ports, chans) = unzip(from_fn(num_ports, |_| oneshot::<()>()));\n         let mut dead_chans = ~[];\n         let mut ports = ports;\n-        for chans.consume_iter().enumerate().advance |(i, chan)| {\n+        foreach (i, chan) in chans.consume_iter().enumerate() {\n             if send_on_chans.contains(&i) {\n                 chan.send(());\n             } else {\n@@ -144,7 +144,7 @@ mod test {\n         let (ports, chans) = unzip(from_fn(num_ports, |_| stream::<()>()));\n         let mut dead_chans = ~[];\n         let mut ports = ports;\n-        for chans.consume_iter().enumerate().advance |(i, chan)| {\n+        foreach (i, chan) in chans.consume_iter().enumerate() {\n             if send_on_chans.contains(&i) {\n                 chan.send(());\n             } else {\n@@ -191,7 +191,7 @@ mod test {\n             let mut ports = ports;\n             let mut port = Some(port);\n             let order = [5u,0,4,3,2,6,9,8,7,1];\n-            for order.iter().advance |&index| {\n+            foreach &index in order.iter() {\n                 // put the port in the vector at any index\n                 util::swap(port.get_mut_ref(), &mut ports[index]);\n                 assert!(select(ports) == index);"}, {"sha": "ec1094ed4f2546ceae036e0bf65c038bdc676f6c", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -14,7 +14,7 @@ use option::{Some, None};\n use cell::Cell;\n use clone::Clone;\n use container::Container;\n-use iterator::IteratorUtil;\n+use iterator::Iterator;\n use vec::{OwnedVector, MutableVector};\n use super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n use rt::sched::Scheduler;\n@@ -100,7 +100,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         let on_exit: ~fn(bool) = |exit_status| {\n             let mut handles = handles.take();\n             // Tell schedulers to exit\n-            for handles.mut_iter().advance |handle| {\n+            foreach handle in handles.mut_iter() {\n                 handle.send(Shutdown);\n             }\n \n@@ -125,7 +125,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         }\n \n         // Wait for schedulers\n-        for threads.consume_iter().advance() |thread| {\n+        foreach thread in threads.consume_iter() {\n             thread.join();\n         }\n     }\n@@ -380,7 +380,7 @@ fn base_port() -> uint {\n \n     let mut final_base = base;\n \n-    for bases.iter().advance |&(dir, base)| {\n+    foreach &(dir, base) in bases.iter() {\n         if path.contains(dir) {\n             final_base = base;\n             break;"}, {"sha": "773adb3848ad17bab629a964d9fc3d441f3061d0", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -606,6 +606,7 @@ mod test {\n     use rt::test::*;\n     use rt::uv::{Loop, AllocCallback};\n     use rt::uv::{vec_from_uv_buf, vec_to_uv_buf, slice_to_uv_buf};\n+    use prelude::*;\n \n     #[test]\n     fn connect_close_ip4() {\n@@ -700,7 +701,7 @@ mod test {\n                     if status.is_none() {\n                         rtdebug!(\"got %d bytes\", nread);\n                         let buf = buf.unwrap();\n-                        for buf.slice(0, nread as uint).iter().advance() |byte| {\n+                        foreach byte in buf.slice(0, nread as uint).iter() {\n                             assert!(*byte == count as u8);\n                             rtdebug!(\"%u\", *byte as uint);\n                             count += 1;\n@@ -776,7 +777,7 @@ mod test {\n                         rtdebug!(\"got %d bytes\", nread);\n                         let buf = buf.unwrap();\n                         let r = buf.slice(0, nread as uint);\n-                        for r.iter().advance |byte| {\n+                        foreach byte in r.iter() {\n                             assert!(*byte == count as u8);\n                             rtdebug!(\"%u\", *byte as uint);\n                             count += 1;\n@@ -847,7 +848,7 @@ mod test {\n                 rtdebug!(\"got %d bytes\", nread);\n \n                 let buf = buf.unwrap();\n-                for buf.slice(0, nread as uint).iter().advance() |&byte| {\n+                foreach &byte in buf.slice(0, nread as uint).iter() {\n                     assert!(byte == count as u8);\n                     rtdebug!(\"%u\", byte as uint);\n                     count += 1;\n@@ -907,7 +908,7 @@ mod test {\n                 rtdebug!(\"got %d bytes\", nread);\n \n                 let buf = buf.unwrap();\n-                for buf.slice(0, nread as uint).iter().advance() |&byte| {\n+                foreach &byte in buf.slice(0, nread as uint).iter() {\n                     assert!(byte == count as u8);\n                     rtdebug!(\"%u\", byte as uint);\n                     count += 1;"}, {"sha": "acdc97da58c7b9b1388f18efdf62d918c8e64124", "filename": "src/libstd/run.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -16,7 +16,6 @@ use cast;\n use clone::Clone;\n use comm::{stream, SharedChan, GenericChan, GenericPort};\n use io;\n-use iterator::IteratorUtil;\n use libc::{pid_t, c_void, c_int};\n use libc;\n use option::{Some, None};\n@@ -175,9 +174,9 @@ impl Process {\n                                    in_fd, out_fd, err_fd);\n \n         unsafe {\n-            for in_pipe.iter().advance  |pipe| { libc::close(pipe.input); }\n-            for out_pipe.iter().advance |pipe| { libc::close(pipe.out); }\n-            for err_pipe.iter().advance |pipe| { libc::close(pipe.out); }\n+            foreach pipe in in_pipe.iter() { libc::close(pipe.input); }\n+            foreach pipe in out_pipe.iter() { libc::close(pipe.out); }\n+            foreach pipe in err_pipe.iter() { libc::close(pipe.out); }\n         }\n \n         Process {\n@@ -322,7 +321,7 @@ impl Process {\n      * If the child has already been finished then the exit code is returned.\n      */\n     pub fn finish(&mut self) -> int {\n-        for self.exit_code.iter().advance |&code| {\n+        foreach &code in self.exit_code.iter() {\n             return code;\n         }\n         self.close_input();\n@@ -521,7 +520,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n         CloseHandle(si.hStdOutput);\n         CloseHandle(si.hStdError);\n \n-        for create_err.iter().advance |msg| {\n+        foreach msg in create_err.iter() {\n             fail!(\"failure in CreateProcess: %s\", *msg);\n         }\n \n@@ -580,7 +579,7 @@ pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n \n     let mut cmd = ~\"\";\n     append_arg(&mut cmd, prog);\n-    for args.iter().advance |arg| {\n+    foreach arg in args.iter() {\n         cmd.push_char(' ');\n         append_arg(&mut cmd, *arg);\n     }\n@@ -697,7 +696,7 @@ fn with_argv<T>(prog: &str, args: &[~str],\n                 cb: &fn(**libc::c_char) -> T) -> T {\n     let mut argptrs = ~[prog.as_c_str(|b| b)];\n     let mut tmps = ~[];\n-    for args.iter().advance |arg| {\n+    foreach arg in args.iter() {\n         let t = @(*arg).clone();\n         tmps.push(t);\n         argptrs.push(t.as_c_str(|b| b));\n@@ -715,7 +714,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n         let mut tmps = ~[];\n         let mut ptrs = ~[];\n \n-        for es.iter().advance |pair| {\n+        foreach pair in es.iter() {\n             // Use of match here is just to workaround limitations\n             // in the stage0 irrefutable pattern impl.\n             match pair {\n@@ -744,7 +743,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n     match env {\n       Some(es) => {\n         let mut blk = ~[];\n-        for es.iter().advance |pair| {\n+        foreach pair in es.iter() {\n             let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n             blk.push_all(kv.to_bytes_with_null());\n         }\n@@ -1300,7 +1299,7 @@ mod tests {\n         let output = str::from_bytes(prog.finish_with_output().output);\n \n         let r = os::env();\n-        for r.iter().advance |&(ref k, ref v)| {\n+        foreach &(ref k, ref v) in r.iter() {\n             // don't check windows magical empty-named variables\n             assert!(k.is_empty() || output.contains(fmt!(\"%s=%s\", *k, *v)));\n         }\n@@ -1314,7 +1313,7 @@ mod tests {\n         let output = str::from_bytes(prog.finish_with_output().output);\n \n         let r = os::env();\n-        for r.iter().advance |&(k, v)| {\n+        foreach &(k, v) in r.iter() {\n             // don't check android RANDOM variables\n             if k != ~\"RANDOM\" {\n                 assert!(output.contains(fmt!(\"%s=%s\", k, v)) ||"}, {"sha": "894351bcc53988e339e4cad3ae981970f694cf43", "filename": "src/libstd/str.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -149,7 +149,7 @@ pub fn from_char(ch: char) -> ~str {\n pub fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n     buf.reserve(chs.len());\n-    for chs.iter().advance |ch| {\n+    foreach ch in chs.iter() {\n         buf.push_char(*ch)\n     }\n     buf\n@@ -178,7 +178,7 @@ impl<'self, S: Str> StrVector for &'self [S] {\n         unsafe {\n             do s.as_mut_buf |buf, _| {\n                 let mut buf = buf;\n-                for self.iter().advance |ss| {\n+                foreach ss in self.iter() {\n                     do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n                         let sslen = sslen - 1;\n                         ptr::copy_memory(buf, ssbuf, sslen);\n@@ -211,7 +211,7 @@ impl<'self, S: Str> StrVector for &'self [S] {\n                 do sep.as_imm_buf |sepbuf, seplen| {\n                     let seplen = seplen - 1;\n                     let mut buf = cast::transmute_mut_unsafe(buf);\n-                    for self.iter().advance |ss| {\n+                    foreach ss in self.iter() {\n                         do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n                             let sslen = sslen - 1;\n                             if first {\n@@ -486,7 +486,7 @@ impl<'self> Iterator<&'self str> for StrSplitIterator<'self> {\n pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = ~\"\";\n     let mut last_end = 0;\n-    for s.matches_index_iter(from).advance |(start, end)| {\n+    foreach (start, end) in s.matches_index_iter(from) {\n         result.push_str(unsafe{raw::slice_bytes(s, last_end, start)});\n         result.push_str(to);\n         last_end = end;\n@@ -556,7 +556,7 @@ Section: Searching\n // Utility used by various searching functions\n fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n     let mut i = at;\n-    for needle.byte_iter().advance |c| { if haystack[i] != c { return false; } i += 1u; }\n+    foreach c in needle.byte_iter() { if haystack[i] != c { return false; } i += 1u; }\n     return true;\n }\n \n@@ -769,6 +769,7 @@ priv static MAX_UNICODE: uint = 1114112u;\n \n /// Unsafe operations\n pub mod raw {\n+    use option::Some;\n     use cast;\n     use libc;\n     use ptr;\n@@ -886,7 +887,7 @@ pub mod raw {\n     unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) {\n         let new_len = s.len() + bytes.len();\n         s.reserve_at_least(new_len);\n-        for bytes.iter().advance |byte| { push_byte(&mut *s, *byte); }\n+        foreach byte in bytes.iter() { push_byte(&mut *s, *byte); }\n     }\n \n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n@@ -938,6 +939,7 @@ pub mod traits {\n     use ops::Add;\n     use cmp::{TotalOrd, Ordering, Less, Equal, Greater, Eq, Ord, Equiv, TotalEq};\n     use super::{Str, eq_slice};\n+    use option::{Some, None};\n \n     impl<'self> Add<&'self str,~str> for &'self str {\n         #[inline]\n@@ -951,7 +953,7 @@ pub mod traits {\n     impl<'self> TotalOrd for &'self str {\n         #[inline]\n         fn cmp(&self, other: & &'self str) -> Ordering {\n-            for self.byte_iter().zip(other.byte_iter()).advance |(s_b, o_b)| {\n+            foreach (s_b, o_b) in self.byte_iter().zip(other.byte_iter()) {\n                 match s_b.cmp(&o_b) {\n                     Greater => return Greater,\n                     Less => return Less,\n@@ -1453,7 +1455,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn escape_default(&self) -> ~str {\n         let mut out: ~str = ~\"\";\n         out.reserve_at_least(self.len());\n-        for self.iter().advance |c| {\n+        foreach c in self.iter() {\n             do c.escape_default |c| {\n                 out.push_char(c);\n             }\n@@ -1465,7 +1467,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn escape_unicode(&self) -> ~str {\n         let mut out: ~str = ~\"\";\n         out.reserve_at_least(self.len());\n-        for self.iter().advance |c| {\n+        foreach c in self.iter() {\n             do c.escape_unicode |c| {\n                 out.push_char(c);\n             }\n@@ -1567,7 +1569,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     pub fn replace(&self, from: &str, to: &str) -> ~str {\n         let mut result = ~\"\";\n         let mut last_end = 0;\n-        for self.matches_index_iter(from).advance |(start, end)| {\n+        foreach (start, end) in self.matches_index_iter(from) {\n             result.push_str(unsafe{raw::slice_bytes(*self, last_end, start)});\n             result.push_str(to);\n             last_end = end;\n@@ -1605,7 +1607,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// Converts to a vector of `u16` encoded as UTF-16.\n     fn to_utf16(&self) -> ~[u16] {\n         let mut u = ~[];\n-        for self.iter().advance |ch| {\n+        foreach ch in self.iter() {\n             // Arithmetic with u32 literals is easier on the eyes than chars.\n             let mut ch = ch as u32;\n \n@@ -1758,12 +1760,12 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// or `None` if there is no match\n     fn find<C: CharEq>(&self, search: C) -> Option<uint> {\n         if search.only_ascii() {\n-            for self.byte_iter().enumerate().advance |(i, b)| {\n+            foreach (i, b) in self.byte_iter().enumerate() {\n                 if search.matches(b as char) { return Some(i) }\n             }\n         } else {\n             let mut index = 0;\n-            for self.iter().advance |c| {\n+            foreach c in self.iter() {\n                 if search.matches(c) { return Some(index); }\n                 index += c.len_utf8_bytes();\n             }\n@@ -1781,12 +1783,12 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {\n         let mut index = self.len();\n         if search.only_ascii() {\n-            for self.byte_rev_iter().advance |b| {\n+            foreach b in self.byte_rev_iter() {\n                 index -= 1;\n                 if search.matches(b as char) { return Some(index); }\n             }\n         } else {\n-            for self.rev_iter().advance |c| {\n+            foreach c in self.rev_iter() {\n                 index -= c.len_utf8_bytes();\n                 if search.matches(c) { return Some(index); }\n             }\n@@ -1855,7 +1857,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// Apply a function to each character.\n     fn map_chars(&self, ff: &fn(char) -> char) -> ~str {\n         let mut result = with_capacity(self.len());\n-        for self.iter().advance |cc| {\n+        foreach cc in self.iter() {\n             result.push_char(ff(cc));\n         }\n         result\n@@ -1871,12 +1873,12 @@ impl<'self> StrSlice<'self> for &'self str {\n \n         let mut dcol = vec::from_fn(tlen + 1, |x| x);\n \n-        for self.iter().enumerate().advance |(i, sc)| {\n+        foreach (i, sc) in self.iter().enumerate() {\n \n             let mut current = i;\n             dcol[0] = current + 1;\n \n-            for t.iter().enumerate().advance |(j, tc)| {\n+            foreach (j, tc) in t.iter().enumerate() {\n \n                 let next = dcol[j + 1];\n \n@@ -1903,7 +1905,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// ~~~ {.rust}\n     /// let string = \"a\\nb\\nc\";\n     /// let mut lines = ~[];\n-    /// for string.line_iter().advance |line| { lines.push(line) }\n+    /// foreach line in string.line_iter() { lines.push(line) }\n     ///\n     /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n     /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n@@ -2238,7 +2240,7 @@ impl<T: Iterator<char>> Extendable<char, T> for ~str {\n         let (lower, _) = iterator.size_hint();\n         let reserve = lower + self.len();\n         self.reserve_at_least(reserve);\n-        for iterator.advance |ch| {\n+        foreach ch in *iterator {\n             self.push_char(ch)\n         }\n     }\n@@ -2269,7 +2271,6 @@ mod tests {\n     use libc;\n     use ptr;\n     use str::*;\n-    use uint;\n     use vec;\n     use vec::{ImmutableVector, CopyableVector};\n     use cmp::{TotalOrd, Less, Equal, Greater};\n@@ -3055,7 +3056,7 @@ mod tests {\n \n         let string = \"a\\nb\\nc\";\n         let mut lines = ~[];\n-        for string.line_iter().advance |line| { lines.push(line) }\n+        foreach line in string.line_iter() { lines.push(line) }\n         assert_eq!(string.subslice_offset(lines[0]), 0);\n         assert_eq!(string.subslice_offset(lines[1]), 2);\n         assert_eq!(string.subslice_offset(lines[2]), 4);\n@@ -3159,7 +3160,7 @@ mod tests {\n                 0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n                 0x000a_u16 ]) ];\n \n-        for pairs.iter().advance |p| {\n+        foreach p in pairs.iter() {\n             let (s, u) = (*p).clone();\n             assert!(s.to_utf16() == u);\n             assert!(from_utf16(u) == s);\n@@ -3173,7 +3174,7 @@ mod tests {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = 0;\n-        for v.iter().advance |ch| {\n+        foreach ch in v.iter() {\n             assert!(s.char_at(pos) == *ch);\n             pos += from_char(*ch).len();\n         }\n@@ -3184,7 +3185,7 @@ mod tests {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = s.len();\n-        for v.rev_iter().advance |ch| {\n+        foreach ch in v.rev_iter() {\n             assert!(s.char_at_reverse(pos) == *ch);\n             pos -= from_char(*ch).len();\n         }\n@@ -3276,7 +3277,7 @@ mod tests {\n         let mut pos = 0;\n         let mut it = s.iter();\n \n-        for it.advance |c| {\n+        foreach c in it {\n             assert_eq!(c, v[pos]);\n             pos += 1;\n         }\n@@ -3292,7 +3293,7 @@ mod tests {\n         let mut pos = 0;\n         let mut it = s.rev_iter();\n \n-        for it.advance |c| {\n+        foreach c in it {\n             assert_eq!(c, v[pos]);\n             pos += 1;\n         }\n@@ -3309,7 +3310,7 @@ mod tests {\n         ];\n         let mut pos = 0;\n \n-        for s.byte_iter().advance |b| {\n+        foreach b in s.byte_iter() {\n             assert_eq!(b, v[pos]);\n             pos += 1;\n         }\n@@ -3325,7 +3326,7 @@ mod tests {\n         ];\n         let mut pos = v.len();\n \n-        for s.byte_rev_iter().advance |b| {\n+        foreach b in s.byte_rev_iter() {\n             pos -= 1;\n             assert_eq!(b, v[pos]);\n         }\n@@ -3341,7 +3342,7 @@ mod tests {\n         let mut pos = 0;\n         let mut it = s.char_offset_iter();\n \n-        for it.advance |c| {\n+        foreach c in it {\n             assert_eq!(c, (p[pos], v[pos]));\n             pos += 1;\n         }\n@@ -3359,7 +3360,7 @@ mod tests {\n         let mut pos = 0;\n         let mut it = s.char_offset_rev_iter();\n \n-        for it.advance |c| {\n+        foreach c in it {\n             assert_eq!(c, (p[pos], v[pos]));\n             pos += 1;\n         }"}, {"sha": "3f24f98bd3d2a25a25891f8d1b0932d1232b8f0d", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -14,9 +14,10 @@ use to_str::{ToStr,ToStrConsume};\n use str;\n use str::StrSlice;\n use cast;\n-use iterator::IteratorUtil;\n+use iterator::{Iterator, IteratorUtil};\n use vec::{CopyableVector, ImmutableVector, OwnedVector};\n use to_bytes::IterBytes;\n+use option::{Some, None};\n \n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n #[deriving(Clone, Eq)]\n@@ -93,7 +94,7 @@ impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n \n     #[inline]\n     fn is_ascii(&self) -> bool {\n-        for self.iter().advance |b| {\n+        foreach b in self.iter() {\n             if !b.is_ascii() { return false; }\n         }\n         true"}, {"sha": "69c4bb20caff23cb67fe94121da1ce94d07590cd", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -167,7 +167,7 @@ pub unsafe fn local_pop<T: 'static>(handle: Handle,\n     let map = get_local_map(handle);\n     let key_value = key_to_key_value(key);\n \n-    for map.mut_iter().advance |entry| {\n+    foreach entry in map.mut_iter() {\n         match *entry {\n             Some((k, _, loan)) if k == key_value => {\n                 if loan != NoLoan {"}, {"sha": "c7f34974a6e09cd3f50dadcfecfb2babbb2f4cc5", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -96,7 +96,6 @@ use rt::local::Local;\n use rt::task::Task;\n use rt::kill::KillHandle;\n use rt::sched::Scheduler;\n-use iterator::IteratorUtil;\n \n #[cfg(test)] use task::default_task_opts;\n #[cfg(test)] use comm;\n@@ -356,7 +355,7 @@ impl Drop for Taskgroup {\n             // If we are failing, the whole taskgroup needs to die.\n             do RuntimeGlue::with_task_handle_and_failing |me, failing| {\n                 if failing {\n-                    for this.notifier.mut_iter().advance |x| {\n+                    foreach x in this.notifier.mut_iter() {\n                         x.failed = true;\n                     }\n                     // Take everybody down with us.\n@@ -385,7 +384,7 @@ pub fn Taskgroup(tasks: TaskGroupArc,\n        ancestors: AncestorList,\n        is_main: bool,\n        mut notifier: Option<AutoNotify>) -> Taskgroup {\n-    for notifier.mut_iter().advance |x| {\n+    foreach x in notifier.mut_iter() {\n         x.failed = false;\n     }\n \n@@ -463,13 +462,13 @@ fn kill_taskgroup(state: TaskGroupInner, me: &TaskHandle, is_main: bool) {\n         if newstate.is_some() {\n             let TaskGroupData { members: members, descendants: descendants } =\n                 newstate.unwrap();\n-            for members.consume().advance |sibling| {\n+            foreach sibling in members.consume() {\n                 // Skip self - killing ourself won't do much good.\n                 if &sibling != me {\n                     RuntimeGlue::kill_task(sibling);\n                 }\n             }\n-            for descendants.consume().advance |child| {\n+            foreach child in descendants.consume() {\n                 assert!(&child != me);\n                 RuntimeGlue::kill_task(child);\n             }"}, {"sha": "b87a165706516ff3ae56256284521d06497d87ff", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -14,11 +14,12 @@ The `ToStr` trait for converting to strings\n \n */\n \n+use option::{Some, None};\n use str::OwnedStr;\n use hashmap::HashMap;\n use hashmap::HashSet;\n use hash::Hash;\n-use iterator::IteratorUtil;\n+use iterator::Iterator;\n use cmp::Eq;\n use vec::ImmutableVector;\n \n@@ -55,7 +56,7 @@ impl<A:ToStr+Hash+Eq, B:ToStr> ToStr for HashMap<A, B> {\n     fn to_str(&self) -> ~str {\n         let mut acc = ~\"{\";\n         let mut first = true;\n-        for self.iter().advance |(key, value)| {\n+        foreach (key, value) in self.iter() {\n             if first {\n                 first = false;\n             }\n@@ -76,7 +77,7 @@ impl<A:ToStr+Hash+Eq> ToStr for HashSet<A> {\n     fn to_str(&self) -> ~str {\n         let mut acc = ~\"{\";\n         let mut first = true;\n-        for self.iter().advance |element| {\n+        foreach element in self.iter() {\n             if first {\n                 first = false;\n             }\n@@ -125,7 +126,7 @@ impl<'self,A:ToStr> ToStr for &'self [A] {\n     fn to_str(&self) -> ~str {\n         let mut acc = ~\"[\";\n         let mut first = true;\n-        for self.iter().advance |elt| {\n+        foreach elt in self.iter() {\n             if first {\n                 first = false;\n             }\n@@ -144,7 +145,7 @@ impl<A:ToStr> ToStr for ~[A] {\n     fn to_str(&self) -> ~str {\n         let mut acc = ~\"[\";\n         let mut first = true;\n-        for self.iter().advance |elt| {\n+        foreach elt in self.iter() {\n             if first {\n                 first = false;\n             }\n@@ -163,7 +164,7 @@ impl<A:ToStr> ToStr for @[A] {\n     fn to_str(&self) -> ~str {\n         let mut acc = ~\"[\";\n         let mut first = true;\n-        for self.iter().advance |elt| {\n+        foreach elt in self.iter() {\n             if first {\n                 first = false;\n             }"}, {"sha": "704e3a500f12bf6f79ca445f7904e2a56d95f859", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -164,7 +164,7 @@ impl<T, Iter: Iterator<(uint, T)>> FromIterator<(uint, T), Iter> for TrieMap<T>\n \n impl<T, Iter: Iterator<(uint, T)>> Extendable<(uint, T), Iter> for TrieMap<T> {\n     fn extend(&mut self, iter: &mut Iter) {\n-        for iter.advance |(k, v)| {\n+        foreach (k, v) in *iter {\n             self.insert(k, v);\n         }\n     }\n@@ -235,7 +235,7 @@ impl<Iter: Iterator<uint>> FromIterator<uint, Iter> for TrieSet {\n \n impl<Iter: Iterator<uint>> Extendable<uint, Iter> for TrieSet {\n     fn extend(&mut self, iter: &mut Iter) {\n-        for iter.advance |elem| {\n+        foreach elem in *iter {\n             self.insert(elem);\n         }\n     }\n@@ -283,7 +283,7 @@ impl<T> TrieNode<T> {\n     }\n \n     fn mutate_values<'a>(&'a mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n-        for self.children.mut_iter().advance |child| {\n+        foreach child in self.children.mut_iter() {\n             match *child {\n                 Internal(ref mut x) => if !x.mutate_values(|i,t| f(i,t)) {\n                     return false\n@@ -379,7 +379,7 @@ pub fn check_integrity<T>(trie: &TrieNode<T>) {\n \n     let mut sum = 0;\n \n-    for trie.children.iter().advance |x| {\n+    foreach x in trie.children.iter() {\n         match *x {\n           Nothing => (),\n           Internal(ref y) => {\n@@ -544,7 +544,7 @@ mod test_map {\n \n         let map: TrieMap<int> = xs.iter().transform(|&x| x).collect();\n \n-        for xs.iter().advance |&(k, v)| {\n+        foreach &(k, v) in xs.iter() {\n             assert_eq!(map.find(&k), Some(&v));\n         }\n     }\n@@ -553,6 +553,7 @@ mod test_map {\n #[cfg(test)]\n mod test_set {\n     use super::*;\n+    use prelude::*;\n     use uint;\n \n     #[test]\n@@ -583,7 +584,7 @@ mod test_set {\n \n         let set: TrieSet = xs.iter().transform(|&x| x).collect();\n \n-        for xs.iter().advance |x| {\n+        foreach x in xs.iter() {\n             assert!(set.contains(x));\n         }\n     }"}, {"sha": "a8cdd1fb2dcc79c02811e68536f8eeba0c0fa5e9", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -77,7 +77,6 @@ debug!(\"hello, %s!\", \"world\");\n */\n \n use prelude::*;\n-use iterator::IteratorUtil;\n \n /*\n  * We have a 'ct' (compile-time) module that parses format strings into a\n@@ -616,7 +615,7 @@ pub mod rt {\n         let headsize = match head { Some(_) => 1, _ => 0 };\n         let uwidth : uint = match cv.width {\n             CountImplied => {\n-                for head.iter().advance |&c| {\n+                foreach &c in head.iter() {\n                     buf.push_char(c);\n                 }\n                 return buf.push_str(s);\n@@ -625,15 +624,15 @@ pub mod rt {\n         };\n         let strlen = s.char_len() + headsize;\n         if uwidth <= strlen {\n-            for head.iter().advance |&c| {\n+            foreach &c in head.iter() {\n                 buf.push_char(c);\n             }\n             return buf.push_str(s);\n         }\n         let mut padchar = ' ';\n         let diff = uwidth - strlen;\n         if have_flag(cv.flags, flag_left_justify) {\n-            for head.iter().advance |&c| {\n+            foreach &c in head.iter() {\n                 buf.push_char(c);\n             }\n             buf.push_str(s);\n@@ -667,7 +666,7 @@ pub mod rt {\n         // instead.\n \n         if signed && zero_padding {\n-            for head.iter().advance |&head| {\n+            foreach &head in head.iter() {\n                 if head == '+' || head == '-' || head == ' ' {\n                     buf.push_char(head);\n                     buf.push_str(padstr);\n@@ -677,7 +676,7 @@ pub mod rt {\n             }\n         }\n         buf.push_str(padstr);\n-        for head.iter().advance |&c| {\n+        foreach &c in head.iter() {\n             buf.push_char(c);\n         }\n         buf.push_str(s);"}, {"sha": "1fae96e78475c983ff929badbd2b6f3bdf6bb459", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -425,7 +425,7 @@ mod tests {\n                 }\n             };\n \n-            for futures.iter().advance |f| { f.recv() }\n+            foreach f in futures.iter() { f.recv() }\n \n             do total.with |total| {\n                 assert!(**total == num_tasks * count)"}, {"sha": "534dc27196c30b0943533d01fa39b6e2ddaa05e2", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -295,7 +295,7 @@ pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n  */\n pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n-    for v.iter().advance |elem| { result.push_all_move(f(elem)); }\n+    foreach elem in v.iter() { result.push_all_move(f(elem)); }\n     result\n }\n \n@@ -329,7 +329,7 @@ impl<'self, T:Clone> VectorVector<T> for &'self [~[T]] {\n     pub fn connect_vec(&self, sep: &T) -> ~[T] {\n         let mut r = ~[];\n         let mut first = true;\n-        for self.iter().advance |inner| {\n+        foreach inner in self.iter() {\n             if first { first = false; } else { r.push((*sep).clone()); }\n             r.push_all((*inner).clone());\n         }\n@@ -347,7 +347,7 @@ impl<'self,T:Clone> VectorVector<T> for &'self [&'self [T]] {\n     pub fn connect_vec(&self, sep: &T) -> ~[T] {\n         let mut r = ~[];\n         let mut first = true;\n-        for self.iter().advance |&inner| {\n+        foreach &inner in self.iter() {\n             if first { first = false; } else { r.push((*sep).clone()); }\n             r.push_all(inner);\n         }\n@@ -365,7 +365,7 @@ impl<'self,T:Clone> VectorVector<T> for &'self [&'self [T]] {\n pub fn unzip_slice<T:Clone,U:Clone>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[];\n     let mut us = ~[];\n-    for v.iter().advance |p| {\n+    foreach p in v.iter() {\n         let (t, u) = (*p).clone();\n         ts.push(t);\n         us.push(u);\n@@ -384,7 +384,7 @@ pub fn unzip_slice<T:Clone,U:Clone>(v: &[(T, U)]) -> (~[T], ~[U]) {\n pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[];\n     let mut us = ~[];\n-    for v.consume_iter().advance |p| {\n+    foreach p in v.consume_iter() {\n         let (t, u) = p;\n         ts.push(t);\n         us.push(u);\n@@ -530,6 +530,7 @@ pub mod traits {\n     use clone::Clone;\n     use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Equal, Equiv};\n     use ops::Add;\n+    use option::{Some, None};\n \n     impl<'self,T:Eq> Eq for &'self [T] {\n         fn eq(&self, other: & &'self [T]) -> bool {\n@@ -588,7 +589,7 @@ pub mod traits {\n \n     impl<'self,T:TotalOrd> TotalOrd for &'self [T] {\n         fn cmp(&self, other: & &'self [T]) -> Ordering {\n-            for self.iter().zip(other.iter()).advance |(s,o)| {\n+            foreach (s,o) in self.iter().zip(other.iter()) {\n                 match s.cmp(o) {\n                     Equal => {},\n                     non_eq => { return non_eq; }\n@@ -610,7 +611,7 @@ pub mod traits {\n \n     impl<'self,T:Ord> Ord for &'self [T] {\n         fn lt(&self, other: & &'self [T]) -> bool {\n-            for self.iter().zip(other.iter()).advance |(s,o)| {\n+            foreach (s,o) in self.iter().zip(other.iter()) {\n                 if *s < *o { return true; }\n                 if *s > *o { return false; }\n             }\n@@ -724,7 +725,7 @@ impl<'self,T:Clone> CopyableVector<T> for &'self [T] {\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n         let mut result = with_capacity(self.len());\n-        for self.iter().advance |e| {\n+        foreach e in self.iter() {\n             result.push((*e).clone());\n         }\n         result\n@@ -879,7 +880,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      *\n      * ~~~ {.rust}\n      * let v = &[1,2,3,4];\n-     * for v.window_iter().advance |win| {\n+     * foreach win in v.window_iter() {\n      *     printfln!(win);\n      * }\n      * ~~~\n@@ -908,7 +909,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      *\n      * ~~~ {.rust}\n      * let v = &[1,2,3,4,5];\n-     * for v.chunk_iter().advance |win| {\n+     * foreach win in v.chunk_iter() {\n      *     printfln!(win);\n      * }\n      * ~~~\n@@ -974,7 +975,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      */\n     #[inline]\n     fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n-        for self.rev_iter().enumerate().advance |(i, t)| {\n+        foreach (i, t) in self.rev_iter().enumerate() {\n             if f(t) { return Some(self.len() - i - 1); }\n         }\n         None\n@@ -1074,7 +1075,7 @@ impl<'self,T:Eq> ImmutableEqVector<T> for &'self [T] {\n \n     /// Return true if a vector contains an element with the given value\n     fn contains(&self, x: &T) -> bool {\n-        for self.iter().advance |elt| { if *x == *elt { return true; } }\n+        foreach elt in self.iter() { if *x == *elt { return true; } }\n         false\n     }\n }\n@@ -1112,7 +1113,7 @@ impl<'self,T:Clone> ImmutableCopyableVector<T> for &'self [T] {\n         let mut lefts  = ~[];\n         let mut rights = ~[];\n \n-        for self.iter().advance |elt| {\n+        foreach elt in self.iter() {\n             if f(elt) {\n                 lefts.push((*elt).clone());\n             } else {\n@@ -1169,7 +1170,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     ///\n     /// ~~~ {.rust}\n     /// let v = ~[~\"a\", ~\"b\"];\n-    /// for v.consume_iter().advance |s| {\n+    /// foreach s in v.consume_iter() {\n     ///   // s has type ~str, not &~str\n     ///   println(s);\n     /// }\n@@ -1498,7 +1499,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         let mut lefts  = ~[];\n         let mut rights = ~[];\n \n-        for self.consume_iter().advance |elt| {\n+        foreach elt in self.consume_iter() {\n             if f(&elt) {\n                 lefts.push(elt);\n             } else {\n@@ -1831,7 +1832,7 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n \n     #[inline]\n     fn move_from(self, mut src: ~[T], start: uint, end: uint) -> uint {\n-        for self.mut_iter().zip(src.mut_slice(start, end).mut_iter()).advance |(a, b)| {\n+        foreach (a, b) in self.mut_iter().zip(src.mut_slice(start, end).mut_iter()) {\n             util::swap(a, b);\n         }\n         cmp::min(self.len(), end-start)\n@@ -1866,7 +1867,7 @@ pub trait MutableCloneableVector<T> {\n impl<'self, T:Clone> MutableCloneableVector<T> for &'self mut [T] {\n     #[inline]\n     fn copy_from(self, src: &[T]) -> uint {\n-        for self.mut_iter().zip(src.iter()).advance |(a, b)| {\n+        foreach (a, b) in self.mut_iter().zip(src.iter()) {\n             *a = b.clone();\n         }\n         cmp::min(self.len(), src.len())\n@@ -2268,7 +2269,7 @@ impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n     fn from_iterator(iterator: &mut T) -> ~[A] {\n         let (lower, _) = iterator.size_hint();\n         let mut xs = with_capacity(lower);\n-        for iterator.advance |x| {\n+        foreach x in *iterator {\n             xs.push(x);\n         }\n         xs\n@@ -2280,7 +2281,7 @@ impl<A, T: Iterator<A>> Extendable<A, T> for ~[A] {\n         let (lower, _) = iterator.size_hint();\n         let len = self.len();\n         self.reserve(len + lower);\n-        for iterator.advance |x| {\n+        foreach x in *iterator {\n             self.push(x);\n         }\n     }\n@@ -3237,7 +3238,7 @@ mod tests {\n     fn test_mut_iterator() {\n         use iterator::*;\n         let mut xs = [1, 2, 3, 4, 5];\n-        for xs.mut_iter().advance |x| {\n+        foreach x in xs.mut_iter() {\n             *x += 1;\n         }\n         assert_eq!(xs, [2, 3, 4, 5, 6])\n@@ -3250,7 +3251,7 @@ mod tests {\n         let xs = [1, 2, 5, 10, 11];\n         let ys = [11, 10, 5, 2, 1];\n         let mut i = 0;\n-        for xs.rev_iter().advance |&x| {\n+        foreach &x in xs.rev_iter() {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -3261,7 +3262,7 @@ mod tests {\n     fn test_mut_rev_iterator() {\n         use iterator::*;\n         let mut xs = [1u, 2, 3, 4, 5];\n-        for xs.mut_rev_iter().enumerate().advance |(i,x)| {\n+        foreach (i,x) in xs.mut_rev_iter().enumerate() {\n             *x += i;\n         }\n         assert_eq!(xs, [5, 5, 5, 5, 5])\n@@ -3501,12 +3502,12 @@ mod tests {\n         {\n             let (left, right) = values.mut_split(2);\n             assert_eq!(left.slice(0, left.len()), [1, 2]);\n-            for left.mut_iter().advance |p| {\n+            foreach p in left.mut_iter() {\n                 *p += 1;\n             }\n \n             assert_eq!(right.slice(0, right.len()), [3, 4, 5]);\n-            for right.mut_iter().advance |p| {\n+            foreach p in right.mut_iter() {\n                 *p += 2;\n             }\n         }\n@@ -3523,25 +3524,25 @@ mod tests {\n         assert_eq!(v.len(), 3);\n         let mut cnt = 0;\n \n-        for v.iter().advance |f| {\n+        foreach f in v.iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 3);\n \n-        for v.slice(1, 3).iter().advance |f| {\n+        foreach f in v.slice(1, 3).iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 5);\n \n-        for v.mut_iter().advance |f| {\n+        foreach f in v.mut_iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 8);\n \n-        for v.consume_iter().advance |f| {\n+        foreach f in v.consume_iter() {\n             assert!(f == Foo);\n             cnt += 1;\n         }\n@@ -3553,7 +3554,7 @@ mod tests {\n         let xs: [Foo, ..3] = [Foo, Foo, Foo];\n         assert_eq!(fmt!(\"%?\", xs.slice(0, 2).to_owned()), ~\"~[{}, {}]\");\n         cnt = 0;\n-        for xs.iter().advance |f| {\n+        foreach f in xs.iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }"}, {"sha": "e086334eb489fa735ace599e00ec42172a56a065", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -209,9 +209,9 @@ impl AbiSet {\n         let mut abis = ~[];\n         for self.each |abi| { abis.push(abi); }\n \n-        for abis.iter().enumerate().advance |(i, abi)| {\n+        foreach (i, abi) in abis.iter().enumerate() {\n             let data = abi.data();\n-            for abis.slice(0, i).iter().advance |other_abi| {\n+            foreach other_abi in abis.slice(0, i).iter() {\n                 let other_data = other_abi.data();\n                 debug!(\"abis=(%?,%?) datas=(%?,%?)\",\n                        abi, data.abi_arch,\n@@ -372,7 +372,7 @@ fn abi_to_str_rust() {\n \n #[test]\n fn indices_are_correct() {\n-    for AbiDatas.iter().enumerate().advance |(i, abi_data)| {\n+    foreach (i, abi_data) in AbiDatas.iter().enumerate() {\n         assert!(i == abi_data.abi.index());\n     }\n \n@@ -387,7 +387,7 @@ fn indices_are_correct() {\n #[cfg(test)]\n fn check_arch(abis: &[Abi], arch: Architecture, expect: Option<Abi>) {\n     let mut set = AbiSet::empty();\n-    for abis.iter().advance |&abi| {\n+    foreach &abi in abis.iter() {\n         set.add(abi);\n     }\n     let r = set.for_arch(arch);"}, {"sha": "bee0f113aa7476c5c26f08eba6aab5c7047ec398", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -163,7 +163,7 @@ pub fn map_fn(\n     (cx,v): (@mut Ctx,\n              visit::vt<@mut Ctx>)\n ) {\n-    for decl.inputs.iter().advance |a| {\n+    foreach a in decl.inputs.iter() {\n         cx.map.insert(a.id, node_arg);\n     }\n     visit::visit_fn(fk, decl, body, sp, id, (cx, v));\n@@ -201,20 +201,20 @@ pub fn map_item(i: @item, (cx, v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n     match i.node {\n         item_impl(_, _, _, ref ms) => {\n             let impl_did = ast_util::local_def(i.id);\n-            for ms.iter().advance |m| {\n+            foreach m in ms.iter() {\n                 map_method(impl_did, extend(cx, i.ident), *m, false, cx);\n             }\n         }\n         item_enum(ref enum_definition, _) => {\n-            for (*enum_definition).variants.iter().advance |v| {\n+            foreach v in (*enum_definition).variants.iter() {\n                 cx.map.insert(v.node.id, node_variant(\n                     /* FIXME (#2543) */ (*v).clone(),\n                     i,\n                     extend(cx, i.ident)));\n             }\n         }\n         item_foreign_mod(ref nm) => {\n-            for nm.items.iter().advance |nitem| {\n+            foreach nitem in nm.items.iter() {\n                 // Compute the visibility for this native item.\n                 let visibility = match nitem.vis {\n                     public => public,\n@@ -248,10 +248,10 @@ pub fn map_item(i: @item, (cx, v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n             );\n         }\n         item_trait(_, ref traits, ref methods) => {\n-            for traits.iter().advance |p| {\n+            foreach p in traits.iter() {\n                 cx.map.insert(p.ref_id, node_item(i, item_path));\n             }\n-            for methods.iter().advance |tm| {\n+            foreach tm in methods.iter() {\n                 let id = ast_util::trait_method_to_ty_method(tm).id;\n                 let d_id = ast_util::local_def(i.id);\n                 cx.map.insert(\n@@ -301,7 +301,7 @@ pub fn map_expr(ex: @expr, (cx,v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n     // Expressions which are or might be calls:\n     {\n         let r = ex.get_callee_id();\n-        for r.iter().advance |callee_id| {\n+        foreach callee_id in r.iter() {\n             cx.map.insert(*callee_id, node_callee_scope(ex));\n         }\n     }"}, {"sha": "b8a2ea1b57db958848f910367b095ddbd2fdecdc", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -278,7 +278,7 @@ pub fn split_trait_methods(trait_methods: &[trait_method])\n     -> (~[TypeMethod], ~[@method]) {\n     let mut reqd = ~[];\n     let mut provd = ~[];\n-    for trait_methods.iter().advance |trt_method| {\n+    foreach trt_method in trait_methods.iter() {\n         match *trt_method {\n           required(ref tm) => reqd.push((*tm).clone()),\n           provided(m) => provd.push(m)\n@@ -391,10 +391,10 @@ impl id_range {\n \n pub fn id_visitor<T: Clone>(vfn: @fn(NodeId, T)) -> visit::vt<T> {\n     let visit_generics: @fn(&Generics, T) = |generics, t| {\n-        for generics.ty_params.iter().advance |p| {\n+        foreach p in generics.ty_params.iter() {\n             vfn(p.id, t.clone());\n         }\n-        for generics.lifetimes.iter().advance |p| {\n+        foreach p in generics.lifetimes.iter() {\n             vfn(p.id, t.clone());\n         }\n     };\n@@ -408,13 +408,13 @@ pub fn id_visitor<T: Clone>(vfn: @fn(NodeId, T)) -> visit::vt<T> {\n             match vi.node {\n               view_item_extern_mod(_, _, id) => vfn(id, t.clone()),\n               view_item_use(ref vps) => {\n-                  for vps.iter().advance |vp| {\n+                  foreach vp in vps.iter() {\n                       match vp.node {\n                           view_path_simple(_, _, id) => vfn(id, t.clone()),\n                           view_path_glob(_, id) => vfn(id, t.clone()),\n                           view_path_list(_, ref paths, id) => {\n                               vfn(id, t.clone());\n-                              for paths.iter().advance |p| {\n+                              foreach p in paths.iter() {\n                                   vfn(p.node.id, t.clone());\n                               }\n                           }\n@@ -434,7 +434,7 @@ pub fn id_visitor<T: Clone>(vfn: @fn(NodeId, T)) -> visit::vt<T> {\n             vfn(i.id, t.clone());\n             match i.node {\n               item_enum(ref enum_definition, _) =>\n-                for (*enum_definition).variants.iter().advance |v| {\n+                foreach v in (*enum_definition).variants.iter() {\n                     vfn(v.node.id, t.clone());\n                 },\n               _ => ()\n@@ -462,7 +462,7 @@ pub fn id_visitor<T: Clone>(vfn: @fn(NodeId, T)) -> visit::vt<T> {\n         visit_expr: |e, (t, vt)| {\n             {\n                 let r = e.get_callee_id();\n-                for r.iter().advance |callee_id| {\n+                foreach callee_id in r.iter() {\n                     vfn(*callee_id, t.clone());\n                 }\n             }\n@@ -500,7 +500,7 @@ pub fn id_visitor<T: Clone>(vfn: @fn(NodeId, T)) -> visit::vt<T> {\n                 }\n             }\n \n-            for d.inputs.iter().advance |arg| {\n+            foreach arg in d.inputs.iter() {\n                 vfn(arg.id, t.clone())\n             }\n             visit::visit_fn(fk, d, a, b, id, (t.clone(), vt));"}, {"sha": "615b47e56813b58d063d8abf18e1ff677ba0f862", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -228,7 +228,7 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n  */\n pub fn find_linkage_metas(attrs: &[Attribute]) -> ~[@MetaItem] {\n     let mut result = ~[];\n-    for attrs.iter().filter(|at| \"link\" == at.name()).advance |attr| {\n+    foreach attr in attrs.iter().filter(|at| \"link\" == at.name()) {\n         match attr.meta().node {\n             MetaList(_, ref items) => result.push_all(*items),\n             _ => ()\n@@ -316,7 +316,7 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n pub fn require_unique_names(diagnostic: @span_handler,\n                             metas: &[@MetaItem]) {\n     let mut set = HashSet::new();\n-    for metas.iter().advance |meta| {\n+    foreach meta in metas.iter() {\n         let name = meta.name();\n \n         // FIXME: How do I silence the warnings? --pcw (#2619)"}, {"sha": "d89057890f1e9e93360775fcc4b628ef5911ea91", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -379,7 +379,7 @@ impl CodeMap {\n     }\n \n     pub fn get_filemap(&self, filename: &str) -> @FileMap {\n-        for self.files.iter().advance |fm| { if filename == fm.name { return *fm; } }\n+        foreach fm in self.files.iter() { if filename == fm.name { return *fm; } }\n         //XXjdm the following triggers a mismatched type bug\n         //      (or expected function, found _|_)\n         fail!(); // (\"asking for \" + filename + \" which we don't know about\");\n@@ -465,7 +465,7 @@ impl CodeMap {\n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n-        for map.multibyte_chars.iter().advance |mbc| {\n+        foreach mbc in map.multibyte_chars.iter() {\n             debug!(\"codemap: %?-byte char at %?\", mbc.bytes, mbc.pos);\n             if mbc.pos < bpos {\n                 total_extra_bytes += mbc.bytes;"}, {"sha": "4c7c9c0c325570973f7be0a69eb406d7103cbf5f", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -268,7 +268,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n         elided = true;\n     }\n     // Print the offending lines\n-    for display_lines.iter().advance |line| {\n+    foreach line in display_lines.iter() {\n         io::stderr().write_str(fmt!(\"%s:%u \", fm.name, *line + 1u));\n         let s = fm.get_line(*line as int) + \"\\n\";\n         io::stderr().write_str(s);\n@@ -332,7 +332,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n }\n \n fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n-    for sp.expn_info.iter().advance |ei| {\n+    foreach ei in sp.expn_info.iter() {\n         let ss = ei.callee.span.map_default(~\"\", |span| cm.span_to_str(*span));\n         print_diagnostic(ss, note,\n                          fmt!(\"in expansion of %s!\", ei.callee.name));"}, {"sha": "9b2b37fe402a5643be218dd75a4e3dd3a589abdf", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -21,13 +21,13 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> bas\n     let exprs = get_exprs_from_tts(cx, sp, tts);\n     let mut bytes = ~[];\n \n-    for exprs.iter().advance |expr| {\n+    foreach expr in exprs.iter() {\n         match expr.node {\n             // expression is a literal\n             ast::expr_lit(lit) => match lit.node {\n                 // string literal, push each byte to vector expression\n                 ast::lit_str(s) => {\n-                    for s.byte_iter().advance |byte| {\n+                    foreach byte in s.byte_iter() {\n                         bytes.push(cx.expr_u8(sp, byte));\n                     }\n                 }"}, {"sha": "e47e3078636780037b9af1568c71b67c38aa20c3", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -18,7 +18,7 @@ use parse::token::{str_to_ident};\n pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let mut res_str = ~\"\";\n-    for tts.iter().enumerate().advance |(i, e)| {\n+    foreach (i, e) in tts.iter().enumerate() {\n         if i & 1 == 1 {\n             match *e {\n                 ast::tt_tok(_, token::COMMA) => (),"}, {"sha": "30dd89b02f1b2585e1063f31bd310446726b3f74", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -110,7 +110,7 @@ fn decodable_substructure(cx: @ExtCtxt, span: span,\n             let mut variants = ~[];\n             let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n \n-            for fields.iter().enumerate().advance |(i, f)| {\n+            foreach (i, f) in fields.iter().enumerate() {\n                 let (name, parts) = match *f { (i, ref p) => (i, p) };\n                 variants.push(cx.expr_str(span, cx.str_of(name)));\n "}, {"sha": "eb425ec029ae2090b1af50453f48eb6c112b9326", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -122,7 +122,7 @@ fn encodable_substructure(cx: @ExtCtxt, span: span,\n         Struct(ref fields) => {\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n             let mut stmts = ~[];\n-            for fields.iter().enumerate().advance |(i, f)| {\n+            foreach (i, f) in fields.iter().enumerate() {\n                 let (name, val) = match *f {\n                     (Some(id), e, _) => (cx.str_of(id), e),\n                     (None, e, _) => (fmt!(\"_field%u\", i).to_managed(), e)\n@@ -153,7 +153,7 @@ fn encodable_substructure(cx: @ExtCtxt, span: span,\n             let encoder = cx.expr_ident(span, blkarg);\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n             let mut stmts = ~[];\n-            for fields.iter().enumerate().advance |(i, f)| {\n+            foreach (i, f) in fields.iter().enumerate() {\n                 let val = match *f { (_, e, _) => e };\n                 let enc = cx.expr_method_call(span, val, encode, ~[blkencoder]);\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);"}, {"sha": "cb74f152c1e7322fdb6e1424494d78d93fb82b73", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -284,7 +284,7 @@ impl<'self> TraitDef<'self> {\n                   _mitem: @ast::MetaItem,\n                   in_items: ~[@ast::item]) -> ~[@ast::item] {\n         let mut result = ~[];\n-        for in_items.iter().advance |item| {\n+        foreach item in in_items.iter() {\n             result.push(*item);\n             match item.node {\n                 ast::item_struct(struct_def, ref generics) => {\n@@ -322,11 +322,11 @@ impl<'self> TraitDef<'self> {\n \n         let mut trait_generics = self.generics.to_generics(cx, span, type_ident, generics);\n         // Copy the lifetimes\n-        for generics.lifetimes.iter().advance |l| {\n+        foreach l in generics.lifetimes.iter() {\n             trait_generics.lifetimes.push(*l)\n         };\n         // Create the type parameters.\n-        for generics.ty_params.iter().advance |ty_param| {\n+        foreach ty_param in generics.ty_params.iter() {\n             // I don't think this can be moved out of the loop, since\n             // a TyParamBound requires an ast id\n             let mut bounds = opt_vec::from(\n@@ -486,7 +486,7 @@ impl<'self> MethodDef<'self> {\n             None => respan(span, ast::sty_static),\n         };\n \n-        for self.args.iter().enumerate().advance |(i, ty)| {\n+        foreach (i, ty) in self.args.iter().enumerate() {\n             let ast_ty = ty.to_ty(cx, span, type_ident, generics);\n             let ident = cx.ident_of(fmt!(\"__arg_%u\", i));\n             arg_tys.push((ident, ast_ty));\n@@ -615,7 +615,7 @@ impl<'self> MethodDef<'self> {\n         // make a series of nested matches, to destructure the\n         // structs. This is actually right-to-left, but it shoudn't\n         // matter.\n-        for self_args.iter().zip(patterns.iter()).advance |(&arg_expr, &pat)| {\n+        foreach (&arg_expr, &pat) in self_args.iter().zip(patterns.iter()) {\n             body = cx.expr_match(span, arg_expr,\n                                  ~[ cx.arm(span, ~[pat], body) ])\n         }\n@@ -739,10 +739,10 @@ impl<'self> MethodDef<'self> {\n \n                     let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n \n-                    for matches_so_far.tail().iter().advance |triple| {\n+                    foreach triple in matches_so_far.tail().iter() {\n                         match triple {\n                             &(_, _, ref other_fields) => {\n-                                for other_fields.iter().enumerate().advance |(i, pair)| {\n+                                foreach (i, pair) in other_fields.iter().enumerate() {\n                                     enum_matching_fields[i].push(pair.second());\n                                 }\n                             }\n@@ -815,7 +815,7 @@ impl<'self> MethodDef<'self> {\n                 }\n             } else {\n                 // create an arm matching on each variant\n-                for enum_def.variants.iter().enumerate().advance |(index, variant)| {\n+                foreach (index, variant) in enum_def.variants.iter().enumerate() {\n                     let (pattern, idents) = create_enum_variant_pattern(cx, span,\n                                                                        variant,\n                                                                        current_match_str,\n@@ -878,7 +878,7 @@ fn summarise_struct(cx: @ExtCtxt, span: span,\n                     struct_def: &struct_def) -> Either<uint, ~[ident]> {\n     let mut named_idents = ~[];\n     let mut unnamed_count = 0;\n-    for struct_def.fields.iter().advance |field| {\n+    foreach field in struct_def.fields.iter() {\n         match field.node.kind {\n             ast::named_field(ident, _) => named_idents.push(ident),\n             ast::unnamed_field => unnamed_count += 1,\n@@ -932,7 +932,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n     let mut ident_expr = ~[];\n     let mut struct_type = Unknown;\n \n-    for struct_def.fields.iter().enumerate().advance |(i, struct_field)| {\n+    foreach (i, struct_field) in struct_def.fields.iter().enumerate() {\n         let opt_id = match struct_field.node.kind {\n             ast::named_field(ident, _) if (struct_type == Unknown ||\n                                            struct_type == Record) => {\n@@ -960,7 +960,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n     // must be nonempty to reach here\n     let pattern = if struct_type == Record {\n         let field_pats = do vec::build |push| {\n-            for subpats.iter().zip(ident_expr.iter()).advance |(&pat, &(id, _))| {\n+            foreach (&pat, &(id, _)) in subpats.iter().zip(ident_expr.iter()) {\n                 // id is guaranteed to be Some\n                 push(ast::field_pat { ident: id.get(), pat: pat })\n             }"}, {"sha": "215d5ca837dd45f38b5ad227bd01cb98ac442a1b", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -81,7 +81,7 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @\n         _ => cx.span_bug(span, \"Impossible substructure in `deriving(IterBytes)`\")\n     }\n \n-    for fields.iter().advance |&(_, field, _)| {\n+    foreach &(_, field, _) in fields.iter() {\n         exprs.push(call_iterbytes(field));\n     }\n "}, {"sha": "5a1a847fbc0c0cb9c461deb46c86b647898ef914", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -64,7 +64,7 @@ fn to_str_substructure(cx: @ExtCtxt, span: span,\n                 stmts.push(cx.stmt_expr(call));\n             };\n \n-            for fields.iter().enumerate().advance |(i, &(name, e, _))| {\n+            foreach (i, &(name, e, _)) in fields.iter().enumerate() {\n                 if i > 0 {\n                     push(cx.expr_str(span, @\", \"));\n                 }"}, {"sha": "dc096a145cc0c46b2489d078d4940d459613a977", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -535,7 +535,7 @@ pub fn new_name_finder() -> @Visitor<@mut ~[ast::ident]> {\n                         _ => ()\n                     }\n                     // visit optional subpattern of pat_ident:\n-                    for inner.iter().advance |subpat: &@ast::pat| {\n+                    foreach subpat in inner.iter() {\n                         (v.visit_pat)(*subpat, (ident_accum, v))\n                     }\n                 }"}, {"sha": "d8d114d1338704e47b11ddac1ed5f1e4ff65a93f", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -67,7 +67,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n     fn make_rt_conv_expr(cx: @ExtCtxt, sp: span, cnv: &Conv) -> @ast::expr {\n         fn make_flags(cx: @ExtCtxt, sp: span, flags: &[Flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, \"flag_none\");\n-            for flags.iter().advance |f| {\n+            foreach f in flags.iter() {\n                 let fstr = match *f {\n                   FlagLeftJustify => \"flag_left_justify\",\n                   FlagLeftZeroPad => \"flag_left_zero_pad\",\n@@ -153,7 +153,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n           option::None => (),\n           _ => cx.span_unimpl(sp, unsupported)\n         }\n-        for cnv.flags.iter().advance |f| {\n+        foreach f in cnv.flags.iter() {\n             match *f {\n               FlagLeftJustify => (),\n               FlagSignAlways => {\n@@ -203,7 +203,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n           Some(p) => { debug!(\"param: %s\", p.to_str()); }\n           _ => debug!(\"param: none\")\n         }\n-        for c.flags.iter().advance |f| {\n+        foreach f in c.flags.iter() {\n             match *f {\n               FlagLeftJustify => debug!(\"flag: left justify\"),\n               FlagLeftZeroPad => debug!(\"flag: left zero pad\"),\n@@ -269,7 +269,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n        corresponding function in std::unstable::extfmt. Each function takes a\n        buffer to insert data into along with the data being formatted. */\n     let npieces = pieces.len();\n-    for pieces.consume_iter().enumerate().advance |(i, pc)| {\n+    foreach (i, pc) in pieces.consume_iter().enumerate() {\n         match pc {\n             /* Raw strings get appended via str::push_str */\n             PieceString(s) => {"}, {"sha": "b080a730f3e29b0a912c015ebd0283a4260783ee", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -59,7 +59,7 @@ pub fn analyze(proto: @mut protocol_, _cx: @ExtCtxt) {\n         changed = false;\n         debug!(\"colive iteration %?\", i);\n         let mut new_colive = ~[];\n-        for colive.iter().enumerate().advance |(i, this_colive)| {\n+        foreach (i, this_colive) in colive.iter().enumerate() {\n             let mut result = this_colive.clone();\n             let this = proto.get_state_by_id(i);\n             for this_colive.ones |j| {\n@@ -78,7 +78,7 @@ pub fn analyze(proto: @mut protocol_, _cx: @ExtCtxt) {\n \n     // Determine if we're bounded\n     let mut self_live = ~[];\n-    for colive.iter().enumerate().advance |(i, bv)| {\n+    foreach (i, bv) in colive.iter().enumerate() {\n         if bv.get(i) {\n             self_live.push(proto.get_state_by_id(i))\n         }"}, {"sha": "02aef13a3a8293b1add6e4e44e4cb6e7c88a9eee", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -210,7 +210,7 @@ impl to_type_decls for state {\n \n         let mut items_msg = ~[];\n \n-        for self.messages.iter().advance |m| {\n+        foreach m in self.messages.iter() {\n             let message(name, span, tys, this, next) = (*m).clone();\n \n             let tys = match next {\n@@ -257,7 +257,7 @@ impl to_type_decls for state {\n         let mut items = ~[];\n \n         {\n-            for self.messages.mut_iter().advance |m| {\n+            foreach m in self.messages.mut_iter() {\n                 if dir == send {\n                     items.push(m.gen_send(cx, true));\n                     items.push(m.gen_send(cx, false));\n@@ -373,8 +373,8 @@ impl gen_init for protocol {\n \n     fn buffer_ty_path(&self, cx: @ExtCtxt) -> ast::Ty {\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n-        for self.states.iter().advance |s| {\n-            for s.generics.ty_params.iter().advance |tp| {\n+        foreach s in self.states.iter() {\n+            foreach tp in s.generics.ty_params.iter() {\n                 match params.iter().find_(|tpp| tp.ident == tpp.ident) {\n                   None => params.push((*tp).clone()),\n                   _ => ()\n@@ -392,7 +392,7 @@ impl gen_init for protocol {\n         let ext_cx = cx;\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         let fields = do self.states.iter().transform |s| {\n-            for s.generics.ty_params.iter().advance |tp| {\n+            foreach tp in s.generics.ty_params.iter() {\n                 match params.iter().find_(|tpp| tp.ident == tpp.ident) {\n                   None => params.push((*tp).clone()),\n                   _ => ()\n@@ -434,7 +434,7 @@ impl gen_init for protocol {\n         let mut client_states = ~[];\n         let mut server_states = ~[];\n \n-        for self.states.iter().advance |s| {\n+        foreach s in self.states.iter() {\n             items.push_all_move(s.to_type_decls(cx));\n \n             client_states.push_all_move(s.to_endpoint_decls(cx, send));"}, {"sha": "5d2ebb68b8a0d7e1959a9adf75d5fedb0c9ee5f0", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -107,7 +107,7 @@ impl state_ {\n     /// Iterate over the states that can be reached in one message\n     /// from this state.\n     pub fn reachable(&self, f: &fn(state) -> bool) -> bool {\n-        for self.messages.iter().advance |m| {\n+        foreach m in self.messages.iter() {\n             match *m {\n               message(_, _, _, _, Some(next_state { state: ref id, _ })) => {\n                 let state = self.proto.get_state((*id));\n@@ -166,7 +166,7 @@ impl protocol_ {\n     }\n \n     pub fn has_ty_params(&self) -> bool {\n-        for self.states.iter().advance |s| {\n+        foreach s in self.states.iter() {\n             if s.generics.ty_params.len() > 0 {\n                 return true;\n             }"}, {"sha": "bcfd898dc6fda7288ab2444867c866fa9661501d", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -632,7 +632,7 @@ fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n fn mk_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> ~[@ast::stmt] {\n     let mut ss = ~[];\n-    for tts.iter().advance |tt| {\n+    foreach tt in tts.iter() {\n         ss.push_all_move(mk_tt(cx, sp, tt));\n     }\n     ss"}, {"sha": "66965f00215039d45f96a51007d2f134172e2da9", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -138,7 +138,7 @@ pub fn count_names(ms: &[matcher]) -> uint {\n pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n                         -> ~MatcherPos {\n     let mut match_idx_hi = 0u;\n-    for ms.iter().advance |elt| {\n+    foreach elt in ms.iter() {\n         match elt.node {\n           match_tok(_) => (),\n           match_seq(_,_,_,_,hi) => {\n@@ -195,7 +195,7 @@ pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n         match *m {\n           codemap::spanned {node: match_tok(_), _} => (),\n           codemap::spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n-            for more_ms.iter().advance |next_m| {\n+            foreach next_m in more_ms.iter() {\n                 n_rec(p_s, next_m, res, ret_val)\n             };\n           }\n@@ -211,7 +211,7 @@ pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n         }\n     }\n     let mut ret_val = HashMap::new();\n-    for ms.iter().advance |m| { n_rec(p_s, m, res, &mut ret_val) }\n+    foreach m in ms.iter() { n_rec(p_s, m, res, &mut ret_val) }\n     ret_val\n }\n \n@@ -356,7 +356,7 @@ pub fn parse(\n         if tok == EOF {\n             if eof_eis.len() == 1u {\n                 let mut v = ~[];\n-                for eof_eis[0u].matches.mut_iter().advance |dv| {\n+                foreach dv in eof_eis[0u].matches.mut_iter() {\n                     v.push(dv.pop());\n                 }\n                 return success(nameize(sess, ms, v));"}, {"sha": "304cf4756e116841563dced2c5d09ff657ae7b56", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -93,7 +93,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n \n         let s_d = cx.parse_sess().span_diagnostic;\n \n-        for lhses.iter().enumerate().advance |(i, lhs)| { // try each arm's matchers\n+        foreach (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n             match *lhs {\n               @matched_nonterminal(nt_matchers(ref mtcs)) => {\n                 // `none` is because we're not interpolating"}, {"sha": "f0b00f5681c5b87a0b33e1b5a6ce8e32e1627af6", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -380,7 +380,7 @@ fn noop_fold_method(m: @method, fld: @ast_fold) -> @method {\n pub fn noop_fold_block(b: &Block, fld: @ast_fold) -> Block {\n     let view_items = b.view_items.map(|x| fld.fold_view_item(x));\n     let mut stmts = ~[];\n-    for b.stmts.iter().advance |stmt| {\n+    foreach stmt in b.stmts.iter() {\n         match fld.fold_stmt(*stmt) {\n             None => {}\n             Some(stmt) => stmts.push(stmt)"}, {"sha": "c5454a2ca95d29356809cba6d401ffe2ea7e9793", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -73,8 +73,8 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         let mut i = uint::max_value;\n         let mut can_trim = true;\n         let mut first = true;\n-        for lines.iter().advance |line| {\n-            for line.iter().enumerate().advance |(j, c)| {\n+        foreach line in lines.iter() {\n+            foreach (j, c) in line.iter().enumerate() {\n                 if j > i || !\"* \\t\".contains_char(c) {\n                     can_trim = false;\n                     break;"}, {"sha": "3259d49fcd10d64fd0211f5664977497c08f011d", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -837,7 +837,7 @@ mod test {\n     // check that the given reader produces the desired stream\n     // of tokens (stop checking after exhausting the expected vec)\n     fn check_tokenization (env: Env, expected: ~[token::Token]) {\n-        for expected.iter().advance |expected_tok| {\n+        foreach expected_tok in expected.iter() {\n             let TokenAndSpan {tok:actual_tok, sp: _} =\n                 env.string_reader.next_token();\n             assert_eq!(&actual_tok,expected_tok);"}, {"sha": "1d61c5be83d746d564d2dd6955b65384bccf6c52", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -3150,7 +3150,7 @@ impl Parser {\n         } = self.parse_items_and_view_items(first_item_attrs,\n                                             false, false);\n \n-        for items.iter().advance |item| {\n+        foreach item in items.iter() {\n             let decl = @spanned(item.span.lo, item.span.hi, decl_item(*item));\n             stmts.push(@spanned(item.span.lo, item.span.hi,\n                                 stmt_decl(decl, self.get_id())));\n@@ -3755,7 +3755,7 @@ impl Parser {\n             fields = ~[];\n             while *self.token != token::RBRACE {\n                 let r = self.parse_struct_decl_field();\n-                for r.iter().advance |struct_field| {\n+                foreach struct_field in r.iter() {\n                     fields.push(*struct_field)\n                 }\n             }\n@@ -4038,7 +4038,7 @@ impl Parser {\n             Some(i) => {\n                 let stack = &self.sess.included_mod_stack;\n                 let mut err = ~\"circular modules: \";\n-                for stack.slice(i, stack.len()).iter().advance |p| {\n+                foreach p in stack.slice(i, stack.len()).iter() {\n                     err.push_str(p.to_str());\n                     err.push_str(\" -> \");\n                 }\n@@ -4246,7 +4246,7 @@ impl Parser {\n         let mut fields: ~[@struct_field] = ~[];\n         while *self.token != token::RBRACE {\n             let r = self.parse_struct_decl_field();\n-            for r.iter().advance |struct_field| {\n+            foreach struct_field in r.iter() {\n                 fields.push(*struct_field);\n             }\n         }\n@@ -4286,7 +4286,7 @@ impl Parser {\n                     seq_sep_trailing_disallowed(token::COMMA),\n                     |p| p.parse_ty(false)\n                 );\n-                for arg_tys.consume_iter().advance |ty| {\n+                foreach ty in arg_tys.consume_iter() {\n                     args.push(ast::variant_arg {\n                         ty: ty,\n                         id: self.get_id(),\n@@ -4395,7 +4395,7 @@ impl Parser {\n                 self.bump();\n                 let the_string = ident_to_str(&s);\n                 let mut abis = AbiSet::empty();\n-                for the_string.word_iter().advance |word| {\n+                foreach word in the_string.word_iter() {\n                     match abi::lookup(word) {\n                         Some(abi) => {\n                             if abis.contains(abi) {"}, {"sha": "706357320a5f4d0f5cc80139209c35e6901cdff6", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -687,7 +687,6 @@ pub fn is_reserved_keyword(tok: &Token) -> bool {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use std::io;\n     #[test] fn t1() {\n         let a = fresh_name(\"ghi\");\n         printfln!(\"interned name: %u,\\ntextual name: %s\\n\","}, {"sha": "a4666847f8c269db26b567a2795f63753976dc2a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -321,7 +321,7 @@ pub fn synth_comment(s: @ps, text: ~str) {\n pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T)) {\n     box(s, 0u, b);\n     let mut first = true;\n-    for elts.iter().advance |elt| {\n+    foreach elt in elts.iter() {\n         if first { first = false; } else { word_space(s, \",\"); }\n         op(s, elt);\n     }\n@@ -334,7 +334,7 @@ pub fn commasep_cmnt<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T),\n     box(s, 0u, b);\n     let len = elts.len();\n     let mut i = 0u;\n-    for elts.iter().advance |elt| {\n+    foreach elt in elts.iter() {\n         maybe_print_comment(s, get_span(elt).hi);\n         op(s, elt);\n         i += 1u;\n@@ -354,23 +354,23 @@ pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::expr]) {\n \n pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: &[ast::Attribute]) {\n     print_inner_attributes(s, attrs);\n-    for _mod.view_items.iter().advance |vitem| {\n+    foreach vitem in _mod.view_items.iter() {\n         print_view_item(s, vitem);\n     }\n-    for _mod.items.iter().advance |item| { print_item(s, *item); }\n+    foreach item in _mod.items.iter() { print_item(s, *item); }\n }\n \n pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n                          attrs: &[ast::Attribute]) {\n     print_inner_attributes(s, attrs);\n-    for nmod.view_items.iter().advance |vitem| {\n+    foreach vitem in nmod.view_items.iter() {\n         print_view_item(s, vitem);\n     }\n-    for nmod.items.iter().advance |item| { print_foreign_item(s, *item); }\n+    foreach item in nmod.items.iter() { print_foreign_item(s, *item); }\n }\n \n pub fn print_opt_lifetime(s: @ps, lifetime: &Option<ast::Lifetime>) {\n-    for lifetime.iter().advance |l| {\n+    foreach l in lifetime.iter() {\n         print_lifetime(s, l);\n         nbsp(s);\n     }\n@@ -590,7 +590,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n             word(s.s, \";\");\n         } else {\n             bopen(s);\n-            for methods.iter().advance |meth| {\n+            foreach meth in methods.iter() {\n                print_method(s, *meth);\n             }\n             bclose(s, item.span);\n@@ -602,7 +602,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         print_generics(s, generics);\n         if traits.len() != 0u {\n             word(s.s, \":\");\n-            for traits.iter().enumerate().advance |(i, trait_)| {\n+            foreach (i, trait_) in traits.iter().enumerate() {\n                 nbsp(s);\n                 if i != 0 {\n                     word_space(s, \"+\");\n@@ -612,7 +612,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         }\n         word(s.s, \" \");\n         bopen(s);\n-        for methods.iter().advance |meth| {\n+        foreach meth in methods.iter() {\n             print_trait_method(s, meth);\n         }\n         bclose(s, item.span);\n@@ -651,7 +651,7 @@ pub fn print_variants(s: @ps,\n                       variants: &[ast::variant],\n                       span: codemap::span) {\n     bopen(s);\n-    for variants.iter().advance |v| {\n+    foreach v in variants.iter() {\n         space_if_not_bol(s);\n         maybe_print_comment(s, v.span.lo);\n         print_outer_attributes(s, v.node.attrs);\n@@ -716,7 +716,7 @@ pub fn print_struct(s: @ps,\n         bopen(s);\n         hardbreak_if_not_bol(s);\n \n-        for struct_def.fields.iter().advance |field| {\n+        foreach field in struct_def.fields.iter() {\n             match field.node.kind {\n                 ast::unnamed_field => fail!(\"unexpected unnamed field\"),\n                 ast::named_field(ident, visibility) => {\n@@ -751,7 +751,7 @@ pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n       }\n       ast::tt_seq(_, ref tts, ref sep, zerok) => {\n         word(s.s, \"$(\");\n-        for (*tts).iter().advance |tt_elt| { print_tt(s, tt_elt); }\n+        foreach tt_elt in (*tts).iter() { print_tt(s, tt_elt); }\n         word(s.s, \")\");\n         match (*sep) {\n           Some(ref tk) => word(s.s, parse::token::to_str(s.intr, tk)),\n@@ -768,7 +768,7 @@ pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n \n pub fn print_tts(s: @ps, tts: & &[ast::token_tree]) {\n     ibox(s, 0);\n-    for tts.iter().enumerate().advance |(i, tt)| {\n+    foreach (i, tt) in tts.iter().enumerate() {\n         if i != 0 {\n             space(s.s);\n         }\n@@ -845,7 +845,7 @@ pub fn print_method(s: @ps, meth: &ast::method) {\n \n pub fn print_outer_attributes(s: @ps, attrs: &[ast::Attribute]) {\n     let mut count = 0;\n-    for attrs.iter().advance |attr| {\n+    foreach attr in attrs.iter() {\n         match attr.node.style {\n           ast::AttrOuter => { print_attribute(s, attr); count += 1; }\n           _ => {/* fallthrough */ }\n@@ -856,7 +856,7 @@ pub fn print_outer_attributes(s: @ps, attrs: &[ast::Attribute]) {\n \n pub fn print_inner_attributes(s: @ps, attrs: &[ast::Attribute]) {\n     let mut count = 0;\n-    for attrs.iter().advance |attr| {\n+    foreach attr in attrs.iter() {\n         match attr.node.style {\n           ast::AttrInner => {\n             print_attribute(s, attr);\n@@ -961,8 +961,8 @@ pub fn print_possibly_embedded_block_(s: @ps,\n \n     print_inner_attributes(s, attrs);\n \n-    for blk.view_items.iter().advance |vi| { print_view_item(s, vi); }\n-    for blk.stmts.iter().advance |st| {\n+    foreach vi in blk.view_items.iter() { print_view_item(s, vi); }\n+    foreach st in blk.stmts.iter() {\n         print_stmt(s, *st);\n     }\n     match blk.expr {\n@@ -1238,7 +1238,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         print_block(s, blk);\n       }\n       ast::expr_loop(ref blk, opt_ident) => {\n-        for opt_ident.iter().advance |ident| {\n+        foreach ident in opt_ident.iter() {\n             word(s.s, \"'\");\n             print_ident(s, *ident);\n             word_space(s, \":\");\n@@ -1255,12 +1255,12 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         space(s.s);\n         bopen(s);\n         let len = arms.len();\n-        for arms.iter().enumerate().advance |(i, arm)| {\n+        foreach (i, arm) in arms.iter().enumerate() {\n             space(s.s);\n             cbox(s, indent_unit);\n             ibox(s, 0u);\n             let mut first = true;\n-            for arm.pats.iter().advance |p| {\n+            foreach p in arm.pats.iter() {\n                 if first {\n                     first = false;\n                 } else { space(s.s); word_space(s, \"|\"); }\n@@ -1386,7 +1386,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n       ast::expr_break(opt_ident) => {\n         word(s.s, \"break\");\n         space(s.s);\n-        for opt_ident.iter().advance |ident| {\n+        foreach ident in opt_ident.iter() {\n             word(s.s, \"'\");\n             print_ident(s, *ident);\n             space(s.s);\n@@ -1395,7 +1395,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n       ast::expr_again(opt_ident) => {\n         word(s.s, \"loop\");\n         space(s.s);\n-        for opt_ident.iter().advance |ident| {\n+        foreach ident in opt_ident.iter() {\n             word(s.s, \"'\");\n             print_ident(s, *ident);\n             space(s.s)\n@@ -1426,15 +1426,15 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         popen(s);\n         print_string(s, a.asm);\n         word_space(s, \":\");\n-        for a.outputs.iter().advance |&(co, o)| {\n+        foreach &(co, o) in a.outputs.iter() {\n             print_string(s, co);\n             popen(s);\n             print_expr(s, o);\n             pclose(s);\n             word_space(s, \",\");\n         }\n         word_space(s, \":\");\n-        for a.inputs.iter().advance |&(co, o)| {\n+        foreach &(co, o) in a.inputs.iter() {\n             print_string(s, co);\n             popen(s);\n             print_expr(s, o);\n@@ -1513,7 +1513,7 @@ fn print_path_(s: @ps, path: &ast::Path, colons_before_params: bool,\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, \"::\"); }\n     let mut first = true;\n-    for path.idents.iter().advance |id| {\n+    foreach id in path.idents.iter() {\n         if first { first = false; } else { word(s.s, \"::\"); }\n         print_ident(s, *id);\n     }\n@@ -1526,7 +1526,7 @@ fn print_path_(s: @ps, path: &ast::Path, colons_before_params: bool,\n         if path.rp.is_some() || !path.types.is_empty() {\n             word(s.s, \"<\");\n \n-            for path.rp.iter().advance |r| {\n+            foreach r in path.rp.iter() {\n                 print_lifetime(s, r);\n                 if !path.types.is_empty() {\n                     word_space(s, \",\");\n@@ -1640,7 +1640,7 @@ pub fn print_pat(s: @ps, pat: &ast::pat) {\n         do commasep(s, inconsistent, *before) |s, &p| {\n             print_pat(s, p);\n         }\n-        for slice.iter().advance |&p| {\n+        foreach &p in slice.iter() {\n             if !before.is_empty() { word_space(s, \",\"); }\n             word(s.s, \"..\");\n             print_pat(s, p);\n@@ -1700,11 +1700,11 @@ pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n     // self type and the args all in the same box.\n     box(s, 0u, inconsistent);\n     let mut first = true;\n-    for opt_explicit_self.iter().advance |explicit_self| {\n+    foreach explicit_self in opt_explicit_self.iter() {\n         first = !print_explicit_self(s, *explicit_self);\n     }\n \n-    for decl.inputs.iter().advance |arg| {\n+    foreach arg in decl.inputs.iter() {\n         if first { first = false; } else { word_space(s, \",\"); }\n         print_arg(s, arg);\n     }\n@@ -1751,7 +1751,7 @@ pub fn print_bounds(s: @ps, bounds: &OptVec<ast::TyParamBound>,\n     if !bounds.is_empty() {\n         word(s.s, \":\");\n         let mut first = true;\n-        for bounds.iter().advance |bound| {\n+        foreach bound in bounds.iter() {\n             nbsp(s);\n             if first {\n                 first = false;\n@@ -1950,10 +1950,10 @@ pub fn print_ty_fn(s: @ps,\n     // self type and the args all in the same box.\n     box(s, 0u, inconsistent);\n     let mut first = true;\n-    for opt_explicit_self.iter().advance |explicit_self| {\n+    foreach explicit_self in opt_explicit_self.iter() {\n         first = !print_explicit_self(s, *explicit_self);\n     }\n-    for decl.inputs.iter().advance |arg| {\n+    foreach arg in decl.inputs.iter() {\n         if first { first = false; } else { word_space(s, \",\"); }\n         print_arg(s, arg);\n     }\n@@ -2109,7 +2109,7 @@ pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n       }\n       comments::isolated => {\n         pprust::hardbreak_if_not_bol(s);\n-        for cmnt.lines.iter().advance |line| {\n+        foreach line in cmnt.lines.iter() {\n             // Don't print empty lines because they will end up as trailing\n             // whitespace\n             if !line.is_empty() { word(s.s, *line); }\n@@ -2123,7 +2123,7 @@ pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n             hardbreak(s.s);\n         } else {\n             ibox(s, 0u);\n-            for cmnt.lines.iter().advance |line| {\n+            foreach line in cmnt.lines.iter() {\n                 if !line.is_empty() { word(s.s, *line); }\n                 hardbreak(s.s);\n             }"}, {"sha": "b9c8c3f4e4c89a45bbe65d7faf74b6f7b51a71c3", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -31,7 +31,7 @@ impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n \n     pub fn prefill(init: &[T]) -> Interner<T> {\n         let rv = Interner::new();\n-        for init.iter().advance |v| {\n+        foreach v in init.iter() {\n             rv.intern((*v).clone());\n         }\n         rv\n@@ -93,7 +93,7 @@ impl StrInterner {\n \n     pub fn prefill(init: &[&str]) -> StrInterner {\n         let rv = StrInterner::new();\n-        for init.iter().advance |&v| { rv.intern(v); }\n+        foreach &v in init.iter() { rv.intern(v); }\n         rv\n     }\n "}, {"sha": "d988f96d3d46df7d7fd30bec733717309ef854e5", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -126,10 +126,10 @@ pub fn visit_mod<E:Clone>(m: &_mod,\n                           _sp: span,\n                           _id: NodeId,\n                           (e, v): (E, vt<E>)) {\n-    for m.view_items.iter().advance |vi| {\n+    foreach vi in m.view_items.iter() {\n         (v.visit_view_item)(vi, (e.clone(), v));\n     }\n-    for m.items.iter().advance |i| {\n+    foreach i in m.items.iter() {\n         (v.visit_item)(*i, (e.clone(), v));\n     }\n }\n@@ -173,10 +173,10 @@ pub fn visit_item<E:Clone>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_mod(ref m) => (v.visit_mod)(m, i.span, i.id, (e, v)),\n         item_foreign_mod(ref nm) => {\n-            for nm.view_items.iter().advance |vi| {\n+            foreach vi in nm.view_items.iter() {\n                 (v.visit_view_item)(vi, (e.clone(), v));\n             }\n-            for nm.items.iter().advance |ni| {\n+            foreach ni in nm.items.iter() {\n                 (v.visit_foreign_item)(*ni, (e.clone(), v));\n             }\n         }\n@@ -194,11 +194,11 @@ pub fn visit_item<E:Clone>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_impl(ref tps, ref traits, ref ty, ref methods) => {\n             (v.visit_generics)(tps, (e.clone(), v));\n-            for traits.iter().advance |p| {\n+            foreach p in traits.iter() {\n                 visit_trait_ref(p, (e.clone(), v));\n             }\n             (v.visit_ty)(ty, (e.clone(), v));\n-            for methods.iter().advance |m| {\n+            foreach m in methods.iter() {\n                 visit_method_helper(*m, (e.clone(), v))\n             }\n         }\n@@ -208,10 +208,10 @@ pub fn visit_item<E:Clone>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n             (v.visit_generics)(generics, (e.clone(), v));\n-            for traits.iter().advance |p| {\n+            foreach p in traits.iter() {\n                 visit_path(&p.path, (e.clone(), v));\n             }\n-            for methods.iter().advance |m| {\n+            foreach m in methods.iter() {\n                 (v.visit_trait_method)(m, (e.clone(), v));\n             }\n         }\n@@ -222,10 +222,10 @@ pub fn visit_item<E:Clone>(i: &item, (e, v): (E, vt<E>)) {\n pub fn visit_enum_def<E:Clone>(enum_definition: &ast::enum_def,\n                                tps: &Generics,\n                                (e, v): (E, vt<E>)) {\n-    for enum_definition.variants.iter().advance |vr| {\n+    foreach vr in enum_definition.variants.iter() {\n         match vr.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n-                for variant_args.iter().advance |va| {\n+                foreach va in variant_args.iter() {\n                     (v.visit_ty)(&va.ty, (e.clone(), v));\n                 }\n             }\n@@ -235,7 +235,7 @@ pub fn visit_enum_def<E:Clone>(enum_definition: &ast::enum_def,\n             }\n         }\n         // Visit the disr expr if it exists\n-        for vr.node.disr_expr.iter().advance |ex| {\n+        foreach ex in vr.node.disr_expr.iter() {\n             (v.visit_expr)(*ex, (e.clone(), v))\n         }\n     }\n@@ -250,12 +250,12 @@ pub fn visit_ty<E:Clone>(t: &Ty, (e, v): (E, vt<E>)) {\n             (v.visit_ty)(mt.ty, (e, v));\n         },\n         ty_tup(ref ts) => {\n-            for ts.iter().advance |tt| {\n+            foreach tt in ts.iter() {\n                 (v.visit_ty)(tt, (e.clone(), v));\n             }\n         },\n         ty_closure(ref f) => {\n-            for f.decl.inputs.iter().advance |a| {\n+            foreach a in f.decl.inputs.iter() {\n                 (v.visit_ty)(&a.ty, (e.clone(), v));\n             }\n             (v.visit_ty)(&f.decl.output, (e.clone(), v));\n@@ -264,7 +264,7 @@ pub fn visit_ty<E:Clone>(t: &Ty, (e, v): (E, vt<E>)) {\n             };\n         },\n         ty_bare_fn(ref f) => {\n-            for f.decl.inputs.iter().advance |a| {\n+            foreach a in f.decl.inputs.iter() {\n                 (v.visit_ty)(&a.ty, (e.clone(), v));\n             }\n             (v.visit_ty)(&f.decl.output, (e, v));\n@@ -284,27 +284,27 @@ pub fn visit_ty<E:Clone>(t: &Ty, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_path<E:Clone>(p: &Path, (e, v): (E, vt<E>)) {\n-    for p.types.iter().advance |tp| { (v.visit_ty)(tp, (e.clone(), v)); }\n+    foreach tp in p.types.iter() { (v.visit_ty)(tp, (e.clone(), v)); }\n }\n \n pub fn visit_pat<E:Clone>(p: &pat, (e, v): (E, vt<E>)) {\n     match p.node {\n         pat_enum(ref path, ref children) => {\n             visit_path(path, (e.clone(), v));\n-            for children.iter().advance |children| {\n-                for children.iter().advance |child| {\n+            foreach children in children.iter() {\n+                foreach child in children.iter() {\n                     (v.visit_pat)(*child, (e.clone(), v));\n                 }\n             }\n         }\n         pat_struct(ref path, ref fields, _) => {\n             visit_path(path, (e.clone(), v));\n-            for fields.iter().advance |f| {\n+            foreach f in fields.iter() {\n                 (v.visit_pat)(f.pat, (e.clone(), v));\n             }\n         }\n         pat_tup(ref elts) => {\n-            for elts.iter().advance |elt| {\n+            foreach elt in elts.iter() {\n                 (v.visit_pat)(*elt, (e.clone(), v))\n             }\n         },\n@@ -313,7 +313,7 @@ pub fn visit_pat<E:Clone>(p: &pat, (e, v): (E, vt<E>)) {\n         },\n         pat_ident(_, ref path, ref inner) => {\n             visit_path(path, (e.clone(), v));\n-            for inner.iter().advance |subpat| {\n+            foreach subpat in inner.iter() {\n                 (v.visit_pat)(*subpat, (e.clone(), v))\n             }\n         }\n@@ -324,13 +324,13 @@ pub fn visit_pat<E:Clone>(p: &pat, (e, v): (E, vt<E>)) {\n         }\n         pat_wild => (),\n         pat_vec(ref before, ref slice, ref after) => {\n-            for before.iter().advance |elt| {\n+            foreach elt in before.iter() {\n                 (v.visit_pat)(*elt, (e.clone(), v));\n             }\n-            for slice.iter().advance |elt| {\n+            foreach elt in slice.iter() {\n                 (v.visit_pat)(*elt, (e.clone(), v));\n             }\n-            for after.iter().advance |tail| {\n+            foreach tail in after.iter() {\n                 (v.visit_pat)(*tail, (e.clone(), v));\n             }\n         }\n@@ -351,7 +351,7 @@ pub fn visit_foreign_item<E:Clone>(ni: &foreign_item, (e, v): (E, vt<E>)) {\n \n pub fn visit_ty_param_bounds<E:Clone>(bounds: &OptVec<TyParamBound>,\n                                       (e, v): (E, vt<E>)) {\n-    for bounds.iter().advance |bound| {\n+    foreach bound in bounds.iter() {\n         match *bound {\n             TraitTyParamBound(ref ty) => visit_trait_ref(ty, (e.clone(), v)),\n             RegionTyParamBound => {}\n@@ -360,13 +360,13 @@ pub fn visit_ty_param_bounds<E:Clone>(bounds: &OptVec<TyParamBound>,\n }\n \n pub fn visit_generics<E:Clone>(generics: &Generics, (e, v): (E, vt<E>)) {\n-    for generics.ty_params.iter().advance |tp| {\n+    foreach tp in generics.ty_params.iter() {\n         visit_ty_param_bounds(&tp.bounds, (e.clone(), v));\n     }\n }\n \n pub fn visit_fn_decl<E:Clone>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n-    for fd.inputs.iter().advance |a| {\n+    foreach a in fd.inputs.iter() {\n         (v.visit_pat)(a.pat, (e.clone(), v));\n         (v.visit_ty)(&a.ty, (e.clone(), v));\n     }\n@@ -395,7 +395,7 @@ pub fn visit_fn<E:Clone>(fk: &fn_kind, decl: &fn_decl, body: &Block, _sp: span,\n }\n \n pub fn visit_ty_method<E:Clone>(m: &TypeMethod, (e, v): (E, vt<E>)) {\n-    for m.decl.inputs.iter().advance |a| {\n+    foreach a in m.decl.inputs.iter() {\n         (v.visit_ty)(&a.ty, (e.clone(), v));\n     }\n     (v.visit_generics)(&m.generics, (e.clone(), v));\n@@ -416,7 +416,7 @@ pub fn visit_struct_def<E:Clone>(\n     _id: NodeId,\n     (e, v): (E, vt<E>)\n ) {\n-    for sd.fields.iter().advance |f| {\n+    foreach f in sd.fields.iter() {\n         (v.visit_struct_field)(*f, (e.clone(), v));\n     }\n }\n@@ -426,10 +426,10 @@ pub fn visit_struct_field<E:Clone>(sf: &struct_field, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_block<E:Clone>(b: &Block, (e, v): (E, vt<E>)) {\n-    for b.view_items.iter().advance |vi| {\n+    foreach vi in b.view_items.iter() {\n         (v.visit_view_item)(vi, (e.clone(), v));\n     }\n-    for b.stmts.iter().advance |s| {\n+    foreach s in b.stmts.iter() {\n         (v.visit_stmt)(*s, (e.clone(), v));\n     }\n     visit_expr_opt(b.expr, (e, v));\n@@ -456,7 +456,7 @@ pub fn visit_expr_opt<E>(eo: Option<@expr>, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_exprs<E:Clone>(exprs: &[@expr], (e, v): (E, vt<E>)) {\n-    for exprs.iter().advance |ex| { (v.visit_expr)(*ex, (e.clone(), v)); }\n+    foreach ex in exprs.iter() { (v.visit_expr)(*ex, (e.clone(), v)); }\n }\n \n pub fn visit_mac<E>(_m: &mac, (_e, _v): (E, vt<E>)) {\n@@ -473,21 +473,21 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n         }\n         expr_struct(ref p, ref flds, base) => {\n             visit_path(p, (e.clone(), v));\n-            for flds.iter().advance |f| {\n+            foreach f in flds.iter() {\n                 (v.visit_expr)(f.expr, (e.clone(), v));\n             }\n             visit_expr_opt(base, (e.clone(), v));\n         }\n         expr_tup(ref elts) => {\n-            for elts.iter().advance |el| { (v.visit_expr)(*el, (e.clone(), v)) }\n+            foreach el in elts.iter() { (v.visit_expr)(*el, (e.clone(), v)) }\n         }\n         expr_call(callee, ref args, _) => {\n             visit_exprs(*args, (e.clone(), v));\n             (v.visit_expr)(callee, (e.clone(), v));\n         }\n         expr_method_call(_, callee, _, ref tys, ref args, _) => {\n             visit_exprs(*args, (e.clone(), v));\n-            for tys.iter().advance |tp| {\n+            foreach tp in tys.iter() {\n                 (v.visit_ty)(tp, (e.clone(), v));\n             }\n             (v.visit_expr)(callee, (e.clone(), v));\n@@ -520,7 +520,7 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_loop(ref b, _) => (v.visit_block)(b, (e.clone(), v)),\n         expr_match(x, ref arms) => {\n             (v.visit_expr)(x, (e.clone(), v));\n-            for arms.iter().advance |a| { (v.visit_arm)(a, (e.clone(), v)); }\n+            foreach a in arms.iter() { (v.visit_arm)(a, (e.clone(), v)); }\n         }\n         expr_fn_block(ref decl, ref body) => {\n             (v.visit_fn)(\n@@ -543,7 +543,7 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n         }\n         expr_field(x, _, ref tys) => {\n             (v.visit_expr)(x, (e.clone(), v));\n-            for tys.iter().advance |tp| {\n+            foreach tp in tys.iter() {\n                 (v.visit_ty)(tp, (e.clone(), v));\n             }\n         }\n@@ -563,10 +563,10 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_mac(ref mac) => visit_mac(mac, (e.clone(), v)),\n         expr_paren(x) => (v.visit_expr)(x, (e.clone(), v)),\n         expr_inline_asm(ref a) => {\n-            for a.inputs.iter().advance |&(_, input)| {\n+            foreach &(_, input) in a.inputs.iter() {\n                 (v.visit_expr)(input, (e.clone(), v));\n             }\n-            for a.outputs.iter().advance |&(_, out)| {\n+            foreach &(_, out) in a.outputs.iter() {\n                 (v.visit_expr)(out, (e.clone(), v));\n             }\n         }\n@@ -575,7 +575,7 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_arm<E:Clone>(a: &arm, (e, v): (E, vt<E>)) {\n-    for a.pats.iter().advance |p| { (v.visit_pat)(*p, (e.clone(), v)); }\n+    foreach p in a.pats.iter() { (v.visit_pat)(*p, (e.clone(), v)); }\n     visit_expr_opt(a.guard, (e.clone(), v));\n     (v.visit_block)(&a.body, (e.clone(), v));\n }"}, {"sha": "85f968cc2e1ca19c2e7ccaa065b2271d4c7bf387", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -28,7 +28,7 @@ pub fn alist_get<A:Clone + 'static,\n                  k: A)\n                  -> B {\n     let eq_fn = lst.eq_fn;\n-    for lst.data.iter().advance |entry| {\n+    foreach entry in lst.data.iter() {\n         if eq_fn(entry.key.clone(), k.clone()) {\n             return entry.value.clone();\n         }"}, {"sha": "10bfb4f60ed632178ec0b650391b38b5cb2a5a7a", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -87,7 +87,7 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n         HashSet::new()\n     };\n \n-    for edges.iter().advance |e| {\n+    foreach e in edges.iter() {\n         match *e {\n             (i, j) => {\n                 graph[i].insert(j);\n@@ -98,7 +98,7 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n \n     do graph.consume_iter().transform |v| {\n         let mut vec = ~[];\n-        for v.consume().advance |i| {\n+        foreach i in v.consume() {\n             vec.push(i);\n         }\n         vec\n@@ -119,7 +119,7 @@ fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n         }\n     }\n     let mut vec = ~[];\n-    for keys.consume().advance |i| {\n+    foreach i in keys.consume() {\n         vec.push(i);\n     }\n     return vec;\n@@ -435,7 +435,7 @@ fn main() {\n     let stop = time::precise_time_s();\n \n     let mut total_edges = 0;\n-    for graph.iter().advance |edges| { total_edges += edges.len(); }\n+    foreach edges in graph.iter() { total_edges += edges.len(); }\n \n     io::stdout().write_line(fmt!(\"Generated graph with %? edges in %? seconds.\",\n                                  total_edges / 2,"}, {"sha": "989630448bec038ef43fe3e6bff534917d9fd2cb", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -80,7 +80,7 @@ fn run(args: &[~str]) {\n         server(&from_parent, &to_parent);\n     }\n \n-    for worker_results.iter().advance |r| {\n+    foreach r in worker_results.iter() {\n         r.recv();\n     }\n "}, {"sha": "77803ecfc3c07cd67d9a01c1824ad5be955a72cb", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -76,7 +76,7 @@ fn run(args: &[~str]) {\n         server(&from_parent, &to_parent);\n     }\n \n-    for worker_results.iter().advance |r| {\n+    foreach r in worker_results.iter() {\n         r.recv();\n     }\n "}, {"sha": "621f38035e988fd8f4dce5a7802e2df1a95ea152", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -108,7 +108,7 @@ fn main() {\n     thread_ring(0, msg_per_task, num_chan.take(), num_port);\n \n     // synchronize\n-    for futures.mut_iter().advance |f| {\n+    foreach f in futures.mut_iter() {\n         f.get()\n     }\n "}, {"sha": "27cd34c5199a17b831a8154af07360ef01c4993c", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -94,7 +94,7 @@ fn main() {\n     thread_ring(0, msg_per_task, num_chan.take(), num_port);\n \n     // synchronize\n-    for futures.mut_iter().advance |f| {\n+    foreach f in futures.mut_iter() {\n         let _ = f.get();\n     }\n "}, {"sha": "609a160aa5d47219c6936d7f6cf1368857977764", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -104,7 +104,7 @@ fn main() {\n     thread_ring(0, msg_per_task, num_chan.take(), num_port);\n \n     // synchronize\n-    for futures.mut_iter().advance |f| {\n+    foreach f in futures.mut_iter() {\n         let _ = f.get();\n     }\n "}, {"sha": "52548f40f8291f591b3809502c7dcdb9140afeb6", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -22,8 +22,8 @@ use std::uint;\n \n fn print_complements() {\n     let all = [Blue, Red, Yellow];\n-    for all.iter().advance |aa| {\n-        for all.iter().advance |bb| {\n+    foreach aa in all.iter() {\n+        foreach bb in all.iter() {\n             println(show_color(*aa) + \" + \" + show_color(*bb) +\n                     \" -> \" + show_color(transform(*aa, *bb)));\n         }\n@@ -47,7 +47,7 @@ fn show_color(cc: color) -> ~str {\n \n fn show_color_list(set: ~[color]) -> ~str {\n     let mut out = ~\"\";\n-    for set.iter().advance |col| {\n+    foreach col in set.iter() {\n         out.push_char(' ');\n         out.push_str(show_color(*col));\n     }\n@@ -180,21 +180,21 @@ fn rendezvous(nn: uint, set: ~[color]) {\n     }\n \n     // tell each creature to stop\n-    for to_creature.iter().advance |to_one| {\n+    foreach to_one in to_creature.iter() {\n         to_one.send(None);\n     }\n \n     // save each creature's meeting stats\n     let mut report = ~[];\n-    for to_creature.iter().advance |_to_one| {\n+    foreach _to_one in to_creature.iter() {\n         report.push(from_creatures_log.recv());\n     }\n \n     // print each color in the set\n     io::println(show_color_list(set));\n \n     // print each creature's stats\n-    for report.iter().advance |rep| {\n+    foreach rep in report.iter() {\n         io::println(*rep);\n     }\n "}, {"sha": "35179328c83308cf90c9112648f87ad4c5e306bd", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -29,7 +29,7 @@ fn fannkuch_redux(n: i32) -> i32 {\n                 r -= 1;\n             }\n \n-            for perm.mut_iter().zip(perm1.iter()).advance |(perm_i, perm1_i)| {\n+            foreach (perm_i, perm1_i) in perm.mut_iter().zip(perm1.iter()) {\n                 *perm_i = *perm1_i;\n             }\n "}, {"sha": "f2cc364ab1095324a25d2794f87b40d89ba6433d", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -58,7 +58,7 @@ static HOMO_SAPIENS: [AminoAcid, ..4] = [\n fn sum_and_scale(a: &'static [AminoAcid]) -> ~[AminoAcid] {\n     let mut result = ~[];\n     let mut p = 0f32;\n-    for a.iter().advance |a_i| {\n+    foreach a_i in a.iter() {\n         let mut a_i = *a_i;\n         p += a_i.p;\n         a_i.p = p * LOOKUP_SCALE;\n@@ -134,7 +134,7 @@ impl RandomFasta {\n     fn make_lookup(a: &[AminoAcid]) -> [AminoAcid, ..LOOKUP_SIZE] {\n         let mut lookup = [ NULL_AMINO_ACID, ..LOOKUP_SIZE ];\n         let mut j = 0;\n-        for lookup.mut_iter().enumerate().advance |(i, slot)| {\n+        foreach (i, slot) in lookup.mut_iter().enumerate() {\n             while a[j].p < (i as f32) {\n                 j += 1;\n             }\n@@ -150,7 +150,7 @@ impl RandomFasta {\n \n     fn nextc(&mut self) -> u8 {\n         let r = self.rng(1.0);\n-        for self.lookup.iter().advance |a| {\n+        foreach a in self.lookup.iter() {\n             if a.p >= r {\n                 return a.c;\n             }"}, {"sha": "350d139676fd13fa000bbc19113d455a812754f2", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -46,7 +46,7 @@ struct AminoAcids {\n fn make_cumulative(aa: ~[AminoAcids]) -> ~[AminoAcids] {\n     let mut cp: u32 = 0u32;\n     let mut ans: ~[AminoAcids] = ~[];\n-    for aa.iter().advance |a| {\n+    foreach a in aa.iter() {\n         cp += a.prob;\n         ans.push(AminoAcids {ch: a.ch, prob: cp});\n     }"}, {"sha": "6c40ede76825b8cae4dae725369c07bbba72e8da", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -62,15 +62,15 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n    let mut pairs = ~[];\n \n    // map -> [(k,%)]\n-   for mm.iter().advance |(key, &val)| {\n+   foreach (key, &val) in mm.iter() {\n       pairs.push(((*key).clone(), pct(val, total)));\n    }\n \n    let pairs_sorted = sortKV(pairs);\n \n    let mut buffer = ~\"\";\n \n-   for pairs_sorted.iter().advance |kv| {\n+   foreach kv in pairs_sorted.iter() {\n        let (k,v) = (*kv).clone();\n        unsafe {\n            let b = str::raw::from_bytes(k);\n@@ -215,7 +215,7 @@ fn main() {\n          (_, true) => {\n             let line_bytes = line.as_bytes();\n \n-           for sizes.iter().enumerate().advance |(ii, _sz)| {\n+           foreach (ii, _sz) in sizes.iter().enumerate() {\n                let lb = line_bytes.to_owned();\n                to_child[ii].send(lb);\n             }\n@@ -227,12 +227,12 @@ fn main() {\n    }\n \n    // finish...\n-    for sizes.iter().enumerate().advance |(ii, _sz)| {\n+    foreach (ii, _sz) in sizes.iter().enumerate() {\n       to_child[ii].send(~[]);\n    }\n \n    // now fetch and print result messages\n-    for sizes.iter().enumerate().advance |(ii, _sz)| {\n+    foreach (ii, _sz) in sizes.iter().enumerate() {\n       io::println(from_child[ii].recv());\n    }\n }"}, {"sha": "3fbebbdb55659db2382e6022e2ff3a520ae5fedb", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -102,7 +102,7 @@ fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: i32) {\n             }\n         }\n \n-        for bodies.mut_iter().advance |a| {\n+        foreach a in bodies.mut_iter() {\n             a.x[0] += dt * a.v[0];\n             a.x[1] += dt * a.v[1];\n             a.x[2] += dt * a.v[2];"}, {"sha": "9344bb63205666213c4d2646667daa686e794ae6", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -89,7 +89,7 @@ fn stress(num_tasks: int) {\n             stress_task(i);\n         }\n     }\n-    for results.iter().advance |r| {\n+    foreach r in results.iter() {\n         r.recv();\n     }\n }"}, {"sha": "893431e6bb37544b2347427a66e9acf109833840", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -19,26 +19,26 @@ fn A(i: i32, j: i32) -> i32 {\n \n fn dot(v: &[f64], u: &[f64]) -> f64 {\n     let mut sum = 0.0;\n-    for v.iter().enumerate().advance |(i, &v_i)| {\n+    foreach (i, &v_i) in v.iter().enumerate() {\n         sum += v_i * u[i];\n     }\n     sum\n }\n \n fn mult_Av(v: &mut [f64], out: &mut [f64]) {\n-    for out.mut_iter().enumerate().advance |(i, out_i)| {\n+    foreach (i, out_i) in out.mut_iter().enumerate() {\n         let mut sum = 0.0;\n-        for v.mut_iter().enumerate().advance |(j, &v_j)| {\n+        foreach (j, &v_j) in v.mut_iter().enumerate() {\n             sum += v_j / (A(i as i32, j as i32) as f64);\n         }\n         *out_i = sum;\n     }\n }\n \n fn mult_Atv(v: &mut [f64], out: &mut [f64]) {\n-    for out.mut_iter().enumerate().advance |(i, out_i)| {\n+    foreach (i, out_i) in out.mut_iter().enumerate() {\n         let mut sum = 0.0;\n-        for v.mut_iter().enumerate().advance |(j, &v_j)| {\n+        foreach (j, &v_j) in v.mut_iter().enumerate() {\n             sum += v_j / (A(j as i32, i as i32) as f64);\n         }\n         *out_i = sum;"}, {"sha": "c535bf7daeaecd46d2937e67cedd1b8cbd2038b9", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -16,7 +16,7 @@ struct Foo {\n \n impl Foo {\n     pub fn foo(&mut self, fun: &fn(&int)) {\n-        for self.n.iter().advance |f| {\n+        foreach f in self.n.iter() {\n             fun(f);\n         }\n     }"}, {"sha": "c6aa1713db8820776ab1a257181dbe930f709005", "filename": "src/test/compile-fail/borrowck-mut-boxed-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let v = @mut [ 1, 2, 3 ];\n-    for v.iter().advance |_x| {\n+    foreach _x in v.iter() {\n         v[1] = 4; //~ ERROR cannot assign\n     }\n }"}, {"sha": "6fe802b650b17974a289f932fdc7baa2c4bef062", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -15,7 +15,7 @@ trait vec_monad<A> {\n impl<A> vec_monad<A> for ~[A] {\n     fn bind<B>(&self, f: &fn(A) -> ~[B]) {\n         let mut r = fail!();\n-        for self.iter().advance |elt| { r = r + f(*elt); }\n+        foreach elt in self.iter() { r = r + f(*elt); }\n         //~^ WARNING unreachable expression\n         //~^^ ERROR the type of this value must be known\n    }"}, {"sha": "d1e8d96a76908cc1dc67b5cfa21502df45b6084a", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -14,7 +14,7 @@\n fn fail_len(v: ~[int]) -> uint {\n     let mut i = 3;\n     fail!();\n-    for v.iter().advance |x| { i += 1u; }\n+    foreach x in v.iter() { i += 1u; }\n     //~^ ERROR: unreachable statement\n     return i;\n }"}, {"sha": "9fc84c98cf57bb83a9f80a6e39a9a23ed38a9bb7", "filename": "src/test/compile-fail/issue-5100.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -37,7 +37,7 @@ fn main() {\n              ('c', 'd'),\n              ('e', 'f')];\n \n-    for v.iter().advance |&(x,y)| {} // should be OK\n+    foreach &(x,y) in v.iter() {} // should be OK\n \n     // Make sure none of the errors above were fatal\n     let x: char = true; //~ ERROR expected `char` but found `bool`"}, {"sha": "d645f35d96d7c224f08aae8443afe05ad48efcb2", "filename": "src/test/compile-fail/rcmut-not-const-and-not-owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -14,7 +14,7 @@ fn o<T: Send>(_: &T) {}\n fn c<T: Freeze>(_: &T) {}\n \n fn main() {\n-    let x = extra::rc::RcMut::from_owned(0);\n+    let x = extra::rc::RcMut::from_send(0);\n     o(&x); //~ ERROR instantiating a type parameter with an incompatible type `extra::rc::RcMut<int>`, which does not fulfill `Send`\n     c(&x); //~ ERROR instantiating a type parameter with an incompatible type `extra::rc::RcMut<int>`, which does not fulfill `Freeze`\n }"}, {"sha": "ef197a10c7d93249907723287f16b535c5003bd9", "filename": "src/test/compile-fail/vec-mut-iter-borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let mut xs = ~[1, 2, 3, 4];\n \n-    for xs.mut_iter().advance |x| {\n+    foreach x in xs.mut_iter() {\n         xs.push(1) //~ ERROR cannot borrow `xs` as mutable\n     }\n }"}, {"sha": "d1629885c7a943356161126fba1943e4a79349fc", "filename": "src/test/pretty/block-comment-wchar.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -108,7 +108,7 @@\n          '\\xA0', '\\u1680', '\\u180E', '\\u2000', '\\u2001', '\\u2002', '\\u2003',\n          '\\u2004', '\\u2005', '\\u2006', '\\u2007', '\\u2008', '\\u2009', '\\u200A',\n          '\\u2028', '\\u2029', '\\u202F', '\\u205F', '\\u3000'];\n-    for chars.iter().advance |c| {\n+    foreach c in chars.iter() {\n         let ws = c.is_whitespace();\n         println(fmt!(\"%? %?\" , c , ws));\n     }"}, {"sha": "822a71da3c87e31a37f6ac80bb03f4ff2a1e85c9", "filename": "src/test/pretty/block-comment-wchar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -102,7 +102,7 @@ fn main() {\n          '\\xA0', '\\u1680', '\\u180E', '\\u2000', '\\u2001', '\\u2002', '\\u2003',\n          '\\u2004', '\\u2005', '\\u2006', '\\u2007', '\\u2008', '\\u2009', '\\u200A',\n          '\\u2028', '\\u2029', '\\u202F', '\\u205F', '\\u3000'];\n-    for chars.iter().advance |c| {\n+    foreach c in chars.iter() {\n         let ws = c.is_whitespace();\n         println(fmt!(\"%? %?\", c , ws));\n     }"}, {"sha": "750c8dd84954bf9b2d702eb346b47cc7a2c76b0f", "filename": "src/test/pretty/for-comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fpretty%2Ffor-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Fpretty%2Ffor-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ffor-comment.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -12,7 +12,7 @@\n \n fn f(v: &[int]) {\n     let mut n = 0;\n-    for v.iter().advance |e| {\n+    foreach e in v.iter() {\n         n = *e; // This comment once triggered pretty printer bug\n     }\n }"}, {"sha": "37ac5f85a9e8cabde557909dc027660562083781", "filename": "src/test/run-pass/auto-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-loop.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -11,7 +11,7 @@\n pub fn main() {\n     let mut sum = 0;\n     let xs = ~[1, 2, 3, 4, 5];\n-    for xs.iter().advance |x| {\n+    foreach x in xs.iter() {\n         sum += *x;\n     }\n     assert_eq!(sum, 15);"}, {"sha": "313d5a62554ab421e9dc2411d2a7827a3ef2af75", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -15,7 +15,7 @@ pub fn main() {\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n \n     // Statement form does not require parentheses:\n-    for v.iter().advance |i| {\n+    foreach i in v.iter() {\n         info!(\"%?\", *i);\n     }\n "}, {"sha": "d9c9670c858b1e4dee03da2bc67a5a71a9b10439", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-fn iter_vec<T>(v: ~[T], f: &fn(&T)) { for v.iter().advance |x| { f(x); } }\n+fn iter_vec<T>(v: ~[T], f: &fn(&T)) { foreach x in v.iter() { f(x); } }\n \n pub fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7];"}, {"sha": "e51ca5bcc956645ab59b2f5dfc24af676d0c8cf6", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-fn iter_vec<T>(v: ~[T], f: &fn(&T)) { for v.iter().advance |x| { f(x); } }\n+fn iter_vec<T>(v: ~[T], f: &fn(&T)) { foreach x in v.iter() { f(x); } }\n \n pub fn main() {\n     let v = ~[1, 2, 3, 4, 5];"}, {"sha": "3b1e28ab915a4bcbd8522514b8df915f1e7d82e8", "filename": "src/test/run-pass/borrowck-borrow-from-at-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -10,7 +10,7 @@\n \n fn sum_slice(x: &[int]) -> int {\n     let mut sum = 0;\n-    for x.iter().advance |i| { sum += *i; }\n+    foreach i in x.iter() { sum += *i; }\n     return sum;\n }\n "}, {"sha": "c6fc84b2054b96d78dbe5cc57e98bc37d0c0e417", "filename": "src/test/run-pass/borrowck-mut-vec-as-imm-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -10,7 +10,7 @@\n \n fn want_slice(v: &[int]) -> int {\n     let mut sum = 0;\n-    for v.iter().advance |i| { sum += *i; }\n+    foreach i in v.iter() { sum += *i; }\n     sum\n }\n "}, {"sha": "c6ef71110431c9533a10630143d1ae2d02d0f2f6", "filename": "src/test/run-pass/borrowck-wg-borrow-mut-to-imm-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -4,7 +4,7 @@ struct Wizard {\n \n impl Wizard {\n     pub fn cast(&mut self) {\n-        for self.spells.iter().advance |&spell| {\n+        foreach &spell in self.spells.iter() {\n             println(spell);\n         }\n     }"}, {"sha": "46b6eec6fa627dbe1fdb8fdbd6eed9cdb4ae7fb5", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -17,7 +17,7 @@ pub fn main() {\n     loop { i += 1; if i == 20 { break; } }\n     assert_eq!(i, 20);\n     let xs = [1, 2, 3, 4, 5, 6];\n-    for xs.iter().advance |x| {\n+    foreach x in xs.iter() {\n         if *x == 3 { break; } assert!((*x <= 3));\n     }\n     i = 0;\n@@ -28,7 +28,7 @@ pub fn main() {\n         if i >= 10 { break; }\n     }\n     let ys = ~[1, 2, 3, 4, 5, 6];\n-    for ys.iter().advance |x| {\n+    foreach x in ys.iter() {\n         if *x % 2 == 0 { loop; }\n         assert!((*x % 2 != 0));\n     }"}, {"sha": "c31b72c1bd9356d25f8b82b4b77c9152412f1e23", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -1,6 +1,6 @@\n fn sum(x: &[int]) -> int {\n     let mut sum = 0;\n-    for x.iter().advance |y| { sum += *y; }\n+    foreach y in x.iter() { sum += *y; }\n     return sum;\n }\n "}, {"sha": "07655cf3525043771c6861f913b79504c4821184", "filename": "src/test/run-pass/const-vec-of-fns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -24,6 +24,6 @@ struct S<'self>(&'self fn());\n static closures: &'static [S<'static>] = &[S(f), S(f)];\n \n pub fn main() {\n-    for bare_fns.iter().advance |&bare_fn| { bare_fn() }\n-    for closures.iter().advance |&closure| { (*closure)() }\n+    foreach &bare_fn in bare_fns.iter() { bare_fn() }\n+    foreach &closure in closures.iter() { (*closure)() }\n }"}, {"sha": "0b070a6ec7abb2384caaac42822fc9ee46148cdb", "filename": "src/test/run-pass/deriving-cmp-generic-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -25,8 +25,8 @@ pub fn main() {\n     // in order for both Ord and TotalOrd\n     let es = [e0, e11, e12, e21, e22];\n \n-    for es.iter().enumerate().advance |(i, e1)| {\n-        for es.iter().enumerate().advance |(j, e2)| {\n+    foreach (i, e1) in es.iter().enumerate() {\n+        foreach (j, e2) in es.iter().enumerate() {\n             let ord = i.cmp(&j);\n \n             let eq = i == j;"}, {"sha": "026994590a0ed22ceecfb141357276f84269fe67", "filename": "src/test/run-pass/deriving-cmp-generic-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -21,8 +21,8 @@ pub fn main() {\n     // in order for both Ord and TotalOrd\n     let ss = [s1, s2];\n \n-    for ss.iter().enumerate().advance |(i, s1)| {\n-        for ss.iter().enumerate().advance |(j, s2)| {\n+    foreach (i, s1) in ss.iter().enumerate() {\n+        foreach (j, s2) in ss.iter().enumerate() {\n             let ord = i.cmp(&j);\n \n             let eq = i == j;"}, {"sha": "4d7701703db591141d67ed414b541076a65a8a28", "filename": "src/test/run-pass/deriving-cmp-generic-tuple-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -19,8 +19,8 @@ pub fn main() {\n     // in order for both Ord and TotalOrd\n     let tss = [ts1, ts2];\n \n-    for tss.iter().enumerate().advance |(i, ts1)| {\n-        for tss.iter().enumerate().advance |(j, ts2)| {\n+    foreach (i, ts1) in tss.iter().enumerate() {\n+        foreach (j, ts2) in tss.iter().enumerate() {\n             let ord = i.cmp(&j);\n \n             let eq = i == j;"}, {"sha": "10f825e32cd524910082fa484222ed7d1661947c", "filename": "src/test/run-pass/explicit-self-closures.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -16,10 +16,10 @@ struct Box {\n \n impl Box {\n     pub fn set_many(&mut self, xs: &[uint]) {\n-        for xs.iter().advance |x| { self.x = *x; }\n+        foreach x in xs.iter() { self.x = *x; }\n     }\n     pub fn set_many2(@mut self, xs: &[uint]) {\n-        for xs.iter().advance |x| { self.x = *x; }\n+        foreach x in xs.iter() { self.x = *x; }\n     }\n }\n "}, {"sha": "bf36d86c849ccdf433b62f3f9e7eb65534c52e37", "filename": "src/test/run-pass/fn-pattern-expected-type-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type-2.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     let v : &[(int,int)] = &[ (1, 2), (3, 4), (5, 6) ];\n-    for v.iter().advance |&(x, y)| {\n+    foreach &(x, y) in v.iter() {\n         println(y.to_str());\n         println(x.to_str());\n     }"}, {"sha": "68d075834f55128ae84846899481039c13118070", "filename": "src/test/run-pass/for-loop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn main() { let x: ~[int] = ~[]; for x.iter().advance |_| { fail!(\"moop\"); } }\n+pub fn main() { let x: ~[int] = ~[]; foreach _ in x.iter() { fail!(\"moop\"); } }"}, {"sha": "388f61c1b032fc5521d45c28680e0240ded33a52", "filename": "src/test/run-pass/generic-static-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -15,7 +15,7 @@ trait vec_utils<T> {\n impl<T> vec_utils<T> for ~[T] {\n     fn map_<U>(x: &~[T], f: &fn(&T) -> U) -> ~[U] {\n         let mut r = ~[];\n-        for x.iter().advance |elt| {\n+        foreach elt in x.iter() {\n             r.push(f(elt));\n         }\n         r"}, {"sha": "3d41065365ced289093acb2a8ed8e66ee34fe79b", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -31,7 +31,7 @@ mod map_reduce {\n     enum ctrl_proto { find_reducer(~[u8], Chan<int>), mapper_done, }\n \n     fn start_mappers(ctrl: SharedChan<ctrl_proto>, inputs: ~[~str]) {\n-        for inputs.iter().advance |i| {\n+        foreach i in inputs.iter() {\n             let ctrl = ctrl.clone();\n             let i = i.clone();\n             task::spawn(|| map_task(ctrl.clone(), i.clone()) );"}, {"sha": "092d5e5813bc5e0b3aa8bafb3c6b76d1a8406c0a", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -67,13 +67,13 @@ fn read_board_grid<rdr:'static + io::Reader>(input: rdr) -> ~[~[square]] {\n     let mut grid = ~[];\n     for input.each_line |line| {\n         let mut row = ~[];\n-        for line.iter().advance |c| {\n+        foreach c in line.iter() {\n             row.push(square_from_char(c))\n         }\n         grid.push(row)\n     }\n     let width = grid[0].len();\n-    for grid.iter().advance |row| { assert!(row.len() == width) }\n+    foreach row in grid.iter() { assert!(row.len() == width) }\n     grid\n }\n "}, {"sha": "84d3db444e9c513965f13b0d3e170869f173dcec", "filename": "src/test/run-pass/issue-3389.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3389.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -14,7 +14,7 @@ struct trie_node {\n }\n \n fn print_str_vector(vector: ~[~str]) {\n-    for vector.iter().advance |string| {\n+    foreach string in vector.iter() {\n         println(*string);\n     }\n }"}, {"sha": "7e9b637516fd719760549bd2da7506c31014e034", "filename": "src/test/run-pass/issue-3563-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -11,7 +11,7 @@\n trait Canvas {\n     fn add_point(&self, point: &int);\n     fn add_points(&self, shapes: &[int]) {\n-        for shapes.iter().advance |pt| {\n+        foreach pt in shapes.iter() {\n             self.add_point(pt)\n         }\n     }"}, {"sha": "b85ddf95a547131a61adb4632e0bd6555c9a4bf9", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -120,7 +120,7 @@ trait Canvas {\n     // Unlike interfaces traits support default implementations.\n     // Got an ICE as soon as I added this method.\n     fn add_points(&mut self, shapes: &[Point]) {\n-        for shapes.iter().advance |pt| {self.add_point(*pt)};\n+        foreach pt in shapes.iter() {self.add_point(*pt)};\n     }\n }\n "}, {"sha": "3bfb2ef38537d174742a7f878c891df25ec601e2", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -102,7 +102,7 @@ priv fn cmd_to_str(cmd: ~[~str]) -> ~str {\n   let mut res = ~\"*\";\n   res.push_str(cmd.len().to_str());\n   res.push_str(\"\\r\\n\");\n-    for cmd.iter().advance |s| {\n+    foreach s in cmd.iter() {\n     res.push_str([~\"$\", s.len().to_str(), ~\"\\r\\n\",\n                   (*s).clone(), ~\"\\r\\n\"].concat() );\n     }"}, {"sha": "da46eb421521d49ba5e7858825008c547ac62d89", "filename": "src/test/run-pass/issue-4542.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fissue-4542.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fissue-4542.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4542.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -12,7 +12,7 @@ use std::os;\n \n pub fn main() {\n     let x = os::args();\n-    for x.iter().advance |arg| {\n+    foreach arg in x.iter() {\n         match arg.clone() {\n             s => { }\n         }"}, {"sha": "c6002afded75ae01d1c446785abc5409a0f8b4a4", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -11,12 +11,12 @@\n pub fn main() {\n     let x = ~[1, 2, 3];\n     let mut y = 0;\n-    for x.iter().advance |i| { info!(*i); y += *i; }\n+    foreach i in x.iter() { info!(*i); y += *i; }\n     info!(y);\n     assert_eq!(y, 6);\n     let s = ~\"hello there\";\n     let mut i: int = 0;\n-    for s.byte_iter().advance |c| {\n+    foreach c in s.byte_iter() {\n         if i == 0 { assert!((c == 'h' as u8)); }\n         if i == 1 { assert!((c == 'e' as u8)); }\n         if i == 2 { assert!((c == 'l' as u8)); }"}, {"sha": "746487f8aff581492f7417e12ae0c1a55c729e02", "filename": "src/test/run-pass/loop-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Floop-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Floop-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-scope.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -11,6 +11,6 @@\n pub fn main() {\n     let x = ~[10, 20, 30];\n     let mut sum = 0;\n-    for x.iter().advance |x| { sum += *x; }\n+    foreach x in x.iter() { sum += *x; }\n     assert_eq!(sum, 60);\n }"}, {"sha": "316f872b82fd278f3e4dd32e2f9c26ff2c175595", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -19,7 +19,7 @@ trait vec_monad<A> {\n impl<A> vec_monad<A> for ~[A] {\n     fn bind<B>(&self, f: &fn(&A) -> ~[B]) -> ~[B] {\n         let mut r = ~[];\n-        for self.iter().advance |elt| {\n+        foreach elt in self.iter() {\n             r.push_all_move(f(elt));\n         }\n         r"}, {"sha": "bfb68d296c183237cb83579e664b7d88cdbdc56f", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -65,7 +65,7 @@ pub fn main() {\n         calllink10\n     ];\n     let mut rng = rand::rng();\n-    for fns.iter().advance |f| {\n+    foreach f in fns.iter() {\n         let f = *f;\n         let sz = rng.next() % 256u32 + 256u32;\n         let frame_backoff = rng.next() % 10u32 + 1u32;"}, {"sha": "5de4b74922c81437d5d8f0a8a6fc2c3c94351011", "filename": "src/test/run-pass/mutability-inherits-through-fixed-length-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -16,8 +16,8 @@ fn test1() {\n \n fn test2() {\n     let mut ints = [0, ..32];\n-    for ints.mut_iter().advance |i| { *i += 22; }\n-    for ints.iter().advance |i| { assert!(*i == 22); }\n+    foreach i in ints.mut_iter() { *i += 22; }\n+    foreach i in ints.iter() { assert!(*i == 22); }\n }\n \n pub fn main() {"}, {"sha": "706168844f5121a5736cadcafa3eaee68e6d7d68", "filename": "src/test/run-pass/overload-index-operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -31,7 +31,7 @@ impl<K,V> AssociationList<K,V> {\n \n impl<K:Eq,V:Clone> Index<K,V> for AssociationList<K,V> {\n     fn index(&self, index: &K) -> V {\n-        for self.pairs.iter().advance |pair| {\n+        foreach pair in self.pairs.iter() {\n             if pair.key == *index {\n                 return pair.value.clone();\n             }"}, {"sha": "0f84adcc9414cead8d909612c098272bbec98d1a", "filename": "src/test/run-pass/packed-struct-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -27,7 +27,7 @@ fn main() {\n         assert_eq!(foos[i], Foo { bar: 1, baz: 2});\n     }\n \n-    for foos.iter().advance |&foo| {\n+    foreach &foo in foos.iter() {\n         assert_eq!(foo, Foo { bar: 1, baz: 2 });\n     }\n }"}, {"sha": "090b5f549d4b3168c01104f2d02eb4a23181b6b6", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -666,7 +666,7 @@ pub fn main() {\n         visit_tydesc(td, v);\n \n         let r = u.vals.clone();\n-        for r.iter().advance |s| {\n+        foreach s in r.iter() {\n             printfln!(\"val: %s\", *s);\n         }\n         error!(\"%?\", u.vals.clone());"}, {"sha": "e80dc2269c2f91566f9fad56d027ead263ed0d54", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -170,7 +170,7 @@ pub fn main() {\n     visit_ty::<i16>(vv);\n     visit_ty::<~[int]>(vv);\n \n-    for v.types.iter().advance |s| {\n+    foreach s in v.types.iter() {\n         printfln!(\"type: %s\", (*s).clone());\n     }\n     assert_eq!((*v.types).clone(), ~[~\"bool\", ~\"int\", ~\"i8\", ~\"i16\", ~\"[\", ~\"int\", ~\"]\"]);"}, {"sha": "5cb2f9b872799dcea135246d984d799547231574", "filename": "src/test/run-pass/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshadow.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -16,7 +16,7 @@ fn foo(c: ~[int]) {\n \n     match none::<int> {\n         some::<int>(_) => {\n-            for c.iter().advance |i| {\n+            foreach i in c.iter() {\n                 info!(a);\n                 let a = 17;\n                 b.push(a);"}, {"sha": "4f86c87518a1e83b45911fdd2197f1657f5a6d77", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -48,10 +48,10 @@ trait vec_utils<T> {\n \n impl<T> vec_utils<T> for ~[T] {\n     fn length_(&self) -> uint { self.len() }\n-    fn iter_(&self, f: &fn(&T)) { for self.iter().advance |x| { f(x); } }\n+    fn iter_(&self, f: &fn(&T)) { foreach x in self.iter() { f(x); } }\n     fn map_<U>(&self, f: &fn(&T) -> U) -> ~[U] {\n         let mut r = ~[];\n-        for self.iter().advance |elt| {\n+        foreach elt in self.iter() {\n             r.push(f(elt));\n         }\n         r"}, {"sha": "6b2516f59215641e7931f4f1d5761451f215f31b", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -54,7 +54,7 @@ fn test00() {\n \n     // Read from spawned tasks...\n     let mut sum = 0;\n-    for results.iter().advance |r| {\n+    foreach r in results.iter() {\n         i = 0;\n         while i < number_of_messages {\n             let value = po.recv();\n@@ -64,7 +64,7 @@ fn test00() {\n     }\n \n     // Join spawned tasks...\n-    for results.iter().advance |r| { r.recv(); }\n+    foreach r in results.iter() { r.recv(); }\n \n     info!(\"Completed: Final number is: \");\n     error!(sum);"}, {"sha": "e0be4ccf810802d34179a9315b6814b5b2e6b730", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -84,20 +84,20 @@ fn main() {\n \n fn check_legs(arc: arc::Arc<~[~Pet:Freeze+Send]>) {\n     let mut legs = 0;\n-    for arc.get().iter().advance |pet| {\n+    foreach pet in arc.get().iter() {\n         legs += pet.num_legs();\n     }\n     assert!(legs == 12);\n }\n fn check_names(arc: arc::Arc<~[~Pet:Freeze+Send]>) {\n-    for arc.get().iter().advance |pet| {\n+    foreach pet in arc.get().iter() {\n         do pet.name |name| {\n             assert!(name[0] == 'a' as u8 && name[1] == 'l' as u8);\n         }\n     }\n }\n fn check_pedigree(arc: arc::Arc<~[~Pet:Freeze+Send]>) {\n-    for arc.get().iter().advance |pet| {\n+    foreach pet in arc.get().iter() {\n         assert!(pet.of_good_pedigree());\n     }\n }"}, {"sha": "a5b85681420a103eed4a93f1965f77080153ce21", "filename": "src/test/run-pass/unfoldr-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Funfoldr-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Funfoldr-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funfoldr-cross-crate.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -26,7 +26,7 @@ fn main() {\n \n     let mut it = Unfoldr::new(0, count);\n     let mut i = 0;\n-    for it.advance |counted| {\n+    foreach counted in it {\n         assert_eq!(counted, i);\n         i += 1;\n     }"}, {"sha": "1ebe72d19c11fd8c6a44341ea6d5ccef8f8698f8", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6069c7a90761c120cecbd8e18317bce21dd213/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=5c6069c7a90761c120cecbd8e18317bce21dd213", "patch": "@@ -41,7 +41,7 @@ pub fn main() {\n \n     fn check_str_eq(a: ~str, b: ~str) {\n         let mut i: int = 0;\n-        for a.byte_iter().advance |ab| {\n+        foreach ab in a.byte_iter() {\n             info!(i);\n             info!(ab);\n             let bb: u8 = b[i];"}]}