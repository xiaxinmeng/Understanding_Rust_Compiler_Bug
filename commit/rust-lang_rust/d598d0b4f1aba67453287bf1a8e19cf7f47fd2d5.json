{"sha": "d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5", "node_id": "C_kwDOAAsO6NoAKGQ1OThkMGI0ZjFhYmE2NzQ1MzI4N2JmMWE4ZTE5Y2Y3ZjQ3ZmQyZDU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-23T18:36:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-23T18:36:44Z"}, "message": "Merge #10322\n\n10322: internal: Split the hover module up r=Veykril a=Veykril\n\ncc https://github.com/rust-analyzer/rust-analyzer/issues/10107\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "eb30f3b7b5ee6e5a5595ee1ab907e7a10e948b39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb30f3b7b5ee6e5a5595ee1ab907e7a10e948b39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhTMk8CRBK7hj4Ov3rIwAAdAIIAI6X1awgaoXG4fPrzjzF7A1o\nqhDPInjdxMlR1IEJCAVwVd8wggRMl/cMdMgthZ/ur29StSOJp+axkvLRfs+bojF1\nGYoRG4G5EX1vGtOrsT5vwUKBUP/NwG+hPGNS3z+Oc/B2KhUx6d5vWeu6SZVOfVMF\n8rlYnkw4Ot54WcT6QoKlOrCZBjkxNjl7Y6U9zipwma2RCILP2k3xjQwgPwZ65kUn\n7fncIvyrTiGK/F1KY2+mTcVtLpF0pUNDU7K4EjsNNsWv/lSm4cWLLh6ojU1hJlT9\n83O8YMdigwHuWPZT/4TNeRz+DfR/Kkma2nLtRDTPkgiZqR55n3i9kY+y3hamkvs=\n=cLo9\n-----END PGP SIGNATURE-----\n", "payload": "tree eb30f3b7b5ee6e5a5595ee1ab907e7a10e948b39\nparent 839885930cd2da8a9a3852f5f89bfb189f5fde89\nparent e60f3d265f74ba410ba52e10143fdbff56eaf342\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1632422204 +0000\ncommitter GitHub <noreply@github.com> 1632422204 +0000\n\nMerge #10322\n\n10322: internal: Split the hover module up r=Veykril a=Veykril\n\ncc https://github.com/rust-analyzer/rust-analyzer/issues/10107\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5", "html_url": "https://github.com/rust-lang/rust/commit/d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "839885930cd2da8a9a3852f5f89bfb189f5fde89", "url": "https://api.github.com/repos/rust-lang/rust/commits/839885930cd2da8a9a3852f5f89bfb189f5fde89", "html_url": "https://github.com/rust-lang/rust/commit/839885930cd2da8a9a3852f5f89bfb189f5fde89"}, {"sha": "e60f3d265f74ba410ba52e10143fdbff56eaf342", "url": "https://api.github.com/repos/rust-lang/rust/commits/e60f3d265f74ba410ba52e10143fdbff56eaf342", "html_url": "https://github.com/rust-lang/rust/commit/e60f3d265f74ba410ba52e10143fdbff56eaf342"}], "stats": {"total": 9387, "additions": 4689, "deletions": 4698}, "files": [{"sha": "474db2e8ded42319a6b688de3bc5b624e0dce3f8", "filename": "crates/ide/src/display.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5/crates%2Fide%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5/crates%2Fide%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdisplay.rs?ref=d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5", "patch": "@@ -2,7 +2,4 @@\n //! into types that may be used to render in a UI.\n \n pub(crate) mod navigation_target;\n-\n pub(crate) use navigation_target::{ToNav, TryToNav};\n-\n-pub(crate) use syntax::display::macro_label;"}, {"sha": "d9e990f0291e4bee59537649fa54bcd25a0c1858", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 70, "deletions": 4694, "changes": 4764, "blob_url": "https://github.com/rust-lang/rust/blob/d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5"}, {"sha": "5b516de4c64b414ded21b2d194d9487f7cd12ed9", "filename": "crates/ide/src/hover/render.rs", "status": "added", "additions": 450, "deletions": 0, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5", "patch": "@@ -0,0 +1,450 @@\n+//! Logic for rendering the different hover messages\n+use either::Either;\n+use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo};\n+use ide_db::{\n+    base_db::SourceDatabase,\n+    defs::Definition,\n+    helpers::{\n+        generated_lints::{CLIPPY_LINTS, DEFAULT_LINTS, FEATURES},\n+        FamousDefs,\n+    },\n+    RootDatabase,\n+};\n+use itertools::Itertools;\n+use stdx::format_to;\n+use syntax::{\n+    algo, ast,\n+    display::{fn_as_proc_macro_label, macro_label},\n+    match_ast, AstNode, Direction,\n+    SyntaxKind::{CONDITION, LET_STMT},\n+    SyntaxToken, T,\n+};\n+\n+use crate::{\n+    doc_links::{remove_links, rewrite_links},\n+    hover::walk_and_push_ty,\n+    markdown_remove::remove_markdown,\n+    HoverAction, HoverConfig, HoverResult, Markup,\n+};\n+\n+pub(super) fn type_info(\n+    sema: &Semantics<RootDatabase>,\n+    config: &HoverConfig,\n+    expr_or_pat: &Either<ast::Expr, ast::Pat>,\n+) -> Option<HoverResult> {\n+    let TypeInfo { original, adjusted } = match expr_or_pat {\n+        Either::Left(expr) => sema.type_of_expr(expr)?,\n+        Either::Right(pat) => sema.type_of_pat(pat)?,\n+    };\n+\n+    let mut res = HoverResult::default();\n+    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n+    let mut push_new_def = |item: hir::ModuleDef| {\n+        if !targets.contains(&item) {\n+            targets.push(item);\n+        }\n+    };\n+    walk_and_push_ty(sema.db, &original, &mut push_new_def);\n+\n+    res.markup = if let Some(adjusted_ty) = adjusted {\n+        walk_and_push_ty(sema.db, &adjusted_ty, &mut push_new_def);\n+        let original = original.display(sema.db).to_string();\n+        let adjusted = adjusted_ty.display(sema.db).to_string();\n+        let static_text_diff_len = \"Coerced to: \".len() - \"Type: \".len();\n+        format!(\n+            \"{bt_start}Type: {:>apad$}\\nCoerced to: {:>opad$}\\n{bt_end}\",\n+            original,\n+            adjusted,\n+            apad = static_text_diff_len + adjusted.len().max(original.len()),\n+            opad = original.len(),\n+            bt_start = if config.markdown() { \"```text\\n\" } else { \"\" },\n+            bt_end = if config.markdown() { \"```\\n\" } else { \"\" }\n+        )\n+        .into()\n+    } else {\n+        if config.markdown() {\n+            Markup::fenced_block(&original.display(sema.db))\n+        } else {\n+            original.display(sema.db).to_string().into()\n+        }\n+    };\n+    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n+    Some(res)\n+}\n+\n+pub(super) fn try_expr(\n+    sema: &Semantics<RootDatabase>,\n+    config: &HoverConfig,\n+    try_expr: &ast::TryExpr,\n+) -> Option<HoverResult> {\n+    let inner_ty = sema.type_of_expr(&try_expr.expr()?)?.original;\n+    let mut ancestors = try_expr.syntax().ancestors();\n+    let mut body_ty = loop {\n+        let next = ancestors.next()?;\n+        break match_ast! {\n+            match next {\n+                ast::Fn(fn_) => sema.to_def(&fn_)?.ret_type(sema.db),\n+                ast::Item(__) => return None,\n+                ast::ClosureExpr(closure) => sema.type_of_expr(&closure.body()?)?.original,\n+                ast::EffectExpr(effect) => if matches!(effect.effect(), ast::Effect::Async(_) | ast::Effect::Try(_)| ast::Effect::Const(_)) {\n+                    sema.type_of_expr(&effect.block_expr()?.into())?.original\n+                } else {\n+                    continue;\n+                },\n+                _ => continue,\n+            }\n+        };\n+    };\n+\n+    if inner_ty == body_ty {\n+        return None;\n+    }\n+\n+    let mut inner_ty = inner_ty;\n+    let mut s = \"Try Target\".to_owned();\n+\n+    let adts = inner_ty.as_adt().zip(body_ty.as_adt());\n+    if let Some((hir::Adt::Enum(inner), hir::Adt::Enum(body))) = adts {\n+        let famous_defs = FamousDefs(sema, sema.scope(&try_expr.syntax()).krate());\n+        // special case for two options, there is no value in showing them\n+        if let Some(option_enum) = famous_defs.core_option_Option() {\n+            if inner == option_enum && body == option_enum {\n+                cov_mark::hit!(hover_try_expr_opt_opt);\n+                return None;\n+            }\n+        }\n+\n+        // special case two results to show the error variants only\n+        if let Some(result_enum) = famous_defs.core_result_Result() {\n+            if inner == result_enum && body == result_enum {\n+                let error_type_args =\n+                    inner_ty.type_arguments().nth(1).zip(body_ty.type_arguments().nth(1));\n+                if let Some((inner, body)) = error_type_args {\n+                    inner_ty = inner;\n+                    body_ty = body;\n+                    s = \"Try Error\".to_owned();\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut res = HoverResult::default();\n+\n+    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n+    let mut push_new_def = |item: hir::ModuleDef| {\n+        if !targets.contains(&item) {\n+            targets.push(item);\n+        }\n+    };\n+    walk_and_push_ty(sema.db, &inner_ty, &mut push_new_def);\n+    walk_and_push_ty(sema.db, &body_ty, &mut push_new_def);\n+    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n+\n+    let inner_ty = inner_ty.display(sema.db).to_string();\n+    let body_ty = body_ty.display(sema.db).to_string();\n+    let ty_len_max = inner_ty.len().max(body_ty.len());\n+\n+    let l = \"Propagated as: \".len() - \" Type: \".len();\n+    let static_text_len_diff = l as isize - s.len() as isize;\n+    let tpad = static_text_len_diff.max(0) as usize;\n+    let ppad = static_text_len_diff.min(0).abs() as usize;\n+\n+    res.markup = format!(\n+        \"{bt_start}{} Type: {:>pad0$}\\nPropagated as: {:>pad1$}\\n{bt_end}\",\n+        s,\n+        inner_ty,\n+        body_ty,\n+        pad0 = ty_len_max + tpad,\n+        pad1 = ty_len_max + ppad,\n+        bt_start = if config.markdown() { \"```text\\n\" } else { \"\" },\n+        bt_end = if config.markdown() { \"```\\n\" } else { \"\" }\n+    )\n+    .into();\n+    Some(res)\n+}\n+\n+pub(super) fn deref_expr(\n+    sema: &Semantics<RootDatabase>,\n+    config: &HoverConfig,\n+    deref_expr: &ast::PrefixExpr,\n+) -> Option<HoverResult> {\n+    let inner_ty = sema.type_of_expr(&deref_expr.expr()?)?.original;\n+    let TypeInfo { original, adjusted } =\n+        sema.type_of_expr(&ast::Expr::from(deref_expr.clone()))?;\n+\n+    let mut res = HoverResult::default();\n+    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n+    let mut push_new_def = |item: hir::ModuleDef| {\n+        if !targets.contains(&item) {\n+            targets.push(item);\n+        }\n+    };\n+    walk_and_push_ty(sema.db, &inner_ty, &mut push_new_def);\n+    walk_and_push_ty(sema.db, &original, &mut push_new_def);\n+\n+    res.markup = if let Some(adjusted_ty) = adjusted {\n+        walk_and_push_ty(sema.db, &adjusted_ty, &mut push_new_def);\n+        let original = original.display(sema.db).to_string();\n+        let adjusted = adjusted_ty.display(sema.db).to_string();\n+        let inner = inner_ty.display(sema.db).to_string();\n+        let type_len = \"To type: \".len();\n+        let coerced_len = \"Coerced to: \".len();\n+        let deref_len = \"Dereferenced from: \".len();\n+        let max_len = (original.len() + type_len)\n+            .max(adjusted.len() + coerced_len)\n+            .max(inner.len() + deref_len);\n+        format!(\n+            \"{bt_start}Dereferenced from: {:>ipad$}\\nTo type: {:>apad$}\\nCoerced to: {:>opad$}\\n{bt_end}\",\n+            inner,\n+            original,\n+            adjusted,\n+            ipad = max_len - deref_len,\n+            apad = max_len - type_len,\n+            opad = max_len - coerced_len,\n+            bt_start = if config.markdown() { \"```text\\n\" } else { \"\" },\n+            bt_end = if config.markdown() { \"```\\n\" } else { \"\" }\n+        )\n+        .into()\n+    } else {\n+        let original = original.display(sema.db).to_string();\n+        let inner = inner_ty.display(sema.db).to_string();\n+        let type_len = \"To type: \".len();\n+        let deref_len = \"Dereferenced from: \".len();\n+        let max_len = (original.len() + type_len).max(inner.len() + deref_len);\n+        format!(\n+            \"{bt_start}Dereferenced from: {:>ipad$}\\nTo type: {:>apad$}\\n{bt_end}\",\n+            inner,\n+            original,\n+            ipad = max_len - deref_len,\n+            apad = max_len - type_len,\n+            bt_start = if config.markdown() { \"```text\\n\" } else { \"\" },\n+            bt_end = if config.markdown() { \"```\\n\" } else { \"\" }\n+        )\n+        .into()\n+    };\n+    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n+\n+    Some(res)\n+}\n+\n+pub(super) fn keyword(\n+    sema: &Semantics<RootDatabase>,\n+    config: &HoverConfig,\n+    token: &SyntaxToken,\n+) -> Option<HoverResult> {\n+    if !token.kind().is_keyword() || !config.documentation.is_some() {\n+        return None;\n+    }\n+    let famous_defs = FamousDefs(sema, sema.scope(&token.parent()?).krate());\n+    // std exposes {}_keyword modules with docstrings on the root to document keywords\n+    let keyword_mod = format!(\"{}_keyword\", token.text());\n+    let doc_owner = find_std_module(&famous_defs, &keyword_mod)?;\n+    let docs = doc_owner.attrs(sema.db).docs()?;\n+    let markup = process_markup(\n+        sema.db,\n+        Definition::ModuleDef(doc_owner.into()),\n+        &markup(Some(docs.into()), token.text().into(), None)?,\n+        config,\n+    );\n+    Some(HoverResult { markup, actions: Default::default() })\n+}\n+\n+pub(super) fn try_for_lint(attr: &ast::Attr, token: &SyntaxToken) -> Option<HoverResult> {\n+    let (path, tt) = attr.as_simple_call()?;\n+    if !tt.syntax().text_range().contains(token.text_range().start()) {\n+        return None;\n+    }\n+    let (is_clippy, lints) = match &*path {\n+        \"feature\" => (false, FEATURES),\n+        \"allow\" | \"deny\" | \"forbid\" | \"warn\" => {\n+            let is_clippy = algo::non_trivia_sibling(token.clone().into(), Direction::Prev)\n+                .filter(|t| t.kind() == T![:])\n+                .and_then(|t| algo::non_trivia_sibling(t, Direction::Prev))\n+                .filter(|t| t.kind() == T![:])\n+                .and_then(|t| algo::non_trivia_sibling(t, Direction::Prev))\n+                .map_or(false, |t| {\n+                    t.kind() == T![ident] && t.into_token().map_or(false, |t| t.text() == \"clippy\")\n+                });\n+            if is_clippy {\n+                (true, CLIPPY_LINTS)\n+            } else {\n+                (false, DEFAULT_LINTS)\n+            }\n+        }\n+        _ => return None,\n+    };\n+\n+    let tmp;\n+    let needle = if is_clippy {\n+        tmp = format!(\"clippy::{}\", token.text());\n+        &tmp\n+    } else {\n+        &*token.text()\n+    };\n+\n+    let lint =\n+        lints.binary_search_by_key(&needle, |lint| lint.label).ok().map(|idx| &lints[idx])?;\n+    Some(HoverResult {\n+        markup: Markup::from(format!(\"```\\n{}\\n```\\n___\\n\\n{}\", lint.label, lint.description)),\n+        ..Default::default()\n+    })\n+}\n+\n+pub(super) fn process_markup(\n+    db: &RootDatabase,\n+    def: Definition,\n+    markup: &Markup,\n+    config: &HoverConfig,\n+) -> Markup {\n+    let markup = markup.as_str();\n+    let markup = if !config.markdown() {\n+        remove_markdown(markup)\n+    } else if config.links_in_hover {\n+        rewrite_links(db, markup, def)\n+    } else {\n+        remove_links(markup)\n+    };\n+    Markup::from(markup)\n+}\n+\n+fn definition_owner_name(db: &RootDatabase, def: &Definition) -> Option<String> {\n+    match def {\n+        Definition::Field(f) => Some(f.parent_def(db).name(db)),\n+        Definition::Local(l) => l.parent(db).name(db),\n+        Definition::ModuleDef(md) => match md {\n+            hir::ModuleDef::Function(f) => match f.as_assoc_item(db)?.container(db) {\n+                hir::AssocItemContainer::Trait(t) => Some(t.name(db)),\n+                hir::AssocItemContainer::Impl(i) => i.self_ty(db).as_adt().map(|adt| adt.name(db)),\n+            },\n+            hir::ModuleDef::Variant(e) => Some(e.parent_enum(db).name(db)),\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+    .map(|name| name.to_string())\n+}\n+\n+pub(super) fn path(db: &RootDatabase, module: hir::Module, item_name: Option<String>) -> String {\n+    let crate_name =\n+        db.crate_graph()[module.krate().into()].display_name.as_ref().map(|it| it.to_string());\n+    let module_path = module\n+        .path_to_root(db)\n+        .into_iter()\n+        .rev()\n+        .flat_map(|it| it.name(db).map(|name| name.to_string()));\n+    crate_name.into_iter().chain(module_path).chain(item_name).join(\"::\")\n+}\n+\n+pub(super) fn definition(\n+    db: &RootDatabase,\n+    def: Definition,\n+    famous_defs: Option<&FamousDefs>,\n+    config: &HoverConfig,\n+) -> Option<Markup> {\n+    let mod_path = definition_mod_path(db, &def);\n+    let (label, docs) = match def {\n+        Definition::Macro(it) => (\n+            match &it.source(db)?.value {\n+                Either::Left(mac) => macro_label(mac),\n+                Either::Right(mac_fn) => fn_as_proc_macro_label(mac_fn),\n+            },\n+            it.attrs(db).docs(),\n+        ),\n+        Definition::Field(def) => label_and_docs(db, def),\n+        Definition::ModuleDef(it) => match it {\n+            hir::ModuleDef::Module(it) => label_and_docs(db, it),\n+            hir::ModuleDef::Function(it) => label_and_docs(db, it),\n+            hir::ModuleDef::Adt(it) => label_and_docs(db, it),\n+            hir::ModuleDef::Variant(it) => label_and_docs(db, it),\n+            hir::ModuleDef::Const(it) => label_and_docs(db, it),\n+            hir::ModuleDef::Static(it) => label_and_docs(db, it),\n+            hir::ModuleDef::Trait(it) => label_and_docs(db, it),\n+            hir::ModuleDef::TypeAlias(it) => label_and_docs(db, it),\n+            hir::ModuleDef::BuiltinType(it) => {\n+                return famous_defs\n+                    .and_then(|fd| builtin(fd, it))\n+                    .or_else(|| Some(Markup::fenced_block(&it.name())))\n+            }\n+        },\n+        Definition::Local(it) => return local(db, it),\n+        Definition::SelfType(impl_def) => {\n+            impl_def.self_ty(db).as_adt().map(|adt| label_and_docs(db, adt))?\n+        }\n+        Definition::GenericParam(it) => label_and_docs(db, it),\n+        Definition::Label(it) => return Some(Markup::fenced_block(&it.name(db))),\n+    };\n+\n+    markup(docs.filter(|_| config.documentation.is_some()).map(Into::into), label, mod_path)\n+}\n+\n+fn label_and_docs<D>(db: &RootDatabase, def: D) -> (String, Option<hir::Documentation>)\n+where\n+    D: HasAttrs + HirDisplay,\n+{\n+    let label = def.display(db).to_string();\n+    let docs = def.attrs(db).docs();\n+    (label, docs)\n+}\n+\n+fn definition_mod_path(db: &RootDatabase, def: &Definition) -> Option<String> {\n+    if let Definition::GenericParam(_) = def {\n+        return None;\n+    }\n+    def.module(db).map(|module| path(db, module, definition_owner_name(db, def)))\n+}\n+\n+fn markup(docs: Option<String>, desc: String, mod_path: Option<String>) -> Option<Markup> {\n+    let mut buf = String::new();\n+\n+    if let Some(mod_path) = mod_path {\n+        if !mod_path.is_empty() {\n+            format_to!(buf, \"```rust\\n{}\\n```\\n\\n\", mod_path);\n+        }\n+    }\n+    format_to!(buf, \"```rust\\n{}\\n```\", desc);\n+\n+    if let Some(doc) = docs {\n+        format_to!(buf, \"\\n___\\n\\n{}\", doc);\n+    }\n+    Some(buf.into())\n+}\n+\n+fn builtin(famous_defs: &FamousDefs, builtin: hir::BuiltinType) -> Option<Markup> {\n+    // std exposes prim_{} modules with docstrings on the root to document the builtins\n+    let primitive_mod = format!(\"prim_{}\", builtin.name());\n+    let doc_owner = find_std_module(famous_defs, &primitive_mod)?;\n+    let docs = doc_owner.attrs(famous_defs.0.db).docs()?;\n+    markup(Some(docs.into()), builtin.name().to_string(), None)\n+}\n+\n+fn find_std_module(famous_defs: &FamousDefs, name: &str) -> Option<hir::Module> {\n+    let db = famous_defs.0.db;\n+    let std_crate = famous_defs.std()?;\n+    let std_root_module = std_crate.root_module(db);\n+    std_root_module\n+        .children(db)\n+        .find(|module| module.name(db).map_or(false, |module| module.to_string() == name))\n+}\n+\n+fn local(db: &RootDatabase, it: hir::Local) -> Option<Markup> {\n+    let ty = it.ty(db);\n+    let ty = ty.display(db);\n+    let is_mut = if it.is_mut(db) { \"mut \" } else { \"\" };\n+    let desc = match it.source(db).value {\n+        Either::Left(ident) => {\n+            let name = it.name(db).unwrap();\n+            let let_kw = if ident\n+                .syntax()\n+                .parent()\n+                .map_or(false, |p| p.kind() == LET_STMT || p.kind() == CONDITION)\n+            {\n+                \"let \"\n+            } else {\n+                \"\"\n+            };\n+            format!(\"{}{}{}: {}\", let_kw, is_mut, name, ty)\n+        }\n+        Either::Right(_) => format!(\"{}self: {}\", is_mut, ty),\n+    };\n+    markup(None, desc, None)\n+}"}, {"sha": "463cd58e48bd890cb8d5d6cc5f308cb11b06e63c", "filename": "crates/ide/src/hover/tests.rs", "status": "added", "additions": 4168, "deletions": 0, "changes": 4168, "blob_url": "https://github.com/rust-lang/rust/blob/d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5"}, {"sha": "5709f34ddd74b6e4b5bc1a477d47732a364f755c", "filename": "crates/rust-analyzer/tests/slow-tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs?ref=d598d0b4f1aba67453287bf1a8e19cf7f47fd2d5", "patch": "@@ -191,7 +191,7 @@ fn deny_clippy(path: &Path, text: &str) {\n         // The documentation in string literals may contain anything for its own purposes\n         \"ide_db/src/helpers/generated_lints.rs\",\n         // The tests test clippy lint hovers\n-        \"ide/src/hover.rs\",\n+        \"ide/src/hover/tests.rs\",\n     ];\n     if ignore.iter().any(|p| path.ends_with(p)) {\n         return;"}]}