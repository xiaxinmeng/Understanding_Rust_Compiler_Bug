{"sha": "cd7fade0a9c1c8762d2fba7c65c1b82e8d369711", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkN2ZhZGUwYTljMWM4NzYyZDJmYmE3YzY1YzFiODJlOGQzNjk3MTE=", "commit": {"author": {"name": "Ruud van Asseldonk", "email": "dev@veniogames.com", "date": "2016-11-02T21:49:27Z"}, "committer": {"name": "Ruud van Asseldonk", "email": "dev@veniogames.com", "date": "2016-11-30T10:09:29Z"}, "message": "Add small-copy optimization for io::Cursor\n\nDuring benchmarking, I found that one of my programs spent between 5 and\n10 percent of the time doing memmoves. Ultimately I tracked these down\nto single-byte slices being copied with a memcopy in io::Cursor::read().\nDoing a manual copy if only one byte is requested can speed things up\nsignificantly. For my program, this reduced the running time by 20%.\n\nWhy special-case only a single byte, and not a \"small\" slice in general?\nI tried doing this for slices of at most 64 bytes and of at most 8\nbytes. In both cases my test program was significantly slower.", "tree": {"sha": "946873bd4b027e019a115f2f1359ecd64ac6502e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/946873bd4b027e019a115f2f1359ecd64ac6502e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd7fade0a9c1c8762d2fba7c65c1b82e8d369711", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd7fade0a9c1c8762d2fba7c65c1b82e8d369711", "html_url": "https://github.com/rust-lang/rust/commit/cd7fade0a9c1c8762d2fba7c65c1b82e8d369711", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd7fade0a9c1c8762d2fba7c65c1b82e8d369711/comments", "author": {"login": "ruuda", "id": 506953, "node_id": "MDQ6VXNlcjUwNjk1Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/506953?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ruuda", "html_url": "https://github.com/ruuda", "followers_url": "https://api.github.com/users/ruuda/followers", "following_url": "https://api.github.com/users/ruuda/following{/other_user}", "gists_url": "https://api.github.com/users/ruuda/gists{/gist_id}", "starred_url": "https://api.github.com/users/ruuda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ruuda/subscriptions", "organizations_url": "https://api.github.com/users/ruuda/orgs", "repos_url": "https://api.github.com/users/ruuda/repos", "events_url": "https://api.github.com/users/ruuda/events{/privacy}", "received_events_url": "https://api.github.com/users/ruuda/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ruuda", "id": 506953, "node_id": "MDQ6VXNlcjUwNjk1Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/506953?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ruuda", "html_url": "https://github.com/ruuda", "followers_url": "https://api.github.com/users/ruuda/followers", "following_url": "https://api.github.com/users/ruuda/following{/other_user}", "gists_url": "https://api.github.com/users/ruuda/gists{/gist_id}", "starred_url": "https://api.github.com/users/ruuda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ruuda/subscriptions", "organizations_url": "https://api.github.com/users/ruuda/orgs", "repos_url": "https://api.github.com/users/ruuda/repos", "events_url": "https://api.github.com/users/ruuda/events{/privacy}", "received_events_url": "https://api.github.com/users/ruuda/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e373b47872872a2ce61c5b02f4dd96d90d046ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e373b47872872a2ce61c5b02f4dd96d90d046ee", "html_url": "https://github.com/rust-lang/rust/commit/8e373b47872872a2ce61c5b02f4dd96d90d046ee"}], "stats": {"total": 18, "additions": 15, "deletions": 3}, "files": [{"sha": "9b50168a954b7b182aa4770cb616ddb6f435958e", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd7fade0a9c1c8762d2fba7c65c1b82e8d369711/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd7fade0a9c1c8762d2fba7c65c1b82e8d369711/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=cd7fade0a9c1c8762d2fba7c65c1b82e8d369711", "patch": "@@ -219,9 +219,21 @@ impl<T> io::Seek for Cursor<T> where T: AsRef<[u8]> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Read for Cursor<T> where T: AsRef<[u8]> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        let n = Read::read(&mut self.fill_buf()?, buf)?;\n-        self.pos += n as u64;\n-        Ok(n)\n+        // First check if the amount of bytes we want to read is small: the read\n+        // in the else branch will end up calling `<&[u8] as Read>::read()`,\n+        // which will copy the buffer using a memcopy. If we only want to read a\n+        // single byte, then the overhead of the function call is significant.\n+        let num_read = {\n+            let mut inner_buf = self.fill_buf()?;\n+            if buf.len() == 1 && inner_buf.len() > 0 {\n+                buf[0] = inner_buf[0];\n+                1\n+            } else {\n+                Read::read(&mut inner_buf, buf)?\n+            }\n+        };\n+        self.pos += num_read as u64;\n+        Ok(num_read)\n     }\n }\n "}]}