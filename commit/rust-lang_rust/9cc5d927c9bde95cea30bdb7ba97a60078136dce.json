{"sha": "9cc5d927c9bde95cea30bdb7ba97a60078136dce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYzVkOTI3YzliZGU5NWNlYTMwYmRiN2JhOTdhNjAwNzgxMzZkY2U=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-20T12:14:39Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-24T18:46:07Z"}, "message": "Add constant for `Size::from_bytes(0)`", "tree": {"sha": "c7baf344b0c1ad72efcb7ec62ecbdc26000243dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7baf344b0c1ad72efcb7ec62ecbdc26000243dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cc5d927c9bde95cea30bdb7ba97a60078136dce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc5d927c9bde95cea30bdb7ba97a60078136dce", "html_url": "https://github.com/rust-lang/rust/commit/9cc5d927c9bde95cea30bdb7ba97a60078136dce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cc5d927c9bde95cea30bdb7ba97a60078136dce/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a41dd6fce2393b8701080f32aff187a6641e5853", "url": "https://api.github.com/repos/rust-lang/rust/commits/a41dd6fce2393b8701080f32aff187a6641e5853", "html_url": "https://github.com/rust-lang/rust/commit/a41dd6fce2393b8701080f32aff187a6641e5853"}], "stats": {"total": 113, "additions": 59, "deletions": 54}, "files": [{"sha": "2dfe9715f4704a41d870b29a8c8d7aff6c845f89", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -120,6 +120,10 @@ impl<'tcx> MemoryPointer {\n         MemoryPointer { alloc_id, offset }\n     }\n \n+    pub fn zero(alloc_id: AllocId) -> Self {\n+        MemoryPointer::new(alloc_id, Size::ZERO)\n+    }\n+\n     pub(crate) fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n         MemoryPointer::new(\n             self.alloc_id,\n@@ -355,7 +359,7 @@ pub struct Allocation {\n \n impl Allocation {\n     pub fn from_bytes(slice: &[u8], align: Align) -> Self {\n-        let mut undef_mask = UndefMask::new(Size::from_bytes(0));\n+        let mut undef_mask = UndefMask::new(Size::ZERO);\n         undef_mask.grow(Size::from_bytes(slice.len() as u64), true);\n         Self {\n             bytes: slice.to_owned(),\n@@ -467,7 +471,7 @@ impl UndefMask {\n     pub fn new(size: Size) -> Self {\n         let mut m = UndefMask {\n             blocks: vec![],\n-            len: Size::from_bytes(0),\n+            len: Size::ZERO,\n         };\n         m.grow(size, false);\n         m"}, {"sha": "f4be1a97fae312f849f75b65f9117134af3d3198", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -231,7 +231,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             LayoutDetails {\n                 variants: Variants::Single { index: 0 },\n                 fields: FieldPlacement::Arbitrary {\n-                    offsets: vec![Size::from_bytes(0), b_offset],\n+                    offsets: vec![Size::ZERO, b_offset],\n                     memory_index: vec![0, 1]\n                 },\n                 abi: Abi::ScalarPair(a, b),\n@@ -267,7 +267,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             };\n \n             let mut sized = true;\n-            let mut offsets = vec![Size::from_bytes(0); fields.len()];\n+            let mut offsets = vec![Size::ZERO; fields.len()];\n             let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n \n             let mut optimize = !repr.inhibit_struct_field_reordering_opt();\n@@ -307,7 +307,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             // field 5 with offset 0 puts 0 in offsets[5].\n             // At the bottom of this function, we use inverse_memory_index to produce memory_index.\n \n-            let mut offset = Size::from_bytes(0);\n+            let mut offset = Size::ZERO;\n \n             if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n                 if packed {\n@@ -503,7 +503,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     fields: FieldPlacement::Union(0),\n                     abi: Abi::Uninhabited,\n                     align: dl.i8_align,\n-                    size: Size::from_bytes(0)\n+                    size: Size::ZERO\n                 })\n             }\n \n@@ -575,7 +575,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     },\n                     abi: Abi::Aggregate { sized: false },\n                     align: element.align,\n-                    size: Size::from_bytes(0)\n+                    size: Size::ZERO\n                 })\n             }\n             ty::TyStr => {\n@@ -587,7 +587,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     },\n                     abi: Abi::Aggregate { sized: false },\n                     align: dl.i8_align,\n-                    size: Size::from_bytes(0)\n+                    size: Size::ZERO\n                 })\n             }\n \n@@ -696,7 +696,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                             Align::from_bytes(repr_align, repr_align).unwrap());\n                     }\n \n-                    let mut size = Size::from_bytes(0);\n+                    let mut size = Size::ZERO;\n                     for field in &variants[0] {\n                         assert!(!field.is_unsized());\n \n@@ -908,7 +908,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let (min_ity, signed) = Integer::repr_discr(tcx, ty, &def.repr, min, max);\n \n                 let mut align = dl.aggregate_align;\n-                let mut size = Size::from_bytes(0);\n+                let mut size = Size::ZERO;\n \n                 // We're interested in the smallest alignment, so start large.\n                 let mut start_align = Align::from_bytes(256, 256).unwrap();\n@@ -1078,7 +1078,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                             }\n                             _ => bug!()\n                         };\n-                        if pair_offsets[0] == Size::from_bytes(0) &&\n+                        if pair_offsets[0] == Size::ZERO &&\n                             pair_offsets[1] == *offset &&\n                             align == pair.align &&\n                             size == pair.size {\n@@ -1099,7 +1099,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         variants: layout_variants,\n                     },\n                     fields: FieldPlacement::Arbitrary {\n-                        offsets: vec![Size::from_bytes(0)],\n+                        offsets: vec![Size::ZERO],\n                         memory_index: vec![0]\n                     },\n                     abi,\n@@ -1182,7 +1182,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         let build_variant_info = |n: Option<ast::Name>,\n                                   flds: &[ast::Name],\n                                   layout: TyLayout<'tcx>| {\n-            let mut min_size = Size::from_bytes(0);\n+            let mut min_size = Size::ZERO;\n             let field_info: Vec<_> = flds.iter().enumerate().map(|(i, &name)| {\n                 match layout.field(self, i) {\n                     Err(err) => {\n@@ -1567,7 +1567,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                     fields: FieldPlacement::Union(fields),\n                     abi: Abi::Uninhabited,\n                     align: tcx.data_layout.i8_align,\n-                    size: Size::from_bytes(0)\n+                    size: Size::ZERO\n                 })\n             }\n \n@@ -1746,19 +1746,19 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n         match layout.abi {\n             Abi::Scalar(ref scalar) => {\n-                return Ok(scalar_niche(scalar, Size::from_bytes(0)));\n+                return Ok(scalar_niche(scalar, Size::ZERO));\n             }\n             Abi::ScalarPair(ref a, ref b) => {\n                 // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n                 // returns the last maximum.\n                 let niche = iter::once((b, a.value.size(self).abi_align(b.value.align(self))))\n-                    .chain(iter::once((a, Size::from_bytes(0))))\n+                    .chain(iter::once((a, Size::ZERO)))\n                     .filter_map(|(scalar, offset)| scalar_niche(scalar, offset))\n                     .max_by_key(|niche| niche.available);\n                 return Ok(niche);\n             }\n             Abi::Vector { ref element, .. } => {\n-                return Ok(scalar_niche(element, Size::from_bytes(0)));\n+                return Ok(scalar_niche(element, Size::ZERO));\n             }\n             _ => {}\n         }"}, {"sha": "6b5baa402b4ab88642e0821004e65e2a6bd2efbe", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -454,7 +454,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n                     adjust_for_rust_scalar(&mut a_attrs,\n                                            a,\n                                            arg.layout,\n-                                           Size::from_bytes(0),\n+                                           Size::ZERO,\n                                            false);\n                     adjust_for_rust_scalar(&mut b_attrs,\n                                            b,\n@@ -471,7 +471,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n                     adjust_for_rust_scalar(attrs,\n                                            scalar,\n                                            arg.layout,\n-                                           Size::from_bytes(0),\n+                                           Size::ZERO,\n                                            is_return);\n                 }\n             }"}, {"sha": "99f08540c716c660e3308ec4a79893c6d419b5b7", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -325,7 +325,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         MemberDescription {\n             name: \"data_ptr\".to_string(),\n             type_metadata: data_ptr_metadata,\n-            offset: Size::from_bytes(0),\n+            offset: Size::ZERO,\n             size: pointer_size,\n             align: pointer_align,\n             flags: DIFlags::FlagZero,\n@@ -1074,7 +1074,7 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n             MemberDescription {\n                 name: f.name.to_string(),\n                 type_metadata: type_metadata(cx, field.ty, self.span),\n-                offset: Size::from_bytes(0),\n+                offset: Size::ZERO,\n                 size,\n                 align,\n                 flags: DIFlags::FlagZero,\n@@ -1158,7 +1158,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     MemberDescription {\n                         name: \"\".to_string(),\n                         type_metadata: variant_type_metadata,\n-                        offset: Size::from_bytes(0),\n+                        offset: Size::ZERO,\n                         size: self.layout.size,\n                         align: self.layout.align,\n                         flags: DIFlags::FlagZero\n@@ -1187,7 +1187,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     MemberDescription {\n                         name: \"\".to_string(),\n                         type_metadata: variant_type_metadata,\n-                        offset: Size::from_bytes(0),\n+                        offset: Size::ZERO,\n                         size: variant.size,\n                         align: variant.align,\n                         flags: DIFlags::FlagZero\n@@ -1248,7 +1248,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     MemberDescription {\n                         name,\n                         type_metadata: variant_type_metadata,\n-                        offset: Size::from_bytes(0),\n+                        offset: Size::ZERO,\n                         size: variant.size,\n                         align: variant.align,\n                         flags: DIFlags::FlagZero\n@@ -1747,7 +1747,7 @@ pub fn create_vtable_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             name.as_ptr(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n-            Size::from_bytes(0).bits(),\n+            Size::ZERO.bits(),\n             cx.tcx.data_layout.pointer_align.abi_bits() as u32,\n             DIFlags::FlagArtificial,\n             ptr::null_mut(),"}, {"sha": "c993d7db107e3944c45a64d704c186cacdf278b4", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -40,7 +40,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             if use_x86_mmx {\n                 return Type::x86_mmx(cx)\n             } else {\n-                let element = layout.scalar_llvm_type_at(cx, element, Size::from_bytes(0));\n+                let element = layout.scalar_llvm_type_at(cx, element, Size::ZERO);\n                 return Type::vector(&element, count);\n             }\n         }\n@@ -120,7 +120,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     let field_count = layout.fields.count();\n \n     let mut packed = false;\n-    let mut offset = Size::from_bytes(0);\n+    let mut offset = Size::ZERO;\n     let mut prev_align = layout.align;\n     let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n     for i in layout.fields.index_by_increasing_offset() {\n@@ -265,7 +265,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                     );\n                     FnType::new(cx, sig, &[]).llvm_type(cx).ptr_to()\n                 }\n-                _ => self.scalar_llvm_type_at(cx, scalar, Size::from_bytes(0))\n+                _ => self.scalar_llvm_type_at(cx, scalar, Size::ZERO)\n             };\n             cx.scalar_lltypes.borrow_mut().insert(self.ty, llty);\n             return llty;\n@@ -372,7 +372,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n \n         let offset = if index == 0 {\n-            Size::from_bytes(0)\n+            Size::ZERO\n         } else {\n             a.value.size(cx).abi_align(b.value.align(cx))\n         };"}, {"sha": "98623976cb8115de4a95889031686f0da06b329e", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -21,7 +21,7 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::region;\n use rustc::infer::InferCtxt;\n-use rustc::ty::layout::{IntegerExt, Size};\n+use rustc::ty::layout::IntegerExt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt, layout};\n use rustc::ty::subst::{Kind, Substs};\n@@ -182,15 +182,15 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             LitKind::Str(ref s, _) => {\n                 let s = s.as_str();\n                 let id = self.tcx.allocate_bytes(s.as_bytes());\n-                let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n+                let ptr = MemoryPointer::zero(id);\n                 ConstValue::ByValPair(\n                     PrimVal::Ptr(ptr),\n                     PrimVal::from_u128(s.len() as u128),\n                 )\n             },\n             LitKind::ByteStr(ref data) => {\n                 let id = self.tcx.allocate_bytes(data);\n-                let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n+                let ptr = MemoryPointer::zero(id);\n                 ConstValue::ByVal(PrimVal::Ptr(ptr))\n             },\n             LitKind::Byte(n) => ConstValue::ByVal(PrimVal::Bytes(n as u128)),"}, {"sha": "38b379cd082a594e6e0498a6195b5b45a5390385", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -22,7 +22,6 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n use rustc::mir::interpret::{PrimVal, GlobalId, ConstValue, Value};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n-use rustc::ty::layout::Size;\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{Def, CtorKind};\n@@ -1123,15 +1122,15 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n         LitKind::Str(ref s, _) => {\n             let s = s.as_str();\n             let id = tcx.allocate_bytes(s.as_bytes());\n-            let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n+            let ptr = MemoryPointer::zero(id);\n             ConstValue::ByValPair(\n                 PrimVal::Ptr(ptr),\n                 PrimVal::from_u128(s.len() as u128),\n             )\n         },\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_bytes(data);\n-            let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n+            let ptr = MemoryPointer::zero(id);\n             ConstValue::ByVal(PrimVal::Ptr(ptr))\n         },\n         LitKind::Byte(n) => ConstValue::ByVal(PrimVal::Bytes(n as u128)),"}, {"sha": "7d10643e81e4606cac9ee48ee3bd7e510d4f9b26", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -1019,7 +1019,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 .lock()\n                 .intern_static(gid.instance.def_id());\n             let layout = self.layout_of(ty)?;\n-            let ptr = MemoryPointer::new(alloc_id, Size::from_bytes(0));\n+            let ptr = MemoryPointer::zero(alloc_id);\n             return Ok(Value::ByRef(ptr.into(), layout.align))\n         }\n         let cv = self.const_eval(gid)?;"}, {"sha": "2eef8c73db8f6b647a997c2ba38022d72602eeee", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -73,12 +73,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> MemoryPointer {\n         let id = self.tcx.alloc_map.lock().create_fn_alloc(instance);\n-        MemoryPointer::new(id, Size::from_bytes(0))\n+        MemoryPointer::zero(id)\n     }\n \n     pub fn allocate_bytes(&mut self, bytes: &[u8]) -> MemoryPointer {\n         let id = self.tcx.allocate_bytes(bytes);\n-        MemoryPointer::new(id, Size::from_bytes(0))\n+        MemoryPointer::zero(id)\n     }\n \n     /// kind is `None` for statics\n@@ -110,7 +110,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         kind: Option<MemoryKind<M::MemoryKinds>>,\n     ) -> EvalResult<'tcx, MemoryPointer> {\n         let id = self.allocate_value(Allocation::undef(size, align), kind)?;\n-        Ok(MemoryPointer::new(id, Size::from_bytes(0)))\n+        Ok(MemoryPointer::zero(id))\n     }\n \n     pub fn reallocate(\n@@ -448,7 +448,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             if !relocations.is_empty() {\n                 msg.clear();\n                 write!(msg, \"{:1$}\", \"\", prefix_len).unwrap(); // Print spaces.\n-                let mut pos = Size::from_bytes(0);\n+                let mut pos = Size::ZERO;\n                 let relocation_width = (self.pointer_size().bytes() - 1) * 3;\n                 for (i, target_id) in relocations {\n                     // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n@@ -847,8 +847,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     fn check_relocation_edges(&self, ptr: MemoryPointer, size: Size) -> EvalResult<'tcx> {\n-        let overlapping_start = self.relocations(ptr, Size::from_bytes(0))?.len();\n-        let overlapping_end = self.relocations(ptr.offset(size, self)?, Size::from_bytes(0))?.len();\n+        let overlapping_start = self.relocations(ptr, Size::ZERO)?.len();\n+        let overlapping_end = self.relocations(ptr.offset(size, self)?, Size::ZERO)?.len();\n         if overlapping_start + overlapping_end != 0 {\n             return err!(ReadPointerAsBytes);\n         }"}, {"sha": "6b5ad615654747a86285386888ed542e7c18a4ee", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -1,6 +1,6 @@\n use rustc::mir;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, LayoutOf, TyLayout, Size};\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n use rustc::mir::interpret::{GlobalId, Value, PrimVal, EvalResult, Pointer, MemoryPointer};\n@@ -210,7 +210,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n                 let alloc = Machine::init_static(self, cid)?;\n                 Place::Ptr {\n-                    ptr: MemoryPointer::new(alloc, Size::from_bytes(0)).into(),\n+                    ptr: MemoryPointer::zero(alloc).into(),\n                     align: layout.align,\n                     extra: PlaceExtra::None,\n                 }"}, {"sha": "1e8af52e3e8192c3f45054442b71182774e77371", "filename": "src/librustc_target/abi/call/mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -47,7 +47,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<Ty>)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n-    let mut offset = Size::from_bytes(0);\n+    let mut offset = Size::ZERO;\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(cx, &mut fty.ret, &mut offset);\n     }"}, {"sha": "93fe9cb723cc0f2db01f7eee7f548df02ef9206f", "filename": "src/librustc_target/abi/call/mips64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -109,7 +109,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n         abi::FieldPlacement::Arbitrary { .. } => {\n             // Structures are split up into a series of 64-bit integer chunks, but any aligned\n             // doubles not part of another aggregate are passed as floats.\n-            let mut last_offset = Size::from_bytes(0);\n+            let mut last_offset = Size::ZERO;\n \n             for i in 0..arg.layout.fields.count() {\n                 let field = arg.layout.field(cx, i);"}, {"sha": "d5f2501efc521ca269c6e1130e973dd69233387e", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -83,7 +83,7 @@ impl ArgAttributes {\n     pub fn new() -> Self {\n         ArgAttributes {\n             regular: ArgAttribute::default(),\n-            pointee_size: Size::from_bytes(0),\n+            pointee_size: Size::ZERO,\n             pointee_align: None,\n         }\n     }\n@@ -206,7 +206,7 @@ impl From<Uniform> for CastTarget {\n     fn from(uniform: Uniform) -> CastTarget {\n         CastTarget {\n             prefix: [None; 8],\n-            prefix_chunk: Size::from_bytes(0),\n+            prefix_chunk: Size::ZERO,\n             rest: uniform\n         }\n     }\n@@ -274,7 +274,7 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n \n             Abi::ScalarPair(..) |\n             Abi::Aggregate { .. } => {\n-                let mut total = Size::from_bytes(0);\n+                let mut total = Size::ZERO;\n                 let mut result = None;\n \n                 let is_union = match self.fields {"}, {"sha": "3be3034143a3473ef798d53222129cfbf4f29a7b", "filename": "src/librustc_target/abi/call/powerpc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -47,7 +47,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<Ty>)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n-    let mut offset = Size::from_bytes(0);\n+    let mut offset = Size::ZERO;\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(cx, &mut fty.ret, &mut offset);\n     }"}, {"sha": "1e8af52e3e8192c3f45054442b71182774e77371", "filename": "src/librustc_target/abi/call/sparc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -47,7 +47,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<Ty>)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n-    let mut offset = Size::from_bytes(0);\n+    let mut offset = Size::ZERO;\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(cx, &mut fty.ret, &mut offset);\n     }"}, {"sha": "e7d44020f5042001015bda694dd8a1379635b205", "filename": "src/librustc_target/abi/call/x86_64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -101,7 +101,7 @@ fn classify_arg<'a, Ty, C>(cx: C, arg: &ArgType<'a, Ty>)\n     }\n \n     let mut cls = [None; MAX_EIGHTBYTES];\n-    classify(cx, arg.layout, &mut cls, Size::from_bytes(0))?;\n+    classify(cx, arg.layout, &mut cls, Size::ZERO)?;\n     if n > 2 {\n         if cls[0] != Some(Class::Sse) {\n             return Err(Memory);\n@@ -175,7 +175,7 @@ fn cast_target(cls: &[Option<Class>], size: Size) -> CastTarget {\n             target = CastTarget::pair(lo, hi);\n         }\n     }\n-    assert_eq!(reg_component(cls, &mut i, Size::from_bytes(0)), None);\n+    assert_eq!(reg_component(cls, &mut i, Size::ZERO), None);\n     target\n }\n "}, {"sha": "64fca7e088014d52ed8ddfd25b94cd94197c394c", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc5d927c9bde95cea30bdb7ba97a60078136dce/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=9cc5d927c9bde95cea30bdb7ba97a60078136dce", "patch": "@@ -227,6 +227,8 @@ pub struct Size {\n }\n \n impl Size {\n+    pub const ZERO: Size = Self::from_bytes(0);\n+\n     pub fn from_bits(bits: u64) -> Size {\n         // Avoid potential overflow from `bits + 7`.\n         Size::from_bytes(bits / 8 + ((bits % 8) + 7) / 8)\n@@ -614,7 +616,7 @@ impl FieldPlacement {\n \n     pub fn offset(&self, i: usize) -> Size {\n         match *self {\n-            FieldPlacement::Union(_) => Size::from_bytes(0),\n+            FieldPlacement::Union(_) => Size::ZERO,\n             FieldPlacement::Array { stride, count } => {\n                 let i = i as u64;\n                 assert!(i < count);"}]}