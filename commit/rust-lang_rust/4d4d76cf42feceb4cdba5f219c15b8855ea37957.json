{"sha": "4d4d76cf42feceb4cdba5f219c15b8855ea37957", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNGQ3NmNmNDJmZWNlYjRjZGJhNWYyMTljMTViODg1NWVhMzc5NTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-08T07:30:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-08T07:30:21Z"}, "message": "Auto merge of #43077 - SimonSapin:ranges, r=alexcrichton\n\nImplement O(1)-time Iterator::nth for Range*, and slim the Step trait\n\nFixes #43064.\nFixes part of #39975.\nFixes items 1 <s>and 3</s> of #42168.\nCC #27741.\n\nI think #42310 and #43012 should not have landed without the `nth` part of this PR, but oh well.", "tree": {"sha": "2d35333b01feb700cfbfd00302ee575a1d8719d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d35333b01feb700cfbfd00302ee575a1d8719d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d4d76cf42feceb4cdba5f219c15b8855ea37957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d4d76cf42feceb4cdba5f219c15b8855ea37957", "html_url": "https://github.com/rust-lang/rust/commit/4d4d76cf42feceb4cdba5f219c15b8855ea37957", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d4d76cf42feceb4cdba5f219c15b8855ea37957/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b6af9704ae183cb76027624f3f8a5d51eb7dc26", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b6af9704ae183cb76027624f3f8a5d51eb7dc26", "html_url": "https://github.com/rust-lang/rust/commit/4b6af9704ae183cb76027624f3f8a5d51eb7dc26"}, {"sha": "e9a61eeb0434aabc1874c768eebc8bc7a68c6659", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9a61eeb0434aabc1874c768eebc8bc7a68c6659", "html_url": "https://github.com/rust-lang/rust/commit/e9a61eeb0434aabc1874c768eebc8bc7a68c6659"}], "stats": {"total": 370, "additions": 196, "deletions": 174}, "files": [{"sha": "32c32e327eb2d6709b919600f630c72631a30e9b", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 120, "deletions": 160, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/4d4d76cf42feceb4cdba5f219c15b8855ea37957/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4d76cf42feceb4cdba5f219c15b8855ea37957/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=4d4d76cf42feceb4cdba5f219c15b8855ea37957", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use convert::TryFrom;\n use mem;\n use ops::{self, Add, Sub};\n use usize;\n@@ -21,22 +22,13 @@ use super::{FusedIterator, TrustedLen};\n #[unstable(feature = \"step_trait\",\n            reason = \"likely to be replaced by finer-grained traits\",\n            issue = \"42168\")]\n-pub trait Step: PartialOrd + Sized {\n-    /// Steps `self` if possible.\n-    fn step(&self, by: &Self) -> Option<Self>;\n-\n+pub trait Step: Clone + PartialOrd + Sized {\n     /// Returns the number of steps between two step objects. The count is\n     /// inclusive of `start` and exclusive of `end`.\n     ///\n     /// Returns `None` if it is not possible to calculate `steps_between`\n     /// without overflow.\n-    fn steps_between(start: &Self, end: &Self, by: &Self) -> Option<usize>;\n-\n-    /// Same as `steps_between`, but with a `by` of 1\n-    fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize>;\n-\n-    /// Tests whether this step is negative or not (going backwards)\n-    fn is_negative(&self) -> bool;\n+    fn steps_between(start: &Self, end: &Self) -> Option<usize>;\n \n     /// Replaces this step with `1`, returning itself\n     fn replace_one(&mut self) -> Self;\n@@ -49,6 +41,34 @@ pub trait Step: PartialOrd + Sized {\n \n     /// Subtracts one to this step, returning the result\n     fn sub_one(&self) -> Self;\n+\n+    /// Add an usize, returning None on overflow\n+    fn add_usize(&self, n: usize) -> Option<Self>;\n+}\n+\n+// These are still macro-generated because the integer literals resolve to different types.\n+macro_rules! step_identical_methods {\n+    () => {\n+        #[inline]\n+        fn replace_one(&mut self) -> Self {\n+            mem::replace(self, 1)\n+        }\n+\n+        #[inline]\n+        fn replace_zero(&mut self) -> Self {\n+            mem::replace(self, 0)\n+        }\n+\n+        #[inline]\n+        fn add_one(&self) -> Self {\n+            Add::add(*self, 1)\n+        }\n+\n+        #[inline]\n+        fn sub_one(&self) -> Self {\n+            Sub::sub(*self, 1)\n+        }\n+    }\n }\n \n macro_rules! step_impl_unsigned {\n@@ -57,128 +77,67 @@ macro_rules! step_impl_unsigned {\n                    reason = \"likely to be replaced by finer-grained traits\",\n                    issue = \"42168\")]\n         impl Step for $t {\n-            #[inline]\n-            fn step(&self, by: &$t) -> Option<$t> {\n-                (*self).checked_add(*by)\n-            }\n             #[inline]\n             #[allow(trivial_numeric_casts)]\n-            fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n-                if *by == 0 { return None; }\n+            fn steps_between(start: &$t, end: &$t) -> Option<usize> {\n                 if *start < *end {\n                     // Note: We assume $t <= usize here\n-                    let diff = (*end - *start) as usize;\n-                    let by = *by as usize;\n-                    if diff % by > 0 {\n-                        Some(diff / by + 1)\n-                    } else {\n-                        Some(diff / by)\n-                    }\n+                    Some((*end - *start) as usize)\n                 } else {\n                     Some(0)\n                 }\n             }\n \n             #[inline]\n-            fn is_negative(&self) -> bool {\n-                false\n-            }\n-\n-            #[inline]\n-            fn replace_one(&mut self) -> Self {\n-                mem::replace(self, 1)\n-            }\n-\n-            #[inline]\n-            fn replace_zero(&mut self) -> Self {\n-                mem::replace(self, 0)\n-            }\n-\n-            #[inline]\n-            fn add_one(&self) -> Self {\n-                Add::add(*self, 1)\n-            }\n-\n-            #[inline]\n-            fn sub_one(&self) -> Self {\n-                Sub::sub(*self, 1)\n+            fn add_usize(&self, n: usize) -> Option<Self> {\n+                match <$t>::try_from(n) {\n+                    Ok(n_as_t) => self.checked_add(n_as_t),\n+                    Err(_) => None,\n+                }\n             }\n \n-            #[inline]\n-            fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize> {\n-                Self::steps_between(start, end, &1)\n-            }\n+            step_identical_methods!();\n         }\n     )*)\n }\n macro_rules! step_impl_signed {\n-    ($($t:ty)*) => ($(\n+    ($( [$t:ty : $unsigned:ty] )*) => ($(\n         #[unstable(feature = \"step_trait\",\n                    reason = \"likely to be replaced by finer-grained traits\",\n                    issue = \"42168\")]\n         impl Step for $t {\n-            #[inline]\n-            fn step(&self, by: &$t) -> Option<$t> {\n-                (*self).checked_add(*by)\n-            }\n             #[inline]\n             #[allow(trivial_numeric_casts)]\n-            fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n-                if *by == 0 { return None; }\n-                let diff: usize;\n-                let by_u: usize;\n-                if *by > 0 {\n-                    if *start >= *end {\n-                        return Some(0);\n-                    }\n+            fn steps_between(start: &$t, end: &$t) -> Option<usize> {\n+                if *start < *end {\n                     // Note: We assume $t <= isize here\n                     // Use .wrapping_sub and cast to usize to compute the\n                     // difference that may not fit inside the range of isize.\n-                    diff = (*end as isize).wrapping_sub(*start as isize) as usize;\n-                    by_u = *by as usize;\n-                } else {\n-                    if *start <= *end {\n-                        return Some(0);\n-                    }\n-                    diff = (*start as isize).wrapping_sub(*end as isize) as usize;\n-                    by_u = (*by as isize).wrapping_mul(-1) as usize;\n-                }\n-                if diff % by_u > 0 {\n-                    Some(diff / by_u + 1)\n+                    Some((*end as isize).wrapping_sub(*start as isize) as usize)\n                 } else {\n-                    Some(diff / by_u)\n+                    Some(0)\n                 }\n             }\n \n             #[inline]\n-            fn is_negative(&self) -> bool {\n-                *self < 0\n-            }\n-\n-            #[inline]\n-            fn replace_one(&mut self) -> Self {\n-                mem::replace(self, 1)\n-            }\n-\n-            #[inline]\n-            fn replace_zero(&mut self) -> Self {\n-                mem::replace(self, 0)\n-            }\n-\n-            #[inline]\n-            fn add_one(&self) -> Self {\n-                Add::add(*self, 1)\n-            }\n-\n-            #[inline]\n-            fn sub_one(&self) -> Self {\n-                Sub::sub(*self, 1)\n+            fn add_usize(&self, n: usize) -> Option<Self> {\n+                match <$unsigned>::try_from(n) {\n+                    Ok(n_as_unsigned) => {\n+                        // Wrapping in unsigned space handles cases like\n+                        // `-120_i8.add_usize(200) == Some(80_i8)`,\n+                        // even though 200_usize is out of range for i8.\n+                        let wrapped = (*self as $unsigned).wrapping_add(n_as_unsigned) as $t;\n+                        if wrapped >= *self {\n+                            Some(wrapped)\n+                        } else {\n+                            None  // Addition overflowed\n+                        }\n+                    }\n+                    Err(_) => None,\n+                }\n             }\n \n-            #[inline]\n-            fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize> {\n-                Self::steps_between(start, end, &1)\n-            }\n+            step_identical_methods!();\n         }\n     )*)\n }\n@@ -190,54 +149,26 @@ macro_rules! step_impl_no_between {\n                    issue = \"42168\")]\n         impl Step for $t {\n             #[inline]\n-            fn step(&self, by: &$t) -> Option<$t> {\n-                (*self).checked_add(*by)\n-            }\n-            #[inline]\n-            fn steps_between(_a: &$t, _b: &$t, _by: &$t) -> Option<usize> {\n+            fn steps_between(_start: &Self, _end: &Self) -> Option<usize> {\n                 None\n             }\n \n             #[inline]\n-            #[allow(unused_comparisons)]\n-            fn is_negative(&self) -> bool {\n-                *self < 0\n-            }\n-\n-            #[inline]\n-            fn replace_one(&mut self) -> Self {\n-                mem::replace(self, 1)\n-            }\n-\n-            #[inline]\n-            fn replace_zero(&mut self) -> Self {\n-                mem::replace(self, 0)\n-            }\n-\n-            #[inline]\n-            fn add_one(&self) -> Self {\n-                Add::add(*self, 1)\n+            fn add_usize(&self, n: usize) -> Option<Self> {\n+                self.checked_add(n as $t)\n             }\n \n-            #[inline]\n-            fn sub_one(&self) -> Self {\n-                Sub::sub(*self, 1)\n-            }\n-\n-            #[inline]\n-            fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize> {\n-                Self::steps_between(start, end, &1)\n-            }\n+            step_identical_methods!();\n         }\n     )*)\n }\n \n step_impl_unsigned!(usize u8 u16 u32);\n-step_impl_signed!(isize i8 i16 i32);\n+step_impl_signed!([isize: usize] [i8: u8] [i16: u16] [i32: u32]);\n #[cfg(target_pointer_width = \"64\")]\n step_impl_unsigned!(u64);\n #[cfg(target_pointer_width = \"64\")]\n-step_impl_signed!(i64);\n+step_impl_signed!([i64: u64]);\n // If the target pointer width is not 64-bits, we\n // assume here that it is less than 64-bits.\n #[cfg(not(target_pointer_width = \"64\"))]\n@@ -277,9 +208,7 @@ macro_rules! range_incl_trusted_len_impl {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step> Iterator for ops::Range<A> where\n-    for<'a> &'a A: Add<&'a A, Output = A>\n-{\n+impl<A: Step> Iterator for ops::Range<A> {\n     type Item = A;\n \n     #[inline]\n@@ -295,11 +224,24 @@ impl<A: Step> Iterator for ops::Range<A> where\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        match Step::steps_between_by_one(&self.start, &self.end) {\n+        match Step::steps_between(&self.start, &self.end) {\n             Some(hint) => (hint, Some(hint)),\n             None => (0, None)\n         }\n     }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<A> {\n+        if let Some(plus_n) = self.start.add_usize(n) {\n+            if plus_n < self.end {\n+                self.start = plus_n.add_one();\n+                return Some(plus_n)\n+            }\n+        }\n+\n+        self.start = self.end.clone();\n+        None\n+    }\n }\n \n // These macros generate `ExactSizeIterator` impls for various range types.\n@@ -317,10 +259,7 @@ range_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 i64 u64);\n range_incl_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 i64 u64);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step + Clone> DoubleEndedIterator for ops::Range<A> where\n-    for<'a> &'a A: Add<&'a A, Output = A>,\n-    for<'a> &'a A: Sub<&'a A, Output = A>\n-{\n+impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.start < self.end {\n@@ -333,13 +272,10 @@ impl<A: Step + Clone> DoubleEndedIterator for ops::Range<A> where\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n-impl<A> FusedIterator for ops::Range<A>\n-    where A: Step, for<'a> &'a A: Add<&'a A, Output = A> {}\n+impl<A: Step> FusedIterator for ops::Range<A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step> Iterator for ops::RangeFrom<A> where\n-    for<'a> &'a A: Add<&'a A, Output = A>\n-{\n+impl<A: Step> Iterator for ops::RangeFrom<A> {\n     type Item = A;\n \n     #[inline]\n@@ -353,16 +289,20 @@ impl<A: Step> Iterator for ops::RangeFrom<A> where\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (usize::MAX, None)\n     }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<A> {\n+        let plus_n = self.start.add_usize(n).expect(\"overflow in RangeFrom::nth\");\n+        self.start = plus_n.add_one();\n+        Some(plus_n)\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n-impl<A> FusedIterator for ops::RangeFrom<A>\n-    where A: Step, for<'a> &'a A: Add<&'a A, Output = A> {}\n+impl<A: Step> FusedIterator for ops::RangeFrom<A> {}\n \n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<A: Step> Iterator for ops::RangeInclusive<A> where\n-    for<'a> &'a A: Add<&'a A, Output = A>\n-{\n+impl<A: Step> Iterator for ops::RangeInclusive<A> {\n     type Item = A;\n \n     #[inline]\n@@ -389,18 +329,39 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> where\n             return (0, Some(0));\n         }\n \n-        match Step::steps_between_by_one(&self.start, &self.end) {\n+        match Step::steps_between(&self.start, &self.end) {\n             Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n             None => (0, None),\n         }\n     }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<A> {\n+        if let Some(plus_n) = self.start.add_usize(n) {\n+            use cmp::Ordering::*;\n+\n+            match plus_n.partial_cmp(&self.end) {\n+                Some(Less) => {\n+                    self.start = plus_n.add_one();\n+                    return Some(plus_n)\n+                }\n+                Some(Equal) => {\n+                    self.start.replace_one();\n+                    self.end.replace_zero();\n+                    return Some(plus_n)\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        self.start.replace_one();\n+        self.end.replace_zero();\n+        None\n+    }\n }\n \n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> where\n-    for<'a> &'a A: Add<&'a A, Output = A>,\n-    for<'a> &'a A: Sub<&'a A, Output = A>\n-{\n+impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         use cmp::Ordering::*;\n@@ -421,5 +382,4 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> where\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n-impl<A> FusedIterator for ops::RangeInclusive<A>\n-    where A: Step, for<'a> &'a A: Add<&'a A, Output = A> {}\n+impl<A: Step> FusedIterator for ops::RangeInclusive<A> {}"}, {"sha": "a1249a5f22cf73c797e0f98dfab73f0a8db945a4", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4d4d76cf42feceb4cdba5f219c15b8855ea37957/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4d76cf42feceb4cdba5f219c15b8855ea37957/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=4d4d76cf42feceb4cdba5f219c15b8855ea37957", "patch": "@@ -1076,6 +1076,75 @@ fn test_range() {\n                (isize::MAX as usize + 2, Some(isize::MAX as usize + 2)));\n }\n \n+#[test]\n+fn test_range_inclusive_exhaustion() {\n+    let mut r = 10...10;\n+    assert_eq!(r.next(), Some(10));\n+    assert_eq!(r, 1...0);\n+\n+    let mut r = 10...10;\n+    assert_eq!(r.next_back(), Some(10));\n+    assert_eq!(r, 1...0);\n+\n+    let mut r = 10...12;\n+    assert_eq!(r.nth(2), Some(12));\n+    assert_eq!(r, 1...0);\n+\n+    let mut r = 10...12;\n+    assert_eq!(r.nth(5), None);\n+    assert_eq!(r, 1...0);\n+\n+}\n+\n+#[test]\n+fn test_range_nth() {\n+    assert_eq!((10..15).nth(0), Some(10));\n+    assert_eq!((10..15).nth(1), Some(11));\n+    assert_eq!((10..15).nth(4), Some(14));\n+    assert_eq!((10..15).nth(5), None);\n+\n+    let mut r = 10..20;\n+    assert_eq!(r.nth(2), Some(12));\n+    assert_eq!(r, 13..20);\n+    assert_eq!(r.nth(2), Some(15));\n+    assert_eq!(r, 16..20);\n+    assert_eq!(r.nth(10), None);\n+    assert_eq!(r, 20..20);\n+}\n+\n+#[test]\n+fn test_range_from_nth() {\n+    assert_eq!((10..).nth(0), Some(10));\n+    assert_eq!((10..).nth(1), Some(11));\n+    assert_eq!((10..).nth(4), Some(14));\n+\n+    let mut r = 10..;\n+    assert_eq!(r.nth(2), Some(12));\n+    assert_eq!(r, 13..);\n+    assert_eq!(r.nth(2), Some(15));\n+    assert_eq!(r, 16..);\n+    assert_eq!(r.nth(10), Some(26));\n+    assert_eq!(r, 27..);\n+}\n+\n+#[test]\n+fn test_range_inclusive_nth() {\n+    assert_eq!((10...15).nth(0), Some(10));\n+    assert_eq!((10...15).nth(1), Some(11));\n+    assert_eq!((10...15).nth(5), Some(15));\n+    assert_eq!((10...15).nth(6), None);\n+\n+    let mut r = 10_u8...20;\n+    assert_eq!(r.nth(2), Some(12));\n+    assert_eq!(r, 13...20);\n+    assert_eq!(r.nth(2), Some(15));\n+    assert_eq!(r, 16...20);\n+    assert_eq!(r.is_empty(), false);\n+    assert_eq!(r.nth(10), None);\n+    assert_eq!(r.is_empty(), true);\n+    assert_eq!(r, 1...0);  // We may not want to document/promise this detail\n+}\n+\n #[test]\n fn test_range_step() {\n     #![allow(deprecated)]"}, {"sha": "26e4c21dc8f4db6aa8d9e62577170dde898e6b32", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d4d76cf42feceb4cdba5f219c15b8855ea37957/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4d76cf42feceb4cdba5f219c15b8855ea37957/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=4d4d76cf42feceb4cdba5f219c15b8855ea37957", "patch": "@@ -18,12 +18,14 @@\n #![feature(core_private_diy_float)]\n #![feature(dec2flt)]\n #![feature(decode_utf8)]\n+#![feature(exact_size_is_empty)]\n #![feature(fixed_size_array)]\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n #![feature(iterator_step_by)]\n #![feature(i128_type)]\n #![feature(inclusive_range)]\n+#![feature(inclusive_range_syntax)]\n #![feature(iter_rfind)]\n #![feature(libc)]\n #![feature(nonzero)]"}, {"sha": "58794e3b35d531c897a3eee98be7e5ca5e33961b", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d4d76cf42feceb4cdba5f219c15b8855ea37957/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4d76cf42feceb4cdba5f219c15b8855ea37957/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=4d4d76cf42feceb4cdba5f219c15b8855ea37957", "patch": "@@ -18,7 +18,6 @@ pub fn main() {\n     // Bool => does not implement iterator.\n     for i in false..true {}\n     //~^ ERROR `bool: std::iter::Step` is not satisfied\n-    //~^^ ERROR `for<'a> &'a bool: std::ops::Add` is not satisfied\n \n     // Unsized type.\n     let arr: &[_] = &[1, 2, 3];"}, {"sha": "84d86cfdf65a43f938406231bd804ac91232cb54", "filename": "src/test/run-pass/impl-trait/example-calendar.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4d4d76cf42feceb4cdba5f219c15b8855ea37957/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4d76cf42feceb4cdba5f219c15b8855ea37957/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs?ref=4d4d76cf42feceb4cdba5f219c15b8855ea37957", "patch": "@@ -162,22 +162,10 @@ impl<'a, 'b> std::ops::Add<&'b NaiveDate> for &'a NaiveDate {\n }\n \n impl std::iter::Step for NaiveDate {\n-    fn step(&self, by: &Self) -> Option<Self> {\n-        Some(self + by)\n-    }\n-\n-    fn steps_between(_: &Self, _: &Self, _: &Self) -> Option<usize> {\n-        unimplemented!()\n-    }\n-\n-    fn steps_between_by_one(_: &Self, _: &Self) -> Option<usize> {\n+    fn steps_between(_: &Self, _: &Self) -> Option<usize> {\n         unimplemented!()\n     }\n \n-    fn is_negative(&self) -> bool {\n-        false\n-    }\n-\n     fn replace_one(&mut self) -> Self {\n         mem::replace(self, NaiveDate(0, 0, 1))\n     }\n@@ -193,6 +181,10 @@ impl std::iter::Step for NaiveDate {\n     fn sub_one(&self) -> Self {\n         unimplemented!()\n     }\n+\n+    fn add_usize(&self, _: usize) -> Option<Self> {\n+        unimplemented!()\n+    }\n }\n \n #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]"}]}