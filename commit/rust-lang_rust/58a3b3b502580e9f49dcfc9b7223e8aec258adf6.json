{"sha": "58a3b3b502580e9f49dcfc9b7223e8aec258adf6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4YTNiM2I1MDI1ODBlOWY0OWRjZmM5YjcyMjNlOGFlYzI1OGFkZjY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-25T15:58:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-25T15:58:54Z"}, "message": "Merge #2404\n\n2404: Use TypeAliasId in Ty, pt 2 r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "3fe683f845d7b3b47f44337303dac2ff8312a832", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fe683f845d7b3b47f44337303dac2ff8312a832"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58a3b3b502580e9f49dcfc9b7223e8aec258adf6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd2/o+CRBK7hj4Ov3rIwAAdHIIAIWPuFP8H5nmDVcpwKk0Dabi\n2WAbOnRdE5dzKpPYflEUecmnkU1SrivBByf7sSR0AVD0qjVO5ePiECZl37dRW5Zz\n1jqh6xRs5pIQx/5uy3fUzngjjbQSoHBdJNlQw2j5vuOY4v9SdyvFCPSWBoUuOtSE\nbJmOqgQRGYkkHnnXa2rva4C8tL3wxN4Ai/Fhjz/wAo3LEs7woEv7tev+pa6Tez27\nNfana65LJSSOvsfLEJFPAPIEl8OtHz1CQzPB9COUv8PIcSwpuykAK8eru6pms2o+\nQQSblW2PhvGdrBXIbf1dPEDtDZcNSI9JNP1Z4P9GHv34XdNDmEf56LMW0KXmhF8=\n=HfnO\n-----END PGP SIGNATURE-----\n", "payload": "tree 3fe683f845d7b3b47f44337303dac2ff8312a832\nparent ecd1204804a2a3c8b9b98e4b9d18feef06ab51c7\nparent 1a0da6d4dad846568042f85ad7225b45b3275e49\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1574697534 +0000\ncommitter GitHub <noreply@github.com> 1574697534 +0000\n\nMerge #2404\n\n2404: Use TypeAliasId in Ty, pt 2 r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58a3b3b502580e9f49dcfc9b7223e8aec258adf6", "html_url": "https://github.com/rust-lang/rust/commit/58a3b3b502580e9f49dcfc9b7223e8aec258adf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecd1204804a2a3c8b9b98e4b9d18feef06ab51c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecd1204804a2a3c8b9b98e4b9d18feef06ab51c7", "html_url": "https://github.com/rust-lang/rust/commit/ecd1204804a2a3c8b9b98e4b9d18feef06ab51c7"}, {"sha": "1a0da6d4dad846568042f85ad7225b45b3275e49", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a0da6d4dad846568042f85ad7225b45b3275e49", "html_url": "https://github.com/rust-lang/rust/commit/1a0da6d4dad846568042f85ad7225b45b3275e49"}], "stats": {"total": 132, "additions": 70, "deletions": 62}, "files": [{"sha": "f7fc80d4ee480ac9daf521d6b9fe37115b248409", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=58a3b3b502580e9f49dcfc9b7223e8aec258adf6", "patch": "@@ -538,14 +538,6 @@ pub enum DefWithBody {\n impl_froms!(DefWithBody: Function, Const, Static);\n \n impl DefWithBody {\n-    pub(crate) fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n-        match self {\n-            DefWithBody::Const(c) => c.krate(db),\n-            DefWithBody::Function(f) => f.krate(db),\n-            DefWithBody::Static(s) => s.krate(db),\n-        }\n-    }\n-\n     pub fn module(self, db: &impl HirDatabase) -> Module {\n         match self {\n             DefWithBody::Const(c) => c.module(db),"}, {"sha": "388530f31060015d2392fcec65cdfd7674041c01", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=58a3b3b502580e9f49dcfc9b7223e8aec258adf6", "patch": "@@ -17,12 +17,15 @@ use std::ops::Deref;\n use std::sync::Arc;\n use std::{fmt, iter, mem};\n \n-use hir_def::{generics::GenericParams, AdtId, GenericDefId};\n+use hir_def::{\n+    generics::GenericParams, AdtId, ContainerId, DefWithBodyId, GenericDefId, HasModule, Lookup,\n+    TraitId, TypeAliasId,\n+};\n use ra_db::{impl_intern_key, salsa};\n \n use crate::{\n-    db::HirDatabase, expr::ExprId, util::make_mut_slice, Adt, Crate, DefWithBody, FloatTy, IntTy,\n-    Mutability, Name, Trait, TypeAlias, Uncertain,\n+    db::HirDatabase, expr::ExprId, util::make_mut_slice, Adt, Crate, FloatTy, IntTy, Mutability,\n+    Name, Trait, Uncertain,\n };\n use display::{HirDisplay, HirFormatter};\n \n@@ -107,13 +110,13 @@ pub enum TypeCtor {\n     /// when we have tried to normalize a projection like `T::Item` but\n     /// couldn't find a better representation.  In that case, we generate\n     /// an **application type** like `(Iterator::Item)<T>`.\n-    AssociatedType(TypeAlias),\n+    AssociatedType(TypeAliasId),\n \n     /// The type of a specific closure.\n     ///\n     /// The closure signature is stored in a `FnPtr` type in the first type\n     /// parameter.\n-    Closure { def: DefWithBody, expr: ExprId },\n+    Closure { def: DefWithBodyId, expr: ExprId },\n }\n \n /// This exists just for Chalk, because Chalk just has a single `StructId` where\n@@ -147,7 +150,7 @@ impl TypeCtor {\n                 generic_params.count_params_including_parent()\n             }\n             TypeCtor::AssociatedType(type_alias) => {\n-                let generic_params = db.generic_params(type_alias.id.into());\n+                let generic_params = db.generic_params(type_alias.into());\n                 generic_params.count_params_including_parent()\n             }\n             TypeCtor::FnPtr { num_args } => num_args as usize + 1,\n@@ -169,10 +172,13 @@ impl TypeCtor {\n             | TypeCtor::Ref(_)\n             | TypeCtor::FnPtr { .. }\n             | TypeCtor::Tuple { .. } => None,\n-            TypeCtor::Closure { def, .. } => def.krate(db),\n+            // Closure's krate is irrelevant for coherence I would think?\n+            TypeCtor::Closure { .. } => None,\n             TypeCtor::Adt(adt) => adt.krate(db),\n             TypeCtor::FnDef(callable) => Some(callable.krate(db).into()),\n-            TypeCtor::AssociatedType(type_alias) => type_alias.krate(db),\n+            TypeCtor::AssociatedType(type_alias) => {\n+                Some(type_alias.lookup(db).module(db).krate.into())\n+            }\n         }\n     }\n \n@@ -193,7 +199,7 @@ impl TypeCtor {\n             | TypeCtor::Closure { .. } => None,\n             TypeCtor::Adt(adt) => Some(adt.into()),\n             TypeCtor::FnDef(callable) => Some(callable.into()),\n-            TypeCtor::AssociatedType(type_alias) => Some(type_alias.id.into()),\n+            TypeCtor::AssociatedType(type_alias) => Some(type_alias.into()),\n         }\n     }\n }\n@@ -212,18 +218,19 @@ pub struct ApplicationTy {\n /// trait and all its parameters are fully known.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct ProjectionTy {\n-    pub associated_ty: TypeAlias,\n+    pub associated_ty: TypeAliasId,\n     pub parameters: Substs,\n }\n \n impl ProjectionTy {\n     pub fn trait_ref(&self, db: &impl HirDatabase) -> TraitRef {\n-        TraitRef {\n-            trait_: self\n-                .associated_ty\n-                .parent_trait(db)\n-                .expect(\"projection ty without parent trait\"),\n-            substs: self.parameters.clone(),\n+        TraitRef { trait_: self.trait_(db).into(), substs: self.parameters.clone() }\n+    }\n+\n+    fn trait_(&self, db: &impl HirDatabase) -> TraitId {\n+        match self.associated_ty.lookup(db).container {\n+            ContainerId::TraitId(it) => it,\n+            _ => panic!(\"projection ty without parent trait\"),\n         }\n     }\n }\n@@ -895,11 +902,12 @@ impl HirDisplay for ApplicationTy {\n                 }\n             }\n             TypeCtor::AssociatedType(type_alias) => {\n-                let trait_name = type_alias\n-                    .parent_trait(f.db)\n-                    .and_then(|t| t.name(f.db))\n-                    .unwrap_or_else(Name::missing);\n-                let name = type_alias.name(f.db);\n+                let trait_ = match type_alias.lookup(f.db).container {\n+                    ContainerId::TraitId(it) => it,\n+                    _ => panic!(\"not an associated type\"),\n+                };\n+                let trait_name = f.db.trait_data(trait_).name.clone().unwrap_or_else(Name::missing);\n+                let name = f.db.type_alias_data(type_alias).name.clone();\n                 write!(f, \"{}::{}\", trait_name, name)?;\n                 if self.parameters.len() > 0 {\n                     write!(f, \"<\")?;\n@@ -926,18 +934,15 @@ impl HirDisplay for ProjectionTy {\n             return write!(f, \"\u2026\");\n         }\n \n-        let trait_name = self\n-            .associated_ty\n-            .parent_trait(f.db)\n-            .and_then(|t| t.name(f.db))\n-            .unwrap_or_else(Name::missing);\n+        let trait_name =\n+            f.db.trait_data(self.trait_(f.db)).name.clone().unwrap_or_else(Name::missing);\n         write!(f, \"<{} as {}\", self.parameters[0].display(f.db), trait_name,)?;\n         if self.parameters.len() > 1 {\n             write!(f, \"<\")?;\n             f.write_joined(&self.parameters[1..], \", \")?;\n             write!(f, \">\")?;\n         }\n-        write!(f, \">::{}\", self.associated_ty.name(f.db))?;\n+        write!(f, \">::{}\", f.db.type_alias_data(self.associated_ty).name)?;\n         Ok(())\n     }\n }\n@@ -1000,7 +1005,10 @@ impl HirDisplay for Ty {\n                                 write!(f, \"<\")?;\n                                 angle_open = true;\n                             }\n-                            let name = projection_pred.projection_ty.associated_ty.name(f.db);\n+                            let name =\n+                                f.db.type_alias_data(projection_pred.projection_ty.associated_ty)\n+                                    .name\n+                                    .clone();\n                             write!(f, \"{} = \", name)?;\n                             projection_pred.ty.hir_fmt(f)?;\n                         }\n@@ -1076,7 +1084,7 @@ impl HirDisplay for GenericPredicate {\n                 write!(\n                     f,\n                     \">::{} = {}\",\n-                    projection_pred.projection_ty.associated_ty.name(f.db),\n+                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name,\n                     projection_pred.ty.display(f.db)\n                 )?;\n             }"}, {"sha": "9e7593b8b08db7e4c700d56213c77d072c6bd599", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=58a3b3b502580e9f49dcfc9b7223e8aec258adf6", "patch": "@@ -69,7 +69,7 @@ fn deref_by_trait(\n \n     let projection = super::traits::ProjectionPredicate {\n         ty: Ty::Bound(0),\n-        projection_ty: super::ProjectionTy { associated_ty: target, parameters },\n+        projection_ty: super::ProjectionTy { associated_ty: target.id, parameters },\n     };\n \n     let obligation = super::Obligation::Projection(projection);"}, {"sha": "316cdc880093a88e0b498208ff3770ddb2191135", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=58a3b3b502580e9f49dcfc9b7223e8aec258adf6", "patch": "@@ -101,7 +101,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         let projection = ProjectionPredicate {\n                             ty: pat_ty.clone(),\n                             projection_ty: ProjectionTy {\n-                                associated_ty: into_iter_item_alias,\n+                                associated_ty: into_iter_item_alias.id,\n                                 parameters: Substs::single(iterable_ty),\n                             },\n                         };\n@@ -137,8 +137,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     TypeCtor::FnPtr { num_args: sig_tys.len() as u16 - 1 },\n                     Substs(sig_tys.into()),\n                 );\n-                let closure_ty =\n-                    Ty::apply_one(TypeCtor::Closure { def: self.owner, expr: tgt_expr }, sig_ty);\n+                let closure_ty = Ty::apply_one(\n+                    TypeCtor::Closure { def: self.owner.into(), expr: tgt_expr },\n+                    sig_ty,\n+                );\n \n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n@@ -281,7 +283,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         let projection = ProjectionPredicate {\n                             ty: ty.clone(),\n                             projection_ty: ProjectionTy {\n-                                associated_ty: future_future_output_alias,\n+                                associated_ty: future_future_output_alias.id,\n                                 parameters: Substs::single(inner_ty),\n                             },\n                         };\n@@ -300,7 +302,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         let projection = ProjectionPredicate {\n                             ty: ty.clone(),\n                             projection_ty: ProjectionTy {\n-                                associated_ty: ops_try_ok_alias,\n+                                associated_ty: ops_try_ok_alias.id,\n                                 parameters: Substs::single(inner_ty),\n                             },\n                         };"}, {"sha": "d7d4bb0d662b05703295a33aca683b3c7bfee3e4", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=58a3b3b502580e9f49dcfc9b7223e8aec258adf6", "patch": "@@ -176,7 +176,7 @@ impl Ty {\n                         Some(associated_ty) => {\n                             // FIXME handle type parameters on the segment\n                             Ty::Projection(ProjectionTy {\n-                                associated_ty,\n+                                associated_ty: associated_ty.id,\n                                 parameters: trait_ref.substs,\n                             })\n                         }\n@@ -268,7 +268,10 @@ impl Ty {\n                     .fill_with_unknown()\n                     .build();\n                 // FIXME handle type parameters on the segment\n-                return Ty::Projection(ProjectionTy { associated_ty, parameters: substs });\n+                return Ty::Projection(ProjectionTy {\n+                    associated_ty: associated_ty.id,\n+                    parameters: substs,\n+                });\n             }\n         }\n         Ty::Unknown\n@@ -508,7 +511,7 @@ fn assoc_type_bindings_from_type_bound<'a>(\n             let associated_ty =\n                 match trait_ref.trait_.associated_type_by_name_including_super_traits(db, &name) {\n                     None => return GenericPredicate::Error,\n-                    Some(t) => t,\n+                    Some(t) => t.id,\n                 };\n             let projection_ty =\n                 ProjectionTy { associated_ty, parameters: trait_ref.substs.clone() };"}, {"sha": "b9a5d651f4e4213c1a9a49f25ebddafbdd29cbda", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=58a3b3b502580e9f49dcfc9b7223e8aec258adf6", "patch": "@@ -2,13 +2,14 @@\n use std::sync::{Arc, Mutex};\n \n use chalk_ir::{cast::Cast, family::ChalkIr};\n+use hir_def::DefWithBodyId;\n use log::debug;\n use ra_db::{impl_intern_key, salsa};\n use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n-use crate::{db::HirDatabase, expr::ExprId, Crate, DefWithBody, ImplBlock, Trait, TypeAlias};\n+use crate::{db::HirDatabase, expr::ExprId, Crate, ImplBlock, Trait, TypeAlias};\n \n use self::chalk::{from_chalk, ToChalk};\n \n@@ -290,7 +291,7 @@ impl FnTrait {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ClosureFnTraitImplData {\n-    def: DefWithBody,\n+    def: DefWithBodyId,\n     expr: ExprId,\n     fn_trait: FnTrait,\n }"}, {"sha": "06388a3ce287fe8da5981aca1ae9aa28c312b882", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a3b3b502580e9f49dcfc9b7223e8aec258adf6/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=58a3b3b502580e9f49dcfc9b7223e8aec258adf6", "patch": "@@ -9,7 +9,7 @@ use chalk_ir::{\n };\n use chalk_rust_ir::{AssociatedTyDatum, AssociatedTyValue, ImplDatum, StructDatum, TraitDatum};\n \n-use hir_def::{lang_item::LangItemTarget, GenericDefId};\n+use hir_def::{lang_item::LangItemTarget, ContainerId, GenericDefId, Lookup, TypeAliasId};\n use hir_expand::name;\n \n use ra_db::salsa::{InternId, InternKey};\n@@ -203,15 +203,15 @@ impl ToChalk for Impl {\n     }\n }\n \n-impl ToChalk for TypeAlias {\n+impl ToChalk for TypeAliasId {\n     type Chalk = chalk_ir::TypeId;\n \n     fn to_chalk(self, _db: &impl HirDatabase) -> chalk_ir::TypeId {\n-        chalk_ir::TypeId(id_to_chalk(self.id))\n+        chalk_ir::TypeId(id_to_chalk(self))\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, type_alias_id: chalk_ir::TypeId) -> TypeAlias {\n-        TypeAlias { id: id_from_chalk(type_alias_id.0) }\n+    fn from_chalk(_db: &impl HirDatabase, type_alias_id: chalk_ir::TypeId) -> TypeAliasId {\n+        id_from_chalk(type_alias_id.0)\n     }\n }\n \n@@ -504,21 +504,21 @@ pub(crate) fn associated_ty_data_query(\n     id: TypeId,\n ) -> Arc<AssociatedTyDatum<ChalkIr>> {\n     debug!(\"associated_ty_data {:?}\", id);\n-    let type_alias: TypeAlias = from_chalk(db, id);\n-    let trait_ = match type_alias.container(db) {\n-        Some(crate::Container::Trait(t)) => t,\n+    let type_alias: TypeAliasId = from_chalk(db, id);\n+    let trait_ = match type_alias.lookup(db).container {\n+        ContainerId::TraitId(t) => t,\n         _ => panic!(\"associated type not in trait\"),\n     };\n-    let generic_params = db.generic_params(type_alias.id.into());\n+    let generic_params = db.generic_params(type_alias.into());\n     let bound_data = chalk_rust_ir::AssociatedTyDatumBound {\n         // FIXME add bounds and where clauses\n         bounds: vec![],\n         where_clauses: vec![],\n     };\n     let datum = AssociatedTyDatum {\n-        trait_id: trait_.to_chalk(db),\n+        trait_id: Trait::from(trait_).to_chalk(db),\n         id,\n-        name: lalrpop_intern::intern(&type_alias.name(db).to_string()),\n+        name: lalrpop_intern::intern(&db.type_alias_data(type_alias).name.to_string()),\n         binders: make_binders(bound_data, generic_params.count_params_including_parent()),\n     };\n     Arc::new(datum)\n@@ -566,7 +566,7 @@ pub(crate) fn trait_datum_query(\n         .items(db)\n         .into_iter()\n         .filter_map(|trait_item| match trait_item {\n-            crate::AssocItem::TypeAlias(type_alias) => Some(type_alias),\n+            crate::AssocItem::TypeAlias(type_alias) => Some(type_alias.id),\n             _ => None,\n         })\n         .map(|type_alias| type_alias.to_chalk(db))\n@@ -785,7 +785,8 @@ fn type_alias_associated_ty_value(\n         .trait_;\n     let assoc_ty = trait_\n         .associated_type_by_name(db, &type_alias.name(db))\n-        .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n+        .expect(\"assoc ty value should not exist\") // validated when building the impl data as well\n+        .id;\n     let generic_params = db.generic_params(impl_block.id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let ty = db.type_for_def(type_alias.into(), crate::ty::Namespace::Types).subst(&bound_vars);\n@@ -820,7 +821,8 @@ fn closure_fn_trait_output_assoc_ty_value(\n \n     let output_ty_id = fn_once_trait\n         .associated_type_by_name(db, &name::OUTPUT_TYPE)\n-        .expect(\"assoc ty value should not exist\");\n+        .expect(\"assoc ty value should not exist\")\n+        .id;\n \n     let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: output_ty.to_chalk(db) };\n "}]}