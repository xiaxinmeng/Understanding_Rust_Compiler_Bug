{"sha": "7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkYTExODU4MWM5ZGM4MzljOGJmM2ZiYjYyMmJhYjljZTMyYmJmMzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-28T11:50:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-28T11:50:14Z"}, "message": "Auto merge of #61258 - Centril:rollup-l2mof9t, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #61084 (Clarify docs for unreachable! macro)\n - #61220 (Added error message for E0284)\n - #61227 (Use .await syntax instead of await!)\n - #61230 (avoid creating Boxes of uninitalized values in RawVec)\n - #61237 (Updated the Iterator docs with information about overriding methods.)\n - #61241 (Check place iterative)\n - #61242 (Make dest_needs_borrow iterate instead of recurse)\n - #61247 (Make eval_place iterate instead of recurse)\n - #61248 (Use Place::local)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "6afa790e230d5ecc9d3ee1849652e00c74688137", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6afa790e230d5ecc9d3ee1849652e00c74688137"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "html_url": "https://github.com/rust-lang/rust/commit/7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "837b72c805f98d95a44ad4fc2b43ba6a8acb108a", "url": "https://api.github.com/repos/rust-lang/rust/commits/837b72c805f98d95a44ad4fc2b43ba6a8acb108a", "html_url": "https://github.com/rust-lang/rust/commit/837b72c805f98d95a44ad4fc2b43ba6a8acb108a"}, {"sha": "149c53fc442a690ea6a5c309f408cb2160039b9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/149c53fc442a690ea6a5c309f408cb2160039b9b", "html_url": "https://github.com/rust-lang/rust/commit/149c53fc442a690ea6a5c309f408cb2160039b9b"}], "stats": {"total": 278, "additions": 168, "deletions": 110}, "files": [{"sha": "76b660fba685ce6b9716e6194f248e628a509497", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -395,11 +395,10 @@ impl<T: Clone> Clone for Box<T> {\n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n impl Clone for Box<str> {\n     fn clone(&self) -> Self {\n-        let len = self.len();\n-        let buf = RawVec::with_capacity(len);\n+        // this makes a copy of the data\n+        let buf: Box<[u8]> = self.as_bytes().into();\n         unsafe {\n-            ptr::copy_nonoverlapping(self.as_ptr(), buf.ptr(), len);\n-            from_boxed_utf8_unchecked(buf.into_box())\n+            from_boxed_utf8_unchecked(buf)\n         }\n     }\n }\n@@ -546,9 +545,12 @@ impl<T: Copy> From<&[T]> for Box<[T]> {\n     /// println!(\"{:?}\", boxed_slice);\n     /// ```\n     fn from(slice: &[T]) -> Box<[T]> {\n-        let mut boxed = unsafe { RawVec::with_capacity(slice.len()).into_box() };\n-        boxed.copy_from_slice(slice);\n-        boxed\n+        let len = slice.len();\n+        let buf = RawVec::with_capacity(len);\n+        unsafe {\n+            ptr::copy_nonoverlapping(slice.as_ptr(), buf.ptr(), len);\n+            buf.into_box()\n+        }\n     }\n }\n "}, {"sha": "0454a564435790e56e3eed2a621bf5499a9d0724", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -685,12 +685,14 @@ impl<T, A: Alloc> RawVec<T, A> {\n impl<T> RawVec<T, Global> {\n     /// Converts the entire buffer into `Box<[T]>`.\n     ///\n-    /// While it is not *strictly* Undefined Behavior to call\n-    /// this procedure while some of the RawVec is uninitialized,\n-    /// it certainly makes it trivial to trigger it.\n-    ///\n     /// Note that this will correctly reconstitute any `cap` changes\n     /// that may have been performed. (see description of type for details)\n+    ///\n+    /// # Undefined Behavior\n+    ///\n+    /// All elements of `RawVec<T, Global>` must be initialized. Notice that\n+    /// the rules around uninitialized boxed values are not finalized yet,\n+    /// but until they are, it is advisable to avoid them.\n     pub unsafe fn into_box(self) -> Box<[T]> {\n         // NOTE: not calling `cap()` here, actually using the real `cap` field!\n         let slice = slice::from_raw_parts_mut(self.ptr(), self.cap);"}, {"sha": "0492fd709b8dca8476297166b2ce48da99454fa9", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -21,7 +21,7 @@ use crate::task::{Context, Poll};\n /// task.\n ///\n /// When using a future, you generally won't call `poll` directly, but instead\n-/// `await!` the value.\n+/// `.await` the value.\n #[doc(spotlight)]\n #[must_use = \"futures do nothing unless you `.await` or poll them\"]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]"}, {"sha": "6eccb9d1ea86d294c9527dff5361fd870f1d89b7", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -140,6 +140,11 @@\n //! call `next()` on your iterator, until it reaches `None`. Let's go over that\n //! next.\n //!\n+//! Also note that `Iterator` provides a default implementation of methods such as `nth` and `fold`\n+//! which call `next` internally. However, it is also possible to write a custom implementation of\n+//! methods like `nth` and `fold` if an iterator can compute them more efficiently without calling\n+//! `next`.\n+//!\n //! # for Loops and IntoIterator\n //!\n //! Rust's `for` loop syntax is actually sugar for iterators. Here's a basic"}, {"sha": "d0fdd79473e6726eaf0cc48ffff0beb79e761822", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -964,6 +964,7 @@ pub trait Iterator {\n     /// Creates an iterator that skips the first `n` elements.\n     ///\n     /// After they have been consumed, the rest of the elements are yielded.\n+    /// Rather than overriding this method directly, instead override the `nth` method.\n     ///\n     /// # Examples\n     ///"}, {"sha": "9dfa09cf8a512cd0ad84c49ab008fbc1c6492baf", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -445,9 +445,10 @@ macro_rules! writeln {\n /// * Iterators that dynamically terminate.\n ///\n /// If the determination that the code is unreachable proves incorrect, the\n-/// program immediately terminates with a [`panic!`]. The function [`unreachable_unchecked`],\n-/// which belongs to the [`std::hint`] module, informs the compiler to\n-/// optimize the code out of the release version entirely.\n+/// program immediately terminates with a [`panic!`].\n+///\n+/// The unsafe counterpart of this macro is the [`unreachable_unchecked`] function, which\n+/// will cause undefined behavior if the code is reached.\n ///\n /// [`panic!`]:  ../std/macro.panic.html\n /// [`unreachable_unchecked`]: ../std/hint/fn.unreachable_unchecked.html"}, {"sha": "6243e911bd5fdf92bc5b834a3ad51e7ccb0f7fd7", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -1207,6 +1207,51 @@ fn main() {\n ```\n \"##,\n \n+E0284: r##\"\n+This error occurs when the compiler is unable to unambiguously infer the\n+return type of a function or method which is generic on return type, such\n+as the `collect` method for `Iterator`s.\n+\n+For example:\n+\n+```compile_fail,E0284\n+fn foo() -> Result<bool, ()> {\n+    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n+    let v: Vec<bool> = results.collect()?;\n+    // Do things with v...\n+    Ok(true)\n+}\n+```\n+\n+Here we have an iterator `results` over `Result<bool, ()>`.\n+Hence, `results.collect()` can return any type implementing\n+`FromIterator<Result<bool, ()>>`. On the other hand, the\n+`?` operator can accept any type implementing `Try`.\n+\n+The author of this code probably wants `collect()` to return a\n+`Result<Vec<bool>, ()>`, but the compiler can't be sure\n+that there isn't another type `T` implementing both `Try` and\n+`FromIterator<Result<bool, ()>>` in scope such that\n+`T::Ok == Vec<bool>`. Hence, this code is ambiguous and an error\n+is returned.\n+\n+To resolve this error, use a concrete type for the intermediate expression:\n+\n+```\n+fn foo() -> Result<bool, ()> {\n+    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n+    let v = {\n+        let temp: Result<Vec<bool>, ()> = results.collect();\n+        temp?\n+    };\n+    // Do things with v...\n+    Ok(true)\n+}\n+```\n+\n+Note that the type of `v` can now be inferred from the type of `temp`.\n+\"##,\n+\n E0308: r##\"\n This error occurs when the compiler was unable to infer the concrete type of a\n variable. It can occur for several cases, the most common of which is a\n@@ -2158,7 +2203,6 @@ register_diagnostics! {\n     E0278, // requirement is not satisfied\n     E0279, // requirement is not satisfied\n     E0280, // requirement is not satisfied\n-    E0284, // cannot resolve type\n //  E0285, // overflow evaluation builtin bounds\n //  E0296, // replaced with a generic attribute input check\n //  E0300, // unexpanded macro"}, {"sha": "07a9f294fb68cd455919ee2a63fa429b1053ff4d", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -528,13 +528,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }) => {\n                 // Not projected from the implicit `self` in a closure.\n                 debug_assert!(\n-                    match *base {\n-                        Place::Base(PlaceBase::Local(local)) => local == Local::new(1),\n-                        Place::Projection(box Projection {\n-                            ref base,\n-                            elem: ProjectionElem::Deref,\n-                        }) => *base == Place::Base(PlaceBase::Local(Local::new(1))),\n-                        _ => false,\n+                    match base.local() {\n+                        Some(local) => local == Local::new(1),\n+                        None => false,\n                     },\n                     \"Unexpected capture place\"\n                 );"}, {"sha": "11022be097cfd9e68799ee720d02d1007fc575e8", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -296,47 +296,50 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n \n     fn eval_place(&mut self, place: &Place<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        match *place {\n-            Place::Base(PlaceBase::Local(loc)) => self.places[loc].clone(),\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Field(field, _) => {\n-                    trace!(\"field proj on {:?}\", proj.base);\n-                    let base = self.eval_place(&proj.base, source_info)?;\n+        place.iterate(|place_base, place_projection| {\n+            let mut eval = match place_base {\n+                PlaceBase::Local(loc) => self.places[*loc].clone()?,\n+                PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted), ..}) => {\n+                    let generics = self.tcx.generics_of(self.source.def_id());\n+                    if generics.requires_monomorphization(self.tcx) {\n+                        // FIXME: can't handle code with generics\n+                        return None;\n+                    }\n+                    let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n+                    let instance = Instance::new(self.source.def_id(), substs);\n+                    let cid = GlobalId {\n+                        instance,\n+                        promoted: Some(*promoted),\n+                    };\n+                    // cannot use `const_eval` here, because that would require having the MIR\n+                    // for the current function available, but we're producing said MIR right now\n                     let res = self.use_ecx(source_info, |this| {\n-                        this.ecx.operand_field(base, field.index() as u64)\n+                        let mir = &this.promoted[*promoted];\n+                        eval_promoted(this.tcx, cid, mir, this.param_env)\n                     })?;\n-                    Some(res)\n-                },\n-                // We could get more projections by using e.g., `operand_projection`,\n-                // but we do not even have the stack frame set up properly so\n-                // an `Index` projection would throw us off-track.\n-                _ => None,\n-            },\n-            Place::Base(\n-                PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted), ..})\n-            ) => {\n-                let generics = self.tcx.generics_of(self.source.def_id());\n-                if generics.requires_monomorphization(self.tcx) {\n-                    // FIXME: can't handle code with generics\n-                    return None;\n+                    trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n+                    res.into()\n                 }\n-                let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n-                let instance = Instance::new(self.source.def_id(), substs);\n-                let cid = GlobalId {\n-                    instance,\n-                    promoted: Some(promoted),\n-                };\n-                // cannot use `const_eval` here, because that would require having the MIR\n-                // for the current function available, but we're producing said MIR right now\n-                let res = self.use_ecx(source_info, |this| {\n-                    let mir = &this.promoted[promoted];\n-                    eval_promoted(this.tcx, cid, mir, this.param_env)\n-                })?;\n-                trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n-                Some(res.into())\n-            },\n-            _ => None,\n-        }\n+                _ => return None,\n+            };\n+\n+            for proj in place_projection {\n+                match proj.elem {\n+                    ProjectionElem::Field(field, _) => {\n+                        trace!(\"field proj on {:?}\", proj.base);\n+                        eval = self.use_ecx(source_info, |this| {\n+                            this.ecx.operand_field(eval, field.index() as u64)\n+                        })?;\n+                    },\n+                    // We could get more projections by using e.g., `operand_projection`,\n+                    // but we do not even have the stack frame set up properly so\n+                    // an `Index` projection would throw us off-track.\n+                    _ => return None,\n+                }\n+            }\n+\n+            Some(eval)\n+        })\n     }\n \n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {"}, {"sha": "782af3024ad2c448b1fb6f776e199decad28cdf1", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -440,19 +440,22 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 // writes to `i`. To prevent this we need to create a temporary\n                 // borrow of the place and pass the destination as `*temp` instead.\n                 fn dest_needs_borrow(place: &Place<'_>) -> bool {\n-                    match *place {\n-                        Place::Projection(ref p) => {\n-                            match p.elem {\n+                    place.iterate(|place_base, place_projection| {\n+                        for proj in place_projection {\n+                            match proj.elem {\n                                 ProjectionElem::Deref |\n-                                ProjectionElem::Index(_) => true,\n-                                _ => dest_needs_borrow(&p.base)\n+                                ProjectionElem::Index(_) => return true,\n+                                _ => {}\n                             }\n                         }\n-                        // Static variables need a borrow because the callee\n-                        // might modify the same static.\n-                        Place::Base(PlaceBase::Static(_)) => true,\n-                        _ => false\n-                    }\n+\n+                        match place_base {\n+                            // Static variables need a borrow because the callee\n+                            // might modify the same static.\n+                            PlaceBase::Static(_) => true,\n+                            _ => false\n+                        }\n+                    })\n                 }\n \n                 let dest = if dest_needs_borrow(&destination.0) {"}, {"sha": "a1e2d0683d3800a37f3184e06299d15e80ad0d7c", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -136,10 +136,10 @@ fn check_rvalue(\n ) -> McfResult {\n     match rvalue {\n         Rvalue::Repeat(operand, _) | Rvalue::Use(operand) => {\n-            check_operand(tcx, mir, operand, span)\n+            check_operand(operand, span)\n         }\n         Rvalue::Len(place) | Rvalue::Discriminant(place) | Rvalue::Ref(_, _, place) => {\n-            check_place(tcx, mir, place, span)\n+            check_place(place, span)\n         }\n         Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n             use rustc::ty::cast::CastTy;\n@@ -153,11 +153,11 @@ fn check_rvalue(\n                 (CastTy::RPtr(_), CastTy::Float) => bug!(),\n                 (CastTy::RPtr(_), CastTy::Int(_)) => bug!(),\n                 (CastTy::Ptr(_), CastTy::RPtr(_)) => bug!(),\n-                _ => check_operand(tcx, mir, operand, span),\n+                _ => check_operand(operand, span),\n             }\n         }\n         Rvalue::Cast(CastKind::Pointer(PointerCast::MutToConstPointer), operand, _) => {\n-            check_operand(tcx, mir, operand, span)\n+            check_operand(operand, span)\n         }\n         Rvalue::Cast(CastKind::Pointer(PointerCast::UnsafeFnPointer), _, _) |\n         Rvalue::Cast(CastKind::Pointer(PointerCast::ClosureFnPointer(_)), _, _) |\n@@ -171,8 +171,8 @@ fn check_rvalue(\n         )),\n         // binops are fine on integers\n         Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n-            check_operand(tcx, mir, lhs, span)?;\n-            check_operand(tcx, mir, rhs, span)?;\n+            check_operand(lhs, span)?;\n+            check_operand(rhs, span)?;\n             let ty = lhs.ty(mir, tcx);\n             if ty.is_integral() || ty.is_bool() || ty.is_char() {\n                 Ok(())\n@@ -191,7 +191,7 @@ fn check_rvalue(\n         Rvalue::UnaryOp(_, operand) => {\n             let ty = operand.ty(mir, tcx);\n             if ty.is_integral() || ty.is_bool() {\n-                check_operand(tcx, mir, operand, span)\n+                check_operand(operand, span)\n             } else {\n                 Err((\n                     span,\n@@ -201,7 +201,7 @@ fn check_rvalue(\n         }\n         Rvalue::Aggregate(_, operands) => {\n             for operand in operands {\n-                check_operand(tcx, mir, operand, span)?;\n+                check_operand(operand, span)?;\n             }\n             Ok(())\n         }\n@@ -216,11 +216,11 @@ fn check_statement(\n     let span = statement.source_info.span;\n     match &statement.kind {\n         StatementKind::Assign(place, rval) => {\n-            check_place(tcx, mir, place, span)?;\n+            check_place(place, span)?;\n             check_rvalue(tcx, mir, rval, span)\n         }\n \n-        StatementKind::FakeRead(_, place) => check_place(tcx, mir, place, span),\n+        StatementKind::FakeRead(_, place) => check_place(place, span),\n \n         // just an assignment\n         StatementKind::SetDiscriminant { .. } => Ok(()),\n@@ -239,43 +239,40 @@ fn check_statement(\n }\n \n fn check_operand(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n     operand: &Operand<'tcx>,\n     span: Span,\n ) -> McfResult {\n     match operand {\n         Operand::Move(place) | Operand::Copy(place) => {\n-            check_place(tcx, mir, place, span)\n+            check_place(place, span)\n         }\n         Operand::Constant(_) => Ok(()),\n     }\n }\n \n-fn check_place(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n-    place: &Place<'tcx>,\n-    span: Span,\n-) -> McfResult {\n-    match place {\n-        Place::Base(PlaceBase::Local(_)) => Ok(()),\n-        // promoteds are always fine, they are essentially constants\n-        Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })) => Ok(()),\n-        Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(_), .. })) =>\n-            Err((span, \"cannot access `static` items in const fn\".into())),\n-        Place::Projection(proj) => {\n+fn check_place(place: &Place<'tcx>, span: Span) -> McfResult {\n+    place.iterate(|place_base, place_projection| {\n+        for proj in place_projection {\n             match proj.elem {\n-                | ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. }\n-                | ProjectionElem::Deref | ProjectionElem::Field(..) | ProjectionElem::Index(_) => {\n-                    check_place(tcx, mir, &proj.base, span)\n-                }\n-                | ProjectionElem::Downcast(..) => {\n-                    Err((span, \"`match` or `if let` in `const fn` is unstable\".into()))\n+                ProjectionElem::Downcast(..) => {\n+                    return Err((span, \"`match` or `if let` in `const fn` is unstable\".into()));\n                 }\n+                ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Subslice { .. }\n+                | ProjectionElem::Deref\n+                | ProjectionElem::Field(..)\n+                | ProjectionElem::Index(_) => {}\n             }\n         }\n-    }\n+\n+        match place_base {\n+            PlaceBase::Static(box Static { kind: StaticKind::Static(_), .. }) => {\n+                Err((span, \"cannot access `static` items in const fn\".into()))\n+            }\n+            PlaceBase::Local(_)\n+            | PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. }) => Ok(()),\n+        }\n+    })\n }\n \n fn check_terminator(\n@@ -290,11 +287,11 @@ fn check_terminator(\n         | TerminatorKind::Resume => Ok(()),\n \n         TerminatorKind::Drop { location, .. } => {\n-            check_place(tcx, mir, location, span)\n+            check_place(location, span)\n         }\n         TerminatorKind::DropAndReplace { location, value, .. } => {\n-            check_place(tcx, mir, location, span)?;\n-            check_operand(tcx, mir, value, span)\n+            check_place(location, span)?;\n+            check_operand(value, span)\n         },\n \n         TerminatorKind::FalseEdges { .. } | TerminatorKind::SwitchInt { .. } => Err((\n@@ -346,10 +343,10 @@ fn check_terminator(\n                     )),\n                 }\n \n-                check_operand(tcx, mir, func, span)?;\n+                check_operand(func, span)?;\n \n                 for arg in args {\n-                    check_operand(tcx, mir, arg, span)?;\n+                    check_operand(arg, span)?;\n                 }\n                 Ok(())\n             } else {\n@@ -363,7 +360,7 @@ fn check_terminator(\n             msg: _,\n             target: _,\n             cleanup: _,\n-        } => check_operand(tcx, mir, cond, span),\n+        } => check_operand(cond, span),\n \n         TerminatorKind::FalseUnwind { .. } => {\n             Err((span, \"loops are not allowed in const fn\".into()))"}, {"sha": "a26ee23894f6dcd04db477b1901adadf00331715", "filename": "src/test/ui/associated-types/associated-types-overridden-binding.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -12,3 +12,4 @@ LL | trait Foo: Iterator<Item = i32> {}\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0284`."}, {"sha": "da14a69ae306a67baece987e98b21226ce43256f", "filename": "src/test/ui/associated-types/associated-types-unconstrained.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -6,3 +6,4 @@ LL |     let x: isize = Foo::bar();\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0284`."}, {"sha": "64694c7a8d0b66dbb9c917c8e667500af41a1d70", "filename": "src/test/ui/issues/issue-12028.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -6,3 +6,4 @@ LL |         self.input_stream(&mut stream);\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0284`."}, {"sha": "f62a540572c934661246e79c7050cc3885c76afe", "filename": "src/test/ui/question-mark-type-infer.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7da118581c9dc839c8bf3fbb622bab9ce32bbf38/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr?ref=7da118581c9dc839c8bf3fbb622bab9ce32bbf38", "patch": "@@ -6,3 +6,4 @@ LL |     l.iter().map(f).collect()?\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0284`."}]}