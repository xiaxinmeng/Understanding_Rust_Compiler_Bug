{"sha": "64690fe92ee366de227023028076608f9a299e5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0NjkwZmU5MmVlMzY2ZGUyMjcwMjMwMjgwNzY2MDhmOWEyOTllNWU=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-09-15T02:32:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-09-15T02:32:35Z"}, "message": "Rollup merge of #44378 - frehberg:rustdoc, r=dtolnay\n\nrustdoc: extend UdpSocket API doc (#657)\n\nsee  https://github.com/carllerche/mio/issues/657", "tree": {"sha": "463bd467cb3ea8369bd045504a0141054f445530", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/463bd467cb3ea8369bd045504a0141054f445530"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64690fe92ee366de227023028076608f9a299e5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64690fe92ee366de227023028076608f9a299e5e", "html_url": "https://github.com/rust-lang/rust/commit/64690fe92ee366de227023028076608f9a299e5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64690fe92ee366de227023028076608f9a299e5e/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ef792a03591235a5d5c9e222161e7246aa3f845", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ef792a03591235a5d5c9e222161e7246aa3f845", "html_url": "https://github.com/rust-lang/rust/commit/3ef792a03591235a5d5c9e222161e7246aa3f845"}, {"sha": "85a9d978844fd37a9458db0921de5443aa680c1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/85a9d978844fd37a9458db0921de5443aa680c1c", "html_url": "https://github.com/rust-lang/rust/commit/85a9d978844fd37a9458db0921de5443aa680c1c"}], "stats": {"total": 54, "additions": 41, "deletions": 13}, "files": [{"sha": "cefe7af8ff3219700d65bcfee3b4314c1ec3fdde", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 41, "deletions": 13, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/64690fe92ee366de227023028076608f9a299e5e/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64690fe92ee366de227023028076608f9a299e5e/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=64690fe92ee366de227023028076608f9a299e5e", "patch": "@@ -48,11 +48,12 @@ use time::Duration;\n /// {\n ///     let mut socket = UdpSocket::bind(\"127.0.0.1:34254\")?;\n ///\n-///     // read from the socket\n+///     // Receives a single datagram message on the socket. If `buf` is too small to hold\n+///     // the message, it will be cut off.\n ///     let mut buf = [0; 10];\n ///     let (amt, src) = socket.recv_from(&mut buf)?;\n ///\n-///     // send a reply to the socket we received data from\n+///     // Redeclare `buf` as slice of the received data and send reverse data back to origin.\n ///     let buf = &mut buf[..amt];\n ///     buf.reverse();\n ///     socket.send_to(buf, &src)?;\n@@ -103,8 +104,12 @@ impl UdpSocket {\n         super::each_addr(addr, net_imp::UdpSocket::bind).map(UdpSocket)\n     }\n \n-    /// Receives data from the socket. On success, returns the number of bytes\n-    /// read and the address from whence the data came.\n+    /// Receives a single datagram message on the socket. On success, returns the number\n+    /// of bytes read and the origin.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n     ///\n     /// # Examples\n     ///\n@@ -115,19 +120,25 @@ impl UdpSocket {\n     /// let mut buf = [0; 10];\n     /// let (number_of_bytes, src_addr) = socket.recv_from(&mut buf)\n     ///                                         .expect(\"Didn't receive data\");\n+    /// let filled_buf = &mut buf[..number_of_bytes];\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n         self.0.recv_from(buf)\n     }\n \n-    /// Receives data from the socket, without removing it from the queue.\n+    /// Receives a single datagram message on the socket, without removing it from the\n+    /// queue. On success, returns the number of bytes read and the origin.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n     ///\n     /// Successive calls return the same data. This is accomplished by passing\n     /// `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n     ///\n-    /// On success, returns the number of bytes peeked and the address from\n-    /// whence the data came.\n+    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n+    /// synchronize IO events on one or more sockets.\n     ///\n     /// # Examples\n     ///\n@@ -138,6 +149,7 @@ impl UdpSocket {\n     /// let mut buf = [0; 10];\n     /// let (number_of_bytes, src_addr) = socket.peek_from(&mut buf)\n     ///                                         .expect(\"Didn't receive data\");\n+    /// let filled_buf = &mut buf[..number_of_bytes];\n     /// ```\n     #[stable(feature = \"peek\", since = \"1.18.0\")]\n     pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n@@ -642,8 +654,12 @@ impl UdpSocket {\n         self.0.send(buf)\n     }\n \n-    /// Receives data on the socket from the remote address to which it is\n-    /// connected.\n+    /// Receives a single datagram message on the socket from the remote address to\n+    /// which it is connected. On success, returns the number of bytes read.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n     ///\n     /// The [`connect`] method will connect this socket to a remote address. This\n     /// method will fail if the socket is not connected.\n@@ -659,7 +675,7 @@ impl UdpSocket {\n     /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n     /// let mut buf = [0; 10];\n     /// match socket.recv(&mut buf) {\n-    ///     Ok(received) => println!(\"received {} bytes\", received),\n+    ///     Ok(received) => println!(\"received {} bytes {:?}\", received, &buf[..received]),\n     ///     Err(e) => println!(\"recv function failed: {:?}\", e),\n     /// }\n     /// ```\n@@ -668,13 +684,25 @@ impl UdpSocket {\n         self.0.recv(buf)\n     }\n \n-    /// Receives data on the socket from the remote address to which it is\n-    /// connected, without removing that data from the queue. On success,\n-    /// returns the number of bytes peeked.\n+    /// Receives single datagram on the socket from the remote address to which it is\n+    /// connected, without removing the message from input queue. On success, returns\n+    /// the number of bytes peeked.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n     ///\n     /// Successive calls return the same data. This is accomplished by passing\n     /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n     ///\n+    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n+    /// synchronize IO events on one or more sockets.\n+    ///\n+    /// The [`connect`] method will connect this socket to a remote address. This\n+    /// method will fail if the socket is not connected.\n+    ///\n+    /// [`connect`]: #method.connect\n+    ///\n     /// # Errors\n     ///\n     /// This method will fail if the socket is not connected. The `connect` method"}]}