{"sha": "3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMjhiOGI5OGU2ZTRmNTVlZjRlY2Q4YmFiZjBhMDUwZjQ4YTNkMTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-11-03T00:23:22Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-11-10T06:55:50Z"}, "message": "std: Migrate to the new libc\n\n* Delete `sys::unix::{c, sync}` as these are now all folded into libc itself\n* Update all references to use `libc` as a result.\n* Update all references to the new flat namespace.\n* Moves all windows bindings into sys::c", "tree": {"sha": "343087c9e62da65e2780db851682280697064c5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/343087c9e62da65e2780db851682280697064c5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "html_url": "https://github.com/rust-lang/rust/commit/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8a29c2092cec369a751051a2bfed093522ff6e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a29c2092cec369a751051a2bfed093522ff6e8", "html_url": "https://github.com/rust-lang/rust/commit/c8a29c2092cec369a751051a2bfed093522ff6e8"}], "stats": {"total": 4332, "additions": 1895, "deletions": 2437}, "files": [{"sha": "89a836eb7cb31355d5d98c91f01e0c7b5e5436aa", "filename": "mk/crates.mk", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -174,3 +174,6 @@ $(foreach crate,$(TOOLS),$(eval $(call RUST_TOOL,$(crate))))\n ifdef CFG_DISABLE_ELF_TLS\n RUSTFLAGS_std := --cfg no_elf_tls\n endif\n+\n+CRATEFILE_libc := $(SREL)src/liblibc/src/lib.rs\n+RUSTFLAGS_libc := --cfg stdbuild"}, {"sha": "052d0c18ed4e26e4545bdc1a5d2f22c3c9d06bd8", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -22,7 +22,7 @@ $(eval $(call RUST_CRATE,coretest))\n DEPS_collectionstest :=\n $(eval $(call RUST_CRATE,collectionstest))\n \n-TEST_TARGET_CRATES = $(filter-out core rustc_unicode alloc_system \\\n+TEST_TARGET_CRATES = $(filter-out core rustc_unicode alloc_system libc \\\n \t\t     \t\t  alloc_jemalloc,$(TARGET_CRATES)) \\\n \t\t\tcollectionstest coretest\n TEST_DOC_CRATES = $(DOC_CRATES)\n@@ -283,6 +283,7 @@ tidy-binaries:\n \t\t| grep '^$(S)src/compiler-rt' -v \\\n \t\t| grep '^$(S)src/libbacktrace' -v \\\n \t\t| grep '^$(S)src/rust-installer' -v \\\n+\t\t| grep '^$(S)src/liblibc' -v \\\n \t\t| xargs $(CFG_PYTHON) $(S)src/etc/check-binaries.py\n \n .PHONY: tidy-errors"}, {"sha": "942793adc31de0159a3b40e847761c53a1ef9d51", "filename": "src/etc/tidy.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -108,7 +108,8 @@ def interesting_file(f):\n             'src/rustllvm',\n             'src/rt/valgrind',\n             'src/rt/msvc',\n-            'src/rust-installer'\n+            'src/rust-installer',\n+            'src/liblibc',\n         }\n \n         if any(d in dirpath for d in skippable_dirs):"}, {"sha": "f2ff0593bfa54f1a780e2f8a94b1bf4c88c55b85", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -14,6 +14,7 @@\n #![staged_api]\n #![no_std]\n #![cfg_attr(not(stage0), allocator)]\n+#![cfg_attr(stage0, allow(improper_ctypes))]\n #![unstable(feature = \"alloc_jemalloc\",\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\","}, {"sha": "93b64c9caebc99ef043043027464594798d5d5dc", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -14,6 +14,7 @@\n #![staged_api]\n #![no_std]\n #![cfg_attr(not(stage0), allocator)]\n+#![cfg_attr(stage0, allow(improper_ctypes))]\n #![unstable(feature = \"alloc_system\",\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\",\n@@ -141,10 +142,16 @@ mod imp {\n }\n \n #[cfg(windows)]\n+#[allow(bad_style)]\n mod imp {\n-    use libc::{BOOL, DWORD, HANDLE, LPVOID, SIZE_T};\n     use MIN_ALIGN;\n \n+    type LPVOID = *mut u8;\n+    type HANDLE = LPVOID;\n+    type SIZE_T = usize;\n+    type DWORD = u32;\n+    type BOOL = i32;\n+\n     extern \"system\" {\n         fn GetProcessHeap() -> HANDLE;\n         fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;"}, {"sha": "51f387523294f43832cd263e485e6ae017d26ec3", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -29,6 +29,7 @@\n #![feature(staged_api)]\n #![feature(unique)]\n #![cfg_attr(test, feature(rustc_private, rand, vec_push_all))]\n+#![cfg_attr(stage0, allow(improper_ctypes))]\n \n #[cfg(test)]\n #[macro_use]"}, {"sha": "74b92318f2774fe6d22ba484696ad5c553a69fa1", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -96,25 +96,30 @@ fn get_resident() -> Option<usize> {\n }\n \n #[cfg(windows)]\n+#[cfg_attr(stage0, allow(improper_ctypes))]\n fn get_resident() -> Option<usize> {\n-    use libc::{BOOL, DWORD, HANDLE, SIZE_T, GetCurrentProcess};\n+    type BOOL = i32;\n+    type DWORD = u32;\n+    type HANDLE = *mut u8;\n+    use libc::size_t;\n     use std::mem;\n     #[repr(C)] #[allow(non_snake_case)]\n     struct PROCESS_MEMORY_COUNTERS {\n         cb: DWORD,\n         PageFaultCount: DWORD,\n-        PeakWorkingSetSize: SIZE_T,\n-        WorkingSetSize: SIZE_T,\n-        QuotaPeakPagedPoolUsage: SIZE_T,\n-        QuotaPagedPoolUsage: SIZE_T,\n-        QuotaPeakNonPagedPoolUsage: SIZE_T,\n-        QuotaNonPagedPoolUsage: SIZE_T,\n-        PagefileUsage: SIZE_T,\n-        PeakPagefileUsage: SIZE_T,\n+        PeakWorkingSetSize: size_t,\n+        WorkingSetSize: size_t,\n+        QuotaPeakPagedPoolUsage: size_t,\n+        QuotaPagedPoolUsage: size_t,\n+        QuotaPeakNonPagedPoolUsage: size_t,\n+        QuotaNonPagedPoolUsage: size_t,\n+        PagefileUsage: size_t,\n+        PeakPagefileUsage: size_t,\n     }\n     type PPROCESS_MEMORY_COUNTERS = *mut PROCESS_MEMORY_COUNTERS;\n     #[link(name = \"psapi\")]\n     extern \"system\" {\n+        fn GetCurrentProcess() -> HANDLE;\n         fn GetProcessMemoryInfo(Process: HANDLE,\n                                 ppsmemCounters: PPROCESS_MEMORY_COUNTERS,\n                                 cb: DWORD) -> BOOL;"}, {"sha": "9cb5012cf0f818b83acd02d1b32e2a6e462c7935", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -16,6 +16,8 @@\n #![allow(dead_code)]\n #![allow(trivial_casts)]\n \n+#![cfg_attr(stage0, allow(improper_ctypes))]\n+\n #![crate_name = \"rustc_llvm\"]\n #![unstable(feature = \"rustc_private\", issue = \"27812\")]\n #![staged_api]"}, {"sha": "63fb19c9772a82a0f1d74b2d5ad7bef38d83944f", "filename": "src/librustc_trans/back/msvc/registry.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -13,8 +13,14 @@ use std::ffi::{OsString, OsStr};\n use std::os::windows::prelude::*;\n use std::ops::RangeFrom;\n use std::ptr;\n-use libc::{DWORD, LPCWSTR, LONG, LPDWORD, LPBYTE, ERROR_SUCCESS};\n-use libc::c_void;\n+use libc::{c_void, c_long};\n+\n+type DWORD = u32;\n+type LPCWSTR = *const u16;\n+type LONG = c_long;\n+type LPDWORD = *mut DWORD;\n+type LPBYTE = *mut u8;\n+\n \n const HKEY_LOCAL_MACHINE: HKEY = 0x80000002 as HKEY;\n const KEY_WOW64_32KEY: REGSAM = 0x0200;\n@@ -27,6 +33,7 @@ const KEY_ENUMERATE_SUB_KEYS: REGSAM = 0x0008;\n const KEY_NOTIFY: REGSAM = 0x0010;\n const SYNCHRONIZE: REGSAM = 0x00100000;\n const REG_SZ: DWORD = 1;\n+const ERROR_SUCCESS: i32 = 0;\n const ERROR_NO_MORE_ITEMS: DWORD = 259;\n \n enum __HKEY__ {}"}, {"sha": "72a5043178baf3c2854666c16f11718b8111c12d", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 29, "deletions": 51, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -121,7 +121,7 @@ mod imp {\n             let buf = CString::new(os.as_bytes()).unwrap();\n             let fd = unsafe {\n                 libc::open(buf.as_ptr(), libc::O_RDWR | libc::O_CREAT,\n-                           libc::S_IRWXU)\n+                           libc::S_IRWXU as libc::c_int)\n             };\n             assert!(fd > 0, \"failed to open lockfile: {}\",\n                     io::Error::last_os_error());\n@@ -164,77 +164,55 @@ mod imp {\n }\n \n #[cfg(windows)]\n+#[allow(bad_style)]\n mod imp {\n-    use libc;\n     use std::io;\n     use std::mem;\n-    use std::ffi::OsStr;\n     use std::os::windows::prelude::*;\n+    use std::os::windows::raw::HANDLE;\n     use std::path::Path;\n-    use std::ptr;\n-\n-    const LOCKFILE_EXCLUSIVE_LOCK: libc::DWORD = 0x00000002;\n+    use std::fs::{File, OpenOptions};\n+\n+    type DWORD = u32;\n+    type LPOVERLAPPED = *mut OVERLAPPED;\n+    type BOOL = i32;\n+    const LOCKFILE_EXCLUSIVE_LOCK: DWORD = 0x00000002;\n+\n+    #[repr(C)]\n+    struct OVERLAPPED {\n+        Internal: usize,\n+        InternalHigh: usize,\n+        Pointer: *mut u8,\n+        hEvent: *mut u8,\n+    }\n \n-    #[allow(non_snake_case)]\n     extern \"system\" {\n-        fn LockFileEx(hFile: libc::HANDLE,\n-                      dwFlags: libc::DWORD,\n-                      dwReserved: libc::DWORD,\n-                      nNumberOfBytesToLockLow: libc::DWORD,\n-                      nNumberOfBytesToLockHigh: libc::DWORD,\n-                      lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;\n-        fn UnlockFileEx(hFile: libc::HANDLE,\n-                        dwReserved: libc::DWORD,\n-                        nNumberOfBytesToLockLow: libc::DWORD,\n-                        nNumberOfBytesToLockHigh: libc::DWORD,\n-                        lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;\n+        fn LockFileEx(hFile: HANDLE,\n+                      dwFlags: DWORD,\n+                      dwReserved: DWORD,\n+                      nNumberOfBytesToLockLow: DWORD,\n+                      nNumberOfBytesToLockHigh: DWORD,\n+                      lpOverlapped: LPOVERLAPPED) -> BOOL;\n     }\n \n     pub struct Lock {\n-        handle: libc::HANDLE,\n+        _file: File,\n     }\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let os: &OsStr = p.as_ref();\n-            let mut p_16: Vec<_> = os.encode_wide().collect();\n-            p_16.push(0);\n-            let handle = unsafe {\n-                libc::CreateFileW(p_16.as_ptr(),\n-                                  libc::FILE_GENERIC_READ |\n-                                    libc::FILE_GENERIC_WRITE,\n-                                  libc::FILE_SHARE_READ |\n-                                    libc::FILE_SHARE_DELETE |\n-                                    libc::FILE_SHARE_WRITE,\n-                                  ptr::null_mut(),\n-                                  libc::CREATE_ALWAYS,\n-                                  libc::FILE_ATTRIBUTE_NORMAL,\n-                                  ptr::null_mut())\n-            };\n-            if handle == libc::INVALID_HANDLE_VALUE {\n-                panic!(\"create file error: {}\", io::Error::last_os_error());\n-            }\n-            let mut overlapped: libc::OVERLAPPED = unsafe { mem::zeroed() };\n+            let f = OpenOptions::new().read(true).write(true).create(true)\n+                                      .open(p).unwrap();\n             let ret = unsafe {\n-                LockFileEx(handle, LOCKFILE_EXCLUSIVE_LOCK, 0, 100, 0,\n+                let mut overlapped: OVERLAPPED = mem::zeroed();\n+                LockFileEx(f.as_raw_handle(), LOCKFILE_EXCLUSIVE_LOCK, 0, 100, 0,\n                            &mut overlapped)\n             };\n             if ret == 0 {\n                 let err = io::Error::last_os_error();\n-                unsafe { libc::CloseHandle(handle); }\n                 panic!(\"could not lock `{}`: {}\", p.display(), err);\n             }\n-            Lock { handle: handle }\n-        }\n-    }\n-\n-    impl Drop for Lock {\n-        fn drop(&mut self) {\n-            let mut overlapped: libc::OVERLAPPED = unsafe { mem::zeroed() };\n-            unsafe {\n-                UnlockFileEx(self.handle, 0, 100, 0, &mut overlapped);\n-                libc::CloseHandle(self.handle);\n-            }\n+            Lock { _file: f }\n         }\n     }\n }"}, {"sha": "1cb48407f10696899e3bd42e94c73fc91a664dfa", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 22, "deletions": 42, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -207,11 +207,11 @@ mod dl {\n \n     unsafe fn open_external(filename: &OsStr) -> *mut u8 {\n         let s = filename.to_cstring().unwrap();\n-        dlopen(s.as_ptr(), LAZY) as *mut u8\n+        libc::dlopen(s.as_ptr(), LAZY) as *mut u8\n     }\n \n     unsafe fn open_internal() -> *mut u8 {\n-        dlopen(ptr::null(), LAZY) as *mut u8\n+        libc::dlopen(ptr::null(), LAZY) as *mut u8\n     }\n \n     pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n@@ -223,11 +223,11 @@ mod dl {\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence\n             let _guard = LOCK.lock();\n-            let _old_error = dlerror();\n+            let _old_error = libc::dlerror();\n \n             let result = f();\n \n-            let last_error = dlerror() as *const _;\n+            let last_error = libc::dlerror() as *const _;\n             let ret = if ptr::null() == last_error {\n                 Ok(result)\n             } else {\n@@ -241,19 +241,10 @@ mod dl {\n \n     pub unsafe fn symbol(handle: *mut u8,\n                          symbol: *const libc::c_char) -> *mut u8 {\n-        dlsym(handle as *mut libc::c_void, symbol) as *mut u8\n+        libc::dlsym(handle as *mut libc::c_void, symbol) as *mut u8\n     }\n     pub unsafe fn close(handle: *mut u8) {\n-        dlclose(handle as *mut libc::c_void); ()\n-    }\n-\n-    extern {\n-        fn dlopen(filename: *const libc::c_char,\n-                  flag: libc::c_int) -> *mut libc::c_void;\n-        fn dlerror() -> *mut libc::c_char;\n-        fn dlsym(handle: *mut libc::c_void,\n-                 symbol: *const libc::c_char) -> *mut libc::c_void;\n-        fn dlclose(handle: *mut libc::c_void) -> libc::c_int;\n+        libc::dlclose(handle as *mut libc::c_void); ()\n     }\n }\n \n@@ -263,11 +254,10 @@ mod dl {\n \n     use ffi::OsStr;\n     use libc;\n-    use libc::consts::os::extra::ERROR_CALL_NOT_IMPLEMENTED;\n-    use sys::os;\n     use os::windows::prelude::*;\n     use ptr;\n-    use sys::c::SetThreadErrorMode;\n+    use sys::c;\n+    use sys::os;\n \n     pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         // disable \"dll load failed\" error dialog.\n@@ -277,32 +267,33 @@ mod dl {\n             let new_error_mode = 1;\n             let mut prev_error_mode = 0;\n             // Windows >= 7 supports thread error mode.\n-            let result = SetThreadErrorMode(new_error_mode, &mut prev_error_mode);\n+            let result = c::SetThreadErrorMode(new_error_mode,\n+                                               &mut prev_error_mode);\n             if result == 0 {\n                 let err = os::errno();\n-                if err as libc::c_int == ERROR_CALL_NOT_IMPLEMENTED {\n+                if err == c::ERROR_CALL_NOT_IMPLEMENTED as i32 {\n                     use_thread_mode = false;\n                     // SetThreadErrorMode not found. use fallback solution:\n                     // SetErrorMode() Note that SetErrorMode is process-wide so\n                     // this can cause race condition!  However, since even\n                     // Windows APIs do not care of such problem (#20650), we\n                     // just assume SetErrorMode race is not a great deal.\n-                    prev_error_mode = SetErrorMode(new_error_mode);\n+                    prev_error_mode = c::SetErrorMode(new_error_mode);\n                 }\n             }\n             prev_error_mode\n         };\n \n         unsafe {\n-            SetLastError(0);\n+            c::SetLastError(0);\n         }\n \n         let result = match filename {\n             Some(filename) => {\n                 let filename_str: Vec<_> =\n                     filename.encode_wide().chain(Some(0)).collect();\n                 let result = unsafe {\n-                    LoadLibraryW(filename_str.as_ptr() as *const libc::c_void)\n+                    c::LoadLibraryW(filename_str.as_ptr())\n                 };\n                 // beware: Vec/String may change errno during drop!\n                 // so we get error here.\n@@ -316,9 +307,10 @@ mod dl {\n             None => {\n                 let mut handle = ptr::null_mut();\n                 let succeeded = unsafe {\n-                    GetModuleHandleExW(0 as libc::DWORD, ptr::null(), &mut handle)\n+                    c::GetModuleHandleExW(0 as c::DWORD, ptr::null(),\n+                                          &mut handle)\n                 };\n-                if succeeded == libc::FALSE {\n+                if succeeded == c::FALSE {\n                     let errno = os::errno();\n                     Err(os::error_string(errno))\n                 } else {\n@@ -329,9 +321,9 @@ mod dl {\n \n         unsafe {\n             if use_thread_mode {\n-                SetThreadErrorMode(prev_error_mode, ptr::null_mut());\n+                c::SetThreadErrorMode(prev_error_mode, ptr::null_mut());\n             } else {\n-                SetErrorMode(prev_error_mode);\n+                c::SetErrorMode(prev_error_mode);\n             }\n         }\n \n@@ -342,7 +334,7 @@ mod dl {\n         F: FnOnce() -> T,\n     {\n         unsafe {\n-            SetLastError(0);\n+            c::SetLastError(0);\n \n             let result = f();\n \n@@ -356,22 +348,10 @@ mod dl {\n     }\n \n     pub unsafe fn symbol(handle: *mut u8, symbol: *const libc::c_char) -> *mut u8 {\n-        GetProcAddress(handle as *mut libc::c_void, symbol) as *mut u8\n+        c::GetProcAddress(handle as c::HMODULE, symbol) as *mut u8\n     }\n     pub unsafe fn close(handle: *mut u8) {\n-        FreeLibrary(handle as *mut libc::c_void); ()\n-    }\n-\n-    #[allow(non_snake_case)]\n-    extern \"system\" {\n-        fn SetLastError(error: libc::size_t);\n-        fn LoadLibraryW(name: *const libc::c_void) -> *mut libc::c_void;\n-        fn GetModuleHandleExW(dwFlags: libc::DWORD, name: *const u16,\n-                              handle: *mut *mut libc::c_void) -> libc::BOOL;\n-        fn GetProcAddress(handle: *mut libc::c_void,\n-                          name: *const libc::c_char) -> *mut libc::c_void;\n-        fn FreeLibrary(handle: *mut libc::c_void);\n-        fn SetErrorMode(uMode: libc::c_uint) -> libc::c_uint;\n+        c::FreeLibrary(handle as c::HMODULE);\n     }\n }\n "}, {"sha": "985dbdd895f847b1da6d464534fa82f47af0bd1c", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -16,7 +16,6 @@ use cmp;\n use fmt;\n use io::lazy::Lazy;\n use io::{self, BufReader, LineWriter};\n-use libc;\n use sync::{Arc, Mutex, MutexGuard};\n use sys::stdio;\n use sys_common::io::{read_to_end_uninitialized};\n@@ -121,9 +120,9 @@ impl<R: io::Read> io::Read for Maybe<R> {\n \n fn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n     #[cfg(windows)]\n-    const ERR: libc::c_int = libc::ERROR_INVALID_HANDLE;\n+    const ERR: i32 = ::sys::c::ERROR_INVALID_HANDLE as i32;\n     #[cfg(not(windows))]\n-    const ERR: libc::c_int = libc::EBADF;\n+    const ERR: i32 = ::libc::EBADF as i32;\n \n     match r {\n         Err(ref e) if e.raw_os_error() == Some(ERR) => Ok(default),"}, {"sha": "a0bb9449806e87a99b2cfa901980635ba75dae76", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -213,13 +213,12 @@\n        test(no_crate_inject, attr(deny(warnings))),\n        test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n-// SNAP 1af31d4\n-#![allow(unused_features)]\n-// SNAP 1af31d4\n-#![allow(unused_attributes)]\n+#![cfg_attr(stage0, allow(unused_attributes))]\n+#![cfg_attr(stage0, allow(improper_ctypes))]\n \n #![feature(alloc)]\n #![feature(allow_internal_unstable)]\n+#![feature(asm)]\n #![feature(associated_consts)]\n #![feature(borrow_state)]\n #![feature(box_syntax)]\n@@ -233,49 +232,52 @@\n #![feature(core_float)]\n #![feature(core_intrinsics)]\n #![feature(core_simd)]\n+#![feature(decode_utf16)]\n #![feature(drain)]\n+#![feature(drop_in_place)]\n+#![feature(dropck_parametricity)]\n+#![feature(float_extras)]\n+#![feature(float_from_str_radix)]\n #![feature(fnbox)]\n #![feature(heap_api)]\n #![feature(int_error_internals)]\n #![feature(into_cow)]\n #![feature(lang_items)]\n #![feature(libc)]\n-#![feature(linkage, thread_local, asm)]\n+#![feature(link_args)]\n+#![feature(linkage)]\n #![feature(macro_reexport)]\n-#![feature(slice_concat_ext)]\n #![feature(no_std)]\n #![feature(oom)]\n #![feature(optin_builtin_traits)]\n #![feature(placement_in_syntax)]\n #![feature(rand)]\n+#![feature(range_inclusive)]\n #![feature(raw)]\n #![feature(reflect_marker)]\n #![feature(slice_bytes)]\n+#![feature(slice_concat_ext)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(str_char)]\n #![feature(str_internals)]\n+#![feature(str_utf16)]\n+#![feature(test, rustc_private)]\n+#![feature(thread_local)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n-#![feature(dropck_parametricity)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n-#![feature(decode_utf16)]\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n #![feature(wrapping)]\n #![feature(zero_one)]\n-#![feature(drop_in_place)]\n-\n-#![cfg_attr(windows, feature(str_utf16))]\n-#![cfg_attr(test, feature(float_from_str_radix, range_inclusive, float_extras))]\n-#![cfg_attr(test, feature(test, rustc_private))]\n-#![cfg_attr(target_env = \"msvc\", feature(link_args))]\n \n // Don't link to std. We are std.\n #![no_std]\n \n #![deny(missing_docs)]\n+#![allow(unused_features)] // std may use features in a platform-specific way\n \n #[cfg(test)] extern crate test;\n #[cfg(test)] #[macro_use] extern crate log;"}, {"sha": "66c1ab720b60f40a072650b7230187216157fbf6", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -13,10 +13,10 @@ use prelude::v1::*;\n use fmt;\n use hash;\n use io;\n-use libc::{self, socklen_t, sa_family_t};\n use mem;\n use net::{lookup_host, ntoh, hton, IpAddr, Ipv4Addr, Ipv6Addr};\n use option;\n+use sys::net::netc as c;\n use sys_common::{FromInner, AsInner, IntoInner};\n use vec;\n \n@@ -39,12 +39,12 @@ pub enum SocketAddr {\n /// An IPv4 socket address which is a (ip, port) combination.\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SocketAddrV4 { inner: libc::sockaddr_in }\n+pub struct SocketAddrV4 { inner: c::sockaddr_in }\n \n /// An IPv6 socket address.\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SocketAddrV6 { inner: libc::sockaddr_in6 }\n+pub struct SocketAddrV6 { inner: c::sockaddr_in6 }\n \n impl SocketAddr {\n     /// Creates a new socket address from the (ip, port) pair.\n@@ -80,8 +80,8 @@ impl SocketAddrV4 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4 {\n         SocketAddrV4 {\n-            inner: libc::sockaddr_in {\n-                sin_family: libc::AF_INET as sa_family_t,\n+            inner: c::sockaddr_in {\n+                sin_family: c::AF_INET as c::sa_family_t,\n                 sin_port: hton(port),\n                 sin_addr: *ip.as_inner(),\n                 .. unsafe { mem::zeroed() }\n@@ -93,7 +93,7 @@ impl SocketAddrV4 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ip(&self) -> &Ipv4Addr {\n         unsafe {\n-            &*(&self.inner.sin_addr as *const libc::in_addr as *const Ipv4Addr)\n+            &*(&self.inner.sin_addr as *const c::in_addr as *const Ipv4Addr)\n         }\n     }\n \n@@ -109,8 +109,8 @@ impl SocketAddrV6 {\n     pub fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32)\n                -> SocketAddrV6 {\n         SocketAddrV6 {\n-            inner: libc::sockaddr_in6 {\n-                sin6_family: libc::AF_INET6 as sa_family_t,\n+            inner: c::sockaddr_in6 {\n+                sin6_family: c::AF_INET6 as c::sa_family_t,\n                 sin6_port: hton(port),\n                 sin6_addr: *ip.as_inner(),\n                 sin6_flowinfo: hton(flowinfo),\n@@ -124,7 +124,7 @@ impl SocketAddrV6 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ip(&self) -> &Ipv6Addr {\n         unsafe {\n-            &*(&self.inner.sin6_addr as *const libc::in6_addr as *const Ipv6Addr)\n+            &*(&self.inner.sin6_addr as *const c::in6_addr as *const Ipv6Addr)\n         }\n     }\n \n@@ -143,26 +143,26 @@ impl SocketAddrV6 {\n     pub fn scope_id(&self) -> u32 { ntoh(self.inner.sin6_scope_id) }\n }\n \n-impl FromInner<libc::sockaddr_in> for SocketAddrV4 {\n-    fn from_inner(addr: libc::sockaddr_in) -> SocketAddrV4 {\n+impl FromInner<c::sockaddr_in> for SocketAddrV4 {\n+    fn from_inner(addr: c::sockaddr_in) -> SocketAddrV4 {\n         SocketAddrV4 { inner: addr }\n     }\n }\n \n-impl FromInner<libc::sockaddr_in6> for SocketAddrV6 {\n-    fn from_inner(addr: libc::sockaddr_in6) -> SocketAddrV6 {\n+impl FromInner<c::sockaddr_in6> for SocketAddrV6 {\n+    fn from_inner(addr: c::sockaddr_in6) -> SocketAddrV6 {\n         SocketAddrV6 { inner: addr }\n     }\n }\n \n-impl<'a> IntoInner<(*const libc::sockaddr, socklen_t)> for &'a SocketAddr {\n-    fn into_inner(self) -> (*const libc::sockaddr, socklen_t) {\n+impl<'a> IntoInner<(*const c::sockaddr, c::socklen_t)> for &'a SocketAddr {\n+    fn into_inner(self) -> (*const c::sockaddr, c::socklen_t) {\n         match *self {\n             SocketAddr::V4(ref a) => {\n-                (a as *const _ as *const _, mem::size_of_val(a) as socklen_t)\n+                (a as *const _ as *const _, mem::size_of_val(a) as c::socklen_t)\n             }\n             SocketAddr::V6(ref a) => {\n-                (a as *const _ as *const _, mem::size_of_val(a) as socklen_t)\n+                (a as *const _ as *const _, mem::size_of_val(a) as c::socklen_t)\n             }\n         }\n     }"}, {"sha": "f3ad148e3da93e89f9965eaf855ac4837cadcfef", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -16,11 +16,12 @@\n use prelude::v1::*;\n \n use cmp::Ordering;\n-use hash;\n use fmt;\n-use libc;\n-use sys_common::{AsInner, FromInner};\n+use hash;\n+use mem;\n use net::{hton, ntoh};\n+use sys::net::netc as c;\n+use sys_common::{AsInner, FromInner};\n \n /// An IP address, either an IPv4 or IPv6 address.\n #[unstable(feature = \"ip_addr\", reason = \"recent addition\", issue = \"27801\")]\n@@ -36,14 +37,14 @@ pub enum IpAddr {\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ipv4Addr {\n-    inner: libc::in_addr,\n+    inner: c::in_addr,\n }\n \n /// Representation of an IPv6 address.\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ipv6Addr {\n-    inner: libc::in6_addr,\n+    inner: c::in6_addr,\n }\n \n #[allow(missing_docs)]\n@@ -65,7 +66,7 @@ impl Ipv4Addr {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n         Ipv4Addr {\n-            inner: libc::in_addr {\n+            inner: c::in_addr {\n                 s_addr: hton(((a as u32) << 24) |\n                              ((b as u32) << 16) |\n                              ((c as u32) <<  8) |\n@@ -239,11 +240,11 @@ impl Ord for Ipv4Addr {\n     }\n }\n \n-impl AsInner<libc::in_addr> for Ipv4Addr {\n-    fn as_inner(&self) -> &libc::in_addr { &self.inner }\n+impl AsInner<c::in_addr> for Ipv4Addr {\n+    fn as_inner(&self) -> &c::in_addr { &self.inner }\n }\n-impl FromInner<libc::in_addr> for Ipv4Addr {\n-    fn from_inner(addr: libc::in_addr) -> Ipv4Addr {\n+impl FromInner<c::in_addr> for Ipv4Addr {\n+    fn from_inner(addr: c::in_addr) -> Ipv4Addr {\n         Ipv4Addr { inner: addr }\n     }\n }\n@@ -270,25 +271,32 @@ impl Ipv6Addr {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,\n                h: u16) -> Ipv6Addr {\n-        Ipv6Addr {\n-            inner: libc::in6_addr {\n-                s6_addr: [hton(a), hton(b), hton(c), hton(d),\n-                          hton(e), hton(f), hton(g), hton(h)]\n-            }\n-        }\n+        let mut addr: c::in6_addr = unsafe { mem::zeroed() };\n+        addr.s6_addr = [(a >> 8) as u8, a as u8,\n+                        (b >> 8) as u8, b as u8,\n+                        (c >> 8) as u8, c as u8,\n+                        (d >> 8) as u8, d as u8,\n+                        (e >> 8) as u8, e as u8,\n+                        (f >> 8) as u8, f as u8,\n+                        (g >> 8) as u8, g as u8,\n+                        (h >> 8) as u8, h as u8];\n+        Ipv6Addr { inner: addr }\n     }\n \n     /// Returns the eight 16-bit segments that make up this address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn segments(&self) -> [u16; 8] {\n-        [ntoh(self.inner.s6_addr[0]),\n-         ntoh(self.inner.s6_addr[1]),\n-         ntoh(self.inner.s6_addr[2]),\n-         ntoh(self.inner.s6_addr[3]),\n-         ntoh(self.inner.s6_addr[4]),\n-         ntoh(self.inner.s6_addr[5]),\n-         ntoh(self.inner.s6_addr[6]),\n-         ntoh(self.inner.s6_addr[7])]\n+        let arr = &self.inner.s6_addr;\n+        [\n+            (arr[0] as u16) << 8 | (arr[1] as u16),\n+            (arr[2] as u16) << 8 | (arr[3] as u16),\n+            (arr[4] as u16) << 8 | (arr[5] as u16),\n+            (arr[6] as u16) << 8 | (arr[7] as u16),\n+            (arr[8] as u16) << 8 | (arr[9] as u16),\n+            (arr[10] as u16) << 8 | (arr[11] as u16),\n+            (arr[12] as u16) << 8 | (arr[13] as u16),\n+            (arr[14] as u16) << 8 | (arr[15] as u16),\n+        ]\n     }\n \n     /// Returns true for the special 'unspecified' address ::.\n@@ -502,11 +510,11 @@ impl Ord for Ipv6Addr {\n     }\n }\n \n-impl AsInner<libc::in6_addr> for Ipv6Addr {\n-    fn as_inner(&self) -> &libc::in6_addr { &self.inner }\n+impl AsInner<c::in6_addr> for Ipv6Addr {\n+    fn as_inner(&self) -> &c::in6_addr { &self.inner }\n }\n-impl FromInner<libc::in6_addr> for Ipv6Addr {\n-    fn from_inner(addr: libc::in6_addr) -> Ipv6Addr {\n+impl FromInner<c::in6_addr> for Ipv6Addr {\n+    fn from_inner(addr: c::in6_addr) -> Ipv6Addr {\n         Ipv6Addr { inner: addr }\n     }\n }"}, {"sha": "60069cf7bc3efea6b5fa483bf351cd6e8f5190a8", "filename": "src/libstd/os/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -12,9 +12,9 @@\n \n #![stable(feature = \"raw_os\", since = \"1.1.0\")]\n \n-#[cfg(target_arch = \"aarch64\")]\n+#[cfg(any(target_arch = \"aarch64\", target_os = \"android\"))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n-#[cfg(not(target_arch = \"aarch64\"))]\n+#[cfg(not(any(target_arch = \"aarch64\", target_os = \"android\")))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = i8;\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_schar = i8;\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_uchar = u8;"}, {"sha": "d1bd013e67b792a8be8cef92cbe7a46c297cd935", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -252,10 +252,7 @@ mod imp {\n     use io;\n     use mem;\n     use rand::Rng;\n-    use libc::types::os::arch::extra::{LONG_PTR};\n-    use libc::{DWORD, BYTE, LPCSTR, BOOL};\n-\n-    type HCRYPTPROV = LONG_PTR;\n+    use sys::c;\n \n     /// A random number generator that retrieves randomness straight from\n     /// the operating system. Platform sources:\n@@ -268,35 +265,17 @@ mod imp {\n     ///\n     /// This does not block.\n     pub struct OsRng {\n-        hcryptprov: HCRYPTPROV\n-    }\n-\n-    const PROV_RSA_FULL: DWORD = 1;\n-    const CRYPT_SILENT: DWORD = 64;\n-    const CRYPT_VERIFYCONTEXT: DWORD = 0xF0000000;\n-\n-    #[allow(non_snake_case)]\n-    #[link(name = \"advapi32\")]\n-    extern \"system\" {\n-        fn CryptAcquireContextA(phProv: *mut HCRYPTPROV,\n-                                pszContainer: LPCSTR,\n-                                pszProvider: LPCSTR,\n-                                dwProvType: DWORD,\n-                                dwFlags: DWORD) -> BOOL;\n-        fn CryptGenRandom(hProv: HCRYPTPROV,\n-                          dwLen: DWORD,\n-                          pbBuffer: *mut BYTE) -> BOOL;\n-        fn CryptReleaseContext(hProv: HCRYPTPROV, dwFlags: DWORD) -> BOOL;\n+        hcryptprov: c::HCRYPTPROV\n     }\n \n     impl OsRng {\n         /// Create a new `OsRng`.\n         pub fn new() -> io::Result<OsRng> {\n             let mut hcp = 0;\n             let ret = unsafe {\n-                CryptAcquireContextA(&mut hcp, 0 as LPCSTR, 0 as LPCSTR,\n-                                     PROV_RSA_FULL,\n-                                     CRYPT_VERIFYCONTEXT | CRYPT_SILENT)\n+                c::CryptAcquireContextA(&mut hcp, 0 as c::LPCSTR, 0 as c::LPCSTR,\n+                                        c::PROV_RSA_FULL,\n+                                        c::CRYPT_VERIFYCONTEXT | c::CRYPT_SILENT)\n             };\n \n             if ret == 0 {\n@@ -320,8 +299,8 @@ mod imp {\n         }\n         fn fill_bytes(&mut self, v: &mut [u8]) {\n             let ret = unsafe {\n-                CryptGenRandom(self.hcryptprov, v.len() as DWORD,\n-                               v.as_mut_ptr())\n+                c::CryptGenRandom(self.hcryptprov, v.len() as c::DWORD,\n+                                  v.as_mut_ptr())\n             };\n             if ret == 0 {\n                 panic!(\"couldn't generate random bytes: {}\",\n@@ -333,7 +312,7 @@ mod imp {\n     impl Drop for OsRng {\n         fn drop(&mut self) {\n             let ret = unsafe {\n-                CryptReleaseContext(self.hcryptprov, 0)\n+                c::CryptReleaseContext(self.hcryptprov, 0)\n             };\n             if ret == 0 {\n                 panic!(\"couldn't release context: {}\","}, {"sha": "a18370dc68e1827ada78d138ec5b3ac0b5de239f", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -12,10 +12,10 @@ use prelude::v1::*;\n \n use sync::atomic::{AtomicUsize, Ordering};\n use sync::{mutex, MutexGuard, PoisonError};\n+use sys::time::SteadyTime;\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n use sys_common::poison::{self, LockResult};\n-use sys::time::SteadyTime;\n use time::Duration;\n \n /// A type indicating whether a timed wait on a condition variable returned"}, {"sha": "449cd9d8c97a1f5693399805b4cc0b8177a8cdf7", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 63, "deletions": 86, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -13,13 +13,13 @@ use prelude::v1::*;\n use ffi::{CStr, CString};\n use fmt;\n use io::{self, Error, ErrorKind};\n-use libc::{self, c_int, c_char, c_void, socklen_t};\n+use libc::{c_int, c_char, c_void};\n use mem;\n use net::{SocketAddr, Shutdown, IpAddr};\n use ptr;\n use str::from_utf8;\n-use sys::c;\n use sys::net::{cvt, cvt_r, cvt_gai, Socket, init, wrlen_t};\n+use sys::net::netc as c;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n \n@@ -31,8 +31,8 @@ pub fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int,\n                      payload: T) -> io::Result<()> {\n     unsafe {\n         let payload = &payload as *const T as *const c_void;\n-        try!(cvt(libc::setsockopt(*sock.as_inner(), opt, val, payload,\n-                                  mem::size_of::<T>() as socklen_t)));\n+        try!(cvt(c::setsockopt(*sock.as_inner(), opt, val, payload,\n+                               mem::size_of::<T>() as c::socklen_t)));\n         Ok(())\n     }\n }\n@@ -41,7 +41,7 @@ pub fn getsockopt<T: Copy>(sock: &Socket, opt: c_int,\n                        val: c_int) -> io::Result<T> {\n     unsafe {\n         let mut slot: T = mem::zeroed();\n-        let mut len = mem::size_of::<T>() as socklen_t;\n+        let mut len = mem::size_of::<T>() as c::socklen_t;\n         try!(cvt(c::getsockopt(*sock.as_inner(), opt, val,\n                                &mut slot as *mut _ as *mut _,\n                                &mut len)));\n@@ -51,29 +51,29 @@ pub fn getsockopt<T: Copy>(sock: &Socket, opt: c_int,\n }\n \n fn sockname<F>(f: F) -> io::Result<SocketAddr>\n-    where F: FnOnce(*mut libc::sockaddr, *mut socklen_t) -> c_int\n+    where F: FnOnce(*mut c::sockaddr, *mut c::socklen_t) -> c_int\n {\n     unsafe {\n-        let mut storage: libc::sockaddr_storage = mem::zeroed();\n-        let mut len = mem::size_of_val(&storage) as socklen_t;\n+        let mut storage: c::sockaddr_storage = mem::zeroed();\n+        let mut len = mem::size_of_val(&storage) as c::socklen_t;\n         try!(cvt(f(&mut storage as *mut _ as *mut _, &mut len)));\n         sockaddr_to_addr(&storage, len as usize)\n     }\n }\n \n-fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n+fn sockaddr_to_addr(storage: &c::sockaddr_storage,\n                     len: usize) -> io::Result<SocketAddr> {\n-    match storage.ss_family as libc::c_int {\n-        libc::AF_INET => {\n-            assert!(len as usize >= mem::size_of::<libc::sockaddr_in>());\n+    match storage.ss_family as c_int {\n+        c::AF_INET => {\n+            assert!(len as usize >= mem::size_of::<c::sockaddr_in>());\n             Ok(SocketAddr::V4(FromInner::from_inner(unsafe {\n-                *(storage as *const _ as *const libc::sockaddr_in)\n+                *(storage as *const _ as *const c::sockaddr_in)\n             })))\n         }\n-        libc::AF_INET6 => {\n-            assert!(len as usize >= mem::size_of::<libc::sockaddr_in6>());\n+        c::AF_INET6 => {\n+            assert!(len as usize >= mem::size_of::<c::sockaddr_in6>());\n             Ok(SocketAddr::V6(FromInner::from_inner(unsafe {\n-                *(storage as *const _ as *const libc::sockaddr_in6)\n+                *(storage as *const _ as *const c::sockaddr_in6)\n             })))\n         }\n         _ => {\n@@ -86,16 +86,9 @@ fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n // get_host_addresses\n ////////////////////////////////////////////////////////////////////////////////\n \n-extern \"system\" {\n-    fn getaddrinfo(node: *const c_char, service: *const c_char,\n-                   hints: *const libc::addrinfo,\n-                   res: *mut *mut libc::addrinfo) -> c_int;\n-    fn freeaddrinfo(res: *mut libc::addrinfo);\n-}\n-\n pub struct LookupHost {\n-    original: *mut libc::addrinfo,\n-    cur: *mut libc::addrinfo,\n+    original: *mut c::addrinfo,\n+    cur: *mut c::addrinfo,\n }\n \n impl Iterator for LookupHost {\n@@ -105,7 +98,7 @@ impl Iterator for LookupHost {\n             if self.cur.is_null() { return None }\n             let ret = sockaddr_to_addr(mem::transmute((*self.cur).ai_addr),\n                                        (*self.cur).ai_addrlen as usize);\n-            self.cur = (*self.cur).ai_next as *mut libc::addrinfo;\n+            self.cur = (*self.cur).ai_next as *mut c::addrinfo;\n             Some(ret)\n         }\n     }\n@@ -116,7 +109,7 @@ unsafe impl Send for LookupHost {}\n \n impl Drop for LookupHost {\n     fn drop(&mut self) {\n-        unsafe { freeaddrinfo(self.original) }\n+        unsafe { c::freeaddrinfo(self.original) }\n     }\n }\n \n@@ -126,8 +119,8 @@ pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     let c_host = try!(CString::new(host));\n     let mut res = ptr::null_mut();\n     unsafe {\n-        try!(cvt_gai(getaddrinfo(c_host.as_ptr(), ptr::null(), ptr::null(),\n-                                 &mut res)));\n+        try!(cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), ptr::null(),\n+                                   &mut res)));\n         Ok(LookupHost { original: res, cur: res })\n     }\n }\n@@ -136,26 +129,18 @@ pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n // lookup_addr\n ////////////////////////////////////////////////////////////////////////////////\n \n-extern \"system\" {\n-    fn getnameinfo(sa: *const libc::sockaddr, salen: socklen_t,\n-                   host: *mut c_char, hostlen: libc::size_t,\n-                   serv: *mut c_char, servlen: libc::size_t,\n-                   flags: c_int) -> c_int;\n-}\n-\n-const NI_MAXHOST: usize = 1025;\n-\n pub fn lookup_addr(addr: &IpAddr) -> io::Result<String> {\n     init();\n \n     let saddr = SocketAddr::new(*addr, 0);\n     let (inner, len) = saddr.into_inner();\n-    let mut hostbuf = [0 as c_char; NI_MAXHOST];\n+    let mut hostbuf = [0 as c_char; c::NI_MAXHOST as usize];\n \n     let data = unsafe {\n-        try!(cvt_gai(getnameinfo(inner, len,\n-                                 hostbuf.as_mut_ptr(), NI_MAXHOST as libc::size_t,\n-                                 ptr::null_mut(), 0, 0)));\n+        try!(cvt_gai(c::getnameinfo(inner, len,\n+                                    hostbuf.as_mut_ptr(),\n+                                    c::NI_MAXHOST,\n+                                    ptr::null_mut(), 0, 0)));\n \n         CStr::from_ptr(hostbuf.as_ptr())\n     };\n@@ -179,10 +164,10 @@ impl TcpStream {\n     pub fn connect(addr: &SocketAddr) -> io::Result<TcpStream> {\n         init();\n \n-        let sock = try!(Socket::new(addr, libc::SOCK_STREAM));\n+        let sock = try!(Socket::new(addr, c::SOCK_STREAM));\n \n         let (addrp, len) = addr.into_inner();\n-        try!(cvt_r(|| unsafe { libc::connect(*sock.as_inner(), addrp, len) }));\n+        try!(cvt_r(|| unsafe { c::connect(*sock.as_inner(), addrp, len) }));\n         Ok(TcpStream { inner: sock })\n     }\n \n@@ -191,19 +176,19 @@ impl TcpStream {\n     pub fn into_socket(self) -> Socket { self.inner }\n \n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n-        self.inner.set_timeout(dur, libc::SO_RCVTIMEO)\n+        self.inner.set_timeout(dur, c::SO_RCVTIMEO)\n     }\n \n     pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n-        self.inner.set_timeout(dur, libc::SO_SNDTIMEO)\n+        self.inner.set_timeout(dur, c::SO_SNDTIMEO)\n     }\n \n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.inner.timeout(libc::SO_RCVTIMEO)\n+        self.inner.timeout(c::SO_RCVTIMEO)\n     }\n \n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.inner.timeout(libc::SO_SNDTIMEO)\n+        self.inner.timeout(c::SO_SNDTIMEO)\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -212,36 +197,28 @@ impl TcpStream {\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let ret = try!(cvt(unsafe {\n-            libc::send(*self.inner.as_inner(),\n-                       buf.as_ptr() as *const c_void,\n-                       buf.len() as wrlen_t,\n-                       0)\n+            c::send(*self.inner.as_inner(),\n+                    buf.as_ptr() as *const c_void,\n+                    buf.len() as wrlen_t,\n+                    0)\n         }));\n         Ok(ret as usize)\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         sockname(|buf, len| unsafe {\n-            libc::getpeername(*self.inner.as_inner(), buf, len)\n+            c::getpeername(*self.inner.as_inner(), buf, len)\n         })\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n         sockname(|buf, len| unsafe {\n-            libc::getsockname(*self.inner.as_inner(), buf, len)\n+            c::getsockname(*self.inner.as_inner(), buf, len)\n         })\n     }\n \n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        use libc::consts::os::bsd44::SHUT_RDWR;\n-\n-        let how = match how {\n-            Shutdown::Write => libc::SHUT_WR,\n-            Shutdown::Read => libc::SHUT_RD,\n-            Shutdown::Both => SHUT_RDWR,\n-        };\n-        try!(cvt(unsafe { libc::shutdown(*self.inner.as_inner(), how) }));\n-        Ok(())\n+        self.inner.shutdown(how)\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpStream> {\n@@ -285,22 +262,22 @@ impl TcpListener {\n     pub fn bind(addr: &SocketAddr) -> io::Result<TcpListener> {\n         init();\n \n-        let sock = try!(Socket::new(addr, libc::SOCK_STREAM));\n+        let sock = try!(Socket::new(addr, c::SOCK_STREAM));\n \n         // On platforms with Berkeley-derived sockets, this allows\n         // to quickly rebind a socket, without needing to wait for\n         // the OS to clean up the previous one.\n         if !cfg!(windows) {\n-            try!(setsockopt(&sock, libc::SOL_SOCKET, libc::SO_REUSEADDR,\n+            try!(setsockopt(&sock, c::SOL_SOCKET, c::SO_REUSEADDR,\n                             1 as c_int));\n         }\n \n         // Bind our new socket\n         let (addrp, len) = addr.into_inner();\n-        try!(cvt(unsafe { libc::bind(*sock.as_inner(), addrp, len) }));\n+        try!(cvt(unsafe { c::bind(*sock.as_inner(), addrp, len) }));\n \n         // Start listening\n-        try!(cvt(unsafe { libc::listen(*sock.as_inner(), 128) }));\n+        try!(cvt(unsafe { c::listen(*sock.as_inner(), 128) }));\n         Ok(TcpListener { inner: sock })\n     }\n \n@@ -310,13 +287,13 @@ impl TcpListener {\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n         sockname(|buf, len| unsafe {\n-            libc::getsockname(*self.inner.as_inner(), buf, len)\n+            c::getsockname(*self.inner.as_inner(), buf, len)\n         })\n     }\n \n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n-        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-        let mut len = mem::size_of_val(&storage) as socklen_t;\n+        let mut storage: c::sockaddr_storage = unsafe { mem::zeroed() };\n+        let mut len = mem::size_of_val(&storage) as c::socklen_t;\n         let sock = try!(self.inner.accept(&mut storage as *mut _ as *mut _,\n                                           &mut len));\n         let addr = try!(sockaddr_to_addr(&storage, len as usize));\n@@ -360,9 +337,9 @@ impl UdpSocket {\n     pub fn bind(addr: &SocketAddr) -> io::Result<UdpSocket> {\n         init();\n \n-        let sock = try!(Socket::new(addr, libc::SOCK_DGRAM));\n+        let sock = try!(Socket::new(addr, c::SOCK_DGRAM));\n         let (addrp, len) = addr.into_inner();\n-        try!(cvt(unsafe { libc::bind(*sock.as_inner(), addrp, len) }));\n+        try!(cvt(unsafe { c::bind(*sock.as_inner(), addrp, len) }));\n         Ok(UdpSocket { inner: sock })\n     }\n \n@@ -372,29 +349,29 @@ impl UdpSocket {\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n         sockname(|buf, len| unsafe {\n-            libc::getsockname(*self.inner.as_inner(), buf, len)\n+            c::getsockname(*self.inner.as_inner(), buf, len)\n         })\n     }\n \n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-        let mut addrlen = mem::size_of_val(&storage) as socklen_t;\n+        let mut storage: c::sockaddr_storage = unsafe { mem::zeroed() };\n+        let mut addrlen = mem::size_of_val(&storage) as c::socklen_t;\n \n         let n = try!(cvt(unsafe {\n-            libc::recvfrom(*self.inner.as_inner(),\n-                           buf.as_mut_ptr() as *mut c_void,\n-                           buf.len() as wrlen_t, 0,\n-                           &mut storage as *mut _ as *mut _, &mut addrlen)\n+            c::recvfrom(*self.inner.as_inner(),\n+                        buf.as_mut_ptr() as *mut c_void,\n+                        buf.len() as wrlen_t, 0,\n+                        &mut storage as *mut _ as *mut _, &mut addrlen)\n         }));\n         Ok((n as usize, try!(sockaddr_to_addr(&storage, addrlen as usize))))\n     }\n \n     pub fn send_to(&self, buf: &[u8], dst: &SocketAddr) -> io::Result<usize> {\n         let (dstp, dstlen) = dst.into_inner();\n         let ret = try!(cvt(unsafe {\n-            libc::sendto(*self.inner.as_inner(),\n-                         buf.as_ptr() as *const c_void, buf.len() as wrlen_t,\n-                         0, dstp, dstlen)\n+            c::sendto(*self.inner.as_inner(),\n+                      buf.as_ptr() as *const c_void, buf.len() as wrlen_t,\n+                      0, dstp, dstlen)\n         }));\n         Ok(ret as usize)\n     }\n@@ -404,19 +381,19 @@ impl UdpSocket {\n     }\n \n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n-        self.inner.set_timeout(dur, libc::SO_RCVTIMEO)\n+        self.inner.set_timeout(dur, c::SO_RCVTIMEO)\n     }\n \n     pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n-        self.inner.set_timeout(dur, libc::SO_SNDTIMEO)\n+        self.inner.set_timeout(dur, c::SO_SNDTIMEO)\n     }\n \n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.inner.timeout(libc::SO_RCVTIMEO)\n+        self.inner.timeout(c::SO_RCVTIMEO)\n     }\n \n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.inner.timeout(libc::SO_SNDTIMEO)\n+        self.inner.timeout(c::SO_SNDTIMEO)\n     }\n }\n "}, {"sha": "7296194efda5eb4bdc1b7f722146d7da602cebd6", "filename": "src/libstd/sys/common/unwind/seh.rs", "status": "modified", "additions": 6, "deletions": 37, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -52,45 +52,14 @@\n use prelude::v1::*;\n \n use any::Any;\n-use libc::{c_ulong, DWORD, c_void};\n use ptr;\n use sys_common::thread_local::StaticKey;\n+use sys::c;\n \n-//                        0x R U S T\n-const RUST_PANIC: DWORD = 0x52555354;\n+//                           0x R U S T\n+const RUST_PANIC: c::DWORD = 0x52555354;\n static PANIC_DATA: StaticKey = StaticKey::new(None);\n \n-// This function is provided by kernel32.dll\n-extern \"system\" {\n-    #[unwind]\n-    fn RaiseException(dwExceptionCode: DWORD,\n-                      dwExceptionFlags: DWORD,\n-                      nNumberOfArguments: DWORD,\n-                      lpArguments: *const c_ulong);\n-}\n-\n-#[repr(C)]\n-pub struct EXCEPTION_POINTERS {\n-    ExceptionRecord: *mut EXCEPTION_RECORD,\n-    ContextRecord: *mut CONTEXT,\n-}\n-\n-enum CONTEXT {}\n-\n-#[repr(C)]\n-struct EXCEPTION_RECORD {\n-    ExceptionCode: DWORD,\n-    ExceptionFlags: DWORD,\n-    ExceptionRecord: *mut _EXCEPTION_RECORD,\n-    ExceptionAddress: *mut c_void,\n-    NumberParameters: DWORD,\n-    ExceptionInformation: [*mut c_ulong; EXCEPTION_MAXIMUM_PARAMETERS],\n-}\n-\n-enum _EXCEPTION_RECORD {}\n-\n-const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n-\n pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n     // See module docs above for an explanation of why `data` is stored in a\n     // thread local instead of being passed as an argument to the\n@@ -100,14 +69,14 @@ pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n     rtassert!(PANIC_DATA.get().is_null());\n     PANIC_DATA.set(Box::into_raw(exception) as *mut u8);\n \n-    RaiseException(RUST_PANIC, 0, 0, ptr::null());\n+    c::RaiseException(RUST_PANIC, 0, 0, ptr::null());\n     rtabort!(\"could not unwind stack\");\n }\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> {\n     // The `ptr` here actually corresponds to the code of the exception, and our\n     // real data is stored in our thread local.\n-    rtassert!(ptr as DWORD == RUST_PANIC);\n+    rtassert!(ptr as c::DWORD == RUST_PANIC);\n \n     let data = PANIC_DATA.get() as *mut Box<Any + Send + 'static>;\n     PANIC_DATA.set(ptr::null_mut());\n@@ -139,7 +108,7 @@ fn rust_eh_personality() {\n #[lang = \"msvc_try_filter\"]\n #[linkage = \"external\"]\n #[allow(private_no_mangle_fns)]\n-extern fn __rust_try_filter(eh_ptrs: *mut EXCEPTION_POINTERS,\n+extern fn __rust_try_filter(eh_ptrs: *mut c::EXCEPTION_POINTERS,\n                             _rbp: *mut u8) -> i32 {\n     unsafe {\n         ((*(*eh_ptrs).ExceptionRecord).ExceptionCode == RUST_PANIC) as i32"}, {"sha": "26c2cee9222db6c7dbfa04d61fe0a2ff6f7e45ce", "filename": "src/libstd/sys/common/unwind/seh64_gnu.rs", "status": "modified", "additions": 34, "deletions": 106, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh64_gnu.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -17,12 +17,10 @@\n use prelude::v1::*;\n \n use any::Any;\n-use self::EXCEPTION_DISPOSITION::*;\n use sys_common::dwarf::eh;\n use core::mem;\n use core::ptr;\n-use libc::{c_void, c_ulonglong, DWORD, LPVOID};\n-type ULONG_PTR = c_ulonglong;\n+use sys::c;\n \n // Define our exception codes:\n // according to http://msdn.microsoft.com/en-us/library/het71c37(v=VS.80).aspx,\n@@ -32,80 +30,10 @@ type ULONG_PTR = c_ulonglong;\n // we define bits:\n //    [24:27] = type\n //    [0:23]  = magic\n-const ETYPE: DWORD = 0b1110_u32 << 28;\n-const MAGIC: DWORD = 0x525354; // \"RST\"\n+const ETYPE: c::DWORD = 0b1110_u32 << 28;\n+const MAGIC: c::DWORD = 0x525354; // \"RST\"\n \n-const RUST_PANIC: DWORD  = ETYPE | (1 << 24) | MAGIC;\n-\n-const EXCEPTION_NONCONTINUABLE: DWORD = 0x1;   // Noncontinuable exception\n-const EXCEPTION_UNWINDING: DWORD = 0x2;        // Unwind is in progress\n-const EXCEPTION_EXIT_UNWIND: DWORD = 0x4;      // Exit unwind is in progress\n-const EXCEPTION_STACK_INVALID: DWORD = 0x8;    // Stack out of limits or unaligned\n-const EXCEPTION_NESTED_CALL: DWORD = 0x10;     // Nested exception handler call\n-const EXCEPTION_TARGET_UNWIND: DWORD = 0x20;   // Target unwind in progress\n-const EXCEPTION_COLLIDED_UNWIND: DWORD = 0x40; // Collided exception handler call\n-const EXCEPTION_UNWIND: DWORD = EXCEPTION_UNWINDING |\n-                                EXCEPTION_EXIT_UNWIND |\n-                                EXCEPTION_TARGET_UNWIND |\n-                                EXCEPTION_COLLIDED_UNWIND;\n-\n-#[repr(C)]\n-pub struct EXCEPTION_RECORD {\n-    ExceptionCode: DWORD,\n-    ExceptionFlags: DWORD,\n-    ExceptionRecord: *const EXCEPTION_RECORD,\n-    ExceptionAddress: LPVOID,\n-    NumberParameters: DWORD,\n-    ExceptionInformation: [ULONG_PTR; 15],\n-}\n-\n-pub enum CONTEXT {}\n-pub enum UNWIND_HISTORY_TABLE {}\n-\n-#[repr(C)]\n-pub struct RUNTIME_FUNCTION {\n-    BeginAddress: DWORD,\n-    EndAddress: DWORD,\n-    UnwindData: DWORD,\n-}\n-\n-#[repr(C)]\n-pub struct DISPATCHER_CONTEXT {\n-    ControlPc: LPVOID,\n-    ImageBase: LPVOID,\n-    FunctionEntry: *const RUNTIME_FUNCTION,\n-    EstablisherFrame: LPVOID,\n-    TargetIp: LPVOID,\n-    ContextRecord: *const CONTEXT,\n-    LanguageHandler: LPVOID,\n-    HandlerData: *const u8,\n-    HistoryTable: *const UNWIND_HISTORY_TABLE,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum EXCEPTION_DISPOSITION {\n-    ExceptionContinueExecution,\n-    ExceptionContinueSearch,\n-    ExceptionNestedException,\n-    ExceptionCollidedUnwind\n-}\n-\n-// From kernel32.dll\n-extern \"system\" {\n-    #[unwind]\n-    fn RaiseException(dwExceptionCode: DWORD,\n-                      dwExceptionFlags: DWORD,\n-                      nNumberOfArguments: DWORD,\n-                      lpArguments: *const ULONG_PTR);\n-\n-    fn RtlUnwindEx(TargetFrame: LPVOID,\n-                   TargetIp: LPVOID,\n-                   ExceptionRecord: *const EXCEPTION_RECORD,\n-                   ReturnValue: LPVOID,\n-                   OriginalContext: *const CONTEXT,\n-                   HistoryTable: *const UNWIND_HISTORY_TABLE);\n-}\n+const RUST_PANIC: c::DWORD  = ETYPE | (1 << 24) | MAGIC;\n \n #[repr(C)]\n struct PanicData {\n@@ -114,11 +42,11 @@ struct PanicData {\n \n pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n     let panic_ctx = Box::new(PanicData { data: data });\n-    let params = [Box::into_raw(panic_ctx) as ULONG_PTR];\n-    RaiseException(RUST_PANIC,\n-                   EXCEPTION_NONCONTINUABLE,\n-                   params.len() as DWORD,\n-                   &params as *const ULONG_PTR);\n+    let params = [Box::into_raw(panic_ctx) as c::ULONG_PTR];\n+    c::RaiseException(RUST_PANIC,\n+                      c::EXCEPTION_NONCONTINUABLE,\n+                      params.len() as c::DWORD,\n+                      &params as *const c::ULONG_PTR);\n     rtabort!(\"could not unwind stack\");\n }\n \n@@ -152,11 +80,11 @@ pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> {\n #[lang = \"eh_personality_catch\"]\n #[cfg(not(test))]\n unsafe extern fn rust_eh_personality_catch(\n-    exceptionRecord: *mut EXCEPTION_RECORD,\n-    establisherFrame: LPVOID,\n-    contextRecord: *mut CONTEXT,\n-    dispatcherContext: *mut DISPATCHER_CONTEXT\n-) -> EXCEPTION_DISPOSITION\n+    exceptionRecord: *mut c::EXCEPTION_RECORD,\n+    establisherFrame: c::LPVOID,\n+    contextRecord: *mut c::CONTEXT,\n+    dispatcherContext: *mut c::DISPATCHER_CONTEXT\n+) -> c::EXCEPTION_DISPOSITION\n {\n     rust_eh_personality(exceptionRecord, establisherFrame,\n                         contextRecord, dispatcherContext)\n@@ -165,44 +93,44 @@ unsafe extern fn rust_eh_personality_catch(\n #[lang = \"eh_personality\"]\n #[cfg(not(test))]\n unsafe extern fn rust_eh_personality(\n-    exceptionRecord: *mut EXCEPTION_RECORD,\n-    establisherFrame: LPVOID,\n-    contextRecord: *mut CONTEXT,\n-    dispatcherContext: *mut DISPATCHER_CONTEXT\n-) -> EXCEPTION_DISPOSITION\n+    exceptionRecord: *mut c::EXCEPTION_RECORD,\n+    establisherFrame: c::LPVOID,\n+    contextRecord: *mut c::CONTEXT,\n+    dispatcherContext: *mut c::DISPATCHER_CONTEXT\n+) -> c::EXCEPTION_DISPOSITION\n {\n     let er = &*exceptionRecord;\n     let dc = &*dispatcherContext;\n \n-    if er.ExceptionFlags & EXCEPTION_UNWIND == 0 { // we are in the dispatch phase\n+    if er.ExceptionFlags & c::EXCEPTION_UNWIND == 0 { // we are in the dispatch phase\n         if er.ExceptionCode == RUST_PANIC {\n             if let Some(lpad) = find_landing_pad(dc) {\n-                RtlUnwindEx(establisherFrame,\n-                            lpad as LPVOID,\n-                            exceptionRecord,\n-                            er.ExceptionInformation[0] as LPVOID, // pointer to PanicData\n-                            contextRecord,\n-                            dc.HistoryTable);\n+                c::RtlUnwindEx(establisherFrame,\n+                               lpad as c::LPVOID,\n+                               exceptionRecord,\n+                               er.ExceptionInformation[0] as c::LPVOID, // pointer to PanicData\n+                               contextRecord,\n+                               dc.HistoryTable);\n                 rtabort!(\"could not unwind\");\n             }\n         }\n     }\n-    ExceptionContinueSearch\n+    c::ExceptionContinueSearch\n }\n \n #[cfg(not(test))]\n #[lang = \"eh_unwind_resume\"]\n #[unwind]\n-unsafe extern fn rust_eh_unwind_resume(panic_ctx: LPVOID) -> ! {\n-    let params = [panic_ctx as ULONG_PTR];\n-    RaiseException(RUST_PANIC,\n-                   EXCEPTION_NONCONTINUABLE,\n-                   params.len() as DWORD,\n-                   &params as *const ULONG_PTR);\n+unsafe extern fn rust_eh_unwind_resume(panic_ctx: c::LPVOID) -> ! {\n+    let params = [panic_ctx as c::ULONG_PTR];\n+    c::RaiseException(RUST_PANIC,\n+                      c::EXCEPTION_NONCONTINUABLE,\n+                      params.len() as c::DWORD,\n+                      &params as *const c::ULONG_PTR);\n     rtabort!(\"could not resume unwind\");\n }\n \n-unsafe fn find_landing_pad(dc: &DISPATCHER_CONTEXT) -> Option<usize> {\n+unsafe fn find_landing_pad(dc: &c::DISPATCHER_CONTEXT) -> Option<usize> {\n     let eh_ctx = eh::EHContext {\n         ip: dc.ControlPc as usize,\n         func_start: dc.ImageBase as usize + (*dc.FunctionEntry).BeginAddress as usize,"}, {"sha": "fc6af6447d2fd316a82d8057335263c55f70770d", "filename": "src/libstd/sys/unix/c.rs", "status": "removed", "additions": 0, "deletions": 452, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/c8a29c2092cec369a751051a2bfed093522ff6e8/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a29c2092cec369a751051a2bfed093522ff6e8/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=c8a29c2092cec369a751051a2bfed093522ff6e8", "patch": "@@ -1,452 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! C definitions used by std::sys that don't belong in liblibc\n-\n-// These are definitions sufficient for the users in this directory.\n-// This is not a general-purpose binding to this functionality, and in\n-// some cases (notably the definition of siginfo_t), we intentionally\n-// have incomplete bindings so that we don't need to fight with unions.\n-//\n-// Note that these types need to match the definitions from the platform\n-// libc (currently glibc on Linux), not the kernel definitions / the\n-// syscall interface.  This has a few weirdnesses, like glibc's sigset_t\n-// being 1024 bits on all platforms. If you're adding a new GNU/Linux\n-// port, check glibc's sysdeps/unix/sysv/linux, not the kernel headers.\n-\n-#![allow(dead_code)]\n-#![allow(non_camel_case_types)]\n-\n-pub use self::signal_os::*;\n-use libc;\n-\n-#[cfg(any(target_os = \"macos\",\n-          target_os = \"ios\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"netbsd\",\n-          target_os = \"openbsd\"))]\n-pub const FIOCLEX: libc::c_ulong = 0x20006601;\n-\n-#[cfg(any(all(target_os = \"linux\",\n-              any(target_arch = \"x86\",\n-                  target_arch = \"x86_64\",\n-                  target_arch = \"arm\",\n-                  target_arch = \"aarch64\")),\n-          target_os = \"android\"))]\n-pub const FIOCLEX: libc::c_ulong = 0x5451;\n-\n-#[cfg(all(target_os = \"linux\",\n-          any(target_arch = \"mips\",\n-              target_arch = \"mipsel\",\n-              target_arch = \"powerpc\")))]\n-pub const FIOCLEX: libc::c_ulong = 0x6601;\n-\n-#[cfg(target_env = \"newlib\")]\n-pub const FD_CLOEXEC: libc::c_int = 1;\n-#[cfg(target_env = \"newlib\")]\n-pub const F_GETFD: libc::c_int = 1;\n-#[cfg(target_env = \"newlib\")]\n-pub const F_SETFD: libc::c_int = 2;\n-\n-pub const WNOHANG: libc::c_int = 1;\n-\n-#[cfg(target_os = \"linux\")]\n-pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 70;\n-#[cfg(any(target_os = \"macos\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\"))]\n-pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 71;\n-#[cfg(any(target_os = \"bitrig\",\n-          target_os = \"openbsd\"))]\n-pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 101;\n-#[cfg(target_os = \"netbsd\")]\n-pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 48;\n-#[cfg(target_os = \"android\")]\n-pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 0x0048;\n-\n-#[repr(C)]\n-#[cfg(target_os = \"linux\")]\n-pub struct passwd {\n-    pub pw_name: *mut libc::c_char,\n-    pub pw_passwd: *mut libc::c_char,\n-    pub pw_uid: libc::uid_t,\n-    pub pw_gid: libc::gid_t,\n-    pub pw_gecos: *mut libc::c_char,\n-    pub pw_dir: *mut libc::c_char,\n-    pub pw_shell: *mut libc::c_char,\n-}\n-#[repr(C)]\n-#[cfg(target_env = \"newlib\")]\n-pub struct passwd {\n-    pub pw_name: *mut libc::c_char,\n-    pub pw_passwd: *mut libc::c_char,\n-    pub pw_uid: libc::uid_t,\n-    pub pw_gid: libc::gid_t,\n-    pub pw_comment: *mut libc::c_char,\n-    pub pw_gecos: *mut libc::c_char,\n-    pub pw_dir: *mut libc::c_char,\n-    pub pw_shell: *mut libc::c_char,\n-}\n-\n-#[repr(C)]\n-#[cfg(any(target_os = \"macos\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"netbsd\",\n-          target_os = \"openbsd\"))]\n-pub struct passwd {\n-    pub pw_name: *mut libc::c_char,\n-    pub pw_passwd: *mut libc::c_char,\n-    pub pw_uid: libc::uid_t,\n-    pub pw_gid: libc::gid_t,\n-    pub pw_change: libc::time_t,\n-    pub pw_class: *mut libc::c_char,\n-    pub pw_gecos: *mut libc::c_char,\n-    pub pw_dir: *mut libc::c_char,\n-    pub pw_shell: *mut libc::c_char,\n-    pub pw_expire: libc::time_t,\n-}\n-\n-#[repr(C)]\n-#[cfg(target_os = \"android\")]\n-pub struct passwd {\n-    pub pw_name: *mut libc::c_char,\n-    pub pw_passwd: *mut libc::c_char,\n-    pub pw_uid: libc::uid_t,\n-    pub pw_gid: libc::gid_t,\n-    pub pw_dir: *mut libc::c_char,\n-    pub pw_shell: *mut libc::c_char,\n-}\n-\n-// This is really a function pointer (or a union of multiple function\n-// pointers), except for constants like SIG_DFL.\n-pub type sighandler_t = *mut libc::c_void;\n-\n-pub const SIG_DFL: sighandler_t = 0 as sighandler_t;\n-pub const SIG_ERR: sighandler_t = !0 as sighandler_t;\n-\n-extern {\n-    pub fn getsockopt(sockfd: libc::c_int,\n-                      level: libc::c_int,\n-                      optname: libc::c_int,\n-                      optval: *mut libc::c_void,\n-                      optlen: *mut libc::socklen_t) -> libc::c_int;\n-    #[cfg(not(target_env = \"newlib\"))]\n-    pub fn ioctl(fd: libc::c_int, req: libc::c_ulong, ...) -> libc::c_int;\n-    #[cfg(target_env = \"newlib\")]\n-    pub fn fnctl(fd: libc::c_int, req: libc::c_int, ...) -> libc::c_int;\n-\n-\n-    pub fn waitpid(pid: libc::pid_t, status: *mut libc::c_int,\n-                   options: libc::c_int) -> libc::pid_t;\n-\n-    pub fn raise(signum: libc::c_int) -> libc::c_int;\n-\n-    #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaction14\")]\n-    pub fn sigaction(signum: libc::c_int,\n-                     act: *const sigaction,\n-                     oldact: *mut sigaction) -> libc::c_int;\n-\n-    #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaltstack14\")]\n-    #[cfg(not(target_env = \"newlib\"))]\n-    pub fn sigaltstack(ss: *const sigaltstack,\n-                       oss: *mut sigaltstack) -> libc::c_int;\n-\n-    #[cfg(not(target_os = \"android\"))]\n-    #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigemptyset14\")]\n-    pub fn sigemptyset(set: *mut sigset_t) -> libc::c_int;\n-\n-    pub fn pthread_sigmask(how: libc::c_int, set: *const sigset_t,\n-                           oldset: *mut sigset_t) -> libc::c_int;\n-\n-    #[cfg(not(target_os = \"ios\"))]\n-    #[cfg_attr(target_os = \"netbsd\", link_name = \"__getpwuid_r50\")]\n-    pub fn getpwuid_r(uid: libc::uid_t,\n-                      pwd: *mut passwd,\n-                      buf: *mut libc::c_char,\n-                      buflen: libc::size_t,\n-                      result: *mut *mut passwd) -> libc::c_int;\n-\n-    #[cfg_attr(target_os = \"netbsd\", link_name = \"__utimes50\")]\n-    pub fn utimes(filename: *const libc::c_char,\n-                  times: *const libc::timeval) -> libc::c_int;\n-    pub fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;\n-    /// Newlib has this, but only for Cygwin.\n-    #[cfg(not(target_os = \"nacl\"))]\n-    pub fn setgroups(ngroups: libc::c_int,\n-                     ptr: *const libc::c_void) -> libc::c_int;\n-    pub fn realpath(pathname: *const libc::c_char, resolved: *mut libc::c_char)\n-                    -> *mut libc::c_char;\n-}\n-\n-// Ugh. This is only available as an inline until Android API 21.\n-#[cfg(target_os = \"android\")]\n-pub unsafe fn sigemptyset(set: *mut sigset_t) -> libc::c_int {\n-    use intrinsics;\n-    intrinsics::write_bytes(set, 0, 1);\n-    return 0;\n-}\n-\n-#[cfg(any(target_os = \"linux\",\n-          target_os = \"android\"))]\n-mod signal_os {\n-    pub use self::arch::{SA_ONSTACK, SA_SIGINFO, SIGBUS, SIG_SETMASK,\n-                         sigaction, sigaltstack};\n-    use libc;\n-\n-    #[cfg(any(target_arch = \"x86\",\n-              target_arch = \"x86_64\",\n-              target_arch = \"arm\",\n-              target_arch = \"mips\",\n-              target_arch = \"mipsel\"))]\n-    pub const SIGSTKSZ: libc::size_t = 8192;\n-\n-    // This is smaller on musl and Android, but no harm in being generous.\n-    #[cfg(any(target_arch = \"aarch64\",\n-              target_arch = \"powerpc\"))]\n-    pub const SIGSTKSZ: libc::size_t = 16384;\n-\n-    // This definition is intentionally a subset of the C structure: the\n-    // fields after si_code are actually a giant union. We're only\n-    // interested in si_addr for this module, though.\n-    #[repr(C)]\n-    pub struct siginfo {\n-        _signo: libc::c_int,\n-        _errno: libc::c_int,\n-        _code: libc::c_int,\n-        // This structure will need extra padding here for MIPS64.\n-        pub si_addr: *mut libc::c_void\n-    }\n-\n-    #[cfg(all(target_os = \"linux\", target_pointer_width = \"32\"))]\n-    #[repr(C)]\n-    pub struct sigset_t {\n-        __val: [libc::c_ulong; 32],\n-    }\n-\n-    #[cfg(all(target_os = \"linux\", target_pointer_width = \"64\"))]\n-    #[repr(C)]\n-    pub struct sigset_t {\n-        __val: [libc::c_ulong; 16],\n-    }\n-\n-    // Android for MIPS has a 128-bit sigset_t, but we don't currently\n-    // support it. Android for AArch64 technically has a structure of a\n-    // single ulong.\n-    #[cfg(target_os = \"android\")]\n-    pub type sigset_t = libc::c_ulong;\n-\n-    #[cfg(any(target_arch = \"x86\",\n-              target_arch = \"x86_64\",\n-              target_arch = \"powerpc\",\n-              target_arch = \"arm\",\n-              target_arch = \"aarch64\"))]\n-    mod arch {\n-        use libc;\n-        use super::super::sighandler_t;\n-        use super::sigset_t;\n-\n-        pub const SA_ONSTACK: libc::c_ulong = 0x08000000;\n-        pub const SA_SIGINFO: libc::c_ulong = 0x00000004;\n-\n-        pub const SIGBUS: libc::c_int = 7;\n-\n-        pub const SIG_SETMASK: libc::c_int = 2;\n-\n-        #[cfg(target_os = \"linux\")]\n-        #[repr(C)]\n-        pub struct sigaction {\n-            pub sa_sigaction: sighandler_t,\n-            pub sa_mask: sigset_t,\n-            pub sa_flags: libc::c_ulong,\n-            _restorer: *mut libc::c_void,\n-        }\n-\n-        #[cfg(all(target_os = \"android\", target_pointer_width = \"32\"))]\n-        #[repr(C)]\n-        pub struct sigaction {\n-            pub sa_sigaction: sighandler_t,\n-            pub sa_flags: libc::c_ulong,\n-            _restorer: *mut libc::c_void,\n-            pub sa_mask: sigset_t,\n-        }\n-\n-        #[cfg(all(target_os = \"android\", target_pointer_width = \"64\"))]\n-        #[repr(C)]\n-        pub struct sigaction {\n-            pub sa_flags: libc::c_uint,\n-            pub sa_sigaction: sighandler_t,\n-            pub sa_mask: sigset_t,\n-            _restorer: *mut libc::c_void,\n-        }\n-\n-        #[repr(C)]\n-        pub struct sigaltstack {\n-            pub ss_sp: *mut libc::c_void,\n-            pub ss_flags: libc::c_int,\n-            pub ss_size: libc::size_t\n-        }\n-    }\n-\n-    #[cfg(any(target_arch = \"mips\",\n-              target_arch = \"mipsel\"))]\n-    mod arch {\n-        use libc;\n-        use super::super::sighandler_t;\n-        use super::sigset_t;\n-\n-        pub const SA_ONSTACK: libc::c_ulong = 0x08000000;\n-        pub const SA_SIGINFO: libc::c_ulong = 0x00000008;\n-\n-        pub const SIGBUS: libc::c_int = 10;\n-\n-        pub const SIG_SETMASK: libc::c_int = 3;\n-\n-        #[cfg(all(target_os = \"linux\", not(target_env = \"musl\")))]\n-        #[repr(C)]\n-        pub struct sigaction {\n-            pub sa_flags: libc::c_uint,\n-            pub sa_sigaction: sighandler_t,\n-            pub sa_mask: sigset_t,\n-            _restorer: *mut libc::c_void,\n-            _resv: [libc::c_int; 1],\n-        }\n-\n-        #[cfg(target_env = \"musl\")]\n-        #[repr(C)]\n-        pub struct sigaction {\n-            pub sa_sigaction: sighandler_t,\n-            pub sa_mask: sigset_t,\n-            pub sa_flags: libc::c_ulong,\n-            _restorer: *mut libc::c_void,\n-        }\n-\n-        #[cfg(target_os = \"android\")]\n-        #[repr(C)]\n-        pub struct sigaction {\n-            pub sa_flags: libc::c_uint,\n-            pub sa_sigaction: sighandler_t,\n-            pub sa_mask: sigset_t,\n-        }\n-\n-        #[repr(C)]\n-        pub struct sigaltstack {\n-            pub ss_sp: *mut libc::c_void,\n-            pub ss_size: libc::size_t,\n-            pub ss_flags: libc::c_int,\n-        }\n-    }\n-}\n-\n-/// Note: Although the signal functions are defined on NaCl, they always fail.\n-/// Also, this could be cfg-ed on newlib instead of nacl, but these structures\n-/// can differ depending on the platform, so I've played it safe here.\n-#[cfg(target_os = \"nacl\")]\n-mod signal_os {\n-    use libc;\n-\n-    pub static SA_NOCLDSTOP: libc::c_ulong = 1;\n-    pub static SA_SIGINFO:   libc::c_ulong = 2;\n-\n-    pub type sigset_t = libc::c_ulong;\n-    #[repr(C)]\n-    pub struct sigaction {\n-        pub sa_flags: libc::c_int,\n-        pub sa_mask:  sigset_t,\n-        pub handler:  extern fn(libc::c_int),\n-    }\n-}\n-\n-#[cfg(any(target_os = \"macos\",\n-          target_os = \"ios\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"netbsd\",\n-          target_os = \"openbsd\"))]\n-mod signal_os {\n-    use libc;\n-    use super::sighandler_t;\n-\n-    pub const SA_ONSTACK: libc::c_int = 0x0001;\n-    pub const SA_SIGINFO: libc::c_int = 0x0040;\n-\n-    pub const SIGBUS: libc::c_int = 10;\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    pub const SIGSTKSZ: libc::size_t = 131072;\n-    // FreeBSD's is actually arch-dependent, but never more than 40960.\n-    // No harm in being generous.\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n-    pub const SIGSTKSZ: libc::size_t = 40960;\n-\n-    pub const SIG_SETMASK: libc::c_int = 3;\n-\n-    #[cfg(any(target_os = \"macos\",\n-              target_os = \"ios\"))]\n-    pub type sigset_t = u32;\n-    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))]\n-    #[repr(C)]\n-    pub struct sigset_t {\n-        bits: [u32; 4],\n-    }\n-    #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n-    pub type sigset_t = libc::c_uint;\n-\n-    // This structure has more fields, but we're not all that interested in\n-    // them.\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\",\n-              target_os = \"freebsd\", target_os = \"dragonfly\"))]\n-    #[repr(C)]\n-    pub struct siginfo {\n-        pub _signo: libc::c_int,\n-        pub _errno: libc::c_int,\n-        pub _code: libc::c_int,\n-        pub _pid: libc::pid_t,\n-        pub _uid: libc::uid_t,\n-        pub _status: libc::c_int,\n-        pub si_addr: *mut libc::c_void\n-    }\n-    #[cfg(any(target_os = \"bitrig\", target_os = \"netbsd\", target_os = \"openbsd\"))]\n-    #[repr(C)]\n-    pub struct siginfo {\n-        pub si_signo: libc::c_int,\n-        pub si_code: libc::c_int,\n-        pub si_errno: libc::c_int,\n-        pub si_addr: *mut libc::c_void\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\",\n-              target_os = \"bitrig\", target_os = \"netbsd\", target_os = \"openbsd\"))]\n-    #[repr(C)]\n-    pub struct sigaction {\n-        pub sa_sigaction: sighandler_t,\n-        pub sa_mask: sigset_t,\n-        pub sa_flags: libc::c_int,\n-    }\n-\n-    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n-    #[repr(C)]\n-    pub struct sigaction {\n-        pub sa_sigaction: sighandler_t,\n-        pub sa_flags: libc::c_int,\n-        pub sa_mask: sigset_t,\n-    }\n-\n-    #[repr(C)]\n-    pub struct sigaltstack {\n-        pub ss_sp: *mut libc::c_void,\n-        pub ss_size: libc::size_t,\n-        pub ss_flags: libc::c_int,\n-    }\n-}"}, {"sha": "3e0f41933e64106b3d23916873c1a41039b70f59", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -13,10 +13,9 @@ use libc;\n use ptr;\n use sys::mutex::{self, Mutex};\n use sys::time;\n-use sys::sync as ffi;\n use time::Duration;\n \n-pub struct Condvar { inner: UnsafeCell<ffi::pthread_cond_t> }\n+pub struct Condvar { inner: UnsafeCell<libc::pthread_cond_t> }\n \n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n@@ -25,24 +24,24 @@ impl Condvar {\n     pub const fn new() -> Condvar {\n         // Might be moved and address is changing it is better to avoid\n         // initialization of potentially opaque OS data before it landed\n-        Condvar { inner: UnsafeCell::new(ffi::PTHREAD_COND_INITIALIZER) }\n+        Condvar { inner: UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER) }\n     }\n \n     #[inline]\n     pub unsafe fn notify_one(&self) {\n-        let r = ffi::pthread_cond_signal(self.inner.get());\n+        let r = libc::pthread_cond_signal(self.inner.get());\n         debug_assert_eq!(r, 0);\n     }\n \n     #[inline]\n     pub unsafe fn notify_all(&self) {\n-        let r = ffi::pthread_cond_broadcast(self.inner.get());\n+        let r = libc::pthread_cond_broadcast(self.inner.get());\n         debug_assert_eq!(r, 0);\n     }\n \n     #[inline]\n     pub unsafe fn wait(&self, mutex: &Mutex) {\n-        let r = ffi::pthread_cond_wait(self.inner.get(), mutex::raw(mutex));\n+        let r = libc::pthread_cond_wait(self.inner.get(), mutex::raw(mutex));\n         debug_assert_eq!(r, 0);\n     }\n \n@@ -55,7 +54,7 @@ impl Condvar {\n         // report timeout based on stable time.\n         let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n         let stable_now = time::SteadyTime::now();\n-        let r = ffi::gettimeofday(&mut sys_now, ptr::null_mut());\n+        let r = libc::gettimeofday(&mut sys_now, ptr::null_mut());\n         debug_assert_eq!(r, 0);\n \n         let nsec = dur.subsec_nanos() as libc::c_long +\n@@ -76,7 +75,7 @@ impl Condvar {\n         });\n \n         // And wait!\n-        let r = ffi::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex),\n+        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex),\n                                             &timeout);\n         debug_assert!(r == libc::ETIMEDOUT || r == 0);\n \n@@ -88,17 +87,17 @@ impl Condvar {\n     #[inline]\n     #[cfg(not(target_os = \"dragonfly\"))]\n     pub unsafe fn destroy(&self) {\n-        let r = ffi::pthread_cond_destroy(self.inner.get());\n+        let r = libc::pthread_cond_destroy(self.inner.get());\n         debug_assert_eq!(r, 0);\n     }\n \n     #[inline]\n     #[cfg(target_os = \"dragonfly\")]\n     pub unsafe fn destroy(&self) {\n-        let r = ffi::pthread_cond_destroy(self.inner.get());\n+        let r = libc::pthread_cond_destroy(self.inner.get());\n         // On DragonFly pthread_cond_destroy() returns EINVAL if called on\n         // a condvar that was just initialized with\n-        // ffi::PTHREAD_COND_INITIALIZER. Once it is used or\n+        // libc::PTHREAD_COND_INITIALIZER. Once it is used or\n         // pthread_cond_init() is called, this behaviour no longer occurs.\n         debug_assert!(r == 0 || r == libc::EINVAL);\n     }"}, {"sha": "d42c15a97ac8c30f43b09d430e68c9158c6a1d39", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -11,7 +11,6 @@\n use io;\n use libc::{self, c_int, size_t, c_void};\n use mem;\n-use sys::c;\n use sys::cvt;\n use sys_common::AsInner;\n \n@@ -54,15 +53,15 @@ impl FileDesc {\n     #[cfg(not(target_env = \"newlib\"))]\n     pub fn set_cloexec(&self) {\n         unsafe {\n-            let ret = c::ioctl(self.fd, c::FIOCLEX);\n+            let ret = libc::ioctl(self.fd, libc::FIOCLEX);\n             debug_assert_eq!(ret, 0);\n         }\n     }\n     #[cfg(target_env = \"newlib\")]\n     pub fn set_cloexec(&self) {\n         unsafe {\n-            let previous = c::fnctl(self.fd, c::F_GETFD);\n-            let ret = c::fnctl(self.fd, c::F_SETFD, previous | c::FD_CLOEXEC);\n+            let previous = libc::fnctl(self.fd, libc::F_GETFD);\n+            let ret = libc::fnctl(self.fd, libc::F_SETFD, previous | libc::FD_CLOEXEC);\n             debug_assert_eq!(ret, 0);\n         }\n     }"}, {"sha": "018c91002880f22147b2a0e588a50792c2aba766", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -21,7 +21,7 @@ use ptr;\n use sync::Arc;\n use sys::fd::FileDesc;\n use sys::platform::raw;\n-use sys::{c, cvt, cvt_r};\n+use sys::{cvt, cvt_r};\n use sys_common::{AsInner, FromInner};\n use vec::Vec;\n \n@@ -43,7 +43,7 @@ unsafe impl Send for Dir {}\n unsafe impl Sync for Dir {}\n \n pub struct DirEntry {\n-    buf: Vec<u8>, // actually *mut libc::dirent_t\n+    buf: Vec<u8>, // actually *mut libc::dirent\n     root: Arc<PathBuf>,\n }\n \n@@ -133,7 +133,7 @@ impl Iterator for ReadDir {\n         let mut buf: Vec<u8> = Vec::with_capacity(unsafe {\n             rust_dirent_t_size() as usize\n         });\n-        let ptr = buf.as_mut_ptr() as *mut libc::dirent_t;\n+        let ptr = buf.as_mut_ptr() as *mut libc::dirent;\n \n         let mut entry_ptr = ptr::null_mut();\n         loop {\n@@ -179,7 +179,7 @@ impl DirEntry {\n \n     pub fn file_type(&self) -> io::Result<FileType> {\n         extern {\n-            fn rust_dir_get_mode(ptr: *mut libc::dirent_t) -> c_int;\n+            fn rust_dir_get_mode(ptr: *mut libc::dirent) -> c_int;\n         }\n         unsafe {\n             match rust_dir_get_mode(self.dirent()) {\n@@ -191,21 +191,21 @@ impl DirEntry {\n \n     pub fn ino(&self) -> raw::ino_t {\n         extern {\n-            fn rust_dir_get_ino(ptr: *mut libc::dirent_t) -> raw::ino_t;\n+            fn rust_dir_get_ino(ptr: *mut libc::dirent) -> raw::ino_t;\n         }\n         unsafe { rust_dir_get_ino(self.dirent()) }\n     }\n \n     fn name_bytes(&self) -> &[u8] {\n         extern {\n-            fn rust_list_dir_val(ptr: *mut libc::dirent_t) -> *const c_char;\n+            fn rust_list_dir_val(ptr: *mut libc::dirent) -> *const c_char;\n         }\n         unsafe {\n             CStr::from_ptr(rust_list_dir_val(self.dirent())).to_bytes()\n         }\n     }\n \n-    fn dirent(&self) -> *mut libc::dirent_t {\n+    fn dirent(&self) -> *mut libc::dirent {\n         self.buf.as_ptr() as *mut _\n     }\n }\n@@ -267,7 +267,7 @@ impl File {\n             (false, false) => libc::O_RDONLY,\n         };\n         let fd = try!(cvt_r(|| unsafe {\n-            libc::open(path.as_ptr(), flags, opts.mode)\n+            libc::open(path.as_ptr(), flags, opts.mode as c_int)\n         }));\n         let fd = FileDesc::new(fd);\n         // Even though we open with the O_CLOEXEC flag, still set CLOEXEC here,\n@@ -532,7 +532,7 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     let path = try!(CString::new(p.as_os_str().as_bytes()));\n     let buf;\n     unsafe {\n-        let r = c::realpath(path.as_ptr(), ptr::null_mut());\n+        let r = libc::realpath(path.as_ptr(), ptr::null_mut());\n         if r.is_null() {\n             return Err(io::Error::last_os_error())\n         }"}, {"sha": "68b0c3d6b0ee7392ce9d81919e3f1bd1e4d6c0e5", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -28,7 +28,6 @@ use ops::Neg;\n #[cfg(target_os = \"openbsd\")]   pub use os::openbsd as platform;\n \n pub mod backtrace;\n-pub mod c;\n pub mod condvar;\n pub mod ext;\n pub mod fd;\n@@ -41,15 +40,14 @@ pub mod pipe;\n pub mod process;\n pub mod rwlock;\n pub mod stack_overflow;\n-pub mod sync;\n pub mod thread;\n pub mod thread_local;\n pub mod time;\n pub mod stdio;\n \n #[cfg(not(target_os = \"nacl\"))]\n pub fn init() {\n-    use libc::funcs::posix01::signal::signal;\n+    use libc::signal;\n     // By default, some platforms will send a *signal* when an EPIPE error\n     // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n     // handler, causing it to kill the program, which isn't exactly what we\n@@ -78,7 +76,7 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n         libc::EINTR => ErrorKind::Interrupted,\n         libc::EINVAL => ErrorKind::InvalidInput,\n         libc::ETIMEDOUT => ErrorKind::TimedOut,\n-        libc::consts::os::posix88::EEXIST => ErrorKind::AlreadyExists,\n+        libc::EEXIST => ErrorKind::AlreadyExists,\n \n         // These two constants can have the same value on some systems,\n         // but different values on others, so we can't use a match"}, {"sha": "4e4abcfbeee4ddb9256451e8f6bdb54e9a0f3d4f", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n use cell::UnsafeCell;\n-use sys::sync as ffi;\n+use libc;\n use mem;\n \n-pub struct Mutex { inner: UnsafeCell<ffi::pthread_mutex_t> }\n+pub struct Mutex { inner: UnsafeCell<libc::pthread_mutex_t> }\n \n #[inline]\n-pub unsafe fn raw(m: &Mutex) -> *mut ffi::pthread_mutex_t {\n+pub unsafe fn raw(m: &Mutex) -> *mut libc::pthread_mutex_t {\n     m.inner.get()\n }\n \n@@ -27,42 +27,42 @@ impl Mutex {\n     pub const fn new() -> Mutex {\n         // Might be moved and address is changing it is better to avoid\n         // initialization of potentially opaque OS data before it landed\n-        Mutex { inner: UnsafeCell::new(ffi::PTHREAD_MUTEX_INITIALIZER) }\n+        Mutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n     }\n     #[inline]\n     pub unsafe fn lock(&self) {\n-        let r = ffi::pthread_mutex_lock(self.inner.get());\n+        let r = libc::pthread_mutex_lock(self.inner.get());\n         debug_assert_eq!(r, 0);\n     }\n     #[inline]\n     pub unsafe fn unlock(&self) {\n-        let r = ffi::pthread_mutex_unlock(self.inner.get());\n+        let r = libc::pthread_mutex_unlock(self.inner.get());\n         debug_assert_eq!(r, 0);\n     }\n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        ffi::pthread_mutex_trylock(self.inner.get()) == 0\n+        libc::pthread_mutex_trylock(self.inner.get()) == 0\n     }\n     #[inline]\n     #[cfg(not(target_os = \"dragonfly\"))]\n     pub unsafe fn destroy(&self) {\n-        let r = ffi::pthread_mutex_destroy(self.inner.get());\n+        let r = libc::pthread_mutex_destroy(self.inner.get());\n         debug_assert_eq!(r, 0);\n     }\n     #[inline]\n     #[cfg(target_os = \"dragonfly\")]\n     pub unsafe fn destroy(&self) {\n         use libc;\n-        let r = ffi::pthread_mutex_destroy(self.inner.get());\n+        let r = libc::pthread_mutex_destroy(self.inner.get());\n         // On DragonFly pthread_mutex_destroy() returns EINVAL if called on a\n-        // mutex that was just initialized with ffi::PTHREAD_MUTEX_INITIALIZER.\n+        // mutex that was just initialized with libc::PTHREAD_MUTEX_INITIALIZER.\n         // Once it is used (locked/unlocked) or pthread_mutex_init() is called,\n         // this behaviour no longer occurs.\n         debug_assert!(r == 0 || r == libc::EINVAL);\n     }\n }\n \n-pub struct ReentrantMutex { inner: UnsafeCell<ffi::pthread_mutex_t> }\n+pub struct ReentrantMutex { inner: UnsafeCell<libc::pthread_mutex_t> }\n \n unsafe impl Send for ReentrantMutex {}\n unsafe impl Sync for ReentrantMutex {}\n@@ -73,35 +73,35 @@ impl ReentrantMutex {\n     }\n \n     pub unsafe fn init(&mut self) {\n-        let mut attr: ffi::pthread_mutexattr_t = mem::uninitialized();\n-        let result = ffi::pthread_mutexattr_init(&mut attr as *mut _);\n+        let mut attr: libc::pthread_mutexattr_t = mem::uninitialized();\n+        let result = libc::pthread_mutexattr_init(&mut attr as *mut _);\n         debug_assert_eq!(result, 0);\n-        let result = ffi::pthread_mutexattr_settype(&mut attr as *mut _,\n-                                                    ffi::PTHREAD_MUTEX_RECURSIVE);\n+        let result = libc::pthread_mutexattr_settype(&mut attr as *mut _,\n+                                                    libc::PTHREAD_MUTEX_RECURSIVE);\n         debug_assert_eq!(result, 0);\n-        let result = ffi::pthread_mutex_init(self.inner.get(), &attr as *const _);\n+        let result = libc::pthread_mutex_init(self.inner.get(), &attr as *const _);\n         debug_assert_eq!(result, 0);\n-        let result = ffi::pthread_mutexattr_destroy(&mut attr as *mut _);\n+        let result = libc::pthread_mutexattr_destroy(&mut attr as *mut _);\n         debug_assert_eq!(result, 0);\n     }\n \n     pub unsafe fn lock(&self) {\n-        let result = ffi::pthread_mutex_lock(self.inner.get());\n+        let result = libc::pthread_mutex_lock(self.inner.get());\n         debug_assert_eq!(result, 0);\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        ffi::pthread_mutex_trylock(self.inner.get()) == 0\n+        libc::pthread_mutex_trylock(self.inner.get()) == 0\n     }\n \n     pub unsafe fn unlock(&self) {\n-        let result = ffi::pthread_mutex_unlock(self.inner.get());\n+        let result = libc::pthread_mutex_unlock(self.inner.get());\n         debug_assert_eq!(result, 0);\n     }\n \n     pub unsafe fn destroy(&self) {\n-        let result = ffi::pthread_mutex_destroy(self.inner.get());\n+        let result = libc::pthread_mutex_destroy(self.inner.get());\n         debug_assert_eq!(result, 0);\n     }\n }"}, {"sha": "bcda1d651d69d125791cc1b8aa0b417043b45df3", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -13,16 +13,16 @@ use prelude::v1::*;\n use ffi::CStr;\n use io;\n use libc::{self, c_int, size_t};\n-use net::SocketAddr;\n+use net::{SocketAddr, Shutdown};\n use str;\n-use sync::atomic::{self, AtomicBool};\n-use sys::c;\n+use sync::atomic::{AtomicBool, Ordering};\n use sys::fd::FileDesc;\n use sys_common::{AsInner, FromInner, IntoInner};\n use sys_common::net::{getsockopt, setsockopt};\n use time::Duration;\n \n pub use sys::{cvt, cvt_r};\n+pub use libc as netc;\n \n pub type wrlen_t = size_t;\n \n@@ -34,7 +34,7 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n     if err == 0 { return Ok(()) }\n \n     let detail = unsafe {\n-        str::from_utf8(CStr::from_ptr(c::gai_strerror(err)).to_bytes()).unwrap()\n+        str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap()\n             .to_owned()\n     };\n     Err(io::Error::new(io::ErrorKind::Other,\n@@ -67,29 +67,44 @@ impl Socket {\n     }\n \n     pub fn duplicate(&self) -> io::Result<Socket> {\n-        use libc::funcs::posix88::fcntl::fcntl;\n+        // We want to atomically duplicate this file descriptor and set the\n+        // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n+        // flag, however, isn't supported on older Linux kernels (earlier than\n+        // 2.6.24).\n+        //\n+        // To detect this and ensure that CLOEXEC is still set, we\n+        // follow a strategy similar to musl [1] where if passing\n+        // F_DUPFD_CLOEXEC causes `fcntl` to return EINVAL it means it's not\n+        // supported (the third parameter, 0, is always valid), so we stop\n+        // trying that. We also *still* call the `set_cloexec` method as\n+        // apparently some kernel at some point stopped setting CLOEXEC even\n+        // though it reported doing so on F_DUPFD_CLOEXEC.\n+        //\n+        // Also note that Android doesn't have F_DUPFD_CLOEXEC, but get it to\n+        // resolve so we at least compile this.\n+        //\n+        // [1]: http://comments.gmane.org/gmane.linux.lib.musl.general/2963\n+        #[cfg(target_os = \"android\")]\n+        use libc::F_DUPFD as F_DUPFD_CLOEXEC;\n+        #[cfg(not(target_os = \"android\"))]\n+        use libc::F_DUPFD_CLOEXEC;\n+\n         let make_socket = |fd| {\n             let fd = FileDesc::new(fd);\n             fd.set_cloexec();\n             Socket(fd)\n         };\n-        static EMULATE_F_DUPFD_CLOEXEC: AtomicBool = AtomicBool::new(false);\n-        if !EMULATE_F_DUPFD_CLOEXEC.load(atomic::Ordering::Relaxed) {\n-            match cvt(unsafe { fcntl(self.0.raw(), libc::F_DUPFD_CLOEXEC, 0) }) {\n-                // `EINVAL` can only be returned on two occasions: Invalid\n-                // command (second parameter) or invalid third parameter. 0 is\n-                // always a valid third parameter, so it must be the second\n-                // parameter.\n-                //\n-                // Store the result in a global variable so we don't try each\n-                // syscall twice.\n+        static TRY_CLOEXEC: AtomicBool = AtomicBool::new(true);\n+        let fd = self.0.raw();\n+        if !cfg!(target_os = \"android\") && TRY_CLOEXEC.load(Ordering::Relaxed) {\n+            match cvt(unsafe { libc::fcntl(fd, F_DUPFD_CLOEXEC, 0) }) {\n                 Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {\n-                    EMULATE_F_DUPFD_CLOEXEC.store(true, atomic::Ordering::Relaxed);\n+                    TRY_CLOEXEC.store(false, Ordering::Relaxed);\n                 }\n                 res => return res.map(make_socket),\n             }\n         }\n-        cvt(unsafe { fcntl(self.0.raw(), libc::F_DUPFD, 0) }).map(make_socket)\n+        cvt(unsafe { libc::fcntl(fd, libc::F_DUPFD, 0) }).map(make_socket)\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -138,6 +153,16 @@ impl Socket {\n             Ok(Some(Duration::new(sec, nsec)))\n         }\n     }\n+\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        let how = match how {\n+            Shutdown::Write => libc::SHUT_WR,\n+            Shutdown::Read => libc::SHUT_RD,\n+            Shutdown::Both => libc::SHUT_RDWR,\n+        };\n+        try!(cvt(unsafe { libc::shutdown(self.0.raw(), how) }));\n+        Ok(())\n+    }\n }\n \n impl AsInner<c_int> for Socket {"}, {"sha": "3c53db53f85f19e29e10da1fa2b05fccb4a5f96f", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -27,9 +27,8 @@ use ptr;\n use slice;\n use str;\n use sync::StaticMutex;\n-use sys::c;\n-use sys::fd;\n use sys::cvt;\n+use sys::fd;\n use vec;\n \n const TMPBUF_SZ: usize = 128;\n@@ -230,8 +229,11 @@ pub fn current_exe() -> io::Result<PathBuf> {\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n+    extern {\n+        fn _NSGetExecutablePath(buf: *mut libc::c_char,\n+                                bufsize: *mut u32) -> libc::c_int;\n+    }\n     unsafe {\n-        use libc::funcs::extra::_NSGetExecutablePath;\n         let mut sz: u32 = 0;\n         _NSGetExecutablePath(ptr::null_mut(), &mut sz);\n         if sz == 0 { return Err(io::Error::last_os_error()); }\n@@ -425,15 +427,15 @@ pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n     let v = try!(CString::new(v.as_bytes()));\n     let _g = ENV_LOCK.lock();\n     cvt(unsafe {\n-        libc::funcs::posix01::unistd::setenv(k.as_ptr(), v.as_ptr(), 1)\n+        libc::setenv(k.as_ptr(), v.as_ptr(), 1)\n     }).map(|_| ())\n }\n \n pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     let nbuf = try!(CString::new(n.as_bytes()));\n     let _g = ENV_LOCK.lock();\n     cvt(unsafe {\n-        libc::funcs::posix01::unistd::unsetenv(nbuf.as_ptr())\n+        libc::unsetenv(nbuf.as_ptr())\n     }).map(|_| ())\n }\n \n@@ -466,18 +468,18 @@ pub fn home_dir() -> Option<PathBuf> {\n                   target_os = \"ios\",\n                   target_os = \"nacl\")))]\n     unsafe fn fallback() -> Option<OsString> {\n-        let amt = match libc::sysconf(c::_SC_GETPW_R_SIZE_MAX) {\n+        let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {\n             n if n < 0 => 512 as usize,\n             n => n as usize,\n         };\n         let me = libc::getuid();\n         loop {\n             let mut buf = Vec::with_capacity(amt);\n-            let mut passwd: c::passwd = mem::zeroed();\n+            let mut passwd: libc::passwd = mem::zeroed();\n             let mut result = ptr::null_mut();\n-            match c::getpwuid_r(me, &mut passwd, buf.as_mut_ptr(),\n-                                buf.capacity() as libc::size_t,\n-                                &mut result) {\n+            match libc::getpwuid_r(me, &mut passwd, buf.as_mut_ptr(),\n+                                   buf.capacity() as libc::size_t,\n+                                   &mut result) {\n                 0 if !result.is_null() => {}\n                 _ => return None\n             }"}, {"sha": "8d80296ab035afaf54b87762e9248639745a77f1", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -23,7 +23,7 @@ use ptr;\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n use sys::pipe::AnonPipe;\n-use sys::{self, c, cvt, cvt_r};\n+use sys::{self, cvt, cvt_r};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -163,7 +163,7 @@ const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n \n impl Process {\n     pub unsafe fn kill(&self) -> io::Result<()> {\n-        try!(cvt(libc::funcs::posix88::signal::kill(self.pid, libc::SIGKILL)));\n+        try!(cvt(libc::kill(self.pid, libc::SIGKILL)));\n         Ok(())\n     }\n \n@@ -326,7 +326,7 @@ impl Process {\n             // fail if we aren't root, so don't bother checking the\n             // return value, this is just done as an optimistic\n             // privilege dropping function.\n-            let _ = c::setgroups(0, ptr::null());\n+            let _ = libc::setgroups(0, ptr::null());\n \n             if libc::setuid(u as libc::uid_t) != 0 {\n                 fail(&mut output);\n@@ -355,12 +355,12 @@ impl Process {\n             // UNIX programs do not reset these things on their own, so we\n             // need to clean things up now to avoid confusing the program\n             // we're about to run.\n-            let mut set: c::sigset_t = mem::uninitialized();\n-            if c::sigemptyset(&mut set) != 0 ||\n-                c::pthread_sigmask(c::SIG_SETMASK, &set, ptr::null_mut()) != 0 ||\n-                libc::funcs::posix01::signal::signal(\n-                    libc::SIGPIPE, mem::transmute(c::SIG_DFL)\n-                        ) == mem::transmute(c::SIG_ERR)\n+            let mut set: libc::sigset_t = mem::uninitialized();\n+            if libc::sigemptyset(&mut set) != 0 ||\n+                libc::pthread_sigmask(libc::SIG_SETMASK, &set, ptr::null_mut()) != 0 ||\n+                libc::signal(\n+                    libc::SIGPIPE, mem::transmute(libc::SIG_DFL)\n+                        ) == mem::transmute(libc::SIG_ERR)\n             {\n                 fail(output);\n             }\n@@ -381,14 +381,14 @@ impl Process {\n \n     pub fn wait(&self) -> io::Result<ExitStatus> {\n         let mut status = 0 as c_int;\n-        try!(cvt_r(|| unsafe { c::waitpid(self.pid, &mut status, 0) }));\n+        try!(cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) }));\n         Ok(ExitStatus(status))\n     }\n \n     pub fn try_wait(&self) -> Option<ExitStatus> {\n         let mut status = 0 as c_int;\n         match cvt_r(|| unsafe {\n-            c::waitpid(self.pid, &mut status, c::WNOHANG)\n+            libc::waitpid(self.pid, &mut status, libc::WNOHANG)\n         }) {\n             Ok(0) => None,\n             Ok(n) if n == self.pid => Some(ExitStatus(status)),\n@@ -459,7 +459,7 @@ mod tests {\n     use ptr;\n     use libc;\n     use slice;\n-    use sys::{self, c, cvt, pipe};\n+    use sys::{self, cvt, pipe};\n \n     macro_rules! t {\n         ($e:expr) => {\n@@ -473,12 +473,12 @@ mod tests {\n     #[cfg(not(target_os = \"android\"))]\n     extern {\n         #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaddset14\")]\n-        fn sigaddset(set: *mut c::sigset_t, signum: libc::c_int) -> libc::c_int;\n+        fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;\n     }\n \n     #[cfg(target_os = \"android\")]\n-    unsafe fn sigaddset(set: *mut c::sigset_t, signum: libc::c_int) -> libc::c_int {\n-        let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<c::sigset_t>());\n+    unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n+        let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n         let bit = (signum - 1) as usize;\n         raw[bit / 8] |= 1 << (bit % 8);\n         return 0;\n@@ -497,23 +497,22 @@ mod tests {\n             let (stdin_read, stdin_write) = t!(sys::pipe::anon_pipe());\n             let (stdout_read, stdout_write) = t!(sys::pipe::anon_pipe());\n \n-            let mut set: c::sigset_t = mem::uninitialized();\n-            let mut old_set: c::sigset_t = mem::uninitialized();\n-            t!(cvt(c::sigemptyset(&mut set)));\n+            let mut set: libc::sigset_t = mem::uninitialized();\n+            let mut old_set: libc::sigset_t = mem::uninitialized();\n+            t!(cvt(libc::sigemptyset(&mut set)));\n             t!(cvt(sigaddset(&mut set, libc::SIGINT)));\n-            t!(cvt(c::pthread_sigmask(c::SIG_SETMASK, &set, &mut old_set)));\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set, &mut old_set)));\n \n             let cat = t!(Process::spawn(&cmd, Stdio::Raw(stdin_read.raw()),\n                                               Stdio::Raw(stdout_write.raw()),\n                                               Stdio::None));\n             drop(stdin_read);\n             drop(stdout_write);\n \n-            t!(cvt(c::pthread_sigmask(c::SIG_SETMASK, &old_set,\n-                                      ptr::null_mut())));\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &old_set,\n+                                         ptr::null_mut())));\n \n-            t!(cvt(libc::funcs::posix88::signal::kill(cat.id() as libc::pid_t,\n-                                                      libc::SIGINT)));\n+            t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n             // We need to wait until SIGINT is definitely delivered. The\n             // easiest way is to write something to cat, and try to read it\n             // back: if SIGINT is unmasked, it'll get delivered when cat is"}, {"sha": "44bd5d895f2e4373af64e753349c799b193be556", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -10,20 +10,19 @@\n \n use libc;\n use cell::UnsafeCell;\n-use sys::sync as ffi;\n \n-pub struct RWLock { inner: UnsafeCell<ffi::pthread_rwlock_t> }\n+pub struct RWLock { inner: UnsafeCell<libc::pthread_rwlock_t> }\n \n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n impl RWLock {\n     pub const fn new() -> RWLock {\n-        RWLock { inner: UnsafeCell::new(ffi::PTHREAD_RWLOCK_INITIALIZER) }\n+        RWLock { inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER) }\n     }\n     #[inline]\n     pub unsafe fn read(&self) {\n-        let r = ffi::pthread_rwlock_rdlock(self.inner.get());\n+        let r = libc::pthread_rwlock_rdlock(self.inner.get());\n \n         // According to the pthread_rwlock_rdlock spec, this function **may**\n         // fail with EDEADLK if a deadlock is detected. On the other hand\n@@ -44,11 +43,11 @@ impl RWLock {\n     }\n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n-        ffi::pthread_rwlock_tryrdlock(self.inner.get()) == 0\n+        libc::pthread_rwlock_tryrdlock(self.inner.get()) == 0\n     }\n     #[inline]\n     pub unsafe fn write(&self) {\n-        let r = ffi::pthread_rwlock_wrlock(self.inner.get());\n+        let r = libc::pthread_rwlock_wrlock(self.inner.get());\n         // see comments above for why we check for EDEADLK\n         if r == libc::EDEADLK {\n             panic!(\"rwlock write lock would result in deadlock\");\n@@ -58,21 +57,21 @@ impl RWLock {\n     }\n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n-        ffi::pthread_rwlock_trywrlock(self.inner.get()) == 0\n+        libc::pthread_rwlock_trywrlock(self.inner.get()) == 0\n     }\n     #[inline]\n     pub unsafe fn read_unlock(&self) {\n-        let r = ffi::pthread_rwlock_unlock(self.inner.get());\n+        let r = libc::pthread_rwlock_unlock(self.inner.get());\n         debug_assert_eq!(r, 0);\n     }\n     #[inline]\n     pub unsafe fn write_unlock(&self) { self.read_unlock() }\n     #[inline]\n     pub unsafe fn destroy(&self) {\n-        let r = ffi::pthread_rwlock_destroy(self.inner.get());\n+        let r = libc::pthread_rwlock_destroy(self.inner.get());\n         // On DragonFly pthread_rwlock_destroy() returns EINVAL if called on a\n         // rwlock that was just initialized with\n-        // ffi::PTHREAD_RWLOCK_INITIALIZER. Once it is used (locked/unlocked)\n+        // libc::PTHREAD_RWLOCK_INITIALIZER. Once it is used (locked/unlocked)\n         // or pthread_rwlock_init() is called, this behaviour no longer occurs.\n         if cfg!(target_os = \"dragonfly\") {\n             debug_assert!(r == 0 || r == libc::EINVAL);"}, {"sha": "9a7f98d24cd5df733617cc416f13f7223e1e7aff", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -43,11 +43,11 @@ mod imp {\n     use sys_common::util::report_overflow;\n     use mem;\n     use ptr;\n-    use sys::c::{siginfo, sigaction, SIGBUS, SIG_DFL,\n-                 SA_SIGINFO, SA_ONSTACK, sigaltstack,\n-                 SIGSTKSZ, sighandler_t};\n+    use libc::{sigaction, SIGBUS, SIG_DFL,\n+               SA_SIGINFO, SA_ONSTACK, sigaltstack,\n+               SIGSTKSZ, sighandler_t};\n     use libc;\n-    use libc::funcs::posix88::mman::{mmap, munmap};\n+    use libc::{mmap, munmap};\n     use libc::{SIGSEGV, PROT_READ, PROT_WRITE, MAP_PRIVATE, MAP_ANON};\n     use libc::MAP_FAILED;\n \n@@ -57,6 +57,22 @@ mod imp {\n     // This is initialized in init() and only read from after\n     static mut PAGE_SIZE: usize = 0;\n \n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> *mut libc::c_void {\n+        #[repr(C)]\n+        struct siginfo_t {\n+            a: [libc::c_int; 3], // si_signo, si_code, si_errno,\n+            si_addr: *mut libc::c_void,\n+        }\n+\n+        (*(info as *const siginfo_t)).si_addr\n+    }\n+\n+    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> *mut libc::c_void {\n+        (*info).si_addr\n+    }\n+\n     // Signal handler for the SIGSEGV and SIGBUS handlers. We've got guard pages\n     // (unmapped pages) at the end of every thread's stack, so if a thread ends\n     // up running into the guard page it'll trigger this handler. We want to\n@@ -76,10 +92,10 @@ mod imp {\n     // handler to work. For a more detailed explanation see the comments on\n     // #26458.\n     unsafe extern fn signal_handler(signum: libc::c_int,\n-                                    info: *mut siginfo,\n+                                    info: *mut libc::siginfo_t,\n                                     _data: *mut libc::c_void) {\n         let guard = thread_info::stack_guard().unwrap_or(0);\n-        let addr = (*info).si_addr as usize;\n+        let addr = siginfo_si_addr(info) as usize;\n \n         // If the faulting address is within the guard page, then we print a\n         // message saying so.\n@@ -126,7 +142,7 @@ mod imp {\n             panic!(\"failed to allocate an alternative stack\");\n         }\n \n-        let mut stack: sigaltstack = mem::zeroed();\n+        let mut stack: libc::stack_t = mem::zeroed();\n \n         stack.ss_sp = alt_stack;\n         stack.ss_flags = 0;"}, {"sha": "6f6acc2560e0cb0a9c6c761f8c6bb6fccb0b472d", "filename": "src/libstd/sys/unix/sync.rs", "status": "removed", "additions": 0, "deletions": 374, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/c8a29c2092cec369a751051a2bfed093522ff6e8/src%2Flibstd%2Fsys%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a29c2092cec369a751051a2bfed093522ff6e8/src%2Flibstd%2Fsys%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fsync.rs?ref=c8a29c2092cec369a751051a2bfed093522ff6e8", "patch": "@@ -1,374 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(bad_style)]\n-\n-use libc;\n-\n-pub use self::os::{PTHREAD_MUTEX_INITIALIZER, PTHREAD_MUTEX_RECURSIVE, pthread_mutex_t,\n-                   pthread_mutexattr_t};\n-pub use self::os::{PTHREAD_COND_INITIALIZER, pthread_cond_t};\n-pub use self::os::{PTHREAD_RWLOCK_INITIALIZER, pthread_rwlock_t};\n-\n-extern {\n-    // mutexes\n-    pub fn pthread_mutex_init(lock: *mut pthread_mutex_t, attr: *const pthread_mutexattr_t)\n-                            -> libc::c_int;\n-    pub fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> libc::c_int;\n-    pub fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> libc::c_int;\n-    pub fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> libc::c_int;\n-    pub fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> libc::c_int;\n-\n-    pub fn pthread_mutexattr_init(attr: *mut pthread_mutexattr_t) -> libc::c_int;\n-    pub fn pthread_mutexattr_destroy(attr: *mut pthread_mutexattr_t) -> libc::c_int;\n-    pub fn pthread_mutexattr_settype(attr: *mut pthread_mutexattr_t, _type: libc::c_int)\n-                                    -> libc::c_int;\n-\n-    // cvars\n-    pub fn pthread_cond_wait(cond: *mut pthread_cond_t,\n-                             lock: *mut pthread_mutex_t) -> libc::c_int;\n-    #[cfg_attr(target_os = \"nacl\", link_name = \"pthread_cond_timedwait_abs\")]\n-    pub fn pthread_cond_timedwait(cond: *mut pthread_cond_t,\n-                              lock: *mut pthread_mutex_t,\n-                              abstime: *const libc::timespec) -> libc::c_int;\n-    pub fn pthread_cond_signal(cond: *mut pthread_cond_t) -> libc::c_int;\n-    pub fn pthread_cond_broadcast(cond: *mut pthread_cond_t) -> libc::c_int;\n-    pub fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> libc::c_int;\n-    #[cfg_attr(target_os = \"netbsd\", link_name = \"__gettimeofday50\")]\n-    pub fn gettimeofday(tp: *mut libc::timeval,\n-                        tz: *mut libc::c_void) -> libc::c_int;\n-\n-    // rwlocks\n-    pub fn pthread_rwlock_destroy(lock: *mut pthread_rwlock_t) -> libc::c_int;\n-    pub fn pthread_rwlock_rdlock(lock: *mut pthread_rwlock_t) -> libc::c_int;\n-    pub fn pthread_rwlock_tryrdlock(lock: *mut pthread_rwlock_t) -> libc::c_int;\n-    pub fn pthread_rwlock_wrlock(lock: *mut pthread_rwlock_t) -> libc::c_int;\n-    pub fn pthread_rwlock_trywrlock(lock: *mut pthread_rwlock_t) -> libc::c_int;\n-    pub fn pthread_rwlock_unlock(lock: *mut pthread_rwlock_t) -> libc::c_int;\n-}\n-\n-#[cfg(any(target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"openbsd\"))]\n-mod os {\n-    use libc;\n-    use ptr;\n-\n-    pub type pthread_mutex_t = *mut libc::c_void;\n-    pub type pthread_mutexattr_t = *mut libc::c_void;\n-    pub type pthread_cond_t = *mut libc::c_void;\n-    pub type pthread_rwlock_t = *mut libc::c_void;\n-\n-    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = ptr::null_mut();\n-    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = ptr::null_mut();\n-    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = ptr::null_mut();\n-    pub const PTHREAD_MUTEX_RECURSIVE: libc::c_int = 2;\n-}\n-\n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-mod os {\n-    use libc;\n-\n-    #[cfg(any(target_arch = \"x86_64\",\n-              target_arch = \"aarch64\"))]\n-    const __PTHREAD_MUTEX_SIZE__: usize = 56;\n-    #[cfg(any(target_arch = \"x86\",\n-              target_arch = \"arm\"))]\n-    const __PTHREAD_MUTEX_SIZE__: usize = 40;\n-\n-    #[cfg(any(target_arch = \"x86_64\",\n-              target_arch = \"aarch64\"))]\n-    const __PTHREAD_COND_SIZE__: usize = 40;\n-    #[cfg(any(target_arch = \"x86\",\n-              target_arch = \"arm\"))]\n-    const __PTHREAD_COND_SIZE__: usize = 24;\n-\n-    #[cfg(any(target_arch = \"x86_64\",\n-              target_arch = \"aarch64\"))]\n-    const __PTHREAD_RWLOCK_SIZE__: usize = 192;\n-    #[cfg(any(target_arch = \"x86\",\n-              target_arch = \"arm\"))]\n-    const __PTHREAD_RWLOCK_SIZE__: usize = 124;\n-\n-    const _PTHREAD_MUTEX_SIG_INIT: libc::c_long = 0x32AAABA7;\n-    const _PTHREAD_COND_SIG_INIT: libc::c_long = 0x3CB0B1BB;\n-    const _PTHREAD_RWLOCK_SIG_INIT: libc::c_long = 0x2DA8B3B4;\n-\n-    #[repr(C)]\n-    pub struct pthread_mutex_t {\n-        __sig: libc::c_long,\n-        __opaque: [u8; __PTHREAD_MUTEX_SIZE__],\n-    }\n-    #[repr(C)]\n-    pub struct pthread_mutexattr_t {\n-        __sig: libc::c_long,\n-        // note, that this is 16 bytes just to be safe, the actual struct might be smaller.\n-        __opaque: [u8; 16],\n-    }\n-    #[repr(C)]\n-    pub struct pthread_cond_t {\n-        __sig: libc::c_long,\n-        __opaque: [u8; __PTHREAD_COND_SIZE__],\n-    }\n-    #[repr(C)]\n-    pub struct pthread_rwlock_t {\n-        __sig: libc::c_long,\n-        __opaque: [u8; __PTHREAD_RWLOCK_SIZE__],\n-    }\n-\n-    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n-        __sig: _PTHREAD_MUTEX_SIG_INIT,\n-        __opaque: [0; __PTHREAD_MUTEX_SIZE__],\n-    };\n-    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n-        __sig: _PTHREAD_COND_SIG_INIT,\n-        __opaque: [0; __PTHREAD_COND_SIZE__],\n-    };\n-    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n-        __sig: _PTHREAD_RWLOCK_SIG_INIT,\n-        __opaque: [0; __PTHREAD_RWLOCK_SIZE__],\n-    };\n-\n-    pub const PTHREAD_MUTEX_RECURSIVE: libc::c_int = 2;\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-mod os {\n-    use libc;\n-\n-    // minus 8 because we have an 'align' field\n-    #[cfg(target_arch = \"x86_64\")]\n-    const __SIZEOF_PTHREAD_MUTEX_T: usize = 40 - 8;\n-    #[cfg(any(target_arch = \"x86\",\n-              target_arch = \"arm\",\n-              target_arch = \"mips\",\n-              target_arch = \"mipsel\",\n-              target_arch = \"powerpc\"))]\n-    const __SIZEOF_PTHREAD_MUTEX_T: usize = 24 - 8;\n-    #[cfg(target_arch = \"aarch64\")]\n-    const __SIZEOF_PTHREAD_MUTEX_T: usize = 48 - 8;\n-\n-    #[cfg(any(target_arch = \"x86_64\",\n-              target_arch = \"x86\",\n-              target_arch = \"arm\",\n-              target_arch = \"aarch64\",\n-              target_arch = \"mips\",\n-              target_arch = \"mipsel\",\n-              target_arch = \"powerpc\"))]\n-    const __SIZEOF_PTHREAD_COND_T: usize = 48 - 8;\n-\n-    #[cfg(any(target_arch = \"x86_64\",\n-              target_arch = \"aarch64\"))]\n-    const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56 - 8;\n-\n-    #[cfg(any(target_arch = \"x86\",\n-              target_arch = \"arm\",\n-              target_arch = \"mips\",\n-              target_arch = \"mipsel\",\n-              target_arch = \"powerpc\"))]\n-    const __SIZEOF_PTHREAD_RWLOCK_T: usize = 32 - 8;\n-\n-    #[repr(C)]\n-    pub struct pthread_mutex_t {\n-        __align: libc::c_longlong,\n-        size: [u8; __SIZEOF_PTHREAD_MUTEX_T],\n-    }\n-    #[repr(C)]\n-    pub struct pthread_mutexattr_t {\n-        __align: libc::c_longlong,\n-        // note, that this is 16 bytes just to be safe, the actual struct might be smaller.\n-        size: [u8; 16],\n-    }\n-    #[repr(C)]\n-    pub struct pthread_cond_t {\n-        __align: libc::c_longlong,\n-        size: [u8; __SIZEOF_PTHREAD_COND_T],\n-    }\n-    #[repr(C)]\n-    pub struct pthread_rwlock_t {\n-        __align: libc::c_longlong,\n-        size: [u8; __SIZEOF_PTHREAD_RWLOCK_T],\n-    }\n-\n-    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n-        __align: 0,\n-        size: [0; __SIZEOF_PTHREAD_MUTEX_T],\n-    };\n-    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n-        __align: 0,\n-        size: [0; __SIZEOF_PTHREAD_COND_T],\n-    };\n-    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n-        __align: 0,\n-        size: [0; __SIZEOF_PTHREAD_RWLOCK_T],\n-    };\n-    pub const PTHREAD_MUTEX_RECURSIVE: libc::c_int = 1;\n-}\n-#[cfg(target_os = \"android\")]\n-mod os {\n-    use libc;\n-    use ptr;\n-\n-    #[repr(C)]\n-    pub struct pthread_mutex_t { value: libc::c_int }\n-    pub type pthread_mutexattr_t = libc::c_long;\n-    #[repr(C)]\n-    pub struct pthread_cond_t { value: libc::c_int }\n-    #[repr(C)]\n-    pub struct pthread_rwlock_t {\n-        lock: pthread_mutex_t,\n-        cond: pthread_cond_t,\n-        numLocks: libc::c_int,\n-        writerThreadId: libc::c_int,\n-        pendingReaders: libc::c_int,\n-        pendingWriters: libc::c_int,\n-        reserved: [*mut libc::c_void; 4],\n-    }\n-\n-    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n-        value: 0,\n-    };\n-    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n-        value: 0,\n-    };\n-    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n-        lock: PTHREAD_MUTEX_INITIALIZER,\n-        cond: PTHREAD_COND_INITIALIZER,\n-        numLocks: 0,\n-        writerThreadId: 0,\n-        pendingReaders: 0,\n-        pendingWriters: 0,\n-        reserved: [ptr::null_mut(); 4],\n-    };\n-    pub const PTHREAD_MUTEX_RECURSIVE: libc::c_int = 1;\n-}\n-\n-#[cfg(target_os = \"netbsd\")]\n-mod os {\n-    use libc;\n-\n-    // size of the type minus width of the magic and alignment field\n-    #[cfg(target_arch = \"x86_64\")]\n-    const __PTHREAD_MUTEX_SIZE__: usize = 48 - 4 - 8;\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    const __PTHREAD_MUTEXATTR_SIZE__: usize = 16 - 8; // no magic field\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    const __PTHREAD_COND_SIZE__: usize = 40 - 4 - 8;\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    const __PTHREAD_RWLOCK_SIZE__: usize = 64 - 4 - 8;\n-\n-    const _PTHREAD_MUTEX_MAGIC_INIT: libc::c_uint = 0x33330003;\n-    const _PTHREAD_COND_MAGIC_INIT: libc::c_uint = 0x55550005;\n-    const _PTHREAD_RWLOCK_MAGIC_INIT: libc::c_uint = 0x99990009;\n-\n-    #[repr(C)]\n-    pub struct pthread_mutex_t {\n-        __magic: libc::c_uint,\n-        __opaque: [u8; __PTHREAD_MUTEX_SIZE__],\n-        __align: libc::c_longlong,\n-    }\n-    #[repr(C)]\n-    pub struct pthread_mutexattr_t {\n-        __opaque: [u8; __PTHREAD_MUTEXATTR_SIZE__],\n-        __align: libc::c_longlong,\n-    }\n-    #[repr(C)]\n-    pub struct pthread_cond_t {\n-        __magic: libc::c_uint,\n-        __opaque: [u8; __PTHREAD_COND_SIZE__],\n-        __align: libc::c_longlong,\n-    }\n-    #[repr(C)]\n-    pub struct pthread_rwlock_t {\n-        __magic: libc::c_uint,\n-        __opaque: [u8; __PTHREAD_RWLOCK_SIZE__],\n-        __align: libc::c_longlong,\n-    }\n-\n-    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n-        __magic: _PTHREAD_MUTEX_MAGIC_INIT,\n-        __opaque: [0; __PTHREAD_MUTEX_SIZE__],\n-        __align: 0,\n-    };\n-    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n-        __magic: _PTHREAD_COND_MAGIC_INIT,\n-        __opaque: [0; __PTHREAD_COND_SIZE__],\n-        __align: 0,\n-    };\n-    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n-        __magic: _PTHREAD_RWLOCK_MAGIC_INIT,\n-        __opaque: [0; __PTHREAD_RWLOCK_SIZE__],\n-        __align: 0,\n-    };\n-\n-    pub const PTHREAD_MUTEX_RECURSIVE: libc::c_int = 2;\n-}\n-#[cfg(target_os = \"nacl\")]\n-mod os {\n-    use libc;\n-\n-    pub type __nc_basic_thread_data = libc::c_void;\n-\n-    #[repr(C)]\n-    pub struct pthread_mutex_t {\n-        mutex_state: libc::c_int,\n-        mutex_type: libc::c_int,\n-        owner_thread_id: *mut __nc_basic_thread_data,\n-        recursion_counter: libc::uint32_t,\n-        _unused: libc::c_int,\n-    }\n-    #[repr(C)]\n-    pub struct pthread_mutexattr_t {\n-        kind: libc::c_int,\n-    }\n-    #[repr(C)]\n-    pub struct pthread_cond_t {\n-        sequence_number: libc::c_int,\n-        _unused: libc::c_int,\n-    }\n-    #[repr(C)]\n-    pub struct pthread_rwlock_t {\n-        mutex: pthread_mutex_t,\n-        reader_count: libc::c_int,\n-        writers_waiting: libc::c_int,\n-        writer_thread_id: *mut __nc_basic_thread_data,\n-        read_possible: pthread_cond_t,\n-        write_possible: pthread_cond_t,\n-    }\n-\n-    const NC_INVALID_HANDLE: libc::c_int = -1;\n-    const NACL_PTHREAD_ILLEGAL_THREAD_ID: *mut __nc_basic_thread_data\n-        = 0 as *mut __nc_basic_thread_data;\n-\n-    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n-        mutex_state:       0,\n-        mutex_type:        0,\n-        owner_thread_id:   NACL_PTHREAD_ILLEGAL_THREAD_ID,\n-        recursion_counter: 0,\n-        _unused:           NC_INVALID_HANDLE,\n-    };\n-    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n-        sequence_number: 0,\n-        _unused: NC_INVALID_HANDLE,\n-    };\n-    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n-        mutex: PTHREAD_MUTEX_INITIALIZER,\n-        reader_count: 0,\n-        writers_waiting: 0,\n-        writer_thread_id: NACL_PTHREAD_ILLEGAL_THREAD_ID,\n-        read_possible: PTHREAD_COND_INITIALIZER,\n-        write_possible: PTHREAD_COND_INITIALIZER,\n-    };\n-    pub const PTHREAD_MUTEX_RECURSIVE: libc::c_int = 1;\n-}"}, {"sha": "f111f97be60a049184c82d8c24aba0daeb4ad505", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 38, "deletions": 105, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -17,7 +17,7 @@ use cmp;\n #[cfg(not(target_env = \"newlib\"))]\n use ffi::CString;\n use io;\n-use libc::consts::os::posix01::PTHREAD_STACK_MIN;\n+use libc::PTHREAD_STACK_MIN;\n use libc;\n use mem;\n use ptr;\n@@ -41,10 +41,11 @@ impl Thread {\n         let p = box p;\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n-        assert_eq!(pthread_attr_init(&mut attr), 0);\n+        assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n \n         let stack_size = cmp::max(stack, min_stack_size(&attr));\n-        match pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t) {\n+        match libc::pthread_attr_setstacksize(&mut attr,\n+                                              stack_size as libc::size_t) {\n             0 => {}\n             n => {\n                 assert_eq!(n, libc::EINVAL);\n@@ -56,13 +57,14 @@ impl Thread {\n                 let stack_size = (stack_size + page_size - 1) &\n                                  (-(page_size as isize - 1) as usize - 1);\n                 let stack_size = stack_size as libc::size_t;\n-                assert_eq!(pthread_attr_setstacksize(&mut attr, stack_size), 0);\n+                assert_eq!(libc::pthread_attr_setstacksize(&mut attr,\n+                                                           stack_size), 0);\n             }\n         };\n \n-        let ret = pthread_create(&mut native, &attr, thread_start,\n-                                 &*p as *const _ as *mut _);\n-        assert_eq!(pthread_attr_destroy(&mut attr), 0);\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start,\n+                                       &*p as *const _ as *mut _);\n+        assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n             Err(io::Error::from_raw_os_error(ret))\n@@ -78,25 +80,20 @@ impl Thread {\n     }\n \n     pub fn yield_now() {\n-        let ret = unsafe { sched_yield() };\n+        let ret = unsafe { libc::sched_yield() };\n         debug_assert_eq!(ret, 0);\n     }\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     pub fn set_name(name: &str) {\n-        // pthread wrapper only appeared in glibc 2.12, so we use syscall\n-        // directly.\n-        extern {\n-            fn prctl(option: libc::c_int, arg2: libc::c_ulong,\n-                     arg3: libc::c_ulong, arg4: libc::c_ulong,\n-                     arg5: libc::c_ulong) -> libc::c_int;\n-        }\n         const PR_SET_NAME: libc::c_int = 15;\n         let cname = CString::new(name).unwrap_or_else(|_| {\n             panic!(\"thread name may not contain interior null bytes\")\n         });\n+        // pthread wrapper only appeared in glibc 2.12, so we use syscall\n+        // directly.\n         unsafe {\n-            prctl(PR_SET_NAME, cname.as_ptr() as libc::c_ulong, 0, 0, 0);\n+            libc::prctl(PR_SET_NAME, cname.as_ptr() as libc::c_ulong, 0, 0, 0);\n         }\n     }\n \n@@ -105,39 +102,27 @@ impl Thread {\n               target_os = \"bitrig\",\n               target_os = \"openbsd\"))]\n     pub fn set_name(name: &str) {\n-        extern {\n-            fn pthread_set_name_np(tid: libc::pthread_t,\n-                                   name: *const libc::c_char);\n-        }\n         let cname = CString::new(name).unwrap();\n         unsafe {\n-            pthread_set_name_np(pthread_self(), cname.as_ptr());\n+            libc::pthread_set_name_np(libc::pthread_self(), cname.as_ptr());\n         }\n     }\n \n     #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n     pub fn set_name(name: &str) {\n-        extern {\n-            fn pthread_setname_np(name: *const libc::c_char) -> libc::c_int;\n-        }\n         let cname = CString::new(name).unwrap();\n         unsafe {\n-            pthread_setname_np(cname.as_ptr());\n+            libc::pthread_setname_np(cname.as_ptr());\n         }\n     }\n \n     #[cfg(target_os = \"netbsd\")]\n     pub fn set_name(name: &str) {\n-        extern {\n-            fn pthread_setname_np(thread: libc::pthread_t,\n-                                  name: *const libc::c_char,\n-                                  arg: *mut libc::c_void) -> libc::c_int;\n-        }\n         let cname = CString::new(&b\"%s\"[..]).unwrap();\n         let carg = CString::new(name).unwrap();\n         unsafe {\n-            pthread_setname_np(pthread_self(), cname.as_ptr(),\n-                               carg.as_ptr() as *mut libc::c_void);\n+            libc::pthread_setname_np(libc::pthread_self(), cname.as_ptr(),\n+                                     carg.as_ptr() as *mut libc::c_void);\n         }\n     }\n     #[cfg(target_env = \"newlib\")]\n@@ -162,7 +147,7 @@ impl Thread {\n \n     pub fn join(self) {\n         unsafe {\n-            let ret = pthread_join(self.id, ptr::null_mut());\n+            let ret = libc::pthread_join(self.id, ptr::null_mut());\n             mem::forget(self);\n             debug_assert_eq!(ret, 0);\n         }\n@@ -171,7 +156,7 @@ impl Thread {\n \n impl Drop for Thread {\n     fn drop(&mut self) {\n-        let ret = unsafe { pthread_detach(self.id) };\n+        let ret = unsafe { libc::pthread_detach(self.id) };\n         debug_assert_eq!(ret, 0);\n     }\n }\n@@ -197,15 +182,10 @@ pub mod guard {\n     use prelude::v1::*;\n \n     use libc::{self, pthread_t};\n-    use libc::funcs::posix88::mman::mmap;\n-    use libc::consts::os::posix88::{PROT_NONE,\n-                                    MAP_PRIVATE,\n-                                    MAP_ANON,\n-                                    MAP_FAILED,\n-                                    MAP_FIXED};\n+    use libc::mmap;\n+    use libc::{PROT_NONE, MAP_PRIVATE, MAP_ANON, MAP_FAILED, MAP_FIXED};\n     use mem;\n     use ptr;\n-    use super::{pthread_self, pthread_attr_destroy};\n     use sys::os;\n \n     #[cfg(any(target_os = \"macos\",\n@@ -217,19 +197,17 @@ pub mod guard {\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\", target_os = \"netbsd\"))]\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n-        use super::pthread_attr_init;\n-\n         let mut ret = None;\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n-        assert_eq!(pthread_attr_init(&mut attr), 0);\n-        if pthread_getattr_np(pthread_self(), &mut attr) == 0 {\n+        assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n+        if libc::pthread_getattr_np(libc::pthread_self(), &mut attr) == 0 {\n             let mut stackaddr = ptr::null_mut();\n             let mut stacksize = 0;\n-            assert_eq!(pthread_attr_getstack(&attr, &mut stackaddr,\n-                                             &mut stacksize), 0);\n+            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr,\n+                                                   &mut stacksize), 0);\n             ret = Some(stackaddr);\n         }\n-        assert_eq!(pthread_attr_destroy(&mut attr), 0);\n+        assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n         ret\n     }\n \n@@ -273,33 +251,18 @@ pub mod guard {\n \n     #[cfg(target_os = \"macos\")]\n     pub unsafe fn current() -> Option<usize> {\n-        extern {\n-            fn pthread_get_stackaddr_np(thread: pthread_t) -> *mut libc::c_void;\n-            fn pthread_get_stacksize_np(thread: pthread_t) -> libc::size_t;\n-        }\n-        Some((pthread_get_stackaddr_np(pthread_self()) as libc::size_t -\n-              pthread_get_stacksize_np(pthread_self())) as usize)\n+        Some((libc::pthread_get_stackaddr_np(libc::pthread_self()) as libc::size_t -\n+              libc::pthread_get_stacksize_np(libc::pthread_self())) as usize)\n     }\n \n     #[cfg(any(target_os = \"openbsd\", target_os = \"bitrig\"))]\n     pub unsafe fn current() -> Option<usize> {\n-        #[repr(C)]\n-        struct stack_t {\n-            ss_sp: *mut libc::c_void,\n-            ss_size: libc::size_t,\n-            ss_flags: libc::c_int,\n-        }\n-        extern {\n-            fn pthread_main_np() -> libc::c_uint;\n-            fn pthread_stackseg_np(thread: pthread_t,\n-                                   sinfo: *mut stack_t) -> libc::c_uint;\n-        }\n-\n-        let mut current_stack: stack_t = mem::zeroed();\n-        assert_eq!(pthread_stackseg_np(pthread_self(), &mut current_stack), 0);\n+        let mut current_stack: libc::stack_t = mem::zeroed();\n+        assert_eq!(libc::pthread_stackseg_np(libc::pthread_self(),\n+                                             &mut current_stack), 0);\n \n         let extra = if cfg!(target_os = \"bitrig\") {3} else {1} * os::page_size();\n-        Some(if pthread_main_np() == 1 {\n+        Some(if libc::pthread_main_np() == 1 {\n             // main thread\n             current_stack.ss_sp as usize - current_stack.ss_size as usize + extra\n         } else {\n@@ -310,41 +273,29 @@ pub mod guard {\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\", target_os = \"netbsd\"))]\n     pub unsafe fn current() -> Option<usize> {\n-        use super::pthread_attr_init;\n-\n         let mut ret = None;\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n-        assert_eq!(pthread_attr_init(&mut attr), 0);\n-        if pthread_getattr_np(pthread_self(), &mut attr) == 0 {\n+        assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n+        if libc::pthread_getattr_np(libc::pthread_self(), &mut attr) == 0 {\n             let mut guardsize = 0;\n-            assert_eq!(pthread_attr_getguardsize(&attr, &mut guardsize), 0);\n+            assert_eq!(libc::pthread_attr_getguardsize(&attr, &mut guardsize), 0);\n             if guardsize == 0 {\n                 panic!(\"there is no guard page\");\n             }\n             let mut stackaddr = ptr::null_mut();\n             let mut size = 0;\n-            assert_eq!(pthread_attr_getstack(&attr, &mut stackaddr, &mut size), 0);\n+            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr,\n+                                                   &mut size), 0);\n \n             ret = if cfg!(target_os = \"netbsd\") {\n                 Some(stackaddr as usize)\n             } else {\n                 Some(stackaddr as usize + guardsize as usize)\n             };\n         }\n-        assert_eq!(pthread_attr_destroy(&mut attr), 0);\n+        assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n         ret\n     }\n-\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\", target_os = \"netbsd\"))]\n-    extern {\n-        fn pthread_getattr_np(native: libc::pthread_t,\n-                              attr: *mut libc::pthread_attr_t) -> libc::c_int;\n-        fn pthread_attr_getguardsize(attr: *const libc::pthread_attr_t,\n-                                     guardsize: *mut libc::size_t) -> libc::c_int;\n-        fn pthread_attr_getstack(attr: *const libc::pthread_attr_t,\n-                                 stackaddr: *mut *mut libc::c_void,\n-                                 stacksize: *mut libc::size_t) -> libc::c_int;\n-    }\n }\n \n // glibc >= 2.15 has a __pthread_get_minstack() function that returns\n@@ -394,21 +345,3 @@ fn min_stack_size(attr: *const libc::pthread_attr_t) -> usize {\n fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n     PTHREAD_STACK_MIN as usize\n }\n-\n-extern {\n-    fn pthread_self() -> libc::pthread_t;\n-    fn pthread_create(native: *mut libc::pthread_t,\n-                      attr: *const libc::pthread_attr_t,\n-                      f: extern fn(*mut libc::c_void) -> *mut libc::c_void,\n-                      value: *mut libc::c_void) -> libc::c_int;\n-    fn pthread_join(native: libc::pthread_t,\n-                    value: *mut *mut libc::c_void) -> libc::c_int;\n-    fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n-    fn pthread_attr_destroy(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n-    fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n-                                 stack_size: libc::size_t) -> libc::c_int;\n-    fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,\n-                                   state: libc::c_int) -> libc::c_int;\n-    fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;\n-    fn sched_yield() -> libc::c_int;\n-}"}, {"sha": "d22118d4d793edf41e02e1dd2a3b94edc96b0ae7", "filename": "src/libstd/sys/unix/thread_local.rs", "status": "modified", "additions": 8, "deletions": 37, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -8,62 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(dead_code)] // sys isn't exported yet\n+#![allow(dead_code)] // not used on all platforms\n \n-use libc::c_int;\n+use mem;\n+use libc;\n \n-pub type Key = pthread_key_t;\n+pub type Key = libc::pthread_key_t;\n \n #[inline]\n pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n     let mut key = 0;\n-    assert_eq!(pthread_key_create(&mut key, dtor), 0);\n+    assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n     key\n }\n \n #[inline]\n pub unsafe fn set(key: Key, value: *mut u8) {\n-    let r = pthread_setspecific(key, value);\n+    let r = libc::pthread_setspecific(key, value as *mut _);\n     debug_assert_eq!(r, 0);\n }\n \n #[inline]\n pub unsafe fn get(key: Key) -> *mut u8 {\n-    pthread_getspecific(key)\n+    libc::pthread_getspecific(key) as *mut u8\n }\n \n #[inline]\n pub unsafe fn destroy(key: Key) {\n-    let r = pthread_key_delete(key);\n+    let r = libc::pthread_key_delete(key);\n     debug_assert_eq!(r, 0);\n }\n-\n-#[cfg(any(target_os = \"macos\",\n-          target_os = \"ios\"))]\n-type pthread_key_t = ::libc::c_ulong;\n-\n-#[cfg(any(target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"netbsd\",\n-          target_os = \"openbsd\",\n-          target_os = \"nacl\"))]\n-type pthread_key_t = ::libc::c_int;\n-\n-#[cfg(not(any(target_os = \"macos\",\n-              target_os = \"ios\",\n-              target_os = \"freebsd\",\n-              target_os = \"dragonfly\",\n-              target_os = \"bitrig\",\n-              target_os = \"netbsd\",\n-              target_os = \"openbsd\",\n-              target_os = \"nacl\")))]\n-type pthread_key_t = ::libc::c_uint;\n-\n-extern {\n-    fn pthread_key_create(key: *mut pthread_key_t,\n-                          dtor: Option<unsafe extern fn(*mut u8)>) -> c_int;\n-    fn pthread_key_delete(key: pthread_key_t) -> c_int;\n-    fn pthread_getspecific(key: pthread_key_t) -> *mut u8;\n-    fn pthread_setspecific(key: pthread_key_t, value: *mut u8) -> c_int;\n-}"}, {"sha": "5192f01269d0cf1b5ab9df91503b1fae9bd0d0f9", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -24,15 +24,10 @@ mod inner {\n         t: u64\n     }\n \n-    extern {\n-        pub fn mach_absolute_time() -> u64;\n-        pub fn mach_timebase_info(info: *mut libc::mach_timebase_info) -> libc::c_int;\n-    }\n-\n     impl SteadyTime {\n         pub fn now() -> SteadyTime {\n             SteadyTime {\n-                t: unsafe { mach_absolute_time() },\n+                t: unsafe { libc::mach_absolute_time() },\n             }\n         }\n     }\n@@ -46,7 +41,7 @@ mod inner {\n \n         unsafe {\n             ONCE.call_once(|| {\n-                mach_timebase_info(&mut INFO);\n+                libc::mach_timebase_info(&mut INFO);\n             });\n             &INFO\n         }\n@@ -87,11 +82,6 @@ mod inner {\n     #[link(name = \"rt\")]\n     extern {}\n \n-    extern {\n-        #[cfg_attr(target_os = \"netbsd\", link_name = \"__clock_gettime50\")]\n-        fn clock_gettime(clk_id: libc::c_int, tp: *mut libc::timespec) -> libc::c_int;\n-    }\n-\n     impl SteadyTime {\n         pub fn now() -> SteadyTime {\n             let mut t = SteadyTime {\n@@ -101,7 +91,8 @@ mod inner {\n                 }\n             };\n             unsafe {\n-                assert_eq!(0, clock_gettime(libc::CLOCK_MONOTONIC, &mut t.t));\n+                assert_eq!(0, libc::clock_gettime(libc::CLOCK_MONOTONIC,\n+                                                  &mut t.t));\n             }\n             t\n         }"}, {"sha": "d106bc3285cb1a461a793783a782d1828d836ac5", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 42, "deletions": 255, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -27,12 +27,13 @@\n use io::prelude::*;\n \n use dynamic_lib::DynamicLibrary;\n-use intrinsics;\n use io;\n-use libc;\n+use libc::c_void;\n+use mem;\n use path::Path;\n use ptr;\n use sync::StaticMutex;\n+use sys::c;\n \n macro_rules! sym{ ($lib:expr, $e:expr, $t:ident) => (unsafe {\n     let lib = $lib;\n@@ -50,264 +51,50 @@ mod printing;\n #[path = \"printing/gnu.rs\"]\n mod printing;\n \n-#[allow(non_snake_case)]\n-extern \"system\" {\n-    fn GetCurrentProcess() -> libc::HANDLE;\n-    fn GetCurrentThread() -> libc::HANDLE;\n-    fn RtlCaptureContext(ctx: *mut arch::CONTEXT);\n-}\n-\n type SymFromAddrFn =\n-    extern \"system\" fn(libc::HANDLE, u64, *mut u64,\n-                       *mut SYMBOL_INFO) -> libc::BOOL;\n+    extern \"system\" fn(c::HANDLE, u64, *mut u64,\n+                       *mut c::SYMBOL_INFO) -> c::BOOL;\n type SymGetLineFromAddr64Fn =\n-    extern \"system\" fn(libc::HANDLE, u64, *mut u32,\n-                       *mut IMAGEHLP_LINE64) -> libc::BOOL;\n+    extern \"system\" fn(c::HANDLE, u64, *mut u32,\n+                       *mut c::IMAGEHLP_LINE64) -> c::BOOL;\n type SymInitializeFn =\n-    extern \"system\" fn(libc::HANDLE, *mut libc::c_void,\n-                       libc::BOOL) -> libc::BOOL;\n+    extern \"system\" fn(c::HANDLE, *mut c_void,\n+                       c::BOOL) -> c::BOOL;\n type SymCleanupFn =\n-    extern \"system\" fn(libc::HANDLE) -> libc::BOOL;\n+    extern \"system\" fn(c::HANDLE) -> c::BOOL;\n \n type StackWalk64Fn =\n-    extern \"system\" fn(libc::DWORD, libc::HANDLE, libc::HANDLE,\n-                       *mut STACKFRAME64, *mut arch::CONTEXT,\n-                       *mut libc::c_void, *mut libc::c_void,\n-                       *mut libc::c_void, *mut libc::c_void) -> libc::BOOL;\n-\n-const MAX_SYM_NAME: usize = 2000;\n-const IMAGE_FILE_MACHINE_I386: libc::DWORD = 0x014c;\n-const IMAGE_FILE_MACHINE_IA64: libc::DWORD = 0x0200;\n-const IMAGE_FILE_MACHINE_AMD64: libc::DWORD = 0x8664;\n-\n-#[repr(C)]\n-struct SYMBOL_INFO {\n-    SizeOfStruct: libc::c_ulong,\n-    TypeIndex: libc::c_ulong,\n-    Reserved: [u64; 2],\n-    Index: libc::c_ulong,\n-    Size: libc::c_ulong,\n-    ModBase: u64,\n-    Flags: libc::c_ulong,\n-    Value: u64,\n-    Address: u64,\n-    Register: libc::c_ulong,\n-    Scope: libc::c_ulong,\n-    Tag: libc::c_ulong,\n-    NameLen: libc::c_ulong,\n-    MaxNameLen: libc::c_ulong,\n-    // note that windows has this as 1, but it basically just means that\n-    // the name is inline at the end of the struct. For us, we just bump\n-    // the struct size up to MAX_SYM_NAME.\n-    Name: [libc::c_char; MAX_SYM_NAME],\n-}\n-\n-#[repr(C)]\n-struct IMAGEHLP_LINE64 {\n-    SizeOfStruct: u32,\n-    Key: *const libc::c_void,\n-    LineNumber: u32,\n-    Filename: *const libc::c_char,\n-    Address: u64,\n-}\n-\n-#[repr(C)]\n-enum ADDRESS_MODE {\n-    AddrMode1616,\n-    AddrMode1632,\n-    AddrModeReal,\n-    AddrModeFlat,\n-}\n-\n-struct ADDRESS64 {\n-    Offset: u64,\n-    Segment: u16,\n-    Mode: ADDRESS_MODE,\n-}\n-\n-pub struct STACKFRAME64 {\n-    AddrPC: ADDRESS64,\n-    AddrReturn: ADDRESS64,\n-    AddrFrame: ADDRESS64,\n-    AddrStack: ADDRESS64,\n-    AddrBStore: ADDRESS64,\n-    FuncTableEntry: *mut libc::c_void,\n-    Params: [u64; 4],\n-    Far: libc::BOOL,\n-    Virtual: libc::BOOL,\n-    Reserved: [u64; 3],\n-    KdHelp: KDHELP64,\n-}\n-\n-struct KDHELP64 {\n-    Thread: u64,\n-    ThCallbackStack: libc::DWORD,\n-    ThCallbackBStore: libc::DWORD,\n-    NextCallback: libc::DWORD,\n-    FramePointer: libc::DWORD,\n-    KiCallUserMode: u64,\n-    KeUserCallbackDispatcher: u64,\n-    SystemRangeStart: u64,\n-    KiUserExceptionDispatcher: u64,\n-    StackBase: u64,\n-    StackLimit: u64,\n-    Reserved: [u64; 5],\n-}\n+    extern \"system\" fn(c::DWORD, c::HANDLE, c::HANDLE,\n+                       *mut c::STACKFRAME64, *mut c::CONTEXT,\n+                       *mut c_void, *mut c_void,\n+                       *mut c_void, *mut c_void) -> c::BOOL;\n \n #[cfg(target_arch = \"x86\")]\n-mod arch {\n-    use libc;\n-\n-    const MAXIMUM_SUPPORTED_EXTENSION: usize = 512;\n-\n-    #[repr(C)]\n-    pub struct CONTEXT {\n-        ContextFlags: libc::DWORD,\n-        Dr0: libc::DWORD,\n-        Dr1: libc::DWORD,\n-        Dr2: libc::DWORD,\n-        Dr3: libc::DWORD,\n-        Dr6: libc::DWORD,\n-        Dr7: libc::DWORD,\n-        FloatSave: FLOATING_SAVE_AREA,\n-        SegGs: libc::DWORD,\n-        SegFs: libc::DWORD,\n-        SegEs: libc::DWORD,\n-        SegDs: libc::DWORD,\n-        Edi: libc::DWORD,\n-        Esi: libc::DWORD,\n-        Ebx: libc::DWORD,\n-        Edx: libc::DWORD,\n-        Ecx: libc::DWORD,\n-        Eax: libc::DWORD,\n-        Ebp: libc::DWORD,\n-        Eip: libc::DWORD,\n-        SegCs: libc::DWORD,\n-        EFlags: libc::DWORD,\n-        Esp: libc::DWORD,\n-        SegSs: libc::DWORD,\n-        ExtendedRegisters: [u8; MAXIMUM_SUPPORTED_EXTENSION],\n-    }\n-\n-    #[repr(C)]\n-    pub struct FLOATING_SAVE_AREA {\n-        ControlWord: libc::DWORD,\n-        StatusWord: libc::DWORD,\n-        TagWord: libc::DWORD,\n-        ErrorOffset: libc::DWORD,\n-        ErrorSelector: libc::DWORD,\n-        DataOffset: libc::DWORD,\n-        DataSelector: libc::DWORD,\n-        RegisterArea: [u8; 80],\n-        Cr0NpxState: libc::DWORD,\n-    }\n-\n-    pub fn init_frame(frame: &mut super::STACKFRAME64,\n-                      ctx: &CONTEXT) -> libc::DWORD {\n-        frame.AddrPC.Offset = ctx.Eip as u64;\n-        frame.AddrPC.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-        frame.AddrStack.Offset = ctx.Esp as u64;\n-        frame.AddrStack.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-        frame.AddrFrame.Offset = ctx.Ebp as u64;\n-        frame.AddrFrame.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-        super::IMAGE_FILE_MACHINE_I386\n-    }\n+pub fn init_frame(frame: &mut c::STACKFRAME64,\n+                  ctx: &c::CONTEXT) -> c::DWORD {\n+    frame.AddrPC.Offset = ctx.Eip as u64;\n+    frame.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+    frame.AddrStack.Offset = ctx.Esp as u64;\n+    frame.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+    frame.AddrFrame.Offset = ctx.Ebp as u64;\n+    frame.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+    c::IMAGE_FILE_MACHINE_I386\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-mod arch {\n-    #![allow(deprecated)]\n-\n-    use libc::{c_longlong, c_ulonglong};\n-    use libc::types::os::arch::extra::{WORD, DWORD, DWORDLONG};\n-    use simd;\n-\n-    #[repr(C)]\n-    pub struct CONTEXT {\n-        _align_hack: [simd::u64x2; 0], // FIXME align on 16-byte\n-        P1Home: DWORDLONG,\n-        P2Home: DWORDLONG,\n-        P3Home: DWORDLONG,\n-        P4Home: DWORDLONG,\n-        P5Home: DWORDLONG,\n-        P6Home: DWORDLONG,\n-\n-        ContextFlags: DWORD,\n-        MxCsr: DWORD,\n-\n-        SegCs: WORD,\n-        SegDs: WORD,\n-        SegEs: WORD,\n-        SegFs: WORD,\n-        SegGs: WORD,\n-        SegSs: WORD,\n-        EFlags: DWORD,\n-\n-        Dr0: DWORDLONG,\n-        Dr1: DWORDLONG,\n-        Dr2: DWORDLONG,\n-        Dr3: DWORDLONG,\n-        Dr6: DWORDLONG,\n-        Dr7: DWORDLONG,\n-\n-        Rax: DWORDLONG,\n-        Rcx: DWORDLONG,\n-        Rdx: DWORDLONG,\n-        Rbx: DWORDLONG,\n-        Rsp: DWORDLONG,\n-        Rbp: DWORDLONG,\n-        Rsi: DWORDLONG,\n-        Rdi: DWORDLONG,\n-        R8:  DWORDLONG,\n-        R9:  DWORDLONG,\n-        R10: DWORDLONG,\n-        R11: DWORDLONG,\n-        R12: DWORDLONG,\n-        R13: DWORDLONG,\n-        R14: DWORDLONG,\n-        R15: DWORDLONG,\n-\n-        Rip: DWORDLONG,\n-\n-        FltSave: FLOATING_SAVE_AREA,\n-\n-        VectorRegister: [M128A; 26],\n-        VectorControl: DWORDLONG,\n-\n-        DebugControl: DWORDLONG,\n-        LastBranchToRip: DWORDLONG,\n-        LastBranchFromRip: DWORDLONG,\n-        LastExceptionToRip: DWORDLONG,\n-        LastExceptionFromRip: DWORDLONG,\n-    }\n-\n-    #[repr(C)]\n-    pub struct M128A {\n-        _align_hack: [simd::u64x2; 0], // FIXME align on 16-byte\n-        Low:  c_ulonglong,\n-        High: c_longlong\n-    }\n-\n-    #[repr(C)]\n-    pub struct FLOATING_SAVE_AREA {\n-        _align_hack: [simd::u64x2; 0], // FIXME align on 16-byte\n-        _Dummy: [u8; 512] // FIXME: Fill this out\n-    }\n-\n-    pub fn init_frame(frame: &mut super::STACKFRAME64,\n-                      ctx: &CONTEXT) -> DWORD {\n-        frame.AddrPC.Offset = ctx.Rip as u64;\n-        frame.AddrPC.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-        frame.AddrStack.Offset = ctx.Rsp as u64;\n-        frame.AddrStack.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-        frame.AddrFrame.Offset = ctx.Rbp as u64;\n-        frame.AddrFrame.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-        super::IMAGE_FILE_MACHINE_AMD64\n-    }\n+pub fn init_frame(frame: &mut c::STACKFRAME64,\n+                  ctx: &c::CONTEXT) -> c::DWORD {\n+    frame.AddrPC.Offset = ctx.Rip as u64;\n+    frame.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+    frame.AddrStack.Offset = ctx.Rsp as u64;\n+    frame.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+    frame.AddrFrame.Offset = ctx.Rbp as u64;\n+    frame.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+    c::IMAGE_FILE_MACHINE_AMD64\n }\n \n struct Cleanup {\n-    handle: libc::HANDLE,\n+    handle: c::HANDLE,\n     SymCleanup: SymCleanupFn,\n }\n \n@@ -335,16 +122,16 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n     let StackWalk64 = sym!(&dbghelp, \"StackWalk64\", StackWalk64Fn);\n \n     // Allocate necessary structures for doing the stack walk\n-    let process = unsafe { GetCurrentProcess() };\n-    let thread = unsafe { GetCurrentThread() };\n-    let mut context: arch::CONTEXT = unsafe { intrinsics::init() };\n-    unsafe { RtlCaptureContext(&mut context); }\n-    let mut frame: STACKFRAME64 = unsafe { intrinsics::init() };\n-    let image = arch::init_frame(&mut frame, &context);\n+    let process = unsafe { c::GetCurrentProcess() };\n+    let thread = unsafe { c::GetCurrentThread() };\n+    let mut context: c::CONTEXT = unsafe { mem::zeroed() };\n+    unsafe { c::RtlCaptureContext(&mut context); }\n+    let mut frame: c::STACKFRAME64 = unsafe { mem::zeroed() };\n+    let image = init_frame(&mut frame, &context);\n \n     // Initialize this process's symbols\n-    let ret = SymInitialize(process, ptr::null_mut(), libc::TRUE);\n-    if ret != libc::TRUE { return Ok(()) }\n+    let ret = SymInitialize(process, ptr::null_mut(), c::TRUE);\n+    if ret != c::TRUE { return Ok(()) }\n     let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n \n     // And now that we're done with all the setup, do the stack walking!\n@@ -356,7 +143,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n                       ptr::null_mut(),\n                       ptr::null_mut(),\n                       ptr::null_mut(),\n-                      ptr::null_mut()) == libc::TRUE{\n+                      ptr::null_mut()) == c::TRUE {\n         let addr = frame.AddrPC.Offset;\n         if addr == frame.AddrReturn.Offset || addr == 0 ||\n            frame.AddrReturn.Offset == 0 { break }"}, {"sha": "42f182eb01066e4f75f4b625b77b6c19150bfa0e", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 1000, "deletions": 287, "changes": 1287, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -10,87 +10,336 @@\n \n //! C definitions used by libnative that don't belong in liblibc\n \n-#![allow(bad_style, dead_code, overflowing_literals)]\n+#![allow(bad_style, overflowing_literals, dead_code, deprecated, unused_imports)]\n \n-use libc;\n-use libc::{c_uint, c_ulong};\n-use libc::{DWORD, BOOL, BOOLEAN, ERROR_CALL_NOT_IMPLEMENTED, LPVOID, HANDLE};\n-use libc::{LPCWSTR, LONG};\n+use os::raw::{c_int, c_uint, c_ulong, c_long, c_longlong, c_ushort};\n+use os::raw::{c_char, c_short, c_ulonglong};\n+use libc::{wchar_t, size_t, c_void};\n use ptr;\n+use simd;\n \n pub use self::GET_FILEEX_INFO_LEVELS::*;\n pub use self::FILE_INFO_BY_HANDLE_CLASS::*;\n-pub use libc::consts::os::extra::{\n-    FILE_ATTRIBUTE_READONLY,\n-    FILE_ATTRIBUTE_DIRECTORY,\n-    WSAPROTOCOL_LEN,\n-};\n-pub use libc::types::os::arch::extra::{GROUP, GUID, WSAPROTOCOLCHAIN};\n+pub use self::EXCEPTION_DISPOSITION::*;\n \n-pub const WSADESCRIPTION_LEN: usize = 256;\n-pub const WSASYS_STATUS_LEN: usize = 128;\n-pub const FIONBIO: libc::c_long = 0x8004667e;\n+pub type DWORD = c_ulong;\n+pub type HANDLE = LPVOID;\n+pub type HINSTANCE = HANDLE;\n+pub type HMODULE = HINSTANCE;\n+pub type BOOL = c_int;\n+pub type BYTE = u8;\n+pub type BOOLEAN = BYTE;\n+pub type GROUP = c_uint;\n+pub type LONG_PTR = isize;\n+pub type LARGE_INTEGER = c_longlong;\n+pub type LONG = c_long;\n+pub type UINT = c_uint;\n+pub type WCHAR = u16;\n+pub type USHORT = c_ushort;\n+pub type SIZE_T = usize;\n+pub type WORD = u16;\n+pub type CHAR = c_char;\n+pub type HCRYPTPROV = LONG_PTR;\n+pub type ULONG_PTR = c_ulonglong;\n+pub type ULONG = c_ulong;\n+pub type ULONGLONG = u64;\n+pub type DWORDLONG = ULONGLONG;\n+\n+pub type LPBOOL = *mut BOOL;\n+pub type LPBYTE = *mut BYTE;\n+pub type LPBY_HANDLE_FILE_INFORMATION = *mut BY_HANDLE_FILE_INFORMATION;\n+pub type LPCSTR = *const CHAR;\n+pub type LPCVOID = *const c_void;\n+pub type LPCWSTR = *const WCHAR;\n+pub type LPDWORD = *mut DWORD;\n+pub type LPHANDLE = *mut HANDLE;\n+pub type LPOVERLAPPED = *mut OVERLAPPED;\n+pub type LPPROCESS_INFORMATION = *mut PROCESS_INFORMATION;\n+pub type LPSECURITY_ATTRIBUTES = *mut SECURITY_ATTRIBUTES;\n+pub type LPSTARTUPINFO = *mut STARTUPINFO;\n+pub type LPVOID = *mut c_void;\n+pub type LPWCH = *mut WCHAR;\n+pub type LPWIN32_FIND_DATAW = *mut WIN32_FIND_DATAW;\n+pub type LPWSADATA = *mut WSADATA;\n+pub type LPWSANETWORKEVENTS = *mut WSANETWORKEVENTS;\n+pub type LPWSAPROTOCOLCHAIN = *mut WSAPROTOCOLCHAIN;\n+pub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;\n+pub type LPWSTR = *mut WCHAR;\n+\n+pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n+pub type PLARGE_INTEGER = *mut c_longlong;\n+pub type PSRWLOCK = *mut SRWLOCK;\n+\n+pub type SOCKET = ::os::windows::raw::SOCKET;\n+pub type socklen_t = c_int;\n+pub type ADDRESS_FAMILY = USHORT;\n+\n+pub const TRUE: BOOL = 1;\n+pub const FALSE: BOOL = 0;\n+\n+pub const FILE_ATTRIBUTE_READONLY: DWORD = 0x1;\n+pub const FILE_ATTRIBUTE_DIRECTORY: DWORD = 0x10;\n+pub const FILE_ATTRIBUTE_NORMAL: DWORD = 0x80;\n+pub const FILE_ATTRIBUTE_REPARSE_POINT: DWORD = 0x400;\n+pub const FILE_SHARE_DELETE: DWORD = 0x4;\n+pub const FILE_SHARE_READ: DWORD = 0x1;\n+pub const FILE_SHARE_WRITE: DWORD = 0x2;\n+pub const CREATE_ALWAYS: DWORD = 2;\n+pub const CREATE_NEW: DWORD = 1;\n+pub const OPEN_ALWAYS: DWORD = 4;\n+pub const OPEN_EXISTING: DWORD = 3;\n+pub const TRUNCATE_EXISTING: DWORD = 5;\n+pub const FILE_APPEND_DATA: DWORD = 0x00000004;\n+pub const FILE_READ_DATA: DWORD = 0x00000001;\n+pub const FILE_WRITE_DATA: DWORD = 0x00000002;\n+pub const STANDARD_RIGHTS_READ: DWORD = 0x20000;\n+pub const STANDARD_RIGHTS_WRITE: DWORD = 0x20000;\n+pub const FILE_WRITE_EA: DWORD = 0x00000010;\n+pub const FILE_READ_EA: DWORD = 0x00000008;\n+pub const SYNCHRONIZE: DWORD = 0x00100000;\n+pub const FILE_WRITE_ATTRIBUTES: DWORD = 0x00000100;\n+pub const FILE_READ_ATTRIBUTES: DWORD = 0x00000080;\n+pub const FILE_GENERIC_READ: DWORD = STANDARD_RIGHTS_READ | FILE_READ_DATA |\n+                                     FILE_READ_ATTRIBUTES |\n+                                     FILE_READ_EA |\n+                                     SYNCHRONIZE;\n+pub const FILE_GENERIC_WRITE: DWORD = STANDARD_RIGHTS_WRITE | FILE_WRITE_DATA |\n+                                      FILE_WRITE_ATTRIBUTES |\n+                                      FILE_WRITE_EA |\n+                                      FILE_APPEND_DATA |\n+                                      SYNCHRONIZE;\n+\n+#[repr(C)]\n+#[derive(Copy)]\n+pub struct WIN32_FIND_DATAW {\n+    pub dwFileAttributes: DWORD,\n+    pub ftCreationTime: FILETIME,\n+    pub ftLastAccessTime: FILETIME,\n+    pub ftLastWriteTime: FILETIME,\n+    pub nFileSizeHigh: DWORD,\n+    pub nFileSizeLow: DWORD,\n+    pub dwReserved0: DWORD,\n+    pub dwReserved1: DWORD,\n+    pub cFileName: [wchar_t; 260], // #define MAX_PATH 260\n+    pub cAlternateFileName: [wchar_t; 14],\n+}\n+impl Clone for WIN32_FIND_DATAW {\n+    fn clone(&self) -> Self { *self }\n+}\n+\n+pub const FIONBIO: c_long = 0x8004667e;\n pub const FD_SETSIZE: usize = 64;\n-pub const MSG_DONTWAIT: libc::c_int = 0;\n-pub const ERROR_ENVVAR_NOT_FOUND: libc::c_int = 203;\n-pub const ERROR_ILLEGAL_CHARACTER: libc::c_int = 582;\n-pub const ENABLE_ECHO_INPUT: libc::DWORD = 0x4;\n-pub const ENABLE_EXTENDED_FLAGS: libc::DWORD = 0x80;\n-pub const ENABLE_INSERT_MODE: libc::DWORD = 0x20;\n-pub const ENABLE_LINE_INPUT: libc::DWORD = 0x2;\n-pub const ENABLE_PROCESSED_INPUT: libc::DWORD = 0x1;\n-pub const ENABLE_QUICK_EDIT_MODE: libc::DWORD = 0x40;\n-pub const WSA_INVALID_EVENT: WSAEVENT = 0 as WSAEVENT;\n+pub const MSG_DONTWAIT: c_int = 0;\n+pub const ENABLE_ECHO_INPUT: DWORD = 0x4;\n+pub const ENABLE_EXTENDED_FLAGS: DWORD = 0x80;\n+pub const ENABLE_INSERT_MODE: DWORD = 0x20;\n+pub const ENABLE_LINE_INPUT: DWORD = 0x2;\n+pub const ENABLE_PROCESSED_INPUT: DWORD = 0x1;\n+pub const ENABLE_QUICK_EDIT_MODE: DWORD = 0x40;\n \n-pub const FD_ACCEPT: libc::c_long = 0x08;\n+pub const FD_ACCEPT: c_long = 0x08;\n pub const FD_MAX_EVENTS: usize = 10;\n-pub const WSA_INFINITE: libc::DWORD = libc::INFINITE;\n-pub const WSA_WAIT_TIMEOUT: libc::DWORD = libc::consts::os::extra::WAIT_TIMEOUT;\n-pub const WSA_WAIT_EVENT_0: libc::DWORD = libc::consts::os::extra::WAIT_OBJECT_0;\n-pub const WSA_WAIT_FAILED: libc::DWORD = libc::consts::os::extra::WAIT_FAILED;\n-pub const WSAESHUTDOWN: libc::c_int = 10058;\n-pub const WSA_FLAG_OVERLAPPED: libc::DWORD = 0x01;\n-pub const WSA_FLAG_NO_HANDLE_INHERIT: libc::DWORD = 0x80;\n-\n-pub const ERROR_NO_MORE_FILES: libc::DWORD = 18;\n-pub const TOKEN_READ: libc::DWORD = 0x20008;\n-pub const FILE_FLAG_OPEN_REPARSE_POINT: libc::DWORD = 0x00200000;\n-pub const FILE_FLAG_BACKUP_SEMANTICS: libc::DWORD = 0x02000000;\n+\n+pub const WSA_INVALID_EVENT: WSAEVENT = 0 as WSAEVENT;\n+pub const WSA_INFINITE: DWORD = INFINITE;\n+pub const WSA_WAIT_TIMEOUT: DWORD = WAIT_TIMEOUT;\n+pub const WSA_WAIT_EVENT_0: DWORD = WAIT_OBJECT_0;\n+pub const WSA_WAIT_FAILED: DWORD = WAIT_FAILED;\n+pub const WSA_FLAG_OVERLAPPED: DWORD = 0x01;\n+pub const WSA_FLAG_NO_HANDLE_INHERIT: DWORD = 0x80;\n+\n+pub const WSADESCRIPTION_LEN: usize = 256;\n+pub const WSASYS_STATUS_LEN: usize = 128;\n+pub const WSAPROTOCOL_LEN: DWORD = 255;\n+pub const INVALID_SOCKET: SOCKET = !0;\n+\n+pub const WSAEINTR: c_int = 10004;\n+pub const WSAEBADF: c_int = 10009;\n+pub const WSAEACCES: c_int = 10013;\n+pub const WSAEFAULT: c_int = 10014;\n+pub const WSAEINVAL: c_int = 10022;\n+pub const WSAEMFILE: c_int = 10024;\n+pub const WSAEWOULDBLOCK: c_int = 10035;\n+pub const WSAEINPROGRESS: c_int = 10036;\n+pub const WSAEALREADY: c_int = 10037;\n+pub const WSAENOTSOCK: c_int = 10038;\n+pub const WSAEDESTADDRREQ: c_int = 10039;\n+pub const WSAEMSGSIZE: c_int = 10040;\n+pub const WSAEPROTOTYPE: c_int = 10041;\n+pub const WSAENOPROTOOPT: c_int = 10042;\n+pub const WSAEPROTONOSUPPORT: c_int = 10043;\n+pub const WSAESOCKTNOSUPPORT: c_int = 10044;\n+pub const WSAEOPNOTSUPP: c_int = 10045;\n+pub const WSAEPFNOSUPPORT: c_int = 10046;\n+pub const WSAEAFNOSUPPORT: c_int = 10047;\n+pub const WSAEADDRINUSE: c_int = 10048;\n+pub const WSAEADDRNOTAVAIL: c_int = 10049;\n+pub const WSAENETDOWN: c_int = 10050;\n+pub const WSAENETUNREACH: c_int = 10051;\n+pub const WSAENETRESET: c_int = 10052;\n+pub const WSAECONNABORTED: c_int = 10053;\n+pub const WSAECONNRESET: c_int = 10054;\n+pub const WSAENOBUFS: c_int = 10055;\n+pub const WSAEISCONN: c_int = 10056;\n+pub const WSAENOTCONN: c_int = 10057;\n+pub const WSAESHUTDOWN: c_int = 10058;\n+pub const WSAETOOMANYREFS: c_int = 10059;\n+pub const WSAETIMEDOUT: c_int = 10060;\n+pub const WSAECONNREFUSED: c_int = 10061;\n+pub const WSAELOOP: c_int = 10062;\n+pub const WSAENAMETOOLONG: c_int = 10063;\n+pub const WSAEHOSTDOWN: c_int = 10064;\n+pub const WSAEHOSTUNREACH: c_int = 10065;\n+pub const WSAENOTEMPTY: c_int = 10066;\n+pub const WSAEPROCLIM: c_int = 10067;\n+pub const WSAEUSERS: c_int = 10068;\n+pub const WSAEDQUOT: c_int = 10069;\n+pub const WSAESTALE: c_int = 10070;\n+pub const WSAEREMOTE: c_int = 10071;\n+pub const WSASYSNOTREADY: c_int = 10091;\n+pub const WSAVERNOTSUPPORTED: c_int = 10092;\n+pub const WSANOTINITIALISED: c_int = 10093;\n+pub const WSAEDISCON: c_int = 10101;\n+pub const WSAENOMORE: c_int = 10102;\n+pub const WSAECANCELLED: c_int = 10103;\n+pub const WSAEINVALIDPROCTABLE: c_int = 10104;\n+pub const NI_MAXHOST: DWORD = 1025;\n+\n+pub const MAX_PROTOCOL_CHAIN: DWORD = 7;\n+\n+pub const TOKEN_READ: DWORD = 0x20008;\n+pub const FILE_FLAG_OPEN_REPARSE_POINT: DWORD = 0x00200000;\n+pub const FILE_FLAG_BACKUP_SEMANTICS: DWORD = 0x02000000;\n pub const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\n-pub const FSCTL_GET_REPARSE_POINT: libc::DWORD = 0x900a8;\n-pub const IO_REPARSE_TAG_SYMLINK: libc::DWORD = 0xa000000c;\n-pub const IO_REPARSE_TAG_MOUNT_POINT: libc::DWORD = 0xa0000003;\n-pub const FSCTL_SET_REPARSE_POINT: libc::DWORD = 0x900a4;\n-pub const FSCTL_DELETE_REPARSE_POINT: libc::DWORD = 0x900ac;\n+pub const FSCTL_GET_REPARSE_POINT: DWORD = 0x900a8;\n+pub const IO_REPARSE_TAG_SYMLINK: DWORD = 0xa000000c;\n+pub const IO_REPARSE_TAG_MOUNT_POINT: DWORD = 0xa0000003;\n+pub const FSCTL_SET_REPARSE_POINT: DWORD = 0x900a4;\n+pub const FSCTL_DELETE_REPARSE_POINT: DWORD = 0x900ac;\n \n-pub const SYMBOLIC_LINK_FLAG_DIRECTORY: libc::DWORD = 0x1;\n+pub const SYMBOLIC_LINK_FLAG_DIRECTORY: DWORD = 0x1;\n \n // Note that these are not actually HANDLEs, just values to pass to GetStdHandle\n-pub const STD_INPUT_HANDLE: libc::DWORD = -10i32 as libc::DWORD;\n-pub const STD_OUTPUT_HANDLE: libc::DWORD = -11i32 as libc::DWORD;\n-pub const STD_ERROR_HANDLE: libc::DWORD = -12i32 as libc::DWORD;\n+pub const STD_INPUT_HANDLE: DWORD = -10i32 as DWORD;\n+pub const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n+pub const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n+\n+pub const HANDLE_FLAG_INHERIT: DWORD = 0x00000001;\n+\n+pub const PROGRESS_CONTINUE: DWORD = 0;\n+pub const PROGRESS_CANCEL: DWORD = 1;\n+pub const PROGRESS_STOP: DWORD = 2;\n+pub const PROGRESS_QUIET: DWORD = 3;\n+\n+pub const TOKEN_ADJUST_PRIVILEGES: DWORD = 0x0020;\n+pub const SE_PRIVILEGE_ENABLED: DWORD = 2;\n+\n \n-pub const HANDLE_FLAG_INHERIT: libc::DWORD = 0x00000001;\n+pub const ERROR_SUCCESS: DWORD = 0;\n+pub const ERROR_INVALID_FUNCTION: DWORD = 1;\n+pub const ERROR_FILE_NOT_FOUND: DWORD = 2;\n+pub const ERROR_PATH_NOT_FOUND: DWORD = 3;\n+pub const ERROR_ACCESS_DENIED: DWORD = 5;\n+pub const ERROR_INVALID_HANDLE: DWORD = 6;\n+pub const ERROR_NO_MORE_FILES: DWORD = 18;\n+pub const ERROR_BROKEN_PIPE: DWORD = 109;\n+pub const ERROR_DISK_FULL: DWORD = 112;\n+pub const ERROR_CALL_NOT_IMPLEMENTED: DWORD = 120;\n+pub const ERROR_INSUFFICIENT_BUFFER: DWORD = 122;\n+pub const ERROR_INVALID_NAME: DWORD = 123;\n+pub const ERROR_ALREADY_EXISTS: DWORD = 183;\n+pub const ERROR_PIPE_BUSY: DWORD = 231;\n+pub const ERROR_NO_DATA: DWORD = 232;\n+pub const ERROR_INVALID_ADDRESS: DWORD = 487;\n+pub const ERROR_PIPE_CONNECTED: DWORD = 535;\n+pub const ERROR_ILLEGAL_CHARACTER: DWORD = 582;\n+pub const ERROR_ENVVAR_NOT_FOUND: DWORD = 203;\n+pub const ERROR_NOTHING_TO_TERMINATE: DWORD = 758;\n+pub const ERROR_OPERATION_ABORTED: DWORD = 995;\n+pub const ERROR_IO_PENDING: DWORD = 997;\n+pub const ERROR_FILE_INVALID: DWORD = 1006;\n+pub const ERROR_NOT_FOUND: DWORD = 1168;\n+pub const ERROR_TIMEOUT: DWORD = 0x5B4;\n+\n+pub const INVALID_HANDLE_VALUE: HANDLE = !0 as HANDLE;\n+\n+pub const FORMAT_MESSAGE_FROM_SYSTEM: DWORD = 0x00001000;\n+pub const FORMAT_MESSAGE_IGNORE_INSERTS: DWORD = 0x00000200;\n+\n+pub const TLS_OUT_OF_INDEXES: DWORD = 0xFFFFFFFF;\n+\n+pub const DLL_THREAD_DETACH: DWORD = 3;\n+pub const DLL_PROCESS_DETACH: DWORD = 0;\n+\n+pub const INFINITE: DWORD = !0;\n+\n+pub const DUPLICATE_SAME_ACCESS: DWORD = 0x00000002;\n+\n+pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE {\n+    ptr: ptr::null_mut(),\n+};\n+pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: ptr::null_mut() };\n \n-pub const PROGRESS_CONTINUE: libc::DWORD = 0;\n-pub const PROGRESS_CANCEL: libc::DWORD = 1;\n-pub const PROGRESS_STOP: libc::DWORD = 2;\n-pub const PROGRESS_QUIET: libc::DWORD = 3;\n+pub const STILL_ACTIVE: DWORD = 259;\n \n-pub const TOKEN_ADJUST_PRIVILEGES: libc::DWORD = 0x0020;\n-pub const SE_PRIVILEGE_ENABLED: libc::DWORD = 2;\n+pub const DETACHED_PROCESS: DWORD = 0x00000008;\n+pub const CREATE_NEW_PROCESS_GROUP: DWORD = 0x00000200;\n+pub const CREATE_UNICODE_ENVIRONMENT: DWORD = 0x00000400;\n+pub const STARTF_USESTDHANDLES: DWORD = 0x00000100;\n+\n+pub const AF_INET: c_int = 2;\n+pub const AF_INET6: c_int = 23;\n+pub const SD_BOTH: c_int = 2;\n+pub const SD_RECEIVE: c_int = 0;\n+pub const SD_SEND: c_int = 1;\n+pub const SOCK_DGRAM: c_int = 2;\n+pub const SOCK_STREAM: c_int = 1;\n+pub const SOL_SOCKET: c_int = 0xffff;\n+pub const SO_RCVTIMEO: c_int = 0x1006;\n+pub const SO_SNDTIMEO: c_int = 0x1005;\n+pub const SO_REUSEADDR: c_int = 0x0004;\n+\n+pub const VOLUME_NAME_DOS: DWORD = 0x0;\n+pub const MOVEFILE_REPLACE_EXISTING: DWORD = 1;\n+\n+pub const FILE_BEGIN: DWORD = 0;\n+pub const FILE_CURRENT: DWORD = 1;\n+pub const FILE_END: DWORD = 2;\n+\n+pub const WAIT_ABANDONED: DWORD = 0x00000080;\n+pub const WAIT_OBJECT_0: DWORD = 0x00000000;\n+pub const WAIT_TIMEOUT: DWORD = 0x00000102;\n+pub const WAIT_FAILED: DWORD = !0;\n+\n+pub const MAX_SYM_NAME: usize = 2000;\n+pub const IMAGE_FILE_MACHINE_I386: DWORD = 0x014c;\n+pub const IMAGE_FILE_MACHINE_IA64: DWORD = 0x0200;\n+pub const IMAGE_FILE_MACHINE_AMD64: DWORD = 0x8664;\n+\n+pub const PROV_RSA_FULL: DWORD = 1;\n+pub const CRYPT_SILENT: DWORD = 64;\n+pub const CRYPT_VERIFYCONTEXT: DWORD = 0xF0000000;\n \n pub const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n-pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n pub const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n-\n-pub const ERROR_PATH_NOT_FOUND: libc::c_int = 3;\n+pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n+pub const EXCEPTION_NONCONTINUABLE: DWORD = 0x1;   // Noncontinuable exception\n+pub const EXCEPTION_UNWINDING: DWORD = 0x2;        // Unwind is in progress\n+pub const EXCEPTION_EXIT_UNWIND: DWORD = 0x4;      // Exit unwind is in progress\n+pub const EXCEPTION_STACK_INVALID: DWORD = 0x8;    // Stack out of limits or unaligned\n+pub const EXCEPTION_NESTED_CALL: DWORD = 0x10;     // Nested exception handler call\n+pub const EXCEPTION_TARGET_UNWIND: DWORD = 0x20;   // Target unwind in progress\n+pub const EXCEPTION_COLLIDED_UNWIND: DWORD = 0x40; // Collided exception handler call\n+pub const EXCEPTION_UNWIND: DWORD = EXCEPTION_UNWINDING |\n+                                    EXCEPTION_EXIT_UNWIND |\n+                                    EXCEPTION_TARGET_UNWIND |\n+                                    EXCEPTION_COLLIDED_UNWIND;\n \n #[repr(C)]\n #[cfg(target_arch = \"x86\")]\n pub struct WSADATA {\n-    pub wVersion: libc::WORD,\n-    pub wHighVersion: libc::WORD,\n+    pub wVersion: WORD,\n+    pub wHighVersion: WORD,\n     pub szDescription: [u8; WSADESCRIPTION_LEN + 1],\n     pub szSystemStatus: [u8; WSASYS_STATUS_LEN + 1],\n     pub iMaxSockets: u16,\n@@ -100,65 +349,59 @@ pub struct WSADATA {\n #[repr(C)]\n #[cfg(target_arch = \"x86_64\")]\n pub struct WSADATA {\n-    pub wVersion: libc::WORD,\n-    pub wHighVersion: libc::WORD,\n+    pub wVersion: WORD,\n+    pub wHighVersion: WORD,\n     pub iMaxSockets: u16,\n     pub iMaxUdpDg: u16,\n     pub lpVendorInfo: *mut u8,\n     pub szDescription: [u8; WSADESCRIPTION_LEN + 1],\n     pub szSystemStatus: [u8; WSASYS_STATUS_LEN + 1],\n }\n \n-pub type LPWSADATA = *mut WSADATA;\n-\n #[repr(C)]\n pub struct WSANETWORKEVENTS {\n-    pub lNetworkEvents: libc::c_long,\n-    pub iErrorCode: [libc::c_int; FD_MAX_EVENTS],\n+    pub lNetworkEvents: c_long,\n+    pub iErrorCode: [c_int; FD_MAX_EVENTS],\n }\n \n-pub type LPWSANETWORKEVENTS = *mut WSANETWORKEVENTS;\n-\n-pub type WSAEVENT = libc::HANDLE;\n+pub type WSAEVENT = HANDLE;\n \n #[repr(C)]\n pub struct WSAPROTOCOL_INFO {\n-    pub dwServiceFlags1: libc::DWORD,\n-    pub dwServiceFlags2: libc::DWORD,\n-    pub dwServiceFlags3: libc::DWORD,\n-    pub dwServiceFlags4: libc::DWORD,\n-    pub dwProviderFlags: libc::DWORD,\n+    pub dwServiceFlags1: DWORD,\n+    pub dwServiceFlags2: DWORD,\n+    pub dwServiceFlags3: DWORD,\n+    pub dwServiceFlags4: DWORD,\n+    pub dwProviderFlags: DWORD,\n     pub ProviderId: GUID,\n-    pub dwCatalogEntryId: libc::DWORD,\n+    pub dwCatalogEntryId: DWORD,\n     pub ProtocolChain: WSAPROTOCOLCHAIN,\n-    pub iVersion: libc::c_int,\n-    pub iAddressFamily: libc::c_int,\n-    pub iMaxSockAddr: libc::c_int,\n-    pub iMinSockAddr: libc::c_int,\n-    pub iSocketType: libc::c_int,\n-    pub iProtocol: libc::c_int,\n-    pub iProtocolMaxOffset: libc::c_int,\n-    pub iNetworkByteOrder: libc::c_int,\n-    pub iSecurityScheme: libc::c_int,\n-    pub dwMessageSize: libc::DWORD,\n-    pub dwProviderReserved: libc::DWORD,\n+    pub iVersion: c_int,\n+    pub iAddressFamily: c_int,\n+    pub iMaxSockAddr: c_int,\n+    pub iMinSockAddr: c_int,\n+    pub iSocketType: c_int,\n+    pub iProtocol: c_int,\n+    pub iProtocolMaxOffset: c_int,\n+    pub iNetworkByteOrder: c_int,\n+    pub iSecurityScheme: c_int,\n+    pub dwMessageSize: DWORD,\n+    pub dwProviderReserved: DWORD,\n     pub szProtocol: [u16; (WSAPROTOCOL_LEN as usize) + 1],\n }\n \n-pub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;\n-\n #[repr(C)]\n pub struct fd_set {\n-    fd_count: libc::c_uint,\n-    fd_array: [libc::SOCKET; FD_SETSIZE],\n+    fd_count: c_uint,\n+    fd_array: [SOCKET; FD_SETSIZE],\n }\n \n-pub fn fd_set(set: &mut fd_set, s: libc::SOCKET) {\n+pub fn fd_set(set: &mut fd_set, s: SOCKET) {\n     set.fd_array[set.fd_count as usize] = s;\n     set.fd_count += 1;\n }\n \n-pub type SHORT = libc::c_short;\n+pub type SHORT = c_short;\n \n #[repr(C)]\n pub struct COORD {\n@@ -178,39 +421,37 @@ pub struct SMALL_RECT {\n pub struct CONSOLE_SCREEN_BUFFER_INFO {\n     pub dwSize: COORD,\n     pub dwCursorPosition: COORD,\n-    pub wAttributes: libc::WORD,\n+    pub wAttributes: WORD,\n     pub srWindow: SMALL_RECT,\n     pub dwMaximumWindowSize: COORD,\n }\n pub type PCONSOLE_SCREEN_BUFFER_INFO = *mut CONSOLE_SCREEN_BUFFER_INFO;\n \n #[repr(C)]\n-#[derive(Clone)]\n+#[derive(Copy, Clone)]\n pub struct WIN32_FILE_ATTRIBUTE_DATA {\n-    pub dwFileAttributes: libc::DWORD,\n-    pub ftCreationTime: libc::FILETIME,\n-    pub ftLastAccessTime: libc::FILETIME,\n-    pub ftLastWriteTime: libc::FILETIME,\n-    pub nFileSizeHigh: libc::DWORD,\n-    pub nFileSizeLow: libc::DWORD,\n+    pub dwFileAttributes: DWORD,\n+    pub ftCreationTime: FILETIME,\n+    pub ftLastAccessTime: FILETIME,\n+    pub ftLastWriteTime: FILETIME,\n+    pub nFileSizeHigh: DWORD,\n+    pub nFileSizeLow: DWORD,\n }\n \n #[repr(C)]\n pub struct BY_HANDLE_FILE_INFORMATION {\n-    pub dwFileAttributes: libc::DWORD,\n-    pub ftCreationTime: libc::FILETIME,\n-    pub ftLastAccessTime: libc::FILETIME,\n-    pub ftLastWriteTime: libc::FILETIME,\n-    pub dwVolumeSerialNumber: libc::DWORD,\n-    pub nFileSizeHigh: libc::DWORD,\n-    pub nFileSizeLow: libc::DWORD,\n-    pub nNumberOfLinks: libc::DWORD,\n-    pub nFileIndexHigh: libc::DWORD,\n-    pub nFileIndexLow: libc::DWORD,\n+    pub dwFileAttributes: DWORD,\n+    pub ftCreationTime: FILETIME,\n+    pub ftLastAccessTime: FILETIME,\n+    pub ftLastWriteTime: FILETIME,\n+    pub dwVolumeSerialNumber: DWORD,\n+    pub nFileSizeHigh: DWORD,\n+    pub nFileSizeLow: DWORD,\n+    pub nNumberOfLinks: DWORD,\n+    pub nFileIndexHigh: DWORD,\n+    pub nFileIndexLow: DWORD,\n }\n \n-pub type LPBY_HANDLE_FILE_INFORMATION = *mut BY_HANDLE_FILE_INFORMATION;\n-\n #[repr(C)]\n pub enum GET_FILEEX_INFO_LEVELS {\n     GetFileExInfoStandard,\n@@ -245,38 +486,32 @@ pub enum FILE_INFO_BY_HANDLE_CLASS {\n \n #[repr(C)]\n pub struct FILE_END_OF_FILE_INFO {\n-    pub EndOfFile: libc::LARGE_INTEGER,\n+    pub EndOfFile: LARGE_INTEGER,\n }\n \n #[repr(C)]\n pub struct REPARSE_DATA_BUFFER {\n-    pub ReparseTag: libc::c_uint,\n-    pub ReparseDataLength: libc::c_ushort,\n-    pub Reserved: libc::c_ushort,\n+    pub ReparseTag: c_uint,\n+    pub ReparseDataLength: c_ushort,\n+    pub Reserved: c_ushort,\n     pub rest: (),\n }\n \n #[repr(C)]\n pub struct SYMBOLIC_LINK_REPARSE_BUFFER {\n-    pub SubstituteNameOffset: libc::c_ushort,\n-    pub SubstituteNameLength: libc::c_ushort,\n-    pub PrintNameOffset: libc::c_ushort,\n-    pub PrintNameLength: libc::c_ushort,\n-    pub Flags: libc::c_ulong,\n-    pub PathBuffer: libc::WCHAR,\n+    pub SubstituteNameOffset: c_ushort,\n+    pub SubstituteNameLength: c_ushort,\n+    pub PrintNameOffset: c_ushort,\n+    pub PrintNameLength: c_ushort,\n+    pub Flags: c_ulong,\n+    pub PathBuffer: WCHAR,\n }\n \n-pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n-pub type PSRWLOCK = *mut SRWLOCK;\n-pub type ULONG = c_ulong;\n-pub type ULONG_PTR = c_ulong;\n-pub type LPBOOL = *mut BOOL;\n-\n pub type LPPROGRESS_ROUTINE = ::option::Option<unsafe extern \"system\" fn(\n-    TotalFileSize: libc::LARGE_INTEGER,\n-    TotalBytesTransferred: libc::LARGE_INTEGER,\n-    StreamSize: libc::LARGE_INTEGER,\n-    StreamBytesTransferred: libc::LARGE_INTEGER,\n+    TotalFileSize: LARGE_INTEGER,\n+    TotalBytesTransferred: LARGE_INTEGER,\n+    StreamSize: LARGE_INTEGER,\n+    StreamBytesTransferred: LARGE_INTEGER,\n     dwStreamNumber: DWORD,\n     dwCallbackReason: DWORD,\n     hSourceFile: HANDLE,\n@@ -298,22 +533,17 @@ pub struct CRITICAL_SECTION {\n     SpinCount: ULONG_PTR\n }\n \n-pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE {\n-    ptr: ptr::null_mut(),\n-};\n-pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: ptr::null_mut() };\n-\n #[repr(C)]\n pub struct LUID {\n-    pub LowPart: libc::DWORD,\n-    pub HighPart: libc::c_long,\n+    pub LowPart: DWORD,\n+    pub HighPart: c_long,\n }\n \n pub type PLUID = *mut LUID;\n \n #[repr(C)]\n pub struct TOKEN_PRIVILEGES {\n-    pub PrivilegeCount: libc::DWORD,\n+    pub PrivilegeCount: DWORD,\n     pub Privileges: [LUID_AND_ATTRIBUTES; 1],\n }\n \n@@ -322,18 +552,18 @@ pub type PTOKEN_PRIVILEGES = *mut TOKEN_PRIVILEGES;\n #[repr(C)]\n pub struct LUID_AND_ATTRIBUTES {\n     pub Luid: LUID,\n-    pub Attributes: libc::DWORD,\n+    pub Attributes: DWORD,\n }\n \n #[repr(C)]\n pub struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n-    pub ReparseTag: libc::DWORD,\n-    pub ReparseDataLength: libc::DWORD,\n-    pub Reserved: libc::WORD,\n-    pub ReparseTargetLength: libc::WORD,\n-    pub ReparseTargetMaximumLength: libc::WORD,\n-    pub Reserved1: libc::WORD,\n-    pub ReparseTarget: libc::WCHAR,\n+    pub ReparseTag: DWORD,\n+    pub ReparseDataLength: DWORD,\n+    pub Reserved: WORD,\n+    pub ReparseTargetLength: WORD,\n+    pub ReparseTargetMaximumLength: WORD,\n+    pub Reserved1: WORD,\n+    pub ReparseTarget: WCHAR,\n }\n \n #[repr(C)]\n@@ -349,175 +579,658 @@ pub struct EXCEPTION_RECORD {\n #[repr(C)]\n pub struct EXCEPTION_POINTERS {\n     pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-    pub ContextRecord: LPVOID\n+    pub ContextRecord: *mut CONTEXT,\n }\n \n pub type PVECTORED_EXCEPTION_HANDLER = extern \"system\"\n         fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n \n+#[repr(C)]\n+pub struct GUID {\n+    pub Data1: DWORD,\n+    pub Data2: WORD,\n+    pub Data3: WORD,\n+    pub Data4: [BYTE; 8],\n+}\n+\n+#[repr(C)]\n+pub struct WSAPROTOCOLCHAIN {\n+    pub ChainLen: c_int,\n+    pub ChainEntries: [DWORD; MAX_PROTOCOL_CHAIN as usize],\n+}\n+\n+#[repr(C)]\n+pub struct SECURITY_ATTRIBUTES {\n+    pub nLength: DWORD,\n+    pub lpSecurityDescriptor: LPVOID,\n+    pub bInheritHandle: BOOL,\n+}\n+\n+#[repr(C)]\n+pub struct PROCESS_INFORMATION {\n+    pub hProcess: HANDLE,\n+    pub hThread: HANDLE,\n+    pub dwProcessId: DWORD,\n+    pub dwThreadId: DWORD,\n+}\n+\n+#[repr(C)]\n+pub struct STARTUPINFO {\n+    pub cb: DWORD,\n+    pub lpReserved: LPWSTR,\n+    pub lpDesktop: LPWSTR,\n+    pub lpTitle: LPWSTR,\n+    pub dwX: DWORD,\n+    pub dwY: DWORD,\n+    pub dwXSize: DWORD,\n+    pub dwYSize: DWORD,\n+    pub dwXCountChars: DWORD,\n+    pub dwYCountCharts: DWORD,\n+    pub dwFillAttribute: DWORD,\n+    pub dwFlags: DWORD,\n+    pub wShowWindow: WORD,\n+    pub cbReserved2: WORD,\n+    pub lpReserved2: LPBYTE,\n+    pub hStdInput: HANDLE,\n+    pub hStdOutput: HANDLE,\n+    pub hStdError: HANDLE,\n+}\n+\n+#[repr(C)]\n+pub struct SOCKADDR {\n+    pub sa_family: ADDRESS_FAMILY,\n+    pub sa_data: [CHAR; 14],\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct FILETIME {\n+    pub dwLowDateTime: DWORD,\n+    pub dwHighDateTime: DWORD,\n+}\n+\n+#[repr(C)]\n+pub struct OVERLAPPED {\n+    pub Internal: *mut c_ulong,\n+    pub InternalHigh: *mut c_ulong,\n+    pub Offset: DWORD,\n+    pub OffsetHigh: DWORD,\n+    pub hEvent: HANDLE,\n+}\n+\n+#[repr(C)]\n+pub struct SYMBOL_INFO {\n+    pub SizeOfStruct: c_ulong,\n+    pub TypeIndex: c_ulong,\n+    pub Reserved: [u64; 2],\n+    pub Index: c_ulong,\n+    pub Size: c_ulong,\n+    pub ModBase: u64,\n+    pub Flags: c_ulong,\n+    pub Value: u64,\n+    pub Address: u64,\n+    pub Register: c_ulong,\n+    pub Scope: c_ulong,\n+    pub Tag: c_ulong,\n+    pub NameLen: c_ulong,\n+    pub MaxNameLen: c_ulong,\n+    // note that windows has this as 1, but it basically just means that\n+    // the name is inline at the end of the struct. For us, we just bump\n+    // the struct size up to MAX_SYM_NAME.\n+    pub Name: [c_char; MAX_SYM_NAME],\n+}\n+\n+#[repr(C)]\n+pub struct IMAGEHLP_LINE64 {\n+    pub SizeOfStruct: u32,\n+    pub Key: *const c_void,\n+    pub LineNumber: u32,\n+    pub Filename: *const c_char,\n+    pub Address: u64,\n+}\n+\n+#[repr(C)]\n+pub enum ADDRESS_MODE {\n+    AddrMode1616,\n+    AddrMode1632,\n+    AddrModeReal,\n+    AddrModeFlat,\n+}\n+\n+#[repr(C)]\n+pub struct ADDRESS64 {\n+    pub Offset: u64,\n+    pub Segment: u16,\n+    pub Mode: ADDRESS_MODE,\n+}\n+\n+#[repr(C)]\n+pub struct STACKFRAME64 {\n+    pub AddrPC: ADDRESS64,\n+    pub AddrReturn: ADDRESS64,\n+    pub AddrFrame: ADDRESS64,\n+    pub AddrStack: ADDRESS64,\n+    pub AddrBStore: ADDRESS64,\n+    pub FuncTableEntry: *mut c_void,\n+    pub Params: [u64; 4],\n+    pub Far: BOOL,\n+    pub Virtual: BOOL,\n+    pub Reserved: [u64; 3],\n+    pub KdHelp: KDHELP64,\n+}\n+\n+#[repr(C)]\n+pub struct KDHELP64 {\n+    pub Thread: u64,\n+    pub ThCallbackStack: DWORD,\n+    pub ThCallbackBStore: DWORD,\n+    pub NextCallback: DWORD,\n+    pub FramePointer: DWORD,\n+    pub KiCallUserMode: u64,\n+    pub KeUserCallbackDispatcher: u64,\n+    pub SystemRangeStart: u64,\n+    pub KiUserExceptionDispatcher: u64,\n+    pub StackBase: u64,\n+    pub StackLimit: u64,\n+    pub Reserved: [u64; 5],\n+}\n+\n+#[cfg(target_arch = \"x86\")]\n+#[repr(C)]\n+pub struct CONTEXT {\n+    pub ContextFlags: DWORD,\n+    pub Dr0: DWORD,\n+    pub Dr1: DWORD,\n+    pub Dr2: DWORD,\n+    pub Dr3: DWORD,\n+    pub Dr6: DWORD,\n+    pub Dr7: DWORD,\n+    pub FloatSave: FLOATING_SAVE_AREA,\n+    pub SegGs: DWORD,\n+    pub SegFs: DWORD,\n+    pub SegEs: DWORD,\n+    pub SegDs: DWORD,\n+    pub Edi: DWORD,\n+    pub Esi: DWORD,\n+    pub Ebx: DWORD,\n+    pub Edx: DWORD,\n+    pub Ecx: DWORD,\n+    pub Eax: DWORD,\n+    pub Ebp: DWORD,\n+    pub Eip: DWORD,\n+    pub SegCs: DWORD,\n+    pub EFlags: DWORD,\n+    pub Esp: DWORD,\n+    pub SegSs: DWORD,\n+    pub ExtendedRegisters: [u8; 512],\n+}\n+\n+#[cfg(target_arch = \"x86\")]\n+#[repr(C)]\n+pub struct FLOATING_SAVE_AREA {\n+    pub ControlWord: DWORD,\n+    pub StatusWord: DWORD,\n+    pub TagWord: DWORD,\n+    pub ErrorOffset: DWORD,\n+    pub ErrorSelector: DWORD,\n+    pub DataOffset: DWORD,\n+    pub DataSelector: DWORD,\n+    pub RegisterArea: [u8; 80],\n+    pub Cr0NpxState: DWORD,\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[repr(C)]\n+pub struct CONTEXT {\n+    _align_hack: [simd::u64x2; 0], // FIXME align on 16-byte\n+    pub P1Home: DWORDLONG,\n+    pub P2Home: DWORDLONG,\n+    pub P3Home: DWORDLONG,\n+    pub P4Home: DWORDLONG,\n+    pub P5Home: DWORDLONG,\n+    pub P6Home: DWORDLONG,\n+\n+    pub ContextFlags: DWORD,\n+    pub MxCsr: DWORD,\n+\n+    pub SegCs: WORD,\n+    pub SegDs: WORD,\n+    pub SegEs: WORD,\n+    pub SegFs: WORD,\n+    pub SegGs: WORD,\n+    pub SegSs: WORD,\n+    pub EFlags: DWORD,\n+\n+    pub Dr0: DWORDLONG,\n+    pub Dr1: DWORDLONG,\n+    pub Dr2: DWORDLONG,\n+    pub Dr3: DWORDLONG,\n+    pub Dr6: DWORDLONG,\n+    pub Dr7: DWORDLONG,\n+\n+    pub Rax: DWORDLONG,\n+    pub Rcx: DWORDLONG,\n+    pub Rdx: DWORDLONG,\n+    pub Rbx: DWORDLONG,\n+    pub Rsp: DWORDLONG,\n+    pub Rbp: DWORDLONG,\n+    pub Rsi: DWORDLONG,\n+    pub Rdi: DWORDLONG,\n+    pub R8:  DWORDLONG,\n+    pub R9:  DWORDLONG,\n+    pub R10: DWORDLONG,\n+    pub R11: DWORDLONG,\n+    pub R12: DWORDLONG,\n+    pub R13: DWORDLONG,\n+    pub R14: DWORDLONG,\n+    pub R15: DWORDLONG,\n+\n+    pub Rip: DWORDLONG,\n+\n+    pub FltSave: FLOATING_SAVE_AREA,\n+\n+    pub VectorRegister: [M128A; 26],\n+    pub VectorControl: DWORDLONG,\n+\n+    pub DebugControl: DWORDLONG,\n+    pub LastBranchToRip: DWORDLONG,\n+    pub LastBranchFromRip: DWORDLONG,\n+    pub LastExceptionToRip: DWORDLONG,\n+    pub LastExceptionFromRip: DWORDLONG,\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[repr(C)]\n+pub struct M128A {\n+    _align_hack: [simd::u64x2; 0], // FIXME align on 16-byte\n+    pub Low:  c_ulonglong,\n+    pub High: c_longlong\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[repr(C)]\n+pub struct FLOATING_SAVE_AREA {\n+    _align_hack: [simd::u64x2; 0], // FIXME align on 16-byte\n+    _Dummy: [u8; 512] // FIXME: Fill this out\n+}\n+\n+#[repr(C)]\n+pub struct SOCKADDR_STORAGE_LH {\n+    pub ss_family: ADDRESS_FAMILY,\n+    pub __ss_pad1: [CHAR; 6],\n+    pub __ss_align: i64,\n+    pub __ss_pad2: [CHAR; 112],\n+}\n+\n+#[repr(C)]\n+pub struct ADDRINFOA {\n+    pub ai_flags: c_int,\n+    pub ai_family: c_int,\n+    pub ai_socktype: c_int,\n+    pub ai_protocol: c_int,\n+    pub ai_addrlen: size_t,\n+    pub ai_canonname: *mut c_char,\n+    pub ai_addr: *mut SOCKADDR,\n+    pub ai_next: *mut ADDRINFOA,\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct sockaddr_in {\n+    pub sin_family: ADDRESS_FAMILY,\n+    pub sin_port: USHORT,\n+    pub sin_addr: in_addr,\n+    pub sin_zero: [CHAR; 8],\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct sockaddr_in6 {\n+    pub sin6_family: ADDRESS_FAMILY,\n+    pub sin6_port: USHORT,\n+    pub sin6_flowinfo: c_ulong,\n+    pub sin6_addr: in6_addr,\n+    pub sin6_scope_id: c_ulong,\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct in_addr {\n+    pub s_addr: u32,\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct in6_addr {\n+    pub s6_addr: [u8; 16],\n+}\n+\n+pub enum UNWIND_HISTORY_TABLE {}\n+\n+#[repr(C)]\n+pub struct RUNTIME_FUNCTION {\n+    pub BeginAddress: DWORD,\n+    pub EndAddress: DWORD,\n+    pub UnwindData: DWORD,\n+}\n+\n+#[repr(C)]\n+pub struct DISPATCHER_CONTEXT {\n+    pub ControlPc: LPVOID,\n+    pub ImageBase: LPVOID,\n+    pub FunctionEntry: *const RUNTIME_FUNCTION,\n+    pub EstablisherFrame: LPVOID,\n+    pub TargetIp: LPVOID,\n+    pub ContextRecord: *const CONTEXT,\n+    pub LanguageHandler: LPVOID,\n+    pub HandlerData: *const u8,\n+    pub HistoryTable: *const UNWIND_HISTORY_TABLE,\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum EXCEPTION_DISPOSITION {\n+    ExceptionContinueExecution,\n+    ExceptionContinueSearch,\n+    ExceptionNestedException,\n+    ExceptionCollidedUnwind\n+}\n+\n #[link(name = \"ws2_32\")]\n #[link(name = \"userenv\")]\n #[link(name = \"shell32\")]\n+#[link(name = \"advapi32\")]\n extern \"system\" {\n-    pub fn WSAStartup(wVersionRequested: libc::WORD,\n-                      lpWSAData: LPWSADATA) -> libc::c_int;\n-    pub fn WSACleanup() -> libc::c_int;\n-    pub fn WSAGetLastError() -> libc::c_int;\n-    pub fn WSACloseEvent(hEvent: WSAEVENT) -> libc::BOOL;\n-    pub fn WSACreateEvent() -> WSAEVENT;\n-    pub fn WSAEventSelect(s: libc::SOCKET,\n-                          hEventObject: WSAEVENT,\n-                          lNetworkEvents: libc::c_long) -> libc::c_int;\n-    pub fn WSASetEvent(hEvent: WSAEVENT) -> libc::BOOL;\n-    pub fn WSAWaitForMultipleEvents(cEvents: libc::DWORD,\n-                                    lphEvents: *const WSAEVENT,\n-                                    fWaitAll: libc::BOOL,\n-                                    dwTimeout: libc::DWORD,\n-                                    fAltertable: libc::BOOL) -> libc::DWORD;\n-    pub fn WSAEnumNetworkEvents(s: libc::SOCKET,\n-                                hEventObject: WSAEVENT,\n-                                lpNetworkEvents: LPWSANETWORKEVENTS)\n-                                -> libc::c_int;\n-    pub fn WSADuplicateSocketW(s: libc::SOCKET,\n-                               dwProcessId: libc::DWORD,\n+    pub fn WSAStartup(wVersionRequested: WORD,\n+                      lpWSAData: LPWSADATA) -> c_int;\n+    pub fn WSACleanup() -> c_int;\n+    pub fn WSAGetLastError() -> c_int;\n+    pub fn WSADuplicateSocketW(s: SOCKET,\n+                               dwProcessId: DWORD,\n                                lpProtocolInfo: LPWSAPROTOCOL_INFO)\n-                               -> libc::c_int;\n-    pub fn GetCurrentProcessId() -> libc::DWORD;\n-    pub fn WSASocketW(af: libc::c_int,\n-                      kind: libc::c_int,\n-                      protocol: libc::c_int,\n+                               -> c_int;\n+    pub fn GetCurrentProcessId() -> DWORD;\n+    pub fn WSASocketW(af: c_int,\n+                      kind: c_int,\n+                      protocol: c_int,\n                       lpProtocolInfo: LPWSAPROTOCOL_INFO,\n                       g: GROUP,\n-                      dwFlags: libc::DWORD) -> libc::SOCKET;\n-\n-    pub fn ioctlsocket(s: libc::SOCKET, cmd: libc::c_long,\n-                       argp: *mut libc::c_ulong) -> libc::c_int;\n-    pub fn select(nfds: libc::c_int,\n-                  readfds: *mut fd_set,\n-                  writefds: *mut fd_set,\n-                  exceptfds: *mut fd_set,\n-                  timeout: *mut libc::timeval) -> libc::c_int;\n-    pub fn getsockopt(sockfd: libc::SOCKET,\n-                      level: libc::c_int,\n-                      optname: libc::c_int,\n-                      optval: *mut libc::c_char,\n-                      optlen: *mut libc::c_int) -> libc::c_int;\n-\n-    pub fn SetEvent(hEvent: libc::HANDLE) -> libc::BOOL;\n-    pub fn WaitForMultipleObjects(nCount: libc::DWORD,\n-                                  lpHandles: *const libc::HANDLE,\n-                                  bWaitAll: libc::BOOL,\n-                                  dwMilliseconds: libc::DWORD) -> libc::DWORD;\n-\n-    pub fn CancelIo(hFile: libc::HANDLE) -> libc::BOOL;\n-    pub fn CancelIoEx(hFile: libc::HANDLE,\n-                      lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;\n-\n+                      dwFlags: DWORD) -> SOCKET;\n     pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOLEAN;\n     pub fn LeaveCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn DeleteCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n \n     // FIXME - pInputControl should be PCONSOLE_READCONSOLE_CONTROL\n-    pub fn ReadConsoleW(hConsoleInput: libc::HANDLE,\n-                        lpBuffer: libc::LPVOID,\n-                        nNumberOfCharsToRead: libc::DWORD,\n-                        lpNumberOfCharsRead: libc::LPDWORD,\n-                        pInputControl: libc::LPVOID) -> libc::BOOL;\n-\n-    pub fn WriteConsoleW(hConsoleOutput: libc::HANDLE,\n-                         lpBuffer: libc::types::os::arch::extra::LPCVOID,\n-                         nNumberOfCharsToWrite: libc::DWORD,\n-                         lpNumberOfCharsWritten: libc::LPDWORD,\n-                         lpReserved: libc::LPVOID) -> libc::BOOL;\n-\n-    pub fn GetConsoleMode(hConsoleHandle: libc::HANDLE,\n-                          lpMode: libc::LPDWORD) -> libc::BOOL;\n-\n-    pub fn SetConsoleMode(hConsoleHandle: libc::HANDLE,\n-                          lpMode: libc::DWORD) -> libc::BOOL;\n-    pub fn GetConsoleScreenBufferInfo(\n-        hConsoleOutput: libc::HANDLE,\n-        lpConsoleScreenBufferInfo: PCONSOLE_SCREEN_BUFFER_INFO,\n-    ) -> libc::BOOL;\n-\n-    pub fn GetFileAttributesExW(lpFileName: libc::LPCWSTR,\n+    pub fn ReadConsoleW(hConsoleInput: HANDLE,\n+                        lpBuffer: LPVOID,\n+                        nNumberOfCharsToRead: DWORD,\n+                        lpNumberOfCharsRead: LPDWORD,\n+                        pInputControl: LPVOID) -> BOOL;\n+\n+    pub fn WriteConsoleW(hConsoleOutput: HANDLE,\n+                         lpBuffer: LPCVOID,\n+                         nNumberOfCharsToWrite: DWORD,\n+                         lpNumberOfCharsWritten: LPDWORD,\n+                         lpReserved: LPVOID) -> BOOL;\n+\n+    pub fn GetConsoleMode(hConsoleHandle: HANDLE,\n+                          lpMode: LPDWORD) -> BOOL;\n+    pub fn GetFileAttributesExW(lpFileName: LPCWSTR,\n                                 fInfoLevelId: GET_FILEEX_INFO_LEVELS,\n-                                lpFileInformation: libc::LPVOID) -> libc::BOOL;\n-    pub fn RemoveDirectoryW(lpPathName: libc::LPCWSTR) -> libc::BOOL;\n-    pub fn SetFileAttributesW(lpFileName: libc::LPCWSTR,\n-                              dwFileAttributes: libc::DWORD) -> libc::BOOL;\n-    pub fn GetFileAttributesW(lpFileName: libc::LPCWSTR) -> libc::DWORD;\n-    pub fn GetFileInformationByHandle(hFile: libc::HANDLE,\n+                                lpFileInformation: LPVOID) -> BOOL;\n+    pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n+    pub fn SetFileAttributesW(lpFileName: LPCWSTR,\n+                              dwFileAttributes: DWORD) -> BOOL;\n+    pub fn GetFileInformationByHandle(hFile: HANDLE,\n                             lpFileInformation: LPBY_HANDLE_FILE_INFORMATION)\n-                            -> libc::BOOL;\n-\n-    pub fn SetLastError(dwErrCode: libc::DWORD);\n-    pub fn GetCommandLineW() -> *mut libc::LPCWSTR;\n-    pub fn LocalFree(ptr: *mut libc::c_void);\n-    pub fn CommandLineToArgvW(lpCmdLine: *mut libc::LPCWSTR,\n-                              pNumArgs: *mut libc::c_int) -> *mut *mut u16;\n-    pub fn SetFileTime(hFile: libc::HANDLE,\n-                       lpCreationTime: *const libc::FILETIME,\n-                       lpLastAccessTime: *const libc::FILETIME,\n-                       lpLastWriteTime: *const libc::FILETIME) -> libc::BOOL;\n-    pub fn GetTempPathW(nBufferLength: libc::DWORD,\n-                        lpBuffer: libc::LPCWSTR) -> libc::DWORD;\n-    pub fn OpenProcessToken(ProcessHandle: libc::HANDLE,\n-                            DesiredAccess: libc::DWORD,\n-                            TokenHandle: *mut libc::HANDLE) -> libc::BOOL;\n-    pub fn GetCurrentProcess() -> libc::HANDLE;\n-    pub fn GetStdHandle(which: libc::DWORD) -> libc::HANDLE;\n-    pub fn ExitProcess(uExitCode: libc::c_uint) -> !;\n-    pub fn DeviceIoControl(hDevice: libc::HANDLE,\n-                           dwIoControlCode: libc::DWORD,\n-                           lpInBuffer: libc::LPVOID,\n-                           nInBufferSize: libc::DWORD,\n-                           lpOutBuffer: libc::LPVOID,\n-                           nOutBufferSize: libc::DWORD,\n-                           lpBytesReturned: libc::LPDWORD,\n-                           lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;\n-    pub fn CreatePipe(hReadPipe: libc::LPHANDLE,\n-                      hWritePipe: libc::LPHANDLE,\n-                      lpPipeAttributes: libc::LPSECURITY_ATTRIBUTES,\n-                      nSize: libc::DWORD) -> libc::BOOL;\n-    pub fn CreateThread(lpThreadAttributes: libc::LPSECURITY_ATTRIBUTES,\n-                        dwStackSize: libc::SIZE_T,\n-                        lpStartAddress: extern \"system\" fn(*mut libc::c_void)\n-                                                           -> libc::DWORD,\n-                        lpParameter: libc::LPVOID,\n-                        dwCreationFlags: libc::DWORD,\n-                        lpThreadId: libc::LPDWORD) -> libc::HANDLE;\n-    pub fn WaitForSingleObject(hHandle: libc::HANDLE,\n-                               dwMilliseconds: libc::DWORD) -> libc::DWORD;\n-    pub fn SwitchToThread() -> libc::BOOL;\n-    pub fn Sleep(dwMilliseconds: libc::DWORD);\n-    pub fn GetProcessId(handle: libc::HANDLE) -> libc::DWORD;\n-    pub fn GetUserProfileDirectoryW(hToken: libc::HANDLE,\n-                                    lpProfileDir: libc::LPCWSTR,\n-                                    lpcchSize: *mut libc::DWORD) -> libc::BOOL;\n-    pub fn SetHandleInformation(hObject: libc::HANDLE,\n-                                dwMask: libc::DWORD,\n-                                dwFlags: libc::DWORD) -> libc::BOOL;\n-    pub fn CopyFileExW(lpExistingFileName: libc::LPCWSTR,\n-                       lpNewFileName: libc::LPCWSTR,\n+                            -> BOOL;\n+\n+    pub fn SetLastError(dwErrCode: DWORD);\n+    pub fn GetCommandLineW() -> *mut LPCWSTR;\n+    pub fn LocalFree(ptr: *mut c_void);\n+    pub fn CommandLineToArgvW(lpCmdLine: *mut LPCWSTR,\n+                              pNumArgs: *mut c_int) -> *mut *mut u16;\n+    pub fn GetTempPathW(nBufferLength: DWORD,\n+                        lpBuffer: LPCWSTR) -> DWORD;\n+    pub fn OpenProcessToken(ProcessHandle: HANDLE,\n+                            DesiredAccess: DWORD,\n+                            TokenHandle: *mut HANDLE) -> BOOL;\n+    pub fn GetCurrentProcess() -> HANDLE;\n+    pub fn GetCurrentThread() -> HANDLE;\n+    pub fn GetStdHandle(which: DWORD) -> HANDLE;\n+    pub fn ExitProcess(uExitCode: c_uint) -> !;\n+    pub fn DeviceIoControl(hDevice: HANDLE,\n+                           dwIoControlCode: DWORD,\n+                           lpInBuffer: LPVOID,\n+                           nInBufferSize: DWORD,\n+                           lpOutBuffer: LPVOID,\n+                           nOutBufferSize: DWORD,\n+                           lpBytesReturned: LPDWORD,\n+                           lpOverlapped: LPOVERLAPPED) -> BOOL;\n+    pub fn CreatePipe(hReadPipe: LPHANDLE,\n+                      hWritePipe: LPHANDLE,\n+                      lpPipeAttributes: LPSECURITY_ATTRIBUTES,\n+                      nSize: DWORD) -> BOOL;\n+    pub fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n+                        dwStackSize: SIZE_T,\n+                        lpStartAddress: extern \"system\" fn(*mut c_void)\n+                                                           -> DWORD,\n+                        lpParameter: LPVOID,\n+                        dwCreationFlags: DWORD,\n+                        lpThreadId: LPDWORD) -> HANDLE;\n+    pub fn WaitForSingleObject(hHandle: HANDLE,\n+                               dwMilliseconds: DWORD) -> DWORD;\n+    pub fn SwitchToThread() -> BOOL;\n+    pub fn Sleep(dwMilliseconds: DWORD);\n+    pub fn GetProcessId(handle: HANDLE) -> DWORD;\n+    pub fn GetUserProfileDirectoryW(hToken: HANDLE,\n+                                    lpProfileDir: LPCWSTR,\n+                                    lpcchSize: *mut DWORD) -> BOOL;\n+    pub fn SetHandleInformation(hObject: HANDLE,\n+                                dwMask: DWORD,\n+                                dwFlags: DWORD) -> BOOL;\n+    pub fn CopyFileExW(lpExistingFileName: LPCWSTR,\n+                       lpNewFileName: LPCWSTR,\n                        lpProgressRoutine: LPPROGRESS_ROUTINE,\n-                       lpData: libc::LPVOID,\n+                       lpData: LPVOID,\n                        pbCancel: LPBOOL,\n-                       dwCopyFlags: libc::DWORD) -> libc::BOOL;\n-    pub fn LookupPrivilegeValueW(lpSystemName: libc::LPCWSTR,\n-                                 lpName: libc::LPCWSTR,\n-                                 lpLuid: PLUID) -> libc::BOOL;\n-    pub fn AdjustTokenPrivileges(TokenHandle: libc::HANDLE,\n-                                 DisableAllPrivileges: libc::BOOL,\n+                       dwCopyFlags: DWORD) -> BOOL;\n+    pub fn LookupPrivilegeValueW(lpSystemName: LPCWSTR,\n+                                 lpName: LPCWSTR,\n+                                 lpLuid: PLUID) -> BOOL;\n+    pub fn AdjustTokenPrivileges(TokenHandle: HANDLE,\n+                                 DisableAllPrivileges: BOOL,\n                                  NewState: PTOKEN_PRIVILEGES,\n-                                 BufferLength: libc::DWORD,\n+                                 BufferLength: DWORD,\n                                  PreviousState: PTOKEN_PRIVILEGES,\n-                                 ReturnLength: *mut libc::DWORD) -> libc::BOOL;\n+                                 ReturnLength: *mut DWORD) -> BOOL;\n     pub fn AddVectoredExceptionHandler(FirstHandler: ULONG,\n                                        VectoredHandler: PVECTORED_EXCEPTION_HANDLER)\n                                        -> LPVOID;\n+    pub fn FormatMessageW(flags: DWORD,\n+                          lpSrc: LPVOID,\n+                          msgId: DWORD,\n+                          langId: DWORD,\n+                          buf: LPWSTR,\n+                          nsize: DWORD,\n+                          args: *const c_void)\n+                          -> DWORD;\n+    pub fn TlsAlloc() -> DWORD;\n+    pub fn TlsFree(dwTlsIndex: DWORD) -> BOOL;\n+    pub fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n+    pub fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n+    pub fn GetLastError() -> DWORD;\n+    pub fn QueryPerformanceFrequency(lpFrequency: *mut LARGE_INTEGER) -> BOOL;\n+    pub fn QueryPerformanceCounter(lpPerformanceCount: *mut LARGE_INTEGER)\n+                                   -> BOOL;\n+    pub fn GetExitCodeProcess(hProcess: HANDLE, lpExitCode: LPDWORD) -> BOOL;\n+    pub fn TerminateProcess(hProcess: HANDLE, uExitCode: UINT) -> BOOL;\n+    pub fn CreateProcessW(lpApplicationName: LPCWSTR,\n+                          lpCommandLine: LPWSTR,\n+                          lpProcessAttributes: LPSECURITY_ATTRIBUTES,\n+                          lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n+                          bInheritHandles: BOOL,\n+                          dwCreationFlags: DWORD,\n+                          lpEnvironment: LPVOID,\n+                          lpCurrentDirectory: LPCWSTR,\n+                          lpStartupInfo: LPSTARTUPINFO,\n+                          lpProcessInformation: LPPROCESS_INFORMATION)\n+                          -> BOOL;\n+    pub fn GetEnvironmentVariableW(n: LPCWSTR, v: LPWSTR, nsize: DWORD) -> DWORD;\n+    pub fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR) -> BOOL;\n+    pub fn GetEnvironmentStringsW() -> LPWCH;\n+    pub fn FreeEnvironmentStringsW(env_ptr: LPWCH) -> BOOL;\n+    pub fn GetModuleFileNameW(hModule: HMODULE,\n+                              lpFilename: LPWSTR,\n+                              nSize: DWORD)\n+                              -> DWORD;\n+    pub fn CreateDirectoryW(lpPathName: LPCWSTR,\n+                            lpSecurityAttributes: LPSECURITY_ATTRIBUTES)\n+                            -> BOOL;\n+    pub fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;\n+    pub fn GetCurrentDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;\n+    pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n+\n+    pub fn closesocket(socket: SOCKET) -> c_int;\n+    pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int,\n+                flags: c_int) -> c_int;\n+    pub fn send(socket: SOCKET, buf: *const c_void, len: c_int,\n+                flags: c_int) -> c_int;\n+    pub fn recvfrom(socket: SOCKET,\n+                    buf: *mut c_void,\n+                    len: c_int,\n+                    flags: c_int,\n+                    addr: *mut SOCKADDR,\n+                    addrlen: *mut c_int)\n+                    -> c_int;\n+    pub fn sendto(socket: SOCKET,\n+                  buf: *const c_void,\n+                  len: c_int,\n+                  flags: c_int,\n+                  addr: *const SOCKADDR,\n+                  addrlen: c_int)\n+                  -> c_int;\n+    pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;\n+    pub fn accept(socket: SOCKET,\n+                  address: *mut SOCKADDR,\n+                  address_len: *mut c_int)\n+                  -> SOCKET;\n+    pub fn DuplicateHandle(hSourceProcessHandle: HANDLE,\n+                           hSourceHandle: HANDLE,\n+                           hTargetProcessHandle: HANDLE,\n+                           lpTargetHandle: LPHANDLE,\n+                           dwDesiredAccess: DWORD,\n+                           bInheritHandle: BOOL,\n+                           dwOptions: DWORD)\n+                           -> BOOL;\n+    pub fn ReadFile(hFile: HANDLE,\n+                    lpBuffer: LPVOID,\n+                    nNumberOfBytesToRead: DWORD,\n+                    lpNumberOfBytesRead: LPDWORD,\n+                    lpOverlapped: LPOVERLAPPED)\n+                    -> BOOL;\n+    pub fn WriteFile(hFile: HANDLE,\n+                     lpBuffer: LPVOID,\n+                     nNumberOfBytesToWrite: DWORD,\n+                     lpNumberOfBytesWritten: LPDWORD,\n+                     lpOverlapped: LPOVERLAPPED)\n+                     -> BOOL;\n+    pub fn CloseHandle(hObject: HANDLE) -> BOOL;\n+    pub fn CreateHardLinkW(lpSymlinkFileName: LPCWSTR,\n+                           lpTargetFileName: LPCWSTR,\n+                           lpSecurityAttributes: LPSECURITY_ATTRIBUTES)\n+                           -> BOOL;\n+    pub fn MoveFileExW(lpExistingFileName: LPCWSTR,\n+                       lpNewFileName: LPCWSTR,\n+                       dwFlags: DWORD)\n+                       -> BOOL;\n+    pub fn SetFilePointerEx(hFile: HANDLE,\n+                            liDistanceToMove: LARGE_INTEGER,\n+                            lpNewFilePointer: PLARGE_INTEGER,\n+                            dwMoveMethod: DWORD)\n+                            -> BOOL;\n+    pub fn FlushFileBuffers(hFile: HANDLE) -> BOOL;\n+    pub fn CreateFileW(lpFileName: LPCWSTR,\n+                       dwDesiredAccess: DWORD,\n+                       dwShareMode: DWORD,\n+                       lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n+                       dwCreationDisposition: DWORD,\n+                       dwFlagsAndAttributes: DWORD,\n+                       hTemplateFile: HANDLE)\n+                       -> HANDLE;\n+\n+    pub fn FindFirstFileW(fileName: LPCWSTR,\n+                          findFileData: LPWIN32_FIND_DATAW)\n+                          -> HANDLE;\n+    pub fn FindNextFileW(findFile: HANDLE, findFileData: LPWIN32_FIND_DATAW)\n+                         -> BOOL;\n+    pub fn FindClose(findFile: HANDLE) -> BOOL;\n+    pub fn RtlCaptureContext(ctx: *mut CONTEXT);\n+    pub fn getsockopt(s: SOCKET,\n+                      level: c_int,\n+                      optname: c_int,\n+                      optval: *mut c_char,\n+                      optlen: *mut c_int)\n+                      -> c_int;\n+    pub fn setsockopt(s: SOCKET,\n+                      level: c_int,\n+                      optname: c_int,\n+                      optval: *const c_void,\n+                      optlen: c_int)\n+                      -> c_int;\n+    pub fn getsockname(socket: SOCKET,\n+                       address: *mut SOCKADDR,\n+                       address_len: *mut c_int)\n+                       -> c_int;\n+    pub fn getpeername(socket: SOCKET,\n+                       address: *mut SOCKADDR,\n+                       address_len: *mut c_int)\n+                       -> c_int;\n+    pub fn bind(socket: SOCKET, address: *const SOCKADDR,\n+                address_len: socklen_t) -> c_int;\n+    pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;\n+    pub fn connect(socket: SOCKET, address: *const SOCKADDR, len: c_int)\n+                   -> c_int;\n+    pub fn getaddrinfo(node: *const c_char, service: *const c_char,\n+                       hints: *const ADDRINFOA,\n+                       res: *mut *mut ADDRINFOA) -> c_int;\n+    pub fn freeaddrinfo(res: *mut ADDRINFOA);\n+    pub fn getnameinfo(sa: *const SOCKADDR, salen: c_int,\n+                       host: *mut c_char, hostlen: DWORD,\n+                       serv: *mut c_char, servlen: DWORD,\n+                       flags: c_int) -> c_int;\n+\n+    pub fn LoadLibraryW(name: LPCWSTR) -> HMODULE;\n+    pub fn GetModuleHandleExW(dwFlags: DWORD, name: LPCWSTR,\n+                              handle: *mut HMODULE) -> BOOL;\n+    pub fn GetProcAddress(handle: HMODULE,\n+                          name: LPCSTR) -> *mut c_void;\n+    pub fn FreeLibrary(handle: HMODULE) -> BOOL;\n+    pub fn SetErrorMode(uMode: c_uint) -> c_uint;\n+    pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n+    pub fn CryptAcquireContextA(phProv: *mut HCRYPTPROV,\n+                                pszContainer: LPCSTR,\n+                                pszProvider: LPCSTR,\n+                                dwProvType: DWORD,\n+                                dwFlags: DWORD) -> BOOL;\n+    pub fn CryptGenRandom(hProv: HCRYPTPROV,\n+                          dwLen: DWORD,\n+                          pbBuffer: *mut BYTE) -> BOOL;\n+    pub fn CryptReleaseContext(hProv: HCRYPTPROV, dwFlags: DWORD) -> BOOL;\n+\n+    #[unwind]\n+    pub fn RaiseException(dwExceptionCode: DWORD,\n+                          dwExceptionFlags: DWORD,\n+                          nNumberOfArguments: DWORD,\n+                          lpArguments: *const ULONG_PTR);\n+    pub fn RtlUnwindEx(TargetFrame: LPVOID,\n+                       TargetIp: LPVOID,\n+                       ExceptionRecord: *const EXCEPTION_RECORD,\n+                       ReturnValue: LPVOID,\n+                       OriginalContext: *const CONTEXT,\n+                       HistoryTable: *const UNWIND_HISTORY_TABLE);\n }\n \n // Functions that aren't available on Windows XP, but we still use them and just"}, {"sha": "780a0d9427d594ad5f5bb3af661f6c9310f4c0ad", "filename": "src/libstd/sys/windows/compat.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -24,21 +24,16 @@\n use prelude::v1::*;\n \n use ffi::CString;\n-use libc::{LPVOID, LPCWSTR, HMODULE, LPCSTR};\n use sync::atomic::{AtomicUsize, Ordering};\n-\n-extern \"system\" {\n-    fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n-    fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;\n-}\n+use sys::c;\n \n pub fn lookup(module: &str, symbol: &str) -> Option<usize> {\n     let mut module: Vec<u16> = module.utf16_units().collect();\n     module.push(0);\n     let symbol = CString::new(symbol).unwrap();\n     unsafe {\n-        let handle = GetModuleHandleW(module.as_ptr());\n-        match GetProcAddress(handle, symbol.as_ptr()) as usize {\n+        let handle = c::GetModuleHandleW(module.as_ptr());\n+        match c::GetProcAddress(handle, symbol.as_ptr()) as usize {\n             0 => None,\n             n => Some(n),\n         }"}, {"sha": "8075374d42bdda788504fe95a8e405d6e30da33c", "filename": "src/libstd/sys/windows/condvar.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use cell::UnsafeCell;\n-use libc::{self, DWORD};\n use sys::c;\n use sys::mutex::{self, Mutex};\n use sys::os;\n@@ -29,7 +28,7 @@ impl Condvar {\n     pub unsafe fn wait(&self, mutex: &Mutex) {\n         let r = c::SleepConditionVariableSRW(self.inner.get(),\n                                              mutex::raw(mutex),\n-                                             libc::INFINITE,\n+                                             c::INFINITE,\n                                              0);\n         debug_assert!(r != 0);\n     }\n@@ -40,8 +39,7 @@ impl Condvar {\n                                              super::dur2timeout(dur),\n                                              0);\n         if r == 0 {\n-            const ERROR_TIMEOUT: DWORD = 0x5B4;\n-            debug_assert_eq!(os::errno() as usize, ERROR_TIMEOUT as usize);\n+            debug_assert_eq!(os::errno() as usize, c::ERROR_TIMEOUT as usize);\n             false\n         } else {\n             true"}, {"sha": "2ddb6c65fd357c692518f089c1df6a6eb3ea79c3", "filename": "src/libstd/sys/windows/ext/io.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -15,6 +15,7 @@ use os::windows::raw;\n use net;\n use sys_common::{self, AsInner, FromInner, IntoInner};\n use sys;\n+use sys::c;\n \n /// Raw HANDLEs.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -73,7 +74,7 @@ impl AsRawHandle for fs::File {\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawHandle for fs::File {\n     unsafe fn from_raw_handle(handle: RawHandle) -> fs::File {\n-        let handle = handle as ::libc::HANDLE;\n+        let handle = handle as c::HANDLE;\n         fs::File::from_inner(sys::fs::File::from_inner(handle))\n     }\n }"}, {"sha": "0b0e1a1ece70cd51af84d3729e4acd37a1c15114", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 80, "deletions": 83, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -14,7 +14,6 @@ use os::windows::prelude::*;\n use ffi::OsString;\n use fmt;\n use io::{self, Error, SeekFrom};\n-use libc::{self, HANDLE};\n use mem;\n use path::{Path, PathBuf};\n use ptr;\n@@ -30,7 +29,7 @@ pub struct File { handle: Handle }\n #[derive(Clone)]\n pub struct FileAttr {\n     data: c::WIN32_FILE_ATTRIBUTE_DATA,\n-    reparse_tag: libc::DWORD,\n+    reparse_tag: c::DWORD,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n@@ -41,17 +40,17 @@ pub enum FileType {\n pub struct ReadDir {\n     handle: FindNextFileHandle,\n     root: Arc<PathBuf>,\n-    first: Option<libc::WIN32_FIND_DATAW>,\n+    first: Option<c::WIN32_FIND_DATAW>,\n }\n \n-struct FindNextFileHandle(libc::HANDLE);\n+struct FindNextFileHandle(c::HANDLE);\n \n unsafe impl Send for FindNextFileHandle {}\n unsafe impl Sync for FindNextFileHandle {}\n \n pub struct DirEntry {\n     root: Arc<PathBuf>,\n-    data: libc::WIN32_FIND_DATAW,\n+    data: c::WIN32_FIND_DATAW,\n }\n \n #[derive(Clone, Default)]\n@@ -61,15 +60,15 @@ pub struct OpenOptions {\n     read: bool,\n     write: bool,\n     truncate: bool,\n-    desired_access: Option<libc::DWORD>,\n-    share_mode: Option<libc::DWORD>,\n-    creation_disposition: Option<libc::DWORD>,\n-    flags_and_attributes: Option<libc::DWORD>,\n+    desired_access: Option<c::DWORD>,\n+    share_mode: Option<c::DWORD>,\n+    creation_disposition: Option<c::DWORD>,\n+    flags_and_attributes: Option<c::DWORD>,\n     security_attributes: usize, // *mut T doesn't have a Default impl\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct FilePermissions { attrs: libc::DWORD }\n+pub struct FilePermissions { attrs: c::DWORD }\n \n pub struct DirBuilder;\n \n@@ -84,9 +83,8 @@ impl Iterator for ReadDir {\n         unsafe {\n             let mut wfd = mem::zeroed();\n             loop {\n-                if libc::FindNextFileW(self.handle.0, &mut wfd) == 0 {\n-                    if libc::GetLastError() ==\n-                        c::ERROR_NO_MORE_FILES as libc::DWORD {\n+                if c::FindNextFileW(self.handle.0, &mut wfd) == 0 {\n+                    if c::GetLastError() == c::ERROR_NO_MORE_FILES {\n                         return None\n                     } else {\n                         return Some(Err(Error::last_os_error()))\n@@ -102,13 +100,13 @@ impl Iterator for ReadDir {\n \n impl Drop for FindNextFileHandle {\n     fn drop(&mut self) {\n-        let r = unsafe { libc::FindClose(self.0) };\n+        let r = unsafe { c::FindClose(self.0) };\n         debug_assert!(r != 0);\n     }\n }\n \n impl DirEntry {\n-    fn new(root: &Arc<PathBuf>, wfd: &libc::WIN32_FIND_DATAW) -> Option<DirEntry> {\n+    fn new(root: &Arc<PathBuf>, wfd: &c::WIN32_FIND_DATAW) -> Option<DirEntry> {\n         match &wfd.cFileName[0..3] {\n             // check for '.' and '..'\n             [46, 0, ..] |\n@@ -170,50 +168,50 @@ impl OpenOptions {\n     pub fn share_mode(&mut self, val: u32) {\n         self.share_mode = Some(val);\n     }\n-    pub fn security_attributes(&mut self, attrs: libc::LPSECURITY_ATTRIBUTES) {\n+    pub fn security_attributes(&mut self, attrs: c::LPSECURITY_ATTRIBUTES) {\n         self.security_attributes = attrs as usize;\n     }\n \n-    fn get_desired_access(&self) -> libc::DWORD {\n+    fn get_desired_access(&self) -> c::DWORD {\n         self.desired_access.unwrap_or({\n-            let mut base = if self.read {libc::FILE_GENERIC_READ} else {0} |\n-                           if self.write {libc::FILE_GENERIC_WRITE} else {0};\n+            let mut base = if self.read {c::FILE_GENERIC_READ} else {0} |\n+                           if self.write {c::FILE_GENERIC_WRITE} else {0};\n             if self.append {\n-                base &= !libc::FILE_WRITE_DATA;\n-                base |= libc::FILE_APPEND_DATA;\n+                base &= !c::FILE_WRITE_DATA;\n+                base |= c::FILE_APPEND_DATA;\n             }\n             base\n         })\n     }\n \n-    fn get_share_mode(&self) -> libc::DWORD {\n+    fn get_share_mode(&self) -> c::DWORD {\n         // libuv has a good comment about this, but the basic idea is that\n         // we try to emulate unix semantics by enabling all sharing by\n         // allowing things such as deleting a file while it's still open.\n-        self.share_mode.unwrap_or(libc::FILE_SHARE_READ |\n-                                  libc::FILE_SHARE_WRITE |\n-                                  libc::FILE_SHARE_DELETE)\n+        self.share_mode.unwrap_or(c::FILE_SHARE_READ |\n+                                  c::FILE_SHARE_WRITE |\n+                                  c::FILE_SHARE_DELETE)\n     }\n \n-    fn get_creation_disposition(&self) -> libc::DWORD {\n+    fn get_creation_disposition(&self) -> c::DWORD {\n         self.creation_disposition.unwrap_or({\n             match (self.create, self.truncate) {\n-                (true, true) => libc::CREATE_ALWAYS,\n-                (true, false) => libc::OPEN_ALWAYS,\n-                (false, false) => libc::OPEN_EXISTING,\n+                (true, true) => c::CREATE_ALWAYS,\n+                (true, false) => c::OPEN_ALWAYS,\n+                (false, false) => c::OPEN_EXISTING,\n                 (false, true) => {\n                     if self.write && !self.append {\n-                        libc::CREATE_ALWAYS\n+                        c::CREATE_ALWAYS\n                     } else {\n-                        libc::TRUNCATE_EXISTING\n+                        c::TRUNCATE_EXISTING\n                     }\n                 }\n             }\n         })\n     }\n \n-    fn get_flags_and_attributes(&self) -> libc::DWORD {\n-        self.flags_and_attributes.unwrap_or(libc::FILE_ATTRIBUTE_NORMAL)\n+    fn get_flags_and_attributes(&self) -> c::DWORD {\n+        self.flags_and_attributes.unwrap_or(c::FILE_ATTRIBUTE_NORMAL)\n     }\n }\n \n@@ -230,38 +228,38 @@ impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n         let path = to_utf16(path);\n         let handle = unsafe {\n-            libc::CreateFileW(path.as_ptr(),\n-                              opts.get_desired_access(),\n-                              opts.get_share_mode(),\n-                              opts.security_attributes as *mut _,\n-                              opts.get_creation_disposition(),\n-                              opts.get_flags_and_attributes(),\n-                              ptr::null_mut())\n+            c::CreateFileW(path.as_ptr(),\n+                           opts.get_desired_access(),\n+                           opts.get_share_mode(),\n+                           opts.security_attributes as *mut _,\n+                           opts.get_creation_disposition(),\n+                           opts.get_flags_and_attributes(),\n+                           ptr::null_mut())\n         };\n-        if handle == libc::INVALID_HANDLE_VALUE {\n+        if handle == c::INVALID_HANDLE_VALUE {\n             Err(Error::last_os_error())\n         } else {\n             Ok(File { handle: Handle::new(handle) })\n         }\n     }\n \n     pub fn fsync(&self) -> io::Result<()> {\n-        try!(cvt(unsafe { libc::FlushFileBuffers(self.handle.raw()) }));\n+        try!(cvt(unsafe { c::FlushFileBuffers(self.handle.raw()) }));\n         Ok(())\n     }\n \n     pub fn datasync(&self) -> io::Result<()> { self.fsync() }\n \n     pub fn truncate(&self, size: u64) -> io::Result<()> {\n         let mut info = c::FILE_END_OF_FILE_INFO {\n-            EndOfFile: size as libc::LARGE_INTEGER,\n+            EndOfFile: size as c::LARGE_INTEGER,\n         };\n         let size = mem::size_of_val(&info);\n         try!(cvt(unsafe {\n             c::SetFileInformationByHandle(self.handle.raw(),\n                                           c::FileEndOfFileInfo,\n                                           &mut info as *mut _ as *mut _,\n-                                          size as libc::DWORD)\n+                                          size as c::DWORD)\n         }));\n         Ok(())\n     }\n@@ -304,15 +302,15 @@ impl File {\n \n     pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n         let (whence, pos) = match pos {\n-            SeekFrom::Start(n) => (libc::FILE_BEGIN, n as i64),\n-            SeekFrom::End(n) => (libc::FILE_END, n),\n-            SeekFrom::Current(n) => (libc::FILE_CURRENT, n),\n+            SeekFrom::Start(n) => (c::FILE_BEGIN, n as i64),\n+            SeekFrom::End(n) => (c::FILE_END, n),\n+            SeekFrom::Current(n) => (c::FILE_CURRENT, n),\n         };\n-        let pos = pos as libc::LARGE_INTEGER;\n+        let pos = pos as c::LARGE_INTEGER;\n         let mut newpos = 0;\n         try!(cvt(unsafe {\n-            libc::SetFilePointerEx(self.handle.raw(), pos,\n-                                   &mut newpos, whence)\n+            c::SetFilePointerEx(self.handle.raw(), pos,\n+                                &mut newpos, whence)\n         }));\n         Ok(newpos as u64)\n     }\n@@ -323,7 +321,7 @@ impl File {\n \n     fn reparse_point<'a>(&self,\n                          space: &'a mut [u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE])\n-                         -> io::Result<(libc::DWORD, &'a c::REPARSE_DATA_BUFFER)> {\n+                         -> io::Result<(c::DWORD, &'a c::REPARSE_DATA_BUFFER)> {\n         unsafe {\n             let mut bytes = 0;\n             try!(cvt({\n@@ -332,7 +330,7 @@ impl File {\n                                    ptr::null_mut(),\n                                    0,\n                                    space.as_mut_ptr() as *mut _,\n-                                   space.len() as libc::DWORD,\n+                                   space.len() as c::DWORD,\n                                    &mut bytes,\n                                    ptr::null_mut())\n             }));\n@@ -361,8 +359,8 @@ impl File {\n     }\n }\n \n-impl FromInner<libc::HANDLE> for File {\n-    fn from_inner(handle: libc::HANDLE) -> File {\n+impl FromInner<c::HANDLE> for File {\n+    fn from_inner(handle: c::HANDLE) -> File {\n         File { handle: Handle::new(handle) }\n     }\n }\n@@ -402,12 +400,12 @@ impl FileAttr {\n     pub fn accessed(&self) -> u64 { self.to_u64(&self.data.ftLastAccessTime) }\n     pub fn modified(&self) -> u64 { self.to_u64(&self.data.ftLastWriteTime) }\n \n-    fn to_u64(&self, ft: &libc::FILETIME) -> u64 {\n+    fn to_u64(&self, ft: &c::FILETIME) -> u64 {\n         (ft.dwLowDateTime as u64) | ((ft.dwHighDateTime as u64) << 32)\n     }\n \n     fn is_reparse_point(&self) -> bool {\n-        self.data.dwFileAttributes & libc::FILE_ATTRIBUTE_REPARSE_POINT != 0\n+        self.data.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0\n     }\n }\n \n@@ -426,8 +424,8 @@ impl FilePermissions {\n }\n \n impl FileType {\n-    fn new(attrs: libc::DWORD, reparse_tag: libc::DWORD) -> FileType {\n-        if attrs & libc::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n+    fn new(attrs: c::DWORD, reparse_tag: c::DWORD) -> FileType {\n+        if attrs & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n             match reparse_tag {\n                 c::IO_REPARSE_TAG_SYMLINK => FileType::Symlink,\n                 c::IO_REPARSE_TAG_MOUNT_POINT => FileType::MountPoint,\n@@ -453,7 +451,7 @@ impl DirBuilder {\n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n         let p = to_utf16(p);\n         try!(cvt(unsafe {\n-            libc::CreateDirectoryW(p.as_ptr(), ptr::null_mut())\n+            c::CreateDirectoryW(p.as_ptr(), ptr::null_mut())\n         }));\n         Ok(())\n     }\n@@ -466,8 +464,8 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n \n     unsafe {\n         let mut wfd = mem::zeroed();\n-        let find_handle = libc::FindFirstFileW(path.as_ptr(), &mut wfd);\n-        if find_handle != libc::INVALID_HANDLE_VALUE {\n+        let find_handle = c::FindFirstFileW(path.as_ptr(), &mut wfd);\n+        if find_handle != c::INVALID_HANDLE_VALUE {\n             Ok(ReadDir {\n                 handle: FindNextFileHandle(find_handle),\n                 root: Arc::new(root),\n@@ -481,16 +479,15 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n     let p_utf16 = to_utf16(p);\n-    try!(cvt(unsafe { libc::DeleteFileW(p_utf16.as_ptr()) }));\n+    try!(cvt(unsafe { c::DeleteFileW(p_utf16.as_ptr()) }));\n     Ok(())\n }\n \n pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n     let old = to_utf16(old);\n     let new = to_utf16(new);\n     try!(cvt(unsafe {\n-        libc::MoveFileExW(old.as_ptr(), new.as_ptr(),\n-                          libc::MOVEFILE_REPLACE_EXISTING)\n+        c::MoveFileExW(old.as_ptr(), new.as_ptr(), c::MOVEFILE_REPLACE_EXISTING)\n     }));\n     Ok(())\n }\n@@ -515,7 +512,7 @@ pub fn symlink_inner(src: &Path, dst: &Path, dir: bool) -> io::Result<()> {\n     let dst = to_utf16(dst);\n     let flags = if dir { c::SYMBOLIC_LINK_FLAG_DIRECTORY } else { 0 };\n     try!(cvt(unsafe {\n-        c::CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), flags) as libc::BOOL\n+        c::CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), flags) as c::BOOL\n     }));\n     Ok(())\n }\n@@ -524,7 +521,7 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n     let src = to_utf16(src);\n     let dst = to_utf16(dst);\n     try!(cvt(unsafe {\n-        libc::CreateHardLinkW(dst.as_ptr(), src.as_ptr(), ptr::null_mut())\n+        c::CreateHardLinkW(dst.as_ptr(), src.as_ptr(), ptr::null_mut())\n     }));\n     Ok(())\n }\n@@ -575,7 +572,7 @@ pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n fn get_path(f: &File) -> io::Result<PathBuf> {\n     super::fill_utf16_buf(|buf, sz| unsafe {\n         c::GetFinalPathNameByHandleW(f.handle.raw(), buf, sz,\n-                                     libc::VOLUME_NAME_DOS)\n+                                     c::VOLUME_NAME_DOS)\n     }, |buf| {\n         PathBuf::from(OsString::from_wide(buf))\n     })\n@@ -592,16 +589,16 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n \n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     unsafe extern \"system\" fn callback(\n-        _TotalFileSize: libc::LARGE_INTEGER,\n-        TotalBytesTransferred: libc::LARGE_INTEGER,\n-        _StreamSize: libc::LARGE_INTEGER,\n-        _StreamBytesTransferred: libc::LARGE_INTEGER,\n-        _dwStreamNumber: libc::DWORD,\n-        _dwCallbackReason: libc::DWORD,\n-        _hSourceFile: HANDLE,\n-        _hDestinationFile: HANDLE,\n-        lpData: libc::LPVOID,\n-    ) -> libc::DWORD {\n+        _TotalFileSize: c::LARGE_INTEGER,\n+        TotalBytesTransferred: c::LARGE_INTEGER,\n+        _StreamSize: c::LARGE_INTEGER,\n+        _StreamBytesTransferred: c::LARGE_INTEGER,\n+        _dwStreamNumber: c::DWORD,\n+        _dwCallbackReason: c::DWORD,\n+        _hSourceFile: c::HANDLE,\n+        _hDestinationFile: c::HANDLE,\n+        lpData: c::LPVOID,\n+    ) -> c::DWORD {\n         *(lpData as *mut i64) = TotalBytesTransferred;\n         c::PROGRESS_CONTINUE\n     }\n@@ -673,10 +670,10 @@ fn directory_junctions_are_directories() {\n             *buf.offset(i) = 0;\n             i += 1;\n             (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n-            (*db).ReparseTargetMaximumLength = (i * 2) as libc::WORD;\n-            (*db).ReparseTargetLength = ((i - 1) * 2) as libc::WORD;\n+            (*db).ReparseTargetMaximumLength = (i * 2) as c::WORD;\n+            (*db).ReparseTargetLength = ((i - 1) * 2) as c::WORD;\n             (*db).ReparseDataLength =\n-                    (*db).ReparseTargetLength as libc::DWORD + 12;\n+                    (*db).ReparseTargetLength as c::DWORD + 12;\n \n             let mut ret = 0;\n             cvt(c::DeviceIoControl(h as *mut _,\n@@ -707,10 +704,10 @@ fn directory_junctions_are_directories() {\n                                               &mut tp.Privileges[0].Luid)));\n             tp.PrivilegeCount = 1;\n             tp.Privileges[0].Attributes = c::SE_PRIVILEGE_ENABLED;\n-            let size = mem::size_of::<c::TOKEN_PRIVILEGES>() as libc::DWORD;\n-            try!(cvt(c::AdjustTokenPrivileges(token, libc::FALSE, &mut tp, size,\n+            let size = mem::size_of::<c::TOKEN_PRIVILEGES>() as c::DWORD;\n+            try!(cvt(c::AdjustTokenPrivileges(token, c::FALSE, &mut tp, size,\n                                               ptr::null_mut(), ptr::null_mut())));\n-            try!(cvt(libc::CloseHandle(token)));\n+            try!(cvt(c::CloseHandle(token)));\n \n             File::open_reparse_point(p, write)\n         }"}, {"sha": "cb41b05daaea26c48afe08bea8f5bb343db0f9d4", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -10,11 +10,10 @@\n \n use io::ErrorKind;\n use io;\n-use libc::funcs::extra::kernel32::{GetCurrentProcess, DuplicateHandle};\n-use libc::{self, HANDLE};\n use mem;\n use ops::Deref;\n use ptr;\n+use sys::c;\n use sys::cvt;\n \n /// An owned container for `HANDLE` object, closing them on Drop.\n@@ -28,17 +27,17 @@ pub struct Handle(RawHandle);\n /// This does **not** drop the handle when it goes out of scope, use `Handle`\n /// instead for that.\n #[derive(Copy, Clone)]\n-pub struct RawHandle(HANDLE);\n+pub struct RawHandle(c::HANDLE);\n \n unsafe impl Send for RawHandle {}\n unsafe impl Sync for RawHandle {}\n \n impl Handle {\n-    pub fn new(handle: HANDLE) -> Handle {\n+    pub fn new(handle: c::HANDLE) -> Handle {\n         Handle(RawHandle::new(handle))\n     }\n \n-    pub fn into_raw(self) -> HANDLE {\n+    pub fn into_raw(self) -> c::HANDLE {\n         let ret = self.raw();\n         mem::forget(self);\n         return ret;\n@@ -52,22 +51,22 @@ impl Deref for Handle {\n \n impl Drop for Handle {\n     fn drop(&mut self) {\n-        unsafe { let _ = libc::CloseHandle(self.raw()); }\n+        unsafe { let _ = c::CloseHandle(self.raw()); }\n     }\n }\n \n impl RawHandle {\n-    pub fn new(handle: HANDLE) -> RawHandle {\n+    pub fn new(handle: c::HANDLE) -> RawHandle {\n         RawHandle(handle)\n     }\n \n-    pub fn raw(&self) -> HANDLE { self.0 }\n+    pub fn raw(&self) -> c::HANDLE { self.0 }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let mut read = 0;\n         let res = cvt(unsafe {\n-            libc::ReadFile(self.0, buf.as_ptr() as libc::LPVOID,\n-                           buf.len() as libc::DWORD, &mut read,\n+            c::ReadFile(self.0, buf.as_ptr() as c::LPVOID,\n+                           buf.len() as c::DWORD, &mut read,\n                            ptr::null_mut())\n         });\n \n@@ -87,20 +86,20 @@ impl RawHandle {\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let mut amt = 0;\n         try!(cvt(unsafe {\n-            libc::WriteFile(self.0, buf.as_ptr() as libc::LPVOID,\n-                            buf.len() as libc::DWORD, &mut amt,\n+            c::WriteFile(self.0, buf.as_ptr() as c::LPVOID,\n+                            buf.len() as c::DWORD, &mut amt,\n                             ptr::null_mut())\n         }));\n         Ok(amt as usize)\n     }\n \n-    pub fn duplicate(&self, access: libc::DWORD, inherit: bool,\n-                     options: libc::DWORD) -> io::Result<Handle> {\n-        let mut ret = 0 as libc::HANDLE;\n+    pub fn duplicate(&self, access: c::DWORD, inherit: bool,\n+                     options: c::DWORD) -> io::Result<Handle> {\n+        let mut ret = 0 as c::HANDLE;\n         try!(cvt(unsafe {\n-            let cur_proc = GetCurrentProcess();\n-            DuplicateHandle(cur_proc, self.0, cur_proc, &mut ret,\n-                            access, inherit as libc::BOOL,\n+            let cur_proc = c::GetCurrentProcess();\n+            c::DuplicateHandle(cur_proc, self.0, cur_proc, &mut ret,\n+                            access, inherit as c::BOOL,\n                             options)\n         }));\n         Ok(Handle::new(ret))"}, {"sha": "3f76218eafee6039be9a7bfab0f063adbc9bf9ba", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -16,7 +16,6 @@ use prelude::v1::*;\n \n use ffi::{OsStr, OsString};\n use io::{self, ErrorKind};\n-use libc;\n use num::Zero;\n use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n@@ -46,25 +45,28 @@ pub mod stdio;\n pub fn init() {}\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n-    match errno as libc::c_int {\n-        libc::ERROR_ACCESS_DENIED => ErrorKind::PermissionDenied,\n-        libc::ERROR_ALREADY_EXISTS => ErrorKind::AlreadyExists,\n-        libc::ERROR_BROKEN_PIPE => ErrorKind::BrokenPipe,\n-        libc::ERROR_FILE_NOT_FOUND => ErrorKind::NotFound,\n-        c::ERROR_PATH_NOT_FOUND => ErrorKind::NotFound,\n-        libc::ERROR_NO_DATA => ErrorKind::BrokenPipe,\n-        libc::ERROR_OPERATION_ABORTED => ErrorKind::TimedOut,\n-\n-        libc::WSAEACCES => ErrorKind::PermissionDenied,\n-        libc::WSAEADDRINUSE => ErrorKind::AddrInUse,\n-        libc::WSAEADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n-        libc::WSAECONNABORTED => ErrorKind::ConnectionAborted,\n-        libc::WSAECONNREFUSED => ErrorKind::ConnectionRefused,\n-        libc::WSAECONNRESET => ErrorKind::ConnectionReset,\n-        libc::WSAEINVAL => ErrorKind::InvalidInput,\n-        libc::WSAENOTCONN => ErrorKind::NotConnected,\n-        libc::WSAEWOULDBLOCK => ErrorKind::WouldBlock,\n-        libc::WSAETIMEDOUT => ErrorKind::TimedOut,\n+    match errno as c::DWORD {\n+        c::ERROR_ACCESS_DENIED => return ErrorKind::PermissionDenied,\n+        c::ERROR_ALREADY_EXISTS => return ErrorKind::AlreadyExists,\n+        c::ERROR_BROKEN_PIPE => return ErrorKind::BrokenPipe,\n+        c::ERROR_FILE_NOT_FOUND => return ErrorKind::NotFound,\n+        c::ERROR_PATH_NOT_FOUND => return ErrorKind::NotFound,\n+        c::ERROR_NO_DATA => return ErrorKind::BrokenPipe,\n+        c::ERROR_OPERATION_ABORTED => return ErrorKind::TimedOut,\n+        _ => {}\n+    }\n+\n+    match errno {\n+        c::WSAEACCES => ErrorKind::PermissionDenied,\n+        c::WSAEADDRINUSE => ErrorKind::AddrInUse,\n+        c::WSAEADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n+        c::WSAECONNABORTED => ErrorKind::ConnectionAborted,\n+        c::WSAECONNREFUSED => ErrorKind::ConnectionRefused,\n+        c::WSAECONNRESET => ErrorKind::ConnectionReset,\n+        c::WSAEINVAL => ErrorKind::InvalidInput,\n+        c::WSAENOTCONN => ErrorKind::NotConnected,\n+        c::WSAEWOULDBLOCK => ErrorKind::WouldBlock,\n+        c::WSAETIMEDOUT => ErrorKind::TimedOut,\n \n         _ => ErrorKind::Other,\n     }\n@@ -91,7 +93,7 @@ fn to_utf16_os(s: &OsStr) -> Vec<u16> {\n // yielded the data which has been read from the syscall. The return value\n // from this closure is then the return value of the function.\n fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> io::Result<T>\n-    where F1: FnMut(*mut u16, libc::DWORD) -> libc::DWORD,\n+    where F1: FnMut(*mut u16, c::DWORD) -> c::DWORD,\n           F2: FnOnce(&[u16]) -> T\n {\n     // Start off with a stack buf but then spill over to the heap if we end up\n@@ -120,13 +122,12 @@ fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> io::Result<T>\n             // error\" is still 0 then we interpret it as a 0 length buffer and\n             // not an actual error.\n             c::SetLastError(0);\n-            let k = match f1(buf.as_mut_ptr(), n as libc::DWORD) {\n-                0 if libc::GetLastError() == 0 => 0,\n+            let k = match f1(buf.as_mut_ptr(), n as c::DWORD) {\n+                0 if c::GetLastError() == 0 => 0,\n                 0 => return Err(io::Error::last_os_error()),\n                 n => n,\n             } as usize;\n-            if k == n && libc::GetLastError() ==\n-                            libc::ERROR_INSUFFICIENT_BUFFER as libc::DWORD {\n+            if k == n && c::GetLastError() == c::ERROR_INSUFFICIENT_BUFFER {\n                 n *= 2;\n             } else if k >= n {\n                 n = k;\n@@ -157,7 +158,7 @@ fn cvt<I: PartialEq + Zero>(i: I) -> io::Result<I> {\n     }\n }\n \n-fn dur2timeout(dur: Duration) -> libc::DWORD {\n+fn dur2timeout(dur: Duration) -> c::DWORD {\n     // Note that a duration is a (u64, u32) (seconds, nanoseconds) pair, and the\n     // timeouts in windows APIs are typically u32 milliseconds. To translate, we\n     // have two pieces to take care of:\n@@ -170,10 +171,10 @@ fn dur2timeout(dur: Duration) -> libc::DWORD {\n     }).and_then(|ms| {\n         ms.checked_add(if dur.subsec_nanos() % 1_000_000 > 0 {1} else {0})\n     }).map(|ms| {\n-        if ms > <libc::DWORD>::max_value() as u64 {\n-            libc::INFINITE\n+        if ms > <c::DWORD>::max_value() as u64 {\n+            c::INFINITE\n         } else {\n-            ms as libc::DWORD\n+            ms as c::DWORD\n         }\n-    }).unwrap_or(libc::INFINITE)\n+    }).unwrap_or(c::INFINITE)\n }"}, {"sha": "3e69902dcb6bd4ea3dc89c5f28b407212daeb84f", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -9,23 +9,30 @@\n // except according to those terms.\n \n use io;\n-use libc::consts::os::extra::INVALID_SOCKET;\n-use libc::{self, c_int, c_void};\n+use libc::{c_int, c_void};\n use mem;\n-use net::SocketAddr;\n+use net::{SocketAddr, Shutdown};\n use num::One;\n use ops::Neg;\n use ptr;\n use sync::Once;\n-use sys;\n use sys::c;\n+use sys;\n use sys_common::{self, AsInner, FromInner, IntoInner};\n-use sys_common::net::{setsockopt, getsockopt};\n+use sys_common::net;\n use time::Duration;\n \n pub type wrlen_t = i32;\n \n-pub struct Socket(libc::SOCKET);\n+pub mod netc {\n+    pub use sys::c::*;\n+    pub use sys::c::SOCKADDR as sockaddr;\n+    pub use sys::c::SOCKADDR_STORAGE_LH as sockaddr_storage;\n+    pub use sys::c::ADDRINFOA as addrinfo;\n+    pub use sys::c::ADDRESS_FAMILY as sa_family_t;\n+}\n+\n+pub struct Socket(c::SOCKET);\n \n /// Checks whether the Windows socket interface has been started already, and\n /// if not, starts it.\n@@ -76,25 +83,25 @@ pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n impl Socket {\n     pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n         let fam = match *addr {\n-            SocketAddr::V4(..) => libc::AF_INET,\n-            SocketAddr::V6(..) => libc::AF_INET6,\n+            SocketAddr::V4(..) => c::AF_INET,\n+            SocketAddr::V6(..) => c::AF_INET6,\n         };\n         let socket = try!(unsafe {\n             match c::WSASocketW(fam, ty, 0, ptr::null_mut(), 0,\n                                 c::WSA_FLAG_OVERLAPPED) {\n-                INVALID_SOCKET => Err(last_error()),\n+                c::INVALID_SOCKET => Err(last_error()),\n                 n => Ok(Socket(n)),\n             }\n         });\n         try!(socket.set_no_inherit());\n         Ok(socket)\n     }\n \n-    pub fn accept(&self, storage: *mut libc::sockaddr,\n-                  len: *mut libc::socklen_t) -> io::Result<Socket> {\n+    pub fn accept(&self, storage: *mut c::SOCKADDR,\n+                  len: *mut c_int) -> io::Result<Socket> {\n         let socket = try!(unsafe {\n-            match libc::accept(self.0, storage, len) {\n-                INVALID_SOCKET => Err(last_error()),\n+            match c::accept(self.0, storage, len) {\n+                c::INVALID_SOCKET => Err(last_error()),\n                 n => Ok(Socket(n)),\n             }\n         });\n@@ -113,7 +120,7 @@ impl Socket {\n                                 info.iProtocol,\n                                 &mut info, 0,\n                                 c::WSA_FLAG_OVERLAPPED) {\n-                INVALID_SOCKET => Err(last_error()),\n+                c::INVALID_SOCKET => Err(last_error()),\n                 n => Ok(Socket(n)),\n             }\n         });\n@@ -125,7 +132,7 @@ impl Socket {\n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n         unsafe {\n-            match libc::recv(self.0, buf.as_mut_ptr() as *mut c_void,\n+            match c::recv(self.0, buf.as_mut_ptr() as *mut c_void,\n                              buf.len() as i32, 0) {\n                 -1 if c::WSAGetLastError() == c::WSAESHUTDOWN => Ok(0),\n                 -1 => Err(last_error()),\n@@ -134,7 +141,8 @@ impl Socket {\n         }\n     }\n \n-    pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> {\n+    pub fn set_timeout(&self, dur: Option<Duration>,\n+                       kind: c_int) -> io::Result<()> {\n         let timeout = match dur {\n             Some(dur) => {\n                 let timeout = sys::dur2timeout(dur);\n@@ -146,11 +154,11 @@ impl Socket {\n             }\n             None => 0\n         };\n-        setsockopt(self, libc::SOL_SOCKET, kind, timeout)\n+        net::setsockopt(self, c::SOL_SOCKET, kind, timeout)\n     }\n \n-    pub fn timeout(&self, kind: libc::c_int) -> io::Result<Option<Duration>> {\n-        let raw: libc::DWORD = try!(getsockopt(self, libc::SOL_SOCKET, kind));\n+    pub fn timeout(&self, kind: c_int) -> io::Result<Option<Duration>> {\n+        let raw: c::DWORD = try!(net::getsockopt(self, c::SOL_SOCKET, kind));\n         if raw == 0 {\n             Ok(None)\n         } else {\n@@ -162,28 +170,38 @@ impl Socket {\n \n     fn set_no_inherit(&self) -> io::Result<()> {\n         sys::cvt(unsafe {\n-            c::SetHandleInformation(self.0 as libc::HANDLE,\n+            c::SetHandleInformation(self.0 as c::HANDLE,\n                                     c::HANDLE_FLAG_INHERIT, 0)\n         }).map(|_| ())\n     }\n+\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        let how = match how {\n+            Shutdown::Write => c::SD_SEND,\n+            Shutdown::Read => c::SD_RECEIVE,\n+            Shutdown::Both => c::SD_BOTH,\n+        };\n+        try!(cvt(unsafe { c::shutdown(self.0, how) }));\n+        Ok(())\n+    }\n }\n \n impl Drop for Socket {\n     fn drop(&mut self) {\n-        let _ = unsafe { libc::closesocket(self.0) };\n+        let _ = unsafe { c::closesocket(self.0) };\n     }\n }\n \n-impl AsInner<libc::SOCKET> for Socket {\n-    fn as_inner(&self) -> &libc::SOCKET { &self.0 }\n+impl AsInner<c::SOCKET> for Socket {\n+    fn as_inner(&self) -> &c::SOCKET { &self.0 }\n }\n \n-impl FromInner<libc::SOCKET> for Socket {\n-    fn from_inner(sock: libc::SOCKET) -> Socket { Socket(sock) }\n+impl FromInner<c::SOCKET> for Socket {\n+    fn from_inner(sock: c::SOCKET) -> Socket { Socket(sock) }\n }\n \n-impl IntoInner<libc::SOCKET> for Socket {\n-    fn into_inner(self) -> libc::SOCKET {\n+impl IntoInner<c::SOCKET> for Socket {\n+    fn into_inner(self) -> c::SOCKET {\n         let ret = self.0;\n         mem::forget(self);\n         ret"}, {"sha": "52740b2cad4f0cb10a5cef65b8a45d216704c739", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 31, "deletions": 54, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -19,8 +19,7 @@ use error::Error as StdError;\n use ffi::{OsString, OsStr};\n use fmt;\n use io;\n-use libc::types::os::arch::extra::LPWCH;\n-use libc::{self, c_int, c_void};\n+use libc::{c_int, c_void};\n use ops::Range;\n use os::windows::ffi::EncodeWide;\n use path::{self, PathBuf};\n@@ -29,52 +28,27 @@ use slice;\n use sys::{c, cvt};\n use sys::handle::Handle;\n \n-use libc::funcs::extra::kernel32::{\n-    GetEnvironmentStringsW,\n-    FreeEnvironmentStringsW\n-};\n-\n pub fn errno() -> i32 {\n-    unsafe { libc::GetLastError() as i32 }\n+    unsafe { c::GetLastError() as i32 }\n }\n \n /// Gets a detailed string description for the given error number.\n pub fn error_string(errnum: i32) -> String {\n-    use libc::types::os::arch::extra::DWORD;\n-    use libc::types::os::arch::extra::LPWSTR;\n-    use libc::types::os::arch::extra::LPVOID;\n-    use libc::types::os::arch::extra::WCHAR;\n-\n-    #[link_name = \"kernel32\"]\n-    extern \"system\" {\n-        fn FormatMessageW(flags: DWORD,\n-                          lpSrc: LPVOID,\n-                          msgId: DWORD,\n-                          langId: DWORD,\n-                          buf: LPWSTR,\n-                          nsize: DWORD,\n-                          args: *const c_void)\n-                          -> DWORD;\n-    }\n-\n-    const FORMAT_MESSAGE_FROM_SYSTEM: DWORD = 0x00001000;\n-    const FORMAT_MESSAGE_IGNORE_INSERTS: DWORD = 0x00000200;\n-\n     // This value is calculated from the macro\n     // MAKELANGID(LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT)\n-    let langId = 0x0800 as DWORD;\n+    let langId = 0x0800 as c::DWORD;\n \n-    let mut buf = [0 as WCHAR; 2048];\n+    let mut buf = [0 as c::WCHAR; 2048];\n \n     unsafe {\n-        let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n-                                 FORMAT_MESSAGE_IGNORE_INSERTS,\n-                                 ptr::null_mut(),\n-                                 errnum as DWORD,\n-                                 langId,\n-                                 buf.as_mut_ptr(),\n-                                 buf.len() as DWORD,\n-                                 ptr::null()) as usize;\n+        let res = c::FormatMessageW(c::FORMAT_MESSAGE_FROM_SYSTEM |\n+                                        c::FORMAT_MESSAGE_IGNORE_INSERTS,\n+                                    ptr::null_mut(),\n+                                    errnum as c::DWORD,\n+                                    langId,\n+                                    buf.as_mut_ptr(),\n+                                    buf.len() as c::DWORD,\n+                                    ptr::null()) as usize;\n         if res == 0 {\n             // Sometimes FormatMessageW can fail e.g. system doesn't like langId,\n             let fm_err = errno();\n@@ -96,8 +70,8 @@ pub fn error_string(errnum: i32) -> String {\n }\n \n pub struct Env {\n-    base: LPWCH,\n-    cur: LPWCH,\n+    base: c::LPWCH,\n+    cur: c::LPWCH,\n }\n \n impl Iterator for Env {\n@@ -126,13 +100,13 @@ impl Iterator for Env {\n \n impl Drop for Env {\n     fn drop(&mut self) {\n-        unsafe { FreeEnvironmentStringsW(self.base); }\n+        unsafe { c::FreeEnvironmentStringsW(self.base); }\n     }\n }\n \n pub fn env() -> Env {\n     unsafe {\n-        let ch = GetEnvironmentStringsW();\n+        let ch = c::GetEnvironmentStringsW();\n         if ch as usize == 0 {\n             panic!(\"failure getting env string from OS: {}\",\n                    io::Error::last_os_error());\n@@ -233,13 +207,13 @@ impl StdError for JoinPathsError {\n \n pub fn current_exe() -> io::Result<PathBuf> {\n     super::fill_utf16_buf(|buf, sz| unsafe {\n-        libc::GetModuleFileNameW(ptr::null_mut(), buf, sz)\n+        c::GetModuleFileNameW(ptr::null_mut(), buf, sz)\n     }, super::os2path)\n }\n \n pub fn getcwd() -> io::Result<PathBuf> {\n     super::fill_utf16_buf(|buf, sz| unsafe {\n-        libc::GetCurrentDirectoryW(sz, buf)\n+        c::GetCurrentDirectoryW(sz, buf)\n     }, super::os2path)\n }\n \n@@ -249,23 +223,26 @@ pub fn chdir(p: &path::Path) -> io::Result<()> {\n     p.push(0);\n \n     cvt(unsafe {\n-        libc::SetCurrentDirectoryW(p.as_ptr())\n+        c::SetCurrentDirectoryW(p.as_ptr())\n     }).map(|_| ())\n }\n \n pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n     let k = super::to_utf16_os(k);\n     let res = super::fill_utf16_buf(|buf, sz| unsafe {\n-        libc::GetEnvironmentVariableW(k.as_ptr(), buf, sz)\n+        c::GetEnvironmentVariableW(k.as_ptr(), buf, sz)\n     }, |buf| {\n         OsStringExt::from_wide(buf)\n     });\n     match res {\n         Ok(value) => Ok(Some(value)),\n-        Err(ref e) if e.raw_os_error() == Some(c::ERROR_ENVVAR_NOT_FOUND) => {\n-            Ok(None)\n+        Err(e) => {\n+            if e.raw_os_error() == Some(c::ERROR_ENVVAR_NOT_FOUND as i32) {\n+                Ok(None)\n+            } else {\n+                Err(e)\n+            }\n         }\n-        Err(e) => Err(e)\n     }\n }\n \n@@ -274,14 +251,14 @@ pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n     let v = super::to_utf16_os(v);\n \n     cvt(unsafe {\n-        libc::SetEnvironmentVariableW(k.as_ptr(), v.as_ptr())\n+        c::SetEnvironmentVariableW(k.as_ptr(), v.as_ptr())\n     }).map(|_| ())\n }\n \n pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     let v = super::to_utf16_os(n);\n     cvt(unsafe {\n-        libc::SetEnvironmentVariableW(v.as_ptr(), ptr::null())\n+        c::SetEnvironmentVariableW(v.as_ptr(), ptr::null())\n     }).map(|_| ())\n }\n \n@@ -350,14 +327,14 @@ pub fn home_dir() -> Option<PathBuf> {\n         let _handle = Handle::new(token);\n         super::fill_utf16_buf(|buf, mut sz| {\n             match c::GetUserProfileDirectoryW(token, buf, &mut sz) {\n-                0 if libc::GetLastError() != 0 => 0,\n+                0 if c::GetLastError() != 0 => 0,\n                 0 => sz,\n-                n => n as libc::DWORD,\n+                n => n as c::DWORD,\n             }\n         }, super::os2path).ok()\n     })\n }\n \n pub fn exit(code: i32) -> ! {\n-    unsafe { c::ExitProcess(code as libc::c_uint) }\n+    unsafe { c::ExitProcess(code as c::UINT) }\n }"}, {"sha": "a6e69c789d098f3f31668b61bfc5ea4fcb1428a5", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use io;\n-use libc;\n use ptr;\n use sys::cvt;\n use sys::c;\n@@ -24,8 +23,8 @@ pub struct AnonPipe {\n }\n \n pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n-    let mut reader = libc::INVALID_HANDLE_VALUE;\n-    let mut writer = libc::INVALID_HANDLE_VALUE;\n+    let mut reader = c::INVALID_HANDLE_VALUE;\n+    let mut writer = c::INVALID_HANDLE_VALUE;\n     try!(cvt(unsafe {\n         c::CreatePipe(&mut reader, &mut writer, ptr::null_mut(), 0)\n     }));\n@@ -38,7 +37,7 @@ impl AnonPipe {\n     pub fn handle(&self) -> &Handle { &self.inner }\n     pub fn into_handle(self) -> Handle { self.inner }\n \n-    pub fn raw(&self) -> libc::HANDLE { self.inner.raw() }\n+    pub fn raw(&self) -> c::HANDLE { self.inner.raw() }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)"}, {"sha": "c1367d5381da12c01e13526419a44e57dd50fd87", "filename": "src/libstd/sys/windows/printing/gnu.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fgnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fgnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fgnu.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -11,14 +11,15 @@\n #![allow(deprecated)]\n \n use dynamic_lib::DynamicLibrary;\n-use io;\n use io::prelude::*;\n-use libc;\n+use io;\n+use sys::c;\n+use libc::c_void;\n \n use sys_common::gnu::libbacktrace;\n \n-pub fn print(w: &mut Write, i: isize, addr: u64, _: &DynamicLibrary, _: libc::HANDLE)\n+pub fn print(w: &mut Write, i: isize, addr: u64, _: &DynamicLibrary, _: c::HANDLE)\n         -> io::Result<()> {\n-    let addr = addr as usize as *mut libc::c_void;\n+    let addr = addr as usize as *mut c_void;\n     libbacktrace::print(w, i, addr, addr)\n }"}, {"sha": "d04691a6a4783c0db625e5ff9bffdeccec026b06", "filename": "src/libstd/sys/windows/printing/msvc.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -10,22 +10,23 @@\n \n #![allow(deprecated)]\n \n-use sys_common::backtrace::{output, output_fileline};\n-use ffi::CStr;\n use dynamic_lib::DynamicLibrary;\n-use super::{SymFromAddrFn, SymGetLineFromAddr64Fn, SYMBOL_INFO, MAX_SYM_NAME, IMAGEHLP_LINE64};\n-use io;\n+use ffi::CStr;\n use io::prelude::*;\n-use intrinsics;\n-use libc;\n+use io;\n+use libc::{c_ulong, c_int, c_char, c_void};\n+use mem;\n+use super::{SymFromAddrFn, SymGetLineFromAddr64Fn};\n+use sys::c;\n+use sys_common::backtrace::{output, output_fileline};\n \n-pub fn print(w: &mut Write, i: isize, addr: u64, dbghelp: &DynamicLibrary, process: libc::HANDLE)\n-        -> io::Result<()> {\n+pub fn print(w: &mut Write, i: isize, addr: u64, dbghelp: &DynamicLibrary,\n+             process: c::HANDLE) -> io::Result<()> {\n     let SymFromAddr = sym!(dbghelp, \"SymFromAddr\", SymFromAddrFn);\n     let SymGetLineFromAddr64 = sym!(dbghelp, \"SymGetLineFromAddr64\", SymGetLineFromAddr64Fn);\n \n-    let mut info: SYMBOL_INFO = unsafe { intrinsics::init() };\n-    info.MaxNameLen = MAX_SYM_NAME as libc::c_ulong;\n+    let mut info: c::SYMBOL_INFO = unsafe { mem::zeroed() };\n+    info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n     // the struct size in C.  the value is different to\n     // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n     // due to struct alignment.\n@@ -34,25 +35,25 @@ pub fn print(w: &mut Write, i: isize, addr: u64, dbghelp: &DynamicLibrary, proce\n     let mut displacement = 0u64;\n     let ret = SymFromAddr(process, addr, &mut displacement, &mut info);\n \n-    let name = if ret == libc::TRUE {\n-        let ptr = info.Name.as_ptr() as *const libc::c_char;\n+    let name = if ret == c::TRUE {\n+        let ptr = info.Name.as_ptr() as *const c_char;\n         Some(unsafe { CStr::from_ptr(ptr).to_bytes() })\n     } else {\n         None\n     };\n \n-    try!(output(w, i, addr as usize as *mut libc::c_void, name));\n+    try!(output(w, i, addr as usize as *mut c_void, name));\n \n     // Now find out the filename and line number\n-    let mut line: IMAGEHLP_LINE64 = unsafe { intrinsics::init() };\n-    line.SizeOfStruct = ::mem::size_of::<IMAGEHLP_LINE64>() as u32;\n+    let mut line: c::IMAGEHLP_LINE64 = unsafe { mem::zeroed() };\n+    line.SizeOfStruct = ::mem::size_of::<c::IMAGEHLP_LINE64>() as u32;\n \n     let mut displacement = 0u32;\n     let ret = SymGetLineFromAddr64(process, addr, &mut displacement, &mut line);\n-    if ret == libc::TRUE {\n+    if ret == c::TRUE {\n         output_fileline(w,\n                         unsafe { CStr::from_ptr(line.Filename).to_bytes() },\n-                        line.LineNumber as libc::c_int,\n+                        line.LineNumber as c_int,\n                         false)\n     } else {\n         Ok(())"}, {"sha": "e0f8d6f9df96306ed3ec3ea38d7413a93e05beaa", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 31, "deletions": 37, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -19,13 +19,14 @@ use ffi::{OsString, OsStr};\n use fmt;\n use fs;\n use io::{self, Error};\n-use libc::{self, c_void};\n+use libc::c_void;\n use mem;\n use os::windows::ffi::OsStrExt;\n use path::Path;\n use ptr;\n use sync::StaticMutex;\n use sys::c;\n+\n use sys::fs::{OpenOptions, File};\n use sys::handle::{Handle, RawHandle};\n use sys::stdio;\n@@ -107,7 +108,7 @@ pub struct Process {\n pub enum Stdio {\n     Inherit,\n     None,\n-    Raw(libc::HANDLE),\n+    Raw(c::HANDLE),\n }\n \n pub type RawStdio = Handle;\n@@ -118,9 +119,6 @@ impl Process {\n                  out_handle: Stdio,\n                  err_handle: Stdio) -> io::Result<Process>\n     {\n-        use libc::{TRUE, STARTF_USESTDHANDLES};\n-        use libc::{DWORD, STARTUPINFO, CreateProcessW};\n-\n         // To have the spawning semantics of unix/windows stay the same, we need\n         // to read the *child's* PATH if one is provided. See #15149 for more\n         // details.\n@@ -143,8 +141,8 @@ impl Process {\n         });\n \n         let mut si = zeroed_startupinfo();\n-        si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n-        si.dwFlags = STARTF_USESTDHANDLES;\n+        si.cb = mem::size_of::<c::STARTUPINFO>() as c::DWORD;\n+        si.dwFlags = c::STARTF_USESTDHANDLES;\n \n         let stdin = try!(in_handle.to_handle(c::STD_INPUT_HANDLE));\n         let stdout = try!(out_handle.to_handle(c::STD_OUTPUT_HANDLE));\n@@ -159,9 +157,9 @@ impl Process {\n         cmd_str.push(0); // add null terminator\n \n         // stolen from the libuv code.\n-        let mut flags = libc::CREATE_UNICODE_ENVIRONMENT;\n+        let mut flags = c::CREATE_UNICODE_ENVIRONMENT;\n         if cfg.detach {\n-            flags |= libc::DETACHED_PROCESS | libc::CREATE_NEW_PROCESS_GROUP;\n+            flags |= c::DETACHED_PROCESS | c::CREATE_NEW_PROCESS_GROUP;\n         }\n \n         let (envp, _data) = make_envp(cfg.env.as_ref());\n@@ -173,12 +171,12 @@ impl Process {\n             static CREATE_PROCESS_LOCK: StaticMutex = StaticMutex::new();\n             let _lock = CREATE_PROCESS_LOCK.lock();\n \n-            cvt(CreateProcessW(ptr::null(),\n-                               cmd_str.as_mut_ptr(),\n-                               ptr::null_mut(),\n-                               ptr::null_mut(),\n-                               TRUE, flags, envp, dirp,\n-                               &mut si, &mut pi))\n+            cvt(c::CreateProcessW(ptr::null(),\n+                                  cmd_str.as_mut_ptr(),\n+                                  ptr::null_mut(),\n+                                  ptr::null_mut(),\n+                                  c::TRUE, flags, envp, dirp,\n+                                  &mut si, &mut pi))\n         });\n \n         // We close the thread handle because we don't care about keeping\n@@ -190,7 +188,7 @@ impl Process {\n     }\n \n     pub unsafe fn kill(&self) -> io::Result<()> {\n-        try!(cvt(libc::TerminateProcess(self.handle.raw(), 1)));\n+        try!(cvt(c::TerminateProcess(self.handle.raw(), 1)));\n         Ok(())\n     }\n \n@@ -201,15 +199,13 @@ impl Process {\n     }\n \n     pub fn wait(&self) -> io::Result<ExitStatus> {\n-        use libc::{INFINITE, WAIT_OBJECT_0};\n-        use libc::{GetExitCodeProcess, WaitForSingleObject};\n-\n         unsafe {\n-            if WaitForSingleObject(self.handle.raw(), INFINITE) != WAIT_OBJECT_0 {\n+            let res = c::WaitForSingleObject(self.handle.raw(), c::INFINITE);\n+            if res != c::WAIT_OBJECT_0 {\n                 return Err(Error::last_os_error())\n             }\n             let mut status = 0;\n-            try!(cvt(GetExitCodeProcess(self.handle.raw(), &mut status)));\n+            try!(cvt(c::GetExitCodeProcess(self.handle.raw(), &mut status)));\n             Ok(ExitStatus(status))\n         }\n     }\n@@ -220,7 +216,7 @@ impl Process {\n }\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitStatus(libc::DWORD);\n+pub struct ExitStatus(c::DWORD);\n \n impl ExitStatus {\n     pub fn success(&self) -> bool {\n@@ -237,8 +233,8 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n-fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n-    libc::types::os::arch::extra::STARTUPINFO {\n+fn zeroed_startupinfo() -> c::STARTUPINFO {\n+    c::STARTUPINFO {\n         cb: 0,\n         lpReserved: ptr::null_mut(),\n         lpDesktop: ptr::null_mut(),\n@@ -254,14 +250,14 @@ fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n         wShowWindow: 0,\n         cbReserved2: 0,\n         lpReserved2: ptr::null_mut(),\n-        hStdInput: libc::INVALID_HANDLE_VALUE,\n-        hStdOutput: libc::INVALID_HANDLE_VALUE,\n-        hStdError: libc::INVALID_HANDLE_VALUE,\n+        hStdInput: c::INVALID_HANDLE_VALUE,\n+        hStdOutput: c::INVALID_HANDLE_VALUE,\n+        hStdError: c::INVALID_HANDLE_VALUE,\n     }\n }\n \n-fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION {\n-    libc::types::os::arch::extra::PROCESS_INFORMATION {\n+fn zeroed_process_information() -> c::PROCESS_INFORMATION {\n+    c::PROCESS_INFORMATION {\n         hProcess: ptr::null_mut(),\n         hThread: ptr::null_mut(),\n         dwProcessId: 0,\n@@ -353,27 +349,25 @@ fn make_dirp(d: Option<&OsString>) -> (*const u16, Vec<u16>) {\n }\n \n impl Stdio {\n-    fn to_handle(&self, stdio_id: libc::DWORD) -> io::Result<Handle> {\n-        use libc::DUPLICATE_SAME_ACCESS;\n-\n+    fn to_handle(&self, stdio_id: c::DWORD) -> io::Result<Handle> {\n         match *self {\n             Stdio::Inherit => {\n                 stdio::get(stdio_id).and_then(|io| {\n-                    io.handle().duplicate(0, true, DUPLICATE_SAME_ACCESS)\n+                    io.handle().duplicate(0, true, c::DUPLICATE_SAME_ACCESS)\n                 })\n             }\n             Stdio::Raw(handle) => {\n-                RawHandle::new(handle).duplicate(0, true, DUPLICATE_SAME_ACCESS)\n+                RawHandle::new(handle).duplicate(0, true, c::DUPLICATE_SAME_ACCESS)\n             }\n \n             // Similarly to unix, we don't actually leave holes for the\n             // stdio file descriptors, but rather open up /dev/null\n             // equivalents. These equivalents are drawn from libuv's\n             // windows process spawning.\n             Stdio::None => {\n-                let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n-                let mut sa = libc::SECURITY_ATTRIBUTES {\n-                    nLength: size as libc::DWORD,\n+                let size = mem::size_of::<c::SECURITY_ATTRIBUTES>();\n+                let mut sa = c::SECURITY_ATTRIBUTES {\n+                    nLength: size as c::DWORD,\n                     lpSecurityDescriptor: ptr::null_mut(),\n                     bInheritHandle: 1,\n                 };"}, {"sha": "01317bec0de8879056424984b847656b0c3d1b73", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc::{self, LONG};\n use sys_common::util::report_overflow;\n use sys::c;\n \n@@ -19,7 +18,7 @@ impl Handler {\n         // This API isn't available on XP, so don't panic in that case and just\n         // pray it works out ok.\n         if c::SetThreadStackGuarantee(&mut 0x5000) == 0 {\n-            if libc::GetLastError() as u32 != libc::ERROR_CALL_NOT_IMPLEMENTED as u32 {\n+            if c::GetLastError() as u32 != c::ERROR_CALL_NOT_IMPLEMENTED as u32 {\n                 panic!(\"failed to reserve stack space for exception handling\");\n             }\n         }\n@@ -28,7 +27,7 @@ impl Handler {\n }\n \n extern \"system\" fn vectored_handler(ExceptionInfo: *mut c::EXCEPTION_POINTERS)\n-                                    -> LONG {\n+                                    -> c::LONG {\n     unsafe {\n         let rec = &(*(*ExceptionInfo).ExceptionRecord);\n         let code = rec.ExceptionCode;"}, {"sha": "8f37dc02e87af80732a2468c6a6497f35d1e6e9c", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -12,7 +12,6 @@ use prelude::v1::*;\n use io::prelude::*;\n \n use io::{self, Cursor};\n-use libc;\n use ptr;\n use str;\n use sync::Mutex;\n@@ -34,9 +33,9 @@ pub struct Stdin {\n pub struct Stdout(Output);\n pub struct Stderr(Output);\n \n-pub fn get(handle: libc::DWORD) -> io::Result<Output> {\n+pub fn get(handle: c::DWORD) -> io::Result<Output> {\n     let handle = unsafe { c::GetStdHandle(handle) };\n-    if handle == libc::INVALID_HANDLE_VALUE {\n+    if handle == c::INVALID_HANDLE_VALUE {\n         Err(io::Error::last_os_error())\n     } else if handle.is_null() {\n         Err(io::Error::new(io::ErrorKind::Other,\n@@ -63,7 +62,7 @@ fn write(out: &Output, data: &[u8]) -> io::Result<usize> {\n     let mut written = 0;\n     try!(cvt(unsafe {\n         c::WriteConsoleW(handle,\n-                         utf16.as_ptr() as libc::LPCVOID,\n+                         utf16.as_ptr() as c::LPCVOID,\n                          utf16.len() as u32,\n                          &mut written,\n                          ptr::null_mut())\n@@ -97,7 +96,7 @@ impl Stdin {\n             let mut num = 0;\n             try!(cvt(unsafe {\n                 c::ReadConsoleW(handle,\n-                                utf16.as_mut_ptr() as libc::LPVOID,\n+                                utf16.as_mut_ptr() as c::LPVOID,\n                                 utf16.len() as u32,\n                                 &mut num,\n                                 ptr::null_mut())\n@@ -147,7 +146,7 @@ impl io::Write for Stderr {\n }\n \n impl NoClose {\n-    fn new(handle: libc::HANDLE) -> NoClose {\n+    fn new(handle: c::HANDLE) -> NoClose {\n         NoClose(Some(Handle::new(handle)))\n     }\n "}, {"sha": "a6e6cc94b7679cc42a11e13fa9f48a4e81dceb9b", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -12,8 +12,8 @@ use prelude::v1::*;\n \n use alloc::boxed::FnBox;\n use io;\n-use libc::{self, c_void, DWORD};\n use mem;\n+use libc::c_void;\n use ptr;\n use sys::c;\n use sys::handle::Handle;\n@@ -37,7 +37,7 @@ impl Thread {\n         // Round up to the next 64 kB because that's what the NT kernel does,\n         // might as well make it explicit.\n         let stack_size = (stack + 0xfffe) & (!0xfffe);\n-        let ret = c::CreateThread(ptr::null_mut(), stack_size as libc::size_t,\n+        let ret = c::CreateThread(ptr::null_mut(), stack_size,\n                                   thread_start, &*p as *const _ as *mut _,\n                                   0, ptr::null_mut());\n \n@@ -48,7 +48,7 @@ impl Thread {\n             Ok(Thread { handle: Handle::new(ret) })\n         };\n \n-        extern \"system\" fn thread_start(main: *mut libc::c_void) -> DWORD {\n+        extern \"system\" fn thread_start(main: *mut c_void) -> c::DWORD {\n             unsafe { start_thread(main); }\n             0\n         }\n@@ -62,8 +62,7 @@ impl Thread {\n     }\n \n     pub fn join(self) {\n-        use libc::consts::os::extra::INFINITE;\n-        unsafe { c::WaitForSingleObject(self.handle.raw(), INFINITE); }\n+        unsafe { c::WaitForSingleObject(self.handle.raw(), c::INFINITE); }\n     }\n \n     pub fn yield_now() {"}, {"sha": "db2ad1d89c4d867c033a18adfca19b9b6d5bd2e9", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -10,13 +10,12 @@\n \n use prelude::v1::*;\n \n-use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n-\n use ptr;\n-use sys_common;\n+use sys::c;\n use sys_common::mutex::Mutex;\n+use sys_common;\n \n-pub type Key = DWORD;\n+pub type Key = c::DWORD;\n pub type Dtor = unsafe extern fn(*mut u8);\n \n // Turns out, like pretty much everything, Windows is pretty close the\n@@ -68,9 +67,8 @@ static mut DTORS: *mut Vec<(Key, Dtor)> = ptr::null_mut();\n \n #[inline]\n pub unsafe fn create(dtor: Option<Dtor>) -> Key {\n-    const TLS_OUT_OF_INDEXES: DWORD = 0xFFFFFFFF;\n-    let key = TlsAlloc();\n-    assert!(key != TLS_OUT_OF_INDEXES);\n+    let key = c::TlsAlloc();\n+    assert!(key != c::TLS_OUT_OF_INDEXES);\n     match dtor {\n         Some(f) => register_dtor(key, f),\n         None => {}\n@@ -80,13 +78,13 @@ pub unsafe fn create(dtor: Option<Dtor>) -> Key {\n \n #[inline]\n pub unsafe fn set(key: Key, value: *mut u8) {\n-    let r = TlsSetValue(key, value as LPVOID);\n+    let r = c::TlsSetValue(key, value as c::LPVOID);\n     debug_assert!(r != 0);\n }\n \n #[inline]\n pub unsafe fn get(key: Key) -> *mut u8 {\n-    TlsGetValue(key) as *mut u8\n+    c::TlsGetValue(key) as *mut u8\n }\n \n #[inline]\n@@ -107,18 +105,11 @@ pub unsafe fn destroy(key: Key) {\n         // Note that source [2] above shows precedent for this sort\n         // of strategy.\n     } else {\n-        let r = TlsFree(key);\n+        let r = c::TlsFree(key);\n         debug_assert!(r != 0);\n     }\n }\n \n-extern \"system\" {\n-    fn TlsAlloc() -> DWORD;\n-    fn TlsFree(dwTlsIndex: DWORD) -> BOOL;\n-    fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n-    fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n-}\n-\n // -------------------------------------------------------------------------\n // Dtor registration\n //\n@@ -243,17 +234,15 @@ unsafe fn unregister_dtor(key: Key) -> bool {\n #[link_section = \".CRT$XLB\"]\n #[linkage = \"external\"]\n #[allow(warnings)]\n-pub static p_thread_callback: unsafe extern \"system\" fn(LPVOID, DWORD,\n-                                                        LPVOID) =\n+pub static p_thread_callback: unsafe extern \"system\" fn(c::LPVOID, c::DWORD,\n+                                                        c::LPVOID) =\n         on_tls_callback;\n \n #[allow(warnings)]\n-unsafe extern \"system\" fn on_tls_callback(h: LPVOID,\n-                                          dwReason: DWORD,\n-                                          pv: LPVOID) {\n-    const DLL_THREAD_DETACH: DWORD = 3;\n-    const DLL_PROCESS_DETACH: DWORD = 0;\n-    if dwReason == DLL_THREAD_DETACH || dwReason == DLL_PROCESS_DETACH {\n+unsafe extern \"system\" fn on_tls_callback(h: c::LPVOID,\n+                                          dwReason: c::DWORD,\n+                                          pv: c::LPVOID) {\n+    if dwReason == c::DLL_THREAD_DETACH || dwReason == c::DLL_PROCESS_DETACH {\n         run_dtors();\n     }\n \n@@ -286,9 +275,9 @@ unsafe fn run_dtors() {\n             ret\n         };\n         for &(key, dtor) in &dtors {\n-            let ptr = TlsGetValue(key);\n+            let ptr = c::TlsGetValue(key);\n             if !ptr.is_null() {\n-                TlsSetValue(key, ptr::null_mut());\n+                c::TlsSetValue(key, ptr::null_mut());\n                 dtor(ptr as *mut _);\n                 any_run = true;\n             }"}, {"sha": "4dc7997d22e85381fe832266aa5e5537954023d2", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -7,32 +7,33 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use libc;\n+\n use ops::Sub;\n-use time::Duration;\n use sync::Once;\n+use sys::c;\n+use time::Duration;\n \n const NANOS_PER_SEC: u64 = 1_000_000_000;\n \n pub struct SteadyTime {\n-    t: libc::LARGE_INTEGER,\n+    t: c::LARGE_INTEGER,\n }\n \n impl SteadyTime {\n     pub fn now() -> SteadyTime {\n         let mut t = SteadyTime { t: 0 };\n-        unsafe { libc::QueryPerformanceCounter(&mut t.t); }\n+        unsafe { c::QueryPerformanceCounter(&mut t.t); }\n         t\n     }\n }\n \n-fn frequency() -> libc::LARGE_INTEGER {\n-    static mut FREQUENCY: libc::LARGE_INTEGER = 0;\n+fn frequency() -> c::LARGE_INTEGER {\n+    static mut FREQUENCY: c::LARGE_INTEGER = 0;\n     static ONCE: Once = Once::new();\n \n     unsafe {\n         ONCE.call_once(|| {\n-            libc::QueryPerformanceFrequency(&mut FREQUENCY);\n+            c::QueryPerformanceFrequency(&mut FREQUENCY);\n         });\n         FREQUENCY\n     }"}, {"sha": "f1fd8be4728302c1a55c25c5db2d79bc422547dc", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -21,7 +21,6 @@ use std::{cmp, error, fmt};\n use std::io::prelude::*;\n use std::io;\n use term::{self, WriterWrapper};\n-use libc;\n \n /// maximum number of lines we will print for each error; arbitrary.\n const MAX_LINES: usize = 6;\n@@ -767,15 +766,19 @@ impl EmitterWriter {\n \n #[cfg(unix)]\n fn stderr_isatty() -> bool {\n+    use libc;\n     unsafe { libc::isatty(libc::STDERR_FILENO) != 0 }\n }\n #[cfg(windows)]\n fn stderr_isatty() -> bool {\n-    const STD_ERROR_HANDLE: libc::DWORD = -12i32 as libc::DWORD;\n+    type DWORD = u32;\n+    type BOOL = i32;\n+    type HANDLE = *mut u8;\n+    const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n     extern \"system\" {\n-        fn GetStdHandle(which: libc::DWORD) -> libc::HANDLE;\n-        fn GetConsoleMode(hConsoleHandle: libc::HANDLE,\n-                          lpMode: libc::LPDWORD) -> libc::BOOL;\n+        fn GetStdHandle(which: DWORD) -> HANDLE;\n+        fn GetConsoleMode(hConsoleHandle: HANDLE,\n+                          lpMode: *mut DWORD) -> BOOL;\n     }\n     unsafe {\n         let handle = GetStdHandle(STD_ERROR_HANDLE);"}, {"sha": "28ddc56793832e3506da2ff263ba9c4f8d3445e6", "filename": "src/libterm/win.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -30,23 +30,28 @@ pub struct WinConsole<T> {\n     background: color::Color,\n }\n \n+type WORD = u16;\n+type DWORD = u32;\n+type BOOL = i32;\n+type HANDLE = *mut u8;\n+\n #[allow(non_snake_case)]\n #[repr(C)]\n struct CONSOLE_SCREEN_BUFFER_INFO {\n     dwSize: [libc::c_short; 2],\n     dwCursorPosition: [libc::c_short; 2],\n-    wAttributes: libc::WORD,\n+    wAttributes: WORD,\n     srWindow: [libc::c_short; 4],\n     dwMaximumWindowSize: [libc::c_short; 2],\n }\n \n #[allow(non_snake_case)]\n #[link(name = \"kernel32\")]\n extern \"system\" {\n-    fn SetConsoleTextAttribute(handle: libc::HANDLE, attr: libc::WORD) -> libc::BOOL;\n-    fn GetStdHandle(which: libc::DWORD) -> libc::HANDLE;\n-    fn GetConsoleScreenBufferInfo(handle: libc::HANDLE,\n-                                  info: *mut CONSOLE_SCREEN_BUFFER_INFO) -> libc::BOOL;\n+    fn SetConsoleTextAttribute(handle: HANDLE, attr: WORD) -> BOOL;\n+    fn GetStdHandle(which: DWORD) -> HANDLE;\n+    fn GetConsoleScreenBufferInfo(handle: HANDLE,\n+                                  info: *mut CONSOLE_SCREEN_BUFFER_INFO) -> BOOL;\n }\n \n fn color_to_bits(color: color::Color) -> u16 {\n@@ -90,7 +95,7 @@ fn bits_to_color(bits: u16) -> color::Color {\n impl<T: Write+Send+'static> WinConsole<T> {\n     fn apply(&mut self) {\n         let _unused = self.buf.flush();\n-        let mut accum: libc::WORD = 0;\n+        let mut accum: WORD = 0;\n         accum |= color_to_bits(self.foreground);\n         accum |= color_to_bits(self.background) << 4;\n \n@@ -104,7 +109,7 @@ impl<T: Write+Send+'static> WinConsole<T> {\n             // terminal! Admittedly, this is fragile, since stderr could be\n             // redirected to a different console. This is good enough for\n             // rustc though. See #13400.\n-            let out = GetStdHandle(-11i32 as libc::DWORD);\n+            let out = GetStdHandle(-11i32 as DWORD);\n             SetConsoleTextAttribute(out, accum);\n         }\n     }\n@@ -116,7 +121,7 @@ impl<T: Write+Send+'static> WinConsole<T> {\n         let bg;\n         unsafe {\n             let mut buffer_info = ::std::mem::uninitialized();\n-            if GetConsoleScreenBufferInfo(GetStdHandle(-11i32 as libc::DWORD),\n+            if GetConsoleScreenBufferInfo(GetStdHandle(-11i32 as DWORD),\n                                           &mut buffer_info) != 0 {\n                 fg = bits_to_color(buffer_info.wAttributes);\n                 bg = bits_to_color(buffer_info.wAttributes >> 4);"}, {"sha": "69b1d37bfc4ee9613b0da3a49f4a0c878b2ad6f0", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -777,11 +777,14 @@ fn stdout_isatty() -> bool {\n }\n #[cfg(windows)]\n fn stdout_isatty() -> bool {\n-    const STD_OUTPUT_HANDLE: libc::DWORD = -11i32 as libc::DWORD;\n+    type DWORD = u32;\n+    type BOOL = i32;\n+    type HANDLE = *mut u8;\n+    type LPDWORD = *mut u32;\n+    const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n     extern \"system\" {\n-        fn GetStdHandle(which: libc::DWORD) -> libc::HANDLE;\n-        fn GetConsoleMode(hConsoleHandle: libc::HANDLE,\n-                          lpMode: libc::LPDWORD) -> libc::BOOL;\n+        fn GetStdHandle(which: DWORD) -> HANDLE;\n+        fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n     }\n     unsafe {\n         let handle = GetStdHandle(STD_OUTPUT_HANDLE);\n@@ -882,10 +885,28 @@ fn get_concurrency() -> usize {\n     };\n \n     #[cfg(windows)]\n+    #[allow(bad_style)]\n     fn num_cpus() -> usize {\n+        #[repr(C)]\n+        struct SYSTEM_INFO {\n+            wProcessorArchitecture: u16,\n+            wReserved: u16,\n+            dwPageSize: u32,\n+            lpMinimumApplicationAddress: *mut u8,\n+            lpMaximumApplicationAddress: *mut u8,\n+            dwActiveProcessorMask: *mut u8,\n+            dwNumberOfProcessors: u32,\n+            dwProcessorType: u32,\n+            dwAllocationGranularity: u32,\n+            wProcessorLevel: u16,\n+            wProcessorRevision: u16,\n+        }\n+        extern \"system\" {\n+            fn GetSystemInfo(info: *mut SYSTEM_INFO) -> i32;\n+        }\n         unsafe {\n             let mut sysinfo = std::mem::zeroed();\n-            libc::GetSystemInfo(&mut sysinfo);\n+            GetSystemInfo(&mut sysinfo);\n             sysinfo.dwNumberOfProcessors as usize\n         }\n     }"}, {"sha": "cca27aebfa44fbb7b7f16026ef854db5d3a1187e", "filename": "src/test/run-pass/issue-13259-windows-tcb-trash.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Ftest%2Frun-pass%2Fissue-13259-windows-tcb-trash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Ftest%2Frun-pass%2Fissue-13259-windows-tcb-trash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13259-windows-tcb-trash.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -14,8 +14,9 @@ extern crate libc;\n \n #[cfg(windows)]\n mod imp {\n-    use libc::{c_void, LPVOID, DWORD};\n-    use libc::types::os::arch::extra::LPWSTR;\n+    type LPVOID = *mut u8;\n+    type DWORD = u32;\n+    type LPWSTR = *mut u16;\n \n     extern \"system\" {\n         fn FormatMessageW(flags: DWORD,\n@@ -24,15 +25,15 @@ mod imp {\n                           langId: DWORD,\n                           buf: LPWSTR,\n                           nsize: DWORD,\n-                          args: *const c_void)\n+                          args: *const u8)\n                           -> DWORD;\n     }\n \n     pub fn test() {\n         let mut buf: [u16; 50] = [0; 50];\n         let ret = unsafe {\n-            FormatMessageW(0x1000, 0 as *mut c_void, 1, 0x400,\n-                           buf.as_mut_ptr(), buf.len() as u32, 0 as *const c_void)\n+            FormatMessageW(0x1000, 0 as *mut _, 1, 0x400,\n+                           buf.as_mut_ptr(), buf.len() as u32, 0 as *const _)\n         };\n         // On some 32-bit Windowses (Win7-8 at least) this will panic with segmented\n         // stacks taking control of pvArbitrary"}, {"sha": "7cdaf278a08f5a510d408b155c4edc56ec608f56", "filename": "src/test/run-pass/rfc-1014-2.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Ftest%2Frun-pass%2Frfc-1014-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Ftest%2Frun-pass%2Frfc-1014-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-1014-2.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -11,15 +11,19 @@\n \n extern crate libc;\n \n+type DWORD = u32;\n+type HANDLE = *mut u8;\n+type BOOL = i32;\n+\n #[cfg(windows)]\n extern \"system\" {\n-    fn SetStdHandle(nStdHandle: libc::DWORD, nHandle: libc::HANDLE) -> libc::BOOL;\n+    fn SetStdHandle(nStdHandle: DWORD, nHandle: HANDLE) -> BOOL;\n }\n \n #[cfg(windows)]\n fn close_stdout() {\n-    const STD_OUTPUT_HANDLE: libc::DWORD = -11i32 as libc::DWORD;\n-    unsafe { SetStdHandle(STD_OUTPUT_HANDLE, 0 as libc::HANDLE); }\n+    const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n+    unsafe { SetStdHandle(STD_OUTPUT_HANDLE, 0 as HANDLE); }\n }\n \n #[cfg(windows)]"}, {"sha": "df969070a2ad451c6f521b0fd8600b1063204cea", "filename": "src/test/run-pass/rfc-1014.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Ftest%2Frun-pass%2Frfc-1014.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Ftest%2Frun-pass%2Frfc-1014.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-1014.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -11,20 +11,24 @@\n \n extern crate libc;\n \n+type DWORD = u32;\n+type HANDLE = *mut u8;\n+\n #[cfg(windows)]\n extern \"system\" {\n-    pub fn GetStdHandle(which: libc::DWORD) -> libc::HANDLE;\n+    fn GetStdHandle(which: DWORD) -> HANDLE;\n+    fn CloseHandle(handle: HANDLE) -> i32;\n }\n \n #[cfg(windows)]\n fn close_stdout() {\n-    const STD_OUTPUT_HANDLE: libc::DWORD = -11i32 as libc::DWORD;\n-    unsafe { libc::CloseHandle(GetStdHandle(STD_OUTPUT_HANDLE)); }\n+    const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n+    unsafe { CloseHandle(GetStdHandle(STD_OUTPUT_HANDLE)); }\n }\n \n #[cfg(not(windows))]\n fn close_stdout() {\n-    unsafe { libc::close(libc::STDOUT_FILENO); }\n+    unsafe { libc::close(1); }\n }\n \n fn main() {"}, {"sha": "795c3f46f757941254bf62bee444625977ee405f", "filename": "src/test/run-pass/wait-forked-but-failed-child.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs?ref=3d28b8b98e6e4f55ef4ecd8babf0a050f48a3d11", "patch": "@@ -15,8 +15,6 @@ extern crate libc;\n \n use std::process::Command;\n \n-use libc::funcs::posix88::unistd;\n-\n // The output from \"ps -A -o pid,ppid,args\" should look like this:\n //   PID  PPID COMMAND\n //     1     0 /sbin/init\n@@ -34,7 +32,7 @@ use libc::funcs::posix88::unistd;\n \n #[cfg(unix)]\n fn find_zombies() {\n-    let my_pid = unsafe { unistd::getpid() };\n+    let my_pid = unsafe { libc::getpid() };\n \n     // http://pubs.opengroup.org/onlinepubs/9699919799/utilities/ps.html\n     let ps_cmd_output = Command::new(\"ps\").args(&[\"-A\", \"-o\", \"pid,ppid,args\"]).output().unwrap();"}]}