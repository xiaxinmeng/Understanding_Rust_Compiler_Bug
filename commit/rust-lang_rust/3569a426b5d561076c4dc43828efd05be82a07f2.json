{"sha": "3569a426b5d561076c4dc43828efd05be82a07f2", "node_id": "C_kwDOAAsO6NoAKDM1NjlhNDI2YjVkNTYxMDc2YzRkYzQzODI4ZWZkMDViZTgyYTA3ZjI", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-05-24T13:58:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-24T13:58:24Z"}, "message": "Rollup merge of #97288 - compiler-errors:tcxify-rustdoc, r=Dylan-DPC\n\nLifetime variance fixes for rustdoc\n\n#97287 migrates rustc to a `Ty` type that is invariant over its lifetime `'tcx`, so I need to fix a bunch of places that assume that `Ty<'a>` and `Ty<'b>` can be unified by shortening both to some common lifetime.\n\nThis is doable, since everything is already `'tcx`, so all this PR does is be a bit more explicit that elided lifetimes are actually `'tcx`.\n\nSplit out from #97287 so the rustdoc team can review independently.", "tree": {"sha": "dc0cbb00559f60107d12f1028693e0fc6902e196", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc0cbb00559f60107d12f1028693e0fc6902e196"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3569a426b5d561076c4dc43828efd05be82a07f2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJijOSACRBK7hj4Ov3rIwAA244IAIaiM1g7NSdfXOi1WumJnXbJ\n6d1QagoC0TXMxVmgWxRS6ctCvxjgb1cz+lTKdepSAfTEb6H2qyWP5ljkp9zkTK4t\nfwYtnSk/dh025b2uNSIbK8g4ZbgB0oe7co6K8eB/aQ+Xs+yNAUppZeV0sX5U+uJ0\nNPBWvfiREl40j9vdoJDqaExtL3KWx0fx896ufGXdVCdzDRwtey9aTIMxNY3grXjD\n8zawiLHfOkKfo/n8nmE+yg71uA9XtpBgrCpfatTBNc46I38jiaXjocc9aDcrNOLn\nVr2taojry32m/FV+p1EnX/fbifAxxYArkTcsKKlHQiiqiogT22mSI2O8r6Konbk=\n=JyvV\n-----END PGP SIGNATURE-----\n", "payload": "tree dc0cbb00559f60107d12f1028693e0fc6902e196\nparent b2eba058e6e1c698723e47074561a30b50b5fa7a\nparent b2a95cb582cec1088b060e79e1ef6ce5a9393ed0\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1653400704 +0200\ncommitter GitHub <noreply@github.com> 1653400704 +0200\n\nRollup merge of #97288 - compiler-errors:tcxify-rustdoc, r=Dylan-DPC\n\nLifetime variance fixes for rustdoc\n\n#97287 migrates rustc to a `Ty` type that is invariant over its lifetime `'tcx`, so I need to fix a bunch of places that assume that `Ty<'a>` and `Ty<'b>` can be unified by shortening both to some common lifetime.\n\nThis is doable, since everything is already `'tcx`, so all this PR does is be a bit more explicit that elided lifetimes are actually `'tcx`.\n\nSplit out from #97287 so the rustdoc team can review independently.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3569a426b5d561076c4dc43828efd05be82a07f2", "html_url": "https://github.com/rust-lang/rust/commit/3569a426b5d561076c4dc43828efd05be82a07f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3569a426b5d561076c4dc43828efd05be82a07f2/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2eba058e6e1c698723e47074561a30b50b5fa7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2eba058e6e1c698723e47074561a30b50b5fa7a", "html_url": "https://github.com/rust-lang/rust/commit/b2eba058e6e1c698723e47074561a30b50b5fa7a"}, {"sha": "b2a95cb582cec1088b060e79e1ef6ce5a9393ed0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2a95cb582cec1088b060e79e1ef6ce5a9393ed0", "html_url": "https://github.com/rust-lang/rust/commit/b2a95cb582cec1088b060e79e1ef6ce5a9393ed0"}], "stats": {"total": 320, "additions": 166, "deletions": 154}, "files": [{"sha": "bda7affe52983b5ab1ca08b0f20b702a3219292f", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3569a426b5d561076c4dc43828efd05be82a07f2/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3569a426b5d561076c4dc43828efd05be82a07f2/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=3569a426b5d561076c4dc43828efd05be82a07f2", "patch": "@@ -343,12 +343,12 @@ pub struct GenericArgs<'hir> {\n     pub span_ext: Span,\n }\n \n-impl GenericArgs<'_> {\n+impl<'hir> GenericArgs<'hir> {\n     pub const fn none() -> Self {\n         Self { args: &[], bindings: &[], parenthesized: false, span_ext: DUMMY_SP }\n     }\n \n-    pub fn inputs(&self) -> &[Ty<'_>] {\n+    pub fn inputs(&self) -> &[Ty<'hir>] {\n         if self.parenthesized {\n             for arg in self.args {\n                 match arg {\n@@ -549,7 +549,7 @@ impl<'hir> Generics<'hir> {\n         &NOPE\n     }\n \n-    pub fn get_named(&self, name: Symbol) -> Option<&GenericParam<'_>> {\n+    pub fn get_named(&self, name: Symbol) -> Option<&GenericParam<'hir>> {\n         for param in self.params {\n             if name == param.name.ident().name {\n                 return Some(param);\n@@ -608,7 +608,7 @@ impl<'hir> Generics<'hir> {\n     pub fn bounds_for_param(\n         &self,\n         param_def_id: LocalDefId,\n-    ) -> impl Iterator<Item = &WhereBoundPredicate<'_>> {\n+    ) -> impl Iterator<Item = &WhereBoundPredicate<'hir>> {\n         self.predicates.iter().filter_map(move |pred| match pred {\n             WherePredicate::BoundPredicate(bp) if bp.is_param_bound(param_def_id.to_def_id()) => {\n                 Some(bp)"}, {"sha": "a82abe669265540ea958589a8cdc49e4cbcc5169", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3569a426b5d561076c4dc43828efd05be82a07f2/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3569a426b5d561076c4dc43828efd05be82a07f2/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3569a426b5d561076c4dc43828efd05be82a07f2", "patch": "@@ -218,7 +218,7 @@ pub(crate) fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean\n     }\n }\n \n-fn build_external_function(cx: &mut DocContext<'_>, did: DefId) -> clean::Function {\n+fn build_external_function<'tcx>(cx: &mut DocContext<'tcx>, did: DefId) -> clean::Function {\n     let sig = cx.tcx.fn_sig(did);\n \n     let predicates = cx.tcx.predicates_of(did);"}, {"sha": "4068531f0108ba972c4b801bd53c8a73ead3b612", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 150, "deletions": 138, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/3569a426b5d561076c4dc43828efd05be82a07f2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3569a426b5d561076c4dc43828efd05be82a07f2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3569a426b5d561076c4dc43828efd05be82a07f2", "patch": "@@ -44,12 +44,12 @@ use utils::*;\n pub(crate) use self::types::*;\n pub(crate) use self::utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n \n-pub(crate) trait Clean<T> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> T;\n+pub(crate) trait Clean<'tcx, T> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> T;\n }\n \n-impl Clean<Item> for DocModule<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for DocModule<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let mut items: Vec<Item> = vec![];\n         items.extend(\n             self.foreigns\n@@ -89,14 +89,14 @@ impl Clean<Item> for DocModule<'_> {\n     }\n }\n \n-impl Clean<Attributes> for [ast::Attribute] {\n+impl<'tcx> Clean<'tcx, Attributes> for [ast::Attribute] {\n     fn clean(&self, _cx: &mut DocContext<'_>) -> Attributes {\n         Attributes::from_ast(self, None)\n     }\n }\n \n-impl Clean<Option<GenericBound>> for hir::GenericBound<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<GenericBound> {\n+impl<'tcx> Clean<'tcx, Option<GenericBound>> for hir::GenericBound<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<GenericBound> {\n         Some(match *self {\n             hir::GenericBound::Outlives(lt) => GenericBound::Outlives(lt.clean(cx)),\n             hir::GenericBound::LangItemTrait(lang_item, span, _, generic_args) => {\n@@ -131,9 +131,9 @@ impl Clean<Option<GenericBound>> for hir::GenericBound<'_> {\n     }\n }\n \n-fn clean_trait_ref_with_bindings(\n-    cx: &mut DocContext<'_>,\n-    trait_ref: ty::TraitRef<'_>,\n+fn clean_trait_ref_with_bindings<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    trait_ref: ty::TraitRef<'tcx>,\n     bindings: &[TypeBinding],\n ) -> Path {\n     let kind = cx.tcx.def_kind(trait_ref.def_id).into();\n@@ -148,15 +148,15 @@ fn clean_trait_ref_with_bindings(\n     path\n }\n \n-impl Clean<Path> for ty::TraitRef<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n+impl<'tcx> Clean<'tcx, Path> for ty::TraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Path {\n         clean_trait_ref_with_bindings(cx, *self, &[])\n     }\n }\n \n-fn clean_poly_trait_ref_with_bindings(\n-    cx: &mut DocContext<'_>,\n-    poly_trait_ref: ty::PolyTraitRef<'_>,\n+fn clean_poly_trait_ref_with_bindings<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     bindings: &[TypeBinding],\n ) -> GenericBound {\n     let poly_trait_ref = poly_trait_ref.lift_to_tcx(cx.tcx).unwrap();\n@@ -182,14 +182,14 @@ fn clean_poly_trait_ref_with_bindings(\n     )\n }\n \n-impl<'tcx> Clean<GenericBound> for ty::PolyTraitRef<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n+impl<'tcx> Clean<'tcx, GenericBound> for ty::PolyTraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericBound {\n         clean_poly_trait_ref_with_bindings(cx, *self, &[])\n     }\n }\n \n-impl Clean<Lifetime> for hir::Lifetime {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Lifetime {\n+impl<'tcx> Clean<'tcx, Lifetime> for hir::Lifetime {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Lifetime {\n         let def = cx.tcx.named_region(self.hir_id);\n         if let Some(\n             rl::Region::EarlyBound(_, node_id)\n@@ -205,8 +205,8 @@ impl Clean<Lifetime> for hir::Lifetime {\n     }\n }\n \n-impl Clean<Constant> for hir::ConstArg {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Constant {\n+impl<'tcx> Clean<'tcx, Constant> for hir::ConstArg {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Constant {\n         Constant {\n             type_: cx\n                 .tcx\n@@ -217,7 +217,7 @@ impl Clean<Constant> for hir::ConstArg {\n     }\n }\n \n-impl Clean<Option<Lifetime>> for ty::Region<'_> {\n+impl<'tcx> Clean<'tcx, Option<Lifetime>> for ty::Region<'tcx> {\n     fn clean(&self, _cx: &mut DocContext<'_>) -> Option<Lifetime> {\n         match **self {\n             ty::ReStatic => Some(Lifetime::statik()),\n@@ -239,8 +239,8 @@ impl Clean<Option<Lifetime>> for ty::Region<'_> {\n     }\n }\n \n-impl Clean<Option<WherePredicate>> for hir::WherePredicate<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+impl<'tcx> Clean<'tcx, Option<WherePredicate>> for hir::WherePredicate<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n         if !self.in_where_clause() {\n             return None;\n         }\n@@ -279,8 +279,8 @@ impl Clean<Option<WherePredicate>> for hir::WherePredicate<'_> {\n     }\n }\n \n-impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+impl<'tcx> Clean<'tcx, Option<WherePredicate>> for ty::Predicate<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n         let bound_predicate = self.kind();\n         match bound_predicate.skip_binder() {\n             ty::PredicateKind::Trait(pred) => bound_predicate.rebind(pred).clean(cx),\n@@ -300,8 +300,8 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n     }\n }\n \n-impl<'a> Clean<Option<WherePredicate>> for ty::PolyTraitPredicate<'a> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+impl<'tcx> Clean<'tcx, Option<WherePredicate>> for ty::PolyTraitPredicate<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n         // `T: ~const Destruct` is hidden because `T: Destruct` is a no-op.\n         if self.skip_binder().constness == ty::BoundConstness::ConstIfConst\n             && Some(self.skip_binder().def_id()) == cx.tcx.lang_items().destruct_trait()\n@@ -318,10 +318,10 @@ impl<'a> Clean<Option<WherePredicate>> for ty::PolyTraitPredicate<'a> {\n     }\n }\n \n-impl<'tcx> Clean<Option<WherePredicate>>\n+impl<'tcx> Clean<'tcx, Option<WherePredicate>>\n     for ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(a, b) = self;\n \n         if a.is_empty() && b.is_empty() {\n@@ -335,8 +335,10 @@ impl<'tcx> Clean<Option<WherePredicate>>\n     }\n }\n \n-impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+impl<'tcx> Clean<'tcx, Option<WherePredicate>>\n+    for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>\n+{\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(ty, lt) = self;\n \n         if lt.is_empty() {\n@@ -351,17 +353,17 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n     }\n }\n \n-impl<'tcx> Clean<Term> for ty::Term<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Term {\n+impl<'tcx> Clean<'tcx, Term> for ty::Term<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Term {\n         match self {\n             ty::Term::Ty(ty) => Term::Type(ty.clean(cx)),\n             ty::Term::Const(c) => Term::Constant(c.clean(cx)),\n         }\n     }\n }\n \n-impl<'tcx> Clean<Term> for hir::Term<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Term {\n+impl<'tcx> Clean<'tcx, Term> for hir::Term<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Term {\n         match self {\n             hir::Term::Ty(ty) => Term::Type(ty.clean(cx)),\n             hir::Term::Const(c) => {\n@@ -372,16 +374,16 @@ impl<'tcx> Clean<Term> for hir::Term<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n+impl<'tcx> Clean<'tcx, WherePredicate> for ty::ProjectionPredicate<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> WherePredicate {\n         let ty::ProjectionPredicate { projection_ty, term } = self;\n         WherePredicate::EqPredicate { lhs: projection_ty.clean(cx), rhs: term.clean(cx) }\n     }\n }\n \n fn clean_projection<'tcx>(\n     ty: ty::ProjectionTy<'tcx>,\n-    cx: &mut DocContext<'_>,\n+    cx: &mut DocContext<'tcx>,\n     def_id: Option<DefId>,\n ) -> Type {\n     let lifted = ty.lift_to_tcx(cx.tcx).unwrap();\n@@ -401,8 +403,8 @@ fn clean_projection<'tcx>(\n     }\n }\n \n-impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+impl<'tcx> Clean<'tcx, Type> for ty::ProjectionTy<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n         clean_projection(*self, cx, None)\n     }\n }\n@@ -414,7 +416,10 @@ fn compute_should_show_cast(self_def_id: Option<DefId>, trait_: &Path, self_type\n             .map_or(!self_type.is_self_type(), |(id, trait_)| id != trait_)\n }\n \n-fn projection_to_path_segment(ty: ty::ProjectionTy<'_>, cx: &mut DocContext<'_>) -> PathSegment {\n+fn projection_to_path_segment<'tcx>(\n+    ty: ty::ProjectionTy<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> PathSegment {\n     let item = cx.tcx.associated_item(ty.item_def_id);\n     let generics = cx.tcx.generics_of(ty.item_def_id);\n     PathSegment {\n@@ -426,8 +431,8 @@ fn projection_to_path_segment(ty: ty::ProjectionTy<'_>, cx: &mut DocContext<'_>)\n     }\n }\n \n-impl Clean<GenericParamDef> for ty::GenericParamDef {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericParamDef {\n+impl<'tcx> Clean<'tcx, GenericParamDef> for ty::GenericParamDef {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             ty::GenericParamDefKind::Lifetime => {\n                 (self.name, GenericParamDefKind::Lifetime { outlives: vec![] })\n@@ -465,10 +470,10 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n     }\n }\n \n-fn clean_generic_param(\n-    cx: &mut DocContext<'_>,\n-    generics: Option<&hir::Generics<'_>>,\n-    param: &hir::GenericParam<'_>,\n+fn clean_generic_param<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    generics: Option<&hir::Generics<'tcx>>,\n+    param: &hir::GenericParam<'tcx>,\n ) -> GenericParamDef {\n     let (name, kind) = match param.kind {\n         hir::GenericParamKind::Lifetime { .. } => {\n@@ -536,8 +541,8 @@ fn clean_generic_param(\n     GenericParamDef { name, kind }\n }\n \n-impl Clean<Generics> for hir::Generics<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Generics {\n+impl<'tcx> Clean<'tcx, Generics> for hir::Generics<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Generics {\n         // Synthetic type-parameters are inserted after normal ones.\n         // In order for normal parameters to be able to refer to synthetic ones,\n         // scans them first.\n@@ -618,10 +623,10 @@ impl Clean<Generics> for hir::Generics<'_> {\n     }\n }\n \n-fn clean_ty_generics(\n-    cx: &mut DocContext<'_>,\n+fn clean_ty_generics<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n     gens: &ty::Generics,\n-    preds: ty::GenericPredicates<'_>,\n+    preds: ty::GenericPredicates<'tcx>,\n ) -> Generics {\n     // Don't populate `cx.impl_trait_bounds` before `clean`ning `where` clauses,\n     // since `Clean for ty::Predicate` would consume them.\n@@ -784,13 +789,13 @@ fn clean_ty_generics(\n     }\n }\n \n-fn clean_fn_or_proc_macro(\n-    item: &hir::Item<'_>,\n-    sig: &hir::FnSig<'_>,\n-    generics: &hir::Generics<'_>,\n+fn clean_fn_or_proc_macro<'tcx>(\n+    item: &hir::Item<'tcx>,\n+    sig: &hir::FnSig<'tcx>,\n+    generics: &hir::Generics<'tcx>,\n     body_id: hir::BodyId,\n     name: &mut Symbol,\n-    cx: &mut DocContext<'_>,\n+    cx: &mut DocContext<'tcx>,\n ) -> ItemKind {\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n     let macro_kind = attrs.iter().find_map(|a| {\n@@ -868,10 +873,10 @@ fn clean_fn_decl_legacy_const_generics(func: &mut Function, attrs: &[ast::Attrib\n     }\n }\n \n-fn clean_function(\n-    cx: &mut DocContext<'_>,\n-    sig: &hir::FnSig<'_>,\n-    generics: &hir::Generics<'_>,\n+fn clean_function<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    sig: &hir::FnSig<'tcx>,\n+    generics: &hir::Generics<'tcx>,\n     body_id: hir::BodyId,\n ) -> Function {\n     let (generics, decl) = enter_impl_trait(cx, |cx| {\n@@ -884,9 +889,9 @@ fn clean_function(\n     Function { decl, generics }\n }\n \n-fn clean_args_from_types_and_names(\n-    cx: &mut DocContext<'_>,\n-    types: &[hir::Ty<'_>],\n+fn clean_args_from_types_and_names<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    types: &[hir::Ty<'tcx>],\n     names: &[Ident],\n ) -> Arguments {\n     Arguments {\n@@ -904,9 +909,9 @@ fn clean_args_from_types_and_names(\n     }\n }\n \n-fn clean_args_from_types_and_body_id(\n-    cx: &mut DocContext<'_>,\n-    types: &[hir::Ty<'_>],\n+fn clean_args_from_types_and_body_id<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    types: &[hir::Ty<'tcx>],\n     body_id: hir::BodyId,\n ) -> Arguments {\n     let body = cx.tcx.hir().body(body_id);\n@@ -924,18 +929,18 @@ fn clean_args_from_types_and_body_id(\n     }\n }\n \n-fn clean_fn_decl_with_args(\n-    cx: &mut DocContext<'_>,\n-    decl: &hir::FnDecl<'_>,\n+fn clean_fn_decl_with_args<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    decl: &hir::FnDecl<'tcx>,\n     args: Arguments,\n ) -> FnDecl {\n     FnDecl { inputs: args, output: decl.output.clean(cx), c_variadic: decl.c_variadic }\n }\n \n-fn clean_fn_decl_from_did_and_sig(\n-    cx: &mut DocContext<'_>,\n+fn clean_fn_decl_from_did_and_sig<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n     did: Option<DefId>,\n-    sig: ty::PolyFnSig<'_>,\n+    sig: ty::PolyFnSig<'tcx>,\n ) -> FnDecl {\n     let mut names = did.map_or(&[] as &[_], |did| cx.tcx.fn_arg_names(did)).iter();\n \n@@ -964,34 +969,34 @@ fn clean_fn_decl_from_did_and_sig(\n     }\n }\n \n-impl Clean<FnRetTy> for hir::FnRetTy<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> FnRetTy {\n+impl<'tcx> Clean<'tcx, FnRetTy> for hir::FnRetTy<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> FnRetTy {\n         match *self {\n             Self::Return(ref typ) => Return(typ.clean(cx)),\n             Self::DefaultReturn(..) => DefaultReturn,\n         }\n     }\n }\n \n-impl Clean<bool> for hir::IsAuto {\n-    fn clean(&self, _: &mut DocContext<'_>) -> bool {\n+impl<'tcx> Clean<'tcx, bool> for hir::IsAuto {\n+    fn clean(&self, _: &mut DocContext<'tcx>) -> bool {\n         match *self {\n             hir::IsAuto::Yes => true,\n             hir::IsAuto::No => false,\n         }\n     }\n }\n \n-impl Clean<Path> for hir::TraitRef<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n+impl<'tcx> Clean<'tcx, Path> for hir::TraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Path {\n         let path = self.path.clean(cx);\n         register_res(cx, path.res);\n         path\n     }\n }\n \n-impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> PolyTrait {\n+impl<'tcx> Clean<'tcx, PolyTrait> for hir::PolyTraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n             generic_params: self\n@@ -1003,8 +1008,8 @@ impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n     }\n }\n \n-impl Clean<Item> for hir::TraitItem<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for hir::TraitItem<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let local_did = self.def_id.to_def_id();\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n@@ -1050,8 +1055,8 @@ impl Clean<Item> for hir::TraitItem<'_> {\n     }\n }\n \n-impl Clean<Item> for hir::ImplItem<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for hir::ImplItem<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let local_did = self.def_id.to_def_id();\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n@@ -1091,8 +1096,8 @@ impl Clean<Item> for hir::ImplItem<'_> {\n     }\n }\n \n-impl Clean<Item> for ty::AssocItem {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let tcx = cx.tcx;\n         let kind = match self.kind {\n             ty::AssocKind::Const => {\n@@ -1282,7 +1287,7 @@ impl Clean<Item> for ty::AssocItem {\n     }\n }\n \n-fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n+fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type {\n     let hir::Ty { hir_id: _, span, ref kind } = *hir_ty;\n     let hir::TyKind::Path(qpath) = kind else { unreachable!() };\n \n@@ -1352,7 +1357,10 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n     }\n }\n \n-fn maybe_expand_private_type_alias(cx: &mut DocContext<'_>, path: &hir::Path<'_>) -> Option<Type> {\n+fn maybe_expand_private_type_alias<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    path: &hir::Path<'tcx>,\n+) -> Option<Type> {\n     let Res::Def(DefKind::TyAlias, def_id) = path.res else { return None };\n     // Substitute private type aliases\n     let def_id = def_id.as_local()?;\n@@ -1435,8 +1443,8 @@ fn maybe_expand_private_type_alias(cx: &mut DocContext<'_>, path: &hir::Path<'_>\n     Some(cx.enter_alias(substs, |cx| ty.clean(cx)))\n }\n \n-impl Clean<Type> for hir::Ty<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+impl<'tcx> Clean<'tcx, Type> for hir::Ty<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n         use rustc_hir::*;\n \n         match self.kind {\n@@ -1530,7 +1538,7 @@ fn normalize<'tcx>(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n     }\n }\n \n-fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'_>, def_id: Option<DefId>) -> Type {\n+fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'tcx>, def_id: Option<DefId>) -> Type {\n     trace!(\"cleaning type: {:?}\", this);\n     let ty = normalize(cx, this).unwrap_or(this);\n     match *ty.kind() {\n@@ -1715,14 +1723,14 @@ fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'_>, def_id: Option<DefId>\n     }\n }\n \n-impl<'tcx> Clean<Type> for Ty<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+impl<'tcx> Clean<'tcx, Type> for Ty<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n         clean_ty(*self, cx, None)\n     }\n }\n \n-impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Constant {\n+impl<'tcx> Clean<'tcx, Constant> for ty::Const<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Constant {\n         // FIXME: instead of storing the stringified expression, store `self` directly instead.\n         Constant {\n             type_: self.ty().clean(cx),\n@@ -1731,15 +1739,15 @@ impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n     }\n }\n \n-impl Clean<Item> for hir::FieldDef<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for hir::FieldDef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let def_id = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n         clean_field(def_id, self.ident.name, self.ty.clean(cx), cx)\n     }\n }\n \n-impl Clean<Item> for ty::FieldDef {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for ty::FieldDef {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         clean_field(self.did, self.name, cx.tcx.type_of(self.did).clean(cx), cx)\n     }\n }\n@@ -1765,7 +1773,7 @@ fn is_field_vis_inherited(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     }\n }\n \n-impl Clean<Visibility> for ty::Visibility {\n+impl<'tcx> Clean<'tcx, Visibility> for ty::Visibility {\n     fn clean(&self, _cx: &mut DocContext<'_>) -> Visibility {\n         match *self {\n             ty::Visibility::Public => Visibility::Public,\n@@ -1779,23 +1787,23 @@ impl Clean<Visibility> for ty::Visibility {\n     }\n }\n \n-impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> VariantStruct {\n+impl<'tcx> Clean<'tcx, VariantStruct> for rustc_hir::VariantData<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> VariantStruct {\n         VariantStruct {\n             struct_type: CtorKind::from_hir(self),\n             fields: self.fields().iter().map(|x| x.clean(cx)).collect(),\n         }\n     }\n }\n \n-impl Clean<Vec<Item>> for hir::VariantData<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Vec<Item> {\n+impl<'tcx> Clean<'tcx, Vec<Item>> for hir::VariantData<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Vec<Item> {\n         self.fields().iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n-impl Clean<Item> for ty::VariantDef {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for ty::VariantDef {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let kind = match self.ctor_kind {\n             CtorKind::Const => Variant::CLike,\n             CtorKind::Fn => {\n@@ -1813,8 +1821,8 @@ impl Clean<Item> for ty::VariantDef {\n     }\n }\n \n-impl Clean<Variant> for hir::VariantData<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Variant {\n+impl<'tcx> Clean<'tcx, Variant> for hir::VariantData<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Variant {\n         match self {\n             hir::VariantData::Struct(..) => Variant::Struct(self.clean(cx)),\n             hir::VariantData::Tuple(..) => Variant::Tuple(self.clean(cx)),\n@@ -1823,14 +1831,14 @@ impl Clean<Variant> for hir::VariantData<'_> {\n     }\n }\n \n-impl Clean<Path> for hir::Path<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n+impl<'tcx> Clean<'tcx, Path> for hir::Path<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Path {\n         Path { res: self.res, segments: self.segments.iter().map(|x| x.clean(cx)).collect() }\n     }\n }\n \n-impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericArgs {\n+impl<'tcx> Clean<'tcx, GenericArgs> for hir::GenericArgs<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericArgs {\n         if self.parenthesized {\n             let output = self.bindings[0].ty().clean(cx);\n             let output =\n@@ -1858,14 +1866,14 @@ impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n     }\n }\n \n-impl Clean<PathSegment> for hir::PathSegment<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> PathSegment {\n+impl<'tcx> Clean<'tcx, PathSegment> for hir::PathSegment<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> PathSegment {\n         PathSegment { name: self.ident.name, args: self.args().clean(cx) }\n     }\n }\n \n-impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> BareFunctionDecl {\n+impl<'tcx> Clean<'tcx, BareFunctionDecl> for hir::BareFnTy<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, |cx| {\n             // NOTE: generics must be cleaned before args\n             let generic_params =\n@@ -1878,9 +1886,9 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     }\n }\n \n-fn clean_maybe_renamed_item(\n-    cx: &mut DocContext<'_>,\n-    item: &hir::Item<'_>,\n+fn clean_maybe_renamed_item<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    item: &hir::Item<'tcx>,\n     renamed: Option<Symbol>,\n ) -> Vec<Item> {\n     use hir::ItemKind;\n@@ -1961,8 +1969,8 @@ fn clean_maybe_renamed_item(\n     })\n }\n \n-impl Clean<Item> for hir::Variant<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for hir::Variant<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let kind = VariantItem(self.data.clean(cx));\n         let what_rustc_thinks =\n             Item::from_hir_id_and_parts(self.id, Some(self.ident.name), kind, cx);\n@@ -1971,7 +1979,11 @@ impl Clean<Item> for hir::Variant<'_> {\n     }\n }\n \n-fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &mut DocContext<'_>) -> Vec<Item> {\n+fn clean_impl<'tcx>(\n+    impl_: &hir::Impl<'tcx>,\n+    hir_id: hir::HirId,\n+    cx: &mut DocContext<'tcx>,\n+) -> Vec<Item> {\n     let tcx = cx.tcx;\n     let mut ret = Vec::new();\n     let trait_ = impl_.of_trait.as_ref().map(|t| t.clean(cx));\n@@ -2009,11 +2021,11 @@ fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &mut DocContext<'_>\n     ret\n }\n \n-fn clean_extern_crate(\n-    krate: &hir::Item<'_>,\n+fn clean_extern_crate<'tcx>(\n+    krate: &hir::Item<'tcx>,\n     name: Symbol,\n     orig_name: Option<Symbol>,\n-    cx: &mut DocContext<'_>,\n+    cx: &mut DocContext<'tcx>,\n ) -> Vec<Item> {\n     // this is the ID of the `extern crate` statement\n     let cnum = cx.tcx.extern_mod_stmt_cnum(krate.def_id).unwrap_or(LOCAL_CRATE);\n@@ -2059,12 +2071,12 @@ fn clean_extern_crate(\n     }]\n }\n \n-fn clean_use_statement(\n-    import: &hir::Item<'_>,\n+fn clean_use_statement<'tcx>(\n+    import: &hir::Item<'tcx>,\n     name: Symbol,\n-    path: &hir::Path<'_>,\n+    path: &hir::Path<'tcx>,\n     kind: hir::UseKind,\n-    cx: &mut DocContext<'_>,\n+    cx: &mut DocContext<'tcx>,\n ) -> Vec<Item> {\n     // We need this comparison because some imports (for std types for example)\n     // are \"inserted\" as well but directly by the compiler and they should not be\n@@ -2172,9 +2184,9 @@ fn clean_use_statement(\n     vec![Item::from_def_id_and_parts(import.def_id.to_def_id(), None, ImportItem(inner), cx)]\n }\n \n-fn clean_maybe_renamed_foreign_item(\n-    cx: &mut DocContext<'_>,\n-    item: &hir::ForeignItem<'_>,\n+fn clean_maybe_renamed_foreign_item<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    item: &hir::ForeignItem<'tcx>,\n     renamed: Option<Symbol>,\n ) -> Item {\n     let def_id = item.def_id.to_def_id();\n@@ -2205,17 +2217,17 @@ fn clean_maybe_renamed_foreign_item(\n     })\n }\n \n-impl Clean<TypeBinding> for hir::TypeBinding<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> TypeBinding {\n+impl<'tcx> Clean<'tcx, TypeBinding> for hir::TypeBinding<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> TypeBinding {\n         TypeBinding {\n             assoc: PathSegment { name: self.ident.name, args: self.gen_args.clean(cx) },\n             kind: self.kind.clean(cx),\n         }\n     }\n }\n \n-impl Clean<TypeBindingKind> for hir::TypeBindingKind<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> TypeBindingKind {\n+impl<'tcx> Clean<'tcx, TypeBindingKind> for hir::TypeBindingKind<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> TypeBindingKind {\n         match *self {\n             hir::TypeBindingKind::Equality { ref term } => {\n                 TypeBindingKind::Equality { term: term.clean(cx) }"}, {"sha": "a0014f721f46cb62765c95fd9533fd155327d7e0", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3569a426b5d561076c4dc43828efd05be82a07f2/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3569a426b5d561076c4dc43828efd05be82a07f2/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=3569a426b5d561076c4dc43828efd05be82a07f2", "patch": "@@ -75,9 +75,9 @@ pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n     Crate { module, primitives, external_traits: cx.external_traits.clone() }\n }\n \n-pub(crate) fn substs_to_args(\n-    cx: &mut DocContext<'_>,\n-    substs: &[ty::subst::GenericArg<'_>],\n+pub(crate) fn substs_to_args<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    substs: &[ty::subst::GenericArg<'tcx>],\n     mut skip_first: bool,\n ) -> Vec<GenericArg> {\n     let mut ret_val =\n@@ -99,12 +99,12 @@ pub(crate) fn substs_to_args(\n     ret_val\n }\n \n-fn external_generic_args(\n-    cx: &mut DocContext<'_>,\n+fn external_generic_args<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n     did: DefId,\n     has_self: bool,\n     bindings: Vec<TypeBinding>,\n-    substs: SubstsRef<'_>,\n+    substs: SubstsRef<'tcx>,\n ) -> GenericArgs {\n     let args = substs_to_args(cx, &substs, has_self);\n \n@@ -127,12 +127,12 @@ fn external_generic_args(\n     }\n }\n \n-pub(super) fn external_path(\n-    cx: &mut DocContext<'_>,\n+pub(super) fn external_path<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n     did: DefId,\n     has_self: bool,\n     bindings: Vec<TypeBinding>,\n-    substs: SubstsRef<'_>,\n+    substs: SubstsRef<'tcx>,\n ) -> Path {\n     let def_kind = cx.tcx.def_kind(did);\n     let name = cx.tcx.item_name(did);\n@@ -439,9 +439,9 @@ pub(crate) fn resolve_use_source(cx: &mut DocContext<'_>, path: Path) -> ImportS\n     }\n }\n \n-pub(crate) fn enter_impl_trait<F, R>(cx: &mut DocContext<'_>, f: F) -> R\n+pub(crate) fn enter_impl_trait<'tcx, F, R>(cx: &mut DocContext<'tcx>, f: F) -> R\n where\n-    F: FnOnce(&mut DocContext<'_>) -> R,\n+    F: FnOnce(&mut DocContext<'tcx>) -> R,\n {\n     let old_bounds = mem::take(&mut cx.impl_trait_bounds);\n     let r = f(cx);"}]}