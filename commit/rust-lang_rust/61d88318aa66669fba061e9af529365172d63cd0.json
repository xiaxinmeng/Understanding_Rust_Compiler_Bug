{"sha": "61d88318aa66669fba061e9af529365172d63cd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZDg4MzE4YWE2NjY2OWZiYTA2MWU5YWY1MjkzNjUxNzJkNjNjZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-09T17:46:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-09T17:46:36Z"}, "message": "Auto merge of #51068 - Crazycolorz5:pluseqsplitting, r=petrochenkov\n\nparser: Split `+=` into `+` and `=` where `+` is explicitly requested (such as generics)\n\nAdded functions in tokens to check whether a token leads with `+`. Used them when parsing to allow for token splitting of `+=` into `+` and `=`.\nFixes https://github.com/rust-lang/rust/issues/47856", "tree": {"sha": "e78ad015a222730438afdc7dd574a5e7d74d6fb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e78ad015a222730438afdc7dd574a5e7d74d6fb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61d88318aa66669fba061e9af529365172d63cd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61d88318aa66669fba061e9af529365172d63cd0", "html_url": "https://github.com/rust-lang/rust/commit/61d88318aa66669fba061e9af529365172d63cd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61d88318aa66669fba061e9af529365172d63cd0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b491a17b95fa984827882b826ef616391b7c5d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b491a17b95fa984827882b826ef616391b7c5d0", "html_url": "https://github.com/rust-lang/rust/commit/0b491a17b95fa984827882b826ef616391b7c5d0"}, {"sha": "759a0e07b58e8b231091854b4e7e2f0ee8a8eddc", "url": "https://api.github.com/repos/rust-lang/rust/commits/759a0e07b58e8b231091854b4e7e2f0ee8a8eddc", "html_url": "https://github.com/rust-lang/rust/commit/759a0e07b58e8b231091854b4e7e2f0ee8a8eddc"}], "stats": {"total": 81, "additions": 71, "deletions": 10}, "files": [{"sha": "53d0b5529efce0bd7c4a052b61768daf7407eacd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/61d88318aa66669fba061e9af529365172d63cd0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d88318aa66669fba061e9af529365172d63cd0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=61d88318aa66669fba061e9af529365172d63cd0", "patch": "@@ -881,6 +881,40 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Expect and consume a `+`. if `+=` is seen, replace it with a `=`\n+    /// and continue. If a `+` is not seen, return false.\n+    ///\n+    /// This is using when token splitting += into +.\n+    /// See issue 47856 for an example of when this may occur.\n+    fn eat_plus(&mut self) -> bool {\n+        self.expected_tokens.push(TokenType::Token(token::BinOp(token::Plus)));\n+        match self.token {\n+            token::BinOp(token::Plus) => {\n+                self.bump();\n+                true\n+            }\n+            token::BinOpEq(token::Plus) => {\n+                let span = self.span.with_lo(self.span.lo() + BytePos(1));\n+                self.bump_with(token::Eq, span);\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+\n+    /// Checks to see if the next token is either `+` or `+=`.\n+    /// Otherwise returns false.\n+    fn check_plus(&mut self) -> bool {\n+        if self.token.is_like_plus() {\n+            true\n+        }\n+        else {\n+            self.expected_tokens.push(TokenType::Token(token::BinOp(token::Plus)));\n+            false\n+        }\n+    }\n+\n     /// Expect and consume an `&`. If `&&` is seen, replace it with a single\n     /// `&` and continue. If an `&` is not seen, signal an error.\n     fn expect_and(&mut self) -> PResult<'a, ()> {\n@@ -1517,7 +1551,7 @@ impl<'a> Parser<'a> {\n \n             if ts.len() == 1 && !last_comma {\n                 let ty = ts.into_iter().nth(0).unwrap().into_inner();\n-                let maybe_bounds = allow_plus && self.token == token::BinOp(token::Plus);\n+                let maybe_bounds = allow_plus && self.token.is_like_plus();\n                 match ty.node {\n                     // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n                     TyKind::Path(None, ref path) if maybe_bounds => {\n@@ -1586,7 +1620,7 @@ impl<'a> Parser<'a> {\n                 self.parse_ty_bare_fn(lifetime_defs)?\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;\n-                let parse_plus = allow_plus && self.check(&token::BinOp(token::Plus));\n+                let parse_plus = allow_plus && self.check_plus();\n                 self.parse_remaining_bounds(lifetime_defs, path, lo, parse_plus)?\n             }\n         } else if self.eat_keyword(keywords::Impl) {\n@@ -1603,7 +1637,7 @@ impl<'a> Parser<'a> {\n             impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n             TyKind::TraitObject(bounds, TraitObjectSyntax::Dyn)\n         } else if self.check(&token::Question) ||\n-                  self.check_lifetime() && self.look_ahead(1, |t| t == &token::BinOp(token::Plus)) {\n+                  self.check_lifetime() && self.look_ahead(1, |t| t.is_like_plus()) {\n             // Bound list (trait object type)\n             TyKind::TraitObject(self.parse_ty_param_bounds_common(allow_plus)?,\n                                 TraitObjectSyntax::None)\n@@ -1623,7 +1657,7 @@ impl<'a> Parser<'a> {\n                 // Just a type path or bound list (trait object type) starting with a trait.\n                 //   `Type`\n                 //   `Trait1 + Trait2 + 'a`\n-                if allow_plus && self.check(&token::BinOp(token::Plus)) {\n+                if allow_plus && self.check_plus() {\n                     self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n                 } else {\n                     TyKind::Path(None, path)\n@@ -1650,7 +1684,7 @@ impl<'a> Parser<'a> {\n         let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_span));\n         let mut bounds = vec![TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None)];\n         if parse_plus {\n-            self.bump(); // `+`\n+            self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n             bounds.append(&mut self.parse_ty_param_bounds()?);\n         }\n         Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n@@ -1671,7 +1705,7 @@ impl<'a> Parser<'a> {\n \n     fn maybe_recover_from_bad_type_plus(&mut self, allow_plus: bool, ty: &Ty) -> PResult<'a, ()> {\n         // Do not add `+` to expected tokens.\n-        if !allow_plus || self.token != token::BinOp(token::Plus) {\n+        if !allow_plus || !self.token.is_like_plus() {\n             return Ok(())\n         }\n \n@@ -4872,7 +4906,7 @@ impl<'a> Parser<'a> {\n                 break\n             }\n \n-            if !allow_plus || !self.eat(&token::BinOp(token::Plus)) {\n+            if !allow_plus || !self.eat_plus() {\n                 break\n             }\n         }\n@@ -4891,7 +4925,7 @@ impl<'a> Parser<'a> {\n         while self.check_lifetime() {\n             lifetimes.push(self.expect_lifetime());\n \n-            if !self.eat(&token::BinOp(token::Plus)) {\n+            if !self.eat_plus() {\n                 break\n             }\n         }\n@@ -5037,7 +5071,7 @@ impl<'a> Parser<'a> {\n         let mut seen_type = false;\n         let mut seen_binding = false;\n         loop {\n-            if self.check_lifetime() && self.look_ahead(1, |t| t != &token::BinOp(token::Plus)) {\n+            if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n                 // Parse lifetime argument.\n                 lifetimes.push(self.expect_lifetime());\n                 if seen_type || seen_binding {\n@@ -5106,7 +5140,7 @@ impl<'a> Parser<'a> {\n \n         loop {\n             let lo = self.span;\n-            if self.check_lifetime() && self.look_ahead(1, |t| t != &token::BinOp(token::Plus)) {\n+            if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n                 let lifetime = self.expect_lifetime();\n                 // Bounds starting with a colon are mandatory, but possibly empty.\n                 self.expect(&token::Colon)?;"}, {"sha": "b4300feced4fae7af89825a02714dd557eb8037d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61d88318aa66669fba061e9af529365172d63cd0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d88318aa66669fba061e9af529365172d63cd0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=61d88318aa66669fba061e9af529365172d63cd0", "patch": "@@ -225,6 +225,13 @@ impl Token {\n         }\n     }\n \n+    pub fn is_like_plus(&self) -> bool {\n+        match *self {\n+            BinOp(Plus) | BinOpEq(Plus) => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// Returns `true` if the token can appear at the start of an expression.\n     pub fn can_begin_expr(&self) -> bool {\n         match *self {"}, {"sha": "cbb955fe61d03836b3fd0b1c5a6668a879154182", "filename": "src/test/parse-fail/trait-plusequal-splitting.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/61d88318aa66669fba061e9af529365172d63cd0/src%2Ftest%2Fparse-fail%2Ftrait-plusequal-splitting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d88318aa66669fba061e9af529365172d63cd0/src%2Ftest%2Fparse-fail%2Ftrait-plusequal-splitting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-plusequal-splitting.rs?ref=61d88318aa66669fba061e9af529365172d63cd0", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+// Fixes issue where `+` in generics weren't parsed if they were part of a `+=`.\n+\n+struct Whitespace<T: Clone + = ()> { t: T }\n+struct TokenSplit<T: Clone +=  ()> { t: T }\n+\n+fn main() {\n+}\n+\n+FAIL //~ ERROR"}]}