{"sha": "619d7c3f72a969c62789383af7d1a1446177adfc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxOWQ3YzNmNzJhOTY5YzYyNzg5MzgzYWY3ZDFhMTQ0NjE3N2FkZmM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-19T12:52:58Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-19T12:52:58Z"}, "message": "Associate names with types introduced by items\n\nIssue #828\n\nThis is not a full solution yet. To really get sane error messages,\nwe'll also have to guess the name to apply to literals, which seems\nnon-trivial.", "tree": {"sha": "d5ad85ec7a281b0943c6e31aa4bedff7cd8774bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5ad85ec7a281b0943c6e31aa4bedff7cd8774bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/619d7c3f72a969c62789383af7d1a1446177adfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/619d7c3f72a969c62789383af7d1a1446177adfc", "html_url": "https://github.com/rust-lang/rust/commit/619d7c3f72a969c62789383af7d1a1446177adfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/619d7c3f72a969c62789383af7d1a1446177adfc/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60acae4df725f2e275e01d7b59cc7ecacefb5f2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/60acae4df725f2e275e01d7b59cc7ecacefb5f2c", "html_url": "https://github.com/rust-lang/rust/commit/60acae4df725f2e275e01d7b59cc7ecacefb5f2c"}], "stats": {"total": 312, "additions": 128, "deletions": 184}, "files": [{"sha": "b1cbb7a752b7819b4f7f0757efc2f218e9285fac", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/619d7c3f72a969c62789383af7d1a1446177adfc/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619d7c3f72a969c62789383af7d1a1446177adfc/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=619d7c3f72a969c62789383af7d1a1446177adfc", "patch": "@@ -107,8 +107,12 @@ fn item_type(item: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n     }\n     let tp = ebml::get_doc(item, tag_items_data_item_type);\n     let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n-    ret parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n-                      def_parser, tcx);\n+    let t = parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n+                          def_parser, tcx);\n+    if family_names_type(item_family(item)) {\n+        t = ty::mk_named(tcx, t, @item_name(item));\n+    }\n+    t\n }\n \n fn item_ty_param_kinds(item: ebml::doc) -> [ast::kind] {\n@@ -307,6 +311,10 @@ fn family_has_type_params(fam_ch: u8) -> bool {\n         };\n }\n \n+fn family_names_type(fam_ch: u8) -> bool {\n+    alt fam_ch as char { 'y' | 't' { true } _ { false } }\n+}\n+\n fn read_path(d: ebml::doc) -> {path: str, pos: uint} {\n     let desc = ebml::doc_data(d);\n     let pos = ebml::be_uint_from_bytes(@desc, 0u, 4u);"}, {"sha": "4bfcc7fb95d9b7ae605d38b590788b46be15153b", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/619d7c3f72a969c62789383af7d1a1446177adfc/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619d7c3f72a969c62789383af7d1a1446177adfc/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=619d7c3f72a969c62789383af7d1a1446177adfc", "patch": "@@ -314,6 +314,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_family(ebml_w, 'y' as u8);\n         encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_name(ebml_w, item.ident);\n         ebml::end_tag(ebml_w);\n       }\n       item_tag(variants, tps) {\n@@ -322,6 +323,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_family(ebml_w, 't' as u8);\n         encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_name(ebml_w, item.ident);\n         for v: variant in variants {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n@@ -336,6 +338,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_family(ebml_w, 'y' as u8);\n         encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n+        encode_name(ebml_w, item.ident);\n         encode_symbol(ecx, ebml_w, item.id);\n         ebml::end_tag(ebml_w);\n \n@@ -356,6 +359,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_family(ebml_w, 'y' as u8);\n         encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n+        encode_name(ebml_w, item.ident);\n         ebml::end_tag(ebml_w);\n \n         index += [{val: ctor_id, pos: ebml_w.writer.tell()}];"}, {"sha": "90d560f1eb1a68ed290c4046674e715bc441a131", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/619d7c3f72a969c62789383af7d1a1446177adfc/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619d7c3f72a969c62789383af7d1a1446177adfc/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=619d7c3f72a969c62789383af7d1a1446177adfc", "patch": "@@ -1712,7 +1712,6 @@ fn find_impls_in_item(i: @ast::item, &impls: [@_impl],\n     }\n }\n \n-// FIXME[impl] we should probably cache this\n fn find_impls_in_mod(e: env, m: def, &impls: [@_impl],\n                      name: option::t<ident>) {\n     alt m {"}, {"sha": "b355c99a8bcddef7b45158427a300ecf0dab5ab6", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/619d7c3f72a969c62789383af7d1a1446177adfc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619d7c3f72a969c62789383af7d1a1446177adfc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=619d7c3f72a969c62789383af7d1a1446177adfc", "patch": "@@ -1037,12 +1037,10 @@ fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n \n type get_tydesc_result = {kind: tydesc_kind, result: result};\n \n-fn get_tydesc(cx: @block_ctxt, orig_t: ty::t, escapes: bool,\n+fn get_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n               storage: ty_param_storage, &static_ti: option::t<@tydesc_info>)\n    -> get_tydesc_result {\n \n-    let t = ty::strip_cname(bcx_tcx(cx), orig_t);\n-\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n     alt ty::type_param(bcx_tcx(cx), t) {\n       some(id) {\n@@ -1051,8 +1049,8 @@ fn get_tydesc(cx: @block_ctxt, orig_t: ty::t, escapes: bool,\n         } else {\n             bcx_tcx(cx).sess.span_bug(cx.sp,\n                                       \"Unbound typaram in get_tydesc: \" +\n-                                          \"orig_t = \" +\n-                                          ty_to_str(bcx_tcx(cx), orig_t) +\n+                                          \"t = \" +\n+                                          ty_to_str(bcx_tcx(cx), t) +\n                                           \" ty_param = \" +\n                                           uint::str(id));\n         }\n@@ -1071,11 +1069,8 @@ fn get_tydesc(cx: @block_ctxt, orig_t: ty::t, escapes: bool,\n     ret {kind: tk_static, result: rslt(cx, info.tydesc)};\n }\n \n-fn get_static_tydesc(cx: @block_ctxt, orig_t: ty::t, ty_params: [uint],\n+fn get_static_tydesc(cx: @block_ctxt, t: ty::t, ty_params: [uint],\n                      is_obj_body: bool) -> @tydesc_info {\n-    let t = ty::strip_cname(bcx_tcx(cx), orig_t);\n-\n-\n     alt bcx_ccx(cx).tydescs.find(t) {\n       some(info) { ret info; }\n       none. {"}, {"sha": "19a4dcdff0b52910e3f78672923a7d2660f39fa3", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 78, "deletions": 120, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/619d7c3f72a969c62789383af7d1a1446177adfc/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619d7c3f72a969c62789383af7d1a1446177adfc/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=619d7c3f72a969c62789383af7d1a1446177adfc", "patch": "@@ -90,19 +90,18 @@ export mk_uint;\n export mk_uniq;\n export mk_var;\n export mk_opaque_closure;\n+export mk_named;\n export gen_ty;\n export mode;\n export mt;\n export node_type_table;\n export pat_ty;\n-export cname;\n-export rename;\n export ret_ty_of_fn;\n export sequence_element_type;\n export struct;\n+export ty_name;\n export sort_methods;\n export stmt_node_id;\n-export strip_cname;\n export sty;\n export substitute_type_params;\n export t;\n@@ -142,6 +141,7 @@ export ty_send_type;\n export ty_uint;\n export ty_uniq;\n export ty_var;\n+export ty_named;\n export ty_var_id;\n export ty_param_substs_opt_and_ty_to_monotype;\n export ty_fn_args;\n@@ -222,13 +222,9 @@ tag cast_type {\n }\n \n type ctxt =\n-    //        constr_table fn_constrs,\n-    // We need the ext_map just for printing the types of tags defined in\n-    // other crates. Once we get cnames back it should go.\n     @{ts: @type_store,\n       sess: session::session,\n       def_map: resolve::def_map,\n-      ext_map: resolve::ext_map,\n       cast_map: hashmap<ast::node_id, cast_type>,\n       node_types: node_type_table,\n       items: ast_map::map,\n@@ -253,12 +249,10 @@ fn method_ty_to_fn_ty(cx: ctxt, m: method) -> t {\n \n \n // Never construct these manually. These are interned.\n-type raw_t =\n-    {struct: sty,\n-     cname: option::t<str>,\n-     hash: uint,\n-     has_params: bool,\n-     has_vars: bool};\n+type raw_t = {struct: sty,\n+              hash: uint,\n+              has_params: bool,\n+              has_vars: bool};\n \n type t = uint;\n \n@@ -298,6 +292,7 @@ tag sty {\n     ty_native(def_id);\n     ty_constr(t, [@type_constr]);\n     ty_opaque_closure; // type of a captured environment.\n+    ty_named(t, @str);\n }\n \n // In the middle end, constraints have a def_id attached, referring\n@@ -380,27 +375,27 @@ type node_type_table =\n     @smallintmap::smallintmap<ty::ty_param_substs_opt_and_ty>;\n \n fn populate_type_store(cx: ctxt) {\n-    intern(cx, ty_nil, none);\n-    intern(cx, ty_bool, none);\n-    intern(cx, ty_int(ast::ty_i), none);\n-    intern(cx, ty_float(ast::ty_f), none);\n-    intern(cx, ty_uint(ast::ty_u), none);\n-    intern(cx, ty_int(ast::ty_i8), none);\n-    intern(cx, ty_int(ast::ty_i16), none);\n-    intern(cx, ty_int(ast::ty_i32), none);\n-    intern(cx, ty_int(ast::ty_i64), none);\n-    intern(cx, ty_uint(ast::ty_u8), none);\n-    intern(cx, ty_uint(ast::ty_u16), none);\n-    intern(cx, ty_uint(ast::ty_u32), none);\n-    intern(cx, ty_uint(ast::ty_u64), none);\n-    intern(cx, ty_float(ast::ty_f32), none);\n-    intern(cx, ty_float(ast::ty_f64), none);\n-    intern(cx, ty_int(ast::ty_char), none);\n-    intern(cx, ty_str, none);\n-    intern(cx, ty_type, none);\n-    intern(cx, ty_send_type, none);\n-    intern(cx, ty_bot, none);\n-    intern(cx, ty_opaque_closure, none);\n+    intern(cx, ty_nil);\n+    intern(cx, ty_bool);\n+    intern(cx, ty_int(ast::ty_i));\n+    intern(cx, ty_float(ast::ty_f));\n+    intern(cx, ty_uint(ast::ty_u));\n+    intern(cx, ty_int(ast::ty_i8));\n+    intern(cx, ty_int(ast::ty_i16));\n+    intern(cx, ty_int(ast::ty_i32));\n+    intern(cx, ty_int(ast::ty_i64));\n+    intern(cx, ty_uint(ast::ty_u8));\n+    intern(cx, ty_uint(ast::ty_u16));\n+    intern(cx, ty_uint(ast::ty_u32));\n+    intern(cx, ty_uint(ast::ty_u64));\n+    intern(cx, ty_float(ast::ty_f32));\n+    intern(cx, ty_float(ast::ty_f64));\n+    intern(cx, ty_int(ast::ty_char));\n+    intern(cx, ty_str);\n+    intern(cx, ty_type);\n+    intern(cx, ty_send_type);\n+    intern(cx, ty_bot);\n+    intern(cx, ty_opaque_closure);\n     assert (vec::len(cx.ts.vect) == idx_first_others);\n }\n \n@@ -417,7 +412,7 @@ fn mk_rcache() -> creader_cache {\n \n \n fn mk_ctxt(s: session::session, dm: resolve::def_map,\n-           em: hashmap<def_id, [ident]>, amap: ast_map::map,\n+           _em: hashmap<def_id, [ident]>, amap: ast_map::map,\n            freevars: freevars::freevar_map) -> ctxt {\n     let ntt: node_type_table =\n         @smallintmap::mk::<ty::ty_param_substs_opt_and_ty>();\n@@ -427,7 +422,6 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map,\n         @{ts: ts,\n           sess: s,\n           def_map: dm,\n-          ext_map: em,\n           cast_map: ast_util::new_node_hash(),\n           node_types: ntt,\n           items: amap,\n@@ -446,9 +440,8 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map,\n \n \n // Type constructors\n-fn mk_raw_ty(cx: ctxt, st: sty, _in_cname: option::t<str>) -> @raw_t {\n-    let cname: option::t<str> = none;\n-    let h = hash_type_info(st, cname);\n+fn mk_raw_ty(cx: ctxt, st: sty) -> @raw_t {\n+    let h = hash_type_structure(st);\n     let has_params: bool = false;\n     let has_vars: bool = false;\n     fn derive_flags_t(cx: ctxt, &has_params: bool, &has_vars: bool, tt: t) {\n@@ -505,28 +498,26 @@ fn mk_raw_ty(cx: ctxt, st: sty, _in_cname: option::t<str>) -> @raw_t {\n         derive_flags_t(cx, has_params, has_vars, tt);\n         for tt: t in tps { derive_flags_t(cx, has_params, has_vars, tt); }\n       }\n-      ty_constr(tt, _) { derive_flags_t(cx, has_params, has_vars, tt); }\n+      ty_constr(tt, _) | ty_named(tt, _) {\n+        derive_flags_t(cx, has_params, has_vars, tt);\n+      }\n     }\n     ret @{struct: st,\n-          cname: cname,\n           hash: h,\n           has_params: has_params,\n           has_vars: has_vars};\n }\n \n-fn intern(cx: ctxt, st: sty, cname: option::t<str>) {\n-    interner::intern(*cx.ts, mk_raw_ty(cx, st, cname));\n+fn intern(cx: ctxt, st: sty) {\n+    interner::intern(*cx.ts, mk_raw_ty(cx, st));\n }\n \n-fn gen_ty_full(cx: ctxt, st: sty, cname: option::t<str>) -> t {\n-    let raw_type = mk_raw_ty(cx, st, cname);\n-    ret interner::intern(*cx.ts, raw_type);\n-}\n-\n-\n // These are private constructors to this module. External users should always\n // use the mk_foo() functions below.\n-fn gen_ty(cx: ctxt, st: sty) -> t { ret gen_ty_full(cx, st, none); }\n+fn gen_ty(cx: ctxt, st: sty) -> t {\n+    let raw_type = mk_raw_ty(cx, st);\n+    ret interner::intern(*cx.ts, raw_type);\n+}\n \n fn mk_nil(_cx: ctxt) -> t { ret idx_nil; }\n \n@@ -637,13 +628,23 @@ fn mk_opaque_closure(_cx: ctxt) -> t {\n     ret idx_opaque_closure;\n }\n \n-// Returns the one-level-deep type structure of the given type.\n-pure fn struct(cx: ctxt, typ: t) -> sty { interner::get(*cx.ts, typ).struct }\n+fn mk_named(cx: ctxt, base: t, name: @str) -> t {\n+    gen_ty(cx, ty_named(base, name))\n+}\n \n+// Returns the one-level-deep type structure of the given type.\n+pure fn struct(cx: ctxt, typ: t) -> sty {\n+    alt interner::get(*cx.ts, typ).struct {\n+      ty_named(t, _) { struct(cx, t) }\n+      s { s }\n+    }\n+}\n \n-// Returns the canonical name of the given type.\n-fn cname(cx: ctxt, typ: t) -> option::t<str> {\n-    ret interner::get(*cx.ts, typ).cname;\n+pure fn ty_name(cx: ctxt, typ: t) -> option::t<@str> {\n+    alt interner::get(*cx.ts, typ).struct {\n+      ty_named(_, n) { some(n) }\n+      _ { none }\n+    }\n }\n \n \n@@ -705,7 +706,7 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n       fm_param(_) { if !type_contains_params(cx, ty) { ret ty; } }\n       fm_general(_) {/* no fast path */ }\n     }\n-    alt struct(cx, ty) {\n+    alt interner::get(*cx.ts, ty).struct {\n       ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_str. | ty_send_type. | ty_type. | ty_native(_) | ty_opaque_closure. {\n         /* no-op */\n@@ -716,6 +717,9 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n       ty_uniq(tm) {\n         ty = mk_uniq(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n       }\n+      ty_named(t, nm) {\n+        ty = mk_named(cx, fold_ty(cx, fld, t), nm);\n+      }\n       ty_ptr(tm) {\n         ty = mk_ptr(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n       }\n@@ -725,7 +729,7 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n       ty_tag(tid, subtys) {\n         let new_subtys: [t] = [];\n         for subty: t in subtys { new_subtys += [fold_ty(cx, fld, subty)]; }\n-        ty = copy_cname(cx, mk_tag(cx, tid, new_subtys), ty);\n+        ty = mk_tag(cx, tid, new_subtys);\n       }\n       ty_rec(fields) {\n         let new_fields: [field] = [];\n@@ -734,30 +738,29 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n             let new_mt = {ty: new_ty, mut: fl.mt.mut};\n             new_fields += [{ident: fl.ident, mt: new_mt}];\n         }\n-        ty = copy_cname(cx, mk_rec(cx, new_fields), ty);\n+        ty = mk_rec(cx, new_fields);\n       }\n       ty_tup(ts) {\n         let new_ts = [];\n         for tt in ts { new_ts += [fold_ty(cx, fld, tt)]; }\n-        ty = copy_cname(cx, mk_tup(cx, new_ts), ty);\n+        ty = mk_tup(cx, new_ts);\n       }\n       ty_fn(proto, args, ret_ty, cf, constrs) {\n         let new_args: [arg] = [];\n         for a: arg in args {\n             let new_ty = fold_ty(cx, fld, a.ty);\n             new_args += [{mode: a.mode, ty: new_ty}];\n         }\n-        ty = copy_cname(cx, mk_fn(cx, proto, new_args,\n-                                  fold_ty(cx, fld, ret_ty), cf, constrs), ty);\n+        ty = mk_fn(cx, proto, new_args, fold_ty(cx, fld, ret_ty), cf,\n+                   constrs);\n       }\n       ty_native_fn(args, ret_ty) {\n         let new_args: [arg] = [];\n         for a: arg in args {\n             let new_ty = fold_ty(cx, fld, a.ty);\n             new_args += [{mode: a.mode, ty: new_ty}];\n         }\n-        ty = copy_cname(cx, mk_native_fn(cx, new_args,\n-                                         fold_ty(cx, fld, ret_ty)), ty);\n+        ty = mk_native_fn(cx, new_args, fold_ty(cx, fld, ret_ty));\n       }\n       ty_obj(methods) {\n         let new_methods: [method] = [];\n@@ -774,14 +777,12 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n                   cf: m.cf,\n                   constrs: m.constrs}];\n         }\n-        ty = copy_cname(cx, mk_obj(cx, new_methods), ty);\n+        ty = mk_obj(cx, new_methods);\n       }\n       ty_res(did, subty, tps) {\n         let new_tps = [];\n         for tp: t in tps { new_tps += [fold_ty(cx, fld, tp)]; }\n-        ty =\n-            copy_cname(cx, mk_res(cx, did, fold_ty(cx, fld, subty), new_tps),\n-                       ty);\n+        ty = mk_res(cx, did, fold_ty(cx, fld, subty), new_tps);\n       }\n       ty_var(id) {\n         alt fld { fm_var(folder) { ty = folder(id); } _ {/* no-op */ } }\n@@ -798,20 +799,6 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n \n // Type utilities\n \n-fn rename(cx: ctxt, typ: t, new_cname: str) -> t {\n-    ret gen_ty_full(cx, struct(cx, typ), some(new_cname));\n-}\n-\n-fn strip_cname(cx: ctxt, typ: t) -> t {\n-    ret gen_ty_full(cx, struct(cx, typ), none);\n-}\n-\n-// Returns a type with the structural part taken from `struct_ty` and the\n-// canonical name from `cname_ty`.\n-fn copy_cname(cx: ctxt, struct_ty: t, cname_ty: t) -> t {\n-    ret gen_ty_full(cx, struct(cx, struct_ty), cname(cx, cname_ty));\n-}\n-\n fn type_is_nil(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_nil. { ret true; } _ { ret false; } }\n }\n@@ -1367,25 +1354,17 @@ fn hash_type_structure(st: sty) -> uint {\n         ret hash_subtys(h, tps);\n       }\n       ty_constr(t, cs) {\n-        let h = 36u;\n+        let h = hash_subty(36u, t);\n         for c: @type_constr in cs { h += (h << 5u) + hash_type_constr(h, c); }\n         ret h;\n       }\n       ty_uniq(mt) { ret hash_subty(37u, mt.ty); }\n       ty_send_type. { ret 38u; }\n       ty_opaque_closure. { ret 39u; }\n+      ty_named(t, name) { (str::hash(*name) << 5u) + hash_subty(40u, t) }\n     }\n }\n \n-fn hash_type_info(st: sty, cname_opt: option::t<str>) -> uint {\n-    let h = hash_type_structure(st);\n-    alt cname_opt {\n-      none. {/* no-op */ }\n-      some(s) { h += (h << 5u) + str::hash(s); }\n-    }\n-    ret h;\n-}\n-\n fn hash_raw_ty(&&rt: @raw_t) -> uint { ret rt.hash; }\n \n fn hash_ty(&&typ: t) -> uint { ret typ; }\n@@ -1435,32 +1414,15 @@ fn constrs_eq(cs: [@constr], ds: [@constr]) -> bool {\n     ret true;\n }\n \n-// An expensive type equality function. This function is private to this\n-// module.\n+// This function is private to this module.\n fn eq_raw_ty(&&a: @raw_t, &&b: @raw_t) -> bool {\n-    // Check hashes (fast path).\n-\n-    if a.hash != b.hash { ret false; }\n-    // Check canonical names.\n-\n-    alt a.cname {\n-      none. { alt b.cname { none. {/* ok */ } _ { ret false; } } }\n-      some(s_a) {\n-        alt b.cname {\n-          some(s_b) { if !str::eq(s_a, s_b) { ret false; } }\n-          _ { ret false; }\n-        }\n-      }\n-    }\n-    // Check structures.\n-\n-    ret a.struct == b.struct;\n+    ret a.hash == b.hash && a.struct == b.struct;\n }\n \n \n // This is the equality function the public should use. It works as long as\n // the types are interned.\n-fn eq_ty(&&a: t, &&b: t) -> bool { ret a == b; }\n+fn eq_ty(&&a: t, &&b: t) -> bool { a == b }\n \n \n // Convert type to machine type\n@@ -1491,8 +1453,11 @@ fn ty_to_machine_ty(cx: ctxt, ty: t) -> t {\n //  machine independent primitive types by their machine type equivalents\n // for the current target architecture\n fn triv_eq_ty(cx: ctxt, &&a: t, &&b: t) -> bool {\n-    ret eq_ty(a, b)\n-        || eq_ty(ty_to_machine_ty(cx, a), ty_to_machine_ty(cx, b));\n+    let a = alt interner::get(*cx.ts, a).struct\n+        { ty_named(t, _) { t } _ { a } };\n+    let b = alt interner::get(*cx.ts, b).struct\n+        { ty_named(t, _) { t } _ { b } };\n+    a == b || ty_to_machine_ty(cx, a) == ty_to_machine_ty(cx, b)\n }\n \n // Type lookups\n@@ -1855,13 +1820,6 @@ mod unify {\n         ret ures_ok(typ);\n     }\n \n-    // Wraps the given type in an appropriate cname.\n-    //\n-    // TODO: This doesn't do anything yet. We should carry the cname up from\n-    // the expected and/or actual types when unification results in a type\n-    // identical to one or both of the two. The precise algorithm for this is\n-    // something we'll probably need to develop over time.\n-\n     // Simple structural type comparison.\n     fn struct_cmp(cx: @ctxt, expected: t, actual: t) -> result {\n         if struct(cx.tcx, expected) == struct(cx.tcx, actual) {"}, {"sha": "cacedb5dae06305936cea9ec5a30d1ba9a1a9bd4", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/619d7c3f72a969c62789383af7d1a1446177adfc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619d7c3f72a969c62789383af7d1a1446177adfc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=619d7c3f72a969c62789383af7d1a1446177adfc", "patch": "@@ -301,7 +301,6 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         ret typ;\n     }\n     let typ;\n-    let cname = none::<str>;\n     alt ast_ty.node {\n       ast::ty_nil. { typ = ty::mk_nil(tcx); }\n       ast::ty_bot. { typ = ty::mk_bot(tcx); }\n@@ -362,7 +361,6 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n             tcx.sess.span_fatal(ast_ty.span, \"internal error in instantiate\");\n           }\n         }\n-        cname = some(path_to_str(path));\n       }\n       ast::ty_obj(meths) {\n         let tmeths: [ty::method] = [];\n@@ -403,10 +401,6 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         }\n       }\n     }\n-    alt cname {\n-      none. {/* no-op */ }\n-      some(cname_str) { typ = ty::rename(tcx, typ, cname_str); }\n-    }\n     tcx.ast_ty_to_ty_cache.insert(ast_ty, some(typ));\n     ret typ;\n }\n@@ -436,25 +430,25 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         }\n         // Tell ast_ty_to_ty() that we want to perform a recursive\n         // call to resolve any named types.\n-\n-        let typ = ast_ty_to_ty(tcx, mode, t);\n+        let typ = ty::mk_named(tcx, ast_ty_to_ty(tcx, mode, t), @it.ident);\n         let tpt = {kinds: ty_param_kinds(tps), ty: typ};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n       ast::item_res(f, _, tps, _) {\n         let t_arg = ty_of_arg(tcx, mode, f.decl.inputs[0]);\n-        let t_res =\n-            {kinds: ty_param_kinds(tps),\n-             ty: ty::mk_res(tcx, local_def(it.id), t_arg.ty,\n-                            mk_ty_params(tcx, tps))};\n+        let t = ty::mk_named(tcx, ty::mk_res(tcx, local_def(it.id), t_arg.ty,\n+                                             mk_ty_params(tcx, tps)),\n+                             @it.ident);\n+        let t_res = {kinds: ty_param_kinds(tps), ty: t};\n         tcx.tcache.insert(local_def(it.id), t_res);\n         ret t_res;\n       }\n       ast::item_tag(_, tps) {\n         // Create a new generic polytype.\n         let subtys: [ty::t] = mk_ty_params(tcx, tps);\n-        let t = ty::mk_tag(tcx, local_def(it.id), subtys);\n+        let t = ty::mk_named(tcx, ty::mk_tag(tcx, local_def(it.id), subtys),\n+                             @it.ident);\n         let tpt = {kinds: ty_param_kinds(tps), ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n@@ -534,8 +528,8 @@ fn ty_of_method(tcx: ty::ctxt, mode: mode, m: @ast::method) -> ty::method {\n fn ty_of_obj(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n         ty_params: [ast::ty_param]) -> ty::ty_param_kinds_and_ty {\n     let methods = ty_of_obj_methods(tcx, mode, ob);\n-    let t_obj = ty::mk_obj(tcx, ty::sort_methods(methods));\n-    t_obj = ty::rename(tcx, t_obj, id);\n+    let t_obj = ty::mk_named(tcx, ty::mk_obj(tcx, ty::sort_methods(methods)),\n+                             @id);\n     ret {kinds: ty_param_kinds(ty_params), ty: t_obj};\n }\n fn ty_of_obj_methods(tcx: ty::ctxt, mode: mode, object: ast::_obj)\n@@ -655,19 +649,17 @@ fn ty_param_kinds(tps: [ast::ty_param]) -> [ast::kind] {\n mod collect {\n     type ctxt = {tcx: ty::ctxt};\n \n-    fn get_tag_variant_types(cx: @ctxt, tag_id: ast::def_id,\n+    fn get_tag_variant_types(cx: @ctxt, tag_ty: ty::t,\n                              variants: [ast::variant],\n                              ty_params: [ast::ty_param]) {\n         // Create a set of parameter types shared among all the variants.\n \n-        let ty_param_tys: [ty::t] = mk_ty_params(cx.tcx, ty_params);\n         for variant: ast::variant in variants {\n             // Nullary tag constructors get turned into constants; n-ary tag\n             // constructors get turned into functions.\n \n-            let result_ty;\n-            if vec::len::<ast::variant_arg>(variant.node.args) == 0u {\n-                result_ty = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n+            let result_ty = if vec::len(variant.node.args) == 0u {\n+                tag_ty\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n@@ -676,13 +668,11 @@ mod collect {\n                     let arg_ty = ast_ty_to_ty(cx.tcx, m_collect, va.ty);\n                     args += [{mode: ast::by_copy, ty: arg_ty}];\n                 }\n-                let tag_t = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n                 // FIXME: this will be different for constrained types\n-                result_ty =\n-                    ty::mk_fn(cx.tcx, ast::proto_shared(ast::sugar_normal),\n-                              args, tag_t,\n-                              ast::return_val, []);\n-            }\n+                ty::mk_fn(cx.tcx, ast::proto_shared(ast::sugar_normal),\n+                          args, tag_ty,\n+                          ast::return_val, [])\n+            };\n             let tpt = {kinds: ty_param_kinds(ty_params), ty: result_ty};\n             cx.tcx.tcache.insert(local_def(variant.node.id), tpt);\n             write::ty_only(cx.tcx, variant.node.id, result_ty);\n@@ -695,7 +685,7 @@ mod collect {\n           ast::item_tag(variants, ty_params) {\n             let tpt = ty_of_item(cx.tcx, m_collect, it);\n             write::ty_only(cx.tcx, it.id, tpt.ty);\n-            get_tag_variant_types(cx, local_def(it.id), variants, ty_params);\n+            get_tag_variant_types(cx, tpt.ty, variants, ty_params);\n           }\n           ast::item_impl(_, selfty, ms) {\n             for m in ms {"}, {"sha": "65ddfb40ddfbcd9f89c0f05f751731c2d7ca5702", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/619d7c3f72a969c62789383af7d1a1446177adfc/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619d7c3f72a969c62789383af7d1a1446177adfc/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=619d7c3f72a969c62789383af7d1a1446177adfc", "patch": "@@ -27,20 +27,6 @@ fn fn_ident_to_string(id: ast::node_id, i: ast::fn_ident) -> str {\n     ret alt i { none. { \"anon\" + int::str(id) } some(s) { s } };\n }\n \n-fn get_id_ident(cx: ctxt, id: ast::def_id) -> str {\n-    if id.crate != ast::local_crate {\n-        alt cx.ext_map.find(id) {\n-          some(j) { str::connect(j, \"::\") }\n-          none. { \"<#\" + int::str(id.crate) + \":\" + int::str(id.node) + \">\" }\n-        }\n-    } else {\n-        alt cx.items.find(id.node) {\n-          some(ast_map::node_item(it)) { it.ident }\n-          _ { fail \"get_id_ident: can't find item in ast_map\" }\n-        }\n-    }\n-}\n-\n fn ty_to_str(cx: ctxt, typ: t) -> str {\n     fn fn_input_to_str(cx: ctxt, input: {mode: middle::ty::mode, ty: t}) ->\n        str {\n@@ -83,7 +69,21 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         }\n         ret mstr + ty_to_str(cx, m.ty);\n     }\n-    alt cname(cx, typ) { some(cs) { ret cs; } _ { } }\n+    alt ty_name(cx, typ) {\n+      some(cs) {\n+        alt struct(cx, typ) {\n+          ty_tag(_, tps) | ty_res(_, _, tps) {\n+            if vec::len(tps) > 0u {\n+                let strs = vec::map(tps, {|t| ty_to_str(cx, t)});\n+                ret *cs + \"<\" + str::connect(strs, \",\") + \">\";\n+            }\n+          }\n+          _ {}\n+        }\n+        ret *cs;\n+      }\n+      _ { }\n+    }\n     ret alt struct(cx, typ) {\n       ty_native(_) { \"native\" }\n       ty_nil. { \"()\" }\n@@ -111,15 +111,6 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         for elem in elems { strs += [ty_to_str(cx, elem)]; }\n         \"(\" + str::connect(strs, \",\") + \")\"\n       }\n-      ty_tag(id, tps) {\n-        let s = get_id_ident(cx, id);\n-        if vec::len::<t>(tps) > 0u {\n-            let strs: [str] = [];\n-            for typ: t in tps { strs += [ty_to_str(cx, typ)]; }\n-            s += \"<\" + str::connect(strs, \",\") + \">\";\n-        }\n-        s\n-      }\n       ty_fn(proto, inputs, output, cf, constrs) {\n         fn_to_str(cx, proto, none, inputs, output, cf, constrs)\n       }\n@@ -132,7 +123,6 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         for m: method in meths { strs += [method_to_str(cx, m)]; }\n         \"obj {\\n\\t\" + str::connect(strs, \"\\n\\t\") + \"\\n}\"\n       }\n-      ty_res(id, _, _) { get_id_ident(cx, id) }\n       ty_var(v) { \"<T\" + int::str(v) + \">\" }\n       ty_param(id, _) {\n         \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)])"}]}