{"sha": "cadd9bb954edf23dcfb7002f9174b61228de5010", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZGQ5YmI5NTRlZGYyM2RjZmI3MDAyZjkxNzRiNjEyMjhkZTUwMTA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-11T19:06:21Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-11T19:06:21Z"}, "message": "Merge pull request #128 from birkenfeld/whitespace-cleanup\n\nall: whitespace cleanup", "tree": {"sha": "bacc7f009a23638ebfb05a773fc8a2a6083fccd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bacc7f009a23638ebfb05a773fc8a2a6083fccd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cadd9bb954edf23dcfb7002f9174b61228de5010", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cadd9bb954edf23dcfb7002f9174b61228de5010", "html_url": "https://github.com/rust-lang/rust/commit/cadd9bb954edf23dcfb7002f9174b61228de5010", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cadd9bb954edf23dcfb7002f9174b61228de5010/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5060e9e685e97106ee2e98547afc989db8ae7c91", "url": "https://api.github.com/repos/rust-lang/rust/commits/5060e9e685e97106ee2e98547afc989db8ae7c91", "html_url": "https://github.com/rust-lang/rust/commit/5060e9e685e97106ee2e98547afc989db8ae7c91"}, {"sha": "e318328d63e122b5b3e516a0592367eaa2b6ea93", "url": "https://api.github.com/repos/rust-lang/rust/commits/e318328d63e122b5b3e516a0592367eaa2b6ea93", "html_url": "https://github.com/rust-lang/rust/commit/e318328d63e122b5b3e516a0592367eaa2b6ea93"}], "stats": {"total": 1724, "additions": 862, "deletions": 862}, "files": [{"sha": "62367b8a26e10cc628b604696d9a84d97e1f974b", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -87,7 +87,7 @@ You can add options  to `allow`/`warn`/`deny`:\n \n *`deny` produces error instead of warnings*\n \n-To have cargo compile your crate with clippy without needing `#![plugin(clippy)]` \n+To have cargo compile your crate with clippy without needing `#![plugin(clippy)]`\n in your code, you can use:\n \n ```"}, {"sha": "3ae579a74b9fdc264fa4a3e4762dfd1d8741788e", "filename": "src/approx_const.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -15,12 +15,12 @@ declare_lint! {\n     \"Warn if a user writes an approximate known constant in their code\"\n }\n \n-const KNOWN_CONSTS : &'static [(f64, &'static str)] = &[(f64::E, \"E\"), (f64::FRAC_1_PI, \"FRAC_1_PI\"), \n-\t(f64::FRAC_1_SQRT_2, \"FRAC_1_SQRT_2\"), (f64::FRAC_2_PI, \"FRAC_2_PI\"), \n-\t(f64::FRAC_2_SQRT_PI, \"FRAC_2_SQRT_PI\"), (f64::FRAC_PI_2, \"FRAC_PI_2\"), (f64::FRAC_PI_3, \"FRAC_PI_3\"),\n-\t(f64::FRAC_PI_4, \"FRAC_PI_4\"), (f64::FRAC_PI_6, \"FRAC_PI_6\"), (f64::FRAC_PI_8, \"FRAC_PI_8\"), \n-\t(f64::LN_10, \"LN_10\"), (f64::LN_2, \"LN_2\"), (f64::LOG10_E, \"LOG10_E\"), (f64::LOG2_E, \"LOG2_E\"),\n-\t(f64::PI, \"PI\"), (f64::SQRT_2, \"SQRT_2\")];\n+const KNOWN_CONSTS : &'static [(f64, &'static str)] = &[(f64::E, \"E\"), (f64::FRAC_1_PI, \"FRAC_1_PI\"),\n+    (f64::FRAC_1_SQRT_2, \"FRAC_1_SQRT_2\"), (f64::FRAC_2_PI, \"FRAC_2_PI\"),\n+    (f64::FRAC_2_SQRT_PI, \"FRAC_2_SQRT_PI\"), (f64::FRAC_PI_2, \"FRAC_PI_2\"), (f64::FRAC_PI_3, \"FRAC_PI_3\"),\n+    (f64::FRAC_PI_4, \"FRAC_PI_4\"), (f64::FRAC_PI_6, \"FRAC_PI_6\"), (f64::FRAC_PI_8, \"FRAC_PI_8\"),\n+    (f64::LN_10, \"LN_10\"), (f64::LN_2, \"LN_2\"), (f64::LOG10_E, \"LOG10_E\"), (f64::LOG2_E, \"LOG2_E\"),\n+    (f64::PI, \"PI\"), (f64::SQRT_2, \"SQRT_2\")];\n \n const EPSILON_DIVISOR : f64 = 8192f64; //TODO: test to find a good value\n \n@@ -31,34 +31,34 @@ impl LintPass for ApproxConstant {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(APPROX_CONSTANT)\n     }\n-    \n+\n     fn check_expr(&mut self, cx: &Context, e: &Expr) {\n-\t\tif let &ExprLit(ref lit) = &e.node {\n-\t\t\tcheck_lit(cx, lit, e.span);\n-\t\t}\n+        if let &ExprLit(ref lit) = &e.node {\n+            check_lit(cx, lit, e.span);\n+        }\n     }\n }\n \n fn check_lit(cx: &Context, lit: &Lit, span: Span) {\n-\tmatch &lit.node {\n-\t\t&LitFloat(ref str, TyF32) => check_known_consts(cx, span, str, \"f32\"),\n-\t\t&LitFloat(ref str, TyF64) => check_known_consts(cx, span, str, \"f64\"),\n-\t\t&LitFloatUnsuffixed(ref str) => check_known_consts(cx, span, str, \"f{32, 64}\"),\n-\t\t_ => ()\n-\t}\n+    match &lit.node {\n+        &LitFloat(ref str, TyF32) => check_known_consts(cx, span, str, \"f32\"),\n+        &LitFloat(ref str, TyF64) => check_known_consts(cx, span, str, \"f64\"),\n+        &LitFloatUnsuffixed(ref str) => check_known_consts(cx, span, str, \"f{32, 64}\"),\n+        _ => ()\n+    }\n }\n \n fn check_known_consts(cx: &Context, span: Span, str: &str, module: &str) {\n-\tif let Ok(value) = str.parse::<f64>() {\n-\t\tfor &(constant, name) in KNOWN_CONSTS {\n-\t\t\tif within_epsilon(constant, value) {\n-\t\t\t\tspan_lint(cx, APPROX_CONSTANT, span, &format!(\n-\t\t\t\t\t\"Approximate value of {}::{} found, consider using it directly.\", module, &name));\n-\t\t\t}\n-\t\t}\n-\t}\n+    if let Ok(value) = str.parse::<f64>() {\n+        for &(constant, name) in KNOWN_CONSTS {\n+            if within_epsilon(constant, value) {\n+                span_lint(cx, APPROX_CONSTANT, span, &format!(\n+                    \"Approximate value of {}::{} found, consider using it directly.\", module, &name));\n+            }\n+        }\n+    }\n }\n \n fn within_epsilon(target: f64, value: f64) -> bool {\n-\tf64::abs(value - target) < f64::abs((if target > value { target } else { value })) / EPSILON_DIVISOR\n+    f64::abs(value - target) < f64::abs((if target > value { target } else { value })) / EPSILON_DIVISOR\n }"}, {"sha": "6d73f1de9649408f7c09dc92b1ad2ad98a58d500", "filename": "src/attrs.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -19,92 +19,92 @@ impl LintPass for AttrPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(INLINE_ALWAYS)\n     }\n-    \n+\n     fn check_item(&mut self, cx: &Context, item: &Item) {\n-\t\tif is_relevant_item(item) {\n-\t\t\tcx.sess().codemap().with_expn_info(item.span.expn_id, \n-\t\t\t\t|info| check_attrs(cx, info, &item.ident, &item.attrs))\n-\t\t}\n-\t}\n-    \n+        if is_relevant_item(item) {\n+            cx.sess().codemap().with_expn_info(item.span.expn_id,\n+                |info| check_attrs(cx, info, &item.ident, &item.attrs))\n+        }\n+    }\n+\n     fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n-\t\tif is_relevant_impl(item) {\n-\t\t\tcx.sess().codemap().with_expn_info(item.span.expn_id, \n-\t\t\t\t|info| check_attrs(cx, info, &item.ident, &item.attrs))\n-\t\t}\n-\t}\n-        \n-\tfn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n-\t\tif is_relevant_trait(item) {\n-\t\t\tcx.sess().codemap().with_expn_info(item.span.expn_id, \n-\t\t\t\t|info| check_attrs(cx, info, &item.ident, &item.attrs))\n-\t\t}\n-\t}\n+        if is_relevant_impl(item) {\n+            cx.sess().codemap().with_expn_info(item.span.expn_id,\n+                |info| check_attrs(cx, info, &item.ident, &item.attrs))\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n+        if is_relevant_trait(item) {\n+            cx.sess().codemap().with_expn_info(item.span.expn_id,\n+                |info| check_attrs(cx, info, &item.ident, &item.attrs))\n+        }\n+    }\n }\n \n fn is_relevant_item(item: &Item) -> bool {\n-\tif let &ItemFn(_, _, _, _, _, ref block) = &item.node {\n-\t\tis_relevant_block(block)\n-\t} else { false }\n+    if let &ItemFn(_, _, _, _, _, ref block) = &item.node {\n+        is_relevant_block(block)\n+    } else { false }\n }\n \n fn is_relevant_impl(item: &ImplItem) -> bool {\n-\tmatch item.node {\n-\t\tMethodImplItem(_, ref block) => is_relevant_block(block),\n-\t\t_ => false\n-\t}\n+    match item.node {\n+        MethodImplItem(_, ref block) => is_relevant_block(block),\n+        _ => false\n+    }\n }\n \n fn is_relevant_trait(item: &TraitItem) -> bool {\n-\tmatch item.node {\n-\t\tMethodTraitItem(_, None) => true,\n-\t\tMethodTraitItem(_, Some(ref block)) => is_relevant_block(block),\n-\t\t_ => false\n-\t}\n+    match item.node {\n+        MethodTraitItem(_, None) => true,\n+        MethodTraitItem(_, Some(ref block)) => is_relevant_block(block),\n+        _ => false\n+    }\n }\n \n fn is_relevant_block(block: &Block) -> bool {\n-\tfor stmt in block.stmts.iter() { \n-\t\tmatch stmt.node {\n-\t\t\tStmtDecl(_, _) => return true,\n-\t\t\tStmtExpr(ref expr, _) | StmtSemi(ref expr, _) => {\n-\t\t\t\treturn is_relevant_expr(expr);\n-\t\t\t}\n-\t\t\t_ => ()\n-\t\t}\n-\t}\n-\tblock.expr.as_ref().map_or(false, |e| is_relevant_expr(&*e))\n+    for stmt in block.stmts.iter() {\n+        match stmt.node {\n+            StmtDecl(_, _) => return true,\n+            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => {\n+                return is_relevant_expr(expr);\n+            }\n+            _ => ()\n+        }\n+    }\n+    block.expr.as_ref().map_or(false, |e| is_relevant_expr(&*e))\n }\n \n fn is_relevant_expr(expr: &Expr) -> bool {\n-\tmatch expr.node {\n-\t\tExprBlock(ref block) => is_relevant_block(block),\n-\t\tExprRet(Some(ref e)) | ExprParen(ref e) => \n-\t\t\tis_relevant_expr(&*e),\n-\t\tExprRet(None) | ExprBreak(_) | ExprMac(_) => false,\n-\t\tExprCall(ref path_expr, _) => {\n-\t\t\tif let ExprPath(_, ref path) = path_expr.node {\n-\t\t\t\t!match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n-\t\t\t} else { true }\n-\t\t}\n-\t\t_ => true\n-\t}\n+    match expr.node {\n+        ExprBlock(ref block) => is_relevant_block(block),\n+        ExprRet(Some(ref e)) | ExprParen(ref e) =>\n+            is_relevant_expr(&*e),\n+        ExprRet(None) | ExprBreak(_) | ExprMac(_) => false,\n+        ExprCall(ref path_expr, _) => {\n+            if let ExprPath(_, ref path) = path_expr.node {\n+                !match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n+            } else { true }\n+        }\n+        _ => true\n+    }\n }\n \n-fn check_attrs(cx: &Context, info: Option<&ExpnInfo>, ident: &Ident, \n-\t\tattrs: &[Attribute]) {\n-\tif in_macro(cx, info) { return; }\n-\t\t\t\n-\tfor attr in attrs {\n-\t\tif let MetaList(ref inline, ref values) = attr.node.value.node {\n-\t\t\tif values.len() != 1 || inline != &\"inline\" { continue; }\n-\t\t\tif let MetaWord(ref always) = values[0].node {\n-\t\t\t\tif always != &\"always\" { continue; }\n-\t\t\t\tspan_lint(cx, INLINE_ALWAYS, attr.span, &format!(\n-\t\t\t\t\t\"You have declared #[inline(always)] on {}. This \\\n-\t\t\t\t\tis usually a bad idea. Are you sure?\", \n-\t\t\t\t\tident.name.as_str()));\n-\t\t\t}\n-\t\t}\n-\t}\n+fn check_attrs(cx: &Context, info: Option<&ExpnInfo>, ident: &Ident,\n+               attrs: &[Attribute]) {\n+    if in_macro(cx, info) { return; }\n+\n+    for attr in attrs {\n+        if let MetaList(ref inline, ref values) = attr.node.value.node {\n+            if values.len() != 1 || inline != &\"inline\" { continue; }\n+            if let MetaWord(ref always) = values[0].node {\n+                if always != &\"always\" { continue; }\n+                span_lint(cx, INLINE_ALWAYS, attr.span, &format!(\n+                    \"You have declared #[inline(always)] on {}. This \\\n+                     is usually a bad idea. Are you sure?\",\n+                    ident.name.as_str()));\n+            }\n+        }\n+    }\n }"}, {"sha": "ad6facfb199e9dbb76720ce97310c57df3a465dd", "filename": "src/bit_mask.rs", "status": "modified", "additions": 130, "deletions": 130, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -12,23 +12,23 @@ declare_lint! {\n     pub BAD_BIT_MASK,\n     Deny,\n     \"Deny the use of incompatible bit masks in comparisons, e.g. \\\n-    '(a & 1) == 2'\"\n+     '(a & 1) == 2'\"\n }\n \n declare_lint! {\n-\tpub INEFFECTIVE_BIT_MASK,\n-\tWarn,\n-\t\"Warn on the use of an ineffective bit mask in comparisons, e.g. \\\n-\t'(a & 1) > 2'\"\n+    pub INEFFECTIVE_BIT_MASK,\n+    Warn,\n+    \"Warn on the use of an ineffective bit mask in comparisons, e.g. \\\n+     '(a & 1) > 2'\"\n }\n \n-/// Checks for incompatible bit masks in comparisons, e.g. `x & 1 == 2`. \n+/// Checks for incompatible bit masks in comparisons, e.g. `x & 1 == 2`.\n /// This cannot work because the bit that makes up the value two was\n /// zeroed out by the bit-and with 1. So the formula for detecting if an\n-/// expression of the type  `_ <bit_op> m <cmp_op> c` (where `<bit_op>` \n-/// is one of {`&`, '|'} and `<cmp_op>` is one of {`!=`, `>=`, `>` , \n+/// expression of the type  `_ <bit_op> m <cmp_op> c` (where `<bit_op>`\n+/// is one of {`&`, '|'} and `<cmp_op>` is one of {`!=`, `>=`, `>` ,\n /// `!=`, `>=`, `>`}) can be determined from the following table:\n-/// \n+///\n /// |Comparison  |Bit-Op|Example     |is always|Formula               |\n /// |------------|------|------------|---------|----------------------|\n /// |`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n@@ -37,7 +37,7 @@ declare_lint! {\n /// |`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n /// |`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n /// |`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n-/// \n+///\n /// This lint is **deny** by default\n ///\n /// There is also a lint that warns on ineffective masks that is *warn*\n@@ -49,140 +49,140 @@ impl LintPass for BitMask {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(BAD_BIT_MASK, INEFFECTIVE_BIT_MASK)\n     }\n-    \n+\n     fn check_expr(&mut self, cx: &Context, e: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n-\t\t\tif is_comparison_binop(cmp.node) {\n-\t\t\t\tfetch_int_literal(cx, right).map_or_else(|| \n-\t\t\t\t\tfetch_int_literal(cx, left).map_or((), |cmp_val| \n-\t\t\t\t\t\tcheck_compare(cx, right, invert_cmp(cmp.node), \n-\t\t\t\t\t\t\tcmp_val, &e.span)), \n-\t\t\t\t\t|cmp_opt| check_compare(cx, left, cmp.node, cmp_opt,\n-\t\t\t\t\t\t&e.span))\n-\t\t\t}\n-\t\t}\n+            if is_comparison_binop(cmp.node) {\n+                fetch_int_literal(cx, right).map_or_else(||\n+                    fetch_int_literal(cx, left).map_or((), |cmp_val|\n+                        check_compare(cx, right, invert_cmp(cmp.node),\n+                                      cmp_val, &e.span)),\n+                    |cmp_opt| check_compare(cx, left, cmp.node, cmp_opt,\n+                                            &e.span))\n+            }\n+        }\n     }\n }\n \n fn invert_cmp(cmp : BinOp_) -> BinOp_ {\n-\tmatch cmp {\n-\t\tBiEq => BiEq,\n-\t\tBiNe => BiNe,\n-\t\tBiLt => BiGt,\n-\t\tBiGt => BiLt,\n-\t\tBiLe => BiGe,\n-\t\tBiGe => BiLe,\n-\t\t_ => BiOr // Dummy\n-\t}\n+    match cmp {\n+        BiEq => BiEq,\n+        BiNe => BiNe,\n+        BiLt => BiGt,\n+        BiGt => BiLt,\n+        BiLe => BiGe,\n+        BiGe => BiLe,\n+        _ => BiOr // Dummy\n+    }\n }\n \n \n fn check_compare(cx: &Context, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u64, span: &Span) {\n-\tmatch &bit_op.node {\n-\t\t&ExprParen(ref subexp) => check_compare(cx, subexp, cmp_op, cmp_value, span),\n-\t\t&ExprBinary(ref op, ref left, ref right) => {\n-\t\t\tif op.node != BiBitAnd && op.node != BiBitOr { return; }\n-\t\t\tfetch_int_literal(cx, right).or_else(|| fetch_int_literal(\n-\t\t\t\tcx, left)).map_or((), |mask| check_bit_mask(cx, op.node, \n-\t\t\t\t\tcmp_op, mask, cmp_value, span))\n-\t\t},\n-\t\t_ => ()\n-\t}\n+    match &bit_op.node {\n+        &ExprParen(ref subexp) => check_compare(cx, subexp, cmp_op, cmp_value, span),\n+        &ExprBinary(ref op, ref left, ref right) => {\n+            if op.node != BiBitAnd && op.node != BiBitOr { return; }\n+            fetch_int_literal(cx, right).or_else(|| fetch_int_literal(\n+                cx, left)).map_or((), |mask| check_bit_mask(cx, op.node,\n+                                                            cmp_op, mask, cmp_value, span))\n+        },\n+        _ => ()\n+    }\n }\n \n-fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_, \n-\t\tmask_value: u64, cmp_value: u64, span: &Span) {\n-\tmatch cmp_op {\n-\t\tBiEq | BiNe => match bit_op {\n-\t\t\tBiBitAnd => if mask_value & cmp_value != mask_value {\n-\t\t\t\tif cmp_value != 0 {\n-\t\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, &format!(\n-\t\t\t\t\t\t\"incompatible bit mask: _ & {} can never be equal to {}\", \n-\t\t\t\t\t\tmask_value, cmp_value));\n-\t\t\t\t}\n-\t\t\t} else { \n-\t\t\t\tif mask_value == 0 {\n-\t\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, \n-\t\t\t\t\t\t&format!(\"&-masking with zero\"));\n-\t\t\t\t}\n-\t\t\t},\n-\t\t\tBiBitOr => if mask_value | cmp_value != cmp_value {\n-\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, &format!(\n-\t\t\t\t\t\"incompatible bit mask: _ | {} can never be equal to {}\", \n-\t\t\t\t\tmask_value, cmp_value));\n-\t\t\t},\n-\t\t\t_ => ()\n-\t\t},\n-\t\tBiLt | BiGe => match bit_op {\n-\t\t\tBiBitAnd => if mask_value < cmp_value {\n-\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, &format!(\n-\t\t\t\t\t\"incompatible bit mask: _ & {} will always be lower than {}\", \n-\t\t\t\t\tmask_value, cmp_value));\n-\t\t\t} else { \n-\t\t\t\tif mask_value == 0 {\n-\t\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, \n-\t\t\t\t\t\t&format!(\"&-masking with zero\"));\n-\t\t\t\t}\n-\t\t\t},\n-\t\t\tBiBitOr => if mask_value >= cmp_value {\n-\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, &format!(\n-\t\t\t\t\t\"incompatible bit mask: _ | {} will never be lower than {}\", \n-\t\t\t\t\tmask_value, cmp_value));\n-\t\t\t} else {\n-\t\t\t\tif mask_value < cmp_value {\n-\t\t\t\t\tspan_lint(cx, INEFFECTIVE_BIT_MASK, *span, &format!(\n-\t\t\t\t\t\t\"ineffective bit mask: x | {} compared to {} is the same as x compared directly\", \n-\t\t\t\t\t\tmask_value, cmp_value)); \n-\t\t\t\t}\n-\t\t\t},\n-\t\t\t_ => ()\n-\t\t},\n-\t\tBiLe | BiGt => match bit_op {\n-\t\t\tBiBitAnd => if mask_value <= cmp_value {\n-\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, &format!(\n-\t\t\t\t\t\"incompatible bit mask: _ & {} will never be higher than {}\", \n-\t\t\t\t\tmask_value, cmp_value));\n-\t\t\t} else { \n-\t\t\t\tif mask_value == 0 {\n-\t\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, \n-\t\t\t\t\t\t&format!(\"&-masking with zero\"));\n-\t\t\t\t}\n-\t\t\t},\n-\t\t\tBiBitOr => if mask_value > cmp_value {\n-\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, &format!(\n-\t\t\t\t\t\"incompatible bit mask: _ | {} will always be higher than {}\", \n-\t\t\t\t\tmask_value, cmp_value));\t\t\t\t\n-\t\t\t} else {\n-\t\t\t\tif mask_value < cmp_value {\n-\t\t\t\t\tspan_lint(cx, INEFFECTIVE_BIT_MASK, *span, &format!(\n-\t\t\t\t\t\t\"ineffective bit mask: x | {} compared to {} is the same as x compared directly\", \n-\t\t\t\t\t\tmask_value, cmp_value)); \n-\t\t\t\t}\n-\t\t\t},\n-\t\t\t_ => ()\n-\t\t},\n-\t\t_ => ()\n-\t}\n+fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n+                  mask_value: u64, cmp_value: u64, span: &Span) {\n+    match cmp_op {\n+        BiEq | BiNe => match bit_op {\n+            BiBitAnd => if mask_value & cmp_value != mask_value {\n+                if cmp_value != 0 {\n+                    span_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                        \"incompatible bit mask: _ & {} can never be equal to {}\",\n+                        mask_value, cmp_value));\n+                }\n+            } else {\n+                if mask_value == 0 {\n+                    span_lint(cx, BAD_BIT_MASK, *span,\n+                              &format!(\"&-masking with zero\"));\n+                }\n+            },\n+            BiBitOr => if mask_value | cmp_value != cmp_value {\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                    \"incompatible bit mask: _ | {} can never be equal to {}\",\n+                    mask_value, cmp_value));\n+            },\n+            _ => ()\n+        },\n+        BiLt | BiGe => match bit_op {\n+            BiBitAnd => if mask_value < cmp_value {\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                    \"incompatible bit mask: _ & {} will always be lower than {}\",\n+                    mask_value, cmp_value));\n+            } else {\n+                if mask_value == 0 {\n+                    span_lint(cx, BAD_BIT_MASK, *span,\n+                              &format!(\"&-masking with zero\"));\n+                }\n+            },\n+            BiBitOr => if mask_value >= cmp_value {\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                    \"incompatible bit mask: _ | {} will never be lower than {}\",\n+                    mask_value, cmp_value));\n+            } else {\n+                if mask_value < cmp_value {\n+                    span_lint(cx, INEFFECTIVE_BIT_MASK, *span, &format!(\n+                        \"ineffective bit mask: x | {} compared to {} is the same as x compared directly\",\n+                        mask_value, cmp_value));\n+                }\n+            },\n+            _ => ()\n+        },\n+        BiLe | BiGt => match bit_op {\n+            BiBitAnd => if mask_value <= cmp_value {\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                    \"incompatible bit mask: _ & {} will never be higher than {}\",\n+                    mask_value, cmp_value));\n+            } else {\n+                if mask_value == 0 {\n+                    span_lint(cx, BAD_BIT_MASK, *span,\n+                              &format!(\"&-masking with zero\"));\n+                }\n+            },\n+            BiBitOr => if mask_value > cmp_value {\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                    \"incompatible bit mask: _ | {} will always be higher than {}\",\n+                    mask_value, cmp_value));\n+            } else {\n+                if mask_value < cmp_value {\n+                    span_lint(cx, INEFFECTIVE_BIT_MASK, *span, &format!(\n+                        \"ineffective bit mask: x | {} compared to {} is the same as x compared directly\",\n+                        mask_value, cmp_value));\n+                }\n+            },\n+            _ => ()\n+        },\n+        _ => ()\n+    }\n }\n \n fn fetch_int_literal(cx: &Context, lit : &Expr) -> Option<u64> {\n-\tmatch &lit.node {\n-\t\t&ExprLit(ref lit_ptr) => {\n-\t\t\tif let &LitInt(value, _) = &lit_ptr.node {\n-\t\t\t\tOption::Some(value) //TODO: Handle sign\n-\t\t\t} else { Option::None }\n-\t\t},\n-\t\t&ExprPath(_, _) => {\n-                // Important to let the borrow expire before the const lookup to avoid double\n-                // borrowing.\n-                let def_map = cx.tcx.def_map.borrow();\n-                match def_map.get(&lit.id) {\n-                    Some(&PathResolution { base_def: DefConst(def_id), ..}) => Some(def_id),\n-                    _ => None\n-                }\n+    match &lit.node {\n+        &ExprLit(ref lit_ptr) => {\n+            if let &LitInt(value, _) = &lit_ptr.node {\n+                Option::Some(value) //TODO: Handle sign\n+            } else { Option::None }\n+        },\n+        &ExprPath(_, _) => {\n+            // Important to let the borrow expire before the const lookup to avoid double\n+            // borrowing.\n+            let def_map = cx.tcx.def_map.borrow();\n+            match def_map.get(&lit.id) {\n+                Some(&PathResolution { base_def: DefConst(def_id), ..}) => Some(def_id),\n+                _ => None\n             }\n-            .and_then(|def_id| lookup_const_by_id(cx.tcx, def_id, Option::None))\n-            .and_then(|l| fetch_int_literal(cx, l)),\n-\t\t_ => Option::None\n-\t}\n+        }\n+        .and_then(|def_id| lookup_const_by_id(cx.tcx, def_id, Option::None))\n+        .and_then(|l| fetch_int_literal(cx, l)),\n+        _ => Option::None\n+    }\n }"}, {"sha": "eae3222945c2ba7eda32f415a6f13bf4dc90730e", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -34,24 +34,24 @@ impl LintPass for CollapsibleIf {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(COLLAPSIBLE_IF)\n     }\n-    \n-\tfn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-\t\tcx.sess().codemap().with_expn_info(expr.span.expn_id, \n-\t\t\t|info| check_expr_expd(cx, expr, info))\n-\t}\n+\n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        cx.sess().codemap().with_expn_info(expr.span.expn_id,\n+            |info| check_expr_expd(cx, expr, info))\n+    }\n }\n \n fn check_expr_expd(cx: &Context, e: &Expr, info: Option<&ExpnInfo>) {\n-\tif in_macro(cx, info) { return; }\n-\t\n-\tif let ExprIf(ref check, ref then, None) = e.node {\n-\t\tif let Some(&Expr{ node: ExprIf(ref check_inner, _, None), ..}) = \n-\t\t\t\tsingle_stmt_of_block(then) {\n-\t\t\tspan_lint(cx, COLLAPSIBLE_IF, e.span, &format!(\n-\t\t\t\t\"This if statement can be collapsed. Try: if {} && {}\\n{:?}\", \n-\t\t\t\tcheck_to_string(check), check_to_string(check_inner), e));\n-\t\t}\n-\t}\n+    if in_macro(cx, info) { return; }\n+\n+    if let ExprIf(ref check, ref then, None) = e.node {\n+        if let Some(&Expr{ node: ExprIf(ref check_inner, _, None), ..}) =\n+            single_stmt_of_block(then) {\n+                span_lint(cx, COLLAPSIBLE_IF, e.span, &format!(\n+                    \"This if statement can be collapsed. Try: if {} && {}\\n{:?}\",\n+                    check_to_string(check), check_to_string(check_inner), e));\n+            }\n+    }\n }\n \n fn requires_brackets(e: &Expr) -> bool {"}, {"sha": "6ad0e0658dfdddd3415a6f851561685756c7300b", "filename": "src/eq_op.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -18,12 +18,12 @@ impl LintPass for EqOp {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(EQ_OP)\n     }\n-    \n+\n     fn check_expr(&mut self, cx: &Context, e: &Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n             if is_cmp_or_bit(op) && is_exp_equal(left, right) {\n                 span_lint(cx, EQ_OP, e.span, &format!(\n-                    \"equal expressions as operands to {}\", \n+                    \"equal expressions as operands to {}\",\n                         ast_util::binop_to_string(op.node)));\n             }\n         }\n@@ -32,36 +32,36 @@ impl LintPass for EqOp {\n \n pub fn is_exp_equal(left : &Expr, right : &Expr) -> bool {\n     match (&left.node, &right.node) {\n-        (&ExprBinary(ref lop, ref ll, ref lr), \n-                &ExprBinary(ref rop, ref rl, ref rr)) => \n-            lop.node == rop.node && \n+        (&ExprBinary(ref lop, ref ll, ref lr),\n+                &ExprBinary(ref rop, ref rl, ref rr)) =>\n+            lop.node == rop.node &&\n             is_exp_equal(ll, rl) && is_exp_equal(lr, rr),\n-        (&ExprBox(ref lpl, ref lbox), &ExprBox(ref rpl, ref rbox)) => \n-            both(lpl, rpl, |l, r| is_exp_equal(l, r)) && \n+        (&ExprBox(ref lpl, ref lbox), &ExprBox(ref rpl, ref rbox)) =>\n+            both(lpl, rpl, |l, r| is_exp_equal(l, r)) &&\n                 is_exp_equal(lbox, rbox),\n-        (&ExprCall(ref lcallee, ref largs), \n-         &ExprCall(ref rcallee, ref rargs)) => is_exp_equal(lcallee, \n+        (&ExprCall(ref lcallee, ref largs),\n+         &ExprCall(ref rcallee, ref rargs)) => is_exp_equal(lcallee,\n             rcallee) && is_exps_equal(largs, rargs),\n-        (&ExprCast(ref lc, ref lty), &ExprCast(ref rc, ref rty)) => \n+        (&ExprCast(ref lc, ref lty), &ExprCast(ref rc, ref rty)) =>\n             is_ty_equal(lty, rty) && is_exp_equal(lc, rc),\n-        (&ExprField(ref lfexp, ref lfident), \n-                &ExprField(ref rfexp, ref rfident)) => \n+        (&ExprField(ref lfexp, ref lfident),\n+                &ExprField(ref rfexp, ref rfident)) =>\n             lfident.node == rfident.node && is_exp_equal(lfexp, rfexp),\n         (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n-        (&ExprMethodCall(ref lident, ref lcty, ref lmargs), \n-                &ExprMethodCall(ref rident, ref rcty, ref rmargs)) => \n-            lident.node == rident.node && is_tys_equal(lcty, rcty) && \n+        (&ExprMethodCall(ref lident, ref lcty, ref lmargs),\n+                &ExprMethodCall(ref rident, ref rcty, ref rmargs)) =>\n+            lident.node == rident.node && is_tys_equal(lcty, rcty) &&\n                 is_exps_equal(lmargs, rmargs),\n         (&ExprParen(ref lparen), _) => is_exp_equal(lparen, right),\n         (_, &ExprParen(ref rparen)) => is_exp_equal(left, rparen),\n-        (&ExprPath(ref lqself, ref lsubpath), \n-                &ExprPath(ref rqself, ref rsubpath)) => \n-            both(lqself, rqself, |l, r| is_qself_equal(l, r)) && \n-                is_path_equal(lsubpath, rsubpath),      \n-        (&ExprTup(ref ltup), &ExprTup(ref rtup)) => \n+        (&ExprPath(ref lqself, ref lsubpath),\n+                &ExprPath(ref rqself, ref rsubpath)) =>\n+            both(lqself, rqself, |l, r| is_qself_equal(l, r)) &&\n+                is_path_equal(lsubpath, rsubpath),\n+        (&ExprTup(ref ltup), &ExprTup(ref rtup)) =>\n             is_exps_equal(ltup, rtup),\n-        (&ExprUnary(lunop, ref l), &ExprUnary(runop, ref r)) => \n-            lunop == runop && is_exp_equal(l, r), \n+        (&ExprUnary(lunop, ref l), &ExprUnary(runop, ref r)) =>\n+            lunop == runop && is_exp_equal(l, r),\n         (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(l, r),\n         _ => false\n     }\n@@ -74,7 +74,7 @@ fn is_exps_equal(left : &[P<Expr>], right : &[P<Expr>]) -> bool {\n fn is_path_equal(left : &Path, right : &Path) -> bool {\n     // The == of idents doesn't work with different contexts,\n     // we have to be explicit about hygiene\n-    left.global == right.global && over(&left.segments, &right.segments, \n+    left.global == right.global && over(&left.segments, &right.segments,\n         |l, r| l.identifier.name == r.identifier.name\n               && l.identifier.ctxt == r.identifier.ctxt\n                && l.parameters == r.parameters)\n@@ -87,23 +87,23 @@ fn is_qself_equal(left : &QSelf, right : &QSelf) -> bool {\n fn is_ty_equal(left : &Ty, right : &Ty) -> bool {\n     match (&left.node, &right.node) {\n     (&TyVec(ref lvec), &TyVec(ref rvec)) => is_ty_equal(lvec, rvec),\n-    (&TyFixedLengthVec(ref lfvty, ref lfvexp), \n-            &TyFixedLengthVec(ref rfvty, ref rfvexp)) => \n+    (&TyFixedLengthVec(ref lfvty, ref lfvexp),\n+            &TyFixedLengthVec(ref rfvty, ref rfvexp)) =>\n         is_ty_equal(lfvty, rfvty) && is_exp_equal(lfvexp, rfvexp),\n     (&TyPtr(ref lmut), &TyPtr(ref rmut)) => is_mut_ty_equal(lmut, rmut),\n-    (&TyRptr(ref ltime, ref lrmut), &TyRptr(ref rtime, ref rrmut)) => \n-        both(ltime, rtime, is_lifetime_equal) && \n+    (&TyRptr(ref ltime, ref lrmut), &TyRptr(ref rtime, ref rrmut)) =>\n+        both(ltime, rtime, is_lifetime_equal) &&\n         is_mut_ty_equal(lrmut, rrmut),\n-    (&TyBareFn(ref lbare), &TyBareFn(ref rbare)) => \n+    (&TyBareFn(ref lbare), &TyBareFn(ref rbare)) =>\n         is_bare_fn_ty_equal(lbare, rbare),\n     (&TyTup(ref ltup), &TyTup(ref rtup)) => is_tys_equal(ltup, rtup),\n-    (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) => \n+    (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) =>\n         both(lq, rq, is_qself_equal) && is_path_equal(lpath, rpath),\n-    (&TyObjectSum(ref lsumty, ref lobounds), \n-            &TyObjectSum(ref rsumty, ref robounds)) => \n-        is_ty_equal(lsumty, rsumty) && \n+    (&TyObjectSum(ref lsumty, ref lobounds),\n+            &TyObjectSum(ref rsumty, ref robounds)) =>\n+        is_ty_equal(lsumty, rsumty) &&\n         is_param_bounds_equal(lobounds, robounds),\n-    (&TyPolyTraitRef(ref ltbounds), &TyPolyTraitRef(ref rtbounds)) => \n+    (&TyPolyTraitRef(ref ltbounds), &TyPolyTraitRef(ref rtbounds)) =>\n         is_param_bounds_equal(ltbounds, rtbounds),\n     (&TyParen(ref lty), &TyParen(ref rty)) => is_ty_equal(lty, rty),\n     (&TyTypeof(ref lof), &TyTypeof(ref rof)) => is_exp_equal(lof, rof),\n@@ -112,13 +112,13 @@ fn is_ty_equal(left : &Ty, right : &Ty) -> bool {\n     }\n }\n \n-fn is_param_bound_equal(left : &TyParamBound, right : &TyParamBound) \n+fn is_param_bound_equal(left : &TyParamBound, right : &TyParamBound)\n         -> bool {\n     match(left, right) {\n-    (&TraitTyParamBound(ref lpoly, ref lmod), \n-            &TraitTyParamBound(ref rpoly, ref rmod)) => \n+    (&TraitTyParamBound(ref lpoly, ref lmod),\n+            &TraitTyParamBound(ref rpoly, ref rmod)) =>\n         lmod == rmod && is_poly_traitref_equal(lpoly, rpoly),\n-    (&RegionTyParamBound(ref ltime), &RegionTyParamBound(ref rtime)) => \n+    (&RegionTyParamBound(ref ltime), &RegionTyParamBound(ref rtime)) =>\n         is_lifetime_equal(ltime, rtime),\n     _ => false\n     }\n@@ -140,24 +140,24 @@ fn is_mut_ty_equal(left : &MutTy, right : &MutTy) -> bool {\n }\n \n fn is_bare_fn_ty_equal(left : &BareFnTy, right : &BareFnTy) -> bool {\n-    left.unsafety == right.unsafety && left.abi == right.abi && \n-        is_lifetimedefs_equal(&left.lifetimes, &right.lifetimes) && \n+    left.unsafety == right.unsafety && left.abi == right.abi &&\n+        is_lifetimedefs_equal(&left.lifetimes, &right.lifetimes) &&\n             is_fndecl_equal(&left.decl, &right.decl)\n-} \n+}\n \n fn is_fndecl_equal(left : &P<FnDecl>, right : &P<FnDecl>) -> bool {\n-    left.variadic == right.variadic && \n-        is_args_equal(&left.inputs, &right.inputs) && \n+    left.variadic == right.variadic &&\n+        is_args_equal(&left.inputs, &right.inputs) &&\n         is_fnret_ty_equal(&left.output, &right.output)\n }\n \n-fn is_fnret_ty_equal(left : &FunctionRetTy, right : &FunctionRetTy) \n+fn is_fnret_ty_equal(left : &FunctionRetTy, right : &FunctionRetTy)\n         -> bool {\n     match (left, right) {\n-    (&NoReturn(_), &NoReturn(_)) | \n+    (&NoReturn(_), &NoReturn(_)) |\n     (&DefaultReturn(_), &DefaultReturn(_)) => true,\n     (&Return(ref lty), &Return(ref rty)) => is_ty_equal(lty, rty),\n-    _ => false  \n+    _ => false\n     }\n }\n \n@@ -172,49 +172,49 @@ fn is_args_equal(left : &[Arg], right : &[Arg]) -> bool {\n fn is_pat_equal(left : &Pat, right : &Pat) -> bool {\n     match(&left.node, &right.node) {\n     (&PatWild(lwild), &PatWild(rwild)) => lwild == rwild,\n-    (&PatIdent(ref lmode, ref lident, Option::None), \n+    (&PatIdent(ref lmode, ref lident, Option::None),\n             &PatIdent(ref rmode, ref rident, Option::None)) =>\n         lmode == rmode && is_ident_equal(&lident.node, &rident.node),\n-    (&PatIdent(ref lmode, ref lident, Option::Some(ref lpat)), \n+    (&PatIdent(ref lmode, ref lident, Option::Some(ref lpat)),\n             &PatIdent(ref rmode, ref rident, Option::Some(ref rpat))) =>\n-        lmode == rmode && is_ident_equal(&lident.node, &rident.node) && \n+        lmode == rmode && is_ident_equal(&lident.node, &rident.node) &&\n             is_pat_equal(lpat, rpat),\n-    (&PatEnum(ref lpath, ref lenum), &PatEnum(ref rpath, ref renum)) => \n-        is_path_equal(lpath, rpath) && both(lenum, renum, |l, r| \n+    (&PatEnum(ref lpath, ref lenum), &PatEnum(ref rpath, ref renum)) =>\n+        is_path_equal(lpath, rpath) && both(lenum, renum, |l, r|\n             is_pats_equal(l, r)),\n-    (&PatStruct(ref lpath, ref lfieldpat, lbool), \n+    (&PatStruct(ref lpath, ref lfieldpat, lbool),\n             &PatStruct(ref rpath, ref rfieldpat, rbool)) =>\n-        lbool == rbool && is_path_equal(lpath, rpath) && \n+        lbool == rbool && is_path_equal(lpath, rpath) &&\n             is_spanned_fieldpats_equal(lfieldpat, rfieldpat),\n-    (&PatTup(ref ltup), &PatTup(ref rtup)) => is_pats_equal(ltup, rtup), \n-    (&PatBox(ref lboxed), &PatBox(ref rboxed)) => \n+    (&PatTup(ref ltup), &PatTup(ref rtup)) => is_pats_equal(ltup, rtup),\n+    (&PatBox(ref lboxed), &PatBox(ref rboxed)) =>\n         is_pat_equal(lboxed, rboxed),\n-    (&PatRegion(ref lpat, ref lmut), &PatRegion(ref rpat, ref rmut)) => \n+    (&PatRegion(ref lpat, ref lmut), &PatRegion(ref rpat, ref rmut)) =>\n         is_pat_equal(lpat, rpat) && lmut == rmut,\n     (&PatLit(ref llit), &PatLit(ref rlit)) => is_exp_equal(llit, rlit),\n     (&PatRange(ref lfrom, ref lto), &PatRange(ref rfrom, ref rto)) =>\n         is_exp_equal(lfrom, rfrom) && is_exp_equal(lto, rto),\n-    (&PatVec(ref lfirst, Option::None, ref llast), \n+    (&PatVec(ref lfirst, Option::None, ref llast),\n             &PatVec(ref rfirst, Option::None, ref rlast)) =>\n         is_pats_equal(lfirst, rfirst) && is_pats_equal(llast, rlast),\n-    (&PatVec(ref lfirst, Option::Some(ref lpat), ref llast), \n+    (&PatVec(ref lfirst, Option::Some(ref lpat), ref llast),\n             &PatVec(ref rfirst, Option::Some(ref rpat), ref rlast)) =>\n-        is_pats_equal(lfirst, rfirst) && is_pat_equal(lpat, rpat) && \n+        is_pats_equal(lfirst, rfirst) && is_pat_equal(lpat, rpat) &&\n             is_pats_equal(llast, rlast),\n     // I don't match macros for now, the code is slow enough as is ;-)\n     _ => false\n     }\n }\n \n-fn is_spanned_fieldpats_equal(left : &[code::Spanned<FieldPat>], \n+fn is_spanned_fieldpats_equal(left : &[code::Spanned<FieldPat>],\n         right : &[code::Spanned<FieldPat>]) -> bool {\n     over(left, right, |l, r| is_fieldpat_equal(&l.node, &r.node))\n }\n \n fn is_fieldpat_equal(left : &FieldPat, right : &FieldPat) -> bool {\n-    left.is_shorthand == right.is_shorthand && \n-        is_ident_equal(&left.ident, &right.ident) && \n-        is_pat_equal(&left.pat, &right.pat) \n+    left.is_shorthand == right.is_shorthand &&\n+        is_ident_equal(&left.ident, &right.ident) &&\n+        is_pat_equal(&left.pat, &right.pat)\n }\n \n fn is_ident_equal(left : &Ident, right : &Ident) -> bool {\n@@ -227,11 +227,11 @@ fn is_pats_equal(left : &[P<Pat>], right : &[P<Pat>]) -> bool {\n \n fn is_lifetimedef_equal(left : &LifetimeDef, right : &LifetimeDef)\n         -> bool {\n-    is_lifetime_equal(&left.lifetime, &right.lifetime) && \n+    is_lifetime_equal(&left.lifetime, &right.lifetime) &&\n         over(&left.bounds, &right.bounds, is_lifetime_equal)\n }\n \n-fn is_lifetimedefs_equal(left : &[LifetimeDef], right : &[LifetimeDef]) \n+fn is_lifetimedefs_equal(left : &[LifetimeDef], right : &[LifetimeDef])\n         -> bool {\n     over(left, right, is_lifetimedef_equal)\n }\n@@ -244,21 +244,21 @@ fn is_tys_equal(left : &[P<Ty>], right : &[P<Ty>]) -> bool {\n     over(left, right, |l, r| is_ty_equal(l, r))\n }\n \n-fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool \n+fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n         where F: FnMut(&X, &X) -> bool {\n-    left.len() == right.len() && left.iter().zip(right).all(|(x, y)| \n+    left.len() == right.len() && left.iter().zip(right).all(|(x, y)|\n         eq_fn(x, y))\n }\n \n-fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn : F) -> bool \n+fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn : F) -> bool\n         where F: FnMut(&X, &X) -> bool {\n     l.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false,\n         |y| eq_fn(x, y)))\n }\n \n fn is_cmp_or_bit(op : &BinOp) -> bool {\n     match op.node {\n-        BiEq | BiLt | BiLe | BiGt | BiGe | BiNe | BiAnd | BiOr | \n+        BiEq | BiLt | BiLe | BiGt | BiGe | BiNe | BiAnd | BiOr |\n         BiBitXor | BiBitAnd | BiBitOr => true,\n         _ => false\n     }"}, {"sha": "6948c1b22abb948b44e197c28281bb40e98dd9a2", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -58,4 +58,3 @@ impl LintPass for EtaPass {\n         }\n     }\n }\n-"}, {"sha": "56d01c52b1d836713392a25f4f2277b5eb1537ff", "filename": "src/identity_op.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -11,7 +11,7 @@ use utils::{span_lint, snippet};\n \n declare_lint! { pub IDENTITY_OP, Warn,\n     \"Warn on identity operations, e.g. '_ + 0'\"}\n-    \n+\n #[derive(Copy,Clone)]\n pub struct IdentityOp;\n \n@@ -27,7 +27,7 @@ impl LintPass for IdentityOp {\n                     check(cx, left, 0, e.span, right.span);\n                     check(cx, right, 0, e.span, left.span);\n                 },\n-                BiShl | BiShr | BiSub => \n+                BiShl | BiShr | BiSub =>\n                     check(cx, right, 0, e.span, left.span),\n                 BiMul => {\n                     check(cx, left, 1, e.span, right.span);\n@@ -49,14 +49,14 @@ impl LintPass for IdentityOp {\n fn check(cx: &Context, e: &Expr, m: i8, span: Span, arg: Span) {\n     if have_lit(cx, e, m) {\n         span_lint(cx, IDENTITY_OP, span, &format!(\n-            \"The operation is ineffective. Consider reducing it to '{}'\", \n+            \"The operation is ineffective. Consider reducing it to '{}'\",\n            snippet(cx, arg, \"..\")));\n     }\n }\n \n fn have_lit(cx: &Context, e : &Expr, m: i8) -> bool {\n     match &e.node {\n-        &ExprUnary(UnNeg, ref litexp) => have_lit(cx, litexp, -m), \n+        &ExprUnary(UnNeg, ref litexp) => have_lit(cx, litexp, -m),\n         &ExprLit(ref lit) => {\n             match (&lit.node, m) {\n                 (&LitInt(0, _), 0) => true,\n@@ -68,9 +68,9 @@ fn have_lit(cx: &Context, e : &Expr, m: i8) -> bool {\n             }\n         },\n         &ExprParen(ref p) => have_lit(cx, p, m),\n-        &ExprPath(_, _) => { \n+        &ExprPath(_, _) => {\n             match cx.tcx.def_map.borrow().get(&e.id) {\n-                Some(&PathResolution { base_def: DefConst(id), ..}) => \n+                Some(&PathResolution { base_def: DefConst(id), ..}) =>\n                         lookup_const_by_id(cx.tcx, id, Option::None)\n                         .map_or(false, |l| have_lit(cx, l, m)),\n                 _ => false"}, {"sha": "0877fa952383bc12dc381029872b2c56af620d99", "filename": "src/len_zero.rs", "status": "modified", "additions": 107, "deletions": 107, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -22,130 +22,130 @@ declare_lint!(pub LEN_WITHOUT_IS_EMPTY, Warn,\n pub struct LenZero;\n \n impl LintPass for LenZero {\n-\tfn get_lints(&self) -> LintArray {\n+    fn get_lints(&self) -> LintArray {\n         lint_array!(LEN_ZERO, LEN_WITHOUT_IS_EMPTY)\n-\t}\n-\t\n-\tfn check_item(&mut self, cx: &Context, item: &Item) {\n-\t\tmatch &item.node {\n-\t\t\t&ItemTrait(_, _, _, ref trait_items) => \n-\t\t\t\tcheck_trait_items(cx, item, trait_items),\n-\t\t\t&ItemImpl(_, _, _, None, _, ref impl_items) => // only non-trait\n-\t\t\t\tcheck_impl_items(cx, item, impl_items),\n-\t\t\t_ => ()\n-\t\t}\n-\t}\n-\t\n-\tfn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-\t\tif let &ExprBinary(Spanned{node: cmp, ..}, ref left, ref right) = \n-\t\t\t\t&expr.node {\n-\t\t\tmatch cmp {\n-\t\t\t\tBiEq => check_cmp(cx, expr.span, left, right, \"\"),\n-\t\t\t\tBiGt | BiNe => check_cmp(cx, expr.span, left, right, \"!\"),\n-\t\t\t\t_ => ()\n-\t\t\t}\n-\t\t}\n-\t}\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, item: &Item) {\n+        match &item.node {\n+            &ItemTrait(_, _, _, ref trait_items) =>\n+                check_trait_items(cx, item, trait_items),\n+            &ItemImpl(_, _, _, None, _, ref impl_items) => // only non-trait\n+                check_impl_items(cx, item, impl_items),\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        if let &ExprBinary(Spanned{node: cmp, ..}, ref left, ref right) =\n+            &expr.node {\n+                match cmp {\n+                    BiEq => check_cmp(cx, expr.span, left, right, \"\"),\n+                    BiGt | BiNe => check_cmp(cx, expr.span, left, right, \"!\"),\n+                    _ => ()\n+                }\n+            }\n+    }\n }\n \n fn check_trait_items(cx: &Context, item: &Item, trait_items: &[P<TraitItem>]) {\n-\tfn is_named_self(item: &TraitItem, name: &str) -> bool {\n-\t\titem.ident.name == name && if let MethodTraitItem(ref sig, _) =\n-\t\t\titem.node { is_self_sig(sig) } else { false }\n-\t}\n-\n-\tif !trait_items.iter().any(|i| is_named_self(i, \"is_empty\")) {\n-\t\t//span_lint(cx, LEN_WITHOUT_IS_EMPTY, item.span, &format!(\"trait {}\", item.ident.as_str()));\n-\t\tfor i in trait_items {\n-\t\t\tif is_named_self(i, \"len\") {\n-\t\t\t\tspan_lint(cx, LEN_WITHOUT_IS_EMPTY, i.span,\n-\t\t\t\t\t&format!(\"Trait '{}' has a '.len(_: &Self)' method, but no \\\n-\t\t\t\t\t\t'.is_empty(_: &Self)' method. Consider adding one.\", \n-\t\t\t\t\t\titem.ident.name));\n-\t\t\t}\n-\t\t};\n-\t}\n+    fn is_named_self(item: &TraitItem, name: &str) -> bool {\n+        item.ident.name == name && if let MethodTraitItem(ref sig, _) =\n+            item.node { is_self_sig(sig) } else { false }\n+    }\n+\n+    if !trait_items.iter().any(|i| is_named_self(i, \"is_empty\")) {\n+        //span_lint(cx, LEN_WITHOUT_IS_EMPTY, item.span, &format!(\"trait {}\", item.ident.as_str()));\n+        for i in trait_items {\n+            if is_named_self(i, \"len\") {\n+                span_lint(cx, LEN_WITHOUT_IS_EMPTY, i.span,\n+                          &format!(\"Trait '{}' has a '.len(_: &Self)' method, but no \\\n+                                    '.is_empty(_: &Self)' method. Consider adding one.\",\n+                                   item.ident.name));\n+            }\n+        };\n+    }\n }\n \n fn check_impl_items(cx: &Context, item: &Item, impl_items: &[P<ImplItem>]) {\n-\tfn is_named_self(item: &ImplItem, name: &str) -> bool {\n-\t\titem.ident.name == name && if let MethodImplItem(ref sig, _) = \n-\t\t\t\titem.node { is_self_sig(sig) } else { false }\n-\t}\n-\n-\tif !impl_items.iter().any(|i| is_named_self(i, \"is_empty\")) {\n-\t\tfor i in impl_items {\n-\t\t\tif is_named_self(i, \"len\") {\n-\t\t\t\tlet s = i.span;\n-\t\t\t\tspan_lint(cx, LEN_WITHOUT_IS_EMPTY, \n-\t\t\t\t\tSpan{ lo: s.lo, hi: s.lo, expn_id: s.expn_id },\n-\t\t\t\t\t&format!(\"Item '{}' has a '.len(_: &Self)' method, but no \\\n-\t\t\t\t\t\t'.is_empty(_: &Self)' method. Consider adding one.\", \n-\t\t\t\t\t\titem.ident.name));\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t}\n+    fn is_named_self(item: &ImplItem, name: &str) -> bool {\n+        item.ident.name == name && if let MethodImplItem(ref sig, _) =\n+            item.node { is_self_sig(sig) } else { false }\n+    }\n+\n+    if !impl_items.iter().any(|i| is_named_self(i, \"is_empty\")) {\n+        for i in impl_items {\n+            if is_named_self(i, \"len\") {\n+                let s = i.span;\n+                span_lint(cx, LEN_WITHOUT_IS_EMPTY,\n+                          Span{ lo: s.lo, hi: s.lo, expn_id: s.expn_id },\n+                          &format!(\"Item '{}' has a '.len(_: &Self)' method, but no \\\n+                                    '.is_empty(_: &Self)' method. Consider adding one.\",\n+                                   item.ident.name));\n+                return;\n+            }\n+        }\n+    }\n }\n \n fn is_self_sig(sig: &MethodSig) -> bool {\n-\tif let SelfStatic = sig.explicit_self.node { \n-\t\tfalse } else { sig.decl.inputs.len() == 1 }\n+    if let SelfStatic = sig.explicit_self.node {\n+        false } else { sig.decl.inputs.len() == 1 }\n }\n \n fn check_cmp(cx: &Context, span: Span, left: &Expr, right: &Expr, empty: &str) {\n-\tmatch (&left.node, &right.node) {\n-\t\t(&ExprLit(ref lit), &ExprMethodCall(ref method, _, ref args)) => \n-\t\t\tcheck_len_zero(cx, span, method, args, lit, empty),\n-\t\t(&ExprMethodCall(ref method, _, ref args), &ExprLit(ref lit)) => \n-\t\t\tcheck_len_zero(cx, span, method, args, lit, empty),\n-\t\t_ => ()\n-\t}\n+    match (&left.node, &right.node) {\n+        (&ExprLit(ref lit), &ExprMethodCall(ref method, _, ref args)) =>\n+            check_len_zero(cx, span, method, args, lit, empty),\n+        (&ExprMethodCall(ref method, _, ref args), &ExprLit(ref lit)) =>\n+            check_len_zero(cx, span, method, args, lit, empty),\n+        _ => ()\n+    }\n }\n \n-fn check_len_zero(cx: &Context, span: Span, method: &SpannedIdent, \n-\t\targs: &[P<Expr>], lit: &Lit, empty: &str) {\n-\tif let &Spanned{node: LitInt(0, _), ..} = lit {\n-\t\tif method.node.name == \"len\" && args.len() == 1 &&\n-\t\t\thas_is_empty(cx, &*args[0]) {\n-\t\t\tspan_lint(cx, LEN_ZERO, span, &format!(\n-\t\t\t\t\"Consider replacing the len comparison with '{}_.is_empty()'\",\n-\t\t\t\t\tempty))\n-\t\t}\n-\t}\n+fn check_len_zero(cx: &Context, span: Span, method: &SpannedIdent,\n+                  args: &[P<Expr>], lit: &Lit, empty: &str) {\n+    if let &Spanned{node: LitInt(0, _), ..} = lit {\n+        if method.node.name == \"len\" && args.len() == 1 &&\n+            has_is_empty(cx, &*args[0]) {\n+                span_lint(cx, LEN_ZERO, span, &format!(\n+                    \"Consider replacing the len comparison with '{}_.is_empty()'\",\n+                    empty))\n+            }\n+    }\n }\n \n /// check if this type has an is_empty method\n fn has_is_empty(cx: &Context, expr: &Expr) -> bool {\n-\t/// get a ImplOrTraitItem and return true if it matches is_empty(self)\n-\tfn is_is_empty(cx: &Context, id: &ImplOrTraitItemId) -> bool {\n-\t\tif let &MethodTraitItemId(def_id) = id {\n-\t\t\tif let ty::MethodTraitItem(ref method) = \n-\t\t\t\t\tcx.tcx.impl_or_trait_item(def_id) {\n-\t\t\t\tmethod.name.as_str() == \"is_empty\"\n-\t\t\t\t\t&& method.fty.sig.skip_binder().inputs.len() == 1 \n-\t\t\t} else { false }\n-\t\t} else { false }\n-\t}\n-\t\n-\t/// check the inherent impl's items for an is_empty(self) method\n-\tfn has_is_empty_impl(cx: &Context, id: &DefId) -> bool {\n-\t\tlet impl_items = cx.tcx.impl_items.borrow();\n-\t\tcx.tcx.inherent_impls.borrow().get(id).map_or(false, \n-\t\t\t|ids| ids.iter().any(|iid| impl_items.get(iid).map_or(false, \n-\t\t\t\t|iids| iids.iter().any(|i| is_is_empty(cx, i)))))\n-\t}\n-\t\n-\tlet ty = &walk_ty(&cx.tcx.expr_ty(expr));\n-\tmatch ty.sty {\n-\t\tty::TyTrait(_) => cx.tcx.trait_item_def_ids.borrow().get(\n-\t\t\t&ty.ty_to_def_id().expect(\"trait impl not found\")).map_or(false, \n-\t\t\t|ids| ids.iter().any(|i| is_is_empty(cx, i))),\n-\t\tty::TyProjection(_) => ty.ty_to_def_id().map_or(false, \n-\t\t\t|id| has_is_empty_impl(cx, &id)),\n-\t\tty::TyEnum(ref id, _) | ty::TyStruct(ref id, _) => \n-\t\t\thas_is_empty_impl(cx, &id.did),\n-\t\tty::TyArray(..) => true,\n-\t\t_ => false,\n-\t}\n+    /// get a ImplOrTraitItem and return true if it matches is_empty(self)\n+    fn is_is_empty(cx: &Context, id: &ImplOrTraitItemId) -> bool {\n+        if let &MethodTraitItemId(def_id) = id {\n+            if let ty::MethodTraitItem(ref method) =\n+                cx.tcx.impl_or_trait_item(def_id) {\n+                    method.name.as_str() == \"is_empty\"\n+                        && method.fty.sig.skip_binder().inputs.len() == 1\n+                } else { false }\n+        } else { false }\n+    }\n+\n+    /// check the inherent impl's items for an is_empty(self) method\n+    fn has_is_empty_impl(cx: &Context, id: &DefId) -> bool {\n+        let impl_items = cx.tcx.impl_items.borrow();\n+        cx.tcx.inherent_impls.borrow().get(id).map_or(false,\n+            |ids| ids.iter().any(|iid| impl_items.get(iid).map_or(false,\n+                |iids| iids.iter().any(|i| is_is_empty(cx, i)))))\n+    }\n+\n+    let ty = &walk_ty(&cx.tcx.expr_ty(expr));\n+    match ty.sty {\n+        ty::TyTrait(_) => cx.tcx.trait_item_def_ids.borrow().get(\n+            &ty.ty_to_def_id().expect(\"trait impl not found\")).map_or(false,\n+                |ids| ids.iter().any(|i| is_is_empty(cx, i))),\n+        ty::TyProjection(_) => ty.ty_to_def_id().map_or(false,\n+            |id| has_is_empty_impl(cx, &id)),\n+        ty::TyEnum(ref id, _) | ty::TyStruct(ref id, _) =>\n+            has_is_empty_impl(cx, &id.did),\n+        ty::TyArray(..) => true,\n+        _ => false,\n+    }\n }"}, {"sha": "16ea422f77f8508d0089cd177ac5c2d44ae725cb", "filename": "src/mut_mut.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -12,50 +12,50 @@ declare_lint!(pub MUT_MUT, Warn,\n pub struct MutMut;\n \n impl LintPass for MutMut {\n-\tfn get_lints(&self) -> LintArray {\n+    fn get_lints(&self) -> LintArray {\n         lint_array!(MUT_MUT)\n-\t}\n-\t\n-\tfn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-\t\tcx.sess().codemap().with_expn_info(expr.span.expn_id, \n-\t\t\t|info| check_expr_expd(cx, expr, info))\n-\t}\n-\t\n-\tfn check_ty(&mut self, cx: &Context, ty: &Ty) {\n-\t\tunwrap_mut(ty).and_then(unwrap_mut).map_or((), |_| span_lint(cx, MUT_MUT, \n-\t\t\tty.span, \"Generally you want to avoid &mut &mut _ if possible.\"))\n-\t}\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        cx.sess().codemap().with_expn_info(expr.span.expn_id,\n+            |info| check_expr_expd(cx, expr, info))\n+    }\n+\n+    fn check_ty(&mut self, cx: &Context, ty: &Ty) {\n+        unwrap_mut(ty).and_then(unwrap_mut).map_or((), |_| span_lint(cx, MUT_MUT,\n+            ty.span, \"Generally you want to avoid &mut &mut _ if possible.\"))\n+    }\n }\n \n fn check_expr_expd(cx: &Context, expr: &Expr, info: Option<&ExpnInfo>) {\n-\tif in_macro(cx, info) { return; }\n-\n-\tfn unwrap_addr(expr : &Expr) -> Option<&Expr> {\n-\t\tmatch expr.node {\n-\t\t\tExprAddrOf(MutMutable, ref e) => Option::Some(e),\n-\t\t\t_ => Option::None\n-\t\t}\n-\t}\n-\t\n-\tunwrap_addr(expr).map_or((), |e| {\n-\t\tunwrap_addr(e).map(|_| {\n-\t\t\tspan_lint(cx, MUT_MUT, expr.span, \n-\t\t\t\t\"Generally you want to avoid &mut &mut _ if possible.\")\n-\t\t}).unwrap_or_else(|| {\n-\t\t\tif let TyRef(_, TypeAndMut{ty: _, mutbl: MutMutable}) = \n-\t\t\t\t\tcx.tcx.expr_ty(e).sty {\n-\t\t\t\tspan_lint(cx, MUT_MUT, expr.span,\n-\t\t\t\t\t\"This expression mutably borrows a mutable reference. \\\n-\t\t\t\t\tConsider reborrowing\")\n-\t\t\t}\n-\t\t})\n-\t})\n+    if in_macro(cx, info) { return; }\n+\n+    fn unwrap_addr(expr : &Expr) -> Option<&Expr> {\n+        match expr.node {\n+            ExprAddrOf(MutMutable, ref e) => Option::Some(e),\n+            _ => Option::None\n+        }\n+    }\n+\n+    unwrap_addr(expr).map_or((), |e| {\n+        unwrap_addr(e).map(|_| {\n+            span_lint(cx, MUT_MUT, expr.span,\n+                      \"Generally you want to avoid &mut &mut _ if possible.\")\n+        }).unwrap_or_else(|| {\n+            if let TyRef(_, TypeAndMut{ty: _, mutbl: MutMutable}) =\n+                cx.tcx.expr_ty(e).sty {\n+                    span_lint(cx, MUT_MUT, expr.span,\n+                              \"This expression mutably borrows a mutable reference. \\\n+                               Consider reborrowing\")\n+                }\n+        })\n+    })\n }\n \n fn unwrap_mut(ty : &Ty) -> Option<&Ty> {\n-\tmatch ty.node {\n-\t\tTyPtr(MutTy{ ty: ref pty, mutbl: MutMutable }) => Option::Some(pty),\n-\t\tTyRptr(_, MutTy{ ty: ref pty, mutbl: MutMutable }) => Option::Some(pty),\n-\t\t_ => Option::None\n-\t}\n+    match ty.node {\n+        TyPtr(MutTy{ ty: ref pty, mutbl: MutMutable }) => Option::Some(pty),\n+        TyRptr(_, MutTy{ ty: ref pty, mutbl: MutMutable }) => Option::Some(pty),\n+        _ => Option::None\n+    }\n }"}, {"sha": "3296bdeca8706eab5e508abdf92c8dcc19a65957", "filename": "src/needless_bool.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -25,38 +25,39 @@ impl LintPass for NeedlessBool {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NEEDLESS_BOOL)\n     }\n-    \n+\n     fn check_expr(&mut self, cx: &Context, e: &Expr) {\n         if let ExprIf(_, ref then_block, Option::Some(ref else_expr)) = e.node {\n-\t\t\tmatch (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n-\t\t\t\t(Option::Some(true), Option::Some(true)) => { \n-\t\t\t\t\tspan_lint(cx, NEEDLESS_BOOL, e.span, \n-\t\t\t\t\t\t\"your if-then-else expression will always return true\"); },\n-\t\t\t\t(Option::Some(true), Option::Some(false)) => { \n-\t\t\t\t\tspan_lint(cx, NEEDLESS_BOOL, e.span, \n-\t\t\t\t\t\t\"you can reduce your if-statement to its predicate\"); },\n-\t\t\t\t(Option::Some(false), Option::Some(true)) => { \n-\t\t\t\t\tspan_lint(cx, NEEDLESS_BOOL, e.span, \n-\t\t\t\t\t\t\"you can reduce your if-statement to '!' + your predicate\"); },\n-\t\t\t\t(Option::Some(false), Option::Some(false)) => { \n-\t\t\t\t\tspan_lint(cx, NEEDLESS_BOOL, e.span, \n-\t\t\t\t\t\t\"your if-then-else expression will always return false\"); },\n-\t\t\t\t_ => ()\n-\t\t\t}\n-\t\t}\n+            match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n+                (Option::Some(true), Option::Some(true)) => {\n+                    span_lint(cx, NEEDLESS_BOOL, e.span,\n+                              \"your if-then-else expression will always return true\"); },\n+                (Option::Some(true), Option::Some(false)) => {\n+                    span_lint(cx, NEEDLESS_BOOL, e.span,\n+                              \"you can reduce your if-statement to its predicate\"); },\n+                (Option::Some(false), Option::Some(true)) => {\n+                    span_lint(cx, NEEDLESS_BOOL, e.span,\n+                              \"you can reduce your if-statement to '!' + your predicate\"); },\n+                (Option::Some(false), Option::Some(false)) => {\n+                    span_lint(cx, NEEDLESS_BOOL, e.span,\n+                              \"your if-then-else expression will always return false\"); },\n+                _ => ()\n+            }\n+        }\n     }\n }\n \n fn fetch_bool_block(block: &Block) -> Option<bool> {\n-\tif block.stmts.is_empty() { \n-\t\tblock.expr.as_ref().map(de_p).and_then(fetch_bool_expr)\n-\t} else { Option::None }\n+    if block.stmts.is_empty() {\n+        block.expr.as_ref().map(de_p).and_then(fetch_bool_expr)\n+    } else { Option::None }\n }\n-\t\n+\n fn fetch_bool_expr(expr: &Expr) -> Option<bool> {\n-\tmatch &expr.node {\n-\t\t&ExprBlock(ref block) => fetch_bool_block(block),\n-\t\t&ExprLit(ref lit_ptr) => if let &LitBool(value) = &lit_ptr.node { Option::Some(value) } else { Option::None },\n-\t\t_ => Option::None\n-\t}\n+    match &expr.node {\n+        &ExprBlock(ref block) => fetch_bool_block(block),\n+        &ExprLit(ref lit_ptr) => if let &LitBool(value) = &lit_ptr.node {\n+            Option::Some(value) } else { Option::None },\n+        _ => Option::None\n+    }\n }"}, {"sha": "939277fe66cb876cb55e7c1eb59aa6c57bbeeb33", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -26,44 +26,44 @@ impl LintPass for PtrArg {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(PTR_ARG)\n     }\n-    \n+\n     fn check_item(&mut self, cx: &Context, item: &Item) {\n-\t\tif let &ItemFn(ref decl, _, _, _, _, _) = &item.node {\n-\t\t\tcheck_fn(cx, decl);\n-\t\t}\n-\t}\n-    \n-    fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) { \n-\t\tif let &MethodImplItem(ref sig, _) = &item.node {\n-\t\t\tcheck_fn(cx, &sig.decl);\n-\t\t}\n-\t}\n-        \n-\tfn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n-\t\tif let &MethodTraitItem(ref sig, _) = &item.node {\n-\t\t\tcheck_fn(cx, &sig.decl);\n-\t\t}\n-\t}\n+        if let &ItemFn(ref decl, _, _, _, _, _) = &item.node {\n+            check_fn(cx, decl);\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n+        if let &MethodImplItem(ref sig, _) = &item.node {\n+            check_fn(cx, &sig.decl);\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n+        if let &MethodTraitItem(ref sig, _) = &item.node {\n+            check_fn(cx, &sig.decl);\n+        }\n+    }\n }\n \n fn check_fn(cx: &Context, decl: &FnDecl) {\n-\tfor arg in &decl.inputs {\n-\t\tmatch &arg.ty.node {\n-\t\t\t&TyPtr(ref p) | &TyRptr(_, ref p) => \n-\t\t\t\tcheck_ptr_subtype(cx, arg.ty.span, &p.ty),\n-\t\t\t_ => ()\n-\t\t}\n-\t}\n+    for arg in &decl.inputs {\n+        match &arg.ty.node {\n+            &TyPtr(ref p) | &TyRptr(_, ref p) =>\n+                check_ptr_subtype(cx, arg.ty.span, &p.ty),\n+            _ => ()\n+        }\n+    }\n }\n \n fn check_ptr_subtype(cx: &Context, span: Span, ty: &Ty) {\n-\tmatch_ty_unwrap(ty, &[\"Vec\"]).map_or_else(|| match_ty_unwrap(ty, \n-\t\t\t&[\"String\"]).map_or((), |_| {\n-\t\tspan_lint(cx, PTR_ARG, span,\n-\t\t\t\"Writing '&String' instead of '&str' involves a new Object \\\n-\t\t\twhere a slices will do. Consider changing the type to &str\")\n-\t}), |_| span_lint(cx, PTR_ARG, span, \"Writing '&Vec<_>' instead of \\\n-\t\t\t'&[_]' involves one more reference and cannot be used with \\\n-\t\t\tnon-vec-based slices. Consider changing the type to &[...]\")\n-\t)\n+    match_ty_unwrap(ty, &[\"Vec\"]).map_or_else(|| match_ty_unwrap(ty,\n+        &[\"String\"]).map_or((), |_| {\n+            span_lint(cx, PTR_ARG, span,\n+                      \"Writing '&String' instead of '&str' involves a new Object \\\n+                       where a slices will do. Consider changing the type to &str\")\n+        }), |_| span_lint(cx, PTR_ARG, span,\n+                          \"Writing '&Vec<_>' instead of \\\n+                           '&[_]' involves one more reference and cannot be used with \\\n+                           non-vec-based slices. Consider changing the type to &[...]\"))\n }"}, {"sha": "3384eed8da5138cfb534eb8181ed536222f95b37", "filename": "src/strings.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -1,5 +1,5 @@\n //! This LintPass catches both string addition and string addition + assignment\n-//! \n+//!\n //! Note that since we have two lints where one subsumes the other, we try to\n //! disable the subsumed lint unless it has a higher level\n \n@@ -25,11 +25,11 @@ impl LintPass for StringAdd {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(STRING_ADD_ASSIGN)\n     }\n-    \n+\n     fn check_expr(&mut self, cx: &Context, e: &Expr) {\n         if let &ExprAssign(ref target, ref  src) = &e.node {\n-            if is_string(cx, target) && is_add(src, target) { \n-                span_lint(cx, STRING_ADD_ASSIGN, e.span, \n+            if is_string(cx, target) && is_add(src, target) {\n+                span_lint(cx, STRING_ADD_ASSIGN, e.span,\n                     \"You assign the result of adding something to this string. \\\n                     Consider using `String::push_str(..) instead.\")\n             }\n@@ -47,7 +47,7 @@ fn is_add(src: &Expr, target: &Expr) -> bool {\n     match &src.node {\n         &ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) =>\n             is_exp_equal(target, left),\n-        &ExprBlock(ref block) => block.stmts.is_empty() && \n+        &ExprBlock(ref block) => block.stmts.is_empty() &&\n             block.expr.as_ref().map_or(false, |expr| is_add(&*expr, target)),\n         &ExprParen(ref expr) => is_add(&*expr, target),\n         _ => false"}, {"sha": "1854d5be7ff203060087913d2db2e0794b220824", "filename": "src/unicode.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funicode.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -9,38 +9,38 @@ declare_lint!{ pub ZERO_WIDTH_SPACE, Deny, \"Zero-width space is confusing\" }\n pub struct Unicode;\n \n impl LintPass for Unicode {\n-\tfn get_lints(&self) -> LintArray {\n+    fn get_lints(&self) -> LintArray {\n         lint_array!(ZERO_WIDTH_SPACE)\n     }\n-    \n+\n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-\t\tif let ExprLit(ref lit) = expr.node {\n-\t\t\tif let LitStr(ref string, _) = lit.node {\n-\t\t\t\tcheck_str(cx, string, lit.span)\n-\t\t\t}\n-\t\t}\n-\t}\n+        if let ExprLit(ref lit) = expr.node {\n+            if let LitStr(ref string, _) = lit.node {\n+                check_str(cx, string, lit.span)\n+            }\n+        }\n+    }\n }\n \n fn check_str(cx: &Context, string: &str, span: Span) {\n-\tlet mut start: Option<usize> = None;\n-\tfor (i, c) in string.char_indices() {\n-\t\tif c == '\\u{200B}' {\n-\t\t\tif start.is_none() { start = Some(i); }\n-\t\t} else {\n-\t\t\tlint_zero_width(cx, span, start);\n-\t\t\tstart = None;\n-\t\t}\n-\t}\n-\tlint_zero_width(cx, span, start);\n+    let mut start: Option<usize> = None;\n+    for (i, c) in string.char_indices() {\n+        if c == '\\u{200B}' {\n+            if start.is_none() { start = Some(i); }\n+        } else {\n+            lint_zero_width(cx, span, start);\n+            start = None;\n+        }\n+    }\n+    lint_zero_width(cx, span, start);\n }\n \n fn lint_zero_width(cx: &Context, span: Span, start: Option<usize>) {\n-\tstart.map(|index| {\n-\t\tspan_lint(cx, ZERO_WIDTH_SPACE, Span {\n-\t\t\tlo: span.lo + BytePos(index as u32),\n-\t\t\thi: span.lo + BytePos(index as u32),\n-\t\t\texpn_id: span.expn_id,\n-\t\t}, \"Zero-width space detected. Consider using \\\\u{200B}\")\n-\t});\n+    start.map(|index| {\n+        span_lint(cx, ZERO_WIDTH_SPACE, Span {\n+            lo: span.lo + BytePos(index as u32),\n+            hi: span.lo + BytePos(index as u32),\n+            expn_id: span.expn_id,\n+        }, \"Zero-width space detected. Consider using \\\\u{200B}\")\n+    });\n }"}, {"sha": "4f5763b149172a182dfc965b0e81d171a259d126", "filename": "src/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -15,7 +15,7 @@ pub fn in_macro(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n         // no span for the callee = external macro\n         info.callee.span.map_or(true, |span| {\n             // no snippet = external macro or compiler-builtin expansion\n-            cx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code| \n+            cx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code|\n                 // macro doesn't start with \"macro_rules\"\n                 // = compiler plugin\n                 !code.starts_with(\"macro_rules\")\n@@ -26,7 +26,7 @@ pub fn in_macro(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n \n /// invokes in_macro with the expansion info of the given span\n pub fn in_external_macro(cx: &Context, span: Span) -> bool {\n-    cx.sess().codemap().with_expn_info(span.expn_id, \n+    cx.sess().codemap().with_expn_info(span.expn_id,\n             |info| in_macro(cx, info))\n }\n \n@@ -57,7 +57,7 @@ pub fn get_parent_expr<'c>(cx: &'c Context, e: &Expr) -> Option<&'c Expr> {\n     let node_id : NodeId = e.id;\n     let parent_id : NodeId = map.get_parent_node(node_id);\n     if node_id == parent_id { return None; }\n-    map.find(parent_id).and_then(|node| \n+    map.find(parent_id).and_then(|node|\n         if let NodeExpr(parent) = node { Some(parent) } else { None } )\n }\n \n@@ -77,7 +77,7 @@ pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n     cx.span_lint(lint, sp, msg);\n }\n \n-pub fn span_help_and_lint(cx: &Context, lint: &'static Lint, span: Span, \n+pub fn span_help_and_lint(cx: &Context, lint: &'static Lint, span: Span,\n         msg: &str, help: &str) {\n     span_lint(cx, lint, span, msg);\n     if cx.current_level(lint) != Level::Allow {"}, {"sha": "3eb170b295be73eda724ad25de587b60c24897f9", "filename": "tests/compile-fail/approx_const.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fapprox_const.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -4,53 +4,53 @@\n #[deny(approx_constant)]\n #[allow(unused)]\n fn main() {\n-\tlet my_e = 2.7182; //~ERROR\n-\tlet almost_e = 2.718; //~ERROR\n-\tlet no_e = 2.71;\n-\t\n-\tlet my_1_frac_pi = 0.3183; //~ERROR\n-\tlet no_1_frac_pi = 0.31;\n-\n-\tlet my_frac_1_sqrt_2 = 0.70710678; //~ERROR\n-\tlet almost_frac_1_sqrt_2 = 0.70711; //~ERROR\n-\tlet my_frac_1_sqrt_2 = 0.707;\n-\t\n-\tlet my_frac_2_pi = 0.63661977; //~ERROR\n-\tlet no_frac_2_pi = 0.636;\n-\t\n-\tlet my_frac_2_sq_pi = 1.128379; //~ERROR\n-\tlet no_frac_2_sq_pi = 1.128;\n-\n-\tlet my_frac_2_pi = 1.57079632679; //~ERROR\n-\tlet no_frac_2_pi = 1.5705;\n-\t\n-\tlet my_frac_3_pi = 1.04719755119; //~ERROR\n-\tlet no_frac_3_pi = 1.047;\n-\t\n-\tlet my_frac_4_pi = 0.785398163397; //~ERROR\n-\tlet no_frac_4_pi = 0.785;\n-\n-\tlet my_frac_6_pi = 0.523598775598; //~ERROR\n-\tlet no_frac_6_pi = 0.523;\n-\n-\tlet my_frac_8_pi = 0.3926990816987; //~ERROR\n-\tlet no_frac_8_pi = 0.392;\n-\n-\tlet my_ln_10 = 2.302585092994046; //~ERROR\n-\tlet no_ln_10 = 2.303;\n-\t\n-\tlet my_ln_2 = 0.6931471805599453; //~ERROR\n-\tlet no_ln_2 = 0.693;\n-\n-\tlet my_log10_e = 0.43429448190325176; //~ERROR\n-\tlet no_log10_e = 0.434;\n-\t\n-\tlet my_log2_e = 1.4426950408889634; //~ERROR\n-\tlet no_log2_e = 1.442;\n-\t\n-\tlet my_pi = 3.1415; //~ERROR\n-\tlet almost_pi = 3.141;\n-\t\n-\tlet my_sq2 = 1.4142; //~ERROR\n-\tlet no_sq2 = 1.414;\n+    let my_e = 2.7182; //~ERROR\n+    let almost_e = 2.718; //~ERROR\n+    let no_e = 2.71;\n+\n+    let my_1_frac_pi = 0.3183; //~ERROR\n+    let no_1_frac_pi = 0.31;\n+\n+    let my_frac_1_sqrt_2 = 0.70710678; //~ERROR\n+    let almost_frac_1_sqrt_2 = 0.70711; //~ERROR\n+    let my_frac_1_sqrt_2 = 0.707;\n+\n+    let my_frac_2_pi = 0.63661977; //~ERROR\n+    let no_frac_2_pi = 0.636;\n+\n+    let my_frac_2_sq_pi = 1.128379; //~ERROR\n+    let no_frac_2_sq_pi = 1.128;\n+\n+    let my_frac_2_pi = 1.57079632679; //~ERROR\n+    let no_frac_2_pi = 1.5705;\n+\n+    let my_frac_3_pi = 1.04719755119; //~ERROR\n+    let no_frac_3_pi = 1.047;\n+\n+    let my_frac_4_pi = 0.785398163397; //~ERROR\n+    let no_frac_4_pi = 0.785;\n+\n+    let my_frac_6_pi = 0.523598775598; //~ERROR\n+    let no_frac_6_pi = 0.523;\n+\n+    let my_frac_8_pi = 0.3926990816987; //~ERROR\n+    let no_frac_8_pi = 0.392;\n+\n+    let my_ln_10 = 2.302585092994046; //~ERROR\n+    let no_ln_10 = 2.303;\n+\n+    let my_ln_2 = 0.6931471805599453; //~ERROR\n+    let no_ln_2 = 0.693;\n+\n+    let my_log10_e = 0.43429448190325176; //~ERROR\n+    let no_log10_e = 0.434;\n+\n+    let my_log2_e = 1.4426950408889634; //~ERROR\n+    let no_log2_e = 1.442;\n+\n+    let my_pi = 3.1415; //~ERROR\n+    let almost_pi = 3.141;\n+\n+    let my_sq2 = 1.4142; //~ERROR\n+    let no_sq2 = 1.414;\n }"}, {"sha": "42bb0fca6dc90417c7d9bfe37d8af068ed5873a0", "filename": "tests/compile-fail/attrs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fattrs.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -5,29 +5,29 @@\n \n #[inline(always)] //~ERROR You have declared #[inline(always)] on test_attr_lint.\n fn test_attr_lint() {\n-\tassert!(true)\n+    assert!(true)\n }\n \n #[inline(always)]\n fn false_positive_expr() {\n-\tunreachable!()\n+    unreachable!()\n }\n \n #[inline(always)]\n fn false_positive_stmt() {\n-\tunreachable!();\n+    unreachable!();\n }\n \n #[inline(always)]\n fn empty_and_false_positive_stmt() {\n-\t;\n-\tunreachable!();\n+    ;\n+    unreachable!();\n }\n \n \n fn main() {\n-\ttest_attr_lint();\n-\tif false { false_positive_expr() }\n-\tif false { false_positive_stmt() }\n-\tif false { empty_and_false_positive_stmt() }\n+    test_attr_lint();\n+    if false { false_positive_expr() }\n+    if false { false_positive_stmt() }\n+    if false { empty_and_false_positive_stmt() }\n }"}, {"sha": "c2a8248300508f050e520c7f3b6a42fa3710a71d", "filename": "tests/compile-fail/bit_masks.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fbit_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fbit_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbit_masks.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -7,47 +7,47 @@ const EVEN_MORE_REDIRECTION : i64 = THREE_BITS;\n #[deny(bad_bit_mask)]\n #[allow(ineffective_bit_mask, identity_op)]\n fn main() {\n-\tlet x = 5;\n-\t\n-\tx & 0 == 0; //~ERROR &-masking with zero\n-\tx & 1 == 1; //ok, distinguishes bit 0\n-\tx & 1 == 0; //ok, compared with zero\n-\tx & 2 == 1; //~ERROR\n-\tx | 0 == 0; //ok, equals x == 0 (maybe warn?)\n-\tx | 1 == 3; //ok, equals x == 2 || x == 3\n-\tx | 3 == 3; //ok, equals x <= 3\n-\tx | 3 == 2; //~ERROR\n-\n-\tx & 1 > 1; //~ERROR\n-\tx & 2 > 1; // ok, distinguishes x & 2 == 2 from x & 2 == 0\n-\tx & 2 < 1; // ok, distinguishes x & 2 == 2 from x & 2 == 0\n-\tx | 1 > 1; // ok (if a bit silly), equals x > 1\n-\tx | 2 > 1; //~ERROR\n-\tx | 2 <= 2; // ok (if a bit silly), equals x <= 2\n-\t\n-\t// this also now works with constants\n-\tx & THREE_BITS == 8; //~ERROR\n-\tx | EVEN_MORE_REDIRECTION < 7; //~ERROR\n-\t\n-\t0 & x == 0; //~ERROR\n-\t1 | x > 1;\n-\t\n-\t// and should now also match uncommon usage\n-\t1 < 2 | x; //~ERROR\n-\t2 == 3 | x; //~ERROR\n-\t1 == x & 2; //~ERROR\n-\t\n-\tx | 1 > 2; // no error, because we allowed ineffective bit masks\n-\tineffective();\n+    let x = 5;\n+\n+    x & 0 == 0; //~ERROR &-masking with zero\n+    x & 1 == 1; //ok, distinguishes bit 0\n+    x & 1 == 0; //ok, compared with zero\n+    x & 2 == 1; //~ERROR\n+    x | 0 == 0; //ok, equals x == 0 (maybe warn?)\n+    x | 1 == 3; //ok, equals x == 2 || x == 3\n+    x | 3 == 3; //ok, equals x <= 3\n+    x | 3 == 2; //~ERROR\n+\n+    x & 1 > 1; //~ERROR\n+    x & 2 > 1; // ok, distinguishes x & 2 == 2 from x & 2 == 0\n+    x & 2 < 1; // ok, distinguishes x & 2 == 2 from x & 2 == 0\n+    x | 1 > 1; // ok (if a bit silly), equals x > 1\n+    x | 2 > 1; //~ERROR\n+    x | 2 <= 2; // ok (if a bit silly), equals x <= 2\n+\n+    // this also now works with constants\n+    x & THREE_BITS == 8; //~ERROR\n+    x | EVEN_MORE_REDIRECTION < 7; //~ERROR\n+\n+    0 & x == 0; //~ERROR\n+    1 | x > 1;\n+\n+    // and should now also match uncommon usage\n+    1 < 2 | x; //~ERROR\n+    2 == 3 | x; //~ERROR\n+    1 == x & 2; //~ERROR\n+\n+    x | 1 > 2; // no error, because we allowed ineffective bit masks\n+    ineffective();\n }\n \n #[deny(ineffective_bit_mask)]\n #[allow(bad_bit_mask)]\n fn ineffective() {\n-\tlet x = 5;\n-\t\n-\tx | 1 > 2; //~ERROR\n-\tx | 1 < 3; //~ERROR\n-\tx | 1 <= 3; //~ERROR\n-\tx | 1 >= 2; //~ERROR\n+    let x = 5;\n+\n+    x | 1 > 2; //~ERROR\n+    x | 1 < 3; //~ERROR\n+    x | 1 <= 3; //~ERROR\n+    x | 1 >= 2; //~ERROR\n }"}, {"sha": "7d80dd86d226cc72fef8ccb39d49edb6aadbf30e", "filename": "tests/compile-fail/box_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fbox_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fbox_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbox_vec.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -8,7 +8,7 @@ pub fn test(foo: Box<Vec<bool>>) { //~ ERROR You seem to be trying to use Box<Ve\n }\n \n pub fn test2(foo: Box<Fn(Vec<u32>)>) { // pass if #31 is fixed\n-\tfoo(vec![1, 2, 3])\n+    foo(vec![1, 2, 3])\n }\n \n fn main(){"}, {"sha": "b6549c2c1fb0909d64815f5155b1648fe044c56e", "filename": "tests/compile-fail/cmp_nan.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fcmp_nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fcmp_nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcmp_nan.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -4,19 +4,19 @@\n #[deny(cmp_nan)]\n #[allow(float_cmp)]\n fn main() {\n-\tlet x = 5f32;\n-\tx == std::f32::NAN; //~ERROR\n-\tx != std::f32::NAN; //~ERROR\n-\tx < std::f32::NAN; //~ERROR\t\n-\tx > std::f32::NAN; //~ERROR\n-\tx <= std::f32::NAN; //~ERROR\n-\tx >= std::f32::NAN; //~ERROR\n+    let x = 5f32;\n+    x == std::f32::NAN; //~ERROR\n+    x != std::f32::NAN; //~ERROR\n+    x < std::f32::NAN; //~ERROR\n+    x > std::f32::NAN; //~ERROR\n+    x <= std::f32::NAN; //~ERROR\n+    x >= std::f32::NAN; //~ERROR\n \n-\tlet y = 0f64;\n-\ty == std::f64::NAN; //~ERROR\n-\ty != std::f64::NAN; //~ERROR\n-\ty < std::f64::NAN; //~ERROR\n-\ty > std::f64::NAN; //~ERROR\n-\ty <= std::f64::NAN; //~ERROR\n-\ty >= std::f64::NAN; //~ERROR\n+    let y = 0f64;\n+    y == std::f64::NAN; //~ERROR\n+    y != std::f64::NAN; //~ERROR\n+    y < std::f64::NAN; //~ERROR\n+    y > std::f64::NAN; //~ERROR\n+    y <= std::f64::NAN; //~ERROR\n+    y >= std::f64::NAN; //~ERROR\n }"}, {"sha": "5951dc1bbd74e11b4b3add9a0915f1eb2b6aac49", "filename": "tests/compile-fail/cmp_owned.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fcmp_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fcmp_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcmp_owned.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -3,21 +3,21 @@\n \n #[deny(cmp_owned)]\n fn main() {\n-\tlet x = \"oh\";\n-\t\n-\t#[allow(str_to_string)]\n-\tfn with_to_string(x : &str) {\n-\t\tx != \"foo\".to_string(); //~ERROR this creates an owned instance\n-\t}\n-\twith_to_string(x);\n-\t\n-\tx != \"foo\".to_owned(); //~ERROR this creates an owned instance\n-\t\n-\t#[allow(deprecated)] // for from_str\n-\tfn old_timey(x : &str) {\n-\t\tx != String::from_str(\"foo\"); //~ERROR this creates an owned instance\n-\t}\n-\told_timey(x);\n-\t\n-\tx != String::from(\"foo\"); //~ERROR this creates an owned instance\n+    let x = \"oh\";\n+\n+    #[allow(str_to_string)]\n+    fn with_to_string(x : &str) {\n+        x != \"foo\".to_string(); //~ERROR this creates an owned instance\n+    }\n+    with_to_string(x);\n+\n+    x != \"foo\".to_owned(); //~ERROR this creates an owned instance\n+\n+    #[allow(deprecated)] // for from_str\n+    fn old_timey(x : &str) {\n+        x != String::from_str(\"foo\"); //~ERROR this creates an owned instance\n+    }\n+    old_timey(x);\n+\n+    x != String::from(\"foo\"); //~ERROR this creates an owned instance\n }"}, {"sha": "280744b5b45c2d98919262cdb5f4b78d78cd6604", "filename": "tests/compile-fail/collapsible_if.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcollapsible_if.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -34,10 +34,10 @@ fn main() {\n         }\n     }\n \n-\tif x == \"hello\" {\n-\t\tprint!(\"Hello \");\n-\t\tif y == \"world\" {\n-\t\t\tprintln!(\"world!\")\n-\t\t}\n-\t}\n+    if x == \"hello\" {\n+        print!(\"Hello \");\n+        if y == \"world\" {\n+            println!(\"world!\")\n+        }\n+    }\n }"}, {"sha": "45fce0c0bb347c9123ffc24154643b6ffc43b9f4", "filename": "tests/compile-fail/eq_op.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Feq_op.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -2,35 +2,35 @@\n #![plugin(clippy)]\n \n fn id<X>(x: X) -> X {\n-\tx\n+    x\n }\n \n #[deny(eq_op)]\n #[allow(identity_op)]\n fn main() {\n-\t// simple values and comparisons\n-\t1 == 1; //~ERROR\n-\t\"no\" == \"no\"; //~ERROR \n-\t// even though I agree that no means no ;-)\n-\tfalse != false; //~ERROR\n-\t1.5 < 1.5; //~ERROR\n-\t1u64 >= 1u64; //~ERROR\n-\t\n-\t// casts, methods, parenthesis\n-\t(1 as u64) & (1 as u64); //~ERROR\n-\t1 ^ ((((((1)))))); //~ERROR\n-\tid((1)) | id(1); //~ERROR\n-\t\n-\t// unary and binary operators\n-\t(-(2) < -(2));  //~ERROR\n+    // simple values and comparisons\n+    1 == 1; //~ERROR\n+    \"no\" == \"no\"; //~ERROR\n+    // even though I agree that no means no ;-)\n+    false != false; //~ERROR\n+    1.5 < 1.5; //~ERROR\n+    1u64 >= 1u64; //~ERROR\n+\n+    // casts, methods, parenthesis\n+    (1 as u64) & (1 as u64); //~ERROR\n+    1 ^ ((((((1)))))); //~ERROR\n+    id((1)) | id(1); //~ERROR\n+\n+    // unary and binary operators\n+    (-(2) < -(2));  //~ERROR\n     ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n           //~^ ERROR\n                     //~^^ ERROR\n                                //~^^^ ERROR\n-\t(1 * 2) + (3 * 4) == 1 * 2 + 3 * 4; //~ERROR\n-\t\n-\t// various other things\n-\t([1] != [1]); //~ERROR\n+    (1 * 2) + (3 * 4) == 1 * 2 + 3 * 4; //~ERROR\n+\n+    // various other things\n+    ([1] != [1]); //~ERROR\n     ((1, 2) != (1, 2)); //~ERROR\n     [1].len() == [1].len(); //~ERROR\n     vec![1, 2, 3] == vec![1, 2, 3]; //no error yet, as we don't match macros"}, {"sha": "2305e42161a705ea15f977021ac91ec8f2362bbc", "filename": "tests/compile-fail/float_cmp.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Ffloat_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Ffloat_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffloat_cmp.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -7,29 +7,29 @@ const ZERO : f32 = 0.0;\n const ONE : f32 = ZERO + 1.0;\n \n fn twice<T>(x : T) -> T where T : Add<T, Output = T>, T : Copy {\n-\tx + x\n+    x + x\n }\n \n #[deny(float_cmp)]\n #[allow(unused)]\n fn main() {\n-\tZERO == 0f32; //~ERROR\n-\tZERO == 0.0; //~ERROR\n-\tZERO + ZERO != 1.0; //~ERROR\n-\t\n-\tONE != 0.0; //~ERROR\n-\ttwice(ONE) != ONE; //~ERROR\n-\tONE as f64 != 0.0; //~ERROR\n-\t\n-\tlet x : f64 = 1.0;\n-\t\n-\tx == 1.0; //~ERROR\n-\tx != 0f64; //~ERROR\n-\t\n-\ttwice(x) != twice(ONE as f64); //~ERROR\n-\t\n-\tx < 0.0;\n-\tx > 0.0;\n-\tx <= 0.0;\n-\tx >= 0.0;\t\n+    ZERO == 0f32; //~ERROR\n+    ZERO == 0.0; //~ERROR\n+    ZERO + ZERO != 1.0; //~ERROR\n+\n+    ONE != 0.0; //~ERROR\n+    twice(ONE) != ONE; //~ERROR\n+    ONE as f64 != 0.0; //~ERROR\n+\n+    let x : f64 = 1.0;\n+\n+    x == 1.0; //~ERROR\n+    x != 0f64; //~ERROR\n+\n+    twice(x) != twice(ONE as f64); //~ERROR\n+\n+    x < 0.0;\n+    x > 0.0;\n+    x <= 0.0;\n+    x >= 0.0;\n }"}, {"sha": "cde4a615b2576be6c9b70cf41b26085cc3b977a4", "filename": "tests/compile-fail/identity_op.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fidentity_op.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -7,18 +7,18 @@ const ZERO : i64 = 0;\n \n #[deny(identity_op)]\n fn main() {\n-\tlet x = 0;\n-\t\n-\tx + 0; //~ERROR\n-\t0 + x; //~ERROR\n-\tx - ZERO; //~ERROR\n-\tx | (0); //~ERROR\n-\t((ZERO)) | x; //~ERROR\n-\t\t\n-\tx * 1; //~ERROR\n-\t1 * x; //~ERROR\n-\tx / ONE; //~ERROR\n-\t\n-\tx & NEG_ONE; //~ERROR\n-\t-1 & x; //~ERROR\n+    let x = 0;\n+\n+    x + 0; //~ERROR\n+    0 + x; //~ERROR\n+    x - ZERO; //~ERROR\n+    x | (0); //~ERROR\n+    ((ZERO)) | x; //~ERROR\n+\n+    x * 1; //~ERROR\n+    1 * x; //~ERROR\n+    x / ONE; //~ERROR\n+\n+    x & NEG_ONE; //~ERROR\n+    -1 & x; //~ERROR\n }"}, {"sha": "48a10042658741ea8e2eebb1703a0429eb2412fa", "filename": "tests/compile-fail/len_zero.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flen_zero.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -5,98 +5,98 @@ struct One;\n \n #[deny(len_without_is_empty)]\n impl One {\n-\tfn len(self: &Self) -> isize { //~ERROR Item 'One' has a '.len(_: &Self)'\n-\t\t1\n-\t}\n+    fn len(self: &Self) -> isize { //~ERROR Item 'One' has a '.len(_: &Self)'\n+        1\n+    }\n }\n \n #[deny(len_without_is_empty)]\n trait TraitsToo {\n-\tfn len(self: &Self) -> isize; //~ERROR Trait 'TraitsToo' has a '.len(_:\n+    fn len(self: &Self) -> isize; //~ERROR Trait 'TraitsToo' has a '.len(_:\n }\n \n impl TraitsToo for One {\n-\tfn len(self: &Self) -> isize {\n-\t\t0\n-\t}\n+    fn len(self: &Self) -> isize {\n+        0\n+    }\n }\n \n struct HasIsEmpty;\n \n #[deny(len_without_is_empty)]\n impl HasIsEmpty {\n-\tfn len(self: &Self) -> isize {\n-\t\t1\n-\t}\n+    fn len(self: &Self) -> isize {\n+        1\n+    }\n \n-\tfn is_empty(self: &Self) -> bool {\n-\t\tfalse\n-\t}\n+    fn is_empty(self: &Self) -> bool {\n+        false\n+    }\n }\n \n struct Wither;\n \n #[deny(len_without_is_empty)]\n trait WithIsEmpty {\n-\tfn len(self: &Self) -> isize;\n-\tfn is_empty(self: &Self) -> bool;\n+    fn len(self: &Self) -> isize;\n+    fn is_empty(self: &Self) -> bool;\n }\n \n impl WithIsEmpty for Wither {\n-\tfn len(self: &Self) -> isize {\n-\t\t1\n-\t}\n+    fn len(self: &Self) -> isize {\n+        1\n+    }\n \n-\tfn is_empty(self: &Self) -> bool {\n-\t\tfalse\n-\t}\n+    fn is_empty(self: &Self) -> bool {\n+        false\n+    }\n }\n \n struct HasWrongIsEmpty;\n \n #[deny(len_without_is_empty)]\n impl HasWrongIsEmpty {\n-\tfn len(self: &Self) -> isize { //~ERROR Item 'HasWrongIsEmpty' has a '.len(_: &Self)'\n-\t\t1\n-\t}\n-\t\n-\t#[allow(dead_code, unused)]\n-\tfn is_empty(self: &Self, x : u32) -> bool {\n-\t\tfalse\n-\t}\n+    fn len(self: &Self) -> isize { //~ERROR Item 'HasWrongIsEmpty' has a '.len(_: &Self)'\n+        1\n+    }\n+\n+    #[allow(dead_code, unused)]\n+    fn is_empty(self: &Self, x : u32) -> bool {\n+        false\n+    }\n }\n \n #[deny(len_zero)]\n fn main() {\n-\tlet x = [1, 2];\n-\tif x.len() == 0 { //~ERROR Consider replacing the len comparison\n-\t\tprintln!(\"This should not happen!\");\n-\t}\n-\t\n-\tlet y = One;\n-\tif y.len()  == 0 { //no error because One does not have .is_empty()\n-\t\tprintln!(\"This should not happen either!\");\n-\t}\n-\t\n-\tlet z : &TraitsToo = &y;\n-\tif z.len() > 0 { //no error, because TraitsToo has no .is_empty() method\n-\t\tprintln!(\"Nor should this!\");\n-\t}\n-\t\n-\tlet hie = HasIsEmpty;\n-\tif hie.len() == 0 { //~ERROR Consider replacing the len comparison\n-\t\tprintln!(\"Or this!\");\n-\t}\n-\tassert!(!hie.is_empty());\n-\t\n-\tlet wie : &WithIsEmpty = &Wither;\n-\tif wie.len() == 0 { //~ERROR Consider replacing the len comparison\n-\t\tprintln!(\"Or this!\");\n-\t}\n-\tassert!(!wie.is_empty());\n-\t\n-\tlet hwie = HasWrongIsEmpty;\n-\tif hwie.len() == 0 { //no error as HasWrongIsEmpty does not have .is_empty()\n-\t\tprintln!(\"Or this!\");\n-\t}\n+    let x = [1, 2];\n+    if x.len() == 0 { //~ERROR Consider replacing the len comparison\n+        println!(\"This should not happen!\");\n+    }\n+\n+    let y = One;\n+    if y.len()  == 0 { //no error because One does not have .is_empty()\n+        println!(\"This should not happen either!\");\n+    }\n+\n+    let z : &TraitsToo = &y;\n+    if z.len() > 0 { //no error, because TraitsToo has no .is_empty() method\n+        println!(\"Nor should this!\");\n+    }\n+\n+    let hie = HasIsEmpty;\n+    if hie.len() == 0 { //~ERROR Consider replacing the len comparison\n+        println!(\"Or this!\");\n+    }\n+    assert!(!hie.is_empty());\n+\n+    let wie : &WithIsEmpty = &Wither;\n+    if wie.len() == 0 { //~ERROR Consider replacing the len comparison\n+        println!(\"Or this!\");\n+    }\n+    assert!(!wie.is_empty());\n+\n+    let hwie = HasWrongIsEmpty;\n+    if hwie.len() == 0 { //no error as HasWrongIsEmpty does not have .is_empty()\n+        println!(\"Or this!\");\n+    }\n }"}, {"sha": "2a3f7e3958c1f8c39cab0b576dffd93fe718e299", "filename": "tests/compile-fail/mut_mut.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmut_mut.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -6,29 +6,29 @@\n \n #[deny(mut_mut)]\n fn fun(x : &mut &mut u32) -> bool { //~ERROR\n-\t**x > 0\n+    **x > 0\n }\n \n macro_rules! mut_ptr {\n-\t($p:expr) => { &mut $p }\n-} \n+    ($p:expr) => { &mut $p }\n+}\n \n #[deny(mut_mut)]\n #[allow(unused_mut, unused_variables)]\n fn main() {\n-\tlet mut x = &mut &mut 1u32; //~ERROR\n-\t{\n-\t\tlet mut y = &mut x; //~ERROR\n-\t}\n-\t\n-\tif fun(x) {\n-\t\tlet y : &mut &mut &mut u32 = &mut &mut &mut 2; \n-\t\t\t //~^ ERROR\n-                  //~^^ ERROR\n-                                  //~^^^ ERROR\n-\t\t\t\t\t\t\t\t\t   //~^^^^ ERROR\n-\t\t***y + **x;\n-\t}\n-\t\n-\tlet mut z = mut_ptr!(&mut 3u32); //~ERROR\n+    let mut x = &mut &mut 1u32; //~ERROR\n+    {\n+        let mut y = &mut x; //~ERROR\n+    }\n+\n+    if fun(x) {\n+        let y : &mut &mut &mut u32 = &mut &mut &mut 2;\n+                 //~^ ERROR\n+                      //~^^ ERROR\n+                                      //~^^^ ERROR\n+                                           //~^^^^ ERROR\n+        ***y + **x;\n+    }\n+\n+    let mut z = mut_ptr!(&mut 3u32); //~ERROR\n }"}, {"sha": "88919f39d6d405ac441205994c6c851145c65a90", "filename": "tests/compile-fail/needless_bool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fneedless_bool.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -3,10 +3,10 @@\n \n #[deny(needless_bool)]\n fn main() {\n-\tlet x = true;\n-\tif x { true } else { true }; //~ERROR \n-\tif x { false } else { false }; //~ERROR\n-\tif x { true } else { false }; //~ERROR\n-\tif x { false } else { true }; //~ERROR\n-\tif x { x } else { false }; // would also be questionable, but we don't catch this yet\n+    let x = true;\n+    if x { true } else { true }; //~ERROR\n+    if x { false } else { false }; //~ERROR\n+    if x { true } else { false }; //~ERROR\n+    if x { false } else { true }; //~ERROR\n+    if x { x } else { false }; // would also be questionable, but we don't catch this yet\n }"}, {"sha": "fb7d06214a2e22afe8cd2fe636458179b103e63b", "filename": "tests/compile-fail/precedence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fprecedence.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -4,7 +4,7 @@\n #[deny(precedence)]\n #[allow(eq_op)]\n fn main() {\n-\tformat!(\"{} vs. {}\", 1 << 2 + 3, (1 << 2) + 3); //~ERROR\n+    format!(\"{} vs. {}\", 1 << 2 + 3, (1 << 2) + 3); //~ERROR\n     format!(\"{} vs. {}\", 1 + 2 << 3, 1 + (2 << 3)); //~ERROR\n     format!(\"{} vs. {}\", 4 >> 1 + 1, (4 >> 1) + 1); //~ERROR\n     format!(\"{} vs. {}\", 1 + 3 >> 2, 1 + (3 >> 2)); //~ERROR"}, {"sha": "7ba291b1439098d2ee7796f64e5bdb87127d3e9d", "filename": "tests/compile-fail/ptr_arg.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_arg.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -4,17 +4,17 @@\n #[deny(ptr_arg)]\n #[allow(unused)]\n fn do_vec(x: &Vec<i64>) { //~ERROR: Writing '&Vec<_>' instead of '&[_]'\n-\t//Nothing here\n+    //Nothing here\n }\n \n #[deny(ptr_arg)]\n #[allow(unused)]\n fn do_str(x: &String) { //~ERROR\n-\t//Nothing here either\n+    //Nothing here either\n }\n \n fn main() {\n-\tlet x = vec![1i64, 2, 3];\n-\tdo_vec(&x);\n-\tdo_str(&\"hello\".to_owned());\n+    let x = vec![1i64, 2, 3];\n+    do_vec(&x);\n+    do_str(&\"hello\".to_owned());\n }"}, {"sha": "4b6f0bc884f6b9dfa4f3ff3d1b396931d7ba6237", "filename": "tests/compile-fail/strings.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstrings.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -4,9 +4,9 @@\n #![deny(string_add_assign)]\n \n fn main() {\n-\tlet x = \"\".to_owned();\n-\t\n-\tfor i in (1..3) {\n-\t\tx = x + \".\"; //~ERROR\n-\t}\n+    let x = \"\".to_owned();\n+\n+    for i in (1..3) {\n+        x = x + \".\"; //~ERROR\n+    }\n }"}, {"sha": "a121b985f09f8b2a7fd407076e476ac0962db6c8", "filename": "tests/compile-fail/unicode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-fail%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funicode.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -3,23 +3,23 @@\n \n #[deny(zero_width_space)]\n fn zero() {\n-\tprint!(\"Here >\u200b< is a ZWS, and \u200banother\"); \n-\t\t\t\t//~^ ERROR Zero-width space detected. Consider using \\u{200B}\n-\t\t\t\t\t\t\t\t//~^^ ERROR Zero-width space detected. Consider using \\u{200B}\n+    print!(\"Here >\u200b< is a ZWS, and \u200banother\");\n+                            //~^ ERROR Zero-width space detected. Consider using \\u{200B}\n+                              //~^^ ERROR Zero-width space detected. Consider using \\u{200B}\n }\n \n //#[deny(unicode_canon)]\n fn canon() {\n-\tprint!(\"\u0300ah?\"); //not yet ~ERROR Non-canonical unicode sequence detected. Consider using \u00e0\n+    print!(\"\u0300ah?\"); //not yet ~ERROR Non-canonical unicode sequence detected. Consider using \u00e0\n }\n \n //#[deny(ascii_only)]\n fn uni() {\n-\tprintln!(\"\u00dcben!\"); //not yet ~ERROR Unicode literal detected. Consider using \\u{FC}\n+    println!(\"\u00dcben!\"); //not yet ~ERROR Unicode literal detected. Consider using \\u{FC}\n }\n \n fn main() {\n-\tzero();\n-\tuni();\n-\tcanon();\n+    zero();\n+    uni();\n+    canon();\n }"}, {"sha": "602937a40afcf181d08048225b2891f6a9cc555b", "filename": "tests/compile-test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -5,13 +5,13 @@ use std::env::var;\n \n fn run_mode(mode: &'static str) {\n     let mut config = compiletest::default_config();\n-    \n+\n     let cfg_mode = mode.parse().ok().expect(\"Invalid mode\");\n     config.target_rustcflags = Some(\"-L target/debug/\".to_owned());\n-\tif let Ok(name) = var::<&str>(\"TESTNAME\") {\n-\t\tlet s : String = name.to_owned();\n-\t\tconfig.filter = Some(s)\n-\t}\n+    if let Ok(name) = var::<&str>(\"TESTNAME\") {\n+        let s : String = name.to_owned();\n+        config.filter = Some(s)\n+    }\n \n     config.mode = cfg_mode;\n     config.src_base = PathBuf::from(format!(\"tests/{}\", mode));"}, {"sha": "ebfd3ed2e1f64d4d850ab29edbdb3fff5f2e1f2b", "filename": "tests/mut_mut_macro.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fmut_mut_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cadd9bb954edf23dcfb7002f9174b61228de5010/tests%2Fmut_mut_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmut_mut_macro.rs?ref=cadd9bb954edf23dcfb7002f9174b61228de5010", "patch": "@@ -10,22 +10,22 @@ use std::collections::HashMap;\n #[test]\n #[deny(mut_mut)]\n fn test_regex() {\n-\tlet pattern = regex!(r\"^(?P<level>[#]+)\\s(?P<title>.+)$\");\n-\tassert!(pattern.is_match(\"# headline\"));\n+    let pattern = regex!(r\"^(?P<level>[#]+)\\s(?P<title>.+)$\");\n+    assert!(pattern.is_match(\"# headline\"));\n }\n \n #[test]\n #[deny(mut_mut)]\n #[allow(unused_variables, unused_mut)]\n fn test_lazy_static() {\n-\tlazy_static! {\n-\t\tstatic ref MUT_MAP : HashMap<usize, &'static str> = {\n-\t\t\tlet mut m = HashMap::new();\n-\t\t\tlet mut zero = &mut &mut \"zero\";\n-\t\t\tm.insert(0, \"zero\");\n-\t\t\tm\n-\t\t};\n-\t\tstatic ref MUT_COUNT : usize = MUT_MAP.len();\n-\t}\n-\tassert!(*MUT_COUNT == 1);\n+    lazy_static! {\n+        static ref MUT_MAP : HashMap<usize, &'static str> = {\n+            let mut m = HashMap::new();\n+            let mut zero = &mut &mut \"zero\";\n+            m.insert(0, \"zero\");\n+            m\n+        };\n+        static ref MUT_COUNT : usize = MUT_MAP.len();\n+    }\n+    assert!(*MUT_COUNT == 1);\n }"}]}