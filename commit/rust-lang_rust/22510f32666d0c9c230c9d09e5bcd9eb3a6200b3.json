{"sha": "22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNTEwZjMyNjY2ZDBjOWMyMzBjOWQwOWU1YmNkOWViM2E2MjAwYjM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-17T19:51:18Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-01T05:59:47Z"}, "message": "rustc: replace TyFnDef in MethodCallee with just the FnSig.", "tree": {"sha": "a3035d33e36fefda5f034f02c59376cb0bceb4db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3035d33e36fefda5f034f02c59376cb0bceb4db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "html_url": "https://github.com/rust-lang/rust/commit/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4988f07920324830558e79a1a5b3233511cfbd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4988f07920324830558e79a1a5b3233511cfbd9", "html_url": "https://github.com/rust-lang/rust/commit/b4988f07920324830558e79a1a5b3233511cfbd9"}], "stats": {"total": 223, "additions": 88, "deletions": 135}, "files": [{"sha": "63dc2e2d8e13f1fc8725c603221854ff4313f232", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Ad\n }\n \n impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n-impl_stable_hash_for!(struct ty::MethodCallee<'tcx> { def_id, ty, substs });\n+impl_stable_hash_for!(struct ty::MethodCallee<'tcx> { def_id, substs, sig });\n impl_stable_hash_for!(struct ty::UpvarId { var_id, closure_expr_id });\n impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n "}, {"sha": "e84265cb60f746cbd7df07df99c75aa46a1c4e9b", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -173,10 +173,10 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n-                let base_type = self.tables.method_map[&expr.id].ty;\n+                let method_sig = self.tables.method_map[&expr.id].sig;\n                 debug!(\"effect: method call case, base type is {:?}\",\n-                        base_type);\n-                if type_is_unsafe_function(base_type) {\n+                        method_sig);\n+                if method_sig.unsafety == hir::Unsafety::Unsafe {\n                     self.require_unsafe(expr.span,\n                                         \"invocation of unsafe method\")\n                 }"}, {"sha": "73598d0bb1a05e0acf26534fd8d74f0791f28076", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -751,11 +751,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         for &overloaded in autoderefs {\n             if let Some(method) = overloaded {\n-                // the method call infrastructure should have\n-                // replaced all late-bound regions with variables:\n-                let self_ty = method.ty.fn_sig().input(0);\n+                let self_ty = method.sig.inputs()[0];\n                 let self_ty = self.mc.infcx.resolve_type_vars_if_possible(&self_ty);\n-                let self_ty = self.tcx().no_late_bound_regions(&self_ty).unwrap();\n \n                 let (m, r) = match self_ty.sty {\n                     ty::TyRef(r, ref m) => (m.mutbl, r),"}, {"sha": "fd8ca332a644955419823ac403b2e22a8e329a4b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -1073,7 +1073,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           hir::ExprCall(ref f, ref args) => {\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n             let diverges = !self.tables.is_method_call(expr.id) &&\n-                self.tables.expr_ty_adjusted(&f).fn_ret().0.is_never();\n+                self.tables.expr_ty_adjusted(&f).fn_sig().output().0.is_never();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1084,9 +1084,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprMethodCall(.., ref args) => {\n-            let method_ty = self.tables.method_map[&expr.id].ty;\n+            let ret_ty = self.tables.method_map[&expr.id].sig.output();\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n-            let succ = if method_ty.fn_ret().0.is_never() {\n+            let succ = if ret_ty.is_never() {\n                 self.s.exit_ln\n             } else {\n                 succ"}, {"sha": "aa729c75796af40bafd1880826da29163d0cbfd3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -1250,13 +1250,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                    -> Ty<'tcx>\n     {\n         // When we process an overloaded `*` or `[]` etc, we often\n-        // need to extract the return type of the method. These method\n-        // types are generated by method resolution and always have\n-        // all late-bound regions fully instantiated, so we just want\n-        // to skip past the binder.\n-        let ret_ty = method.ty.fn_ret();\n-        let ret_ty = self.infcx.resolve_type_vars_if_possible(&ret_ty);\n-        self.tcx().no_late_bound_regions(&ret_ty).unwrap()\n+        // need to extract the return type of the method.\n+        let ret_ty = method.sig.output();\n+        self.infcx.resolve_type_vars_if_possible(&ret_ty)\n     }\n }\n "}, {"sha": "d138b306732caf13dd0446cac68ff5eeb04841fb", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -394,8 +394,12 @@ impl Variance {\n pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n     pub def_id: DefId,\n-    pub ty: Ty<'tcx>,\n-    pub substs: &'tcx Substs<'tcx>\n+    pub substs: &'tcx Substs<'tcx>,\n+\n+    /// Instantiated method signature, i.e. it has been substituted,\n+    /// normalized, and has had late-bound lifetimes replaced\n+    /// (with inference variables, during type-checking).\n+    pub sig: FnSig<'tcx>,\n }\n \n // Contains information needed to resolve types and (in the future) look up"}, {"sha": "df7c2e567f7e6011c8f47264e00f4346b7d5e1ad", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -1313,15 +1313,6 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Type accessors for substructures of types\n-    pub fn fn_args(&self) -> ty::Binder<&'tcx [Ty<'tcx>]> {\n-        self.fn_sig().inputs()\n-    }\n-\n-    pub fn fn_ret(&self) -> Binder<Ty<'tcx>> {\n-        self.fn_sig().output()\n-    }\n-\n     pub fn is_fn(&self) -> bool {\n         match self.sty {\n             TyFnDef(..) | TyFnPtr(_) => true,"}, {"sha": "d456bc3ded3907b03224c66c0436c848f2df1eff", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -201,13 +201,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 exit_block.unit()\n             }\n             ExprKind::Call { ty, fun, args } => {\n-                let diverges = match ty.sty {\n-                    ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n-                        // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-                        f.output().skip_binder().is_never()\n-                    }\n-                    _ => false\n-                };\n+                // FIXME(canndrew): This is_never should probably be an is_uninhabited\n+                let diverges = expr.ty.is_never();\n                 let intrinsic = match ty.sty {\n                     ty::TyFnDef(def_id, _, ref f) if\n                         f.abi() == Abi::RustIntrinsic ||"}, {"sha": "6428146525cd430c7e67d153db28fb2c0617487b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -18,6 +18,7 @@ use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::cast::CastKind as TyCastKind;\n+use rustc::ty::subst::Subst;\n use rustc::hir;\n use syntax::ptr::P;\n \n@@ -92,9 +93,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     let kind = if let Some(method) = overloaded {\n                         debug!(\"make_mirror: overloaded autoderef (method={:?})\", method);\n \n-                        // Method calls always have all late-bound regions\n-                        // fully instantiated.\n-                        ref_ty = cx.tcx.no_late_bound_regions(&method.ty.fn_ret()).unwrap();\n+                        ref_ty = method.sig.output();\n                         let (region, mutbl) = match ref_ty.sty {\n                             ty::TyRef(region, mt) => (region, mt.mutbl),\n                             _ => span_bug!(expr.span, \"autoderef returned bad type\"),\n@@ -265,14 +264,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n                 // rewrite f(u, v) into FnOnce::call_once(f, (u, v))\n \n+                let sig = method.sig;\n                 let method = method_callee(cx, expr, method);\n \n-                let sig = method.ty.fn_sig();\n-\n-                let sig = cx.tcx\n-                    .no_late_bound_regions(&sig)\n-                    .unwrap_or_else(|| span_bug!(expr.span, \"method call has late-bound regions\"));\n-\n                 assert_eq!(sig.inputs().len(), 2);\n \n                 let tupled_args = Expr {\n@@ -711,7 +705,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     Expr {\n         temp_lifetime: temp_lifetime,\n         temp_lifetime_was_shrunk: was_shrunk,\n-        ty: callee.ty,\n+        ty: cx.tcx.type_of(callee.def_id).subst(cx.tcx, callee.substs),\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: Literal::Value {\n@@ -1012,9 +1006,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n \n     // to find the type &T of the content returned by the method;\n-    let ref_ty = method.ty.fn_ret();\n-    let ref_ty = cx.tcx.no_late_bound_regions(&ref_ty).unwrap();\n-    // callees always have all late-bound regions fully instantiated,\n+    let ref_ty = method.sig.output();\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type"}, {"sha": "33f0b0282d173b878953ffe5dc2bf09aa840b453", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -619,7 +619,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Type check the path.\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n         // Replace constructor type with constructed type for tuple struct patterns.\n-        let pat_ty = tcx.no_late_bound_regions(&pat_ty.fn_ret()).expect(\"expected fn type\");\n+        let pat_ty = pat_ty.fn_sig().output();\n+        let pat_ty = tcx.no_late_bound_regions(&pat_ty).expect(\"expected fn type\");\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns."}, {"sha": "5302ba0029192bf220bd800e9fe8a2063ab73ed5", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -72,11 +72,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             Some(CallStep::Overloaded(method_callee)) => {\n-                self.confirm_overloaded_call(call_expr,\n-                                             callee_expr,\n-                                             arg_exprs,\n-                                             expected,\n-                                             method_callee)\n+                self.confirm_overloaded_call(call_expr, arg_exprs, expected, method_callee)\n             }\n         };\n \n@@ -152,7 +148,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     autoref,\n                     unsize: false\n                 },\n-                target: *method.ty.fn_sig().input(0).skip_binder()\n+                target: method.sig.inputs()[0]\n             });\n             CallStep::Overloaded(method)\n         })\n@@ -302,14 +298,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn confirm_overloaded_call(&self,\n                                call_expr: &hir::Expr,\n-                               callee_expr: &'gcx hir::Expr,\n                                arg_exprs: &'gcx [hir::Expr],\n                                expected: Expectation<'tcx>,\n                                method_callee: ty::MethodCallee<'tcx>)\n                                -> Ty<'tcx> {\n         let output_type = self.check_method_argument_types(call_expr.span,\n-                                                           method_callee.ty,\n-                                                           callee_expr,\n+                                                           Ok(method_callee),\n                                                            arg_exprs,\n                                                            TupleArgumentsFlag::TupleArguments,\n                                                            expected);\n@@ -349,9 +343,7 @@ impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n                 // can't because of the annoying need for a TypeTrace.\n                 // (This always bites me, should find a way to\n                 // refactor it.)\n-                let method_sig = fcx.tcx\n-                    .no_late_bound_regions(&method_callee.ty.fn_sig())\n-                    .unwrap();\n+                let method_sig = method_callee.sig;\n \n                 debug!(\"attempt_resolution: method_callee={:?}\", method_callee);\n "}, {"sha": "71bcff84cc2d6f1fa522eb5d5b99dec02d83a630", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -88,19 +88,20 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         debug!(\"all_substs={:?}\", all_substs);\n \n         // Create the final signature for the method, replacing late-bound regions.\n-        let (method_ty, method_predicates) = self.instantiate_method_sig(&pick, all_substs);\n+        let (method_sig, method_predicates) = self.instantiate_method_sig(&pick, all_substs);\n \n         // Unify the (adjusted) self type with what the method expects.\n-        self.unify_receivers(self_ty, method_ty.fn_sig().input(0).skip_binder());\n+        self.unify_receivers(self_ty, method_sig.inputs()[0]);\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n+        let method_ty = self.tcx.mk_fn_ptr(ty::Binder(method_sig));\n         self.add_obligations(method_ty, all_substs, &method_predicates);\n \n         // Create the final `MethodCallee`.\n         let callee = ty::MethodCallee {\n             def_id: pick.item.def_id,\n-            ty: method_ty,\n             substs: all_substs,\n+            sig: method_sig,\n         };\n \n         if let Some(hir::MutMutable) = pick.autoref {\n@@ -351,7 +352,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn instantiate_method_sig(&mut self,\n                               pick: &probe::Pick<'tcx>,\n                               all_substs: &'tcx Substs<'tcx>)\n-                              -> (Ty<'tcx>, ty::InstantiatedPredicates<'tcx>) {\n+                              -> (ty::FnSig<'tcx>, ty::InstantiatedPredicates<'tcx>) {\n         debug!(\"instantiate_method_sig(pick={:?}, all_substs={:?})\",\n                pick,\n                all_substs);\n@@ -382,8 +383,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         let method_sig = self.instantiate_type_scheme(self.span, all_substs, &method_sig);\n         debug!(\"type scheme substituted, method_sig={:?}\", method_sig);\n \n-        (self.tcx.mk_fn_def(def_id, all_substs, ty::Binder(method_sig)),\n-         method_predicates)\n+        (method_sig, method_predicates)\n     }\n \n     fn add_obligations(&mut self,\n@@ -508,11 +508,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         }) = self.tables.borrow_mut().adjustments.get_mut(&base_expr.id) {\n             debug!(\"convert_lvalue_op_to_mutable: converting autoref of {:?}\", target);\n \n-            // extract method return type, which will be &mut T;\n-            // all LB regions should have been instantiated during method lookup\n-            let method_sig = self.tcx.no_late_bound_regions(&method.ty.fn_sig()).unwrap();\n-\n-            *target = method_sig.inputs()[0];\n+            *target = method.sig.inputs()[0];\n             if let ty::TyRef(r_, mt) = target.sty {\n                 *r = r_;\n                 *mutbl = mt.mutbl;"}, {"sha": "dd58fdbf073ab0b46e29d2a7b21d9766a857a004", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -267,7 +267,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         obligations.push(traits::Obligation::new(cause, ty::Predicate::WellFormed(method_ty)));\n \n         let autoref = match (&original_method_ty.fn_sig().input(0).skip_binder().sty,\n-                                      &method_ty.fn_sig().input(0).skip_binder().sty) {\n+                             &fn_sig.inputs()[0].sty) {\n             (&ty::TyRef(..), &ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ })) => {\n                 // Trait method is fn(&self) or fn(&mut self), need an\n                 // autoref. Pull the region etc out of the type of first argument.\n@@ -281,8 +281,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let callee = ty::MethodCallee {\n             def_id: def_id,\n-            ty: method_ty,\n             substs: trait_ref.substs,\n+            sig: fn_sig,\n         };\n \n         debug!(\"callee = {:?}\", callee);"}, {"sha": "f8020794b98a3ae15955f2985c7422f23ca4b7dc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -2156,8 +2156,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         // extract method return type, which will be &T;\n         // all LB regions should have been instantiated during method lookup\n-        let ret_ty = method.ty.fn_ret();\n-        let ret_ty = self.tcx.no_late_bound_regions(&ret_ty).unwrap();\n+        let ret_ty = method.sig.output();\n \n         // method returns &T, but the type as visible to user is T, so deref\n         ret_ty.builtin_deref(true, NoPreference).unwrap()\n@@ -2246,7 +2245,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         autoref,\n                         unsize\n                     },\n-                    target: *method.ty.fn_sig().input(0).skip_binder()\n+                    target: method.sig.inputs()[0]\n                 });\n \n                 self.tables.borrow_mut().method_map.insert(expr.id, method);\n@@ -2321,13 +2320,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_method_argument_types(&self,\n                                    sp: Span,\n-                                   method_fn_ty: Ty<'tcx>,\n-                                   callee_expr: &'gcx hir::Expr,\n+                                   method: Result<ty::MethodCallee<'tcx>, ()>,\n                                    args_no_rcvr: &'gcx [hir::Expr],\n                                    tuple_arguments: TupleArgumentsFlag,\n                                    expected: Expectation<'tcx>)\n                                    -> Ty<'tcx> {\n-        if method_fn_ty.references_error() {\n+        let has_error = match method {\n+            Ok(method) => {\n+                method.substs.references_error() || method.sig.references_error()\n+            }\n+            Err(_) => true\n+        };\n+        if has_error {\n             let err_inputs = self.err_args(args_no_rcvr.len());\n \n             let err_inputs = match tuple_arguments {\n@@ -2337,27 +2341,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             self.check_argument_types(sp, &err_inputs[..], &[], args_no_rcvr,\n                                       false, tuple_arguments, None);\n-            self.tcx.types.err\n-        } else {\n-            match method_fn_ty.sty {\n-                ty::TyFnDef(def_id, .., ref fty) => {\n-                    // HACK(eddyb) ignore self in the definition (see above).\n-                    let expected_arg_tys = self.expected_inputs_for_expected_output(\n-                        sp,\n-                        expected,\n-                        fty.0.output(),\n-                        &fty.0.inputs()[1..]\n-                    );\n-                    self.check_argument_types(sp, &fty.0.inputs()[1..], &expected_arg_tys[..],\n-                                              args_no_rcvr, fty.0.variadic, tuple_arguments,\n-                                              self.tcx.hir.span_if_local(def_id));\n-                    fty.0.output()\n-                }\n-                _ => {\n-                    span_bug!(callee_expr.span, \"method without bare fn type\");\n-                }\n-            }\n+            return self.tcx.types.err;\n         }\n+\n+        let method = method.unwrap();\n+        // HACK(eddyb) ignore self in the definition (see above).\n+        let expected_arg_tys = self.expected_inputs_for_expected_output(\n+            sp,\n+            expected,\n+            method.sig.output(),\n+            &method.sig.inputs()[1..]\n+        );\n+        self.check_argument_types(sp, &method.sig.inputs()[1..], &expected_arg_tys[..],\n+                                  args_no_rcvr, method.sig.variadic, tuple_arguments,\n+                                  self.tcx.hir.span_if_local(method.def_id));\n+        method.sig.output()\n     }\n \n     /// Generic function that factors out common logic from function calls,\n@@ -2782,15 +2780,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let expr_t = self.structurally_resolved_type(expr.span, rcvr_t);\n \n         let tps = tps.iter().map(|ast_ty| self.to_ty(&ast_ty)).collect::<Vec<_>>();\n-        let fn_ty = match self.lookup_method(method_name.span,\n-                                             method_name.node,\n-                                             expr_t,\n-                                             tps,\n-                                             expr,\n-                                             rcvr) {\n+        let method = match self.lookup_method(method_name.span,\n+                                              method_name.node,\n+                                              expr_t,\n+                                              tps,\n+                                              expr,\n+                                              rcvr) {\n             Ok(method) => {\n                 self.tables.borrow_mut().method_map.insert(expr.id, method);\n-                method.ty\n+                Ok(method)\n             }\n             Err(error) => {\n                 if method_name.node != keywords::Invalid.name() {\n@@ -2801,18 +2799,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              error,\n                                              Some(args));\n                 }\n-                self.write_error(expr.id);\n-                self.tcx.types.err\n+                Err(())\n             }\n         };\n \n         // Call the generic checker.\n-        let ret_ty = self.check_method_argument_types(method_name.span, fn_ty,\n-                                                      expr, &args[1..],\n-                                                      DontTupleArguments,\n-                                                      expected);\n-\n-        ret_ty\n+        self.check_method_argument_types(method_name.span, method,\n+                                         &args[1..],\n+                                         DontTupleArguments,\n+                                         expected)\n     }\n \n     fn check_return_expr(&self, return_expr: &'gcx hir::Expr) {\n@@ -3465,7 +3460,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     autoref,\n                                     unsize: false\n                                 },\n-                                target: *method.ty.fn_sig().input(0).skip_binder()\n+                                target: method.sig.inputs()[0]\n                             });\n                             oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n                             self.tables.borrow_mut().method_map.insert(expr.id, method);"}, {"sha": "267b2b009786667cce1caae5b4d2159e62275201", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -419,14 +419,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         autoref,\n                         unsize: false\n                     },\n-                    target: *method.ty.fn_sig().input(0).skip_binder()\n+                    target: method.sig.inputs()[0]\n                 });\n                 self.tables.borrow_mut().method_map.insert(expr.id, method);\n \n-                // extract return type for method; all late bound regions\n-                // should have been instantiated by now\n-                let ret_ty = method.ty.fn_ret();\n-                Ok(self.tcx.no_late_bound_regions(&ret_ty).unwrap())\n+                Ok(method.sig.output())\n             }\n             None => {\n                 Err(())"}, {"sha": "9b609cac2fc68902e630282f84154a80fca4c860", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -538,8 +538,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             self.substs_wf_in_scope(origin, &callee.substs, expr.span, expr_region);\n-            self.type_must_outlive(infer::ExprTypeIsNotInScope(callee.ty, expr.span),\n-                                   callee.ty, expr_region);\n+            for &ty in callee.sig.inputs() {\n+                self.type_must_outlive(infer::ExprTypeIsNotInScope(ty, expr.span),\n+                                       ty, expr_region);\n+            }\n         }\n \n         // Check any autoderefs or autorefs that appear.\n@@ -692,9 +694,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                     Some(method) => {\n                         self.constrain_call(expr, Some(&base),\n                                             None::<hir::Expr>.iter(), true);\n-                        // late-bound regions in overloaded method calls are instantiated\n-                        let fn_ret = self.tcx.no_late_bound_regions(&method.ty.fn_ret());\n-                        fn_ret.unwrap()\n+                        method.sig.output()\n                     }\n                     None => self.resolve_node_type(base.id)\n                 };\n@@ -933,17 +933,14 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n                 // Treat overloaded autoderefs as if an AutoBorrow adjustment\n                 // was applied on the base type, as that is always the case.\n-                let fn_sig = method.ty.fn_sig();\n-                let fn_sig = // late-bound regions should have been instantiated\n-                    self.tcx.no_late_bound_regions(&fn_sig).unwrap();\n-                let self_ty = fn_sig.inputs()[0];\n+                let self_ty = method.sig.inputs()[0];\n                 let (m, r) = match self_ty.sty {\n                     ty::TyRef(r, ref m) => (m.mutbl, r),\n                     _ => {\n                         span_bug!(\n                             deref_expr.span,\n                             \"bad overloaded deref type {:?}\",\n-                            method.ty)\n+                            method.sig)\n                     }\n                 };\n \n@@ -958,7 +955,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 self.type_must_outlive(infer::CallRcvr(deref_expr.span),\n                                        self_ty, r_deref_expr);\n                 self.type_must_outlive(infer::CallReturn(deref_expr.span),\n-                                       fn_sig.output(), r_deref_expr);\n+                                       method.sig.output(), r_deref_expr);\n             }\n \n             {"}, {"sha": "455a8e1cf1610ec1a04f8a65b6da0d516ef989a0", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "patch": "@@ -340,8 +340,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                                 overloaded.map(|method| {\n                                     MethodCallee {\n                                         def_id: method.def_id,\n-                                        ty: self.resolve(&method.ty, &span),\n                                         substs: self.resolve(&method.substs, &span),\n+                                        sig: self.resolve(&method.sig, &span),\n                                     }\n                                 })\n                             }).collect(),\n@@ -368,8 +368,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             Some(method) => {\n                 Some(MethodCallee {\n                     def_id: method.def_id,\n-                    ty: self.resolve(&method.ty, &method_span),\n                     substs: self.resolve(&method.substs, &method_span),\n+                    sig: self.resolve(&method.sig, &method_span),\n                 })\n             }\n             None => None"}]}