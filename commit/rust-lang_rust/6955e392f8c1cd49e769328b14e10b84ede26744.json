{"sha": "6955e392f8c1cd49e769328b14e10b84ede26744", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NTVlMzkyZjhjMWNkNDllNzY5MzI4YjE0ZTEwYjg0ZWRlMjY3NDQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-16T16:40:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-17T09:53:22Z"}, "message": "remove old macro support", "tree": {"sha": "5eeb4f7f65dd5dcf8bb5c1e3b4ffe5f353b5659d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5eeb4f7f65dd5dcf8bb5c1e3b4ffe5f353b5659d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6955e392f8c1cd49e769328b14e10b84ede26744", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6955e392f8c1cd49e769328b14e10b84ede26744", "html_url": "https://github.com/rust-lang/rust/commit/6955e392f8c1cd49e769328b14e10b84ede26744", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6955e392f8c1cd49e769328b14e10b84ede26744/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee3cf6172b29a1dc0973800b5a4f97afa5eefd90", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee3cf6172b29a1dc0973800b5a4f97afa5eefd90", "html_url": "https://github.com/rust-lang/rust/commit/ee3cf6172b29a1dc0973800b5a4f97afa5eefd90"}], "stats": {"total": 356, "additions": 95, "deletions": 261}, "files": [{"sha": "c7bad7e2b4fc570c9609f946e1ec3e2d562fb2c5", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6955e392f8c1cd49e769328b14e10b84ede26744/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6955e392f8c1cd49e769328b14e10b84ede26744/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=6955e392f8c1cd49e769328b14e10b84ede26744", "patch": "@@ -4,12 +4,10 @@ use ra_syntax::{SyntaxNode, TreeArc, SourceFile};\n use ra_db::{SourceDatabase, salsa, FileId};\n \n use crate::{\n-    MacroCallId, HirFileId,\n-    SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n+    HirFileId, SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n     Function, FnSignature, ExprScopes, TypeAlias,\n     Struct, Enum, StructField,\n     Const, ConstSignature, Static,\n-    macros::MacroExpansion,\n     nameres::{Namespace, ImportSourceMap, RawItems, CrateDefMap},\n     ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, CallableDef, FnSig},\n     adt::{StructData, EnumData},\n@@ -23,9 +21,6 @@ pub trait PersistentHirDatabase: SourceDatabase + AsRef<HirInterner> {\n     #[salsa::invoke(HirFileId::hir_parse)]\n     fn hir_parse(&self, file_id: HirFileId) -> TreeArc<SourceFile>;\n \n-    #[salsa::invoke(crate::macros::expand_macro_invocation)]\n-    fn expand_macro_invocation(&self, invoc: MacroCallId) -> Option<Arc<MacroExpansion>>;\n-\n     #[salsa::invoke(crate::adt::StructData::struct_data_query)]\n     fn struct_data(&self, s: Struct) -> Arc<StructData>;\n "}, {"sha": "9596488d3f4694b8ab4acc5ac6f11a239d28d84c", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6955e392f8c1cd49e769328b14e10b84ede26744/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6955e392f8c1cd49e769328b14e10b84ede26744/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=6955e392f8c1cd49e769328b14e10b84ede26744", "patch": "@@ -89,17 +89,31 @@ impl HirFileId {\n     ) -> TreeArc<SourceFile> {\n         match file_id.0 {\n             HirFileIdRepr::File(file_id) => db.parse(file_id),\n-            HirFileIdRepr::Macro(m) => {\n-                if let Some(exp) = db.expand_macro_invocation(m) {\n-                    return exp.file();\n-                }\n+            HirFileIdRepr::Macro(macro_call_id) => {\n                 // returning an empty string looks fishy...\n-                SourceFile::parse(\"\")\n+                parse_macro(db, macro_call_id).unwrap_or_else(|| SourceFile::parse(\"\"))\n             }\n         }\n     }\n }\n \n+fn parse_macro(\n+    db: &impl PersistentHirDatabase,\n+    macro_call_id: MacroCallId,\n+) -> Option<TreeArc<SourceFile>> {\n+    let loc = macro_call_id.loc(db);\n+    let syntax = db.file_item(loc.source_item_id);\n+    let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n+    let (macro_arg, _) = macro_call.token_tree().and_then(mbe::ast_to_token_tree)?;\n+\n+    let def_map = db.crate_def_map(loc.module.krate);\n+    let (krate, macro_id) = def_map.resolve_macro(macro_call_id)?;\n+    let def_map = db.crate_def_map(krate);\n+    let macro_rules = &def_map[macro_id];\n+    let tt = macro_rules.expand(&macro_arg).ok()?;\n+    Some(mbe::token_tree_to_ast_item_list(&tt))\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n enum HirFileIdRepr {\n     File(FileId),\n@@ -373,7 +387,6 @@ impl SourceFileItems {\n impl std::ops::Index<SourceFileItemId> for SourceFileItems {\n     type Output = SyntaxNodePtr;\n     fn index(&self, idx: SourceFileItemId) -> &SyntaxNodePtr {\n-        eprintln!(\"invalid SourceFileItemId({:?}) for file({:?})\", idx, self.file_id);\n         &self.arena[idx]\n     }\n }"}, {"sha": "75c977d3284bc43a0127cd9fd5b237f95216ecca", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6955e392f8c1cd49e769328b14e10b84ede26744/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6955e392f8c1cd49e769328b14e10b84ede26744/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=6955e392f8c1cd49e769328b14e10b84ede26744", "patch": "@@ -24,7 +24,6 @@ mod path;\n pub mod source_binder;\n \n mod ids;\n-mod macros;\n mod name;\n mod nameres;\n mod adt;\n@@ -53,7 +52,6 @@ pub use self::{\n     path::{Path, PathKind},\n     name::Name,\n     ids::{HirFileId, MacroCallId, MacroCallLoc, HirInterner},\n-    macros::{MacroDef, MacroInput, MacroExpansion},\n     nameres::{PerNs, Namespace},\n     ty::{Ty, Substs, display::HirDisplay},\n     impl_block::{ImplBlock, ImplItem},"}, {"sha": "45128c7dfd54b0f615f6c2ed3e54750727a99a5d", "filename": "crates/ra_hir/src/macros.rs", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/ee3cf6172b29a1dc0973800b5a4f97afa5eefd90/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee3cf6172b29a1dc0973800b5a4f97afa5eefd90/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros.rs?ref=ee3cf6172b29a1dc0973800b5a4f97afa5eefd90", "patch": "@@ -1,135 +0,0 @@\n-/// Machinery for macro expansion.\n-///\n-/// One of the more complicated things about macros is managing the source code\n-/// that is produced after expansion. See `HirFileId` and `MacroCallId` for how\n-/// do we do that.\n-///\n-/// When the file-management question is resolved, all that is left is a\n-/// token-tree-to-token-tree transformation plus hygiene. We don't have either of\n-/// those yet, so all macros are string based at the moment!\n-use std::sync::Arc;\n-\n-use ra_syntax::{\n-    TextRange, TextUnit, SourceFile, AstNode, SyntaxNode, TreeArc, SyntaxNodePtr,\n-    ast,\n-};\n-\n-use crate::{MacroCallId, PersistentHirDatabase};\n-\n-// Hard-coded defs for now :-(\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum MacroDef {\n-    Vec,\n-}\n-\n-impl MacroDef {\n-    /// Expands macro call, returning the expansion and offset to be used to\n-    /// convert ranges between expansion and original source.\n-    pub fn ast_expand(macro_call: &ast::MacroCall) -> Option<(TextUnit, MacroExpansion)> {\n-        let (def, input) = MacroDef::from_call(macro_call)?;\n-        let exp = def.expand(input)?;\n-        let off = macro_call.token_tree()?.syntax().range().start();\n-        Some((off, exp))\n-    }\n-\n-    fn from_call(macro_call: &ast::MacroCall) -> Option<(MacroDef, MacroInput)> {\n-        let def = {\n-            let path = macro_call.path()?;\n-            let name_ref = path.segment()?.name_ref()?;\n-            if name_ref.text() == \"vec\" {\n-                MacroDef::Vec\n-            } else {\n-                return None;\n-            }\n-        };\n-\n-        let input = {\n-            let arg = macro_call.token_tree()?.syntax();\n-            MacroInput { text: arg.text().to_string() }\n-        };\n-        Some((def, input))\n-    }\n-\n-    fn expand(self, input: MacroInput) -> Option<MacroExpansion> {\n-        match self {\n-            MacroDef::Vec => self.expand_vec(input),\n-        }\n-    }\n-    fn expand_vec(self, input: MacroInput) -> Option<MacroExpansion> {\n-        let text = format!(r\"fn dummy() {{ {}; }}\", input.text);\n-        let file = SourceFile::parse(&text);\n-        let array_expr = file.syntax().descendants().find_map(ast::ArrayExpr::cast)?;\n-        let ptr = SyntaxNodePtr::new(array_expr.syntax());\n-        let src_range = TextRange::offset_len(0.into(), TextUnit::of_str(&input.text));\n-        let ranges_map = vec![(src_range, array_expr.syntax().range())];\n-        let res = MacroExpansion { text, ranges_map, ptr };\n-        Some(res)\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct MacroInput {\n-    // Should be token trees\n-    pub text: String,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct MacroExpansion {\n-    /// The result of macro expansion. Should be token tree as well.\n-    text: String,\n-    /// Correspondence between ranges in the original source code and ranges in\n-    /// the macro.\n-    ranges_map: Vec<(TextRange, TextRange)>,\n-    /// Implementation detail: internally, a macro is expanded to the whole file,\n-    /// even if it is an expression. This `ptr` selects the actual expansion from\n-    /// the expanded file.\n-    ptr: SyntaxNodePtr,\n-}\n-\n-impl MacroExpansion {\n-    // FIXME: does not really make sense, macro expansion is not necessary a\n-    // whole file. See `MacroExpansion::ptr` as well.\n-    pub(crate) fn file(&self) -> TreeArc<SourceFile> {\n-        SourceFile::parse(&self.text)\n-    }\n-\n-    pub fn syntax(&self) -> TreeArc<SyntaxNode> {\n-        self.ptr.to_node(&self.file()).to_owned()\n-    }\n-    /// Maps range in the source code to the range in the expanded code.\n-    pub fn map_range_forward(&self, src_range: TextRange) -> Option<TextRange> {\n-        for (s_range, t_range) in self.ranges_map.iter() {\n-            if src_range.is_subrange(&s_range) {\n-                let src_at_zero_range = src_range - src_range.start();\n-                let src_range_offset = src_range.start() - s_range.start();\n-                let src_range = src_at_zero_range + src_range_offset + t_range.start();\n-                return Some(src_range);\n-            }\n-        }\n-        None\n-    }\n-    /// Maps range in the expanded code to the range in the source code.\n-    pub fn map_range_back(&self, tgt_range: TextRange) -> Option<TextRange> {\n-        for (s_range, t_range) in self.ranges_map.iter() {\n-            if tgt_range.is_subrange(&t_range) {\n-                let tgt_at_zero_range = tgt_range - tgt_range.start();\n-                let tgt_range_offset = tgt_range.start() - t_range.start();\n-                let src_range = tgt_at_zero_range + tgt_range_offset + s_range.start();\n-                return Some(src_range);\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-pub(crate) fn expand_macro_invocation(\n-    db: &impl PersistentHirDatabase,\n-    invoc: MacroCallId,\n-) -> Option<Arc<MacroExpansion>> {\n-    let loc = invoc.loc(db);\n-    let syntax = db.file_item(loc.source_item_id);\n-    let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n-\n-    let (def, input) = MacroDef::from_call(macro_call)?;\n-    def.expand(input).map(Arc::new)\n-}"}, {"sha": "17602ee6b98130e2d2d46b6de20d0b9b7e140324", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6955e392f8c1cd49e769328b14e10b84ede26744/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6955e392f8c1cd49e769328b14e10b84ede26744/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=6955e392f8c1cd49e769328b14e10b84ede26744", "patch": "@@ -57,7 +57,7 @@ use test_utils::tested_by;\n use crate::{\n     ModuleDef, Name, Crate, Module, Problem,\n     PersistentHirDatabase, Path, PathKind, HirFileId,\n-    ids::{SourceItemId, SourceFileItemId},\n+    ids::{SourceItemId, SourceFileItemId, MacroCallId},\n };\n \n pub(crate) use self::raw::{RawItems, ImportId, ImportSourceMap};\n@@ -76,7 +76,9 @@ pub struct CrateDefMap {\n     extern_prelude: FxHashMap<Name, ModuleDef>,\n     root: CrateModuleId,\n     modules: Arena<CrateModuleId, ModuleData>,\n-    public_macros: FxHashMap<Name, mbe::MacroRules>,\n+    macros: Arena<CrateMacroId, mbe::MacroRules>,\n+    public_macros: FxHashMap<Name, CrateMacroId>,\n+    macro_resolutions: FxHashMap<MacroCallId, (Crate, CrateMacroId)>,\n     problems: CrateDefMapProblems,\n }\n \n@@ -87,9 +89,21 @@ impl std::ops::Index<CrateModuleId> for CrateDefMap {\n     }\n }\n \n+impl std::ops::Index<CrateMacroId> for CrateDefMap {\n+    type Output = mbe::MacroRules;\n+    fn index(&self, id: CrateMacroId) -> &mbe::MacroRules {\n+        &self.macros[id]\n+    }\n+}\n+\n+/// An ID of a macro, **local** to a specific crate\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub(crate) struct CrateMacroId(RawId);\n+impl_arena_id!(CrateMacroId);\n+\n /// An ID of a module, **local** to a specific crate\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-struct CrateModuleId(RawId);\n+pub(crate) struct CrateModuleId(RawId);\n impl_arena_id!(CrateModuleId);\n \n #[derive(Default, Debug, PartialEq, Eq)]\n@@ -192,7 +206,9 @@ impl CrateDefMap {\n                 prelude: None,\n                 root,\n                 modules,\n+                macros: Arena::default(),\n                 public_macros: FxHashMap::default(),\n+                macro_resolutions: FxHashMap::default(),\n                 problems: CrateDefMapProblems::default(),\n             }\n         };\n@@ -221,6 +237,13 @@ impl CrateDefMap {\n         &self.extern_prelude\n     }\n \n+    pub(crate) fn resolve_macro(\n+        &self,\n+        macro_call_id: MacroCallId,\n+    ) -> Option<(Crate, CrateMacroId)> {\n+        self.macro_resolutions.get(&macro_call_id).map(|&it| it)\n+    }\n+\n     pub(crate) fn find_module_by_source(\n         &self,\n         file_id: HirFileId,"}, {"sha": "9992e054d713a093a404b83b9e3403ece761e4a0", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6955e392f8c1cd49e769328b14e10b84ede26744/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6955e392f8c1cd49e769328b14e10b84ede26744/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=6955e392f8c1cd49e769328b14e10b84ede26744", "patch": "@@ -6,13 +6,13 @@ use ra_db::FileId;\n \n use crate::{\n     Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n-    PersistentHirDatabase, HirFileId, Name, Path, Problem,\n+    PersistentHirDatabase, HirFileId, Name, Path, Problem, Crate,\n     KnownName,\n     nameres::{Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode, raw},\n     ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId},\n };\n \n-use super::{CrateDefMap, CrateModuleId, ModuleData};\n+use super::{CrateDefMap, CrateModuleId, ModuleData, CrateMacroId};\n \n pub(super) fn collect_defs(\n     db: &impl PersistentHirDatabase,\n@@ -52,7 +52,7 @@ struct DefCollector<DB> {\n     glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n     unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n     unexpanded_macros: Vec<(CrateModuleId, MacroCallId, Path, tt::Subtree)>,\n-    global_macro_scope: FxHashMap<Name, mbe::MacroRules>,\n+    global_macro_scope: FxHashMap<Name, CrateMacroId>,\n }\n \n impl<'a, DB> DefCollector<&'a DB>\n@@ -95,10 +95,11 @@ where\n \n     fn define_macro(&mut self, name: Name, tt: &tt::Subtree, export: bool) {\n         if let Ok(rules) = mbe::MacroRules::parse(tt) {\n+            let macro_id = self.def_map.macros.alloc(rules);\n             if export {\n-                self.def_map.public_macros.insert(name.clone(), rules.clone());\n+                self.def_map.public_macros.insert(name.clone(), macro_id);\n             }\n-            self.global_macro_scope.insert(name, rules);\n+            self.global_macro_scope.insert(name, macro_id);\n         }\n     }\n \n@@ -295,6 +296,7 @@ where\n     fn resolve_macros(&mut self) -> ReachedFixedPoint {\n         let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n         let mut resolved = Vec::new();\n+        let mut res = ReachedFixedPoint::Yes;\n         macros.retain(|(module_id, call_id, path, tt)| {\n             if path.segments.len() != 2 {\n                 return true;\n@@ -308,19 +310,16 @@ where\n                 Some(it) => it,\n                 _ => return true,\n             };\n+            res = ReachedFixedPoint::No;\n             let def_map = self.db.crate_def_map(krate);\n-            let rules = def_map.public_macros.get(&path.segments[1].name).cloned();\n-            resolved.push((*module_id, *call_id, rules, tt.clone()));\n+            if let Some(macro_id) = def_map.public_macros.get(&path.segments[1].name).cloned() {\n+                resolved.push((*module_id, *call_id, (krate, macro_id), tt.clone()));\n+            }\n             false\n         });\n-        let res = if resolved.is_empty() { ReachedFixedPoint::Yes } else { ReachedFixedPoint::No };\n \n-        for (module_id, macro_call_id, rules, arg) in resolved {\n-            if let Some(rules) = rules {\n-                if let Ok(tt) = rules.expand(&arg) {\n-                    self.collect_macro_expansion(module_id, macro_call_id, tt);\n-                }\n-            }\n+        for (module_id, macro_call_id, macro_def_id, arg) in resolved {\n+            self.collect_macro_expansion(module_id, macro_call_id, macro_def_id, arg);\n         }\n         res\n     }\n@@ -329,20 +328,32 @@ where\n         &mut self,\n         module_id: CrateModuleId,\n         macro_call_id: MacroCallId,\n-        expansion: tt::Subtree,\n+        macro_def_id: (Crate, CrateMacroId),\n+        macro_arg: tt::Subtree,\n     ) {\n-        // XXX: this **does not** go through a database, because we can't\n-        // identify macro_call without adding the whole state of name resolution\n-        // as a parameter to the query.\n-        //\n-        // So, we run the queries \"manually\" and we must ensure that\n-        // `db.hir_parse(macro_call_id)` returns the same source_file.\n-        let file_id: HirFileId = macro_call_id.into();\n-        let source_file = mbe::token_tree_to_ast_item_list(&expansion);\n-\n-        let raw_items = raw::RawItems::from_source_file(&source_file, file_id);\n-        ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n-            .collect(raw_items.items())\n+        let (macro_krate, macro_id) = macro_def_id;\n+        let dm;\n+        let rules = if macro_krate == self.def_map.krate {\n+            &self.def_map[macro_id]\n+        } else {\n+            dm = self.db.crate_def_map(macro_krate);\n+            &dm[macro_id]\n+        };\n+        if let Ok(expansion) = rules.expand(&macro_arg) {\n+            self.def_map.macro_resolutions.insert(macro_call_id, macro_def_id);\n+            // XXX: this **does not** go through a database, because we can't\n+            // identify macro_call without adding the whole state of name resolution\n+            // as a parameter to the query.\n+            //\n+            // So, we run the queries \"manually\" and we must ensure that\n+            // `db.hir_parse(macro_call_id)` returns the same source_file.\n+            let file_id: HirFileId = macro_call_id.into();\n+            let source_file = mbe::token_tree_to_ast_item_list(&expansion);\n+\n+            let raw_items = raw::RawItems::from_source_file(&source_file, file_id);\n+            ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n+                .collect(raw_items.items())\n+        }\n     }\n \n     fn finish(self) -> CrateDefMap {\n@@ -486,12 +497,15 @@ where\n \n         // Case 2: try to expand macro_rules from this crate, triggering\n         // recursive item collection.\n-        if let Some(rules) =\n+        if let Some(&macro_id) =\n             mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(name))\n         {\n-            if let Ok(tt) = rules.expand(&mac.arg) {\n-                self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, tt);\n-            }\n+            self.def_collector.collect_macro_expansion(\n+                self.module_id,\n+                macro_call_id,\n+                (self.def_collector.def_map.krate, macro_id),\n+                mac.arg.clone(),\n+            );\n             return;\n         }\n "}, {"sha": "d23290b74b29086bd7a54a3c54651df68a21aec2", "filename": "crates/ra_ide_api/src/extend_selection.rs", "status": "modified", "additions": 2, "deletions": 44, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6955e392f8c1cd49e769328b14e10b84ede26744/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6955e392f8c1cd49e769328b14e10b84ede26744/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs?ref=6955e392f8c1cd49e769328b14e10b84ede26744", "patch": "@@ -1,55 +1,13 @@\n use ra_db::SourceDatabase;\n-use ra_syntax::{\n-    SyntaxNode, AstNode, SourceFile,\n-    ast, algo::find_covering_node,\n-};\n+use ra_syntax::AstNode;\n \n use crate::{\n     TextRange, FileRange,\n     db::RootDatabase,\n };\n \n+// FIXME: restore macro support\n pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRange {\n     let source_file = db.parse(frange.file_id);\n-    if let Some(range) = extend_selection_in_macro(db, &source_file, frange) {\n-        return range;\n-    }\n     ra_ide_api_light::extend_selection(source_file.syntax(), frange.range).unwrap_or(frange.range)\n }\n-\n-fn extend_selection_in_macro(\n-    _db: &RootDatabase,\n-    source_file: &SourceFile,\n-    frange: FileRange,\n-) -> Option<TextRange> {\n-    let macro_call = find_macro_call(source_file.syntax(), frange.range)?;\n-    let (off, exp) = hir::MacroDef::ast_expand(macro_call)?;\n-    let dst_range = exp.map_range_forward(frange.range - off)?;\n-    let dst_range = ra_ide_api_light::extend_selection(&exp.syntax(), dst_range)?;\n-    let src_range = exp.map_range_back(dst_range)? + off;\n-    Some(src_range)\n-}\n-\n-fn find_macro_call(node: &SyntaxNode, range: TextRange) -> Option<&ast::MacroCall> {\n-    find_covering_node(node, range).ancestors().find_map(ast::MacroCall::cast)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use ra_syntax::TextRange;\n-\n-    use crate::mock_analysis::single_file_with_range;\n-\n-    #[test]\n-    fn extend_selection_inside_macros() {\n-        let (analysis, frange) = single_file_with_range(\n-            \"\n-            fn main() {\n-                vec![foo(|x| <|>x<|>)];\n-            }\n-        \",\n-        );\n-        let r = analysis.extend_selection(frange).unwrap();\n-        assert_eq!(r, TextRange::from_to(50.into(), 55.into()));\n-    }\n-}"}, {"sha": "fdd87bcfffc9a39d5b27c8f7721b1d27518a5ddd", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6955e392f8c1cd49e769328b14e10b84ede26744/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6955e392f8c1cd49e769328b14e10b84ede26744/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=6955e392f8c1cd49e769328b14e10b84ede26744", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{ast, AstNode,};\n+use ra_syntax::AstNode;\n use ra_db::SourceDatabase;\n \n use crate::{\n@@ -8,37 +8,5 @@ use crate::{\n \n pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRange> {\n     let source_file = db.parse(file_id);\n-    let mut res = ra_ide_api_light::highlight(source_file.syntax());\n-    for macro_call in source_file.syntax().descendants().filter_map(ast::MacroCall::cast) {\n-        if let Some((off, exp)) = hir::MacroDef::ast_expand(macro_call) {\n-            let mapped_ranges =\n-                ra_ide_api_light::highlight(&exp.syntax()).into_iter().filter_map(|r| {\n-                    let mapped_range = exp.map_range_back(r.range)?;\n-                    let res = HighlightedRange { range: mapped_range + off, tag: r.tag };\n-                    Some(res)\n-                });\n-            res.extend(mapped_ranges);\n-        }\n-    }\n-    res\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::mock_analysis::single_file;\n-\n-    use insta::assert_debug_snapshot_matches;\n-\n-    #[test]\n-    fn highlights_code_inside_macros() {\n-        let (analysis, file_id) = single_file(\n-            \"\n-            fn main() {\n-                vec![{ let x = 92; x}];\n-            }\n-            \",\n-        );\n-        let highlights = analysis.highlight(file_id).unwrap();\n-        assert_debug_snapshot_matches!(\"highlights_code_inside_macros\", &highlights);\n-    }\n+    ra_ide_api_light::highlight(source_file.syntax())\n }"}]}