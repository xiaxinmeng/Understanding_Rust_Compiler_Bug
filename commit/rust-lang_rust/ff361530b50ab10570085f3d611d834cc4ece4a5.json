{"sha": "ff361530b50ab10570085f3d611d834cc4ece4a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMzYxNTMwYjUwYWIxMDU3MDA4NWYzZDYxMWQ4MzRjYzRlY2U0YTU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-03T19:48:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-06T03:01:30Z"}, "message": "Partial fix for #17901: Be less conservative around unbound type\nvariables in the intracrate case. This requires a deeper distinction\nbetween inter- and intra-crate so as to keep coherence working.\n\nI suspect the best fix is to generalize the recursion check that\nexists today, but this requires a bit more refactoring to achieve.\n\n(In other words, where today it says OK for an exact match, we'd want\nto not detect exact matches but rather skolemize each trait-reference\nfresh and return AMBIG -- but that requires us to make builtin bounds\nwork shallowly like everything else and move the cycle detection into\nthe fulfillment context.)", "tree": {"sha": "11951e9440f151ae71d026b7e35630abd933bd8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11951e9440f151ae71d026b7e35630abd933bd8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff361530b50ab10570085f3d611d834cc4ece4a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff361530b50ab10570085f3d611d834cc4ece4a5", "html_url": "https://github.com/rust-lang/rust/commit/ff361530b50ab10570085f3d611d834cc4ece4a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff361530b50ab10570085f3d611d834cc4ece4a5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7914739379711e9f56fdcfab049b5a9531feb52", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7914739379711e9f56fdcfab049b5a9531feb52", "html_url": "https://github.com/rust-lang/rust/commit/f7914739379711e9f56fdcfab049b5a9531feb52"}], "stats": {"total": 146, "additions": 85, "deletions": 61}, "files": [{"sha": "09490f9bdf7e951c77afcbd48c8c771e7e50bb98", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff361530b50ab10570085f3d611d834cc4ece4a5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff361530b50ab10570085f3d611d834cc4ece4a5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=ff361530b50ab10570085f3d611d834cc4ece4a5", "patch": "@@ -43,7 +43,7 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n     // Determine whether `impl2` can provide an implementation for those\n     // same types.\n     let param_env = ty::empty_parameter_environment();\n-    let mut selcx = SelectionContext::new(infcx, &param_env, infcx.tcx);\n+    let mut selcx = SelectionContext::intercrate(infcx, &param_env, infcx.tcx);\n     let obligation = Obligation::misc(DUMMY_SP, impl1_trait_ref);\n     debug!(\"impl_can_satisfy obligation={}\", obligation.repr(infcx.tcx));\n     selcx.evaluate_impl(impl2_def_id, &obligation)"}, {"sha": "09bd0f52985b1799334e4f6e47d83dae9c2ab66b", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 83, "deletions": 59, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/ff361530b50ab10570085f3d611d834cc4ece4a5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff361530b50ab10570085f3d611d834cc4ece4a5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=ff361530b50ab10570085f3d611d834cc4ece4a5", "patch": "@@ -45,6 +45,22 @@ pub struct SelectionContext<'cx, 'tcx:'cx> {\n     /// which is important for checking for trait bounds that\n     /// recursively require themselves.\n     skolemizer: TypeSkolemizer<'cx, 'tcx>,\n+\n+    /// If true, indicates that the evaluation should be conservative\n+    /// and consider the possibility of types outside this crate.\n+    /// This comes up primarily when resolving ambiguity. Imagine\n+    /// there is some trait reference `$0 : Bar` where `$0` is an\n+    /// inference variable. If `intercrate` is true, then we can never\n+    /// say for sure that this reference is not implemented, even if\n+    /// there are *no impls at all for `Bar`*, because `$0` could be\n+    /// bound to some type that in a downstream crate that implements\n+    /// `Bar`. This is the suitable mode for coherence. Elsewhere,\n+    /// though, we set this to false, because we are only interested\n+    /// in types that the user could actually have written --- in\n+    /// other words, we consider `$0 : Bar` to be unimplemented if\n+    /// there is no type that the user could *actually name* that\n+    /// would satisfy it. This avoids crippling inference, basically.\n+    intercrate: bool,\n }\n \n // A stack that walks back up the stack frame.\n@@ -142,6 +158,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             param_env: param_env,\n             typer: typer,\n             skolemizer: infcx.skolemizer(),\n+            intercrate: false,\n+        }\n+    }\n+\n+    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>,\n+                      param_env: &'cx ty::ParameterEnvironment,\n+                      typer: &'cx Typer<'tcx>)\n+                      -> SelectionContext<'cx, 'tcx> {\n+        SelectionContext {\n+            infcx: infcx,\n+            param_env: param_env,\n+            typer: typer,\n+            skolemizer: infcx.skolemizer(),\n+            intercrate: true,\n         }\n     }\n \n@@ -214,44 +244,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // The result is \"true\" if the obligation *may* hold and \"false\" if\n     // we can be sure it does not.\n \n-    pub fn evaluate_obligation_intercrate(&mut self,\n-                                          obligation: &Obligation)\n-                                          -> bool\n-    {\n-        /*!\n-         * Evaluates whether the obligation `obligation` can be\n-         * satisfied (by any means). This \"intercrate\" version allows\n-         * for the possibility that unbound type variables may be\n-         * instantiated with types from another crate. This is\n-         * important for coherence. In practice this means that\n-         * unbound type variables must always be considered ambiguous.\n-         */\n-\n-        debug!(\"evaluate_obligation_intercrate({})\",\n-               obligation.repr(self.tcx()));\n-\n-        let stack = self.push_stack(None, obligation);\n-        self.evaluate_stack_intercrate(&stack).may_apply()\n-    }\n-\n-    pub fn evaluate_obligation_intracrate(&mut self,\n-                                            obligation: &Obligation)\n-                                            -> bool\n+    pub fn evaluate_obligation(&mut self,\n+                               obligation: &Obligation)\n+                               -> bool\n     {\n         /*!\n          * Evaluates whether the obligation `obligation` can be\n-         * satisfied (by any means). This \"intracrate\" version does\n-         * not allow for the possibility that unbound type variables\n-         * may be instantiated with types from another crate; hence,\n-         * if there are unbound inputs but no crates locally visible,\n-         * it considers the result to be unimplemented.\n+         * satisfied (by any means).\n          */\n \n-        debug!(\"evaluate_obligation_intracrate({})\",\n+        debug!(\"evaluate_obligation({})\",\n                obligation.repr(self.tcx()));\n \n         let stack = self.push_stack(None, obligation);\n-        self.evaluate_stack_intracrate(&stack).may_apply()\n+        self.evaluate_stack(&stack).may_apply()\n     }\n \n     fn evaluate_builtin_bound_recursively(&mut self,\n@@ -288,46 +294,53 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let stack = self.push_stack(previous_stack.map(|x| x), obligation);\n \n-        // FIXME(#17901) -- Intercrate vs intracrate resolution is a\n-        // tricky question here. For coherence, we want\n-        // intercrate. Also, there was a nasty cycle around impls like\n-        // `impl<T:Eq> Eq for Vec<T>` (which would wind up checking\n-        // whether `$0:Eq`, where $0 was the value substituted for\n-        // `T`, which could then be checked against the very same\n-        // impl). This problem is avoided by the stricter rules around\n-        // unbound type variables by intercrate. I suspect that in the\n-        // latter case a more fine-grained rule would suffice (i.e.,\n-        // consider it ambiguous if even 1 impl matches, no need to\n-        // figure out which one, but call it unimplemented if 0 impls\n-        // match).\n-        let result = self.evaluate_stack_intercrate(&stack);\n+        let result = self.evaluate_stack(&stack);\n \n         debug!(\"result: {}\", result);\n         result\n     }\n \n-    fn evaluate_stack_intercrate(&mut self,\n+    fn evaluate_stack(&mut self,\n                       stack: &ObligationStack)\n                       -> EvaluationResult\n     {\n-        // Whenever any of the types are unbound, there can always be\n-        // an impl.  Even if there are no impls in this crate, perhaps\n-        // the type would be unified with something from another crate\n-        // that does provide an impl.\n+        // In intercrate mode, whenever any of the types are unbound,\n+        // there can always be an impl. Even if there are no impls in\n+        // this crate, perhaps the type would be unified with\n+        // something from another crate that does provide an impl.\n+        //\n+        // In intracrate mode, we must still be conservative. The reason is\n+        // that we want to avoid cycles. Imagine an impl like:\n+        //\n+        //     impl<T:Eq> Eq for Vec<T>\n+        //\n+        // and a trait reference like `$0 : Eq` where `$0` is an\n+        // unbound variable. When we evaluate this trait-reference, we\n+        // will unify `$0` with `Vec<$1>` (for some fresh variable\n+        // `$1`), on the condition that `$1 : Eq`. We will then wind\n+        // up with many candidates (since that are other `Eq` impls\n+        // that apply) and try to winnow things down. This results in\n+        // a recurssive evaluation that `$1 : Eq` -- as you can\n+        // imagine, this is just where we started. To avoid that, we\n+        // check for unbound variables and return an ambiguous (hence possible)\n+        // match if we've seen this trait before.\n+        //\n+        // This suffices to allow chains like `FnMut` implemented in\n+        // terms of `Fn` etc, but we could probably make this more\n+        // precise still.\n         let input_types = stack.skol_trait_ref.input_types();\n-        if input_types.iter().any(|&t| ty::type_is_skolemized(t)) {\n-            debug!(\"evaluate_stack_intercrate({}) --> unbound argument, must be ambiguous\",\n+        let unbound_input_types = input_types.iter().any(|&t| ty::type_is_skolemized(t));\n+        if\n+            unbound_input_types &&\n+             (self.intercrate ||\n+              stack.iter().skip(1).any(\n+                  |prev| stack.skol_trait_ref.def_id == prev.skol_trait_ref.def_id))\n+        {\n+            debug!(\"evaluate_stack_intracrate({}) --> unbound argument, recursion -->  ambiguous\",\n                    stack.skol_trait_ref.repr(self.tcx()));\n             return EvaluatedToAmbig;\n         }\n \n-        self.evaluate_stack_intracrate(stack)\n-    }\n-\n-    fn evaluate_stack_intracrate(&mut self,\n-                                 stack: &ObligationStack)\n-                                 -> EvaluationResult\n-    {\n         // If there is any previous entry on the stack that precisely\n         // matches this obligation, then we can assume that the\n         // obligation is satisfied for now (still all other conditions\n@@ -592,7 +605,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Err(_) => { return Err(()); }\n             }\n \n-            if self.evaluate_obligation_intracrate(obligation) {\n+            if self.evaluate_obligation(obligation) {\n                 Ok(())\n             } else {\n                 Err(())\n@@ -828,7 +841,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // be the case that you could still satisfy the obligation\n         // from another crate by instantiating the type variables with\n         // a type from another crate that does have an impl. This case\n-        // is checked for in `evaluate_obligation` (and hence users\n+        // is checked for in `evaluate_stack` (and hence users\n         // who might care about this case, like coherence, should use\n         // that function).\n         if candidates.len() == 0 {\n@@ -849,6 +862,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // global cache. We want the cache that is specific to this\n         // scope whenever where clauses might affect the result.\n \n+        // Avoid using the master cache during coherence and just rely\n+        // on the local cache. This effectively disables caching\n+        // during coherence. It is really just a simplification to\n+        // avoid us having to fear that coherence results \"pollute\"\n+        // the master cache. Since coherence executes pretty quickly,\n+        // it's not worth going to more trouble to increase the\n+        // hit-rate I don't think.\n+        if self.intercrate {\n+            return &self.param_env.selection_cache;\n+        }\n+\n         // If the trait refers to any parameters in scope, then use\n         // the cache of the param-environment.\n         if"}, {"sha": "f854bc52acd7b3a009c4f230f58ff527f8b5483b", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff361530b50ab10570085f3d611d834cc4ece4a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff361530b50ab10570085f3d611d834cc4ece4a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=ff361530b50ab10570085f3d611d834cc4ece4a5", "patch": "@@ -235,7 +235,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(\n     let mut selcx = traits::SelectionContext::new(fcx.infcx(),\n                                                   &fcx.inh.param_env,\n                                                   fcx);\n-    if !selcx.evaluate_obligation_intracrate(&obligation) {\n+    if !selcx.evaluate_obligation(&obligation) {\n         debug!(\"--> Cannot match obligation\");\n         return None; // Cannot be matched, no such method resolution is possible.\n     }"}]}