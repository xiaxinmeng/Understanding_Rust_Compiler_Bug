{"sha": "1dda298ad39a64e019a3511139c5b13ac0a18e54", "node_id": "C_kwDOAAsO6NoAKDFkZGEyOThhZDM5YTY0ZTAxOWEzNTExMTM5YzViMTNhYzBhMThlNTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-24T09:44:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-24T09:44:46Z"}, "message": "Auto merge of #104809 - matthiaskrgr:rollup-8abjdwh, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #103908 (Suggest `.clone()` or `ref binding` on E0382)\n - #104517 (Throw error on failure in loading llvm-plugin)\n - #104594 (Properly handle `Pin<&mut dyn* Trait>` receiver in codegen)\n - #104742 (Make `deref_into_dyn_supertrait` lint the impl and not the usage)\n - #104753 (Pass `InferCtxt` to `DropRangeVisitor` so we can resolve vars)\n - #104771 (Add regression test for issue #99938)\n - #104772 (Small accessibility improvements)\n - #104775 (Use ObligationCtxt::normalize)\n - #104778 (:arrow_up: rust-analyzer)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ac1b48fa193d147d799dedabcddd525f5b0ec5ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac1b48fa193d147d799dedabcddd525f5b0ec5ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dda298ad39a64e019a3511139c5b13ac0a18e54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dda298ad39a64e019a3511139c5b13ac0a18e54", "html_url": "https://github.com/rust-lang/rust/commit/1dda298ad39a64e019a3511139c5b13ac0a18e54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dda298ad39a64e019a3511139c5b13ac0a18e54/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "341d8b8a2c290b4535e965867e876b095461ff6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/341d8b8a2c290b4535e965867e876b095461ff6e", "html_url": "https://github.com/rust-lang/rust/commit/341d8b8a2c290b4535e965867e876b095461ff6e"}, {"sha": "1afbd6e0318600639433fc455b4ab641db51c2d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1afbd6e0318600639433fc455b4ab641db51c2d0", "html_url": "https://github.com/rust-lang/rust/commit/1afbd6e0318600639433fc455b4ab641db51c2d0"}], "stats": {"total": 5255, "additions": 4084, "deletions": 1171}, "files": [{"sha": "28072f153a4792513914f67fac059e1148194d9c", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1376,7 +1376,7 @@ pub enum ExprKind {\n     /// Conditionless loop (can be exited with `break`, `continue`, or `return`).\n     ///\n     /// `'label: loop { block }`\n-    Loop(P<Block>, Option<Label>),\n+    Loop(P<Block>, Option<Label>, Span),\n     /// A `match` block.\n     Match(P<Expr>, Vec<Arm>),\n     /// A closure (e.g., `move |a, b, c| a + b + c`)."}, {"sha": "a5b24c403dd376d10c75550310a53300d59201a7", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1355,9 +1355,10 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             vis.visit_block(body);\n             visit_opt(label, |label| vis.visit_label(label));\n         }\n-        ExprKind::Loop(body, label) => {\n+        ExprKind::Loop(body, label, span) => {\n             vis.visit_block(body);\n             visit_opt(label, |label| vis.visit_label(label));\n+            vis.visit_span(span);\n         }\n         ExprKind::Match(expr, arms) => {\n             vis.visit_expr(expr);"}, {"sha": "c528118be08085869bac97af434e5f37978784a8", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -824,7 +824,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Loop(block, opt_label) => {\n+        ExprKind::Loop(block, opt_label, _) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }"}, {"sha": "3c217c0249abac6a596fcee06e0659f01a89be8b", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -131,12 +131,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let span = this.mark_span_with_reason(DesugaringKind::WhileLoop, e.span, None);\n                     this.lower_expr_while_in_loop_scope(span, cond, body, *opt_label)\n                 }),\n-                ExprKind::Loop(body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                ExprKind::Loop(body, opt_label, span) => self.with_loop_scope(e.id, |this| {\n                     hir::ExprKind::Loop(\n                         this.lower_block(body, false),\n                         this.lower_label(*opt_label),\n                         hir::LoopSource::Loop,\n-                        DUMMY_SP,\n+                        this.lower_span(*span),\n                     )\n                 }),\n                 ExprKind::TryBlock(body) => self.lower_expr_try_block(body),"}, {"sha": "4b37fa027f53b75046029d2180ff43f8e9c5a00f", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -377,7 +377,7 @@ impl<'a> State<'a> {\n                 self.space();\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::Loop(ref blk, opt_label) => {\n+            ast::ExprKind::Loop(ref blk, opt_label, _) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");"}, {"sha": "5c645c66cd71c64341a018ed9fcda18b9842a3ab", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 194, "deletions": 30, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -167,10 +167,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            self.add_moved_or_invoked_closure_note(location, used_place, &mut err);\n+            let closure = self.add_moved_or_invoked_closure_note(location, used_place, &mut err);\n \n             let mut is_loop_move = false;\n             let mut in_pattern = false;\n+            let mut seen_spans = FxHashSet::default();\n \n             for move_site in &move_site_vec {\n                 let move_out = self.move_data.moves[(*move_site).moi];\n@@ -191,37 +192,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     is_loop_move = true;\n                 }\n \n-                self.explain_captures(\n-                    &mut err,\n-                    span,\n-                    move_span,\n-                    move_spans,\n-                    *moved_place,\n-                    partially_str,\n-                    loop_message,\n-                    move_msg,\n-                    is_loop_move,\n-                    maybe_reinitialized_locations.is_empty(),\n-                );\n-\n-                if let (UseSpans::PatUse(span), []) =\n-                    (move_spans, &maybe_reinitialized_locations[..])\n-                {\n-                    if maybe_reinitialized_locations.is_empty() {\n-                        err.span_suggestion_verbose(\n-                            span.shrink_to_lo(),\n-                            &format!(\n-                                \"borrow this field in the pattern to avoid moving {}\",\n-                                self.describe_place(moved_place.as_ref())\n-                                    .map(|n| format!(\"`{}`\", n))\n-                                    .unwrap_or_else(|| \"the value\".to_string())\n-                            ),\n-                            \"ref \",\n-                            Applicability::MachineApplicable,\n-                        );\n-                        in_pattern = true;\n+                if !seen_spans.contains(&move_span) {\n+                    if !closure {\n+                        self.suggest_ref_or_clone(mpi, move_span, &mut err, &mut in_pattern);\n                     }\n+\n+                    self.explain_captures(\n+                        &mut err,\n+                        span,\n+                        move_span,\n+                        move_spans,\n+                        *moved_place,\n+                        partially_str,\n+                        loop_message,\n+                        move_msg,\n+                        is_loop_move,\n+                        maybe_reinitialized_locations.is_empty(),\n+                    );\n                 }\n+                seen_spans.insert(move_span);\n             }\n \n             use_spans.var_path_only_subdiag(&mut err, desired_action);\n@@ -317,6 +306,160 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    fn suggest_ref_or_clone(\n+        &mut self,\n+        mpi: MovePathIndex,\n+        move_span: Span,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        in_pattern: &mut bool,\n+    ) {\n+        struct ExpressionFinder<'hir> {\n+            expr_span: Span,\n+            expr: Option<&'hir hir::Expr<'hir>>,\n+            pat: Option<&'hir hir::Pat<'hir>>,\n+            parent_pat: Option<&'hir hir::Pat<'hir>>,\n+        }\n+        impl<'hir> Visitor<'hir> for ExpressionFinder<'hir> {\n+            fn visit_expr(&mut self, e: &'hir hir::Expr<'hir>) {\n+                if e.span == self.expr_span {\n+                    self.expr = Some(e);\n+                }\n+                hir::intravisit::walk_expr(self, e);\n+            }\n+            fn visit_pat(&mut self, p: &'hir hir::Pat<'hir>) {\n+                if p.span == self.expr_span {\n+                    self.pat = Some(p);\n+                }\n+                if let hir::PatKind::Binding(hir::BindingAnnotation::NONE, _, i, sub) = p.kind {\n+                    if i.span == self.expr_span || p.span == self.expr_span {\n+                        self.pat = Some(p);\n+                    }\n+                    // Check if we are in a situation of `ident @ ident` where we want to suggest\n+                    // `ref ident @ ref ident` or `ref ident @ Struct { ref ident }`.\n+                    if let Some(subpat) = sub && self.pat.is_none() {\n+                        self.visit_pat(subpat);\n+                        if self.pat.is_some() {\n+                            self.parent_pat = Some(p);\n+                        }\n+                        return;\n+                    }\n+                }\n+                hir::intravisit::walk_pat(self, p);\n+            }\n+        }\n+        let hir = self.infcx.tcx.hir();\n+        if let Some(hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(_, _, body_id),\n+            ..\n+        })) = hir.find(hir.local_def_id_to_hir_id(self.mir_def_id()))\n+            && let Some(hir::Node::Expr(expr)) = hir.find(body_id.hir_id)\n+        {\n+            let place = &self.move_data.move_paths[mpi].place;\n+            let span = place.as_local()\n+                .map(|local| self.body.local_decls[local].source_info.span);\n+            let mut finder = ExpressionFinder {\n+                expr_span: move_span,\n+                expr: None,\n+                pat: None,\n+                parent_pat: None,\n+            };\n+            finder.visit_expr(expr);\n+            if let Some(span) = span && let Some(expr) = finder.expr {\n+                for (_, expr) in hir.parent_iter(expr.hir_id) {\n+                    if let hir::Node::Expr(expr) = expr {\n+                        if expr.span.contains(span) {\n+                            // If the let binding occurs within the same loop, then that\n+                            // loop isn't relevant, like in the following, the outermost `loop`\n+                            // doesn't play into `x` being moved.\n+                            // ```\n+                            // loop {\n+                            //     let x = String::new();\n+                            //     loop {\n+                            //         foo(x);\n+                            //     }\n+                            // }\n+                            // ```\n+                            break;\n+                        }\n+                        if let hir::ExprKind::Loop(.., loop_span) = expr.kind {\n+                            err.span_label(loop_span, \"inside of this loop\");\n+                        }\n+                    }\n+                }\n+                let typeck = self.infcx.tcx.typeck(self.mir_def_id());\n+                let hir_id = hir.get_parent_node(expr.hir_id);\n+                if let Some(parent) = hir.find(hir_id) {\n+                    let (def_id, args, offset) = if let hir::Node::Expr(parent_expr) = parent\n+                        && let hir::ExprKind::MethodCall(_, _, args, _) = parent_expr.kind\n+                        && let Some(def_id) = typeck.type_dependent_def_id(parent_expr.hir_id)\n+                    {\n+                        (def_id.as_local(), args, 1)\n+                    } else if let hir::Node::Expr(parent_expr) = parent\n+                        && let hir::ExprKind::Call(call, args) = parent_expr.kind\n+                        && let ty::FnDef(def_id, _) = typeck.node_type(call.hir_id).kind()\n+                    {\n+                        (def_id.as_local(), args, 0)\n+                    } else {\n+                        (None, &[][..], 0)\n+                    };\n+                    if let Some(def_id) = def_id\n+                        && let Some(node) = hir.find(hir.local_def_id_to_hir_id(def_id))\n+                        && let Some(fn_sig) = node.fn_sig()\n+                        && let Some(ident) = node.ident()\n+                        && let Some(pos) = args.iter().position(|arg| arg.hir_id == expr.hir_id)\n+                        && let Some(arg) = fn_sig.decl.inputs.get(pos + offset)\n+                    {\n+                        let mut span: MultiSpan = arg.span.into();\n+                        span.push_span_label(\n+                            arg.span,\n+                            \"this parameter takes ownership of the value\".to_string(),\n+                        );\n+                        let descr = match node.fn_kind() {\n+                            Some(hir::intravisit::FnKind::ItemFn(..)) | None => \"function\",\n+                            Some(hir::intravisit::FnKind::Method(..)) => \"method\",\n+                            Some(hir::intravisit::FnKind::Closure) => \"closure\",\n+                        };\n+                        span.push_span_label(\n+                            ident.span,\n+                            format!(\"in this {descr}\"),\n+                        );\n+                        err.span_note(\n+                            span,\n+                            format!(\n+                                \"consider changing this parameter type in {descr} `{ident}` to \\\n+                                 borrow instead if owning the value isn't necessary\",\n+                            ),\n+                        );\n+                    }\n+                    let place = &self.move_data.move_paths[mpi].place;\n+                    let ty = place.ty(self.body, self.infcx.tcx).ty;\n+                    if let hir::Node::Expr(parent_expr) = parent\n+                        && let hir::ExprKind::Call(call_expr, _) = parent_expr.kind\n+                        && let hir::ExprKind::Path(\n+                            hir::QPath::LangItem(LangItem::IntoIterIntoIter, _, _)\n+                        ) = call_expr.kind\n+                    {\n+                        // Do not suggest `.clone()` in a `for` loop, we already suggest borrowing.\n+                    } else {\n+                        self.suggest_cloning(err, ty, move_span);\n+                    }\n+                }\n+            }\n+            if let Some(pat) = finder.pat {\n+                *in_pattern = true;\n+                let mut sugg = vec![(pat.span.shrink_to_lo(), \"ref \".to_string())];\n+                if let Some(pat) = finder.parent_pat {\n+                    sugg.insert(0, (pat.span.shrink_to_lo(), \"ref \".to_string()));\n+                }\n+                err.multipart_suggestion_verbose(\n+                    \"borrow this binding in the pattern to avoid moving the value\",\n+                    sugg,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+\n     fn report_use_of_uninitialized(\n         &self,\n         mpi: MovePathIndex,\n@@ -590,6 +733,27 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         true\n     }\n \n+    fn suggest_cloning(&self, err: &mut Diagnostic, ty: Ty<'tcx>, span: Span) {\n+        let tcx = self.infcx.tcx;\n+        // Try to find predicates on *generic params* that would allow copying `ty`\n+        let infcx = tcx.infer_ctxt().build();\n+        if infcx\n+            .type_implements_trait(\n+                tcx.lang_items().clone_trait().unwrap(),\n+                [tcx.erase_regions(ty)],\n+                self.param_env,\n+            )\n+            .must_apply_modulo_regions()\n+        {\n+            err.span_suggestion_verbose(\n+                span.shrink_to_hi(),\n+                \"consider cloning the value if the performance cost is acceptable\",\n+                \".clone()\".to_string(),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n     fn suggest_adding_copy_bounds(&self, err: &mut Diagnostic, ty: Ty<'tcx>, span: Span) {\n         let tcx = self.infcx.tcx;\n         let generics = tcx.generics_of(self.mir_def_id());"}, {"sha": "c500cbc49e4a3700e69b7421976d8708867bfb93", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -70,7 +70,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         location: Location,\n         place: PlaceRef<'tcx>,\n         diag: &mut Diagnostic,\n-    ) {\n+    ) -> bool {\n         debug!(\"add_moved_or_invoked_closure_note: location={:?} place={:?}\", location, place);\n         let mut target = place.local_or_deref_local();\n         for stmt in &self.body[location.block].statements[location.statement_index..] {\n@@ -106,7 +106,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         {\n                             place.local_or_deref_local().unwrap()\n                         }\n-                        _ => return,\n+                        _ => return false,\n                     };\n \n                     debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n@@ -125,7 +125,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     ty::place_to_string_for_capture(self.infcx.tcx, hir_place)\n                                 ),\n                             );\n-                            return;\n+                            return true;\n                         }\n                     }\n                 }\n@@ -149,9 +149,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             ty::place_to_string_for_capture(self.infcx.tcx, hir_place)\n                         ),\n                     );\n+                    return true;\n                 }\n             }\n         }\n+        false\n     }\n \n     /// End-user visible description of `place` if one can be found."}, {"sha": "9f42a0c2d585cdef4270de56762ab529b45dc6ac", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -307,7 +307,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             | ExprKind::InlineAsm(_)\n             | ExprKind::Let(_, _, _)\n             | ExprKind::Lit(_)\n-            | ExprKind::Loop(_, _)\n+            | ExprKind::Loop(_, _, _)\n             | ExprKind::MacCall(_)\n             | ExprKind::Match(_, _)\n             | ExprKind::Path(_, _)"}, {"sha": "03d833fbba87cf4afbc49318c9fa55b52d8a57e3", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -938,7 +938,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // that is understood elsewhere in the compiler as a method on\n                         // `dyn Trait`.\n                         // To get a `*mut RcBox<Self>`, we just keep unwrapping newtypes until\n-                        // we get a value of a built-in pointer type\n+                        // we get a value of a built-in pointer type.\n+                        //\n+                        // This is also relevant for `Pin<&mut Self>`, where we need to peel the `Pin`.\n                         'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n                             && !op.layout.ty.is_region_ptr()\n                         {\n@@ -980,13 +982,29 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         continue;\n                     }\n                     Immediate(_) => {\n-                        let ty::Ref(_, ty, _) = op.layout.ty.kind() else {\n-                            span_bug!(span, \"can't codegen a virtual call on {:#?}\", op);\n-                        };\n-                        if !ty.is_dyn_star() {\n+                        // See comment above explaining why we peel these newtypes\n+                        'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n+                            && !op.layout.ty.is_region_ptr()\n+                        {\n+                            for i in 0..op.layout.fields.count() {\n+                                let field = op.extract_field(bx, i);\n+                                if !field.layout.is_zst() {\n+                                    // we found the one non-zero-sized field that is allowed\n+                                    // now find *its* non-zero-sized field, or stop if it's a\n+                                    // pointer\n+                                    op = field;\n+                                    continue 'descend_newtypes;\n+                                }\n+                            }\n+\n+                            span_bug!(span, \"receiver has no non-zero-sized fields {:?}\", op);\n+                        }\n+\n+                        // Make sure that we've actually unwrapped the rcvr down\n+                        // to a pointer or ref to `dyn* Trait`.\n+                        if !op.layout.ty.builtin_deref(true).unwrap().ty.is_dyn_star() {\n                             span_bug!(span, \"can't codegen a virtual call on {:#?}\", op);\n                         }\n-                        // FIXME(dyn-star): Make sure this is done on a &dyn* receiver\n                         let place = op.deref(bx.cx());\n                         let data_ptr = place.project_field(bx, 0);\n                         let meta_ptr = place.project_field(bx, 1);"}, {"sha": "de386e2d135568c0c5cdc3e784f060efdaf34752", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -218,14 +218,11 @@ fn compare_predicate_entailment<'tcx>(\n \n     debug!(\"compare_impl_method: caller_bounds={:?}\", param_env.caller_bounds());\n \n-    let mut selcx = traits::SelectionContext::new(&infcx);\n     let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_placeholder_substs);\n     for (predicate, span) in iter::zip(impl_m_own_bounds.predicates, impl_m_own_bounds.spans) {\n         let normalize_cause = traits::ObligationCause::misc(span, impl_m_hir_id);\n-        let traits::Normalized { value: predicate, obligations } =\n-            traits::normalize(&mut selcx, param_env, normalize_cause, predicate);\n+        let predicate = ocx.normalize(normalize_cause, param_env, predicate);\n \n-        ocx.register_obligations(obligations);\n         let cause = ObligationCause::new(\n             span,\n             impl_m_hir_id,\n@@ -1555,14 +1552,11 @@ fn compare_type_predicate_entailment<'tcx>(\n \n     debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\", param_env.caller_bounds());\n \n-    let mut selcx = traits::SelectionContext::new(&infcx);\n-\n     assert_eq!(impl_ty_own_bounds.predicates.len(), impl_ty_own_bounds.spans.len());\n     for (span, predicate) in std::iter::zip(impl_ty_own_bounds.spans, impl_ty_own_bounds.predicates)\n     {\n         let cause = ObligationCause::misc(span, impl_ty_hir_id);\n-        let traits::Normalized { value: predicate, obligations } =\n-            traits::normalize(&mut selcx, param_env, cause, predicate);\n+        let predicate = ocx.normalize(cause, param_env, predicate);\n \n         let cause = ObligationCause::new(\n             span,\n@@ -1573,7 +1567,6 @@ fn compare_type_predicate_entailment<'tcx>(\n                 kind: impl_ty.kind,\n             },\n         );\n-        ocx.register_obligations(obligations);\n         ocx.register_obligation(traits::Obligation::new(tcx, cause, param_env, predicate));\n     }\n \n@@ -1756,7 +1749,6 @@ pub fn check_type_bounds<'tcx>(\n     let assumed_wf_types =\n         ocx.assumed_wf_types(param_env, impl_ty_span, impl_ty.def_id.expect_local());\n \n-    let mut selcx = traits::SelectionContext::new(&infcx);\n     let normalize_cause = ObligationCause::new(\n         impl_ty_span,\n         impl_ty_hir_id,\n@@ -1785,16 +1777,11 @@ pub fn check_type_bounds<'tcx>(\n     debug!(\"check_type_bounds: item_bounds={:?}\", obligations);\n \n     for mut obligation in util::elaborate_obligations(tcx, obligations) {\n-        let traits::Normalized { value: normalized_predicate, obligations } = traits::normalize(\n-            &mut selcx,\n-            normalize_param_env,\n-            normalize_cause.clone(),\n-            obligation.predicate,\n-        );\n+        let normalized_predicate =\n+            ocx.normalize(normalize_cause.clone(), normalize_param_env, obligation.predicate);\n         debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);\n         obligation.predicate = normalized_predicate;\n \n-        ocx.register_obligations(obligations);\n         ocx.register_obligation(obligation);\n     }\n     // Check that all obligations are satisfied by the implementation's"}, {"sha": "82784bb8a661a61122cf923f7eef8126d064fdd8", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -755,20 +755,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         if let ty::Dynamic(a_data, _, _) = a.kind()\n             && let ty::Dynamic(b_data, _, _) = b.kind()\n+            && a_data.principal_def_id() == b_data.principal_def_id()\n         {\n-            if a_data.principal_def_id() == b_data.principal_def_id() {\n-                return self.unify_and(a, b, |_| vec![]);\n-            } else if !self.tcx().features().trait_upcasting {\n-                let mut err = feature_err(\n-                    &self.tcx.sess.parse_sess,\n-                    sym::trait_upcasting,\n-                    self.cause.span,\n-                    &format!(\n-                        \"cannot cast `{a}` to `{b}`, trait upcasting coercion is experimental\"\n-                    ),\n-                );\n-                err.emit();\n-            }\n+            return self.unify_and(a, b, |_| vec![]);\n         }\n \n         // Check the obligations of the cast -- for example, when casting\n@@ -796,19 +785,16 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ])\n             .collect();\n \n-        // Enforce that the type is `usize`/pointer-sized. For now, only those\n-        // can be coerced to `dyn*`, except for `dyn* -> dyn*` upcasts.\n-        if !a.is_dyn_star() {\n-            obligations.push(Obligation::new(\n-                self.tcx,\n-                self.cause.clone(),\n-                self.param_env,\n-                ty::Binder::dummy(\n-                    self.tcx.at(self.cause.span).mk_trait_ref(hir::LangItem::PointerSized, [a]),\n-                )\n-                .to_poly_trait_predicate(),\n-            ));\n-        }\n+        // Enforce that the type is `usize`/pointer-sized.\n+        obligations.push(Obligation::new(\n+            self.tcx,\n+            self.cause.clone(),\n+            self.param_env,\n+            ty::Binder::dummy(\n+                self.tcx.at(self.cause.span).mk_trait_ref(hir::LangItem::PointerSized, [a]),\n+            )\n+            .to_poly_trait_predicate(),\n+        ));\n \n         Ok(InferOk {\n             value: (vec![Adjustment { kind: Adjust::DynStar, target: b }], b),"}, {"sha": "fd8ea1ad7bff4c503d3e93203fe800a75601f995", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -9,9 +9,10 @@ use hir::{\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_index::vec::IndexVec;\n+use rustc_infer::infer::InferCtxt;\n use rustc_middle::{\n     hir::map::Map,\n-    ty::{TyCtxt, TypeckResults},\n+    ty::{ParamEnv, TyCtxt, TypeVisitable, TypeckResults},\n };\n use std::mem::swap;\n \n@@ -21,20 +22,29 @@ use std::mem::swap;\n /// The resulting structure still needs to be iterated to a fixed point, which\n /// can be done with propagate_to_fixpoint in cfg_propagate.\n pub(super) fn build_control_flow_graph<'tcx>(\n-    hir: Map<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     typeck_results: &TypeckResults<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     consumed_borrowed_places: ConsumedAndBorrowedPlaces,\n     body: &'tcx Body<'tcx>,\n     num_exprs: usize,\n ) -> (DropRangesBuilder, FxHashSet<HirId>) {\n-    let mut drop_range_visitor =\n-        DropRangeVisitor::new(hir, tcx, typeck_results, consumed_borrowed_places, num_exprs);\n+    let mut drop_range_visitor = DropRangeVisitor::new(\n+        infcx,\n+        typeck_results,\n+        param_env,\n+        consumed_borrowed_places,\n+        num_exprs,\n+    );\n     intravisit::walk_body(&mut drop_range_visitor, body);\n \n     drop_range_visitor.drop_ranges.process_deferred_edges();\n-    if let Some(filename) = &tcx.sess.opts.unstable_opts.dump_drop_tracking_cfg {\n-        super::cfg_visualize::write_graph_to_file(&drop_range_visitor.drop_ranges, filename, tcx);\n+    if let Some(filename) = &infcx.tcx.sess.opts.unstable_opts.dump_drop_tracking_cfg {\n+        super::cfg_visualize::write_graph_to_file(\n+            &drop_range_visitor.drop_ranges,\n+            filename,\n+            infcx.tcx,\n+        );\n     }\n \n     (drop_range_visitor.drop_ranges, drop_range_visitor.places.borrowed_temporaries)\n@@ -82,40 +92,44 @@ pub(super) fn build_control_flow_graph<'tcx>(\n /// ```\n \n struct DropRangeVisitor<'a, 'tcx> {\n-    hir: Map<'tcx>,\n+    typeck_results: &'a TypeckResults<'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     places: ConsumedAndBorrowedPlaces,\n     drop_ranges: DropRangesBuilder,\n     expr_index: PostOrderId,\n-    tcx: TyCtxt<'tcx>,\n-    typeck_results: &'a TypeckResults<'tcx>,\n     label_stack: Vec<(Option<rustc_ast::Label>, PostOrderId)>,\n }\n \n impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n     fn new(\n-        hir: Map<'tcx>,\n-        tcx: TyCtxt<'tcx>,\n+        infcx: &'a InferCtxt<'tcx>,\n         typeck_results: &'a TypeckResults<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n         places: ConsumedAndBorrowedPlaces,\n         num_exprs: usize,\n     ) -> Self {\n         debug!(\"consumed_places: {:?}\", places.consumed);\n         let drop_ranges = DropRangesBuilder::new(\n             places.consumed.iter().flat_map(|(_, places)| places.iter().cloned()),\n-            hir,\n+            infcx.tcx.hir(),\n             num_exprs,\n         );\n         Self {\n-            hir,\n+            infcx,\n+            typeck_results,\n+            param_env,\n             places,\n             drop_ranges,\n             expr_index: PostOrderId::from_u32(0),\n-            typeck_results,\n-            tcx,\n             label_stack: vec![],\n         }\n     }\n \n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n     fn record_drop(&mut self, value: TrackedValue) {\n         if self.places.borrowed.contains(&value) {\n             debug!(\"not marking {:?} as dropped because it is borrowed at some point\", value);\n@@ -137,7 +151,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n             .map_or(vec![], |places| places.iter().cloned().collect());\n         for place in places {\n             trace!(?place, \"consuming place\");\n-            for_each_consumable(self.hir, place, |value| self.record_drop(value));\n+            for_each_consumable(self.tcx().hir(), place, |value| self.record_drop(value));\n         }\n     }\n \n@@ -214,10 +228,15 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n     /// return.\n     fn handle_uninhabited_return(&mut self, expr: &Expr<'tcx>) {\n         let ty = self.typeck_results.expr_ty(expr);\n-        let ty = self.tcx.erase_regions(ty);\n-        let m = self.tcx.parent_module(expr.hir_id).to_def_id();\n-        let param_env = self.tcx.param_env(m.expect_local());\n-        if !ty.is_inhabited_from(self.tcx, m, param_env) {\n+        let ty = self.infcx.resolve_vars_if_possible(ty);\n+        if ty.has_non_region_infer() {\n+            self.tcx()\n+                .sess\n+                .delay_span_bug(expr.span, format!(\"could not resolve infer vars in `{ty}`\"));\n+        }\n+        let ty = self.tcx().erase_regions(ty);\n+        let m = self.tcx().parent_module(expr.hir_id).to_def_id();\n+        if !ty.is_inhabited_from(self.tcx(), m, self.param_env) {\n             // This function will not return. We model this fact as an infinite loop.\n             self.drop_ranges.add_control_edge(self.expr_index + 1, self.expr_index + 1);\n         }\n@@ -238,7 +257,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n         destination: hir::Destination,\n     ) -> Result<HirId, LoopIdError> {\n         destination.target_id.map(|target| {\n-            let node = self.hir.get(target);\n+            let node = self.tcx().hir().get(target);\n             match node {\n                 hir::Node::Expr(_) => target,\n                 hir::Node::Block(b) => find_last_block_expression(b),"}, {"sha": "2abcadcc9ce7de4f6335daf6c9febc0ca8d3a6c4", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -43,9 +43,9 @@ pub fn compute_drop_ranges<'a, 'tcx>(\n         let typeck_results = &fcx.typeck_results.borrow();\n         let num_exprs = fcx.tcx.region_scope_tree(def_id).body_expr_count(body.id()).unwrap_or(0);\n         let (mut drop_ranges, borrowed_temporaries) = build_control_flow_graph(\n-            fcx.tcx.hir(),\n-            fcx.tcx,\n+            &fcx,\n             typeck_results,\n+            fcx.param_env,\n             consumed_borrowed_places,\n             body,\n             num_exprs,"}, {"sha": "67cf66f470829d8f20f56bd999bac7461db566e2", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1245,6 +1245,23 @@ impl<'tcx> LateContext<'tcx> {\n \n         AbsolutePathPrinter { tcx: self.tcx }.print_def_path(def_id, &[]).unwrap()\n     }\n+\n+    /// Returns the associated type `name` for `self_ty` as an implementation of `trait_id`.\n+    /// Do not invoke without first verifying that the type implements the trait.\n+    pub fn get_associated_type(\n+        &self,\n+        self_ty: Ty<'tcx>,\n+        trait_id: DefId,\n+        name: &str,\n+    ) -> Option<Ty<'tcx>> {\n+        let tcx = self.tcx;\n+        tcx.associated_items(trait_id)\n+            .find_by_name_and_kind(tcx, Ident::from_str(name), ty::AssocKind::Type, trait_id)\n+            .and_then(|assoc| {\n+                let proj = tcx.mk_projection(assoc.def_id, tcx.mk_substs_trait(self_ty, []));\n+                tcx.try_normalize_erasing_regions(self.param_env, proj).ok()\n+            })\n+    }\n }\n \n impl<'tcx> abi::HasDataLayout for LateContext<'tcx> {"}, {"sha": "1d29a234a3c882192c31cf9b81aabca6a8db9022", "filename": "compiler/rustc_lint/src/deref_into_dyn_supertrait.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,92 @@\n+use crate::{LateContext, LateLintPass, LintContext};\n+\n+use rustc_errors::DelayDm;\n+use rustc_hir as hir;\n+use rustc_middle::{traits::util::supertraits, ty};\n+use rustc_span::sym;\n+\n+declare_lint! {\n+    /// The `deref_into_dyn_supertrait` lint is output whenever there is a use of the\n+    /// `Deref` implementation with a `dyn SuperTrait` type as `Output`.\n+    ///\n+    /// These implementations will become shadowed when the `trait_upcasting` feature is stabilized.\n+    /// The `deref` functions will no longer be called implicitly, so there might be behavior change.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(deref_into_dyn_supertrait)]\n+    /// #![allow(dead_code)]\n+    ///\n+    /// use core::ops::Deref;\n+    ///\n+    /// trait A {}\n+    /// trait B: A {}\n+    /// impl<'a> Deref for dyn 'a + B {\n+    ///     type Target = dyn A;\n+    ///     fn deref(&self) -> &Self::Target {\n+    ///         todo!()\n+    ///     }\n+    /// }\n+    ///\n+    /// fn take_a(_: &dyn A) { }\n+    ///\n+    /// fn take_b(b: &dyn B) {\n+    ///     take_a(b);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The dyn upcasting coercion feature adds new coercion rules, taking priority\n+    /// over certain other coercion rules, which will cause some behavior change.\n+    pub DEREF_INTO_DYN_SUPERTRAIT,\n+    Warn,\n+    \"`Deref` implementation usage with a supertrait trait object for output might be shadowed in the future\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #89460 <https://github.com/rust-lang/rust/issues/89460>\",\n+    };\n+}\n+\n+declare_lint_pass!(DerefIntoDynSupertrait => [DEREF_INTO_DYN_SUPERTRAIT]);\n+\n+impl<'tcx> LateLintPass<'tcx> for DerefIntoDynSupertrait {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n+        // `Deref` is being implemented for `t`\n+        if let hir::ItemKind::Impl(impl_) = item.kind\n+            && let Some(trait_) = &impl_.of_trait\n+            && let t = cx.tcx.type_of(item.owner_id)\n+            && let opt_did @ Some(did) = trait_.trait_def_id()\n+            && opt_did == cx.tcx.lang_items().deref_trait()\n+            // `t` is `dyn t_principal`\n+            && let ty::Dynamic(data, _, ty::Dyn) = t.kind()\n+            && let Some(t_principal) = data.principal()\n+            // `<T as Deref>::Target` is `dyn target_principal`\n+            && let Some(target) = cx.get_associated_type(t, did, \"Target\")\n+            && let ty::Dynamic(data, _, ty::Dyn) = target.kind()\n+            && let Some(target_principal) = data.principal()\n+            // `target_principal` is a supertrait of `t_principal`\n+            && supertraits(cx.tcx, t_principal.with_self_ty(cx.tcx, cx.tcx.types.trait_object_dummy_self))\n+                .any(|sup| sup.map_bound(|x| ty::ExistentialTraitRef::erase_self_ty(cx.tcx, x)) == target_principal)\n+        {\n+            cx.struct_span_lint(\n+                DEREF_INTO_DYN_SUPERTRAIT,\n+                cx.tcx.def_span(item.owner_id.def_id),\n+                DelayDm(|| {\n+                    format!(\n+                        \"`{t}` implements `Deref` with supertrait `{target_principal}` as target\"\n+                    )\n+                }),\n+                |lint| {\n+                    if let Some(target_span) = impl_.items.iter().find_map(|i| (i.ident.name == sym::Target).then_some(i.span)) {\n+                        lint.span_label(target_span, \"target type is set here\");\n+                    }\n+\n+                    lint\n+                },\n+            )\n+        }\n+    }\n+}"}, {"sha": "b6027476adfd97f3d2f8c05062fc1d652d44d890", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -49,6 +49,7 @@ extern crate tracing;\n mod array_into_iter;\n pub mod builtin;\n mod context;\n+mod deref_into_dyn_supertrait;\n mod early;\n mod enum_intrinsics_non_enums;\n mod errors;\n@@ -87,6 +88,7 @@ use rustc_span::Span;\n \n use array_into_iter::ArrayIntoIter;\n use builtin::*;\n+use deref_into_dyn_supertrait::*;\n use enum_intrinsics_non_enums::EnumIntrinsicsNonEnums;\n use for_loops_over_fallibles::*;\n use hidden_unicode_codepoints::*;\n@@ -192,6 +194,7 @@ macro_rules! late_lint_mod_passes {\n             $args,\n             [\n                 ForLoopsOverFallibles: ForLoopsOverFallibles,\n+                DerefIntoDynSupertrait: DerefIntoDynSupertrait,\n                 HardwiredLints: HardwiredLints,\n                 ImproperCTypesDeclarations: ImproperCTypesDeclarations,\n                 ImproperCTypesDefinitions: ImproperCTypesDefinitions,"}, {"sha": "df0e17dea3c051495593062c68485307b168bf01", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -3262,7 +3262,6 @@ declare_lint_pass! {\n         UNUSED_TUPLE_STRUCT_FIELDS,\n         NON_EXHAUSTIVE_OMITTED_PATTERNS,\n         TEXT_DIRECTION_CODEPOINT_IN_COMMENT,\n-        DEREF_INTO_DYN_SUPERTRAIT,\n         DEPRECATED_CFG_ATTR_CRATE_TYPE_NAME,\n         DUPLICATE_MACRO_ATTRIBUTES,\n         SUSPICIOUS_AUTO_TRAIT_IMPLS,\n@@ -3764,51 +3763,6 @@ declare_lint! {\n     \"invisible directionality-changing codepoints in comment\"\n }\n \n-declare_lint! {\n-    /// The `deref_into_dyn_supertrait` lint is output whenever there is a use of the\n-    /// `Deref` implementation with a `dyn SuperTrait` type as `Output`.\n-    ///\n-    /// These implementations will become shadowed when the `trait_upcasting` feature is stabilized.\n-    /// The `deref` functions will no longer be called implicitly, so there might be behavior change.\n-    ///\n-    /// ### Example\n-    ///\n-    /// ```rust,compile_fail\n-    /// #![deny(deref_into_dyn_supertrait)]\n-    /// #![allow(dead_code)]\n-    ///\n-    /// use core::ops::Deref;\n-    ///\n-    /// trait A {}\n-    /// trait B: A {}\n-    /// impl<'a> Deref for dyn 'a + B {\n-    ///     type Target = dyn A;\n-    ///     fn deref(&self) -> &Self::Target {\n-    ///         todo!()\n-    ///     }\n-    /// }\n-    ///\n-    /// fn take_a(_: &dyn A) { }\n-    ///\n-    /// fn take_b(b: &dyn B) {\n-    ///     take_a(b);\n-    /// }\n-    /// ```\n-    ///\n-    /// {{produces}}\n-    ///\n-    /// ### Explanation\n-    ///\n-    /// The dyn upcasting coercion feature adds new coercion rules, taking priority\n-    /// over certain other coercion rules, which will cause some behavior change.\n-    pub DEREF_INTO_DYN_SUPERTRAIT,\n-    Warn,\n-    \"`Deref` implementation usage with a supertrait trait object for output might be shadowed in the future\",\n-    @future_incompatible = FutureIncompatibleInfo {\n-        reference: \"issue #89460 <https://github.com/rust-lang/rust/issues/89460>\",\n-    };\n-}\n-\n declare_lint! {\n     /// The `duplicate_macro_attributes` lint detects when a `#[test]`-like built-in macro\n     /// attribute is duplicated on an item. This lint may trigger on `bench`, `cfg_eval`, `test`"}, {"sha": "5f02bb6c3070f7d5b93cf9f781dbf77562e07eab", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -800,7 +800,7 @@ LLVMRustOptimize(\n       auto Plugin = PassPlugin::Load(PluginPath.str());\n       if (!Plugin) {\n         LLVMRustSetLastError((\"Failed to load pass plugin\" + PluginPath.str()).c_str());\n-        continue;\n+        return LLVMRustResult::Failure;\n       }\n       Plugin->registerPassBuilderCallbacks(PB);\n     }"}, {"sha": "e369dba55242c8f1703b38120a99489ca2c80e0f", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1044,11 +1044,19 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n                     name,\n                     typeck_results.node_type(pat.hir_id),\n                 );\n-                sess.struct_span_err(pat.span, \"borrow of moved value\")\n-                    .span_label(binding_span, format!(\"value moved into `{}` here\", name))\n+                let mut err = sess.struct_span_err(pat.span, \"borrow of moved value\");\n+                err.span_label(binding_span, format!(\"value moved into `{}` here\", name))\n                     .span_label(binding_span, occurs_because)\n-                    .span_labels(conflicts_ref, \"value borrowed here after move\")\n-                    .emit();\n+                    .span_labels(conflicts_ref, \"value borrowed here after move\");\n+                if pat.span.contains(binding_span) {\n+                    err.span_suggestion_verbose(\n+                        binding_span.shrink_to_lo(),\n+                        \"borrow this binding in the pattern to avoid moving the value\",\n+                        \"ref \".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                err.emit();\n             }\n             return;\n         }"}, {"sha": "9f2267efb82872569ea399de4c47ea569cf98c66", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1734,7 +1734,7 @@ impl<'a> Parser<'a> {\n                         expr.kind,\n                         ExprKind::While(_, _, None)\n                             | ExprKind::ForLoop(_, _, _, None)\n-                            | ExprKind::Loop(_, None)\n+                            | ExprKind::Loop(_, None, _)\n                             | ExprKind::Block(_, None)\n                     )\n                 {\n@@ -2444,10 +2444,11 @@ impl<'a> Parser<'a> {\n \n     /// Parses `loop { ... }` (`loop` token already eaten).\n     fn parse_loop_expr(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n+        let loop_span = self.prev_token.span;\n         let (attrs, body) = self.parse_inner_attrs_and_block()?;\n         Ok(self.mk_expr_with_attrs(\n             lo.to(self.prev_token.span),\n-            ExprKind::Loop(body, opt_label),\n+            ExprKind::Loop(body, opt_label, loop_span),\n             attrs,\n         ))\n     }"}, {"sha": "93b0f5814dedf297a9e92d96bea6085df0de393f", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -3841,7 +3841,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 }\n             }\n \n-            ExprKind::Loop(ref block, label) => self.resolve_labeled_block(label, expr.id, &block),\n+            ExprKind::Loop(ref block, label, _) => {\n+                self.resolve_labeled_block(label, expr.id, &block)\n+            }\n \n             ExprKind::While(ref cond, ref block, label) => {\n                 self.with_resolved_label(label, expr.id, |this| {"}, {"sha": "cd4a0447391720bd83835ca3572c2f84f5f6132f", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -6,11 +6,9 @@\n //!\n //! [rustc dev guide]:https://rustc-dev-guide.rust-lang.org/traits/resolution.html#candidate-assembly\n use hir::LangItem;\n-use rustc_errors::DelayDm;\n use rustc_hir as hir;\n use rustc_infer::traits::ObligationCause;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n-use rustc_lint_defs::builtin::DEREF_INTO_DYN_SUPERTRAIT;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, Ty, TypeVisitable};\n use rustc_target::spec::abi::Abi;\n@@ -776,9 +774,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match (source.kind(), target.kind()) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::Dynamic(ref data_a, _, dyn_a), &ty::Dynamic(ref data_b, _, dyn_b))\n-                if dyn_a == dyn_b =>\n-            {\n+            (&ty::Dynamic(ref data_a, _, ty::Dyn), &ty::Dynamic(ref data_b, _, ty::Dyn)) => {\n                 // Upcast coercions permit several things:\n                 //\n                 // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n@@ -811,16 +807,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             &obligation.cause,\n                         ) {\n                             if deref_trait_ref.def_id() == target_trait_did {\n-                                self.tcx().struct_span_lint_hir(\n-                                    DEREF_INTO_DYN_SUPERTRAIT,\n-                                    obligation.cause.body_id,\n-                                    obligation.cause.span,\n-                                    DelayDm(|| format!(\n-                                        \"`{}` implements `Deref` with supertrait `{}` as output\",\n-                                        source, deref_trait_ref\n-                                    )),\n-                                    |lint| lint,\n-                                );\n                                 return;\n                             }\n                         }"}, {"sha": "3cffd2bb7801766ee6d1a9f7884b09ae13bccd5d", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -803,9 +803,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let upcast_trait_ref;\n         match (source.kind(), target.kind()) {\n             // TraitA+Kx+'a -> TraitB+Ky+'b (trait upcasting coercion).\n-            (&ty::Dynamic(ref data_a, r_a, repr_a), &ty::Dynamic(ref data_b, r_b, repr_b))\n-                if repr_a == repr_b =>\n-            {\n+            (\n+                &ty::Dynamic(ref data_a, r_a, repr_a @ ty::Dyn),\n+                &ty::Dynamic(ref data_b, r_b, ty::Dyn),\n+            ) => {\n                 // See `assemble_candidates_for_unsizing` for more info.\n                 // We already checked the compatibility of auto traits within `assemble_candidates_for_unsizing`.\n                 let principal_a = data_a.principal().unwrap();\n@@ -831,7 +832,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             .map(ty::Binder::dummy),\n                     );\n                 let existential_predicates = tcx.mk_poly_existential_predicates(iter);\n-                let source_trait = tcx.mk_dynamic(existential_predicates, r_b, repr_b);\n+                let source_trait = tcx.mk_dynamic(existential_predicates, r_b, repr_a);\n \n                 // Require that the traits involved in this upcast are **equal**;\n                 // only the **lifetime bound** is changed."}, {"sha": "ef28e2a855a04cc353c849c6d6ab18e982cf02d7", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1071,7 +1071,7 @@ fn write_impl_section_heading(w: &mut Buffer, title: &str, id: &str) {\n         w,\n         \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n             {title}\\\n-            <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n+            <a href=\\\"#{id}\\\" class=\\\"anchor\\\">\u00a7</a>\\\n          </h2>\"\n     );\n }\n@@ -1536,7 +1536,7 @@ fn render_impl(\n                     render_rightside(w, cx, item, containing_item, render_mode);\n                     if trait_.is_some() {\n                         // Anchors are only used on trait impls.\n-                        write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n+                        write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\">\u00a7</a>\", id);\n                     }\n                     w.write_str(\"<h4 class=\\\"code-header\\\">\");\n                     render_assoc_item(\n@@ -1562,7 +1562,7 @@ fn render_impl(\n                 render_rightside(w, cx, item, containing_item, render_mode);\n                 if trait_.is_some() {\n                     // Anchors are only used on trait impls.\n-                    write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n+                    write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\">\u00a7</a>\", id);\n                 }\n                 w.write_str(\"<h4 class=\\\"code-header\\\">\");\n                 assoc_const(\n@@ -1587,7 +1587,7 @@ fn render_impl(\n                 write!(w, \"<section id=\\\"{}\\\" class=\\\"{}{}\\\">\", id, item_type, in_trait_class);\n                 if trait_.is_some() {\n                     // Anchors are only used on trait impls.\n-                    write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n+                    write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\">\u00a7</a>\", id);\n                 }\n                 w.write_str(\"<h4 class=\\\"code-header\\\">\");\n                 assoc_type(\n@@ -1613,7 +1613,7 @@ fn render_impl(\n                 );\n                 if trait_.is_some() {\n                     // Anchors are only used on trait impls.\n-                    write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n+                    write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\">\u00a7</a>\", id);\n                 }\n                 w.write_str(\"<h4 class=\\\"code-header\\\">\");\n                 assoc_type(\n@@ -1846,7 +1846,7 @@ pub(crate) fn render_impl_summary(\n     };\n     write!(w, \"<section id=\\\"{}\\\" class=\\\"impl has-srclink\\\"{}>\", id, aliases);\n     render_rightside(w, cx, &i.impl_item, containing_item, RenderMode::Normal);\n-    write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n+    write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\">\u00a7</a>\", id);\n     write!(w, \"<h3 class=\\\"code-header\\\">\");\n \n     if let Some(use_absolute) = use_absolute {"}, {"sha": "0f9b3b15c77ff15ce58acb69ec5e8c7d72797914", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -717,7 +717,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         write!(\n             w,\n             \"<h2 id=\\\"{0}\\\" class=\\\"small-section-header\\\">\\\n-                {1}<a href=\\\"#{0}\\\" class=\\\"anchor\\\"></a>\\\n+                {1}<a href=\\\"#{0}\\\" class=\\\"anchor\\\">\u00a7</a>\\\n              </h2>{2}\",\n             id, title, extra_content\n         )\n@@ -1147,7 +1147,7 @@ fn item_union(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean:\n         write!(\n             w,\n             \"<h2 id=\\\"fields\\\" class=\\\"fields small-section-header\\\">\\\n-                Fields<a href=\\\"#fields\\\" class=\\\"anchor\\\"></a>\\\n+                Fields<a href=\\\"#fields\\\" class=\\\"anchor\\\">\u00a7</a>\\\n             </h2>\"\n         );\n         for (field, ty) in fields {\n@@ -1156,7 +1156,7 @@ fn item_union(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean:\n             write!(\n                 w,\n                 \"<span id=\\\"{id}\\\" class=\\\"{shortty} small-section-header\\\">\\\n-                     <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                     <a href=\\\"#{id}\\\" class=\\\"anchor field\\\">\u00a7</a>\\\n                      <code>{name}: {ty}</code>\\\n                  </span>\",\n                 id = id,\n@@ -1262,7 +1262,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n         write!(\n             w,\n             \"<h2 id=\\\"variants\\\" class=\\\"variants small-section-header\\\">\\\n-                Variants{}<a href=\\\"#variants\\\" class=\\\"anchor\\\"></a>\\\n+                Variants{}<a href=\\\"#variants\\\" class=\\\"anchor\\\">\u00a7</a>\\\n             </h2>\",\n             document_non_exhaustive_header(it)\n         );\n@@ -1273,7 +1273,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n             write!(\n                 w,\n                 \"<section id=\\\"{id}\\\" class=\\\"variant\\\">\\\n-                    <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\",\n+                    <a href=\\\"#{id}\\\" class=\\\"anchor\\\">\u00a7</a>\",\n                 id = id,\n             );\n             render_stability_since_raw_with_extra(\n@@ -1325,7 +1325,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n                                 w,\n                                 \"<div class=\\\"sub-variant-field\\\">\\\n                                  <span id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n-                                     <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                                     <a href=\\\"#{id}\\\" class=\\\"anchor field\\\">\u00a7</a>\\\n                                      <code>{f}:&nbsp;{t}</code>\\\n                                  </span>\",\n                                 id = id,\n@@ -1477,7 +1477,7 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n             write!(\n                 w,\n                 \"<h2 id=\\\"fields\\\" class=\\\"fields small-section-header\\\">\\\n-                     {}{}<a href=\\\"#fields\\\" class=\\\"anchor\\\"></a>\\\n+                     {}{}<a href=\\\"#fields\\\" class=\\\"anchor\\\">\u00a7</a>\\\n                  </h2>\",\n                 if s.ctor_kind.is_none() { \"Fields\" } else { \"Tuple Fields\" },\n                 document_non_exhaustive_header(it)\n@@ -1490,7 +1490,7 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n                 write!(\n                     w,\n                     \"<span id=\\\"{id}\\\" class=\\\"{item_type} small-section-header\\\">\\\n-                         <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                         <a href=\\\"#{id}\\\" class=\\\"anchor field\\\">\u00a7</a>\\\n                          <code>{name}: {ty}</code>\\\n                      </span>\",\n                     item_type = ItemType::StructField,\n@@ -1908,7 +1908,7 @@ fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n     writeln!(\n         w,\n         \"<h2 id=\\\"layout\\\" class=\\\"small-section-header\\\"> \\\n-        Layout<a href=\\\"#layout\\\" class=\\\"anchor\\\"></a></h2>\"\n+        Layout<a href=\\\"#layout\\\" class=\\\"anchor\\\">\u00a7</a></h2>\"\n     );\n     writeln!(w, \"<div class=\\\"docblock\\\">\");\n "}, {"sha": "e0a4f2364b682e526ef994c8c9cb106d96f5069e", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -730,9 +730,6 @@ a {\n h2.small-section-header > .anchor {\n \tpadding-right: 6px;\n }\n-.anchor::before {\n-\tcontent: '\u00a7';\n-}\n \n .main-heading a:hover,\n .example-wrap > pre.rust a:hover,"}, {"sha": "aa3bf827db4bf5d0c60ab36e98c133105fef4040", "filename": "src/librustdoc/html/templates/page.html", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -115,6 +115,7 @@ <h2></h2> {#- -#}\n                     <input {# -#}\n                         class=\"search-input\" {# -#}\n                         name=\"search\" {# -#}\n+                        aria-label=\"Run search in the documentation\" {# -#}\n                         autocomplete=\"off\" {# -#}\n                         spellcheck=\"false\" {# -#}\n                         placeholder=\"Click or press \u2018S\u2019 to search, \u2018?\u2019 for more options\u2026\" {# -#}"}, {"sha": "7f72942958141bf055d41db2272856dcd307ed7e", "filename": "src/test/ui/async-await/drop-tracking-unresolved-typeck-results.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,106 @@\n+// compile-flags: -Zdrop-tracking\n+// incremental\n+// edition: 2021\n+\n+use std::future::*;\n+use std::marker::PhantomData;\n+use std::pin::Pin;\n+use std::task::*;\n+\n+fn send<T: Send>(_: T) {}\n+\n+pub trait Stream {\n+    type Item;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;\n+}\n+\n+struct Empty<T>(PhantomData<fn() -> T>);\n+\n+impl<T> Stream for Empty<T> {\n+    type Item = T;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        todo!()\n+    }\n+}\n+\n+pub trait FnOnce1<A> {\n+    type Output;\n+    fn call_once(self, arg: A) -> Self::Output;\n+}\n+\n+impl<T, A, R> FnOnce1<A> for T\n+where\n+    T: FnOnce(A) -> R,\n+{\n+    type Output = R;\n+    fn call_once(self, arg: A) -> R {\n+        self(arg)\n+    }\n+}\n+\n+pub trait FnMut1<A>: FnOnce1<A> {\n+    fn call_mut(&mut self, arg: A) -> Self::Output;\n+}\n+\n+impl<T, A, R> FnMut1<A> for T\n+where\n+    T: FnMut(A) -> R,\n+{\n+    fn call_mut(&mut self, arg: A) -> R {\n+        self(arg)\n+    }\n+}\n+\n+struct Map<St, F>(St, F);\n+\n+impl<St, F> Stream for Map<St, F>\n+where\n+    St: Stream,\n+    F: FnMut1<St::Item>,\n+{\n+    type Item = F::Output;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        todo!()\n+    }\n+}\n+\n+struct FuturesOrdered<T: Future>(PhantomData<fn() -> T::Output>);\n+\n+pub struct Buffered<St: Stream>(St, FuturesOrdered<St::Item>, usize)\n+where\n+    St::Item: Future;\n+\n+impl<St> Stream for Buffered<St>\n+where\n+    St: Stream,\n+    St::Item: Future,\n+{\n+    type Item = <St::Item as Future>::Output;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        todo!()\n+    }\n+}\n+\n+struct Next<'a, T: ?Sized>(&'a T);\n+\n+impl<St: ?Sized + Stream + Unpin> Future for Next<'_, St> {\n+    type Output = Option<St::Item>;\n+\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        todo!()\n+    }\n+}\n+\n+fn main() {\n+    send(async {\n+        //~^ ERROR implementation of `FnOnce` is not general enough\n+        //~| ERROR implementation of `FnOnce` is not general enough\n+        //~| ERROR implementation of `FnOnce` is not general enough\n+        //~| ERROR implementation of `FnOnce` is not general enough\n+        Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+    });\n+}"}, {"sha": "aa9a22e9e72ea53d4da1fc04f7c4a54635eed6a8", "filename": "src/test/ui/async-await/drop-tracking-unresolved-typeck-results.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,62 @@\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/drop-tracking-unresolved-typeck-results.rs:99:5\n+   |\n+LL | /     send(async {\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+LL | |     });\n+   | |______^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&'0 ()) -> std::future::Ready<&'0 ()> {std::future::ready::<&'0 ()>}` must implement `FnOnce<(&'1 (),)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but it actually implements `FnOnce<(&(),)>`\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/drop-tracking-unresolved-typeck-results.rs:99:5\n+   |\n+LL | /     send(async {\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+LL | |     });\n+   | |______^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&'0 ()) -> std::future::Ready<&'0 ()> {std::future::ready::<&'0 ()>}` must implement `FnOnce<(&'1 (),)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but it actually implements `FnOnce<(&(),)>`\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/drop-tracking-unresolved-typeck-results.rs:99:5\n+   |\n+LL | /     send(async {\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+LL | |     });\n+   | |______^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&'0 ()) -> std::future::Ready<&'0 ()> {std::future::ready::<&'0 ()>}` must implement `FnOnce<(&'1 (),)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but it actually implements `FnOnce<(&(),)>`\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/drop-tracking-unresolved-typeck-results.rs:99:5\n+   |\n+LL | /     send(async {\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+LL | |     });\n+   | |______^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&'0 ()) -> std::future::Ready<&'0 ()> {std::future::ready::<&'0 ()>}` must implement `FnOnce<(&'1 (),)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but it actually implements `FnOnce<(&(),)>`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "0ec2ae8839e7982480ec5f420a5ac5ed28210cda", "filename": "src/test/ui/binding/issue-53114-borrow-checks.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-borrow-checks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-borrow-checks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-borrow-checks.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -17,6 +17,10 @@ LL |     match mm { (_, _y) => { } }\n    |           ^^ value used here after partial move\n    |\n    = note: partial move occurs because `mm.0` has type `M`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     match mm { (ref _x, _) => { } }\n+   |                 +++\n \n error[E0382]: use of partially moved value: `mm`\n   --> $DIR/issue-53114-borrow-checks.rs:29:11\n@@ -28,6 +32,10 @@ LL |     match mm { (_, _) => { } }\n    |           ^^ value used here after partial move\n    |\n    = note: partial move occurs because `mm.1` has type `M`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     match mm { (_, ref _y) => { } }\n+   |                    +++\n \n error[E0382]: use of moved value: `m`\n   --> $DIR/issue-53114-borrow-checks.rs:36:16\n@@ -48,6 +56,10 @@ LL |     if let (_, _y) = mm { }\n    |                      ^^ value used here after partial move\n    |\n    = note: partial move occurs because `mm.0` has type `M`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     if let (ref _x, _) = mm { }\n+   |             +++\n \n error[E0382]: use of partially moved value: `mm`\n   --> $DIR/issue-53114-borrow-checks.rs:43:21\n@@ -59,6 +71,10 @@ LL |     if let (_, _) = mm { }\n    |                     ^^ value used here after partial move\n    |\n    = note: partial move occurs because `mm.1` has type `M`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     if let (_, ref _y) = mm { }\n+   |                +++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "994eaf9d8c77885a219ea90c5a0a41e07896e4ec", "filename": "src/test/ui/binop/binop-move-semantics.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -32,6 +32,10 @@ LL |     +\n LL |     x.clone();\n    |     ^^^^^^^^^ value borrowed here after move\n    |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     x.clone()\n+   |      ++++++++\n help: consider further restricting this bound\n    |\n LL | fn move_then_borrow<T: Add<Output=()> + Clone + Copy>(x: T) {"}, {"sha": "50eee1049db6e479e2c827046b8f484927995f4c", "filename": "src/test/ui/borrowck/bindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -27,6 +27,11 @@ LL |         a @ [.., _] => (),\n ...\n LL |     &x;\n    |     ^^ value borrowed here after move\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref a @ [.., _] => (),\n+   |         +++\n \n error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:28:5\n@@ -71,13 +76,15 @@ LL | fn bindings_after_at_or_patterns_move(x: Option<Test>) {\n    |                                       - move occurs because `x` has type `Option<Test>`, which does not implement the `Copy` trait\n LL |     match x {\n LL |         foo @ Some(Test::Foo | Test::Bar) => (),\n-   |         ---\n-   |         |\n-   |         value moved here\n-   |         value moved here\n+   |         --- value moved here\n ...\n LL |     &x;\n    |     ^^ value borrowed here after move\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref foo @ Some(Test::Foo | Test::Bar) => (),\n+   |         +++\n \n error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:86:5\n@@ -122,13 +129,15 @@ LL | fn bindings_after_at_slice_patterns_or_patterns_moves(x: [Option<Test>; 4])\n    |                                                       - move occurs because `x` has type `[Option<Test>; 4]`, which does not implement the `Copy` trait\n LL |     match x {\n LL |         a @ [.., Some(Test::Foo | Test::Bar)] => (),\n-   |         -\n-   |         |\n-   |         value moved here\n-   |         value moved here\n+   |         - value moved here\n ...\n LL |     &x;\n    |     ^^ value borrowed here after move\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref a @ [.., Some(Test::Foo | Test::Bar)] => (),\n+   |         +++\n \n error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:144:5"}, {"sha": "d2e9497d0795cf6e3b3a202ddb4d48ec36fffaec", "filename": "src/test/ui/borrowck/borrowck-consume-unsize-vec.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-consume-unsize-vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-consume-unsize-vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-consume-unsize-vec.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,18 @@ LL |     consume(b);\n    |             - value moved here\n LL |     consume(b);\n    |             ^ value used here after move\n+   |\n+note: consider changing this parameter type in function `consume` to borrow instead if owning the value isn't necessary\n+  --> $DIR/borrowck-consume-unsize-vec.rs:3:15\n+   |\n+LL | fn consume(_: Box<[i32]>) {\n+   |    -------    ^^^^^^^^^^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     consume(b.clone());\n+   |              ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "ed7e883ca63924c0cc68a116fe375221867d811d", "filename": "src/test/ui/borrowck/borrowck-consume-upcast-box.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-consume-upcast-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-consume-upcast-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-consume-upcast-box.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,14 @@ LL |     consume(b);\n    |             - value moved here\n LL |     consume(b);\n    |             ^ value used here after move\n+   |\n+note: consider changing this parameter type in function `consume` to borrow instead if owning the value isn't necessary\n+  --> $DIR/borrowck-consume-upcast-box.rs:5:15\n+   |\n+LL | fn consume(_: Box<dyn Foo>) {\n+   |    -------    ^^^^^^^^^^^^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n \n error: aborting due to previous error\n "}, {"sha": "eaf4bb38bc5905532ba39d0081673df2cd6e3107", "filename": "src/test/ui/borrowck/borrowck-drop-from-guard.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-drop-from-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-drop-from-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-drop-from-guard.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -9,6 +9,11 @@ LL |         Some(_) if { drop(my_str); false } => {}\n LL |         Some(_) => {}\n LL |         None => { foo(my_str); }\n    |                       ^^^^^^ value used here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         Some(_) if { drop(my_str.clone()); false } => {}\n+   |                                 ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "e1b99162088054e024b885cfb391afac15e6d7d1", "filename": "src/test/ui/borrowck/borrowck-loan-in-overloaded-op.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-loan-in-overloaded-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-loan-in-overloaded-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-loan-in-overloaded-op.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,11 @@ LL |     let _y = {x} + x.clone(); // the `{x}` forces a move to occur\n    |               -    ^^^^^^^^^ value borrowed here after move\n    |               |\n    |               value moved here\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let _y = {x.clone()} + x.clone(); // the `{x}` forces a move to occur\n+   |                ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "67b00c1dd90ce7695fa2bc2f57fb252120045c26", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-match.stderr", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-match.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,6 +8,10 @@ LL |         [.., _y] => {}\n    |              ^^ value used here after move\n    |\n    = note: move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, ref _x] => {}\n+   |                +++\n \n error[E0382]: use of partially moved value: `a[..]`\n   --> $DIR/borrowck-move-out-from-array-match.rs:23:14\n@@ -19,6 +23,10 @@ LL |         [.., _y] => {}\n    |              ^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, (ref _x, _)] => {}\n+   |                 +++\n \n error[E0382]: use of moved value: `a[..].0`\n   --> $DIR/borrowck-move-out-from-array-match.rs:33:15\n@@ -30,6 +38,10 @@ LL |         [.., (_y, _)] => {}\n    |               ^^ value used here after move\n    |\n    = note: move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, (ref _x, _)] => {}\n+   |                 +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-match.rs:44:11\n@@ -41,6 +53,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [ref _x, _, _] => {}\n+   |          +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-match.rs:55:11\n@@ -52,6 +68,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [.., ref _x] => {}\n+   |              +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-match.rs:66:11\n@@ -63,6 +83,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [(ref _x, _), _, _] => {}\n+   |           +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-match.rs:77:11\n@@ -74,6 +98,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [.., (ref _x, _)] => {}\n+   |               +++\n \n error[E0382]: use of moved value: `a[..].0`\n   --> $DIR/borrowck-move-out-from-array-match.rs:89:11\n@@ -85,6 +113,10 @@ LL |         [(_x, _), _, _] => {}\n    |           ^^ value used here after move\n    |\n    = note: move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [ref _y @ .., _, _] => {}\n+   |          +++\n \n error[E0382]: use of moved value: `a[..].0`\n   --> $DIR/borrowck-move-out-from-array-match.rs:99:15\n@@ -96,6 +128,10 @@ LL |         [.., (_x, _)] => {}\n    |               ^^ value used here after move\n    |\n    = note: move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, ref _y @ ..] => {}\n+   |                +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-match.rs:110:11\n@@ -107,6 +143,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [ref x @ .., _] => {}\n+   |          +++\n \n error: aborting due to 10 previous errors\n "}, {"sha": "47429ea3eebae32927f0def3ef6bae5f62f2708b", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-no-overlap-match.stderr", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap-match.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,6 +8,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, ref _x] => {}\n+   |                +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:28:11\n@@ -19,6 +23,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, (ref _x, _)] => {}\n+   |                 +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:41:11\n@@ -30,6 +38,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [ref _x, _, _] => {}\n+   |          +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:52:11\n@@ -41,6 +53,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [.., ref _x] => {}\n+   |              +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:63:11\n@@ -52,6 +68,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [(ref _x, _), _, _] => {}\n+   |           +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:74:11\n@@ -63,6 +83,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [.., (ref _x, _)] => {}\n+   |               +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:85:11\n@@ -74,6 +98,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, ref _y @ ..] => {}\n+   |             +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:96:11\n@@ -85,6 +113,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [ref _y @ .., _] => {}\n+   |          +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:109:11\n@@ -96,6 +128,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [ref x @ .., _, _] => {}\n+   |          +++\n \n error: aborting due to 9 previous errors\n "}, {"sha": "bfab13d42d2a16151132110737c16fc17a9c88be", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use-match.stderr", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-match.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,6 +8,10 @@ LL |         [.., ref _y] => {}\n    |              ^^^^^^ value borrowed here after move\n    |\n    = note: move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, ref _x] => {}\n+   |                +++\n \n error[E0382]: borrow of partially moved value: `a[..]`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:23:14\n@@ -19,6 +23,10 @@ LL |         [.., ref _y] => {}\n    |              ^^^^^^ value borrowed here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, (ref _x, _)] => {}\n+   |                 +++\n \n error[E0382]: borrow of moved value: `a[..].0`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:33:15\n@@ -30,6 +38,10 @@ LL |         [.., (ref _y, _)] => {}\n    |               ^^^^^^ value borrowed here after move\n    |\n    = note: move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, (ref _x, _)] => {}\n+   |                 +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:44:11\n@@ -41,6 +53,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [ref _x, _, _] => {}\n+   |          +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:55:11\n@@ -52,6 +68,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [.., ref _x] => {}\n+   |              +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:66:11\n@@ -63,6 +83,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [(ref _x, _), _, _] => {}\n+   |           +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:77:11\n@@ -74,6 +98,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [.., (ref _x, _)] => {}\n+   |               +++\n \n error[E0382]: borrow of moved value: `a[..]`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:89:11\n@@ -85,6 +113,10 @@ LL |         [(ref _x, _), _, _] => {}\n    |           ^^^^^^ value borrowed here after move\n    |\n    = note: move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [ref _y @ .., _, _] => {}\n+   |          +++\n \n error[E0382]: borrow of moved value: `a[..]`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:99:15\n@@ -96,6 +128,10 @@ LL |         [.., (ref _x, _)] => {}\n    |               ^^^^^^ value borrowed here after move\n    |\n    = note: move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, ref _y @ ..] => {}\n+   |                +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:110:11\n@@ -107,6 +143,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [ref x @ .., _] => {}\n+   |          +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:123:5\n@@ -118,6 +158,10 @@ LL |     a[2] = Default::default();\n    |     ^^^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, ref _x] => {}\n+   |                +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:131:5\n@@ -129,6 +173,10 @@ LL |     a[2].1 = Default::default();\n    |     ^^^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, (ref _x, _)] => {}\n+   |                 +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:139:5\n@@ -140,6 +188,10 @@ LL |     a[0] = Default::default();\n    |     ^^^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, ref _x @ ..] => {}\n+   |                +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:147:5\n@@ -151,6 +203,10 @@ LL |     a[0].1 = Default::default();\n    |     ^^^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, ref _x @ ..] => {}\n+   |                +++\n \n error: aborting due to 14 previous errors\n "}, {"sha": "8412c24fe61122b09dd3280fde6054a6957f4b17", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use-no-overlap-match.stderr", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap-match.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,6 +8,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, ref _x] => {}\n+   |                +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:28:11\n@@ -19,6 +23,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, _, (ref _x, _)] => {}\n+   |                 +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:41:11\n@@ -30,6 +38,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [ref _x, _, _] => {}\n+   |          +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:52:11\n@@ -41,6 +53,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [.., ref _x] => {}\n+   |              +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:63:11\n@@ -52,6 +68,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [(ref _x, _), _, _] => {}\n+   |           +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:74:11\n@@ -63,6 +83,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [.., (ref _x, _)] => {}\n+   |               +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:85:11\n@@ -74,6 +98,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [_, ref _y @ ..] => {}\n+   |             +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:96:11\n@@ -85,6 +113,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [ref _y @ .., _] => {}\n+   |          +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:109:11\n@@ -96,6 +128,10 @@ LL |     match a {\n    |           ^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         [ref x @ .., _, _] => {}\n+   |          +++\n \n error: aborting due to 9 previous errors\n "}, {"sha": "e2aeaafc63c25320f6894415016c0f709eea0e5b", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use.stderr", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,10 @@ LL |     let [.., ref _y] = a;\n    |              ^^^^^^ value borrowed here after move\n    |\n    = note: move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [_, _, ref _x] = a;\n+   |                +++\n \n error[E0382]: borrow of partially moved value: `a[..]`\n   --> $DIR/borrowck-move-out-from-array-use.rs:16:14\n@@ -17,6 +21,10 @@ LL |     let [.., ref _y] = a;\n    |              ^^^^^^ value borrowed here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [_, _, (ref _x, _)] = a;\n+   |                 +++\n \n error[E0382]: borrow of moved value: `a[..].0`\n   --> $DIR/borrowck-move-out-from-array-use.rs:22:15\n@@ -27,6 +35,10 @@ LL |     let [.., (ref _y, _)] = a;\n    |               ^^^^^^ value borrowed here after move\n    |\n    = note: move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [_, _, (ref _x, _)] = a;\n+   |                 +++\n \n error[E0382]: borrow of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use.rs:30:10\n@@ -37,6 +49,10 @@ LL |     let [ref _y @ .., _, _] = a;\n    |          ^^^^^^ value borrowed here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [ref _x, _, _] = a;\n+   |          +++\n \n error[E0382]: borrow of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use.rs:36:16\n@@ -47,6 +63,10 @@ LL |     let [_, _, ref _y @ ..] = a;\n    |                ^^^^^^ value borrowed here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [.., ref _x] = a;\n+   |              +++\n \n error[E0382]: borrow of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use.rs:42:10\n@@ -57,6 +77,10 @@ LL |     let [ref _y @ .., _, _] = a;\n    |          ^^^^^^ value borrowed here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [(ref _x, _), _, _] = a;\n+   |           +++\n \n error[E0382]: borrow of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use.rs:48:16\n@@ -67,6 +91,10 @@ LL |     let [_, _, ref _y @ ..] = a;\n    |                ^^^^^^ value borrowed here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [.., (ref _x, _)] = a;\n+   |               +++\n \n error[E0382]: borrow of moved value: `a[..]`\n   --> $DIR/borrowck-move-out-from-array-use.rs:54:11\n@@ -77,6 +105,10 @@ LL |     let [(ref _x, _), _, _] = a;\n    |           ^^^^^^ value borrowed here after move\n    |\n    = note: move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [ref _y @ .., _, _] = a;\n+   |          +++\n \n error[E0382]: borrow of moved value: `a[..]`\n   --> $DIR/borrowck-move-out-from-array-use.rs:60:15\n@@ -87,6 +119,10 @@ LL |     let [.., (ref _x, _)] = a;\n    |               ^^^^^^ value borrowed here after move\n    |\n    = note: move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [_, _, ref _y @ ..] = a;\n+   |                +++\n \n error[E0382]: borrow of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use.rs:68:13\n@@ -97,6 +133,10 @@ LL |     let [_, ref _y @ ..] = a;\n    |             ^^^^^^ value borrowed here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [ref x @ .., _] = a;\n+   |          +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use.rs:76:5\n@@ -107,6 +147,10 @@ LL |     a[2] = Default::default();\n    |     ^^^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [_, _, ref _x] = a;\n+   |                +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use.rs:82:5\n@@ -117,6 +161,10 @@ LL |     a[2].1 = Default::default();\n    |     ^^^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [_, _, (ref _x, _)] = a;\n+   |                 +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use.rs:88:5\n@@ -127,6 +175,10 @@ LL |     a[0] = Default::default();\n    |     ^^^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [_, _, ref _x @ ..] = a;\n+   |                +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use.rs:94:5\n@@ -137,6 +189,10 @@ LL |     a[0].1 = Default::default();\n    |     ^^^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [_, _, ref _x @ ..] = a;\n+   |                +++\n \n error: aborting due to 14 previous errors\n "}, {"sha": "dd456681f57bc691d42d3b22ee2d46e7a5c14eb4", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array.stderr", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,10 @@ LL |     let [.., _y] = a;\n    |              ^^ value used here after move\n    |\n    = note: move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [_, _, ref _x] = a;\n+   |                +++\n \n error[E0382]: use of partially moved value: `a[..]`\n   --> $DIR/borrowck-move-out-from-array.rs:16:14\n@@ -17,6 +21,10 @@ LL |     let [.., _y] = a;\n    |              ^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [_, _, (ref _x, _)] = a;\n+   |                 +++\n \n error[E0382]: use of moved value: `a[..].0`\n   --> $DIR/borrowck-move-out-from-array.rs:22:15\n@@ -27,6 +35,10 @@ LL |     let [.., (_y, _)] = a;\n    |               ^^ value used here after move\n    |\n    = note: move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [_, _, (ref _x, _)] = a;\n+   |                 +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array.rs:30:10\n@@ -37,6 +49,10 @@ LL |     let [_y @ .., _, _] = a;\n    |          ^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [ref _x, _, _] = a;\n+   |          +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array.rs:36:16\n@@ -47,6 +63,10 @@ LL |     let [_, _, _y @ ..] = a;\n    |                ^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [.., ref _x] = a;\n+   |              +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array.rs:42:10\n@@ -57,6 +77,10 @@ LL |     let [_y @ .., _, _] = a;\n    |          ^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [(ref _x, _), _, _] = a;\n+   |           +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array.rs:48:16\n@@ -67,6 +91,10 @@ LL |     let [_, _, _y @ ..] = a;\n    |                ^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [.., (ref _x, _)] = a;\n+   |               +++\n \n error[E0382]: use of moved value: `a[..].0`\n   --> $DIR/borrowck-move-out-from-array.rs:54:11\n@@ -77,6 +105,10 @@ LL |     let [(_x, _), _, _] = a;\n    |           ^^ value used here after move\n    |\n    = note: move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [ref _y @ .., _, _] = a;\n+   |          +++\n \n error[E0382]: use of moved value: `a[..].0`\n   --> $DIR/borrowck-move-out-from-array.rs:60:15\n@@ -87,6 +119,10 @@ LL |     let [.., (_x, _)] = a;\n    |               ^^ value used here after move\n    |\n    = note: move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [_, _, ref _y @ ..] = a;\n+   |                +++\n \n error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array.rs:68:13\n@@ -97,6 +133,10 @@ LL |     let [_, _y @ ..] = a;\n    |             ^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let [ref x @ .., _] = a;\n+   |          +++\n \n error: aborting due to 10 previous errors\n "}, {"sha": "f94cbc30db421d77c381e2f123be1c4b464b9bc5", "filename": "src/test/ui/borrowck/borrowck-multiple-captures.stderr", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-multiple-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-multiple-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-multiple-captures.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -40,6 +40,11 @@ LL |     thread::spawn(move|| {\n ...\n LL |         drop(x1);\n    |              -- use occurs due to use in closure\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     drop(x1.clone());\n+   |            ++++++++\n \n error[E0382]: use of moved value: `x2`\n   --> $DIR/borrowck-multiple-captures.rs:27:19\n@@ -53,6 +58,11 @@ LL |     thread::spawn(move|| {\n ...\n LL |         drop(x2);\n    |              -- use occurs due to use in closure\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     drop(x2.clone());\n+   |            ++++++++\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/borrowck-multiple-captures.rs:41:14\n@@ -100,6 +110,11 @@ LL |     thread::spawn(move|| {\n LL |\n LL |         drop(x);\n    |              - use occurs due to use in closure\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     drop(x.clone());\n+   |           ++++++++\n \n error: aborting due to 8 previous errors\n "}, {"sha": "fb0e274c2919ab2958b9110b31ed8337cf3d617d", "filename": "src/test/ui/borrowck/borrowck-overloaded-index-move-index.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-move-index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-move-index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-move-index.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -33,6 +33,11 @@ LL |     println!(\"{}\", f[s]);\n ...\n LL |     f[s] = 10;\n    |       ^ value used here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     println!(\"{}\", f[s.clone()]);\n+   |                       ++++++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "f785900d53fc0c8b3b19d212699458361cc38d01", "filename": "src/test/ui/borrowck/borrowck-reinit.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,6 +8,11 @@ LL |     drop(x);\n    |          - value moved here\n LL |     let _ = (1,x);\n    |                ^ value used here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     drop(x.clone());\n+   |           ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "ad898fcabd9dbfab6df5fb1b94e7b02585f10aad", "filename": "src/test/ui/borrowck/issue-31287-drop-in-guard.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fissue-31287-drop-in-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fissue-31287-drop-in-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-31287-drop-in-guard.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,6 +8,11 @@ LL |         Some(_) if { drop(a); false } => None,\n    |                           - value moved here\n LL |         x => x,\n    |         ^ value used here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         Some(_) if { drop(a.clone()); false } => None,\n+   |                            ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "716cc9d0c8ba26af893beac1735a2a62d15e7100", "filename": "src/test/ui/borrowck/issue-41962.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -5,7 +5,7 @@ LL |         if let Some(thing) = maybe {\n    |                     ^^^^^ value moved here, in previous iteration of loop\n    |\n    = note: move occurs because value has type `Vec<bool>`, which does not implement the `Copy` trait\n-help: borrow this field in the pattern to avoid moving `maybe.0`\n+help: borrow this binding in the pattern to avoid moving the value\n    |\n LL |         if let Some(ref thing) = maybe {\n    |                     +++"}, {"sha": "2552fff860cd369a94b66b767d80f63f8a27df7e", "filename": "src/test/ui/borrowck/issue-83760.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fissue-83760.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fissue-83760.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-83760.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,6 +8,10 @@ LL |             val = None;\n    |             ---------- this reinitialization might get skipped\n    |\n    = note: move occurs because value has type `Struct`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     while let Some(ref foo) = val {\n+   |                    +++\n \n error[E0382]: use of moved value: `foo`\n   --> $DIR/issue-83760.rs:21:14"}, {"sha": "55948afca733b763e35c15ec362211499da800d0", "filename": "src/test/ui/borrowck/move-in-pattern-mut-in-loop.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut-in-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut-in-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut-in-loop.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -5,7 +5,7 @@ LL |         if let Some(mut _x) = opt {}\n    |                     ^^^^^^ value moved here, in previous iteration of loop\n    |\n    = note: move occurs because value has type `&mut i32`, which does not implement the `Copy` trait\n-help: borrow this field in the pattern to avoid moving `opt.0`\n+help: borrow this binding in the pattern to avoid moving the value\n    |\n LL |         if let Some(ref mut _x) = opt {}\n    |                     +++"}, {"sha": "dd3471e2c8be58dcd66f5e4d64e21b904cf0d274", "filename": "src/test/ui/borrowck/move-in-pattern-mut.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,7 +8,7 @@ LL |     foo(s);\n    |         ^ value used here after partial move\n    |\n    = note: partial move occurs because value has type `S`, which does not implement the `Copy` trait\n-help: borrow this field in the pattern to avoid moving `s.0`\n+help: borrow this binding in the pattern to avoid moving the value\n    |\n LL |     if let Some(ref mut x) = s {\n    |                 +++\n@@ -23,7 +23,7 @@ LL |     bar(e);\n    |         ^ value used here after partial move\n    |\n    = note: partial move occurs because value has type `S`, which does not implement the `Copy` trait\n-help: borrow this field in the pattern to avoid moving `e.s`\n+help: borrow this binding in the pattern to avoid moving the value\n    |\n LL |     let E::V { s: ref mut x } = e;\n    |                   +++"}, {"sha": "250acbe5928a0aed75da3fa8446a6d28277d4a53", "filename": "src/test/ui/borrowck/move-in-pattern.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,7 +8,7 @@ LL |     foo(s);\n    |         ^ value used here after partial move\n    |\n    = note: partial move occurs because value has type `S`, which does not implement the `Copy` trait\n-help: borrow this field in the pattern to avoid moving `s.0`\n+help: borrow this binding in the pattern to avoid moving the value\n    |\n LL |     if let Some(ref x) = s {\n    |                 +++\n@@ -23,7 +23,7 @@ LL |     bar(e);\n    |         ^ value used here after partial move\n    |\n    = note: partial move occurs because value has type `S`, which does not implement the `Copy` trait\n-help: borrow this field in the pattern to avoid moving `e.s`\n+help: borrow this binding in the pattern to avoid moving the value\n    |\n LL |     let E::V { s: ref x } = e;\n    |                   +++"}, {"sha": "74e7067c9afaa46a35ee835b9fb43d2fac3e5dc0", "filename": "src/test/ui/borrowck/mut-borrow-in-loop-2.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop-2.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,9 +4,17 @@ error[E0382]: use of moved value: `value`\n LL | fn this_does_not<'a, R>(value: &'a mut Events<R>) {\n    |                         ----- move occurs because `value` has type `&mut Events<R>`, which does not implement the `Copy` trait\n LL |     for _ in 0..3 {\n+   |     ------------- inside of this loop\n LL |         Other::handle(value);\n    |                       ^^^^^ value moved here, in previous iteration of loop\n    |\n+note: consider changing this parameter type in function `handle` to borrow instead if owning the value isn't necessary\n+  --> $DIR/mut-borrow-in-loop-2.rs:9:22\n+   |\n+LL |     fn handle(value: T) -> Self;\n+   |        ------        ^ this parameter takes ownership of the value\n+   |        |\n+   |        in this function\n help: consider creating a fresh reborrow of `value` here\n    |\n LL |         Other::handle(&mut *value);"}, {"sha": "9501798bb06d0f6ef12b4a81455bc7fba5e2364d", "filename": "src/test/ui/borrowck/or-patterns.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2For-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fborrowck%2For-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2For-patterns.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,6 +8,10 @@ LL |     &x.0 .0;\n    |     ^^^^^^^ value borrowed here after move\n    |\n    = note: move occurs because `x.0.0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ((ref y, _) | (_, y),) => (),\n+   |           +++\n \n error[E0382]: borrow of moved value: `x.0.1`\n   --> $DIR/or-patterns.rs:10:5\n@@ -19,6 +23,10 @@ LL |     &x.0 .1;\n    |     ^^^^^^^ value borrowed here after move\n    |\n    = note: move occurs because `x.0.1` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ((y, _) | (_, ref y),) => (),\n+   |                       +++\n \n error[E0502]: cannot borrow `x.0.0` as mutable because it is also borrowed as immutable\n   --> $DIR/or-patterns.rs:18:5\n@@ -77,6 +85,10 @@ LL |     &x.0 .0;\n    |     ^^^^^^^ value borrowed here after move\n    |\n    = note: move occurs because `x.0.0` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ((ref y, _) | (_, y),) = x;\n+   |           +++\n \n error[E0382]: borrow of moved value: `x.0.1`\n   --> $DIR/or-patterns.rs:40:5\n@@ -88,6 +100,10 @@ LL |     &x.0 .1;\n    |     ^^^^^^^ value borrowed here after move\n    |\n    = note: move occurs because `x.0.1` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ((y, _) | (_, ref y),) = x;\n+   |                       +++\n \n error[E0502]: cannot borrow `x.0.0` as mutable because it is also borrowed as immutable\n   --> $DIR/or-patterns.rs:46:5"}, {"sha": "080f6c39449f040993ae98e851ad7fc8e5fbaeea", "filename": "src/test/ui/codemap_tests/tab_3.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -15,6 +15,10 @@ note: this function takes ownership of the receiver `self`, which moves `some_ve\n LL |     fn into_iter(self) -> Self::IntoIter;\n    |                  ^^^^\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     some_vec.clone().into_iter();\n+   |             ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "f030228f71ae493ff87f9f28bb9a3853f0b1e335", "filename": "src/test/ui/drop/repeat-drop-2.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdrop%2Frepeat-drop-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdrop%2Frepeat-drop-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Frepeat-drop-2.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,11 @@ LL |     let _bar = foo;\n    |                --- value moved here\n LL |     let _baz = [foo; 0];\n    |                 ^^^ value used here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let _bar = foo.clone();\n+   |                   ++++++++\n \n error[E0493]: destructor of `String` cannot be evaluated at compile-time\n   --> $DIR/repeat-drop-2.rs:7:25"}, {"sha": "5774c8b2a67225ab38c91f235acb61a8cffa65ea", "filename": "src/test/ui/dyn-star/dispatch-on-pin-mut.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fdispatch-on-pin-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fdispatch-on-pin-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fdispatch-on-pin-mut.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,52 @@\n+// run-pass\n+// edition:2021\n+// check-run-results\n+\n+#![feature(dyn_star)]\n+//~^ WARN the feature `dyn_star` is incomplete and may not be safe to use and/or cause compiler crashes\n+\n+use std::future::Future;\n+\n+async fn foo(f: dyn* Future<Output = i32>) {\n+    println!(\"value: {}\", f.await);\n+}\n+\n+async fn async_main() {\n+    foo(Box::pin(async { 1 })).await\n+}\n+\n+// ------------------------------------------------------------------------- //\n+// Implementation Details Below...\n+\n+use std::pin::Pin;\n+use std::task::*;\n+\n+pub fn noop_waker() -> Waker {\n+    let raw = RawWaker::new(std::ptr::null(), &NOOP_WAKER_VTABLE);\n+\n+    // SAFETY: the contracts for RawWaker and RawWakerVTable are upheld\n+    unsafe { Waker::from_raw(raw) }\n+}\n+\n+const NOOP_WAKER_VTABLE: RawWakerVTable = RawWakerVTable::new(noop_clone, noop, noop, noop);\n+\n+unsafe fn noop_clone(_p: *const ()) -> RawWaker {\n+    RawWaker::new(std::ptr::null(), &NOOP_WAKER_VTABLE)\n+}\n+\n+unsafe fn noop(_p: *const ()) {}\n+\n+fn main() {\n+    let mut fut = async_main();\n+\n+    // Poll loop, just to test the future...\n+    let waker = noop_waker();\n+    let ctx = &mut Context::from_waker(&waker);\n+\n+    loop {\n+        match unsafe { Pin::new_unchecked(&mut fut).poll(ctx) } {\n+            Poll::Pending => {}\n+            Poll::Ready(()) => break,\n+        }\n+    }\n+}"}, {"sha": "96c5ca6985ffd01126664fd12f1b92f8b6a4f163", "filename": "src/test/ui/dyn-star/dispatch-on-pin-mut.run.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fdispatch-on-pin-mut.run.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fdispatch-on-pin-mut.run.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fdispatch-on-pin-mut.run.stdout?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1 @@\n+value: 1"}, {"sha": "fdf74aa7efe08de048a8cec8aff22e234b9e4e30", "filename": "src/test/ui/dyn-star/dispatch-on-pin-mut.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fdispatch-on-pin-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fdispatch-on-pin-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fdispatch-on-pin-mut.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `dyn_star` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/dispatch-on-pin-mut.rs:5:12\n+   |\n+LL | #![feature(dyn_star)]\n+   |            ^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "c12b16f16055d599da9629673b78ff2e4c0b7553", "filename": "src/test/ui/dyn-star/dont-unsize-coerce-dyn-star.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fdont-unsize-coerce-dyn-star.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fdont-unsize-coerce-dyn-star.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fdont-unsize-coerce-dyn-star.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1,7 +1,8 @@\n-// check-pass\n+// run-pass\n+// check-run-results\n \n #![feature(dyn_star)]\n-#![allow(incomplete_features)]\n+//~^ WARN the feature `dyn_star` is incomplete and may not be safe to use and/or cause compiler crashes\n \n trait AddOne {\n     fn add1(&mut self) -> usize;"}, {"sha": "b4db3ed707d8db168f186db15a293a5c24452b71", "filename": "src/test/ui/dyn-star/dont-unsize-coerce-dyn-star.run.stdout", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fdont-unsize-coerce-dyn-star.run.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fdont-unsize-coerce-dyn-star.run.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fdont-unsize-coerce-dyn-star.run.stdout?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,2 @@\n+43\n+44"}, {"sha": "933c133831ad330412c96bead9ea040debbbcabc", "filename": "src/test/ui/dyn-star/dont-unsize-coerce-dyn-star.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fdont-unsize-coerce-dyn-star.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fdont-unsize-coerce-dyn-star.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fdont-unsize-coerce-dyn-star.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `dyn_star` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/dont-unsize-coerce-dyn-star.rs:4:12\n+   |\n+LL | #![feature(dyn_star)]\n+   |            ^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "a4eb669e3210430d0c3ce1efbd13cee6b1d978b6", "filename": "src/test/ui/dyn-star/no-unsize-coerce-dyn-trait.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fno-unsize-coerce-dyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fno-unsize-coerce-dyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fno-unsize-coerce-dyn-trait.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,13 @@\n+#![feature(dyn_star, trait_upcasting)]\n+//~^ WARN the feature `dyn_star` is incomplete and may not be safe to use and/or cause compiler crashes\n+\n+trait A: B {}\n+trait B {}\n+impl A for usize {}\n+impl B for usize {}\n+\n+fn main() {\n+    let x: Box<dyn* A> = Box::new(1usize as dyn* A);\n+    let y: Box<dyn* B> = x;\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "2fc751b3b4a1efbff854a2355448c7922ac284fc", "filename": "src/test/ui/dyn-star/no-unsize-coerce-dyn-trait.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fno-unsize-coerce-dyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fno-unsize-coerce-dyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fno-unsize-coerce-dyn-trait.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,23 @@\n+warning: the feature `dyn_star` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/no-unsize-coerce-dyn-trait.rs:1:12\n+   |\n+LL | #![feature(dyn_star, trait_upcasting)]\n+   |            ^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/no-unsize-coerce-dyn-trait.rs:11:26\n+   |\n+LL |     let y: Box<dyn* B> = x;\n+   |            -----------   ^ expected trait `B`, found trait `A`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected struct `Box<dyn* B>`\n+              found struct `Box<dyn* A>`\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "c667ac143a395167ff9054ebc18a41dadb4212b8", "filename": "src/test/ui/dyn-star/upcast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fupcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fupcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fupcast.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1,7 +1,6 @@\n-// run-pass\n+// known-bug: #104800\n \n #![feature(dyn_star, trait_upcasting)]\n-#![allow(incomplete_features)]\n \n trait Foo: Bar {\n     fn hello(&self);"}, {"sha": "6a95f7754e68548d8abb417105c7bb88d2e62dbd", "filename": "src/test/ui/dyn-star/upcast.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fupcast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fdyn-star%2Fupcast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fupcast.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,20 @@\n+warning: the feature `dyn_star` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/upcast.rs:3:12\n+   |\n+LL | #![feature(dyn_star, trait_upcasting)]\n+   |            ^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0277]: `dyn* Foo` needs to be a pointer-sized type\n+  --> $DIR/upcast.rs:30:23\n+   |\n+LL |     let w: dyn* Bar = w;\n+   |                       ^ `dyn* Foo` needs to be a pointer-sized type\n+   |\n+   = help: the trait `PointerSized` is not implemented for `dyn* Foo`\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "92ee5cf22b719a7fa8a5e573fbbf073443be0f7e", "filename": "src/test/ui/issues/issue-29723.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fissues%2Fissue-29723.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fissues%2Fissue-29723.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29723.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -9,6 +9,11 @@ LL |         0 if { drop(s); false } => String::from(\"oops\"),\n ...\n LL |             s\n    |             ^ value used here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         0 if { drop(s.clone()); false } => String::from(\"oops\"),\n+   |                      ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "f2971df5db27594cdd277d9eeccfe98c918cd84a", "filename": "src/test/ui/issues/issue-42796.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fissues%2Fissue-42796.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fissues%2Fissue-42796.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-42796.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -10,6 +10,10 @@ LL |     println!(\"{}\", s);\n    |                    ^ value borrowed here after move\n    |\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let mut s_copy = s.clone();\n+   |                       ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "d14cd6cb4e03a04a4255047ab22d2feca8451c29", "filename": "src/test/ui/liveness/liveness-move-call-arg.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-call-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-call-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-call-arg.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -3,9 +3,23 @@ error[E0382]: use of moved value: `x`\n    |\n LL |     let x: Box<isize> = Box::new(25);\n    |         - move occurs because `x` has type `Box<isize>`, which does not implement the `Copy` trait\n-...\n+LL |\n+LL |     loop {\n+   |     ---- inside of this loop\n LL |         take(x);\n    |              ^ value moved here, in previous iteration of loop\n+   |\n+note: consider changing this parameter type in function `take` to borrow instead if owning the value isn't necessary\n+  --> $DIR/liveness-move-call-arg.rs:1:13\n+   |\n+LL | fn take(_x: Box<isize>) {}\n+   |    ----     ^^^^^^^^^^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         take(x.clone());\n+   |               ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "a060914f17859539736a35de38fd893a9074b419", "filename": "src/test/ui/liveness/liveness-move-in-loop.stderr", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-loop.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,8 +4,22 @@ error[E0382]: use of moved value: `y`\n LL |     let y: Box<isize> = 42.into();\n    |         - move occurs because `y` has type `Box<isize>`, which does not implement the `Copy` trait\n ...\n+LL |     loop {\n+   |     ---- inside of this loop\n+LL |         println!(\"{}\", y);\n+LL |         loop {\n+   |         ---- inside of this loop\n+LL |             loop {\n+   |             ---- inside of this loop\n+LL |                 loop {\n+   |                 ---- inside of this loop\n LL |                     x = y;\n    |                         ^ value moved here, in previous iteration of loop\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |                     x = y.clone();\n+   |                          ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "4dff7447dd7661cad7ed453b177107669294ef77", "filename": "src/test/ui/liveness/liveness-move-in-while.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -24,12 +24,22 @@ error[E0382]: borrow of moved value: `y`\n LL |     let y: Box<isize> = 42.into();\n    |         - move occurs because `y` has type `Box<isize>`, which does not implement the `Copy` trait\n ...\n+LL |     loop {\n+   |     ---- inside of this loop\n LL |         println!(\"{}\", y);\n    |                        ^ value borrowed here after move\n LL |         while true { while true { while true { x = y; x.clone(); } } }\n-   |                                                    - value moved here, in previous iteration of loop\n+   |         ----------   ----------   ----------       - value moved here, in previous iteration of loop\n+   |         |            |            |\n+   |         |            |            inside of this loop\n+   |         |            inside of this loop\n+   |         inside of this loop\n    |\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         while true { while true { while true { x = y.clone(); x.clone(); } } }\n+   |                                                     ++++++++\n \n error: aborting due to previous error; 3 warnings emitted\n "}, {"sha": "3accba197a13deee42616521336538cd42ee99e3", "filename": "src/test/ui/liveness/liveness-use-after-move.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-move.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -10,6 +10,10 @@ LL |     println!(\"{}\", *x);\n    |                    ^^ value borrowed here after move\n    |\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let y = x.clone();\n+   |              ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "65d55ca8f7073ae3ec92de307d75cf1c0e7d8d2e", "filename": "src/test/ui/liveness/liveness-use-after-send.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-send.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-send.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-send.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,7 +8,16 @@ LL |     send(ch, message);\n LL |     println!(\"{}\", message);\n    |                    ^^^^^^^ value borrowed here after move\n    |\n+note: consider changing this parameter type in function `send` to borrow instead if owning the value isn't necessary\n+  --> $DIR/liveness-use-after-send.rs:3:54\n+   |\n+LL | fn send<T:Send + std::fmt::Debug>(ch: Chan<T>, data: T) {\n+   |    ---- in this function                             ^ this parameter takes ownership of the value\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     send(ch, message.clone());\n+   |                     ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "9a84ddef7e64e88be01eda170acc9d6db34ccf9b", "filename": "src/test/ui/moves/borrow-closures-instead-of-move.stderr", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,9 +4,17 @@ error[E0382]: use of moved value: `f`\n LL | fn takes_fn(f: impl Fn()) {\n    |             - move occurs because `f` has type `impl Fn()`, which does not implement the `Copy` trait\n LL |     loop {\n+   |     ---- inside of this loop\n LL |         takes_fnonce(f);\n    |                      ^ value moved here, in previous iteration of loop\n    |\n+note: consider changing this parameter type in function `takes_fnonce` to borrow instead if owning the value isn't necessary\n+  --> $DIR/borrow-closures-instead-of-move.rs:34:20\n+   |\n+LL | fn takes_fnonce(_: impl FnOnce()) {}\n+   |    ------------    ^^^^^^^^^^^^^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n help: consider borrowing `f`\n    |\n LL |         takes_fnonce(&f);\n@@ -24,6 +32,13 @@ LL |         takes_fnonce(m);\n LL |     takes_fnonce(m);\n    |                  ^ value used here after move\n    |\n+note: consider changing this parameter type in function `takes_fnonce` to borrow instead if owning the value isn't necessary\n+  --> $DIR/borrow-closures-instead-of-move.rs:34:20\n+   |\n+LL | fn takes_fnonce(_: impl FnOnce()) {}\n+   |    ------------    ^^^^^^^^^^^^^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n help: consider mutably borrowing `m`\n    |\n LL |         takes_fnonce(&mut m);"}, {"sha": "94bc9e6f4546535fac1925442960e7a171e80429", "filename": "src/test/ui/moves/issue-46099-move-in-macro.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fissue-46099-move-in-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fissue-46099-move-in-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fissue-46099-move-in-macro.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -5,6 +5,11 @@ LL |     let b = Box::new(true);\n    |         - move occurs because `b` has type `Box<bool>`, which does not implement the `Copy` trait\n LL |     test!({b});\n    |            ^ value used here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     test!({b.clone()});\n+   |             ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "56c225bab8cbca0c2858e522c4adab734db99e3c", "filename": "src/test/ui/moves/issue-72649-uninit-in-loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fissue-72649-uninit-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fissue-72649-uninit-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fissue-72649-uninit-in-loop.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -25,7 +25,7 @@ fn moved_here_1() {\n fn moved_here_2() {\n     let value = NonCopy{};\n     //~^ NOTE move occurs because `value` has type `NonCopy`, which does not implement the `Copy` trait\n-    loop {\n+    loop { //~ NOTE inside of this loop\n         let _used = value;\n         //~^ NOTE value moved here\n         loop {\n@@ -38,7 +38,7 @@ fn moved_here_2() {\n fn moved_loop_1() {\n     let value = NonCopy{};\n     //~^ NOTE move occurs because `value` has type `NonCopy`, which does not implement the `Copy` trait\n-    loop {\n+    loop { //~ NOTE inside of this loop\n         let _used = value; //~ ERROR use of moved value: `value`\n         //~^ NOTE value moved here, in previous iteration of loop\n     }\n@@ -49,7 +49,7 @@ fn moved_loop_2() {\n     //~^ NOTE move occurs because `value` has type `NonCopy`, which does not implement the `Copy` trait\n     let _used = value;\n     value = NonCopy{};\n-    loop {\n+    loop { //~ NOTE inside of this loop\n         let _used2 = value; //~ ERROR use of moved value: `value`\n         //~^ NOTE value moved here, in previous iteration of loop\n     }"}, {"sha": "7e119fe8cda64f2d49c562e2589c71f704dd5ef1", "filename": "src/test/ui/moves/issue-72649-uninit-in-loop.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fissue-72649-uninit-in-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fissue-72649-uninit-in-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fissue-72649-uninit-in-loop.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -15,7 +15,9 @@ error[E0382]: use of moved value: `value`\n    |\n LL |     let value = NonCopy{};\n    |         ----- move occurs because `value` has type `NonCopy`, which does not implement the `Copy` trait\n-...\n+LL |\n+LL |     loop {\n+   |     ---- inside of this loop\n LL |         let _used = value;\n    |                     ----- value moved here\n ...\n@@ -27,7 +29,9 @@ error[E0382]: use of moved value: `value`\n    |\n LL |     let value = NonCopy{};\n    |         ----- move occurs because `value` has type `NonCopy`, which does not implement the `Copy` trait\n-...\n+LL |\n+LL |     loop {\n+   |     ---- inside of this loop\n LL |         let _used = value;\n    |                     ^^^^^ value moved here, in previous iteration of loop\n \n@@ -37,6 +41,8 @@ error[E0382]: use of moved value: `value`\n LL |     let mut value = NonCopy{};\n    |         --------- move occurs because `value` has type `NonCopy`, which does not implement the `Copy` trait\n ...\n+LL |     loop {\n+   |     ---- inside of this loop\n LL |         let _used2 = value;\n    |                      ^^^^^ value moved here, in previous iteration of loop\n "}, {"sha": "c13dc58826eb83bfa27ff49b2575db210dd877ee", "filename": "src/test/ui/moves/move-fn-self-receiver.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -96,6 +96,10 @@ note: this function takes ownership of the receiver `self`, which moves `rc_foo`\n    |\n LL |     fn use_rc_self(self: Rc<Self>) {}\n    |                    ^^^^\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     rc_foo.clone().use_rc_self();\n+   |           ++++++++\n \n error[E0382]: use of moved value: `foo_add`\n   --> $DIR/move-fn-self-receiver.rs:59:5\n@@ -137,6 +141,11 @@ LL |     for _val in explicit_into_iter.into_iter() {}\n    |                                    ----------- `explicit_into_iter` moved due to this method call\n LL |     explicit_into_iter;\n    |     ^^^^^^^^^^^^^^^^^^ value used here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     for _val in explicit_into_iter.clone().into_iter() {}\n+   |                                   ++++++++\n \n error[E0382]: use of moved value: `container`\n   --> $DIR/move-fn-self-receiver.rs:71:5\n@@ -160,6 +169,7 @@ error[E0382]: use of moved value: `foo2`\n LL |     let foo2 = Foo;\n    |         ---- move occurs because `foo2` has type `Foo`, which does not implement the `Copy` trait\n LL |     loop {\n+   |     ---- inside of this loop\n LL |         foo2.use_self();\n    |         ^^^^ ---------- `foo2` moved due to this method call, in previous iteration of loop\n "}, {"sha": "86e5f65248b977f14352d87b403e7631ca8ef478", "filename": "src/test/ui/moves/move-guard-same-consts.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmove-guard-same-consts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmove-guard-same-consts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-guard-same-consts.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,6 +8,18 @@ LL |         (1, 2) if take(x) => (),\n    |                        - value moved here\n LL |         (1, 2) if take(x) => (),\n    |                        ^ value used here after move\n+   |\n+note: consider changing this parameter type in function `take` to borrow instead if owning the value isn't necessary\n+  --> $DIR/move-guard-same-consts.rs:25:15\n+   |\n+LL | fn take<T>(_: T) -> bool { false }\n+   |    ----       ^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         (1, 2) if take(x.clone()) => (),\n+   |                         ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "f04cb34d7c46e0e84b5e3797c93eb1d560246823", "filename": "src/test/ui/moves/move-in-guard-1.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-1.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,6 +8,18 @@ LL |         (1, _) if take(x) => (),\n    |                        - value moved here\n LL |         (_, 2) if take(x) => (),\n    |                        ^ value used here after move\n+   |\n+note: consider changing this parameter type in function `take` to borrow instead if owning the value isn't necessary\n+  --> $DIR/move-in-guard-1.rs:15:15\n+   |\n+LL | fn take<T>(_: T) -> bool { false }\n+   |    ----       ^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         (1, _) if take(x.clone()) => (),\n+   |                         ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "26047861f55d704df5023072644fa212bda525e3", "filename": "src/test/ui/moves/move-in-guard-2.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-2.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -6,6 +6,18 @@ LL |     let x: Box<_> = Box::new(1);\n ...\n LL |         (_, 2) if take(x) => (),\n    |                        ^ value used here after move\n+   |\n+note: consider changing this parameter type in function `take` to borrow instead if owning the value isn't necessary\n+  --> $DIR/move-in-guard-2.rs:13:15\n+   |\n+LL | fn take<T>(_: T) -> bool { false }\n+   |    ----       ^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         (_, 2) if take(x.clone()) => (),\n+   |                         ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "a49ee31b46622c8570e21cd0969b656e176437d3", "filename": "src/test/ui/moves/moves-based-on-type-access-to-field.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -13,6 +13,10 @@ note: this function takes ownership of the receiver `self`, which moves `x`\n    |\n LL |     fn into_iter(self) -> Self::IntoIter;\n    |                  ^^^^\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     consume(x.clone().into_iter().next().unwrap());\n+   |              ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "db4382b58fcb21c07c6d084227b86687a4d95566", "filename": "src/test/ui/moves/moves-based-on-type-cyclic-types-issue-4821.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-cyclic-types-issue-4821.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-cyclic-types-issue-4821.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-cyclic-types-issue-4821.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,7 +8,7 @@ LL |     consume(node) + r\n    |             ^^^^ value used here after partial move\n    |\n    = note: partial move occurs because value has type `Box<List>`, which does not implement the `Copy` trait\n-help: borrow this field in the pattern to avoid moving `node.next.0`\n+help: borrow this binding in the pattern to avoid moving the value\n    |\n LL |         Some(ref right) => consume(right),\n    |              +++"}, {"sha": "0930df148059dae9dd5329c268b575d15dfc264e", "filename": "src/test/ui/moves/moves-based-on-type-distribute-copy-over-paren.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-distribute-copy-over-paren.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-distribute-copy-over-paren.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-distribute-copy-over-paren.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -9,6 +9,11 @@ LL |     let _y = Foo { f:x };\n LL |\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let _y = Foo { f:x.clone() };\n+   |                       ++++++++\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-distribute-copy-over-paren.rs:21:11\n@@ -21,6 +26,11 @@ LL |     let _y = Foo { f:(((x))) };\n LL |\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let _y = Foo { f:(((x))).clone() };\n+   |                             ++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "838b1282cb4ed883de4561af3c7104e08b719655", "filename": "src/test/ui/moves/moves-based-on-type-exprs.stderr", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,11 @@ LL |     let _y = Foo { f:x };\n    |                      - value moved here\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let _y = Foo { f:x.clone() };\n+   |                       ++++++++\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:18:11\n@@ -17,6 +22,11 @@ LL |     let _y = (x, 3);\n    |               - value moved here\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let _y = (x.clone(), 3);\n+   |                ++++++++\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:35:11\n@@ -29,6 +39,11 @@ LL |         x\n ...\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         x.clone()\n+   |          ++++++++\n \n error[E0382]: borrow of moved value: `y`\n   --> $DIR/moves-based-on-type-exprs.rs:36:11\n@@ -41,6 +56,11 @@ LL |         y\n ...\n LL |     touch(&y);\n    |           ^^ value borrowed here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         y.clone()\n+   |          ++++++++\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:46:11\n@@ -53,6 +73,11 @@ LL |         true => x,\n ...\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         true => x.clone(),\n+   |                  ++++++++\n \n error[E0382]: borrow of moved value: `y`\n   --> $DIR/moves-based-on-type-exprs.rs:47:11\n@@ -65,6 +90,11 @@ LL |         false => y\n ...\n LL |     touch(&y);\n    |           ^^ value borrowed here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         false => y.clone()\n+   |                   ++++++++\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:58:11\n@@ -77,6 +107,18 @@ LL |         _ if guard(x) => 10,\n ...\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+note: consider changing this parameter type in function `guard` to borrow instead if owning the value isn't necessary\n+  --> $DIR/moves-based-on-type-exprs.rs:6:14\n+   |\n+LL | fn guard(_s: String) -> bool {panic!()}\n+   |    -----     ^^^^^^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         _ if guard(x.clone()) => 10,\n+   |                     ++++++++\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:65:11\n@@ -87,6 +129,11 @@ LL |     let _y = [x];\n    |               - value moved here\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let _y = [x.clone()];\n+   |                ++++++++\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:71:11\n@@ -97,6 +144,11 @@ LL |     let _y = vec![x];\n    |                   - value moved here\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let _y = vec![x.clone()];\n+   |                    ++++++++\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:77:11\n@@ -113,6 +165,10 @@ note: this function takes ownership of the receiver `self`, which moves `x`\n    |\n LL |     fn into_iter(self) -> Self::IntoIter;\n    |                  ^^^^\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let _y = x.clone().into_iter().next().unwrap();\n+   |               ++++++++\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:83:11\n@@ -129,6 +185,10 @@ note: this function takes ownership of the receiver `self`, which moves `x`\n    |\n LL |     fn into_iter(self) -> Self::IntoIter;\n    |                  ^^^^\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let _y = [x.clone().into_iter().next().unwrap(); 1];\n+   |                ++++++++\n \n error: aborting due to 11 previous errors\n "}, {"sha": "225935532ead73c39f577a429bc7d3062362d74a", "filename": "src/test/ui/moves/moves-based-on-type-match-bindings.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-match-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-match-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-match-bindings.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,6 +8,10 @@ LL |     touch(&x);\n    |           ^^ value borrowed here after partial move\n    |\n    = note: partial move occurs because `x.f` has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         Foo {ref f} => {}\n+   |              +++\n \n error: aborting due to previous error\n "}, {"sha": "0bcce30126306a421268bb2d87803c64d42f468b", "filename": "src/test/ui/moves/moves-based-on-type-tuple.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,6 +8,11 @@ LL |     Box::new((x, x))\n    |               -  ^ value used here after move\n    |               |\n    |               value moved here\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     Box::new((x.clone(), x))\n+   |                ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "22e7951dbe3670d8229fd6cf6e8a655ac54dd452", "filename": "src/test/ui/moves/use_of_moved_value_clone_suggestions.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,11 @@ LL |     (t, t)\n    |      -  ^ value used here after move\n    |      |\n    |      value moved here\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     (t.clone(), t)\n+   |       ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "0a09353b8ec0a52f941f11331dd54b180b04e1e7", "filename": "src/test/ui/nll/closure-access-spans.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fnll%2Fclosure-access-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fnll%2Fclosure-access-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-access-spans.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -67,6 +67,11 @@ LL |     || x.len();\n    |     ^^ - borrow occurs due to use in closure\n    |     |\n    |     value borrowed here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let r = x.clone();\n+   |              ++++++++\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/closure-access-spans.rs:40:5\n@@ -79,6 +84,11 @@ LL |     || x = String::new();\n    |     ^^ - borrow occurs due to use in closure\n    |     |\n    |     value borrowed here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let r = x.clone();\n+   |              ++++++++\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/closure-access-spans.rs:45:5"}, {"sha": "97ed414b1eceb8ced620331d99e3d08b24314486", "filename": "src/test/ui/nll/issue-21232-partial-init-and-use.stderr", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -37,6 +37,11 @@ LL |     let mut t: T = (0, Box::new(0)); drop(t);\n    |         move occurs because `t` has type `(u32, Box<u32>)`, which does not implement the `Copy` trait\n LL |     t.0 = 10; t.1 = Box::new(20);\n    |     ^^^^^^^^ value partially assigned here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let mut t: T = (0, Box::new(0)); drop(t.clone());\n+   |                                            ++++++++\n \n error[E0381]: partially assigned binding `s` isn't fully initialized\n   --> $DIR/issue-21232-partial-init-and-use.rs:123:5\n@@ -77,6 +82,11 @@ LL |     let mut t: T = (0, Box::new(0)); drop(t);\n    |         move occurs because `t` has type `(u32, Box<u32>)`, which does not implement the `Copy` trait\n LL |     t.0 = 10;\n    |     ^^^^^^^^ value partially assigned here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let mut t: T = (0, Box::new(0)); drop(t.clone());\n+   |                                            ++++++++\n \n error[E0381]: partially assigned binding `s` isn't fully initialized\n   --> $DIR/issue-21232-partial-init-and-use.rs:149:5\n@@ -208,6 +218,11 @@ LL |         c2 => {\n    |         -- value moved here\n LL |             c.0 = 2;\n    |             ^^^^^^^ value partially assigned here after move\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref c2 => {\n+   |         +++\n \n error[E0382]: assign to part of moved value: `c`\n   --> $DIR/issue-21232-partial-init-and-use.rs:255:13\n@@ -219,6 +234,11 @@ LL |         c2 => {\n    |         -- value moved here\n LL |             (c.1).0 = 2;\n    |             ^^^^^^^^^^^ value partially assigned here after move\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref c2 => {\n+   |         +++\n \n error[E0382]: assign to part of moved value: `c.1`\n   --> $DIR/issue-21232-partial-init-and-use.rs:263:13\n@@ -229,6 +249,10 @@ LL |             ((c.1).1).0 = 3;\n    |             ^^^^^^^^^^^^^^^ value partially assigned here after move\n    |\n    = note: move occurs because `c.1` has type `(i32, (i32, String))`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref c2 => {\n+   |         +++\n \n error: aborting due to 23 previous errors\n "}, {"sha": "072e96788b17ebe16a8ab4e8d3c57a70baf0c627", "filename": "src/test/ui/nll/issue-51512.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fnll%2Fissue-51512.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fnll%2Fissue-51512.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-51512.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,11 @@ LL |     let r = range;\n    |             ----- value moved here\n LL |     let x = range.start;\n    |             ^^^^^^^^^^^ value used here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let r = range.clone();\n+   |                  ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "d8f58b591311d8a90beef915b84796c471bcf427", "filename": "src/test/ui/nll/issue-53807.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fnll%2Fissue-53807.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fnll%2Fissue-53807.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-53807.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -5,7 +5,7 @@ LL |         if let Some(thing) = maybe {\n    |                     ^^^^^ value moved here, in previous iteration of loop\n    |\n    = note: move occurs because value has type `Vec<bool>`, which does not implement the `Copy` trait\n-help: borrow this field in the pattern to avoid moving `maybe.0`\n+help: borrow this binding in the pattern to avoid moving the value\n    |\n LL |         if let Some(ref thing) = maybe {\n    |                     +++"}, {"sha": "f72ed3af71823de592dba52b3fe33f787507c125", "filename": "src/test/ui/nll/match-cfg-fake-edges.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fnll%2Fmatch-cfg-fake-edges.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fnll%2Fmatch-cfg-fake-edges.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-cfg-fake-edges.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -26,6 +26,11 @@ LL |         false if { drop(x); true } => 1,\n LL |         true => {\n LL |             x;\n    |             ^ value used here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         false if { drop(x.clone()); true } => 1,\n+   |                          ++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b1f5117cb0243abc1781cc2f9632399f9ad01b4a", "filename": "src/test/ui/nll/ref-suggestion.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fnll%2Fref-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fnll%2Fref-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fref-suggestion.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,11 @@ LL |     let y = x;\n    |             - value moved here\n LL |     x;\n    |     ^ value used here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let y = x.clone();\n+   |              ++++++++\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/ref-suggestion.rs:8:5\n@@ -17,6 +22,11 @@ LL |     let mut y = x;\n    |                 - value moved here\n LL |     x;\n    |     ^ value used here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let mut y = x.clone();\n+   |                  ++++++++\n \n error[E0382]: use of partially moved value: `x`\n   --> $DIR/ref-suggestion.rs:16:5\n@@ -28,7 +38,7 @@ LL |     x;\n    |     ^ value used here after partial move\n    |\n    = note: partial move occurs because value has type `Vec<i32>`, which does not implement the `Copy` trait\n-help: borrow this field in the pattern to avoid moving `x.0.0`\n+help: borrow this binding in the pattern to avoid moving the value\n    |\n LL |         (Some(ref y), ()) => {},\n    |               +++"}, {"sha": "c8b45fd24d98c00c916c3b7b292ecf6be0d7c480", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-neither-can-live-while-the-other-survives-1.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -16,6 +16,11 @@ LL |         Some(_z @ ref _y) => {}\n    |              |    value borrowed here after move\n    |              value moved into `_z` here\n    |              move occurs because `_z` has type `X` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         Some(ref _z @ ref _y) => {}\n+   |              +++\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:26:14\n@@ -35,6 +40,11 @@ LL |         Some(_z @ ref mut _y) => {}\n    |              |    value borrowed here after move\n    |              value moved into `_z` here\n    |              move occurs because `_z` has type `X` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         Some(ref _z @ ref mut _y) => {}\n+   |              +++\n \n error[E0382]: borrow of moved value\n   --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:12:14\n@@ -45,7 +55,7 @@ LL |         Some(ref _y @ _z) => {}\n    |              value borrowed here after move\n    |\n    = note: move occurs because value has type `X`, which does not implement the `Copy` trait\n-help: borrow this field in the pattern to avoid moving `x.0`\n+help: borrow this binding in the pattern to avoid moving the value\n    |\n LL |         Some(ref _y @ ref _z) => {}\n    |                       +++\n@@ -59,7 +69,7 @@ LL |         Some(ref mut _y @ _z) => {}\n    |              value borrowed here after move\n    |\n    = note: move occurs because value has type `X`, which does not implement the `Copy` trait\n-help: borrow this field in the pattern to avoid moving `x.0`\n+help: borrow this binding in the pattern to avoid moving the value\n    |\n LL |         Some(ref mut _y @ ref _z) => {}\n    |                           +++"}, {"sha": "324897151124cba965713e64fb97bd208fb0d815", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-move-and-move.stderr", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -6,6 +6,11 @@ LL |     let a @ b = U;\n    |         |   |\n    |         |   value moved here\n    |         value used here after move\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ ref b = U;\n+   |         +++     +++\n \n error[E0382]: use of partially moved value\n   --> $DIR/borrowck-move-and-move.rs:13:9\n@@ -16,6 +21,10 @@ LL |     let a @ (b, c) = (U, U);\n    |         value used here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ (b, ref c) = (U, U);\n+   |         +++         +++\n \n error[E0382]: use of partially moved value\n   --> $DIR/borrowck-move-and-move.rs:15:9\n@@ -26,6 +35,10 @@ LL |     let a @ (b, c) = (u(), u());\n    |         value used here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ (b, ref c) = (u(), u());\n+   |         +++         +++\n \n error[E0382]: use of moved value\n   --> $DIR/borrowck-move-and-move.rs:18:16\n@@ -36,6 +49,11 @@ LL |         a @ Ok(b) | a @ Err(b) => {}\n    |         -      ^ value used here after move\n    |         |\n    |         value moved here\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref a @ Ok(b) | a @ Err(b) => {}\n+   |         +++\n \n error[E0382]: use of moved value\n   --> $DIR/borrowck-move-and-move.rs:18:29\n@@ -46,6 +64,11 @@ LL |         a @ Ok(b) | a @ Err(b) => {}\n    |                     -       ^ value used here after move\n    |                     |\n    |                     value moved here\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         a @ Ok(b) | ref a @ Err(b) => {}\n+   |                     +++\n \n error[E0382]: use of partially moved value\n   --> $DIR/borrowck-move-and-move.rs:25:9\n@@ -56,6 +79,10 @@ LL |         xs @ [a, .., b] => {}\n    |         value used here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref xs @ [a, .., ref b] => {}\n+   |         +++              +++\n \n error[E0382]: use of partially moved value\n   --> $DIR/borrowck-move-and-move.rs:29:9\n@@ -66,6 +93,10 @@ LL |         xs @ [_, ys @ .., _] => {}\n    |         value used here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref xs @ [_, ref ys @ .., _] => {}\n+   |         +++          +++\n \n error[E0382]: use of moved value\n   --> $DIR/borrowck-move-and-move.rs:22:12"}, {"sha": "f27df32ccfa5ce2afbe63b73b2f62255371b7228", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -79,6 +79,10 @@ LL |     let ref a @ box b = Box::new(NC);\n    |         value borrowed here after move\n    |\n    = note: move occurs because value has type `NC`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ box ref b = Box::new(NC);\n+   |                     +++\n \n error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-at-and-box.rs:38:9"}, {"sha": "d6474f1b49fb0f5c112ffec62a4ca78646afb718", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref-inverse-promotion.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,11 @@ LL |     let a @ ref b = U;\n    |         |   value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ ref b = U;\n+   |         +++\n \n error: aborting due to previous error\n "}, {"sha": "389e86e646457ec2586b521ea93ee7dc065e080a", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref-inverse.stderr", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,11 @@ LL |     let a @ ref b = U;\n    |         |   value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ ref b = U;\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:24:9\n@@ -18,6 +23,11 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    |         |            value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `(U, U)` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:24:14\n@@ -28,6 +38,11 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    |              |       value borrowed here after move\n    |              value moved into `b` here\n    |              move occurs because `b` has type `U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let a @ (ref mut b @ ref mut c, d @ ref e) = (U, U);\n+   |              +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:24:33\n@@ -38,6 +53,11 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    |                                 |   value borrowed here after move\n    |                                 value moved into `d` here\n    |                                 move occurs because `d` has type `U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let a @ (mut b @ ref mut c, ref d @ ref e) = (U, U);\n+   |                                 +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:29:9\n@@ -49,6 +69,11 @@ LL |     let a @ [ref mut b, ref c] = [U, U];\n    |         |    value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `[U; 2]` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ [ref mut b, ref c] = [U, U];\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:31:9\n@@ -59,6 +84,11 @@ LL |     let a @ ref b = u();\n    |         |   value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ ref b = u();\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:33:9\n@@ -70,6 +100,11 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    |         |            value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `(U, U)` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:33:14\n@@ -80,6 +115,11 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    |              |       value borrowed here after move\n    |              value moved into `b` here\n    |              move occurs because `b` has type `U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let a @ (ref mut b @ ref mut c, d @ ref e) = (u(), u());\n+   |              +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:33:33\n@@ -90,6 +130,11 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    |                                 |   value borrowed here after move\n    |                                 value moved into `d` here\n    |                                 move occurs because `d` has type `U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let a @ (mut b @ ref mut c, ref d @ ref e) = (u(), u());\n+   |                                 +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:38:9\n@@ -101,6 +146,11 @@ LL |     let a @ [ref mut b, ref c] = [u(), u()];\n    |         |    value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `[U; 2]` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ [ref mut b, ref c] = [u(), u()];\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:42:9\n@@ -111,6 +161,11 @@ LL |         a @ Some(ref b) => {}\n    |         |        value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `Option<U>` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref a @ Some(ref b) => {}\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:47:9\n@@ -122,6 +177,11 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |         |                 value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `Option<(U, U)>` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:47:19\n@@ -132,6 +192,11 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                   |       value borrowed here after move\n    |                   value moved into `b` here\n    |                   move occurs because `b` has type `U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         a @ Some((ref mut b @ ref mut c, d @ ref e)) => {}\n+   |                   +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:47:38\n@@ -142,6 +207,11 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                                      |   value borrowed here after move\n    |                                      value moved into `d` here\n    |                                      move occurs because `d` has type `U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         a @ Some((mut b @ ref mut c, ref d @ ref e)) => {}\n+   |                                      +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:55:9\n@@ -153,6 +223,11 @@ LL |         mut a @ Some([ref b, ref mut c]) => {}\n    |         |             value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `Option<[U; 2]>` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref mut a @ Some([ref b, ref mut c]) => {}\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:9\n@@ -163,6 +238,11 @@ LL |         a @ Some(ref b) => {}\n    |         |        value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `Option<U>` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref a @ Some(ref b) => {}\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:67:9\n@@ -174,6 +254,11 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |         |                 value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `Option<(U, U)>` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:67:19\n@@ -184,6 +269,11 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                   |       value borrowed here after move\n    |                   value moved into `b` here\n    |                   move occurs because `b` has type `U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         a @ Some((ref mut b @ ref mut c, d @ ref e)) => {}\n+   |                   +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:67:38\n@@ -194,6 +284,11 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                                      |   value borrowed here after move\n    |                                      value moved into `d` here\n    |                                      move occurs because `d` has type `U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         a @ Some((mut b @ ref mut c, ref d @ ref e)) => {}\n+   |                                      +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:75:9\n@@ -205,6 +300,11 @@ LL |         mut a @ Some([ref b, ref mut c]) => {}\n    |         |             value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `Option<[U; 2]>` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref mut a @ Some([ref b, ref mut c]) => {}\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:11:11\n@@ -215,6 +315,11 @@ LL |     fn f1(a @ ref b: U) {}\n    |           |   value borrowed here after move\n    |           value moved into `a` here\n    |           move occurs because `a` has type `U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     fn f1(ref a @ ref b: U) {}\n+   |           +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:14:11\n@@ -226,6 +331,11 @@ LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    |           |            value borrowed here after move\n    |           value moved into `a` here\n    |           move occurs because `a` has type `(U, U)` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     fn f2(ref mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n+   |           +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:14:20\n@@ -236,6 +346,11 @@ LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    |                    |   value borrowed here after move\n    |                    value moved into `b` here\n    |                    move occurs because `b` has type `U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     fn f2(mut a @ (ref b @ ref c, mut d @ ref e): (U, U)) {}\n+   |                    +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:14:31\n@@ -246,6 +361,11 @@ LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    |                               |       value borrowed here after move\n    |                               value moved into `d` here\n    |                               move occurs because `d` has type `U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     fn f2(mut a @ (b @ ref c, ref mut d @ ref e): (U, U)) {}\n+   |                               +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:19:11\n@@ -257,6 +377,11 @@ LL |     fn f3(a @ [ref mut b, ref c]: [U; 2]) {}\n    |           |    value borrowed here after move\n    |           value moved into `a` here\n    |           move occurs because `a` has type `[U; 2]` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     fn f3(ref a @ [ref mut b, ref c]: [U; 2]) {}\n+   |           +++\n \n error[E0382]: use of partially moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:24:9\n@@ -267,6 +392,10 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    |         value used here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ (mut b @ ref mut c, ref d @ ref e) = (U, U);\n+   |         +++                         +++\n \n error[E0382]: use of partially moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:33:9\n@@ -277,6 +406,10 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    |         value used here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ (mut b @ ref mut c, ref d @ ref e) = (u(), u());\n+   |         +++                         +++\n \n error[E0382]: use of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:47:38\n@@ -285,6 +418,11 @@ LL |     match Some((U, U)) {\n    |           ------------ move occurs because value has type `Option<(U, U)>`, which does not implement the `Copy` trait\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |         - value moved here           ^ value used here after move\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |         +++\n \n error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:55:30\n@@ -305,6 +443,11 @@ LL |         a @ Some(ref b) => {}\n    |         -        ^^^^^ value borrowed here after move\n    |         |\n    |         value moved here\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref a @ Some(ref b) => {}\n+   |         +++\n \n error[E0382]: use of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:67:38\n@@ -313,6 +456,11 @@ LL |     match Some((u(), u())) {\n    |           ---------------- move occurs because value has type `Option<(U, U)>`, which does not implement the `Copy` trait\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |         - value moved here           ^ value used here after move\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         ref a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |         +++\n \n error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:75:30"}, {"sha": "770bb89530ccaa60c2a1b63605854ca5f76e29f9", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref.stderr", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -242,6 +242,10 @@ LL |     let ref mut a @ [b, mut c] = [U, U];\n    |         value borrowed here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref mut a @ [b, ref mut c] = [U, U];\n+   |                         +++\n \n error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:33:9\n@@ -251,6 +255,11 @@ LL |     let ref a @ b = u();\n    |         |       |\n    |         |       value moved here\n    |         value borrowed here after move\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ ref b = u();\n+   |                 +++\n \n error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:36:18\n@@ -261,6 +270,10 @@ LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n    |                  value borrowed here after move\n    |\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ (ref b @ ref mut c, ref d @ e) = (u(), u());\n+   |                          +++\n \n error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:36:33\n@@ -271,6 +284,10 @@ LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n    |                                 value borrowed here after move\n    |\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ (ref b @ mut c, ref d @ ref e) = (u(), u());\n+   |                                         +++\n \n error[E0382]: borrow of partially moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:42:9\n@@ -281,6 +298,10 @@ LL |     let ref mut a @ [b, mut c] = [u(), u()];\n    |         value borrowed here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref mut a @ [b, ref mut c] = [u(), u()];\n+   |                         +++\n \n error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:69:23\n@@ -291,7 +312,7 @@ LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |                       value borrowed here after move\n    |\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n-help: borrow this field in the pattern to avoid moving the value\n+help: borrow this binding in the pattern to avoid moving the value\n    |\n LL |         ref a @ Some((ref b @ ref mut c, ref d @ e)) => {}\n    |                               +++\n@@ -305,7 +326,7 @@ LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |                                      value borrowed here after move\n    |\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n-help: borrow this field in the pattern to avoid moving the value\n+help: borrow this binding in the pattern to avoid moving the value\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ ref e)) => {}\n    |                                              +++"}, {"sha": "ad4ce7952ca7494b065b86b9f62107b24655d5ea", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.stderr", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -97,6 +97,11 @@ LL |     let a @ (ref mut b, ref mut c) = (U, U);\n    |         |    value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `(U, U)` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:67:9\n@@ -109,6 +114,11 @@ LL |     let a @ (b, [c, d]) = &mut val; // Same as ^--\n    |         |    value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `&mut (U, [U; 2])` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ (b, [c, d]) = &mut val; // Same as ^--\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:70:9\n@@ -119,6 +129,11 @@ LL |     let a @ &mut ref mut b = &mut U;\n    |         |        value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `&mut U` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ &mut ref mut b = &mut U;\n+   |         +++\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:72:9\n@@ -130,6 +145,11 @@ LL |     let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n    |         |         value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `&mut (U, U)` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n+   |         +++\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:76:9"}, {"sha": "e0e623fa544f773af68f1d0dfc9719e2631d788b", "filename": "src/test/ui/pattern/bindings-after-at/copy-and-move-mixed.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,10 @@ LL |     let a @ NC(b, c @ NC(d, e)) = NC(C, NC(C, C));\n    |         value used here after partial move\n    |\n    = note: partial move occurs because value has type `NC<C, C>`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref a @ NC(b, ref c @ NC(d, e)) = NC(C, NC(C, C));\n+   |         +++           +++\n \n error: aborting due to previous error\n "}, {"sha": "638bdd6db7606761b035dfea6375a9b9761c5487", "filename": "src/test/ui/pattern/bindings-after-at/default-binding-modes-both-sides-independent.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -34,6 +34,11 @@ LL |         Ok(ref a @ b) | Err(b @ ref a) => {\n    |                             |   value borrowed here after move\n    |                             value moved into `b` here\n    |                             move occurs because `b` has type `NotCopy` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |         Ok(ref a @ b) | Err(ref b @ ref a) => {\n+   |                             +++\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/default-binding-modes-both-sides-independent.rs:42:9\n@@ -52,6 +57,11 @@ LL |     let ref mut a @ b = NotCopy;\n    |         |           |\n    |         |           value moved here\n    |         value borrowed here after move\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref mut a @ ref b = NotCopy;\n+   |                     +++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "bb7b818368b78dca3969c32b35f92d5c45371b04", "filename": "src/test/ui/pattern/move-ref-patterns/borrowck-move-ref-pattern.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -129,6 +129,10 @@ LL |     drop(tup.1);\n    |          ^^^^^ value used here after move\n    |\n    = note: move occurs because `tup.1` has type `U`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let (ref _x0, ref _x1, ref _x2, ..) = tup;\n+   |                   +++\n \n error[E0382]: borrow of moved value: `tup.1`\n   --> $DIR/borrowck-move-ref-pattern.rs:29:20"}, {"sha": "06699b947be40f2bb66426cfde35e04c8de7d81e", "filename": "src/test/ui/rfc-2361-dbg-macro/dbg-macro-move-semantics.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Frfc-2361-dbg-macro%2Fdbg-macro-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Frfc-2361-dbg-macro%2Fdbg-macro-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2361-dbg-macro%2Fdbg-macro-move-semantics.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,12 @@ LL |     let _ = dbg!(a);\n    |             ------- value moved here\n LL |     let _ = dbg!(a);\n    |                  ^ value used here after move\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+  --> $SRC_DIR/std/src/macros.rs:LL:COL\n+   |\n+LL |             ref tmp => {\n+   |             +++\n \n error: aborting due to previous error\n "}, {"sha": "bd81ce0b19c0639d45652b174d96dad7976744a0", "filename": "src/test/ui/rfc-2497-if-let-chains/issue-99938.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-99938.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-99938.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-99938.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,31 @@\n+// compile-flags: -Zvalidate-mir -C opt-level=3\n+// build-pass\n+#![feature(let_chains)]\n+struct TupleIter<T, I: Iterator<Item = T>> {\n+    inner: I,\n+}\n+\n+impl<T, I: Iterator<Item = T>> Iterator for TupleIter<T, I> {\n+    type Item = (T, T, T);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let inner = &mut self.inner;\n+\n+        if let Some(first) = inner.next()\n+            && let Some(second) = inner.next()\n+            && let Some(third) = inner.next()\n+        {\n+            Some((first, second, third))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let vec: Vec<u8> = Vec::new();\n+    let mut tup_iter = TupleIter {\n+        inner: vec.into_iter(),\n+    };\n+    tup_iter.next();\n+}"}, {"sha": "0cc8994fe1f2d7589f564287f46c730d45824769", "filename": "src/test/ui/suggestions/borrow-for-loop-head.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fsuggestions%2Fborrow-for-loop-head.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fsuggestions%2Fborrow-for-loop-head.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fborrow-for-loop-head.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -12,6 +12,7 @@ error[E0382]: use of moved value: `a`\n LL |     let a = vec![1, 2, 3];\n    |         - move occurs because `a` has type `Vec<i32>`, which does not implement the `Copy` trait\n LL |     for i in &a {\n+   |     ----------- inside of this loop\n LL |         for j in a {\n    |                  ^ `a` moved due to this implicit call to `.into_iter()`, in previous iteration of loop\n    |"}, {"sha": "c36040eeca3012397ccc38058b1ab566d4c45e96", "filename": "src/test/ui/suggestions/ref-pattern-binding.fixed", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fsuggestions%2Fref-pattern-binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fsuggestions%2Fref-pattern-binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fref-pattern-binding.fixed?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,19 @@\n+// run-rustfix\n+#![allow(unused)]\n+\n+struct S {\n+    f: String,\n+}\n+\n+fn main() {\n+    let ref _moved @ ref _from = String::from(\"foo\"); //~ ERROR\n+    let ref _moved @ ref _from = String::from(\"foo\"); //~ ERROR\n+    let ref _moved @ ref _from = String::from(\"foo\"); //~ ERROR\n+    //~^ ERROR\n+    let ref _moved @ ref _from = String::from(\"foo\"); // ok\n+    let ref _moved @ S { ref f } = S { f: String::from(\"foo\") }; //~ ERROR\n+    let ref _moved @ S { ref f } = S { f: String::from(\"foo\") }; //~ ERROR\n+    //~^ ERROR\n+    let ref _moved @ S { ref f } = S { f: String::from(\"foo\") }; // ok\n+    let ref _moved @ S { ref f } = S { f: String::from(\"foo\") }; //~ ERROR\n+}"}, {"sha": "c0d4feb033098844624c30c67819776d9b122f42", "filename": "src/test/ui/suggestions/ref-pattern-binding.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fsuggestions%2Fref-pattern-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fsuggestions%2Fref-pattern-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fref-pattern-binding.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,19 @@\n+// run-rustfix\n+#![allow(unused)]\n+\n+struct S {\n+    f: String,\n+}\n+\n+fn main() {\n+    let _moved @ _from = String::from(\"foo\"); //~ ERROR\n+    let _moved @ ref _from = String::from(\"foo\"); //~ ERROR\n+    let ref _moved @ _from = String::from(\"foo\"); //~ ERROR\n+    //~^ ERROR\n+    let ref _moved @ ref _from = String::from(\"foo\"); // ok\n+    let _moved @ S { f } = S { f: String::from(\"foo\") }; //~ ERROR\n+    let ref _moved @ S { f } = S { f: String::from(\"foo\") }; //~ ERROR\n+    //~^ ERROR\n+    let ref _moved @ S { ref f } = S { f: String::from(\"foo\") }; // ok\n+    let _moved @ S { ref f } = S { f: String::from(\"foo\") }; //~ ERROR\n+}"}, {"sha": "10447ba7089caae7eff7065aefdd1ccf4b8a63f3", "filename": "src/test/ui/suggestions/ref-pattern-binding.stderr", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fsuggestions%2Fref-pattern-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fsuggestions%2Fref-pattern-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fref-pattern-binding.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,107 @@\n+error: borrow of moved value\n+  --> $DIR/ref-pattern-binding.rs:10:9\n+   |\n+LL |     let _moved @ ref _from = String::from(\"foo\");\n+   |         ------^^^---------\n+   |         |        |\n+   |         |        value borrowed here after move\n+   |         value moved into `_moved` here\n+   |         move occurs because `_moved` has type `String` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref _moved @ ref _from = String::from(\"foo\");\n+   |         +++\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/ref-pattern-binding.rs:11:9\n+   |\n+LL |     let ref _moved @ _from = String::from(\"foo\");\n+   |         ----------^^^-----\n+   |         |            |\n+   |         |            value moved into `_from` here\n+   |         value borrowed, by `_moved`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/ref-pattern-binding.rs:15:9\n+   |\n+LL |     let ref _moved @ S { f } = S { f: String::from(\"foo\") };\n+   |         ----------^^^^^^^-^^\n+   |         |                |\n+   |         |                value moved into `f` here\n+   |         value borrowed, by `_moved`, here\n+\n+error: borrow of moved value\n+  --> $DIR/ref-pattern-binding.rs:18:9\n+   |\n+LL |     let _moved @ S { ref f } = S { f: String::from(\"foo\") };\n+   |         ------^^^^^^^-----^^\n+   |         |            |\n+   |         |            value borrowed here after move\n+   |         value moved into `_moved` here\n+   |         move occurs because `_moved` has type `S` which does not implement the `Copy` trait\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref _moved @ S { ref f } = S { f: String::from(\"foo\") };\n+   |         +++\n+\n+error[E0382]: use of moved value\n+  --> $DIR/ref-pattern-binding.rs:9:9\n+   |\n+LL |     let _moved @ _from = String::from(\"foo\");\n+   |         ^^^^^^   -----   ------------------- move occurs because value has type `String`, which does not implement the `Copy` trait\n+   |         |        |\n+   |         |        value moved here\n+   |         value used here after move\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref _moved @ ref _from = String::from(\"foo\");\n+   |         +++          +++\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/ref-pattern-binding.rs:11:9\n+   |\n+LL |     let ref _moved @ _from = String::from(\"foo\");\n+   |         ^^^^^^^^^^   -----   ------------------- move occurs because value has type `String`, which does not implement the `Copy` trait\n+   |         |            |\n+   |         |            value moved here\n+   |         value borrowed here after move\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref _moved @ ref _from = String::from(\"foo\");\n+   |                      +++\n+\n+error[E0382]: use of partially moved value\n+  --> $DIR/ref-pattern-binding.rs:14:9\n+   |\n+LL |     let _moved @ S { f } = S { f: String::from(\"foo\") };\n+   |         ^^^^^^       - value partially moved here\n+   |         |\n+   |         value used here after partial move\n+   |\n+   = note: partial move occurs because value has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref _moved @ S { ref f } = S { f: String::from(\"foo\") };\n+   |         +++              +++\n+\n+error[E0382]: borrow of partially moved value\n+  --> $DIR/ref-pattern-binding.rs:15:9\n+   |\n+LL |     let ref _moved @ S { f } = S { f: String::from(\"foo\") };\n+   |         ^^^^^^^^^^       - value partially moved here\n+   |         |\n+   |         value borrowed here after partial move\n+   |\n+   = note: partial move occurs because value has type `String`, which does not implement the `Copy` trait\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref _moved @ S { ref f } = S { f: String::from(\"foo\") };\n+   |                          +++\n+\n+error: aborting due to 8 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "fe13e5ef3f5467ab93e85e200dca553d4958a4df", "filename": "src/test/ui/track-diagnostics/track2.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Ftrack-diagnostics%2Ftrack2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Ftrack-diagnostics%2Ftrack2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrack-diagnostics%2Ftrack2.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,6 +7,11 @@ LL |     let _moved @ _from = String::from(\"foo\");\n    |         |        value moved here\n    |         value used here after move\n -Ztrack-diagnostics: created at compiler/rustc_borrowck/src/borrowck_errors.rs:LL:CC\n+   |\n+help: borrow this binding in the pattern to avoid moving the value\n+   |\n+LL |     let ref _moved @ ref _from = String::from(\"foo\");\n+   |         +++          +++\n \n error: aborting due to previous error\n "}, {"sha": "d624187561ed7e0fbbe74ce9f738aa8a835e66dd", "filename": "src/test/ui/traits/trait-upcasting/migrate-lint-deny.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmigrate-lint-deny.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmigrate-lint-deny.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmigrate-lint-deny.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,7 +7,11 @@ use core::ops::Deref;\n // issue 89190\n trait A {}\n trait B: A {}\n+\n impl<'a> Deref for dyn 'a + B {\n+    //~^ ERROR `(dyn B + 'a)` implements `Deref` with supertrait `A` as target\n+    //~| WARN this was previously accepted by the compiler but is being phased out;\n+\n     type Target = dyn A;\n     fn deref(&self) -> &Self::Target {\n         todo!()\n@@ -18,8 +22,6 @@ fn take_a(_: &dyn A) {}\n \n fn whoops(b: &dyn B) {\n     take_a(b)\n-    //~^ ERROR `dyn B` implements `Deref` with supertrait `A` as output\n-    //~^^ WARN this was previously accepted by the compiler but is being phased out;\n }\n \n fn main() {}"}, {"sha": "4533b1163425c61153440bff60afa6ab776be5c6", "filename": "src/test/ui/traits/trait-upcasting/migrate-lint-deny.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmigrate-lint-deny.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmigrate-lint-deny.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmigrate-lint-deny.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1,8 +1,11 @@\n-error: `dyn B` implements `Deref` with supertrait `A` as output\n-  --> $DIR/migrate-lint-deny.rs:20:12\n+error: `(dyn B + 'a)` implements `Deref` with supertrait `A` as target\n+  --> $DIR/migrate-lint-deny.rs:11:1\n    |\n-LL |     take_a(b)\n-   |            ^\n+LL | impl<'a> Deref for dyn 'a + B {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     type Target = dyn A;\n+   |     -------------------- target type is set here\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #89460 <https://github.com/rust-lang/rust/issues/89460>"}, {"sha": "f738b03eed6b8441cba5d88252b8dd6ddb39a1cb", "filename": "src/test/ui/try-block/try-block-maybe-bad-lifetime.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-maybe-bad-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-maybe-bad-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-maybe-bad-lifetime.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -23,6 +23,10 @@ LL |         println!(\"{}\", x);\n    |                        ^ value borrowed here after move\n    |\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |             ::std::mem::drop(x.clone());\n+   |                               ++++++++\n \n error[E0506]: cannot assign to `i` because it is borrowed\n   --> $DIR/try-block-maybe-bad-lifetime.rs:40:9"}, {"sha": "6381ae874ba81d56f72f0711be0bec8a342297e7", "filename": "src/test/ui/union/union-move.mirunsafeck.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Funion%2Funion-move.mirunsafeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Funion%2Funion-move.mirunsafeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-move.mirunsafeck.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,6 +8,14 @@ LL |         move_out(x.f1_nocopy);\n    |                  ----------- value moved here\n LL |         move_out(x.f2_nocopy);\n    |                  ^^^^^^^^^^^ value used here after move\n+   |\n+note: consider changing this parameter type in function `move_out` to borrow instead if owning the value isn't necessary\n+  --> $DIR/union-move.rs:10:19\n+   |\n+LL | fn move_out<T>(x: T) {}\n+   |    --------       ^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/union-move.rs:45:18\n@@ -19,6 +27,14 @@ LL |         move_out(x.f2_nocopy);\n    |                  ----------- value moved here\n LL |         move_out(x.f3_copy);\n    |                  ^^^^^^^^^ value used here after move\n+   |\n+note: consider changing this parameter type in function `move_out` to borrow instead if owning the value isn't necessary\n+  --> $DIR/union-move.rs:10:19\n+   |\n+LL | fn move_out<T>(x: T) {}\n+   |    --------       ^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n \n error[E0509]: cannot move out of type `U2`, which implements the `Drop` trait\n   --> $DIR/union-move.rs:52:18"}, {"sha": "6381ae874ba81d56f72f0711be0bec8a342297e7", "filename": "src/test/ui/union/union-move.thirunsafeck.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Funion%2Funion-move.thirunsafeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Funion%2Funion-move.thirunsafeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-move.thirunsafeck.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,6 +8,14 @@ LL |         move_out(x.f1_nocopy);\n    |                  ----------- value moved here\n LL |         move_out(x.f2_nocopy);\n    |                  ^^^^^^^^^^^ value used here after move\n+   |\n+note: consider changing this parameter type in function `move_out` to borrow instead if owning the value isn't necessary\n+  --> $DIR/union-move.rs:10:19\n+   |\n+LL | fn move_out<T>(x: T) {}\n+   |    --------       ^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/union-move.rs:45:18\n@@ -19,6 +27,14 @@ LL |         move_out(x.f2_nocopy);\n    |                  ----------- value moved here\n LL |         move_out(x.f3_copy);\n    |                  ^^^^^^^^^ value used here after move\n+   |\n+note: consider changing this parameter type in function `move_out` to borrow instead if owning the value isn't necessary\n+  --> $DIR/union-move.rs:10:19\n+   |\n+LL | fn move_out<T>(x: T) {}\n+   |    --------       ^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n \n error[E0509]: cannot move out of type `U2`, which implements the `Drop` trait\n   --> $DIR/union-move.rs:52:18"}, {"sha": "d52a92b8888e8dde0ec433d54af6072b6b5be0cd", "filename": "src/test/ui/unop-move-semantics.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funop-move-semantics.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -14,6 +14,10 @@ note: calling this operator moves the left-hand side\n    |\n LL |     fn not(self) -> Self::Output;\n    |            ^^^^\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     !x.clone();\n+   |       ++++++++\n help: consider further restricting this bound\n    |\n LL | fn move_then_borrow<T: Not<Output=T> + Clone + Copy>(x: T) {"}, {"sha": "d8bffd4f9cf3e51f94559b79fcd34feec564898d", "filename": "src/test/ui/unsized-locals/borrow-after-move.stderr", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -28,6 +28,14 @@ LL |         drop_unsized(y);\n ...\n LL |         println!(\"{}\", &y);\n    |                        ^^ value borrowed here after move\n+   |\n+note: consider changing this parameter type in function `drop_unsized` to borrow instead if owning the value isn't necessary\n+  --> $DIR/borrow-after-move.rs:14:31\n+   |\n+LL | fn drop_unsized<T: ?Sized>(_: T) {}\n+   |    ------------               ^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/borrow-after-move.rs:31:24\n@@ -66,6 +74,11 @@ LL |         x.foo();\n    |         - value moved here\n LL |         println!(\"{}\", &x);\n    |                        ^^ value borrowed here after move\n+   |\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |         x.clone().foo();\n+   |          ++++++++\n \n error: aborting due to 5 previous errors; 1 warning emitted\n "}, {"sha": "71534818141caeb3fc06791687887b757dd799ca", "filename": "src/test/ui/unsized-locals/double-move.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -16,6 +16,14 @@ LL |         drop_unsized(y);\n    |                      - value moved here\n LL |         drop_unsized(y);\n    |                      ^ value used here after move\n+   |\n+note: consider changing this parameter type in function `drop_unsized` to borrow instead if owning the value isn't necessary\n+  --> $DIR/double-move.rs:14:31\n+   |\n+LL | fn drop_unsized<T: ?Sized>(_: T) {}\n+   |    ------------               ^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/double-move.rs:27:22"}, {"sha": "7b4d2454994d7175a2cf6f70afc69bfcf458d04b", "filename": "src/test/ui/use/use-after-move-based-on-type.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-based-on-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-based-on-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-based-on-type.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -9,6 +9,10 @@ LL |     println!(\"{}\", x);\n    |                    ^ value borrowed here after move\n    |\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider cloning the value if the performance cost is acceptable\n+   |\n+LL |     let _y = x.clone();\n+   |               ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "dfa0c04836eb3b7f66b2b26709d16e5129158448", "filename": "src/test/ui/use/use-after-move-implicity-coerced-object.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-implicity-coerced-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-implicity-coerced-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-implicity-coerced-object.stderr?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -9,6 +9,14 @@ LL |     l.push(n);\n LL |\n LL |     let x = n.to_string();\n    |             ^^^^^^^^^^^^^ value borrowed here after move\n+   |\n+note: consider changing this parameter type in method `push` to borrow instead if owning the value isn't necessary\n+  --> $DIR/use-after-move-implicity-coerced-object.rs:17:27\n+   |\n+LL |     fn push(&mut self, n: Box<dyn ToString + 'static>) {\n+   |        ----               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value\n+   |        |\n+   |        in this method\n \n error: aborting due to previous error\n "}, {"sha": "b4210d875104bbe9f473fdbd430d67d28a45095c", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_overeager_cloned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{get_associated_type, implements_trait, is_copy};\n+use clippy_utils::ty::{implements_trait, is_copy};\n use rustc_errors::Applicability;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n@@ -25,7 +25,7 @@ pub(super) fn check<'tcx>(\n         && let Some(method_id) = typeck.type_dependent_def_id(cloned_call.hir_id)\n         && cx.tcx.trait_of_item(method_id) == Some(iter_id)\n         && let cloned_recv_ty = typeck.expr_ty_adjusted(cloned_recv)\n-        && let Some(iter_assoc_ty) = get_associated_type(cx, cloned_recv_ty, iter_id, \"Item\")\n+        && let Some(iter_assoc_ty) = cx.get_associated_type(cloned_recv_ty, iter_id, \"Item\")\n         && matches!(*iter_assoc_ty.kind(), ty::Ref(_, ty, _) if !is_copy(cx, ty))\n     {\n         if needs_into_iter"}, {"sha": "52a4ff7d1ae4f09aa23e2172f2a89e2bc26f894c", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -2,7 +2,7 @@ use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait};\n+use clippy_utils::ty::{get_iterator_item_ty, implements_trait};\n use clippy_utils::{fn_def_id, get_parent_expr};\n use rustc_errors::Applicability;\n use rustc_hir::{def_id::DefId, Expr, ExprKind};\n@@ -54,7 +54,7 @@ pub fn check_for_loop_iter(\n                 if let Some(into_iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::IntoIterator);\n                 let collection_ty = cx.typeck_results().expr_ty(collection);\n                 if implements_trait(cx, collection_ty, into_iterator_trait_id, &[]);\n-                if let Some(into_iter_item_ty) = get_associated_type(cx, collection_ty, into_iterator_trait_id, \"Item\");\n+                if let Some(into_iter_item_ty) = cx.get_associated_type(collection_ty, into_iterator_trait_id, \"Item\");\n \n                 if iter_item_ty == into_iter_item_ty;\n                 if let Some(collection_snippet) = snippet_opt(cx, collection.span);"}, {"sha": "8b000cd754cd1352f6ab5219336e659b91593a7a", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -2,9 +2,11 @@ use super::implicit_clone::is_clone_like;\n use super::unnecessary_iter_cloned::{self, is_into_iter};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs};\n+use clippy_utils::ty::{get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs};\n use clippy_utils::visitors::find_all_ret_expressions;\n-use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item, return_ty};\n+use clippy_utils::{\n+    fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item, return_ty,\n+};\n use clippy_utils::{meets_msrv, msrvs};\n use rustc_errors::Applicability;\n use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, ItemKind, Node};\n@@ -18,7 +20,9 @@ use rustc_middle::ty::EarlyBinder;\n use rustc_middle::ty::{self, ParamTy, PredicateKind, ProjectionPredicate, TraitPredicate, Ty};\n use rustc_semver::RustcVersion;\n use rustc_span::{sym, Symbol};\n-use rustc_trait_selection::traits::{query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause};\n+use rustc_trait_selection::traits::{\n+    query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause,\n+};\n use std::cmp::max;\n \n use super::UNNECESSARY_TO_OWNED;\n@@ -146,7 +150,7 @@ fn check_addr_of_expr(\n             if_chain! {\n                 if let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref);\n                 if implements_trait(cx, receiver_ty, deref_trait_id, &[]);\n-                if get_associated_type(cx, receiver_ty, deref_trait_id, \"Target\") == Some(target_ty);\n+                if cx.get_associated_type(receiver_ty, deref_trait_id, \"Target\") == Some(target_ty);\n                 then {\n                     if n_receiver_refs > 0 {\n                         span_lint_and_sugg(\n@@ -341,13 +345,13 @@ fn get_input_traits_and_projections<'tcx>(\n                 if trait_predicate.trait_ref.self_ty() == input {\n                     trait_predicates.push(trait_predicate);\n                 }\n-            },\n+            }\n             PredicateKind::Projection(projection_predicate) => {\n                 if projection_predicate.projection_ty.self_ty() == input {\n                     projection_predicates.push(projection_predicate);\n                 }\n-            },\n-            _ => {},\n+            }\n+            _ => {}\n         }\n     }\n     (trait_predicates, projection_predicates)\n@@ -462,7 +466,12 @@ fn is_cloned_or_copied(cx: &LateContext<'_>, method_name: Symbol, method_def_id:\n \n /// Returns true if the named method can be used to convert the receiver to its \"owned\"\n /// representation.\n-fn is_to_owned_like<'a>(cx: &LateContext<'a>, call_expr: &Expr<'a>, method_name: Symbol, method_def_id: DefId) -> bool {\n+fn is_to_owned_like<'a>(\n+    cx: &LateContext<'a>,\n+    call_expr: &Expr<'a>,\n+    method_name: Symbol,\n+    method_def_id: DefId,\n+) -> bool {\n     is_clone_like(cx, method_name.as_str(), method_def_id)\n         || is_cow_into_owned(cx, method_name, method_def_id)\n         || is_to_string_on_string_like(cx, call_expr, method_name, method_def_id)\n@@ -490,7 +499,7 @@ fn is_to_string_on_string_like<'a>(\n         && let GenericArgKind::Type(ty) = generic_arg.unpack()\n         && let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref)\n         && let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef)\n-        && (get_associated_type(cx, ty, deref_trait_id, \"Target\") == Some(cx.tcx.types.str_) ||\n+        && (cx.get_associated_type(ty, deref_trait_id, \"Target\") == Some(cx.tcx.types.str_) ||\n             implements_trait(cx, ty, as_ref_trait_id, &[cx.tcx.types.str_.into()])) {\n             true\n         } else {"}, {"sha": "e111c7d22915186b12a00f803f5a6960ce690938", "filename": "src/tools/clippy/clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -582,7 +582,7 @@ fn ident_difference_expr_with_base_location(\n         | (Block(_, _), Block(_, _))\n         | (Closure(_), Closure(_))\n         | (Match(_, _), Match(_, _))\n-        | (Loop(_, _), Loop(_, _))\n+        | (Loop(_, _, _), Loop(_, _, _))\n         | (ForLoop(_, _, _, _), ForLoop(_, _, _, _))\n         | (While(_, _, _), While(_, _, _))\n         | (If(_, _, _), If(_, _, _))"}, {"sha": "6bcf0bbd7eb75f8ef50e8ea81b390d2e610be8cb", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -171,7 +171,7 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (ForLoop(lp, li, lt, ll), ForLoop(rp, ri, rt, rl)) => {\n             eq_label(ll, rl) && eq_pat(lp, rp) && eq_expr(li, ri) && eq_block(lt, rt)\n         },\n-        (Loop(lt, ll), Loop(rt, rl)) => eq_label(ll, rl) && eq_block(lt, rt),\n+        (Loop(lt, ll, _), Loop(rt, rl, _)) => eq_label(ll, rl) && eq_block(lt, rt),\n         (Block(lb, ll), Block(rb, rl)) => eq_label(ll, rl) && eq_block(lb, rb),\n         (TryBlock(l), TryBlock(r)) => eq_block(l, r),\n         (Yield(l), Yield(r)) | (Ret(l), Ret(r)) => eq_expr_opt(l, r),"}, {"sha": "8284dc5c28c0bd3684bde74b25d86d147af43c52", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -117,24 +117,7 @@ pub fn contains_ty_adt_constructor_opaque<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'\n pub fn get_iterator_item_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     cx.tcx\n         .get_diagnostic_item(sym::Iterator)\n-        .and_then(|iter_did| get_associated_type(cx, ty, iter_did, \"Item\"))\n-}\n-\n-/// Returns the associated type `name` for `ty` as an implementation of `trait_id`.\n-/// Do not invoke without first verifying that the type implements the trait.\n-pub fn get_associated_type<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    ty: Ty<'tcx>,\n-    trait_id: DefId,\n-    name: &str,\n-) -> Option<Ty<'tcx>> {\n-    cx.tcx\n-        .associated_items(trait_id)\n-        .find_by_name_and_kind(cx.tcx, Ident::from_str(name), ty::AssocKind::Type, trait_id)\n-        .and_then(|assoc| {\n-            let proj = cx.tcx.mk_projection(assoc.def_id, cx.tcx.mk_substs_trait(ty, []));\n-            cx.tcx.try_normalize_erasing_regions(cx.param_env, proj).ok()\n-        })\n+        .and_then(|iter_did| cx.get_associated_type(ty, iter_did, \"Item\"))\n }\n \n /// Get the diagnostic name of a type, e.g. `sym::HashMap`. To check if a type"}, {"sha": "41c5d36671de00e56f6d890b0139b1d8f4e5be1a", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 77, "deletions": 39, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -221,6 +221,16 @@ dependencies = [\n  \"tracing\",\n ]\n \n+[[package]]\n+name = \"command-group\"\n+version = \"1.0.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f7a8a86f409b4a59df3a3e4bee2de0b83f1755fdd2a25e3a9684c396fc4bed2c\"\n+dependencies = [\n+ \"nix\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"countme\"\n version = \"3.0.1\"\n@@ -300,7 +310,7 @@ dependencies = [\n  \"hashbrown\",\n  \"lock_api\",\n  \"once_cell\",\n- \"parking_lot_core 0.9.3\",\n+ \"parking_lot_core 0.9.4\",\n ]\n \n [[package]]\n@@ -359,14 +369,14 @@ dependencies = [\n \n [[package]]\n name = \"filetime\"\n-version = \"0.2.17\"\n+version = \"0.2.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e94a7bbaa59354bc20dd75b67f23e2797b4490e9d6928203fb105c79e448c86c\"\n+checksum = \"4b9663d381d07ae25dc88dbdf27df458faa83a9b25336bcac83d5e452b5fc9d3\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"redox_syscall\",\n- \"windows-sys 0.36.1\",\n+ \"windows-sys 0.42.0\",\n ]\n \n [[package]]\n@@ -390,6 +400,7 @@ name = \"flycheck\"\n version = \"0.0.0\"\n dependencies = [\n  \"cargo_metadata\",\n+ \"command-group\",\n  \"crossbeam-channel\",\n  \"jod-thread\",\n  \"paths\",\n@@ -963,11 +974,24 @@ dependencies = [\n \n [[package]]\n name = \"miow\"\n-version = \"0.4.0\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a7377f7792b3afb6a3cba68daa54ca23c032137010460d667fda53a8d66be00e\"\n+checksum = \"52ffbca2f655e33c08be35d87278e5b18b89550a37dbd598c20db92f6a471123\"\n dependencies = [\n- \"windows-sys 0.28.0\",\n+ \"windows-sys 0.42.0\",\n+]\n+\n+[[package]]\n+name = \"nix\"\n+version = \"0.22.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e4916f159ed8e5de0082076562152a76b7a1f64a01fd9d1e0fea002c37624faf\"\n+dependencies = [\n+ \"bitflags\",\n+ \"cc\",\n+ \"cfg-if\",\n+ \"libc\",\n+ \"memoffset\",\n ]\n \n [[package]]\n@@ -1037,7 +1061,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f\"\n dependencies = [\n  \"lock_api\",\n- \"parking_lot_core 0.9.3\",\n+ \"parking_lot_core 0.9.4\",\n ]\n \n [[package]]\n@@ -1056,15 +1080,15 @@ dependencies = [\n \n [[package]]\n name = \"parking_lot_core\"\n-version = \"0.9.3\"\n+version = \"0.9.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09a279cbf25cb0757810394fbc1e359949b59e348145c643a939a525692e6929\"\n+checksum = \"4dc9e0dc2adc1c69d09143aff38d3d30c5c3f0df0dad82e6d25547af174ebec0\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"redox_syscall\",\n  \"smallvec\",\n- \"windows-sys 0.36.1\",\n+ \"windows-sys 0.42.0\",\n ]\n \n [[package]]\n@@ -1979,19 +2003,6 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n-[[package]]\n-name = \"windows-sys\"\n-version = \"0.28.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"82ca39602d5cbfa692c4b67e3bcbb2751477355141c1ed434c94da4186836ff6\"\n-dependencies = [\n- \"windows_aarch64_msvc 0.28.0\",\n- \"windows_i686_gnu 0.28.0\",\n- \"windows_i686_msvc 0.28.0\",\n- \"windows_x86_64_gnu 0.28.0\",\n- \"windows_x86_64_msvc 0.28.0\",\n-]\n-\n [[package]]\n name = \"windows-sys\"\n version = \"0.36.1\"\n@@ -2006,10 +2017,25 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"windows_aarch64_msvc\"\n-version = \"0.28.0\"\n+name = \"windows-sys\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7\"\n+dependencies = [\n+ \"windows_aarch64_gnullvm\",\n+ \"windows_aarch64_msvc 0.42.0\",\n+ \"windows_i686_gnu 0.42.0\",\n+ \"windows_i686_msvc 0.42.0\",\n+ \"windows_x86_64_gnu 0.42.0\",\n+ \"windows_x86_64_gnullvm\",\n+ \"windows_x86_64_msvc 0.42.0\",\n+]\n+\n+[[package]]\n+name = \"windows_aarch64_gnullvm\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"52695a41e536859d5308cc613b4a022261a274390b25bd29dfff4bf08505f3c2\"\n+checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n \n [[package]]\n name = \"windows_aarch64_msvc\"\n@@ -2018,10 +2044,10 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n \n [[package]]\n-name = \"windows_i686_gnu\"\n-version = \"0.28.0\"\n+name = \"windows_aarch64_msvc\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f54725ac23affef038fecb177de6c9bf065787c2f432f79e3c373da92f3e1d8a\"\n+checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n@@ -2030,10 +2056,10 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n \n [[package]]\n-name = \"windows_i686_msvc\"\n-version = \"0.28.0\"\n+name = \"windows_i686_gnu\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"51d5158a43cc43623c0729d1ad6647e62fa384a3d135fd15108d37c683461f64\"\n+checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n@@ -2042,10 +2068,10 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n \n [[package]]\n-name = \"windows_x86_64_gnu\"\n-version = \"0.28.0\"\n+name = \"windows_i686_msvc\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bc31f409f565611535130cfe7ee8e6655d3fa99c1c61013981e491921b5ce954\"\n+checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n@@ -2054,17 +2080,29 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n \n [[package]]\n-name = \"windows_x86_64_msvc\"\n-version = \"0.28.0\"\n+name = \"windows_x86_64_gnu\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bf7b1b21b5362cbc318f686150e5bcea75ecedc74dd157d874d754a2ca44b0ed\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnullvm\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f2b8c7cbd3bfdddd9ab98769f9746a7fad1bca236554cd032b78d768bc0e89f\"\n+checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n version = \"0.36.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\"\n \n+[[package]]\n+name = \"windows_x86_64_msvc\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f40009d85759725a34da6d89a94e63d7bdc50a862acf0dbc7c8e488f1edcb6f5\"\n+\n [[package]]\n name = \"write-json\"\n version = \"0.1.2\""}, {"sha": "a484ecec68250944dff51124551cc19d54af5991", "filename": "src/tools/rust-analyzer/crates/base-db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "2857420c285a7874c1f465d757967f709e1aebc2", "filename": "src/tools/rust-analyzer/crates/cfg/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "514d567fcce756eb461adacefa07a117c5dc349b", "filename": "src/tools/rust-analyzer/crates/flycheck/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false\n@@ -17,6 +17,7 @@ rustc-hash = \"1.1.0\"\n serde = { version = \"1.0.137\", features = [\"derive\"] }\n serde_json = \"1.0.86\"\n jod-thread = \"0.1.2\"\n+command-group = \"1.0.8\"\n \n toolchain = { path = \"../toolchain\", version = \"0.0.0\" }\n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "8f93dad06e3f5d384b95b89907faee227e1db0eb", "filename": "src/tools/rust-analyzer/crates/flycheck/src/lib.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -10,11 +10,12 @@ use std::{\n     time::Duration,\n };\n \n+use command_group::{CommandGroup, GroupChild};\n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n use paths::AbsPathBuf;\n use rustc_hash::FxHashMap;\n use serde::Deserialize;\n-use stdx::{process::streaming_output, JodChild};\n+use stdx::process::streaming_output;\n \n pub use cargo_metadata::diagnostic::{\n     Applicability, Diagnostic, DiagnosticCode, DiagnosticLevel, DiagnosticSpan,\n@@ -39,7 +40,7 @@ pub enum InvocationLocation {\n pub enum FlycheckConfig {\n     CargoCommand {\n         command: String,\n-        target_triple: Option<String>,\n+        target_triples: Vec<String>,\n         all_targets: bool,\n         no_default_features: bool,\n         all_features: bool,\n@@ -285,7 +286,7 @@ impl FlycheckActor {\n         let (mut cmd, args) = match &self.config {\n             FlycheckConfig::CargoCommand {\n                 command,\n-                target_triple,\n+                target_triples,\n                 no_default_features,\n                 all_targets,\n                 all_features,\n@@ -299,7 +300,7 @@ impl FlycheckActor {\n                 cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n                     .arg(self.root.join(\"Cargo.toml\").as_os_str());\n \n-                if let Some(target) = target_triple {\n+                for target in target_triples {\n                     cmd.args(&[\"--target\", target.as_str()]);\n                 }\n                 if *all_targets {\n@@ -359,10 +360,12 @@ impl FlycheckActor {\n     }\n }\n \n+struct JodChild(GroupChild);\n+\n /// A handle to a cargo process used for fly-checking.\n struct CargoHandle {\n     /// The handle to the actual cargo process. As we cannot cancel directly from with\n-    /// a read syscall dropping and therefor terminating the process is our best option.\n+    /// a read syscall dropping and therefore terminating the process is our best option.\n     child: JodChild,\n     thread: jod_thread::JoinHandle<io::Result<(bool, String)>>,\n     receiver: Receiver<CargoMessage>,\n@@ -371,10 +374,10 @@ struct CargoHandle {\n impl CargoHandle {\n     fn spawn(mut command: Command) -> std::io::Result<CargoHandle> {\n         command.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());\n-        let mut child = JodChild::spawn(command)?;\n+        let mut child = command.group_spawn().map(JodChild)?;\n \n-        let stdout = child.stdout.take().unwrap();\n-        let stderr = child.stderr.take().unwrap();\n+        let stdout = child.0.inner().stdout.take().unwrap();\n+        let stderr = child.0.inner().stderr.take().unwrap();\n \n         let (sender, receiver) = unbounded();\n         let actor = CargoActor::new(sender, stdout, stderr);\n@@ -386,13 +389,13 @@ impl CargoHandle {\n     }\n \n     fn cancel(mut self) {\n-        let _ = self.child.kill();\n-        let _ = self.child.wait();\n+        let _ = self.child.0.kill();\n+        let _ = self.child.0.wait();\n     }\n \n     fn join(mut self) -> io::Result<()> {\n-        let _ = self.child.kill();\n-        let exit_status = self.child.wait()?;\n+        let _ = self.child.0.kill();\n+        let exit_status = self.child.0.wait()?;\n         let (read_at_least_one_message, error) = self.thread.join()?;\n         if read_at_least_one_message || exit_status.success() {\n             Ok(())"}, {"sha": "22f98ea7cd450e83a44ad9512e1fb9303fadbca0", "filename": "src/tools/rust-analyzer/crates/hir-def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "9c76969086485b2aecafdd7a36f436c4802d8136", "filename": "src/tools/rust-analyzer/crates/hir-def/src/data.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -236,11 +236,19 @@ impl TraitData {\n             .by_key(\"rustc_skip_array_during_method_dispatch\")\n             .exists();\n \n-        let mut collector =\n-            AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::TraitId(tr));\n-        collector.collect(&item_tree, tree_id.tree_id(), &tr_def.items);\n-        let (items, attribute_calls, diagnostics) = collector.finish();\n-\n+        let (items, attribute_calls, diagnostics) = match &tr_def.items {\n+            Some(items) => {\n+                let mut collector = AssocItemCollector::new(\n+                    db,\n+                    module_id,\n+                    tree_id.file_id(),\n+                    ItemContainerId::TraitId(tr),\n+                );\n+                collector.collect(&item_tree, tree_id.tree_id(), items);\n+                collector.finish()\n+            }\n+            None => Default::default(),\n+        };\n         (\n             Arc::new(TraitData {\n                 name,"}, {"sha": "0aa531eff71f6f5e02e12f003c947e25c1dddf5e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -666,7 +666,8 @@ pub struct Trait {\n     pub generic_params: Interned<GenericParams>,\n     pub is_auto: bool,\n     pub is_unsafe: bool,\n-    pub items: Box<[AssocItem]>,\n+    /// This is [`None`] if this Trait is a trait alias.\n+    pub items: Option<Box<[AssocItem]>>,\n     pub ast_id: FileAstId<ast::Trait>,\n }\n "}, {"sha": "b25274bccc9a4aa6dbe507dc946376af735ab181", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -451,15 +451,7 @@ impl<'a> Ctx<'a> {\n                 .collect()\n         });\n         let ast_id = self.source_ast_id_map.ast_id(trait_def);\n-        let res = Trait {\n-            name,\n-            visibility,\n-            generic_params,\n-            is_auto,\n-            is_unsafe,\n-            items: items.unwrap_or_default(),\n-            ast_id,\n-        };\n+        let res = Trait { name, visibility, generic_params, is_auto, is_unsafe, items, ast_id };\n         Some(id(self.data().traits.alloc(res)))\n     }\n "}, {"sha": "48c40df22ff5f2ff319405cbb352739af61aafb1", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -375,12 +375,21 @@ impl<'a> Printer<'a> {\n                 }\n                 w!(self, \"trait {}\", name);\n                 self.print_generic_params(generic_params);\n-                self.print_where_clause_and_opening_brace(generic_params);\n-                self.indented(|this| {\n-                    for item in &**items {\n-                        this.print_mod_item((*item).into());\n+                match items {\n+                    Some(items) => {\n+                        self.print_where_clause_and_opening_brace(generic_params);\n+                        self.indented(|this| {\n+                            for item in &**items {\n+                                this.print_mod_item((*item).into());\n+                            }\n+                        });\n                     }\n-                });\n+                    None => {\n+                        w!(self, \" = \");\n+                        // FIXME: Print the aliased traits\n+                        self.print_where_clause_and_opening_brace(generic_params);\n+                    }\n+                }\n                 wln!(self, \"}}\");\n             }\n             ModItem::Impl(it) => {"}, {"sha": "fc90c6e9f370f107cacd59606055ecba9a6d94ea", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/matching.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -94,11 +94,11 @@ macro_rules! m {\n     ($($s:stmt)*) => (stringify!($($s |)*);)\n }\n stringify!(;\n-|;\n-|92|;\n-|let x = 92|;\n+| ;\n+|92| ;\n+|let x = 92| ;\n |loop {}\n-|;\n+| ;\n |);\n \"#]],\n     );\n@@ -118,7 +118,7 @@ m!(.. .. ..);\n macro_rules! m {\n     ($($p:pat)*) => (stringify!($($p |)*);)\n }\n-stringify!(.. .. ..|);\n+stringify!(.. .. .. |);\n \"#]],\n     );\n }"}, {"sha": "118c14ed843fecf9e3e5ad2a59f2f3ae3e1757bc", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/proc_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -82,14 +82,14 @@ fn attribute_macro_syntax_completion_2() {\n #[proc_macros::identity_when_valid]\n fn foo() { bar.; blub }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[proc_macros::identity_when_valid]\n fn foo() { bar.; blub }\n \n fn foo() {\n-    bar.;\n+    bar. ;\n     blub\n-}\"##]],\n+}\"#]],\n     );\n }\n "}, {"sha": "b0dd01f9dbea288784cceef395338852ef4ed859", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -212,6 +212,7 @@ impl Import {\n \n #[derive(Debug, Eq, PartialEq)]\n struct ImportDirective {\n+    /// The module this import directive is in.\n     module_id: LocalModuleId,\n     import: Import,\n     status: PartialResolvedImport,\n@@ -963,8 +964,10 @@ impl DefCollector<'_> {\n \n     fn update(\n         &mut self,\n+        // The module for which `resolutions` have been resolve\n         module_id: LocalModuleId,\n         resolutions: &[(Option<Name>, PerNs)],\n+        // Visibility this import will have\n         vis: Visibility,\n         import_type: ImportType,\n     ) {\n@@ -974,6 +977,7 @@ impl DefCollector<'_> {\n \n     fn update_recursive(\n         &mut self,\n+        // The module for which `resolutions` have been resolve\n         module_id: LocalModuleId,\n         resolutions: &[(Option<Name>, PerNs)],\n         // All resolutions are imported with this visibility; the visibilities in"}, {"sha": "20d39ec6cb92e2c86b2a1c48d43de2ca627f73e1", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -73,7 +73,10 @@ impl DefMap {\n     pub(crate) fn resolve_visibility(\n         &self,\n         db: &dyn DefDatabase,\n+        // module to import to\n         original_module: LocalModuleId,\n+        // pub(path)\n+        //     ^^^^ this\n         visibility: &RawVisibility,\n     ) -> Option<Visibility> {\n         let mut vis = match visibility {\n@@ -115,6 +118,7 @@ impl DefMap {\n         &self,\n         db: &dyn DefDatabase,\n         mode: ResolveMode,\n+        // module to import to\n         mut original_module: LocalModuleId,\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n@@ -361,6 +365,9 @@ impl DefMap {\n                     );\n                 }\n             };\n+\n+            curr_per_ns = curr_per_ns\n+                .filter_visibility(|vis| vis.is_visible_from_def_map(db, self, original_module));\n         }\n \n         ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None, Some(self.krate))"}, {"sha": "0d90047c28f6f7e3e30991914642effaedb23387", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -58,9 +58,9 @@ extern {\n \"#,\n         expect![[r#\"\n             crate\n-            E: t\n+            E: _\n             S: t v\n-            V: t v\n+            V: _\n             foo: t\n \n             crate::foo\n@@ -307,7 +307,7 @@ pub struct FromLib;\n             Bar: t v\n \n             crate::foo\n-            Bar: t v\n+            Bar: _\n             FromLib: t v\n         \"#]],\n     );"}, {"sha": "88a3c76393f08fed9b12adf425a5f37f9d7e3d7d", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/globs.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -119,7 +119,7 @@ use foo::*;\n use foo::bar::*;\n \n //- /foo/mod.rs\n-mod bar;\n+pub mod bar;\n fn Foo() {};\n pub struct Foo {};\n \n@@ -132,6 +132,7 @@ pub(crate) struct PubCrateStruct;\n             crate\n             Foo: t\n             PubCrateStruct: t v\n+            bar: t\n             foo: t\n \n             crate::foo\n@@ -336,3 +337,33 @@ mod d {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn glob_name_collision_check_visibility() {\n+    check(\n+        r#\"\n+mod event {\n+    mod serenity {\n+        pub fn Event() {}\n+    }\n+    use serenity::*;\n+\n+    pub struct Event {}\n+}\n+\n+use event::Event;\n+        \"#,\n+        expect![[r#\"\n+            crate\n+            Event: t\n+            event: t\n+\n+            crate::event\n+            Event: t v\n+            serenity: t\n+\n+            crate::event::serenity\n+            Event: v\n+        \"#]],\n+    );\n+}"}, {"sha": "c575bf7cac2550d252c88bf785b6179c86b43551", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -580,7 +580,7 @@ fn module_resolution_decl_inside_inline_module_in_crate_root() {\n //- /main.rs\n mod foo {\n     #[path = \"baz.rs\"]\n-    mod bar;\n+    pub mod bar;\n }\n use self::foo::bar::Baz;\n "}, {"sha": "77eb1fd450433468adc517c258322a6559d4c55c", "filename": "src/tools/rust-analyzer/crates/hir-expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "a4abe75626e6dcacf24df7e822857e404eecc919", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/fixup.rs", "status": "modified", "additions": 66, "deletions": 30, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,6 +4,7 @@ use std::mem;\n \n use mbe::{SyntheticToken, SyntheticTokenId, TokenMap};\n use rustc_hash::FxHashMap;\n+use smallvec::SmallVec;\n use syntax::{\n     ast::{self, AstNode, HasLoopBody},\n     match_ast, SyntaxElement, SyntaxKind, SyntaxNode, TextRange,\n@@ -292,25 +293,34 @@ pub(crate) fn reverse_fixups(\n     token_map: &TokenMap,\n     undo_info: &SyntaxFixupUndoInfo,\n ) {\n-    tt.token_trees.retain(|tt| match tt {\n-        tt::TokenTree::Leaf(leaf) => {\n-            token_map.synthetic_token_id(leaf.id()).is_none()\n-                || token_map.synthetic_token_id(leaf.id()) != Some(EMPTY_ID)\n-        }\n-        tt::TokenTree::Subtree(st) => st.delimiter.map_or(true, |d| {\n-            token_map.synthetic_token_id(d.id).is_none()\n-                || token_map.synthetic_token_id(d.id) != Some(EMPTY_ID)\n-        }),\n-    });\n-    tt.token_trees.iter_mut().for_each(|tt| match tt {\n-        tt::TokenTree::Subtree(tt) => reverse_fixups(tt, token_map, undo_info),\n-        tt::TokenTree::Leaf(leaf) => {\n-            if let Some(id) = token_map.synthetic_token_id(leaf.id()) {\n-                let original = &undo_info.original[id.0 as usize];\n-                *tt = tt::TokenTree::Subtree(original.clone());\n+    let tts = std::mem::take(&mut tt.token_trees);\n+    tt.token_trees = tts\n+        .into_iter()\n+        .filter(|tt| match tt {\n+            tt::TokenTree::Leaf(leaf) => token_map.synthetic_token_id(leaf.id()) != Some(EMPTY_ID),\n+            tt::TokenTree::Subtree(st) => {\n+                st.delimiter.map_or(true, |d| token_map.synthetic_token_id(d.id) != Some(EMPTY_ID))\n             }\n-        }\n-    });\n+        })\n+        .flat_map(|tt| match tt {\n+            tt::TokenTree::Subtree(mut tt) => {\n+                reverse_fixups(&mut tt, token_map, undo_info);\n+                SmallVec::from_const([tt.into()])\n+            }\n+            tt::TokenTree::Leaf(leaf) => {\n+                if let Some(id) = token_map.synthetic_token_id(leaf.id()) {\n+                    let original = undo_info.original[id.0 as usize].clone();\n+                    if original.delimiter.is_none() {\n+                        original.token_trees.into()\n+                    } else {\n+                        SmallVec::from_const([original.into()])\n+                    }\n+                } else {\n+                    SmallVec::from_const([leaf.into()])\n+                }\n+            }\n+        })\n+        .collect();\n }\n \n #[cfg(test)]\n@@ -319,6 +329,31 @@ mod tests {\n \n     use super::reverse_fixups;\n \n+    // The following three functions are only meant to check partial structural equivalence of\n+    // `TokenTree`s, see the last assertion in `check()`.\n+    fn check_leaf_eq(a: &tt::Leaf, b: &tt::Leaf) -> bool {\n+        match (a, b) {\n+            (tt::Leaf::Literal(a), tt::Leaf::Literal(b)) => a.text == b.text,\n+            (tt::Leaf::Punct(a), tt::Leaf::Punct(b)) => a.char == b.char,\n+            (tt::Leaf::Ident(a), tt::Leaf::Ident(b)) => a.text == b.text,\n+            _ => false,\n+        }\n+    }\n+\n+    fn check_subtree_eq(a: &tt::Subtree, b: &tt::Subtree) -> bool {\n+        a.delimiter.map(|it| it.kind) == b.delimiter.map(|it| it.kind)\n+            && a.token_trees.len() == b.token_trees.len()\n+            && a.token_trees.iter().zip(&b.token_trees).all(|(a, b)| check_tt_eq(a, b))\n+    }\n+\n+    fn check_tt_eq(a: &tt::TokenTree, b: &tt::TokenTree) -> bool {\n+        match (a, b) {\n+            (tt::TokenTree::Leaf(a), tt::TokenTree::Leaf(b)) => check_leaf_eq(a, b),\n+            (tt::TokenTree::Subtree(a), tt::TokenTree::Subtree(b)) => check_subtree_eq(a, b),\n+            _ => false,\n+        }\n+    }\n+\n     #[track_caller]\n     fn check(ra_fixture: &str, mut expect: Expect) {\n         let parsed = syntax::SourceFile::parse(ra_fixture);\n@@ -331,27 +366,28 @@ mod tests {\n             fixups.append,\n         );\n \n-        let mut actual = tt.to_string();\n-        actual.push('\\n');\n+        let actual = format!(\"{}\\n\", tt);\n \n         expect.indent(false);\n         expect.assert_eq(&actual);\n \n         // the fixed-up tree should be syntactically valid\n         let (parse, _) = mbe::token_tree_to_syntax_node(&tt, ::mbe::TopEntryPoint::MacroItems);\n-        assert_eq!(\n-            parse.errors(),\n-            &[],\n+        assert!(\n+            parse.errors().is_empty(),\n             \"parse has syntax errors. parse tree:\\n{:#?}\",\n             parse.syntax_node()\n         );\n \n         reverse_fixups(&mut tt, &tmap, &fixups.undo_info);\n \n         // the fixed-up + reversed version should be equivalent to the original input\n-        // (but token IDs don't matter)\n+        // modulo token IDs and `Punct`s' spacing.\n         let (original_as_tt, _) = mbe::syntax_node_to_token_tree(&parsed.syntax_node());\n-        assert_eq!(tt.to_string(), original_as_tt.to_string());\n+        assert!(\n+            check_subtree_eq(&tt, &original_as_tt),\n+            \"different token tree: {tt:?}, {original_as_tt:?}\"\n+        );\n     }\n \n     #[test]\n@@ -468,7 +504,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-fn foo () {a .__ra_fixup}\n+fn foo () {a . __ra_fixup}\n \"#]],\n         )\n     }\n@@ -482,7 +518,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-fn foo () {a .__ra_fixup ;}\n+fn foo () {a . __ra_fixup ;}\n \"#]],\n         )\n     }\n@@ -497,7 +533,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-fn foo () {a .__ra_fixup ; bar () ;}\n+fn foo () {a . __ra_fixup ; bar () ;}\n \"#]],\n         )\n     }\n@@ -525,7 +561,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-fn foo () {let x = a .__ra_fixup ;}\n+fn foo () {let x = a . __ra_fixup ;}\n \"#]],\n         )\n     }\n@@ -541,7 +577,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-fn foo () {a .b ; bar () ;}\n+fn foo () {a . b ; bar () ;}\n \"#]],\n         )\n     }"}, {"sha": "7352b003a491cde5ca4b09ce94ecfa1c99f9f172", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -814,7 +814,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n \n     pub fn original_syntax_node(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxNode>> {\n         // This kind of upmapping can only be achieved in attribute expanded files,\n-        // as we don't have node inputs otherwise and  therefor can't find an `N` node in the input\n+        // as we don't have node inputs otherwise and therefore can't find an `N` node in the input\n         if !self.file_id.is_macro() {\n             return Some(self.map(Clone::clone));\n         } else if !self.file_id.is_attr_macro(db) {\n@@ -926,7 +926,7 @@ impl<N: AstNode> InFile<N> {\n \n     pub fn original_ast_node(self, db: &dyn db::AstDatabase) -> Option<InFile<N>> {\n         // This kind of upmapping can only be achieved in attribute expanded files,\n-        // as we don't have node inputs otherwise and  therefor can't find an `N` node in the input\n+        // as we don't have node inputs otherwise and therefore can't find an `N` node in the input\n         if !self.file_id.is_macro() {\n             return Some(self);\n         } else if !self.file_id.is_attr_macro(db) {"}, {"sha": "a1d6835bfaed36eb2a5e4655174ee2d926a74486", "filename": "src/tools/rust-analyzer/crates/hir-ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "39514fc44e6c8091849b73b3d9c06549ba585b7b", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lib.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -53,7 +53,7 @@ pub use builder::{ParamKind, TyBuilder};\n pub use chalk_ext::*;\n pub use infer::{\n     could_coerce, could_unify, Adjust, Adjustment, AutoBorrow, BindingMode, InferenceDiagnostic,\n-    InferenceResult,\n+    InferenceResult, OverloadedDeref, PointerCast,\n };\n pub use interner::Interner;\n pub use lower::{\n@@ -523,35 +523,36 @@ where\n }\n \n pub fn callable_sig_from_fnonce(\n-    self_ty: &Canonical<Ty>,\n+    self_ty: &Ty,\n     env: Arc<TraitEnvironment>,\n     db: &dyn HirDatabase,\n ) -> Option<CallableSig> {\n     let krate = env.krate;\n     let fn_once_trait = FnTrait::FnOnce.get_id(db, krate)?;\n     let output_assoc_type = db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;\n \n-    let mut kinds = self_ty.binders.interned().to_vec();\n     let b = TyBuilder::trait_ref(db, fn_once_trait);\n     if b.remaining() != 2 {\n         return None;\n     }\n-    let fn_once = b\n-        .push(self_ty.value.clone())\n-        .fill_with_bound_vars(DebruijnIndex::INNERMOST, kinds.len())\n-        .build();\n-    kinds.extend(fn_once.substitution.iter(Interner).skip(1).map(|x| {\n-        let vk = match x.data(Interner) {\n-            chalk_ir::GenericArgData::Ty(_) => {\n-                chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General)\n-            }\n-            chalk_ir::GenericArgData::Lifetime(_) => chalk_ir::VariableKind::Lifetime,\n-            chalk_ir::GenericArgData::Const(c) => {\n-                chalk_ir::VariableKind::Const(c.data(Interner).ty.clone())\n-            }\n-        };\n-        chalk_ir::WithKind::new(vk, UniverseIndex::ROOT)\n-    }));\n+    let fn_once = b.push(self_ty.clone()).fill_with_bound_vars(DebruijnIndex::INNERMOST, 0).build();\n+    let kinds = fn_once\n+        .substitution\n+        .iter(Interner)\n+        .skip(1)\n+        .map(|x| {\n+            let vk = match x.data(Interner) {\n+                chalk_ir::GenericArgData::Ty(_) => {\n+                    chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General)\n+                }\n+                chalk_ir::GenericArgData::Lifetime(_) => chalk_ir::VariableKind::Lifetime,\n+                chalk_ir::GenericArgData::Const(c) => {\n+                    chalk_ir::VariableKind::Const(c.data(Interner).ty.clone())\n+                }\n+            };\n+            chalk_ir::WithKind::new(vk, UniverseIndex::ROOT)\n+        })\n+        .collect::<Vec<_>>();\n \n     // FIXME: chalk refuses to solve `<Self as FnOnce<^0.0>>::Output == ^0.1`, so we first solve\n     // `<Self as FnOnce<^0.0>>` and then replace `^0.0` with the concrete argument tuple.\n@@ -563,21 +564,16 @@ pub fn callable_sig_from_fnonce(\n         Some(Solution::Unique(vars)) => vars.value.subst,\n         _ => return None,\n     };\n-    let args = subst.at(Interner, self_ty.binders.interned().len()).ty(Interner)?;\n+    let args = subst.at(Interner, 0).ty(Interner)?;\n     let params = match args.kind(Interner) {\n         chalk_ir::TyKind::Tuple(_, subst) => {\n             subst.iter(Interner).filter_map(|arg| arg.ty(Interner).cloned()).collect::<Vec<_>>()\n         }\n         _ => return None,\n     };\n-    if params.iter().any(|ty| ty.is_unknown()) {\n-        return None;\n-    }\n \n-    let fn_once = TyBuilder::trait_ref(db, fn_once_trait)\n-        .push(self_ty.value.clone())\n-        .push(args.clone())\n-        .build();\n+    let fn_once =\n+        TyBuilder::trait_ref(db, fn_once_trait).push(self_ty.clone()).push(args.clone()).build();\n     let projection =\n         TyBuilder::assoc_type_projection(db, output_assoc_type, Some(fn_once.substitution.clone()))\n             .build();"}, {"sha": "8bcfa2728f071844a8e57c0ec81ca3f6f2dcbf46", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -541,7 +541,7 @@ pub struct ReceiverAdjustments {\n \n impl ReceiverAdjustments {\n     pub(crate) fn apply(&self, table: &mut InferenceTable<'_>, ty: Ty) -> (Ty, Vec<Adjustment>) {\n-        let mut ty = ty;\n+        let mut ty = table.resolve_ty_shallow(&ty);\n         let mut adjust = Vec::new();\n         for _ in 0..self.autoderefs {\n             match autoderef::autoderef_step(table, ty.clone()) {"}, {"sha": "5d76d185ffc0441cb3b961bd57c251f612972b33", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -164,16 +164,16 @@ fn infer_associated_method_with_modules() {\n     check_infer(\n         r#\"\n         mod a {\n-            struct A;\n+            pub struct A;\n             impl A { pub fn thing() -> A { A {} }}\n         }\n \n         mod b {\n-            struct B;\n+            pub struct B;\n             impl B { pub fn thing() -> u32 { 99 }}\n \n-            mod c {\n-                struct C;\n+            pub mod c {\n+                pub struct C;\n                 impl C { pub fn thing() -> C { C {} }}\n             }\n         }\n@@ -186,22 +186,22 @@ fn infer_associated_method_with_modules() {\n         }\n         \"#,\n         expect![[r#\"\n-            55..63 '{ A {} }': A\n-            57..61 'A {}': A\n-            125..131 '{ 99 }': u32\n-            127..129 '99': u32\n-            201..209 '{ C {} }': C\n-            203..207 'C {}': C\n-            240..324 '{     ...g(); }': ()\n-            250..251 'x': A\n-            254..265 'a::A::thing': fn thing() -> A\n-            254..267 'a::A::thing()': A\n-            277..278 'y': u32\n-            281..292 'b::B::thing': fn thing() -> u32\n-            281..294 'b::B::thing()': u32\n-            304..305 'z': C\n-            308..319 'c::C::thing': fn thing() -> C\n-            308..321 'c::C::thing()': C\n+            59..67 '{ A {} }': A\n+            61..65 'A {}': A\n+            133..139 '{ 99 }': u32\n+            135..137 '99': u32\n+            217..225 '{ C {} }': C\n+            219..223 'C {}': C\n+            256..340 '{     ...g(); }': ()\n+            266..267 'x': A\n+            270..281 'a::A::thing': fn thing() -> A\n+            270..283 'a::A::thing()': A\n+            293..294 'y': u32\n+            297..308 'b::B::thing': fn thing() -> u32\n+            297..310 'b::B::thing()': u32\n+            320..321 'z': C\n+            324..335 'c::C::thing': fn thing() -> C\n+            324..337 'c::C::thing()': C\n         \"#]],\n     );\n }"}, {"sha": "4e46397459d5d6b26a16e4729d799bcaa244f4c1", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1707,3 +1707,19 @@ impl<T, const N: usize> Trait for [T; N] {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn unsize_array_with_inference_variable() {\n+    check_types(\n+        r#\"\n+//- minicore: try, slice\n+use core::ops::ControlFlow;\n+fn foo() -> ControlFlow<(), [usize; 1]> { loop {} }\n+fn bar() -> ControlFlow<(), ()> {\n+    let a = foo()?.len();\n+      //^ usize\n+    ControlFlow::Continue(())\n+}\n+\"#,\n+    );\n+}"}, {"sha": "d7431443b83d519bb1330a7bd5e5ef4a1650142a", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -214,7 +214,7 @@ fn infer_paths() {\n fn a() -> u32 { 1 }\n \n mod b {\n-    fn c() -> u32 { 1 }\n+    pub fn c() -> u32 { 1 }\n }\n \n fn test() {\n@@ -225,13 +225,13 @@ fn test() {\n         expect![[r#\"\n             14..19 '{ 1 }': u32\n             16..17 '1': u32\n-            47..52 '{ 1 }': u32\n-            49..50 '1': u32\n-            66..90 '{     ...c(); }': ()\n-            72..73 'a': fn a() -> u32\n-            72..75 'a()': u32\n-            81..85 'b::c': fn c() -> u32\n-            81..87 'b::c()': u32\n+            51..56 '{ 1 }': u32\n+            53..54 '1': u32\n+            70..94 '{     ...c(); }': ()\n+            76..77 'a': fn a() -> u32\n+            76..79 'a()': u32\n+            85..89 'b::c': fn c() -> u32\n+            85..91 'b::c()': u32\n         \"#]],\n     );\n }\n@@ -1856,7 +1856,7 @@ fn not_shadowing_module_by_primitive() {\n     check_types(\n         r#\"\n //- /str.rs\n-fn foo() -> u32 {0}\n+pub fn foo() -> u32 {0}\n \n //- /main.rs\n mod str;"}, {"sha": "3d7194b6f4468ff0fe20910642af7f61bd52b73f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1706,7 +1706,7 @@ fn where_clause_trait_in_scope_for_method_resolution() {\n     check_types(\n         r#\"\n mod foo {\n-    trait Trait {\n+    pub trait Trait {\n         fn foo(&self) -> u32 { 0 }\n     }\n }\n@@ -1723,7 +1723,7 @@ fn super_trait_method_resolution() {\n     check_infer(\n         r#\"\n mod foo {\n-    trait SuperTrait {\n+    pub trait SuperTrait {\n         fn foo(&self) -> u32 {}\n     }\n }\n@@ -1735,15 +1735,15 @@ fn test<T: Trait1, U: Trait2>(x: T, y: U) {\n     y.foo();\n }\"#,\n         expect![[r#\"\n-            49..53 'self': &Self\n-            62..64 '{}': u32\n-            181..182 'x': T\n-            187..188 'y': U\n-            193..222 '{     ...o(); }': ()\n-            199..200 'x': T\n-            199..206 'x.foo()': u32\n-            212..213 'y': U\n-            212..219 'y.foo()': u32\n+            53..57 'self': &Self\n+            66..68 '{}': u32\n+            185..186 'x': T\n+            191..192 'y': U\n+            197..226 '{     ...o(); }': ()\n+            203..204 'x': T\n+            203..210 'x.foo()': u32\n+            216..217 'y': U\n+            216..223 'y.foo()': u32\n         \"#]],\n     );\n }\n@@ -1754,7 +1754,7 @@ fn super_trait_impl_trait_method_resolution() {\n         r#\"\n //- minicore: sized\n mod foo {\n-    trait SuperTrait {\n+    pub trait SuperTrait {\n         fn foo(&self) -> u32 {}\n     }\n }\n@@ -1764,12 +1764,12 @@ fn test(x: &impl Trait1) {\n     x.foo();\n }\"#,\n         expect![[r#\"\n-            49..53 'self': &Self\n-            62..64 '{}': u32\n-            115..116 'x': &impl Trait1\n-            132..148 '{     ...o(); }': ()\n-            138..139 'x': &impl Trait1\n-            138..145 'x.foo()': u32\n+            53..57 'self': &Self\n+            66..68 '{}': u32\n+            119..120 'x': &impl Trait1\n+            136..152 '{     ...o(); }': ()\n+            142..143 'x': &impl Trait1\n+            142..149 'x.foo()': u32\n         \"#]],\n     );\n }"}, {"sha": "f780e3f53c855aa733d2b690883d16386727d037", "filename": "src/tools/rust-analyzer/crates/hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "cbbcaebb428554a107ffcec8babdac21f3efac15", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -117,7 +117,7 @@ pub use {\n         name::{known, Name},\n         ExpandResult, HirFileId, InFile, MacroFile, Origin,\n     },\n-    hir_ty::display::HirDisplay,\n+    hir_ty::{display::HirDisplay, PointerCast, Safety},\n };\n \n // These are negative re-exports: pub using these names is forbidden, they\n@@ -2997,8 +2997,7 @@ impl Type {\n             TyKind::Function(_) => Callee::FnPtr,\n             TyKind::FnDef(..) => Callee::Def(self.ty.callable_def(db)?),\n             _ => {\n-                let ty = hir_ty::replace_errors_with_variables(&self.ty);\n-                let sig = hir_ty::callable_sig_from_fnonce(&ty, self.env.clone(), db)?;\n+                let sig = hir_ty::callable_sig_from_fnonce(&self.ty, self.env.clone(), db)?;\n                 return Some(Callable {\n                     ty: self.clone(),\n                     sig,\n@@ -3651,6 +3650,28 @@ impl From<ItemInNs> for ScopeDef {\n     }\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum Adjust {\n+    /// Go from ! to any type.\n+    NeverToAny,\n+    /// Dereference once, producing a place.\n+    Deref(Option<OverloadedDeref>),\n+    /// Take the address and produce either a `&` or `*` pointer.\n+    Borrow(AutoBorrow),\n+    Pointer(PointerCast),\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum AutoBorrow {\n+    /// Converts from T to &T.\n+    Ref(Mutability),\n+    /// Converts from T to *T.\n+    RawPtr(Mutability),\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct OverloadedDeref(pub Mutability);\n+\n pub trait HasVisibility {\n     fn visibility(&self, db: &dyn HirDatabase) -> Visibility;\n     fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {"}, {"sha": "2e1f88ba09043e7b9d76bfbb2b1d1ec266302c13", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics.rs", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -29,9 +29,10 @@ use crate::{\n     db::HirDatabase,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, SourceAnalyzer},\n-    Access, BindingMode, BuiltinAttr, Callable, ConstParam, Crate, DeriveHelper, Field, Function,\n-    HasSource, HirFileId, Impl, InFile, Label, LifetimeParam, Local, Macro, Module, ModuleDef,\n-    Name, Path, ScopeDef, ToolModule, Trait, Type, TypeAlias, TypeParam, VariantDef,\n+    Access, Adjust, AutoBorrow, BindingMode, BuiltinAttr, Callable, ConstParam, Crate,\n+    DeriveHelper, Field, Function, HasSource, HirFileId, Impl, InFile, Label, LifetimeParam, Local,\n+    Macro, Module, ModuleDef, Name, OverloadedDeref, Path, ScopeDef, ToolModule, Trait, Type,\n+    TypeAlias, TypeParam, VariantDef,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -333,9 +334,8 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_trait(trait_)\n     }\n \n-    // FIXME: Figure out a nice interface to inspect adjustments\n-    pub fn is_implicit_reborrow(&self, expr: &ast::Expr) -> Option<Mutability> {\n-        self.imp.is_implicit_reborrow(expr)\n+    pub fn expr_adjustments(&self, expr: &ast::Expr) -> Option<Vec<Adjust>> {\n+        self.imp.expr_adjustments(expr)\n     }\n \n     pub fn type_of_expr(&self, expr: &ast::Expr) -> Option<TypeInfo> {\n@@ -1067,8 +1067,29 @@ impl<'db> SemanticsImpl<'db> {\n         }\n     }\n \n-    fn is_implicit_reborrow(&self, expr: &ast::Expr) -> Option<Mutability> {\n-        self.analyze(expr.syntax())?.is_implicit_reborrow(self.db, expr)\n+    fn expr_adjustments(&self, expr: &ast::Expr) -> Option<Vec<Adjust>> {\n+        let mutability = |m| match m {\n+            hir_ty::Mutability::Not => Mutability::Shared,\n+            hir_ty::Mutability::Mut => Mutability::Mut,\n+        };\n+        self.analyze(expr.syntax())?.expr_adjustments(self.db, expr).map(|it| {\n+            it.iter()\n+                .map(|adjust| match adjust.kind {\n+                    hir_ty::Adjust::NeverToAny => Adjust::NeverToAny,\n+                    hir_ty::Adjust::Deref(Some(hir_ty::OverloadedDeref(m))) => {\n+                        Adjust::Deref(Some(OverloadedDeref(mutability(m))))\n+                    }\n+                    hir_ty::Adjust::Deref(None) => Adjust::Deref(None),\n+                    hir_ty::Adjust::Borrow(hir_ty::AutoBorrow::RawPtr(m)) => {\n+                        Adjust::Borrow(AutoBorrow::RawPtr(mutability(m)))\n+                    }\n+                    hir_ty::Adjust::Borrow(hir_ty::AutoBorrow::Ref(m)) => {\n+                        Adjust::Borrow(AutoBorrow::Ref(mutability(m)))\n+                    }\n+                    hir_ty::Adjust::Pointer(pc) => Adjust::Pointer(pc),\n+                })\n+                .collect()\n+        })\n     }\n \n     fn type_of_expr(&self, expr: &ast::Expr) -> Option<TypeInfo> {"}, {"sha": "91ea1c24d14f83895c13c30a861bbe354f78919a", "filename": "src/tools/rust-analyzer/crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -38,8 +38,7 @@ use hir_ty::{\n         UnsafeExpr,\n     },\n     method_resolution::{self, lang_names_for_bin_op},\n-    Adjust, Adjustment, AutoBorrow, InferenceResult, Interner, Substitution, Ty, TyExt, TyKind,\n-    TyLoweringContext,\n+    Adjustment, InferenceResult, Interner, Substitution, Ty, TyExt, TyKind, TyLoweringContext,\n };\n use itertools::Itertools;\n use smallvec::SmallVec;\n@@ -156,21 +155,14 @@ impl SourceAnalyzer {\n         Some(res)\n     }\n \n-    pub(crate) fn is_implicit_reborrow(\n+    pub(crate) fn expr_adjustments(\n         &self,\n         db: &dyn HirDatabase,\n         expr: &ast::Expr,\n-    ) -> Option<Mutability> {\n+    ) -> Option<&[Adjustment]> {\n         let expr_id = self.expr_id(db, expr)?;\n         let infer = self.infer.as_ref()?;\n-        let adjustments = infer.expr_adjustments.get(&expr_id)?;\n-        adjustments.windows(2).find_map(|slice| match slice {\n-            &[Adjustment {kind: Adjust::Deref(None), ..}, Adjustment {kind: Adjust::Borrow(AutoBorrow::Ref(m)), ..}] => Some(match m {\n-                hir_ty::Mutability::Mut => Mutability::Mut,\n-                hir_ty::Mutability::Not => Mutability::Shared,\n-            }),\n-            _ => None,\n-        })\n+        infer.expr_adjustments.get(&expr_id).map(|v| &**v)\n     }\n \n     pub(crate) fn type_of_expr("}, {"sha": "e781c0a016d5ad3467a4ab7a3d1ec9a0abf761e7", "filename": "src/tools/rust-analyzer/crates/ide-assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "2b3793659cf7d4f9998549cc4c952698b2d6746c", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -196,6 +196,7 @@ trait Foo {\n     type Output;\n \n     const CONST: usize = 42;\n+    const CONST_2: i32;\n \n     fn foo(&self);\n     fn bar(&self);\n@@ -213,6 +214,7 @@ trait Foo {\n     type Output;\n \n     const CONST: usize = 42;\n+    const CONST_2: i32;\n \n     fn foo(&self);\n     fn bar(&self);\n@@ -226,7 +228,7 @@ impl Foo for S {\n \n     $0type Output;\n \n-    const CONST: usize = 42;\n+    const CONST_2: i32;\n \n     fn foo(&self) {\n         todo!()\n@@ -379,14 +381,14 @@ impl Foo for S {\n             r#\"\n mod foo {\n     pub struct Bar;\n-    trait Foo { fn foo(&self, bar: Bar); }\n+    pub trait Foo { fn foo(&self, bar: Bar); }\n }\n struct S;\n impl foo::Foo for S { $0 }\"#,\n             r#\"\n mod foo {\n     pub struct Bar;\n-    trait Foo { fn foo(&self, bar: Bar); }\n+    pub trait Foo { fn foo(&self, bar: Bar); }\n }\n struct S;\n impl foo::Foo for S {\n@@ -439,14 +441,14 @@ impl bar::Foo for S {\n             r#\"\n mod foo {\n     pub struct Bar<T>;\n-    trait Foo { fn foo(&self, bar: Bar<u32>); }\n+    pub trait Foo { fn foo(&self, bar: Bar<u32>); }\n }\n struct S;\n impl foo::Foo for S { $0 }\"#,\n             r#\"\n mod foo {\n     pub struct Bar<T>;\n-    trait Foo { fn foo(&self, bar: Bar<u32>); }\n+    pub trait Foo { fn foo(&self, bar: Bar<u32>); }\n }\n struct S;\n impl foo::Foo for S {\n@@ -464,14 +466,14 @@ impl foo::Foo for S {\n             r#\"\n mod foo {\n     pub struct Bar<T>;\n-    trait Foo<T> { fn foo(&self, bar: Bar<T>); }\n+    pub trait Foo<T> { fn foo(&self, bar: Bar<T>); }\n }\n struct S;\n impl foo::Foo<u32> for S { $0 }\"#,\n             r#\"\n mod foo {\n     pub struct Bar<T>;\n-    trait Foo<T> { fn foo(&self, bar: Bar<T>); }\n+    pub trait Foo<T> { fn foo(&self, bar: Bar<T>); }\n }\n struct S;\n impl foo::Foo<u32> for S {\n@@ -489,15 +491,15 @@ impl foo::Foo<u32> for S {\n             add_missing_impl_members,\n             r#\"\n mod foo {\n-    trait Foo<T> { fn foo(&self, bar: T); }\n+    pub trait Foo<T> { fn foo(&self, bar: T); }\n     pub struct Param;\n }\n struct Param;\n struct S;\n impl foo::Foo<Param> for S { $0 }\"#,\n             r#\"\n mod foo {\n-    trait Foo<T> { fn foo(&self, bar: T); }\n+    pub trait Foo<T> { fn foo(&self, bar: T); }\n     pub struct Param;\n }\n struct Param;\n@@ -518,15 +520,15 @@ impl foo::Foo<Param> for S {\n mod foo {\n     pub struct Bar<T>;\n     impl Bar<T> { type Assoc = u32; }\n-    trait Foo { fn foo(&self, bar: Bar<u32>::Assoc); }\n+    pub trait Foo { fn foo(&self, bar: Bar<u32>::Assoc); }\n }\n struct S;\n impl foo::Foo for S { $0 }\"#,\n             r#\"\n mod foo {\n     pub struct Bar<T>;\n     impl Bar<T> { type Assoc = u32; }\n-    trait Foo { fn foo(&self, bar: Bar<u32>::Assoc); }\n+    pub trait Foo { fn foo(&self, bar: Bar<u32>::Assoc); }\n }\n struct S;\n impl foo::Foo for S {\n@@ -545,15 +547,15 @@ impl foo::Foo for S {\n mod foo {\n     pub struct Bar<T>;\n     pub struct Baz;\n-    trait Foo { fn foo(&self, bar: Bar<Baz>); }\n+    pub trait Foo { fn foo(&self, bar: Bar<Baz>); }\n }\n struct S;\n impl foo::Foo for S { $0 }\"#,\n             r#\"\n mod foo {\n     pub struct Bar<T>;\n     pub struct Baz;\n-    trait Foo { fn foo(&self, bar: Bar<Baz>); }\n+    pub trait Foo { fn foo(&self, bar: Bar<Baz>); }\n }\n struct S;\n impl foo::Foo for S {\n@@ -571,14 +573,14 @@ impl foo::Foo for S {\n             r#\"\n mod foo {\n     pub trait Fn<Args> { type Output; }\n-    trait Foo { fn foo(&self, bar: dyn Fn(u32) -> i32); }\n+    pub trait Foo { fn foo(&self, bar: dyn Fn(u32) -> i32); }\n }\n struct S;\n impl foo::Foo for S { $0 }\"#,\n             r#\"\n mod foo {\n     pub trait Fn<Args> { type Output; }\n-    trait Foo { fn foo(&self, bar: dyn Fn(u32) -> i32); }\n+    pub trait Foo { fn foo(&self, bar: dyn Fn(u32) -> i32); }\n }\n struct S;\n impl foo::Foo for S {\n@@ -658,6 +660,7 @@ trait Foo {\n     type Output;\n \n     const CONST: usize = 42;\n+    const CONST_2: i32;\n \n     fn valid(some: u32) -> bool { false }\n     fn foo(some: u32) -> bool;\n@@ -669,13 +672,16 @@ trait Foo {\n     type Output;\n \n     const CONST: usize = 42;\n+    const CONST_2: i32;\n \n     fn valid(some: u32) -> bool { false }\n     fn foo(some: u32) -> bool;\n }\n struct S;\n impl Foo for S {\n-    $0fn valid(some: u32) -> bool { false }\n+    $0const CONST: usize = 42;\n+\n+    fn valid(some: u32) -> bool { false }\n }\"#,\n         )\n     }"}, {"sha": "c1e2f19ab18b2502989555158aaff00a9e63554d", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 266, "deletions": 4, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -109,8 +109,6 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n             let params =\n                 body.extracted_function_params(ctx, &container_info, locals_used.iter().copied());\n \n-            let extracted_from_trait_impl = body.extracted_from_trait_impl();\n-\n             let name = make_function_name(&semantics_scope);\n \n             let fun = Function {\n@@ -129,8 +127,11 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n \n             builder.replace(target_range, make_call(ctx, &fun, old_indent));\n \n+            let has_impl_wrapper =\n+                insert_after.ancestors().any(|a| a.kind() == SyntaxKind::IMPL && a != insert_after);\n+\n             let fn_def = match fun.self_param_adt(ctx) {\n-                Some(adt) if extracted_from_trait_impl => {\n+                Some(adt) if anchor == Anchor::Method && !has_impl_wrapper => {\n                     let fn_def = format_function(ctx, module, &fun, old_indent, new_indent + 1);\n                     generate_impl_text(&adt, &fn_def).replace(\"{\\n\\n\", \"{\")\n                 }\n@@ -272,7 +273,7 @@ enum FunType {\n }\n \n /// Where to put extracted function definition\n-#[derive(Debug)]\n+#[derive(Debug, Eq, PartialEq, Clone, Copy)]\n enum Anchor {\n     /// Extract free function and put right after current top-level function\n     Freestanding,\n@@ -1245,6 +1246,14 @@ fn node_to_insert_after(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNod\n     while let Some(next_ancestor) = ancestors.next() {\n         match next_ancestor.kind() {\n             SyntaxKind::SOURCE_FILE => break,\n+            SyntaxKind::IMPL => {\n+                if body.extracted_from_trait_impl() && matches!(anchor, Anchor::Method) {\n+                    let impl_node = find_non_trait_impl(&next_ancestor);\n+                    if let target_node @ Some(_) = impl_node.as_ref().and_then(last_impl_member) {\n+                        return target_node;\n+                    }\n+                }\n+            }\n             SyntaxKind::ITEM_LIST if !matches!(anchor, Anchor::Freestanding) => continue,\n             SyntaxKind::ITEM_LIST => {\n                 if ancestors.peek().map(SyntaxNode::kind) == Some(SyntaxKind::MODULE) {\n@@ -1265,6 +1274,29 @@ fn node_to_insert_after(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNod\n     last_ancestor\n }\n \n+fn find_non_trait_impl(trait_impl: &SyntaxNode) -> Option<ast::Impl> {\n+    let as_impl = ast::Impl::cast(trait_impl.clone())?;\n+    let impl_type = Some(impl_type_name(&as_impl)?);\n+\n+    let sibblings = trait_impl.parent()?.children();\n+    sibblings\n+        .filter_map(ast::Impl::cast)\n+        .find(|s| impl_type_name(s) == impl_type && !is_trait_impl(s))\n+}\n+\n+fn last_impl_member(impl_node: &ast::Impl) -> Option<SyntaxNode> {\n+    let last_child = impl_node.assoc_item_list()?.assoc_items().last()?;\n+    Some(last_child.syntax().clone())\n+}\n+\n+fn is_trait_impl(node: &ast::Impl) -> bool {\n+    node.trait_().is_some()\n+}\n+\n+fn impl_type_name(impl_node: &ast::Impl) -> Option<String> {\n+    Some(impl_node.self_ty()?.to_string())\n+}\n+\n fn make_call(ctx: &AssistContext<'_>, fun: &Function, indent: IndentLevel) -> String {\n     let ret_ty = fun.return_type(ctx);\n \n@@ -5051,6 +5083,236 @@ impl Struct {\n         );\n     }\n \n+    #[test]\n+    fn extract_method_from_trait_with_existing_non_empty_impl_block() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        $0self.0 + 2$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+\n+    fn $0fun_name(&self) -> i32 {\n+        self.0 + 2\n+    }\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        self.fun_name()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_function_from_trait_with_existing_non_empty_impl_block() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        let three_squared = $03 * 3$0;\n+        self.0 + three_squared\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        let three_squared = fun_name();\n+        self.0 + three_squared\n+    }\n+}\n+\n+fn $0fun_name() -> i32 {\n+    3 * 3\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_method_from_trait_with_multiple_existing_impl_blocks() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+struct StructBefore(i32);\n+struct StructAfter(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl StructBefore {\n+    fn foo(){}\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+}\n+\n+impl StructAfter {\n+    fn foo(){}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        $0self.0 + 2$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+struct StructBefore(i32);\n+struct StructAfter(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl StructBefore {\n+    fn foo(){}\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+\n+    fn $0fun_name(&self) -> i32 {\n+        self.0 + 2\n+    }\n+}\n+\n+impl StructAfter {\n+    fn foo(){}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        self.fun_name()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_method_from_trait_with_multiple_existing_trait_impl_blocks() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+trait TraitBefore {\n+    fn before(&self) -> i32;\n+}\n+trait TraitAfter {\n+    fn after(&self) -> i32;\n+}\n+\n+impl TraitBefore for Struct {\n+    fn before(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+}\n+\n+impl TraitAfter for Struct {\n+    fn after(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        $0self.0 + 2$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+trait TraitBefore {\n+    fn before(&self) -> i32;\n+}\n+trait TraitAfter {\n+    fn after(&self) -> i32;\n+}\n+\n+impl TraitBefore for Struct {\n+    fn before(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+\n+    fn $0fun_name(&self) -> i32 {\n+        self.0 + 2\n+    }\n+}\n+\n+impl TraitAfter for Struct {\n+    fn after(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        self.fun_name()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn closure_arguments() {\n         check_assist("}, {"sha": "d9e00435ecf5d73e14c0fefbc4e3f62cd7af1eb1", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/fix_visibility.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::HirDatabase, HasSource, HasVisibility, PathResolution};\n+use hir::{db::HirDatabase, HasSource, HasVisibility, ModuleDef, PathResolution, ScopeDef};\n use ide_db::base_db::FileId;\n use syntax::{\n     ast::{self, HasVisibility as _},\n@@ -18,7 +18,7 @@ use crate::{utils::vis_offset, AssistContext, AssistId, AssistKind, Assists};\n //     fn frobnicate() {}\n // }\n // fn main() {\n-//     m::frobnicate$0() {}\n+//     m::frobnicate$0();\n // }\n // ```\n // ->\n@@ -27,7 +27,7 @@ use crate::{utils::vis_offset, AssistContext, AssistId, AssistKind, Assists};\n //     $0pub(crate) fn frobnicate() {}\n // }\n // fn main() {\n-//     m::frobnicate() {}\n+//     m::frobnicate();\n // }\n // ```\n pub(crate) fn fix_visibility(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n@@ -37,11 +37,15 @@ pub(crate) fn fix_visibility(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n \n fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let path: ast::Path = ctx.find_node_at_offset()?;\n-    let path_res = ctx.sema.resolve_path(&path)?;\n-    let def = match path_res {\n-        PathResolution::Def(def) => def,\n-        _ => return None,\n-    };\n+    let qualifier = path.qualifier()?;\n+    let name_ref = path.segment()?.name_ref()?;\n+    let qualifier_res = ctx.sema.resolve_path(&qualifier)?;\n+    let PathResolution::Def(ModuleDef::Module(module)) = qualifier_res else { return None; };\n+    let (_, def) = module\n+        .scope(ctx.db(), None)\n+        .into_iter()\n+        .find(|(name, _)| name.to_smol_str() == name_ref.text().as_str())?;\n+    let ScopeDef::ModuleDef(def) = def else { return None; };\n \n     let current_module = ctx.sema.scope(path.syntax())?.module();\n     let target_module = def.module(ctx.db())?;"}, {"sha": "0bcb5728311b73db3f6c757a34864c6ee3ac2cc8", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_enum_variant.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -261,12 +261,12 @@ fn main() {\n }\n \n //- /foo.rs\n-enum Foo {\n+pub enum Foo {\n     Bar,\n }\n \",\n             r\"\n-enum Foo {\n+pub enum Foo {\n     Bar,\n     Baz,\n }\n@@ -310,7 +310,7 @@ fn main() {\n             generate_enum_variant,\n             r\"\n mod m {\n-    enum Foo {\n+    pub enum Foo {\n         Bar,\n     }\n }\n@@ -320,7 +320,7 @@ fn main() {\n \",\n             r\"\n mod m {\n-    enum Foo {\n+    pub enum Foo {\n         Bar,\n         Baz,\n     }\n@@ -516,10 +516,10 @@ mod foo;\n use foo::Foo::Bar$0;\n \n //- /foo.rs\n-enum Foo {}\n+pub enum Foo {}\n \",\n             r\"\n-enum Foo {\n+pub enum Foo {\n     Bar,\n }\n \","}, {"sha": "57f198748cb76ef9a285b538a2b09a6071f8db67", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1324,7 +1324,7 @@ fn foo() {\n             generate_function,\n             r\"\n mod bar {\n-    mod baz {}\n+    pub mod baz {}\n }\n \n fn foo() {\n@@ -1333,7 +1333,7 @@ fn foo() {\n \",\n             r\"\n mod bar {\n-    mod baz {\n+    pub mod baz {\n         pub(crate) fn my_fn() {\n             ${0:todo!()}\n         }"}, {"sha": "11db6ae7f7b811825d59fd8b08c6e872c179195a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_format_string_arg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -92,7 +92,7 @@ pub(crate) fn move_format_string_arg(acc: &mut Assists, ctx: &AssistContext<'_>)\n                         NodeOrToken::Node(n) => {\n                             format_to!(current_arg, \"{n}\");\n                         },\n-                        NodeOrToken::Token(t) if t.kind() == COMMA=> {\n+                        NodeOrToken::Token(t) if t.kind() == COMMA => {\n                             existing_args.push(current_arg.trim().into());\n                             current_arg.clear();\n                         },\n@@ -238,14 +238,14 @@ fn main() {\n             &add_macro_decl(\n                 r#\"\n fn main() {\n-    print!(\"{} {x + 1:b} {Struct(1, 2)}$0\", 1);\n+    print!(\"{:b} {x + 1:b} {Struct(1, 2)}$0\", 1);\n }\n \"#,\n             ),\n             &add_macro_decl(\n                 r#\"\n fn main() {\n-    print!(\"{} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n+    print!(\"{:b} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n }\n \"#,\n             ),"}, {"sha": "99ae60e07bcfa7283e274fbdcd5d91743052c4c2", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 56, "deletions": 7, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1,7 +1,7 @@\n use itertools::Itertools;\n use syntax::{\n     ast::{self, AstNode, AstToken},\n-    match_ast, NodeOrToken, SyntaxElement, TextSize, T,\n+    match_ast, NodeOrToken, SyntaxElement, TextRange, TextSize, T,\n };\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -22,7 +22,36 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // }\n // ```\n pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    let macro_call = ctx.find_node_at_offset::<ast::MacroCall>()?;\n+    let macro_calls = if ctx.has_empty_selection() {\n+        vec![ctx.find_node_at_offset::<ast::MacroCall>()?]\n+    } else {\n+        ctx.covering_element()\n+            .as_node()?\n+            .descendants()\n+            .filter(|node| ctx.selection_trimmed().contains_range(node.text_range()))\n+            .filter_map(ast::MacroCall::cast)\n+            .collect()\n+    };\n+\n+    let replacements =\n+        macro_calls.into_iter().filter_map(compute_dbg_replacement).collect::<Vec<_>>();\n+    if replacements.is_empty() {\n+        return None;\n+    }\n+\n+    acc.add(\n+        AssistId(\"remove_dbg\", AssistKind::Refactor),\n+        \"Remove dbg!()\",\n+        ctx.selection_trimmed(),\n+        |builder| {\n+            for (range, text) in replacements {\n+                builder.replace(range, text);\n+            }\n+        },\n+    )\n+}\n+\n+fn compute_dbg_replacement(macro_call: ast::MacroCall) -> Option<(TextRange, String)> {\n     let tt = macro_call.token_tree()?;\n     let r_delim = NodeOrToken::Token(tt.right_delimiter_token()?);\n     if macro_call.path()?.segment()?.name_ref()?.text() != \"dbg\"\n@@ -41,7 +70,7 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<(\n \n     let macro_expr = ast::MacroExpr::cast(macro_call.syntax().parent()?)?;\n     let parent = macro_expr.syntax().parent()?;\n-    let (range, text) = match &*input_expressions {\n+    Some(match &*input_expressions {\n         // dbg!()\n         [] => {\n             match_ast! {\n@@ -107,10 +136,6 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<(\n         }\n         // dbg!(expr0, expr1, ...)\n         exprs => (macro_call.syntax().text_range(), format!(\"({})\", exprs.iter().format(\", \"))),\n-    };\n-\n-    acc.add(AssistId(\"remove_dbg\", AssistKind::Refactor), \"Remove dbg!()\", range, |builder| {\n-        builder.replace(range, text);\n     })\n }\n \n@@ -238,4 +263,28 @@ fn foo() {\n         check(r#\"$0dbg!(0, 1)\"#, r#\"(0, 1)\"#);\n         check(r#\"$0dbg!(0, (1, 2))\"#, r#\"(0, (1, 2))\"#);\n     }\n+\n+    #[test]\n+    fn test_range() {\n+        check(\n+            r#\"\n+fn f() {\n+    dbg!(0) + $0dbg!(1);\n+    dbg!(())$0\n+}\n+\"#,\n+            r#\"\n+fn f() {\n+    dbg!(0) + 1;\n+    ()\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_range_partial() {\n+        check_assist_not_applicable(remove_dbg, r#\"$0dbg$0!(0)\"#);\n+        check_assist_not_applicable(remove_dbg, r#\"$0dbg!(0$0)\"#);\n+    }\n }"}, {"sha": "6fa15b28e4efcfac2b42fba2fc938b9c920b69c8", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1019,8 +1019,6 @@ struct Foo {\n impl foo::Bar for Foo {\n     $0type Qux;\n \n-    const Baz: usize = 42;\n-\n     const Fez: usize;\n \n     fn foo() {"}, {"sha": "c09317572acf2b8fb935fd8e8f7ff6d72f4fe0ee", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -741,15 +741,15 @@ mod m {\n     fn frobnicate() {}\n }\n fn main() {\n-    m::frobnicate$0() {}\n+    m::frobnicate$0();\n }\n \"#####,\n         r#####\"\n mod m {\n     $0pub(crate) fn frobnicate() {}\n }\n fn main() {\n-    m::frobnicate() {}\n+    m::frobnicate();\n }\n \"#####,\n     )"}, {"sha": "68c31b4f8e92285586f14ebe4f3caf119170790b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/utils.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -119,6 +119,10 @@ pub fn filter_assoc_items(\n                 (default_methods, def.body()),\n                 (DefaultMethods::Only, Some(_)) | (DefaultMethods::No, None)\n             ),\n+            ast::AssocItem::Const(def) => matches!(\n+                (default_methods, def.body()),\n+                (DefaultMethods::Only, Some(_)) | (DefaultMethods::No, None)\n+            ),\n             _ => default_methods == DefaultMethods::No,\n         })\n         .collect::<Vec<_>>()"}, {"sha": "11310e2f1291e63b3e40681720b608aacee7ae38", "filename": "src/tools/rust-analyzer/crates/ide-completion/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "7384a3f2d80b4141cec4fdc2f0bb7799bc20e738", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 139, "deletions": 20, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -157,7 +157,7 @@ fn complete_trait_impl(\n                     add_function_impl(acc, ctx, replacement_range, func, hir_impl)\n                 }\n                 (hir::AssocItem::TypeAlias(type_alias), All | TypeAlias) => {\n-                    add_type_alias_impl(acc, ctx, replacement_range, type_alias)\n+                    add_type_alias_impl(acc, ctx, replacement_range, type_alias, hir_impl)\n                 }\n                 (hir::AssocItem::Const(const_), All | Const) => {\n                     add_const_impl(acc, ctx, replacement_range, const_, hir_impl)\n@@ -236,9 +236,7 @@ fn get_transformed_assoc_item(\n     );\n \n     transform.apply(assoc_item.syntax());\n-    if let ast::AssocItem::Fn(func) = &assoc_item {\n-        func.remove_attrs_and_docs();\n-    }\n+    assoc_item.remove_attrs_and_docs();\n     Some(assoc_item)\n }\n \n@@ -247,24 +245,50 @@ fn add_type_alias_impl(\n     ctx: &CompletionContext<'_>,\n     replacement_range: TextRange,\n     type_alias: hir::TypeAlias,\n+    impl_def: hir::Impl,\n ) {\n-    let alias_name = type_alias.name(ctx.db);\n-    let (alias_name, escaped_name) =\n-        (alias_name.unescaped().to_smol_str(), alias_name.to_smol_str());\n+    let alias_name = type_alias.name(ctx.db).unescaped().to_smol_str();\n \n     let label = format!(\"type {} =\", alias_name);\n-    let replacement = format!(\"type {} = \", escaped_name);\n \n     let mut item = CompletionItem::new(SymbolKind::TypeAlias, replacement_range, label);\n     item.lookup_by(format!(\"type {}\", alias_name))\n         .set_documentation(type_alias.docs(ctx.db))\n         .set_relevance(CompletionRelevance { is_item_from_trait: true, ..Default::default() });\n-    match ctx.config.snippet_cap {\n-        Some(cap) => item\n-            .snippet_edit(cap, TextEdit::replace(replacement_range, format!(\"{}$0;\", replacement))),\n-        None => item.text_edit(TextEdit::replace(replacement_range, replacement)),\n-    };\n-    item.add_to(acc);\n+\n+    if let Some(source) = ctx.sema.source(type_alias) {\n+        let assoc_item = ast::AssocItem::TypeAlias(source.value);\n+        if let Some(transformed_item) = get_transformed_assoc_item(ctx, assoc_item, impl_def) {\n+            let transformed_ty = match transformed_item {\n+                ast::AssocItem::TypeAlias(ty) => ty,\n+                _ => unreachable!(),\n+            };\n+\n+            let start = transformed_ty.syntax().text_range().start();\n+            let Some(end) = transformed_ty\n+                .eq_token()\n+                .map(|tok| tok.text_range().start())\n+                .or(transformed_ty.semicolon_token().map(|tok| tok.text_range().start())) else { return };\n+\n+            let len = end - start;\n+            let mut decl = transformed_ty.syntax().text().slice(..len).to_string();\n+            if !decl.ends_with(' ') {\n+                decl.push(' ');\n+            }\n+            decl.push_str(\"= \");\n+\n+            match ctx.config.snippet_cap {\n+                Some(cap) => {\n+                    let snippet = format!(\"{}$0;\", decl);\n+                    item.snippet_edit(cap, TextEdit::replace(replacement_range, snippet));\n+                }\n+                None => {\n+                    item.text_edit(TextEdit::replace(replacement_range, decl));\n+                }\n+            };\n+            item.add_to(acc);\n+        }\n+    }\n }\n \n fn add_const_impl(\n@@ -309,7 +333,6 @@ fn add_const_impl(\n }\n \n fn make_const_compl_syntax(const_: &ast::Const, needs_whitespace: bool) -> String {\n-    const_.remove_attrs_and_docs();\n     let const_ = if needs_whitespace {\n         insert_whitespace_into_node::insert_ws_into(const_.syntax().clone())\n     } else {\n@@ -333,8 +356,6 @@ fn make_const_compl_syntax(const_: &ast::Const, needs_whitespace: bool) -> Strin\n }\n \n fn function_declaration(node: &ast::Fn, needs_whitespace: bool) -> String {\n-    node.remove_attrs_and_docs();\n-\n     let node = if needs_whitespace {\n         insert_whitespace_into_node::insert_ws_into(node.syntax().clone())\n     } else {\n@@ -350,9 +371,7 @@ fn function_declaration(node: &ast::Fn, needs_whitespace: bool) -> String {\n         .map_or(end, |f| f.text_range().start());\n \n     let len = end - start;\n-    let range = TextRange::new(0.into(), len);\n-\n-    let syntax = node.text().slice(range).to_string();\n+    let syntax = node.text().slice(..len).to_string();\n \n     syntax.trim_end().to_owned()\n }\n@@ -1160,6 +1179,106 @@ impl Foo for Test {\n     $0\n }\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn includes_gat_generics() {\n+        check_edit(\n+            \"type Ty\",\n+            r#\"\n+trait Tr<'b> {\n+    type Ty<'a: 'b, T: Copy, const C: usize>;\n+}\n+\n+impl<'b> Tr<'b> for () {\n+    $0\n+}\n+\"#,\n+            r#\"\n+trait Tr<'b> {\n+    type Ty<'a: 'b, T: Copy, const C: usize>;\n+}\n+\n+impl<'b> Tr<'b> for () {\n+    type Ty<'a: 'b, T: Copy, const C: usize> = $0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn strips_comments() {\n+        check_edit(\n+            \"fn func\",\n+            r#\"\n+trait Tr {\n+    /// docs\n+    #[attr]\n+    fn func();\n+}\n+impl Tr for () {\n+    $0\n+}\n+\"#,\n+            r#\"\n+trait Tr {\n+    /// docs\n+    #[attr]\n+    fn func();\n+}\n+impl Tr for () {\n+    fn func() {\n+    $0\n+}\n+}\n+\"#,\n+        );\n+        check_edit(\n+            \"const C\",\n+            r#\"\n+trait Tr {\n+    /// docs\n+    #[attr]\n+    const C: usize;\n+}\n+impl Tr for () {\n+    $0\n+}\n+\"#,\n+            r#\"\n+trait Tr {\n+    /// docs\n+    #[attr]\n+    const C: usize;\n+}\n+impl Tr for () {\n+    const C: usize = $0;\n+}\n+\"#,\n+        );\n+        check_edit(\n+            \"type Item\",\n+            r#\"\n+trait Tr {\n+    /// docs\n+    #[attr]\n+    type Item;\n+}\n+impl Tr for () {\n+    $0\n+}\n+\"#,\n+            r#\"\n+trait Tr {\n+    /// docs\n+    #[attr]\n+    type Item;\n+}\n+impl Tr for () {\n+    type Item = $0;\n+}\n \"#,\n         );\n     }"}, {"sha": "c142a7305f9e94ac6e68ae2d02be21d36ffb5c3a", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -681,9 +681,13 @@ fn classify_name_ref(\n                     ast::Item::ExternBlock(it) => it.extern_item_list().is_none(),\n                     ast::Item::Fn(it) => it.body().is_none(),\n                     ast::Item::Impl(it) => it.assoc_item_list().is_none(),\n-                    ast::Item::Module(it) => it.item_list().is_none(),\n+                    ast::Item::Module(it) => {\n+                        it.item_list().is_none() && it.semicolon_token().is_none()\n+                    }\n                     ast::Item::Static(it) => it.body().is_none(),\n-                    ast::Item::Struct(it) => it.field_list().is_none(),\n+                    ast::Item::Struct(it) => {\n+                        it.field_list().is_none() && it.semicolon_token().is_none()\n+                    }\n                     ast::Item::Trait(it) => it.assoc_item_list().is_none(),\n                     ast::Item::TypeAlias(it) => it.ty().is_none(),\n                     ast::Item::Union(it) => it.record_field_list().is_none(),"}, {"sha": "8ed6cb3cf867ef851c417b4c3316189327b90c88", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/item_list.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -245,3 +245,35 @@ impl Test for () {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn after_unit_struct() {\n+    check(\n+        r#\"struct S; f$0\"#,\n+        expect![[r#\"\n+            ma makro!(\u2026)           macro_rules! makro\n+            md module\n+            kw const\n+            kw crate::\n+            kw enum\n+            kw extern\n+            kw fn\n+            kw impl\n+            kw mod\n+            kw pub\n+            kw pub(crate)\n+            kw pub(super)\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            sn macro_rules\n+            sn tfn (Test function)\n+            sn tmod (Test module)\n+        \"#]],\n+    );\n+}"}, {"sha": "f48cce58c6e7386a68cbe7f341aa6027992bc8f5", "filename": "src/tools/rust-analyzer/crates/ide-db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "1b8f56187a02bf78f214fc0dacb7087ba16fc45d", "filename": "src/tools/rust-analyzer/crates/ide-db/src/line_index.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -58,8 +58,11 @@ impl LineIndex {\n         let mut utf16_lines = NoHashHashMap::default();\n         let mut utf16_chars = Vec::new();\n \n-        let mut newlines = vec![0.into()];\n-        let mut curr_row @ mut curr_col = 0.into();\n+        let mut newlines = Vec::with_capacity(16);\n+        newlines.push(TextSize::from(0));\n+\n+        let mut curr_row = 0.into();\n+        let mut curr_col = 0.into();\n         let mut line = 0;\n         for c in text.chars() {\n             let c_len = TextSize::of(c);"}, {"sha": "313346ee131539b9210714159d0164b5b464e8c2", "filename": "src/tools/rust-analyzer/crates/ide-db/src/syntax_helpers/format_string_exprs.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -104,6 +104,11 @@ pub fn parse_format_exprs(input: &str) -> Result<(String, Vec<Arg>), ()> {\n                 extracted_expressions.push(Arg::Placeholder);\n                 state = State::NotArg;\n             }\n+            (State::MaybeArg, ':') => {\n+                output.push(chr);\n+                extracted_expressions.push(Arg::Placeholder);\n+                state = State::FormatOpts;\n+            }\n             (State::MaybeArg, _) => {\n                 if matches!(chr, '\\\\' | '$') {\n                     current_expr.push('\\\\');\n@@ -118,44 +123,41 @@ pub fn parse_format_exprs(input: &str) -> Result<(String, Vec<Arg>), ()> {\n                     state = State::Expr;\n                 }\n             }\n-            (State::Ident | State::Expr, '}') => {\n-                if inexpr_open_count == 0 {\n-                    output.push(chr);\n-\n-                    if matches!(state, State::Expr) {\n-                        extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n-                    } else {\n-                        extracted_expressions.push(Arg::Ident(current_expr.trim().into()));\n-                    }\n-\n-                    current_expr = String::new();\n-                    state = State::NotArg;\n-                } else {\n-                    // We're closing one brace met before inside of the expression.\n-                    current_expr.push(chr);\n-                    inexpr_open_count -= 1;\n-                }\n-            }\n             (State::Ident | State::Expr, ':') if matches!(chars.peek(), Some(':')) => {\n                 // path separator\n                 state = State::Expr;\n                 current_expr.push_str(\"::\");\n                 chars.next();\n             }\n-            (State::Ident | State::Expr, ':') => {\n+            (State::Ident | State::Expr, ':' | '}') => {\n                 if inexpr_open_count == 0 {\n-                    // We're outside of braces, thus assume that it's a specifier, like \"{Some(value):?}\"\n-                    output.push(chr);\n+                    let trimmed = current_expr.trim();\n \n-                    if matches!(state, State::Expr) {\n-                        extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n+                    // if the expression consists of a single number, like \"0\" or \"12\", it can refer to\n+                    // format args in the order they are specified.\n+                    // see: https://doc.rust-lang.org/std/fmt/#positional-parameters\n+                    if trimmed.chars().fold(true, |only_num, c| c.is_ascii_digit() && only_num) {\n+                        output.push_str(trimmed);\n+                    } else if matches!(state, State::Expr) {\n+                        extracted_expressions.push(Arg::Expr(trimmed.into()));\n                     } else {\n-                        extracted_expressions.push(Arg::Ident(current_expr.trim().into()));\n+                        extracted_expressions.push(Arg::Ident(trimmed.into()));\n                     }\n \n-                    current_expr = String::new();\n-                    state = State::FormatOpts;\n-                } else {\n+                    output.push(chr);\n+                    current_expr.clear();\n+                    state = if chr == ':' {\n+                        State::FormatOpts\n+                    } else if chr == '}' {\n+                        State::NotArg\n+                    } else {\n+                        unreachable!()\n+                    };\n+                } else if chr == '}' {\n+                    // We're closing one brace met before inside of the expression.\n+                    current_expr.push(chr);\n+                    inexpr_open_count -= 1;\n+                } else if chr == ':' {\n                     // We're inside of braced expression, assume that it's a struct field name/value delimiter.\n                     current_expr.push(chr);\n                 }\n@@ -219,6 +221,10 @@ mod tests {\n             (\"{expr} is {2 + 2}\", expect![[\"{} is {}; expr, 2 + 2\"]]),\n             (\"{expr:?}\", expect![[\"{:?}; expr\"]]),\n             (\"{expr:1$}\", expect![[r\"{:1\\$}; expr\"]]),\n+            (\"{:1$}\", expect![[r\"{:1\\$}; $1\"]]),\n+            (\"{:>padding$}\", expect![[r\"{:>padding\\$}; $1\"]]),\n+            (\"{}, {}, {0}\", expect![[r\"{}, {}, {0}; $1, $2\"]]),\n+            (\"{}, {}, {0:b}\", expect![[r\"{}, {}, {0:b}; $1, $2\"]]),\n             (\"{$0}\", expect![[r\"{}; \\$0\"]]),\n             (\"{malformed\", expect![[\"-\"]]),\n             (\"malformed}\", expect![[\"-\"]]),"}, {"sha": "7e9a1125d751c9525010ca062d57b450489ba9d5", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "870c78d1f1eb729277df8d71da89ecab3e675f48", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/macro_error.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -5,10 +5,7 @@ use crate::{Diagnostic, DiagnosticsContext};\n // This diagnostic is shown for macro expansion errors.\n pub(crate) fn macro_error(ctx: &DiagnosticsContext<'_>, d: &hir::MacroError) -> Diagnostic {\n     // Use more accurate position if available.\n-    let display_range = d\n-        .precise_location\n-        .unwrap_or_else(|| ctx.sema.diagnostics_display_range(d.node.clone()).range);\n-\n+    let display_range = ctx.resolve_precise_location(&d.node, d.precise_location);\n     Diagnostic::new(\"macro-error\", d.message.clone(), display_range).experimental()\n }\n "}, {"sha": "d8f2a9de9818fca43f638f6e8e8031abc9887d78", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/no_such_field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -268,12 +268,12 @@ fn main() {\n     foo::Foo { bar: 3, $0baz: false};\n }\n //- /foo.rs\n-struct Foo {\n+pub struct Foo {\n     bar: i32\n }\n \"#,\n             r#\"\n-struct Foo {\n+pub struct Foo {\n     bar: i32,\n     pub(crate) baz: bool\n }"}, {"sha": "87531f4acfb753b0feb68c58caf76b3518bc6c5d", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unresolved_macro_call.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -9,10 +9,7 @@ pub(crate) fn unresolved_macro_call(\n     d: &hir::UnresolvedMacroCall,\n ) -> Diagnostic {\n     // Use more accurate position if available.\n-    let display_range = d\n-        .precise_location\n-        .unwrap_or_else(|| ctx.sema.diagnostics_display_range(d.macro_call.clone()).range);\n-\n+    let display_range = ctx.resolve_precise_location(&d.macro_call, d.precise_location);\n     let bang = if d.is_bang { \"!\" } else { \"\" };\n     Diagnostic::new(\n         \"unresolved-macro-call\","}, {"sha": "23818d883f73181d7c684523d21637cda93b1085", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unresolved_proc_macro.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1,5 +1,4 @@\n use hir::db::DefDatabase;\n-use syntax::NodeOrToken;\n \n use crate::{Diagnostic, DiagnosticsContext, Severity};\n \n@@ -19,16 +18,7 @@ pub(crate) fn unresolved_proc_macro(\n     proc_attr_macros_enabled: bool,\n ) -> Diagnostic {\n     // Use more accurate position if available.\n-    let display_range = (|| {\n-        let precise_location = d.precise_location?;\n-        let root = ctx.sema.parse_or_expand(d.node.file_id)?;\n-        match root.covering_element(precise_location) {\n-            NodeOrToken::Node(it) => Some(ctx.sema.original_range(&it)),\n-            NodeOrToken::Token(it) => d.node.with_value(it).original_file_range_opt(ctx.sema.db),\n-        }\n-    })()\n-    .unwrap_or_else(|| ctx.sema.diagnostics_display_range(d.node.clone()))\n-    .range;\n+    let display_range = ctx.resolve_precise_location(&d.node, d.precise_location);\n \n     let config_enabled = match d.kind {\n         hir::MacroKind::Attr => proc_macros_enabled && proc_attr_macros_enabled,"}, {"sha": "289ed0458c67dbc4aea2f677dc9e5a88037e91eb", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/useless_braces.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fuseless_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fuseless_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fuseless_braces.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -71,9 +71,9 @@ use a;\n use a::{c, d::e};\n \n mod a {\n-    mod c {}\n-    mod d {\n-        mod e {}\n+    pub mod c {}\n+    pub mod d {\n+        pub mod e {}\n     }\n }\n \"#,\n@@ -87,9 +87,9 @@ use a::{\n };\n \n mod a {\n-    mod c {}\n-    mod d {\n-        mod e {}\n+    pub mod c {}\n+    pub mod d {\n+        pub mod e {}\n     }\n }\n \"#,\n@@ -116,11 +116,11 @@ use b;\n         );\n         check_fix(\n             r#\"\n-mod a { mod c {} }\n+mod a { pub mod c {} }\n use a::{c$0};\n \"#,\n             r#\"\n-mod a { mod c {} }\n+mod a { pub mod c {} }\n use a::c;\n \"#,\n         );\n@@ -136,11 +136,11 @@ use a;\n         );\n         check_fix(\n             r#\"\n-mod a { mod c {} mod d { mod e {} } }\n+mod a { pub mod c {} pub mod d { pub mod e {} } }\n use a::{c, d::{e$0}};\n \"#,\n             r#\"\n-mod a { mod c {} mod d { mod e {} } }\n+mod a { pub mod c {} pub mod d { pub mod e {} } }\n use a::{c, d::e};\n \"#,\n         );"}, {"sha": "d81e36a1f86321428d55f3f99fbb229e7dc0d0a2", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -182,6 +182,28 @@ struct DiagnosticsContext<'a> {\n     resolve: &'a AssistResolveStrategy,\n }\n \n+impl<'a> DiagnosticsContext<'a> {\n+    fn resolve_precise_location(\n+        &self,\n+        node: &InFile<SyntaxNodePtr>,\n+        precise_location: Option<TextRange>,\n+    ) -> TextRange {\n+        let sema = &self.sema;\n+        (|| {\n+            let precise_location = precise_location?;\n+            let root = sema.parse_or_expand(node.file_id)?;\n+            match root.covering_element(precise_location) {\n+                syntax::NodeOrToken::Node(it) => Some(sema.original_range(&it)),\n+                syntax::NodeOrToken::Token(it) => {\n+                    node.with_value(it).original_file_range_opt(sema.db)\n+                }\n+            }\n+        })()\n+        .unwrap_or_else(|| sema.diagnostics_display_range(node.clone()))\n+        .range\n+    }\n+}\n+\n pub fn diagnostics(\n     db: &RootDatabase,\n     config: &DiagnosticsConfig,"}, {"sha": "7be62a8d9ffe905035c530ab3d86ae305e7d4021", "filename": "src/tools/rust-analyzer/crates/ide-ssr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -5,7 +5,7 @@ description = \"Structural search and replace of Rust code\"\n license = \"MIT OR Apache-2.0\"\n repository = \"https://github.com/rust-lang/rust-analyzer\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "73f202630f15b86396d19ae0638ebd140f5ebb5d", "filename": "src/tools/rust-analyzer/crates/ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "43f7a529bc2979168dcef1d96a2daf67aafe1b28", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_definition.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -289,10 +289,10 @@ mod b;\n enum E { X(Foo$0) }\n \n //- /a.rs\n-struct Foo;\n-     //^^^\n+pub struct Foo;\n+         //^^^\n //- /b.rs\n-struct Foo;\n+pub struct Foo;\n \"#,\n         );\n     }"}, {"sha": "838fb18c3d590e273819af63ec7eae6ae5c2ff6b", "filename": "src/tools/rust-analyzer/crates/ide/src/hover.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -119,7 +119,14 @@ pub(crate) fn hover(\n         });\n     }\n \n-    let in_attr = matches!(original_token.parent().and_then(ast::TokenTree::cast), Some(tt) if tt.syntax().ancestors().any(|it| ast::Meta::can_cast(it.kind())));\n+    let in_attr = original_token\n+        .parent_ancestors()\n+        .filter_map(ast::Item::cast)\n+        .any(|item| sema.is_attr_macro_call(&item))\n+        && !matches!(\n+            original_token.parent().and_then(ast::TokenTree::cast),\n+            Some(tt) if tt.syntax().ancestors().any(|it| ast::Meta::can_cast(it.kind()))\n+        );\n     // prefer descending the same token kind in attribute expansions, in normal macros text\n     // equivalency is more important\n     let descended = if in_attr {"}, {"sha": "37384c4e7e07501dffe853c1e31d02309618af41", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 172, "deletions": 71, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1,7 +1,10 @@\n use std::fmt;\n \n use either::Either;\n-use hir::{known, Callable, HasVisibility, HirDisplay, Mutability, Semantics, TypeInfo};\n+use hir::{\n+    known, Adjust, AutoBorrow, Callable, HasVisibility, HirDisplay, Mutability, OverloadedDeref,\n+    PointerCast, Safety, Semantics, TypeInfo,\n+};\n use ide_db::{\n     base_db::FileRange, famous_defs::FamousDefs, syntax_helpers::node_ext::walk_ty, FxHashMap,\n     RootDatabase,\n@@ -22,7 +25,7 @@ pub struct InlayHintsConfig {\n     pub type_hints: bool,\n     pub parameter_hints: bool,\n     pub chaining_hints: bool,\n-    pub reborrow_hints: ReborrowHints,\n+    pub adjustment_hints: AdjustmentHints,\n     pub closure_return_type_hints: ClosureReturnTypeHints,\n     pub binding_mode_hints: bool,\n     pub lifetime_elision_hints: LifetimeElisionHints,\n@@ -48,9 +51,9 @@ pub enum LifetimeElisionHints {\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n-pub enum ReborrowHints {\n+pub enum AdjustmentHints {\n     Always,\n-    MutableOnly,\n+    ReborrowOnly,\n     Never,\n }\n \n@@ -61,7 +64,8 @@ pub enum InlayKind {\n     ClosingBraceHint,\n     ClosureReturnTypeHint,\n     GenericParamListHint,\n-    ImplicitReborrowHint,\n+    AdjustmentHint,\n+    AdjustmentHintClosingParenthesis,\n     LifetimeHint,\n     ParameterHint,\n     TypeHint,\n@@ -115,6 +119,12 @@ impl From<String> for InlayHintLabel {\n     }\n }\n \n+impl From<&str> for InlayHintLabel {\n+    fn from(s: &str) -> Self {\n+        Self { parts: vec![InlayHintLabelPart { text: s.into(), linked_location: None }] }\n+    }\n+}\n+\n impl fmt::Display for InlayHintLabel {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", self.parts.iter().map(|part| &part.text).format(\"\"))\n@@ -180,7 +190,7 @@ impl fmt::Debug for InlayHintLabelPart {\n pub(crate) fn inlay_hints(\n     db: &RootDatabase,\n     file_id: FileId,\n-    range_limit: Option<FileRange>,\n+    range_limit: Option<TextRange>,\n     config: &InlayHintsConfig,\n ) -> Vec<InlayHint> {\n     let _p = profile::span(\"inlay_hints\");\n@@ -195,7 +205,7 @@ pub(crate) fn inlay_hints(\n \n         let hints = |node| hints(&mut acc, &famous_defs, config, file_id, node);\n         match range_limit {\n-            Some(FileRange { range, .. }) => match file.covering_element(range) {\n+            Some(range) => match file.covering_element(range) {\n                 NodeOrToken::Token(_) => return acc,\n                 NodeOrToken::Node(n) => n\n                     .descendants()\n@@ -221,6 +231,7 @@ fn hints(\n         match node {\n             ast::Expr(expr) => {\n                 chaining_hints(hints, sema, &famous_defs, config, file_id, &expr);\n+                adjustment_hints(hints, sema, config, &expr);\n                 match expr {\n                     ast::Expr::CallExpr(it) => param_name_hints(hints, sema, config, ast::Expr::from(it)),\n                     ast::Expr::MethodCallExpr(it) => {\n@@ -229,7 +240,7 @@ fn hints(\n                     ast::Expr::ClosureExpr(it) => closure_ret_hints(hints, sema, &famous_defs, config, file_id, it),\n                     // We could show reborrows for all expressions, but usually that is just noise to the user\n                     // and the main point here is to show why \"moving\" a mutable reference doesn't necessarily move it\n-                    ast::Expr::PathExpr(_) => reborrow_hints(hints, sema, config, &expr),\n+                    // ast::Expr::PathExpr(_) => reborrow_hints(hints, sema, config, &expr),\n                     _ => None,\n                 }\n             },\n@@ -617,30 +628,95 @@ fn closure_ret_hints(\n     Some(())\n }\n \n-fn reborrow_hints(\n+fn adjustment_hints(\n     acc: &mut Vec<InlayHint>,\n     sema: &Semantics<'_, RootDatabase>,\n     config: &InlayHintsConfig,\n     expr: &ast::Expr,\n ) -> Option<()> {\n-    if config.reborrow_hints == ReborrowHints::Never {\n+    if config.adjustment_hints == AdjustmentHints::Never {\n+        return None;\n+    }\n+\n+    if let ast::Expr::ParenExpr(_) = expr {\n+        // These inherit from the inner expression which would result in duplicate hints\n         return None;\n     }\n \n+    let parent = expr.syntax().parent().and_then(ast::Expr::cast);\n     let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n     let desc_expr = descended.as_ref().unwrap_or(expr);\n-    let mutability = sema.is_implicit_reborrow(desc_expr)?;\n-    let label = match mutability {\n-        hir::Mutability::Shared if config.reborrow_hints != ReborrowHints::MutableOnly => \"&*\",\n-        hir::Mutability::Mut => \"&mut *\",\n-        _ => return None,\n+    let adjustments = sema.expr_adjustments(desc_expr).filter(|it| !it.is_empty())?;\n+    let needs_parens = match parent {\n+        Some(parent) => {\n+            match parent {\n+                ast::Expr::AwaitExpr(_)\n+                | ast::Expr::CallExpr(_)\n+                | ast::Expr::CastExpr(_)\n+                | ast::Expr::FieldExpr(_)\n+                | ast::Expr::MethodCallExpr(_)\n+                | ast::Expr::TryExpr(_) => true,\n+                // FIXME: shorthands need special casing, though not sure if adjustments are even valid there\n+                ast::Expr::RecordExpr(_) => false,\n+                ast::Expr::IndexExpr(index) => index.base().as_ref() == Some(expr),\n+                _ => false,\n+            }\n+        }\n+        None => false,\n     };\n-    acc.push(InlayHint {\n-        range: expr.syntax().text_range(),\n-        kind: InlayKind::ImplicitReborrowHint,\n-        label: label.to_string().into(),\n-        tooltip: Some(InlayTooltip::String(\"Compiler inserted reborrow\".into())),\n-    });\n+    if needs_parens {\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::AdjustmentHint,\n+            label: \"(\".into(),\n+            tooltip: None,\n+        });\n+    }\n+    for adjustment in adjustments.into_iter().rev() {\n+        // FIXME: Add some nicer tooltips to each of these\n+        let text = match adjustment {\n+            Adjust::NeverToAny if config.adjustment_hints == AdjustmentHints::Always => {\n+                \"<never-to-any>\"\n+            }\n+            Adjust::Deref(None) => \"*\",\n+            Adjust::Deref(Some(OverloadedDeref(Mutability::Mut))) => \"*\",\n+            Adjust::Deref(Some(OverloadedDeref(Mutability::Shared))) => \"*\",\n+            Adjust::Borrow(AutoBorrow::Ref(Mutability::Shared)) => \"&\",\n+            Adjust::Borrow(AutoBorrow::Ref(Mutability::Mut)) => \"&mut \",\n+            Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Shared)) => \"&raw const \",\n+            Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Mut)) => \"&raw mut \",\n+            // some of these could be represented via `as` casts, but that's not too nice and\n+            // handling everything as a prefix expr makes the `(` and `)` insertion easier\n+            Adjust::Pointer(cast) if config.adjustment_hints == AdjustmentHints::Always => {\n+                match cast {\n+                    PointerCast::ReifyFnPointer => \"<fn-item-to-fn-pointer>\",\n+                    PointerCast::UnsafeFnPointer => \"<safe-fn-pointer-to-unsafe-fn-pointer>\",\n+                    PointerCast::ClosureFnPointer(Safety::Unsafe) => {\n+                        \"<closure-to-unsafe-fn-pointer>\"\n+                    }\n+                    PointerCast::ClosureFnPointer(Safety::Safe) => \"<closure-to-fn-pointer>\",\n+                    PointerCast::MutToConstPointer => \"<mut-ptr-to-const-ptr>\",\n+                    PointerCast::ArrayToPointer => \"<array-ptr-to-element-ptr>\",\n+                    PointerCast::Unsize => \"<unsize>\",\n+                }\n+            }\n+            _ => continue,\n+        };\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::AdjustmentHint,\n+            label: text.into(),\n+            tooltip: None,\n+        });\n+    }\n+    if needs_parens {\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::AdjustmentHintClosingParenthesis,\n+            label: \")\".into(),\n+            tooltip: None,\n+        });\n+    }\n     Some(())\n }\n \n@@ -1213,12 +1289,11 @@ fn get_callable(\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n-    use ide_db::base_db::FileRange;\n     use itertools::Itertools;\n     use syntax::{TextRange, TextSize};\n     use test_utils::extract_annotations;\n \n-    use crate::inlay_hints::ReborrowHints;\n+    use crate::inlay_hints::AdjustmentHints;\n     use crate::{fixture, inlay_hints::InlayHintsConfig, LifetimeElisionHints};\n \n     use super::ClosureReturnTypeHints;\n@@ -1230,7 +1305,7 @@ mod tests {\n         chaining_hints: false,\n         lifetime_elision_hints: LifetimeElisionHints::Never,\n         closure_return_type_hints: ClosureReturnTypeHints::Never,\n-        reborrow_hints: ReborrowHints::Always,\n+        adjustment_hints: AdjustmentHints::Never,\n         binding_mode_hints: false,\n         hide_named_constructor_hints: false,\n         hide_closure_initialization_hints: false,\n@@ -1242,7 +1317,6 @@ mod tests {\n         type_hints: true,\n         parameter_hints: true,\n         chaining_hints: true,\n-        reborrow_hints: ReborrowHints::Always,\n         closure_return_type_hints: ClosureReturnTypeHints::WithBlock,\n         binding_mode_hints: true,\n         lifetime_elision_hints: LifetimeElisionHints::Always,\n@@ -1838,10 +1912,7 @@ fn main() {\n             .inlay_hints(\n                 &InlayHintsConfig { type_hints: true, ..DISABLED_CONFIG },\n                 file_id,\n-                Some(FileRange {\n-                    file_id,\n-                    range: TextRange::new(TextSize::from(500), TextSize::from(600)),\n-                }),\n+                Some(TextRange::new(TextSize::from(500), TextSize::from(600))),\n             )\n             .unwrap();\n         let actual =\n@@ -2845,48 +2916,6 @@ impl () {\n         );\n     }\n \n-    #[test]\n-    fn hints_implicit_reborrow() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                reborrow_hints: ReborrowHints::Always,\n-                parameter_hints: true,\n-                ..DISABLED_CONFIG\n-            },\n-            r#\"\n-fn __() {\n-    let unique = &mut ();\n-    let r_mov = unique;\n-    let foo: &mut _ = unique;\n-                    //^^^^^^ &mut *\n-    ref_mut_id(unique);\n-             //^^^^^^ mut_ref\n-             //^^^^^^ &mut *\n-    let shared = ref_id(unique);\n-                      //^^^^^^ shared_ref\n-                      //^^^^^^ &*\n-    let mov = shared;\n-    let r_mov: &_ = shared;\n-    ref_id(shared);\n-         //^^^^^^ shared_ref\n-\n-    identity(unique);\n-    identity(shared);\n-}\n-fn identity<T>(t: T) -> T {\n-    t\n-}\n-fn ref_mut_id(mut_ref: &mut ()) -> &mut () {\n-    mut_ref\n-  //^^^^^^^ &mut *\n-}\n-fn ref_id(shared_ref: &()) -> &() {\n-    shared_ref\n-}\n-\"#,\n-        );\n-    }\n-\n     #[test]\n     fn hints_binding_modes() {\n         check_with_config(\n@@ -2994,4 +3023,76 @@ fn f() {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn adjustment_hints() {\n+        check_with_config(\n+            InlayHintsConfig { adjustment_hints: AdjustmentHints::Always, ..DISABLED_CONFIG },\n+            r#\"\n+//- minicore: coerce_unsized\n+fn main() {\n+    let _: u32         = loop {};\n+                       //^^^^^^^<never-to-any>\n+    let _: &u32        = &mut 0;\n+                       //^^^^^^&\n+                       //^^^^^^*\n+    let _: &mut u32    = &mut 0;\n+                       //^^^^^^&mut $\n+                       //^^^^^^*\n+    let _: *const u32  = &mut 0;\n+                       //^^^^^^&raw const $\n+                       //^^^^^^*\n+    let _: *mut u32    = &mut 0;\n+                       //^^^^^^&raw mut $\n+                       //^^^^^^*\n+    let _: fn()        = main;\n+                       //^^^^<fn-item-to-fn-pointer>\n+    let _: unsafe fn() = main;\n+                       //^^^^<safe-fn-pointer-to-unsafe-fn-pointer>\n+                       //^^^^<fn-item-to-fn-pointer>\n+    let _: unsafe fn() = main as fn();\n+                       //^^^^^^^^^^^^<safe-fn-pointer-to-unsafe-fn-pointer>\n+    let _: fn()        = || {};\n+                       //^^^^^<closure-to-fn-pointer>\n+    let _: unsafe fn() = || {};\n+                       //^^^^^<closure-to-unsafe-fn-pointer>\n+    let _: *const u32  = &mut 0u32 as *mut u32;\n+                       //^^^^^^^^^^^^^^^^^^^^^<mut-ptr-to-const-ptr>\n+    let _: &mut [_]    = &mut [0; 0];\n+                       //^^^^^^^^^^^<unsize>\n+                       //^^^^^^^^^^^&mut $\n+                       //^^^^^^^^^^^*\n+\n+    Struct.consume();\n+    Struct.by_ref();\n+  //^^^^^^(\n+  //^^^^^^&\n+  //^^^^^^)\n+    Struct.by_ref_mut();\n+  //^^^^^^(\n+  //^^^^^^&mut $\n+  //^^^^^^)\n+\n+    (&Struct).consume();\n+   //^^^^^^^*\n+    (&Struct).by_ref();\n+\n+    (&mut Struct).consume();\n+   //^^^^^^^^^^^*\n+    (&mut Struct).by_ref();\n+   //^^^^^^^^^^^&\n+   //^^^^^^^^^^^*\n+    (&mut Struct).by_ref_mut();\n+}\n+\n+#[derive(Copy, Clone)]\n+struct Struct;\n+impl Struct {\n+    fn consume(self) {}\n+    fn by_ref(&self) {}\n+    fn by_ref_mut(&mut self) {}\n+}\n+\"#,\n+        )\n+    }\n }"}, {"sha": "7402e86f36fa411c5e6f713a0a1fc8e76030e11c", "filename": "src/tools/rust-analyzer/crates/ide/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -81,8 +81,8 @@ pub use crate::{\n     highlight_related::{HighlightRelatedConfig, HighlightedRange},\n     hover::{HoverAction, HoverConfig, HoverDocFormat, HoverGotoTypeData, HoverResult},\n     inlay_hints::{\n-        ClosureReturnTypeHints, InlayHint, InlayHintLabel, InlayHintsConfig, InlayKind,\n-        InlayTooltip, LifetimeElisionHints, ReborrowHints,\n+        AdjustmentHints, ClosureReturnTypeHints, InlayHint, InlayHintLabel, InlayHintsConfig,\n+        InlayKind, InlayTooltip, LifetimeElisionHints,\n     },\n     join_lines::JoinLinesConfig,\n     markup::Markup,\n@@ -367,7 +367,7 @@ impl Analysis {\n         &self,\n         config: &InlayHintsConfig,\n         file_id: FileId,\n-        range: Option<FileRange>,\n+        range: Option<TextRange>,\n     ) -> Cancellable<Vec<InlayHint>> {\n         self.with_db(|db| inlay_hints::inlay_hints(db, file_id, range, config))\n     }"}, {"sha": "fcbf6d8e58c4b07fd66cda4e0b3f8f49f696bfda", "filename": "src/tools/rust-analyzer/crates/ide/src/moniker.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1,17 +1,17 @@\n //! This module generates [moniker](https://microsoft.github.io/language-server-protocol/specifications/lsif/0.6.0/specification/#exportsImports)\n //! for LSIF and LSP.\n \n-use hir::{db::DefDatabase, AsAssocItem, AssocItemContainer, Crate, Name, Semantics};\n+use hir::{AsAssocItem, AssocItemContainer, Crate, Name, Semantics};\n use ide_db::{\n-    base_db::{CrateOrigin, FileId, FileLoader, FilePosition, LangCrateOrigin},\n+    base_db::{CrateOrigin, FilePosition, LangCrateOrigin},\n     defs::{Definition, IdentClass},\n     helpers::pick_best_token,\n     RootDatabase,\n };\n use itertools::Itertools;\n use syntax::{AstNode, SyntaxKind::*, T};\n \n-use crate::{doc_links::token_as_doc_comment, RangeInfo};\n+use crate::{doc_links::token_as_doc_comment, parent_module::crates_for, RangeInfo};\n \n #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum MonikerDescriptorKind {\n@@ -77,25 +77,13 @@ pub struct PackageInformation {\n     pub version: Option<String>,\n }\n \n-pub(crate) fn crate_for_file(db: &RootDatabase, file_id: FileId) -> Option<Crate> {\n-    for &krate in db.relevant_crates(file_id).iter() {\n-        let crate_def_map = db.crate_def_map(krate);\n-        for (_, data) in crate_def_map.modules() {\n-            if data.origin.file_id() == Some(file_id) {\n-                return Some(krate.into());\n-            }\n-        }\n-    }\n-    None\n-}\n-\n pub(crate) fn moniker(\n     db: &RootDatabase,\n     FilePosition { file_id, offset }: FilePosition,\n ) -> Option<RangeInfo<Vec<MonikerResult>>> {\n     let sema = &Semantics::new(db);\n     let file = sema.parse(file_id).syntax().clone();\n-    let current_crate = crate_for_file(db, file_id)?;\n+    let current_crate: hir::Crate = crates_for(db, file_id).pop()?.into();\n     let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n         IDENT\n         | INT_NUMBER"}, {"sha": "0f758cfa2d344dec2fa3dd2546aa1acae9fb9edf", "filename": "src/tools/rust-analyzer/crates/ide/src/references.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -16,6 +16,7 @@ use ide_db::{\n     search::{ReferenceCategory, SearchScope, UsageSearchResult},\n     RootDatabase,\n };\n+use itertools::Itertools;\n use stdx::hash::NoHashHashMap;\n use syntax::{\n     algo::find_node_at_offset,\n@@ -86,6 +87,7 @@ pub(crate) fn find_all_refs(\n                         file_id,\n                         refs.into_iter()\n                             .map(|file_ref| (file_ref.range, file_ref.category))\n+                            .unique()\n                             .collect(),\n                     )\n                 })"}, {"sha": "e7412d27faf446452a33962d6e70ca5220cc1122", "filename": "src/tools/rust-analyzer/crates/ide/src/signature_help.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1345,5 +1345,36 @@ fn f<F: FnOnce(u8, u16) -> i32>(f: F) {\n                  ^^  ---\n             \"#]],\n         );\n+        check(\n+            r#\"\n+fn f<T, F: FnOnce(&T, u16) -> &T>(f: F) {\n+    f($0)\n+}\n+\"#,\n+            expect![[r#\"\n+                (&T, u16) -> &T\n+                 ^^  ---\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn regression_13579() {\n+        check(\n+            r#\"\n+fn f() {\n+    take(2)($0);\n+}\n+\n+fn take<C, Error>(\n+    count: C\n+) -> impl Fn() -> C  {\n+    move || count\n+}\n+\"#,\n+            expect![[r#\"\n+                () -> i32\n+            \"#]],\n+        );\n     }\n }"}, {"sha": "2380cf7381c1ceb5223fcaeba8a22e837e92717e", "filename": "src/tools/rust-analyzer/crates/ide/src/static_index.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -13,7 +13,8 @@ use syntax::{AstNode, SyntaxKind::*, SyntaxToken, TextRange, T};\n \n use crate::{\n     hover::hover_for_definition,\n-    moniker::{crate_for_file, def_to_moniker, MonikerResult},\n+    moniker::{def_to_moniker, MonikerResult},\n+    parent_module::crates_for,\n     Analysis, Fold, HoverConfig, HoverDocFormat, HoverResult, InlayHint, InlayHintsConfig,\n     TryToNav,\n };\n@@ -99,7 +100,7 @@ fn all_modules(db: &dyn HirDatabase) -> Vec<Module> {\n \n impl StaticIndex<'_> {\n     fn add_file(&mut self, file_id: FileId) {\n-        let current_crate = crate_for_file(self.db, file_id);\n+        let current_crate = crates_for(self.db, file_id).pop().map(Into::into);\n         let folds = self.analysis.folding_ranges(file_id).unwrap();\n         let inlay_hints = self\n             .analysis\n@@ -111,7 +112,7 @@ impl StaticIndex<'_> {\n                     chaining_hints: true,\n                     closure_return_type_hints: crate::ClosureReturnTypeHints::WithBlock,\n                     lifetime_elision_hints: crate::LifetimeElisionHints::Never,\n-                    reborrow_hints: crate::ReborrowHints::Never,\n+                    adjustment_hints: crate::AdjustmentHints::Never,\n                     hide_named_constructor_hints: false,\n                     hide_closure_initialization_hints: false,\n                     param_names_for_lifetime_elision_hints: false,"}, {"sha": "3536f73da73e3be2c144913491e8835a9e593080", "filename": "src/tools/rust-analyzer/crates/limit/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [features]\n tracking = []"}, {"sha": "bce2fc9a70e8271a1471a0d03e88d5baf6f98fd8", "filename": "src/tools/rust-analyzer/crates/mbe/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "cf53c16726bf7fe092c11fe7cf87748f39d2f9b8", "filename": "src/tools/rust-analyzer/crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 62, "deletions": 27, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -12,6 +12,9 @@ use tt::buffer::{Cursor, TokenBuffer};\n \n use crate::{to_parser_input::to_parser_input, tt_iter::TtIter, TokenMap};\n \n+#[cfg(test)]\n+mod tests;\n+\n /// Convert the syntax node to a `TokenTree` (what macro\n /// will consume).\n pub fn syntax_node_to_token_tree(node: &SyntaxNode) -> (tt::Subtree, TokenMap) {\n@@ -35,7 +38,7 @@ pub fn syntax_node_to_token_tree_with_modifications(\n     append: FxHashMap<SyntaxElement, Vec<SyntheticToken>>,\n ) -> (tt::Subtree, TokenMap, u32) {\n     let global_offset = node.text_range().start();\n-    let mut c = Convertor::new(node, global_offset, existing_token_map, next_id, replace, append);\n+    let mut c = Converter::new(node, global_offset, existing_token_map, next_id, replace, append);\n     let subtree = convert_tokens(&mut c);\n     c.id_alloc.map.shrink_to_fit();\n     always!(c.replace.is_empty(), \"replace: {:?}\", c.replace);\n@@ -100,7 +103,7 @@ pub fn parse_to_token_tree(text: &str) -> Option<(tt::Subtree, TokenMap)> {\n         return None;\n     }\n \n-    let mut conv = RawConvertor {\n+    let mut conv = RawConverter {\n         lexed,\n         pos: 0,\n         id_alloc: TokenIdAlloc {\n@@ -148,7 +151,7 @@ pub fn parse_exprs_with_sep(tt: &tt::Subtree, sep: char) -> Vec<tt::Subtree> {\n     res\n }\n \n-fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n+fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n     struct StackEntry {\n         subtree: tt::Subtree,\n         idx: usize,\n@@ -228,7 +231,7 @@ fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n             }\n \n             let spacing = match conv.peek().map(|next| next.kind(conv)) {\n-                Some(kind) if !kind.is_trivia() => tt::Spacing::Joint,\n+                Some(kind) if is_single_token_op(kind) => tt::Spacing::Joint,\n                 _ => tt::Spacing::Alone,\n             };\n             let char = match token.to_char(conv) {\n@@ -307,6 +310,35 @@ fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n     }\n }\n \n+fn is_single_token_op(kind: SyntaxKind) -> bool {\n+    matches!(\n+        kind,\n+        EQ | L_ANGLE\n+            | R_ANGLE\n+            | BANG\n+            | AMP\n+            | PIPE\n+            | TILDE\n+            | AT\n+            | DOT\n+            | COMMA\n+            | SEMICOLON\n+            | COLON\n+            | POUND\n+            | DOLLAR\n+            | QUESTION\n+            | PLUS\n+            | MINUS\n+            | STAR\n+            | SLASH\n+            | PERCENT\n+            | CARET\n+            // LIFETIME_IDENT will be split into a sequence of `'` (a single quote) and an\n+            // identifier.\n+            | LIFETIME_IDENT\n+    )\n+}\n+\n /// Returns the textual content of a doc comment block as a quoted string\n /// That is, strips leading `///` (or `/**`, etc)\n /// and strips the ending `*/`\n@@ -425,8 +457,8 @@ impl TokenIdAlloc {\n     }\n }\n \n-/// A raw token (straight from lexer) convertor\n-struct RawConvertor<'a> {\n+/// A raw token (straight from lexer) converter\n+struct RawConverter<'a> {\n     lexed: parser::LexedStr<'a>,\n     pos: usize,\n     id_alloc: TokenIdAlloc,\n@@ -442,7 +474,7 @@ trait SrcToken<Ctx>: std::fmt::Debug {\n     fn synthetic_id(&self, ctx: &Ctx) -> Option<SyntheticTokenId>;\n }\n \n-trait TokenConvertor: Sized {\n+trait TokenConverter: Sized {\n     type Token: SrcToken<Self>;\n \n     fn convert_doc_comment(&self, token: &Self::Token) -> Option<Vec<tt::TokenTree>>;\n@@ -454,25 +486,25 @@ trait TokenConvertor: Sized {\n     fn id_alloc(&mut self) -> &mut TokenIdAlloc;\n }\n \n-impl<'a> SrcToken<RawConvertor<'a>> for usize {\n-    fn kind(&self, ctx: &RawConvertor<'a>) -> SyntaxKind {\n+impl<'a> SrcToken<RawConverter<'a>> for usize {\n+    fn kind(&self, ctx: &RawConverter<'a>) -> SyntaxKind {\n         ctx.lexed.kind(*self)\n     }\n \n-    fn to_char(&self, ctx: &RawConvertor<'a>) -> Option<char> {\n+    fn to_char(&self, ctx: &RawConverter<'a>) -> Option<char> {\n         ctx.lexed.text(*self).chars().next()\n     }\n \n-    fn to_text(&self, ctx: &RawConvertor<'_>) -> SmolStr {\n+    fn to_text(&self, ctx: &RawConverter<'_>) -> SmolStr {\n         ctx.lexed.text(*self).into()\n     }\n \n-    fn synthetic_id(&self, _ctx: &RawConvertor<'a>) -> Option<SyntheticTokenId> {\n+    fn synthetic_id(&self, _ctx: &RawConverter<'a>) -> Option<SyntheticTokenId> {\n         None\n     }\n }\n \n-impl<'a> TokenConvertor for RawConvertor<'a> {\n+impl<'a> TokenConverter for RawConverter<'a> {\n     type Token = usize;\n \n     fn convert_doc_comment(&self, &token: &usize) -> Option<Vec<tt::TokenTree>> {\n@@ -504,7 +536,7 @@ impl<'a> TokenConvertor for RawConvertor<'a> {\n     }\n }\n \n-struct Convertor {\n+struct Converter {\n     id_alloc: TokenIdAlloc,\n     current: Option<SyntaxToken>,\n     current_synthetic: Vec<SyntheticToken>,\n@@ -515,19 +547,19 @@ struct Convertor {\n     punct_offset: Option<(SyntaxToken, TextSize)>,\n }\n \n-impl Convertor {\n+impl Converter {\n     fn new(\n         node: &SyntaxNode,\n         global_offset: TextSize,\n         existing_token_map: TokenMap,\n         next_id: u32,\n         mut replace: FxHashMap<SyntaxElement, Vec<SyntheticToken>>,\n         mut append: FxHashMap<SyntaxElement, Vec<SyntheticToken>>,\n-    ) -> Convertor {\n+    ) -> Converter {\n         let range = node.text_range();\n         let mut preorder = node.preorder_with_tokens();\n         let (first, synthetic) = Self::next_token(&mut preorder, &mut replace, &mut append);\n-        Convertor {\n+        Converter {\n             id_alloc: { TokenIdAlloc { map: existing_token_map, global_offset, next_id } },\n             current: first,\n             current_synthetic: synthetic,\n@@ -590,39 +622,39 @@ impl SynToken {\n     }\n }\n \n-impl SrcToken<Convertor> for SynToken {\n-    fn kind(&self, _ctx: &Convertor) -> SyntaxKind {\n+impl SrcToken<Converter> for SynToken {\n+    fn kind(&self, ctx: &Converter) -> SyntaxKind {\n         match self {\n             SynToken::Ordinary(token) => token.kind(),\n-            SynToken::Punch(token, _) => token.kind(),\n+            SynToken::Punch(..) => SyntaxKind::from_char(self.to_char(ctx).unwrap()).unwrap(),\n             SynToken::Synthetic(token) => token.kind,\n         }\n     }\n-    fn to_char(&self, _ctx: &Convertor) -> Option<char> {\n+    fn to_char(&self, _ctx: &Converter) -> Option<char> {\n         match self {\n             SynToken::Ordinary(_) => None,\n             SynToken::Punch(it, i) => it.text().chars().nth((*i).into()),\n             SynToken::Synthetic(token) if token.text.len() == 1 => token.text.chars().next(),\n             SynToken::Synthetic(_) => None,\n         }\n     }\n-    fn to_text(&self, _ctx: &Convertor) -> SmolStr {\n+    fn to_text(&self, _ctx: &Converter) -> SmolStr {\n         match self {\n             SynToken::Ordinary(token) => token.text().into(),\n             SynToken::Punch(token, _) => token.text().into(),\n             SynToken::Synthetic(token) => token.text.clone(),\n         }\n     }\n \n-    fn synthetic_id(&self, _ctx: &Convertor) -> Option<SyntheticTokenId> {\n+    fn synthetic_id(&self, _ctx: &Converter) -> Option<SyntheticTokenId> {\n         match self {\n             SynToken::Synthetic(token) => Some(token.id),\n             _ => None,\n         }\n     }\n }\n \n-impl TokenConvertor for Convertor {\n+impl TokenConverter for Converter {\n     type Token = SynToken;\n     fn convert_doc_comment(&self, token: &Self::Token) -> Option<Vec<tt::TokenTree>> {\n         convert_doc_comment(token.token()?)\n@@ -651,7 +683,7 @@ impl TokenConvertor for Convertor {\n         }\n \n         let curr = self.current.clone()?;\n-        if !&self.range.contains_range(curr.text_range()) {\n+        if !self.range.contains_range(curr.text_range()) {\n             return None;\n         }\n         let (new_current, new_synth) =\n@@ -809,12 +841,15 @@ impl<'a> TtTreeSink<'a> {\n         let next = last.bump();\n         if let (\n             Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(curr), _)),\n-            Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(_), _)),\n+            Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(next), _)),\n         ) = (last.token_tree(), next.token_tree())\n         {\n             // Note: We always assume the semi-colon would be the last token in\n             // other parts of RA such that we don't add whitespace here.\n-            if curr.spacing == tt::Spacing::Alone && curr.char != ';' {\n+            //\n+            // When `next` is a `Punct` of `'`, that's a part of a lifetime identifier so we don't\n+            // need to add whitespace either.\n+            if curr.spacing == tt::Spacing::Alone && curr.char != ';' && next.char != '\\'' {\n                 self.inner.token(WHITESPACE, \" \");\n                 self.text_pos += TextSize::of(' ');\n             }"}, {"sha": "4e04d2bc1c77bcbd972d7d349cb7ed2fe6c32129", "filename": "src/tools/rust-analyzer/crates/mbe/src/syntax_bridge/tests.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -0,0 +1,93 @@\n+use std::collections::HashMap;\n+\n+use syntax::{ast, AstNode};\n+use test_utils::extract_annotations;\n+use tt::{\n+    buffer::{TokenBuffer, TokenTreeRef},\n+    Leaf, Punct, Spacing,\n+};\n+\n+use super::syntax_node_to_token_tree;\n+\n+fn check_punct_spacing(fixture: &str) {\n+    let source_file = ast::SourceFile::parse(fixture).ok().unwrap();\n+    let (subtree, token_map) = syntax_node_to_token_tree(source_file.syntax());\n+    let mut annotations: HashMap<_, _> = extract_annotations(fixture)\n+        .into_iter()\n+        .map(|(range, annotation)| {\n+            let token = token_map.token_by_range(range).expect(\"no token found\");\n+            let spacing = match annotation.as_str() {\n+                \"Alone\" => Spacing::Alone,\n+                \"Joint\" => Spacing::Joint,\n+                a => panic!(\"unknown annotation: {}\", a),\n+            };\n+            (token, spacing)\n+        })\n+        .collect();\n+\n+    let buf = TokenBuffer::from_subtree(&subtree);\n+    let mut cursor = buf.begin();\n+    while !cursor.eof() {\n+        while let Some(token_tree) = cursor.token_tree() {\n+            if let TokenTreeRef::Leaf(Leaf::Punct(Punct { spacing, id, .. }), _) = token_tree {\n+                if let Some(expected) = annotations.remove(&id) {\n+                    assert_eq!(expected, *spacing);\n+                }\n+            }\n+            cursor = cursor.bump_subtree();\n+        }\n+        cursor = cursor.bump();\n+    }\n+\n+    assert!(annotations.is_empty(), \"unchecked annotations: {:?}\", annotations);\n+}\n+\n+#[test]\n+fn punct_spacing() {\n+    check_punct_spacing(\n+        r#\"\n+fn main() {\n+    0+0;\n+   //^ Alone\n+    0+(0);\n+   //^ Alone\n+    0<=0;\n+   //^ Joint\n+   // ^ Alone\n+    0<=(0);\n+   // ^ Alone\n+    a=0;\n+   //^ Alone\n+    a=(0);\n+   //^ Alone\n+    a+=0;\n+   //^ Joint\n+   // ^ Alone\n+    a+=(0);\n+   // ^ Alone\n+    a&&b;\n+   //^ Joint\n+   // ^ Alone\n+    a&&(b);\n+   // ^ Alone\n+    foo::bar;\n+   //  ^ Joint\n+   //   ^ Alone\n+    use foo::{bar,baz,};\n+   //       ^ Alone\n+   //            ^ Alone\n+   //                ^ Alone\n+    struct Struct<'a> {};\n+   //            ^ Joint\n+   //             ^ Joint\n+    Struct::<0>;\n+   //       ^ Alone\n+    Struct::<{0}>;\n+   //       ^ Alone\n+    ;;\n+  //^ Joint\n+  // ^ Alone\n+}\n+        \"#,\n+    );\n+}"}, {"sha": "d1420de8937a02d66fd97d4cb4660ca4b4b3cffb", "filename": "src/tools/rust-analyzer/crates/parser/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "d23a63d2a973d426d1cd8b9af30d1edfbc06d1f5", "filename": "src/tools/rust-analyzer/crates/paths/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "f261f3def45d68060b90786c5e6c52e3d7db4898", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "7991e125ab83c2f81544efb5408aea76a853f24c", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv-cli/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv-cli%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv-cli%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv-cli%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [dependencies]\n proc-macro-srv = { version = \"0.0.0\", path = \"../proc-macro-srv\" }"}, {"sha": "a136abc12b756e89b231846984a5cd69814b2a24", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "0ce099ae0bab3b5a39b29a431b1bbd836315e679", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -117,7 +117,7 @@ impl Abi {\n                 let inner = unsafe { Abi_1_63::from_lib(lib, symbol_name) }?;\n                 Ok(Abi::Abi1_63(inner))\n             }\n-            _ => Err(LoadProcMacroDylibError::UnsupportedABI),\n+            _ => Err(LoadProcMacroDylibError::UnsupportedABI(info.version_string.clone())),\n         }\n     }\n "}, {"sha": "0722cd89d7297b5c4b502b86a66e1299c9ad641b", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/dylib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -80,14 +80,14 @@ fn load_library(file: &Path) -> Result<Library, libloading::Error> {\n pub enum LoadProcMacroDylibError {\n     Io(io::Error),\n     LibLoading(libloading::Error),\n-    UnsupportedABI,\n+    UnsupportedABI(String),\n }\n \n impl fmt::Display for LoadProcMacroDylibError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Self::Io(e) => e.fmt(f),\n-            Self::UnsupportedABI => write!(f, \"unsupported ABI version\"),\n+            Self::UnsupportedABI(v) => write!(f, \"unsupported ABI `{v}`\"),\n             Self::LibLoading(e) => e.fmt(f),\n         }\n     }"}, {"sha": "b4f5ebd157f33d04c1a94a21b76cef917c4ba667", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -113,12 +113,12 @@ impl ProcMacroSrv {\n \n     fn expander(&mut self, path: &Path) -> Result<&dylib::Expander, String> {\n         let time = fs::metadata(path).and_then(|it| it.modified()).map_err(|err| {\n-            format!(\"Failed to get file metadata for {}: {:?}\", path.display(), err)\n+            format!(\"Failed to get file metadata for {}: {}\", path.display(), err)\n         })?;\n \n         Ok(match self.expanders.entry((path.to_path_buf(), time)) {\n             Entry::Vacant(v) => v.insert(dylib::Expander::new(path).map_err(|err| {\n-                format!(\"Cannot create expander for {}: {:?}\", path.display(), err)\n+                format!(\"Cannot create expander for {}: {}\", path.display(), err)\n             })?),\n             Entry::Occupied(e) => e.into_mut(),\n         })"}, {"sha": "cc0fc91fe989e3230720237584cb6ad48fbe9821", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/tests/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -19,7 +19,7 @@ fn test_derive_error() {\n         expect![[r##\"\n             SUBTREE $\n               IDENT   compile_error 4294967295\n-              PUNCH   ! [joint] 4294967295\n+              PUNCH   ! [alone] 4294967295\n               SUBTREE () 4294967295\n                 LITERAL \"#[derive(DeriveError)] struct S ;\" 4294967295\n               PUNCH   ; [alone] 4294967295\"##]],\n@@ -109,7 +109,7 @@ fn test_fn_like_macro_clone_literals() {\n               PUNCH   , [alone] 4294967295\n               LITERAL 2_u32 4294967295\n               PUNCH   , [alone] 4294967295\n-              PUNCH   - [joint] 4294967295\n+              PUNCH   - [alone] 4294967295\n               LITERAL 4i64 4294967295\n               PUNCH   , [alone] 4294967295\n               LITERAL 3.14f32 4294967295\n@@ -130,7 +130,7 @@ fn test_attr_macro() {\n         expect![[r##\"\n             SUBTREE $\n               IDENT   compile_error 4294967295\n-              PUNCH   ! [joint] 4294967295\n+              PUNCH   ! [alone] 4294967295\n               SUBTREE () 4294967295\n                 LITERAL \"#[attr_error(some arguments)] mod m {}\" 4294967295\n               PUNCH   ; [alone] 4294967295\"##]],"}, {"sha": "d2a79f91074a187005a0d451b5244405dc9b16ec", "filename": "src/tools/rust-analyzer/crates/proc-macro-test/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -3,7 +3,7 @@ name = \"proc-macro-test\"\n version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n publish = false\n \n [lib]"}, {"sha": "1bd14070e90da80ef7560d06984f7eed5e4a968b", "filename": "src/tools/rust-analyzer/crates/proc-macro-test/imp/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2Fimp%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2Fimp%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2Fimp%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -3,7 +3,7 @@ name = \"proc-macro-test-impl\"\n version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n publish = false\n \n [lib]"}, {"sha": "01d1735bf784391c16c82432c359a4acf56dcbab", "filename": "src/tools/rust-analyzer/crates/profile/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "39902a53214d0dfcbf4a33d64e009af530bef0a3", "filename": "src/tools/rust-analyzer/crates/project-model/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "ae2b41f27d58efe226a66e667683cca74788cb47", "filename": "src/tools/rust-analyzer/crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -69,7 +69,7 @@ impl WorkspaceBuildScripts {\n                 cmd.args(&[\"check\", \"--quiet\", \"--workspace\", \"--message-format=json\"]);\n \n                 // --all-targets includes tests, benches and examples in addition to the\n-                // default lib and bins. This is an independent concept from the --targets\n+                // default lib and bins. This is an independent concept from the --target\n                 // flag below.\n                 cmd.arg(\"--all-targets\");\n "}, {"sha": "02ec7a4f6f992b60a60d0a593afce746150680f5", "filename": "src/tools/rust-analyzer/crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -270,11 +270,7 @@ impl CargoWorkspace {\n         config: &CargoConfig,\n         progress: &dyn Fn(String),\n     ) -> Result<cargo_metadata::Metadata> {\n-        let target = config\n-            .target\n-            .clone()\n-            .or_else(|| cargo_config_build_target(cargo_toml, &config.extra_env))\n-            .or_else(|| rustc_discover_host_triple(cargo_toml, &config.extra_env));\n+        let targets = find_list_of_build_targets(config, cargo_toml);\n \n         let mut meta = MetadataCommand::new();\n         meta.cargo_path(toolchain::cargo());\n@@ -294,8 +290,12 @@ impl CargoWorkspace {\n         }\n         meta.current_dir(current_dir.as_os_str());\n \n-        if let Some(target) = target {\n-            meta.other_options(vec![String::from(\"--filter-platform\"), target]);\n+        if !targets.is_empty() {\n+            let other_options: Vec<_> = targets\n+                .into_iter()\n+                .flat_map(|target| [\"--filter-platform\".to_string(), target])\n+                .collect();\n+            meta.other_options(other_options);\n         }\n \n         // FIXME: Fetching metadata is a slow process, as it might require\n@@ -469,6 +469,19 @@ impl CargoWorkspace {\n     }\n }\n \n+fn find_list_of_build_targets(config: &CargoConfig, cargo_toml: &ManifestPath) -> Vec<String> {\n+    if let Some(target) = &config.target {\n+        return [target.into()].to_vec();\n+    }\n+\n+    let build_targets = cargo_config_build_target(cargo_toml, &config.extra_env);\n+    if !build_targets.is_empty() {\n+        return build_targets;\n+    }\n+\n+    rustc_discover_host_triple(cargo_toml, &config.extra_env).into_iter().collect()\n+}\n+\n fn rustc_discover_host_triple(\n     cargo_toml: &ManifestPath,\n     extra_env: &FxHashMap<String, String>,\n@@ -499,20 +512,29 @@ fn rustc_discover_host_triple(\n fn cargo_config_build_target(\n     cargo_toml: &ManifestPath,\n     extra_env: &FxHashMap<String, String>,\n-) -> Option<String> {\n+) -> Vec<String> {\n     let mut cargo_config = Command::new(toolchain::cargo());\n     cargo_config.envs(extra_env);\n     cargo_config\n         .current_dir(cargo_toml.parent())\n         .args(&[\"-Z\", \"unstable-options\", \"config\", \"get\", \"build.target\"])\n         .env(\"RUSTC_BOOTSTRAP\", \"1\");\n     // if successful we receive `build.target = \"target-triple\"`\n+    // or `build.target = [\"<target 1>\", ..]`\n     tracing::debug!(\"Discovering cargo config target by {:?}\", cargo_config);\n-    match utf8_stdout(cargo_config) {\n-        Ok(stdout) => stdout\n-            .strip_prefix(\"build.target = \\\"\")\n-            .and_then(|stdout| stdout.strip_suffix('\"'))\n-            .map(ToOwned::to_owned),\n-        Err(_) => None,\n+    utf8_stdout(cargo_config).map(parse_output_cargo_config_build_target).unwrap_or_default()\n+}\n+\n+fn parse_output_cargo_config_build_target(stdout: String) -> Vec<String> {\n+    let trimmed = stdout.trim_start_matches(\"build.target = \").trim_matches('\"');\n+\n+    if !trimmed.starts_with('[') {\n+        return [trimmed.to_string()].to_vec();\n+    }\n+\n+    let res = serde_json::from_str(trimmed);\n+    if let Err(e) = &res {\n+        tracing::warn!(\"Failed to parse `build.target` as an array of target: {}`\", e);\n     }\n+    res.unwrap_or_default()\n }"}, {"sha": "f6c09a27c9d7ea1a03727550603237348454feab", "filename": "src/tools/rust-analyzer/crates/project-model/src/sysroot.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -128,14 +128,18 @@ impl Sysroot {\n         }\n \n         if let Some(alloc) = sysroot.by_name(\"alloc\") {\n-            if let Some(core) = sysroot.by_name(\"core\") {\n-                sysroot.crates[alloc].deps.push(core);\n+            for dep in ALLOC_DEPS.trim().lines() {\n+                if let Some(dep) = sysroot.by_name(dep) {\n+                    sysroot.crates[alloc].deps.push(dep)\n+                }\n             }\n         }\n \n         if let Some(proc_macro) = sysroot.by_name(\"proc_macro\") {\n-            if let Some(std) = sysroot.by_name(\"std\") {\n-                sysroot.crates[proc_macro].deps.push(std);\n+            for dep in PROC_MACRO_DEPS.trim().lines() {\n+                if let Some(dep) = sysroot.by_name(dep) {\n+                    sysroot.crates[proc_macro].deps.push(dep)\n+                }\n             }\n         }\n \n@@ -239,24 +243,27 @@ fn get_rust_src(sysroot_path: &AbsPath) -> Option<AbsPathBuf> {\n \n const SYSROOT_CRATES: &str = \"\n alloc\n+backtrace\n core\n panic_abort\n panic_unwind\n proc_macro\n profiler_builtins\n std\n stdarch/crates/std_detect\n-term\n test\n unwind\";\n \n+const ALLOC_DEPS: &str = \"core\";\n+\n const STD_DEPS: &str = \"\n alloc\n-core\n-panic_abort\n panic_unwind\n+panic_abort\n+core\n profiler_builtins\n+unwind\n std_detect\n-term\n-test\n-unwind\";\n+test\";\n+\n+const PROC_MACRO_DEPS: &str = \"std\";"}, {"sha": "a1cb438bddc4c6cd6a00450378d44b384705aea9", "filename": "src/tools/rust-analyzer/crates/project-model/src/tests.rs", "status": "modified", "additions": 14, "deletions": 57, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1566,10 +1566,10 @@ fn rust_project_hello_world_project_model() {\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    1,\n+                                    3,\n                                 ),\n                                 name: CrateName(\n-                                    \"core\",\n+                                    \"panic_unwind\",\n                                 ),\n                                 prelude: true,\n                             },\n@@ -1584,10 +1584,10 @@ fn rust_project_hello_world_project_model() {\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    3,\n+                                    1,\n                                 ),\n                                 name: CrateName(\n-                                    \"panic_unwind\",\n+                                    \"core\",\n                                 ),\n                                 prelude: true,\n                             },\n@@ -1602,40 +1602,31 @@ fn rust_project_hello_world_project_model() {\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    7,\n+                                    9,\n                                 ),\n                                 name: CrateName(\n-                                    \"std_detect\",\n+                                    \"unwind\",\n                                 ),\n                                 prelude: true,\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    8,\n+                                    7,\n                                 ),\n                                 name: CrateName(\n-                                    \"term\",\n+                                    \"std_detect\",\n                                 ),\n                                 prelude: true,\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    9,\n+                                    8,\n                                 ),\n                                 name: CrateName(\n                                     \"test\",\n                                 ),\n                                 prelude: true,\n                             },\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    10,\n-                                ),\n-                                name: CrateName(\n-                                    \"unwind\",\n-                                ),\n-                                prelude: true,\n-                            },\n                         ],\n                         proc_macro: Err(\n                             \"no proc macro loaded for sysroot crate\",\n@@ -1687,40 +1678,6 @@ fn rust_project_hello_world_project_model() {\n                         ),\n                         edition: Edition2018,\n                         version: None,\n-                        display_name: Some(\n-                            CrateDisplayName {\n-                                crate_name: CrateName(\n-                                    \"term\",\n-                                ),\n-                                canonical_name: \"term\",\n-                            },\n-                        ),\n-                        cfg_options: CfgOptions(\n-                            [],\n-                        ),\n-                        potential_cfg_options: CfgOptions(\n-                            [],\n-                        ),\n-                        env: Env {\n-                            entries: {},\n-                        },\n-                        dependencies: [],\n-                        proc_macro: Err(\n-                            \"no proc macro loaded for sysroot crate\",\n-                        ),\n-                        origin: Lang(\n-                            Other,\n-                        ),\n-                        is_proc_macro: false,\n-                    },\n-                    CrateId(\n-                        9,\n-                    ): CrateData {\n-                        root_file_id: FileId(\n-                            10,\n-                        ),\n-                        edition: Edition2018,\n-                        version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n@@ -1748,10 +1705,10 @@ fn rust_project_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        10,\n+                        9,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            11,\n+                            10,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n@@ -1782,10 +1739,10 @@ fn rust_project_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        11,\n+                        10,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            12,\n+                            11,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n@@ -1836,7 +1793,7 @@ fn rust_project_hello_world_project_model() {\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    9,\n+                                    8,\n                                 ),\n                                 name: CrateName(\n                                     \"test\","}, {"sha": "3d199ed24afe79342c97ef43951cb7bc709c7486", "filename": "src/tools/rust-analyzer/crates/project-model/src/workspace.rs", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -377,6 +377,21 @@ impl ProjectWorkspace {\n         }\n     }\n \n+    pub fn find_sysroot_proc_macro_srv(&self) -> Option<AbsPathBuf> {\n+        match self {\n+            ProjectWorkspace::Cargo { sysroot: Some(sysroot), .. }\n+            | ProjectWorkspace::Json { sysroot: Some(sysroot), .. } => {\n+                let standalone_server_name =\n+                    format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n+                [\"libexec\", \"lib\"]\n+                    .into_iter()\n+                    .map(|segment| sysroot.root().join(segment).join(&standalone_server_name))\n+                    .find(|server_path| std::fs::metadata(&server_path).is_ok())\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     /// Returns the roots for the current `ProjectWorkspace`\n     /// The return type contains the path and whether or not\n     /// the root is a member of the current workspace\n@@ -509,14 +524,14 @@ impl ProjectWorkspace {\n                 build_scripts,\n                 toolchain: _,\n             } => cargo_to_crate_graph(\n-                rustc_cfg.clone(),\n-                cfg_overrides,\n                 load_proc_macro,\n                 load,\n+                rustc,\n                 cargo,\n-                build_scripts,\n                 sysroot.as_ref(),\n-                rustc,\n+                rustc_cfg.clone(),\n+                cfg_overrides,\n+                build_scripts,\n             ),\n             ProjectWorkspace::DetachedFiles { files, sysroot, rustc_cfg } => {\n                 detached_files_to_crate_graph(rustc_cfg.clone(), load, files, sysroot)\n@@ -602,7 +617,7 @@ fn project_json_to_crate_graph(\n     for (from, krate) in project.crates() {\n         if let Some(&from) = crates.get(&from) {\n             if let Some((public_deps, libproc_macro)) = &sysroot_deps {\n-                public_deps.add(from, &mut crate_graph);\n+                public_deps.add_to_crate_graph(&mut crate_graph, from);\n                 if krate.is_proc_macro {\n                     if let Some(proc_macro) = libproc_macro {\n                         add_dep(\n@@ -626,14 +641,14 @@ fn project_json_to_crate_graph(\n }\n \n fn cargo_to_crate_graph(\n-    rustc_cfg: Vec<CfgFlag>,\n-    override_cfg: &CfgOverrides,\n     load_proc_macro: &mut dyn FnMut(&str, &AbsPath) -> ProcMacroLoadResult,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+    rustc: &Option<CargoWorkspace>,\n     cargo: &CargoWorkspace,\n-    build_scripts: &WorkspaceBuildScripts,\n     sysroot: Option<&Sysroot>,\n-    rustc: &Option<CargoWorkspace>,\n+    rustc_cfg: Vec<CfgFlag>,\n+    override_cfg: &CfgOverrides,\n+    build_scripts: &WorkspaceBuildScripts,\n ) -> CrateGraph {\n     let _p = profile::span(\"cargo_to_crate_graph\");\n     let mut crate_graph = CrateGraph::default();\n@@ -642,13 +657,15 @@ fn cargo_to_crate_graph(\n         None => (SysrootPublicDeps::default(), None),\n     };\n \n-    let mut cfg_options = CfgOptions::default();\n-    cfg_options.extend(rustc_cfg);\n+    let cfg_options = {\n+        let mut cfg_options = CfgOptions::default();\n+        cfg_options.extend(rustc_cfg);\n+        cfg_options.insert_atom(\"debug_assertions\".into());\n+        cfg_options\n+    };\n \n     let mut pkg_to_lib_crate = FxHashMap::default();\n \n-    cfg_options.insert_atom(\"debug_assertions\".into());\n-\n     let mut pkg_crates = FxHashMap::default();\n     // Does any crate signal to rust-analyzer that they need the rustc_private crates?\n     let mut has_private = false;\n@@ -723,7 +740,7 @@ fn cargo_to_crate_graph(\n         // Set deps to the core, std and to the lib target of the current package\n         for &(from, kind) in pkg_crates.get(&pkg).into_iter().flatten() {\n             // Add sysroot deps first so that a lib target named `core` etc. can overwrite them.\n-            public_deps.add(from, &mut crate_graph);\n+            public_deps.add_to_crate_graph(&mut crate_graph, from);\n \n             if let Some((to, name)) = lib_tgt.clone() {\n                 if to != from && kind != TargetKind::BuildScript {\n@@ -767,15 +784,16 @@ fn cargo_to_crate_graph(\n         if let Some(rustc_workspace) = rustc {\n             handle_rustc_crates(\n                 &mut crate_graph,\n-                rustc_workspace,\n+                &mut pkg_to_lib_crate,\n                 load,\n-                &cfg_options,\n-                override_cfg,\n                 load_proc_macro,\n-                &mut pkg_to_lib_crate,\n-                &public_deps,\n+                rustc_workspace,\n                 cargo,\n+                &public_deps,\n+                libproc_macro,\n                 &pkg_crates,\n+                &cfg_options,\n+                override_cfg,\n                 build_scripts,\n             );\n         }\n@@ -825,28 +843,29 @@ fn detached_files_to_crate_graph(\n             },\n         );\n \n-        public_deps.add(detached_file_crate, &mut crate_graph);\n+        public_deps.add_to_crate_graph(&mut crate_graph, detached_file_crate);\n     }\n     crate_graph\n }\n \n fn handle_rustc_crates(\n     crate_graph: &mut CrateGraph,\n-    rustc_workspace: &CargoWorkspace,\n+    pkg_to_lib_crate: &mut FxHashMap<Package, CrateId>,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-    cfg_options: &CfgOptions,\n-    override_cfg: &CfgOverrides,\n     load_proc_macro: &mut dyn FnMut(&str, &AbsPath) -> ProcMacroLoadResult,\n-    pkg_to_lib_crate: &mut FxHashMap<Package, CrateId>,\n-    public_deps: &SysrootPublicDeps,\n+    rustc_workspace: &CargoWorkspace,\n     cargo: &CargoWorkspace,\n+    public_deps: &SysrootPublicDeps,\n+    libproc_macro: Option<CrateId>,\n     pkg_crates: &FxHashMap<Package, Vec<(CrateId, TargetKind)>>,\n+    cfg_options: &CfgOptions,\n+    override_cfg: &CfgOverrides,\n     build_scripts: &WorkspaceBuildScripts,\n ) {\n     let mut rustc_pkg_crates = FxHashMap::default();\n     // The root package of the rustc-dev component is rustc_driver, so we match that\n     let root_pkg =\n-        rustc_workspace.packages().find(|package| rustc_workspace[*package].name == \"rustc_driver\");\n+        rustc_workspace.packages().find(|&package| rustc_workspace[package].name == \"rustc_driver\");\n     // The rustc workspace might be incomplete (such as if rustc-dev is not\n     // installed for the current toolchain) and `rustc_source` is set to discover.\n     if let Some(root_pkg) = root_pkg {\n@@ -901,7 +920,16 @@ fn handle_rustc_crates(\n                     );\n                     pkg_to_lib_crate.insert(pkg, crate_id);\n                     // Add dependencies on core / std / alloc for this crate\n-                    public_deps.add(crate_id, crate_graph);\n+                    public_deps.add_to_crate_graph(crate_graph, crate_id);\n+                    if let Some(proc_macro) = libproc_macro {\n+                        add_dep_with_prelude(\n+                            crate_graph,\n+                            crate_id,\n+                            CrateName::new(\"proc_macro\").unwrap(),\n+                            proc_macro,\n+                            rustc_workspace[tgt].is_proc_macro,\n+                        );\n+                    }\n                     rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n                 }\n             }\n@@ -1009,7 +1037,7 @@ struct SysrootPublicDeps {\n \n impl SysrootPublicDeps {\n     /// Makes `from` depend on the public sysroot crates.\n-    fn add(&self, from: CrateId, crate_graph: &mut CrateGraph) {\n+    fn add_to_crate_graph(&self, crate_graph: &mut CrateGraph, from: CrateId) {\n         for (name, krate, prelude) in &self.deps {\n             add_dep_with_prelude(crate_graph, from, name.clone(), *krate, *prelude);\n         }"}, {"sha": "56f14fe1874901ab32b88abcceb59e5329d03772", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -8,7 +8,7 @@ documentation = \"https://rust-analyzer.github.io/manual.html\"\n license = \"MIT OR Apache-2.0\"\n autobins = false\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "cf51cf15a0e1d209855150a7dcd710c9bbd78442", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -3,11 +3,11 @@\n use std::mem;\n \n use cfg::{CfgAtom, CfgExpr};\n-use ide::{FileId, RunnableKind, TestId};\n+use ide::{Cancellable, FileId, RunnableKind, TestId};\n use project_model::{self, CargoFeatures, ManifestPath, TargetKind};\n use vfs::AbsPathBuf;\n \n-use crate::{global_state::GlobalStateSnapshot, Result};\n+use crate::global_state::GlobalStateSnapshot;\n \n /// Abstract representation of Cargo target.\n ///\n@@ -29,7 +29,7 @@ impl CargoTargetSpec {\n         spec: Option<CargoTargetSpec>,\n         kind: &RunnableKind,\n         cfg: &Option<CfgExpr>,\n-    ) -> Result<(Vec<String>, Vec<String>)> {\n+    ) -> (Vec<String>, Vec<String>) {\n         let mut args = Vec::new();\n         let mut extra_args = Vec::new();\n \n@@ -111,13 +111,13 @@ impl CargoTargetSpec {\n                 }\n             }\n         }\n-        Ok((args, extra_args))\n+        (args, extra_args)\n     }\n \n     pub(crate) fn for_file(\n         global_state_snapshot: &GlobalStateSnapshot,\n         file_id: FileId,\n-    ) -> Result<Option<CargoTargetSpec>> {\n+    ) -> Cancellable<Option<CargoTargetSpec>> {\n         let crate_id = match &*global_state_snapshot.analysis.crates_for(file_id)? {\n             &[crate_id, ..] => crate_id,\n             _ => return Ok(None),"}, {"sha": "762d7d3a18e8b51ef7c03ce80a73ff9d289db4f9", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -60,24 +60,12 @@ pub fn load_workspace(\n     };\n \n     let proc_macro_client = if load_config.with_proc_macro {\n-        let mut path = AbsPathBuf::assert(std::env::current_exe()?);\n-        let mut args = vec![\"proc-macro\"];\n-\n-        if let ProjectWorkspace::Cargo { sysroot, .. } | ProjectWorkspace::Json { sysroot, .. } =\n-            &ws\n-        {\n-            if let Some(sysroot) = sysroot.as_ref() {\n-                let standalone_server_name =\n-                    format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n-                let server_path = sysroot.root().join(\"libexec\").join(&standalone_server_name);\n-                if std::fs::metadata(&server_path).is_ok() {\n-                    path = server_path;\n-                    args = vec![];\n-                }\n-            }\n-        }\n+        let (server_path, args): (_, &[_]) = match ws.find_sysroot_proc_macro_srv() {\n+            Some(server_path) => (server_path, &[]),\n+            None => (AbsPathBuf::assert(std::env::current_exe()?), &[\"proc-macro\"]),\n+        };\n \n-        ProcMacroServer::spawn(path.clone(), args.clone()).map_err(|e| e.to_string())\n+        ProcMacroServer::spawn(server_path, args).map_err(|e| e.to_string())\n     } else {\n         Err(\"proc macro server disabled\".to_owned())\n     };"}, {"sha": "9edd045ab0716510309e3248ea8c15ce40d55f7f", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 68, "deletions": 47, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -47,30 +47,27 @@ impl flags::Scip {\n \n         let si = StaticIndex::compute(&analysis);\n \n-        let mut index = scip_types::Index {\n-            metadata: Some(scip_types::Metadata {\n-                version: scip_types::ProtocolVersion::UnspecifiedProtocolVersion.into(),\n-                tool_info: Some(scip_types::ToolInfo {\n-                    name: \"rust-analyzer\".to_owned(),\n-                    version: \"0.1\".to_owned(),\n-                    arguments: vec![],\n-                    ..Default::default()\n-                })\n-                .into(),\n-                project_root: format!(\n-                    \"file://{}\",\n-                    path.normalize()\n-                        .as_os_str()\n-                        .to_str()\n-                        .ok_or(anyhow::anyhow!(\"Unable to normalize project_root path\"))?\n-                        .to_string()\n-                ),\n-                text_document_encoding: scip_types::TextEncoding::UTF8.into(),\n-                ..Default::default()\n+        let metadata = scip_types::Metadata {\n+            version: scip_types::ProtocolVersion::UnspecifiedProtocolVersion.into(),\n+            tool_info: Some(scip_types::ToolInfo {\n+                name: \"rust-analyzer\".to_owned(),\n+                version: \"0.1\".to_owned(),\n+                arguments: vec![],\n+                special_fields: Default::default(),\n             })\n             .into(),\n-            ..Default::default()\n+            project_root: format!(\n+                \"file://{}\",\n+                path.normalize()\n+                    .as_os_str()\n+                    .to_str()\n+                    .ok_or(anyhow::anyhow!(\"Unable to normalize project_root path\"))?\n+                    .to_string()\n+            ),\n+            text_document_encoding: scip_types::TextEncoding::UTF8.into(),\n+            special_fields: Default::default(),\n         };\n+        let mut documents = Vec::new();\n \n         let mut symbols_emitted: HashSet<TokenId> = HashSet::default();\n         let mut tokens_to_symbol: HashMap<TokenId, String> = HashMap::new();\n@@ -95,53 +92,77 @@ impl flags::Scip {\n                 endings: LineEndings::Unix,\n             };\n \n-            let mut doc = scip_types::Document {\n-                relative_path,\n-                language: \"rust\".to_string(),\n-                ..Default::default()\n-            };\n+            let mut occurrences = Vec::new();\n+            let mut symbols = Vec::new();\n \n-            tokens.into_iter().for_each(|(range, id)| {\n+            tokens.into_iter().for_each(|(text_range, id)| {\n                 let token = si.tokens.get(id).unwrap();\n \n-                let mut occurrence = scip_types::Occurrence::default();\n-                occurrence.range = text_range_to_scip_range(&line_index, range);\n-                occurrence.symbol = tokens_to_symbol\n+                let range = text_range_to_scip_range(&line_index, text_range);\n+                let symbol = tokens_to_symbol\n                     .entry(id)\n                     .or_insert_with(|| {\n                         let symbol = token_to_symbol(&token).unwrap_or_else(&mut new_local_symbol);\n                         scip::symbol::format_symbol(symbol)\n                     })\n                     .clone();\n \n+                let mut symbol_roles = Default::default();\n+\n                 if let Some(def) = token.definition {\n-                    if def.range == range {\n-                        occurrence.symbol_roles |= scip_types::SymbolRole::Definition as i32;\n+                    if def.range == text_range {\n+                        symbol_roles |= scip_types::SymbolRole::Definition as i32;\n                     }\n \n                     if symbols_emitted.insert(id) {\n-                        let mut symbol_info = scip_types::SymbolInformation::default();\n-                        symbol_info.symbol = occurrence.symbol.clone();\n-                        if let Some(hover) = &token.hover {\n-                            if !hover.markup.as_str().is_empty() {\n-                                symbol_info.documentation = vec![hover.markup.as_str().to_string()];\n-                            }\n-                        }\n-\n-                        doc.symbols.push(symbol_info)\n+                        let documentation = token\n+                            .hover\n+                            .as_ref()\n+                            .map(|hover| hover.markup.as_str())\n+                            .filter(|it| !it.is_empty())\n+                            .map(|it| vec![it.to_owned()]);\n+                        let symbol_info = scip_types::SymbolInformation {\n+                            symbol: symbol.clone(),\n+                            documentation: documentation.unwrap_or_default(),\n+                            relationships: Vec::new(),\n+                            special_fields: Default::default(),\n+                        };\n+\n+                        symbols.push(symbol_info)\n                     }\n                 }\n \n-                doc.occurrences.push(occurrence);\n+                occurrences.push(scip_types::Occurrence {\n+                    range,\n+                    symbol,\n+                    symbol_roles,\n+                    override_documentation: Vec::new(),\n+                    syntax_kind: Default::default(),\n+                    diagnostics: Vec::new(),\n+                    special_fields: Default::default(),\n+                });\n             });\n \n-            if doc.occurrences.is_empty() {\n+            if occurrences.is_empty() {\n                 continue;\n             }\n \n-            index.documents.push(doc);\n+            documents.push(scip_types::Document {\n+                relative_path,\n+                language: \"rust\".to_string(),\n+                occurrences,\n+                symbols,\n+                special_fields: Default::default(),\n+            });\n         }\n \n+        let index = scip_types::Index {\n+            metadata: Some(metadata).into(),\n+            documents,\n+            external_symbols: Vec::new(),\n+            special_fields: Default::default(),\n+        };\n+\n         scip::write_message_to_file(\"index.scip\", index)\n             .map_err(|err| anyhow::anyhow!(\"Failed to write scip to file: {}\", err))?;\n \n@@ -181,7 +202,7 @@ fn new_descriptor_str(\n         name: name.to_string(),\n         disambiguator: \"\".to_string(),\n         suffix: suffix.into(),\n-        ..Default::default()\n+        special_fields: Default::default(),\n     }\n }\n \n@@ -232,11 +253,11 @@ fn token_to_symbol(token: &TokenStaticData) -> Option<scip_types::Symbol> {\n             manager: \"cargo\".to_string(),\n             name: package_name,\n             version: version.unwrap_or_else(|| \".\".to_string()),\n-            ..Default::default()\n+            special_fields: Default::default(),\n         })\n         .into(),\n         descriptors,\n-        ..Default::default()\n+        special_fields: Default::default(),\n     })\n }\n "}, {"sha": "6b2f22faa7178b262fe08b2e5f57323f4f210e4a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 68, "deletions": 15, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -118,9 +118,11 @@ config_data! {\n         /// This option does not take effect until rust-analyzer is restarted.\n         cargo_sysroot: Option<String>    = \"\\\"discover\\\"\",\n         /// Compilation target override (target triple).\n+        // FIXME(@poliorcetics): move to multiple targets here too, but this will need more work\n+        // than `checkOnSave_target`\n         cargo_target: Option<String>     = \"null\",\n         /// Unsets `#[cfg(test)]` for the specified crates.\n-        cargo_unsetTest: Vec<String>   = \"[\\\"core\\\"]\",\n+        cargo_unsetTest: Vec<String>     = \"[\\\"core\\\"]\",\n \n         /// Check all targets and tests (`--all-targets`).\n         checkOnSave_allTargets: bool                     = \"true\",\n@@ -157,7 +159,7 @@ config_data! {\n         checkOnSave_noDefaultFeatures: Option<bool>      = \"null\",\n         /// Override the command rust-analyzer uses instead of `cargo check` for\n         /// diagnostics on save. The command is required to output json and\n-        /// should therefor include `--message-format=json` or a similar option.\n+        /// should therefore include `--message-format=json` or a similar option.\n         ///\n         /// If you're changing this because you're using some tool wrapping\n         /// Cargo, you might also want to change\n@@ -174,9 +176,13 @@ config_data! {\n         /// ```\n         /// .\n         checkOnSave_overrideCommand: Option<Vec<String>> = \"null\",\n-        /// Check for a specific target. Defaults to\n-        /// `#rust-analyzer.cargo.target#`.\n-        checkOnSave_target: Option<String>               = \"null\",\n+        /// Check for specific targets. Defaults to `#rust-analyzer.cargo.target#` if empty.\n+        ///\n+        /// Can be a single target, e.g. `\"x86_64-unknown-linux-gnu\"` or a list of targets, e.g.\n+        /// `[\"aarch64-apple-darwin\", \"x86_64-apple-darwin\"]`.\n+        ///\n+        /// Aliased as `\"checkOnSave.targets\"`.\n+        checkOnSave_target | checkOnSave_targets: CheckOnSaveTargets           = \"[]\",\n \n         /// Toggles the additional completions that automatically add imports when completed.\n         /// Note that your client must specify the `additionalTextEdits` LSP client capability to truly have this feature enabled.\n@@ -261,6 +267,7 @@ config_data! {\n         files_excludeDirs: Vec<PathBuf> = \"[]\",\n         /// Controls file watching implementation.\n         files_watcher: FilesWatcherDef = \"\\\"client\\\"\",\n+\n         /// Enables highlighting of related references while the cursor is on `break`, `loop`, `while`, or `for` keywords.\n         highlightRelated_breakPoints_enable: bool = \"true\",\n         /// Enables highlighting of all exit points while the cursor is on any `return`, `?`, `fn`, or return type arrow (`->`).\n@@ -320,6 +327,8 @@ config_data! {\n         inlayHints_closingBraceHints_minLines: usize               = \"25\",\n         /// Whether to show inlay type hints for return types of closures.\n         inlayHints_closureReturnTypeHints_enable: ClosureReturnTypeHintsDef  = \"\\\"never\\\"\",\n+        /// Whether to show inlay hints for type adjustments.\n+        inlayHints_expressionAdjustmentHints_enable: AdjustmentHintsDef = \"\\\"never\\\"\",\n         /// Whether to show inlay type hints for elided lifetimes in function signatures.\n         inlayHints_lifetimeElisionHints_enable: LifetimeElisionDef = \"\\\"never\\\"\",\n         /// Whether to prefer using parameter names as the name for elided lifetime hints if possible.\n@@ -329,7 +338,8 @@ config_data! {\n         /// Whether to show function parameter name inlay hints at the call\n         /// site.\n         inlayHints_parameterHints_enable: bool                     = \"true\",\n-        /// Whether to show inlay type hints for compiler inserted reborrows.\n+        /// Whether to show inlay hints for compiler inserted reborrows.\n+        /// This setting is deprecated in favor of #rust-analyzer.inlayHints.expressionAdjustmentHints.enable#.\n         inlayHints_reborrowHints_enable: ReborrowHintsDef          = \"\\\"never\\\"\",\n         /// Whether to render leading colons for type hints, and trailing colons for parameter hints.\n         inlayHints_renderColons: bool                              = \"true\",\n@@ -1143,11 +1153,10 @@ impl Config {\n             }\n             Some(_) | None => FlycheckConfig::CargoCommand {\n                 command: self.data.checkOnSave_command.clone(),\n-                target_triple: self\n-                    .data\n-                    .checkOnSave_target\n-                    .clone()\n-                    .or_else(|| self.data.cargo_target.clone()),\n+                target_triples: match &self.data.checkOnSave_target.0[..] {\n+                    [] => self.data.cargo_target.clone().into_iter().collect(),\n+                    targets => targets.into(),\n+                },\n                 all_targets: self.data.checkOnSave_allTargets,\n                 no_default_features: self\n                     .data\n@@ -1200,10 +1209,15 @@ impl Config {\n             hide_closure_initialization_hints: self\n                 .data\n                 .inlayHints_typeHints_hideClosureInitialization,\n-            reborrow_hints: match self.data.inlayHints_reborrowHints_enable {\n-                ReborrowHintsDef::Always => ide::ReborrowHints::Always,\n-                ReborrowHintsDef::Never => ide::ReborrowHints::Never,\n-                ReborrowHintsDef::Mutable => ide::ReborrowHints::MutableOnly,\n+            adjustment_hints: match self.data.inlayHints_expressionAdjustmentHints_enable {\n+                AdjustmentHintsDef::Always => ide::AdjustmentHints::Always,\n+                AdjustmentHintsDef::Never => match self.data.inlayHints_reborrowHints_enable {\n+                    ReborrowHintsDef::Always | ReborrowHintsDef::Mutable => {\n+                        ide::AdjustmentHints::ReborrowOnly\n+                    }\n+                    ReborrowHintsDef::Never => ide::AdjustmentHints::Never,\n+                },\n+                AdjustmentHintsDef::Reborrow => ide::AdjustmentHints::ReborrowOnly,\n             },\n             binding_mode_hints: self.data.inlayHints_bindingModeHints_enable,\n             param_names_for_lifetime_elision_hints: self\n@@ -1538,6 +1552,7 @@ mod de_unit_v {\n     named_unit_variant!(all);\n     named_unit_variant!(skip_trivial);\n     named_unit_variant!(mutable);\n+    named_unit_variant!(reborrow);\n     named_unit_variant!(with_block);\n }\n \n@@ -1647,6 +1662,9 @@ enum InvocationStrategy {\n     PerWorkspace,\n }\n \n+#[derive(Deserialize, Debug, Clone)]\n+struct CheckOnSaveTargets(#[serde(deserialize_with = \"single_or_array\")] Vec<String>);\n+\n #[derive(Deserialize, Debug, Clone)]\n #[serde(rename_all = \"snake_case\")]\n enum InvocationLocation {\n@@ -1687,6 +1705,17 @@ enum ReborrowHintsDef {\n     Mutable,\n }\n \n+#[derive(Deserialize, Debug, Clone)]\n+#[serde(untagged)]\n+enum AdjustmentHintsDef {\n+    #[serde(deserialize_with = \"true_or_always\")]\n+    Always,\n+    #[serde(deserialize_with = \"false_or_never\")]\n+    Never,\n+    #[serde(deserialize_with = \"de_unit_v::reborrow\")]\n+    Reborrow,\n+}\n+\n #[derive(Deserialize, Debug, Clone)]\n #[serde(rename_all = \"snake_case\")]\n enum FilesWatcherDef {\n@@ -1996,6 +2025,19 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 \"Only show mutable reborrow hints.\"\n             ]\n         },\n+        \"AdjustmentHintsDef\" => set! {\n+            \"type\": \"string\",\n+            \"enum\": [\n+                \"always\",\n+                \"never\",\n+                \"reborrow\"\n+            ],\n+            \"enumDescriptions\": [\n+                \"Always show all adjustment hints.\",\n+                \"Never show adjustment hints.\",\n+                \"Only show auto borrow and dereference adjustment hints.\"\n+            ]\n+        },\n         \"CargoFeaturesDef\" => set! {\n             \"anyOf\": [\n                 {\n@@ -2084,6 +2126,17 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 \"The command will be executed in the project root.\"\n             ],\n         },\n+        \"CheckOnSaveTargets\" => set! {\n+            \"anyOf\": [\n+                {\n+                    \"type\": \"string\",\n+                },\n+                {\n+                    \"type\": \"array\",\n+                    \"items\": { \"type\": \"string\" }\n+                },\n+            ],\n+        },\n         _ => panic!(\"missing entry for {}: {}\", ty, default),\n     }\n "}, {"sha": "beb23c54c9f0fc7361bd7199073499798dc41ec3", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -359,14 +359,15 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n         .iter()\n         .flat_map(|primary_span| {\n             let primary_location = primary_location(config, workspace_root, primary_span, snap);\n-\n-            let mut message = message.clone();\n-            if needs_primary_span_label {\n-                if let Some(primary_span_label) = &primary_span.label {\n-                    format_to!(message, \"\\n{}\", primary_span_label);\n+            let message = {\n+                let mut message = message.clone();\n+                if needs_primary_span_label {\n+                    if let Some(primary_span_label) = &primary_span.label {\n+                        format_to!(message, \"\\n{}\", primary_span_label);\n+                    }\n                 }\n-            }\n-\n+                message\n+            };\n             // Each primary diagnostic span may result in multiple LSP diagnostics.\n             let mut diagnostics = Vec::new();\n \n@@ -417,7 +418,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n                     message: message.clone(),\n                     related_information: Some(information_for_additional_diagnostic),\n                     tags: if tags.is_empty() { None } else { Some(tags.clone()) },\n-                    data: None,\n+                    data: Some(serde_json::json!({ \"rendered\": rd.rendered })),\n                 };\n                 diagnostics.push(MappedRustDiagnostic {\n                     url: secondary_location.uri,\n@@ -449,7 +450,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n                         }\n                     },\n                     tags: if tags.is_empty() { None } else { Some(tags.clone()) },\n-                    data: None,\n+                    data: Some(serde_json::json!({ \"rendered\": rd.rendered })),\n                 },\n                 fix: None,\n             });\n@@ -534,7 +535,8 @@ mod tests {\n             Config::new(workspace_root.to_path_buf(), ClientCapabilities::default()),\n         );\n         let snap = state.snapshot();\n-        let actual = map_rust_diagnostic_to_lsp(&config, &diagnostic, workspace_root, &snap);\n+        let mut actual = map_rust_diagnostic_to_lsp(&config, &diagnostic, workspace_root, &snap);\n+        actual.iter_mut().for_each(|diag| diag.diagnostic.data = None);\n         expect.assert_debug_eq(&actual)\n     }\n "}, {"sha": "dd433b0f4d31cffad29b39955fb5365597355b4d", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -42,8 +42,10 @@ pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> R\n pub(crate) fn text_range(line_index: &LineIndex, range: lsp_types::Range) -> Result<TextRange> {\n     let start = offset(line_index, range.start)?;\n     let end = offset(line_index, range.end)?;\n-    let text_range = TextRange::new(start, end);\n-    Ok(text_range)\n+    match end < start {\n+        true => Err(format_err!(\"Invalid Range\").into()),\n+        false => Ok(TextRange::new(start, end)),\n+    }\n }\n \n pub(crate) fn file_id(snap: &GlobalStateSnapshot, url: &lsp_types::Url) -> Result<FileId> {"}, {"sha": "4e8bc8d6462ce58362d04a5a625eccb3ac565d59", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -100,7 +100,7 @@ pub(crate) struct GlobalState {\n     /// the user just adds comments or whitespace to Cargo.toml, we do not want\n     /// to invalidate any salsa caches.\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n-    pub(crate) fetch_workspaces_queue: OpQueue<Vec<anyhow::Result<ProjectWorkspace>>>,\n+    pub(crate) fetch_workspaces_queue: OpQueue<Option<Vec<anyhow::Result<ProjectWorkspace>>>>,\n     pub(crate) fetch_build_data_queue:\n         OpQueue<(Arc<Vec<ProjectWorkspace>>, Vec<anyhow::Result<WorkspaceBuildScripts>>)>,\n "}, {"sha": "d190a9f4e2ca99c0322a141c9700dcf19de8d12f", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -9,9 +9,9 @@ use std::{\n \n use anyhow::Context;\n use ide::{\n-    AnnotationConfig, AssistKind, AssistResolveStrategy, FileId, FilePosition, FileRange,\n-    HoverAction, HoverGotoTypeData, Query, RangeInfo, ReferenceCategory, Runnable, RunnableKind,\n-    SingleResolve, SourceChange, TextEdit,\n+    AnnotationConfig, AssistKind, AssistResolveStrategy, Cancellable, FileId, FilePosition,\n+    FileRange, HoverAction, HoverGotoTypeData, Query, RangeInfo, ReferenceCategory, Runnable,\n+    RunnableKind, SingleResolve, SourceChange, TextEdit,\n };\n use ide_db::SymbolKind;\n use lsp_server::ErrorCode;\n@@ -556,7 +556,7 @@ pub(crate) fn handle_will_rename_files(\n     if source_change.source_file_edits.is_empty() {\n         Ok(None)\n     } else {\n-        to_proto::workspace_edit(&snap, source_change).map(Some)\n+        Ok(Some(to_proto::workspace_edit(&snap, source_change)?))\n     }\n }\n \n@@ -1313,7 +1313,7 @@ pub(crate) fn handle_ssr(\n         position,\n         selections,\n     )??;\n-    to_proto::workspace_edit(&snap, source_change)\n+    to_proto::workspace_edit(&snap, source_change).map_err(Into::into)\n }\n \n pub(crate) fn publish_diagnostics(\n@@ -1354,13 +1354,12 @@ pub(crate) fn handle_inlay_hints(\n ) -> Result<Option<Vec<InlayHint>>> {\n     let _p = profile::span(\"handle_inlay_hints\");\n     let document_uri = &params.text_document.uri;\n-    let file_id = from_proto::file_id(&snap, document_uri)?;\n-    let line_index = snap.file_line_index(file_id)?;\n-    let range = from_proto::file_range(\n+    let FileRange { file_id, range } = from_proto::file_range(\n         &snap,\n         TextDocumentIdentifier::new(document_uri.to_owned()),\n         params.range,\n     )?;\n+    let line_index = snap.file_line_index(file_id)?;\n     let inlay_hints_config = snap.config.inlay_hints();\n     Ok(Some(\n         snap.analysis\n@@ -1369,7 +1368,7 @@ pub(crate) fn handle_inlay_hints(\n             .map(|it| {\n                 to_proto::inlay_hint(&snap, &line_index, inlay_hints_config.render_colons, it)\n             })\n-            .collect::<Result<Vec<_>>>()?,\n+            .collect::<Cancellable<Vec<_>>>()?,\n     ))\n }\n \n@@ -1426,7 +1425,7 @@ pub(crate) fn handle_call_hierarchy_prepare(\n         .into_iter()\n         .filter(|it| it.kind == Some(SymbolKind::Function))\n         .map(|it| to_proto::call_hierarchy_item(&snap, it))\n-        .collect::<Result<Vec<_>>>()?;\n+        .collect::<Cancellable<Vec<_>>>()?;\n \n     Ok(Some(res))\n }"}, {"sha": "2945dba12f255527265fb4668707adabda75d04d", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/line_index.rs", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -27,10 +27,6 @@ pub(crate) enum LineEndings {\n impl LineEndings {\n     /// Replaces `\\r\\n` with `\\n` in-place in `src`.\n     pub(crate) fn normalize(src: String) -> (String, LineEndings) {\n-        if !src.as_bytes().contains(&b'\\r') {\n-            return (src, LineEndings::Unix);\n-        }\n-\n         // We replace `\\r\\n` with `\\n` in-place, which doesn't break utf-8 encoding.\n         // While we *can* call `as_mut_vec` and do surgery on the live string\n         // directly, let's rather steal the contents of `src`. This makes the code\n@@ -39,10 +35,19 @@ impl LineEndings {\n         let mut buf = src.into_bytes();\n         let mut gap_len = 0;\n         let mut tail = buf.as_mut_slice();\n+        let mut crlf_seen = false;\n+\n+        let find_crlf = |src: &[u8]| src.windows(2).position(|it| it == b\"\\r\\n\");\n+\n         loop {\n             let idx = match find_crlf(&tail[gap_len..]) {\n-                None => tail.len(),\n-                Some(idx) => idx + gap_len,\n+                None if crlf_seen => tail.len(),\n+                // SAFETY: buf is unchanged and therefore still contains utf8 data\n+                None => return (unsafe { String::from_utf8_unchecked(buf) }, LineEndings::Unix),\n+                Some(idx) => {\n+                    crlf_seen = true;\n+                    idx + gap_len\n+                }\n             };\n             tail.copy_within(gap_len..idx, 0);\n             tail = &mut tail[idx - gap_len..];\n@@ -54,15 +59,48 @@ impl LineEndings {\n \n         // Account for removed `\\r`.\n         // After `set_len`, `buf` is guaranteed to contain utf-8 again.\n-        let new_len = buf.len() - gap_len;\n         let src = unsafe {\n+            let new_len = buf.len() - gap_len;\n             buf.set_len(new_len);\n             String::from_utf8_unchecked(buf)\n         };\n-        return (src, LineEndings::Dos);\n+        (src, LineEndings::Dos)\n+    }\n+}\n \n-        fn find_crlf(src: &[u8]) -> Option<usize> {\n-            src.windows(2).position(|it| it == b\"\\r\\n\")\n-        }\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn unix() {\n+        let src = \"a\\nb\\nc\\n\\n\\n\\n\";\n+        let (res, endings) = LineEndings::normalize(src.into());\n+        assert_eq!(endings, LineEndings::Unix);\n+        assert_eq!(res, src);\n+    }\n+\n+    #[test]\n+    fn dos() {\n+        let src = \"\\r\\na\\r\\n\\r\\nb\\r\\nc\\r\\n\\r\\n\\r\\n\\r\\n\";\n+        let (res, endings) = LineEndings::normalize(src.into());\n+        assert_eq!(endings, LineEndings::Dos);\n+        assert_eq!(res, \"\\na\\n\\nb\\nc\\n\\n\\n\\n\");\n+    }\n+\n+    #[test]\n+    fn mixed() {\n+        let src = \"a\\r\\nb\\r\\nc\\r\\n\\n\\r\\n\\n\";\n+        let (res, endings) = LineEndings::normalize(src.into());\n+        assert_eq!(endings, LineEndings::Dos);\n+        assert_eq!(res, \"a\\nb\\nc\\n\\n\\n\\n\");\n+    }\n+\n+    #[test]\n+    fn none() {\n+        let src = \"abc\";\n+        let (res, endings) = LineEndings::normalize(src.into());\n+        assert_eq!(endings, LineEndings::Unix);\n+        assert_eq!(res, src);\n     }\n }"}, {"sha": "0971dc36f3a5c84ef1f1ab34ae0da88c4ce70edc", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 59, "deletions": 52, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -1,5 +1,5 @@\n //! Utilities for LSP-related boilerplate code.\n-use std::{ops::Range, sync::Arc};\n+use std::{mem, ops::Range, sync::Arc};\n \n use lsp_server::Notification;\n \n@@ -133,11 +133,37 @@ impl GlobalState {\n }\n \n pub(crate) fn apply_document_changes(\n-    old_text: &mut String,\n-    content_changes: Vec<lsp_types::TextDocumentContentChangeEvent>,\n-) {\n+    file_contents: impl FnOnce() -> String,\n+    mut content_changes: Vec<lsp_types::TextDocumentContentChangeEvent>,\n+) -> String {\n+    // Skip to the last full document change, as it invalidates all previous changes anyways.\n+    let mut start = content_changes\n+        .iter()\n+        .rev()\n+        .position(|change| change.range.is_none())\n+        .map(|idx| content_changes.len() - idx - 1)\n+        .unwrap_or(0);\n+\n+    let mut text: String = match content_changes.get_mut(start) {\n+        // peek at the first content change as an optimization\n+        Some(lsp_types::TextDocumentContentChangeEvent { range: None, text, .. }) => {\n+            let text = mem::take(text);\n+            start += 1;\n+\n+            // The only change is a full document update\n+            if start == content_changes.len() {\n+                return text;\n+            }\n+            text\n+        }\n+        Some(_) => file_contents(),\n+        // we received no content changes\n+        None => return file_contents(),\n+    };\n+\n     let mut line_index = LineIndex {\n-        index: Arc::new(ide::LineIndex::new(old_text)),\n+        // the index will be overwritten in the bottom loop's first iteration\n+        index: Arc::new(ide::LineIndex::new(&text)),\n         // We don't care about line endings or offset encoding here.\n         endings: LineEndings::Unix,\n         encoding: PositionEncoding::Utf16,\n@@ -148,38 +174,20 @@ pub(crate) fn apply_document_changes(\n     // Some clients (e.g. Code) sort the ranges in reverse. As an optimization, we\n     // remember the last valid line in the index and only rebuild it if needed.\n     // The VFS will normalize the end of lines to `\\n`.\n-    enum IndexValid {\n-        All,\n-        UpToLineExclusive(u32),\n-    }\n-\n-    impl IndexValid {\n-        fn covers(&self, line: u32) -> bool {\n-            match *self {\n-                IndexValid::UpToLineExclusive(to) => to > line,\n-                _ => true,\n-            }\n-        }\n-    }\n-\n-    let mut index_valid = IndexValid::All;\n+    let mut index_valid = !0u32;\n     for change in content_changes {\n-        match change.range {\n-            Some(range) => {\n-                if !index_valid.covers(range.end.line) {\n-                    line_index.index = Arc::new(ide::LineIndex::new(old_text));\n-                }\n-                index_valid = IndexValid::UpToLineExclusive(range.start.line);\n-                if let Ok(range) = from_proto::text_range(&line_index, range) {\n-                    old_text.replace_range(Range::<usize>::from(range), &change.text);\n-                }\n+        // The None case can't happen as we have handled it above already\n+        if let Some(range) = change.range {\n+            if index_valid <= range.end.line {\n+                *Arc::make_mut(&mut line_index.index) = ide::LineIndex::new(&text);\n             }\n-            None => {\n-                *old_text = change.text;\n-                index_valid = IndexValid::UpToLineExclusive(0);\n+            index_valid = range.start.line;\n+            if let Ok(range) = from_proto::text_range(&line_index, range) {\n+                text.replace_range(Range::<usize>::from(range), &change.text);\n             }\n         }\n     }\n+    text\n }\n \n /// Checks that the edits inside the completion and the additional edits do not overlap.\n@@ -242,51 +250,50 @@ mod tests {\n             };\n         }\n \n-        let mut text = String::new();\n-        apply_document_changes(&mut text, vec![]);\n+        let text = apply_document_changes(|| String::new(), vec![]);\n         assert_eq!(text, \"\");\n-        apply_document_changes(\n-            &mut text,\n+        let text = apply_document_changes(\n+            || text,\n             vec![TextDocumentContentChangeEvent {\n                 range: None,\n                 range_length: None,\n                 text: String::from(\"the\"),\n             }],\n         );\n         assert_eq!(text, \"the\");\n-        apply_document_changes(&mut text, c![0, 3; 0, 3 => \" quick\"]);\n+        let text = apply_document_changes(|| text, c![0, 3; 0, 3 => \" quick\"]);\n         assert_eq!(text, \"the quick\");\n-        apply_document_changes(&mut text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n+        let text = apply_document_changes(|| text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n         assert_eq!(text, \"quick foxes\");\n-        apply_document_changes(&mut text, c![0, 11; 0, 11 => \"\\ndream\"]);\n+        let text = apply_document_changes(|| text, c![0, 11; 0, 11 => \"\\ndream\"]);\n         assert_eq!(text, \"quick foxes\\ndream\");\n-        apply_document_changes(&mut text, c![1, 0; 1, 0 => \"have \"]);\n+        let text = apply_document_changes(|| text, c![1, 0; 1, 0 => \"have \"]);\n         assert_eq!(text, \"quick foxes\\nhave dream\");\n-        apply_document_changes(\n-            &mut text,\n+        let text = apply_document_changes(\n+            || text,\n             c![0, 0; 0, 0 => \"the \", 1, 4; 1, 4 => \" quiet\", 1, 16; 1, 16 => \"s\\n\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nhave quiet dreams\\n\");\n-        apply_document_changes(&mut text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n+        let text = apply_document_changes(|| text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n         assert_eq!(text, \"the quick foxes\\n\\nhave quiet dreams\\n\\n\");\n-        apply_document_changes(\n-            &mut text,\n+        let text = apply_document_changes(\n+            || text,\n             c![1, 0; 1, 0 => \"DREAM\", 2, 0; 2, 0 => \"they \", 3, 0; 3, 0 => \"DON'T THEY?\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nDREAM\\nthey have quiet dreams\\nDON'T THEY?\\n\");\n-        apply_document_changes(&mut text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n+        let text = apply_document_changes(|| text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n         assert_eq!(text, \"the quick \\nthey have quiet dreams\\n\");\n \n-        text = String::from(\"\u2764\ufe0f\");\n-        apply_document_changes(&mut text, c![0, 0; 0, 0 => \"a\"]);\n+        let text = String::from(\"\u2764\ufe0f\");\n+        let text = apply_document_changes(|| text, c![0, 0; 0, 0 => \"a\"]);\n         assert_eq!(text, \"a\u2764\ufe0f\");\n \n-        text = String::from(\"a\\nb\");\n-        apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n+        let text = String::from(\"a\\nb\");\n+        let text = apply_document_changes(|| text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n         assert_eq!(text, \"adcb\");\n \n-        text = String::from(\"a\\nb\");\n-        apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n+        let text = String::from(\"a\\nb\");\n+        let text = apply_document_changes(|| text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n         assert_eq!(text, \"a\u021bc\\ncb\");\n     }\n "}, {"sha": "274588ce0e0764f9953c09402edfca046fc02ada", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -451,7 +451,7 @@ impl GlobalState {\n                     ProjectWorkspaceProgress::Begin => (Progress::Begin, None),\n                     ProjectWorkspaceProgress::Report(msg) => (Progress::Report, Some(msg)),\n                     ProjectWorkspaceProgress::End(workspaces) => {\n-                        self.fetch_workspaces_queue.op_completed(workspaces);\n+                        self.fetch_workspaces_queue.op_completed(Some(workspaces));\n \n                         let old = Arc::clone(&self.workspaces);\n                         self.switch_workspaces(\"fetched workspace\".to_string());\n@@ -759,8 +759,10 @@ impl GlobalState {\n \n                     let vfs = &mut this.vfs.write().0;\n                     let file_id = vfs.file_id(&path).unwrap();\n-                    let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n-                    apply_document_changes(&mut text, params.content_changes);\n+                    let text = apply_document_changes(\n+                        || std::str::from_utf8(vfs.file_contents(file_id)).unwrap().into(),\n+                        params.content_changes,\n+                    );\n \n                     vfs.set_file_contents(path, Some(text.into_bytes()));\n                 }"}, {"sha": "45a1dab9772faa8a3809436949262c97b8585243", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/mem_docs.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmem_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmem_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmem_docs.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -7,7 +7,7 @@ use vfs::VfsPath;\n \n /// Holds the set of in-memory documents.\n ///\n-/// For these document, there true contents is maintained by the client. It\n+/// For these document, their true contents is maintained by the client. It\n /// might be different from what's on disk.\n #[derive(Default, Clone)]\n pub(crate) struct MemDocs {\n@@ -19,31 +19,37 @@ impl MemDocs {\n     pub(crate) fn contains(&self, path: &VfsPath) -> bool {\n         self.mem_docs.contains_key(path)\n     }\n+\n     pub(crate) fn insert(&mut self, path: VfsPath, data: DocumentData) -> Result<(), ()> {\n         self.added_or_removed = true;\n         match self.mem_docs.insert(path, data) {\n             Some(_) => Err(()),\n             None => Ok(()),\n         }\n     }\n+\n     pub(crate) fn remove(&mut self, path: &VfsPath) -> Result<(), ()> {\n         self.added_or_removed = true;\n         match self.mem_docs.remove(path) {\n             Some(_) => Ok(()),\n             None => Err(()),\n         }\n     }\n+\n     pub(crate) fn get(&self, path: &VfsPath) -> Option<&DocumentData> {\n         self.mem_docs.get(path)\n     }\n+\n     pub(crate) fn get_mut(&mut self, path: &VfsPath) -> Option<&mut DocumentData> {\n         // NB: don't set `self.added_or_removed` here, as that purposefully only\n         // tracks changes to the key set.\n         self.mem_docs.get_mut(path)\n     }\n+\n     pub(crate) fn iter(&self) -> impl Iterator<Item = &VfsPath> {\n         self.mem_docs.keys()\n     }\n+\n     pub(crate) fn take_changes(&mut self) -> bool {\n         mem::replace(&mut self.added_or_removed, false)\n     }"}, {"sha": "fcfe4be0b8cec9aa5578286e8e34e483e6341bb8", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 24, "deletions": 40, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -106,6 +106,14 @@ impl GlobalState {\n             status.health = lsp_ext::Health::Error;\n             status.message = Some(error)\n         }\n+\n+        if self.config.linked_projects().is_empty()\n+            && self.config.detached_files().is_empty()\n+            && self.config.notifications().cargo_toml_not_found\n+        {\n+            status.health = lsp_ext::Health::Warning;\n+            status.message = Some(\"Workspace reload required\".to_string())\n+        }\n         status\n     }\n \n@@ -198,12 +206,9 @@ impl GlobalState {\n             self.show_and_log_error(\"failed to run build scripts\".to_string(), Some(error));\n         }\n \n-        let workspaces = self\n-            .fetch_workspaces_queue\n-            .last_op_result()\n-            .iter()\n-            .filter_map(|res| res.as_ref().ok().cloned())\n-            .collect::<Vec<_>>();\n+        let Some(workspaces) = self.fetch_workspaces_queue.last_op_result() else { return; };\n+        let workspaces =\n+            workspaces.iter().filter_map(|res| res.as_ref().ok().cloned()).collect::<Vec<_>>();\n \n         fn eq_ignore_build_data<'a>(\n             left: &'a ProjectWorkspace,\n@@ -300,50 +305,24 @@ impl GlobalState {\n         let files_config = self.config.files();\n         let project_folders = ProjectFolders::new(&self.workspaces, &files_config.exclude);\n \n-        let standalone_server_name =\n-            format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n-\n         if self.proc_macro_clients.is_empty() {\n             if let Some((path, path_manually_set)) = self.config.proc_macro_srv() {\n                 tracing::info!(\"Spawning proc-macro servers\");\n                 self.proc_macro_clients = self\n                     .workspaces\n                     .iter()\n                     .map(|ws| {\n-                        let (path, args) = if path_manually_set {\n+                        let (path, args): (_, &[_]) = if path_manually_set {\n                             tracing::debug!(\n                                 \"Pro-macro server path explicitly set: {}\",\n                                 path.display()\n                             );\n-                            (path.clone(), vec![])\n+                            (path.clone(), &[])\n                         } else {\n-                            let mut sysroot_server = None;\n-                            if let ProjectWorkspace::Cargo { sysroot, .. }\n-                            | ProjectWorkspace::Json { sysroot, .. } = ws\n-                            {\n-                                if let Some(sysroot) = sysroot.as_ref() {\n-                                    let server_path = sysroot\n-                                        .root()\n-                                        .join(\"libexec\")\n-                                        .join(&standalone_server_name);\n-                                    if std::fs::metadata(&server_path).is_ok() {\n-                                        tracing::debug!(\n-                                            \"Sysroot proc-macro server exists at {}\",\n-                                            server_path.display()\n-                                        );\n-                                        sysroot_server = Some(server_path);\n-                                    } else {\n-                                        tracing::debug!(\n-                                            \"Sysroot proc-macro server does not exist at {}\",\n-                                            server_path.display()\n-                                        );\n-                                    }\n-                                }\n+                            match ws.find_sysroot_proc_macro_srv() {\n+                                Some(server_path) => (server_path, &[]),\n+                                None => (path.clone(), &[\"proc-macro\"]),\n                             }\n-                            sysroot_server.map_or_else(\n-                                || (path.clone(), vec![\"proc-macro\".to_owned()]),\n-                                |path| (path, vec![]),\n-                            )\n                         };\n \n                         tracing::info!(?args, \"Using proc-macro server at {}\", path.display(),);\n@@ -427,9 +406,14 @@ impl GlobalState {\n     fn fetch_workspace_error(&self) -> Result<(), String> {\n         let mut buf = String::new();\n \n-        for ws in self.fetch_workspaces_queue.last_op_result() {\n-            if let Err(err) = ws {\n-                stdx::format_to!(buf, \"rust-analyzer failed to load workspace: {:#}\\n\", err);\n+        let Some(last_op_result) = self.fetch_workspaces_queue.last_op_result() else { return Ok(()) };\n+        if last_op_result.is_empty() {\n+            stdx::format_to!(buf, \"rust-analyzer failed to discover workspace\");\n+        } else {\n+            for ws in last_op_result {\n+                if let Err(err) = ws {\n+                    stdx::format_to!(buf, \"rust-analyzer failed to load workspace: {:#}\\n\", err);\n+                }\n             }\n         }\n "}, {"sha": "81cc1952ba5ca4b9d210f85b2225ed1abde4e189", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -24,7 +24,7 @@ use crate::{\n     line_index::{LineEndings, LineIndex, PositionEncoding},\n     lsp_ext,\n     lsp_utils::invalid_params_error,\n-    semantic_tokens, Result,\n+    semantic_tokens,\n };\n \n pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n@@ -429,7 +429,7 @@ pub(crate) fn inlay_hint(\n     line_index: &LineIndex,\n     render_colons: bool,\n     mut inlay_hint: InlayHint,\n-) -> Result<lsp_types::InlayHint> {\n+) -> Cancellable<lsp_types::InlayHint> {\n     match inlay_hint.kind {\n         InlayKind::ParameterHint if render_colons => inlay_hint.label.append_str(\":\"),\n         InlayKind::TypeHint if render_colons => inlay_hint.label.prepend_str(\": \"),\n@@ -440,32 +440,35 @@ pub(crate) fn inlay_hint(\n     Ok(lsp_types::InlayHint {\n         position: match inlay_hint.kind {\n             // before annotated thing\n-            InlayKind::ParameterHint\n-            | InlayKind::ImplicitReborrowHint\n-            | InlayKind::BindingModeHint => position(line_index, inlay_hint.range.start()),\n+            InlayKind::ParameterHint | InlayKind::AdjustmentHint | InlayKind::BindingModeHint => {\n+                position(line_index, inlay_hint.range.start())\n+            }\n             // after annotated thing\n             InlayKind::ClosureReturnTypeHint\n             | InlayKind::TypeHint\n             | InlayKind::ChainingHint\n             | InlayKind::GenericParamListHint\n+            | InlayKind::AdjustmentHintClosingParenthesis\n             | InlayKind::LifetimeHint\n             | InlayKind::ClosingBraceHint => position(line_index, inlay_hint.range.end()),\n         },\n         padding_left: Some(match inlay_hint.kind {\n             InlayKind::TypeHint => !render_colons,\n             InlayKind::ChainingHint | InlayKind::ClosingBraceHint => true,\n-            InlayKind::BindingModeHint\n+            InlayKind::AdjustmentHintClosingParenthesis\n+            | InlayKind::BindingModeHint\n             | InlayKind::ClosureReturnTypeHint\n             | InlayKind::GenericParamListHint\n-            | InlayKind::ImplicitReborrowHint\n+            | InlayKind::AdjustmentHint\n             | InlayKind::LifetimeHint\n             | InlayKind::ParameterHint => false,\n         }),\n         padding_right: Some(match inlay_hint.kind {\n-            InlayKind::ChainingHint\n+            InlayKind::AdjustmentHintClosingParenthesis\n+            | InlayKind::ChainingHint\n             | InlayKind::ClosureReturnTypeHint\n             | InlayKind::GenericParamListHint\n-            | InlayKind::ImplicitReborrowHint\n+            | InlayKind::AdjustmentHint\n             | InlayKind::TypeHint\n             | InlayKind::ClosingBraceHint => false,\n             InlayKind::BindingModeHint => inlay_hint.label.as_simple_str() != Some(\"&\"),\n@@ -476,10 +479,11 @@ pub(crate) fn inlay_hint(\n             InlayKind::ClosureReturnTypeHint | InlayKind::TypeHint | InlayKind::ChainingHint => {\n                 Some(lsp_types::InlayHintKind::TYPE)\n             }\n-            InlayKind::BindingModeHint\n+            InlayKind::AdjustmentHintClosingParenthesis\n+            | InlayKind::BindingModeHint\n             | InlayKind::GenericParamListHint\n             | InlayKind::LifetimeHint\n-            | InlayKind::ImplicitReborrowHint\n+            | InlayKind::AdjustmentHint\n             | InlayKind::ClosingBraceHint => None,\n         },\n         text_edits: None,\n@@ -518,7 +522,7 @@ pub(crate) fn inlay_hint(\n fn inlay_hint_label(\n     snap: &GlobalStateSnapshot,\n     label: InlayHintLabel,\n-) -> Result<lsp_types::InlayHintLabel> {\n+) -> Cancellable<lsp_types::InlayHintLabel> {\n     Ok(match label.as_simple_str() {\n         Some(s) => lsp_types::InlayHintLabel::String(s.into()),\n         None => lsp_types::InlayHintLabel::LabelParts(\n@@ -536,7 +540,7 @@ fn inlay_hint_label(\n                         command: None,\n                     })\n                 })\n-                .collect::<Result<Vec<_>>>()?,\n+                .collect::<Cancellable<Vec<_>>>()?,\n         ),\n     })\n }\n@@ -794,7 +798,7 @@ pub(crate) fn optional_versioned_text_document_identifier(\n pub(crate) fn location(\n     snap: &GlobalStateSnapshot,\n     frange: FileRange,\n-) -> Result<lsp_types::Location> {\n+) -> Cancellable<lsp_types::Location> {\n     let url = url(snap, frange.file_id);\n     let line_index = snap.file_line_index(frange.file_id)?;\n     let range = range(&line_index, frange.range);\n@@ -806,7 +810,7 @@ pub(crate) fn location(\n pub(crate) fn location_from_nav(\n     snap: &GlobalStateSnapshot,\n     nav: NavigationTarget,\n-) -> Result<lsp_types::Location> {\n+) -> Cancellable<lsp_types::Location> {\n     let url = url(snap, nav.file_id);\n     let line_index = snap.file_line_index(nav.file_id)?;\n     let range = range(&line_index, nav.full_range);\n@@ -818,7 +822,7 @@ pub(crate) fn location_link(\n     snap: &GlobalStateSnapshot,\n     src: Option<FileRange>,\n     target: NavigationTarget,\n-) -> Result<lsp_types::LocationLink> {\n+) -> Cancellable<lsp_types::LocationLink> {\n     let origin_selection_range = match src {\n         Some(src) => {\n             let line_index = snap.file_line_index(src.file_id)?;\n@@ -840,7 +844,7 @@ pub(crate) fn location_link(\n fn location_info(\n     snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n-) -> Result<(lsp_types::Url, lsp_types::Range, lsp_types::Range)> {\n+) -> Cancellable<(lsp_types::Url, lsp_types::Range, lsp_types::Range)> {\n     let line_index = snap.file_line_index(target.file_id)?;\n \n     let target_uri = url(snap, target.file_id);\n@@ -854,20 +858,20 @@ pub(crate) fn goto_definition_response(\n     snap: &GlobalStateSnapshot,\n     src: Option<FileRange>,\n     targets: Vec<NavigationTarget>,\n-) -> Result<lsp_types::GotoDefinitionResponse> {\n+) -> Cancellable<lsp_types::GotoDefinitionResponse> {\n     if snap.config.location_link() {\n         let links = targets\n             .into_iter()\n             .map(|nav| location_link(snap, src, nav))\n-            .collect::<Result<Vec<_>>>()?;\n+            .collect::<Cancellable<Vec<_>>>()?;\n         Ok(links.into())\n     } else {\n         let locations = targets\n             .into_iter()\n             .map(|nav| {\n                 location(snap, FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() })\n             })\n-            .collect::<Result<Vec<_>>>()?;\n+            .collect::<Cancellable<Vec<_>>>()?;\n         Ok(locations.into())\n     }\n }\n@@ -881,7 +885,7 @@ pub(crate) fn snippet_text_document_edit(\n     is_snippet: bool,\n     file_id: FileId,\n     edit: TextEdit,\n-) -> Result<lsp_ext::SnippetTextDocumentEdit> {\n+) -> Cancellable<lsp_ext::SnippetTextDocumentEdit> {\n     let text_document = optional_versioned_text_document_identifier(snap, file_id);\n     let line_index = snap.file_line_index(file_id)?;\n     let mut edits: Vec<_> =\n@@ -958,7 +962,7 @@ pub(crate) fn snippet_text_document_ops(\n pub(crate) fn snippet_workspace_edit(\n     snap: &GlobalStateSnapshot,\n     source_change: SourceChange,\n-) -> Result<lsp_ext::SnippetWorkspaceEdit> {\n+) -> Cancellable<lsp_ext::SnippetWorkspaceEdit> {\n     let mut document_changes: Vec<lsp_ext::SnippetDocumentChangeOperation> = Vec::new();\n \n     for op in source_change.file_system_edits {\n@@ -995,7 +999,7 @@ pub(crate) fn snippet_workspace_edit(\n pub(crate) fn workspace_edit(\n     snap: &GlobalStateSnapshot,\n     source_change: SourceChange,\n-) -> Result<lsp_types::WorkspaceEdit> {\n+) -> Cancellable<lsp_types::WorkspaceEdit> {\n     assert!(!source_change.is_snippet);\n     snippet_workspace_edit(snap, source_change).map(|it| it.into())\n }\n@@ -1048,7 +1052,7 @@ impl From<lsp_ext::SnippetTextEdit>\n pub(crate) fn call_hierarchy_item(\n     snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n-) -> Result<lsp_types::CallHierarchyItem> {\n+) -> Cancellable<lsp_types::CallHierarchyItem> {\n     let name = target.name.to_string();\n     let detail = target.description.clone();\n     let kind = target.kind.map(symbol_kind).unwrap_or(lsp_types::SymbolKind::FUNCTION);\n@@ -1080,7 +1084,7 @@ pub(crate) fn code_action(\n     snap: &GlobalStateSnapshot,\n     assist: Assist,\n     resolve_data: Option<(usize, lsp_types::CodeActionParams)>,\n-) -> Result<lsp_ext::CodeAction> {\n+) -> Cancellable<lsp_ext::CodeAction> {\n     let mut res = lsp_ext::CodeAction {\n         title: assist.label.to_string(),\n         group: assist.group.filter(|_| snap.config.code_action_group()).map(|gr| gr.0),\n@@ -1113,13 +1117,13 @@ pub(crate) fn code_action(\n pub(crate) fn runnable(\n     snap: &GlobalStateSnapshot,\n     runnable: Runnable,\n-) -> Result<lsp_ext::Runnable> {\n+) -> Cancellable<lsp_ext::Runnable> {\n     let config = snap.config.runnables();\n     let spec = CargoTargetSpec::for_file(snap, runnable.nav.file_id)?;\n     let workspace_root = spec.as_ref().map(|it| it.workspace_root.clone());\n     let target = spec.as_ref().map(|s| s.target.clone());\n     let (cargo_args, executable_args) =\n-        CargoTargetSpec::runnable_args(snap, spec, &runnable.kind, &runnable.cfg)?;\n+        CargoTargetSpec::runnable_args(snap, spec, &runnable.kind, &runnable.cfg);\n     let label = runnable.label(target);\n     let location = location_link(snap, None, runnable.nav)?;\n \n@@ -1142,7 +1146,7 @@ pub(crate) fn code_lens(\n     acc: &mut Vec<lsp_types::CodeLens>,\n     snap: &GlobalStateSnapshot,\n     annotation: Annotation,\n-) -> Result<()> {\n+) -> Cancellable<()> {\n     let client_commands_config = snap.config.client_commands();\n     match annotation.kind {\n         AnnotationKind::Runnable(run) => {"}, {"sha": "593dc4e55b21bb769bcfe70cfb949e7c8d609040", "filename": "src/tools/rust-analyzer/crates/sourcegen/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "f7b7d09640ff71fc7e4f8630cb122ce69e3c19ce", "filename": "src/tools/rust-analyzer/crates/stdx/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false\n@@ -16,7 +16,7 @@ always-assert = { version = \"0.1.2\", features = [\"log\"] }\n # Think twice before adding anything here\n \n [target.'cfg(windows)'.dependencies]\n-miow = \"0.4.0\"\n+miow = \"0.5.0\"\n winapi = { version = \"0.3.9\", features = [\"winerror\"] }\n \n [features]"}, {"sha": "00743cca5593494622640b85663cff15289e13d2", "filename": "src/tools/rust-analyzer/crates/syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -5,7 +5,7 @@ description = \"Comment and whitespace preserving parser for the Rust language\"\n license = \"MIT OR Apache-2.0\"\n repository = \"https://github.com/rust-lang/rust-analyzer\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "f295c40065dbd2497f9f7c77e7f14d19fd6ae040", "filename": "src/tools/rust-analyzer/crates/syntax/fuzz/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Ffuzz%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Ffuzz%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Ffuzz%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ name = \"syntax-fuzz\"\n version = \"0.0.1\"\n publish = false\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [package.metadata]\n cargo-fuzz = true"}, {"sha": "0a0cb0290d6cb5b0a55bc683a8fb8292f64fae63", "filename": "src/tools/rust-analyzer/crates/syntax/rust.ungram", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -239,8 +239,11 @@ Static =\n Trait =\n   Attr* Visibility?\n   'unsafe'? 'auto'?\n-  'trait' Name GenericParamList? (':' TypeBoundList?)? WhereClause?\n-  AssocItemList\n+  'trait' Name GenericParamList?\n+  (\n+    (':' TypeBoundList?)? WhereClause? AssocItemList\n+    | '=' TypeBoundList? WhereClause? ';'\n+  )\n \n AssocItemList =\n   '{' Attr* AssocItem* '}'"}, {"sha": "2ea715f47fb23753089a3be6e96ac55425697d52", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -407,6 +407,8 @@ impl Trait {\n     pub fn auto_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![auto]) }\n     pub fn trait_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![trait]) }\n     pub fn assoc_item_list(&self) -> Option<AssocItemList> { support::child(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]"}, {"sha": "8990f7a7d4e8ec4b85d5906667216f5835e8cb80", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/token_ext.rs", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -209,17 +209,19 @@ impl ast::String {\n         let text = &text[self.text_range_between_quotes()? - self.syntax().text_range().start()];\n \n         let mut buf = String::new();\n-        let mut text_iter = text.chars();\n+        let mut prev_end = 0;\n         let mut has_error = false;\n         unescape_literal(text, Mode::Str, &mut |char_range, unescaped_char| match (\n             unescaped_char,\n             buf.capacity() == 0,\n         ) {\n             (Ok(c), false) => buf.push(c),\n-            (Ok(c), true) if char_range.len() == 1 && Some(c) == text_iter.next() => (),\n+            (Ok(_), true) if char_range.len() == 1 && char_range.start == prev_end => {\n+                prev_end = char_range.end\n+            }\n             (Ok(c), true) => {\n                 buf.reserve_exact(text.len());\n-                buf.push_str(&text[..char_range.start]);\n+                buf.push_str(&text[..prev_end]);\n                 buf.push(c);\n             }\n             (Err(_), _) => has_error = true,\n@@ -252,17 +254,19 @@ impl ast::ByteString {\n         let text = &text[self.text_range_between_quotes()? - self.syntax().text_range().start()];\n \n         let mut buf: Vec<u8> = Vec::new();\n-        let mut text_iter = text.chars();\n+        let mut prev_end = 0;\n         let mut has_error = false;\n         unescape_literal(text, Mode::ByteStr, &mut |char_range, unescaped_char| match (\n             unescaped_char,\n             buf.capacity() == 0,\n         ) {\n             (Ok(c), false) => buf.push(c as u8),\n-            (Ok(c), true) if char_range.len() == 1 && Some(c) == text_iter.next() => (),\n+            (Ok(_), true) if char_range.len() == 1 && char_range.start == prev_end => {\n+                prev_end = char_range.end\n+            }\n             (Ok(c), true) => {\n                 buf.reserve_exact(text.len());\n-                buf.extend_from_slice(text[..char_range.start].as_bytes());\n+                buf.extend_from_slice(text[..prev_end].as_bytes());\n                 buf.push(c as u8);\n             }\n             (Err(_), _) => has_error = true,\n@@ -445,6 +449,36 @@ mod tests {\n         check_string_value(r\"\\foobar\", None);\n         check_string_value(r\"\\nfoobar\", \"\\nfoobar\");\n         check_string_value(r\"C:\\\\Windows\\\\System32\\\\\", \"C:\\\\Windows\\\\System32\\\\\");\n+        check_string_value(r\"\\x61bcde\", \"abcde\");\n+        check_string_value(\n+            r\"a\\\n+bcde\", \"abcde\",\n+        );\n+    }\n+\n+    fn check_byte_string_value<'a, const N: usize>(\n+        lit: &str,\n+        expected: impl Into<Option<&'a [u8; N]>>,\n+    ) {\n+        assert_eq!(\n+            ast::ByteString { syntax: make::tokens::literal(&format!(\"b\\\"{}\\\"\", lit)) }\n+                .value()\n+                .as_deref(),\n+            expected.into().map(|value| &value[..])\n+        );\n+    }\n+\n+    #[test]\n+    fn test_byte_string_escape() {\n+        check_byte_string_value(r\"foobar\", b\"foobar\");\n+        check_byte_string_value(r\"\\foobar\", None::<&[u8; 0]>);\n+        check_byte_string_value(r\"\\nfoobar\", b\"\\nfoobar\");\n+        check_byte_string_value(r\"C:\\\\Windows\\\\System32\\\\\", b\"C:\\\\Windows\\\\System32\\\\\");\n+        check_byte_string_value(r\"\\x61bcde\", b\"abcde\");\n+        check_byte_string_value(\n+            r\"a\\\n+bcde\", b\"abcde\",\n+        );\n     }\n \n     #[test]"}, {"sha": "712ef5f63b651e9e3db63378dff73210a7622a12", "filename": "src/tools/rust-analyzer/crates/syntax/src/tests/sourcegen_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -86,7 +86,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> String {\n                 .traits\n                 .iter()\n                 .filter(|trait_name| {\n-                    // Loops have two expressions so this might collide, therefor manual impl it\n+                    // Loops have two expressions so this might collide, therefore manual impl it\n                     node.name != \"ForExpr\" && node.name != \"WhileExpr\"\n                         || trait_name.as_str() != \"HasLoopBody\"\n                 })"}, {"sha": "1047373b1c75ea104608913537f099e5971d6343", "filename": "src/tools/rust-analyzer/crates/test-utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "8df7e1af611635d2486736e25ac8234e2cbf181a", "filename": "src/tools/rust-analyzer/crates/text-edit/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftext-edit%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftext-edit%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftext-edit%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "a6a3ae742aeb3f0c7ebc07783a9a64b72b25ff98", "filename": "src/tools/rust-analyzer/crates/toolchain/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftoolchain%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftoolchain%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftoolchain%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "4f2103f3a97fc4174393249ea1d0bf0f1f0577a3", "filename": "src/tools/rust-analyzer/crates/tt/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "061f3c157a88c528025717fd4d411302a81b72ad", "filename": "src/tools/rust-analyzer/crates/vfs-notify/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "e55bf6f293c436e23c9d6e8f5d02597740313cf6", "filename": "src/tools/rust-analyzer/crates/vfs/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "a07cf036e0604de89140018332f6deb362cc3035", "filename": "src/tools/rust-analyzer/docs/dev/architecture.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -481,7 +481,7 @@ It is not cheap enough to enable in prod, and this is a bug which should be fixe\n rust-analyzer strives to be as configurable as possible while offering reasonable defaults where no configuration exists yet.\n The rule of thumb is to enable most features by default unless they are buggy or degrade performance too much.\n There will always be features that some people find more annoying than helpful, so giving the users the ability to tweak or disable these is a big part of offering a good user experience.\n-Enabling them by default is a matter of discoverability, as many users end up don't know about some features even though they are presented in the manual.\n+Enabling them by default is a matter of discoverability, as many users don't know about some features even though they are presented in the manual.\n Mind the code--architecture gap: at the moment, we are using fewer feature flags than we really should.\n \n ### Serialization\n@@ -492,8 +492,8 @@ If a type is serializable, then it is a part of some IPC boundary.\n You often don't control the other side of this boundary, so changing serializable types is hard.\n \n For this reason, the types in `ide`, `base_db` and below are not serializable by design.\n-If such types need to cross an IPC boundary, then the client of rust-analyzer needs to provide custom, client-specific serialization format.\n+If such types need to cross an IPC boundary, then the client of rust-analyzer needs to provide a custom, client-specific serialization format.\n This isolates backwards compatibility and migration concerns to a specific client.\n \n-For example, `rust-project.json` is it's own format -- it doesn't include `CrateGraph` as is.\n+For example, `rust-project.json` is its own format -- it doesn't include `CrateGraph` as is.\n Instead, it creates a `CrateGraph` by calling appropriate constructing functions."}, {"sha": "57f950034cbb7c0eb99c4cefee5e346d23a7694b", "filename": "src/tools/rust-analyzer/docs/user/generated_config.adoc", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -173,7 +173,7 @@ Whether to pass `--no-default-features` to Cargo. Defaults to\n --\n Override the command rust-analyzer uses instead of `cargo check` for\n diagnostics on save. The command is required to output json and\n-should therefor include `--message-format=json` or a similar option.\n+should therefore include `--message-format=json` or a similar option.\n \n If you're changing this because you're using some tool wrapping\n Cargo, you might also want to change\n@@ -190,11 +190,15 @@ cargo check --workspace --message-format=json --all-targets\n ```\n .\n --\n-[[rust-analyzer.checkOnSave.target]]rust-analyzer.checkOnSave.target (default: `null`)::\n+[[rust-analyzer.checkOnSave.target]]rust-analyzer.checkOnSave.target (default: `[]`)::\n +\n --\n-Check for a specific target. Defaults to\n-`#rust-analyzer.cargo.target#`.\n+Check for specific targets. Defaults to `#rust-analyzer.cargo.target#` if empty.\n+\n+Can be a single target, e.g. `\"x86_64-unknown-linux-gnu\"` or a list of targets, e.g.\n+`[\"aarch64-apple-darwin\", \"x86_64-apple-darwin\"]`.\n+\n+Aliased as `\"checkOnSave.targets\"`.\n --\n [[rust-analyzer.completion.autoimport.enable]]rust-analyzer.completion.autoimport.enable (default: `true`)::\n +\n@@ -450,6 +454,11 @@ to always show them).\n --\n Whether to show inlay type hints for return types of closures.\n --\n+[[rust-analyzer.inlayHints.expressionAdjustmentHints.enable]]rust-analyzer.inlayHints.expressionAdjustmentHints.enable (default: `\"never\"`)::\n++\n+--\n+Whether to show inlay hints for type adjustments.\n+--\n [[rust-analyzer.inlayHints.lifetimeElisionHints.enable]]rust-analyzer.inlayHints.lifetimeElisionHints.enable (default: `\"never\"`)::\n +\n --\n@@ -474,7 +483,8 @@ site.\n [[rust-analyzer.inlayHints.reborrowHints.enable]]rust-analyzer.inlayHints.reborrowHints.enable (default: `\"never\"`)::\n +\n --\n-Whether to show inlay type hints for compiler inserted reborrows.\n+Whether to show inlay hints for compiler inserted reborrows.\n+This setting is deprecated in favor of #rust-analyzer.inlayHints.expressionAdjustmentHints.enable#.\n --\n [[rust-analyzer.inlayHints.renderColons]]rust-analyzer.inlayHints.renderColons (default: `true`)::\n +"}, {"sha": "1a4c70575b033af617a301a7db203a99f9da0252", "filename": "src/tools/rust-analyzer/docs/user/manual.adoc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -367,7 +367,7 @@ if executable('rust-analyzer')\n endif\n ----\n \n-There is no dedicated UI for the server configuration, so you would need to send any options as a value of the `initialization_options` field, as described in the <<_configuration,Configuration>> section.\n+There is no dedicated UI for the server configuration, so you would need to send any options as a value of the `initialization_options` field, as described in the <<configuration,Configuration>> section.\n Here is an example of how to enable the proc-macro support:\n \n [source,vim]"}, {"sha": "c4d4e428ea07d9d60cd855e2097ad6b178333ce4", "filename": "src/tools/rust-analyzer/editors/code/package.json", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -396,6 +396,11 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.diagnostics.previewRustcOutput\": {\n+                    \"markdownDescription\": \"Whether to show the main part of the rendered rustc output of a diagnostic message.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n                 \"$generated-start\": {},\n                 \"rust-analyzer.assist.emitMustUse\": {\n                     \"markdownDescription\": \"Whether to insert #[must_use] when generating `as_` methods\\nfor enum variants.\",\n@@ -623,7 +628,7 @@\n                     ]\n                 },\n                 \"rust-analyzer.checkOnSave.overrideCommand\": {\n-                    \"markdownDescription\": \"Override the command rust-analyzer uses instead of `cargo check` for\\ndiagnostics on save. The command is required to output json and\\nshould therefor include `--message-format=json` or a similar option.\\n\\nIf you're changing this because you're using some tool wrapping\\nCargo, you might also want to change\\n`#rust-analyzer.cargo.buildScripts.overrideCommand#`.\\n\\nIf there are multiple linked projects, this command is invoked for\\neach of them, with the working directory being the project root\\n(i.e., the folder containing the `Cargo.toml`).\\n\\nAn example command would be:\\n\\n```bash\\ncargo check --workspace --message-format=json --all-targets\\n```\\n.\",\n+                    \"markdownDescription\": \"Override the command rust-analyzer uses instead of `cargo check` for\\ndiagnostics on save. The command is required to output json and\\nshould therefore include `--message-format=json` or a similar option.\\n\\nIf you're changing this because you're using some tool wrapping\\nCargo, you might also want to change\\n`#rust-analyzer.cargo.buildScripts.overrideCommand#`.\\n\\nIf there are multiple linked projects, this command is invoked for\\neach of them, with the working directory being the project root\\n(i.e., the folder containing the `Cargo.toml`).\\n\\nAn example command would be:\\n\\n```bash\\ncargo check --workspace --message-format=json --all-targets\\n```\\n.\",\n                     \"default\": null,\n                     \"type\": [\n                         \"null\",\n@@ -634,11 +639,18 @@\n                     }\n                 },\n                 \"rust-analyzer.checkOnSave.target\": {\n-                    \"markdownDescription\": \"Check for a specific target. Defaults to\\n`#rust-analyzer.cargo.target#`.\",\n-                    \"default\": null,\n-                    \"type\": [\n-                        \"null\",\n-                        \"string\"\n+                    \"markdownDescription\": \"Check for specific targets. Defaults to `#rust-analyzer.cargo.target#` if empty.\\n\\nCan be a single target, e.g. `\\\"x86_64-unknown-linux-gnu\\\"` or a list of targets, e.g.\\n`[\\\"aarch64-apple-darwin\\\", \\\"x86_64-apple-darwin\\\"]`.\\n\\nAliased as `\\\"checkOnSave.targets\\\"`.\",\n+                    \"default\": [],\n+                    \"anyOf\": [\n+                        {\n+                            \"type\": \"string\"\n+                        },\n+                        {\n+                            \"type\": \"array\",\n+                            \"items\": {\n+                                \"type\": \"string\"\n+                            }\n+                        }\n                     ]\n                 },\n                 \"rust-analyzer.completion.autoimport.enable\": {\n@@ -935,6 +947,21 @@\n                         \"Only show type hints for return types of closures with blocks.\"\n                     ]\n                 },\n+                \"rust-analyzer.inlayHints.expressionAdjustmentHints.enable\": {\n+                    \"markdownDescription\": \"Whether to show inlay hints for type adjustments.\",\n+                    \"default\": \"never\",\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"always\",\n+                        \"never\",\n+                        \"reborrow\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"Always show all adjustment hints.\",\n+                        \"Never show adjustment hints.\",\n+                        \"Only show auto borrow and dereference adjustment hints.\"\n+                    ]\n+                },\n                 \"rust-analyzer.inlayHints.lifetimeElisionHints.enable\": {\n                     \"markdownDescription\": \"Whether to show inlay type hints for elided lifetimes in function signatures.\",\n                     \"default\": \"never\",\n@@ -970,7 +997,7 @@\n                     \"type\": \"boolean\"\n                 },\n                 \"rust-analyzer.inlayHints.reborrowHints.enable\": {\n-                    \"markdownDescription\": \"Whether to show inlay type hints for compiler inserted reborrows.\",\n+                    \"markdownDescription\": \"Whether to show inlay hints for compiler inserted reborrows.\\nThis setting is deprecated in favor of #rust-analyzer.inlayHints.expressionAdjustmentHints.enable#.\",\n                     \"default\": \"never\",\n                     \"type\": \"string\",\n                     \"enum\": [\n@@ -1276,6 +1303,11 @@\n                 \"$generated-end\": {}\n             }\n         },\n+        \"configurationDefaults\": {\n+            \"explorer.fileNesting.patterns\": {\n+                \"Cargo.toml\": \"Cargo.lock\"\n+            }\n+        },\n         \"problemPatterns\": [\n             {\n                 \"name\": \"rustc\","}, {"sha": "23e039722ee334ac1634d2c5a0093e2ce1a4ea26", "filename": "src/tools/rust-analyzer/editors/code/src/client.ts", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ import * as ra from \"../src/lsp_ext\";\n import * as Is from \"vscode-languageclient/lib/common/utils/is\";\n import { assert } from \"./util\";\n import { WorkspaceEdit } from \"vscode\";\n-import { substituteVSCodeVariables } from \"./config\";\n+import { Config, substituteVSCodeVariables } from \"./config\";\n import { randomUUID } from \"crypto\";\n \n export interface Env {\n@@ -66,7 +66,8 @@ export async function createClient(\n     traceOutputChannel: vscode.OutputChannel,\n     outputChannel: vscode.OutputChannel,\n     initializationOptions: vscode.WorkspaceConfiguration,\n-    serverOptions: lc.ServerOptions\n+    serverOptions: lc.ServerOptions,\n+    config: Config\n ): Promise<lc.LanguageClient> {\n     const clientOptions: lc.LanguageClientOptions = {\n         documentSelector: [{ scheme: \"file\", language: \"rust\" }],\n@@ -99,6 +100,43 @@ export async function createClient(\n                     }\n                 },\n             },\n+            async handleDiagnostics(\n+                uri: vscode.Uri,\n+                diagnostics: vscode.Diagnostic[],\n+                next: lc.HandleDiagnosticsSignature\n+            ) {\n+                const preview = config.previewRustcOutput;\n+                diagnostics.forEach((diag, idx) => {\n+                    // Abuse the fact that VSCode leaks the LSP diagnostics data field through the\n+                    // Diagnostic class, if they ever break this we are out of luck and have to go\n+                    // back to the worst diagnostics experience ever:)\n+\n+                    // We encode the rendered output of a rustc diagnostic in the rendered field of\n+                    // the data payload of the lsp diagnostic. If that field exists, overwrite the\n+                    // diagnostic code such that clicking it opens the diagnostic in a readonly\n+                    // text editor for easy inspection\n+                    const rendered = (diag as unknown as { data?: { rendered?: string } }).data\n+                        ?.rendered;\n+                    if (rendered) {\n+                        if (preview) {\n+                            const index = rendered.match(/^(note|help):/m)?.index || 0;\n+                            diag.message = rendered\n+                                .substring(0, index)\n+                                .replace(/^ -->[^\\n]+\\n/m, \"\");\n+                        }\n+                        diag.code = {\n+                            target: vscode.Uri.from({\n+                                scheme: \"rust-analyzer-diagnostics-view\",\n+                                path: \"/diagnostic message\",\n+                                fragment: uri.toString(),\n+                                query: idx.toString(),\n+                            }),\n+                            value: \"Click for full compiler diagnostic\",\n+                        };\n+                    }\n+                });\n+                return next(uri, diagnostics);\n+            },\n             async provideHover(\n                 document: vscode.TextDocument,\n                 position: vscode.Position,"}, {"sha": "d8dbd1df16dfbceecee1e7249dec38046ccbe41d", "filename": "src/tools/rust-analyzer/editors/code/src/config.ts", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -238,6 +238,9 @@ export class Config {\n             gotoTypeDef: this.get<boolean>(\"hover.actions.gotoTypeDef.enable\"),\n         };\n     }\n+    get previewRustcOutput() {\n+        return this.get<boolean>(\"diagnostics.previewRustcOutput\");\n+    }\n }\n \n const VarRegex = new RegExp(/\\$\\{(.+?)\\}/g);"}, {"sha": "d6cee5c8fc6100926f7675edb81033759e43dfef", "filename": "src/tools/rust-analyzer/editors/code/src/ctx.ts", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -179,7 +179,8 @@ export class Ctx {\n                 this.traceOutputChannel,\n                 this.outputChannel,\n                 initializationOptions,\n-                serverOptions\n+                serverOptions,\n+                this.config\n             );\n             this.pushClientCleanup(\n                 this._client.onNotification(ra.serverStatus, (params) =>"}, {"sha": "25f1e83d109cbba173e01bdb336454bb616268a9", "filename": "src/tools/rust-analyzer/editors/code/src/main.ts", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -48,6 +48,30 @@ async function activateServer(ctx: Ctx): Promise<RustAnalyzerExtensionApi> {\n         ctx.pushExtCleanup(activateTaskProvider(ctx.config));\n     }\n \n+    ctx.pushExtCleanup(\n+        vscode.workspace.registerTextDocumentContentProvider(\n+            \"rust-analyzer-diagnostics-view\",\n+            new (class implements vscode.TextDocumentContentProvider {\n+                async provideTextDocumentContent(uri: vscode.Uri): Promise<string> {\n+                    const diags = ctx.client?.diagnostics?.get(\n+                        vscode.Uri.parse(uri.fragment, true)\n+                    );\n+                    if (!diags) {\n+                        return \"Unable to find original rustc diagnostic\";\n+                    }\n+\n+                    const diag = diags[parseInt(uri.query)];\n+                    if (!diag) {\n+                        return \"Unable to find original rustc diagnostic\";\n+                    }\n+                    const rendered = (diag as unknown as { data?: { rendered?: string } }).data\n+                        ?.rendered;\n+                    return rendered ?? \"Unable to find original rustc diagnostic\";\n+                }\n+            })()\n+        )\n+    );\n+\n     vscode.workspace.onDidChangeWorkspaceFolders(\n         async (_) => ctx.onWorkspaceFolderChanges(),\n         null,"}, {"sha": "95e27beab5dc12506d23463e4f3f04222c39e295", "filename": "src/tools/rust-analyzer/xtask/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fxtask%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frust-analyzer%2Fxtask%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fxtask%2FCargo.toml?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -4,7 +4,7 @@ version = \"0.1.0\"\n publish = false\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [dependencies]\n anyhow = \"1.0.62\""}, {"sha": "414e767690bd090af990c13beb68d4bf2cb8fc25", "filename": "src/tools/rustfmt/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dda298ad39a64e019a3511139c5b13ac0a18e54/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs?ref=1dda298ad39a64e019a3511139c5b13ac0a18e54", "patch": "@@ -660,7 +660,7 @@ fn to_control_flow(expr: &ast::Expr, expr_type: ExprType) -> Option<ControlFlow<\n         ast::ExprKind::ForLoop(ref pat, ref cond, ref block, label) => {\n             Some(ControlFlow::new_for(pat, cond, block, label, expr.span))\n         }\n-        ast::ExprKind::Loop(ref block, label) => {\n+        ast::ExprKind::Loop(ref block, label, _) => {\n             Some(ControlFlow::new_loop(block, label, expr.span))\n         }\n         ast::ExprKind::While(ref cond, ref block, label) => {"}]}