{"sha": "df77e2448cf85ad33d07ceddb31922a133168895", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNzdlMjQ0OGNmODVhZDMzZDA3Y2VkZGIzMTkyMmExMzMxNjg4OTU=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-08-21T17:47:06Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-08-21T18:07:07Z"}, "message": "Fix panic caused by #9966\n\nChalk can introduce new type variables when doing lazy normalization, so\nwe have to do the proper 'fudging' after all.", "tree": {"sha": "6f345344fad2473b5b2c4361f5b3eabed1910df0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f345344fad2473b5b2c4361f5b3eabed1910df0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df77e2448cf85ad33d07ceddb31922a133168895", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df77e2448cf85ad33d07ceddb31922a133168895", "html_url": "https://github.com/rust-lang/rust/commit/df77e2448cf85ad33d07ceddb31922a133168895", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df77e2448cf85ad33d07ceddb31922a133168895/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f4c51522316c0698d59e7738ed8d8aab2d2c42d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f4c51522316c0698d59e7738ed8d8aab2d2c42d", "html_url": "https://github.com/rust-lang/rust/commit/3f4c51522316c0698d59e7738ed8d8aab2d2c42d"}], "stats": {"total": 146, "additions": 129, "deletions": 17}, "files": [{"sha": "7d37e512448f9bcad8b9dfd8bffde9bb0fe30e9c", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/df77e2448cf85ad33d07ceddb31922a133168895/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df77e2448cf85ad33d07ceddb31922a133168895/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=df77e2448cf85ad33d07ceddb31922a133168895", "patch": "@@ -985,20 +985,21 @@ impl<'a> InferenceContext<'a> {\n         inputs: Vec<Ty>,\n     ) -> Vec<Ty> {\n         if let Some(expected_ty) = expected_output.to_option(&mut self.table) {\n-            let snapshot = self.table.snapshot();\n-            let result = if self.table.try_unify(&expected_ty, &output).is_ok() {\n-                // FIXME: the unification could introduce lifetime variables, which we'd need to handle here\n-                self.table.resolve_with_fallback(inputs, |var, kind, _, _| match kind {\n-                    chalk_ir::VariableKind::Ty(tk) => var.to_ty(&Interner, tk).cast(&Interner),\n-                    chalk_ir::VariableKind::Lifetime => var.to_lifetime(&Interner).cast(&Interner),\n-                    chalk_ir::VariableKind::Const(ty) => {\n-                        var.to_const(&Interner, ty).cast(&Interner)\n-                    }\n-                })\n-            } else {\n-                Vec::new()\n-            };\n-            self.table.rollback_to(snapshot);\n+            let result = self.table.fudge_inference(|table| {\n+                if table.try_unify(&expected_ty, &output).is_ok() {\n+                    table.resolve_with_fallback(inputs, |var, kind, _, _| match kind {\n+                        chalk_ir::VariableKind::Ty(tk) => var.to_ty(&Interner, tk).cast(&Interner),\n+                        chalk_ir::VariableKind::Lifetime => {\n+                            var.to_lifetime(&Interner).cast(&Interner)\n+                        }\n+                        chalk_ir::VariableKind::Const(ty) => {\n+                            var.to_const(&Interner, ty).cast(&Interner)\n+                        }\n+                    })\n+                } else {\n+                    Vec::new()\n+                }\n+            });\n             result\n         } else {\n             Vec::new()"}, {"sha": "bb87e83ca054dd2028299c771cb655f4f4d99b63", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 83, "deletions": 3, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/df77e2448cf85ad33d07ceddb31922a133168895/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df77e2448cf85ad33d07ceddb31922a133168895/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=df77e2448cf85ad33d07ceddb31922a133168895", "patch": "@@ -11,9 +11,9 @@ use ena::unify::UnifyKey;\n \n use super::{InferOk, InferResult, InferenceContext, TypeError};\n use crate::{\n-    db::HirDatabase, fold_tys, static_lifetime, AliasEq, AliasTy, BoundVar, Canonical,\n-    DebruijnIndex, GenericArg, Goal, Guidance, InEnvironment, InferenceVar, Interner, ProjectionTy,\n-    Scalar, Solution, Substitution, TraitEnvironment, Ty, TyKind, VariableKind,\n+    db::HirDatabase, fold_tys, static_lifetime, AliasEq, AliasTy, BoundVar, Canonical, Const,\n+    DebruijnIndex, GenericArg, Goal, Guidance, InEnvironment, InferenceVar, Interner, Lifetime,\n+    ProjectionTy, Scalar, Solution, Substitution, TraitEnvironment, Ty, TyKind, VariableKind,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -273,6 +273,16 @@ impl<'a> InferenceTable<'a> {\n         self.new_var(TyVariableKind::General, true)\n     }\n \n+    pub(crate) fn new_const_var(&mut self, ty: Ty) -> Const {\n+        let var = self.var_unification_table.new_variable(UniverseIndex::ROOT);\n+        var.to_const(&Interner, ty)\n+    }\n+\n+    pub(crate) fn new_lifetime_var(&mut self) -> Lifetime {\n+        let var = self.var_unification_table.new_variable(UniverseIndex::ROOT);\n+        var.to_lifetime(&Interner)\n+    }\n+\n     pub(crate) fn resolve_with_fallback<T>(\n         &mut self,\n         t: T,\n@@ -388,6 +398,76 @@ impl<'a> InferenceTable<'a> {\n         }\n     }\n \n+    pub(crate) fn fudge_inference<T: Fold<Interner>>(\n+        &mut self,\n+        f: impl FnOnce(&mut Self) -> T,\n+    ) -> T::Result {\n+        use chalk_ir::fold::Folder;\n+        struct VarFudger<'a, 'b> {\n+            table: &'a mut InferenceTable<'b>,\n+            highest_known_var: InferenceVar,\n+        }\n+        impl<'a, 'b> Folder<'static, Interner> for VarFudger<'a, 'b> {\n+            fn as_dyn(&mut self) -> &mut dyn Folder<'static, Interner> {\n+                self\n+            }\n+\n+            fn interner(&self) -> &'static Interner {\n+                &Interner\n+            }\n+\n+            fn fold_inference_ty(\n+                &mut self,\n+                var: chalk_ir::InferenceVar,\n+                kind: TyVariableKind,\n+                _outer_binder: chalk_ir::DebruijnIndex,\n+            ) -> chalk_ir::Fallible<chalk_ir::Ty<Interner>> {\n+                Ok(if var < self.highest_known_var {\n+                    var.to_ty(&Interner, kind)\n+                } else {\n+                    self.table.new_type_var()\n+                })\n+            }\n+\n+            fn fold_inference_lifetime(\n+                &mut self,\n+                var: chalk_ir::InferenceVar,\n+                _outer_binder: chalk_ir::DebruijnIndex,\n+            ) -> chalk_ir::Fallible<chalk_ir::Lifetime<Interner>> {\n+                Ok(if var < self.highest_known_var {\n+                    var.to_lifetime(&Interner)\n+                } else {\n+                    self.table.new_lifetime_var()\n+                })\n+            }\n+\n+            fn fold_inference_const(\n+                &mut self,\n+                ty: chalk_ir::Ty<Interner>,\n+                var: chalk_ir::InferenceVar,\n+                _outer_binder: chalk_ir::DebruijnIndex,\n+            ) -> chalk_ir::Fallible<chalk_ir::Const<Interner>> {\n+                Ok(if var < self.highest_known_var {\n+                    var.to_const(&Interner, ty)\n+                } else {\n+                    self.table.new_const_var(ty)\n+                })\n+            }\n+        }\n+\n+        let snapshot = self.snapshot();\n+        let highest_known_var =\n+            self.new_type_var().inference_var(&Interner).expect(\"inference_var\");\n+        let result = f(self);\n+        self.rollback_to(snapshot);\n+\n+        let result = result\n+            .fold_with(&mut VarFudger { table: self, highest_known_var }, DebruijnIndex::INNERMOST)\n+            .expect(\"fold_with with VarFudger\");\n+\n+        result\n+    }\n+\n     /// This checks whether any of the free variables in the `canonicalized`\n     /// have changed (either been unified with another variable, or with a\n     /// value). If this is not the case, we don't need to try to solve the goal"}, {"sha": "70a1c37dc077d55e53434b5aa7e31f4d6cc480ac", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/df77e2448cf85ad33d07ceddb31922a133168895/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df77e2448cf85ad33d07ceddb31922a133168895/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=df77e2448cf85ad33d07ceddb31922a133168895", "patch": "@@ -1114,3 +1114,34 @@ fn test() {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn coerce_diesel_panic() {\n+    check_no_mismatches(\n+        r#\"\n+//- minicore: option\n+\n+trait TypeMetadata {\n+    type MetadataLookup;\n+}\n+\n+pub struct Output<'a, T, DB>\n+where\n+    DB: TypeMetadata,\n+    DB::MetadataLookup: 'a,\n+{\n+    out: T,\n+    metadata_lookup: Option<&'a DB::MetadataLookup>,\n+}\n+\n+impl<'a, T, DB: TypeMetadata> Output<'a, T, DB> {\n+    pub fn new(out: T, metadata_lookup: &'a DB::MetadataLookup) -> Self {\n+        Output {\n+            out,\n+            metadata_lookup: Some(metadata_lookup),\n+        }\n+    }\n+}\n+        \"#,\n+    );\n+}"}]}