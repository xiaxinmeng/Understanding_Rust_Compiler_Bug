{"sha": "1423bec54cf2db283b614e527cfd602b481485d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MjNiZWM1NGNmMmRiMjgzYjYxNGU1MjdjZmQ2MDJiNDgxNDg1ZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-05T20:22:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-05T20:22:27Z"}, "message": "Auto merge of #66121 - pietroalbini:rollup-8zrwe7l, r=pietroalbini\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #65948 (Improve MaybeUninit::get_{ref,mut} documentation)\n - #65953 (Allow specifying LLVM's MCTargetOptions::ABIName in target specification files)\n - #66012 (De-querify `trivial_dropck_outlives`.)\n - #66025 (`Span` cannot represent `span.hi < span.lo`)\n - #66047 (Don't double-count `simd_shuffle` promotion candidates)\n - #66053 (when Miri tests are not passing, do not add Miri component)\n - #66082 (clean highlightSourceLines code)\n - #66091 (Implemented the home_dir for VxWorks)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "8be41192c0d558c2b4f16e8c3d174f2b3552d5e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8be41192c0d558c2b4f16e8c3d174f2b3552d5e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1423bec54cf2db283b614e527cfd602b481485d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1423bec54cf2db283b614e527cfd602b481485d1", "html_url": "https://github.com/rust-lang/rust/commit/1423bec54cf2db283b614e527cfd602b481485d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1423bec54cf2db283b614e527cfd602b481485d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a1b3b30c6cdd674049b144a3ced7b711de962b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a1b3b30c6cdd674049b144a3ced7b711de962b2", "html_url": "https://github.com/rust-lang/rust/commit/3a1b3b30c6cdd674049b144a3ced7b711de962b2"}, {"sha": "135b7841829c5bb67e584bf57610139f55c7a10f", "url": "https://api.github.com/repos/rust-lang/rust/commits/135b7841829c5bb67e584bf57610139f55c7a10f", "html_url": "https://github.com/rust-lang/rust/commit/135b7841829c5bb67e584bf57610139f55c7a10f"}], "stats": {"total": 369, "additions": 267, "deletions": 102}, "files": [{"sha": "873f5da0537872ab96b6201b267aef47c70ca812", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -208,6 +208,7 @@ name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n  \"serde\",\n+ \"serde_json\",\n  \"toml\",\n ]\n "}, {"sha": "51ba260589f622832aed220ad2d8ff173f5c19db", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 159, "deletions": 8, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -509,32 +509,183 @@ impl<T> MaybeUninit<T> {\n         self.as_ptr().read()\n     }\n \n-    /// Gets a reference to the contained value.\n+    /// Gets a shared reference to the contained value.\n+    ///\n+    /// This can be useful when we want to access a `MaybeUninit` that has been\n+    /// initialized but don't have ownership of the `MaybeUninit` (preventing the use\n+    /// of `.assume_init()`).\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n+    /// Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really\n+    /// is in an initialized state.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ### Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// // Initialize `x`:\n+    /// unsafe { x.as_mut_ptr().write(vec![1, 2, 3]); }\n+    /// // Now that our `MaybeUninit<_>` is known to be initialized, it is okay to\n+    /// // create a shared reference to it:\n+    /// let x: &Vec<u32> = unsafe {\n+    ///     // Safety: `x` has been initialized.\n+    ///     x.get_ref()\n+    /// };\n+    /// assert_eq!(x, &vec![1, 2, 3]);\n+    /// ```\n+    ///\n+    /// ### *Incorrect* usages of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// let x_vec: &Vec<u32> = unsafe { x.get_ref() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::{cell::Cell, mem::MaybeUninit};\n+    ///\n+    /// let b = MaybeUninit::<Cell<bool>>::uninit();\n+    /// // Initialize the `MaybeUninit` using `Cell::set`:\n+    /// unsafe {\n+    ///     b.get_ref().set(true);\n+    ///  // ^^^^^^^^^^^\n+    ///  // Reference to an uninitialized `Cell<bool>`: UB!\n+    /// }\n+    /// ```\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_ref(&self) -> &T {\n+        intrinsics::panic_if_uninhabited::<T>();\n         &*self.value\n     }\n \n-    /// Gets a mutable reference to the contained value.\n+    /// Gets a mutable (unique) reference to the contained value.\n+    ///\n+    /// This can be useful when we want to access a `MaybeUninit` that has been\n+    /// initialized but don't have ownership of the `MaybeUninit` (preventing the use\n+    /// of `.assume_init()`).\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n+    /// Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really\n+    /// is in an initialized state. For instance, `.get_mut()` cannot be used to\n+    /// initialize a `MaybeUninit`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ### Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// # unsafe extern \"C\" fn initialize_buffer(buf: *mut [u8; 2048]) { *buf = [0; 2048] }\n+    /// # #[cfg(FALSE)]\n+    /// extern \"C\" {\n+    ///     /// Initializes *all* the bytes of the input buffer.\n+    ///     fn initialize_buffer(buf: *mut [u8; 2048]);\n+    /// }\n+    ///\n+    /// let mut buf = MaybeUninit::<[u8; 2048]>::uninit();\n+    ///\n+    /// // Initialize `buf`:\n+    /// unsafe { initialize_buffer(buf.as_mut_ptr()); }\n+    /// // Now we know that `buf` has been initialized, so we could `.assume_init()` it.\n+    /// // However, using `.assume_init()` may trigger a `memcpy` of the 2048 bytes.\n+    /// // To assert our buffer has been initialized without copying it, we upgrade\n+    /// // the `&mut MaybeUninit<[u8; 2048]>` to a `&mut [u8; 2048]`:\n+    /// let buf: &mut [u8; 2048] = unsafe {\n+    ///     // Safety: `buf` has been initialized.\n+    ///     buf.get_mut()\n+    /// };\n+    ///\n+    /// // Now we can use `buf` as a normal slice:\n+    /// buf.sort_unstable();\n+    /// assert!(\n+    ///     buf.chunks(2).all(|chunk| chunk[0] <= chunk[1]),\n+    ///     \"buffer is sorted\",\n+    /// );\n+    /// ```\n+    ///\n+    /// ### *Incorrect* usages of this method:\n+    ///\n+    /// You cannot use `.get_mut()` to initialize a value:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut b = MaybeUninit::<bool>::uninit();\n+    /// unsafe {\n+    ///     *b.get_mut() = true;\n+    ///     // We have created a (mutable) reference to an uninitialized `bool`!\n+    ///     // This is undefined behavior.\n+    /// }\n+    /// ```\n+    ///\n+    /// For instance, you cannot [`Read`] into an uninitialized buffer:\n+    ///\n+    /// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::{io, mem::MaybeUninit};\n+    ///\n+    /// fn read_chunk (reader: &'_ mut dyn io::Read) -> io::Result<[u8; 64]>\n+    /// {\n+    ///     let mut buffer = MaybeUninit::<[u8; 64]>::uninit();\n+    ///     reader.read_exact(unsafe { buffer.get_mut() })?;\n+    ///                             // ^^^^^^^^^^^^^^^^\n+    ///                             // (mutable) reference to uninitialized memory!\n+    ///                             // This is undefined behavior.\n+    ///     Ok(unsafe { buffer.assume_init() })\n+    /// }\n+    /// ```\n+    ///\n+    /// Nor can you use direct field access to do field-by-field gradual initialization:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::{mem::MaybeUninit, ptr};\n+    ///\n+    /// struct Foo {\n+    ///     a: u32,\n+    ///     b: u8,\n+    /// }\n+    ///\n+    /// let foo: Foo = unsafe {\n+    ///     let mut foo = MaybeUninit::<Foo>::uninit();\n+    ///     ptr::write(&mut foo.get_mut().a as *mut u32, 1337);\n+    ///                  // ^^^^^^^^^^^^^\n+    ///                  // (mutable) reference to uninitialized memory!\n+    ///                  // This is undefined behavior.\n+    ///     ptr::write(&mut foo.get_mut().b as *mut u8, 42);\n+    ///                  // ^^^^^^^^^^^^^\n+    ///                  // (mutable) reference to uninitialized memory!\n+    ///                  // This is undefined behavior.\n+    ///     foo.assume_init()\n+    /// };\n+    /// ```\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n     // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n     // a final decision about the rules before stabilization.\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n+        intrinsics::panic_if_uninhabited::<T>();\n         &mut *self.value\n     }\n "}, {"sha": "a5b131520c243a7d5250b7eff65cdc95cbc742d2", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -309,11 +309,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n         // position that belongs to it, as opposed to hashing the first\n         // position past it.\n         let span = self.data();\n-\n-        if span.hi < span.lo {\n-            return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n-        }\n-\n         let (file_lo, line_lo, col_lo) = match hcx.source_map()\n                                                   .byte_pos_to_line_and_col(span.lo) {\n             Some(pos) => pos,"}, {"sha": "12ae2c3201547b93a6d1b683d3f2182b8732148b", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -228,12 +228,6 @@ rustc_queries! {\n             cycle_delay_bug\n         }\n \n-        query trivial_dropck_outlives(ty: Ty<'tcx>) -> bool {\n-            anon\n-            no_force\n-            desc { \"checking if `{:?}` has trivial dropck\", ty }\n-        }\n-\n         query adt_dtorck_constraint(\n             _: DefId\n         ) -> Result<DtorckConstraint<'tcx>, NoSolution> {}"}, {"sha": "eaf5971e4592f32044765236d47701f36a4e49a6", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -5,7 +5,6 @@ use std::iter::FromIterator;\n use syntax::source_map::Span;\n use crate::ty::subst::GenericArg;\n use crate::ty::{self, Ty, TyCtxt};\n-use crate::ty::query::Providers;\n \n impl<'cx, 'tcx> At<'cx, 'tcx> {\n     /// Given a type `ty` of some value being dropped, computes a set\n@@ -34,7 +33,7 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n         // Quick check: there are a number of cases that we know do not require\n         // any destructor.\n         let tcx = self.infcx.tcx;\n-        if tcx.trivial_dropck_outlives(ty) {\n+        if trivial_dropck_outlives(tcx, ty) {\n             return InferOk {\n                 value: vec![],\n                 obligations: vec![],\n@@ -208,15 +207,15 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         | ty::Error => true,\n \n         // [T; N] and [T] have same properties as T.\n-        ty::Array(ty, _) | ty::Slice(ty) => tcx.trivial_dropck_outlives(ty),\n+        ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, ty),\n \n         // (T1..Tn) and closures have same properties as T1..Tn --\n         // check if *any* of those are trivial.\n-        ty::Tuple(ref tys) => tys.iter().all(|t| tcx.trivial_dropck_outlives(t.expect_ty())),\n+        ty::Tuple(ref tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t.expect_ty())),\n         ty::Closure(def_id, ref substs) => substs\n             .as_closure()\n             .upvar_tys(def_id, tcx)\n-            .all(|t| tcx.trivial_dropck_outlives(t)),\n+            .all(|t| trivial_dropck_outlives(tcx, t)),\n \n         ty::Adt(def, _) => {\n             if Some(def.did) == tcx.lang_items().manually_drop() {\n@@ -244,10 +243,3 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n     }\n }\n-\n-crate fn provide(p: &mut Providers<'_>) {\n-    *p = Providers {\n-        trivial_dropck_outlives,\n-        ..*p\n-    };\n-}"}, {"sha": "81c3857cbf8d83d407e0a790d8dd0ad705072d39", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -1,5 +1,5 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n-use crate::traits::query::dropck_outlives::DropckOutlivesResult;\n+use crate::traits::query::dropck_outlives::{DropckOutlivesResult, trivial_dropck_outlives};\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n@@ -21,7 +21,7 @@ impl super::QueryTypeOp<'tcx> for DropckOutlives<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n-        if tcx.trivial_dropck_outlives(key.value.dropped_ty) {\n+        if trivial_dropck_outlives(tcx, key.value.dropped_ty) {\n             Some(DropckOutlivesResult::default())\n         } else {\n             None"}, {"sha": "1b1cc423fd457df5eb5c64a8d224c8a15aedab06", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -3407,7 +3407,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     layout::provide(providers);\n     util::provide(providers);\n     constness::provide(providers);\n-    crate::traits::query::dropck_outlives::provide(providers);\n     *providers = ty::query::Providers {\n         asyncness,\n         associated_item,"}, {"sha": "4dabea01c9e46f96591eb2c68d0235d5e7dc5fe5", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -796,11 +796,6 @@ where\n         }\n \n         let span_data = span.data();\n-\n-        if span_data.hi < span_data.lo {\n-            return TAG_INVALID_SPAN.encode(self);\n-        }\n-\n         let (file_lo, line_lo, col_lo) = match self.source_map\n                                                    .byte_pos_to_line_and_col(span_data.lo) {\n             Some(pos) => pos,"}, {"sha": "fa14ce7b03c8ca69a215187cceefe170609f3d9f", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -161,6 +161,7 @@ pub fn target_machine_factory(sess: &Session, optlvl: config::OptLevel, find_fea\n     let cpu = SmallCStr::new(llvm_util::target_cpu(sess));\n     let features = features.join(\",\");\n     let features = CString::new(features).unwrap();\n+    let abi = SmallCStr::new(&sess.target.target.options.llvm_abiname);\n     let is_pie_binary = !find_features && is_pie_binary(sess);\n     let trap_unreachable = sess.target.target.options.trap_unreachable;\n     let emit_stack_size_section = sess.opts.debugging_opts.emit_stack_sizes;\n@@ -170,7 +171,7 @@ pub fn target_machine_factory(sess: &Session, optlvl: config::OptLevel, find_fea\n     Arc::new(move || {\n         let tm = unsafe {\n             llvm::LLVMRustCreateTargetMachine(\n-                triple.as_ptr(), cpu.as_ptr(), features.as_ptr(),\n+                triple.as_ptr(), cpu.as_ptr(), features.as_ptr(), abi.as_ptr(),\n                 code_model,\n                 reloc_model,\n                 opt_level,"}, {"sha": "4dad6ff793c9e36f7d2cc916b4d481b2cdfb0d76", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -1684,6 +1684,7 @@ extern \"C\" {\n     pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n                                        CPU: *const c_char,\n                                        Features: *const c_char,\n+                                       Abi: *const c_char,\n                                        Model: CodeModel,\n                                        Reloc: RelocMode,\n                                        Level: CodeGenOptLevel,"}, {"sha": "f5e49e32834061443452e0fa68eea3e58e8761ad", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -199,6 +199,8 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n                             bb: location.block,\n                             index: 2,\n                         });\n+\n+                        return; // Don't double count `simd_shuffle` candidates\n                     }\n                 }\n "}, {"sha": "e51772220b73f95953529dbde2ed646d09025ca8", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -793,7 +793,10 @@ pub struct TargetOptions {\n     pub merge_functions: MergeFunctions,\n \n     /// Use platform dependent mcount function\n-    pub target_mcount: String\n+    pub target_mcount: String,\n+\n+    /// LLVM ABI name, corresponds to the '-mabi' parameter available in multilib C compilers\n+    pub llvm_abiname: String,\n }\n \n impl Default for TargetOptions {\n@@ -880,6 +883,7 @@ impl Default for TargetOptions {\n             override_export_symbols: None,\n             merge_functions: MergeFunctions::Aliases,\n             target_mcount: \"mcount\".to_string(),\n+            llvm_abiname: \"\".to_string(),\n         }\n     }\n }\n@@ -1196,6 +1200,7 @@ impl Target {\n         key!(override_export_symbols, opt_list);\n         key!(merge_functions, MergeFunctions)?;\n         key!(target_mcount);\n+        key!(llvm_abiname);\n \n         if let Some(array) = obj.find(\"abi-blacklist\").and_then(Json::as_array) {\n             for name in array.iter().filter_map(|abi| abi.as_string()) {\n@@ -1414,6 +1419,7 @@ impl ToJson for Target {\n         target_option_val!(override_export_symbols);\n         target_option_val!(merge_functions);\n         target_option_val!(target_mcount);\n+        target_option_val!(llvm_abiname);\n \n         if default.abi_blacklist != self.options.abi_blacklist {\n             d.insert(\"abi-blacklist\".to_string(), self.options.abi_blacklist.iter()"}, {"sha": "d77ec3010f4b7843d49d68d7d8b0aab1a020b5bc", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::{Canonical, QueryResponse};\n use rustc::traits::query::dropck_outlives::{DropckOutlivesResult, DtorckConstraint};\n+use rustc::traits::query::dropck_outlives::trivial_dropck_outlives;\n use rustc::traits::query::{CanonicalTyGoal, NoSolution};\n use rustc::traits::{TraitEngine, Normalized, ObligationCause, TraitEngineExt};\n use rustc::ty::query::Providers;\n@@ -172,7 +173,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n         return Ok(());\n     }\n \n-    if tcx.trivial_dropck_outlives(ty) {\n+    if trivial_dropck_outlives(tcx, ty) {\n         return Ok(());\n     }\n "}, {"sha": "53e16978ff12b0fde3fcc2b331fca01fb1ae42fd", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 54, "deletions": 42, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -163,59 +163,71 @@ function getSearchElement() {\n \n     var main = document.getElementById(\"main\");\n \n-    function highlightSourceLines(ev) {\n-        // If we're in mobile mode, we should add the sidebar in any case.\n+    function onHashChange(ev) {\n+        // If we're in mobile mode, we should hide the sidebar in any case.\n         hideSidebar();\n-        var elem;\n-        var search = getSearchElement();\n-        var i, from, to, match = window.location.hash.match(/^#?(\\d+)(?:-(\\d+))?$/);\n+        var match = window.location.hash.match(/^#?(\\d+)(?:-(\\d+))?$/);\n         if (match) {\n-            from = parseInt(match[1], 10);\n-            to = from;\n-            if (typeof match[2] !== \"undefined\") {\n-                to = parseInt(match[2], 10);\n-            }\n-            if (to < from) {\n-                var tmp = to;\n-                to = from;\n-                from = tmp;\n-            }\n-            elem = document.getElementById(from);\n-            if (!elem) {\n-                return;\n-            }\n-            if (ev === null) {\n-                var x = document.getElementById(from);\n-                if (x) {\n-                    x.scrollIntoView();\n-                }\n-            }\n-            onEachLazy(document.getElementsByClassName(\"line-numbers\"), function(e) {\n-                onEachLazy(e.getElementsByTagName(\"span\"), function(i_e) {\n-                    removeClass(i_e, \"line-highlighted\");\n-                });\n-            });\n-            for (i = from; i <= to; ++i) {\n-                elem = document.getElementById(i);\n-                if (!elem) {\n-                    break;\n-                }\n-                addClass(elem, \"line-highlighted\");\n-            }\n-        } else if (ev !== null && search && !hasClass(search, \"hidden\") && ev.newURL) {\n+            return highlightSourceLines(match, ev);\n+        }\n+        var search = getSearchElement();\n+        if (ev !== null && search && !hasClass(search, \"hidden\") && ev.newURL) {\n             addClass(search, \"hidden\");\n             removeClass(main, \"hidden\");\n             var hash = ev.newURL.slice(ev.newURL.indexOf(\"#\") + 1);\n             if (browserSupportsHistoryApi()) {\n                 history.replaceState(hash, \"\", \"?search=#\" + hash);\n             }\n-            elem = document.getElementById(hash);\n+            var elem = document.getElementById(hash);\n             if (elem) {\n                 elem.scrollIntoView();\n             }\n         }\n     }\n \n+    function highlightSourceLines(match, ev) {\n+        if (typeof match === \"undefined\") {\n+            // If we're in mobile mode, we should hide the sidebar in any case.\n+            hideSidebar();\n+            match = window.location.hash.match(/^#?(\\d+)(?:-(\\d+))?$/);\n+        }\n+        if (!match) {\n+            return;\n+        }\n+        var from = parseInt(match[1], 10);\n+        var to = from;\n+        if (typeof match[2] !== \"undefined\") {\n+            to = parseInt(match[2], 10);\n+        }\n+        if (to < from) {\n+            var tmp = to;\n+            to = from;\n+            from = tmp;\n+        }\n+        var elem = document.getElementById(from);\n+        if (!elem) {\n+            return;\n+        }\n+        if (!ev) {\n+            var x = document.getElementById(from);\n+            if (x) {\n+                x.scrollIntoView();\n+            }\n+        }\n+        onEachLazy(document.getElementsByClassName(\"line-numbers\"), function(e) {\n+            onEachLazy(e.getElementsByTagName(\"span\"), function(i_e) {\n+                removeClass(i_e, \"line-highlighted\");\n+            });\n+        });\n+        for (var i = from; i <= to; ++i) {\n+            elem = document.getElementById(i);\n+            if (!elem) {\n+                break;\n+            }\n+            addClass(elem, \"line-highlighted\");\n+        }\n+    }\n+\n     function expandSection(id) {\n         var elem = document.getElementById(id);\n         if (elem && isHidden(elem)) {\n@@ -234,8 +246,8 @@ function getSearchElement() {\n         }\n     }\n \n-    highlightSourceLines(null);\n-    window.onhashchange = highlightSourceLines;\n+    highlightSourceLines();\n+    window.onhashchange = onHashChange;\n \n     // Gets the human-readable string for the virtual-key code of the\n     // given KeyboardEvent, ev.\n@@ -358,7 +370,7 @@ function getSearchElement() {\n             var set_fragment = function(name) {\n                 if (browserSupportsHistoryApi()) {\n                     history.replaceState(null, null, \"#\" + name);\n-                    highlightSourceLines(null);\n+                    highlightSourceLines();\n                 } else {\n                     location.replace(\"#\" + name);\n                 }"}, {"sha": "baa6c425d2e7f0e02f0016af24403a222ded7619", "filename": "src/libstd/sys/vxworks/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibstd%2Fsys%2Fvxworks%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibstd%2Fsys%2Fvxworks%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fos.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -287,7 +287,8 @@ pub fn temp_dir() -> PathBuf {\n }\n \n pub fn home_dir() -> Option<PathBuf> {\n-    None\n+    crate::env::var_os(\"HOME\").or_else(|| None\n+    ).map(PathBuf::from)\n }\n \n pub fn exit(code: i32) -> ! {"}, {"sha": "e2a7ea28b9b59c69aec64b8b97b775310c0a462d", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -68,7 +68,7 @@ impl<'a> StringReader<'a> {\n         let end = sess.source_map().lookup_byte_offset(span.hi());\n \n         // Make the range zero-length if the span is invalid.\n-        if span.lo() > span.hi() || begin.sf.start_pos != end.sf.start_pos {\n+        if begin.sf.start_pos != end.sf.start_pos {\n             span = span.shrink_to_lo();\n         }\n "}, {"sha": "d9f618602a40b4bc8f5c56ec0fa1b4b0a862f7b2", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -498,10 +498,6 @@ impl SourceMap {\n     pub fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n         debug!(\"span_to_lines(sp={:?})\", sp);\n \n-        if sp.lo() > sp.hi() {\n-            return Err(SpanLinesError::IllFormedSpan(sp));\n-        }\n-\n         let lo = self.lookup_char_pos(sp.lo());\n         debug!(\"span_to_lines: lo={:?}\", lo);\n         let hi = self.lookup_char_pos(sp.hi());\n@@ -549,10 +545,6 @@ impl SourceMap {\n     fn span_to_source<F>(&self, sp: Span, extract_source: F) -> Result<String, SpanSnippetError>\n         where F: Fn(&str, usize, usize) -> Result<String, SpanSnippetError>\n     {\n-        if sp.lo() > sp.hi() {\n-            return Err(SpanSnippetError::IllFormedSpan(sp));\n-        }\n-\n         let local_begin = self.lookup_byte_offset(sp.lo());\n         let local_end = self.lookup_byte_offset(sp.hi());\n \n@@ -762,14 +754,14 @@ impl SourceMap {\n \n     /// Finds the width of a character, either before or after the provided span.\n     fn find_width_of_character_at_span(&self, sp: Span, forwards: bool) -> u32 {\n-        // Disregard malformed spans and assume a one-byte wide character.\n-        if sp.lo() >= sp.hi() {\n-            debug!(\"find_width_of_character_at_span: early return malformed span\");\n+        let sp = sp.data();\n+        if sp.lo == sp.hi {\n+            debug!(\"find_width_of_character_at_span: early return empty span\");\n             return 1;\n         }\n \n-        let local_begin = self.lookup_byte_offset(sp.lo());\n-        let local_end = self.lookup_byte_offset(sp.hi());\n+        let local_begin = self.lookup_byte_offset(sp.lo);\n+        let local_end = self.lookup_byte_offset(sp.hi);\n         debug!(\"find_width_of_character_at_span: local_begin=`{:?}`, local_end=`{:?}`\",\n                local_begin, local_end);\n "}, {"sha": "dc29b189639ce409625a39fa380161d1493616de", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -1512,7 +1512,6 @@ pub type FileLinesResult = Result<FileLines, SpanLinesError>;\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n pub enum SpanLinesError {\n-    IllFormedSpan(Span),\n     DistinctSources(DistinctSources),\n }\n "}, {"sha": "5b3900ab496114e85d726aba323789ef7a39da9c", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -343,7 +343,7 @@ extern \"C\" const char* LLVMRustGetHostCPUName(size_t *len) {\n \n extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n     const char *TripleStr, const char *CPU, const char *Feature,\n-    LLVMRustCodeModel RustCM, LLVMRustRelocMode RustReloc,\n+    const char *ABIStr, LLVMRustCodeModel RustCM, LLVMRustRelocMode RustReloc,\n     LLVMRustCodeGenOptLevel RustOptLevel, bool UseSoftFloat,\n     bool PositionIndependentExecutable, bool FunctionSections,\n     bool DataSections,\n@@ -374,6 +374,7 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n   Options.FunctionSections = FunctionSections;\n   Options.MCOptions.AsmVerbose = AsmComments;\n   Options.MCOptions.PreserveAsmComments = AsmComments;\n+  Options.MCOptions.ABIName = ABIStr;\n \n   if (TrapUnreachable) {\n     // Tell LLVM to codegen `unreachable` into an explicit trap instruction."}, {"sha": "0bbbabd29989ebce3b5c749a1272be2b9bb5d6ff", "filename": "src/tools/build-manifest/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2FCargo.toml?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -7,3 +7,4 @@ edition = \"2018\"\n [dependencies]\n toml = \"0.5\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n+serde_json = \"1.0\""}, {"sha": "d92924085e7c785694f42f69fc2ebb1aafc99845", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1423bec54cf2db283b614e527cfd602b481485d1/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1423bec54cf2db283b614e527cfd602b481485d1/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=1423bec54cf2db283b614e527cfd602b481485d1", "patch": "@@ -11,10 +11,11 @@ use serde::Serialize;\n \n use std::collections::BTreeMap;\n use std::env;\n-use std::fs;\n+use std::fs::{self, File};\n use std::io::{self, Read, Write};\n use std::path::{PathBuf, Path};\n use std::process::{Command, Stdio};\n+use std::collections::HashMap;\n \n static HOSTS: &[&str] = &[\n     \"aarch64-unknown-linux-gnu\",\n@@ -366,6 +367,7 @@ impl Builder {\n         self.lldb_git_commit_hash = self.git_commit_hash(\"lldb\", \"x86_64-unknown-linux-gnu\");\n         self.miri_git_commit_hash = self.git_commit_hash(\"miri\", \"x86_64-unknown-linux-gnu\");\n \n+        self.check_toolstate();\n         self.digest_and_sign();\n         let manifest = self.build_manifest();\n         self.write_channel_files(&self.rust_release, &manifest);\n@@ -375,6 +377,25 @@ impl Builder {\n         }\n     }\n \n+    /// If a tool does not pass its tests, don't ship it.\n+    /// Right now, we do this only for Miri.\n+    fn check_toolstate(&mut self) {\n+        let toolstates: Option<HashMap<String, String>> =\n+            File::open(self.input.join(\"toolstates-linux.json\")).ok()\n+                .and_then(|f| serde_json::from_reader(&f).ok());\n+        let toolstates = toolstates.unwrap_or_else(|| {\n+            println!(\"WARNING: `toolstates-linux.json` missing/malformed; \\\n+                assuming all tools failed\");\n+            HashMap::default() // Use empty map if anything went wrong.\n+        });\n+        // Mark some tools as missing based on toolstate.\n+        if toolstates.get(\"miri\").map(|s| &*s as &str) != Some(\"test-pass\") {\n+            println!(\"Miri tests are not passing, removing component\");\n+            self.miri_version = None;\n+            self.miri_git_commit_hash = None;\n+        }\n+    }\n+\n     /// Hash all files, compute their signatures, and collect the hashes in `self.digests`.\n     fn digest_and_sign(&mut self) {\n         for file in t!(self.input.read_dir()).map(|e| t!(e).path()) {"}]}