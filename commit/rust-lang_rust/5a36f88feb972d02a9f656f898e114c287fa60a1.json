{"sha": "5a36f88feb972d02a9f656f898e114c287fa60a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMzZmODhmZWI5NzJkMDJhOWY2NTZmODk4ZTExNGMyODdmYTYwYTE=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-12T18:58:55Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:02:48Z"}, "message": "Remove debug_loc from CleanupScope and privatize various helpers", "tree": {"sha": "860ed640c93c830f6e0e349a440d6b470a8b17fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/860ed640c93c830f6e0e349a440d6b470a8b17fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a36f88feb972d02a9f656f898e114c287fa60a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a36f88feb972d02a9f656f898e114c287fa60a1", "html_url": "https://github.com/rust-lang/rust/commit/5a36f88feb972d02a9f656f898e114c287fa60a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a36f88feb972d02a9f656f898e114c287fa60a1/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed989d39a196acc0e7b3d30976a79ccc7c78a849", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed989d39a196acc0e7b3d30976a79ccc7c78a849", "html_url": "https://github.com/rust-lang/rust/commit/ed989d39a196acc0e7b3d30976a79ccc7c78a849"}], "stats": {"total": 221, "additions": 94, "deletions": 127}, "files": [{"sha": "43b8aa8b6c82f35941373ab52f038d44fd7b52bb", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 94, "deletions": 127, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/5a36f88feb972d02a9f656f898e114c287fa60a1/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a36f88feb972d02a9f656f898e114c287fa60a1/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=5a36f88feb972d02a9f656f898e114c287fa60a1", "patch": "@@ -114,13 +114,12 @@\n //! code for `expr` itself is responsible for freeing any other byproducts\n //! that may be in play.\n \n-pub use self::EarlyExitLabel::*;\n+use self::EarlyExitLabel::*;\n \n use llvm::{BasicBlockRef, ValueRef};\n use base::{self, Lifetime};\n use common;\n use common::{BlockAndBuilder, FunctionContext, Funclet};\n-use debuginfo::{DebugLoc};\n use glue;\n use type_::Type;\n use value::Value;\n@@ -130,10 +129,6 @@ pub struct CleanupScope<'tcx> {\n     // Cleanups to run upon scope exit.\n     cleanups: Vec<DropValue<'tcx>>,\n \n-    // The debug location any drop calls generated for this scope will be\n-    // associated with.\n-    debug_loc: DebugLoc,\n-\n     cached_early_exits: Vec<CachedEarlyExit>,\n     cached_landing_pad: Option<BasicBlockRef>,\n }\n@@ -144,18 +139,18 @@ pub struct CustomScopeIndex {\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum EarlyExitLabel {\n+enum EarlyExitLabel {\n     UnwindExit(UnwindKind),\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub enum UnwindKind {\n+enum UnwindKind {\n     LandingPad,\n     CleanupPad(ValueRef),\n }\n \n #[derive(Copy, Clone)]\n-pub struct CachedEarlyExit {\n+struct CachedEarlyExit {\n     label: EarlyExitLabel,\n     cleanup_block: BasicBlockRef,\n     last_cleanup: usize,\n@@ -165,15 +160,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     pub fn push_custom_cleanup_scope(&self) -> CustomScopeIndex {\n         let index = self.scopes_len();\n         debug!(\"push_custom_cleanup_scope(): {}\", index);\n-\n-        // Just copy the debuginfo source location from the enclosing scope\n-        let debug_loc = self.scopes\n-                            .borrow()\n-                            .last()\n-                            .map(|opt_scope| opt_scope.debug_loc)\n-                            .unwrap_or(DebugLoc::None);\n-\n-        self.push_scope(CleanupScope::new(debug_loc));\n+        self.push_scope(CleanupScope::new());\n         CustomScopeIndex { index: index }\n     }\n \n@@ -282,8 +269,67 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             popped_scopes.push(self.pop_scope());\n         }\n \n-        // Check for an existing landing pad in the new topmost scope:\n-        let llbb = self.get_or_create_landing_pad();\n+        // Creates a landing pad for the top scope, if one does not exist.  The\n+        // landing pad will perform all cleanups necessary for an unwind and then\n+        // `resume` to continue error propagation:\n+        //\n+        //     landing_pad -> ... cleanups ... -> [resume]\n+        //\n+        // (The cleanups and resume instruction are created by\n+        // `trans_cleanups_to_exit_scope()`, not in this function itself.)\n+        let mut scopes = self.scopes.borrow_mut();\n+        let last_scope = scopes.last_mut().unwrap();\n+        let llbb = if let Some(llbb) = last_scope.cached_landing_pad {\n+            llbb\n+        } else {\n+            let name = last_scope.block_name(\"unwind\");\n+            let pad_bcx = self.build_new_block(&name[..]);\n+            last_scope.cached_landing_pad = Some(pad_bcx.llbb());\n+            let llpersonality = pad_bcx.fcx().eh_personality();\n+\n+            let val = if base::wants_msvc_seh(self.ccx.sess()) {\n+                // A cleanup pad requires a personality function to be specified, so\n+                // we do that here explicitly (happens implicitly below through\n+                // creation of the landingpad instruction). We then create a\n+                // cleanuppad instruction which has no filters to run cleanup on all\n+                // exceptions.\n+                pad_bcx.set_personality_fn(llpersonality);\n+                let llretval = pad_bcx.cleanup_pad(None, &[]);\n+                UnwindKind::CleanupPad(llretval)\n+            } else {\n+                // The landing pad return type (the type being propagated). Not sure\n+                // what this represents but it's determined by the personality\n+                // function and this is what the EH proposal example uses.\n+                let llretty = Type::struct_(self.ccx,\n+                    &[Type::i8p(self.ccx), Type::i32(self.ccx)],\n+                    false);\n+\n+                // The only landing pad clause will be 'cleanup'\n+                let llretval = pad_bcx.landing_pad(llretty, llpersonality, 1,\n+                    pad_bcx.fcx().llfn);\n+\n+                // The landing pad block is a cleanup\n+                pad_bcx.set_cleanup(llretval);\n+\n+                let addr = match self.landingpad_alloca.get() {\n+                    Some(addr) => addr,\n+                    None => {\n+                        let addr = base::alloca(&pad_bcx, common::val_ty(llretval), \"\");\n+                        Lifetime::Start.call(&pad_bcx, addr);\n+                        self.landingpad_alloca.set(Some(addr));\n+                        addr\n+                    }\n+                };\n+                pad_bcx.store(llretval, addr);\n+                UnwindKind::LandingPad\n+            };\n+\n+            // Generate the cleanup block and branch to it.\n+            let label = UnwindExit(val);\n+            let cleanup_llbb = self.trans_cleanups_to_exit_scope(label);\n+            label.branch(&pad_bcx, cleanup_llbb);\n+            pad_bcx.llbb()\n+        };\n \n         // Push the scopes we removed back on:\n         loop {\n@@ -346,11 +392,8 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     /// breaks. The return value would be the first basic block in that sequence\n     /// (`Cleanup(AST 24)`). The caller could then branch to `Cleanup(AST 24)`\n     /// and it will perform all cleanups and finally branch to the `break_blk`.\n-    fn trans_cleanups_to_exit_scope(&'blk self,\n-                                    label: EarlyExitLabel)\n-                                    -> BasicBlockRef {\n-        debug!(\"trans_cleanups_to_exit_scope label={:?} scopes={}\",\n-               label, self.scopes_len());\n+    fn trans_cleanups_to_exit_scope(&'blk self, label: EarlyExitLabel) -> BasicBlockRef {\n+        debug!(\"trans_cleanups_to_exit_scope label={:?} scopes={}\", label, self.scopes_len());\n \n         let orig_scopes_len = self.scopes_len();\n         let mut prev_llbb;\n@@ -367,36 +410,34 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         // (Presuming that there are no cached exits)\n         loop {\n             if self.scopes_len() == 0 {\n-                match label {\n-                    UnwindExit(val) => {\n-                        // Generate a block that will resume unwinding to the\n-                        // calling function\n-                        let bcx = self.build_new_block(\"resume\");\n-                        match val {\n-                            UnwindKind::LandingPad => {\n-                                let addr = self.landingpad_alloca.get()\n-                                               .unwrap();\n-                                let lp = bcx.load(addr);\n-                                Lifetime::End.call(&bcx, addr);\n-                                if !bcx.sess().target.target.options.custom_unwind_resume {\n-                                    bcx.resume(lp);\n-                                } else {\n-                                    let exc_ptr = bcx.extract_value(lp, 0);\n-                                    bcx.call(\n-                                        bcx.fcx().eh_unwind_resume().reify(bcx.ccx()),\n-                                        &[exc_ptr],\n-                                        bcx.funclet().map(|b| b.bundle()));\n-                                }\n-                            }\n-                            UnwindKind::CleanupPad(_) => {\n-                                let pad = bcx.cleanup_pad(None, &[]);\n-                                bcx.cleanup_ret(pad, None);\n-                            }\n+                let val = match label {\n+                    UnwindExit(val) => val,\n+                };\n+                // Generate a block that will resume unwinding to the\n+                // calling function\n+                let bcx = self.build_new_block(\"resume\");\n+                match val {\n+                    UnwindKind::LandingPad => {\n+                        let addr = self.landingpad_alloca.get().unwrap();\n+                        let lp = bcx.load(addr);\n+                        Lifetime::End.call(&bcx, addr);\n+                        if !bcx.sess().target.target.options.custom_unwind_resume {\n+                            bcx.resume(lp);\n+                        } else {\n+                            let exc_ptr = bcx.extract_value(lp, 0);\n+                            bcx.call(\n+                                bcx.fcx().eh_unwind_resume().reify(bcx.ccx()),\n+                                &[exc_ptr],\n+                                bcx.funclet().map(|b| b.bundle()));\n                         }\n-                        prev_llbb = bcx.llbb();\n-                        break;\n+                    }\n+                    UnwindKind::CleanupPad(_) => {\n+                        let pad = bcx.cleanup_pad(None, &[]);\n+                        bcx.cleanup_ret(pad, None);\n                     }\n                 }\n+                prev_llbb = bcx.llbb();\n+                break;\n             }\n \n             // Pop off the scope, since we may be generating\n@@ -466,85 +507,11 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         assert_eq!(self.scopes_len(), orig_scopes_len);\n         prev_llbb\n     }\n-\n-    /// Creates a landing pad for the top scope, if one does not exist.  The\n-    /// landing pad will perform all cleanups necessary for an unwind and then\n-    /// `resume` to continue error propagation:\n-    ///\n-    ///     landing_pad -> ... cleanups ... -> [resume]\n-    ///\n-    /// (The cleanups and resume instruction are created by\n-    /// `trans_cleanups_to_exit_scope()`, not in this function itself.)\n-    fn get_or_create_landing_pad(&'blk self) -> BasicBlockRef {\n-        let pad_bcx;\n-\n-        debug!(\"get_or_create_landing_pad\");\n-\n-        // Check if a landing pad block exists; if not, create one.\n-        {\n-            let mut scopes = self.scopes.borrow_mut();\n-            let last_scope = scopes.last_mut().unwrap();\n-            match last_scope.cached_landing_pad {\n-                Some(llbb) => return llbb,\n-                None => {\n-                    let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.build_new_block(&name[..]);\n-                    last_scope.cached_landing_pad = Some(pad_bcx.llbb());\n-                }\n-            }\n-        };\n-\n-        let llpersonality = pad_bcx.fcx().eh_personality();\n-\n-        let val = if base::wants_msvc_seh(self.ccx.sess()) {\n-            // A cleanup pad requires a personality function to be specified, so\n-            // we do that here explicitly (happens implicitly below through\n-            // creation of the landingpad instruction). We then create a\n-            // cleanuppad instruction which has no filters to run cleanup on all\n-            // exceptions.\n-            pad_bcx.set_personality_fn(llpersonality);\n-            let llretval = pad_bcx.cleanup_pad(None, &[]);\n-            UnwindKind::CleanupPad(llretval)\n-        } else {\n-            // The landing pad return type (the type being propagated). Not sure\n-            // what this represents but it's determined by the personality\n-            // function and this is what the EH proposal example uses.\n-            let llretty = Type::struct_(self.ccx,\n-                                        &[Type::i8p(self.ccx), Type::i32(self.ccx)],\n-                                        false);\n-\n-            // The only landing pad clause will be 'cleanup'\n-            let llretval = pad_bcx.landing_pad(llretty, llpersonality, 1, pad_bcx.fcx().llfn);\n-\n-            // The landing pad block is a cleanup\n-            pad_bcx.set_cleanup(llretval);\n-\n-            let addr = match self.landingpad_alloca.get() {\n-                Some(addr) => addr,\n-                None => {\n-                    let addr = base::alloca(&pad_bcx, common::val_ty(llretval), \"\");\n-                    Lifetime::Start.call(&pad_bcx, addr);\n-                    self.landingpad_alloca.set(Some(addr));\n-                    addr\n-                }\n-            };\n-            pad_bcx.store(llretval, addr);\n-            UnwindKind::LandingPad\n-        };\n-\n-        // Generate the cleanup block and branch to it.\n-        let label = UnwindExit(val);\n-        let cleanup_llbb = self.trans_cleanups_to_exit_scope(label);\n-        label.branch(&pad_bcx, cleanup_llbb);\n-\n-        return pad_bcx.llbb();\n-    }\n }\n \n impl<'tcx> CleanupScope<'tcx> {\n-    fn new(debug_loc: DebugLoc) -> CleanupScope<'tcx> {\n+    fn new() -> CleanupScope<'tcx> {\n         CleanupScope {\n-            debug_loc: debug_loc,\n             cleanups: vec![],\n             cached_early_exits: vec![],\n             cached_landing_pad: None,"}]}