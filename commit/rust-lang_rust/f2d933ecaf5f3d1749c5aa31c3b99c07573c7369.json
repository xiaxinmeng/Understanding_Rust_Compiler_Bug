{"sha": "f2d933ecaf5f3d1749c5aa31c3b99c07573c7369", "node_id": "C_kwDOAAsO6NoAKGYyZDkzM2VjYWY1ZjNkMTc0OWM1YWEzMWMzYjk5YzA3NTczYzczNjk", "commit": {"author": {"name": "Ddystopia", "email": "alexanderbabak@proton.me", "date": "2023-04-25T13:14:35Z"}, "committer": {"name": "Ddystopia", "email": "alexanderbabak@proton.me", "date": "2023-05-02T15:06:38Z"}, "message": "Add support for local documentation links alongside web documentation links, pending for `target_dir` path and tests", "tree": {"sha": "d9c7995bfe527ac4d3fc70d0ca2b4a247c4ac055", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9c7995bfe527ac4d3fc70d0ca2b4a247c4ac055"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2d933ecaf5f3d1749c5aa31c3b99c07573c7369", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE83x4qCmEA5TzaAMiEJh17BFTUhIFAmRRJv4ACgkQEJh17BFT\nUhKZ7Q//eChaTWlUjEu0dH88zcSDn5nn6s5gnpPnkAFLTPb86gBHY8k2cHEs7AKi\nIv6cndB/HW/zMbRqYwK4MF3A1/xruYclSaKfizQyYHsYBlgnhgvBdOV0P2Ue7p4H\n0oKIMY2voqaaSwVbQl1VCMrsq2K5/vPucCMtVFZhwzhgtDv4f5flRJhk6EHAfkl2\nNGyuoccUsPy1OZpHSamzFfF/MkrA9hbhemqneSmHfl9oM62ByBbtcFWT+zmViayE\nG9YCwAqzcfSTnOHUu3A8E9HzjeUCW8ai0yAThquIDHi17alnqma32fPliuKs10J/\nwUwwd2M4VVKo0Y3fIrVevtVPQZ4UPAWTy7ljkgDH5Nhw5WXfvH1dolXkj15Czpot\nntRBPRXz9PvhxcNRxjqz13NYCg8Jbk/amO2YhgqwoM/Tzmr/eDJBtzaWwueyoaJ9\n0bbeoAVz3SaPpPVTVymgqk1fIO2m5LuRFtYcso+zPOX93eaDuJ/jtQLUiHcHRM+v\nGFeYEizB9Huk83bmmXOJxKol/NYdcxlql5w7PNn+EMouc7YvaBqOJ2J6fDPL9YDV\nGuxYWXT0niCtUVqKu6MAEb1UkFbGto/LAhutsLe+cHfFPchwAAEmmpmlQrpKJ7XP\nONWX31zJGt9KznuNO/bdFtayv+xhWVyb0aHvRRuUNBTi5KkbCoY=\n=hR8q\n-----END PGP SIGNATURE-----", "payload": "tree d9c7995bfe527ac4d3fc70d0ca2b4a247c4ac055\nparent fc888b583d3dd06ea89a3558350dda9440c82f61\nauthor Ddystopia <alexanderbabak@proton.me> 1682428475 +0200\ncommitter Ddystopia <alexanderbabak@proton.me> 1683039998 +0200\n\nAdd support for local documentation links alongside web documentation links, pending for `target_dir` path and tests\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2d933ecaf5f3d1749c5aa31c3b99c07573c7369", "html_url": "https://github.com/rust-lang/rust/commit/f2d933ecaf5f3d1749c5aa31c3b99c07573c7369", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2d933ecaf5f3d1749c5aa31c3b99c07573c7369/comments", "author": {"login": "Ddystopia", "id": 63151578, "node_id": "MDQ6VXNlcjYzMTUxNTc4", "avatar_url": "https://avatars.githubusercontent.com/u/63151578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ddystopia", "html_url": "https://github.com/Ddystopia", "followers_url": "https://api.github.com/users/Ddystopia/followers", "following_url": "https://api.github.com/users/Ddystopia/following{/other_user}", "gists_url": "https://api.github.com/users/Ddystopia/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ddystopia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ddystopia/subscriptions", "organizations_url": "https://api.github.com/users/Ddystopia/orgs", "repos_url": "https://api.github.com/users/Ddystopia/repos", "events_url": "https://api.github.com/users/Ddystopia/events{/privacy}", "received_events_url": "https://api.github.com/users/Ddystopia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ddystopia", "id": 63151578, "node_id": "MDQ6VXNlcjYzMTUxNTc4", "avatar_url": "https://avatars.githubusercontent.com/u/63151578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ddystopia", "html_url": "https://github.com/Ddystopia", "followers_url": "https://api.github.com/users/Ddystopia/followers", "following_url": "https://api.github.com/users/Ddystopia/following{/other_user}", "gists_url": "https://api.github.com/users/Ddystopia/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ddystopia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ddystopia/subscriptions", "organizations_url": "https://api.github.com/users/Ddystopia/orgs", "repos_url": "https://api.github.com/users/Ddystopia/repos", "events_url": "https://api.github.com/users/Ddystopia/events{/privacy}", "received_events_url": "https://api.github.com/users/Ddystopia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc888b583d3dd06ea89a3558350dda9440c82f61", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc888b583d3dd06ea89a3558350dda9440c82f61", "html_url": "https://github.com/rust-lang/rust/commit/fc888b583d3dd06ea89a3558350dda9440c82f61"}], "stats": {"total": 127, "additions": 82, "deletions": 45}, "files": [{"sha": "a291389363b035c9156cdddddb73e8812502edb1", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 74, "deletions": 40, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f2d933ecaf5f3d1749c5aa31c3b99c07573c7369/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2d933ecaf5f3d1749c5aa31c3b99c07573c7369/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=f2d933ecaf5f3d1749c5aa31c3b99c07573c7369", "patch": "@@ -29,8 +29,16 @@ use crate::{\n     FilePosition, Semantics,\n };\n \n-/// Weblink to an item's documentation.\n-pub(crate) type DocumentationLink = String;\n+/// Web and local links to an item's documentation.\n+#[derive(Default, Debug, Clone, PartialEq, Eq)]\n+pub struct DocumentationLinks {\n+    /// The URL to the documentation on docs.rs.\n+    /// Could be invalid.\n+    pub web_url: Option<String>,\n+    /// The URL to the documentation in the local file system.\n+    /// Could be invalid.\n+    pub local_url: Option<String>,\n+}\n \n const MARKDOWN_OPTIONS: Options =\n     Options::ENABLE_FOOTNOTES.union(Options::ENABLE_TABLES).union(Options::ENABLE_TASKLISTS);\n@@ -119,38 +127,38 @@ pub(crate) fn remove_links(markdown: &str) -> String {\n //\n // | VS Code | **rust-analyzer: Open Docs**\n // |===\n-pub(crate) fn external_docs(\n-    db: &RootDatabase,\n-    position: &FilePosition,\n-) -> Option<DocumentationLink> {\n+pub(crate) fn external_docs(db: &RootDatabase, position: &FilePosition) -> DocumentationLinks {\n     let sema = &Semantics::new(db);\n     let file = sema.parse(position.file_id).syntax().clone();\n     let token = pick_best_token(file.token_at_offset(position.offset), |kind| match kind {\n         IDENT | INT_NUMBER | T![self] => 3,\n         T!['('] | T![')'] => 2,\n         kind if kind.is_trivia() => 0,\n         _ => 1,\n-    })?;\n+    });\n+    let Some(token) = token else { return Default::default() };\n     let token = sema.descend_into_macros_single(token);\n \n-    let node = token.parent()?;\n+    let Some(node) = token.parent() else { return Default::default() };\n     let definition = match_ast! {\n         match node {\n-            ast::NameRef(name_ref) => match NameRefClass::classify(sema, &name_ref)? {\n-                NameRefClass::Definition(def) => def,\n-                NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n+            ast::NameRef(name_ref) => match NameRefClass::classify(sema, &name_ref) {\n+                Some(NameRefClass::Definition(def)) => def,\n+                Some(NameRefClass::FieldShorthand { local_ref: _, field_ref }) => {\n                     Definition::Field(field_ref)\n                 }\n+                None => return Default::default(),\n             },\n-            ast::Name(name) => match NameClass::classify(sema, &name)? {\n-                NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-                NameClass::PatFieldShorthand { local_def: _, field_ref } => Definition::Field(field_ref),\n+            ast::Name(name) => match NameClass::classify(sema, &name) {\n+                Some(NameClass::Definition(it) | NameClass::ConstReference(it)) => it,\n+                Some(NameClass::PatFieldShorthand { local_def: _, field_ref }) => Definition::Field(field_ref),\n+                None => return Default::default(),\n             },\n-            _ => return None,\n+            _ => return Default::default(),\n         }\n     };\n \n-    get_doc_link(db, definition)\n+    return get_doc_links(db, definition);\n }\n \n /// Extracts all links from a given markdown text returning the definition text range, link-text\n@@ -308,19 +316,34 @@ fn broken_link_clone_cb(link: BrokenLink<'_>) -> Option<(CowStr<'_>, CowStr<'_>)\n //\n // This should cease to be a problem if RFC2988 (Stable Rustdoc URLs) is implemented\n // https://github.com/rust-lang/rfcs/pull/2988\n-fn get_doc_link(db: &RootDatabase, def: Definition) -> Option<String> {\n-    let (target, file, frag) = filename_and_frag_for_def(db, def)?;\n+fn get_doc_links(db: &RootDatabase, def: Definition) -> DocumentationLinks {\n+    let Some((target, file, frag)) = filename_and_frag_for_def(db, def) else { return Default::default(); };\n \n-    let mut url = get_doc_base_url(db, target)?;\n+    let (mut web_url, mut local_url) = get_doc_base_urls(db, target);\n \n     if let Some(path) = mod_path_of_def(db, target) {\n-        url = url.join(&path).ok()?;\n+        web_url = join_url(web_url, &path);\n+        local_url = join_url(local_url, &path);\n     }\n \n-    url = url.join(&file).ok()?;\n-    url.set_fragment(frag.as_deref());\n+    web_url = join_url(web_url, &file);\n+    local_url = join_url(local_url, &file);\n+\n+    set_fragment_for_url(web_url.as_mut(), frag.as_deref());\n+    set_fragment_for_url(local_url.as_mut(), frag.as_deref());\n \n-    Some(url.into())\n+    return DocumentationLinks {\n+        web_url: web_url.map(|it| it.into()),\n+        local_url: local_url.map(|it| it.into()),\n+    };\n+\n+    fn join_url(base_url: Option<Url>, path: &str) -> Option<Url> {\n+        base_url.and_then(|url| url.join(path).ok())\n+    }\n+\n+    fn set_fragment_for_url(url: Option<&mut Url>, frag: Option<&str>) {\n+        url.map(|url| url.set_fragment(frag));\n+    }\n }\n \n fn rewrite_intra_doc_link(\n@@ -332,7 +355,7 @@ fn rewrite_intra_doc_link(\n     let (link, ns) = parse_intra_doc_link(target);\n \n     let resolved = resolve_doc_path_for_def(db, def, link, ns)?;\n-    let mut url = get_doc_base_url(db, resolved)?;\n+    let mut url = get_doc_base_urls(db, resolved).0?;\n \n     let (_, file, frag) = filename_and_frag_for_def(db, resolved)?;\n     if let Some(path) = mod_path_of_def(db, resolved) {\n@@ -351,7 +374,7 @@ fn rewrite_url_link(db: &RootDatabase, def: Definition, target: &str) -> Option<\n         return None;\n     }\n \n-    let mut url = get_doc_base_url(db, def)?;\n+    let mut url = get_doc_base_urls(db, def).0?;\n     let (def, file, frag) = filename_and_frag_for_def(db, def)?;\n \n     if let Some(path) = mod_path_of_def(db, def) {\n@@ -427,18 +450,26 @@ fn map_links<'e>(\n /// https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n /// ^^^^^^^^^^^^^^^^^^^^^^^^^^\n /// ```\n-fn get_doc_base_url(db: &RootDatabase, def: Definition) -> Option<Url> {\n+fn get_doc_base_urls(db: &RootDatabase, def: Definition) -> (Option<Url>, Option<Url>) {\n+    // TODO: get this is from `CargoWorkspace`\n+    // TODO: get `CargoWorkspace` from `db`\n+    let target_path = \"file:///project/root/target\";\n+    let target_path = Url::parse(target_path).ok();\n+    let local_doc_path = target_path.and_then(|url| url.join(\"doc\").ok());\n+    debug_assert!(local_doc_path.is_some(), \"failed to parse local doc path\");\n+\n     // special case base url of `BuiltinType` to core\n     // https://github.com/rust-lang/rust-analyzer/issues/12250\n     if let Definition::BuiltinType(..) = def {\n-        return Url::parse(\"https://doc.rust-lang.org/nightly/core/\").ok();\n+        let weblink = Url::parse(\"https://doc.rust-lang.org/nightly/core/\").ok();\n+        return (weblink, local_doc_path);\n     };\n \n-    let krate = def.krate(db)?;\n-    let display_name = krate.display_name(db)?;\n+    let Some(krate) = def.krate(db) else { return Default::default() };\n+    let Some(display_name) = krate.display_name(db) else { return Default::default() };\n     let crate_data = &db.crate_graph()[krate.into()];\n     let channel = crate_data.channel.map_or(\"nightly\", ReleaseChannel::as_str);\n-    let base = match &crate_data.origin {\n+    let (web_base, local_base) = match &crate_data.origin {\n         // std and co do not specify `html_root_url` any longer so we gotta handwrite this ourself.\n         // FIXME: Use the toolchains channel instead of nightly\n         CrateOrigin::Lang(\n@@ -447,16 +478,14 @@ fn get_doc_base_url(db: &RootDatabase, def: Definition) -> Option<Url> {\n             | LangCrateOrigin::ProcMacro\n             | LangCrateOrigin::Std\n             | LangCrateOrigin::Test),\n-        ) => {\n-            format!(\"https://doc.rust-lang.org/{channel}/{origin}\")\n-        }\n-        CrateOrigin::Lang(_) => return None,\n+        ) => (Some(format!(\"https://doc.rust-lang.org/{channel}/{origin}\")), None),\n+        CrateOrigin::Lang(_) => return (None, None),\n         CrateOrigin::Rustc { name: _ } => {\n-            format!(\"https://doc.rust-lang.org/{channel}/nightly-rustc/\")\n+            (Some(format!(\"https://doc.rust-lang.org/{channel}/nightly-rustc/\")), None)\n         }\n         CrateOrigin::Local { repo: _, name: _ } => {\n             // FIXME: These should not attempt to link to docs.rs!\n-            krate.get_html_root_url(db).or_else(|| {\n+            let weblink = krate.get_html_root_url(db).or_else(|| {\n                 let version = krate.version(db);\n                 // Fallback to docs.rs. This uses `display_name` and can never be\n                 // correct, but that's what fallbacks are about.\n@@ -468,10 +497,11 @@ fn get_doc_base_url(db: &RootDatabase, def: Definition) -> Option<Url> {\n                     krate = display_name,\n                     version = version.as_deref().unwrap_or(\"*\")\n                 ))\n-            })?\n+            });\n+            (weblink, local_doc_path)\n         }\n         CrateOrigin::Library { repo: _, name } => {\n-            krate.get_html_root_url(db).or_else(|| {\n+            let weblink = krate.get_html_root_url(db).or_else(|| {\n                 let version = krate.version(db);\n                 // Fallback to docs.rs. This uses `display_name` and can never be\n                 // correct, but that's what fallbacks are about.\n@@ -483,10 +513,14 @@ fn get_doc_base_url(db: &RootDatabase, def: Definition) -> Option<Url> {\n                     krate = name,\n                     version = version.as_deref().unwrap_or(\"*\")\n                 ))\n-            })?\n+            });\n+            (weblink, local_doc_path)\n         }\n     };\n-    Url::parse(&base).ok()?.join(&format!(\"{display_name}/\")).ok()\n+    let web_base = web_base\n+        .and_then(|it| Url::parse(&it).ok())\n+        .and_then(|it| it.join(&format!(\"{display_name}/\")).ok());\n+    (web_base, local_base)\n }\n \n /// Get the filename and extension generated for a symbol by rustdoc."}, {"sha": "4a4410ad20f5a48b371ae4dd4ac2e9622c5bf424", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2d933ecaf5f3d1749c5aa31c3b99c07573c7369/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2d933ecaf5f3d1749c5aa31c3b99c07573c7369/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=f2d933ecaf5f3d1749c5aa31c3b99c07573c7369", "patch": "@@ -471,7 +471,7 @@ impl Analysis {\n     pub fn external_docs(\n         &self,\n         position: FilePosition,\n-    ) -> Cancellable<Option<doc_links::DocumentationLink>> {\n+    ) -> Cancellable<doc_links::DocumentationLinks> {\n         self.with_db(|db| doc_links::external_docs(db, &position))\n     }\n "}, {"sha": "47dd571054b84efcbaafb5b1fe5b2f159348c985", "filename": "crates/rust-analyzer/src/handlers/request.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f2d933ecaf5f3d1749c5aa31c3b99c07573c7369/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Frequest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2d933ecaf5f3d1749c5aa31c3b99c07573c7369/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Frequest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Frequest.rs?ref=f2d933ecaf5f3d1749c5aa31c3b99c07573c7369", "patch": "@@ -1535,13 +1535,16 @@ pub(crate) fn handle_semantic_tokens_range(\n pub(crate) fn handle_open_docs(\n     snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentPositionParams,\n-) -> Result<Option<lsp_types::Url>> {\n+) -> Result<(Option<lsp_types::Url>, Option<lsp_types::Url>)> {\n     let _p = profile::span(\"handle_open_docs\");\n     let position = from_proto::file_position(&snap, params)?;\n \n-    let remote = snap.analysis.external_docs(position)?;\n+    let Ok(remote_urls) = snap.analysis.external_docs(position) else { return Ok((None, None)); };\n \n-    Ok(remote.and_then(|remote| Url::parse(&remote).ok()))\n+    let web_url = remote_urls.web_url.and_then(|it| Url::parse(&it).ok());\n+    let local_url = remote_urls.local_url.and_then(|it| Url::parse(&it).ok());\n+\n+    Ok((web_url, local_url))\n }\n \n pub(crate) fn handle_open_cargo_toml("}, {"sha": "9c27f6e1c335a5901239c87c535f30ea3bb0510d", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2d933ecaf5f3d1749c5aa31c3b99c07573c7369/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2d933ecaf5f3d1749c5aa31c3b99c07573c7369/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=f2d933ecaf5f3d1749c5aa31c3b99c07573c7369", "patch": "@@ -508,7 +508,7 @@ pub enum ExternalDocs {}\n \n impl Request for ExternalDocs {\n     type Params = lsp_types::TextDocumentPositionParams;\n-    type Result = Option<lsp_types::Url>;\n+    type Result = (Option<lsp_types::Url>, Option<lsp_types::Url>);\n     const METHOD: &'static str = \"experimental/externalDocs\";\n }\n "}]}