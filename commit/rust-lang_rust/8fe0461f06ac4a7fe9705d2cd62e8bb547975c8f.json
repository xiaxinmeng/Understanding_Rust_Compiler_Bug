{"sha": "8fe0461f06ac4a7fe9705d2cd62e8bb547975c8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZTA0NjFmMDZhYzRhN2ZlOTcwNWQyY2Q2MmU4YmI1NDc5NzVjOGY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-05-15T22:08:52Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-05-15T22:08:52Z"}, "message": "Remove the unused pairwise.rs", "tree": {"sha": "aae19dfde0eb102172e645b491426e478daf823d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aae19dfde0eb102172e645b491426e478daf823d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fe0461f06ac4a7fe9705d2cd62e8bb547975c8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fe0461f06ac4a7fe9705d2cd62e8bb547975c8f", "html_url": "https://github.com/rust-lang/rust/commit/8fe0461f06ac4a7fe9705d2cd62e8bb547975c8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fe0461f06ac4a7fe9705d2cd62e8bb547975c8f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "250bbddb901d0d748a07caf91a10b56e24d40c9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/250bbddb901d0d748a07caf91a10b56e24d40c9b", "html_url": "https://github.com/rust-lang/rust/commit/250bbddb901d0d748a07caf91a10b56e24d40c9b"}], "stats": {"total": 407, "additions": 0, "deletions": 407}, "files": [{"sha": "802671e2c81cf84aaa3fbbfef0ad5a9f64483d28", "filename": "src/rustc/middle/pairwise.rs", "status": "removed", "additions": 0, "deletions": 407, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/250bbddb901d0d748a07caf91a10b56e24d40c9b/src%2Frustc%2Fmiddle%2Fpairwise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250bbddb901d0d748a07caf91a10b56e24d40c9b/src%2Frustc%2Fmiddle%2Fpairwise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpairwise.rs?ref=250bbddb901d0d748a07caf91a10b56e24d40c9b", "patch": "@@ -1,407 +0,0 @@\n-iface lattice<T> {\n-    fn lub(T, T) -> cres<T>;\n-    fn glb(T, T) -> cres<T>;\n-}\n-\n-iface lattice_op<T> {\n-    fn bnd<V:copy>(b: bounds<V>) -> option<V>;\n-    fn with_bnd<V:copy>(b: bounds<V>, v: V) -> bounds<V>;\n-}\n-\n-iface pairwise {\n-    fn infcx() -> infer_ctxt;\n-    fn tag() -> str;\n-\n-    fn c_tys(t1: ty::t, t2: ty::t) -> cres<ty::t>;\n-    fn c_flds(a: ty::field, b: ty::field) -> cres<ty::field>;\n-    fn c_bot(b: ty::t) -> cres<ty::t>;\n-    fn c_mts(a: ty::mt, b: ty::mt) -> cres<ty::mt>;\n-    fn c_contratys(t1: ty::t, t2: ty::t) -> cres<ty::t>;\n-    fn c_protos(p1: ast::proto, p2: ast::proto) -> cres<ast::proto>;\n-    fn c_ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style>;\n-\n-    // Combining regions (along with some specific cases that are\n-    // different for LUB/GLB):\n-    fn c_regions(\n-        a: ty::region, b: ty::region) -> cres<ty::region>;\n-    fn c_regions_scope_scope(\n-        a: ty::region, a_id: ast::node_id,\n-        b: ty::region, b_id: ast::node_id) -> cres<ty::region>;\n-    fn c_regions_free_scope(\n-        a: ty::region, a_id: ast::node_id, a_br: ty::bound_region,\n-        b: ty::region, b_id: ast::node_id) -> cres<ty::region>;\n-}\n-\n-fn c_vars<V:copy vid, PW:pairwise, T:copy to_str st>(\n-    self: PW, vb: vals_and_bindings<V, T>,\n-    a_t: T, a_vid: V, b_vid: V,\n-    c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n-\n-    // The comments in this function are written for LUB and types,\n-    // but they apply equally well to GLB and regions if you inverse\n-    // upper/lower/sub/super/etc.\n-\n-    // Need to find a type that is a supertype of both a and b:\n-    let {root: a_vid, bounds: a_bounds} = self.infcx().get(vb, a_vid);\n-    let {root: b_vid, bounds: b_bounds} = self.infcx().get(vb, b_vid);\n-\n-    #debug[\"%s.c_vars(%s=%s <: %s=%s)\",\n-           self.tag(),\n-           a_vid.to_str(), a_bounds.to_str(self.infcx()),\n-           b_vid.to_str(), b_bounds.to_str(self.infcx())];\n-\n-    if a_vid == b_vid {\n-        ret ok(a_t);\n-    }\n-\n-    // If both A and B have an UB type, then we can just compute the\n-    // LUB of those types:\n-    let a_bnd = self.bnd(a_bounds), b_bnd = self.bnd(b_bounds);\n-    alt (a_bnd, b_bnd) {\n-      (some(a_ty), some(b_ty)) {\n-        alt self.infcx().try {|| c_ts(a_ty, b_ty) } {\n-            ok(t) { ret ok(t); }\n-            err(_) { /*fallthrough */ }\n-        }\n-      }\n-      _ {/*fallthrough*/}\n-    }\n-\n-    // Otherwise, we need to merge A and B into one variable.  We can\n-    // then use either variable as an upper bound:\n-    self.infcx().vars(vb, a_vid, b_vid).then {||\n-        ok(a_t)\n-    }\n-}\n-\n-fn c_var_t<V:copy vid, PW:pairwise, T:copy to_str st>(\n-    self: PW, vb: vals_and_bindings<V, T>,\n-    a_vid: V, b: T,\n-    c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n-\n-    let {root: a_id, bounds: a_bounds} = self.infcx().get(vb, a_vid);\n-\n-    // The comments in this function are written for LUB, but they\n-    // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n-\n-    #debug[\"%s.c_var_ty(%s=%s <: %s)\",\n-           self.tag(),\n-           a_id.to_str(), a_bounds.to_str(self.infcx()),\n-           b.to_str(self.infcx())];\n-\n-    alt self.bnd(a_bounds) {\n-      some(a_bnd) {\n-        // If a has an upper bound, return it.\n-        ret c_ts(a_bnd, b);\n-      }\n-      none {\n-        // If a does not have an upper bound, make b the upper bound of a\n-        // and then return b.\n-        let a_bounds = self.with_bnd(a_bounds, b);\n-        self.infcx().bnds(a_bounds.lb, a_bounds.ub).then {||\n-            self.infcx().set(vb, a_id, bounded(a_bounds));\n-            ok(b)\n-        }\n-      }\n-    }\n-}\n-\n-fn c_tuptys<PW:pairwise>(self: PW, as: [ty::t], bs: [ty::t])\n-    -> cres<[ty::t]> {\n-\n-    if check vec::same_length(as, bs) {\n-        map2(as, bs) {|a, b| self.c_tys(a, b) }\n-    } else {\n-        err(ty::terr_tuple_size(as.len(), bs.len()))\n-    }\n-}\n-\n-fn c_tps<PW:pairwise>(self: PW, _did: ast::def_id, as: [ty::t], bs: [ty::t])\n-    -> cres<[ty::t]> {\n-    // FIXME #1973 lookup the declared variance of the type parameters\n-    // based on did\n-    if check vec::same_length(as, bs) {\n-        map2(as, bs) {|a,b| self.c_tys(a, b) }\n-    } else {\n-        err(ty::terr_ty_param_size(as.len(), bs.len()))\n-    }\n-}\n-\n-fn c_fieldvecs<PW:pairwise>(\n-    self: PW, as: [ty::field], bs: [ty::field])\n-    -> cres<[ty::field]> {\n-\n-    if check vec::same_length(as, bs) {\n-        map2(as, bs) {|a,b| self.c_flds(a, b) }\n-    } else {\n-        err(ty::terr_record_size(as.len(), bs.len()))\n-    }\n-}\n-\n-fn c_flds<PW:pairwise>(\n-    self: PW, a: ty::field, b: ty::field) -> cres<ty::field> {\n-\n-    if a.ident == b.ident {\n-        self.c_mts(a.mt, b.mt).chain {|mt|\n-            ok({ident: a.ident, mt: mt})\n-        }\n-    } else {\n-        err(ty::terr_record_fields(a.ident, b.ident))\n-    }\n-}\n-\n-fn c_modes<PW:pairwise>(\n-    self: PW, a: ast::mode, b: ast::mode)\n-    -> cres<ast::mode> {\n-\n-    let tcx = self.infcx().tcx;\n-    ty::unify_mode(tcx, a, b)\n-}\n-\n-fn c_args<PW:pairwise>(\n-    self: PW, a: ty::arg, b: ty::arg)\n-    -> cres<ty::arg> {\n-\n-    self.c_modes(a.mode, b.mode).chain {|m|\n-        // Note: contravariant\n-        self.c_contratys(b.ty, a.ty).chain {|t|\n-            ok({mode: m, ty: t})\n-        }\n-    }\n-}\n-\n-fn c_argvecs<PW:pairwise>(\n-    self: PW, a_args: [ty::arg], b_args: [ty::arg]) -> cres<[ty::arg]> {\n-\n-    if check vec::same_length(a_args, b_args) {\n-        map2(a_args, b_args) {|a, b| self.c_args(a, b) }\n-    } else {\n-        err(ty::terr_arg_count)\n-    }\n-}\n-\n-fn c_fns<PW:pairwise>(\n-    self: PW, a_f: ty::fn_ty, b_f: ty::fn_ty) -> cres<ty::fn_ty> {\n-\n-    self.c_protos(a_f.proto, b_f.proto).chain {|p|\n-        self.c_ret_styles(a_f.ret_style, b_f.ret_style).chain {|rs|\n-            self.c_argvecs(a_f.inputs, b_f.inputs).chain {|inputs|\n-                self.c_tys(a_f.output, b_f.output).chain {|output|\n-                    //FIXME self.infcx().constrvecs(a_f.constraints,\n-                    //FIXME                         b_f.constraints).then {||\n-                        ok({proto: p,\n-                            inputs: inputs,\n-                            output: output,\n-                            ret_style: rs,\n-                            constraints: a_f.constraints})\n-                    //FIXME }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn c_tys<PW:pairwise>(\n-    self: PW, a: ty::t, b: ty::t) -> cres<ty::t> {\n-\n-    let tcx = self.infcx().tcx;\n-\n-    #debug(\"%s.c_tys(%s, %s)\",\n-           self.tag(),\n-           ty_to_str(tcx, a),\n-           ty_to_str(tcx, b));\n-\n-    // Fast path.\n-    if a == b { ret ok(a); }\n-\n-    alt (ty::get(a).struct, ty::get(b).struct) {\n-      (ty::ty_bot, _) { self.c_bot(b) }\n-      (_, ty::ty_bot) { self.c_bot(b) }\n-\n-      (ty::ty_var(a_id), ty::ty_var(b_id)) {\n-        self.c_vars(self.infcx().vb,\n-               a, a_id, b_id,\n-               {|x, y| self.c_tys(x, y) })\n-      }\n-\n-      // Note that the LUB/GLB operations are commutative:\n-      (ty::ty_var(v_id), _) {\n-        self.c_var_t(self.infcx().vb,\n-                v_id, b,\n-                {|x, y| self.c_tys(x, y) })\n-      }\n-      (_, ty::ty_var(v_id)) {\n-        self.c_var_t(self.infcx().vb,\n-                v_id, a,\n-                {|x, y| self.c_tys(x, y) })\n-      }\n-\n-      (ty::ty_nil, _) |\n-      (ty::ty_bool, _) |\n-      (ty::ty_int(_), _) |\n-      (ty::ty_uint(_), _) |\n-      (ty::ty_float(_), _) |\n-      (ty::ty_str, _) {\n-        let cfg = tcx.sess.targ_cfg;\n-        if ty::mach_sty(cfg, a) == ty::mach_sty(cfg, b) {\n-            ok(a)\n-        } else {\n-            err(ty::terr_mismatch)\n-        }\n-      }\n-\n-      (ty::ty_param(a_n, _), ty::ty_param(b_n, _)) if a_n == b_n {\n-        ok(a)\n-      }\n-\n-      (ty::ty_enum(a_id, a_tps), ty::ty_enum(b_id, b_tps))\n-      if a_id == b_id {\n-        self.c_tps(a_id, a_tps, b_tps).chain {|tps|\n-            ok(ty::mk_enum(tcx, a_id, tps))\n-        }\n-      }\n-\n-      (ty::ty_iface(a_id, a_tps), ty::ty_iface(b_id, b_tps))\n-      if a_id == b_id {\n-        self.c_tps(a_id, a_tps, b_tps).chain {|tps|\n-            ok(ty::mk_iface(tcx, a_id, tps))\n-        }\n-      }\n-\n-      (ty::ty_class(a_id, a_tps), ty::ty_class(b_id, b_tps))\n-      if a_id == b_id {\n-        // FIXME variance\n-        self.c_tps(a_id, a_tps, b_tps).chain {|tps|\n-            ok(ty::mk_class(tcx, a_id, tps))\n-        }\n-      }\n-\n-      (ty::ty_box(a_mt), ty::ty_box(b_mt)) {\n-        self.c_mts(a_mt, b_mt).chain {|mt|\n-            ok(ty::mk_box(tcx, mt))\n-        }\n-      }\n-\n-      (ty::ty_uniq(a_mt), ty::ty_uniq(b_mt)) {\n-        self.c_mts(a_mt, b_mt).chain {|mt|\n-            ok(ty::mk_uniq(tcx, mt))\n-        }\n-      }\n-\n-      (ty::ty_vec(a_mt), ty::ty_vec(b_mt)) {\n-        self.c_mts(a_mt, b_mt).chain {|mt|\n-            ok(ty::mk_vec(tcx, mt))\n-        }\n-      }\n-\n-      (ty::ty_ptr(a_mt), ty::ty_ptr(b_mt)) {\n-        self.c_mts(a_mt, b_mt).chain {|mt|\n-            ok(ty::mk_ptr(tcx, mt))\n-        }\n-      }\n-\n-      (ty::ty_rptr(a_r, a_mt), ty::ty_rptr(b_r, b_mt)) {\n-        self.c_regions(a_r, b_r).chain {|r|\n-            self.c_mts(a_mt, b_mt).chain {|mt|\n-                ok(ty::mk_rptr(tcx, r, mt))\n-            }\n-        }\n-      }\n-\n-      (ty::ty_res(a_id, a_t, a_tps), ty::ty_res(b_id, b_t, b_tps))\n-      if a_id == b_id {\n-        self.c_tys(a_t, b_t).chain {|t|\n-            self.c_tps(a_id, a_tps, b_tps).chain {|tps|\n-                ok(ty::mk_res(tcx, a_id, t, tps))\n-            }\n-        }\n-      }\n-\n-      (ty::ty_rec(a_fields), ty::ty_rec(b_fields)) {\n-        self.c_fieldvecs(a_fields, b_fields).chain {|fs|\n-            ok(ty::mk_rec(tcx, fs))\n-        }\n-      }\n-\n-      (ty::ty_tup(a_tys), ty::ty_tup(b_tys)) {\n-        self.c_tuptys(a_tys, b_tys).chain {|ts|\n-            ok(ty::mk_tup(tcx, ts))\n-        }\n-      }\n-\n-      (ty::ty_fn(a_fty), ty::ty_fn(b_fty)) {\n-        self.c_fns(a_fty, b_fty).chain {|fty|\n-            ok(ty::mk_fn(tcx, fty))\n-        }\n-      }\n-\n-      (ty::ty_constr(a_t, a_constrs), ty::ty_constr(b_t, b_constrs)) {\n-        self.c_tys(a_t, b_t).chain {|t|\n-            self.infcx().constrvecs(a_constrs, b_constrs).then {||\n-                ok(ty::mk_constr(tcx, t, a_constrs))\n-            }\n-        }\n-      }\n-\n-      _ { err(ty::terr_mismatch) }\n-    }\n-}\n-\n-fn c_regions<PW:pairwise>(\n-    self: PW, a: ty::region, b: ty::region) -> cres<ty::region> {\n-\n-    #debug[\"%s.c_regions(%?, %?)\",\n-           self.tag(),\n-           a.to_str(self.infcx()),\n-           b.to_str(self.infcx())];\n-\n-    alt (a, b) {\n-      (ty::re_var(a_id), ty::re_var(b_id)) {\n-        self.c_vars(self.infcx().rb,\n-               a, a_id, b_id,\n-               {|x, y| self.c_regions(x, y) })\n-      }\n-\n-      (ty::re_var(v_id), r) |\n-      (r, ty::re_var(v_id)) {\n-        self.c_var_t(self.infcx().rb,\n-                v_id, r,\n-                {|x, y| self.c_regions(x, y) })\n-      }\n-\n-      (f @ ty::re_free(f_id, f_br), s @ ty::re_scope(s_id)) |\n-      (s @ ty::re_scope(s_id), f @ ty::re_free(f_id, f_br)) {\n-        self.c_regions_free_scope(f, f_id, f_br, s, s_id)\n-      }\n-\n-      (ty::re_scope(a_id), ty::re_scope(b_id)) {\n-        self.c_regions_scope_scope(a, a_id, b, b_id)\n-      }\n-\n-      // For these types, we cannot define any additional relationship:\n-      (ty::re_free(_, _), ty::re_free(_, _)) |\n-      (ty::re_bound(_), ty::re_bound(_)) |\n-      (ty::re_bound(_), ty::re_free(_, _)) |\n-      (ty::re_bound(_), ty::re_scope(_)) |\n-      (ty::re_free(_, _), ty::re_bound(_)) |\n-      (ty::re_scope(_), ty::re_bound(_)) {\n-        if a == b {\n-            #debug[\"... yes, %s == %s.\",\n-                   a.to_str(self.infcx()),\n-                   b.to_str(self.infcx())];\n-            ok(a)\n-        } else {\n-            #debug[\"... no, %s != %s.\",\n-                   a.to_str(self.infcx()),\n-                   b.to_str(self.infcx())];\n-            err(ty::terr_regions_differ(false, b, a))\n-        }\n-      }\n-\n-      (ty::re_default, _) |\n-      (_, ty::re_default) {\n-        // actually a compiler bug, I think.\n-        err(ty::terr_regions_differ(false, b, a))\n-      }\n-    }\n-}"}]}