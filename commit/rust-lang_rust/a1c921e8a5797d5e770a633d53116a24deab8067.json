{"sha": "a1c921e8a5797d5e770a633d53116a24deab8067", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYzkyMWU4YTU3OTdkNWU3NzBhNjMzZDUzMTE2YTI0ZGVhYjgwNjc=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-09-19T20:28:21Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-10-01T19:29:30Z"}, "message": "don't duplicate item types between encoder <-> astencode\n\na 5% win on libcore\n\n512576 liballoc-bb943c5a.rlib\n1425106 liballoc_jemalloc-bb943c5a.rlib\n10070 liballoc_system-bb943c5a.rlib\n141332 libarena-bb943c5a.rlib\n3611586 libcollections-bb943c5a.rlib\n16293400 libcore-bb943c5a.rlib\n195018 libflate-bb943c5a.rlib\n231940 libfmt_macros-bb943c5a.rlib\n532704 libgetopts-bb943c5a.rlib\n208094 libgraphviz-bb943c5a.rlib\n383522 liblibc-bb943c5a.rlib\n183786 liblog-bb943c5a.rlib\n658332 librand-bb943c5a.rlib\n567676 librbml-bb943c5a.rlib\n1376114 librustc_back-bb943c5a.rlib\n37134688 librustc-bb943c5a.rlib\n12826 librustc_bitflags-bb943c5a.rlib\n2241942 librustc_borrowck-bb943c5a.rlib\n513598 librustc_data_structures-bb943c5a.rlib\n9340348 librustc_driver-bb943c5a.rlib\n8880472 librustc_front-bb943c5a.rlib\n1590548 librustc_lint-bb943c5a.rlib\n79149202 librustc_llvm-bb943c5a.rlib\n4536740 librustc_mir-bb943c5a.rlib\n3528866 librustc_platform_intrinsics-bb943c5a.rlib\n588514 librustc_privacy-bb943c5a.rlib\n3068562 librustc_resolve-bb943c5a.rlib\n13982508 librustc_trans-bb943c5a.rlib\n11799790 librustc_typeck-bb943c5a.rlib\n1637532 librustc_unicode-bb943c5a.rlib\n15611582 librustdoc-bb943c5a.rlib\n2649520 libserialize-bb943c5a.rlib\n8095050 libstd-bb943c5a.rlib\n29391260 libsyntax-bb943c5a.rlib\n891210 libterm-bb943c5a.rlib", "tree": {"sha": "b37cacdd3be477781777988af4173fa495de1774", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b37cacdd3be477781777988af4173fa495de1774"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1c921e8a5797d5e770a633d53116a24deab8067", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1c921e8a5797d5e770a633d53116a24deab8067", "html_url": "https://github.com/rust-lang/rust/commit/a1c921e8a5797d5e770a633d53116a24deab8067", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1c921e8a5797d5e770a633d53116a24deab8067/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b74219964c1e86129cffc952a5e2ed3c03f052c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b74219964c1e86129cffc952a5e2ed3c03f052c1", "html_url": "https://github.com/rust-lang/rust/commit/b74219964c1e86129cffc952a5e2ed3c03f052c1"}], "stats": {"total": 171, "additions": 52, "deletions": 119}, "files": [{"sha": "e27178b32f9e2f9de093ce4bdc4e711541b5388f", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1c921e8a5797d5e770a633d53116a24deab8067/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c921e8a5797d5e770a633d53116a24deab8067/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=a1c921e8a5797d5e770a633d53116a24deab8067", "patch": "@@ -125,7 +125,7 @@ enum_from_u32! {\n         tag_table_node_type = 0x57,\n         tag_table_item_subst = 0x58,\n         tag_table_freevars = 0x59,\n-        tag_table_tcache = 0x5a,\n+        // GAP 0x5a\n         tag_table_param_defs = 0x5b,\n         // GAP 0x5c, 0x5d, 0x5e\n         tag_table_method_map = 0x5f,"}, {"sha": "a6a048710369bc5a731b297da0cbfdea4c17dc6b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 51, "deletions": 118, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/a1c921e8a5797d5e770a633d53116a24deab8067/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c921e8a5797d5e770a633d53116a24deab8067/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a1c921e8a5797d5e770a633d53116a24deab8067", "patch": "@@ -35,7 +35,6 @@ use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::privacy::{AllPublic, LastMod};\n use middle::region;\n use middle::subst;\n-use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty};\n \n use syntax::{ast, ast_util, codemap};\n@@ -167,6 +166,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                name);\n         region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n         decode_side_tables(dcx, ast_doc);\n+        copy_item_types(dcx, ii);\n         match *ii {\n           InlinedItem::Item(ref i) => {\n             debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n@@ -205,6 +205,17 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n         (id.wrapping_sub(self.from_id_range.min).wrapping_add(self.to_id_range.min))\n     }\n \n+    /// Gets the original crate's DefId from a translated internal\n+    /// def-id.\n+    pub fn reverse_tr_id(&self, id: ast::NodeId) -> DefId {\n+        // from_id_range should be non-empty\n+        assert!(!self.from_id_range.empty());\n+        // Use wrapping arithmetic because otherwise it introduces control flow.\n+        // Maybe we should just have the control flow? -- aatch\n+        let node = id.wrapping_sub(self.to_id_range.min).wrapping_add(self.from_id_range.min);\n+        DefId { krate: self.cdata.cnum, node: node }\n+    }\n+\n     /// Translates an EXTERNAL def-id, converting the crate number from the one used in the encoded\n     /// data to the current crate numbers..  By external, I mean that it be translated to a\n     /// reference to the item in its original crate, as opposed to being translated to a reference\n@@ -576,36 +587,6 @@ pub fn encode_cast_kind(ebml_w: &mut Encoder, kind: cast::CastKind) {\n     kind.encode(ebml_w).unwrap();\n }\n \n-pub trait vtable_decoder_helpers<'tcx> {\n-    fn read_vec_per_param_space<T, F>(&mut self, f: F) -> VecPerParamSpace<T> where\n-        F: FnMut(&mut Self) -> T;\n-}\n-\n-impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n-    fn read_vec_per_param_space<T, F>(&mut self, mut f: F) -> VecPerParamSpace<T> where\n-        F: FnMut(&mut reader::Decoder<'a>) -> T,\n-    {\n-        let types = self.read_to_vec(|this| Ok(f(this))).unwrap();\n-        let selfs = self.read_to_vec(|this| Ok(f(this))).unwrap();\n-        let fns = self.read_to_vec(|this| Ok(f(this))).unwrap();\n-        VecPerParamSpace::new(types, selfs, fns)\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-//\n-\n-fn encode_vec_per_param_space<T, F>(rbml_w: &mut Encoder,\n-                                    v: &subst::VecPerParamSpace<T>,\n-                                    mut f: F) where\n-    F: FnMut(&mut Encoder, &T),\n-{\n-    for &space in &subst::ParamSpace::all() {\n-        rbml_w.emit_from_vec(v.get_slice(space),\n-                             |rbml_w, n| Ok(f(rbml_w, n))).unwrap();\n-    }\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding the side tables\n \n@@ -632,14 +613,10 @@ trait rbml_writer_helpers<'tcx> {\n     fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]);\n     fn emit_type_param_def<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                type_param_def: &ty::TypeParameterDef<'tcx>);\n-    fn emit_region_param_def(&mut self, ecx: &e::EncodeContext,\n-                             region_param_def: &ty::RegionParameterDef);\n     fn emit_predicate<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                           predicate: &ty::Predicate<'tcx>);\n     fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                           ty: &ty::TraitRef<'tcx>);\n-    fn emit_type_scheme<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                            type_scheme: ty::TypeScheme<'tcx>);\n     fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                        substs: &subst::Substs<'tcx>);\n     fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n@@ -688,14 +665,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                                          type_param_def))\n         });\n     }\n-    fn emit_region_param_def(&mut self, ecx: &e::EncodeContext,\n-                             region_param_def: &ty::RegionParameterDef) {\n-        self.emit_opaque(|this| {\n-            Ok(tyencode::enc_region_param_def(this,\n-                                              &ecx.ty_str_ctxt(),\n-                                              region_param_def))\n-        });\n-    }\n+\n     fn emit_predicate<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                           predicate: &ty::Predicate<'tcx>) {\n         self.emit_opaque(|this| {\n@@ -705,32 +675,6 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_type_scheme<'b>(&mut self,\n-                            ecx: &e::EncodeContext<'b, 'tcx>,\n-                            type_scheme: ty::TypeScheme<'tcx>) {\n-        use serialize::Encoder;\n-\n-        self.emit_struct(\"TypeScheme\", 2, |this| {\n-            this.emit_struct_field(\"generics\", 0, |this| {\n-                this.emit_struct(\"Generics\", 2, |this| {\n-                    this.emit_struct_field(\"types\", 0, |this| {\n-                        Ok(encode_vec_per_param_space(\n-                            this, &type_scheme.generics.types,\n-                            |this, def| this.emit_type_param_def(ecx, def)))\n-                    });\n-                    this.emit_struct_field(\"regions\", 1, |this| {\n-                        Ok(encode_vec_per_param_space(\n-                            this, &type_scheme.generics.regions,\n-                            |this, def| this.emit_region_param_def(ecx, def)))\n-                    })\n-                })\n-            });\n-            this.emit_struct_field(\"ty\", 1, |this| {\n-                Ok(this.emit_ty(ecx, type_scheme.ty))\n-            })\n-        });\n-    }\n-\n     fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n                                    bounds: &ty::ExistentialBounds<'tcx>) {\n         self.emit_opaque(|this| Ok(tyencode::enc_existential_bounds(this,\n@@ -950,14 +894,6 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    let lid = DefId { krate: LOCAL_CRATE, node: id };\n-    if let Some(type_scheme) = tcx.tcache.borrow().get(&lid) {\n-        rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.emit_type_scheme(ecx, type_scheme.clone());\n-        })\n-    }\n-\n     if let Some(type_param_def) = tcx.ty_param_defs.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_param_defs, |rbml_w| {\n             rbml_w.id(id);\n@@ -1051,12 +987,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                    -> ty::PolyTraitRef<'tcx>;\n     fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> ty::TypeParameterDef<'tcx>;\n-    fn read_region_param_def(&mut self, dcx: &DecodeContext)\n-                             -> ty::RegionParameterDef;\n     fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                               -> ty::Predicate<'tcx>;\n-    fn read_type_scheme<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                -> ty::TypeScheme<'tcx>;\n     fn read_existential_bounds<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                        -> ty::ExistentialBounds<'tcx>;\n     fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1177,44 +1109,13 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                    -> ty::TypeParameterDef<'tcx> {\n         self.read_ty_encoded(dcx, |decoder| decoder.parse_type_param_def())\n     }\n-    fn read_region_param_def(&mut self, dcx: &DecodeContext)\n-                             -> ty::RegionParameterDef {\n-        self.read_ty_encoded(dcx, |decoder| decoder.parse_region_param_def())\n-    }\n+\n     fn read_predicate<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                               -> ty::Predicate<'tcx>\n     {\n         self.read_ty_encoded(dcx, |decoder| decoder.parse_predicate())\n     }\n \n-    fn read_type_scheme<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                -> ty::TypeScheme<'tcx> {\n-        self.read_struct(\"TypeScheme\", 3, |this| {\n-            Ok(ty::TypeScheme {\n-                generics: this.read_struct_field(\"generics\", 0, |this| {\n-                    this.read_struct(\"Generics\", 2, |this| {\n-                        Ok(ty::Generics {\n-                            types:\n-                            this.read_struct_field(\"types\", 0, |this| {\n-                                Ok(this.read_vec_per_param_space(\n-                                    |this| this.read_type_param_def(dcx)))\n-                            }).unwrap(),\n-\n-                            regions:\n-                            this.read_struct_field(\"regions\", 1, |this| {\n-                                Ok(this.read_vec_per_param_space(\n-                                    |this| this.read_region_param_def(dcx)))\n-                            }).unwrap(),\n-                        })\n-                    })\n-                }).unwrap(),\n-                ty: this.read_struct_field(\"ty\", 1, |this| {\n-                    Ok(this.read_ty(dcx))\n-                }).unwrap()\n-            })\n-        }).unwrap()\n-    }\n-\n     fn read_existential_bounds<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                        -> ty::ExistentialBounds<'tcx>\n     {\n@@ -1450,11 +1351,6 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         let ub = val_dsr.read_upvar_capture(dcx);\n                         dcx.tcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub);\n                     }\n-                    c::tag_table_tcache => {\n-                        let type_scheme = val_dsr.read_type_scheme(dcx);\n-                        let lid = DefId { krate: LOCAL_CRATE, node: id };\n-                        dcx.tcx.register_item_type(lid, type_scheme);\n-                    }\n                     c::tag_table_param_defs => {\n                         let bounds = val_dsr.read_type_param_def(dcx);\n                         dcx.tcx.ty_param_defs.borrow_mut().insert(id, bounds);\n@@ -1506,6 +1402,43 @@ fn decode_side_tables(dcx: &DecodeContext,\n     }\n }\n \n+// copy the tcache entries from the original item to the new\n+// inlined item\n+fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem) {\n+    fn copy_item_type(dcx: &DecodeContext, inlined_node: ast::NodeId) {\n+        let inlined_did = DefId::local(inlined_node);\n+        let remote_did = dcx.reverse_tr_id(inlined_node);\n+        dcx.tcx.register_item_type(inlined_did,\n+                                   dcx.tcx.lookup_item_type(remote_did));\n+\n+    }\n+    // copy the entry for the item itself\n+    let item_node_id = match ii {\n+        &InlinedItem::Item(ref i) => i.id,\n+        &InlinedItem::TraitItem(_, ref ti) => ti.id,\n+        &InlinedItem::ImplItem(_, ref ii) => ii.id,\n+        &InlinedItem::Foreign(ref fi) => fi.id\n+    };\n+    copy_item_type(dcx, item_node_id);\n+\n+    // copy the entries of inner items\n+    if let &InlinedItem::Item(ref item) = ii {\n+        match item.node {\n+            hir::ItemEnum(ref def, _) => {\n+                for variant in &def.variants {\n+                    copy_item_type(dcx, variant.node.id);\n+                }\n+            }\n+            hir::ItemStruct(ref def, _) => {\n+                if let Some(ctor_id) = def.ctor_id {\n+                    copy_item_type(dcx, ctor_id);\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n // ______________________________________________________________________\n // Testing of astencode_gen\n "}]}