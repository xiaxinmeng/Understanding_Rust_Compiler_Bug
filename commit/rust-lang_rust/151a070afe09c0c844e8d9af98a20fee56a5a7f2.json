{"sha": "151a070afe09c0c844e8d9af98a20fee56a5a7f2", "node_id": "C_kwDOAAsO6NoAKDE1MWEwNzBhZmUwOWMwYzg0NGU4ZDlhZjk4YTIwZmVlNTZhNWE3ZjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-06T07:25:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-06T07:25:50Z"}, "message": "Auto merge of #104872 - luqmana:packed-union-align, r=oli-obk\n\nAvoid alignment mismatch between ABI and layout for unions.\n\nFixes #104802\nFixes #103634\n\nr? `@eddyb` cc `@RalfJung`", "tree": {"sha": "4eeea10607f3966e9f495576439b1a6817aaa7a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eeea10607f3966e9f495576439b1a6817aaa7a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/151a070afe09c0c844e8d9af98a20fee56a5a7f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/151a070afe09c0c844e8d9af98a20fee56a5a7f2", "html_url": "https://github.com/rust-lang/rust/commit/151a070afe09c0c844e8d9af98a20fee56a5a7f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/151a070afe09c0c844e8d9af98a20fee56a5a7f2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e96802bf51f4f847f2c1457bcb93385e76ab172", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e96802bf51f4f847f2c1457bcb93385e76ab172", "html_url": "https://github.com/rust-lang/rust/commit/6e96802bf51f4f847f2c1457bcb93385e76ab172"}, {"sha": "8e7714d3bb81e41ed3e812415626acbabd20ff02", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e7714d3bb81e41ed3e812415626acbabd20ff02", "html_url": "https://github.com/rust-lang/rust/commit/8e7714d3bb81e41ed3e812415626acbabd20ff02"}], "stats": {"total": 478, "additions": 397, "deletions": 81}, "files": [{"sha": "3d97d9b489508a8004023841fe3d921bf89260b9", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 51, "deletions": 20, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/151a070afe09c0c844e8d9af98a20fee56a5a7f2/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151a070afe09c0c844e8d9af98a20fee56a5a7f2/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=151a070afe09c0c844e8d9af98a20fee56a5a7f2", "patch": "@@ -729,42 +729,73 @@ pub trait LayoutCalculator {\n             align = align.max(AbiAndPrefAlign::new(repr_align));\n         }\n \n-        let optimize = !repr.inhibit_union_abi_opt();\n+        // If all the non-ZST fields have the same ABI and union ABI optimizations aren't\n+        // disabled, we can use that common ABI for the union as a whole.\n+        struct AbiMismatch;\n+        let mut common_non_zst_abi_and_align = if repr.inhibit_union_abi_opt() {\n+            // Can't optimize\n+            Err(AbiMismatch)\n+        } else {\n+            Ok(None)\n+        };\n+\n         let mut size = Size::ZERO;\n-        let mut abi = Abi::Aggregate { sized: true };\n         let only_variant = &variants[FIRST_VARIANT];\n         for field in only_variant {\n             assert!(field.0.is_sized());\n+\n             align = align.max(field.align());\n+            size = cmp::max(size, field.size());\n \n-            // If all non-ZST fields have the same ABI, forward this ABI\n-            if optimize && !field.0.is_zst() {\n+            if field.0.is_zst() {\n+                // Nothing more to do for ZST fields\n+                continue;\n+            }\n+\n+            if let Ok(common) = common_non_zst_abi_and_align {\n                 // Discard valid range information and allow undef\n-                let field_abi = match field.abi() {\n-                    Abi::Scalar(x) => Abi::Scalar(x.to_union()),\n-                    Abi::ScalarPair(x, y) => Abi::ScalarPair(x.to_union(), y.to_union()),\n-                    Abi::Vector { element: x, count } => {\n-                        Abi::Vector { element: x.to_union(), count }\n-                    }\n-                    Abi::Uninhabited | Abi::Aggregate { .. } => Abi::Aggregate { sized: true },\n-                };\n+                let field_abi = field.abi().to_union();\n \n-                if size == Size::ZERO {\n-                    // first non ZST: initialize 'abi'\n-                    abi = field_abi;\n-                } else if abi != field_abi {\n-                    // different fields have different ABI: reset to Aggregate\n-                    abi = Abi::Aggregate { sized: true };\n+                if let Some((common_abi, common_align)) = common {\n+                    if common_abi != field_abi {\n+                        // Different fields have different ABI: disable opt\n+                        common_non_zst_abi_and_align = Err(AbiMismatch);\n+                    } else {\n+                        // Fields with the same non-Aggregate ABI should also\n+                        // have the same alignment\n+                        if !matches!(common_abi, Abi::Aggregate { .. }) {\n+                            assert_eq!(\n+                                common_align,\n+                                field.align().abi,\n+                                \"non-Aggregate field with matching ABI but differing alignment\"\n+                            );\n+                        }\n+                    }\n+                } else {\n+                    // First non-ZST field: record its ABI and alignment\n+                    common_non_zst_abi_and_align = Ok(Some((field_abi, field.align().abi)));\n                 }\n             }\n-\n-            size = cmp::max(size, field.size());\n         }\n \n         if let Some(pack) = repr.pack {\n             align = align.min(AbiAndPrefAlign::new(pack));\n         }\n \n+        // If all non-ZST fields have the same ABI, we may forward that ABI\n+        // for the union as a whole, unless otherwise inhibited.\n+        let abi = match common_non_zst_abi_and_align {\n+            Err(AbiMismatch) | Ok(None) => Abi::Aggregate { sized: true },\n+            Ok(Some((abi, _))) => {\n+                if abi.inherent_align(dl).map(|a| a.abi) != Some(align.abi) {\n+                    // Mismatched alignment (e.g. union is #[repr(packed)]): disable opt\n+                    Abi::Aggregate { sized: true }\n+                } else {\n+                    abi\n+                }\n+            }\n+        };\n+\n         Some(LayoutS {\n             variants: Variants::Single { index: FIRST_VARIANT },\n             fields: FieldsShape::Union(NonZeroUsize::new(only_variant.len())?),"}, {"sha": "43db66a3c2869fa7834369165923c7cba20b1a28", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/151a070afe09c0c844e8d9af98a20fee56a5a7f2/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151a070afe09c0c844e8d9af98a20fee56a5a7f2/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=151a070afe09c0c844e8d9af98a20fee56a5a7f2", "patch": "@@ -1272,6 +1272,50 @@ impl Abi {\n     pub fn is_scalar(&self) -> bool {\n         matches!(*self, Abi::Scalar(_))\n     }\n+\n+    /// Returns the fixed alignment of this ABI, if any is mandated.\n+    pub fn inherent_align<C: HasDataLayout>(&self, cx: &C) -> Option<AbiAndPrefAlign> {\n+        Some(match *self {\n+            Abi::Scalar(s) => s.align(cx),\n+            Abi::ScalarPair(s1, s2) => s1.align(cx).max(s2.align(cx)),\n+            Abi::Vector { element, count } => {\n+                cx.data_layout().vector_align(element.size(cx) * count)\n+            }\n+            Abi::Uninhabited | Abi::Aggregate { .. } => return None,\n+        })\n+    }\n+\n+    /// Returns the fixed size of this ABI, if any is mandated.\n+    pub fn inherent_size<C: HasDataLayout>(&self, cx: &C) -> Option<Size> {\n+        Some(match *self {\n+            Abi::Scalar(s) => {\n+                // No padding in scalars.\n+                s.size(cx)\n+            }\n+            Abi::ScalarPair(s1, s2) => {\n+                // May have some padding between the pair.\n+                let field2_offset = s1.size(cx).align_to(s2.align(cx).abi);\n+                (field2_offset + s2.size(cx)).align_to(self.inherent_align(cx)?.abi)\n+            }\n+            Abi::Vector { element, count } => {\n+                // No padding in vectors, except possibly for trailing padding\n+                // to make the size a multiple of align (e.g. for vectors of size 3).\n+                (element.size(cx) * count).align_to(self.inherent_align(cx)?.abi)\n+            }\n+            Abi::Uninhabited | Abi::Aggregate { .. } => return None,\n+        })\n+    }\n+\n+    /// Discard validity range information and allow undef.\n+    pub fn to_union(&self) -> Self {\n+        assert!(self.is_sized());\n+        match *self {\n+            Abi::Scalar(s) => Abi::Scalar(s.to_union()),\n+            Abi::ScalarPair(s1, s2) => Abi::ScalarPair(s1.to_union(), s2.to_union()),\n+            Abi::Vector { element, count } => Abi::Vector { element: element.to_union(), count },\n+            Abi::Uninhabited | Abi::Aggregate { .. } => Abi::Aggregate { sized: true },\n+        }\n+    }\n }\n \n #[derive(PartialEq, Eq, Hash, Clone, Debug)]"}, {"sha": "c4a4cda68016dccc8599902bd48bd682d5ccb5ca", "filename": "compiler/rustc_ty_utils/src/layout_sanity_check.rs", "status": "modified", "additions": 40, "deletions": 54, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/151a070afe09c0c844e8d9af98a20fee56a5a7f2/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151a070afe09c0c844e8d9af98a20fee56a5a7f2/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs?ref=151a070afe09c0c844e8d9af98a20fee56a5a7f2", "patch": "@@ -4,7 +4,7 @@ use rustc_middle::ty::{\n };\n use rustc_target::abi::*;\n \n-use std::cmp;\n+use std::assert_matches::assert_matches;\n \n /// Enforce some basic invariants on layouts.\n pub(super) fn sanity_check_layout<'tcx>(\n@@ -68,21 +68,31 @@ pub(super) fn sanity_check_layout<'tcx>(\n     }\n \n     fn check_layout_abi<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLayout<'tcx>) {\n+        // Verify the ABI mandated alignment and size.\n+        let align = layout.abi.inherent_align(cx).map(|align| align.abi);\n+        let size = layout.abi.inherent_size(cx);\n+        let Some((align, size)) = align.zip(size) else {\n+            assert_matches!(\n+                layout.layout.abi(),\n+                Abi::Uninhabited | Abi::Aggregate { .. },\n+                \"ABI unexpectedly missing alignment and/or size in {layout:#?}\"\n+            );\n+            return\n+        };\n+        assert_eq!(\n+            layout.layout.align().abi,\n+            align,\n+            \"alignment mismatch between ABI and layout in {layout:#?}\"\n+        );\n+        assert_eq!(\n+            layout.layout.size(),\n+            size,\n+            \"size mismatch between ABI and layout in {layout:#?}\"\n+        );\n+\n+        // Verify per-ABI invariants\n         match layout.layout.abi() {\n-            Abi::Scalar(scalar) => {\n-                // No padding in scalars.\n-                let size = scalar.size(cx);\n-                let align = scalar.align(cx).abi;\n-                assert_eq!(\n-                    layout.layout.size(),\n-                    size,\n-                    \"size mismatch between ABI and layout in {layout:#?}\"\n-                );\n-                assert_eq!(\n-                    layout.layout.align().abi,\n-                    align,\n-                    \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                );\n+            Abi::Scalar(_) => {\n                 // Check that this matches the underlying field.\n                 let inner = skip_newtypes(cx, layout);\n                 assert!(\n@@ -135,24 +145,6 @@ pub(super) fn sanity_check_layout<'tcx>(\n                 }\n             }\n             Abi::ScalarPair(scalar1, scalar2) => {\n-                // Sanity-check scalar pairs. Computing the expected size and alignment is a bit of work.\n-                let size1 = scalar1.size(cx);\n-                let align1 = scalar1.align(cx).abi;\n-                let size2 = scalar2.size(cx);\n-                let align2 = scalar2.align(cx).abi;\n-                let align = cmp::max(align1, align2);\n-                let field2_offset = size1.align_to(align2);\n-                let size = (field2_offset + size2).align_to(align);\n-                assert_eq!(\n-                    layout.layout.size(),\n-                    size,\n-                    \"size mismatch between ABI and layout in {layout:#?}\"\n-                );\n-                assert_eq!(\n-                    layout.layout.align().abi,\n-                    align,\n-                    \"alignment mismatch between ABI and layout in {layout:#?}\",\n-                );\n                 // Check that the underlying pair of fields matches.\n                 let inner = skip_newtypes(cx, layout);\n                 assert!(\n@@ -189,8 +181,9 @@ pub(super) fn sanity_check_layout<'tcx>(\n                         \"`ScalarPair` layout for type with less than two non-ZST fields: {inner:#?}\"\n                     )\n                 });\n-                assert!(\n-                    fields.next().is_none(),\n+                assert_matches!(\n+                    fields.next(),\n+                    None,\n                     \"`ScalarPair` layout for type with at least three non-ZST fields: {inner:#?}\"\n                 );\n                 // The fields might be in opposite order.\n@@ -200,6 +193,10 @@ pub(super) fn sanity_check_layout<'tcx>(\n                     (offset2, field2, offset1, field1)\n                 };\n                 // The fields should be at the right offset, and match the `scalar` layout.\n+                let size1 = scalar1.size(cx);\n+                let align1 = scalar1.align(cx).abi;\n+                let size2 = scalar2.size(cx);\n+                let align2 = scalar2.align(cx).abi;\n                 assert_eq!(\n                     offset1,\n                     Size::ZERO,\n@@ -213,10 +210,12 @@ pub(super) fn sanity_check_layout<'tcx>(\n                     field1.align.abi, align1,\n                     \"`ScalarPair` first field with bad align in {inner:#?}\",\n                 );\n-                assert!(\n-                    matches!(field1.abi, Abi::Scalar(_)),\n+                assert_matches!(\n+                    field1.abi,\n+                    Abi::Scalar(_),\n                     \"`ScalarPair` first field with bad ABI in {inner:#?}\",\n                 );\n+                let field2_offset = size1.align_to(align2);\n                 assert_eq!(\n                     offset2, field2_offset,\n                     \"`ScalarPair` second field at bad offset in {inner:#?}\",\n@@ -229,27 +228,14 @@ pub(super) fn sanity_check_layout<'tcx>(\n                     field2.align.abi, align2,\n                     \"`ScalarPair` second field with bad align in {inner:#?}\",\n                 );\n-                assert!(\n-                    matches!(field2.abi, Abi::Scalar(_)),\n+                assert_matches!(\n+                    field2.abi,\n+                    Abi::Scalar(_),\n                     \"`ScalarPair` second field with bad ABI in {inner:#?}\",\n                 );\n             }\n-            Abi::Vector { count, element } => {\n-                // No padding in vectors, except possibly for trailing padding to make the size a multiple of align.\n-                let size = element.size(cx) * count;\n-                let align = cx.data_layout().vector_align(size).abi;\n-                let size = size.align_to(align); // needed e.g. for vectors of size 3\n+            Abi::Vector { element, .. } => {\n                 assert!(align >= element.align(cx).abi); // just sanity-checking `vector_align`.\n-                assert_eq!(\n-                    layout.layout.size(),\n-                    size,\n-                    \"size mismatch between ABI and layout in {layout:#?}\"\n-                );\n-                assert_eq!(\n-                    layout.layout.align().abi,\n-                    align,\n-                    \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                );\n                 // FIXME: Do some kind of check of the inner type, like for Scalar and ScalarPair.\n             }\n             Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check."}, {"sha": "73a2f6af579a6321d95c50fdfcdbdf0637a84e2e", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/151a070afe09c0c844e8d9af98a20fee56a5a7f2/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151a070afe09c0c844e8d9af98a20fee56a5a7f2/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=151a070afe09c0c844e8d9af98a20fee56a5a7f2", "patch": "@@ -5,6 +5,7 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(assert_matches)]\n #![feature(iterator_try_collect)]\n #![feature(let_chains)]\n #![feature(never_type)]"}, {"sha": "46171880a6fe169d60a706e7d588430400a04452", "filename": "tests/ui/layout/debug.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/151a070afe09c0c844e8d9af98a20fee56a5a7f2/tests%2Fui%2Flayout%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151a070afe09c0c844e8d9af98a20fee56a5a7f2/tests%2Fui%2Flayout%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flayout%2Fdebug.rs?ref=151a070afe09c0c844e8d9af98a20fee56a5a7f2", "patch": "@@ -1,8 +1,9 @@\n // normalize-stderr-test \"pref: Align\\([1-8] bytes\\)\" -> \"pref: $$PREF_ALIGN\"\n-#![feature(never_type, rustc_attrs, type_alias_impl_trait)]\n+#![feature(never_type, rustc_attrs, type_alias_impl_trait, repr_simd)]\n #![crate_type = \"lib\"]\n \n #[rustc_layout(debug)]\n+#[derive(Copy, Clone)]\n enum E { Foo, Bar(!, i32, i32) } //~ ERROR: layout_of\n \n #[rustc_layout(debug)]\n@@ -17,6 +18,51 @@ type Test = Result<i32, i32>; //~ ERROR: layout_of\n #[rustc_layout(debug)]\n type T = impl std::fmt::Debug; //~ ERROR: layout_of\n \n+#[rustc_layout(debug)]\n+pub union V { //~ ERROR: layout_of\n+    a: [u16; 0],\n+    b: u8,\n+}\n+\n+#[rustc_layout(debug)]\n+pub union W { //~ ERROR: layout_of\n+    b: u8,\n+    a: [u16; 0],\n+}\n+\n+#[rustc_layout(debug)]\n+pub union Y { //~ ERROR: layout_of\n+    b: [u8; 0],\n+    a: [u16; 0],\n+}\n+\n+#[rustc_layout(debug)]\n+#[repr(packed(1))]\n+union P1 { x: u32 } //~ ERROR: layout_of\n+\n+#[rustc_layout(debug)]\n+#[repr(packed(1))]\n+union P2 { x: (u32, u32) } //~ ERROR: layout_of\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct F32x4(f32, f32, f32, f32);\n+\n+#[rustc_layout(debug)]\n+#[repr(packed(1))]\n+union P3 { x: F32x4 } //~ ERROR: layout_of\n+\n+#[rustc_layout(debug)]\n+#[repr(packed(1))]\n+union P4 { x: E } //~ ERROR: layout_of\n+\n+#[rustc_layout(debug)]\n+#[repr(packed(1))]\n+union P5 { zst: [u16; 0], byte: u8 } //~ ERROR: layout_of\n+\n+#[rustc_layout(debug)]\n+type X = std::mem::MaybeUninit<u8>; //~ ERROR: layout_of\n+\n fn f() -> T {\n     0i32\n }"}, {"sha": "b9fa1b299e9697aece36003f632dd1f15c657b0c", "filename": "tests/ui/layout/debug.stderr", "status": "modified", "additions": 214, "deletions": 6, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/151a070afe09c0c844e8d9af98a20fee56a5a7f2/tests%2Fui%2Flayout%2Fdebug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/151a070afe09c0c844e8d9af98a20fee56a5a7f2/tests%2Fui%2Flayout%2Fdebug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flayout%2Fdebug.stderr?ref=151a070afe09c0c844e8d9af98a20fee56a5a7f2", "patch": "@@ -81,7 +81,7 @@ error: layout_of(E) = Layout {\n                ],\n            },\n        }\n-  --> $DIR/debug.rs:6:1\n+  --> $DIR/debug.rs:7:1\n    |\n LL | enum E { Foo, Bar(!, i32, i32) }\n    | ^^^^^^\n@@ -125,7 +125,7 @@ error: layout_of(S) = Layout {\n                index: 0,\n            },\n        }\n-  --> $DIR/debug.rs:9:1\n+  --> $DIR/debug.rs:10:1\n    |\n LL | struct S { f1: i32, f2: (), f3: i32 }\n    | ^^^^^^^^\n@@ -147,7 +147,7 @@ error: layout_of(U) = Layout {\n                index: 0,\n            },\n        }\n-  --> $DIR/debug.rs:12:1\n+  --> $DIR/debug.rs:13:1\n    |\n LL | union U { f1: (i32, i32), f3: i32 }\n    | ^^^^^^^\n@@ -276,7 +276,7 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                ],\n            },\n        }\n-  --> $DIR/debug.rs:15:1\n+  --> $DIR/debug.rs:16:1\n    |\n LL | type Test = Result<i32, i32>;\n    | ^^^^^^^^^\n@@ -302,10 +302,218 @@ error: layout_of(i32) = Layout {\n                index: 0,\n            },\n        }\n-  --> $DIR/debug.rs:18:1\n+  --> $DIR/debug.rs:19:1\n    |\n LL | type T = impl std::fmt::Debug;\n    | ^^^^^^\n \n-error: aborting due to 5 previous errors\n+error: layout_of(V) = Layout {\n+           size: Size(2 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(2 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n+           fields: Union(\n+               2,\n+           ),\n+           largest_niche: None,\n+           variants: Single {\n+               index: 0,\n+           },\n+       }\n+  --> $DIR/debug.rs:22:1\n+   |\n+LL | pub union V {\n+   | ^^^^^^^^^^^\n+\n+error: layout_of(W) = Layout {\n+           size: Size(2 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(2 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n+           fields: Union(\n+               2,\n+           ),\n+           largest_niche: None,\n+           variants: Single {\n+               index: 0,\n+           },\n+       }\n+  --> $DIR/debug.rs:28:1\n+   |\n+LL | pub union W {\n+   | ^^^^^^^^^^^\n+\n+error: layout_of(Y) = Layout {\n+           size: Size(0 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(2 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n+           fields: Union(\n+               2,\n+           ),\n+           largest_niche: None,\n+           variants: Single {\n+               index: 0,\n+           },\n+       }\n+  --> $DIR/debug.rs:34:1\n+   |\n+LL | pub union Y {\n+   | ^^^^^^^^^^^\n+\n+error: layout_of(P1) = Layout {\n+           size: Size(4 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n+           fields: Union(\n+               1,\n+           ),\n+           largest_niche: None,\n+           variants: Single {\n+               index: 0,\n+           },\n+       }\n+  --> $DIR/debug.rs:41:1\n+   |\n+LL | union P1 { x: u32 }\n+   | ^^^^^^^^\n+\n+error: layout_of(P2) = Layout {\n+           size: Size(8 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n+           fields: Union(\n+               1,\n+           ),\n+           largest_niche: None,\n+           variants: Single {\n+               index: 0,\n+           },\n+       }\n+  --> $DIR/debug.rs:45:1\n+   |\n+LL | union P2 { x: (u32, u32) }\n+   | ^^^^^^^^\n+\n+error: layout_of(P3) = Layout {\n+           size: Size(16 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n+           fields: Union(\n+               1,\n+           ),\n+           largest_niche: None,\n+           variants: Single {\n+               index: 0,\n+           },\n+       }\n+  --> $DIR/debug.rs:53:1\n+   |\n+LL | union P3 { x: F32x4 }\n+   | ^^^^^^^^\n+\n+error: layout_of(P4) = Layout {\n+           size: Size(12 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n+           fields: Union(\n+               1,\n+           ),\n+           largest_niche: None,\n+           variants: Single {\n+               index: 0,\n+           },\n+       }\n+  --> $DIR/debug.rs:57:1\n+   |\n+LL | union P4 { x: E }\n+   | ^^^^^^^^\n+\n+error: layout_of(P5) = Layout {\n+           size: Size(1 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Scalar(\n+               Union {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+               },\n+           ),\n+           fields: Union(\n+               2,\n+           ),\n+           largest_niche: None,\n+           variants: Single {\n+               index: 0,\n+           },\n+       }\n+  --> $DIR/debug.rs:61:1\n+   |\n+LL | union P5 { zst: [u16; 0], byte: u8 }\n+   | ^^^^^^^^\n+\n+error: layout_of(std::mem::MaybeUninit<u8>) = Layout {\n+           size: Size(1 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Scalar(\n+               Union {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+               },\n+           ),\n+           fields: Union(\n+               2,\n+           ),\n+           largest_niche: None,\n+           variants: Single {\n+               index: 0,\n+           },\n+       }\n+  --> $DIR/debug.rs:64:1\n+   |\n+LL | type X = std::mem::MaybeUninit<u8>;\n+   | ^^^^^^\n+\n+error: aborting due to 14 previous errors\n "}]}