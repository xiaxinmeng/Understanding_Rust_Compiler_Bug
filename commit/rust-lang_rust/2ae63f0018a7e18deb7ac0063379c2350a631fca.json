{"sha": "2ae63f0018a7e18deb7ac0063379c2350a631fca", "node_id": "C_kwDOAAsO6NoAKDJhZTYzZjAwMThhN2UxOGRlYjdhYzAwNjMzNzljMjM1MGE2MzFmY2E", "commit": {"author": {"name": "Tom Milligan", "email": "tom@reinfer.io", "date": "2022-06-10T11:17:29Z"}, "committer": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2022-07-01T03:25:39Z"}, "message": "config_type: add unstable_variant attribute", "tree": {"sha": "4c48d35571dec6283e5032062e49bdb9c12991ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c48d35571dec6283e5032062e49bdb9c12991ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ae63f0018a7e18deb7ac0063379c2350a631fca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ae63f0018a7e18deb7ac0063379c2350a631fca", "html_url": "https://github.com/rust-lang/rust/commit/2ae63f0018a7e18deb7ac0063379c2350a631fca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ae63f0018a7e18deb7ac0063379c2350a631fca/comments", "author": {"login": "tommilligan", "id": 12255914, "node_id": "MDQ6VXNlcjEyMjU1OTE0", "avatar_url": "https://avatars.githubusercontent.com/u/12255914?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tommilligan", "html_url": "https://github.com/tommilligan", "followers_url": "https://api.github.com/users/tommilligan/followers", "following_url": "https://api.github.com/users/tommilligan/following{/other_user}", "gists_url": "https://api.github.com/users/tommilligan/gists{/gist_id}", "starred_url": "https://api.github.com/users/tommilligan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tommilligan/subscriptions", "organizations_url": "https://api.github.com/users/tommilligan/orgs", "repos_url": "https://api.github.com/users/tommilligan/repos", "events_url": "https://api.github.com/users/tommilligan/events{/privacy}", "received_events_url": "https://api.github.com/users/tommilligan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3d4fb448c79240785d8ccd78b73d40c59fc5071", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3d4fb448c79240785d8ccd78b73d40c59fc5071", "html_url": "https://github.com/rust-lang/rust/commit/b3d4fb448c79240785d8ccd78b73d40c59fc5071"}], "stats": {"total": 278, "additions": 244, "deletions": 34}, "files": [{"sha": "e51755289706c14f33e77ca25570b31ac20d3b48", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ae63f0018a7e18deb7ac0063379c2350a631fca/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2ae63f0018a7e18deb7ac0063379c2350a631fca/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2ae63f0018a7e18deb7ac0063379c2350a631fca", "patch": "@@ -476,7 +476,7 @@ checksum = \"fc71d2faa173b74b232dedc235e3ee1696581bb132fc116fa3626d6151a1a8fb\"\n \n [[package]]\n name = \"rustfmt-config_proc_macro\"\n-version = \"0.2.0\"\n+version = \"0.3.0\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\","}, {"sha": "7438335eaa78faf606cbf9ca1298414f3120161a", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ae63f0018a7e18deb7ac0063379c2350a631fca/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2ae63f0018a7e18deb7ac0063379c2350a631fca/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=2ae63f0018a7e18deb7ac0063379c2350a631fca", "patch": "@@ -57,7 +57,7 @@ unicode-segmentation = \"1.9\"\n unicode-width = \"0.1\"\n unicode_categories = \"0.1\"\n \n-rustfmt-config_proc_macro = { version = \"0.2\", path = \"config_proc_macro\" }\n+rustfmt-config_proc_macro = { version = \"0.3\", path = \"config_proc_macro\" }\n \n # A noop dependency that changes in the Rust repository, it's a bit of a hack.\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`"}, {"sha": "49f2f72a8d2196323aeefce78a22fdd8b0afd80d", "filename": "config_proc_macro/Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ae63f0018a7e18deb7ac0063379c2350a631fca/config_proc_macro%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2ae63f0018a7e18deb7ac0063379c2350a631fca/config_proc_macro%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2FCargo.lock?ref=2ae63f0018a7e18deb7ac0063379c2350a631fca", "patch": "@@ -22,7 +22,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-config_proc_macro\"\n-version = \"0.2.0\"\n+version = \"0.3.0\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\","}, {"sha": "d10d0469cc401ffe3564c93f7eb1b2033cf31bb9", "filename": "config_proc_macro/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ae63f0018a7e18deb7ac0063379c2350a631fca/config_proc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2ae63f0018a7e18deb7ac0063379c2350a631fca/config_proc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2FCargo.toml?ref=2ae63f0018a7e18deb7ac0063379c2350a631fca", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"rustfmt-config_proc_macro\"\n-version = \"0.2.0\"\n+version = \"0.3.0\"\n edition = \"2018\"\n description = \"A collection of procedural macros for rustfmt\"\n license = \"Apache-2.0/MIT\""}, {"sha": "dd18ff572cb1cd28daee3d0925f459557ae202fd", "filename": "config_proc_macro/src/attrs.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2ae63f0018a7e18deb7ac0063379c2350a631fca/config_proc_macro%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ae63f0018a7e18deb7ac0063379c2350a631fca/config_proc_macro%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2Fsrc%2Fattrs.rs?ref=2ae63f0018a7e18deb7ac0063379c2350a631fca", "patch": "@@ -1,8 +1,10 @@\n //! This module provides utilities for handling attributes on variants\n-//! of `config_type` enum. Currently there are two types of attributes\n-//! that could appear on the variants of `config_type` enum: `doc_hint`\n-//! and `value`. Both comes in the form of name-value pair whose value\n-//! is string literal.\n+//! of `config_type` enum. Currently there are the following attributes\n+//! that could appear on the variants of `config_type` enum:\n+//!\n+//! - `doc_hint`: name-value pair whose value is string literal\n+//! - `value`: name-value pair whose value is string literal\n+//! - `unstable_variant`: name only\n \n /// Returns the value of the first `doc_hint` attribute in the given slice or\n /// `None` if `doc_hint` attribute is not available.\n@@ -27,6 +29,11 @@ pub fn find_config_value(attrs: &[syn::Attribute]) -> Option<String> {\n     attrs.iter().filter_map(config_value).next()\n }\n \n+/// Returns `true` if the there is at least one `unstable` attribute in the given slice.\n+pub fn any_unstable_variant(attrs: &[syn::Attribute]) -> bool {\n+    attrs.iter().any(is_unstable_variant)\n+}\n+\n /// Returns a string literal value if the given attribute is `value`\n /// attribute or `None` otherwise.\n pub fn config_value(attr: &syn::Attribute) -> Option<String> {\n@@ -38,13 +45,25 @@ pub fn is_config_value(attr: &syn::Attribute) -> bool {\n     is_attr_name_value(attr, \"value\")\n }\n \n+/// Returns `true` if the given attribute is an `unstable` attribute.\n+pub fn is_unstable_variant(attr: &syn::Attribute) -> bool {\n+    is_attr_path(attr, \"unstable_variant\")\n+}\n+\n fn is_attr_name_value(attr: &syn::Attribute, name: &str) -> bool {\n     attr.parse_meta().ok().map_or(false, |meta| match meta {\n         syn::Meta::NameValue(syn::MetaNameValue { ref path, .. }) if path.is_ident(name) => true,\n         _ => false,\n     })\n }\n \n+fn is_attr_path(attr: &syn::Attribute, name: &str) -> bool {\n+    attr.parse_meta().ok().map_or(false, |meta| match meta {\n+        syn::Meta::Path(path) if path.is_ident(name) => true,\n+        _ => false,\n+    })\n+}\n+\n fn get_name_value_str_lit(attr: &syn::Attribute, name: &str) -> Option<String> {\n     attr.parse_meta().ok().and_then(|meta| match meta {\n         syn::Meta::NameValue(syn::MetaNameValue {"}, {"sha": "731a7ea06077bf5dc7d677b3295310b2bbd7b942", "filename": "config_proc_macro/src/item_enum.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2ae63f0018a7e18deb7ac0063379c2350a631fca/config_proc_macro%2Fsrc%2Fitem_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ae63f0018a7e18deb7ac0063379c2350a631fca/config_proc_macro%2Fsrc%2Fitem_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2Fsrc%2Fitem_enum.rs?ref=2ae63f0018a7e18deb7ac0063379c2350a631fca", "patch": "@@ -1,5 +1,6 @@\n use proc_macro2::TokenStream;\n-use quote::quote;\n+use quote::{quote, quote_spanned};\n+use syn::spanned::Spanned;\n \n use crate::attrs::*;\n use crate::utils::*;\n@@ -47,25 +48,50 @@ fn process_variant(variant: &syn::Variant) -> TokenStream {\n     let metas = variant\n         .attrs\n         .iter()\n-        .filter(|attr| !is_doc_hint(attr) && !is_config_value(attr));\n+        .filter(|attr| !is_doc_hint(attr) && !is_config_value(attr) && !is_unstable_variant(attr));\n     let attrs = fold_quote(metas, |meta| quote!(#meta));\n     let syn::Variant { ident, fields, .. } = variant;\n     quote!(#attrs #ident #fields)\n }\n \n+/// Return the correct syntax to pattern match on the enum variant, discarding all\n+/// internal field data.\n+fn fields_in_variant(variant: &syn::Variant) -> TokenStream {\n+    // With thanks to https://stackoverflow.com/a/65182902\n+    match &variant.fields {\n+        syn::Fields::Unnamed(_) => quote_spanned! { variant.span() => (..) },\n+        syn::Fields::Unit => quote_spanned! { variant.span() => },\n+        syn::Fields::Named(_) => quote_spanned! { variant.span() => {..} },\n+    }\n+}\n+\n fn impl_doc_hint(ident: &syn::Ident, variants: &Variants) -> TokenStream {\n     let doc_hint = variants\n         .iter()\n         .map(doc_hint_of_variant)\n         .collect::<Vec<_>>()\n         .join(\"|\");\n     let doc_hint = format!(\"[{}]\", doc_hint);\n+\n+    let variant_stables = variants\n+        .iter()\n+        .map(|v| (&v.ident, fields_in_variant(&v), !unstable_of_variant(v)));\n+    let match_patterns = fold_quote(variant_stables, |(v, fields, stable)| {\n+        quote! {\n+            #ident::#v #fields => #stable,\n+        }\n+    });\n     quote! {\n         use crate::config::ConfigType;\n         impl ConfigType for #ident {\n             fn doc_hint() -> String {\n                 #doc_hint.to_owned()\n             }\n+            fn stable_variant(&self) -> bool {\n+                match self {\n+                    #match_patterns\n+                }\n+            }\n         }\n     }\n }\n@@ -123,13 +149,21 @@ fn impl_from_str(ident: &syn::Ident, variants: &Variants) -> TokenStream {\n }\n \n fn doc_hint_of_variant(variant: &syn::Variant) -> String {\n-    find_doc_hint(&variant.attrs).unwrap_or(variant.ident.to_string())\n+    let mut text = find_doc_hint(&variant.attrs).unwrap_or(variant.ident.to_string());\n+    if unstable_of_variant(&variant) {\n+        text.push_str(\" (unstable)\")\n+    };\n+    text\n }\n \n fn config_value_of_variant(variant: &syn::Variant) -> String {\n     find_config_value(&variant.attrs).unwrap_or(variant.ident.to_string())\n }\n \n+fn unstable_of_variant(variant: &syn::Variant) -> bool {\n+    any_unstable_variant(&variant.attrs)\n+}\n+\n fn impl_serde(ident: &syn::Ident, variants: &Variants) -> TokenStream {\n     let arms = fold_quote(variants.iter(), |v| {\n         let v_ident = &v.ident;"}, {"sha": "c8a83e39c9efc656d1d411de343a8fdb0aa23cbb", "filename": "config_proc_macro/tests/smoke.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ae63f0018a7e18deb7ac0063379c2350a631fca/config_proc_macro%2Ftests%2Fsmoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ae63f0018a7e18deb7ac0063379c2350a631fca/config_proc_macro%2Ftests%2Fsmoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2Ftests%2Fsmoke.rs?ref=2ae63f0018a7e18deb7ac0063379c2350a631fca", "patch": "@@ -1,6 +1,7 @@\n pub mod config {\n     pub trait ConfigType: Sized {\n         fn doc_hint() -> String;\n+        fn stable_variant(&self) -> bool;\n     }\n }\n "}, {"sha": "26d57a13791a50dcc1bb7d90eaeeb65876958068", "filename": "src/config/config_type.rs", "status": "modified", "additions": 74, "deletions": 16, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/2ae63f0018a7e18deb7ac0063379c2350a631fca/src%2Fconfig%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ae63f0018a7e18deb7ac0063379c2350a631fca/src%2Fconfig%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fconfig_type.rs?ref=2ae63f0018a7e18deb7ac0063379c2350a631fca", "patch": "@@ -6,6 +6,14 @@ pub(crate) trait ConfigType: Sized {\n     /// Returns hint text for use in `Config::print_docs()`. For enum types, this is a\n     /// pipe-separated list of variants; for other types it returns \"<type>\".\n     fn doc_hint() -> String;\n+\n+    /// Return `true` if the variant (i.e. value of this type) is stable.\n+    ///\n+    /// By default, return true for all values. Enums annotated with `#[config_type]`\n+    /// are automatically implemented, based on the `#[unstable_variant]` annotation.\n+    fn stable_variant(&self) -> bool {\n+        true\n+    }\n }\n \n impl ConfigType for bool {\n@@ -51,6 +59,13 @@ impl ConfigType for IgnoreList {\n }\n \n macro_rules! create_config {\n+    // Options passed in to the macro.\n+    //\n+    // - $i: the ident name of the option\n+    // - $ty: the type of the option value\n+    // - $def: the default value of the option\n+    // - $stb: true if the option is stable\n+    // - $dstring: description of the option\n     ($($i:ident: $ty:ty, $def:expr, $stb:expr, $( $dstring:expr ),+ );+ $(;)*) => (\n         #[cfg(test)]\n         use std::collections::HashSet;\n@@ -61,9 +76,12 @@ macro_rules! create_config {\n         #[derive(Clone)]\n         #[allow(unreachable_pub)]\n         pub struct Config {\n-            // For each config item, we store a bool indicating whether it has\n-            // been accessed and the value, and a bool whether the option was\n-            // manually initialised, or taken from the default,\n+            // For each config item, we store:\n+            //\n+            // - 0: true if the value has been access\n+            // - 1: true if the option was manually initialized\n+            // - 2: the option value\n+            // - 3: true if the option is unstable\n             $($i: (Cell<bool>, bool, $ty, bool)),+\n         }\n \n@@ -143,18 +161,13 @@ macro_rules! create_config {\n \n             fn fill_from_parsed_config(mut self, parsed: PartialConfig, dir: &Path) -> Config {\n             $(\n-                if let Some(val) = parsed.$i {\n-                    if self.$i.3 {\n+                if let Some(option_value) = parsed.$i {\n+                    let option_stable = self.$i.3;\n+                    if $crate::config::config_type::is_stable_option_and_value(\n+                        stringify!($i), option_stable, &option_value\n+                    ) {\n                         self.$i.1 = true;\n-                        self.$i.2 = val;\n-                    } else {\n-                        if crate::is_nightly_channel!() {\n-                            self.$i.1 = true;\n-                            self.$i.2 = val;\n-                        } else {\n-                            eprintln!(\"Warning: can't set `{} = {:?}`, unstable features are only \\\n-                                       available in nightly channel.\", stringify!($i), val);\n-                        }\n+                        self.$i.2 = option_value;\n                     }\n                 }\n             )+\n@@ -221,12 +234,22 @@ macro_rules! create_config {\n                 match key {\n                     $(\n                         stringify!($i) => {\n-                            self.$i.1 = true;\n-                            self.$i.2 = val.parse::<$ty>()\n+                            let option_value = val.parse::<$ty>()\n                                 .expect(&format!(\"Failed to parse override for {} (\\\"{}\\\") as a {}\",\n                                                  stringify!($i),\n                                                  val,\n                                                  stringify!($ty)));\n+\n+                            // Users are currently allowed to set unstable\n+                            // options/variants via the `--config` options override.\n+                            //\n+                            // There is ongoing discussion about how to move forward here:\n+                            // https://github.com/rust-lang/rustfmt/pull/5379\n+                            //\n+                            // For now, do not validate whether the option or value is stable,\n+                            // just always set it.\n+                            self.$i.1 = true;\n+                            self.$i.2 = option_value;\n                         }\n                     )+\n                     _ => panic!(\"Unknown config key in override: {}\", key)\n@@ -424,3 +447,38 @@ macro_rules! create_config {\n         }\n     )\n }\n+\n+pub(crate) fn is_stable_option_and_value<T>(\n+    option_name: &str,\n+    option_stable: bool,\n+    option_value: &T,\n+) -> bool\n+where\n+    T: PartialEq + std::fmt::Debug + ConfigType,\n+{\n+    let nightly = crate::is_nightly_channel!();\n+    let variant_stable = option_value.stable_variant();\n+    match (nightly, option_stable, variant_stable) {\n+        // Stable with an unstable option\n+        (false, false, _) => {\n+            eprintln!(\n+                \"Warning: can't set `{} = {:?}`, unstable features are only \\\n+                       available in nightly channel.\",\n+                option_name, option_value\n+            );\n+            false\n+        }\n+        // Stable with a stable option, but an unstable variant\n+        (false, true, false) => {\n+            eprintln!(\n+                \"Warning: can't set `{} = {:?}`, unstable variants are only \\\n+                       available in nightly channel.\",\n+                option_name, option_value\n+            );\n+            false\n+        }\n+        // Nightly: everything allowed\n+        // Stable with stable option and variant: allowed\n+        (true, _, _) | (false, true, true) => true,\n+    }\n+}"}, {"sha": "eaada8db090a85d39ee49ea32ff2c23132db779f", "filename": "src/config/mod.rs", "status": "modified", "additions": 105, "deletions": 7, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/2ae63f0018a7e18deb7ac0063379c2350a631fca/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ae63f0018a7e18deb7ac0063379c2350a631fca/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=2ae63f0018a7e18deb7ac0063379c2350a631fca", "patch": "@@ -408,6 +408,15 @@ mod test {\n     #[allow(dead_code)]\n     mod mock {\n         use super::super::*;\n+        use rustfmt_config_proc_macro::config_type;\n+\n+        #[config_type]\n+        pub enum PartiallyUnstableOption {\n+            V1,\n+            V2,\n+            #[unstable_variant]\n+            V3,\n+        }\n \n         create_config! {\n             // Options that are used by the generated functions\n@@ -451,6 +460,63 @@ mod test {\n             // Options that are used by the tests\n             stable_option: bool, false, true, \"A stable option\";\n             unstable_option: bool, false, false, \"An unstable option\";\n+            partially_unstable_option: PartiallyUnstableOption, PartiallyUnstableOption::V1, true,\n+                \"A partially unstable option\";\n+        }\n+\n+        #[cfg(test)]\n+        mod partially_unstable_option {\n+            use super::{Config, PartialConfig, PartiallyUnstableOption};\n+            use rustfmt_config_proc_macro::{nightly_only_test, stable_only_test};\n+            use std::path::Path;\n+\n+            /// From the config file, we can fill with a stable variant\n+            #[test]\n+            fn test_from_toml_stable_value() {\n+                let toml = r#\"\n+                    partially_unstable_option = \"V2\"\n+                \"#;\n+                let partial_config: PartialConfig = toml::from_str(toml).unwrap();\n+                let config = Config::default();\n+                let config = config.fill_from_parsed_config(partial_config, Path::new(\"\"));\n+                assert_eq!(\n+                    config.partially_unstable_option(),\n+                    PartiallyUnstableOption::V2\n+                );\n+            }\n+\n+            /// From the config file, we cannot fill with an unstable variant (stable only)\n+            #[stable_only_test]\n+            #[test]\n+            fn test_from_toml_unstable_value_on_stable() {\n+                let toml = r#\"\n+                    partially_unstable_option = \"V3\"\n+                \"#;\n+                let partial_config: PartialConfig = toml::from_str(toml).unwrap();\n+                let config = Config::default();\n+                let config = config.fill_from_parsed_config(partial_config, Path::new(\"\"));\n+                assert_eq!(\n+                    config.partially_unstable_option(),\n+                    // default value from config, i.e. fill failed\n+                    PartiallyUnstableOption::V1\n+                );\n+            }\n+\n+            /// From the config file, we can fill with an unstable variant (nightly only)\n+            #[nightly_only_test]\n+            #[test]\n+            fn test_from_toml_unstable_value_on_nightly() {\n+                let toml = r#\"\n+                    partially_unstable_option = \"V3\"\n+                \"#;\n+                let partial_config: PartialConfig = toml::from_str(toml).unwrap();\n+                let config = Config::default();\n+                let config = config.fill_from_parsed_config(partial_config, Path::new(\"\"));\n+                assert_eq!(\n+                    config.partially_unstable_option(),\n+                    PartiallyUnstableOption::V3\n+                );\n+            }\n         }\n     }\n \n@@ -489,6 +555,11 @@ mod test {\n         assert_eq!(config.was_set().verbose(), false);\n     }\n \n+    const PRINT_DOCS_STABLE_OPTION: &str = \"stable_option <boolean> Default: false\";\n+    const PRINT_DOCS_UNSTABLE_OPTION: &str = \"unstable_option <boolean> Default: false (unstable)\";\n+    const PRINT_DOCS_PARTIALLY_UNSTABLE_OPTION: &str =\n+        \"partially_unstable_option [V1|V2|V3 (unstable)] Default: V1\";\n+\n     #[test]\n     fn test_print_docs_exclude_unstable() {\n         use self::mock::Config;\n@@ -497,10 +568,9 @@ mod test {\n         Config::print_docs(&mut output, false);\n \n         let s = str::from_utf8(&output).unwrap();\n-\n-        assert_eq!(s.contains(\"stable_option\"), true);\n-        assert_eq!(s.contains(\"unstable_option\"), false);\n-        assert_eq!(s.contains(\"(unstable)\"), false);\n+        assert_eq!(s.contains(PRINT_DOCS_STABLE_OPTION), true);\n+        assert_eq!(s.contains(PRINT_DOCS_UNSTABLE_OPTION), false);\n+        assert_eq!(s.contains(PRINT_DOCS_PARTIALLY_UNSTABLE_OPTION), true);\n     }\n \n     #[test]\n@@ -511,9 +581,9 @@ mod test {\n         Config::print_docs(&mut output, true);\n \n         let s = str::from_utf8(&output).unwrap();\n-        assert_eq!(s.contains(\"stable_option\"), true);\n-        assert_eq!(s.contains(\"unstable_option\"), true);\n-        assert_eq!(s.contains(\"(unstable)\"), true);\n+        assert_eq!(s.contains(PRINT_DOCS_STABLE_OPTION), true);\n+        assert_eq!(s.contains(PRINT_DOCS_UNSTABLE_OPTION), true);\n+        assert_eq!(s.contains(PRINT_DOCS_PARTIALLY_UNSTABLE_OPTION), true);\n     }\n \n     #[test]\n@@ -921,4 +991,32 @@ make_backup = false\n             assert_eq!(config.single_line_if_else_max_width(), 100);\n         }\n     }\n+\n+    #[cfg(test)]\n+    mod partially_unstable_option {\n+        use super::mock::{Config, PartiallyUnstableOption};\n+        use super::*;\n+\n+        /// From the command line, we can override with a stable variant.\n+        #[test]\n+        fn test_override_stable_value() {\n+            let mut config = Config::default();\n+            config.override_value(\"partially_unstable_option\", \"V2\");\n+            assert_eq!(\n+                config.partially_unstable_option(),\n+                PartiallyUnstableOption::V2\n+            );\n+        }\n+\n+        /// From the command line, we can override with an unstable variant.\n+        #[test]\n+        fn test_override_unstable_value() {\n+            let mut config = Config::default();\n+            config.override_value(\"partially_unstable_option\", \"V3\");\n+            assert_eq!(\n+                config.partially_unstable_option(),\n+                PartiallyUnstableOption::V3\n+            );\n+        }\n+    }\n }"}]}