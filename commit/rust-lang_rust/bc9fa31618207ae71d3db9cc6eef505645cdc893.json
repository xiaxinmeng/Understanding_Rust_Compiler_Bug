{"sha": "bc9fa31618207ae71d3db9cc6eef505645cdc893", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjOWZhMzE2MTgyMDdhZTcxZDNkYjljYzZlZWY1MDU2NDVjZGM4OTM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-27T17:08:57Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-27T17:08:57Z"}, "message": "A little tidying in rt.", "tree": {"sha": "ed2230a1ae0c4671e311f36f264f24e7d3702497", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed2230a1ae0c4671e311f36f264f24e7d3702497"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc9fa31618207ae71d3db9cc6eef505645cdc893", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc9fa31618207ae71d3db9cc6eef505645cdc893", "html_url": "https://github.com/rust-lang/rust/commit/bc9fa31618207ae71d3db9cc6eef505645cdc893", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc9fa31618207ae71d3db9cc6eef505645cdc893/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "022ebc198b9e9e42880a4f3bcd31565533333296", "url": "https://api.github.com/repos/rust-lang/rust/commits/022ebc198b9e9e42880a4f3bcd31565533333296", "html_url": "https://github.com/rust-lang/rust/commit/022ebc198b9e9e42880a4f3bcd31565533333296"}], "stats": {"total": 55, "additions": 24, "deletions": 31}, "files": [{"sha": "381392b6af044e102a1e68bc1e70578ad505a71a", "filename": "src/rt/memory_region.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc9fa31618207ae71d3db9cc6eef505645cdc893/src%2Frt%2Fmemory_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/bc9fa31618207ae71d3db9cc6eef505645cdc893/src%2Frt%2Fmemory_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.h?ref=bc9fa31618207ae71d3db9cc6eef505645cdc893", "patch": "@@ -2,7 +2,7 @@\n  * The Rust runtime uses memory regions to provide a primitive level of\n  * memory management and isolation between tasks, and domains.\n  *\n- * TODO: Implement a custom lock-free malloc / free instead of relying solely\n+ * FIXME: Implement a custom lock-free malloc / free instead of relying solely\n  *       on the standard malloc / free.\n  */\n "}, {"sha": "093656b77d2ab69a34f5a1307b568a0478fcf813", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc9fa31618207ae71d3db9cc6eef505645cdc893/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bc9fa31618207ae71d3db9cc6eef505645cdc893/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=bc9fa31618207ae71d3db9cc6eef505645cdc893", "patch": "@@ -79,7 +79,7 @@ int get_num_threads()\n         if(num > 0)\n             return num;\n     }\n-    // TODO: in this case, determine the number of CPUs present on the\n+    // FIXME: in this case, determine the number of CPUs present on the\n     // machine.\n     return 1;\n }"}, {"sha": "c9c6b56c09ee0adca3e38318ca83b18326f9f391", "filename": "src/rt/rust_dom.cpp", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc9fa31618207ae71d3db9cc6eef505645cdc893/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bc9fa31618207ae71d3db9cc6eef505645cdc893/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=bc9fa31618207ae71d3db9cc6eef505645cdc893", "patch": "@@ -269,7 +269,11 @@ rust_dom::start_main_loop(int id) {\n     scheduler_lock.lock();\n \n     // Make sure someone is watching, to pull us out of infinite loops.\n-    //rust_timer timer(this);\n+    //\n+    // FIXME: time-based interruption is not presently working; worked\n+    // in rustboot and has been completely broken in rustc.\n+    //\n+    // rust_timer timer(this);\n \n     DLOG(this, dom, \"started domain loop %d\", id);\n \n@@ -332,14 +336,6 @@ rust_dom::start_main_loop(int id) {\n              scheduled_task->rust_sp,\n              id);\n \n-        /*\n-          // These invariants are no longer valid, as rust_sp is not\n-          // updated.\n-        I(this, scheduled_task->rust_sp >=\n-          (uintptr_t) &scheduled_task->stk->data[0]);\n-        I(this, scheduled_task->rust_sp < scheduled_task->stk->limit);\n-        */\n-        \n         reap_dead_tasks();\n     }\n \n@@ -371,14 +367,14 @@ rust_dom::start_main_loop(int id) {\n int rust_dom::start_main_loops(int num_threads)\n {\n     dom_worker *worker = NULL;\n-    \n+\n     // -1, because this thread will also be a worker.\n     for(int i = 0; i < num_threads - 1; ++i) {\n         worker = new dom_worker(i + 1, this);\n         worker->start();\n         threads.push(worker);\n     }\n-    \n+\n     start_main_loop(0);\n \n     while(threads.pop(&worker)) {"}, {"sha": "21c0f593f9acebbaf327b5a1767d4e1481a0952a", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bc9fa31618207ae71d3db9cc6eef505645cdc893/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bc9fa31618207ae71d3db9cc6eef505645cdc893/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=bc9fa31618207ae71d3db9cc6eef505645cdc893", "patch": "@@ -14,8 +14,7 @@\n \n // FIXME (issue #151): This should be 0x300; the change here is for\n // practicality's sake until stack growth is working.\n-//static size_t const min_stk_bytes = 0x300000;\n-//static size_t const min_stk_bytes = 0x10000;\n+\n static size_t const min_stk_bytes = 0x100000;\n \n // Task stack segments. Heap allocated and chained together.\n@@ -120,7 +119,7 @@ struct spawn_args {\n     rust_task *task;\n     uintptr_t a3;\n     uintptr_t a4;\n-    void (*CDECL f)(int *, rust_task *, \n+    void (*CDECL f)(int *, rust_task *,\n                        uintptr_t, uintptr_t);\n };\n \n@@ -129,15 +128,15 @@ void task_start_wrapper(spawn_args *a)\n {\n     rust_task *task = a->task;\n     int rval = 42;\n-    \n+\n     a->f(&rval, task, a->a3, a->a4);\n-    \n+\n     LOG(task, task, \"task exited with value %d\", rval);\n \n     {\n         scoped_lock with(task->dom->scheduler_lock);\n-        \n-        // TODO: the old exit glue does some magical argument copying\n+\n+        // FIXME: the old exit glue does some magical argument copying\n         // stuff. This is probably still needed.\n \n         // This is duplicated from upcall_exit, which is probably dead code by\n@@ -160,7 +159,7 @@ rust_task::start(uintptr_t spawnee_fn,\n \n     I(dom, stk->data != NULL);\n     I(dom, !dom->scheduler_lock.lock_held_by_current_thread());\n-    \n+\n     scoped_lock with(dom->scheduler_lock);\n \n     char *sp = (char *)rust_sp;\n@@ -174,7 +173,7 @@ rust_task::start(uintptr_t spawnee_fn,\n     a->a4 = args;\n     void **f = (void **)&a->f;\n     *f = (void *)spawnee_fn;\n-    \n+\n     ctx.call((void *)task_start_wrapper, a, sp);\n \n     yield_timer.reset(0);\n@@ -201,7 +200,7 @@ rust_task::yield(size_t nargs, size_t time_in_us) {\n     LOG(this, task, \"task %s @0x%\" PRIxPTR \" yielding for %d us\",\n         name, this, time_in_us);\n \n-    // TODO: what is nargs for, and is it safe to ignore?\n+    // FIXME: what is nargs for, and is it safe to ignore?\n \n     yield_timer.reset(time_in_us);\n \n@@ -254,9 +253,9 @@ rust_task::fail(size_t nargs) {\n void\n rust_task::gc(size_t nargs)\n {\n+    // FIXME: not presently implemented; was broken by rustc.\n     DLOG(dom, task,\n              \"task %s @0x%\" PRIxPTR \" garbage collecting\", name, this);\n-    // run_after_return(nargs, rust_gc_glue);\n }\n \n void\n@@ -346,7 +345,7 @@ void *\n rust_task::malloc(size_t sz, type_desc *td)\n {\n     // FIXME: GC is disabled for now.\n-    // Effects, GC-memory classification are all wrong.\n+    // GC-memory classification is all wrong.\n     td = NULL;\n \n     if (td) {\n@@ -373,7 +372,7 @@ void *\n rust_task::realloc(void *data, size_t sz, bool is_gc)\n {\n     // FIXME: GC is disabled for now.\n-    // Effects, GC-memory classification are all wrong.\n+    // Effects, GC-memory classification is all wrong.\n     is_gc = false;\n     if (is_gc) {\n         gc_alloc *gcm = (gc_alloc*)(((char *)data) - sizeof(gc_alloc));\n@@ -397,7 +396,7 @@ void\n rust_task::free(void *p, bool is_gc)\n {\n     // FIXME: GC is disabled for now.\n-    // Effects, GC-memory classification are all wrong.\n+    // GC-memory classification is all wrong.\n     is_gc = false;\n     if (is_gc) {\n         gc_alloc *gcm = (gc_alloc*)(((char *)p) - sizeof(gc_alloc));"}, {"sha": "022735f05dc85da3c9807371f457084e055872ed", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc9fa31618207ae71d3db9cc6eef505645cdc893/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bc9fa31618207ae71d3db9cc6eef505645cdc893/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=bc9fa31618207ae71d3db9cc6eef505645cdc893", "patch": "@@ -571,7 +571,7 @@ upcall_new_thread(rust_task *task, const char *name) {\n     return child_task_proxy;\n }\n \n-#if 0 /* TODO: this code will be re-enabled once we have multithreading. */\n+#if 0 /* FIXME: this code will be re-enabled once we have multithreading. */\n \n #if defined(__WIN32__)\n static DWORD WINAPI rust_thread_start(void *ptr)"}, {"sha": "f67e3ee310d47c6c3600d35814a981a86555970e", "filename": "src/rt/sync/lock_and_signal.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc9fa31618207ae71d3db9cc6eef505645cdc893/src%2Frt%2Fsync%2Flock_and_signal.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bc9fa31618207ae71d3db9cc6eef505645cdc893/src%2Frt%2Fsync%2Flock_and_signal.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.cpp?ref=bc9fa31618207ae71d3db9cc6eef505645cdc893", "patch": "@@ -11,7 +11,7 @@\n \n #if defined(__WIN32__)\n lock_and_signal::lock_and_signal() {\n-    // TODO: In order to match the behavior of pthread_cond_broadcast on\n+    // FIXME: In order to match the behavior of pthread_cond_broadcast on\n     // Windows, we create manual reset events. This however breaks the\n     // behavior of pthread_cond_signal, fixing this is quite involved:\n     // refer to: http://www.cs.wustl.edu/~schmidt/win32-cv-1.html"}, {"sha": "cf82818c4ff0a9741db0b9f88b034093214cdbb1", "filename": "src/rt/test/rust_test_runtime.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc9fa31618207ae71d3db9cc6eef505645cdc893/src%2Frt%2Ftest%2Frust_test_runtime.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bc9fa31618207ae71d3db9cc6eef505645cdc893/src%2Frt%2Ftest%2Frust_test_runtime.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Ftest%2Frust_test_runtime.cpp?ref=bc9fa31618207ae71d3db9cc6eef505645cdc893", "patch": "@@ -1,11 +1,9 @@\n #include \"rust_test_runtime.h\"\n \n rust_test_runtime::rust_test_runtime() {\n-    // TODO Auto-generated constructor stub\n }\n \n rust_test_runtime::~rust_test_runtime() {\n-    // TODO Auto-generated destructor stub\n }\n \n #define DOMAINS 32"}]}