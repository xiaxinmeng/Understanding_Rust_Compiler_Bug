{"sha": "6636f56e79b55f22b88094b7edaed6ec88880500", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MzZmNTZlNzliNTVmMjJiODgwOTRiN2VkYWVkNmVjODg4ODA1MDA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-29T22:23:03Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-29T22:23:03Z"}, "message": "Rename ModuleItem -> Item", "tree": {"sha": "d042009ea61be66aee1710070c09893447847c9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d042009ea61be66aee1710070c09893447847c9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6636f56e79b55f22b88094b7edaed6ec88880500", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6636f56e79b55f22b88094b7edaed6ec88880500", "html_url": "https://github.com/rust-lang/rust/commit/6636f56e79b55f22b88094b7edaed6ec88880500", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6636f56e79b55f22b88094b7edaed6ec88880500/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16caadb404de465d8ea1cb6a107740ef004f232b", "url": "https://api.github.com/repos/rust-lang/rust/commits/16caadb404de465d8ea1cb6a107740ef004f232b", "html_url": "https://github.com/rust-lang/rust/commit/16caadb404de465d8ea1cb6a107740ef004f232b"}], "stats": {"total": 977, "additions": 485, "deletions": 492}, "files": [{"sha": "c33b645f31397fc71ef7b6b978d258b71cc0642b", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -627,53 +627,53 @@ impl ExprCollector<'_> {\n             .items()\n             .filter_map(|item| {\n                 let (def, name): (ModuleDefId, Option<ast::Name>) = match item {\n-                    ast::ModuleItem::FnDef(def) => {\n+                    ast::Item::FnDef(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (\n                             FunctionLoc { container: container.into(), id }.intern(self.db).into(),\n                             def.name(),\n                         )\n                     }\n-                    ast::ModuleItem::TypeAliasDef(def) => {\n+                    ast::Item::TypeAliasDef(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (\n                             TypeAliasLoc { container: container.into(), id }.intern(self.db).into(),\n                             def.name(),\n                         )\n                     }\n-                    ast::ModuleItem::ConstDef(def) => {\n+                    ast::Item::ConstDef(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (\n                             ConstLoc { container: container.into(), id }.intern(self.db).into(),\n                             def.name(),\n                         )\n                     }\n-                    ast::ModuleItem::StaticDef(def) => {\n+                    ast::Item::StaticDef(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (StaticLoc { container, id }.intern(self.db).into(), def.name())\n                     }\n-                    ast::ModuleItem::StructDef(def) => {\n+                    ast::Item::StructDef(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (StructLoc { container, id }.intern(self.db).into(), def.name())\n                     }\n-                    ast::ModuleItem::EnumDef(def) => {\n+                    ast::Item::EnumDef(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (EnumLoc { container, id }.intern(self.db).into(), def.name())\n                     }\n-                    ast::ModuleItem::UnionDef(def) => {\n+                    ast::Item::UnionDef(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (UnionLoc { container, id }.intern(self.db).into(), def.name())\n                     }\n-                    ast::ModuleItem::TraitDef(def) => {\n+                    ast::Item::TraitDef(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (TraitLoc { container, id }.intern(self.db).into(), def.name())\n                     }\n-                    ast::ModuleItem::ExternBlock(_) => return None, // FIXME: collect from extern blocks\n-                    ast::ModuleItem::ImplDef(_)\n-                    | ast::ModuleItem::UseItem(_)\n-                    | ast::ModuleItem::ExternCrateItem(_)\n-                    | ast::ModuleItem::Module(_)\n-                    | ast::ModuleItem::MacroCall(_) => return None,\n+                    ast::Item::ExternBlock(_) => return None, // FIXME: collect from extern blocks\n+                    ast::Item::ImplDef(_)\n+                    | ast::Item::UseItem(_)\n+                    | ast::Item::ExternCrateItem(_)\n+                    | ast::Item::Module(_)\n+                    | ast::Item::MacroCall(_) => return None,\n                 };\n \n                 Some((def, name))"}, {"sha": "615c1e14ca489c728b8ca2e0ac24a00d424af0de", "filename": "crates/ra_hir_def/src/item_tree.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -70,7 +70,7 @@ impl GenericParamsId {\n pub struct ItemTree {\n     top_level: SmallVec<[ModItem; 1]>,\n     attrs: FxHashMap<AttrOwner, Attrs>,\n-    inner_items: FxHashMap<FileAstId<ast::ModuleItem>, SmallVec<[ModItem; 1]>>,\n+    inner_items: FxHashMap<FileAstId<ast::Item>, SmallVec<[ModItem; 1]>>,\n \n     data: Option<Box<ItemTreeData>>,\n }\n@@ -187,7 +187,7 @@ impl ItemTree {\n     ///\n     /// Most AST items are lowered to a single `ModItem`, but some (eg. `use` items) may be lowered\n     /// to multiple items in the `ItemTree`.\n-    pub fn inner_items(&self, ast: FileAstId<ast::ModuleItem>) -> &[ModItem] {\n+    pub fn inner_items(&self, ast: FileAstId<ast::Item>) -> &[ModItem] {\n         &self.inner_items[&ast]\n     }\n \n@@ -310,7 +310,7 @@ from_attrs!(ModItem(ModItem), Variant(Idx<Variant>), Field(Idx<Field>));\n \n /// Trait implemented by all item nodes in the item tree.\n pub trait ItemTreeNode: Clone {\n-    type Source: AstNode + Into<ast::ModuleItem>;\n+    type Source: AstNode + Into<ast::Item>;\n \n     fn ast_id(&self) -> FileAstId<Self::Source>;\n "}, {"sha": "eb1da463207df0f0c16b8d68b79621afa083f3cc", "filename": "crates/ra_hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -70,19 +70,19 @@ impl Ctx {\n         self.tree.data_mut()\n     }\n \n-    fn lower_mod_item(&mut self, item: &ast::ModuleItem, inner: bool) -> Option<ModItems> {\n+    fn lower_mod_item(&mut self, item: &ast::Item, inner: bool) -> Option<ModItems> {\n         assert!(inner || self.inner_items.is_empty());\n \n         // Collect inner items for 1-to-1-lowered items.\n         match item {\n-            ast::ModuleItem::StructDef(_)\n-            | ast::ModuleItem::UnionDef(_)\n-            | ast::ModuleItem::EnumDef(_)\n-            | ast::ModuleItem::FnDef(_)\n-            | ast::ModuleItem::TypeAliasDef(_)\n-            | ast::ModuleItem::ConstDef(_)\n-            | ast::ModuleItem::StaticDef(_)\n-            | ast::ModuleItem::MacroCall(_) => {\n+            ast::Item::StructDef(_)\n+            | ast::Item::UnionDef(_)\n+            | ast::Item::EnumDef(_)\n+            | ast::Item::FnDef(_)\n+            | ast::Item::TypeAliasDef(_)\n+            | ast::Item::ConstDef(_)\n+            | ast::Item::StaticDef(_)\n+            | ast::Item::MacroCall(_) => {\n                 // Skip this if we're already collecting inner items. We'll descend into all nodes\n                 // already.\n                 if !inner {\n@@ -92,34 +92,30 @@ impl Ctx {\n \n             // These are handled in their respective `lower_X` method (since we can't just blindly\n             // walk them).\n-            ast::ModuleItem::TraitDef(_)\n-            | ast::ModuleItem::ImplDef(_)\n-            | ast::ModuleItem::ExternBlock(_) => {}\n+            ast::Item::TraitDef(_) | ast::Item::ImplDef(_) | ast::Item::ExternBlock(_) => {}\n \n             // These don't have inner items.\n-            ast::ModuleItem::Module(_)\n-            | ast::ModuleItem::ExternCrateItem(_)\n-            | ast::ModuleItem::UseItem(_) => {}\n+            ast::Item::Module(_) | ast::Item::ExternCrateItem(_) | ast::Item::UseItem(_) => {}\n         };\n \n         let attrs = Attrs::new(item, &self.hygiene);\n         let items = match item {\n-            ast::ModuleItem::StructDef(ast) => self.lower_struct(ast).map(Into::into),\n-            ast::ModuleItem::UnionDef(ast) => self.lower_union(ast).map(Into::into),\n-            ast::ModuleItem::EnumDef(ast) => self.lower_enum(ast).map(Into::into),\n-            ast::ModuleItem::FnDef(ast) => self.lower_function(ast).map(Into::into),\n-            ast::ModuleItem::TypeAliasDef(ast) => self.lower_type_alias(ast).map(Into::into),\n-            ast::ModuleItem::StaticDef(ast) => self.lower_static(ast).map(Into::into),\n-            ast::ModuleItem::ConstDef(ast) => Some(self.lower_const(ast).into()),\n-            ast::ModuleItem::Module(ast) => self.lower_module(ast).map(Into::into),\n-            ast::ModuleItem::TraitDef(ast) => self.lower_trait(ast).map(Into::into),\n-            ast::ModuleItem::ImplDef(ast) => self.lower_impl(ast).map(Into::into),\n-            ast::ModuleItem::UseItem(ast) => Some(ModItems(\n+            ast::Item::StructDef(ast) => self.lower_struct(ast).map(Into::into),\n+            ast::Item::UnionDef(ast) => self.lower_union(ast).map(Into::into),\n+            ast::Item::EnumDef(ast) => self.lower_enum(ast).map(Into::into),\n+            ast::Item::FnDef(ast) => self.lower_function(ast).map(Into::into),\n+            ast::Item::TypeAliasDef(ast) => self.lower_type_alias(ast).map(Into::into),\n+            ast::Item::StaticDef(ast) => self.lower_static(ast).map(Into::into),\n+            ast::Item::ConstDef(ast) => Some(self.lower_const(ast).into()),\n+            ast::Item::Module(ast) => self.lower_module(ast).map(Into::into),\n+            ast::Item::TraitDef(ast) => self.lower_trait(ast).map(Into::into),\n+            ast::Item::ImplDef(ast) => self.lower_impl(ast).map(Into::into),\n+            ast::Item::UseItem(ast) => Some(ModItems(\n                 self.lower_use(ast).into_iter().map(Into::into).collect::<SmallVec<_>>(),\n             )),\n-            ast::ModuleItem::ExternCrateItem(ast) => self.lower_extern_crate(ast).map(Into::into),\n-            ast::ModuleItem::MacroCall(ast) => self.lower_macro_call(ast).map(Into::into),\n-            ast::ModuleItem::ExternBlock(ast) => {\n+            ast::Item::ExternCrateItem(ast) => self.lower_extern_crate(ast).map(Into::into),\n+            ast::Item::MacroCall(ast) => self.lower_macro_call(ast).map(Into::into),\n+            ast::Item::ExternBlock(ast) => {\n                 Some(ModItems(self.lower_extern_block(ast).into_iter().collect::<SmallVec<_>>()))\n             }\n         };\n@@ -147,22 +143,22 @@ impl Ctx {\n     fn collect_inner_items(&mut self, container: &SyntaxNode) {\n         let forced_vis = self.forced_visibility.take();\n         let mut inner_items = mem::take(&mut self.tree.inner_items);\n-        inner_items.extend(\n-            container.descendants().skip(1).filter_map(ast::ModuleItem::cast).filter_map(|item| {\n+        inner_items.extend(container.descendants().skip(1).filter_map(ast::Item::cast).filter_map(\n+            |item| {\n                 let ast_id = self.source_ast_id_map.ast_id(&item);\n                 Some((ast_id, self.lower_mod_item(&item, true)?.0))\n-            }),\n-        );\n+            },\n+        ));\n         self.tree.inner_items = inner_items;\n         self.forced_visibility = forced_vis;\n     }\n \n-    fn lower_assoc_item(&mut self, item: &ast::ModuleItem) -> Option<AssocItem> {\n+    fn lower_assoc_item(&mut self, item: &ast::Item) -> Option<AssocItem> {\n         match item {\n-            ast::ModuleItem::FnDef(ast) => self.lower_function(ast).map(Into::into),\n-            ast::ModuleItem::TypeAliasDef(ast) => self.lower_type_alias(ast).map(Into::into),\n-            ast::ModuleItem::ConstDef(ast) => Some(self.lower_const(ast).into()),\n-            ast::ModuleItem::MacroCall(ast) => self.lower_macro_call(ast).map(Into::into),\n+            ast::Item::FnDef(ast) => self.lower_function(ast).map(Into::into),\n+            ast::Item::TypeAliasDef(ast) => self.lower_type_alias(ast).map(Into::into),\n+            ast::Item::ConstDef(ast) => Some(self.lower_const(ast).into()),\n+            ast::Item::MacroCall(ast) => self.lower_macro_call(ast).map(Into::into),\n             _ => None,\n         }\n     }"}, {"sha": "a6057ceab58d3882f15ad48f0e3ed13d4207907c", "filename": "crates/ra_hir_def/src/item_tree/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -21,7 +21,7 @@ fn test_inner_items(ra_fixture: &str) {\n     let mut outer_items = FxHashSet::default();\n     let mut worklist = tree.top_level_items().to_vec();\n     while let Some(item) = worklist.pop() {\n-        let node: ast::ModuleItem = match item {\n+        let node: ast::Item = match item {\n             ModItem::Import(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n             ModItem::ExternCrate(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n             ModItem::Function(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n@@ -53,7 +53,7 @@ fn test_inner_items(ra_fixture: &str) {\n \n     // Now descend the root node and check that all `ast::ModuleItem`s are either recorded above, or\n     // registered as inner items.\n-    for item in root.descendants().skip(1).filter_map(ast::ModuleItem::cast) {\n+    for item in root.descendants().skip(1).filter_map(ast::Item::cast) {\n         if outer_items.contains(&item) {\n             continue;\n         }\n@@ -279,7 +279,7 @@ fn simple_inner_items() {\n \n             inner items:\n \n-            for AST FileAstId::<ra_syntax::ast::generated::nodes::ModuleItem>(2):\n+            for AST FileAstId::<ra_syntax::ast::generated::nodes::Item>(2):\n             Function { name: Name(Text(\"end\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(2) }\n \n         \"#]],\n@@ -412,7 +412,7 @@ fn inner_item_attrs() {\n \n             inner items:\n \n-            for AST FileAstId::<ra_syntax::ast::generated::nodes::ModuleItem>(1):\n+            for AST FileAstId::<ra_syntax::ast::generated::nodes::Item>(1):\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"on_inner\"))] }, input: None }]) }]\n             Function { name: Name(Text(\"inner\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(1) }\n "}, {"sha": "237b1038afcfe52447b1cc347330f24c3c085916", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -521,7 +521,7 @@ impl AsMacroCall for AstIdWithPath<ast::MacroCall> {\n     }\n }\n \n-impl AsMacroCall for AstIdWithPath<ast::ModuleItem> {\n+impl AsMacroCall for AstIdWithPath<ast::Item> {\n     fn as_call_id(\n         &self,\n         db: &dyn db::DefDatabase,"}, {"sha": "28b7a20c552910b7f35e5217b5a09a4742861606", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -170,7 +170,7 @@ struct MacroDirective {\n #[derive(Clone, Debug, Eq, PartialEq)]\n struct DeriveDirective {\n     module_id: LocalModuleId,\n-    ast_id: AstIdWithPath<ast::ModuleItem>,\n+    ast_id: AstIdWithPath<ast::Item>,\n }\n \n struct DefData<'a> {\n@@ -1100,7 +1100,7 @@ impl ModCollector<'_, '_> {\n         res\n     }\n \n-    fn collect_derives(&mut self, attrs: &Attrs, ast_id: FileAstId<ast::ModuleItem>) {\n+    fn collect_derives(&mut self, attrs: &Attrs, ast_id: FileAstId<ast::Item>) {\n         for derive_subtree in attrs.by_key(\"derive\").tt_values() {\n             // for #[derive(Copy, Clone)], `derive_subtree` is the `(Copy, Clone)` subtree\n             for tt in &derive_subtree.token_trees {"}, {"sha": "8bfe1b4ba7d3357f36682c56e76cf2515d8cbc30", "filename": "crates/ra_hir_expand/src/ast_id_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -73,7 +73,7 @@ impl AstIdMap {\n         // change parent's id. This means that, say, adding a new function to a\n         // trait does not change ids of top-level items, which helps caching.\n         bfs(node, |it| {\n-            if let Some(module_item) = ast::ModuleItem::cast(it) {\n+            if let Some(module_item) = ast::Item::cast(it) {\n                 res.alloc(module_item.syntax());\n             }\n         });"}, {"sha": "8f70a3567093cb17f80005b6c1017cc76acddea0", "filename": "crates/ra_hir_expand/src/builtin_derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -276,7 +276,7 @@ mod tests {\n         let file_id = file_pos.file_id;\n         let parsed = db.parse(file_id);\n         let items: Vec<_> =\n-            parsed.syntax_node().descendants().filter_map(ast::ModuleItem::cast).collect();\n+            parsed.syntax_node().descendants().filter_map(ast::Item::cast).collect();\n \n         let ast_id_map = db.ast_id_map(file_id.into());\n "}, {"sha": "2e8d63691716b9f1190a5b5604bc65711464da18", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -159,7 +159,7 @@ impl HirFileId {\n     }\n \n     /// Indicate it is macro file generated for builtin derive\n-    pub fn is_builtin_derive(&self, db: &dyn db::AstDatabase) -> Option<InFile<ast::ModuleItem>> {\n+    pub fn is_builtin_derive(&self, db: &dyn db::AstDatabase) -> Option<InFile<ast::Item>> {\n         match self.0 {\n             HirFileIdRepr::FileId(_) => None,\n             HirFileIdRepr::MacroFile(macro_file) => {\n@@ -174,7 +174,7 @@ impl HirFileId {\n                     MacroDefKind::BuiltInDerive(_) => loc.kind.node(db),\n                     _ => return None,\n                 };\n-                Some(item.with_value(ast::ModuleItem::cast(item.value.clone())?))\n+                Some(item.with_value(ast::Item::cast(item.value.clone())?))\n             }\n         }\n     }\n@@ -258,7 +258,7 @@ pub struct MacroCallLoc {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum MacroCallKind {\n     FnLike(AstId<ast::MacroCall>),\n-    Attr(AstId<ast::ModuleItem>, String),\n+    Attr(AstId<ast::Item>, String),\n }\n \n impl MacroCallKind {"}, {"sha": "7a53083f5404b4f63e19abb192c540ee59491cdd", "filename": "crates/ra_ide/src/completion/complete_fn_param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -28,7 +28,7 @@ pub(super) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext)\n             }\n         };\n         for item in items {\n-            if let ast::ModuleItem::FnDef(func) = item {\n+            if let ast::Item::FnDef(func) = item {\n                 if Some(&func) == me.as_ref() {\n                     continue;\n                 }"}, {"sha": "f612835c2ac9ff1073e242479bcb28ef17428f72", "filename": "crates/ra_ide/src/runnables.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Frunnables.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -246,12 +246,12 @@ fn has_test_function_or_multiple_test_submodules(module: &ast::Module) -> bool {\n \n         for item in item_list.items() {\n             match item {\n-                ast::ModuleItem::FnDef(f) => {\n+                ast::Item::FnDef(f) => {\n                     if has_test_related_attribute(&f) {\n                         return true;\n                     }\n                 }\n-                ast::ModuleItem::Module(submodule) => {\n+                ast::Item::Module(submodule) => {\n                     if has_test_function_or_multiple_test_submodules(&submodule) {\n                         number_of_test_submodules += 1;\n                     }"}, {"sha": "78e03f394be5b6a42b1791e58262c745415c744a", "filename": "crates/ra_ssr/src/parsing.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fparsing.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -71,10 +71,7 @@ impl ParsedRule {\n         };\n         builder.try_add(ast::Expr::parse(&raw_pattern), raw_template.map(ast::Expr::parse));\n         builder.try_add(ast::TypeRef::parse(&raw_pattern), raw_template.map(ast::TypeRef::parse));\n-        builder.try_add(\n-            ast::ModuleItem::parse(&raw_pattern),\n-            raw_template.map(ast::ModuleItem::parse),\n-        );\n+        builder.try_add(ast::Item::parse(&raw_pattern), raw_template.map(ast::Item::parse));\n         builder.try_add(ast::Path::parse(&raw_pattern), raw_template.map(ast::Path::parse));\n         builder.try_add(ast::Pat::parse(&raw_pattern), raw_template.map(ast::Pat::parse));\n         builder.build()"}, {"sha": "3c8bdfcad743f4de3ba6520f603149b38ac31af6", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 394, "deletions": 394, "changes": 788, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -26,6 +26,57 @@ impl Attr {\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ConstDef {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for ConstDef {}\n+impl ast::NameOwner for ConstDef {}\n+impl ast::VisibilityOwner for ConstDef {}\n+impl ast::TypeAscriptionOwner for ConstDef {}\n+impl ConstDef {\n+    pub fn default_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![default]) }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n+    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n+    pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct EnumDef {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for EnumDef {}\n+impl ast::NameOwner for EnumDef {}\n+impl ast::VisibilityOwner for EnumDef {}\n+impl ast::TypeParamsOwner for EnumDef {}\n+impl EnumDef {\n+    pub fn enum_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![enum]) }\n+    pub fn variant_list(&self) -> Option<EnumVariantList> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ExternBlock {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for ExternBlock {}\n+impl ExternBlock {\n+    pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n+    pub fn extern_item_list(&self) -> Option<ExternItemList> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ExternCrateItem {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for ExternCrateItem {}\n+impl ast::VisibilityOwner for ExternCrateItem {}\n+impl ExternCrateItem {\n+    pub fn extern_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![extern]) }\n+    pub fn crate_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![crate]) }\n+    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n+    pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }\n+    pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FnDef {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -46,6 +97,131 @@ impl FnDef {\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ImplDef {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for ImplDef {}\n+impl ast::VisibilityOwner for ImplDef {}\n+impl ast::TypeParamsOwner for ImplDef {}\n+impl ImplDef {\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n+    pub fn default_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![default]) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n+    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![impl]) }\n+    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n+    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n+    pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MacroCall {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for MacroCall {}\n+impl ast::NameOwner for MacroCall {}\n+impl MacroCall {\n+    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n+    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n+    pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Module {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for Module {}\n+impl ast::NameOwner for Module {}\n+impl ast::VisibilityOwner for Module {}\n+impl Module {\n+    pub fn mod_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mod]) }\n+    pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct StaticDef {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for StaticDef {}\n+impl ast::NameOwner for StaticDef {}\n+impl ast::VisibilityOwner for StaticDef {}\n+impl ast::TypeAscriptionOwner for StaticDef {}\n+impl StaticDef {\n+    pub fn static_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![static]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n+    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n+    pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct StructDef {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for StructDef {}\n+impl ast::NameOwner for StructDef {}\n+impl ast::VisibilityOwner for StructDef {}\n+impl ast::TypeParamsOwner for StructDef {}\n+impl StructDef {\n+    pub fn struct_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![struct]) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+    pub fn field_def_list(&self) -> Option<FieldDefList> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TraitDef {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for TraitDef {}\n+impl ast::NameOwner for TraitDef {}\n+impl ast::VisibilityOwner for TraitDef {}\n+impl ast::TypeParamsOwner for TraitDef {}\n+impl ast::TypeBoundsOwner for TraitDef {}\n+impl TraitDef {\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n+    pub fn auto_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![auto]) }\n+    pub fn trait_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![trait]) }\n+    pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TypeAliasDef {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for TypeAliasDef {}\n+impl ast::NameOwner for TypeAliasDef {}\n+impl ast::VisibilityOwner for TypeAliasDef {}\n+impl ast::TypeParamsOwner for TypeAliasDef {}\n+impl ast::TypeBoundsOwner for TypeAliasDef {}\n+impl TypeAliasDef {\n+    pub fn default_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![default]) }\n+    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![type]) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n+    pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct UnionDef {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for UnionDef {}\n+impl ast::NameOwner for UnionDef {}\n+impl ast::VisibilityOwner for UnionDef {}\n+impl ast::TypeParamsOwner for UnionDef {}\n+impl UnionDef {\n+    pub fn union_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![union]) }\n+    pub fn record_field_def_list(&self) -> Option<RecordFieldDefList> {\n+        support::child(&self.syntax)\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct UseItem {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for UseItem {}\n+impl ast::VisibilityOwner for UseItem {}\n+impl UseItem {\n+    pub fn use_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![use]) }\n+    pub fn use_tree(&self) -> Option<UseTree> { support::child(&self.syntax) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Visibility {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -122,19 +298,6 @@ impl BlockExpr {\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct StructDef {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for StructDef {}\n-impl ast::NameOwner for StructDef {}\n-impl ast::VisibilityOwner for StructDef {}\n-impl ast::TypeParamsOwner for StructDef {}\n-impl StructDef {\n-    pub fn struct_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![struct]) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n-    pub fn field_def_list(&self) -> Option<FieldDefList> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldDefList {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -153,20 +316,6 @@ impl TupleFieldDefList {\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct UnionDef {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for UnionDef {}\n-impl ast::NameOwner for UnionDef {}\n-impl ast::VisibilityOwner for UnionDef {}\n-impl ast::TypeParamsOwner for UnionDef {}\n-impl UnionDef {\n-    pub fn union_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![union]) }\n-    pub fn record_field_def_list(&self) -> Option<RecordFieldDefList> {\n-        support::child(&self.syntax)\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldDef {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -188,18 +337,6 @@ impl TupleFieldDef {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct EnumDef {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for EnumDef {}\n-impl ast::NameOwner for EnumDef {}\n-impl ast::VisibilityOwner for EnumDef {}\n-impl ast::TypeParamsOwner for EnumDef {}\n-impl EnumDef {\n-    pub fn enum_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![enum]) }\n-    pub fn variant_list(&self) -> Option<EnumVariantList> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EnumVariantList {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -221,21 +358,6 @@ impl EnumVariant {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TraitDef {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for TraitDef {}\n-impl ast::NameOwner for TraitDef {}\n-impl ast::VisibilityOwner for TraitDef {}\n-impl ast::TypeParamsOwner for TraitDef {}\n-impl ast::TypeBoundsOwner for TraitDef {}\n-impl TraitDef {\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n-    pub fn auto_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![auto]) }\n-    pub fn trait_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![trait]) }\n-    pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBoundList {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -253,82 +375,6 @@ impl ItemList {\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Module {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for Module {}\n-impl ast::NameOwner for Module {}\n-impl ast::VisibilityOwner for Module {}\n-impl Module {\n-    pub fn mod_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mod]) }\n-    pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ConstDef {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for ConstDef {}\n-impl ast::NameOwner for ConstDef {}\n-impl ast::VisibilityOwner for ConstDef {}\n-impl ast::TypeAscriptionOwner for ConstDef {}\n-impl ConstDef {\n-    pub fn default_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![default]) }\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n-    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n-    pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct StaticDef {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for StaticDef {}\n-impl ast::NameOwner for StaticDef {}\n-impl ast::VisibilityOwner for StaticDef {}\n-impl ast::TypeAscriptionOwner for StaticDef {}\n-impl StaticDef {\n-    pub fn static_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![static]) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n-    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n-    pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TypeAliasDef {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for TypeAliasDef {}\n-impl ast::NameOwner for TypeAliasDef {}\n-impl ast::VisibilityOwner for TypeAliasDef {}\n-impl ast::TypeParamsOwner for TypeAliasDef {}\n-impl ast::TypeBoundsOwner for TypeAliasDef {}\n-impl TypeAliasDef {\n-    pub fn default_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![default]) }\n-    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![type]) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n-    pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ImplDef {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for ImplDef {}\n-impl ast::VisibilityOwner for ImplDef {}\n-impl ast::TypeParamsOwner for ImplDef {}\n-impl ImplDef {\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n-    pub fn default_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![default]) }\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n-    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![impl]) }\n-    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n-    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n-    pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenType {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -920,18 +966,6 @@ impl MacroPat {\n     pub fn macro_call(&self) -> Option<MacroCall> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MacroCall {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for MacroCall {}\n-impl ast::NameOwner for MacroCall {}\n-impl MacroCall {\n-    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n-    pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordPat {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -1125,17 +1159,6 @@ impl Param {\n     pub fn dotdotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![...]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct UseItem {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for UseItem {}\n-impl ast::VisibilityOwner for UseItem {}\n-impl UseItem {\n-    pub fn use_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![use]) }\n-    pub fn use_tree(&self) -> Option<UseTree> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseTree {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -1164,20 +1187,6 @@ impl Alias {\n     pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ExternCrateItem {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for ExternCrateItem {}\n-impl ast::VisibilityOwner for ExternCrateItem {}\n-impl ExternCrateItem {\n-    pub fn extern_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![extern]) }\n-    pub fn crate_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![crate]) }\n-    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }\n-    pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathSegment {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -1229,15 +1238,6 @@ impl ConstArg {\n     pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ExternBlock {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for ExternBlock {}\n-impl ExternBlock {\n-    pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n-    pub fn extern_item_list(&self) -> Option<ExternItemList> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternItemList {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -1257,23 +1257,23 @@ impl MetaItem {\n     pub fn nested_meta_items(&self) -> AstChildren<MetaItem> { support::children(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum ModuleItem {\n-    StructDef(StructDef),\n-    UnionDef(UnionDef),\n+pub enum Item {\n+    ConstDef(ConstDef),\n     EnumDef(EnumDef),\n+    ExternBlock(ExternBlock),\n+    ExternCrateItem(ExternCrateItem),\n     FnDef(FnDef),\n+    ImplDef(ImplDef),\n+    MacroCall(MacroCall),\n+    Module(Module),\n+    StaticDef(StaticDef),\n+    StructDef(StructDef),\n     TraitDef(TraitDef),\n     TypeAliasDef(TypeAliasDef),\n-    ImplDef(ImplDef),\n+    UnionDef(UnionDef),\n     UseItem(UseItem),\n-    ExternCrateItem(ExternCrateItem),\n-    ConstDef(ConstDef),\n-    StaticDef(StaticDef),\n-    Module(Module),\n-    MacroCall(MacroCall),\n-    ExternBlock(ExternBlock),\n }\n-impl ast::AttrsOwner for ModuleItem {}\n+impl ast::AttrsOwner for Item {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum TypeRef {\n     ParenType(ParenType),\n@@ -1381,12 +1381,45 @@ pub enum AdtDef {\n     EnumDef(EnumDef),\n     UnionDef(UnionDef),\n }\n-impl ast::AttrsOwner for AdtDef {}\n-impl ast::NameOwner for AdtDef {}\n-impl ast::TypeParamsOwner for AdtDef {}\n-impl ast::VisibilityOwner for AdtDef {}\n-impl AstNode for SourceFile {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }\n+impl ast::AttrsOwner for AdtDef {}\n+impl ast::NameOwner for AdtDef {}\n+impl ast::TypeParamsOwner for AdtDef {}\n+impl ast::VisibilityOwner for AdtDef {}\n+impl AstNode for SourceFile {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for Attr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ATTR }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for ConstDef {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST_DEF }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for EnumDef {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ENUM_DEF }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1396,8 +1429,19 @@ impl AstNode for SourceFile {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Attr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ATTR }\n+impl AstNode for ExternBlock {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EXTERN_BLOCK }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for ExternCrateItem {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EXTERN_CRATE_ITEM }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1418,8 +1462,8 @@ impl AstNode for FnDef {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Visibility {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == VISIBILITY }\n+impl AstNode for ImplDef {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == IMPL_DEF }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1429,8 +1473,8 @@ impl AstNode for Visibility {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Abi {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ABI }\n+impl AstNode for MacroCall {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MACRO_CALL }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1440,8 +1484,8 @@ impl AstNode for Abi {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Name {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }\n+impl AstNode for Module {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MODULE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1451,8 +1495,8 @@ impl AstNode for Name {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TypeParamList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_PARAM_LIST }\n+impl AstNode for StaticDef {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STATIC_DEF }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1462,8 +1506,8 @@ impl AstNode for TypeParamList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ParamList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM_LIST }\n+impl AstNode for StructDef {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_DEF }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1473,8 +1517,8 @@ impl AstNode for ParamList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RetType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RET_TYPE }\n+impl AstNode for TraitDef {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TRAIT_DEF }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1484,8 +1528,8 @@ impl AstNode for RetType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for WhereClause {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == WHERE_CLAUSE }\n+impl AstNode for TypeAliasDef {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ALIAS_DEF }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1495,8 +1539,8 @@ impl AstNode for WhereClause {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for BlockExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == BLOCK_EXPR }\n+impl AstNode for UnionDef {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == UNION_DEF }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1506,8 +1550,8 @@ impl AstNode for BlockExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for StructDef {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_DEF }\n+impl AstNode for UseItem {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_ITEM }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1517,8 +1561,8 @@ impl AstNode for StructDef {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RecordFieldDefList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_FIELD_DEF_LIST }\n+impl AstNode for Visibility {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == VISIBILITY }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1528,8 +1572,8 @@ impl AstNode for RecordFieldDefList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TupleFieldDefList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_FIELD_DEF_LIST }\n+impl AstNode for Abi {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ABI }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1539,8 +1583,8 @@ impl AstNode for TupleFieldDefList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for UnionDef {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == UNION_DEF }\n+impl AstNode for Name {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1550,8 +1594,8 @@ impl AstNode for UnionDef {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RecordFieldDef {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_FIELD_DEF }\n+impl AstNode for TypeParamList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_PARAM_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1561,8 +1605,8 @@ impl AstNode for RecordFieldDef {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TupleFieldDef {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_FIELD_DEF }\n+impl AstNode for ParamList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1572,8 +1616,8 @@ impl AstNode for TupleFieldDef {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for EnumDef {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ENUM_DEF }\n+impl AstNode for RetType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RET_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1583,8 +1627,8 @@ impl AstNode for EnumDef {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for EnumVariantList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ENUM_VARIANT_LIST }\n+impl AstNode for WhereClause {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == WHERE_CLAUSE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1594,8 +1638,8 @@ impl AstNode for EnumVariantList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for EnumVariant {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ENUM_VARIANT }\n+impl AstNode for BlockExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BLOCK_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1605,8 +1649,8 @@ impl AstNode for EnumVariant {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TraitDef {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TRAIT_DEF }\n+impl AstNode for RecordFieldDefList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_FIELD_DEF_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1616,8 +1660,8 @@ impl AstNode for TraitDef {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TypeBoundList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND_LIST }\n+impl AstNode for TupleFieldDefList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_FIELD_DEF_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1627,8 +1671,8 @@ impl AstNode for TypeBoundList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ItemList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ITEM_LIST }\n+impl AstNode for RecordFieldDef {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_FIELD_DEF }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1638,8 +1682,8 @@ impl AstNode for ItemList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Module {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MODULE }\n+impl AstNode for TupleFieldDef {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_FIELD_DEF }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1649,8 +1693,8 @@ impl AstNode for Module {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ConstDef {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST_DEF }\n+impl AstNode for EnumVariantList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ENUM_VARIANT_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1660,8 +1704,8 @@ impl AstNode for ConstDef {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for StaticDef {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == STATIC_DEF }\n+impl AstNode for EnumVariant {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ENUM_VARIANT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1671,8 +1715,8 @@ impl AstNode for StaticDef {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TypeAliasDef {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ALIAS_DEF }\n+impl AstNode for TypeBoundList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1682,8 +1726,8 @@ impl AstNode for TypeAliasDef {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ImplDef {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == IMPL_DEF }\n+impl AstNode for ItemList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ITEM_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2397,17 +2441,6 @@ impl AstNode for MacroPat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MacroCall {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MACRO_CALL }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for RecordPat {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2606,17 +2639,6 @@ impl AstNode for Param {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for UseItem {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_ITEM }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for UseTree {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == USE_TREE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2650,17 +2672,6 @@ impl AstNode for Alias {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ExternCrateItem {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == EXTERN_CRATE_ITEM }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for PathSegment {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_SEGMENT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2716,17 +2727,6 @@ impl AstNode for ConstArg {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ExternBlock {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == EXTERN_BLOCK }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for ExternItemList {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == EXTERN_ITEM_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2749,93 +2749,93 @@ impl AstNode for MetaItem {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl From<StructDef> for ModuleItem {\n-    fn from(node: StructDef) -> ModuleItem { ModuleItem::StructDef(node) }\n+impl From<ConstDef> for Item {\n+    fn from(node: ConstDef) -> Item { Item::ConstDef(node) }\n }\n-impl From<UnionDef> for ModuleItem {\n-    fn from(node: UnionDef) -> ModuleItem { ModuleItem::UnionDef(node) }\n+impl From<EnumDef> for Item {\n+    fn from(node: EnumDef) -> Item { Item::EnumDef(node) }\n }\n-impl From<EnumDef> for ModuleItem {\n-    fn from(node: EnumDef) -> ModuleItem { ModuleItem::EnumDef(node) }\n+impl From<ExternBlock> for Item {\n+    fn from(node: ExternBlock) -> Item { Item::ExternBlock(node) }\n }\n-impl From<FnDef> for ModuleItem {\n-    fn from(node: FnDef) -> ModuleItem { ModuleItem::FnDef(node) }\n+impl From<ExternCrateItem> for Item {\n+    fn from(node: ExternCrateItem) -> Item { Item::ExternCrateItem(node) }\n }\n-impl From<TraitDef> for ModuleItem {\n-    fn from(node: TraitDef) -> ModuleItem { ModuleItem::TraitDef(node) }\n+impl From<FnDef> for Item {\n+    fn from(node: FnDef) -> Item { Item::FnDef(node) }\n }\n-impl From<TypeAliasDef> for ModuleItem {\n-    fn from(node: TypeAliasDef) -> ModuleItem { ModuleItem::TypeAliasDef(node) }\n+impl From<ImplDef> for Item {\n+    fn from(node: ImplDef) -> Item { Item::ImplDef(node) }\n }\n-impl From<ImplDef> for ModuleItem {\n-    fn from(node: ImplDef) -> ModuleItem { ModuleItem::ImplDef(node) }\n+impl From<MacroCall> for Item {\n+    fn from(node: MacroCall) -> Item { Item::MacroCall(node) }\n }\n-impl From<UseItem> for ModuleItem {\n-    fn from(node: UseItem) -> ModuleItem { ModuleItem::UseItem(node) }\n+impl From<Module> for Item {\n+    fn from(node: Module) -> Item { Item::Module(node) }\n }\n-impl From<ExternCrateItem> for ModuleItem {\n-    fn from(node: ExternCrateItem) -> ModuleItem { ModuleItem::ExternCrateItem(node) }\n+impl From<StaticDef> for Item {\n+    fn from(node: StaticDef) -> Item { Item::StaticDef(node) }\n }\n-impl From<ConstDef> for ModuleItem {\n-    fn from(node: ConstDef) -> ModuleItem { ModuleItem::ConstDef(node) }\n+impl From<StructDef> for Item {\n+    fn from(node: StructDef) -> Item { Item::StructDef(node) }\n }\n-impl From<StaticDef> for ModuleItem {\n-    fn from(node: StaticDef) -> ModuleItem { ModuleItem::StaticDef(node) }\n+impl From<TraitDef> for Item {\n+    fn from(node: TraitDef) -> Item { Item::TraitDef(node) }\n }\n-impl From<Module> for ModuleItem {\n-    fn from(node: Module) -> ModuleItem { ModuleItem::Module(node) }\n+impl From<TypeAliasDef> for Item {\n+    fn from(node: TypeAliasDef) -> Item { Item::TypeAliasDef(node) }\n }\n-impl From<MacroCall> for ModuleItem {\n-    fn from(node: MacroCall) -> ModuleItem { ModuleItem::MacroCall(node) }\n+impl From<UnionDef> for Item {\n+    fn from(node: UnionDef) -> Item { Item::UnionDef(node) }\n }\n-impl From<ExternBlock> for ModuleItem {\n-    fn from(node: ExternBlock) -> ModuleItem { ModuleItem::ExternBlock(node) }\n+impl From<UseItem> for Item {\n+    fn from(node: UseItem) -> Item { Item::UseItem(node) }\n }\n-impl AstNode for ModuleItem {\n+impl AstNode for Item {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            STRUCT_DEF | UNION_DEF | ENUM_DEF | FN_DEF | TRAIT_DEF | TYPE_ALIAS_DEF | IMPL_DEF\n-            | USE_ITEM | EXTERN_CRATE_ITEM | CONST_DEF | STATIC_DEF | MODULE | MACRO_CALL\n-            | EXTERN_BLOCK => true,\n+            CONST_DEF | ENUM_DEF | EXTERN_BLOCK | EXTERN_CRATE_ITEM | FN_DEF | IMPL_DEF\n+            | MACRO_CALL | MODULE | STATIC_DEF | STRUCT_DEF | TRAIT_DEF | TYPE_ALIAS_DEF\n+            | UNION_DEF | USE_ITEM => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n-            STRUCT_DEF => ModuleItem::StructDef(StructDef { syntax }),\n-            UNION_DEF => ModuleItem::UnionDef(UnionDef { syntax }),\n-            ENUM_DEF => ModuleItem::EnumDef(EnumDef { syntax }),\n-            FN_DEF => ModuleItem::FnDef(FnDef { syntax }),\n-            TRAIT_DEF => ModuleItem::TraitDef(TraitDef { syntax }),\n-            TYPE_ALIAS_DEF => ModuleItem::TypeAliasDef(TypeAliasDef { syntax }),\n-            IMPL_DEF => ModuleItem::ImplDef(ImplDef { syntax }),\n-            USE_ITEM => ModuleItem::UseItem(UseItem { syntax }),\n-            EXTERN_CRATE_ITEM => ModuleItem::ExternCrateItem(ExternCrateItem { syntax }),\n-            CONST_DEF => ModuleItem::ConstDef(ConstDef { syntax }),\n-            STATIC_DEF => ModuleItem::StaticDef(StaticDef { syntax }),\n-            MODULE => ModuleItem::Module(Module { syntax }),\n-            MACRO_CALL => ModuleItem::MacroCall(MacroCall { syntax }),\n-            EXTERN_BLOCK => ModuleItem::ExternBlock(ExternBlock { syntax }),\n+            CONST_DEF => Item::ConstDef(ConstDef { syntax }),\n+            ENUM_DEF => Item::EnumDef(EnumDef { syntax }),\n+            EXTERN_BLOCK => Item::ExternBlock(ExternBlock { syntax }),\n+            EXTERN_CRATE_ITEM => Item::ExternCrateItem(ExternCrateItem { syntax }),\n+            FN_DEF => Item::FnDef(FnDef { syntax }),\n+            IMPL_DEF => Item::ImplDef(ImplDef { syntax }),\n+            MACRO_CALL => Item::MacroCall(MacroCall { syntax }),\n+            MODULE => Item::Module(Module { syntax }),\n+            STATIC_DEF => Item::StaticDef(StaticDef { syntax }),\n+            STRUCT_DEF => Item::StructDef(StructDef { syntax }),\n+            TRAIT_DEF => Item::TraitDef(TraitDef { syntax }),\n+            TYPE_ALIAS_DEF => Item::TypeAliasDef(TypeAliasDef { syntax }),\n+            UNION_DEF => Item::UnionDef(UnionDef { syntax }),\n+            USE_ITEM => Item::UseItem(UseItem { syntax }),\n             _ => return None,\n         };\n         Some(res)\n     }\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n-            ModuleItem::StructDef(it) => &it.syntax,\n-            ModuleItem::UnionDef(it) => &it.syntax,\n-            ModuleItem::EnumDef(it) => &it.syntax,\n-            ModuleItem::FnDef(it) => &it.syntax,\n-            ModuleItem::TraitDef(it) => &it.syntax,\n-            ModuleItem::TypeAliasDef(it) => &it.syntax,\n-            ModuleItem::ImplDef(it) => &it.syntax,\n-            ModuleItem::UseItem(it) => &it.syntax,\n-            ModuleItem::ExternCrateItem(it) => &it.syntax,\n-            ModuleItem::ConstDef(it) => &it.syntax,\n-            ModuleItem::StaticDef(it) => &it.syntax,\n-            ModuleItem::Module(it) => &it.syntax,\n-            ModuleItem::MacroCall(it) => &it.syntax,\n-            ModuleItem::ExternBlock(it) => &it.syntax,\n+            Item::ConstDef(it) => &it.syntax,\n+            Item::EnumDef(it) => &it.syntax,\n+            Item::ExternBlock(it) => &it.syntax,\n+            Item::ExternCrateItem(it) => &it.syntax,\n+            Item::FnDef(it) => &it.syntax,\n+            Item::ImplDef(it) => &it.syntax,\n+            Item::MacroCall(it) => &it.syntax,\n+            Item::Module(it) => &it.syntax,\n+            Item::StaticDef(it) => &it.syntax,\n+            Item::StructDef(it) => &it.syntax,\n+            Item::TraitDef(it) => &it.syntax,\n+            Item::TypeAliasDef(it) => &it.syntax,\n+            Item::UnionDef(it) => &it.syntax,\n+            Item::UseItem(it) => &it.syntax,\n         }\n     }\n }\n@@ -3378,7 +3378,7 @@ impl AstNode for AdtDef {\n         }\n     }\n }\n-impl std::fmt::Display for ModuleItem {\n+impl std::fmt::Display for Item {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -3438,47 +3438,47 @@ impl std::fmt::Display for Attr {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for FnDef {\n+impl std::fmt::Display for ConstDef {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Visibility {\n+impl std::fmt::Display for EnumDef {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Abi {\n+impl std::fmt::Display for ExternBlock {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Name {\n+impl std::fmt::Display for ExternCrateItem {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TypeParamList {\n+impl std::fmt::Display for FnDef {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ParamList {\n+impl std::fmt::Display for ImplDef {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RetType {\n+impl std::fmt::Display for MacroCall {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for WhereClause {\n+impl std::fmt::Display for Module {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for BlockExpr {\n+impl std::fmt::Display for StaticDef {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -3488,12 +3488,12 @@ impl std::fmt::Display for StructDef {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RecordFieldDefList {\n+impl std::fmt::Display for TraitDef {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TupleFieldDefList {\n+impl std::fmt::Display for TypeAliasDef {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -3503,67 +3503,87 @@ impl std::fmt::Display for UnionDef {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RecordFieldDef {\n+impl std::fmt::Display for UseItem {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TupleFieldDef {\n+impl std::fmt::Display for Visibility {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for EnumDef {\n+impl std::fmt::Display for Abi {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for EnumVariantList {\n+impl std::fmt::Display for Name {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for EnumVariant {\n+impl std::fmt::Display for TypeParamList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TraitDef {\n+impl std::fmt::Display for ParamList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TypeBoundList {\n+impl std::fmt::Display for RetType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ItemList {\n+impl std::fmt::Display for WhereClause {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Module {\n+impl std::fmt::Display for BlockExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ConstDef {\n+impl std::fmt::Display for RecordFieldDefList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for StaticDef {\n+impl std::fmt::Display for TupleFieldDefList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TypeAliasDef {\n+impl std::fmt::Display for RecordFieldDef {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ImplDef {\n+impl std::fmt::Display for TupleFieldDef {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for EnumVariantList {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for EnumVariant {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for TypeBoundList {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for ItemList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -3888,11 +3908,6 @@ impl std::fmt::Display for MacroPat {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for MacroCall {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for RecordPat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3983,11 +3998,6 @@ impl std::fmt::Display for Param {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for UseItem {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for UseTree {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -4003,11 +4013,6 @@ impl std::fmt::Display for Alias {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ExternCrateItem {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for PathSegment {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -4033,11 +4038,6 @@ impl std::fmt::Display for ConstArg {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ExternBlock {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for ExternItemList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)"}, {"sha": "9fe0b93c1e0dd2507c6efbe49a604b5ea8b1adc9", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -44,7 +44,7 @@ pub trait ArgListOwner: AstNode {\n }\n \n pub trait ModuleItemOwner: AstNode {\n-    fn items(&self) -> AstChildren<ast::ModuleItem> {\n+    fn items(&self) -> AstChildren<ast::Item> {\n         support::children(self.syntax())\n     }\n }"}, {"sha": "219dd0b07720f345ffef882cc013ed12087cde2a", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -187,7 +187,7 @@ impl ast::Expr {\n     }\n }\n \n-impl ast::ModuleItem {\n+impl ast::Item {\n     /// Returns `text`, parsed as an item, but only if it has no errors.\n     pub fn parse(text: &str) -> Result<Self, ()> {\n         parsing::parse_text_fragment(text, ra_parser::FragmentKind::Item)\n@@ -255,7 +255,7 @@ fn api_walkthrough() {\n     let mut func = None;\n     for item in file.items() {\n         match item {\n-            ast::ModuleItem::FnDef(f) => func = Some(f),\n+            ast::Item::FnDef(f) => func = Some(f),\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "68cee8914930677d4bffe5a5df47a0f5d182f901", "filename": "crates/ra_syntax/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ftests.rs?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -89,7 +89,7 @@ fn item_parser_tests() {\n     fragment_parser_dir_test(\n         &[\"parser/fragments/item/ok\"],\n         &[\"parser/fragments/item/err\"],\n-        crate::ast::ModuleItem::parse,\n+        crate::ast::Item::parse,\n     );\n }\n "}, {"sha": "08db700937d5157765a9675f2f41a30f6e72d739", "filename": "xtask/src/codegen/rust.ungram", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6636f56e79b55f22b88094b7edaed6ec88880500/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/6636f56e79b55f22b88094b7edaed6ec88880500/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Frust.ungram?ref=6636f56e79b55f22b88094b7edaed6ec88880500", "patch": "@@ -1,6 +1,22 @@\n SourceFile =\n   Attr*\n-  items:ModuleItem*\n+  Item*\n+\n+Item =\n+  ConstDef\n+| EnumDef\n+| ExternBlock\n+| ExternCrateItem\n+| FnDef\n+| ImplDef\n+| MacroCall\n+| Module\n+| StaticDef\n+| StructDef\n+| TraitDef\n+| TypeAliasDef\n+| UnionDef\n+| UseItem\n \n FnDef =\n  Attr* Visibility? Abi? 'const' 'default' 'async' 'unsafe' 'fn' Name TypeParamList?\n@@ -59,7 +75,7 @@ Module =\n ItemList =\n   '{'\n     AssocItem*\n-    items:ModuleItem*\n+    Item*\n   '}'\n \n ConstDef =\n@@ -168,7 +184,7 @@ Label =\n BlockExpr =\n   Attr* Label\n   '{'\n-    items:ModuleItem*\n+    Item*\n     statements:Stmt*\n     Expr?\n   '}'\n@@ -316,7 +332,7 @@ TokenTree =\n   '(' ')' | '{' '}' | '[' ']'\n \n MacroItems =\n-  items:ModuleItem*\n+  Item*\n \n MacroStmts =\n   statements:Stmt*\n@@ -454,22 +470,6 @@ AssocItem =\n ExternItem =\n   FnDef | StaticDef\n \n-ModuleItem =\n-  StructDef\n-| UnionDef\n-| EnumDef\n-| FnDef\n-| TraitDef\n-| TypeAliasDef\n-| ImplDef\n-| UseItem\n-| ExternCrateItem\n-| ConstDef\n-| StaticDef\n-| Module\n-| MacroCall\n-| ExternBlock\n-\n AttrInput =\n   Literal\n | TokenTree"}]}