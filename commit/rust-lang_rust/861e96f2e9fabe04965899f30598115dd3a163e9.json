{"sha": "861e96f2e9fabe04965899f30598115dd3a163e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MWU5NmYyZTlmYWJlMDQ5NjU4OTlmMzA1OTgxMTVkZDNhMTYzZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-29T00:23:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-29T00:23:23Z"}, "message": "Auto merge of #66567 - estebank:suggest-copy, r=Centril\n\nUse structured suggestion when requiring `Copy` constraint in type param", "tree": {"sha": "64fe4b9d6878c3faca37a817cff7c1f708625ad5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64fe4b9d6878c3faca37a817cff7c1f708625ad5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/861e96f2e9fabe04965899f30598115dd3a163e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/861e96f2e9fabe04965899f30598115dd3a163e9", "html_url": "https://github.com/rust-lang/rust/commit/861e96f2e9fabe04965899f30598115dd3a163e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/861e96f2e9fabe04965899f30598115dd3a163e9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61e1c3d343ea0deb1164eb812ad7c2b8de68c5a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/61e1c3d343ea0deb1164eb812ad7c2b8de68c5a9", "html_url": "https://github.com/rust-lang/rust/commit/61e1c3d343ea0deb1164eb812ad7c2b8de68c5a9"}, {"sha": "0f530ecb6875540f5cf5032ea7df54a38d01ab1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f530ecb6875540f5cf5032ea7df54a38d01ab1c", "html_url": "https://github.com/rust-lang/rust/commit/0f530ecb6875540f5cf5032ea7df54a38d01ab1c"}], "stats": {"total": 308, "additions": 187, "deletions": 121}, "files": [{"sha": "6e723cdc999b02a56c64688a5644d9d475d2a6f0", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 91, "deletions": 65, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=861e96f2e9fabe04965899f30598115dd3a163e9", "patch": "@@ -39,6 +39,7 @@ use syntax::ast;\n use syntax::symbol::{sym, kw};\n use syntax_pos::{DUMMY_SP, Span, ExpnKind, MultiSpan};\n use rustc::hir::def_id::LOCAL_CRATE;\n+use syntax_pos::source_map::SourceMap;\n \n use rustc_error_codes::*;\n \n@@ -1091,7 +1092,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n     fn suggest_restricting_param_bound(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        mut err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::PolyTraitRef<'_>,\n         body_id: hir::HirId,\n     ) {\n@@ -1102,7 +1103,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => return,\n         };\n \n-        let mut suggest_restriction = |generics: &hir::Generics, msg| {\n+        let suggest_restriction = |\n+            generics: &hir::Generics,\n+            msg,\n+            err: &mut DiagnosticBuilder<'_>,\n+        | {\n             let span = generics.where_clause.span_for_predicates_or_empty_place();\n             if !span.from_expansion() && span.desugaring_kind().is_none() {\n                 err.span_suggestion(\n@@ -1132,7 +1137,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     kind: hir::TraitItemKind::Method(..), ..\n                 }) if param_ty && self_ty == self.tcx.types.self_param => {\n                     // Restricting `Self` for a single method.\n-                    suggest_restriction(&generics, \"`Self`\");\n+                    suggest_restriction(&generics, \"`Self`\", err);\n                     return;\n                 }\n \n@@ -1154,7 +1159,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     kind: hir::ItemKind::Impl(_, _, _, generics, ..), ..\n                 }) if projection.is_some() => {\n                     // Missing associated type bound.\n-                    suggest_restriction(&generics, \"the associated type\");\n+                    suggest_restriction(&generics, \"the associated type\", err);\n                     return;\n                 }\n \n@@ -1183,68 +1188,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 hir::Node::ImplItem(hir::ImplItem { generics, span, .. })\n                 if param_ty => {\n                     // Missing generic type parameter bound.\n-                    let restrict_msg = \"consider further restricting this bound\";\n                     let param_name = self_ty.to_string();\n-                    for param in generics.params.iter().filter(|p| {\n-                        p.name.ident().as_str() == param_name\n-                    }) {\n-                        if param_name.starts_with(\"impl \") {\n-                            // `impl Trait` in argument:\n-                            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n-                            err.span_suggestion(\n-                                param.span,\n-                                restrict_msg,\n-                                // `impl CurrentTrait + MissingTrait`\n-                                format!(\"{} + {}\", param.name.ident(), trait_ref),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else if generics.where_clause.predicates.is_empty() &&\n-                                param.bounds.is_empty()\n-                        {\n-                            // If there are no bounds whatsoever, suggest adding a constraint\n-                            // to the type parameter:\n-                            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n-                            err.span_suggestion(\n-                                param.span,\n-                                \"consider restricting this bound\",\n-                                format!(\"{}\", trait_ref.to_predicate()),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else if !generics.where_clause.predicates.is_empty() {\n-                            // There is a `where` clause, so suggest expanding it:\n-                            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n-                            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n-                            err.span_suggestion(\n-                                generics.where_clause.span().unwrap().shrink_to_hi(),\n-                                &format!(\n-                                    \"consider further restricting type parameter `{}`\",\n-                                    param_name,\n-                                ),\n-                                format!(\", {}\", trait_ref.to_predicate()),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            // If there is no `where` clause lean towards constraining to the\n-                            // type parameter:\n-                            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n-                            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n-                            let sp = param.span.with_hi(span.hi());\n-                            let span = self.tcx.sess.source_map()\n-                                .span_through_char(sp, ':');\n-                            if sp != param.span && sp != span {\n-                                // Only suggest if we have high certainty that the span\n-                                // covers the colon in `foo<T: Trait>`.\n-                                err.span_suggestion(span, restrict_msg, format!(\n-                                    \"{} + \",\n-                                    trait_ref.to_predicate(),\n-                                ), Applicability::MachineApplicable);\n-                            } else {\n-                                err.span_label(param.span, &format!(\n-                                    \"consider adding a `where {}` bound\",\n-                                    trait_ref.to_predicate(),\n-                                ));\n-                            }\n-                        }\n+                    let constraint = trait_ref.to_string();\n+                    if suggest_constraining_type_param(\n+                        generics,\n+                        &mut err,\n+                        &param_name,\n+                        &constraint,\n+                        self.tcx.sess.source_map(),\n+                        *span,\n+                    ) {\n                         return;\n                     }\n                 }\n@@ -2546,3 +2499,76 @@ impl ArgKind {\n         }\n     }\n }\n+\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_param(\n+    generics: &hir::Generics,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+    source_map: &SourceMap,\n+    span: Span,\n+) -> bool {\n+    let restrict_msg = \"consider further restricting this bound\";\n+    if let Some(param) = generics.params.iter().filter(|p| {\n+        p.name.ident().as_str() == param_name\n+    }).next() {\n+        if param_name.starts_with(\"impl \") {\n+            // `impl Trait` in argument:\n+            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n+            err.span_suggestion(\n+                param.span,\n+                restrict_msg,\n+                // `impl CurrentTrait + MissingTrait`\n+                format!(\"{} + {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if generics.where_clause.predicates.is_empty() &&\n+                param.bounds.is_empty()\n+        {\n+            // If there are no bounds whatsoever, suggest adding a constraint\n+            // to the type parameter:\n+            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            err.span_suggestion(\n+                param.span,\n+                \"consider restricting this bound\",\n+                format!(\"{}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if !generics.where_clause.predicates.is_empty() {\n+            // There is a `where` clause, so suggest expanding it:\n+            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n+            err.span_suggestion(\n+                generics.where_clause.span().unwrap().shrink_to_hi(),\n+                &format!(\"consider further restricting type parameter `{}`\", param_name),\n+                format!(\", {}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            // If there is no `where` clause lean towards constraining to the\n+            // type parameter:\n+            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+            let sp = param.span.with_hi(span.hi());\n+            let span = source_map.span_through_char(sp, ':');\n+            if sp != param.span && sp != span {\n+                // Only suggest if we have high certainty that the span\n+                // covers the colon in `foo<T: Trait>`.\n+                err.span_suggestion(\n+                    span,\n+                    restrict_msg,\n+                    format!(\"{}: {} + \", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_label(\n+                    param.span,\n+                    &format!(\"consider adding a `where {}: {}` bound\", param_name, constraint),\n+                );\n+            }\n+        }\n+        return true;\n+    }\n+    false\n+}"}, {"sha": "48f8ad9bbd8d693673ac0cffeea9ef2ef58cb4fd", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=861e96f2e9fabe04965899f30598115dd3a163e9", "patch": "@@ -7,6 +7,7 @@ use rustc::mir::{\n     PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, Ty};\n+use rustc::traits::error_reporting::suggest_constraining_type_param;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_index::vec::Idx;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n@@ -231,13 +232,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 if let ty::Param(param_ty) = ty.kind {\n                     let tcx = self.infcx.tcx;\n                     let generics = tcx.generics_of(self.mir_def_id);\n-                    let def_id = generics.type_param(&param_ty, tcx).def_id;\n-                    if let Some(sp) = tcx.hir().span_if_local(def_id) {\n-                        err.span_label(\n-                            sp,\n-                            \"consider adding a `Copy` constraint to this type argument\",\n-                        );\n-                    }\n+                    let param = generics.type_param(&param_ty, tcx);\n+                    let generics = tcx.hir().get_generics(self.mir_def_id).unwrap();\n+                    suggest_constraining_type_param(\n+                        generics,\n+                        &mut err,\n+                        &param.name.as_str(),\n+                        \"Copy\",\n+                        tcx.sess.source_map(),\n+                        span,\n+                    );\n                 }\n                 let span = if let Some(local) = place.as_local() {\n                     let decl = &self.body.local_decls[local];"}, {"sha": "876e984ecb0bfbba527526c503e10f5a2df82b3c", "filename": "src/test/ui/binop/binop-consume-args.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr?ref=861e96f2e9fabe04965899f30598115dd3a163e9", "patch": "@@ -2,9 +2,9 @@ error[E0382]: use of moved value: `lhs`\n   --> $DIR/binop-consume-args.rs:7:10\n    |\n LL | fn add<A: Add<B, Output=()>, B>(lhs: A, rhs: B) {\n-   |        -                        --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |        --                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |        |\n-   |        consider adding a `Copy` constraint to this type argument\n+   |        help: consider further restricting this bound: `A: Copy +`\n LL |     lhs + rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -16,7 +16,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn add<A: Add<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                              |\n-   |                              consider adding a `Copy` constraint to this type argument\n+   |                              help: consider restricting this bound: `B: Copy`\n LL |     lhs + rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -27,9 +27,9 @@ error[E0382]: use of moved value: `lhs`\n   --> $DIR/binop-consume-args.rs:13:10\n    |\n LL | fn sub<A: Sub<B, Output=()>, B>(lhs: A, rhs: B) {\n-   |        -                        --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |        --                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |        |\n-   |        consider adding a `Copy` constraint to this type argument\n+   |        help: consider further restricting this bound: `A: Copy +`\n LL |     lhs - rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -41,7 +41,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn sub<A: Sub<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                              |\n-   |                              consider adding a `Copy` constraint to this type argument\n+   |                              help: consider restricting this bound: `B: Copy`\n LL |     lhs - rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -52,9 +52,9 @@ error[E0382]: use of moved value: `lhs`\n   --> $DIR/binop-consume-args.rs:19:10\n    |\n LL | fn mul<A: Mul<B, Output=()>, B>(lhs: A, rhs: B) {\n-   |        -                        --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |        --                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |        |\n-   |        consider adding a `Copy` constraint to this type argument\n+   |        help: consider further restricting this bound: `A: Copy +`\n LL |     lhs * rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -66,7 +66,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn mul<A: Mul<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                              |\n-   |                              consider adding a `Copy` constraint to this type argument\n+   |                              help: consider restricting this bound: `B: Copy`\n LL |     lhs * rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -77,9 +77,9 @@ error[E0382]: use of moved value: `lhs`\n   --> $DIR/binop-consume-args.rs:25:10\n    |\n LL | fn div<A: Div<B, Output=()>, B>(lhs: A, rhs: B) {\n-   |        -                        --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |        --                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |        |\n-   |        consider adding a `Copy` constraint to this type argument\n+   |        help: consider further restricting this bound: `A: Copy +`\n LL |     lhs / rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -91,7 +91,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn div<A: Div<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                              |\n-   |                              consider adding a `Copy` constraint to this type argument\n+   |                              help: consider restricting this bound: `B: Copy`\n LL |     lhs / rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -102,9 +102,9 @@ error[E0382]: use of moved value: `lhs`\n   --> $DIR/binop-consume-args.rs:31:10\n    |\n LL | fn rem<A: Rem<B, Output=()>, B>(lhs: A, rhs: B) {\n-   |        -                        --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |        --                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |        |\n-   |        consider adding a `Copy` constraint to this type argument\n+   |        help: consider further restricting this bound: `A: Copy +`\n LL |     lhs % rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -116,7 +116,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn rem<A: Rem<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                              |\n-   |                              consider adding a `Copy` constraint to this type argument\n+   |                              help: consider restricting this bound: `B: Copy`\n LL |     lhs % rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -127,9 +127,9 @@ error[E0382]: use of moved value: `lhs`\n   --> $DIR/binop-consume-args.rs:37:10\n    |\n LL | fn bitand<A: BitAnd<B, Output=()>, B>(lhs: A, rhs: B) {\n-   |           -                           --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |           --                          --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |           |\n-   |           consider adding a `Copy` constraint to this type argument\n+   |           help: consider further restricting this bound: `A: Copy +`\n LL |     lhs & rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -141,7 +141,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn bitand<A: BitAnd<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                    -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                                    |\n-   |                                    consider adding a `Copy` constraint to this type argument\n+   |                                    help: consider restricting this bound: `B: Copy`\n LL |     lhs & rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -152,9 +152,9 @@ error[E0382]: use of moved value: `lhs`\n   --> $DIR/binop-consume-args.rs:43:10\n    |\n LL | fn bitor<A: BitOr<B, Output=()>, B>(lhs: A, rhs: B) {\n-   |          -                          --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |          --                         --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |          |\n-   |          consider adding a `Copy` constraint to this type argument\n+   |          help: consider further restricting this bound: `A: Copy +`\n LL |     lhs | rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -166,7 +166,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn bitor<A: BitOr<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                  -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                                  |\n-   |                                  consider adding a `Copy` constraint to this type argument\n+   |                                  help: consider restricting this bound: `B: Copy`\n LL |     lhs | rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -177,9 +177,9 @@ error[E0382]: use of moved value: `lhs`\n   --> $DIR/binop-consume-args.rs:49:10\n    |\n LL | fn bitxor<A: BitXor<B, Output=()>, B>(lhs: A, rhs: B) {\n-   |           -                           --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |           --                          --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |           |\n-   |           consider adding a `Copy` constraint to this type argument\n+   |           help: consider further restricting this bound: `A: Copy +`\n LL |     lhs ^ rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -191,7 +191,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn bitxor<A: BitXor<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                    -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                                    |\n-   |                                    consider adding a `Copy` constraint to this type argument\n+   |                                    help: consider restricting this bound: `B: Copy`\n LL |     lhs ^ rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -202,9 +202,9 @@ error[E0382]: use of moved value: `lhs`\n   --> $DIR/binop-consume-args.rs:55:10\n    |\n LL | fn shl<A: Shl<B, Output=()>, B>(lhs: A, rhs: B) {\n-   |        -                        --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |        --                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |        |\n-   |        consider adding a `Copy` constraint to this type argument\n+   |        help: consider further restricting this bound: `A: Copy +`\n LL |     lhs << rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -216,7 +216,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn shl<A: Shl<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                              |\n-   |                              consider adding a `Copy` constraint to this type argument\n+   |                              help: consider restricting this bound: `B: Copy`\n LL |     lhs << rhs;\n    |            --- value moved here\n LL |     drop(lhs);\n@@ -227,9 +227,9 @@ error[E0382]: use of moved value: `lhs`\n   --> $DIR/binop-consume-args.rs:61:10\n    |\n LL | fn shr<A: Shr<B, Output=()>, B>(lhs: A, rhs: B) {\n-   |        -                        --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |        --                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |        |\n-   |        consider adding a `Copy` constraint to this type argument\n+   |        help: consider further restricting this bound: `A: Copy +`\n LL |     lhs >> rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -241,7 +241,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn shr<A: Shr<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                              |\n-   |                              consider adding a `Copy` constraint to this type argument\n+   |                              help: consider restricting this bound: `B: Copy`\n LL |     lhs >> rhs;\n    |            --- value moved here\n LL |     drop(lhs);"}, {"sha": "7552dc669749c0098c7a326f9cfb2ffc3a47d716", "filename": "src/test/ui/binop/binop-move-semantics.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr?ref=861e96f2e9fabe04965899f30598115dd3a163e9", "patch": "@@ -2,9 +2,9 @@ error[E0382]: use of moved value: `x`\n   --> $DIR/binop-move-semantics.rs:8:5\n    |\n LL | fn double_move<T: Add<Output=()>>(x: T) {\n-   |                -                  - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n+   |                --                 - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n    |                |\n-   |                consider adding a `Copy` constraint to this type argument\n+   |                help: consider further restricting this bound: `T: Copy +`\n LL |     x\n    |     - value moved here\n LL |     +\n@@ -15,9 +15,9 @@ error[E0382]: borrow of moved value: `x`\n   --> $DIR/binop-move-semantics.rs:14:5\n    |\n LL | fn move_then_borrow<T: Add<Output=()> + Clone>(x: T) {\n-   |                     -                          - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n+   |                     --                         - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n    |                     |\n-   |                     consider adding a `Copy` constraint to this type argument\n+   |                     help: consider further restricting this bound: `T: Copy +`\n LL |     x\n    |     - value moved here\n LL |     +"}, {"sha": "5cd0471cd0d6e520a53ddcbdfedf89b96348e414", "filename": "src/test/ui/borrowck/borrowck-unboxed-closures.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr?ref=861e96f2e9fabe04965899f30598115dd3a163e9", "patch": "@@ -20,9 +20,9 @@ error[E0382]: use of moved value: `f`\n   --> $DIR/borrowck-unboxed-closures.rs:12:5\n    |\n LL | fn c<F:FnOnce(isize, isize) -> isize>(f: F) {\n-   |      -                                - move occurs because `f` has type `F`, which does not implement the `Copy` trait\n+   |      --                               - move occurs because `f` has type `F`, which does not implement the `Copy` trait\n    |      |\n-   |      consider adding a `Copy` constraint to this type argument\n+   |      help: consider further restricting this bound: `F: Copy +`\n LL |     f(1, 2);\n    |     - value moved here\n LL |     f(1, 2);"}, {"sha": "5c38f47b363e9c10d0e2b0b9e649b1327b40f331", "filename": "src/test/ui/hrtb/hrtb-higher-ranker-supertraits-transitive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.stderr?ref=861e96f2e9fabe04965899f30598115dd3a163e9", "patch": "@@ -7,7 +7,7 @@ LL |     where B : for<'ccx> Bar<'ccx>\n    |               ------------------- required by this bound in `want_bar_for_any_ccx`\n ...\n LL |     where B : Qux\n-   |                  - help: consider further restricting type parameter `B`: `, for<'ccx> B: Bar<'ccx>`\n+   |                  - help: consider further restricting type parameter `B`: `, B: for<'ccx> Bar<'ccx>`\n ...\n LL |     want_bar_for_any_ccx(b);\n    |                          ^ the trait `for<'ccx> Bar<'ccx>` is not implemented for `B`"}, {"sha": "768bc6c71847f445934d9cb820cd33a73445acd0", "filename": "src/test/ui/hrtb/hrtb-higher-ranker-supertraits.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.stderr?ref=861e96f2e9fabe04965899f30598115dd3a163e9", "patch": "@@ -2,7 +2,7 @@ error[E0277]: the trait bound `for<'tcx> F: Foo<'tcx>` is not satisfied\n   --> $DIR/hrtb-higher-ranker-supertraits.rs:18:26\n    |\n LL |     where F : Foo<'x>\n-   |                      - help: consider further restricting type parameter `F`: `, for<'tcx> F: Foo<'tcx>`\n+   |                      - help: consider further restricting type parameter `F`: `, F: for<'tcx> Foo<'tcx>`\n ...\n LL |     want_foo_for_any_tcx(f);\n    |                          ^ the trait `for<'tcx> Foo<'tcx>` is not implemented for `F`\n@@ -16,7 +16,7 @@ error[E0277]: the trait bound `for<'ccx> B: Bar<'ccx>` is not satisfied\n   --> $DIR/hrtb-higher-ranker-supertraits.rs:35:26\n    |\n LL |     where B : Bar<'x>\n-   |                      - help: consider further restricting type parameter `B`: `, for<'ccx> B: Bar<'ccx>`\n+   |                      - help: consider further restricting type parameter `B`: `, B: for<'ccx> Bar<'ccx>`\n ...\n LL |     want_bar_for_any_ccx(b);\n    |                          ^ the trait `for<'ccx> Bar<'ccx>` is not implemented for `B`"}, {"sha": "ba2810ee3d725803e3f8e2f2cca978a7fa9dd9e5", "filename": "src/test/ui/issues/issue-34721.fixed", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fissues%2Fissue-34721.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fissues%2Fissue-34721.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34721.fixed?ref=861e96f2e9fabe04965899f30598115dd3a163e9", "patch": "@@ -0,0 +1,34 @@\n+// run-rustfix\n+\n+pub trait Foo {\n+    fn zero(self) -> Self;\n+}\n+\n+impl Foo for u32 {\n+    fn zero(self) -> u32 { 0u32 }\n+}\n+\n+pub mod bar {\n+    pub use Foo;\n+    pub fn bar<T: Foo>(x: T) -> T {\n+      x.zero()\n+    }\n+}\n+\n+mod baz {\n+    use bar;\n+    use Foo;\n+    pub fn baz<T: Copy +  Foo>(x: T) -> T {\n+        if 0 == 1 {\n+            bar::bar(x.zero())\n+        } else {\n+            x.zero()\n+        };\n+        x.zero()\n+        //~^ ERROR use of moved value\n+    }\n+}\n+\n+fn main() {\n+    let _ = baz::baz(0u32);\n+}"}, {"sha": "14dd01766aa4475b1b4dc6bb8b26b1d88dd23add", "filename": "src/test/ui/issues/issue-34721.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fissues%2Fissue-34721.rs", "raw_url": "https://github.com/rust-lang/rust/raw/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fissues%2Fissue-34721.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34721.rs?ref=861e96f2e9fabe04965899f30598115dd3a163e9", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n pub trait Foo {\n     fn zero(self) -> Self;\n }"}, {"sha": "3002b07e8c909ce64559ca1ad4575ce668fe03f6", "filename": "src/test/ui/issues/issue-34721.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr?ref=861e96f2e9fabe04965899f30598115dd3a163e9", "patch": "@@ -1,10 +1,10 @@\n error[E0382]: use of moved value: `x`\n-  --> $DIR/issue-34721.rs:25:9\n+  --> $DIR/issue-34721.rs:27:9\n    |\n LL |     pub fn baz<T: Foo>(x: T) -> T {\n-   |                -       - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n+   |                --      - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n    |                |\n-   |                consider adding a `Copy` constraint to this type argument\n+   |                help: consider further restricting this bound: `T: Copy +`\n LL |         if 0 == 1 {\n LL |             bar::bar(x.zero())\n    |                      - value moved here"}, {"sha": "ead2cceebf857293567757b1c0245c7c4fba5cec", "filename": "src/test/ui/moves/moves-based-on-type-no-recursive-stack-closure.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr?ref=861e96f2e9fabe04965899f30598115dd3a163e9", "patch": "@@ -11,9 +11,9 @@ error[E0382]: borrow of moved value: `f`\n   --> $DIR/moves-based-on-type-no-recursive-stack-closure.rs:32:5\n    |\n LL | fn conspirator<F>(mut f: F) where F: FnMut(&mut R, bool) {\n-   |                -  ----- move occurs because `f` has type `F`, which does not implement the `Copy` trait\n-   |                |\n-   |                consider adding a `Copy` constraint to this type argument\n+   |                   -----                                 - help: consider further restricting type parameter `F`: `, F: Copy`\n+   |                   |\n+   |                   move occurs because `f` has type `F`, which does not implement the `Copy` trait\n LL |     let mut r = R {c: Box::new(f)};\n    |                                - value moved here\n LL |     f(&mut r, false)"}, {"sha": "fd9980602185653d1b6963d8f6e90b7bade4f623", "filename": "src/test/ui/once-cant-call-twice-on-heap.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr?ref=861e96f2e9fabe04965899f30598115dd3a163e9", "patch": "@@ -2,9 +2,9 @@ error[E0382]: use of moved value: `blk`\n   --> $DIR/once-cant-call-twice-on-heap.rs:9:5\n    |\n LL | fn foo<F:FnOnce()>(blk: F) {\n-   |        -           --- move occurs because `blk` has type `F`, which does not implement the `Copy` trait\n+   |        --          --- move occurs because `blk` has type `F`, which does not implement the `Copy` trait\n    |        |\n-   |        consider adding a `Copy` constraint to this type argument\n+   |        help: consider further restricting this bound: `F: Copy +`\n LL |     blk();\n    |     --- value moved here\n LL |     blk();"}, {"sha": "092c419d7cba861cbf5c3ca689f47f8c38c78da6", "filename": "src/test/ui/unop-move-semantics.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/861e96f2e9fabe04965899f30598115dd3a163e9/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funop-move-semantics.stderr?ref=861e96f2e9fabe04965899f30598115dd3a163e9", "patch": "@@ -2,9 +2,9 @@ error[E0382]: borrow of moved value: `x`\n   --> $DIR/unop-move-semantics.rs:8:5\n    |\n LL | fn move_then_borrow<T: Not<Output=T> + Clone>(x: T) {\n-   |                     -                         - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n+   |                     --                        - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n    |                     |\n-   |                     consider adding a `Copy` constraint to this type argument\n+   |                     help: consider further restricting this bound: `T: Copy +`\n LL |     !x;\n    |      - value moved here\n LL | "}]}