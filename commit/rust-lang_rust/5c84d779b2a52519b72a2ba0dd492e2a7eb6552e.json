{"sha": "5c84d779b2a52519b72a2ba0dd492e2a7eb6552e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjODRkNzc5YjJhNTI1MTliNzJhMmJhMGRkNDkyZTJhN2ViNjU1MmU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-19T23:01:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-19T23:01:38Z"}, "message": "Rollup merge of #60745 - wesleywiser:const_prop_into_terminators, r=oli-obk\n\nPerform constant propagation into terminators\n\nPerform constant propagation into MIR `Assert` and `SwitchInt` `Terminator`s which in some cases allows them to be removed by the branch simplification pass.\n\nr? @oli-obk", "tree": {"sha": "e7a3fc91989cf876f94050fc538a6d9fc2f0fafb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7a3fc91989cf876f94050fc538a6d9fc2f0fafb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c84d779b2a52519b72a2ba0dd492e2a7eb6552e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc4eBSCRBK7hj4Ov3rIwAAdHIIAI2DhYO85GUjkm9PpvOCT9o+\nqXPDXONMGZ6HJEQRuWF3ot+p3KmeSjgR8LB6swQfcZ7mQc/p7z40aCj7wPkouoBL\nsq3c/08NjPUvf9Mtjyc/MLrR2i6GuvYR+3quDbQTTz5+RnxGtfqPbPpYNrB1qwrI\nRpbpuh/xqWyqRkYubDe4scXtPmwF3TztEJb9jflW5QdrS9q29OYa6/GAQw2Ii7eV\nfUg7NbViHtuHRfK6VM1g1TpRwsqLKA7FAUFJxdrv/8aFO2Jhn43uvUmRJeD3gJur\n88mak495HRSNdQal8fXGiP9lzDCzGlWAl5qErXI1Mu9S2DEYoRuOOk9VdF1Aw9g=\n=txpP\n-----END PGP SIGNATURE-----\n", "payload": "tree e7a3fc91989cf876f94050fc538a6d9fc2f0fafb\nparent f9d65c000dfa92825589dd1a13a20b95a328493b\nparent ec853ba026261bc1c8c53a99d210c02f88fde54f\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1558306898 +0200\ncommitter GitHub <noreply@github.com> 1558306898 +0200\n\nRollup merge of #60745 - wesleywiser:const_prop_into_terminators, r=oli-obk\n\nPerform constant propagation into terminators\n\nPerform constant propagation into MIR `Assert` and `SwitchInt` `Terminator`s which in some cases allows them to be removed by the branch simplification pass.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c84d779b2a52519b72a2ba0dd492e2a7eb6552e", "html_url": "https://github.com/rust-lang/rust/commit/5c84d779b2a52519b72a2ba0dd492e2a7eb6552e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c84d779b2a52519b72a2ba0dd492e2a7eb6552e/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9d65c000dfa92825589dd1a13a20b95a328493b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9d65c000dfa92825589dd1a13a20b95a328493b", "html_url": "https://github.com/rust-lang/rust/commit/f9d65c000dfa92825589dd1a13a20b95a328493b"}, {"sha": "ec853ba026261bc1c8c53a99d210c02f88fde54f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec853ba026261bc1c8c53a99d210c02f88fde54f", "html_url": "https://github.com/rust-lang/rust/commit/ec853ba026261bc1c8c53a99d210c02f88fde54f"}], "stats": {"total": 225, "additions": 152, "deletions": 73}, "files": [{"sha": "8f3dd72c4f2450a82ca151b53d8ebbe9128b72d6", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 108, "deletions": 67, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/5c84d779b2a52519b72a2ba0dd492e2a7eb6552e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c84d779b2a52519b72a2ba0dd492e2a7eb6552e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=5c84d779b2a52519b72a2ba0dd492e2a7eb6552e", "patch": "@@ -546,6 +546,10 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             }\n         }\n     }\n+\n+    fn should_const_prop(&self) -> bool {\n+        self.tcx.sess.opts.debugging_opts.mir_opt_level >= 2\n+    }\n }\n \n fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -639,7 +643,7 @@ impl<'b, 'a, 'tcx> MutVisitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                             assert!(self.places[local].is_none());\n                             self.places[local] = Some(value);\n \n-                            if self.tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n+                            if self.should_const_prop() {\n                                 self.replace_with_const(rval, value, statement.source_info.span);\n                             }\n                         }\n@@ -656,75 +660,112 @@ impl<'b, 'a, 'tcx> MutVisitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         location: Location,\n     ) {\n         self.super_terminator(terminator, location);\n-        let source_info = terminator.source_info;;\n-        if let TerminatorKind::Assert { expected, msg, cond, .. } = &terminator.kind {\n-            if let Some(value) = self.eval_operand(&cond, source_info) {\n-                trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                let expected = ScalarMaybeUndef::from(Scalar::from_bool(*expected));\n-                if expected != self.ecx.read_scalar(value).unwrap() {\n-                    // poison all places this operand references so that further code\n-                    // doesn't use the invalid value\n-                    match cond {\n-                        Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                            let mut place = place;\n-                            while let Place::Projection(ref proj) = *place {\n-                                place = &proj.base;\n-                            }\n-                            if let Place::Base(PlaceBase::Local(local)) = *place {\n-                                self.places[local] = None;\n+        let source_info = terminator.source_info;\n+        match &mut terminator.kind {\n+            TerminatorKind::Assert { expected, msg, ref mut cond, .. } => {\n+                if let Some(value) = self.eval_operand(&cond, source_info) {\n+                    trace!(\"assertion on {:?} should be {:?}\", value, expected);\n+                    let expected = ScalarMaybeUndef::from(Scalar::from_bool(*expected));\n+                    let value_const = self.ecx.read_scalar(value).unwrap();\n+                    if expected != value_const {\n+                        // poison all places this operand references so that further code\n+                        // doesn't use the invalid value\n+                        match cond {\n+                            Operand::Move(ref place) | Operand::Copy(ref place) => {\n+                                let mut place = place;\n+                                while let Place::Projection(ref proj) = *place {\n+                                    place = &proj.base;\n+                                }\n+                                if let Place::Base(PlaceBase::Local(local)) = *place {\n+                                    self.places[local] = None;\n+                                }\n+                            },\n+                            Operand::Constant(_) => {}\n+                        }\n+                        let span = terminator.source_info.span;\n+                        let hir_id = self\n+                            .tcx\n+                            .hir()\n+                            .as_local_hir_id(self.source.def_id())\n+                            .expect(\"some part of a failing const eval must be local\");\n+                        use rustc::mir::interpret::InterpError::*;\n+                        let msg = match msg {\n+                            Overflow(_) |\n+                            OverflowNeg |\n+                            DivisionByZero |\n+                            RemainderByZero => msg.description().to_owned(),\n+                            BoundsCheck { ref len, ref index } => {\n+                                let len = self\n+                                    .eval_operand(len, source_info)\n+                                    .expect(\"len must be const\");\n+                                let len = match self.ecx.read_scalar(len) {\n+                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n+                                        bits, ..\n+                                    })) => bits,\n+                                    other => bug!(\"const len not primitive: {:?}\", other),\n+                                };\n+                                let index = self\n+                                    .eval_operand(index, source_info)\n+                                    .expect(\"index must be const\");\n+                                let index = match self.ecx.read_scalar(index) {\n+                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n+                                        bits, ..\n+                                    })) => bits,\n+                                    other => bug!(\"const index not primitive: {:?}\", other),\n+                                };\n+                                format!(\n+                                    \"index out of bounds: \\\n+                                    the len is {} but the index is {}\",\n+                                    len,\n+                                    index,\n+                                )\n+                            },\n+                            // Need proper const propagator for these\n+                            _ => return,\n+                        };\n+                        self.tcx.lint_hir(\n+                            ::rustc::lint::builtin::CONST_ERR,\n+                            hir_id,\n+                            span,\n+                            &msg,\n+                        );\n+                    } else {\n+                        if self.should_const_prop() {\n+                            if let ScalarMaybeUndef::Scalar(scalar) = value_const {\n+                                *cond = self.operand_from_scalar(\n+                                    scalar,\n+                                    self.tcx.types.bool,\n+                                    source_info.span,\n+                                );\n                             }\n-                        },\n-                        Operand::Constant(_) => {}\n+                        }\n                     }\n-                    let span = terminator.source_info.span;\n-                    let hir_id = self\n-                        .tcx\n-                        .hir()\n-                        .as_local_hir_id(self.source.def_id())\n-                        .expect(\"some part of a failing const eval must be local\");\n-                    use rustc::mir::interpret::InterpError::*;\n-                    let msg = match msg {\n-                        Overflow(_) |\n-                        OverflowNeg |\n-                        DivisionByZero |\n-                        RemainderByZero => msg.description().to_owned(),\n-                        BoundsCheck { ref len, ref index } => {\n-                            let len = self\n-                                .eval_operand(len, source_info)\n-                                .expect(\"len must be const\");\n-                            let len = match self.ecx.read_scalar(len) {\n-                                Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n-                                    bits, ..\n-                                })) => bits,\n-                                other => bug!(\"const len not primitive: {:?}\", other),\n-                            };\n-                            let index = self\n-                                .eval_operand(index, source_info)\n-                                .expect(\"index must be const\");\n-                            let index = match self.ecx.read_scalar(index) {\n-                                Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n-                                    bits, ..\n-                                })) => bits,\n-                                other => bug!(\"const index not primitive: {:?}\", other),\n-                            };\n-                            format!(\n-                                \"index out of bounds: \\\n-                                the len is {} but the index is {}\",\n-                                len,\n-                                index,\n-                            )\n-                        },\n-                        // Need proper const propagator for these\n-                        _ => return,\n-                    };\n-                    self.tcx.lint_hir(\n-                        ::rustc::lint::builtin::CONST_ERR,\n-                        hir_id,\n-                        span,\n-                        &msg,\n-                    );\n                 }\n-            }\n+            },\n+            TerminatorKind::SwitchInt { ref mut discr, switch_ty, .. } => {\n+                if self.should_const_prop() {\n+                    if let Some(value) = self.eval_operand(&discr, source_info) {\n+                        if let ScalarMaybeUndef::Scalar(scalar) =\n+                                self.ecx.read_scalar(value).unwrap() {\n+                            *discr = self.operand_from_scalar(scalar, switch_ty, source_info.span);\n+                        }\n+                    }\n+                }\n+            },\n+            //none of these have Operands to const-propagate\n+            TerminatorKind::Goto { .. } |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Abort |\n+            TerminatorKind::Return |\n+            TerminatorKind::Unreachable |\n+            TerminatorKind::Drop { .. } |\n+            TerminatorKind::DropAndReplace { .. } |\n+            TerminatorKind::Yield { .. } |\n+            TerminatorKind::GeneratorDrop |\n+            TerminatorKind::FalseEdges { .. } |\n+            TerminatorKind::FalseUnwind { .. } => { }\n+            //FIXME(wesleywiser) Call does have Operands that could be const-propagated\n+            TerminatorKind::Call { .. } => { }\n         }\n     }\n }"}, {"sha": "dd22eb5d604ea51b84d8586ebfc26c6e16bcb038", "filename": "src/test/mir-opt/const_prop/array_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c84d779b2a52519b72a2ba0dd492e2a7eb6552e/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c84d779b2a52519b72a2ba0dd492e2a7eb6552e/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.rs?ref=5c84d779b2a52519b72a2ba0dd492e2a7eb6552e", "patch": "@@ -23,7 +23,7 @@ fn main() {\n //  bb0: {\n //      ...\n //      _5 = const true;\n-//      assert(move _5, \"index out of bounds: the len is move _4 but the index is _3\") -> bb1;\n+//      assert(const true, \"index out of bounds: the len is move _4 but the index is _3\") -> bb1;\n //  }\n //  bb1: {\n //      _1 = _2[_3];"}, {"sha": "fe98cf24eec009ecc6416033e5b7a38e787a6dae", "filename": "src/test/mir-opt/const_prop/checked_add.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c84d779b2a52519b72a2ba0dd492e2a7eb6552e/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c84d779b2a52519b72a2ba0dd492e2a7eb6552e/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.rs?ref=5c84d779b2a52519b72a2ba0dd492e2a7eb6552e", "patch": "@@ -16,6 +16,6 @@ fn main() {\n //  bb0: {\n //      ...\n //      _2 = (const 2u32, const false);\n-//      assert(!move (_2.1: bool), \"attempt to add with overflow\") -> bb1;\n+//      assert(!const false, \"attempt to add with overflow\") -> bb1;\n //  }\n // END rustc.main.ConstProp.after.mir"}, {"sha": "0df1112ec3eb7283ced4451208e1f1e31f9ad7bb", "filename": "src/test/mir-opt/const_prop/switch_int.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5c84d779b2a52519b72a2ba0dd492e2a7eb6552e/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c84d779b2a52519b72a2ba0dd492e2a7eb6552e/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs?ref=5c84d779b2a52519b72a2ba0dd492e2a7eb6552e", "patch": "@@ -0,0 +1,38 @@\n+#[inline(never)]\n+fn foo(_: i32) { }\n+\n+fn main() {\n+    match 1 {\n+        1 => foo(0),\n+        _ => foo(-1),\n+    }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.main.ConstProp.before.mir\n+//  bb0: {\n+//      ...\n+//      _1 = const 1i32;\n+//      switchInt(_1) -> [1i32: bb1, otherwise: bb2];\n+//  }\n+// END rustc.main.ConstProp.before.mir\n+// START rustc.main.ConstProp.after.mir\n+//  bb0: {\n+//      ...\n+//      switchInt(const 1i32) -> [1i32: bb1, otherwise: bb2];\n+//  }\n+// END rustc.main.ConstProp.after.mir\n+// START rustc.main.SimplifyBranches-after-const-prop.before.mir\n+//  bb0: {\n+//      ...\n+//      _1 = const 1i32;\n+//      switchInt(const 1i32) -> [1i32: bb1, otherwise: bb2];\n+//  }\n+// END rustc.main.SimplifyBranches-after-const-prop.before.mir\n+// START rustc.main.SimplifyBranches-after-const-prop.after.mir\n+//  bb0: {\n+//      ...\n+//      _1 = const 1i32;\n+//      goto -> bb1;\n+//  }\n+// END rustc.main.SimplifyBranches-after-const-prop.after.mir"}, {"sha": "35512b94c0c8cf8f96c87db6ab2350ae51118525", "filename": "src/test/mir-opt/simplify_if.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c84d779b2a52519b72a2ba0dd492e2a7eb6552e/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c84d779b2a52519b72a2ba0dd492e2a7eb6552e/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs?ref=5c84d779b2a52519b72a2ba0dd492e2a7eb6552e", "patch": "@@ -5,15 +5,15 @@ fn main() {\n }\n \n // END RUST SOURCE\n-// START rustc.main.SimplifyBranches-after-copy-prop.before.mir\n+// START rustc.main.SimplifyBranches-after-const-prop.before.mir\n // bb0: {\n //     ...\n //     switchInt(const false) -> [false: bb3, otherwise: bb1];\n // }\n-// END rustc.main.SimplifyBranches-after-copy-prop.before.mir\n-// START rustc.main.SimplifyBranches-after-copy-prop.after.mir\n+// END rustc.main.SimplifyBranches-after-const-prop.before.mir\n+// START rustc.main.SimplifyBranches-after-const-prop.after.mir\n // bb0: {\n //     ...\n //     goto -> bb3;\n // }\n-// END rustc.main.SimplifyBranches-after-copy-prop.after.mir\n+// END rustc.main.SimplifyBranches-after-const-prop.after.mir"}]}