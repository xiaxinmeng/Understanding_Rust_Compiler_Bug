{"sha": "652332f9d44d0c3eb36c220a88ef37f7f875206f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MjMzMmY5ZDQ0ZDBjM2ViMzZjMjIwYTg4ZWYzN2Y3Zjg3NTIwNmY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-25T22:12:54Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:44Z"}, "message": "Convert std::map::new_str_hash to istrs. Issue #855", "tree": {"sha": "61e00059bd5e16cc90b4f103cad5dff72f11fffb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61e00059bd5e16cc90b4f103cad5dff72f11fffb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/652332f9d44d0c3eb36c220a88ef37f7f875206f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/652332f9d44d0c3eb36c220a88ef37f7f875206f", "html_url": "https://github.com/rust-lang/rust/commit/652332f9d44d0c3eb36c220a88ef37f7f875206f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/652332f9d44d0c3eb36c220a88ef37f7f875206f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faef9490ae724bce4802405f826d65988b2b7b05", "url": "https://api.github.com/repos/rust-lang/rust/commits/faef9490ae724bce4802405f826d65988b2b7b05", "html_url": "https://github.com/rust-lang/rust/commit/faef9490ae724bce4802405f826d65988b2b7b05"}], "stats": {"total": 325, "additions": 181, "deletions": 144}, "files": [{"sha": "6692bcea0707b584d93435d75f3d72abf5f8c547", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -901,22 +901,26 @@ native \"cdecl\" mod llvm = \"rustllvm\" {\n /* Memory-managed object interface to type handles. */\n \n obj type_names(type_names: std::map::hashmap<TypeRef, str>,\n-               named_types: std::map::hashmap<str, TypeRef>) {\n+               named_types: std::map::hashmap<istr, TypeRef>) {\n \n     fn associate(s: str, t: TypeRef) {\n-        assert (!named_types.contains_key(s));\n+        assert (!named_types.contains_key(istr::from_estr(s)));\n         assert (!type_names.contains_key(t));\n         type_names.insert(t, s);\n-        named_types.insert(s, t);\n+        named_types.insert(istr::from_estr(s), t);\n     }\n \n     fn type_has_name(t: TypeRef) -> bool { ret type_names.contains_key(t); }\n \n     fn get_name(t: TypeRef) -> str { ret type_names.get(t); }\n \n-    fn name_has_type(s: str) -> bool { ret named_types.contains_key(s); }\n+    fn name_has_type(s: str) -> bool {\n+        ret named_types.contains_key(istr::from_estr(s));\n+    }\n \n-    fn get_type(s: str) -> TypeRef { ret named_types.get(s); }\n+    fn get_type(s: str) -> TypeRef {\n+        ret named_types.get(istr::from_estr(s));\n+    }\n }\n \n fn mk_type_names() -> type_names {"}, {"sha": "3f6d63cf5779b8a7c5e88b53e1fdb3fea9173b79", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -47,7 +47,7 @@ fn read_crates(sess: session::session, crate: &ast::crate) {\n \n type env =\n     @{sess: session::session,\n-      crate_cache: @hashmap<str, int>,\n+      crate_cache: @hashmap<istr, int>,\n       library_search_paths: [str],\n       mutable next_crate_num: ast::crate_num};\n \n@@ -226,7 +226,7 @@ fn load_library_crate(sess: &session::session, span: span, ident: &ast::ident,\n \n fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n                  span: span) -> ast::crate_num {\n-    if !e.crate_cache.contains_key(ident) {\n+    if !e.crate_cache.contains_key(istr::from_estr(ident)) {\n         let cinfo =\n             load_library_crate(e.sess, span, ident, metas,\n                                e.library_search_paths);\n@@ -236,7 +236,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n \n         // Claim this crate number and cache it\n         let cnum = e.next_crate_num;\n-        e.crate_cache.insert(ident, cnum);\n+        e.crate_cache.insert(istr::from_estr(ident), cnum);\n         e.next_crate_num += 1;\n \n         // Now resolve the crates referenced by this crate\n@@ -248,7 +248,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n         cstore::set_crate_data(cstore, cnum, cmeta);\n         cstore::add_used_crate_file(cstore, cfilename);\n         ret cnum;\n-    } else { ret e.crate_cache.get(ident); }\n+    } else { ret e.crate_cache.get(istr::from_estr(ident)); }\n }\n \n // Go through the crate metadata and load any crates that it references\n@@ -261,10 +261,10 @@ fn resolve_crate_deps(e: env, cdata: &@[u8]) -> cstore::cnum_map {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.ident;\n         log #fmt[\"resolving dep %s\", cname];\n-        if e.crate_cache.contains_key(cname) {\n+        if e.crate_cache.contains_key(istr::from_estr(cname)) {\n             log \"already have it\";\n             // We've already seen this crate\n-            let local_cnum = e.crate_cache.get(cname);\n+            let local_cnum = e.crate_cache.get(istr::from_estr(cname));\n             cnum_map.insert(extrn_cnum, local_cnum);\n         } else {\n             log \"need to load it\";"}, {"sha": "5b9ab91cebb9cd1b95756ae2af5fbba4449ea8f7", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -47,7 +47,7 @@ fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n     bcx = td_r.result.bcx;\n     let lltydesc = td_r.result.val;\n \n-    let gcroot = bcx_ccx(bcx).intrinsics.get(\"llvm.gcroot\");\n+    let gcroot = bcx_ccx(bcx).intrinsics.get(~\"llvm.gcroot\");\n     let llvalptr = bld::PointerCast(bcx, llval, T_ptr(T_ptr(T_i8())));\n \n     alt td_r.kind {"}, {"sha": "9c0c5281cccab791f23d47264fb69b1637c8ab29", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -33,6 +33,7 @@ import std::option::is_none;\n import std::option::some;\n import std::option::none;\n import std::str;\n+import std::istr;\n import syntax::print::pprust::*;\n \n export resolve_crate;\n@@ -101,7 +102,7 @@ tag mod_index_entry {\n     mie_tag_variant(/* tag item */@ast::item, /* variant index */uint);\n }\n \n-type mod_index = hashmap<ident, list<mod_index_entry>>;\n+type mod_index = hashmap<identistr, list<mod_index_entry>>;\n \n // A tuple of an imported def and the import stmt that brung it\n type glob_imp_def = {def: def, item: @ast::view_item};\n@@ -110,7 +111,7 @@ type indexed_mod =\n     {m: option::t<ast::_mod>,\n      index: mod_index,\n      mutable glob_imports: [glob_imp_def],\n-     glob_imported_names: hashmap<str, import_state>};\n+     glob_imported_names: hashmap<istr, import_state>};\n \n \n /* native modules can't contain tags, and we don't store their ASTs because we\n@@ -954,7 +955,7 @@ fn lookup_in_local_mod(e: &env, node_id: node_id, sp: &span, id: &ident,\n         ret none::<def>; // name is not visible\n \n     }\n-    alt info.index.find(id) {\n+    alt info.index.find(istr::from_estr(id)) {\n       none. { }\n       some(lst_) {\n         let lst = lst_;\n@@ -1009,14 +1010,15 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n     // since we don't know what names we have in advance,\n     // absence takes the place of todo()\n \n-    if !info.glob_imported_names.contains_key(id) {\n-        info.glob_imported_names.insert(id, resolving(sp));\n+    if !info.glob_imported_names.contains_key(istr::from_estr(id)) {\n+        info.glob_imported_names.insert(istr::from_estr(id), resolving(sp));\n         let val = per_ns(e, info, sp, id, ns_value, dr);\n         let typ = per_ns(e, info, sp, id, ns_type, dr);\n         let md = per_ns(e, info, sp, id, ns_module, dr);\n-        info.glob_imported_names.insert(id, resolved(val, typ, md));\n+        info.glob_imported_names.insert(istr::from_estr(id),\n+                                        resolved(val, typ, md));\n     }\n-    alt info.glob_imported_names.get(id) {\n+    alt info.glob_imported_names.get(istr::from_estr(id)) {\n       todo(_, _, _, _, _) { e.sess.bug(\"Shouldn't've put a todo in.\"); }\n       resolving(sp) {\n         ret none::<def>; //circularity is okay in import globs\n@@ -1071,10 +1073,12 @@ fn lookup_in_mie(e: &env, mie: &mod_index_entry, ns: namespace) ->\n \n \n // Module indexing\n-fn add_to_index(index: &hashmap<ident, list<mod_index_entry>>, id: &ident,\n-                ent: &mod_index_entry) {\n+fn add_to_index(index: &hashmap<identistr, list<mod_index_entry>>,\n+                id: &ident, ent: &mod_index_entry) {\n+    let id = istr::from_estr(id);\n     alt index.find(id) {\n-      none. { index.insert(id, cons(ent, @nil::<mod_index_entry>)); }\n+      none. { index.insert(id,\n+                           cons(ent, @nil::<mod_index_entry>)); }\n       some(prev) { index.insert(id, cons(ent, @prev)); }\n     }\n }\n@@ -1187,9 +1191,9 @@ fn check_for_collisions(e: &@env, c: &ast::crate) {\n     // Module indices make checking those relatively simple -- just check each\n     // name for multiple entities in the same namespace.\n     for each m: @{key: ast::node_id, val: @indexed_mod} in e.mod_map.items() {\n-        for each name: @{key: ident, val: list<mod_index_entry>} in\n+        for each name: @{key: identistr, val: list<mod_index_entry>} in\n                  m.val.index.items() {\n-            check_mod_name(*e, name.key, name.val);\n+            check_mod_name(*e, istr::to_estr(name.key), name.val);\n         }\n     }\n     // Other scopes have to be checked the hard way."}, {"sha": "0fd6762a4d191c35aa89f91d26923de468b0e1ce", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -355,31 +355,35 @@ fn decl_glue(llmod: ModuleRef, cx: &crate_ctxt, s: &str) -> ValueRef {\n     ret decl_cdecl_fn(llmod, s, T_fn([T_taskptr(cx)], T_void()));\n }\n \n-fn get_extern_fn(externs: &hashmap<str, ValueRef>, llmod: ModuleRef,\n+fn get_extern_fn(externs: &hashmap<istr, ValueRef>, llmod: ModuleRef,\n                  name: &str, cc: uint, ty: TypeRef) -> ValueRef {\n-    if externs.contains_key(name) { ret externs.get(name); }\n+    if externs.contains_key(istr::from_estr(name)) {\n+        ret externs.get(istr::from_estr(name));\n+    }\n     let f = decl_fn(llmod, name, cc, ty);\n-    externs.insert(name, f);\n+    externs.insert(istr::from_estr(name), f);\n     ret f;\n }\n \n-fn get_extern_const(externs: &hashmap<str, ValueRef>, llmod: ModuleRef,\n+fn get_extern_const(externs: &hashmap<istr, ValueRef>, llmod: ModuleRef,\n                     name: &str, ty: TypeRef) -> ValueRef {\n-    if externs.contains_key(name) { ret externs.get(name); }\n+    if externs.contains_key(istr::from_estr(name)) {\n+        ret externs.get(istr::from_estr(name));\n+    }\n     let c = llvm::LLVMAddGlobal(llmod, ty, str::buf(name));\n-    externs.insert(name, c);\n+    externs.insert(istr::from_estr(name), c);\n     ret c;\n }\n \n-fn get_simple_extern_fn(externs: &hashmap<str, ValueRef>, llmod: ModuleRef,\n+fn get_simple_extern_fn(externs: &hashmap<istr, ValueRef>, llmod: ModuleRef,\n                         name: &str, n_args: int) -> ValueRef {\n     let inputs = std::vec::init_elt::<TypeRef>(T_int(), n_args as uint);\n     let output = T_int();\n     let t = T_fn(inputs, output);\n     ret get_extern_fn(externs, llmod, name, lib::llvm::LLVMCCallConv, t);\n }\n \n-fn trans_native_call(cx: &@block_ctxt, externs: &hashmap<str, ValueRef>,\n+fn trans_native_call(cx: &@block_ctxt, externs: &hashmap<istr, ValueRef>,\n                      llmod: ModuleRef, name: &str, args: &[ValueRef]) ->\n    ValueRef {\n     let n: int = std::vec::len::<ValueRef>(args) as int;\n@@ -2287,8 +2291,8 @@ fn call_memmove(cx: &@block_ctxt, dst: ValueRef, src: ValueRef,\n     // LLVM complains -- not even a constant element of a tydesc works).\n \n     let i = bcx_ccx(cx).intrinsics;\n-    assert (i.contains_key(\"llvm.memmove.p0i8.p0i8.i32\"));\n-    let memmove = i.get(\"llvm.memmove.p0i8.p0i8.i32\");\n+    assert (i.contains_key(~\"llvm.memmove.p0i8.p0i8.i32\"));\n+    let memmove = i.get(~\"llvm.memmove.p0i8.p0i8.i32\");\n     let src_ptr = bld::PointerCast(cx, src, T_ptr(T_i8()));\n     let dst_ptr = bld::PointerCast(cx, dst, T_ptr(T_i8()));\n     let size = bld::IntCast(cx, n_bytes, T_i32());\n@@ -2304,8 +2308,8 @@ fn call_bzero(cx: &@block_ctxt, dst: ValueRef, n_bytes: ValueRef,\n     // FIXME: switch to the 64-bit variant when on such a platform.\n \n     let i = bcx_ccx(cx).intrinsics;\n-    assert (i.contains_key(\"llvm.memset.p0i8.i32\"));\n-    let memset = i.get(\"llvm.memset.p0i8.i32\");\n+    assert (i.contains_key(~\"llvm.memset.p0i8.i32\"));\n+    let memset = i.get(~\"llvm.memset.p0i8.i32\");\n     let dst_ptr = bld::PointerCast(cx, dst, T_ptr(T_i8()));\n     let size = bld::IntCast(cx, n_bytes, T_i32());\n     let align =\n@@ -4524,8 +4528,8 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n     let lcx = cx.fcx.lcx;\n     let modname = str::connect(lcx.module_path, \"::\");\n     let global;\n-    if lcx.ccx.module_data.contains_key(modname) {\n-        global = lcx.ccx.module_data.get(modname);\n+    if lcx.ccx.module_data.contains_key(istr::from_estr(modname)) {\n+        global = lcx.ccx.module_data.get(istr::from_estr(modname));\n     } else {\n         let s =\n             link::mangle_internal_name_by_path_and_seq(lcx.ccx,\n@@ -4536,7 +4540,7 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n         llvm::LLVMSetInitializer(global, C_null(T_int()));\n         llvm::LLVMSetLinkage(global,\n                              lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-        lcx.ccx.module_data.insert(modname, global);\n+        lcx.ccx.module_data.insert(istr::from_estr(modname), global);\n     }\n     let log_cx = new_scope_block_ctxt(cx, \"log\");\n     let after_cx = new_sub_block_ctxt(cx, \"after\");\n@@ -6168,7 +6172,7 @@ fn vi2p(cx: &@block_ctxt, v: ValueRef, t: TypeRef) -> ValueRef {\n \n fn p2i(v: ValueRef) -> ValueRef { ret llvm::LLVMConstPtrToInt(v, T_int()); }\n \n-fn declare_intrinsics(llmod: ModuleRef) -> hashmap<str, ValueRef> {\n+fn declare_intrinsics(llmod: ModuleRef) -> hashmap<istr, ValueRef> {\n     let T_memmove32_args: [TypeRef] =\n         [T_ptr(T_i8()), T_ptr(T_i8()), T_i32(), T_i32(), T_i1()];\n     let T_memmove64_args: [TypeRef] =\n@@ -6198,19 +6202,19 @@ fn declare_intrinsics(llmod: ModuleRef) -> hashmap<str, ValueRef> {\n                       T_fn(T_memset64_args, T_void()));\n     let trap = decl_cdecl_fn(llmod, \"llvm.trap\", T_fn(T_trap_args, T_void()));\n     let intrinsics = new_str_hash::<ValueRef>();\n-    intrinsics.insert(\"llvm.gcroot\", gcroot);\n-    intrinsics.insert(\"llvm.gcread\", gcread);\n-    intrinsics.insert(\"llvm.memmove.p0i8.p0i8.i32\", memmove32);\n-    intrinsics.insert(\"llvm.memmove.p0i8.p0i8.i64\", memmove64);\n-    intrinsics.insert(\"llvm.memset.p0i8.i32\", memset32);\n-    intrinsics.insert(\"llvm.memset.p0i8.i64\", memset64);\n-    intrinsics.insert(\"llvm.trap\", trap);\n+    intrinsics.insert(~\"llvm.gcroot\", gcroot);\n+    intrinsics.insert(~\"llvm.gcread\", gcread);\n+    intrinsics.insert(~\"llvm.memmove.p0i8.p0i8.i32\", memmove32);\n+    intrinsics.insert(~\"llvm.memmove.p0i8.p0i8.i64\", memmove64);\n+    intrinsics.insert(~\"llvm.memset.p0i8.i32\", memset32);\n+    intrinsics.insert(~\"llvm.memset.p0i8.i64\", memset64);\n+    intrinsics.insert(~\"llvm.trap\", trap);\n     ret intrinsics;\n }\n \n fn trap(bcx: &@block_ctxt) {\n     let v: [ValueRef] = [];\n-    alt bcx_ccx(bcx).intrinsics.find(\"llvm.trap\") {\n+    alt bcx_ccx(bcx).intrinsics.find(~\"llvm.trap\") {\n       some(x) { bld::Call(bcx, x, v); }\n       _ { bcx_ccx(bcx).sess.bug(\"unbound llvm.trap in trap\"); }\n     }\n@@ -6264,8 +6268,9 @@ fn create_module_map(ccx: &@crate_ctxt) -> ValueRef {\n     llvm::LLVMSetLinkage(map,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n     let elts: [ValueRef] = [];\n-    for each item: @{key: str, val: ValueRef} in ccx.module_data.items() {\n-        let elt = C_struct([p2i(C_cstr(ccx, item.key)), p2i(item.val)]);\n+    for each item: @{key: istr, val: ValueRef} in ccx.module_data.items() {\n+        let elt = C_struct([p2i(C_cstr(ccx, istr::to_estr(item.key))),\n+                            p2i(item.val)]);\n         elts += [elt];\n     }\n     let term = C_struct([C_int(0), C_int(0)]);"}, {"sha": "57539c2a3c59a12d95047768beca8cedbe593de1", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -1,4 +1,5 @@\n import std::str;\n+import std::istr;\n import std::vec;\n import std::option;\n import option::some;\n@@ -303,7 +304,8 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n             // the actual arm block.\n             for each @{key, val} in data.id_map.items() {\n                 bcx.fcx.lllocals.insert\n-                    (val, option::get(assoc(key, m[0].bound)));\n+                    (val, option::get(assoc(istr::to_estr(key),\n+                                            m[0].bound)));\n             }\n             let {bcx: guard_bcx, val: guard_val} =\n                 trans::trans_expr(guard_cx, e);\n@@ -467,12 +469,12 @@ fn make_phi_bindings(bcx: &@block_ctxt, map: &[exit_node],\n                      ids: &ast_util::pat_id_map) -> bool {\n     let our_block = bcx.llbb as uint;\n     let success = true;\n-    for each item: @{key: ast::ident, val: ast::node_id} in ids.items() {\n+    for each item: @{key: ast::identistr, val: ast::node_id} in ids.items() {\n         let llbbs = [];\n         let vals = [];\n         for ex: exit_node in map {\n             if ex.to as uint == our_block {\n-                alt assoc(item.key, ex.bound) {\n+                alt assoc(istr::to_estr(item.key), ex.bound) {\n                   some(val) { llbbs += [ex.from]; vals += [val]; }\n                   none. { }\n                 }"}, {"sha": "77a101d9f681c7e6bdc00e9a34840fe1c4510fc9", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -127,8 +127,8 @@ type crate_ctxt =\n      llmod: ModuleRef,\n      td: target_data,\n      tn: type_names,\n-     externs: hashmap<str, ValueRef>,\n-     intrinsics: hashmap<str, ValueRef>,\n+     externs: hashmap<istr, ValueRef>,\n+     intrinsics: hashmap<istr, ValueRef>,\n      item_ids: hashmap<ast::node_id, ValueRef>,\n      ast_map: ast_map::map,\n      item_symbols: hashmap<ast::node_id, str>,\n@@ -141,7 +141,7 @@ type crate_ctxt =\n      consts: hashmap<ast::node_id, ValueRef>,\n      obj_methods: hashmap<ast::node_id, ()>,\n      tydescs: hashmap<ty::t, @tydesc_info>,\n-     module_data: hashmap<str, ValueRef>,\n+     module_data: hashmap<istr, ValueRef>,\n      lltypes: hashmap<ty::t, TypeRef>,\n      glues: @glue_fns,\n      names: namegen,"}, {"sha": "5a71c99cec2d527b3ba6b12b4f36ee633779b20d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -1322,7 +1322,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n         let vid = lookup_local(fcx, pat.span, pat.id);\n         let typ = ty::mk_var(fcx.ccx.tcx, vid);\n         typ = demand::simple(fcx, pat.span, expected, typ);\n-        let canon_id = map.get(name);\n+        let canon_id = map.get(istr::from_estr(name));\n         if canon_id != pat.id {\n             let ct =\n                 ty::mk_var(fcx.ccx.tcx,"}, {"sha": "d380fbecdb48300caba8873e80660e95590a6de5", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -8,6 +8,8 @@ import codemap::filename;\n type spanned<T> = {node: T, span: span};\n \n type ident = str;\n+type identistr = istr;\n+\n // Functions may or may not have names.\n type fn_ident = option::t<ident>;\n "}, {"sha": "687070da24fca0eca8b4a4ea0b508fc3d1df5568", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -1,4 +1,5 @@\n import std::str;\n+import std::istr;\n import std::option;\n import codemap::span;\n import ast::*;\n@@ -43,15 +44,15 @@ fn def_id_of_def(d: def) -> def_id {\n     }\n }\n \n-type pat_id_map = std::map::hashmap<str, ast::node_id>;\n+type pat_id_map = std::map::hashmap<istr, ast::node_id>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the node_id of their namesake in the first pattern.\n fn pat_id_map(pat: &@pat) -> pat_id_map {\n     let map = std::map::new_str_hash::<node_id>();\n     for each bound in pat_bindings(pat) {\n         let name = alt bound.node { pat_bind(n) { n } };\n-        map.insert(name, bound.id);\n+        map.insert(istr::from_estr(name), bound.id);\n     }\n     ret map;\n }"}, {"sha": "a354aa67090f1ec4cb16ecd152c592637f640d18", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -1,3 +1,4 @@\n+import std::istr;\n import std::vec;\n import std::option;\n import std::map::hashmap;\n@@ -19,17 +20,17 @@ tag syntax_extension {\n \n // A temporary hard-coded map of methods for expanding syntax extension\n // AST nodes into full ASTs\n-fn syntax_expander_table() -> hashmap<str, syntax_extension> {\n+fn syntax_expander_table() -> hashmap<istr, syntax_extension> {\n     let syntax_expanders = new_str_hash::<syntax_extension>();\n-    syntax_expanders.insert(\"fmt\", normal(ext::fmt::expand_syntax_ext));\n-    syntax_expanders.insert(\"env\", normal(ext::env::expand_syntax_ext));\n-    syntax_expanders.insert(\"macro\",\n+    syntax_expanders.insert(~\"fmt\", normal(ext::fmt::expand_syntax_ext));\n+    syntax_expanders.insert(~\"env\", normal(ext::env::expand_syntax_ext));\n+    syntax_expanders.insert(~\"macro\",\n                             macro_defining(ext::simplext::add_new_extension));\n-    syntax_expanders.insert(\"concat_idents\",\n+    syntax_expanders.insert(~\"concat_idents\",\n                             normal(ext::concat_idents::expand_syntax_ext));\n-    syntax_expanders.insert(\"ident_to_str\",\n+    syntax_expanders.insert(~\"ident_to_str\",\n                             normal(ext::ident_to_str::expand_syntax_ext));\n-    syntax_expanders.insert(\"log_syntax\",\n+    syntax_expanders.insert(~\"log_syntax\",\n                             normal(ext::log_syntax::expand_syntax_ext));\n     ret syntax_expanders;\n }"}, {"sha": "542b280540295e00b1284093c96db05dca9600f2", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -5,6 +5,7 @@ import std::option::some;\n \n import std::map::hashmap;\n import std::vec;\n+import std::istr;\n \n import syntax::ast::crate;\n import syntax::ast::expr_;\n@@ -14,7 +15,7 @@ import syntax::fold::*;\n import syntax::ext::base::*;\n \n \n-fn expand_expr(exts: &hashmap<str, syntax_extension>, cx: &ext_ctxt,\n+fn expand_expr(exts: &hashmap<istr, syntax_extension>, cx: &ext_ctxt,\n                e: &expr_, fld: ast_fold, orig: &fn(&expr_, ast_fold) -> expr_)\n    -> expr_ {\n     ret alt e {\n@@ -23,7 +24,7 @@ fn expand_expr(exts: &hashmap<str, syntax_extension>, cx: &ext_ctxt,\n               mac_invoc(pth, args, body) {\n                 assert (vec::len(pth.node.idents) > 0u);\n                 let extname = pth.node.idents[0];\n-                alt exts.find(extname) {\n+                alt exts.find(istr::from_estr(extname)) {\n                   none. {\n                     cx.span_fatal(pth.span,\n                                   #fmt[\"macro undefined: '%s'\", extname])\n@@ -40,7 +41,9 @@ fn expand_expr(exts: &hashmap<str, syntax_extension>, cx: &ext_ctxt,\n                   }\n                   some(macro_defining(ext)) {\n                     let named_extension = ext(cx, pth.span, args, body);\n-                    exts.insert(named_extension.ident, named_extension.ext);\n+                    exts.insert(\n+                        istr::from_estr(named_extension.ident),\n+                        named_extension.ext);\n                     ast::expr_rec([], none)\n                   }\n                 }"}, {"sha": "b0d7cd26020075deccd9c3bfc8004118ddfefa39", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -2,6 +2,7 @@ use std;\n \n import codemap::span;\n import std::vec;\n+import std::istr;\n import std::option;\n import std::map::hashmap;\n import std::map::new_str_hash;\n@@ -18,6 +19,7 @@ import fold::*;\n import ast::node_id;\n import ast_util::respan;\n import ast::ident;\n+import ast::identistr;\n import ast::path;\n import ast::ty;\n import ast::blk;\n@@ -155,9 +157,9 @@ fn compose_sels(s1: selector, s2: selector) -> selector {\n \n \n type binders =\n-    {real_binders: hashmap<ident, selector>,\n+    {real_binders: hashmap<identistr, selector>,\n      mutable literal_ast_matchers: [selector]};\n-type bindings = hashmap<ident, arb_depth<matchable>>;\n+type bindings = hashmap<identistr, arb_depth<matchable>>;\n \n fn acumm_bindings(_cx: &ext_ctxt, _b_dest: &bindings, _b_src: &bindings) { }\n \n@@ -189,7 +191,8 @@ fn use_selectors_to_bind(b: &binders, e: @expr) -> option::t<bindings> {\n         alt sel(match_expr(e)) { none. { ret none; } _ { } }\n     }\n     let never_mind: bool = false;\n-    for each pair: @{key: ident, val: selector} in b.real_binders.items() {\n+    for each pair: @{key: identistr,\n+                     val: selector} in b.real_binders.items() {\n         alt pair.val(match_expr(e)) {\n           none. { never_mind = true; }\n           some(mtc) { res.insert(pair.key, mtc); }\n@@ -262,10 +265,12 @@ fn follow_for_trans(cx: &ext_ctxt, mmaybe: &option::t<arb_depth<matchable>>,\n \n /* helper for transcribe_exprs: what vars from `b` occur in `e`? */\n iter free_vars(b: &bindings, e: @expr) -> ident {\n-    let idents: hashmap<ident, ()> = new_str_hash::<()>();\n+    let idents: hashmap<identistr, ()> = new_str_hash::<()>();\n     fn mark_ident(i: &ident, _fld: ast_fold, b: &bindings,\n-                  idents: &hashmap<ident, ()>) -> ident {\n-        if b.contains_key(i) { idents.insert(i, ()); }\n+                  idents: &hashmap<identistr, ()>) -> ident {\n+        if b.contains_key(istr::from_estr(i)) {\n+            idents.insert(istr::from_estr(i), ());\n+        }\n         ret i;\n     }\n     // using fold is a hack: we want visit, but it doesn't hit idents ) :\n@@ -276,7 +281,7 @@ iter free_vars(b: &bindings, e: @expr) -> ident {\n     let f = make_fold(f_pre);\n     f.fold_expr(e); // ignore result\n     dummy_out(f);\n-    for each id: ident in idents.keys() { put id; }\n+    for each id: identistr in idents.keys() { put istr::to_estr(id); }\n }\n \n \n@@ -293,7 +298,7 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n             /* we need to walk over all the free vars in lockstep, except for\n             the leaves, which are just duplicated */\n             for each fv: ident in free_vars(b, repeat_me) {\n-                let cur_pos = follow(b.get(fv), idx_path);\n+                let cur_pos = follow(b.get(istr::from_estr(fv)), idx_path);\n                 alt cur_pos {\n                   leaf(_) { }\n                   seq(ms, _) {\n@@ -345,7 +350,7 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n // substitute, in a position that's required to be an ident\n fn transcribe_ident(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                     i: &ident, _fld: ast_fold) -> ident {\n-    ret alt follow_for_trans(cx, b.find(i), idx_path) {\n+    ret alt follow_for_trans(cx, b.find(istr::from_estr(i)), idx_path) {\n           some(match_ident(a_id)) { a_id.node }\n           some(m) { match_error(cx, m, \"an identifier\") }\n           none. { i }\n@@ -357,7 +362,8 @@ fn transcribe_path(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                    p: &path_, _fld: ast_fold) -> path_ {\n     // Don't substitute into qualified names.\n     if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { ret p; }\n-    ret alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n+    ret alt follow_for_trans(cx, b.find(\n+        istr::from_estr(p.idents[0])), idx_path) {\n           some(match_ident(id)) {\n             {global: false, idents: [id.node], types: []}\n           }\n@@ -378,7 +384,8 @@ fn transcribe_expr(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n             if vec::len(p.node.types) > 0u || vec::len(p.node.idents) != 1u {\n                 e\n             }\n-            alt follow_for_trans(cx, b.find(p.node.idents[0]), idx_path) {\n+            alt follow_for_trans(cx, b.find(\n+                istr::from_estr(p.node.idents[0])), idx_path) {\n               some(match_ident(id)) {\n                 expr_path(respan(id.span,\n                                  {global: false,\n@@ -402,7 +409,8 @@ fn transcribe_type(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n           ast::ty_path(pth, _) {\n             alt path_to_ident(pth) {\n               some(id) {\n-                alt follow_for_trans(cx, b.find(id), idx_path) {\n+                alt follow_for_trans(cx, b.find(\n+                    istr::from_estr(id)), idx_path) {\n                   some(match_ty(ty)) { ty.node }\n                   some(m) { match_error(cx, m, \"a type\") }\n                   none. { orig(t, fld) }\n@@ -424,7 +432,8 @@ fn transcribe_block(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                     orig: fn(&blk_, ast_fold) -> blk_) -> blk_ {\n     ret alt block_to_ident(blk) {\n           some(id) {\n-            alt follow_for_trans(cx, b.find(id), idx_path) {\n+            alt follow_for_trans(cx, b.find(\n+                istr::from_estr(id)), idx_path) {\n               some(match_block(new_blk)) { new_blk.node }\n \n \n@@ -525,10 +534,11 @@ fn p_t_s_r_path(cx: &ext_ctxt, p: &path, s: &selector, b: &binders) {\n                   _ { cx.bug(\"broken traversal in p_t_s_r\") }\n                 }\n         }\n-        if b.real_binders.contains_key(p_id) {\n+        if b.real_binders.contains_key(istr::from_estr(p_id)) {\n             cx.span_fatal(p.span, \"duplicate binding identifier\");\n         }\n-        b.real_binders.insert(p_id, compose_sels(s, bind select(cx, _)));\n+        b.real_binders.insert(istr::from_estr(p_id),\n+                              compose_sels(s, bind select(cx, _)));\n       }\n       none. { }\n     }\n@@ -573,7 +583,8 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n                         }\n                 }\n                 let final_step = bind select_pt_1(cx, _, select_pt_2);\n-                b.real_binders.insert(id, compose_sels(s, final_step));\n+                b.real_binders.insert(\n+                    istr::from_estr(id), compose_sels(s, final_step));\n               }\n               none. { no_des(cx, pth.span, \"under `#<>`\"); }\n             }\n@@ -593,7 +604,8 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n                     }\n             }\n             let final_step = bind select_pt_1(cx, _, select_pt_2);\n-            b.real_binders.insert(id, compose_sels(s, final_step));\n+            b.real_binders.insert(istr::from_estr(id),\n+                                  compose_sels(s, final_step));\n           }\n           none. { no_des(cx, blk.span, \"under `#{}`\"); }\n         }"}, {"sha": "c0beb8a32c3c2a5372722400869f9edab2f780f4", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -53,7 +53,7 @@ type parser =\n         fn get_str(token::str_num) -> str;\n         fn get_reader() -> lexer::reader;\n         fn get_filemap() -> codemap::filemap;\n-        fn get_bad_expr_words() -> hashmap<str, ()>;\n+        fn get_bad_expr_words() -> hashmap<istr, ()>;\n         fn get_chpos() -> uint;\n         fn get_byte_pos() -> uint;\n         fn get_id() -> node_id;\n@@ -84,7 +84,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n                      mutable restr: restriction,\n                      rdr: lexer::reader,\n                      precs: @[op_spec],\n-                     bad_words: hashmap<str, ()>) {\n+                     bad_words: hashmap<istr, ()>) {\n         fn peek() -> token::token { ret tok; }\n         fn bump() {\n             last_tok_span = tok_span;\n@@ -132,7 +132,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n         }\n         fn get_reader() -> lexer::reader { ret rdr; }\n         fn get_filemap() -> codemap::filemap { ret rdr.get_filemap(); }\n-        fn get_bad_expr_words() -> hashmap<str, ()> { ret bad_words; }\n+        fn get_bad_expr_words() -> hashmap<istr, ()> { ret bad_words; }\n         fn get_chpos() -> uint { ret rdr.get_chpos(); }\n         fn get_byte_pos() -> uint { ret rdr.get_byte_pos(); }\n         fn get_id() -> node_id { ret next_node_id(sess); }\n@@ -148,44 +148,44 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n // These are the words that shouldn't be allowed as value identifiers,\n // because, if used at the start of a line, they will cause the line to be\n // interpreted as a specific kind of statement, which would be confusing.\n-fn bad_expr_word_table() -> hashmap<str, ()> {\n+fn bad_expr_word_table() -> hashmap<istr, ()> {\n     let words = new_str_hash();\n-    words.insert(\"mod\", ());\n-    words.insert(\"if\", ());\n-    words.insert(\"else\", ());\n-    words.insert(\"while\", ());\n-    words.insert(\"do\", ());\n-    words.insert(\"alt\", ());\n-    words.insert(\"for\", ());\n-    words.insert(\"each\", ());\n-    words.insert(\"break\", ());\n-    words.insert(\"cont\", ());\n-    words.insert(\"put\", ());\n-    words.insert(\"ret\", ());\n-    words.insert(\"be\", ());\n-    words.insert(\"fail\", ());\n-    words.insert(\"type\", ());\n-    words.insert(\"resource\", ());\n-    words.insert(\"check\", ());\n-    words.insert(\"assert\", ());\n-    words.insert(\"claim\", ());\n-    words.insert(\"prove\", ());\n-    words.insert(\"native\", ());\n-    words.insert(\"fn\", ());\n-    words.insert(\"block\", ());\n-    words.insert(\"lambda\", ());\n-    words.insert(\"pure\", ());\n-    words.insert(\"iter\", ());\n-    words.insert(\"block\", ());\n-    words.insert(\"import\", ());\n-    words.insert(\"export\", ());\n-    words.insert(\"let\", ());\n-    words.insert(\"const\", ());\n-    words.insert(\"log\", ());\n-    words.insert(\"log_err\", ());\n-    words.insert(\"tag\", ());\n-    words.insert(\"obj\", ());\n-    words.insert(\"copy\", ());\n+    words.insert(~\"mod\", ());\n+    words.insert(~\"if\", ());\n+    words.insert(~\"else\", ());\n+    words.insert(~\"while\", ());\n+    words.insert(~\"do\", ());\n+    words.insert(~\"alt\", ());\n+    words.insert(~\"for\", ());\n+    words.insert(~\"each\", ());\n+    words.insert(~\"break\", ());\n+    words.insert(~\"cont\", ());\n+    words.insert(~\"put\", ());\n+    words.insert(~\"ret\", ());\n+    words.insert(~\"be\", ());\n+    words.insert(~\"fail\", ());\n+    words.insert(~\"type\", ());\n+    words.insert(~\"resource\", ());\n+    words.insert(~\"check\", ());\n+    words.insert(~\"assert\", ());\n+    words.insert(~\"claim\", ());\n+    words.insert(~\"prove\", ());\n+    words.insert(~\"native\", ());\n+    words.insert(~\"fn\", ());\n+    words.insert(~\"block\", ());\n+    words.insert(~\"lambda\", ());\n+    words.insert(~\"pure\", ());\n+    words.insert(~\"iter\", ());\n+    words.insert(~\"block\", ());\n+    words.insert(~\"import\", ());\n+    words.insert(~\"export\", ());\n+    words.insert(~\"let\", ());\n+    words.insert(~\"const\", ());\n+    words.insert(~\"log\", ());\n+    words.insert(~\"log_err\", ());\n+    words.insert(~\"tag\", ());\n+    words.insert(~\"obj\", ());\n+    words.insert(~\"copy\", ());\n     ret words;\n }\n \n@@ -273,7 +273,7 @@ fn check_bad_word(p: &parser) {\n     alt p.peek() {\n       token::IDENT(sid, false) {\n         let w = p.get_str(sid);\n-        if p.get_bad_expr_words().contains_key(w) {\n+        if p.get_bad_expr_words().contains_key(istr::from_estr(w)) {\n             p.fatal(\"found \" + w + \" in expression position\");\n         }\n       }\n@@ -1455,7 +1455,8 @@ fn parse_pat(p: &parser) -> @ast::pat {\n                 p.bump();\n                 subpat = parse_pat(p);\n             } else {\n-                if p.get_bad_expr_words().contains_key(fieldname) {\n+                if p.get_bad_expr_words()\n+                    .contains_key(istr::from_estr(fieldname)) {\n                     p.fatal(\"found \" + fieldname + \" in binding position\");\n                 }\n                 subpat =\n@@ -2061,7 +2062,7 @@ fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let variants: [ast::variant] = [];\n     // Newtype syntax\n     if p.peek() == token::EQ {\n-        if p.get_bad_expr_words().contains_key(id) {\n+        if p.get_bad_expr_words().contains_key(istr::from_estr(id)) {\n             p.fatal(\"found \" + id + \" in tag constructor position\");\n         }\n         p.bump();"}, {"sha": "7a46e28e67def7961abab6b640c478db6e0d581a", "filename": "src/lib/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -194,8 +194,8 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n \n // Hash map constructors for basic types\n \n-fn new_str_hash<@V>() -> hashmap<str, V> {\n-    ret mk_hashmap(str::hash, str::eq);\n+fn new_str_hash<@V>() -> hashmap<istr, V> {\n+    ret mk_hashmap(istr::hash, istr::eq);\n }\n \n fn new_int_hash<@V>() -> hashmap<int, V> {"}, {"sha": "eb193d61af7302b75ec54d45d593435b5ee8239c", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -81,10 +81,10 @@ mod map_reduce {\n         // log_err \"map_task \" + input;\n         let intermediates = map::new_str_hash();\n \n-        fn emit(im: &map::hashmap<str, chan<reduce_proto>>,\n+        fn emit(im: &map::hashmap<istr, chan<reduce_proto>>,\n                 ctrl: chan<ctrl_proto>, key: str, val: int) {\n             let c;\n-            alt im.find(key) {\n+            alt im.find(istr::from_estr(key)) {\n               some(_c) {\n \n                 c = _c\n@@ -94,7 +94,7 @@ mod map_reduce {\n                 let keyi = str::bytes(key);\n                 send(ctrl, find_reducer(keyi, chan(p)));\n                 c = recv(p);\n-                im.insert(key, c);\n+                im.insert(istr::from_estr(key), c);\n                 send(c, ref);\n               }\n             }\n@@ -103,7 +103,7 @@ mod map_reduce {\n \n         map(input, bind emit(intermediates, ctrl, _, _));\n \n-        for each kv: @{key: str, val: chan<reduce_proto>} in\n+        for each kv: @{key: istr, val: chan<reduce_proto>} in\n                  intermediates.items() {\n             send(kv.val, release);\n         }\n@@ -147,7 +147,7 @@ mod map_reduce {\n         // This task becomes the master control task. It task::_spawns\n         // to do the rest.\n \n-        let reducers: map::hashmap<str, chan<reduce_proto>>;\n+        let reducers: map::hashmap<istr, chan<reduce_proto>>;\n \n         reducers = map::new_str_hash();\n \n@@ -163,7 +163,7 @@ mod map_reduce {\n               }\n               find_reducer(ki, cc) {\n                 let c;\n-                let k = str::unsafe_from_bytes(ki);\n+                let k = istr::unsafe_from_bytes(ki);\n                 // log_err \"finding reducer for \" + k;\n                 alt reducers.find(k) {\n                   some(_c) {\n@@ -174,7 +174,8 @@ mod map_reduce {\n                     // log_err \"creating new reducer for \" + k;\n                     let p = port();\n                     tasks +=\n-                        [task::spawn_joinable(bind reduce_task(k, chan(p)))];\n+                        [task::spawn_joinable(\n+                            bind reduce_task(istr::to_estr(k), chan(p)))];\n                     c = recv(p);\n                     reducers.insert(k, c);\n                   }\n@@ -184,7 +185,7 @@ mod map_reduce {\n             }\n         }\n \n-        for each kv: @{key: str, val: chan<reduce_proto>} in reducers.items()\n+        for each kv: @{key: istr, val: chan<reduce_proto>} in reducers.items()\n                  {\n             send(kv.val, done);\n         }"}, {"sha": "bb0c5dee6fe76507d097d8c35b15c38ec8d00628", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652332f9d44d0c3eb36c220a88ef37f7f875206f/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=652332f9d44d0c3eb36c220a88ef37f7f875206f", "patch": "@@ -10,6 +10,7 @@ import option = std::option::t;\n import std::option::some;\n import std::option::none;\n import std::str;\n+import std::istr;\n import std::vec;\n import std::map;\n import std::task;\n@@ -40,10 +41,10 @@ mod map_reduce {\n \n         let intermediates = map::new_str_hash();\n \n-        fn emit(im: &map::hashmap<str, int>, ctrl: chan<ctrl_proto>,\n+        fn emit(im: &map::hashmap<istr, int>, ctrl: chan<ctrl_proto>,\n                 key: str, val: str) {\n             let c;\n-            alt im.find(key) {\n+            alt im.find(istr::from_estr(key)) {\n               some(_c) { c = _c }\n               none. {\n                 let p = port();\n@@ -52,7 +53,7 @@ mod map_reduce {\n                 log_err \"receiving\";\n                 c = recv(p);\n                 log_err c;\n-                im.insert(key, c);\n+                im.insert(istr::from_estr(key), c);\n               }\n             }\n         }\n@@ -67,7 +68,7 @@ mod map_reduce {\n         // This task becomes the master control task. It spawns others\n         // to do the rest.\n \n-        let reducers: map::hashmap<str, int>;\n+        let reducers: map::hashmap<istr, int>;\n \n         reducers = map::new_str_hash();\n \n@@ -80,7 +81,7 @@ mod map_reduce {\n               mapper_done. { num_mappers -= 1; }\n               find_reducer(k, cc) {\n                 let c;\n-                alt reducers.find(str::unsafe_from_bytes(k)) {\n+                alt reducers.find(istr::unsafe_from_bytes(k)) {\n                   some(_c) { c = _c; }\n                   none. { c = 0; }\n                 }"}]}