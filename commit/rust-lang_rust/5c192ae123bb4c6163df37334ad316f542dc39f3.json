{"sha": "5c192ae123bb4c6163df37334ad316f542dc39f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMTkyYWUxMjNiYjRjNjE2M2RmMzczMzRhZDMxNmY1NDJkYzM5ZjM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-14T20:55:25Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-18T11:36:36Z"}, "message": "rustc: move type definitions from middle::freevars to middle::ty.", "tree": {"sha": "d1842519dd990845d12454cf761b80c57936dc1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1842519dd990845d12454cf761b80c57936dc1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c192ae123bb4c6163df37334ad316f542dc39f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c192ae123bb4c6163df37334ad316f542dc39f3", "html_url": "https://github.com/rust-lang/rust/commit/5c192ae123bb4c6163df37334ad316f542dc39f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c192ae123bb4c6163df37334ad316f542dc39f3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6536a0c0d6285c00675a6b9342c3630c309aba36", "url": "https://api.github.com/repos/rust-lang/rust/commits/6536a0c0d6285c00675a6b9342c3630c309aba36", "html_url": "https://github.com/rust-lang/rust/commit/6536a0c0d6285c00675a6b9342c3630c309aba36"}], "stats": {"total": 200, "additions": 86, "deletions": 114}, "files": [{"sha": "424467be86ffcd96de4510ca043e5c4f12d7d83d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5c192ae123bb4c6163df37334ad316f542dc39f3", "patch": "@@ -18,13 +18,12 @@ use driver::session::Session;\n use metadata::decoder;\n use middle::def;\n use metadata::encoder as e;\n-use middle::freevars::{CaptureMode, freevar_entry};\n-use middle::freevars;\n use middle::region;\n use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n use metadata::tydecode::{RegionParameter};\n use metadata::tyencode;\n+use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::typeck::{MethodCall, MethodCallee, MethodOrigin};\n@@ -540,36 +539,36 @@ impl tr for ty::TraitStore {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(rbml_w: &mut Encoder, fv: &freevar_entry) {\n+fn encode_freevar_entry(rbml_w: &mut Encoder, fv: &ty::Freevar) {\n     (*fv).encode(rbml_w).unwrap();\n }\n \n-fn encode_capture_mode(rbml_w: &mut Encoder, cm: CaptureMode) {\n+fn encode_capture_mode(rbml_w: &mut Encoder, cm: ast::CaptureClause) {\n     cm.encode(rbml_w).unwrap();\n }\n \n trait rbml_decoder_helper {\n     fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n-                          -> freevar_entry;\n-    fn read_capture_mode(&mut self) -> CaptureMode;\n+                          -> ty::Freevar;\n+    fn read_capture_mode(&mut self) -> ast::CaptureClause;\n }\n \n impl<'a> rbml_decoder_helper for reader::Decoder<'a> {\n     fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n-                          -> freevar_entry {\n-        let fv: freevar_entry = Decodable::decode(self).unwrap();\n+                          -> ty::Freevar {\n+        let fv: ty::Freevar = Decodable::decode(self).unwrap();\n         fv.tr(dcx)\n     }\n \n-    fn read_capture_mode(&mut self) -> CaptureMode {\n-        let cm: CaptureMode = Decodable::decode(self).unwrap();\n+    fn read_capture_mode(&mut self) -> ast::CaptureClause {\n+        let cm: ast::CaptureClause = Decodable::decode(self).unwrap();\n         cm\n     }\n }\n \n-impl tr for freevar_entry {\n-    fn tr(&self, dcx: &DecodeContext) -> freevar_entry {\n-        freevar_entry {\n+impl tr for ty::Freevar {\n+    fn tr(&self, dcx: &DecodeContext) -> ty::Freevar {\n+        ty::Freevar {\n             def: self.def.tr(dcx),\n             span: self.span.tr(dcx),\n         }\n@@ -1291,8 +1290,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         });\n \n         for freevar in fv.iter() {\n-            match freevars::get_capture_mode(tcx, id) {\n-                freevars::CaptureByRef => {\n+            match tcx.capture_mode(id) {\n+                ast::CaptureByRef => {\n                     rbml_w.tag(c::tag_table_upvar_borrow_map, |rbml_w| {\n                         rbml_w.id(id);\n                         rbml_w.tag(c::tag_table_val, |rbml_w| {"}, {"sha": "4034a476e61f8fad1b03e02d92cbb2aeb78c3749", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5c192ae123bb4c6163df37334ad316f542dc39f3", "patch": "@@ -17,6 +17,7 @@\n use middle::mem_categorization as mc;\n use middle::def;\n use middle::freevars;\n+use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::ty;\n use middle::typeck::{MethodCall, MethodObject, MethodOrigin, MethodParam};\n@@ -911,12 +912,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         debug!(\"walk_captures({})\", closure_expr.repr(self.tcx()));\n \n         let tcx = self.typer.tcx();\n-        freevars::with_freevars(tcx, closure_expr.id, |freevars| {\n-            match freevars::get_capture_mode(self.tcx(), closure_expr.id) {\n-                freevars::CaptureByRef => {\n+        ty::with_freevars(tcx, closure_expr.id, |freevars| {\n+            match self.tcx().capture_mode(closure_expr.id) {\n+                ast::CaptureByRef => {\n                     self.walk_by_ref_captures(closure_expr, freevars);\n                 }\n-                freevars::CaptureByValue => {\n+                ast::CaptureByValue => {\n                     self.walk_by_value_captures(closure_expr, freevars);\n                 }\n             }\n@@ -925,7 +926,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n \n     fn walk_by_ref_captures(&mut self,\n                             closure_expr: &ast::Expr,\n-                            freevars: &[freevars::freevar_entry]) {\n+                            freevars: &[ty::Freevar]) {\n         for freevar in freevars.iter() {\n             let id_var = freevar.def.def_id().node;\n             let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n@@ -950,7 +951,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n \n     fn walk_by_value_captures(&mut self,\n                               closure_expr: &ast::Expr,\n-                              freevars: &[freevars::freevar_entry]) {\n+                              freevars: &[ty::Freevar]) {\n         for freevar in freevars.iter() {\n             let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                closure_expr.span,"}, {"sha": "c014c8f8bb2bc8bd22a789e94440a3fe7a849b42", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 8, "deletions": 50, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=5c192ae123bb4c6163df37334ad316f542dc39f3", "patch": "@@ -14,7 +14,6 @@\n #![allow(non_camel_case_types)]\n \n use middle::def;\n-use middle::mem_categorization::Typer;\n use middle::resolve;\n use middle::ty;\n use util::nodemap::{NodeMap, NodeSet};\n@@ -24,27 +23,6 @@ use syntax::codemap::Span;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-#[deriving(Clone, Decodable, Encodable, Show)]\n-pub enum CaptureMode {\n-    /// Copy/move the value into the environment.\n-    CaptureByValue,\n-\n-    /// Access by reference (used for stack closures).\n-    CaptureByRef\n-}\n-\n-// A vector of defs representing the free variables referred to in a function.\n-// (The def_upvar will already have been stripped).\n-#[deriving(Encodable, Decodable)]\n-pub struct freevar_entry {\n-    pub def: def::Def, //< The variable being accessed free.\n-    pub span: Span     //< First span where it is accessed (there can be multiple)\n-}\n-\n-pub type freevar_map = NodeMap<Vec<freevar_entry>>;\n-\n-pub type CaptureModeMap = NodeMap<CaptureMode>;\n-\n struct CollectFreevarsVisitor<'a, 'b:'a> {\n     node_id: ast::NodeId,\n     seen: NodeSet,\n@@ -60,30 +38,22 @@ impl<'a, 'b, 'v> Visitor<'v> for CollectFreevarsVisitor<'a, 'b> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprProc(..) => {\n-                self.cx.capture_mode_map.insert(expr.id, CaptureByValue);\n+                self.cx.capture_mode_map.insert(expr.id, ast::CaptureByValue);\n                 self.depth += 1;\n                 visit::walk_expr(self, expr);\n                 self.depth -= 1;\n             }\n             ast::ExprFnBlock(_, _, _) => {\n                 // NOTE(stage0): After snapshot, change to:\n                 //\n-                //let capture_mode = match capture_clause {\n-                //    ast::CaptureByValue => CaptureByValue,\n-                //    ast::CaptureByRef => CaptureByRef,\n-                //};\n-                let capture_mode = CaptureByRef;\n-                self.cx.capture_mode_map.insert(expr.id, capture_mode);\n+                //self.cx.capture_mode_map.insert(expr.id, capture_clause);\n+                self.cx.capture_mode_map.insert(expr.id, ast::CaptureByRef);\n                 self.depth += 1;\n                 visit::walk_expr(self, expr);\n                 self.depth -= 1;\n             }\n             ast::ExprUnboxedFn(capture_clause, _, _, _) => {\n-                let capture_mode = match capture_clause {\n-                    ast::CaptureByValue => CaptureByValue,\n-                    ast::CaptureByRef => CaptureByRef,\n-                };\n-                self.cx.capture_mode_map.insert(expr.id, capture_mode);\n+                self.cx.capture_mode_map.insert(expr.id, capture_clause);\n                 self.depth += 1;\n                 visit::walk_expr(self, expr);\n                 self.depth -= 1;\n@@ -111,7 +81,7 @@ impl<'a, 'b, 'v> Visitor<'v> for CollectFreevarsVisitor<'a, 'b> {\n                     },\n                     _ => return\n                 };\n-                self.cx.freevars.find_or_insert(self.node_id, vec![]).push(freevar_entry {\n+                self.cx.freevars.find_or_insert(self.node_id, vec![]).push(ty::Freevar {\n                     def: def,\n                     span: expr.span,\n                 });\n@@ -124,8 +94,8 @@ impl<'a, 'b, 'v> Visitor<'v> for CollectFreevarsVisitor<'a, 'b> {\n \n struct AnnotateFreevarsVisitor<'a> {\n     def_map: &'a resolve::DefMap,\n-    freevars: freevar_map,\n-    capture_mode_map: CaptureModeMap,\n+    freevars: ty::FreevarMap,\n+    capture_mode_map: ty::CaptureModeMap,\n }\n \n impl<'a, 'v> Visitor<'v> for AnnotateFreevarsVisitor<'a> {\n@@ -147,7 +117,7 @@ impl<'a, 'v> Visitor<'v> for AnnotateFreevarsVisitor<'a> {\n // node of interest rather than building up the free variables in\n // one pass. This could be improved upon if it turns out to matter.\n pub fn annotate_freevars(def_map: &resolve::DefMap, krate: &ast::Crate)\n-                         -> (freevar_map, CaptureModeMap) {\n+                         -> (ty::FreevarMap, ty::CaptureModeMap) {\n     let mut visitor = AnnotateFreevarsVisitor {\n         def_map: def_map,\n         freevars: NodeMap::new(),\n@@ -156,15 +126,3 @@ pub fn annotate_freevars(def_map: &resolve::DefMap, krate: &ast::Crate)\n     visit::walk_crate(&mut visitor, krate);\n     (visitor.freevars, visitor.capture_mode_map)\n }\n-\n-pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[freevar_entry]| -> T) -> T {\n-    match tcx.freevars.borrow().find(&fid) {\n-        None => fail!(\"with_freevars: {} has no freevars\", fid),\n-        Some(d) => f(d.as_slice())\n-    }\n-}\n-\n-pub fn get_capture_mode<'tcx, T:Typer<'tcx>>(tcx: &T, closure_expr_id: ast::NodeId)\n-                                             -> CaptureMode {\n-    tcx.capture_mode(closure_expr_id)\n-}"}, {"sha": "ad275e6e84cdea9335235040fe7c775fe856f243", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=5c192ae123bb4c6163df37334ad316f542dc39f3", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::freevars::freevar_entry;\n-use middle::freevars;\n use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::ty;\n@@ -146,10 +144,10 @@ fn check_item(cx: &mut Context, item: &Item) {\n fn with_appropriate_checker(cx: &Context,\n                             id: NodeId,\n                             fn_span: Span,\n-                            b: |checker: |&Context, &freevar_entry||) {\n+                            b: |checker: |&Context, &ty::Freevar||) {\n     fn check_for_uniq(cx: &Context,\n                       fn_span: Span,\n-                      fv: &freevar_entry,\n+                      fv: &ty::Freevar,\n                       bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n@@ -162,7 +160,7 @@ fn with_appropriate_checker(cx: &Context,\n     fn check_for_block(cx: &Context,\n                        fn_span: Span,\n                        fn_id: NodeId,\n-                       fv: &freevar_entry,\n+                       fv: &ty::Freevar,\n                        bounds: ty::BuiltinBounds) {\n         let id = fv.def.def_id().node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n@@ -177,7 +175,7 @@ fn with_appropriate_checker(cx: &Context,\n                              bounds, Some(var_t));\n     }\n \n-    fn check_for_bare(cx: &Context, fv: &freevar_entry) {\n+    fn check_for_bare(cx: &Context, fv: &ty::Freevar) {\n         span_err!(cx.tcx.sess, fv.span, E0143,\n                   \"can't capture dynamic environment in a fn item; \\\n                    use the || {} closure form instead\", \"{ ... }\");\n@@ -227,7 +225,7 @@ fn check_fn(\n \n     // <Check kinds on free variables:\n     with_appropriate_checker(cx, fn_id, sp, |chk| {\n-        freevars::with_freevars(cx.tcx, fn_id, |freevars| {\n+        ty::with_freevars(cx.tcx, fn_id, |freevars| {\n             for fv in freevars.iter() {\n                 chk(cx, fv);\n             }"}, {"sha": "982c1a945a31482d12857545cbd9abc5e6ab7427", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5c192ae123bb4c6163df37334ad316f542dc39f3", "patch": "@@ -459,7 +459,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         // in better error messages than just pointing at the closure\n         // construction site.\n         let mut call_caps = Vec::new();\n-        freevars::with_freevars(ir.tcx, expr.id, |freevars| {\n+        ty::with_freevars(ir.tcx, expr.id, |freevars| {\n             for fv in freevars.iter() {\n                 match fv.def {\n                     DefLocal(rv) => {"}, {"sha": "8d0d701885e736a3f82e3c349dd5de2b4c19d4fa", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5c192ae123bb4c6163df37334ad316f542dc39f3", "patch": "@@ -273,7 +273,7 @@ pub trait Typer<'tcx> {\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode;\n+                    -> ast::CaptureClause;\n     fn unboxed_closures<'a>(&'a self)\n                         -> &'a RefCell<DefIdMap<ty::UnboxedClosure>>;\n }"}, {"sha": "12b277829375c16c5672eaf63a3f7e484b416edc", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=5c192ae123bb4c6163df37334ad316f542dc39f3", "patch": "@@ -15,6 +15,7 @@ use driver::config::FullDebugInfo;\n use llvm::ValueRef;\n use middle::def;\n use middle::freevars;\n+use middle::mem_categorization::Typer;\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -100,7 +101,7 @@ use syntax::ast_util;\n // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n pub struct EnvValue {\n-    action: freevars::CaptureMode,\n+    action: ast::CaptureClause,\n     datum: Datum<Lvalue>\n }\n \n@@ -120,8 +121,8 @@ pub fn mk_closure_tys(tcx: &ty::ctxt,\n     // converted to ptrs.\n     let bound_tys = bound_values.iter().map(|bv| {\n         match bv.action {\n-            freevars::CaptureByValue => bv.datum.ty,\n-            freevars::CaptureByRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n+            ast::CaptureByValue => bv.datum.ty,\n+            ast::CaptureByRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n         }\n     }).collect();\n     let cdata_ty = ty::mk_tup(tcx, bound_tys);\n@@ -208,10 +209,10 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let bound_data = GEPi(bcx, llbox, [0u, abi::box_field_body, i]);\n \n         match bv.action {\n-            freevars::CaptureByValue => {\n+            ast::CaptureByValue => {\n                 bcx = bv.datum.store_to(bcx, bound_data);\n             }\n-            freevars::CaptureByRef => {\n+            ast::CaptureByRef => {\n                 Store(bcx, bv.datum.to_llref(), bound_data);\n             }\n         }\n@@ -223,8 +224,8 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n-                             freevar_mode: freevars::CaptureMode,\n-                             freevars: &Vec<freevars::freevar_entry>,\n+                             freevar_mode: ast::CaptureClause,\n+                             freevars: &Vec<ty::Freevar>,\n                              store: ty::TraitStore)\n                              -> ClosureResult<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::build_closure\");\n@@ -247,7 +248,7 @@ fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n // with the upvars and type descriptors.\n fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 cdata_ty: ty::t,\n-                                freevars: &Vec<freevars::freevar_entry>,\n+                                freevars: &Vec<ty::Freevar>,\n                                 store: ty::TraitStore)\n                                 -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n@@ -301,7 +302,7 @@ fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn load_unboxed_closure_environment<'blk, 'tcx>(\n                                     bcx: Block<'blk, 'tcx>,\n                                     arg_scope_id: ScopeId,\n-                                    freevars: &Vec<freevars::freevar_entry>,\n+                                    freevars: &Vec<ty::Freevar>,\n                                     closure_id: ast::DefId)\n                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n@@ -386,11 +387,9 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n \n-    let freevar_mode = freevars::get_capture_mode(tcx, id);\n-    let freevars: Vec<freevars::freevar_entry> =\n-        freevars::with_freevars(tcx,\n-                                id,\n-                                |fv| fv.iter().map(|&fv| fv).collect());\n+    let freevar_mode = tcx.capture_mode(id);\n+    let freevars: Vec<ty::Freevar> =\n+        ty::with_freevars(tcx, id, |fv| fv.iter().map(|&fv| fv).collect());\n \n     let ClosureResult {\n         llbox,\n@@ -476,10 +475,8 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                                         .clone();\n     let function_type = ty::mk_closure(bcx.tcx(), function_type);\n \n-    let freevars: Vec<freevars::freevar_entry> =\n-        freevars::with_freevars(bcx.tcx(),\n-                                id,\n-                                |fv| fv.iter().map(|&fv| fv).collect());\n+    let freevars: Vec<ty::Freevar> =\n+        ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n     let freevars_ptr = &freevars;\n \n     trans_closure(bcx.ccx(),"}, {"sha": "ec8fc5d1059c8c07c46dd83adcb709d2bc5e510b", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5c192ae123bb4c6163df37334ad316f542dc39f3", "patch": "@@ -525,7 +525,7 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode {\n+                    -> ast::CaptureClause {\n         self.tcx().capture_modes.borrow().get_copy(&closure_expr_id)\n     }\n }"}, {"sha": "6dda5dcf19cbc9a028d20c0cc4545acbc00d0ca6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5c192ae123bb4c6163df37334ad316f542dc39f3", "patch": "@@ -17,8 +17,6 @@ use metadata::csearch;\n use middle::const_eval;\n use middle::def;\n use middle::dependency_format;\n-use middle::freevars::CaptureModeMap;\n-use middle::freevars;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n use middle::lang_items::{FnOnceTraitLangItem, OpaqueStructLangItem};\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n@@ -480,7 +478,7 @@ pub struct ctxt<'tcx> {\n \n     pub map: ast_map::Map<'tcx>,\n     pub intrinsic_defs: RefCell<DefIdMap<t>>,\n-    pub freevars: RefCell<freevars::freevar_map>,\n+    pub freevars: RefCell<FreevarMap>,\n     pub tcache: type_cache,\n     pub rcache: creader_cache,\n     pub short_names_cache: RefCell<HashMap<t, String>>,\n@@ -1463,8 +1461,8 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      dm: resolve::DefMap,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n-                     freevars: freevars::freevar_map,\n-                     capture_modes: freevars::CaptureModeMap,\n+                     freevars: FreevarMap,\n+                     capture_modes: CaptureModeMap,\n                      region_maps: middle::region::RegionMaps,\n                      lang_items: middle::lang_items::LanguageItems,\n                      stability: stability::Index) -> ctxt<'tcx> {\n@@ -5615,7 +5613,7 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode {\n+                    -> ast::CaptureClause {\n         self.capture_modes.borrow().get_copy(&closure_expr_id)\n     }\n \n@@ -5686,3 +5684,24 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n         }\n     })\n }\n+\n+/// A free variable referred to in a function.\n+#[deriving(Encodable, Decodable)]\n+pub struct Freevar {\n+    /// The variable being accessed free.\n+    pub def: def::Def,\n+\n+    // First span where it is accessed (there can be multiple).\n+    pub span: Span\n+}\n+\n+pub type FreevarMap = NodeMap<Vec<Freevar>>;\n+\n+pub type CaptureModeMap = NodeMap<ast::CaptureClause>;\n+\n+pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[Freevar]| -> T) -> T {\n+    match tcx.freevars.borrow().find(&fid) {\n+        None => fail!(\"with_freevars: {} has no freevars\", fid),\n+        Some(d) => f(d.as_slice())\n+    }\n+}"}, {"sha": "55c13cc636bc39a6cd25d86778d31ec8a815e558", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5c192ae123bb4c6163df37334ad316f542dc39f3", "patch": "@@ -318,7 +318,7 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n         self.ccx.tcx.upvar_borrow(upvar_id)\n     }\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode {\n+                    -> ast::CaptureClause {\n         self.ccx.tcx.capture_mode(closure_expr_id)\n     }\n     fn unboxed_closures<'a>(&'a self)"}, {"sha": "0e421200208b6abd70d46c1cffbdeb52fc2fd3e9", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=5c192ae123bb4c6163df37334ad316f542dc39f3", "patch": "@@ -478,7 +478,7 @@ impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode {\n+                    -> ast::CaptureClause {\n         self.tcx().capture_modes.borrow().get_copy(&closure_expr_id)\n     }\n \n@@ -851,7 +851,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                                          ..}) => {\n             // For closure, ensure that the variables outlive region\n             // bound, since they are captured by reference.\n-            freevars::with_freevars(tcx, expr.id, |freevars| {\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n                 if freevars.is_empty() {\n                     // No free variables means that the environment\n                     // will be NULL at runtime and hence the closure\n@@ -874,13 +874,13 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                                          ..}) => {\n             // For proc, ensure that the *types* of the variables\n             // outlive region bound, since they are captured by value.\n-            freevars::with_freevars(tcx, expr.id, |freevars| {\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n                 ensure_free_variable_types_outlive_closure_bound(\n                     rcx, bounds.region_bound, expr, freevars);\n             });\n         }\n         ty::ty_unboxed_closure(_, region) => {\n-            freevars::with_freevars(tcx, expr.id, |freevars| {\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n                 // No free variables means that there is no environment and\n                 // hence the closure has static lifetime. Otherwise, the\n                 // closure must not outlive the variables it closes over\n@@ -906,7 +906,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                 store: ty::RegionTraitStore(..),\n                 ..\n             }) => {\n-            freevars::with_freevars(tcx, expr.id, |freevars| {\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n                 propagate_upupvar_borrow_kind(rcx, expr, freevars);\n             })\n         }\n@@ -917,7 +917,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         rcx: &mut Rcx,\n         region_bound: ty::Region,\n         expr: &ast::Expr,\n-        freevars: &[freevars::freevar_entry])\n+        freevars: &[ty::Freevar])\n     {\n         /*!\n          * Make sure that the type of all free variables referenced\n@@ -950,7 +950,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         rcx: &mut Rcx,\n         region_bound: ty::Region,\n         expr: &ast::Expr,\n-        freevars: &[freevars::freevar_entry])\n+        freevars: &[ty::Freevar])\n     {\n         /*!\n          * Make sure that all free variables referenced inside the\n@@ -1000,7 +1000,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n     fn propagate_upupvar_borrow_kind(rcx: &mut Rcx,\n                                      expr: &ast::Expr,\n-                                     freevars: &[freevars::freevar_entry]) {\n+                                     freevars: &[ty::Freevar]) {\n         let tcx = rcx.fcx.ccx.tcx;\n         debug!(\"propagate_upupvar_borrow_kind({})\", expr.repr(tcx));\n         for freevar in freevars.iter() {"}]}