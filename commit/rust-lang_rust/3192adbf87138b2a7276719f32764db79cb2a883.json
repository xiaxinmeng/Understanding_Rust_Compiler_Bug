{"sha": "3192adbf87138b2a7276719f32764db79cb2a883", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxOTJhZGJmODcxMzhiMmE3Mjc2NzE5ZjMyNzY0ZGI3OWNiMmE4ODM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-21T00:15:00Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-21T23:01:02Z"}, "message": "Refactor out `mac_result` in `expand_mac_invoc`", "tree": {"sha": "9162f96e44250cdcb47c2456c831917f55b72e0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9162f96e44250cdcb47c2456c831917f55b72e0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3192adbf87138b2a7276719f32764db79cb2a883", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3192adbf87138b2a7276719f32764db79cb2a883", "html_url": "https://github.com/rust-lang/rust/commit/3192adbf87138b2a7276719f32764db79cb2a883", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3192adbf87138b2a7276719f32764db79cb2a883/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "215c1460f68a5c47f40ea173484cd791166ebc94", "url": "https://api.github.com/repos/rust-lang/rust/commits/215c1460f68a5c47f40ea173484cd791166ebc94", "html_url": "https://github.com/rust-lang/rust/commit/215c1460f68a5c47f40ea173484cd791166ebc94"}], "stats": {"total": 107, "additions": 53, "deletions": 54}, "files": [{"sha": "952d398e5bdde78925823576bdbabb07db3c2531", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 53, "deletions": 54, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/3192adbf87138b2a7276719f32764db79cb2a883/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3192adbf87138b2a7276719f32764db79cb2a883/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3192adbf87138b2a7276719f32764db79cb2a883", "patch": "@@ -201,83 +201,82 @@ fn expand_mac_invoc<T>(mac: ast::Mac, attrs: Vec<ast::Attribute>, span: Span,\n                        fld: &mut MacroExpander) -> T\n     where T: MacroGenerable,\n {\n-    check_attributes(&attrs, fld);\n-\n     // it would almost certainly be cleaner to pass the whole\n     // macro invocation in, rather than pulling it apart and\n     // marking the tts and the ctxt separately. This also goes\n     // for the other three macro invocation chunks of code\n     // in this file.\n \n-    let Mac_ { path: pth, tts, .. } = mac.node;\n-    if pth.segments.len() > 1 {\n-        fld.cx.span_err(pth.span,\n-                        \"expected macro name without module \\\n-                        separators\");\n-        // let compilation continue\n-        return T::dummy(span);\n-    }\n-    let extname = pth.segments[0].identifier.name;\n-    match fld.cx.syntax_env.find(extname) {\n-        None => {\n-            let mut err = fld.cx.struct_span_err(\n-                pth.span,\n-                &format!(\"macro undefined: '{}!'\",\n-                        &extname));\n+    let Mac_ { path, tts, .. } = mac.node;\n+    let mark = fresh_mark();\n+\n+    fn mac_result<'a>(path: &ast::Path, tts: Vec<TokenTree>, mark: Mrk,\n+                      attrs: Vec<ast::Attribute>, call_site: Span, fld: &'a mut MacroExpander)\n+                      -> Option<Box<MacResult + 'a>> {\n+        check_attributes(&attrs, fld);\n+\n+        if path.segments.len() > 1 {\n+            fld.cx.span_err(path.span, \"expected macro name without module separators\");\n+            return None;\n+        }\n+\n+        let extname = path.segments[0].identifier.name;\n+        let extension = if let Some(extension) = fld.cx.syntax_env.find(extname) {\n+            extension\n+        } else {\n+            let mut err = fld.cx.struct_span_err(path.span,\n+                                                 &format!(\"macro undefined: '{}!'\", &extname));\n             fld.cx.suggest_macro_name(&extname.as_str(), &mut err);\n             err.emit();\n+            return None;\n+        };\n \n-            // let compilation continue\n-            T::dummy(span)\n-        }\n-        Some(rc) => match *rc {\n+        match *extension {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n                 fld.cx.bt_push(ExpnInfo {\n-                        call_site: span,\n-                        callee: NameAndSpan {\n-                            format: MacroBang(extname),\n-                            span: exp_span,\n-                            allow_internal_unstable: allow_internal_unstable,\n-                        },\n-                    });\n-                let fm = fresh_mark();\n-                let marked_before = mark_tts(&tts[..], fm);\n+                    call_site: call_site,\n+                    callee: NameAndSpan {\n+                        format: MacroBang(extname),\n+                        span: exp_span,\n+                        allow_internal_unstable: allow_internal_unstable,\n+                    },\n+                });\n \n                 // The span that we pass to the expanders we want to\n                 // be the root of the call stack. That's the most\n                 // relevant span and it's the actual invocation of\n                 // the macro.\n                 let mac_span = fld.cx.original_span();\n \n-                let opt_parsed = {\n-                    let expanded = expandfun.expand(fld.cx,\n-                                                    mac_span,\n-                                                    &marked_before[..]);\n-                    T::make_with(expanded)\n-                };\n-                let parsed = match opt_parsed {\n-                    Some(e) => e,\n-                    None => {\n-                        let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n-                                          name = extname, kind = T::kind_name());\n-                        fld.cx.span_err(pth.span, &msg);\n-                        return T::dummy(span);\n-                    }\n-                };\n-                let marked = parsed.fold_with(&mut Marker { mark: fm });\n-                let fully_expanded = marked.fold_with(fld);\n-                fld.cx.bt_pop();\n-                fully_expanded\n+                let marked_tts = mark_tts(&tts[..], mark);\n+                Some(expandfun.expand(fld.cx, mac_span, &marked_tts))\n             }\n             _ => {\n-                fld.cx.span_err(\n-                    pth.span,\n-                    &format!(\"'{}' is not a tt-style macro\",\n-                            extname));\n-                T::dummy(span)\n+                fld.cx.span_err(path.span,\n+                                &format!(\"'{}' is not a tt-style macro\", extname));\n+                None\n             }\n         }\n     }\n+\n+    let opt_expanded = T::make_with(match mac_result(&path, tts, mark, attrs, span, fld) {\n+        Some(result) => result,\n+        None => return T::dummy(span),\n+    });\n+\n+    let expanded = if let Some(expanded) = opt_expanded {\n+        expanded\n+    } else {\n+        let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n+                          name = path.segments[0].identifier.name, kind = T::kind_name());\n+        fld.cx.span_err(path.span, &msg);\n+        return T::dummy(span);\n+    };\n+\n+    let marked = expanded.fold_with(&mut Marker { mark: mark });\n+    let fully_expanded = marked.fold_with(fld);\n+    fld.cx.bt_pop();\n+    fully_expanded\n }\n \n /// Rename loop label and expand its loop body"}]}