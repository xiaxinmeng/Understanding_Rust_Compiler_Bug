{"sha": "555a239301cabeb20e45c9c3c3cf98588b8ec916", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NWEyMzkzMDFjYWJlYjIwZTQ1YzljM2MzY2Y5ODU4OGI4ZWM5MTY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-09T13:20:44Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-17T07:53:07Z"}, "message": "De-@ CStore uses.", "tree": {"sha": "31c3c083034bca6cdc876420802969171672ba03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31c3c083034bca6cdc876420802969171672ba03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/555a239301cabeb20e45c9c3c3cf98588b8ec916", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/555a239301cabeb20e45c9c3c3cf98588b8ec916", "html_url": "https://github.com/rust-lang/rust/commit/555a239301cabeb20e45c9c3c3cf98588b8ec916", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/555a239301cabeb20e45c9c3c3cf98588b8ec916/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f77c74414256bf487bd9e912d668e3cf63127250", "url": "https://api.github.com/repos/rust-lang/rust/commits/f77c74414256bf487bd9e912d668e3cf63127250", "html_url": "https://github.com/rust-lang/rust/commit/f77c74414256bf487bd9e912d668e3cf63127250"}], "stats": {"total": 231, "additions": 109, "deletions": 122}, "files": [{"sha": "2e6b842f3f9dfb4399b3b2b587f6bf90f020a11d", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=555a239301cabeb20e45c9c3c3cf98588b8ec916", "patch": "@@ -1000,7 +1000,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n             }\n         };\n         a.add_rlib(&p, name, sess.lto()).unwrap();\n-        let native_libs = csearch::get_native_libraries(sess.cstore, cnum);\n+        let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         for &(kind, ref lib) in native_libs.iter() {\n             let name = match kind {\n                 cstore::NativeStatic => \"static library\",\n@@ -1302,8 +1302,8 @@ fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n     // * If one form of linking fails, the second is also attempted\n     // * If both forms fail, then we emit an error message\n \n-    let dynamic = get_deps(sess.cstore, cstore::RequireDynamic);\n-    let statik = get_deps(sess.cstore, cstore::RequireStatic);\n+    let dynamic = get_deps(&sess.cstore, cstore::RequireDynamic);\n+    let statik = get_deps(&sess.cstore, cstore::RequireStatic);\n     match (dynamic, statik, sess.opts.cg.prefer_dynamic, dylib) {\n         (_, Some(deps), false, false) => {\n             add_static_crates(args, sess, tmpdir, deps)\n@@ -1459,7 +1459,7 @@ fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n fn add_upstream_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n-    let cstore = sess.cstore;\n+    let cstore = &sess.cstore;\n     cstore.iter_crate_data(|cnum, _| {\n         let libs = csearch::get_native_libraries(cstore, cnum);\n         for &(kind, ref lib) in libs.iter() {"}, {"sha": "dee0cf23ec7f7963c7eb1034847d5c6b78ca961f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=555a239301cabeb20e45c9c3c3cf98588b8ec916", "patch": "@@ -1004,7 +1004,6 @@ pub fn build_session_(sopts: @session::Options,\n                       -> Session {\n     let target_cfg = build_target_config(sopts);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler, codemap);\n-    let cstore = @CStore::new(token::get_ident_interner());\n     let default_sysroot = match sopts.maybe_sysroot {\n         Some(_) => None,\n         None => Some(filesearch::get_or_default_sysroot())\n@@ -1022,7 +1021,7 @@ pub fn build_session_(sopts: @session::Options,\n     Session {\n         targ_cfg: target_cfg,\n         opts: sopts,\n-        cstore: cstore,\n+        cstore: CStore::new(token::get_ident_interner()),\n         parse_sess: p_s,\n         codemap: codemap,\n         // For a library crate, this is always none"}, {"sha": "5cdfe3691c7212baacd1c82ead3e01ba9e8f52c0", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=555a239301cabeb20e45c9c3c3cf98588b8ec916", "patch": "@@ -176,7 +176,7 @@ pub enum CrateType {\n pub struct Session {\n     targ_cfg: @Config,\n     opts: @Options,\n-    cstore: @metadata::cstore::CStore,\n+    cstore: metadata::cstore::CStore,\n     parse_sess: @ParseSess,\n     codemap: @codemap::CodeMap,\n     // For a library crate, this is always none"}, {"sha": "359f28f2ad177044da7bd65ea9cbbe155b3b0161", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=555a239301cabeb20e45c9c3c3cf98588b8ec916", "patch": "@@ -120,12 +120,10 @@ struct Env<'a> {\n }\n \n fn visit_crate(e: &Env, c: &ast::Crate) {\n-    let cstore = e.sess.cstore;\n-\n     for a in c.attrs.iter().filter(|m| m.name().equiv(&(\"link_args\"))) {\n         match a.value_str() {\n-          Some(ref linkarg) => cstore.add_used_link_args(linkarg.get()),\n-          None => { /* fallthrough */ }\n+            Some(ref linkarg) => e.sess.cstore.add_used_link_args(linkarg.get()),\n+            None => { /* fallthrough */ }\n         }\n     }\n }\n@@ -195,7 +193,6 @@ fn visit_item(e: &Env, i: &ast::Item) {\n             }\n \n             // First, add all of the custom link_args attributes\n-            let cstore = e.sess.cstore;\n             let link_args = i.attrs.iter()\n                 .filter_map(|at| if at.name().equiv(&(\"link_args\")) {\n                     Some(at)\n@@ -205,13 +202,12 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                 .to_owned_vec();\n             for m in link_args.iter() {\n                 match m.value_str() {\n-                    Some(linkarg) => cstore.add_used_link_args(linkarg.get()),\n+                    Some(linkarg) => e.sess.cstore.add_used_link_args(linkarg.get()),\n                     None => { /* fallthrough */ }\n                 }\n             }\n \n             // Next, process all of the #[link(..)]-style arguments\n-            let cstore = e.sess.cstore;\n             let link_args = i.attrs.iter()\n                 .filter_map(|at| if at.name().equiv(&(\"link\")) {\n                     Some(at)\n@@ -260,7 +256,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                         if n.get().is_empty() {\n                             e.sess.span_err(m.span, \"#[link(name = \\\"\\\")] given with empty name\");\n                         } else {\n-                            cstore.add_used_library(n.get().to_owned(), kind);\n+                            e.sess.cstore.add_used_library(n.get().to_owned(), kind);\n                         }\n                     }\n                     None => {}\n@@ -344,18 +340,15 @@ fn resolve_crate(e: &mut Env,\n                 cnum: cnum\n             };\n \n-            let cstore = e.sess.cstore;\n-            cstore.set_crate_data(cnum, cmeta);\n-            cstore.add_used_crate_source(cstore::CrateSource {\n+            e.sess.cstore.set_crate_data(cnum, cmeta);\n+            e.sess.cstore.add_used_crate_source(cstore::CrateSource {\n                 dylib: dylib,\n                 rlib: rlib,\n                 cnum: cnum,\n             });\n-            return cnum;\n-        }\n-        Some(cnum) => {\n-            return cnum;\n+            cnum\n         }\n+        Some(cnum) => cnum\n     }\n }\n \n@@ -415,12 +408,12 @@ impl<'a> CrateLoader for Loader<'a> {\n     }\n \n     fn get_exported_macros(&mut self, cnum: ast::CrateNum) -> Vec<~str> {\n-        csearch::get_exported_macros(self.env.sess.cstore, cnum).move_iter()\n-                                                                .collect()\n+        csearch::get_exported_macros(&self.env.sess.cstore, cnum).move_iter()\n+                                                                 .collect()\n     }\n \n     fn get_registrar_symbol(&mut self, cnum: ast::CrateNum) -> Option<~str> {\n-        let cstore = self.env.sess.cstore;\n+        let cstore = &self.env.sess.cstore;\n         csearch::get_macro_registrar_fn(cstore, cnum)\n             .map(|did| csearch::get_symbol(cstore, did))\n     }"}, {"sha": "95c85a04b19e55e36365aa51463b1a6d6c18d97a", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=555a239301cabeb20e45c9c3c3cf98588b8ec916", "patch": "@@ -34,19 +34,19 @@ pub struct StaticMethodInfo {\n     vis: ast::Visibility,\n }\n \n-pub fn get_symbol(cstore: @cstore::CStore, def: ast::DefId) -> ~str {\n+pub fn get_symbol(cstore: &cstore::CStore, def: ast::DefId) -> ~str {\n     let cdata = cstore.get_crate_data(def.krate).data();\n     return decoder::get_symbol(cdata, def.node);\n }\n \n-pub fn get_type_param_count(cstore: @cstore::CStore, def: ast::DefId)\n+pub fn get_type_param_count(cstore: &cstore::CStore, def: ast::DefId)\n                          -> uint {\n     let cdata = cstore.get_crate_data(def.krate).data();\n     return decoder::get_type_param_count(cdata, def.node);\n }\n \n /// Iterates over all the language items in the given crate.\n-pub fn each_lang_item(cstore: @cstore::CStore,\n+pub fn each_lang_item(cstore: &cstore::CStore,\n                       cnum: ast::CrateNum,\n                       f: |ast::NodeId, uint| -> bool)\n                       -> bool {\n@@ -55,7 +55,7 @@ pub fn each_lang_item(cstore: @cstore::CStore,\n }\n \n /// Iterates over each child of the given item.\n-pub fn each_child_of_item(cstore: @cstore::CStore,\n+pub fn each_child_of_item(cstore: &cstore::CStore,\n                           def_id: ast::DefId,\n                           callback: |decoder::DefLike,\n                                      ast::Ident,\n@@ -72,7 +72,7 @@ pub fn each_child_of_item(cstore: @cstore::CStore,\n }\n \n /// Iterates over each top-level crate item.\n-pub fn each_top_level_item_of_crate(cstore: @cstore::CStore,\n+pub fn each_top_level_item_of_crate(cstore: &cstore::CStore,\n                                     cnum: ast::CrateNum,\n                                     callback: |decoder::DefLike,\n                                                ast::Ident,\n@@ -88,7 +88,7 @@ pub fn each_top_level_item_of_crate(cstore: @cstore::CStore,\n }\n \n pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem> {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     let path = decoder::get_item_path(cdata, def.node);\n \n@@ -110,45 +110,45 @@ pub enum found_ast {\n pub fn maybe_get_item_ast(tcx: &ty::ctxt, def: ast::DefId,\n                           decode_inlined_item: decoder::DecodeInlinedItem)\n                        -> found_ast {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::maybe_get_item_ast(cdata, tcx, def.node, decode_inlined_item)\n }\n \n pub fn get_enum_variants(tcx: &ty::ctxt, def: ast::DefId)\n                       -> Vec<@ty::VariantInfo> {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n }\n \n /// Returns information about the given implementation.\n pub fn get_impl(tcx: &ty::ctxt, impl_def_id: ast::DefId)\n                 -> ty::Impl {\n-    let cdata = tcx.cstore.get_crate_data(impl_def_id.krate);\n-    decoder::get_impl(tcx.cstore.intr, cdata, impl_def_id.node, tcx)\n+    let cdata = tcx.sess.cstore.get_crate_data(impl_def_id.krate);\n+    decoder::get_impl(tcx.sess.cstore.intr, cdata, impl_def_id.node, tcx)\n }\n \n pub fn get_method(tcx: &ty::ctxt, def: ast::DefId) -> ty::Method {\n-    let cdata = tcx.cstore.get_crate_data(def.krate);\n-    decoder::get_method(tcx.cstore.intr, cdata, def.node, tcx)\n+    let cdata = tcx.sess.cstore.get_crate_data(def.krate);\n+    decoder::get_method(tcx.sess.cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_method_name_and_explicit_self(cstore: @cstore::CStore,\n+pub fn get_method_name_and_explicit_self(cstore: &cstore::CStore,\n                                          def: ast::DefId)\n                                      -> (ast::Ident, ast::ExplicitSelf_)\n {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_method_name_and_explicit_self(cstore.intr, cdata, def.node)\n }\n \n-pub fn get_trait_method_def_ids(cstore: @cstore::CStore,\n+pub fn get_trait_method_def_ids(cstore: &cstore::CStore,\n                                 def: ast::DefId) -> Vec<ast::DefId> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_method_def_ids(cdata, def.node)\n }\n \n-pub fn get_item_variances(cstore: @cstore::CStore,\n+pub fn get_item_variances(cstore: &cstore::CStore,\n                           def: ast::DefId) -> ty::ItemVariances {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_item_variances(cdata, def.node)\n@@ -157,38 +157,38 @@ pub fn get_item_variances(cstore: @cstore::CStore,\n pub fn get_provided_trait_methods(tcx: &ty::ctxt,\n                                   def: ast::DefId)\n                                -> Vec<@ty::Method> {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n pub fn get_supertraits(tcx: &ty::ctxt, def: ast::DefId) -> Vec<@ty::TraitRef> {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_supertraits(cdata, def.node, tcx)\n }\n \n-pub fn get_type_name_if_impl(cstore: @cstore::CStore, def: ast::DefId)\n+pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: ast::DefId)\n                           -> Option<ast::Ident> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type_name_if_impl(cdata, def.node)\n }\n \n-pub fn get_static_methods_if_impl(cstore: @cstore::CStore,\n+pub fn get_static_methods_if_impl(cstore: &cstore::CStore,\n                                   def: ast::DefId)\n                                -> Option<Vec<StaticMethodInfo> > {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_static_methods_if_impl(cstore.intr, cdata, def.node)\n }\n \n-pub fn get_item_attrs(cstore: @cstore::CStore,\n+pub fn get_item_attrs(cstore: &cstore::CStore,\n                       def_id: ast::DefId,\n                       f: |Vec<@ast::MetaItem> |) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }\n \n-pub fn get_struct_fields(cstore: @cstore::CStore,\n+pub fn get_struct_fields(cstore: &cstore::CStore,\n                          def: ast::DefId)\n                       -> Vec<ty::field_ty> {\n     let cdata = cstore.get_crate_data(def.krate);\n@@ -198,20 +198,20 @@ pub fn get_struct_fields(cstore: @cstore::CStore,\n pub fn get_type(tcx: &ty::ctxt,\n                 def: ast::DefId)\n              -> ty::ty_param_bounds_and_ty {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n pub fn get_trait_def(tcx: &ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_def(cdata, def.node, tcx)\n }\n \n pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n                       def: ast::DefId) -> ty::ty_param_bounds_and_ty {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(class_id.krate);\n     let all_items = reader::get_doc(reader::Doc(cdata.data()), tag_items);\n     let class_doc = expect(tcx.diag,\n@@ -234,56 +234,56 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n // if there is one.\n pub fn get_impl_trait(tcx: &ty::ctxt,\n                       def: ast::DefId) -> Option<@ty::TraitRef> {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_trait(cdata, def.node, tcx)\n }\n \n // Given a def_id for an impl, return information about its vtables\n pub fn get_impl_vtables(tcx: &ty::ctxt,\n                         def: ast::DefId) -> typeck::impl_res {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_vtables(cdata, def.node, tcx)\n }\n \n-pub fn get_impl_method(cstore: @cstore::CStore,\n+pub fn get_impl_method(cstore: &cstore::CStore,\n                        def: ast::DefId,\n                        mname: ast::Ident)\n                     -> Option<ast::DefId> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_method(cstore.intr, cdata, def.node, mname)\n }\n \n-pub fn get_item_visibility(cstore: @cstore::CStore,\n+pub fn get_item_visibility(cstore: &cstore::CStore,\n                            def_id: ast::DefId)\n                         -> ast::Visibility {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_visibility(cdata, def_id.node)\n }\n \n-pub fn get_native_libraries(cstore: @cstore::CStore,\n+pub fn get_native_libraries(cstore: &cstore::CStore,\n                             crate_num: ast::CrateNum)\n                                 -> Vec<(cstore::NativeLibaryKind, ~str)> {\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::get_native_libraries(cdata)\n }\n \n-pub fn each_impl(cstore: @cstore::CStore,\n+pub fn each_impl(cstore: &cstore::CStore,\n                  crate_num: ast::CrateNum,\n                  callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::each_impl(cdata, callback)\n }\n \n-pub fn each_implementation_for_type(cstore: @cstore::CStore,\n+pub fn each_implementation_for_type(cstore: &cstore::CStore,\n                                     def_id: ast::DefId,\n                                     callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::each_implementation_for_type(cdata, def_id.node, callback)\n }\n \n-pub fn each_implementation_for_trait(cstore: @cstore::CStore,\n+pub fn each_implementation_for_trait(cstore: &cstore::CStore,\n                                      def_id: ast::DefId,\n                                      callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n@@ -293,22 +293,22 @@ pub fn each_implementation_for_trait(cstore: @cstore::CStore,\n /// If the given def ID describes a method belonging to a trait (either a\n /// default method or an implementation of a trait method), returns the ID of\n /// the trait that the method belongs to. Otherwise, returns `None`.\n-pub fn get_trait_of_method(cstore: @cstore::CStore,\n+pub fn get_trait_of_method(cstore: &cstore::CStore,\n                            def_id: ast::DefId,\n                            tcx: &ty::ctxt)\n                            -> Option<ast::DefId> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_trait_of_method(cdata, def_id.node, tcx)\n }\n \n-pub fn get_macro_registrar_fn(cstore: @cstore::CStore,\n+pub fn get_macro_registrar_fn(cstore: &cstore::CStore,\n                               crate_num: ast::CrateNum)\n                               -> Option<ast::DefId> {\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::get_macro_registrar_fn(cdata)\n }\n \n-pub fn get_exported_macros(cstore: @cstore::CStore,\n+pub fn get_exported_macros(cstore: &cstore::CStore,\n                            crate_num: ast::CrateNum)\n                            -> Vec<~str> {\n     let cdata = cstore.get_crate_data(crate_num);"}, {"sha": "a1ee7d39ed7e61e2d8c09900c6977350ee18b056", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=555a239301cabeb20e45c9c3c3cf98588b8ec916", "patch": "@@ -74,7 +74,7 @@ pub struct EncodeParams<'a> {\n     item_symbols: &'a RefCell<NodeMap<~str>>,\n     non_inlineable_statics: &'a RefCell<NodeSet>,\n     link_meta: &'a LinkMeta,\n-    cstore: @cstore::CStore,\n+    cstore: &'a cstore::CStore,\n     encode_inlined_item: EncodeInlinedItem<'a>,\n }\n "}, {"sha": "2ce34a31129ecc512e82547b75efe8331825aa17", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=555a239301cabeb20e45c9c3c3cf98588b8ec916", "patch": "@@ -165,7 +165,7 @@ impl<'a> LanguageItemCollector<'a> {\n     }\n \n     pub fn collect_external_language_items(&mut self) {\n-        let crate_store = self.session.cstore;\n+        let crate_store = &self.session.cstore;\n         crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n             each_lang_item(crate_store, crate_number, |node_id, item_index| {\n                 let def_id = ast::DefId { krate: crate_number, node: node_id };"}, {"sha": "6ea26a9c5aab3ca7ab1320dc64de0b1d22a4783c", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=555a239301cabeb20e45c9c3c3cf98588b8ec916", "patch": "@@ -1100,7 +1100,7 @@ fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n                     _ => {}\n                 }\n             } else {\n-                csearch::get_item_attrs(cx.tcx.sess.cstore, did, |attrs| {\n+                csearch::get_item_attrs(&cx.tcx.sess.cstore, did, |attrs| {\n                     if attr::contains_name(attrs.as_slice(), \"must_use\") {\n                         cx.span_lint(UnusedMustUse, s.span,\n                                      \"unused result which must be used\");\n@@ -1562,7 +1562,7 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n         let mut s = None;\n         // run through all the attributes and take the first\n         // stability one.\n-        csearch::get_item_attrs(cx.tcx.cstore, id, |meta_items| {\n+        csearch::get_item_attrs(&cx.tcx.sess.cstore, id, |meta_items| {\n             if s.is_none() {\n                 s = attr::find_stability(meta_items.move_iter())\n             }"}, {"sha": "1de38d8a461e4a2e5e6513ab9af0409d4cd70caa", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=555a239301cabeb20e45c9c3c3cf98588b8ec916", "patch": "@@ -585,7 +585,7 @@ impl<'a> PrivacyVisitor<'a> {\n                 }\n             }\n         } else {\n-            let cstore = self.tcx.sess.cstore;\n+            let cstore = &self.tcx.sess.cstore;\n             match enum_id {\n                 Some(enum_id) => {\n                     let v = csearch::get_enum_variants(self.tcx, enum_id);"}, {"sha": "bea776eb20928659a8f0ade6a447fee34812558f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=555a239301cabeb20e45c9c3c3cf98588b8ec916", "patch": "@@ -1690,11 +1690,11 @@ impl<'a> Resolver<'a> {\n               // to the trait info.\n \n               let method_def_ids =\n-                csearch::get_trait_method_def_ids(self.session.cstore, def_id);\n+                csearch::get_trait_method_def_ids(&self.session.cstore, def_id);\n               let mut interned_method_names = HashSet::new();\n               for &method_def_id in method_def_ids.iter() {\n                   let (method_name, explicit_self) =\n-                      csearch::get_method_name_and_explicit_self(self.session.cstore,\n+                      csearch::get_method_name_and_explicit_self(&self.session.cstore,\n                                                                  method_def_id);\n \n                   debug!(\"(building reduced graph for \\\n@@ -1743,7 +1743,7 @@ impl<'a> Resolver<'a> {\n                     crate) building type and value for {}\",\n                    final_ident);\n             child_name_bindings.define_type(def, DUMMY_SP, is_public);\n-            if csearch::get_struct_fields(self.session.cstore, def_id).len() == 0 {\n+            if csearch::get_struct_fields(&self.session.cstore, def_id).len() == 0 {\n                 child_name_bindings.define_value(def, DUMMY_SP, is_public);\n             }\n             self.structs.insert(def_id);\n@@ -1775,7 +1775,7 @@ impl<'a> Resolver<'a> {\n                     DefForeignMod(def_id) => {\n                         // Foreign modules have no names. Recur and populate\n                         // eagerly.\n-                        csearch::each_child_of_item(self.session.cstore,\n+                        csearch::each_child_of_item(&self.session.cstore,\n                                                     def_id,\n                                                     |def_like,\n                                                      child_ident,\n@@ -1805,11 +1805,11 @@ impl<'a> Resolver<'a> {\n             }\n             DlImpl(def) => {\n                 // We only process static methods of impls here.\n-                match csearch::get_type_name_if_impl(self.session.cstore, def) {\n+                match csearch::get_type_name_if_impl(&self.session.cstore, def) {\n                     None => {}\n                     Some(final_ident) => {\n                         let static_methods_opt =\n-                            csearch::get_static_methods_if_impl(self.session.cstore, def);\n+                            csearch::get_static_methods_if_impl(&self.session.cstore, def);\n                         match static_methods_opt {\n                             Some(ref static_methods) if\n                                 static_methods.len() >= 1 => {\n@@ -1910,7 +1910,7 @@ impl<'a> Resolver<'a> {\n             Some(def_id) => def_id,\n         };\n \n-        csearch::each_child_of_item(self.session.cstore,\n+        csearch::each_child_of_item(&self.session.cstore,\n                                     def_id,\n                                     |def_like, child_ident, visibility| {\n             debug!(\"(populating external module) ... found ident: {}\",\n@@ -1936,7 +1936,7 @@ impl<'a> Resolver<'a> {\n     /// crate.\n     fn build_reduced_graph_for_external_crate(&mut self,\n                                               root: @Module) {\n-        csearch::each_top_level_item_of_crate(self.session.cstore,\n+        csearch::each_top_level_item_of_crate(&self.session.cstore,\n                                               root.def_id\n                                                   .get()\n                                                   .unwrap()"}, {"sha": "56ceb867735da7f84590bfee93214325e0a55910", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=555a239301cabeb20e45c9c3c3cf98588b8ec916", "patch": "@@ -246,7 +246,7 @@ fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n     }\n \n     let f = decl_rust_fn(ccx, false, inputs, output, name);\n-    csearch::get_item_attrs(ccx.tcx.cstore, did, |meta_items| {\n+    csearch::get_item_attrs(&ccx.sess().cstore, did, |meta_items| {\n         set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr(x)).to_owned_vec(), f)\n     });\n \n@@ -555,7 +555,7 @@ pub fn get_res_dtor(ccx: &CrateContext,\n         get_item_val(ccx, did.node)\n     } else {\n         let tcx = ccx.tcx;\n-        let name = csearch::get_symbol(ccx.sess().cstore, did);\n+        let name = csearch::get_symbol(&ccx.sess().cstore, did);\n         let class_ty = ty::subst_tps(tcx,\n                                      substs,\n                                      None,\n@@ -874,7 +874,7 @@ pub fn fail_if_zero<'a>(\n }\n \n pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> ValueRef {\n-    let name = csearch::get_symbol(ccx.sess().cstore, did);\n+    let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             match fn_ty.abis.for_target(ccx.sess().targ_cfg.os,\n@@ -1966,7 +1966,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                 match external_srcs.get().find(&i.id) {\n                                     Some(&did) => {\n                                         debug!(\"but found in other crate...\");\n-                                        (csearch::get_symbol(ccx.sess().cstore,\n+                                        (csearch::get_symbol(&ccx.sess().cstore,\n                                                              did), false)\n                                     }\n                                     None => (sym, true)\n@@ -2394,7 +2394,7 @@ pub fn decl_crate_map(sess: &Session, mapmeta: LinkMeta,\n     let targ_cfg = sess.targ_cfg;\n     let int_type = Type::int(targ_cfg.arch);\n     let mut n_subcrates = 1;\n-    let cstore = sess.cstore;\n+    let cstore = &sess.cstore;\n     while cstore.have_crate_data(n_subcrates) { n_subcrates += 1; }\n     let is_top = !sess.building_library.get() || sess.opts.cg.gen_crate_map;\n     let sym_name = if is_top {\n@@ -2432,7 +2432,7 @@ pub fn fill_crate_map(ccx: &CrateContext, map: ValueRef) {\n                 llvm::LLVMConstPointerCast(get_item_val(ccx, did.node),\n                                            ccx.int_type.ptr_to().to_ref())\n             } else {\n-                let name = csearch::get_symbol(ccx.sess().cstore, did);\n+                let name = csearch::get_symbol(&ccx.sess().cstore, did);\n                 let global = name.with_c_str(|buf| {\n                     llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n                 });\n@@ -2462,7 +2462,7 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeI\n             item_symbols: item_symbols,\n             non_inlineable_statics: &cx.non_inlineable_statics,\n             link_meta: link_meta,\n-            cstore: cx.sess().cstore,\n+            cstore: &cx.sess().cstore,\n             encode_inlined_item: ie,\n         }\n }"}, {"sha": "20385c971020bb9eee6c205e4e52c2bddb2afab3", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=555a239301cabeb20e45c9c3c3cf98588b8ec916", "patch": "@@ -581,7 +581,7 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n                     unsafe {\n                         let llty = type_of::type_of(bcx.ccx(), const_ty);\n                         let symbol = csearch::get_symbol(\n-                            bcx.ccx().sess().cstore,\n+                            &bcx.ccx().sess().cstore,\n                             did);\n                         let llval = symbol.with_c_str(|buf| {\n                                 llvm::LLVMAddGlobal(bcx.ccx().llmod,"}, {"sha": "aa92cf30498ca3dd1562e148206cb73044fff6da", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=555a239301cabeb20e45c9c3c3cf98588b8ec916", "patch": "@@ -13,7 +13,6 @@\n use back::svh::Svh;\n use driver::session::Session;\n use metadata::csearch;\n-use metadata;\n use middle::const_eval;\n use middle::lang_items::{ExchangeHeapLangItem, OpaqueStructLangItem};\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n@@ -259,7 +258,6 @@ pub struct ctxt {\n     // quite often.\n     interner: RefCell<FnvHashMap<intern_key, ~t_box_>>,\n     next_id: Cell<uint>,\n-    cstore: @metadata::cstore::CStore,\n     sess: Session,\n     def_map: resolve::DefMap,\n \n@@ -1093,7 +1091,6 @@ pub fn mk_ctxt(s: Session,\n         diag: s.diagnostic(),\n         interner: RefCell::new(FnvHashMap::new()),\n         next_id: Cell::new(primitives::LAST_PRIMITIVE_ID),\n-        cstore: s.cstore,\n         sess: s,\n         def_map: dm,\n         region_maps: region_maps,\n@@ -3806,7 +3803,7 @@ pub fn trait_method_def_ids(cx: &ctxt, id: ast::DefId) -> @Vec<DefId> {\n                                      id,\n                                      trait_method_def_ids.get(),\n                                      || {\n-        @csearch::get_trait_method_def_ids(cx.cstore, id)\n+        @csearch::get_trait_method_def_ids(&cx.sess.cstore, id)\n     })\n }\n \n@@ -4175,7 +4172,7 @@ pub fn each_attr(tcx: &ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n         item.attrs.iter().advance(|attr| f(attr.node.value))\n     } else {\n         let mut cont = true;\n-        csearch::get_item_attrs(tcx.cstore, did, |meta_items| {\n+        csearch::get_item_attrs(&tcx.sess.cstore, did, |meta_items| {\n             if cont {\n                 cont = meta_items.iter().advance(|ptrptr| f(*ptrptr));\n             }\n@@ -4246,38 +4243,36 @@ pub fn lookup_field_type(tcx: &ctxt,\n // Look up the list of field names and IDs for a given struct\n // Fails if the id is not bound to a struct.\n pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n-  if did.krate == ast::LOCAL_CRATE {\n-      {\n-          match cx.map.find(did.node) {\n-           Some(ast_map::NodeItem(i)) => {\n-             match i.node {\n-                ast::ItemStruct(struct_def, _) => {\n-                   struct_field_tys(struct_def.fields.as_slice())\n-                }\n-                _ => cx.sess.bug(\"struct ID bound to non-struct\")\n-             }\n-           }\n-           Some(ast_map::NodeVariant(ref variant)) => {\n-              match (*variant).node.kind {\n-                ast::StructVariantKind(struct_def) => {\n-                  struct_field_tys(struct_def.fields.as_slice())\n+    if did.krate == ast::LOCAL_CRATE {\n+        match cx.map.find(did.node) {\n+            Some(ast_map::NodeItem(i)) => {\n+                match i.node {\n+                    ast::ItemStruct(struct_def, _) => {\n+                        struct_field_tys(struct_def.fields.as_slice())\n+                    }\n+                    _ => cx.sess.bug(\"struct ID bound to non-struct\")\n                 }\n-                _ => {\n-                  cx.sess.bug(\"struct ID bound to enum variant that isn't \\\n-                               struct-like\")\n+            }\n+            Some(ast_map::NodeVariant(ref variant)) => {\n+                match (*variant).node.kind {\n+                    ast::StructVariantKind(struct_def) => {\n+                        struct_field_tys(struct_def.fields.as_slice())\n+                    }\n+                    _ => {\n+                        cx.sess.bug(\"struct ID bound to enum variant that \\\n+                                    isn't struct-like\")\n+                    }\n                 }\n-              }\n-           }\n-           _ => {\n-               cx.sess.bug(\n-                   format!(\"struct ID not bound to an item: {}\",\n+            }\n+            _ => {\n+                cx.sess.bug(\n+                    format!(\"struct ID not bound to an item: {}\",\n                         cx.map.node_to_str(did.node)));\n-           }\n-          }\n-      }\n-  } else {\n-    return csearch::get_struct_fields(cx.sess.cstore, did);\n-  }\n+            }\n+        }\n+    } else {\n+        csearch::get_struct_fields(&cx.sess.cstore, did)\n+    }\n }\n \n pub fn lookup_struct_field(cx: &ctxt,\n@@ -4650,7 +4645,7 @@ pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> @ItemVariances {\n     let mut item_variance_map = tcx.item_variance_map.borrow_mut();\n     lookup_locally_or_in_crate_store(\n         \"item_variance_map\", item_id, item_variance_map.get(),\n-        || @csearch::get_item_variances(tcx.cstore, item_id))\n+        || @csearch::get_item_variances(&tcx.sess.cstore, item_id))\n }\n \n /// Records a trait-to-implementation mapping.\n@@ -4687,7 +4682,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n         }\n     }\n \n-    csearch::each_implementation_for_type(tcx.sess.cstore, type_id,\n+    csearch::each_implementation_for_type(&tcx.sess.cstore, type_id,\n             |implementation_def_id| {\n         let implementation = @csearch::get_impl(tcx, implementation_def_id);\n \n@@ -4756,7 +4751,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n         }\n     }\n \n-    csearch::each_implementation_for_trait(tcx.sess.cstore, trait_id,\n+    csearch::each_implementation_for_trait(&tcx.sess.cstore, trait_id,\n             |implementation_def_id| {\n         let implementation = @csearch::get_impl(tcx, implementation_def_id);\n \n@@ -4810,7 +4805,7 @@ pub fn trait_id_of_impl(tcx: &ctxt,\n pub fn trait_of_method(tcx: &ctxt, def_id: ast::DefId)\n                        -> Option<ast::DefId> {\n     if def_id.krate != LOCAL_CRATE {\n-        return csearch::get_trait_of_method(tcx.cstore, def_id, tcx);\n+        return csearch::get_trait_of_method(&tcx.sess.cstore, def_id, tcx);\n     }\n     let method;\n     {"}, {"sha": "894c70c7b61194f2592a3cd1f55d5b63d7fe3ec8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555a239301cabeb20e45c9c3c3cf98588b8ec916/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=555a239301cabeb20e45c9c3c3cf98588b8ec916", "patch": "@@ -450,7 +450,7 @@ impl<'a> CoherenceChecker<'a> {\n                             session.span_note(self.span_of_impl(implementation_b),\n                                               \"note conflicting implementation here\");\n                         } else {\n-                            let crate_store = self.crate_context.tcx.sess.cstore;\n+                            let crate_store = &self.crate_context.tcx.sess.cstore;\n                             let cdata = crate_store.get_crate_data(implementation_b.did.krate);\n                             session.note(\n                                 \"conflicting implementation in crate `\" + cdata.name + \"`\");\n@@ -468,7 +468,7 @@ impl<'a> CoherenceChecker<'a> {\n             return;\n         }\n \n-        let crate_store = self.crate_context.tcx.sess.cstore;\n+        let crate_store = &self.crate_context.tcx.sess.cstore;\n         csearch::each_implementation_for_trait(crate_store, trait_def_id, |impl_def_id| {\n             let implementation = @csearch::get_impl(self.crate_context.tcx, impl_def_id);\n             let _ = lookup_item_type(self.crate_context.tcx, implementation.did);\n@@ -682,7 +682,7 @@ impl<'a> CoherenceChecker<'a> {\n     fn add_external_crates(&self) {\n         let mut impls_seen = HashSet::new();\n \n-        let crate_store = self.crate_context.tcx.sess.cstore;\n+        let crate_store = &self.crate_context.tcx.sess.cstore;\n         crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n             each_impl(crate_store, crate_number, |def_id| {\n                 assert_eq!(crate_number, def_id.krate);"}]}