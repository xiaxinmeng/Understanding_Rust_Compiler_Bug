{"sha": "39b9bea4bab5c9721fcd213e016ad666dbf0906b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5YjliZWE0YmFiNWM5NzIxZmNkMjEzZTAxNmFkNjY2ZGJmMDkwNmI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-06-05T23:06:14Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-06-08T09:29:22Z"}, "message": "Skip useless recursion in freshening and late-bound-region substitutio\n\nBefore:\n581.72user 4.75system 7:42.74elapsed 126%CPU (0avgtext+0avgdata 1176224maxresident)k\nllvm took 359.183\n\nAfter:\n550.63user 5.09system 7:20.28elapsed 126%CPU (0avgtext+0avgdata 1165516maxresident)k\nllvm took 354.801", "tree": {"sha": "f43064d6ec3f5e138c1e40e5b31c4398d6f18af2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f43064d6ec3f5e138c1e40e5b31c4398d6f18af2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39b9bea4bab5c9721fcd213e016ad666dbf0906b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39b9bea4bab5c9721fcd213e016ad666dbf0906b", "html_url": "https://github.com/rust-lang/rust/commit/39b9bea4bab5c9721fcd213e016ad666dbf0906b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39b9bea4bab5c9721fcd213e016ad666dbf0906b/comments", "author": null, "committer": null, "parents": [{"sha": "717e8831b6b81669f7d087a2a1d7f7e899bcea43", "url": "https://api.github.com/repos/rust-lang/rust/commits/717e8831b6b81669f7d087a2a1d7f7e899bcea43", "html_url": "https://github.com/rust-lang/rust/commit/717e8831b6b81669f7d087a2a1d7f7e899bcea43"}], "stats": {"total": 205, "additions": 129, "deletions": 76}, "files": [{"sha": "8783577945ce470ccb938b8c8fce61bf2b249135", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39b9bea4bab5c9721fcd213e016ad666dbf0906b/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b9bea4bab5c9721fcd213e016ad666dbf0906b/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=39b9bea4bab5c9721fcd213e016ad666dbf0906b", "patch": "@@ -104,6 +104,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        if !ty::type_needs_infer(t) && !ty::type_has_erasable_regions(t) {\n+            return t;\n+        }\n+\n         let tcx = self.infcx.tcx;\n \n         match t.sty {"}, {"sha": "7fd4a14b25b453c947a32fa4ebfb53a3b012acfd", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39b9bea4bab5c9721fcd213e016ad666dbf0906b/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b9bea4bab5c9721fcd213e016ad666dbf0906b/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=39b9bea4bab5c9721fcd213e016ad666dbf0906b", "patch": "@@ -530,7 +530,7 @@ pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n      * details.\n      */\n \n-    let (result, map) = ty::replace_late_bound_regions(infcx.tcx, binder, |br| {\n+    let (result, map) = ty_fold::replace_late_bound_regions(infcx.tcx, binder, |br| {\n         infcx.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n     });\n "}, {"sha": "b3c4dd68dbaf7675dda65770401534c11a85fa98", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/39b9bea4bab5c9721fcd213e016ad666dbf0906b/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b9bea4bab5c9721fcd213e016ad666dbf0906b/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=39b9bea4bab5c9721fcd213e016ad666dbf0906b", "patch": "@@ -26,9 +26,8 @@ use middle::free_region::FreeRegionMap;\n use middle::subst;\n use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, UnconstrainedNumeric};\n-use middle::ty::replace_late_bound_regions;\n use middle::ty::{self, Ty};\n-use middle::ty_fold::{TypeFolder, TypeFoldable};\n+use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{RefCell};\n@@ -1038,7 +1037,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n         where T : TypeFoldable<'tcx> + Repr<'tcx>\n     {\n-        ty::replace_late_bound_regions(\n+        ty_fold::replace_late_bound_regions(\n             self.tcx,\n             value,\n             |br| self.next_region_var(LateBoundRegion(span, br, lbrct)))"}, {"sha": "b5ef06f9a9ec4ca9a76f8bcc281038705b1ce4b7", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 31, "deletions": 70, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/39b9bea4bab5c9721fcd213e016ad666dbf0906b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b9bea4bab5c9721fcd213e016ad666dbf0906b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=39b9bea4bab5c9721fcd213e016ad666dbf0906b", "patch": "@@ -806,29 +806,31 @@ impl<'tcx> ctxt<'tcx> {\n // recursing over the type itself.\n bitflags! {\n     flags TypeFlags: u32 {\n-        const HAS_PARAMS        = 1 << 0,\n-        const HAS_SELF          = 1 << 1,\n-        const HAS_TY_INFER      = 1 << 2,\n-        const HAS_RE_INFER      = 1 << 3,\n-        const HAS_RE_LATE_BOUND = 1 << 4,\n-        const HAS_REGIONS       = 1 << 5,\n-        const HAS_TY_ERR        = 1 << 6,\n-        const HAS_PROJECTION    = 1 << 7,\n-        const HAS_TY_CLOSURE    = 1 << 8,\n-        const NEEDS_SUBST       = TypeFlags::HAS_PARAMS.bits |\n-                                  TypeFlags::HAS_SELF.bits |\n-                                  TypeFlags::HAS_REGIONS.bits,\n+        const HAS_PARAMS         = 1 << 0,\n+        const HAS_SELF           = 1 << 1,\n+        const HAS_TY_INFER       = 1 << 2,\n+        const HAS_RE_INFER       = 1 << 3,\n+        const HAS_RE_EARLY_BOUND = 1 << 4,\n+        const HAS_FREE_REGIONS   = 1 << 5,\n+        const HAS_TY_ERR         = 1 << 6,\n+        const HAS_PROJECTION     = 1 << 7,\n+        const HAS_TY_CLOSURE     = 1 << 8,\n+        const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n+                                   TypeFlags::HAS_SELF.bits |\n+                                   TypeFlags::HAS_RE_EARLY_BOUND.bits,\n \n         // Flags representing the nominal content of a type,\n-        // computed by FlagsComputetion\n+        // computed by FlagsComputation. If you add a new nominal\n+        // flag, it should be added here too.\n         const NOMINAL_FLAGS     = TypeFlags::HAS_PARAMS.bits |\n                                   TypeFlags::HAS_SELF.bits |\n                                   TypeFlags::HAS_TY_INFER.bits |\n                                   TypeFlags::HAS_RE_INFER.bits |\n-                                  TypeFlags::HAS_RE_LATE_BOUND.bits |\n-                                  TypeFlags::HAS_REGIONS.bits |\n+                                  TypeFlags::HAS_RE_EARLY_BOUND.bits |\n+                                  TypeFlags::HAS_FREE_REGIONS.bits |\n                                   TypeFlags::HAS_TY_ERR.bits |\n-                                  TypeFlags::HAS_PROJECTION.bits,\n+                                  TypeFlags::HAS_PROJECTION.bits |\n+                                  TypeFlags::HAS_TY_CLOSURE.bits,\n \n         // Caches for type_is_sized, type_moves_by_default\n         const SIZEDNESS_CACHED  = 1 << 16,\n@@ -990,8 +992,10 @@ pub fn type_has_ty_closure(ty: Ty) -> bool {\n     ty.flags.get().intersects(TypeFlags::HAS_TY_CLOSURE)\n }\n \n-pub fn type_has_late_bound_regions(ty: Ty) -> bool {\n-    ty.flags.get().intersects(TypeFlags::HAS_RE_LATE_BOUND)\n+pub fn type_has_erasable_regions(ty: Ty) -> bool {\n+    ty.flags.get().intersects(TypeFlags::HAS_RE_EARLY_BOUND |\n+                              TypeFlags::HAS_RE_INFER |\n+                              TypeFlags::HAS_FREE_REGIONS)\n }\n \n /// An \"escaping region\" is a bound region whose binder is not part of `t`.\n@@ -2987,7 +2991,7 @@ impl FlagComputation {\n                 for projection_bound in &bounds.projection_bounds {\n                     let mut proj_computation = FlagComputation::new();\n                     proj_computation.add_projection_predicate(&projection_bound.0);\n-                    computation.add_bound_computation(&proj_computation);\n+                    self.add_bound_computation(&proj_computation);\n                 }\n                 self.add_bound_computation(&computation);\n \n@@ -3041,14 +3045,12 @@ impl FlagComputation {\n     }\n \n     fn add_region(&mut self, r: Region) {\n-        self.add_flags(TypeFlags::HAS_REGIONS);\n         match r {\n             ty::ReInfer(_) => { self.add_flags(TypeFlags::HAS_RE_INFER); }\n-            ty::ReLateBound(debruijn, _) => {\n-                self.add_flags(TypeFlags::HAS_RE_LATE_BOUND);\n-                self.add_depth(debruijn.depth);\n-            }\n-            _ => { }\n+            ty::ReLateBound(debruijn, _) => { self.add_depth(debruijn.depth); }\n+            ty::ReEarlyBound(..) => { self.add_flags(TypeFlags::HAS_RE_EARLY_BOUND); }\n+            ty::ReStatic => {}\n+            _ => { self.add_flags(TypeFlags::HAS_FREE_REGIONS); }\n         }\n     }\n \n@@ -6994,7 +6996,7 @@ pub fn liberate_late_bound_regions<'tcx, T>(\n     -> T\n     where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n-    replace_late_bound_regions(\n+    ty_fold::replace_late_bound_regions(\n         tcx, value,\n         |br| ty::ReFree(ty::FreeRegion{scope: all_outlive_scope, bound_region: br})).0\n }\n@@ -7005,7 +7007,7 @@ pub fn count_late_bound_regions<'tcx, T>(\n     -> usize\n     where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n-    let (_, skol_map) = replace_late_bound_regions(tcx, value, |_| ty::ReStatic);\n+    let (_, skol_map) = ty_fold::replace_late_bound_regions(tcx, value, |_| ty::ReStatic);\n     skol_map.len()\n }\n \n@@ -7063,7 +7065,7 @@ pub fn erase_late_bound_regions<'tcx, T>(\n     -> T\n     where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n-    replace_late_bound_regions(tcx, value, |_| ty::ReStatic).0\n+    ty_fold::replace_late_bound_regions(tcx, value, |_| ty::ReStatic).0\n }\n \n /// Rewrite any late-bound regions so that they are anonymous.  Region numbers are\n@@ -7081,53 +7083,12 @@ pub fn anonymize_late_bound_regions<'tcx, T>(\n     where T : TypeFoldable<'tcx> + Repr<'tcx>,\n {\n     let mut counter = 0;\n-    ty::Binder(replace_late_bound_regions(tcx, sig, |_| {\n+    ty::Binder(ty_fold::replace_late_bound_regions(tcx, sig, |_| {\n         counter += 1;\n         ReLateBound(ty::DebruijnIndex::new(1), BrAnon(counter))\n     }).0)\n }\n \n-/// Replaces the late-bound-regions in `value` that are bound by `value`.\n-pub fn replace_late_bound_regions<'tcx, T, F>(\n-    tcx: &ty::ctxt<'tcx>,\n-    binder: &Binder<T>,\n-    mut mapf: F)\n-    -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>,\n-          F : FnMut(BoundRegion) -> ty::Region,\n-{\n-    debug!(\"replace_late_bound_regions({})\", binder.repr(tcx));\n-\n-    let mut map = FnvHashMap();\n-\n-    // Note: fold the field `0`, not the binder, so that late-bound\n-    // regions bound by `binder` are considered free.\n-    let value = ty_fold::fold_regions(tcx, &binder.0, |region, current_depth| {\n-        debug!(\"region={}\", region.repr(tcx));\n-        match region {\n-            ty::ReLateBound(debruijn, br) if debruijn.depth == current_depth => {\n-                let region = *map.entry(br).or_insert_with(|| mapf(br));\n-\n-                if let ty::ReLateBound(debruijn1, br) = region {\n-                    // If the callback returns a late-bound region,\n-                    // that region should always use depth 1. Then we\n-                    // adjust it to the correct depth.\n-                    assert_eq!(debruijn1.depth, 1);\n-                    ty::ReLateBound(debruijn, br)\n-                } else {\n-                    region\n-                }\n-            }\n-            _ => {\n-                region\n-            }\n-        }\n-    });\n-\n-    debug!(\"resulting map: {:?} value: {:?}\", map, value.repr(tcx));\n-    (value, map)\n-}\n-\n impl DebruijnIndex {\n     pub fn new(depth: u32) -> DebruijnIndex {\n         assert!(depth > 0);"}, {"sha": "884fc9571ce1f886854156516d815d09d1b91403", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/39b9bea4bab5c9721fcd213e016ad666dbf0906b/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b9bea4bab5c9721fcd213e016ad666dbf0906b/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=39b9bea4bab5c9721fcd213e016ad666dbf0906b", "patch": "@@ -42,6 +42,7 @@ use std::rc::Rc;\n use syntax::abi;\n use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n+use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -841,6 +842,86 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Late-bound region replacer\n+\n+// Replaces the escaping regions in a type.\n+\n+struct RegionReplacer<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    current_depth: u32,\n+    fld_r: &'a mut (FnMut(ty::BoundRegion) -> ty::Region + 'a),\n+    map: FnvHashMap<ty::BoundRegion, ty::Region>\n+}\n+\n+impl<'a, 'tcx> RegionReplacer<'a, 'tcx> {\n+    fn new<F>(tcx: &'a ty::ctxt<'tcx>, fld_r: &'a mut F) -> RegionReplacer<'a, 'tcx>\n+        where F : FnMut(ty::BoundRegion) -> ty::Region\n+    {\n+        RegionReplacer {\n+            tcx: tcx,\n+            current_depth: 1,\n+            fld_r: fld_r,\n+            map: FnvHashMap()\n+        }\n+    }\n+}\n+\n+pub fn replace_late_bound_regions<'tcx,T,F>(tcx: &ty::ctxt<'tcx>,\n+                                            value: &ty::Binder<T>,\n+                                            mut f: F)\n+                                            -> (T, FnvHashMap<ty::BoundRegion, ty::Region>)\n+    where F : FnMut(ty::BoundRegion) -> ty::Region,\n+          T : TypeFoldable<'tcx> + Repr<'tcx>,\n+{\n+    debug!(\"replace_late_bound_regions({})\", value.repr(tcx));\n+    let mut replacer = RegionReplacer::new(tcx, &mut f);\n+    let result = value.skip_binder().fold_with(&mut replacer);\n+    (result, replacer.map)\n+}\n+\n+impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n+{\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n+\n+    fn enter_region_binder(&mut self) {\n+        self.current_depth += 1;\n+    }\n+\n+    fn exit_region_binder(&mut self) {\n+        self.current_depth -= 1;\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        if !ty::type_escapes_depth(t, self.current_depth-1) {\n+            return t;\n+        }\n+\n+        super_fold_ty(self, t)\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        match r {\n+            ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n+                debug!(\"RegionReplacer.fold_region({}) folding region (current_depth={})\",\n+                       r.repr(self.tcx()), self.current_depth);\n+                let fld_r = &mut self.fld_r;\n+                let region = *self.map.entry(br).or_insert_with(|| fld_r(br));\n+                if let ty::ReLateBound(debruijn1, br) = region {\n+                    // If the callback returns a late-bound region,\n+                    // that region should always use depth 1. Then we\n+                    // adjust it to the correct depth.\n+                    assert_eq!(debruijn1.depth, 1);\n+                    ty::ReLateBound(debruijn, br)\n+                } else {\n+                    region\n+                }\n+            }\n+            r => r\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Region eraser\n //\n@@ -861,6 +942,14 @@ pub fn erase_regions<'tcx, T: TypeFoldable<'tcx>>(tcx: &ty::ctxt<'tcx>, t: T) ->\n impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        if !ty::type_has_erasable_regions(t) {\n+            return t;\n+        }\n+\n+        super_fold_ty(self, t)\n+    }\n+\n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         // because whether or not a region is bound affects subtyping,\n         // we can't erase the bound/free distinction, but we can"}, {"sha": "3532bcdb279a92379f0922335de0b681ee69b8e8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39b9bea4bab5c9721fcd213e016ad666dbf0906b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b9bea4bab5c9721fcd213e016ad666dbf0906b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=39b9bea4bab5c9721fcd213e016ad666dbf0906b", "patch": "@@ -24,7 +24,7 @@ use middle::ty::{ty_param, ty_ptr, ty_rptr, ty_tup};\n use middle::ty::ty_closure;\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n-use middle::ty_fold::TypeFoldable;\n+use middle::ty_fold::{self, TypeFoldable};\n \n use std::collections::HashMap;\n use std::collections::hash_state::HashState;\n@@ -1301,7 +1301,7 @@ impl<'tcx, T> UserString<'tcx> for ty::Binder<T>\n         // the output. We'll probably want to tweak this over time to\n         // decide just how much information to give.\n         let mut names = Vec::new();\n-        let (unbound_value, _) = ty::replace_late_bound_regions(tcx, self, |br| {\n+        let (unbound_value, _) = ty_fold::replace_late_bound_regions(tcx, self, |br| {\n             ty::ReLateBound(ty::DebruijnIndex::new(1), match br {\n                 ty::BrNamed(_, name) => {\n                     names.push(token::get_name(name));"}]}