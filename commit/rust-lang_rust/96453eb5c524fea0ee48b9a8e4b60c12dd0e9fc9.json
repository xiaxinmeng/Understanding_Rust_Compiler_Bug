{"sha": "96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NDUzZWI1YzUyNGZlYTBlZTQ4YjlhOGU0YjYwYzEyZGQwZTlmYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-12T20:34:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-12T20:34:29Z"}, "message": "auto merge of #7736 : thestinger/rust/doc, r=thestinger\n\n2b96408 r=sanxiyn\r\n\r\ndocuments conversion, size hints and double-ended iterators and adds\r\nmore of the traits to the prelude", "tree": {"sha": "d50a3ccbaca480e6ef0f526fc0591622c20c542d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d50a3ccbaca480e6ef0f526fc0591622c20c542d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "html_url": "https://github.com/rust-lang/rust/commit/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cc4e5145dc971c032eb106b7a6866b8aa274482", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cc4e5145dc971c032eb106b7a6866b8aa274482", "html_url": "https://github.com/rust-lang/rust/commit/5cc4e5145dc971c032eb106b7a6866b8aa274482"}, {"sha": "9b21bf45e9be7410f2370e5f178c46f3415b6765", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b21bf45e9be7410f2370e5f178c46f3415b6765", "html_url": "https://github.com/rust-lang/rust/commit/9b21bf45e9be7410f2370e5f178c46f3415b6765"}], "stats": {"total": 290, "additions": 214, "deletions": 76}, "files": [{"sha": "2146b76a4afbd13ee3d1801318db28c181e3afc4", "filename": "doc/tutorial-container.md", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/doc%2Ftutorial-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/doc%2Ftutorial-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-container.md?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -205,3 +205,104 @@ println(fmt!(\"last: %?\", it.next()));\n // the iterator is now fully consumed\n assert!(it.next().is_none());\n ~~~\n+\n+## Conversion\n+\n+Iterators offer generic conversion to containers with the `collect` adaptor:\n+\n+~~~\n+let xs = [0, 1, 1, 2, 3, 5, 8];\n+let ys = xs.rev_iter().skip(1).transform(|&x| x * 2).collect::<~[int]>();\n+assert_eq!(ys, ~[10, 6, 4, 2, 2, 0]);\n+~~~\n+\n+The method requires a type hint for the container type, if the surrounding code\n+does not provide sufficient information.\n+\n+Containers can provide conversion from iterators through `collect` by\n+implementing the `FromIterator` trait. For example, the implementation for\n+vectors is as follows:\n+\n+~~~\n+impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n+    pub fn from_iterator(iterator: &mut T) -> ~[A] {\n+        let (lower, _) = iterator.size_hint();\n+        let mut xs = with_capacity(lower);\n+        for iterator.advance |x| {\n+            xs.push(x);\n+        }\n+        xs\n+    }\n+}\n+~~~\n+\n+### Size hints\n+\n+The `Iterator` trait provides a `size_hint` default method, returning a lower\n+bound and optionally on upper bound on the length of the iterator:\n+\n+~~~\n+fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n+~~~\n+\n+The vector implementation of `FromIterator` from above uses the lower bound\n+to pre-allocate enough space to hold the minimum number of elements the\n+iterator will yield.\n+\n+The default implementation is always correct, but it should be overridden if\n+the iterator can provide better information.\n+\n+The `ZeroStream` from earlier can provide an exact lower and upper bound:\n+\n+~~~\n+/// A stream of N zeroes\n+struct ZeroStream {\n+    priv remaining: uint\n+}\n+\n+impl ZeroStream {\n+    fn new(n: uint) -> ZeroStream {\n+        ZeroStream { remaining: n }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.remaining, Some(self.remaining))\n+    }\n+}\n+\n+impl Iterator<int> for ZeroStream {\n+    fn next(&mut self) -> Option<int> {\n+        if self.remaining == 0 {\n+            None\n+        } else {\n+            self.remaining -= 1;\n+            Some(0)\n+        }\n+    }\n+}\n+~~~\n+\n+## Double-ended iterators\n+\n+The `DoubleEndedIterator` trait represents an iterator able to yield elements\n+from either end of a range. It inherits from the `Iterator` trait and extends\n+it with the `next_back` function.\n+\n+A `DoubleEndedIterator` can be flipped with the `invert` adaptor, returning\n+another `DoubleEndedIterator` with `next` and `next_back` exchanged.\n+\n+~~~\n+let xs = [1, 2, 3, 4, 5, 6];\n+let mut it = xs.iter();\n+println(fmt!(\"%?\", it.next())); // prints `Some(&1)`\n+println(fmt!(\"%?\", it.next())); // prints `Some(&2)`\n+println(fmt!(\"%?\", it.next_back())); // prints `Some(&6)`\n+\n+// prints `5`, `4` and `3`\n+for it.invert().advance |&x| {\n+    println(fmt!(\"%?\", x))\n+}\n+~~~\n+\n+The `rev_iter` and `mut_rev_iter` methods on vectors just return an inverted\n+version of the standard immutable and mutable vector iterators."}, {"sha": "7a0db7a1de7fdb51b2d9946a36fdc59bbf50b817", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -104,7 +104,7 @@ impl SmallBitv {\n     }\n \n     #[inline]\n-    pub fn invert(&mut self) { self.bits = !self.bits; }\n+    pub fn negate(&mut self) { self.bits = !self.bits; }\n }\n \n struct BigBitv {\n@@ -160,7 +160,7 @@ impl BigBitv {\n     }\n \n     #[inline]\n-    pub fn invert(&mut self) { for self.each_storage |w| { *w = !*w } }\n+    pub fn negate(&mut self) { for self.each_storage |w| { *w = !*w } }\n \n     #[inline]\n     pub fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n@@ -366,9 +366,9 @@ impl Bitv {\n \n     /// Invert all bits\n     #[inline]\n-    pub fn invert(&mut self) {\n+    pub fn negate(&mut self) {\n       match self.rep {\n-        Small(ref mut b) => b.invert(),\n+        Small(ref mut b) => b.negate(),\n         Big(ref mut s) => for s.each_storage() |w| { *w = !*w } }\n     }\n "}, {"sha": "9ce7362ef71e5d5cdea8c7844f645599cb5a4c3b", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -446,7 +446,7 @@ pub mod flatteners {\n                               T: Decodable<D>>(\n                               buf: &[u8])\n                               -> T {\n-        let buf = vec::to_owned(buf);\n+        let buf = buf.to_owned();\n         let buf_reader = @BufReader::new(buf);\n         let reader = buf_reader as @Reader;\n         let mut deser: D = FromReader::from_reader(reader);"}, {"sha": "f8119143c61564cd9bf5e72a028d3449d7e0d28a", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -343,7 +343,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n         }\n         i += 1;\n     }\n-    return Ok(Matches {opts: vec::to_owned(opts),\n+    return Ok(Matches {opts: opts.to_owned(),\n                vals: vals,\n                free: free});\n }"}, {"sha": "2c60be4451974f06ea8bbd1da25979b55ca45d6b", "filename": "src/libextra/md4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibextra%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibextra%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fmd4.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -28,7 +28,7 @@ pub fn md4(msg: &[u8]) -> Quad {\n     let orig_len: u64 = (msg.len() * 8u) as u64;\n \n     // pad message\n-    let mut msg = vec::append(vec::to_owned(msg), [0x80u8]);\n+    let mut msg = vec::append(msg.to_owned(), [0x80u8]);\n     let mut bitlen = orig_len + 8u64;\n     while (bitlen + 64u64) % 512u64 > 0u64 {\n         msg.push(0u8);"}, {"sha": "4bc77f313df41dae8467380be9efdbccbf8d91d8", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -567,7 +567,7 @@ impl BigUint {\n     /// Creates and initializes an BigUint.\n \n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n-        return BigUint::new(vec::to_owned(slice));\n+        return BigUint::new(slice.to_owned());\n     }\n \n     /// Creates and initializes an BigUint."}, {"sha": "f488c03ce75ab69bef560bc47eef566ba6f670f5", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -12,7 +12,6 @@ use sort;\n use std::cmp;\n use std::io;\n use std::num;\n-use std::vec;\n \n // NB: this can probably be rewritten in terms of num::Num\n // to be less f64-specific.\n@@ -200,13 +199,13 @@ impl<'self> Stats for &'self [f64] {\n     }\n \n     fn percentile(self, pct: f64) -> f64 {\n-        let mut tmp = vec::to_owned(self);\n+        let mut tmp = self.to_owned();\n         sort::tim_sort(tmp);\n         percentile_of_sorted(tmp, pct)\n     }\n \n     fn quartiles(self) -> (f64,f64,f64) {\n-        let mut tmp = vec::to_owned(self);\n+        let mut tmp = self.to_owned();\n         sort::tim_sort(tmp);\n         let a = percentile_of_sorted(tmp, 25.0);\n         let b = percentile_of_sorted(tmp, 50.0);\n@@ -251,7 +250,7 @@ priv fn percentile_of_sorted(sorted_samples: &[f64],\n ///\n /// See: http://en.wikipedia.org/wiki/Winsorising\n pub fn winsorize(samples: &mut [f64], pct: f64) {\n-    let mut tmp = vec::to_owned(samples);\n+    let mut tmp = samples.to_owned();\n     sort::tim_sort(tmp);\n     let lo = percentile_of_sorted(tmp, pct);\n     let hi = percentile_of_sorted(tmp, 100.0-pct);"}, {"sha": "65b01c6af10ff4ffb771e280b59be092764afb91", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -714,7 +714,7 @@ pub fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n     let item_doc = lookup_item(id, cdata.data);\n     let path = {\n         let item_path = item_path(item_doc);\n-        vec::to_owned(item_path.init())\n+        item_path.init().to_owned()\n     };\n     match decode_inlined_item(cdata, tcx, copy path, item_doc) {\n       Some(ref ii) => csearch::found((/*bad*/copy *ii)),"}, {"sha": "742d549e202e897daba55dfdf62252055f22d07f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -1659,7 +1659,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n \n     let writer_bytes: &mut ~[u8] = wr.bytes;\n \n-    vec::to_owned(metadata_encoding_version) +\n+    metadata_encoding_version.to_owned() +\n         flate::deflate_bytes(*writer_bytes)\n }\n "}, {"sha": "b1095e53075e55c644b5d9b4f45fd2f979e9ddbd", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -484,7 +484,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                 match cx.tcx.def_map.find(&pat_id) {\n                     Some(&def_variant(_, id)) => {\n                         if variant(id) == *ctor_id {\n-                            Some(vec::to_owned(r.tail()))\n+                            Some(r.tail().to_owned())\n                         } else {\n                             None\n                         }\n@@ -522,7 +522,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                             _ => fail!(\"type error\")\n                         };\n                         if match_ {\n-                            Some(vec::to_owned(r.tail()))\n+                            Some(r.tail().to_owned())\n                         } else {\n                             None\n                         }\n@@ -569,7 +569,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                             _ => fail!(\"type error\")\n                         };\n                         if match_ {\n-                            Some(vec::to_owned(r.tail()))\n+                            Some(r.tail().to_owned())\n                         } else {\n                             None\n                         }\n@@ -579,7 +579,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                             Some(args) => args,\n                             None => vec::from_elem(arity, wild())\n                         };\n-                        Some(vec::append(args, vec::to_owned(r.tail())))\n+                        Some(vec::append(args, r.tail()))\n                     }\n                     def_variant(_, _) => None,\n \n@@ -591,7 +591,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                             Some(args) => new_args = args,\n                             None => new_args = vec::from_elem(arity, wild())\n                         }\n-                        Some(vec::append(new_args, vec::to_owned(r.tail())))\n+                        Some(vec::append(new_args, r.tail()))\n                     }\n                     _ => None\n                 }\n@@ -609,7 +609,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                                     _ => wild()\n                                 }\n                             });\n-                            Some(vec::append(args, vec::to_owned(r.tail())))\n+                            Some(vec::append(args, r.tail()))\n                         } else {\n                             None\n                         }\n@@ -640,7 +640,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                                 _ => wild()\n                             }\n                         }).collect();\n-                        Some(vec::append(args, vec::to_owned(r.tail())))\n+                        Some(vec::append(args, r.tail()))\n                     }\n                 }\n             }\n@@ -676,14 +676,14 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                     single => true,\n                     _ => fail!(\"type error\")\n                 };\n-                if match_ { Some(vec::to_owned(r.tail())) } else { None }\n+                if match_ { Some(r.tail().to_owned()) } else { None }\n             }\n             pat_range(lo, hi) => {\n                 let (c_lo, c_hi) = match *ctor_id {\n                     val(ref v) => ((/*bad*/copy *v), (/*bad*/copy *v)),\n                     range(ref lo, ref hi) =>\n                         ((/*bad*/copy *lo), (/*bad*/copy *hi)),\n-                    single => return Some(vec::to_owned(r.tail())),\n+                    single => return Some(r.tail().to_owned()),\n                     _ => fail!(\"type error\")\n                 };\n                 let v_lo = eval_const_expr(cx.tcx, lo);\n@@ -693,7 +693,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                 let m2 = compare_const_vals(&c_hi, &v_hi);\n                 match (m1, m2) {\n                     (Some(val1), Some(val2)) if val1 >= 0 && val2 <= 0 => {\n-                        Some(vec::to_owned(r.tail()))\n+                        Some(r.tail().to_owned())\n                     },\n                     (Some(_), Some(_)) => None,\n                     _ => {\n@@ -734,7 +734,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n }\n \n pub fn default(cx: &MatchCheckCtxt, r: &[@pat]) -> Option<~[@pat]> {\n-    if is_wild(cx, r[0]) { Some(vec::to_owned(r.tail())) }\n+    if is_wild(cx, r[0]) { Some(r.tail().to_owned()) }\n     else { None }\n }\n "}, {"sha": "0a2d24ee5fffe2f4d7243e9f404aab1e207c866d", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -47,7 +47,6 @@\n use std::container::Map;\n use std::libc::c_ulonglong;\n use std::option::{Option, Some, None};\n-use std::vec;\n \n use lib::llvm::{ValueRef, True, IntEQ, IntNE};\n use middle::trans::_match;\n@@ -219,7 +218,7 @@ fn mk_struct(cx: &mut CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64,\n         align: machine::llalign_of_min(cx, llty_rec) /*bad*/as u64,\n         packed: packed,\n-        fields: vec::to_owned(tys)\n+        fields: tys.to_owned(),\n     }\n }\n "}, {"sha": "a79f08b33c937d2b8296870aaa7cfc2d7c792f36", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -3783,7 +3783,7 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n           }\n \n           ast_map::node_variant(ref variant, _, path) => {\n-            vec::append_one(vec::to_owned(path.init()),\n+            vec::append_one(path.init().to_owned(),\n                             ast_map::path_name((*variant).node.name))\n           }\n "}, {"sha": "ea49144b7716c17d39423b9f6c6b0dc26e314e2e", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -47,8 +47,9 @@ pub use cmp::{Eq, ApproxEq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Great\n pub use char::Char;\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n-pub use iter::{Times};\n-pub use iterator::{Iterator, IteratorUtil, OrdIterator};\n+pub use iter::Times;\n+pub use iterator::{Iterator, IteratorUtil, DoubleEndedIterator, DoubleEndedIteratorUtil};\n+pub use iterator::OrdIterator;\n pub use num::{Num, NumCast};\n pub use num::{Orderable, Signed, Unsigned, Round};\n pub use num::{Algebraic, Trigonometric, Exponential, Hyperbolic};"}, {"sha": "2cf45ba70ec0e49235440784b9b90b9404712d83", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -591,7 +591,7 @@ impl<R: Rng> RngUtil for R {\n \n     /// Shuffle a vec\n     fn shuffle<T:Copy>(&mut self, values: &[T]) -> ~[T] {\n-        let mut m = vec::to_owned(values);\n+        let mut m = values.to_owned();\n         self.shuffle_mut(m);\n         m\n     }"}, {"sha": "8b27ce4235ee4386a4b6eeaea5c042b0f490b59a", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 69, "deletions": 19, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -30,7 +30,6 @@ use ptr::RawPtr;\n use rt::global_heap::malloc_raw;\n use rt::global_heap::realloc_raw;\n use sys;\n-use sys::size_of;\n use uint;\n use unstable::intrinsics;\n #[cfg(stage0)]\n@@ -91,11 +90,6 @@ pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n     }\n }\n \n-/// Creates a new unique vector with the same contents as the slice\n-pub fn to_owned<T:Copy>(t: &[T]) -> ~[T] {\n-    from_fn(t.len(), |i| copy t[i])\n-}\n-\n /// Creates a new vector with a capacity of `capacity`\n #[cfg(stage0)]\n pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n@@ -114,7 +108,7 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n             vec\n         } else {\n             let alloc = capacity * sys::nonzero_size_of::<T>();\n-            let ptr = malloc_raw(alloc + size_of::<raw::VecRepr>()) as *mut raw::VecRepr;\n+            let ptr = malloc_raw(alloc + sys::size_of::<raw::VecRepr>()) as *mut raw::VecRepr;\n             (*ptr).unboxed.alloc = alloc;\n             (*ptr).unboxed.fill = 0;\n             cast::transmute(ptr)\n@@ -756,10 +750,13 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn iter(self) -> VecIterator<'self, T> {\n         unsafe {\n             let p = vec::raw::to_ptr(self);\n-            VecIterator{ptr: p, end: p.offset(self.len()),\n+            VecIterator{ptr: p,\n+                        end: cast::transmute(p as uint + self.len() *\n+                                             sys::nonzero_size_of::<T>()),\n                         lifetime: cast::transmute(p)}\n         }\n     }\n+\n     #[inline]\n     fn rev_iter(self) -> VecRevIterator<'self, T> {\n         self.iter().invert()\n@@ -1153,7 +1150,7 @@ impl<T> OwnedVector<T> for ~[T] {\n                     ::at_vec::raw::reserve_raw(td, ptr, n);\n                 } else {\n                     let alloc = n * sys::nonzero_size_of::<T>();\n-                    *ptr = realloc_raw(*ptr as *mut c_void, alloc + size_of::<raw::VecRepr>())\n+                    *ptr = realloc_raw(*ptr as *mut c_void, alloc + sys::size_of::<raw::VecRepr>())\n                            as *mut raw::VecRepr;\n                     (**ptr).unboxed.alloc = alloc;\n                 }\n@@ -1182,7 +1179,7 @@ impl<T> OwnedVector<T> for ~[T] {\n                     ::at_vec::raw::reserve_raw(td, ptr, n);\n                 } else {\n                     let alloc = n * sys::nonzero_size_of::<T>();\n-                    let size = alloc + size_of::<raw::VecRepr>();\n+                    let size = alloc + sys::size_of::<raw::VecRepr>();\n                     if alloc / sys::nonzero_size_of::<T>() != n || size < alloc {\n                         fail!(\"vector size is too large: %u\", n);\n                     }\n@@ -1716,7 +1713,9 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     fn mut_iter(self) -> VecMutIterator<'self, T> {\n         unsafe {\n             let p = vec::raw::to_mut_ptr(self);\n-            VecMutIterator{ptr: p, end: p.offset(self.len()),\n+            VecMutIterator{ptr: p,\n+                           end: cast::transmute(p as uint + self.len() *\n+                                                sys::nonzero_size_of::<T>()),\n                            lifetime: cast::transmute(p)}\n         }\n     }\n@@ -2093,7 +2092,11 @@ macro_rules! iterator {\n                         None\n                     } else {\n                         let old = self.ptr;\n-                        self.ptr = self.ptr.offset(1);\n+                        // purposefully don't use 'ptr.offset' because for\n+                        // vectors with 0-size elements this would return the\n+                        // same pointer.\n+                        self.ptr = cast::transmute(self.ptr as uint +\n+                                                   sys::nonzero_size_of::<T>());\n                         Some(cast::transmute(old))\n                     }\n                 }\n@@ -2102,7 +2105,7 @@ macro_rules! iterator {\n             #[inline]\n             fn size_hint(&self) -> (uint, Option<uint>) {\n                 let diff = (self.end as uint) - (self.ptr as uint);\n-                let exact = diff / size_of::<$elem>();\n+                let exact = diff / sys::nonzero_size_of::<$elem>();\n                 (exact, Some(exact))\n             }\n         }\n@@ -2119,7 +2122,9 @@ macro_rules! double_ended_iterator {\n                     if self.end == self.ptr {\n                         None\n                     } else {\n-                        self.end = self.end.offset(-1);\n+                        // See above for why 'ptr.offset' isn't used\n+                        self.end = cast::transmute(self.end as uint -\n+                                                   sys::nonzero_size_of::<T>());\n                         Some(cast::transmute(self.end))\n                     }\n                 }\n@@ -2211,7 +2216,6 @@ impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n     }\n }\n \n-\n #[cfg(test)]\n mod tests {\n     use option::{None, Option, Some};\n@@ -2676,19 +2680,19 @@ mod tests {\n         let mut results: ~[~[int]];\n \n         results = ~[];\n-        for each_permutation([]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([]) |v| { results.push(v.to_owned()); }\n         assert_eq!(results, ~[~[]]);\n \n         results = ~[];\n-        for each_permutation([7]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([7]) |v| { results.push(v.to_owned()); }\n         assert_eq!(results, ~[~[7]]);\n \n         results = ~[];\n-        for each_permutation([1,1]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([1,1]) |v| { results.push(v.to_owned()); }\n         assert_eq!(results, ~[~[1,1],~[1,1]]);\n \n         results = ~[];\n-        for each_permutation([5,2,0]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([5,2,0]) |v| { results.push(v.to_owned()); }\n         assert!(results ==\n             ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]]);\n     }\n@@ -3375,4 +3379,50 @@ mod tests {\n \n         assert_eq!(values, [2, 3, 5, 6, 7]);\n     }\n+\n+    #[deriving(Eq)]\n+    struct Foo;\n+\n+    #[test]\n+    fn test_iter_zero_sized() {\n+        let mut v = ~[Foo, Foo, Foo];\n+        assert_eq!(v.len(), 3);\n+        let mut cnt = 0;\n+\n+        for v.iter().advance |f| {\n+            assert!(*f == Foo);\n+            cnt += 1;\n+        }\n+        assert_eq!(cnt, 3);\n+\n+        for v.slice(1, 3).iter().advance |f| {\n+            assert!(*f == Foo);\n+            cnt += 1;\n+        }\n+        assert_eq!(cnt, 5);\n+\n+        for v.mut_iter().advance |f| {\n+            assert!(*f == Foo);\n+            cnt += 1;\n+        }\n+        assert_eq!(cnt, 8);\n+\n+        for v.consume_iter().advance |f| {\n+            assert!(f == Foo);\n+            cnt += 1;\n+        }\n+        assert_eq!(cnt, 11);\n+\n+        let xs = ~[Foo, Foo, Foo];\n+        assert_eq!(fmt!(\"%?\", xs.slice(0, 2).to_owned()), ~\"~[{}, {}]\");\n+\n+        let xs: [Foo, ..3] = [Foo, Foo, Foo];\n+        assert_eq!(fmt!(\"%?\", xs.slice(0, 2).to_owned()), ~\"~[{}, {}]\");\n+        cnt = 0;\n+        for xs.iter().advance |f| {\n+            assert!(*f == Foo);\n+            cnt += 1;\n+        }\n+        assert!(cnt == 3);\n+    }\n }"}, {"sha": "055d5540f8d260772db35f24583e9108d092e8b5", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -20,7 +20,6 @@ use diagnostic::span_handler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n \n use std::hashmap::HashSet;\n-use std::vec;\n /* Constructors */\n \n pub fn mk_name_value_item_str(name: @str, value: @str)\n@@ -256,7 +255,7 @@ pub fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: &str)\n \n pub fn sort_meta_items(items: &[@ast::meta_item]) -> ~[@ast::meta_item] {\n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let mut v = vec::to_owned(items);\n+    let mut v = items.to_owned();\n     do extra::sort::quick_sort(v) |ma, mb| {\n         get_meta_item_name(*ma) <= get_meta_item_name(*mb)\n     }"}, {"sha": "bf7cccdc9efc03efb95bf345b6a9e470452f9205", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -19,8 +19,6 @@ use ext::base::*;\n use parse;\n use parse::token;\n \n-use std::vec;\n-\n enum State {\n     Asm,\n     Outputs,\n@@ -43,7 +41,7 @@ pub fn expand_asm(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n                -> base::MacResult {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),\n-                                       vec::to_owned(tts));\n+                                       tts.to_owned());\n \n     let mut asm = @\"\";\n     let mut outputs = ~[];"}, {"sha": "c9bd2986a425202351249227f752f8e622b9a142", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -18,7 +18,6 @@ use parse;\n use parse::token;\n use parse::token::{ident_to_str, intern, str_to_ident};\n \n-use std::vec;\n use std::hashmap::HashMap;\n \n // new-style macro! tt code:\n@@ -362,7 +361,7 @@ pub fn get_exprs_from_tts(cx: @ExtCtxt, tts: &[ast::token_tree])\n                        -> ~[@ast::expr] {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),\n-                                       vec::to_owned(tts));\n+                                       tts.to_owned());\n     let mut es = ~[];\n     while *p.token != token::EOF {\n         if es.len() != 0 {"}, {"sha": "409873d347ba283f3285816ee3471f8383cb8e3e", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -15,7 +15,6 @@ use ext::base;\n use print;\n use parse::token::{get_ident_interner};\n \n-use std::vec;\n use std::io;\n \n pub fn expand_syntax_ext(cx: @ExtCtxt,\n@@ -26,7 +25,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt,\n     cx.print_backtrace();\n     io::stdout().write_line(\n         print::pprust::tt_to_str(\n-            &ast::tt_delim(vec::to_owned(tt)),\n+            &ast::tt_delim(tt.to_owned()),\n             get_ident_interner()));\n \n     //trivial expression"}, {"sha": "3e0e9c93fd00e9ba8d193623d6f7b81bdfb19d0b", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -17,8 +17,6 @@ use parse::token::*;\n use parse::token;\n use parse;\n \n-use std::vec;\n-\n /**\n *\n * Quasiquoting works via token trees.\n@@ -653,7 +651,7 @@ fn expand_tts(cx: @ExtCtxt,\n     let p = parse::new_parser_from_tts(\n         cx.parse_sess(),\n         cx.cfg(),\n-        vec::to_owned(tts)\n+        tts.to_owned()\n     );\n     *p.quote_depth += 1u;\n     let tts = p.parse_all_token_trees();"}, {"sha": "ba3b8f22e69b6fd9e58bda959f47cd3816cf4c76", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -16,8 +16,6 @@ use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n use parse::token::keywords;\n \n-use std::vec;\n-\n pub fn expand_trace_macros(cx: @ExtCtxt,\n                            sp: span,\n                            tt: &[ast::token_tree])\n@@ -27,7 +25,7 @@ pub fn expand_trace_macros(cx: @ExtCtxt,\n     let tt_rdr = new_tt_reader(\n         copy cx.parse_sess().span_diagnostic,\n         None,\n-        vec::to_owned(tt)\n+        tt.to_owned()\n     );\n     let rdr = tt_rdr as @reader;\n     let rust_parser = Parser("}, {"sha": "a2e3d7bfeca24ed4a88d1763ae16aa6d106b9939", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -23,7 +23,6 @@ use parse::token::{get_ident_interner, special_idents, gensym_ident, ident_to_st\n use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt};\n use print;\n \n-use std::vec;\n use std::io;\n \n pub fn add_new_extension(cx: @ExtCtxt,\n@@ -82,7 +81,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n             io::println(fmt!(\"%s! { %s }\",\n                              cx.str_of(name),\n                              print::pprust::tt_to_str(\n-                                 &ast::tt_delim(vec::to_owned(arg)),\n+                                 &ast::tt_delim(arg.to_owned()),\n                                  get_ident_interner())));\n         }\n \n@@ -99,7 +98,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n                 let arg_rdr = new_tt_reader(\n                     s_d,\n                     None,\n-                    vec::to_owned(arg)\n+                    arg.to_owned()\n                 ) as @reader;\n                 match parse(cx.parse_sess(), cx.cfg(), arg_rdr, *mtcs) {\n                   success(named_matches) => {"}, {"sha": "3df60762dea02090c84d66ebbb37eb4d489e31d4", "filename": "src/test/run-pass/rcvr-borrowed-to-slice.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs?ref=96453eb5c524fea0ee48b9a8e4b60c12dd0e9fc9", "patch": "@@ -11,19 +11,17 @@\n use std::vec;\n \n trait sum {\n-    fn sum(self) -> int;\n+    fn sum_(self) -> int;\n }\n \n // Note: impl on a slice\n impl<'self> sum for &'self [int] {\n-    fn sum(self) -> int {\n-        let mut sum = 0;\n-        for self.iter().advance |e| { sum += *e; }\n-        return sum;\n+    fn sum_(self) -> int {\n+        self.iter().fold(0, |a, &b| a + b)\n     }\n }\n \n-fn call_sum(x: &[int]) -> int { x.sum() }\n+fn call_sum(x: &[int]) -> int { x.sum_() }\n \n pub fn main() {\n     let x = ~[1, 2, 3];\n@@ -32,12 +30,12 @@ pub fn main() {\n     assert_eq!(y, 6);\n \n     let mut x = ~[1, 2, 3];\n-    let y = x.sum();\n+    let y = x.sum_();\n     debug!(\"y==%d\", y);\n     assert_eq!(y, 6);\n \n     let x = ~[1, 2, 3];\n-    let y = x.sum();\n+    let y = x.sum_();\n     debug!(\"y==%d\", y);\n     assert_eq!(y, 6);\n }"}]}