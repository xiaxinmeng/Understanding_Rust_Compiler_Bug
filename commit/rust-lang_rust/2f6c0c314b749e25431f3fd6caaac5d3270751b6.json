{"sha": "2f6c0c314b749e25431f3fd6caaac5d3270751b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNmMwYzMxNGI3NDllMjU0MzFmM2ZkNmNhYWFjNWQzMjcwNzUxYjY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-15T11:47:26Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-15T11:47:26Z"}, "message": "Move scope tests to hir_def", "tree": {"sha": "85d898d41976ea57ef1a7a3f6da0a9bdc7b88031", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85d898d41976ea57ef1a7a3f6da0a9bdc7b88031"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f6c0c314b749e25431f3fd6caaac5d3270751b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f6c0c314b749e25431f3fd6caaac5d3270751b6", "html_url": "https://github.com/rust-lang/rust/commit/2f6c0c314b749e25431f3fd6caaac5d3270751b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f6c0c314b749e25431f3fd6caaac5d3270751b6/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9167da66acff22b4fe68d7bbe60c25ab0b56ad72", "url": "https://api.github.com/repos/rust-lang/rust/commits/9167da66acff22b4fe68d7bbe60c25ab0b56ad72", "html_url": "https://github.com/rust-lang/rust/commit/9167da66acff22b4fe68d7bbe60c25ab0b56ad72"}], "stats": {"total": 444, "additions": 233, "deletions": 211}, "files": [{"sha": "e4598eec074d72c3dc3e40109b09f02f16a4bce1", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/2f6c0c314b749e25431f3fd6caaac5d3270751b6/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6c0c314b749e25431f3fd6caaac5d3270751b6/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=2f6c0c314b749e25431f3fd6caaac5d3270751b6", "patch": "@@ -42,192 +42,3 @@ pub(crate) fn resolver_for_scope(\n     }\n     r\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use hir_expand::Source;\n-    use ra_db::{fixture::WithFixture, SourceDatabase};\n-    use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n-    use test_utils::{assert_eq_text, extract_offset};\n-\n-    use crate::{source_binder::SourceAnalyzer, test_db::TestDB};\n-\n-    fn do_check(code: &str, expected: &[&str]) {\n-        let (off, code) = extract_offset(code);\n-        let code = {\n-            let mut buf = String::new();\n-            let off = u32::from(off) as usize;\n-            buf.push_str(&code[..off]);\n-            buf.push_str(\"marker\");\n-            buf.push_str(&code[off..]);\n-            buf\n-        };\n-\n-        let (db, file_id) = TestDB::with_single_file(&code);\n-\n-        let file = db.parse(file_id).ok().unwrap();\n-        let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n-        let analyzer = SourceAnalyzer::new(&db, file_id, marker.syntax(), None);\n-\n-        let scopes = analyzer.scopes();\n-        let expr_id = analyzer\n-            .body_source_map()\n-            .node_expr(Source { file_id: file_id.into(), ast: &marker.into() })\n-            .unwrap();\n-        let scope = scopes.scope_for(expr_id);\n-\n-        let actual = scopes\n-            .scope_chain(scope)\n-            .flat_map(|scope| scopes.entries(scope))\n-            .map(|it| it.name().to_string())\n-            .collect::<Vec<_>>()\n-            .join(\"\\n\");\n-        let expected = expected.join(\"\\n\");\n-        assert_eq_text!(&expected, &actual);\n-    }\n-\n-    #[test]\n-    fn test_lambda_scope() {\n-        do_check(\n-            r\"\n-            fn quux(foo: i32) {\n-                let f = |bar, baz: i32| {\n-                    <|>\n-                };\n-            }\",\n-            &[\"bar\", \"baz\", \"foo\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_call_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                f(|x| <|> );\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_method_call_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                z.f(|x| <|> );\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_loop_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                loop {\n-                    let x = ();\n-                    <|>\n-                };\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_match() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                match () {\n-                    Some(x) => {\n-                        <|>\n-                    }\n-                };\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_shadow_variable() {\n-        do_check(\n-            r\"\n-            fn foo(x: String) {\n-                let x : &str = &x<|>;\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    fn do_check_local_name(code: &str, expected_offset: u32) {\n-        let (off, code) = extract_offset(code);\n-\n-        let (db, file_id) = TestDB::with_single_file(&code);\n-        let file = db.parse(file_id).ok().unwrap();\n-        let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n-            .expect(\"failed to find a name at the target offset\");\n-        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let analyzer = SourceAnalyzer::new(&db, file_id, name_ref.syntax(), None);\n-\n-        let local_name_entry = analyzer.resolve_local_name(&name_ref).unwrap();\n-        let local_name =\n-            local_name_entry.ptr().either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n-        assert_eq!(local_name.range(), expected_name.syntax().text_range());\n-    }\n-\n-    #[test]\n-    fn test_resolve_local_name() {\n-        do_check_local_name(\n-            r#\"\n-            fn foo(x: i32, y: u32) {\n-                {\n-                    let z = x * 2;\n-                }\n-                {\n-                    let t = x<|> * 3;\n-                }\n-            }\"#,\n-            21,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_resolve_local_name_declaration() {\n-        do_check_local_name(\n-            r#\"\n-            fn foo(x: String) {\n-                let x : &str = &x<|>;\n-            }\"#,\n-            21,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_resolve_local_name_shadow() {\n-        do_check_local_name(\n-            r\"\n-            fn foo(x: String) {\n-                let x : &str = &x;\n-                x<|>\n-            }\n-            \",\n-            53,\n-        );\n-    }\n-\n-    #[test]\n-    fn ref_patterns_contribute_bindings() {\n-        do_check_local_name(\n-            r\"\n-            fn foo() {\n-                if let Some(&from) = bar() {\n-                    from<|>;\n-                }\n-            }\n-            \",\n-            53,\n-        );\n-    }\n-}"}, {"sha": "662d3f8808cb005169234e5d4f971fb9c16e8efa", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2f6c0c314b749e25431f3fd6caaac5d3270751b6/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6c0c314b749e25431f3fd6caaac5d3270751b6/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=2f6c0c314b749e25431f3fd6caaac5d3270751b6", "patch": "@@ -19,7 +19,6 @@ use ra_syntax::{\n     SyntaxKind::*,\n     SyntaxNode, SyntaxNodePtr, TextRange, TextUnit,\n };\n-use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n@@ -286,22 +285,14 @@ impl SourceAnalyzer {\n     }\n \n     fn resolve_local_name(&self, name_ref: &ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n-        let mut shadowed = FxHashSet::default();\n         let name = name_ref.as_name();\n         let source_map = self.body_source_map.as_ref()?;\n         let scopes = self.scopes.as_ref()?;\n-        let scope = scope_for(scopes, source_map, self.file_id.into(), name_ref.syntax());\n-        let ret = scopes\n-            .scope_chain(scope)\n-            .flat_map(|scope| scopes.entries(scope).iter())\n-            .filter(|entry| shadowed.insert(entry.name()))\n-            .filter(|entry| entry.name() == &name)\n-            .nth(0);\n-        ret.and_then(|entry| {\n-            Some(ScopeEntryWithSyntax {\n-                name: entry.name().clone(),\n-                ptr: source_map.pat_syntax(entry.pat())?.ast,\n-            })\n+        let scope = scope_for(scopes, source_map, self.file_id.into(), name_ref.syntax())?;\n+        let entry = scopes.resolve_name_in_scope(scope, &name)?;\n+        Some(ScopeEntryWithSyntax {\n+            name: entry.name().clone(),\n+            ptr: source_map.pat_syntax(entry.pat())?.ast,\n         })\n     }\n \n@@ -413,11 +404,6 @@ impl SourceAnalyzer {\n     pub(crate) fn inference_result(&self) -> Arc<crate::ty::InferenceResult> {\n         self.infer.clone().unwrap()\n     }\n-\n-    #[cfg(test)]\n-    pub(crate) fn scopes(&self) -> Arc<ExprScopes> {\n-        self.scopes.clone().unwrap()\n-    }\n }\n \n fn scope_for("}, {"sha": "10cb87d37bdf1b9d73b63ab6b2bb74aa22c6dfa3", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/2f6c0c314b749e25431f3fd6caaac5d3270751b6/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6c0c314b749e25431f3fd6caaac5d3270751b6/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=2f6c0c314b749e25431f3fd6caaac5d3270751b6", "patch": "@@ -67,6 +67,11 @@ impl ExprScopes {\n         std::iter::successors(scope, move |&scope| self.scopes[scope].parent)\n     }\n \n+    pub fn resolve_name_in_scope(&self, scope: ScopeId, name: &Name) -> Option<&ScopeEntry> {\n+        self.scope_chain(Some(scope))\n+            .find_map(|scope| self.entries(scope).iter().find(|it| it.name == *name))\n+    }\n+\n     pub fn scope_for(&self, expr: ExprId) -> Option<ScopeId> {\n         self.scope_by_expr.get(&expr).copied()\n     }\n@@ -163,3 +168,217 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n         e => e.walk_child_exprs(|e| compute_expr_scopes(e, body, scopes, scope)),\n     };\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use hir_expand::{name::AsName, Source};\n+    use ra_db::{fixture::WithFixture, FileId, SourceDatabase};\n+    use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n+    use test_utils::{assert_eq_text, extract_offset};\n+\n+    use crate::{db::DefDatabase2, test_db::TestDB, FunctionId, ModuleDefId};\n+\n+    fn find_function(db: &TestDB, file_id: FileId) -> FunctionId {\n+        let krate = db.test_crate();\n+        let crate_def_map = db.crate_def_map(krate);\n+\n+        let module = crate_def_map.modules_for_file(file_id).next().unwrap();\n+        let (_, res) = crate_def_map[module].scope.entries().next().unwrap();\n+        match res.def.take_values().unwrap() {\n+            ModuleDefId::FunctionId(it) => it,\n+            _ => panic!(),\n+        }\n+    }\n+\n+    fn do_check(code: &str, expected: &[&str]) {\n+        let (off, code) = extract_offset(code);\n+        let code = {\n+            let mut buf = String::new();\n+            let off = u32::from(off) as usize;\n+            buf.push_str(&code[..off]);\n+            buf.push_str(\"marker\");\n+            buf.push_str(&code[off..]);\n+            buf\n+        };\n+\n+        let (db, file_id) = TestDB::with_single_file(&code);\n+\n+        let file_syntax = db.parse(file_id).syntax_node();\n+        let marker: ast::PathExpr = find_node_at_offset(&file_syntax, off).unwrap();\n+        let function = find_function(&db, file_id);\n+\n+        let scopes = db.expr_scopes(function.into());\n+        let (_body, source_map) = db.body_with_source_map(function.into());\n+\n+        let expr_id =\n+            source_map.node_expr(Source { file_id: file_id.into(), ast: &marker.into() }).unwrap();\n+        let scope = scopes.scope_for(expr_id);\n+\n+        let actual = scopes\n+            .scope_chain(scope)\n+            .flat_map(|scope| scopes.entries(scope))\n+            .map(|it| it.name().to_string())\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+        let expected = expected.join(\"\\n\");\n+        assert_eq_text!(&expected, &actual);\n+    }\n+\n+    #[test]\n+    fn test_lambda_scope() {\n+        do_check(\n+            r\"\n+            fn quux(foo: i32) {\n+                let f = |bar, baz: i32| {\n+                    <|>\n+                };\n+            }\",\n+            &[\"bar\", \"baz\", \"foo\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_call_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                f(|x| <|> );\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_method_call_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                z.f(|x| <|> );\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_loop_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                loop {\n+                    let x = ();\n+                    <|>\n+                };\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_match() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                match () {\n+                    Some(x) => {\n+                        <|>\n+                    }\n+                };\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_shadow_variable() {\n+        do_check(\n+            r\"\n+            fn foo(x: String) {\n+                let x : &str = &x<|>;\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    fn do_check_local_name(code: &str, expected_offset: u32) {\n+        let (off, code) = extract_offset(code);\n+\n+        let (db, file_id) = TestDB::with_single_file(&code);\n+\n+        let file = db.parse(file_id).ok().unwrap();\n+        let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n+            .expect(\"failed to find a name at the target offset\");\n+        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n+\n+        let function = find_function(&db, file_id);\n+\n+        let scopes = db.expr_scopes(function.into());\n+        let (_body, source_map) = db.body_with_source_map(function.into());\n+\n+        let expr_scope = {\n+            let expr_ast = name_ref.syntax().ancestors().find_map(ast::Expr::cast).unwrap();\n+            let expr_id =\n+                source_map.node_expr(Source { file_id: file_id.into(), ast: &expr_ast }).unwrap();\n+            scopes.scope_for(expr_id).unwrap()\n+        };\n+\n+        let resolved = scopes.resolve_name_in_scope(expr_scope, &name_ref.as_name()).unwrap();\n+        let pat_src = source_map.pat_syntax(resolved.pat()).unwrap();\n+\n+        let local_name = pat_src.ast.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n+        assert_eq!(local_name.range(), expected_name.syntax().text_range());\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name() {\n+        do_check_local_name(\n+            r#\"\n+            fn foo(x: i32, y: u32) {\n+                {\n+                    let z = x * 2;\n+                }\n+                {\n+                    let t = x<|> * 3;\n+                }\n+            }\"#,\n+            21,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name_declaration() {\n+        do_check_local_name(\n+            r#\"\n+            fn foo(x: String) {\n+                let x : &str = &x<|>;\n+            }\"#,\n+            21,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name_shadow() {\n+        do_check_local_name(\n+            r\"\n+            fn foo(x: String) {\n+                let x : &str = &x;\n+                x<|>\n+            }\n+            \",\n+            53,\n+        );\n+    }\n+\n+    #[test]\n+    fn ref_patterns_contribute_bindings() {\n+        do_check_local_name(\n+            r\"\n+            fn foo() {\n+                if let Some(&from) = bar() {\n+                    from<|>;\n+                }\n+            }\n+            \",\n+            53,\n+        );\n+    }\n+}"}, {"sha": "21d5f62e042f9ec16fe1971037b50ac7e4f81046", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f6c0c314b749e25431f3fd6caaac5d3270751b6/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6c0c314b749e25431f3fd6caaac5d3270751b6/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=2f6c0c314b749e25431f3fd6caaac5d3270751b6", "patch": "@@ -58,7 +58,7 @@ mod tests;\n \n use std::sync::Arc;\n \n-use hir_expand::{diagnostics::DiagnosticSink, name::Name, MacroDefId};\n+use hir_expand::{ast_id_map::FileAstId, diagnostics::DiagnosticSink, name::Name, MacroDefId};\n use once_cell::sync::Lazy;\n use ra_arena::Arena;\n use ra_db::{CrateId, Edition, FileId};\n@@ -73,7 +73,7 @@ use crate::{\n         diagnostics::DefDiagnostic, path_resolution::ResolveMode, per_ns::PerNs, raw::ImportId,\n     },\n     path::Path,\n-    AstId, CrateModuleId, ModuleDefId, ModuleId, TraitId,\n+    AstId, CrateModuleId, FunctionId, ModuleDefId, ModuleId, TraitId,\n };\n \n /// Contains all top-level defs from a macro-expanded crate\n@@ -124,6 +124,11 @@ pub struct ModuleData {\n     pub definition: Option<FileId>,\n }\n \n+#[derive(Default, Debug, PartialEq, Eq, Clone)]\n+pub(crate) struct Declarations {\n+    fns: FxHashMap<FileAstId<ast::FnDef>, FunctionId>,\n+}\n+\n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n     pub items: FxHashMap<Name, Resolution>,"}, {"sha": "5c899aff35c78010eeb3d156393888d5e5bc6bf0", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f6c0c314b749e25431f3fd6caaac5d3270751b6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6c0c314b749e25431f3fd6caaac5d3270751b6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=2f6c0c314b749e25431f3fd6caaac5d3270751b6", "patch": "@@ -664,7 +664,8 @@ where\n         let name = def.name.clone();\n         let def: PerNs = match def.kind {\n             raw::DefKind::Function(ast_id) => {\n-                PerNs::values(FunctionId::from_ast_id(ctx, ast_id).into())\n+                let f = FunctionId::from_ast_id(ctx, ast_id);\n+                PerNs::values(f.into())\n             }\n             raw::DefKind::Struct(ast_id) => {\n                 let id = StructOrUnionId::from_ast_id(ctx, ast_id).into();"}]}