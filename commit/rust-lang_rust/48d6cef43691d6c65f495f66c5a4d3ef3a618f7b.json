{"sha": "48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "node_id": "C_kwDOAAsO6NoAKDQ4ZDZjZWY0MzY5MWQ2YzY1ZjQ5NWY2NmM1YTRkM2VmM2E2MThmN2I", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-20T12:05:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-20T12:05:23Z"}, "message": "Merge #10484\n\n10484: internal: Update match checking algorithm r=lnicola a=iDawer\n\nSync match checking algorithm with rust-lang/rust f31622a50 2021-11-12 (https://github.com/rust-lang/rust/pull/90813)\r\n\r\nThis update brings huge simplification to the match checking and introduces an easy to use machinery for pattern destructuring and also:\r\n\r\n1. Add a function to do post-inference normalization `hir_ty::infer::normalize(...)`.\r\n2. Store binding modes in `InferenceResult`.\r\n\r\nTodo:\r\n\r\n- [x] Rebase & test (https://github.com/rust-analyzer/rust-analyzer/pull/10484#issuecomment-996669665)\n\nCo-authored-by: Dawer <7803845+iDawer@users.noreply.github.com>\nCo-authored-by: iDawer <ilnur.iskhakov.oss@outlook.com>", "tree": {"sha": "82d8f3fd2c89482d0214a22411566cc8bad82b2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82d8f3fd2c89482d0214a22411566cc8bad82b2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhwHGDCRBK7hj4Ov3rIwAA9MIIABDskUXdMlQ5iqn/3cMDjMLL\nKDYShVVdRGYkqI7QOsaqZ13Vx1PknE39v2G1kGkiA256D3ktrZ2GRva0Jm1RIfKS\nv8xZiOczew1ramSoM9QqhZs1O9uR+GjwtHQPGXyss67utvt6/f1YiQTu3eLeR7js\nTtZn2lKR0qpZXKGGZyrfW7LZlhzcEC9JQV61sXNnQDFY6oW4Aqj37QZRXUK9UuwG\nN0sAR/kFXiPbGdFBMPMmAGa6SIO2JBdGnTNl5d17smXqbGuzQNa9KD/XRXYgLoLl\nLilfp9ITx2g0KExzFdaIqvmNjbvINE7koKeNxyGYaOoXj3vVJZw1Ho8Vt805Yow=\n=da7C\n-----END PGP SIGNATURE-----\n", "payload": "tree 82d8f3fd2c89482d0214a22411566cc8bad82b2b\nparent 2ca3834c9f15027fa68a0d0f70f7abf75a26d750\nparent a9ad7be748d4bd146f05ae4dd9cbb0acb9431440\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1640001923 +0000\ncommitter GitHub <noreply@github.com> 1640001923 +0000\n\nMerge #10484\n\n10484: internal: Update match checking algorithm r=lnicola a=iDawer\n\nSync match checking algorithm with rust-lang/rust f31622a50 2021-11-12 (https://github.com/rust-lang/rust/pull/90813)\r\n\r\nThis update brings huge simplification to the match checking and introduces an easy to use machinery for pattern destructuring and also:\r\n\r\n1. Add a function to do post-inference normalization `hir_ty::infer::normalize(...)`.\r\n2. Store binding modes in `InferenceResult`.\r\n\r\nTodo:\r\n\r\n- [x] Rebase & test (https://github.com/rust-analyzer/rust-analyzer/pull/10484#issuecomment-996669665)\n\nCo-authored-by: Dawer <7803845+iDawer@users.noreply.github.com>\nCo-authored-by: iDawer <ilnur.iskhakov.oss@outlook.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "html_url": "https://github.com/rust-lang/rust/commit/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ca3834c9f15027fa68a0d0f70f7abf75a26d750", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ca3834c9f15027fa68a0d0f70f7abf75a26d750", "html_url": "https://github.com/rust-lang/rust/commit/2ca3834c9f15027fa68a0d0f70f7abf75a26d750"}, {"sha": "a9ad7be748d4bd146f05ae4dd9cbb0acb9431440", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9ad7be748d4bd146f05ae4dd9cbb0acb9431440", "html_url": "https://github.com/rust-lang/rust/commit/a9ad7be748d4bd146f05ae4dd9cbb0acb9431440"}], "stats": {"total": 1585, "additions": 699, "deletions": 886}, "files": [{"sha": "7d6446ea6b86f4a3d64ea9ea87bc01824818e968", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "patch": "@@ -559,6 +559,7 @@ dependencies = [\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-tree\",\n+ \"typed-arena\",\n ]\n \n [[package]]\n@@ -1775,6 +1776,12 @@ dependencies = [\n  \"stdx\",\n ]\n \n+[[package]]\n+name = \"typed-arena\"\n+version = \"2.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0685c84d5d54d1c26f7d3eb96cd41550adb97baed141a761cf335d3d33bcd0ae\"\n+\n [[package]]\n name = \"ungrammar\"\n version = \"1.14.9\""}, {"sha": "f5e557570713ac4bfdbffdd883463e18723902b7", "filename": "crates/hir_ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fhir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fhir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2FCargo.toml?ref=48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "patch": "@@ -23,6 +23,7 @@ chalk-ir = \"0.75\"\n chalk-recursive = { version = \"0.75\", default-features = false }\n la-arena = { version = \"0.3.0\", path = \"../../lib/arena\" }\n once_cell = { version = \"1.5.0\" }\n+typed-arena = \"2.0.1\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n hir_def = { path = \"../hir_def\", version = \"0.0.0\" }"}, {"sha": "a8c4026e31f3b1a2a7fe9a449ce404dfdce8a430", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "patch": "@@ -2,7 +2,7 @@\n //! through the body using inference results: mismatched arg counts, missing\n //! fields, etc.\n \n-use std::{cell::RefCell, sync::Arc};\n+use std::sync::Arc;\n \n use hir_def::{\n     expr::Statement, path::path, resolver::HasResolver, type_ref::Mutability, AssocItemId,\n@@ -11,12 +11,14 @@ use hir_def::{\n use hir_expand::name;\n use itertools::Either;\n use rustc_hash::FxHashSet;\n+use typed_arena::Arena;\n \n use crate::{\n     db::HirDatabase,\n     diagnostics::match_check::{\n         self,\n-        usefulness::{compute_match_usefulness, expand_pattern, MatchCheckCtx, PatternArena},\n+        deconstruct_pat::DeconstructedPat,\n+        usefulness::{compute_match_usefulness, MatchCheckCtx},\n     },\n     AdtId, InferenceResult, Interner, Ty, TyExt, TyKind,\n };\n@@ -275,15 +277,20 @@ impl ExprValidator {\n     ) {\n         let body = db.body(self.owner);\n \n-        let match_expr_ty = if infer.type_of_expr[match_expr].is_unknown() {\n+        let match_expr_ty = &infer[match_expr];\n+        if match_expr_ty.is_unknown() {\n             return;\n-        } else {\n-            &infer.type_of_expr[match_expr]\n-        };\n+        }\n \n-        let pattern_arena = RefCell::new(PatternArena::new());\n+        let pattern_arena = Arena::new();\n+        let cx = MatchCheckCtx {\n+            module: self.owner.module(db.upcast()),\n+            body: self.owner,\n+            db,\n+            pattern_arena: &pattern_arena,\n+        };\n \n-        let mut m_arms = Vec::new();\n+        let mut m_arms = Vec::with_capacity(arms.len());\n         let mut has_lowering_errors = false;\n         for arm in arms {\n             if let Some(pat_ty) = infer.type_of_pat.get(arm.pat) {\n@@ -308,13 +315,7 @@ impl ExprValidator {\n                     // check the usefulness of each pattern as we added it\n                     // to the matrix here.\n                     let m_arm = match_check::MatchArm {\n-                        pat: self.lower_pattern(\n-                            arm.pat,\n-                            &mut pattern_arena.borrow_mut(),\n-                            db,\n-                            &body,\n-                            &mut has_lowering_errors,\n-                        ),\n+                        pat: self.lower_pattern(&cx, arm.pat, db, &body, &mut has_lowering_errors),\n                         has_guard: arm.guard.is_some(),\n                     };\n                     m_arms.push(m_arm);\n@@ -332,17 +333,10 @@ impl ExprValidator {\n             return;\n         }\n \n-        let cx = MatchCheckCtx {\n-            module: self.owner.module(db.upcast()),\n-            match_expr,\n-            infer: &infer,\n-            db,\n-            pattern_arena: &pattern_arena,\n-        };\n-        let report = compute_match_usefulness(&cx, &m_arms);\n+        let report = compute_match_usefulness(&cx, &m_arms, match_expr_ty);\n \n         // FIXME Report unreacheble arms\n-        // https://github.com/rust-lang/rust/blob/25c15cdbe/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L200-L201\n+        // https://github.com/rust-lang/rust/blob/f31622a50/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L200\n \n         let witnesses = report.non_exhaustiveness_witnesses;\n         // FIXME Report witnesses\n@@ -352,17 +346,17 @@ impl ExprValidator {\n         }\n     }\n \n-    fn lower_pattern(\n+    fn lower_pattern<'p>(\n         &self,\n+        cx: &MatchCheckCtx<'_, 'p>,\n         pat: PatId,\n-        pattern_arena: &mut PatternArena,\n         db: &dyn HirDatabase,\n         body: &Body,\n         have_errors: &mut bool,\n-    ) -> match_check::PatId {\n+    ) -> &'p DeconstructedPat<'p> {\n         let mut patcx = match_check::PatCtxt::new(db, &self.infer, body);\n         let pattern = patcx.lower_pattern(pat);\n-        let pattern = pattern_arena.alloc(expand_pattern(pattern));\n+        let pattern = cx.pattern_arena.alloc(DeconstructedPat::from_pat(cx, &pattern));\n         if !patcx.errors.is_empty() {\n             *have_errors = true;\n         }"}, {"sha": "87a85797613b4079d30726b054da4361c5a7cf90", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "patch": "@@ -5,25 +5,26 @@\n //!\n //! It is modeled on the rustc module `rustc_mir_build::thir::pattern`.\n \n-mod deconstruct_pat;\n mod pat_util;\n \n+pub(crate) mod deconstruct_pat;\n pub(crate) mod usefulness;\n \n-use hir_def::{body::Body, EnumVariantId, LocalFieldId, VariantId};\n-use la_arena::Idx;\n+use hir_def::{body::Body, expr::PatId, EnumVariantId, LocalFieldId, VariantId};\n+use stdx::never;\n \n-use crate::{db::HirDatabase, InferenceResult, Interner, Substitution, Ty, TyKind};\n+use crate::{\n+    db::HirDatabase, infer::BindingMode, InferenceResult, Interner, Substitution, Ty, TyKind,\n+};\n \n use self::pat_util::EnumerateAndAdjustIterator;\n \n pub(crate) use self::usefulness::MatchArm;\n \n-pub(crate) type PatId = Idx<Pat>;\n-\n #[derive(Clone, Debug)]\n pub(crate) enum PatternError {\n     Unimplemented,\n+    UnexpectedType,\n     UnresolvedVariant,\n     MissingField,\n     ExtraFields,\n@@ -41,12 +42,6 @@ pub(crate) struct Pat {\n     pub(crate) kind: Box<PatKind>,\n }\n \n-impl Pat {\n-    pub(crate) fn wildcard_from_ty(ty: Ty) -> Self {\n-        Pat { ty, kind: Box::new(PatKind::Wild) }\n-    }\n-}\n-\n /// Close relative to `rustc_mir_build::thir::pattern::PatKind`\n #[derive(Clone, Debug, PartialEq)]\n pub(crate) enum PatKind {\n@@ -100,7 +95,7 @@ impl<'a> PatCtxt<'a> {\n         Self { db, infer, body, errors: Vec::new() }\n     }\n \n-    pub(crate) fn lower_pattern(&mut self, pat: hir_def::expr::PatId) -> Pat {\n+    pub(crate) fn lower_pattern(&mut self, pat: PatId) -> Pat {\n         // XXX(iDawer): Collecting pattern adjustments feels imprecise to me.\n         // When lowering of & and box patterns are implemented this should be tested\n         // in a manner of `match_ergonomics_issue_9095` test.\n@@ -116,7 +111,7 @@ impl<'a> PatCtxt<'a> {\n         )\n     }\n \n-    fn lower_pattern_unadjusted(&mut self, pat: hir_def::expr::PatId) -> Pat {\n+    fn lower_pattern_unadjusted(&mut self, pat: PatId) -> Pat {\n         let mut ty = &self.infer[pat];\n         let variant = self.infer.variant_resolution_for_pat(pat);\n \n@@ -138,9 +133,16 @@ impl<'a> PatCtxt<'a> {\n                 PatKind::Leaf { subpatterns }\n             }\n \n-            hir_def::expr::Pat::Bind { subpat, .. } => {\n-                if let TyKind::Ref(.., rty) = ty.kind(Interner) {\n-                    ty = rty;\n+            hir_def::expr::Pat::Bind { ref name, subpat, .. } => {\n+                let bm = self.infer.pat_binding_modes[&pat];\n+                match (bm, ty.kind(Interner)) {\n+                    (BindingMode::Ref(_), TyKind::Ref(.., rty)) => ty = rty,\n+                    (BindingMode::Ref(_), _) => {\n+                        never!(\"`ref {}` has wrong type {:?}\", name, ty);\n+                        self.errors.push(PatternError::UnexpectedType);\n+                        return Pat { ty: ty.clone(), kind: PatKind::Wild.into() };\n+                    }\n+                    _ => (),\n                 }\n                 PatKind::Binding { subpattern: self.lower_opt_pattern(subpat) }\n             }\n@@ -189,7 +191,7 @@ impl<'a> PatCtxt<'a> {\n \n     fn lower_tuple_subpats(\n         &mut self,\n-        pats: &[hir_def::expr::PatId],\n+        pats: &[PatId],\n         expected_len: usize,\n         ellipsis: Option<usize>,\n     ) -> Vec<FieldPat> {\n@@ -207,17 +209,17 @@ impl<'a> PatCtxt<'a> {\n             .collect()\n     }\n \n-    fn lower_patterns(&mut self, pats: &[hir_def::expr::PatId]) -> Vec<Pat> {\n+    fn lower_patterns(&mut self, pats: &[PatId]) -> Vec<Pat> {\n         pats.iter().map(|&p| self.lower_pattern(p)).collect()\n     }\n \n-    fn lower_opt_pattern(&mut self, pat: Option<hir_def::expr::PatId>) -> Option<Pat> {\n+    fn lower_opt_pattern(&mut self, pat: Option<PatId>) -> Option<Pat> {\n         pat.map(|p| self.lower_pattern(p))\n     }\n \n     fn lower_variant_or_leaf(\n         &mut self,\n-        pat: hir_def::expr::PatId,\n+        pat: PatId,\n         ty: &Ty,\n         subpatterns: Vec<FieldPat>,\n     ) -> PatKind {\n@@ -244,7 +246,7 @@ impl<'a> PatCtxt<'a> {\n         kind\n     }\n \n-    fn lower_path(&mut self, pat: hir_def::expr::PatId, _path: &hir_def::path::Path) -> Pat {\n+    fn lower_path(&mut self, pat: PatId, _path: &hir_def::path::Path) -> Pat {\n         let ty = &self.infer[pat];\n \n         let pat_from_kind = |kind| Pat { ty: ty.clone(), kind: Box::new(kind) };"}, {"sha": "84ded517ba7ad2cc25943f0805fdb2aff64020df", "filename": "crates/hir_ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 391, "deletions": 271, "changes": 662, "blob_url": "https://github.com/rust-lang/rust/blob/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "patch": "@@ -42,6 +42,7 @@\n //! wildcards, see [`SplitWildcard`]; for integer ranges, see [`SplitIntRange`].\n \n use std::{\n+    cell::Cell,\n     cmp::{max, min},\n     iter::once,\n     ops::RangeInclusive,\n@@ -52,15 +53,32 @@ use smallvec::{smallvec, SmallVec};\n use stdx::never;\n use syntax::SmolStr;\n \n-use crate::{AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n+use crate::{infer::normalize, AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n \n use super::{\n-    usefulness::{MatchCheckCtx, PatCtxt},\n-    FieldPat, Pat, PatId, PatKind,\n+    usefulness::{helper::Captures, MatchCheckCtx, PatCtxt},\n+    Pat, PatKind,\n };\n \n use self::Constructor::*;\n \n+/// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n+fn expand_or_pat(pat: &Pat) -> Vec<&Pat> {\n+    fn expand<'p>(pat: &'p Pat, vec: &mut Vec<&'p Pat>) {\n+        if let PatKind::Or { pats } = pat.kind.as_ref() {\n+            for pat in pats {\n+                expand(pat, vec);\n+            }\n+        } else {\n+            vec.push(pat)\n+        }\n+    }\n+\n+    let mut pats = Vec::new();\n+    expand(pat, &mut pats);\n+    pats\n+}\n+\n /// [Constructor] uses this in umimplemented variants.\n /// It allows porting match expressions from upstream algorithm without losing semantics.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -241,6 +259,10 @@ pub(super) struct Slice {\n }\n \n impl Slice {\n+    fn arity(self) -> usize {\n+        unimplemented!()\n+    }\n+\n     /// See `Constructor::is_covered_by`\n     fn is_covered_by(self, _other: Self) -> bool {\n         unimplemented!() // never called as Slice contains Void\n@@ -278,17 +300,24 @@ pub(super) enum Constructor {\n     /// for those types for which we cannot list constructors explicitly, like `f64` and `str`.\n     NonExhaustive,\n     /// Stands for constructors that are not seen in the matrix, as explained in the documentation\n-    /// for [`SplitWildcard`].\n-    Missing,\n+    /// for [`SplitWildcard`]. The carried `bool` is used for the `non_exhaustive_omitted_patterns`\n+    /// lint.\n+    Missing { nonexhaustive_enum_missing_real_variants: bool },\n     /// Wildcard pattern.\n     Wildcard,\n+    /// Or-pattern.\n+    Or,\n }\n \n impl Constructor {\n     pub(super) fn is_wildcard(&self) -> bool {\n         matches!(self, Wildcard)\n     }\n \n+    pub(super) fn is_non_exhaustive(&self) -> bool {\n+        matches!(self, NonExhaustive)\n+    }\n+\n     fn as_int_range(&self) -> Option<&IntRange> {\n         match self {\n             IntRange(range) => Some(range),\n@@ -303,6 +332,14 @@ impl Constructor {\n         }\n     }\n \n+    pub(super) fn is_unstable_variant(&self, _pcx: PatCtxt<'_, '_>) -> bool {\n+        false //FIXME: implement this\n+    }\n+\n+    pub(super) fn is_doc_hidden_variant(&self, _pcx: PatCtxt<'_, '_>) -> bool {\n+        false //FIXME: implement this\n+    }\n+\n     fn variant_id_for_adt(&self, adt: hir_def::AdtId) -> VariantId {\n         match *self {\n             Variant(id) => id.into(),\n@@ -318,16 +355,39 @@ impl Constructor {\n         }\n     }\n \n-    /// Determines the constructor that the given pattern can be specialized to.\n-    pub(super) fn from_pat(cx: &MatchCheckCtx<'_>, pat: PatId) -> Self {\n-        match cx.pattern_arena.borrow()[pat].kind.as_ref() {\n-            PatKind::Binding { .. } | PatKind::Wild => Wildcard,\n-            PatKind::Leaf { .. } | PatKind::Deref { .. } => Single,\n-            &PatKind::Variant { enum_variant, .. } => Variant(enum_variant),\n-            &PatKind::LiteralBool { value } => IntRange(IntRange::from_bool(value)),\n-            PatKind::Or { .. } => {\n-                never!(\"Or-pattern should have been expanded earlier on.\");\n-                Wildcard\n+    /// The number of fields for this constructor. This must be kept in sync with\n+    /// `Fields::wildcards`.\n+    pub(super) fn arity(&self, pcx: PatCtxt<'_, '_>) -> usize {\n+        match self {\n+            Single | Variant(_) => match *pcx.ty.kind(Interner) {\n+                TyKind::Tuple(arity, ..) => arity,\n+                TyKind::Ref(..) => 1,\n+                TyKind::Adt(adt, ..) => {\n+                    if adt_is_box(adt.0, pcx.cx) {\n+                        // The only legal patterns of type `Box` (outside `std`) are `_` and box\n+                        // patterns. If we're here we can assume this is a box pattern.\n+                        1\n+                    } else {\n+                        let variant = self.variant_id_for_adt(adt.0);\n+                        Fields::list_variant_nonhidden_fields(pcx.cx, pcx.ty, variant).count()\n+                    }\n+                }\n+                _ => {\n+                    never!(\"Unexpected type for `Single` constructor: {:?}\", pcx.ty);\n+                    0\n+                }\n+            },\n+            Slice(slice) => slice.arity(),\n+            Str(..)\n+            | FloatRange(..)\n+            | IntRange(..)\n+            | NonExhaustive\n+            | Opaque\n+            | Missing { .. }\n+            | Wildcard => 0,\n+            Or => {\n+                never!(\"The `Or` constructor doesn't have a fixed arity\");\n+                0\n             }\n         }\n     }\n@@ -347,7 +407,7 @@ impl Constructor {\n     /// matrix, unless all of them are.\n     pub(super) fn split<'a>(\n         &self,\n-        pcx: PatCtxt<'_>,\n+        pcx: PatCtxt<'_, '_>,\n         ctors: impl Iterator<Item = &'a Constructor> + Clone,\n     ) -> SmallVec<[Self; 1]> {\n         match self {\n@@ -375,13 +435,13 @@ impl Constructor {\n     /// this checks for inclusion.\n     // We inline because this has a single call site in `Matrix::specialize_constructor`.\n     #[inline]\n-    pub(super) fn is_covered_by(&self, _pcx: PatCtxt<'_>, other: &Self) -> bool {\n+    pub(super) fn is_covered_by(&self, _pcx: PatCtxt<'_, '_>, other: &Self) -> bool {\n         // This must be kept in sync with `is_covered_by_any`.\n         match (self, other) {\n             // Wildcards cover anything\n             (_, Wildcard) => true,\n             // The missing ctors are not covered by anything in the matrix except wildcards.\n-            (Missing | Wildcard, _) => false,\n+            (Missing { .. } | Wildcard, _) => false,\n \n             (Single, Single) => true,\n             (Variant(self_id), Variant(other_id)) => self_id == other_id,\n@@ -411,7 +471,7 @@ impl Constructor {\n     /// Faster version of `is_covered_by` when applied to many constructors. `used_ctors` is\n     /// assumed to be built from `matrix.head_ctors()` with wildcards filtered out, and `self` is\n     /// assumed to have been split from a wildcard.\n-    fn is_covered_by_any(&self, _pcx: PatCtxt<'_>, used_ctors: &[Constructor]) -> bool {\n+    fn is_covered_by_any(&self, _pcx: PatCtxt<'_, '_>, used_ctors: &[Constructor]) -> bool {\n         if used_ctors.is_empty() {\n             return false;\n         }\n@@ -431,7 +491,7 @@ impl Constructor {\n                 .any(|other| slice.is_covered_by(other)),\n             // This constructor is never covered by anything else\n             NonExhaustive => false,\n-            Str(..) | FloatRange(..) | Opaque | Missing | Wildcard => {\n+            Str(..) | FloatRange(..) | Opaque | Missing { .. } | Wildcard | Or => {\n                 never!(\"found unexpected ctor in all_ctors: {:?}\", self);\n                 true\n             }\n@@ -463,7 +523,7 @@ pub(super) struct SplitWildcard {\n }\n \n impl SplitWildcard {\n-    pub(super) fn new(pcx: PatCtxt<'_>) -> Self {\n+    pub(super) fn new(pcx: PatCtxt<'_, '_>) -> Self {\n         let cx = pcx.cx;\n         let make_range = |start, end, scalar| IntRange(IntRange::from_range(start, end, scalar));\n \n@@ -483,7 +543,7 @@ impl SplitWildcard {\n             TyKind::Scalar(Scalar::Bool) => smallvec![make_range(0, 1, Scalar::Bool)],\n             // TyKind::Array(..) if ... => unhandled(),\n             TyKind::Array(..) | TyKind::Slice(..) => unhandled(),\n-            &TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ref _substs) => {\n+            &TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ..) => {\n                 let enum_data = cx.db.enum_data(enum_id);\n \n                 // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n@@ -502,27 +562,35 @@ impl SplitWildcard {\n                 //\n                 // we don't want to show every possible IO error, but instead have only `_` as the\n                 // witness.\n-                let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive_enum(enum_id);\n+                let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive_enum(pcx.ty);\n+\n+                let is_exhaustive_pat_feature = cx.feature_exhaustive_patterns();\n \n                 // If `exhaustive_patterns` is disabled and our scrutinee is an empty enum, we treat it\n                 // as though it had an \"unknown\" constructor to avoid exposing its emptiness. The\n                 // exception is if the pattern is at the top level, because we want empty matches to be\n                 // considered exhaustive.\n                 let is_secretly_empty = enum_data.variants.is_empty()\n-                    && !cx.feature_exhaustive_patterns()\n+                    && !is_exhaustive_pat_feature\n                     && !pcx.is_top_level;\n \n+                let mut ctors: SmallVec<[_; 1]> = enum_data\n+                    .variants\n+                    .iter()\n+                    .filter(|&(_, _v)| {\n+                        // If `exhaustive_patterns` is enabled, we exclude variants known to be\n+                        // uninhabited.\n+                        let is_uninhabited = is_exhaustive_pat_feature\n+                            && unimplemented!(\"after MatchCheckCtx.feature_exhaustive_patterns()\");\n+                        !is_uninhabited\n+                    })\n+                    .map(|(local_id, _)| Variant(EnumVariantId { parent: enum_id, local_id }))\n+                    .collect();\n+\n                 if is_secretly_empty || is_declared_nonexhaustive {\n-                    smallvec![NonExhaustive]\n-                } else if cx.feature_exhaustive_patterns() {\n-                    unimplemented!() // see MatchCheckCtx.feature_exhaustive_patterns()\n-                } else {\n-                    enum_data\n-                        .variants\n-                        .iter()\n-                        .map(|(local_id, ..)| Variant(EnumVariantId { parent: enum_id, local_id }))\n-                        .collect()\n+                    ctors.push(NonExhaustive);\n                 }\n+                ctors\n             }\n             TyKind::Scalar(Scalar::Char) => unhandled(),\n             TyKind::Scalar(Scalar::Int(..) | Scalar::Uint(..)) => unhandled(),\n@@ -535,14 +603,15 @@ impl SplitWildcard {\n             // This type is one for which we cannot list constructors, like `str` or `f64`.\n             _ => smallvec![NonExhaustive],\n         };\n+\n         SplitWildcard { matrix_ctors: Vec::new(), all_ctors }\n     }\n \n     /// Pass a set of constructors relative to which to split this one. Don't call twice, it won't\n     /// do what you want.\n     pub(super) fn split<'a>(\n         &mut self,\n-        pcx: PatCtxt<'_>,\n+        pcx: PatCtxt<'_, '_>,\n         ctors: impl Iterator<Item = &'a Constructor> + Clone,\n     ) {\n         // Since `all_ctors` never contains wildcards, this won't recurse further.\n@@ -552,21 +621,21 @@ impl SplitWildcard {\n     }\n \n     /// Whether there are any value constructors for this type that are not present in the matrix.\n-    fn any_missing(&self, pcx: PatCtxt<'_>) -> bool {\n+    fn any_missing(&self, pcx: PatCtxt<'_, '_>) -> bool {\n         self.iter_missing(pcx).next().is_some()\n     }\n \n     /// Iterate over the constructors for this type that are not present in the matrix.\n-    pub(super) fn iter_missing<'a>(\n+    pub(super) fn iter_missing<'a, 'p>(\n         &'a self,\n-        pcx: PatCtxt<'a>,\n-    ) -> impl Iterator<Item = &'a Constructor> {\n+        pcx: PatCtxt<'a, 'p>,\n+    ) -> impl Iterator<Item = &'a Constructor> + Captures<'p> {\n         self.all_ctors.iter().filter(move |ctor| !ctor.is_covered_by_any(pcx, &self.matrix_ctors))\n     }\n \n     /// Return the set of constructors resulting from splitting the wildcard. As explained at the\n     /// top of the file, if any constructors are missing we can ignore the present ones.\n-    fn into_ctors(self, pcx: PatCtxt<'_>) -> SmallVec<[Constructor; 1]> {\n+    fn into_ctors(self, pcx: PatCtxt<'_, '_>) -> SmallVec<[Constructor; 1]> {\n         if self.any_missing(pcx) {\n             // Some constructors are missing, thus we can specialize with the special `Missing`\n             // constructor, which stands for those constructors that are not seen in the matrix,\n@@ -597,7 +666,15 @@ impl SplitWildcard {\n             // sometimes prefer reporting the list of constructors instead of just `_`.\n             let report_when_all_missing = pcx.is_top_level && !IntRange::is_integral(pcx.ty);\n             let ctor = if !self.matrix_ctors.is_empty() || report_when_all_missing {\n-                Missing\n+                if pcx.is_non_exhaustive {\n+                    Missing {\n+                        nonexhaustive_enum_missing_real_variants: self\n+                            .iter_missing(pcx)\n+                            .any(|c| !(c.is_non_exhaustive() || c.is_unstable_variant(pcx))),\n+                    }\n+                } else {\n+                    Missing { nonexhaustive_enum_missing_real_variants: false }\n+                }\n             } else {\n                 Wildcard\n             };\n@@ -611,291 +688,334 @@ impl SplitWildcard {\n \n /// A value can be decomposed into a constructor applied to some fields. This struct represents\n /// those fields, generalized to allow patterns in each field. See also `Constructor`.\n-/// This is constructed from a constructor using [`Fields::wildcards()`].\n ///\n-/// If a private or `non_exhaustive` field is uninhabited, the code mustn't observe that it is\n-/// uninhabited. For that, we filter these fields out of the matrix. This is handled automatically\n-/// in `Fields`. This filtering is uncommon in practice, because uninhabited fields are rarely used,\n-/// so we avoid it when possible to preserve performance.\n-#[derive(Debug, Clone)]\n-pub(super) enum Fields {\n-    /// Lists of patterns that don't contain any filtered fields.\n-    /// `Slice` and `Vec` behave the same; the difference is only to avoid allocating and\n-    /// triple-dereferences when possible. Frankly this is premature optimization, I (Nadrieril)\n-    /// have not measured if it really made a difference.\n-    Vec(SmallVec<[PatId; 2]>),\n+/// This is constructed for a constructor using [`Fields::wildcards()`]. The idea is that\n+/// [`Fields::wildcards()`] constructs a list of fields where all entries are wildcards, and then\n+/// given a pattern we fill some of the fields with its subpatterns.\n+/// In the following example `Fields::wildcards` returns `[_, _, _, _]`. Then in\n+/// `extract_pattern_arguments` we fill some of the entries, and the result is\n+/// `[Some(0), _, _, _]`.\n+/// ```rust\n+/// let x: [Option<u8>; 4] = foo();\n+/// match x {\n+///     [Some(0), ..] => {}\n+/// }\n+/// ```\n+///\n+/// Note that the number of fields of a constructor may not match the fields declared in the\n+/// original struct/variant. This happens if a private or `non_exhaustive` field is uninhabited,\n+/// because the code mustn't observe that it is uninhabited. In that case that field is not\n+/// included in `fields`. For that reason, when you have a `mir::Field` you must use\n+/// `index_with_declared_idx`.\n+#[derive(Clone, Copy)]\n+pub(super) struct Fields<'p> {\n+    fields: &'p [DeconstructedPat<'p>],\n }\n \n-impl Fields {\n-    /// Internal use. Use `Fields::wildcards()` instead.\n-    /// Must not be used if the pattern is a field of a struct/tuple/variant.\n-    fn from_single_pattern(pat: PatId) -> Self {\n-        Fields::Vec(smallvec![pat])\n+impl<'p> Fields<'p> {\n+    fn empty() -> Self {\n+        Fields { fields: &[] }\n     }\n \n-    /// Convenience; internal use.\n-    fn wildcards_from_tys(cx: &MatchCheckCtx<'_>, tys: impl IntoIterator<Item = Ty>) -> Self {\n-        let wilds = tys.into_iter().map(Pat::wildcard_from_ty);\n-        let pats = wilds.map(|pat| cx.alloc_pat(pat)).collect();\n-        Fields::Vec(pats)\n+    fn singleton(cx: &MatchCheckCtx<'_, 'p>, field: DeconstructedPat<'p>) -> Self {\n+        let field = cx.pattern_arena.alloc(field);\n+        Fields { fields: std::slice::from_ref(field) }\n     }\n \n-    /// Creates a new list of wildcard fields for a given constructor.\n-    pub(crate) fn wildcards(pcx: PatCtxt<'_>, constructor: &Constructor) -> Self {\n-        let ty = pcx.ty;\n-        let cx = pcx.cx;\n-        let wildcard_from_ty = |ty: &Ty| cx.alloc_pat(Pat::wildcard_from_ty(ty.clone()));\n+    pub(super) fn from_iter(\n+        cx: &MatchCheckCtx<'_, 'p>,\n+        fields: impl IntoIterator<Item = DeconstructedPat<'p>>,\n+    ) -> Self {\n+        let fields: &[_] = cx.pattern_arena.alloc_extend(fields);\n+        Fields { fields }\n+    }\n+\n+    fn wildcards_from_tys(cx: &MatchCheckCtx<'_, 'p>, tys: impl IntoIterator<Item = Ty>) -> Self {\n+        Fields::from_iter(cx, tys.into_iter().map(DeconstructedPat::wildcard))\n+    }\n+\n+    // In the cases of either a `#[non_exhaustive]` field list or a non-public field, we hide\n+    // uninhabited fields in order not to reveal the uninhabitedness of the whole variant.\n+    // This lists the fields we keep along with their types.\n+    fn list_variant_nonhidden_fields<'a>(\n+        cx: &'a MatchCheckCtx<'a, 'p>,\n+        ty: &'a Ty,\n+        variant: VariantId,\n+    ) -> impl Iterator<Item = (LocalFieldId, Ty)> + Captures<'a> + Captures<'p> {\n+        let (adt, substs) = ty.as_adt().unwrap();\n+\n+        let adt_is_local = variant.module(cx.db.upcast()).krate() == cx.module.krate();\n+        // Whether we must not match the fields of this variant exhaustively.\n+        let is_non_exhaustive = is_field_list_non_exhaustive(variant, cx) && !adt_is_local;\n+\n+        let visibility = cx.db.field_visibilities(variant);\n+        let field_ty = cx.db.field_types(variant);\n+        let fields_len = variant.variant_data(cx.db.upcast()).fields().len() as u32;\n+\n+        (0..fields_len).map(|idx| LocalFieldId::from_raw(idx.into())).filter_map(move |fid| {\n+            let ty = field_ty[fid].clone().substitute(Interner, substs);\n+            let ty = normalize(cx.db, cx.body, ty);\n+            let is_visible = matches!(adt, hir_def::AdtId::EnumId(..))\n+                || visibility[fid].is_visible_from(cx.db.upcast(), cx.module);\n+            let is_uninhabited = cx.is_uninhabited(&ty);\n+\n+            if is_uninhabited && (!is_visible || is_non_exhaustive) {\n+                None\n+            } else {\n+                Some((fid, ty))\n+            }\n+        })\n+    }\n \n+    /// Creates a new list of wildcard fields for a given constructor. The result must have a\n+    /// length of `constructor.arity()`.\n+    pub(crate) fn wildcards(\n+        cx: &MatchCheckCtx<'_, 'p>,\n+        ty: &Ty,\n+        constructor: &Constructor,\n+    ) -> Self {\n         let ret = match constructor {\n             Single | Variant(_) => match ty.kind(Interner) {\n                 TyKind::Tuple(_, substs) => {\n                     let tys = substs.iter(Interner).map(|ty| ty.assert_ty_ref(Interner));\n                     Fields::wildcards_from_tys(cx, tys.cloned())\n                 }\n-                TyKind::Ref(.., rty) => Fields::from_single_pattern(wildcard_from_ty(rty)),\n+                TyKind::Ref(.., rty) => Fields::wildcards_from_tys(cx, once(rty.clone())),\n                 &TyKind::Adt(AdtId(adt), ref substs) => {\n                     if adt_is_box(adt, cx) {\n-                        // Use T as the sub pattern type of Box<T>.\n-                        let subst_ty = substs.at(Interner, 0).assert_ty_ref(Interner);\n-                        Fields::from_single_pattern(wildcard_from_ty(subst_ty))\n+                        // The only legal patterns of type `Box` (outside `std`) are `_` and box\n+                        // patterns. If we're here we can assume this is a box pattern.\n+                        let subst_ty = substs.at(Interner, 0).assert_ty_ref(Interner).clone();\n+                        Fields::wildcards_from_tys(cx, once(subst_ty))\n                     } else {\n-                        let variant_id = constructor.variant_id_for_adt(adt);\n-                        let adt_is_local =\n-                            variant_id.module(cx.db.upcast()).krate() == cx.module.krate();\n-                        // Whether we must not match the fields of this variant exhaustively.\n-                        let is_non_exhaustive =\n-                            is_field_list_non_exhaustive(variant_id, cx) && !adt_is_local;\n-\n-                        cov_mark::hit!(match_check_wildcard_expanded_to_substitutions);\n-                        let field_ty_data = cx.db.field_types(variant_id);\n-                        let field_tys = || {\n-                            field_ty_data\n-                                .iter()\n-                                .map(|(_, binders)| binders.clone().substitute(Interner, substs))\n-                        };\n-\n-                        // In the following cases, we don't need to filter out any fields. This is\n-                        // the vast majority of real cases, since uninhabited fields are uncommon.\n-                        let has_no_hidden_fields = (matches!(adt, hir_def::AdtId::EnumId(_))\n-                            && !is_non_exhaustive)\n-                            || !field_tys().any(|ty| cx.is_uninhabited(&ty));\n-\n-                        if has_no_hidden_fields {\n-                            Fields::wildcards_from_tys(cx, field_tys())\n-                        } else {\n-                            //FIXME(iDawer): see MatchCheckCtx::is_uninhabited, has_no_hidden_fields is always true\n-                            unimplemented!(\"exhaustive_patterns feature\")\n-                        }\n+                        let variant = constructor.variant_id_for_adt(adt);\n+                        let tys = Fields::list_variant_nonhidden_fields(cx, ty, variant)\n+                            .map(|(_, ty)| ty);\n+                        Fields::wildcards_from_tys(cx, tys)\n                     }\n                 }\n                 ty_kind => {\n                     never!(\"Unexpected type for `Single` constructor: {:?}\", ty_kind);\n-                    Fields::from_single_pattern(wildcard_from_ty(ty))\n+                    Fields::wildcards_from_tys(cx, once(ty.clone()))\n                 }\n             },\n             Slice(..) => {\n                 unimplemented!()\n             }\n-            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque | Missing\n-            | Wildcard => Fields::Vec(Default::default()),\n+            Str(..)\n+            | FloatRange(..)\n+            | IntRange(..)\n+            | NonExhaustive\n+            | Opaque\n+            | Missing { .. }\n+            | Wildcard => Fields::empty(),\n+            Or => {\n+                never!(\"called `Fields::wildcards` on an `Or` ctor\");\n+                Fields::empty()\n+            }\n         };\n         ret\n     }\n \n-    /// Apply a constructor to a list of patterns, yielding a new pattern. `self`\n-    /// must have as many elements as this constructor's arity.\n-    ///\n-    /// This is roughly the inverse of `specialize_constructor`.\n-    ///\n-    /// Examples:\n-    /// `ctor`: `Constructor::Single`\n-    /// `ty`: `Foo(u32, u32, u32)`\n-    /// `self`: `[10, 20, _]`\n-    /// returns `Foo(10, 20, _)`\n-    ///\n-    /// `ctor`: `Constructor::Variant(Option::Some)`\n-    /// `ty`: `Option<bool>`\n-    /// `self`: `[false]`\n-    /// returns `Some(false)`\n-    pub(super) fn apply(self, pcx: PatCtxt<'_>, ctor: &Constructor) -> Pat {\n-        let subpatterns_and_indices = self.patterns_and_indices();\n-        let mut subpatterns =\n-            subpatterns_and_indices.iter().map(|&(_, p)| pcx.cx.pattern_arena.borrow()[p].clone());\n-        // FIXME(iDawer) witnesses are not yet used\n-        const UNHANDLED: PatKind = PatKind::Wild;\n-\n-        let pat = match ctor {\n-            Single | Variant(_) => match pcx.ty.kind(Interner) {\n-                TyKind::Adt(..) | TyKind::Tuple(..) => {\n-                    // We want the real indices here.\n-                    let subpatterns = subpatterns_and_indices\n-                        .iter()\n-                        .map(|&(field, pat)| FieldPat {\n-                            field,\n-                            pattern: pcx.cx.pattern_arena.borrow()[pat].clone(),\n-                        })\n-                        .collect();\n-\n-                    if let Some((hir_def::AdtId::EnumId(_), substs)) = pcx.ty.as_adt() {\n-                        let enum_variant = match ctor {\n-                            &Variant(id) => id,\n-                            _ => unreachable!(),\n-                        };\n-                        PatKind::Variant { substs: substs.clone(), enum_variant, subpatterns }\n-                    } else {\n-                        PatKind::Leaf { subpatterns }\n-                    }\n-                }\n-                // Note: given the expansion of `&str` patterns done in `expand_pattern`, we should\n-                // be careful to reconstruct the correct constant pattern here. However a string\n-                // literal pattern will never be reported as a non-exhaustiveness witness, so we\n-                // can ignore this issue.\n-                TyKind::Ref(..) => PatKind::Deref { subpattern: subpatterns.next().unwrap() },\n-                TyKind::Slice(..) | TyKind::Array(..) => {\n-                    never!(\"bad slice pattern {:?} {:?}\", ctor, pcx.ty);\n-                    PatKind::Wild\n-                }\n-                _ => PatKind::Wild,\n-            },\n-            Constructor::Slice(_) => UNHANDLED,\n-            Str(_) => UNHANDLED,\n-            FloatRange(..) => UNHANDLED,\n-            Constructor::IntRange(_) => UNHANDLED,\n-            NonExhaustive => PatKind::Wild,\n-            Wildcard => return Pat::wildcard_from_ty(pcx.ty.clone()),\n-            Opaque => {\n-                never!(\"we should not try to apply an opaque constructor\");\n-                PatKind::Wild\n-            }\n-            Missing => {\n-                never!(\n-                    \"trying to apply the `Missing` constructor; \\\n-                    this should have been done in `apply_constructors`\",\n-                );\n-                PatKind::Wild\n-            }\n-        };\n-\n-        Pat { ty: pcx.ty.clone(), kind: Box::new(pat) }\n+    /// Returns the list of patterns.\n+    pub(super) fn iter_patterns<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = &'p DeconstructedPat<'p>> + Captures<'a> {\n+        self.fields.iter()\n     }\n+}\n \n-    /// Returns the number of patterns. This is the same as the arity of the constructor used to\n-    /// construct `self`.\n-    pub(super) fn len(&self) -> usize {\n-        match self {\n-            Fields::Vec(pats) => pats.len(),\n-        }\n-    }\n+/// Values and patterns can be represented as a constructor applied to some fields. This represents\n+/// a pattern in this form.\n+/// This also keeps track of whether the pattern has been found reachable during analysis. For this\n+/// reason we should be careful not to clone patterns for which we care about that. Use\n+/// `clone_and_forget_reachability` if you're sure.\n+pub(crate) struct DeconstructedPat<'p> {\n+    ctor: Constructor,\n+    fields: Fields<'p>,\n+    ty: Ty,\n+    reachable: Cell<bool>,\n+}\n \n-    /// Returns the list of patterns along with the corresponding field indices.\n-    fn patterns_and_indices(&self) -> SmallVec<[(LocalFieldId, PatId); 2]> {\n-        match self {\n-            Fields::Vec(pats) => pats\n-                .iter()\n-                .copied()\n-                .enumerate()\n-                .map(|(i, p)| (LocalFieldId::from_raw((i as u32).into()), p))\n-                .collect(),\n-        }\n+impl<'p> DeconstructedPat<'p> {\n+    pub(super) fn wildcard(ty: Ty) -> Self {\n+        Self::new(Wildcard, Fields::empty(), ty)\n     }\n \n-    pub(super) fn into_patterns(self) -> SmallVec<[PatId; 2]> {\n-        match self {\n-            Fields::Vec(pats) => pats,\n-        }\n+    pub(super) fn new(ctor: Constructor, fields: Fields<'p>, ty: Ty) -> Self {\n+        DeconstructedPat { ctor, fields, ty, reachable: Cell::new(false) }\n     }\n \n-    /// Overrides some of the fields with the provided patterns. Exactly like\n-    /// `replace_fields_indexed`, except that it takes `FieldPat`s as input.\n-    fn replace_with_fieldpats(\n-        &self,\n-        new_pats: impl IntoIterator<Item = (LocalFieldId, PatId)>,\n-    ) -> Self {\n-        self.replace_fields_indexed(\n-            new_pats.into_iter().map(|(field, pat)| (u32::from(field.into_raw()) as usize, pat)),\n-        )\n+    /// Construct a pattern that matches everything that starts with this constructor.\n+    /// For example, if `ctor` is a `Constructor::Variant` for `Option::Some`, we get the pattern\n+    /// `Some(_)`.\n+    pub(super) fn wild_from_ctor(pcx: PatCtxt<'_, 'p>, ctor: Constructor) -> Self {\n+        let fields = Fields::wildcards(pcx.cx, pcx.ty, &ctor);\n+        DeconstructedPat::new(ctor, fields, pcx.ty.clone())\n     }\n \n-    /// Overrides some of the fields with the provided patterns. This is used when a pattern\n-    /// defines some fields but not all, for example `Foo { field1: Some(_), .. }`: here we start\n-    /// with a `Fields` that is just one wildcard per field of the `Foo` struct, and override the\n-    /// entry corresponding to `field1` with the pattern `Some(_)`. This is also used for slice\n-    /// patterns for the same reason.\n-    fn replace_fields_indexed(&self, new_pats: impl IntoIterator<Item = (usize, PatId)>) -> Self {\n-        let mut fields = self.clone();\n+    /// Clone this value. This method emphasizes that cloning loses reachability information and\n+    /// should be done carefully.\n+    pub(super) fn clone_and_forget_reachability(&self) -> Self {\n+        DeconstructedPat::new(self.ctor.clone(), self.fields, self.ty.clone())\n+    }\n \n-        match &mut fields {\n-            Fields::Vec(pats) => {\n-                for (i, pat) in new_pats {\n-                    if let Some(p) = pats.get_mut(i) {\n-                        *p = pat;\n+    pub(crate) fn from_pat(cx: &MatchCheckCtx<'_, 'p>, pat: &Pat) -> Self {\n+        let mkpat = |pat| DeconstructedPat::from_pat(cx, pat);\n+        let ctor;\n+        let fields;\n+        match pat.kind.as_ref() {\n+            PatKind::Binding { subpattern: Some(subpat) } => return mkpat(subpat),\n+            PatKind::Binding { subpattern: None } | PatKind::Wild => {\n+                ctor = Wildcard;\n+                fields = Fields::empty();\n+            }\n+            PatKind::Deref { subpattern } => {\n+                ctor = Single;\n+                fields = Fields::singleton(cx, mkpat(subpattern));\n+            }\n+            PatKind::Leaf { subpatterns } | PatKind::Variant { subpatterns, .. } => {\n+                match pat.ty.kind(Interner) {\n+                    TyKind::Tuple(_, substs) => {\n+                        ctor = Single;\n+                        let mut wilds: SmallVec<[_; 2]> = substs\n+                            .iter(Interner)\n+                            .map(|arg| arg.assert_ty_ref(Interner).clone())\n+                            .map(DeconstructedPat::wildcard)\n+                            .collect();\n+                        for pat in subpatterns {\n+                            let idx: u32 = pat.field.into_raw().into();\n+                            wilds[idx as usize] = mkpat(&pat.pattern);\n+                        }\n+                        fields = Fields::from_iter(cx, wilds)\n+                    }\n+                    TyKind::Adt(adt, substs) if adt_is_box(adt.0, cx) => {\n+                        // The only legal patterns of type `Box` (outside `std`) are `_` and box\n+                        // patterns. If we're here we can assume this is a box pattern.\n+                        // FIXME(Nadrieril): A `Box` can in theory be matched either with `Box(_,\n+                        // _)` or a box pattern. As a hack to avoid an ICE with the former, we\n+                        // ignore other fields than the first one. This will trigger an error later\n+                        // anyway.\n+                        // See https://github.com/rust-lang/rust/issues/82772 ,\n+                        // explanation: https://github.com/rust-lang/rust/pull/82789#issuecomment-796921977\n+                        // The problem is that we can't know from the type whether we'll match\n+                        // normally or through box-patterns. We'll have to figure out a proper\n+                        // solution when we introduce generalized deref patterns. Also need to\n+                        // prevent mixing of those two options.\n+                        let pat =\n+                            subpatterns.iter().find(|pat| pat.field.into_raw() == 0u32.into());\n+                        let field = if let Some(pat) = pat {\n+                            mkpat(&pat.pattern)\n+                        } else {\n+                            let ty = substs.at(Interner, 0).assert_ty_ref(Interner).clone();\n+                            DeconstructedPat::wildcard(ty)\n+                        };\n+                        ctor = Single;\n+                        fields = Fields::singleton(cx, field)\n+                    }\n+                    &TyKind::Adt(adt, _) => {\n+                        ctor = match pat.kind.as_ref() {\n+                            PatKind::Leaf { .. } => Single,\n+                            PatKind::Variant { enum_variant, .. } => Variant(*enum_variant),\n+                            _ => {\n+                                never!();\n+                                Wildcard\n+                            }\n+                        };\n+                        let variant = ctor.variant_id_for_adt(adt.0);\n+                        let fields_len = variant.variant_data(cx.db.upcast()).fields().len();\n+                        // For each field in the variant, we store the relevant index into `self.fields` if any.\n+                        let mut field_id_to_id: Vec<Option<usize>> = vec![None; fields_len];\n+                        let tys = Fields::list_variant_nonhidden_fields(cx, &pat.ty, variant)\n+                            .enumerate()\n+                            .map(|(i, (fid, ty))| {\n+                                let field_idx: u32 = fid.into_raw().into();\n+                                field_id_to_id[field_idx as usize] = Some(i);\n+                                ty\n+                            });\n+                        let mut wilds: SmallVec<[_; 2]> =\n+                            tys.map(DeconstructedPat::wildcard).collect();\n+                        for pat in subpatterns {\n+                            let field_idx: u32 = pat.field.into_raw().into();\n+                            if let Some(i) = field_id_to_id[field_idx as usize] {\n+                                wilds[i] = mkpat(&pat.pattern);\n+                            }\n+                        }\n+                        fields = Fields::from_iter(cx, wilds);\n+                    }\n+                    _ => {\n+                        never!(\"pattern has unexpected type: pat: {:?}, ty: {:?}\", pat, &pat.ty);\n+                        ctor = Wildcard;\n+                        fields = Fields::empty();\n                     }\n                 }\n             }\n+            &PatKind::LiteralBool { value } => {\n+                ctor = IntRange(IntRange::from_bool(value));\n+                fields = Fields::empty();\n+            }\n+            PatKind::Or { .. } => {\n+                ctor = Or;\n+                let pats: SmallVec<[_; 2]> = expand_or_pat(pat).into_iter().map(mkpat).collect();\n+                fields = Fields::from_iter(cx, pats)\n+            }\n         }\n-        fields\n+        DeconstructedPat::new(ctor, fields, pat.ty.clone())\n     }\n \n-    /// Replaces contained fields with the given list of patterns. There must be `len()` patterns\n-    /// in `pats`.\n-    pub(super) fn replace_fields(\n-        &self,\n-        cx: &MatchCheckCtx<'_>,\n-        pats: impl IntoIterator<Item = Pat>,\n-    ) -> Self {\n-        let pats = pats.into_iter().map(|pat| cx.alloc_pat(pat)).collect();\n+    // // FIXME(iDawer): implement reporting of noncovered patterns\n+    // pub(crate) fn to_pat(&self, _cx: &MatchCheckCtx<'_, 'p>) -> Pat {\n+    //     Pat { ty: self.ty.clone(), kind: PatKind::Wild.into() }\n+    // }\n \n-        match self {\n-            Fields::Vec(_) => Fields::Vec(pats),\n-        }\n+    pub(super) fn is_or_pat(&self) -> bool {\n+        matches!(self.ctor, Or)\n     }\n \n-    /// Replaces contained fields with the arguments of the given pattern. Only use on a pattern\n-    /// that is compatible with the constructor used to build `self`.\n-    /// This is meant to be used on the result of `Fields::wildcards()`. The idea is that\n-    /// `wildcards` constructs a list of fields where all entries are wildcards, and the pattern\n-    /// provided to this function fills some of the fields with non-wildcards.\n-    /// In the following example `Fields::wildcards` would return `[_, _, _, _]`. If we call\n-    /// `replace_with_pattern_arguments` on it with the pattern, the result will be `[Some(0), _,\n-    /// _, _]`.\n-    /// ```rust\n-    /// let x: [Option<u8>; 4] = foo();\n-    /// match x {\n-    ///     [Some(0), ..] => {}\n-    /// }\n-    /// ```\n-    /// This is guaranteed to preserve the number of patterns in `self`.\n-    pub(super) fn replace_with_pattern_arguments(\n-        &self,\n-        pat: PatId,\n-        cx: &MatchCheckCtx<'_>,\n-    ) -> Self {\n-        // FIXME(iDawer): Factor out pattern deep cloning. See discussion:\n-        // https://github.com/rust-analyzer/rust-analyzer/pull/8717#discussion_r633086640\n-        let mut arena = cx.pattern_arena.borrow_mut();\n-        match arena[pat].kind.as_ref() {\n-            PatKind::Deref { subpattern } => {\n-                assert_eq!(self.len(), 1);\n-                let subpattern = subpattern.clone();\n-                Fields::from_single_pattern(arena.alloc(subpattern))\n+    pub(super) fn ctor(&self) -> &Constructor {\n+        &self.ctor\n+    }\n+\n+    pub(super) fn ty(&self) -> &Ty {\n+        &self.ty\n+    }\n+\n+    pub(super) fn iter_fields<'a>(&'a self) -> impl Iterator<Item = &'a DeconstructedPat<'a>> + 'a {\n+        self.fields.iter_patterns()\n+    }\n+\n+    /// Specialize this pattern with a constructor.\n+    /// `other_ctor` can be different from `self.ctor`, but must be covered by it.\n+    pub(super) fn specialize<'a>(\n+        &'a self,\n+        cx: &MatchCheckCtx<'_, 'p>,\n+        other_ctor: &Constructor,\n+    ) -> SmallVec<[&'p DeconstructedPat<'p>; 2]> {\n+        match (&self.ctor, other_ctor) {\n+            (Wildcard, _) => {\n+                // We return a wildcard for each field of `other_ctor`.\n+                Fields::wildcards(cx, &self.ty, other_ctor).iter_patterns().collect()\n             }\n-            PatKind::Leaf { subpatterns } | PatKind::Variant { subpatterns, .. } => {\n-                let subpatterns = subpatterns.clone();\n-                let subpatterns = subpatterns\n-                    .iter()\n-                    .map(|field_pat| (field_pat.field, arena.alloc(field_pat.pattern.clone())));\n-                self.replace_with_fieldpats(subpatterns)\n+            (Slice(self_slice), Slice(other_slice))\n+                if self_slice.arity() != other_slice.arity() =>\n+            {\n+                unimplemented!()\n             }\n-\n-            PatKind::Wild\n-            | PatKind::Binding { .. }\n-            | PatKind::LiteralBool { .. }\n-            | PatKind::Or { .. } => self.clone(),\n+            _ => self.fields.iter_patterns().collect(),\n         }\n     }\n+\n+    /// We keep track for each pattern if it was ever reachable during the analysis. This is used\n+    /// with `unreachable_spans` to report unreachable subpatterns arising from or patterns.\n+    pub(super) fn set_reachable(&self) {\n+        self.reachable.set(true)\n+    }\n+    pub(super) fn is_reachable(&self) -> bool {\n+        self.reachable.get()\n+    }\n }\n \n-fn is_field_list_non_exhaustive(variant_id: VariantId, cx: &MatchCheckCtx<'_>) -> bool {\n+fn is_field_list_non_exhaustive(variant_id: VariantId, cx: &MatchCheckCtx<'_, '_>) -> bool {\n     let attr_def_id = match variant_id {\n         VariantId::EnumVariantId(id) => id.into(),\n         VariantId::StructId(id) => id.into(),\n@@ -904,7 +1024,7 @@ fn is_field_list_non_exhaustive(variant_id: VariantId, cx: &MatchCheckCtx<'_>) -\n     cx.db.attrs(attr_def_id).by_key(\"non_exhaustive\").exists()\n }\n \n-fn adt_is_box(adt: hir_def::AdtId, cx: &MatchCheckCtx<'_>) -> bool {\n+fn adt_is_box(adt: hir_def::AdtId, cx: &MatchCheckCtx<'_, '_>) -> bool {\n     use hir_def::lang_item::LangItemTarget;\n     match cx.db.lang_item(cx.module.krate(), SmolStr::new_inline(\"owned_box\")) {\n         Some(LangItemTarget::StructId(box_id)) => adt == box_id.into(),"}, {"sha": "e8a13955d21c6711a8e76be6bd3c8f13eafde694", "filename": "crates/hir_ty/src/diagnostics/match_check/usefulness.rs", "status": "modified", "additions": 192, "deletions": 562, "changes": 754, "blob_url": "https://github.com/rust-lang/rust/blob/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs?ref=48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "patch": "@@ -1,5 +1,5 @@\n-//! Based on rust-lang/rust 1.52.0-nightly (25c15cdbe 2021-04-22)\n-//! <https://github.com/rust-lang/rust/blob/25c15cdbe/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs>\n+//! Based on rust-lang/rust (last sync f31622a50 2021-11-12)\n+//! <https://github.com/rust-lang/rust/blob/f31622a50/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs>\n //!\n //! -----\n //!\n@@ -271,139 +271,79 @@\n //! The details are not necessary to understand this file, so we explain them in\n //! [`super::deconstruct_pat`]. Splitting is done by the [`Constructor::split`] function.\n \n-use std::{cell::RefCell, iter::FromIterator};\n+use std::iter::once;\n \n-use hir_def::{expr::ExprId, HasModule, ModuleId};\n-use la_arena::Arena;\n-use once_cell::unsync::OnceCell;\n-use rustc_hash::FxHashMap;\n+use hir_def::{AdtId, DefWithBodyId, HasModule, ModuleId};\n use smallvec::{smallvec, SmallVec};\n+use typed_arena::Arena;\n \n-use crate::{db::HirDatabase, InferenceResult, Interner, Ty};\n+use crate::{db::HirDatabase, Ty, TyExt};\n \n-use super::{\n-    deconstruct_pat::{Constructor, Fields, SplitWildcard},\n-    Pat, PatId, PatKind, PatternFoldable, PatternFolder,\n-};\n+use super::deconstruct_pat::{Constructor, DeconstructedPat, Fields, SplitWildcard};\n \n-use self::{helper::PatIdExt, Usefulness::*, WitnessPreference::*};\n+use self::{helper::Captures, ArmType::*, Usefulness::*};\n \n-pub(crate) struct MatchCheckCtx<'a> {\n+pub(crate) struct MatchCheckCtx<'a, 'p> {\n     pub(crate) module: ModuleId,\n-    pub(crate) match_expr: ExprId,\n-    pub(crate) infer: &'a InferenceResult,\n+    pub(crate) body: DefWithBodyId,\n     pub(crate) db: &'a dyn HirDatabase,\n     /// Lowered patterns from arms plus generated by the check.\n-    pub(crate) pattern_arena: &'a RefCell<PatternArena>,\n+    pub(crate) pattern_arena: &'p Arena<DeconstructedPat<'p>>,\n }\n \n-impl<'a> MatchCheckCtx<'a> {\n+impl<'a, 'p> MatchCheckCtx<'a, 'p> {\n     pub(super) fn is_uninhabited(&self, _ty: &Ty) -> bool {\n         // FIXME(iDawer) implement exhaustive_patterns feature. More info in:\n         // Tracking issue for RFC 1872: exhaustive_patterns feature https://github.com/rust-lang/rust/issues/51085\n         false\n     }\n \n     /// Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n-    pub(super) fn is_foreign_non_exhaustive_enum(&self, enum_id: hir_def::EnumId) -> bool {\n-        let has_non_exhaustive_attr =\n-            self.db.attrs(enum_id.into()).by_key(\"non_exhaustive\").exists();\n-        let is_local =\n-            hir_def::AdtId::from(enum_id).module(self.db.upcast()).krate() == self.module.krate();\n-        has_non_exhaustive_attr && !is_local\n+    pub(super) fn is_foreign_non_exhaustive_enum(&self, ty: &Ty) -> bool {\n+        match ty.as_adt() {\n+            Some((adt @ AdtId::EnumId(_), _)) => {\n+                let has_non_exhaustive_attr =\n+                    self.db.attrs(adt.into()).by_key(\"non_exhaustive\").exists();\n+                let is_local = adt.module(self.db.upcast()).krate() == self.module.krate();\n+                has_non_exhaustive_attr && !is_local\n+            }\n+            _ => false,\n+        }\n     }\n \n     // Rust feature described as \"Allows exhaustive pattern matching on types that contain uninhabited types.\"\n     pub(super) fn feature_exhaustive_patterns(&self) -> bool {\n         // FIXME see MatchCheckCtx::is_uninhabited\n         false\n     }\n-\n-    pub(super) fn alloc_pat(&self, pat: Pat) -> PatId {\n-        self.pattern_arena.borrow_mut().alloc(pat)\n-    }\n-\n-    /// Get type of a pattern. Handles expanded patterns.\n-    pub(super) fn type_of(&self, pat: PatId) -> Ty {\n-        self.pattern_arena.borrow()[pat].ty.clone()\n-    }\n }\n \n #[derive(Copy, Clone)]\n-pub(super) struct PatCtxt<'a> {\n-    pub(super) cx: &'a MatchCheckCtx<'a>,\n+pub(super) struct PatCtxt<'a, 'p> {\n+    pub(super) cx: &'a MatchCheckCtx<'a, 'p>,\n     /// Type of the current column under investigation.\n     pub(super) ty: &'a Ty,\n     /// Whether the current pattern is the whole pattern as found in a match arm, or if it's a\n     /// subpattern.\n     pub(super) is_top_level: bool,\n-}\n-\n-pub(crate) fn expand_pattern(pat: Pat) -> Pat {\n-    LiteralExpander.fold_pattern(&pat)\n-}\n-\n-struct LiteralExpander;\n-\n-impl PatternFolder for LiteralExpander {\n-    fn fold_pattern(&mut self, pat: &Pat) -> Pat {\n-        match (pat.ty.kind(Interner), pat.kind.as_ref()) {\n-            (_, PatKind::Binding { subpattern: Some(s), .. }) => s.fold_with(self),\n-            _ => pat.super_fold_with(self),\n-        }\n-    }\n-}\n-\n-impl Pat {\n-    fn _is_wildcard(&self) -> bool {\n-        matches!(*self.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n-    }\n-}\n-\n-impl PatIdExt for PatId {\n-    fn is_or_pat(self, cx: &MatchCheckCtx<'_>) -> bool {\n-        matches!(*cx.pattern_arena.borrow()[self].kind, PatKind::Or { .. })\n-    }\n-\n-    /// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n-    fn expand_or_pat(self, cx: &MatchCheckCtx<'_>) -> Vec<Self> {\n-        fn expand(pat: PatId, vec: &mut Vec<PatId>, pat_arena: &mut PatternArena) {\n-            if let PatKind::Or { pats } = pat_arena[pat].kind.as_ref() {\n-                // FIXME(iDawer): Factor out pattern deep cloning. See discussion:\n-                // https://github.com/rust-analyzer/rust-analyzer/pull/8717#discussion_r633086640\n-                let pats = pats.clone();\n-                for pat in pats {\n-                    let pat = pat_arena.alloc(pat.clone());\n-                    expand(pat, vec, pat_arena);\n-                }\n-            } else {\n-                vec.push(pat)\n-            }\n-        }\n-\n-        let mut pat_arena = cx.pattern_arena.borrow_mut();\n-        let mut pats = Vec::new();\n-        expand(self, &mut pats, &mut pat_arena);\n-        pats\n-    }\n+    /// Wether the current pattern is from a `non_exhaustive` enum.\n+    pub(super) is_non_exhaustive: bool,\n }\n \n /// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n /// works well.\n #[derive(Clone)]\n-pub(super) struct PatStack {\n-    pats: SmallVec<[PatId; 2]>,\n-    /// Cache for the constructor of the head\n-    head_ctor: OnceCell<Constructor>,\n+pub(super) struct PatStack<'p> {\n+    pats: SmallVec<[&'p DeconstructedPat<'p>; 2]>,\n }\n \n-impl PatStack {\n-    fn from_pattern(pat: PatId) -> Self {\n+impl<'p> PatStack<'p> {\n+    fn from_pattern(pat: &'p DeconstructedPat<'p>) -> Self {\n         Self::from_vec(smallvec![pat])\n     }\n \n-    fn from_vec(vec: SmallVec<[PatId; 2]>) -> Self {\n-        PatStack { pats: vec, head_ctor: OnceCell::new() }\n+    fn from_vec(vec: SmallVec<[&'p DeconstructedPat<'p>; 2]>) -> Self {\n+        PatStack { pats: vec }\n     }\n \n     fn is_empty(&self) -> bool {\n@@ -414,73 +354,42 @@ impl PatStack {\n         self.pats.len()\n     }\n \n-    fn head(&self) -> PatId {\n+    fn head(&self) -> &'p DeconstructedPat<'p> {\n         self.pats[0]\n     }\n \n-    #[inline]\n-    fn head_ctor(&self, cx: &MatchCheckCtx<'_>) -> &Constructor {\n-        self.head_ctor.get_or_init(|| Constructor::from_pat(cx, self.head()))\n-    }\n-\n     // Recursively expand the first pattern into its subpatterns. Only useful if the pattern is an\n     // or-pattern. Panics if `self` is empty.\n-    fn expand_or_pat(&self, cx: &MatchCheckCtx<'_>) -> impl Iterator<Item = PatStack> + '_ {\n-        self.head().expand_or_pat(cx).into_iter().map(move |pat| {\n+    fn expand_or_pat(&self) -> impl Iterator<Item = PatStack<'p>> + Captures<'_> {\n+        self.head().iter_fields().map(move |pat| {\n             let mut new_patstack = PatStack::from_pattern(pat);\n             new_patstack.pats.extend_from_slice(&self.pats[1..]);\n             new_patstack\n         })\n     }\n \n-    /// This computes `S(self.head_ctor(), self)`. See top of the file for explanations.\n+    /// This computes `S(self.head().ctor(), self)`. See top of the file for explanations.\n     ///\n     /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n     /// fields filled with wild patterns.\n     ///\n     /// This is roughly the inverse of `Constructor::apply`.\n-    fn pop_head_constructor(\n-        &self,\n-        ctor_wild_subpatterns: &Fields,\n-        cx: &MatchCheckCtx<'_>,\n-    ) -> PatStack {\n+    fn pop_head_constructor(&self, cx: &MatchCheckCtx<'_, 'p>, ctor: &Constructor) -> PatStack<'p> {\n         // We pop the head pattern and push the new fields extracted from the arguments of\n         // `self.head()`.\n-        let mut new_fields =\n-            ctor_wild_subpatterns.replace_with_pattern_arguments(self.head(), cx).into_patterns();\n+        let mut new_fields: SmallVec<[_; 2]> = self.head().specialize(cx, ctor);\n         new_fields.extend_from_slice(&self.pats[1..]);\n         PatStack::from_vec(new_fields)\n     }\n }\n \n-impl Default for PatStack {\n-    fn default() -> Self {\n-        Self::from_vec(smallvec![])\n-    }\n-}\n-\n-impl PartialEq for PatStack {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.pats == other.pats\n-    }\n-}\n-\n-impl FromIterator<PatId> for PatStack {\n-    fn from_iter<T>(iter: T) -> Self\n-    where\n-        T: IntoIterator<Item = PatId>,\n-    {\n-        Self::from_vec(iter.into_iter().collect())\n-    }\n-}\n-\n /// A 2D matrix.\n #[derive(Clone)]\n-pub(super) struct Matrix {\n-    patterns: Vec<PatStack>,\n+pub(super) struct Matrix<'p> {\n+    patterns: Vec<PatStack<'p>>,\n }\n \n-impl Matrix {\n+impl<'p> Matrix<'p> {\n     fn empty() -> Self {\n         Matrix { patterns: vec![] }\n     }\n@@ -492,295 +401,29 @@ impl Matrix {\n \n     /// Pushes a new row to the matrix. If the row starts with an or-pattern, this recursively\n     /// expands it.\n-    fn push(&mut self, row: PatStack, cx: &MatchCheckCtx<'_>) {\n-        if !row.is_empty() && row.head().is_or_pat(cx) {\n-            for row in row.expand_or_pat(cx) {\n-                self.patterns.push(row);\n-            }\n+    fn push(&mut self, row: PatStack<'p>) {\n+        if !row.is_empty() && row.head().is_or_pat() {\n+            self.patterns.extend(row.expand_or_pat());\n         } else {\n             self.patterns.push(row);\n         }\n     }\n \n     /// Iterate over the first component of each row\n-    fn heads(&self) -> impl Iterator<Item = PatId> + '_ {\n+    fn heads(&self) -> impl Iterator<Item = &'p DeconstructedPat<'p>> + Clone + Captures<'_> {\n         self.patterns.iter().map(|r| r.head())\n     }\n \n-    /// Iterate over the first constructor of each row.\n-    fn head_ctors<'a>(\n-        &'a self,\n-        cx: &'a MatchCheckCtx<'_>,\n-    ) -> impl Iterator<Item = &'a Constructor> + Clone {\n-        self.patterns.iter().map(move |r| r.head_ctor(cx))\n-    }\n-\n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n-    fn specialize_constructor(\n-        &self,\n-        pcx: PatCtxt<'_>,\n-        ctor: &Constructor,\n-        ctor_wild_subpatterns: &Fields,\n-    ) -> Matrix {\n-        let rows = self\n-            .patterns\n-            .iter()\n-            .filter(|r| ctor.is_covered_by(pcx, r.head_ctor(pcx.cx)))\n-            .map(|r| r.pop_head_constructor(ctor_wild_subpatterns, pcx.cx));\n-        Matrix::from_iter(rows, pcx.cx)\n-    }\n-\n-    fn from_iter(rows: impl IntoIterator<Item = PatStack>, cx: &MatchCheckCtx<'_>) -> Matrix {\n+    fn specialize_constructor(&self, pcx: PatCtxt<'_, 'p>, ctor: &Constructor) -> Matrix<'p> {\n         let mut matrix = Matrix::empty();\n-        for x in rows {\n-            // Using `push` ensures we correctly expand or-patterns.\n-            matrix.push(x, cx);\n-        }\n-        matrix\n-    }\n-}\n-\n-/// Given a pattern or a pattern-stack, this struct captures a set of its subpatterns. We use that\n-/// to track reachable sub-patterns arising from or-patterns. In the absence of or-patterns this\n-/// will always be either `Empty` (the whole pattern is unreachable) or `Full` (the whole pattern\n-/// is reachable). When there are or-patterns, some subpatterns may be reachable while others\n-/// aren't. In this case the whole pattern still counts as reachable, but we will lint the\n-/// unreachable subpatterns.\n-///\n-/// This supports a limited set of operations, so not all possible sets of subpatterns can be\n-/// represented. That's ok, we only want the ones that make sense for our usage.\n-///\n-/// What we're doing is illustrated by this:\n-/// ```\n-/// match (true, 0) {\n-///     (true, 0) => {}\n-///     (_, 1) => {}\n-///     (true | false, 0 | 1) => {}\n-/// }\n-/// ```\n-/// When we try the alternatives of the `true | false` or-pattern, the last `0` is reachable in the\n-/// `false` alternative but not the `true`. So overall it is reachable. By contrast, the last `1`\n-/// is not reachable in either alternative, so we want to signal this to the user.\n-/// Therefore we take the union of sets of reachable patterns coming from different alternatives in\n-/// order to figure out which subpatterns are overall reachable.\n-///\n-/// Invariant: we try to construct the smallest representation we can. In particular if\n-/// `self.is_empty()` we ensure that `self` is `Empty`, and same with `Full`. This is not important\n-/// for correctness currently.\n-#[derive(Debug, Clone)]\n-enum SubPatSet {\n-    /// The empty set. This means the pattern is unreachable.\n-    Empty,\n-    /// The set containing the full pattern.\n-    Full,\n-    /// If the pattern is a pattern with a constructor or a pattern-stack, we store a set for each\n-    /// of its subpatterns. Missing entries in the map are implicitly full, because that's the\n-    /// common case.\n-    Seq { subpats: FxHashMap<usize, SubPatSet> },\n-    /// If the pattern is an or-pattern, we store a set for each of its alternatives. Missing\n-    /// entries in the map are implicitly empty. Note: we always flatten nested or-patterns.\n-    Alt {\n-        subpats: FxHashMap<usize, SubPatSet>,\n-        /// Counts the total number of alternatives in the pattern\n-        alt_count: usize,\n-        /// We keep the pattern around to retrieve spans.\n-        pat: PatId,\n-    },\n-}\n-\n-impl SubPatSet {\n-    fn full() -> Self {\n-        SubPatSet::Full\n-    }\n-\n-    fn empty() -> Self {\n-        SubPatSet::Empty\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        match self {\n-            SubPatSet::Empty => true,\n-            SubPatSet::Full => false,\n-            // If any subpattern in a sequence is unreachable, the whole pattern is unreachable.\n-            SubPatSet::Seq { subpats } => subpats.values().any(|set| set.is_empty()),\n-            // An or-pattern is reachable if any of its alternatives is.\n-            SubPatSet::Alt { subpats, .. } => subpats.values().all(|set| set.is_empty()),\n-        }\n-    }\n-\n-    fn is_full(&self) -> bool {\n-        match self {\n-            SubPatSet::Empty => false,\n-            SubPatSet::Full => true,\n-            // The whole pattern is reachable only when all its alternatives are.\n-            SubPatSet::Seq { subpats } => subpats.values().all(|sub_set| sub_set.is_full()),\n-            // The whole or-pattern is reachable only when all its alternatives are.\n-            SubPatSet::Alt { subpats, alt_count, .. } => {\n-                subpats.len() == *alt_count && subpats.values().all(|set| set.is_full())\n-            }\n-        }\n-    }\n-\n-    /// Union `self` with `other`, mutating `self`.\n-    fn union(&mut self, other: Self) {\n-        use SubPatSet::*;\n-        // Union with full stays full; union with empty changes nothing.\n-        if self.is_full() || other.is_empty() {\n-            return;\n-        } else if self.is_empty() {\n-            *self = other;\n-            return;\n-        } else if other.is_full() {\n-            *self = Full;\n-            return;\n-        }\n-\n-        match (&mut *self, other) {\n-            (Seq { subpats: s_set }, Seq { subpats: mut o_set }) => {\n-                s_set.retain(|i, s_sub_set| {\n-                    // Missing entries count as full.\n-                    let o_sub_set = o_set.remove(i).unwrap_or(Full);\n-                    s_sub_set.union(o_sub_set);\n-                    // We drop full entries.\n-                    !s_sub_set.is_full()\n-                });\n-                // Everything left in `o_set` is missing from `s_set`, i.e. counts as full. Since\n-                // unioning with full returns full, we can drop those entries.\n-            }\n-            (Alt { subpats: s_set, .. }, Alt { subpats: mut o_set, .. }) => {\n-                s_set.retain(|i, s_sub_set| {\n-                    // Missing entries count as empty.\n-                    let o_sub_set = o_set.remove(i).unwrap_or(Empty);\n-                    s_sub_set.union(o_sub_set);\n-                    // We drop empty entries.\n-                    !s_sub_set.is_empty()\n-                });\n-                // Everything left in `o_set` is missing from `s_set`, i.e. counts as empty. Since\n-                // unioning with empty changes nothing, we can take those entries as is.\n-                s_set.extend(o_set);\n-            }\n-            _ => panic!(\"bug\"),\n-        }\n-\n-        if self.is_full() {\n-            *self = Full;\n-        }\n-    }\n-\n-    /// Returns a list of the unreachable subpatterns. If `self` is empty (i.e. the\n-    /// whole pattern is unreachable) we return `None`.\n-    fn list_unreachable_subpatterns(&self, cx: &MatchCheckCtx<'_>) -> Option<Vec<PatId>> {\n-        /// Panics if `set.is_empty()`.\n-        fn fill_subpats(\n-            set: &SubPatSet,\n-            unreachable_pats: &mut Vec<PatId>,\n-            cx: &MatchCheckCtx<'_>,\n-        ) {\n-            match set {\n-                SubPatSet::Empty => panic!(\"bug\"),\n-                SubPatSet::Full => {}\n-                SubPatSet::Seq { subpats } => {\n-                    for sub_set in subpats.values() {\n-                        fill_subpats(sub_set, unreachable_pats, cx);\n-                    }\n-                }\n-                SubPatSet::Alt { subpats, pat, alt_count, .. } => {\n-                    let expanded = pat.expand_or_pat(cx);\n-                    for (i, &expanded) in expanded.iter().enumerate().take(*alt_count) {\n-                        let sub_set = subpats.get(&i).unwrap_or(&SubPatSet::Empty);\n-                        if sub_set.is_empty() {\n-                            // Found an unreachable subpattern.\n-                            unreachable_pats.push(expanded);\n-                        } else {\n-                            fill_subpats(sub_set, unreachable_pats, cx);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        if self.is_empty() {\n-            return None;\n-        }\n-        if self.is_full() {\n-            // No subpatterns are unreachable.\n-            return Some(Vec::new());\n-        }\n-        let mut unreachable_pats = Vec::new();\n-        fill_subpats(self, &mut unreachable_pats, cx);\n-        Some(unreachable_pats)\n-    }\n-\n-    /// When `self` refers to a patstack that was obtained from specialization, after running\n-    /// `unspecialize` it will refer to the original patstack before specialization.\n-    fn unspecialize(self, arity: usize) -> Self {\n-        use SubPatSet::*;\n-        match self {\n-            Full => Full,\n-            Empty => Empty,\n-            Seq { subpats } => {\n-                // We gather the first `arity` subpatterns together and shift the remaining ones.\n-                let mut new_subpats = FxHashMap::default();\n-                let mut new_subpats_first_col = FxHashMap::default();\n-                for (i, sub_set) in subpats {\n-                    if i < arity {\n-                        // The first `arity` indices are now part of the pattern in the first\n-                        // column.\n-                        new_subpats_first_col.insert(i, sub_set);\n-                    } else {\n-                        // Indices after `arity` are simply shifted\n-                        new_subpats.insert(i - arity + 1, sub_set);\n-                    }\n-                }\n-                // If `new_subpats_first_col` has no entries it counts as full, so we can omit it.\n-                if !new_subpats_first_col.is_empty() {\n-                    new_subpats.insert(0, Seq { subpats: new_subpats_first_col });\n-                }\n-                Seq { subpats: new_subpats }\n+        for row in &self.patterns {\n+            if ctor.is_covered_by(pcx, row.head().ctor()) {\n+                let new_row = row.pop_head_constructor(pcx.cx, ctor);\n+                matrix.push(new_row);\n             }\n-            Alt { .. } => panic!(\"bug\"), // `self` is a patstack\n-        }\n-    }\n-\n-    /// When `self` refers to a patstack that was obtained from splitting an or-pattern, after\n-    /// running `unspecialize` it will refer to the original patstack before splitting.\n-    ///\n-    /// For example:\n-    /// ```\n-    /// match Some(true) {\n-    ///     Some(true) => {}\n-    ///     None | Some(true | false) => {}\n-    /// }\n-    /// ```\n-    /// Here `None` would return the full set and `Some(true | false)` would return the set\n-    /// containing `false`. After `unsplit_or_pat`, we want the set to contain `None` and `false`.\n-    /// This is what this function does.\n-    fn unsplit_or_pat(mut self, alt_id: usize, alt_count: usize, pat: PatId) -> Self {\n-        use SubPatSet::*;\n-        if self.is_empty() {\n-            return Empty;\n         }\n-\n-        // Subpatterns coming from inside the or-pattern alternative itself, e.g. in `None | Some(0\n-        // | 1)`.\n-        let set_first_col = match &mut self {\n-            Full => Full,\n-            Seq { subpats } => subpats.remove(&0).unwrap_or(Full),\n-            Empty => unreachable!(),\n-            Alt { .. } => panic!(\"bug\"), // `self` is a patstack\n-        };\n-        let mut subpats_first_col = FxHashMap::default();\n-        subpats_first_col.insert(alt_id, set_first_col);\n-        let set_first_col = Alt { subpats: subpats_first_col, pat, alt_count };\n-\n-        let mut subpats = match self {\n-            Full => FxHashMap::default(),\n-            Seq { subpats } => subpats,\n-            Empty => unreachable!(),\n-            Alt { .. } => panic!(\"bug\"), // `self` is a patstack\n-        };\n-        subpats.insert(0, set_first_col);\n-        Seq { subpats }\n+        matrix\n     }\n }\n \n@@ -789,31 +432,34 @@ impl SubPatSet {\n /// of potential unreachable sub-patterns (in the presence of or-patterns). When checking\n /// exhaustiveness of a whole match, we use the `WithWitnesses` variant, which carries a list of\n /// witnesses of non-exhaustiveness when there are any.\n-/// Which variant to use is dictated by `WitnessPreference`.\n-#[derive(Clone, Debug)]\n-enum Usefulness {\n-    /// Carries a set of subpatterns that have been found to be reachable. If empty, this indicates\n-    /// the whole pattern is unreachable. If not, this indicates that the pattern is reachable but\n-    /// that some sub-patterns may be unreachable (due to or-patterns). In the absence of\n-    /// or-patterns this will always be either `Empty` (the whole pattern is unreachable) or `Full`\n-    /// (the whole pattern is reachable).\n-    NoWitnesses(SubPatSet),\n+/// Which variant to use is dictated by `ArmType`.\n+enum Usefulness<'p> {\n+    /// If we don't care about witnesses, simply remember if the pattern was useful.\n+    NoWitnesses { useful: bool },\n     /// Carries a list of witnesses of non-exhaustiveness. If empty, indicates that the whole\n     /// pattern is unreachable.\n-    WithWitnesses(Vec<Witness>),\n+    WithWitnesses(Vec<Witness<'p>>),\n }\n \n-impl Usefulness {\n-    fn new_useful(preference: WitnessPreference) -> Self {\n+impl<'p> Usefulness<'p> {\n+    fn new_useful(preference: ArmType) -> Self {\n         match preference {\n-            ConstructWitness => WithWitnesses(vec![Witness(vec![])]),\n-            LeaveOutWitness => NoWitnesses(SubPatSet::full()),\n+            // A single (empty) witness of reachability.\n+            FakeExtraWildcard => WithWitnesses(vec![Witness(vec![])]),\n+            RealArm => NoWitnesses { useful: true },\n         }\n     }\n-    fn new_not_useful(preference: WitnessPreference) -> Self {\n+    fn new_not_useful(preference: ArmType) -> Self {\n         match preference {\n-            ConstructWitness => WithWitnesses(vec![]),\n-            LeaveOutWitness => NoWitnesses(SubPatSet::empty()),\n+            FakeExtraWildcard => WithWitnesses(vec![]),\n+            RealArm => NoWitnesses { useful: false },\n+        }\n+    }\n+\n+    fn is_useful(&self) -> bool {\n+        match self {\n+            Usefulness::NoWitnesses { useful } => *useful,\n+            Usefulness::WithWitnesses(witnesses) => !witnesses.is_empty(),\n         }\n     }\n \n@@ -823,89 +469,96 @@ impl Usefulness {\n             (WithWitnesses(_), WithWitnesses(o)) if o.is_empty() => {}\n             (WithWitnesses(s), WithWitnesses(o)) if s.is_empty() => *self = WithWitnesses(o),\n             (WithWitnesses(s), WithWitnesses(o)) => s.extend(o),\n-            (NoWitnesses(s), NoWitnesses(o)) => s.union(o),\n-            _ => unreachable!(),\n-        }\n-    }\n-\n-    /// When trying several branches and each returns a `Usefulness`, we need to combine the\n-    /// results together.\n-    fn merge(pref: WitnessPreference, usefulnesses: impl Iterator<Item = Self>) -> Self {\n-        let mut ret = Self::new_not_useful(pref);\n-        for u in usefulnesses {\n-            ret.extend(u);\n-            if let NoWitnesses(subpats) = &ret {\n-                if subpats.is_full() {\n-                    // Once we reach the full set, more unions won't change the result.\n-                    return ret;\n-                }\n+            (NoWitnesses { useful: s_useful }, NoWitnesses { useful: o_useful }) => {\n+                *s_useful = *s_useful || o_useful\n             }\n-        }\n-        ret\n-    }\n-\n-    /// After calculating the usefulness for a branch of an or-pattern, call this to make this\n-    /// usefulness mergeable with those from the other branches.\n-    fn unsplit_or_pat(self, alt_id: usize, alt_count: usize, pat: PatId) -> Self {\n-        match self {\n-            NoWitnesses(subpats) => NoWitnesses(subpats.unsplit_or_pat(alt_id, alt_count, pat)),\n-            WithWitnesses(_) => panic!(\"bug\"),\n+            _ => unreachable!(),\n         }\n     }\n \n-    /// After calculating usefulness after a specialization, call this to recontruct a usefulness\n+    /// After calculating usefulness after a specialization, call this to reconstruct a usefulness\n     /// that makes sense for the matrix pre-specialization. This new usefulness can then be merged\n     /// with the results of specializing with the other constructors.\n     fn apply_constructor(\n         self,\n-        pcx: PatCtxt<'_>,\n-        matrix: &Matrix,\n+        pcx: PatCtxt<'_, 'p>,\n+        matrix: &Matrix<'p>,\n         ctor: &Constructor,\n-        ctor_wild_subpatterns: &Fields,\n     ) -> Self {\n         match self {\n-            WithWitnesses(witnesses) if witnesses.is_empty() => WithWitnesses(witnesses),\n+            NoWitnesses { .. } => self,\n+            WithWitnesses(ref witnesses) if witnesses.is_empty() => self,\n             WithWitnesses(witnesses) => {\n-                let new_witnesses = if matches!(ctor, Constructor::Missing) {\n-                    let mut split_wildcard = SplitWildcard::new(pcx);\n-                    split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n-                    // Construct for each missing constructor a \"wild\" version of this\n-                    // constructor, that matches everything that can be built with\n-                    // it. For example, if `ctor` is a `Constructor::Variant` for\n-                    // `Option::Some`, we get the pattern `Some(_)`.\n-                    let new_patterns: Vec<_> = split_wildcard\n-                        .iter_missing(pcx)\n-                        .map(|missing_ctor| {\n-                            Fields::wildcards(pcx, missing_ctor).apply(pcx, missing_ctor)\n-                        })\n-                        .collect();\n+                let new_witnesses = if let Constructor::Missing { .. } = ctor {\n+                    // We got the special `Missing` constructor, so each of the missing constructors\n+                    // gives a new pattern that is not caught by the match. We list those patterns.\n+                    let new_patterns = if pcx.is_non_exhaustive {\n+                        // Here we don't want the user to try to list all variants, we want them to add\n+                        // a wildcard, so we only suggest that.\n+                        vec![DeconstructedPat::wildcard(pcx.ty.clone())]\n+                    } else {\n+                        let mut split_wildcard = SplitWildcard::new(pcx);\n+                        split_wildcard.split(pcx, matrix.heads().map(DeconstructedPat::ctor));\n+\n+                        // This lets us know if we skipped any variants because they are marked\n+                        // `doc(hidden)` or they are unstable feature gate (only stdlib types).\n+                        let mut hide_variant_show_wild = false;\n+                        // Construct for each missing constructor a \"wild\" version of this\n+                        // constructor, that matches everything that can be built with\n+                        // it. For example, if `ctor` is a `Constructor::Variant` for\n+                        // `Option::Some`, we get the pattern `Some(_)`.\n+                        let mut new: Vec<DeconstructedPat<'_>> = split_wildcard\n+                            .iter_missing(pcx)\n+                            .filter_map(|missing_ctor| {\n+                                // Check if this variant is marked `doc(hidden)`\n+                                if missing_ctor.is_doc_hidden_variant(pcx)\n+                                    || missing_ctor.is_unstable_variant(pcx)\n+                                {\n+                                    hide_variant_show_wild = true;\n+                                    return None;\n+                                }\n+                                Some(DeconstructedPat::wild_from_ctor(pcx, missing_ctor.clone()))\n+                            })\n+                            .collect();\n+\n+                        if hide_variant_show_wild {\n+                            new.push(DeconstructedPat::wildcard(pcx.ty.clone()))\n+                        }\n+\n+                        new\n+                    };\n+\n                     witnesses\n                         .into_iter()\n                         .flat_map(|witness| {\n                             new_patterns.iter().map(move |pat| {\n-                                let mut witness = witness.clone();\n-                                witness.0.push(pat.clone());\n-                                witness\n+                                Witness(\n+                                    witness\n+                                        .0\n+                                        .iter()\n+                                        .chain(once(pat))\n+                                        .map(DeconstructedPat::clone_and_forget_reachability)\n+                                        .collect(),\n+                                )\n                             })\n                         })\n                         .collect()\n                 } else {\n                     witnesses\n                         .into_iter()\n-                        .map(|witness| witness.apply_constructor(pcx, ctor, ctor_wild_subpatterns))\n+                        .map(|witness| witness.apply_constructor(pcx, ctor))\n                         .collect()\n                 };\n                 WithWitnesses(new_witnesses)\n             }\n-            NoWitnesses(subpats) => NoWitnesses(subpats.unspecialize(ctor_wild_subpatterns.len())),\n         }\n     }\n }\n \n #[derive(Copy, Clone, Debug)]\n-enum WitnessPreference {\n-    ConstructWitness,\n-    LeaveOutWitness,\n+enum ArmType {\n+    FakeExtraWildcard,\n+    RealArm,\n }\n \n /// A witness of non-exhaustiveness for error reporting, represented\n@@ -941,12 +594,11 @@ enum WitnessPreference {\n ///     `Witness(vec![Pair(Some(_), true)])`\n ///\n /// The final `Pair(Some(_), true)` is then the resulting witness.\n-#[derive(Clone, Debug)]\n-pub(crate) struct Witness(Vec<Pat>);\n+pub(crate) struct Witness<'p>(Vec<DeconstructedPat<'p>>);\n \n-impl Witness {\n+impl<'p> Witness<'p> {\n     /// Asserts that the witness contains a single pattern, and returns it.\n-    fn single_pattern(self) -> Pat {\n+    fn single_pattern(self) -> DeconstructedPat<'p> {\n         assert_eq!(self.0.len(), 1);\n         self.0.into_iter().next().unwrap()\n     }\n@@ -964,17 +616,13 @@ impl Witness {\n     ///\n     /// left_ty: struct X { a: (bool, &'static str), b: usize}\n     /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n-    fn apply_constructor(\n-        mut self,\n-        pcx: PatCtxt<'_>,\n-        ctor: &Constructor,\n-        ctor_wild_subpatterns: &Fields,\n-    ) -> Self {\n+    fn apply_constructor(mut self, pcx: PatCtxt<'_, 'p>, ctor: &Constructor) -> Self {\n         let pat = {\n             let len = self.0.len();\n-            let arity = ctor_wild_subpatterns.len();\n+            let arity = ctor.arity(pcx);\n             let pats = self.0.drain((len - arity)..).rev();\n-            ctor_wild_subpatterns.replace_fields(pcx.cx, pats).apply(pcx, ctor)\n+            let fields = Fields::from_iter(pcx.cx, pats);\n+            DeconstructedPat::new(ctor.clone(), fields, pcx.ty.clone())\n         };\n \n         self.0.push(pat);\n@@ -1005,14 +653,14 @@ impl Witness {\n /// `is_under_guard` is used to inform if the pattern has a guard. If it\n /// has one it must not be inserted into the matrix. This shouldn't be\n /// relied on for soundness.\n-fn is_useful(\n-    cx: &MatchCheckCtx<'_>,\n-    matrix: &Matrix,\n-    v: &PatStack,\n-    witness_preference: WitnessPreference,\n+fn is_useful<'p>(\n+    cx: &MatchCheckCtx<'_, 'p>,\n+    matrix: &Matrix<'p>,\n+    v: &PatStack<'p>,\n+    witness_preference: ArmType,\n     is_under_guard: bool,\n     is_top_level: bool,\n-) -> Usefulness {\n+) -> Usefulness<'p> {\n     let Matrix { patterns: rows, .. } = matrix;\n \n     // The base case. We are pattern-matching on () and the return value is\n@@ -1029,69 +677,62 @@ fn is_useful(\n         return ret;\n     }\n \n-    assert!(rows.iter().all(|r| r.len() == v.len()));\n+    debug_assert!(rows.iter().all(|r| r.len() == v.len()));\n \n-    // FIXME(Nadrieril): Hack to work around type normalization issues (see rust-lang/rust#72476).\n-    let ty = matrix.heads().next().map_or(cx.type_of(v.head()), |r| cx.type_of(r));\n-    let pcx = PatCtxt { cx, ty: &ty, is_top_level };\n+    let ty = v.head().ty();\n+    let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n+    let pcx = PatCtxt { cx, ty, is_top_level, is_non_exhaustive };\n \n     // If the first pattern is an or-pattern, expand it.\n-    let ret = if v.head().is_or_pat(cx) {\n-        //expanding or-pattern\n-        let v_head = v.head();\n-        let vs: Vec<_> = v.expand_or_pat(cx).collect();\n-        let alt_count = vs.len();\n+    let mut ret = Usefulness::new_not_useful(witness_preference);\n+    if v.head().is_or_pat() {\n         // We try each or-pattern branch in turn.\n         let mut matrix = matrix.clone();\n-        let usefulnesses = vs.into_iter().enumerate().map(|(i, v)| {\n+        for v in v.expand_or_pat() {\n             let usefulness = is_useful(cx, &matrix, &v, witness_preference, is_under_guard, false);\n+            ret.extend(usefulness);\n             // If pattern has a guard don't add it to the matrix.\n             if !is_under_guard {\n                 // We push the already-seen patterns into the matrix in order to detect redundant\n                 // branches like `Some(_) | Some(0)`.\n-                matrix.push(v, cx);\n+                matrix.push(v);\n             }\n-            usefulness.unsplit_or_pat(i, alt_count, v_head)\n-        });\n-        Usefulness::merge(witness_preference, usefulnesses)\n+        }\n     } else {\n-        let v_ctor = v.head_ctor(cx);\n-        // if let Constructor::IntRange(ctor_range) = v_ctor {\n-        //     // Lint on likely incorrect range patterns (#63987)\n-        //     ctor_range.lint_overlapping_range_endpoints(\n-        //         pcx,\n-        //         matrix.head_ctors_and_spans(cx),\n-        //         matrix.column_count().unwrap_or(0),\n-        //         hir_id,\n-        //     )\n-        // }\n+        let v_ctor = v.head().ctor();\n+\n+        // FIXME: implement `overlapping_range_endpoints` lint\n \n         // We split the head constructor of `v`.\n-        let split_ctors = v_ctor.split(pcx, matrix.head_ctors(cx));\n+        let split_ctors = v_ctor.split(pcx, matrix.heads().map(DeconstructedPat::ctor));\n         // For each constructor, we compute whether there's a value that starts with it that would\n         // witness the usefulness of `v`.\n         let start_matrix = matrix;\n-        let usefulnesses = split_ctors.into_iter().map(|ctor| {\n-            // debug!(\"specialize({:?})\", ctor);\n+        for ctor in split_ctors {\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n-            let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n-            let spec_matrix =\n-                start_matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n-            let v = v.pop_head_constructor(&ctor_wild_subpatterns, cx);\n+            let spec_matrix = start_matrix.specialize_constructor(pcx, &ctor);\n+            let v = v.pop_head_constructor(cx, &ctor);\n             let usefulness =\n                 is_useful(cx, &spec_matrix, &v, witness_preference, is_under_guard, false);\n-            usefulness.apply_constructor(pcx, start_matrix, &ctor, &ctor_wild_subpatterns)\n-        });\n-        Usefulness::merge(witness_preference, usefulnesses)\n+            let usefulness = usefulness.apply_constructor(pcx, start_matrix, &ctor);\n+\n+            // FIXME: implement `non_exhaustive_omitted_patterns` lint\n+\n+            ret.extend(usefulness);\n+        }\n     };\n \n+    if ret.is_useful() {\n+        v.head().set_reachable();\n+    }\n+\n     ret\n }\n \n /// The arm of a match expression.\n #[derive(Clone, Copy)]\n-pub(crate) struct MatchArm {\n-    pub(crate) pat: PatId,\n+pub(crate) struct MatchArm<'p> {\n+    pub(crate) pat: &'p DeconstructedPat<'p>,\n     pub(crate) has_guard: bool,\n }\n \n@@ -1101,72 +742,61 @@ pub(crate) enum Reachability {\n     /// The arm is reachable. This additionally carries a set of or-pattern branches that have been\n     /// found to be unreachable despite the overall arm being reachable. Used only in the presence\n     /// of or-patterns, otherwise it stays empty.\n-    Reachable(Vec<PatId>),\n+    // FIXME: store ureachable subpattern IDs\n+    Reachable,\n     /// The arm is unreachable.\n     Unreachable,\n }\n \n /// The output of checking a match for exhaustiveness and arm reachability.\n-pub(crate) struct UsefulnessReport {\n+pub(crate) struct UsefulnessReport<'p> {\n     /// For each arm of the input, whether that arm is reachable after the arms above it.\n-    pub(crate) _arm_usefulness: Vec<(MatchArm, Reachability)>,\n+    pub(crate) _arm_usefulness: Vec<(MatchArm<'p>, Reachability)>,\n     /// If the match is exhaustive, this is empty. If not, this contains witnesses for the lack of\n     /// exhaustiveness.\n-    pub(crate) non_exhaustiveness_witnesses: Vec<Pat>,\n+    pub(crate) non_exhaustiveness_witnesses: Vec<DeconstructedPat<'p>>,\n }\n \n /// The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which\n /// of its arms are reachable.\n ///\n /// Note: the input patterns must have been lowered through\n /// `check_match::MatchVisitor::lower_pattern`.\n-pub(crate) fn compute_match_usefulness(\n-    cx: &MatchCheckCtx<'_>,\n-    arms: &[MatchArm],\n-) -> UsefulnessReport {\n+pub(crate) fn compute_match_usefulness<'p>(\n+    cx: &MatchCheckCtx<'_, 'p>,\n+    arms: &[MatchArm<'p>],\n+    scrut_ty: &Ty,\n+) -> UsefulnessReport<'p> {\n     let mut matrix = Matrix::empty();\n     let arm_usefulness = arms\n         .iter()\n         .copied()\n         .map(|arm| {\n             let v = PatStack::from_pattern(arm.pat);\n-            let usefulness = is_useful(cx, &matrix, &v, LeaveOutWitness, arm.has_guard, true);\n+            is_useful(cx, &matrix, &v, RealArm, arm.has_guard, true);\n             if !arm.has_guard {\n-                matrix.push(v, cx);\n+                matrix.push(v);\n             }\n-            let reachability = match usefulness {\n-                NoWitnesses(subpats) if subpats.is_empty() => Reachability::Unreachable,\n-                NoWitnesses(subpats) => {\n-                    Reachability::Reachable(subpats.list_unreachable_subpatterns(cx).unwrap())\n-                }\n-                WithWitnesses(..) => panic!(\"bug\"),\n+            let reachability = if arm.pat.is_reachable() {\n+                Reachability::Reachable\n+            } else {\n+                Reachability::Unreachable\n             };\n             (arm, reachability)\n         })\n         .collect();\n \n-    let wild_pattern =\n-        cx.pattern_arena.borrow_mut().alloc(Pat::wildcard_from_ty(cx.infer[cx.match_expr].clone()));\n+    let wild_pattern = cx.pattern_arena.alloc(DeconstructedPat::wildcard(scrut_ty.clone()));\n     let v = PatStack::from_pattern(wild_pattern);\n-    let usefulness = is_useful(cx, &matrix, &v, ConstructWitness, false, true);\n+    let usefulness = is_useful(cx, &matrix, &v, FakeExtraWildcard, false, true);\n     let non_exhaustiveness_witnesses = match usefulness {\n         WithWitnesses(pats) => pats.into_iter().map(Witness::single_pattern).collect(),\n-        NoWitnesses(_) => panic!(\"bug\"),\n+        NoWitnesses { .. } => panic!(\"bug\"),\n     };\n     UsefulnessReport { _arm_usefulness: arm_usefulness, non_exhaustiveness_witnesses }\n }\n \n-pub(crate) type PatternArena = Arena<Pat>;\n-\n-mod helper {\n-    use super::MatchCheckCtx;\n-\n-    pub(super) trait PatIdExt: Sized {\n-        // fn is_wildcard(self, cx: &MatchCheckCtx<'_>) -> bool;\n-        fn is_or_pat(self, cx: &MatchCheckCtx<'_>) -> bool;\n-        fn expand_or_pat(self, cx: &MatchCheckCtx<'_>) -> Vec<Self>;\n-    }\n-\n+pub(crate) mod helper {\n     // Copy-pasted from rust/compiler/rustc_data_structures/src/captures.rs\n     /// \"Signaling\" trait used in impl trait to tag lifetimes that you may\n     /// need to capture but don't really need for other reasons."}, {"sha": "54c3590f04bcb168769d827406fc08e3b75268b8", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "patch": "@@ -16,7 +16,7 @@\n use std::ops::Index;\n use std::sync::Arc;\n \n-use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety, Scalar};\n+use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData, StaticData},\n@@ -70,6 +70,26 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n     Arc::new(ctx.resolve_all())\n }\n \n+/// Fully normalize all the types found within `ty` in context of `owner` body definition.\n+///\n+/// This is appropriate to use only after type-check: it assumes\n+/// that normalization will succeed, for example.\n+pub(crate) fn normalize(db: &dyn HirDatabase, owner: DefWithBodyId, ty: Ty) -> Ty {\n+    if !ty.data(Interner).flags.intersects(TypeFlags::HAS_PROJECTION) {\n+        return ty;\n+    }\n+    let krate = owner.module(db.upcast()).krate();\n+    let trait_env = owner\n+        .as_generic_def_id()\n+        .map_or_else(|| Arc::new(TraitEnvironment::empty(krate)), |d| db.trait_environment(d));\n+    let mut table = unify::InferenceTable::new(db, trait_env.clone());\n+\n+    let ty_with_vars = table.normalize_associated_types_in(ty);\n+    table.resolve_obligations_as_possible();\n+    table.propagate_diverging_flag();\n+    table.resolve_completely(ty_with_vars)\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n enum ExprOrPatId {\n     ExprId(ExprId),\n@@ -80,7 +100,7 @@ impl_from!(ExprId, PatId for ExprOrPatId);\n /// Binding modes inferred for patterns.\n /// <https://doc.rust-lang.org/reference/patterns.html#binding-modes>\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-enum BindingMode {\n+pub enum BindingMode {\n     Move,\n     Ref(Mutability),\n }\n@@ -272,6 +292,7 @@ pub struct InferenceResult {\n     standard_types: InternedStandardTypes,\n     /// Stores the types which were implicitly dereferenced in pattern binding modes.\n     pub pat_adjustments: FxHashMap<PatId, Vec<Adjustment>>,\n+    pub pat_binding_modes: FxHashMap<PatId, BindingMode>,\n     pub expr_adjustments: FxHashMap<ExprId, Vec<Adjustment>>,\n }\n "}, {"sha": "50fd2dd7494973249efeb8659775b949532b5040", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "patch": "@@ -204,6 +204,8 @@ impl<'a> InferenceContext<'a> {\n                 } else {\n                     BindingMode::convert(*mode)\n                 };\n+                self.result.pat_binding_modes.insert(pat, mode);\n+\n                 let inner_ty = match subpat {\n                     Some(subpat) => self.infer_pat(*subpat, &expected, default_bm),\n                     None => expected,"}, {"sha": "6e2764e59ff88ac9df1bc8efa28120f8e1ea4a50", "filename": "crates/ide_diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "patch": "@@ -821,7 +821,6 @@ fn main() {\n \n     #[test]\n     fn pattern_type_is_of_substitution() {\n-        cov_mark::check!(match_check_wildcard_expanded_to_substitutions);\n         check_diagnostics_no_bails(\n             r#\"\n struct Foo<T>(T);\n@@ -864,6 +863,43 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn normalize_field_ty() {\n+        check_diagnostics_no_bails(\n+            r\"\n+trait Trait { type Projection; }\n+enum E {Foo, Bar}\n+struct A;\n+impl Trait for A { type Projection = E; }\n+struct Next<T: Trait>(T::Projection);\n+static __: () = {\n+    let n: Next<A> = Next(E::Foo);\n+    match n { Next(E::Foo) => {} }\n+    //    ^ error: missing match arm\n+    match n { Next(E::Foo | E::Bar) => {} }\n+    match n { Next(E::Foo | _     ) => {} }\n+    match n { Next(_      | E::Bar) => {} }\n+    match n {      _ | Next(E::Bar) => {} }\n+    match &n { Next(E::Foo | E::Bar) => {} }\n+    match &n {      _ | Next(E::Bar) => {} }\n+};\",\n+        );\n+    }\n+\n+    #[test]\n+    fn binding_mode_by_ref() {\n+        check_diagnostics_no_bails(\n+            r\"\n+enum E{ A, B }\n+fn foo() {\n+    match &E::A {\n+        E::A => {}\n+        x => {}\n+    }\n+}\",\n+        );\n+    }\n+\n     mod false_negatives {\n         //! The implementation of match checking here is a work in progress. As we roll this out, we\n         //! prefer false negatives to false positives (ideally there would be no false positives). This"}]}