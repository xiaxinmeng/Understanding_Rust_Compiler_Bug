{"sha": "c9e2ca0dfad8f2aff48c64887b1ec4276929eced", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ZTJjYTBkZmFkOGYyYWZmNDhjNjQ4ODdiMWVjNDI3NjkyOWVjZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-04T15:31:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-04T15:31:27Z"}, "message": "auto merge of #15051 : retep998/rust/master, r=alexcrichton\n\nThis implementation does have the minor issue of not handling things correctly when a codepoint is split across multiple writes or reads, but its better than not having unicode support at all.\r\n\r\nAdds a Windows specific struct `WindowsTTY` in `libnative` and make `tty_open` create that struct on Windows. Adds needed functions and constants to `c_win32.rs`.\r\n\r\nLibuv still needs to be updated before #15028 can be closed.", "tree": {"sha": "2ea0167be164ca883d185fe9dcd9228764d65299", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ea0167be164ca883d185fe9dcd9228764d65299"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9e2ca0dfad8f2aff48c64887b1ec4276929eced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e2ca0dfad8f2aff48c64887b1ec4276929eced", "html_url": "https://github.com/rust-lang/rust/commit/c9e2ca0dfad8f2aff48c64887b1ec4276929eced", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9e2ca0dfad8f2aff48c64887b1ec4276929eced/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04ac2b087e10c8d23e41d5f910ea2069e77c9e73", "url": "https://api.github.com/repos/rust-lang/rust/commits/04ac2b087e10c8d23e41d5f910ea2069e77c9e73", "html_url": "https://github.com/rust-lang/rust/commit/04ac2b087e10c8d23e41d5f910ea2069e77c9e73"}, {"sha": "a34fd5a1bb76256770b95dad16b9fc237fec254b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a34fd5a1bb76256770b95dad16b9fc237fec254b", "html_url": "https://github.com/rust-lang/rust/commit/a34fd5a1bb76256770b95dad16b9fc237fec254b"}], "stats": {"total": 206, "additions": 203, "deletions": 3}, "files": [{"sha": "482155c339c9b5e0b7f6b0973d725b69287a4c87", "filename": "src/libnative/io/c_win32.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c9e2ca0dfad8f2aff48c64887b1ec4276929eced/src%2Flibnative%2Fio%2Fc_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e2ca0dfad8f2aff48c64887b1ec4276929eced/src%2Flibnative%2Fio%2Fc_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_win32.rs?ref=c9e2ca0dfad8f2aff48c64887b1ec4276929eced", "patch": "@@ -19,6 +19,13 @@ pub static WSASYS_STATUS_LEN: uint = 128;\n pub static FIONBIO: libc::c_long = 0x8004667e;\n static FD_SETSIZE: uint = 64;\n pub static MSG_DONTWAIT: libc::c_int = 0;\n+pub static ERROR_ILLEGAL_CHARACTER: libc::c_int = 582;\n+pub static ENABLE_ECHO_INPUT: libc::DWORD = 0x4;\n+pub static ENABLE_EXTENDED_FLAGS: libc::DWORD = 0x80;\n+pub static ENABLE_INSERT_MODE: libc::DWORD = 0x20;\n+pub static ENABLE_LINE_INPUT: libc::DWORD = 0x2;\n+pub static ENABLE_PROCESSED_INPUT: libc::DWORD = 0x1;\n+pub static ENABLE_QUICK_EDIT_MODE: libc::DWORD = 0x40;\n \n #[repr(C)]\n pub struct WSADATA {\n@@ -165,3 +172,24 @@ pub mod compat {\n         })\n     }\n }\n+\n+extern \"system\" {\n+    // FIXME - pInputControl should be PCONSOLE_READCONSOLE_CONTROL\n+    pub fn ReadConsoleW(hConsoleInput: libc::HANDLE,\n+                        lpBuffer: libc::LPVOID,\n+                        nNumberOfCharsToRead: libc::DWORD,\n+                        lpNumberOfCharsRead: libc::LPDWORD,\n+                        pInputControl: libc::LPVOID) -> libc::BOOL;\n+\n+    pub fn WriteConsoleW(hConsoleOutput: libc::HANDLE,\n+                         lpBuffer: libc::types::os::arch::extra::LPCVOID,\n+                         nNumberOfCharsToWrite: libc::DWORD,\n+                         lpNumberOfCharsWritten: libc::LPDWORD,\n+                         lpReserved: libc::LPVOID) -> libc::BOOL;\n+\n+    pub fn GetConsoleMode(hConsoleHandle: libc::HANDLE,\n+                          lpMode: libc::LPDWORD) -> libc::BOOL;\n+\n+    pub fn SetConsoleMode(hConsoleHandle: libc::HANDLE,\n+                          lpMode: libc::DWORD) -> libc::BOOL;\n+}"}, {"sha": "ecdf4ad2c45f49b24af8653bc2d713bfed9dd1d3", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c9e2ca0dfad8f2aff48c64887b1ec4276929eced/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e2ca0dfad8f2aff48c64887b1ec4276929eced/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=c9e2ca0dfad8f2aff48c64887b1ec4276929eced", "patch": "@@ -69,6 +69,10 @@ pub mod pipe;\n #[path = \"pipe_win32.rs\"]\n pub mod pipe;\n \n+#[cfg(windows)]\n+#[path = \"tty_win32.rs\"]\n+mod tty;\n+\n #[cfg(unix)]    #[path = \"c_unix.rs\"]  mod c;\n #[cfg(windows)] #[path = \"c_win32.rs\"] mod c;\n \n@@ -280,15 +284,27 @@ impl rtio::IoFactory for IoFactory {\n     fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<rtio::RtioPipe + Send>> {\n         Ok(box file::FileDesc::new(fd, true) as Box<rtio::RtioPipe + Send>)\n     }\n+    #[cfg(unix)]\n     fn tty_open(&mut self, fd: c_int, _readable: bool)\n                 -> IoResult<Box<rtio::RtioTTY + Send>> {\n-        #[cfg(unix)] use ERROR = libc::ENOTTY;\n-        #[cfg(windows)] use ERROR = libc::ERROR_INVALID_HANDLE;\n         if unsafe { libc::isatty(fd) } != 0 {\n             Ok(box file::FileDesc::new(fd, true) as Box<rtio::RtioTTY + Send>)\n         } else {\n             Err(IoError {\n-                code: ERROR as uint,\n+                code: libc::ENOTTY as uint,\n+                extra: 0,\n+                detail: None,\n+            })\n+        }\n+    }\n+    #[cfg(windows)]\n+    fn tty_open(&mut self, fd: c_int, _readable: bool)\n+                -> IoResult<Box<rtio::RtioTTY + Send>> {\n+        if tty::is_tty(fd) {\n+            Ok(box tty::WindowsTTY::new(fd) as Box<rtio::RtioTTY + Send>)\n+        } else {\n+            Err(IoError {\n+                code: libc::ERROR_INVALID_HANDLE as uint,\n                 extra: 0,\n                 detail: None,\n             })"}, {"sha": "72cf5e785fb93a52426e2143d04b0a3ea1862462", "filename": "src/libnative/io/tty_win32.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/c9e2ca0dfad8f2aff48c64887b1ec4276929eced/src%2Flibnative%2Fio%2Ftty_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e2ca0dfad8f2aff48c64887b1ec4276929eced/src%2Flibnative%2Fio%2Ftty_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftty_win32.rs?ref=c9e2ca0dfad8f2aff48c64887b1ec4276929eced", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Windows specific console TTY implementation\n+//!\n+//! This module contains the implementation of a Windows specific console TTY.\n+//! Also converts between UTF-16 and UTF-8. Windows has very poor support for\n+//! UTF-8 and some functions will fail. In particular ReadFile and ReadConsole\n+//! will fail when the codepage is set to UTF-8 and a unicode character is\n+//! entered.\n+//!\n+//! FIXME\n+//! This implementation does not account for codepoints that are split across\n+//! multiple reads and writes. Also, this implementation does not expose a way\n+//! to read/write UTF-16 directly. When/if Rust receives a Reader/Writer\n+//! wrapper that performs encoding/decoding, this implementation should switch\n+//! to working in raw UTF-16, with such a wrapper around it.\n+\n+use super::c::{ReadConsoleW, WriteConsoleW, GetConsoleMode, SetConsoleMode};\n+use super::c::{ERROR_ILLEGAL_CHARACTER};\n+use super::c::{ENABLE_ECHO_INPUT, ENABLE_EXTENDED_FLAGS};\n+use super::c::{ENABLE_INSERT_MODE, ENABLE_LINE_INPUT};\n+use super::c::{ENABLE_PROCESSED_INPUT, ENABLE_QUICK_EDIT_MODE};\n+use libc::{c_int, HANDLE, LPDWORD, DWORD, LPVOID};\n+use libc::{get_osfhandle, CloseHandle};\n+use libc::types::os::arch::extra::LPCVOID;\n+use std::io::MemReader;\n+use std::ptr;\n+use std::rt::rtio::{IoResult, IoError, RtioTTY};\n+use std::str::{from_utf16, from_utf8};\n+\n+fn invalid_encoding() -> IoError {\n+    IoError {\n+        code: ERROR_ILLEGAL_CHARACTER as uint,\n+        extra: 0,\n+        detail: Some(\"text was not valid unicode\".to_string()),\n+    }\n+}\n+\n+pub fn is_tty(fd: c_int) -> bool {\n+    let mut out: DWORD = 0;\n+    // If this function doesn't fail then fd is a TTY\n+    match unsafe { GetConsoleMode(get_osfhandle(fd) as HANDLE,\n+                                  &mut out as LPDWORD) } {\n+        0 => false,\n+        _ => true,\n+    }\n+}\n+\n+pub struct WindowsTTY {\n+    closeme: bool,\n+    handle: HANDLE,\n+    utf8: MemReader,\n+}\n+\n+impl WindowsTTY {\n+    pub fn new(fd: c_int) -> WindowsTTY {\n+        // If the file descriptor is one of stdin, stderr, or stdout\n+        // then it should not be closed by us\n+        let closeme = match fd {\n+            0..2 => false,\n+            _ => true,\n+        };\n+        let handle = unsafe { get_osfhandle(fd) as HANDLE };\n+        WindowsTTY {\n+            handle: handle,\n+            utf8: MemReader::new(Vec::new()),\n+            closeme: closeme,\n+        }\n+    }\n+}\n+\n+impl Drop for WindowsTTY {\n+    fn drop(&mut self) {\n+        if self.closeme {\n+            // Nobody cares about the return value\n+            let _ = unsafe { CloseHandle(self.handle) };\n+        }\n+    }\n+}\n+\n+impl RtioTTY for WindowsTTY {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        // Read more if the buffer is empty\n+        if self.utf8.eof() {\n+            let mut utf16 = Vec::from_elem(0x1000, 0u16);\n+            let mut num: DWORD = 0;\n+            match unsafe { ReadConsoleW(self.handle,\n+                                         utf16.as_mut_ptr() as LPVOID,\n+                                         utf16.len() as u32,\n+                                         &mut num as LPDWORD,\n+                                         ptr::mut_null()) } {\n+                0 => return Err(super::last_error()),\n+                _ => (),\n+            };\n+            utf16.truncate(num as uint);\n+            let utf8 = match from_utf16(utf16.as_slice()) {\n+                Some(utf8) => utf8.into_bytes(),\n+                None => return Err(invalid_encoding()),\n+            };\n+            self.utf8 = MemReader::new(utf8);\n+        }\n+        // MemReader shouldn't error here since we just filled it\n+        Ok(self.utf8.read(buf).unwrap())\n+    }\n+\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        let utf16 = match from_utf8(buf) {\n+            Some(utf8) => utf8.to_utf16(),\n+            None => return Err(invalid_encoding()),\n+        };\n+        let mut num: DWORD = 0;\n+        match unsafe { WriteConsoleW(self.handle,\n+                                     utf16.as_ptr() as LPCVOID,\n+                                     utf16.len() as u32,\n+                                     &mut num as LPDWORD,\n+                                     ptr::mut_null()) } {\n+            0 => Err(super::last_error()),\n+            _ => Ok(()),\n+        }\n+    }\n+\n+    fn set_raw(&mut self, raw: bool) -> IoResult<()> {\n+        // FIXME\n+        // Somebody needs to decide on which of these flags we want\n+        match unsafe { SetConsoleMode(self.handle,\n+            match raw {\n+                true => 0,\n+                false => ENABLE_ECHO_INPUT | ENABLE_EXTENDED_FLAGS |\n+                         ENABLE_INSERT_MODE | ENABLE_LINE_INPUT |\n+                         ENABLE_PROCESSED_INPUT | ENABLE_QUICK_EDIT_MODE,\n+            }) } {\n+            0 => Err(super::last_error()),\n+            _ => Ok(()),\n+        }\n+    }\n+\n+    fn get_winsize(&mut self) -> IoResult<(int, int)> {\n+        // FIXME\n+        // Get console buffer via CreateFile with CONOUT$\n+        // Make a CONSOLE_SCREEN_BUFFER_INFO\n+        // Call GetConsoleScreenBufferInfo\n+        // Maybe call GetLargestConsoleWindowSize instead?\n+        Err(super::unimpl())\n+    }\n+\n+    // Let us magically declare this as a TTY\n+    fn isatty(&self) -> bool { true }\n+}"}]}