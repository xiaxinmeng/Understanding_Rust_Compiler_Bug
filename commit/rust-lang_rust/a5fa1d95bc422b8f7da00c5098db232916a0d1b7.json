{"sha": "a5fa1d95bc422b8f7da00c5098db232916a0d1b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZmExZDk1YmM0MjJiOGY3ZGEwMGM1MDk4ZGIyMzI5MTZhMGQxYjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-28T00:36:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-28T00:36:46Z"}, "message": "auto merge of #11098 : erickt/rust/collect, r=alexcrichton\n\nThis patch changes `result::collect` (and adds a new `option::collect`) from creating a `~[T]` to take an `Iterator`. This makes the function much more flexible, and may replace the need for #10989.\r\n\r\nThis patch is a little more complicated than it needs to be because of #11084. Once that is fixed we can replace the `CollectIterator` with a `Scan` iterator.\r\n\r\nIt also fixes a test warning.", "tree": {"sha": "14b67993ffed27f2ec40a23b4788c3b8cd1628ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14b67993ffed27f2ec40a23b4788c3b8cd1628ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5fa1d95bc422b8f7da00c5098db232916a0d1b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5fa1d95bc422b8f7da00c5098db232916a0d1b7", "html_url": "https://github.com/rust-lang/rust/commit/a5fa1d95bc422b8f7da00c5098db232916a0d1b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5fa1d95bc422b8f7da00c5098db232916a0d1b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "html_url": "https://github.com/rust-lang/rust/commit/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335"}, {"sha": "1da9112be9652a407e74b2ab93cc21145fc1ca2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1da9112be9652a407e74b2ab93cc21145fc1ca2b", "html_url": "https://github.com/rust-lang/rust/commit/1da9112be9652a407e74b2ab93cc21145fc1ca2b"}], "stats": {"total": 129, "additions": 98, "deletions": 31}, "files": [{"sha": "7a79857e7547e0a5489e4938c0ea766a51a22fdd", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5fa1d95bc422b8f7da00c5098db232916a0d1b7/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fa1d95bc422b8f7da00c5098db232916a0d1b7/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=a5fa1d95bc422b8f7da00c5098db232916a0d1b7", "patch": "@@ -117,7 +117,6 @@ mod test {\n     use prelude::*;\n     use super::*;\n     use io;\n-    use comm;\n     use task;\n \n     #[test]\n@@ -136,7 +135,7 @@ mod test {\n \n         assert_eq!(false, reader.eof());\n \n-        assert_eq!(Some(0), reader.read(~[]));\n+        assert_eq!(Some(0), reader.read([]));\n         assert_eq!(false, reader.eof());\n \n         assert_eq!(Some(3), reader.read(buf));"}, {"sha": "5467a894cff3ba614e59e8c7781d192846da841f", "filename": "src/libstd/option.rs", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a5fa1d95bc422b8f7da00c5098db232916a0d1b7/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fa1d95bc422b8f7da00c5098db232916a0d1b7/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=a5fa1d95bc422b8f7da00c5098db232916a0d1b7", "patch": "@@ -43,7 +43,7 @@ use clone::DeepClone;\n use cmp::{Eq, TotalEq, TotalOrd};\n use default::Default;\n use fmt;\n-use iter::{Iterator, DoubleEndedIterator, ExactSize};\n+use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};\n use kinds::Send;\n use str::OwnedStr;\n use to_str::ToStr;\n@@ -410,6 +410,46 @@ impl<A> DoubleEndedIterator<A> for OptionIterator<A> {\n \n impl<A> ExactSize<A> for OptionIterator<A> {}\n \n+/////////////////////////////////////////////////////////////////////////////\n+// Free functions\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// Takes each element in the `Iterator`: if it is `None`, no further\n+/// elements are taken, and the `None` is returned. Should no `None` occur, a\n+/// vector containing the values of each `Option` is returned.\n+///\n+/// Here is an example which increments every integer in a vector,\n+/// checking for overflow:\n+///\n+///     fn inc_conditionally(x: uint) -> Option<uint> {\n+///         if x == uint::max_value { return None; }\n+///         else { return Some(x+1u); }\n+///     }\n+///     let v = [1u, 2, 3];\n+///     let res = collect(v.iter().map(|&x| inc_conditionally(x)));\n+///     assert!(res == Some(~[2u, 3, 4]));\n+#[inline]\n+pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(iter: Iter) -> Option<V> {\n+    // FIXME(#11084): This should be twice as fast once this bug is closed.\n+    let mut iter = iter.scan(false, |state, x| {\n+        match x {\n+            Some(x) => Some(x),\n+            None => {\n+                *state = true;\n+                None\n+            }\n+        }\n+    });\n+\n+    let v: V = FromIterator::from_iterator(&mut iter);\n+\n+    if iter.state {\n+        None\n+    } else {\n+        Some(v)\n+    }\n+}\n+\n /////////////////////////////////////////////////////////////////////////////\n // Tests\n /////////////////////////////////////////////////////////////////////////////\n@@ -418,8 +458,10 @@ impl<A> ExactSize<A> for OptionIterator<A> {}\n mod tests {\n     use super::*;\n \n+    use iter::range;\n     use str::StrSlice;\n     use util;\n+    use vec::ImmutableVector;\n \n     #[test]\n     fn test_get_ptr() {\n@@ -661,4 +703,26 @@ mod tests {\n         assert!(!x.mutate_default(0i, |i| i+1));\n         assert_eq!(x, Some(0i));\n     }\n+\n+    #[test]\n+    fn test_collect() {\n+        let v: Option<~[int]> = collect(range(0, 0)\n+                                        .map(|_| Some(0)));\n+        assert_eq!(v, Some(~[]));\n+\n+        let v: Option<~[int]> = collect(range(0, 3)\n+                                        .map(|x| Some(x)));\n+        assert_eq!(v, Some(~[0, 1, 2]));\n+\n+        let v: Option<~[int]> = collect(range(0, 3)\n+                                        .map(|x| if x > 1 { None } else { Some(x) }));\n+        assert_eq!(v, None);\n+\n+        // test that it does not take more elements than it needs\n+        let functions = [|| Some(()), || None, || fail!()];\n+\n+        let v: Option<~[()]> = collect(functions.iter().map(|f| (*f)()));\n+\n+        assert_eq!(v, None);\n+    }\n }"}, {"sha": "2dbba3096982fb638547f6bc9def5842ebecad90", "filename": "src/libstd/result.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a5fa1d95bc422b8f7da00c5098db232916a0d1b7/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fa1d95bc422b8f7da00c5098db232916a0d1b7/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=a5fa1d95bc422b8f7da00c5098db232916a0d1b7", "patch": "@@ -13,12 +13,10 @@\n use clone::Clone;\n use cmp::Eq;\n use fmt;\n-use iter::Iterator;\n+use iter::{Iterator, FromIterator};\n use option::{None, Option, Some};\n use str::OwnedStr;\n use to_str::ToStr;\n-use vec::OwnedVector;\n-use vec;\n \n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n #[deriving(Clone, DeepClone, Eq, Ord, TotalEq, TotalOrd, ToStr)]\n@@ -221,10 +219,9 @@ impl<T: fmt::Default, E: fmt::Default> fmt::Default for Result<T, E> {\n // Free functions\n /////////////////////////////////////////////////////////////////////////////\n \n-/// Takes each element in the iterator: if it is an error, no further\n-/// elements are taken, and the error is returned.\n-/// Should no error occur, a vector containing the values of each Result\n-/// is returned.\n+/// Takes each element in the `Iterator`: if it is an `Err`, no further\n+/// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n+/// vector containing the values of each `Result` is returned.\n ///\n /// Here is an example which increments every integer in a vector,\n /// checking for overflow:\n@@ -237,17 +234,24 @@ impl<T: fmt::Default, E: fmt::Default> fmt::Default for Result<T, E> {\n ///     let res = collect(v.iter().map(|&x| inc_conditionally(x)));\n ///     assert!(res == Ok(~[2u, 3, 4]));\n #[inline]\n-pub fn collect<T, E, Iter: Iterator<Result<T, E>>>(mut iterator: Iter)\n-    -> Result<~[T], E> {\n-    let (lower, _) = iterator.size_hint();\n-    let mut vs: ~[T] = vec::with_capacity(lower);\n-    for t in iterator {\n-        match t {\n-            Ok(v) => vs.push(v),\n-            Err(u) => return Err(u)\n+pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(iter: Iter) -> Result<V, E> {\n+    // FIXME(#11084): This should be twice as fast once this bug is closed.\n+    let mut iter = iter.scan(None, |state, x| {\n+        match x {\n+            Ok(x) => Some(x),\n+            Err(err) => {\n+                *state = Some(err);\n+                None\n+            }\n         }\n+    });\n+\n+    let v: V = FromIterator::from_iterator(&mut iter);\n+\n+    match iter.state {\n+        Some(err) => Err(err),\n+        None => Ok(v),\n     }\n-    Ok(vs)\n }\n \n /// Perform a fold operation over the result values from an iterator.\n@@ -291,8 +295,8 @@ mod tests {\n     use super::*;\n \n     use iter::range;\n-    use vec::ImmutableVector;\n     use to_str::ToStr;\n+    use vec::ImmutableVector;\n \n     pub fn op1() -> Result<int, ~str> { Ok(666) }\n     pub fn op2() -> Result<int, ~str> { Err(~\"sadface\") }\n@@ -347,21 +351,21 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        assert_eq!(collect(range(0, 0)\n-                           .map(|_| Ok::<int, ()>(0))),\n-                   Ok(~[]));\n-        assert_eq!(collect(range(0, 3)\n-                           .map(|x| Ok::<int, ()>(x))),\n-                   Ok(~[0, 1, 2]));\n-        assert_eq!(collect(range(0, 3)\n-                           .map(|x| if x > 1 { Err(x) } else { Ok(x) })),\n-                   Err(2));\n+        let v: Result<~[int], ()> = collect(range(0, 0).map(|_| Ok::<int, ()>(0)));\n+        assert_eq!(v, Ok(~[]));\n+\n+        let v: Result<~[int], ()> = collect(range(0, 3).map(|x| Ok::<int, ()>(x)));\n+        assert_eq!(v, Ok(~[0, 1, 2]));\n+\n+        let v: Result<~[int], int> = collect(range(0, 3)\n+                                             .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n+        assert_eq!(v, Err(2));\n \n         // test that it does not take more elements than it needs\n         let functions = [|| Ok(()), || Err(1), || fail!()];\n \n-        assert_eq!(collect(functions.iter().map(|f| (*f)())),\n-                   Err(1));\n+        let v: Result<~[()], int> = collect(functions.iter().map(|f| (*f)()));\n+        assert_eq!(v, Err(1));\n     }\n \n     #[test]"}]}