{"sha": "40170885e799ebdefb24ed00865cd1c7800af491", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMTcwODg1ZTc5OWViZGVmYjI0ZWQwMDg2NWNkMWM3ODAwYWY0OTE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-09T11:52:31Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-10T12:46:39Z"}, "message": "WIP: switch to fully decomposed tokens internally", "tree": {"sha": "1b7a6f1eaaa70e1db70dd5763377fd877636a55d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b7a6f1eaaa70e1db70dd5763377fd877636a55d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40170885e799ebdefb24ed00865cd1c7800af491", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40170885e799ebdefb24ed00865cd1c7800af491", "html_url": "https://github.com/rust-lang/rust/commit/40170885e799ebdefb24ed00865cd1c7800af491", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40170885e799ebdefb24ed00865cd1c7800af491/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2ebb467bdf3ebb7d29260adb95c56594c6db282", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2ebb467bdf3ebb7d29260adb95c56594c6db282", "html_url": "https://github.com/rust-lang/rust/commit/e2ebb467bdf3ebb7d29260adb95c56594c6db282"}], "stats": {"total": 703, "additions": 423, "deletions": 280}, "files": [{"sha": "0158f9b8adbf74e1a2bca0d22f5a14d9e4a527b2", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=40170885e799ebdefb24ed00865cd1c7800af491", "patch": "@@ -210,7 +210,7 @@ fn opt_visibility(p: &mut Parser) -> bool {\n         //\n         // test crate_keyword_path\n         // fn foo() { crate::foo(); }\n-        T![crate] if p.nth(1) != T![::] => {\n+        T![crate] if !p.nth_at(1, T![::]) => {\n             let m = p.start();\n             p.bump_any();\n             m.complete(p, VISIBILITY);\n@@ -245,7 +245,7 @@ fn abi(p: &mut Parser) {\n fn opt_fn_ret_type(p: &mut Parser) -> bool {\n     if p.at(T![->]) {\n         let m = p.start();\n-        p.bump_any();\n+        p.bump(T![->]);\n         types::type_(p);\n         m.complete(p, RET_TYPE);\n         true"}, {"sha": "ea04b945822471907e6f1e0b8b4b8b35889cd908", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 107, "deletions": 91, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=40170885e799ebdefb24ed00865cd1c7800af491", "patch": "@@ -212,52 +212,48 @@ struct Restrictions {\n     prefer_stmt: bool,\n }\n \n-enum Op {\n-    Simple,\n-    Composite(SyntaxKind, u8),\n-}\n-\n-fn current_op(p: &Parser) -> (u8, Op) {\n-    if let Some(t) = p.current3() {\n-        match t {\n-            (T![<], T![<], T![=]) => return (1, Op::Composite(T![<<=], 3)),\n-            (T![>], T![>], T![=]) => return (1, Op::Composite(T![>>=], 3)),\n-            _ => (),\n-        }\n-    }\n-\n-    if let Some(t) = p.current2() {\n-        match t {\n-            (T![+], T![=]) => return (1, Op::Composite(T![+=], 2)),\n-            (T![-], T![=]) => return (1, Op::Composite(T![-=], 2)),\n-            (T![*], T![=]) => return (1, Op::Composite(T![*=], 2)),\n-            (T![%], T![=]) => return (1, Op::Composite(T![%=], 2)),\n-            (T![/], T![=]) => return (1, Op::Composite(T![/=], 2)),\n-            (T![|], T![=]) => return (1, Op::Composite(T![|=], 2)),\n-            (T![&], T![=]) => return (1, Op::Composite(T![&=], 2)),\n-            (T![^], T![=]) => return (1, Op::Composite(T![^=], 2)),\n-            (T![|], T![|]) => return (3, Op::Composite(T![||], 2)),\n-            (T![&], T![&]) => return (4, Op::Composite(T![&&], 2)),\n-            (T![<], T![=]) => return (5, Op::Composite(T![<=], 2)),\n-            (T![>], T![=]) => return (5, Op::Composite(T![>=], 2)),\n-            (T![<], T![<]) => return (9, Op::Composite(T![<<], 2)),\n-            (T![>], T![>]) => return (9, Op::Composite(T![>>], 2)),\n-            _ => (),\n-        }\n+/// Binding powers of operators for a Pratt parser.\n+///\n+/// See https://www.oilshell.org/blog/2016/11/03.html\n+#[rustfmt::skip]\n+fn current_op(p: &Parser) -> (u8, SyntaxKind) {\n+    const NOT_AN_OP: (u8, SyntaxKind) = (0, T![@]);\n+    match p.current() {\n+        T![|] if p.at(T![||])  => (3,  T![||]),\n+        T![|] if p.at(T![|=])  => (1,  T![|=]),\n+        T![|]                  => (6,  T![|]),\n+        T![>] if p.at(T![>>=]) => (1,  T![>>=]),\n+        T![>] if p.at(T![>>])  => (9,  T![>>]),\n+        T![>] if p.at(T![>=])  => (5,  T![>=]),\n+        T![>]                  => (5,  T![>]),\n+        T![=] if p.at(T![=>])  => NOT_AN_OP,\n+        T![=] if p.at(T![==])  => (5,  T![==]),\n+        T![=]                  => (1,  T![=]),\n+        T![<] if p.at(T![<=])  => (5,  T![<=]),\n+        T![<] if p.at(T![<<=]) => (1,  T![<<=]),\n+        T![<] if p.at(T![<<])  => (9,  T![<<]),\n+        T![<]                  => (5,  T![<]),\n+        T![+] if p.at(T![+=])  => (1,  T![+=]),\n+        T![+]                  => (10, T![+]),\n+        T![^] if p.at(T![^=])  => (1,  T![^=]),\n+        T![^]                  => (7,  T![^]),\n+        T![%] if p.at(T![%=])  => (1,  T![%=]),\n+        T![%]                  => (11, T![%]),\n+        T![&] if p.at(T![&=])  => (1,  T![&=]),\n+        T![&] if p.at(T![&&])  => (4,  T![&&]),\n+        T![&]                  => (8,  T![&]),\n+        T![/] if p.at(T![/=])  => (1,  T![/=]),\n+        T![/]                  => (11, T![/]),\n+        T![*] if p.at(T![*=])  => (1,  T![*=]),\n+        T![*]                  => (11, T![*]),\n+        T![.] if p.at(T![..=]) => (2,  T![..=]),\n+        T![.] if p.at(T![..])  => (2,  T![..]),\n+        T![!] if p.at(T![!=])  => (5,  T![!=]),\n+        T![-] if p.at(T![-=])  => (1,  T![-=]),\n+        T![-]                  => (10, T![-]),\n+\n+        _                      => NOT_AN_OP\n     }\n-\n-    let bp = match p.current() {\n-        T![=] => 1,\n-        T![..] | T![..=] => 2,\n-        T![==] | T![!=] | T![<] | T![>] => 5,\n-        T![|] => 6,\n-        T![^] => 7,\n-        T![&] => 8,\n-        T![-] | T![+] => 10,\n-        T![*] | T![/] | T![%] => 11,\n-        _ => 0,\n-    };\n-    (bp, Op::Simple)\n }\n \n // Parses expression with binding power of at least bp.\n@@ -308,21 +304,15 @@ fn expr_bp(\n             break;\n         }\n         let m = lhs.precede(p);\n-        match op {\n-            Op::Simple => p.bump_any(),\n-            Op::Composite(kind, n) => {\n-                p.bump_compound(kind, n);\n-            }\n-        }\n+        p.bump(op);\n \n         expr_bp(p, r, op_bp + 1, dollar_lvl);\n         lhs = m.complete(p, if is_range { RANGE_EXPR } else { BIN_EXPR });\n     }\n     (Some(lhs), BlockLike::NotBlock)\n }\n \n-const LHS_FIRST: TokenSet =\n-    atom::ATOM_EXPR_FIRST.union(token_set![AMP, STAR, EXCL, DOTDOT, DOTDOTEQ, MINUS]);\n+const LHS_FIRST: TokenSet = atom::ATOM_EXPR_FIRST.union(token_set![AMP, STAR, EXCL, DOT, MINUS]);\n \n fn lhs(\n     p: &mut Parser,\n@@ -353,17 +343,20 @@ fn lhs(\n             p.bump_any();\n             PREFIX_EXPR\n         }\n-        // test full_range_expr\n-        // fn foo() { xs[..]; }\n-        T![..] | T![..=] => {\n-            m = p.start();\n-            p.bump_any();\n-            if p.at_ts(EXPR_FIRST) {\n-                expr_bp(p, r, 2, dollar_lvl);\n-            }\n-            return Some((m.complete(p, RANGE_EXPR), BlockLike::NotBlock));\n-        }\n         _ => {\n+            // test full_range_expr\n+            // fn foo() { xs[..]; }\n+            for &op in [T![..=], T![..]].iter() {\n+                if p.at(op) {\n+                    m = p.start();\n+                    p.bump(op);\n+                    if p.at_ts(EXPR_FIRST) {\n+                        expr_bp(p, r, 2, dollar_lvl);\n+                    }\n+                    return Some((m.complete(p, RANGE_EXPR), BlockLike::NotBlock));\n+                }\n+            }\n+\n             // test expression_after_block\n             // fn foo() {\n             //    let mut p = F{x: 5};\n@@ -399,37 +392,60 @@ fn postfix_expr(\n             // }\n             T!['('] if allow_calls => call_expr(p, lhs),\n             T!['['] if allow_calls => index_expr(p, lhs),\n-            T![.] if p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth(2) == T![::]) => {\n-                method_call_expr(p, lhs)\n-            }\n-            T![.] if p.nth(1) == AWAIT_KW => {\n-                // test await_expr\n-                // fn foo() {\n-                //     x.await;\n-                //     x.0.await;\n-                //     x.0().await?.hello();\n-                // }\n-                let m = lhs.precede(p);\n-                p.bump_any();\n-                p.bump_any();\n-                m.complete(p, AWAIT_EXPR)\n-            }\n-            T![.] => field_expr(p, lhs),\n-            // test postfix_range\n-            // fn foo() { let x = 1..; }\n-            T![..] | T![..=] if !EXPR_FIRST.contains(p.nth(1)) => {\n-                let m = lhs.precede(p);\n-                p.bump_any();\n-                m.complete(p, RANGE_EXPR)\n-            }\n+            T![.] => match postfix_dot_expr(p, lhs) {\n+                Ok(it) => it,\n+                Err(it) => {\n+                    lhs = it;\n+                    break;\n+                }\n+            },\n             T![?] => try_expr(p, lhs),\n             T![as] => cast_expr(p, lhs),\n             _ => break,\n         };\n         allow_calls = true;\n         block_like = BlockLike::NotBlock;\n     }\n-    (lhs, block_like)\n+    return (lhs, block_like);\n+\n+    fn postfix_dot_expr(\n+        p: &mut Parser,\n+        lhs: CompletedMarker,\n+    ) -> Result<CompletedMarker, CompletedMarker> {\n+        assert!(p.at(T![.]));\n+        if p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth_at(2, T![::])) {\n+            return Ok(method_call_expr(p, lhs));\n+        }\n+\n+        // test await_expr\n+        // fn foo() {\n+        //     x.await;\n+        //     x.0.await;\n+        //     x.0().await?.hello();\n+        // }\n+        if p.nth(1) == T![await] {\n+            let m = lhs.precede(p);\n+            p.bump(T![.]);\n+            p.bump(T![await]);\n+            return Ok(m.complete(p, AWAIT_EXPR));\n+        }\n+\n+        // test postfix_range\n+        // fn foo() { let x = 1..; }\n+        for &(op, la) in [(T![..=], 3), (T![..], 2)].iter() {\n+            if p.at(op) {\n+                return if EXPR_FIRST.contains(p.nth(la)) {\n+                    Err(lhs)\n+                } else {\n+                    let m = lhs.precede(p);\n+                    p.bump(op);\n+                    Ok(m.complete(p, RANGE_EXPR))\n+                };\n+            }\n+        }\n+\n+        Ok(field_expr(p, lhs))\n+    }\n }\n \n // test call_expr\n@@ -465,7 +481,7 @@ fn index_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n //     y.bar::<T>(1, 2,);\n // }\n fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(T![.]) && p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth(2) == T![::]));\n+    assert!(p.at(T![.]) && p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth_at(2, T![::])));\n     let m = lhs.precede(p);\n     p.bump_any();\n     name_ref(p);\n@@ -567,7 +583,7 @@ fn path_expr(p: &mut Parser, r: Restrictions) -> (CompletedMarker, BlockLike) {\n             record_field_list(p);\n             (m.complete(p, RECORD_LIT), BlockLike::NotBlock)\n         }\n-        T![!] => {\n+        T![!] if !p.at(T![!=]) => {\n             let block_like = items::macro_call_after_excl(p);\n             (m.complete(p, MACRO_CALL), block_like)\n         }\n@@ -601,8 +617,8 @@ pub(crate) fn record_field_list(p: &mut Parser) {\n                 }\n                 m.complete(p, RECORD_FIELD);\n             }\n-            T![..] => {\n-                p.bump_any();\n+            T![.] if p.at(T![..]) => {\n+                p.bump(T![..]);\n                 expr(p);\n             }\n             T!['{'] => error_block(p, \"expected a field\"),"}, {"sha": "eff9d67e49d8468951b6f59128fc1af613e926fd", "filename": "crates/ra_parser/src/grammar/items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs?ref=40170885e799ebdefb24ed00865cd1c7800af491", "patch": "@@ -422,7 +422,7 @@ pub(crate) fn token_tree(p: &mut Parser) {\n                 return;\n             }\n             T![')'] | T![']'] => p.err_and_bump(\"unmatched brace\"),\n-            _ => p.bump_raw(),\n+            _ => p.bump_any(),\n         }\n     }\n     p.expect(closing_paren_kind);"}, {"sha": "f28f522b83b956642fa1ac82bc0bbd0a134c6ad2", "filename": "crates/ra_parser/src/grammar/items/use_item.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs?ref=40170885e799ebdefb24ed00865cd1c7800af491", "patch": "@@ -13,9 +13,8 @@ pub(super) fn use_item(p: &mut Parser, m: Marker) {\n /// so handles both `some::path::{inner::path}` and `inner::path` in\n /// `use some::path::{inner::path};`\n fn use_tree(p: &mut Parser) {\n-    let la = p.nth(1);\n     let m = p.start();\n-    match (p.current(), la) {\n+    match p.current() {\n         // Finish the use_tree for cases of e.g.\n         // `use some::path::{self, *};` or `use *;`\n         // This does not handle cases such as `use some::path::*`\n@@ -28,15 +27,15 @@ fn use_tree(p: &mut Parser) {\n         // use ::*;\n         // use some::path::{*};\n         // use some::path::{::*};\n-        (T![*], _) => p.bump_any(),\n-        (T![::], T![*]) => {\n+        T![*] => p.bump(T![*]),\n+        T![:] if p.at(T![::]) && p.nth(2) == T![*] => {\n             // Parse `use ::*;`, which imports all from the crate root in Rust 2015\n             // This is invalid inside a use_tree_list, (e.g. `use some::path::{::*}`)\n             // but still parses and errors later: ('crate root in paths can only be used in start position')\n             // FIXME: Add this error (if not out of scope)\n             // In Rust 2018, it is always invalid (see above)\n-            p.bump_any();\n-            p.bump_any();\n+            p.bump(T![::]);\n+            p.bump(T![*]);\n         }\n         // Open a use tree list\n         // Handles cases such as `use {some::path};` or `{inner::path}` in\n@@ -47,10 +46,11 @@ fn use_tree(p: &mut Parser) {\n         // use {path::from::root}; // Rust 2015\n         // use ::{some::arbritrary::path}; // Rust 2015\n         // use ::{{{crate::export}}}; // Nonsensical but perfectly legal nestnig\n-        (T!['{'], _) | (T![::], T!['{']) => {\n-            if p.at(T![::]) {\n-                p.bump_any();\n-            }\n+        T!['{'] => {\n+            use_tree_list(p);\n+        }\n+        T![:] if p.at(T![::]) && p.nth(2) == T!['{'] => {\n+            p.bump(T![::]);\n             use_tree_list(p);\n         }\n         // Parse a 'standard' path.\n@@ -80,8 +80,8 @@ fn use_tree(p: &mut Parser) {\n                     // use Trait as _;\n                     opt_alias(p);\n                 }\n-                T![::] => {\n-                    p.bump_any();\n+                T![:] if p.at(T![::]) => {\n+                    p.bump(T![::]);\n                     match p.current() {\n                         T![*] => {\n                             p.bump_any();"}, {"sha": "5893b22fdc5e056d09f1c33c1a4ec40f851a8673", "filename": "crates/ra_parser/src/grammar/params.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs?ref=40170885e799ebdefb24ed00865cd1c7800af491", "patch": "@@ -80,7 +80,7 @@ fn value_parameter(p: &mut Parser, flavor: Flavor) {\n     match flavor {\n         Flavor::OptionalType | Flavor::Normal => {\n             patterns::pattern(p);\n-            if p.at(T![:]) || flavor.type_required() {\n+            if p.at(T![:]) && !p.at(T![::]) || flavor.type_required() {\n                 types::ascription(p)\n             }\n         }\n@@ -96,10 +96,11 @@ fn value_parameter(p: &mut Parser, flavor: Flavor) {\n             // trait Foo {\n             //     fn bar(_: u64, mut x: i32);\n             // }\n-            if (la0 == IDENT || la0 == T![_]) && la1 == T![:]\n+            if (la0 == IDENT || la0 == T![_]) && la1 == T![:] && !p.nth_at(1, T![::])\n                 || la0 == T![mut] && la1 == IDENT && la2 == T![:]\n-                || la0 == T![&] && la1 == IDENT && la2 == T![:]\n-                || la0 == T![&] && la1 == T![mut] && la2 == IDENT && la3 == T![:]\n+                || la0 == T![&]\n+                    && (la1 == IDENT && la2 == T![:] && !p.nth_at(2, T![::])\n+                        || la1 == T![mut] && la2 == IDENT && la3 == T![:] && !p.nth_at(3, T![::]))\n             {\n                 patterns::pattern(p);\n                 types::ascription(p);"}, {"sha": "24b65128edb859986e4444eaa2084dde5897fb3d", "filename": "crates/ra_parser/src/grammar/paths.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=40170885e799ebdefb24ed00865cd1c7800af491", "patch": "@@ -1,15 +1,16 @@\n use super::*;\n \n pub(super) const PATH_FIRST: TokenSet =\n-    token_set![IDENT, SELF_KW, SUPER_KW, CRATE_KW, COLONCOLON, L_ANGLE];\n+    token_set![IDENT, SELF_KW, SUPER_KW, CRATE_KW, COLON, L_ANGLE];\n \n pub(super) fn is_path_start(p: &Parser) -> bool {\n     is_use_path_start(p) || p.at(T![<])\n }\n \n pub(super) fn is_use_path_start(p: &Parser) -> bool {\n     match p.current() {\n-        IDENT | T![self] | T![super] | T![crate] | T![::] => true,\n+        IDENT | T![self] | T![super] | T![crate] => true,\n+        T![:] if p.at(T![::]) => true,\n         _ => false,\n     }\n }\n@@ -38,13 +39,13 @@ fn path(p: &mut Parser, mode: Mode) {\n     path_segment(p, mode, true);\n     let mut qual = path.complete(p, PATH);\n     loop {\n-        let use_tree = match p.nth(1) {\n+        let use_tree = match p.nth(2) {\n             T![*] | T!['{'] => true,\n             _ => false,\n         };\n         if p.at(T![::]) && !use_tree {\n             let path = qual.precede(p);\n-            p.bump_any();\n+            p.bump(T![::]);\n             path_segment(p, mode, false);\n             let path = path.complete(p, PATH);\n             qual = path;"}, {"sha": "dd1d25b07c4b192e6dceeff93f6af9aabda31a73", "filename": "crates/ra_parser/src/grammar/patterns.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=40170885e799ebdefb24ed00865cd1c7800af491", "patch": "@@ -34,17 +34,20 @@ pub(super) fn pattern_r(p: &mut Parser, recovery_set: TokenSet) {\n         //         200 .. 301=> (),\n         //     }\n         // }\n-        if p.at(T![...]) || p.at(T![..=]) || p.at(T![..]) {\n-            let m = lhs.precede(p);\n-            p.bump_any();\n-            atom_pat(p, recovery_set);\n-            m.complete(p, RANGE_PAT);\n+        for &range_op in [T![...], T![..=], T![..]].iter() {\n+            if p.at(range_op) {\n+                let m = lhs.precede(p);\n+                p.bump(range_op);\n+                atom_pat(p, recovery_set);\n+                m.complete(p, RANGE_PAT);\n+                return;\n+            }\n         }\n         // test marco_pat\n         // fn main() {\n         //     let m!(x) = 0;\n         // }\n-        else if lhs.kind() == PATH_PAT && p.at(T![!]) {\n+        if lhs.kind() == PATH_PAT && p.at(T![!]) {\n             let m = lhs.precede(p);\n             items::macro_call_after_excl(p);\n             m.complete(p, MACRO_CALL);\n@@ -56,14 +59,16 @@ const PAT_RECOVERY_SET: TokenSet =\n     token_set![LET_KW, IF_KW, WHILE_KW, LOOP_KW, MATCH_KW, R_PAREN, COMMA];\n \n fn atom_pat(p: &mut Parser, recovery_set: TokenSet) -> Option<CompletedMarker> {\n-    // Checks the token after an IDENT to see if a pattern is a path (Struct { .. }) or macro\n-    // (T![x]).\n-    let is_path_or_macro_pat =\n-        |la1| la1 == T![::] || la1 == T!['('] || la1 == T!['{'] || la1 == T![!];\n-\n     let m = match p.nth(0) {\n         T![box] => box_pat(p),\n-        T![ref] | T![mut] | IDENT if !is_path_or_macro_pat(p.nth(1)) => bind_pat(p, true),\n+        T![ref] | T![mut] => bind_pat(p, true),\n+        IDENT => match p.nth(1) {\n+            // Checks the token after an IDENT to see if a pattern is a path (Struct { .. }) or macro\n+            // (T![x]).\n+            T!['('] | T!['{'] | T![!] => path_pat(p),\n+            T![:] if p.nth_at(1, T![::]) => path_pat(p),\n+            _ => bind_pat(p, true),\n+        },\n \n         _ if paths::is_use_path_start(p) => path_pat(p),\n         _ if is_literal_pat_start(p) => literal_pat(p),\n@@ -158,7 +163,7 @@ fn record_field_pat_list(p: &mut Parser) {\n     p.bump_any();\n     while !p.at(EOF) && !p.at(T!['}']) {\n         match p.current() {\n-            T![..] => p.bump_any(),\n+            T![.] if p.at(T![..]) => p.bump(T![..]),\n             IDENT if p.nth(1) == T![:] => record_field_pat(p),\n             T!['{'] => error_block(p, \"expected ident\"),\n             T![box] => {\n@@ -237,7 +242,7 @@ fn slice_pat(p: &mut Parser) -> CompletedMarker {\n fn pat_list(p: &mut Parser, ket: SyntaxKind) {\n     while !p.at(EOF) && !p.at(ket) {\n         match p.current() {\n-            T![..] => p.bump_any(),\n+            T![.] if p.at(T![..]) => p.bump(T![..]),\n             _ => {\n                 if !p.at_ts(PATTERN_FIRST) {\n                     p.error(\"expected a pattern\");"}, {"sha": "edc7d4ff2b7f89c4640ce5580970cf18a9e6aeca", "filename": "crates/ra_parser/src/grammar/type_args.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs?ref=40170885e799ebdefb24ed00865cd1c7800af491", "patch": "@@ -2,19 +2,16 @@ use super::*;\n \n pub(super) fn opt_type_arg_list(p: &mut Parser, colon_colon_required: bool) {\n     let m;\n-    match (colon_colon_required, p.nth(0), p.nth(1)) {\n-        (_, T![::], T![<]) => {\n-            m = p.start();\n-            p.bump_any();\n-            p.bump_any();\n-        }\n-        (false, T![<], T![=]) => return,\n-        (false, T![<], _) => {\n-            m = p.start();\n-            p.bump_any();\n-        }\n-        _ => return,\n-    };\n+    if p.at(T![::]) && p.nth(2) == T![<] {\n+        m = p.start();\n+        p.bump(T![::]);\n+        p.bump(T![<]);\n+    } else if !colon_colon_required && p.at(T![<]) && p.nth(1) != T![=] {\n+        m = p.start();\n+        p.bump(T![<]);\n+    } else {\n+        return;\n+    }\n \n     while !p.at(EOF) && !p.at(T![>]) {\n         type_arg(p);\n@@ -37,7 +34,7 @@ fn type_arg(p: &mut Parser) {\n         }\n         // test associated_type_bounds\n         // fn print_all<T: Iterator<Item: Display>>(printables: T) {}\n-        IDENT if p.nth(1) == T![:] => {\n+        IDENT if p.nth(1) == T![:] && p.nth(2) != T![:] => {\n             name_ref(p);\n             type_params::bounds(p);\n             m.complete(p, ASSOC_TYPE_ARG);"}, {"sha": "a27cdc2eaf5ae5bc5375563731cfe81ff8bd8f2a", "filename": "crates/ra_parser/src/parser.rs", "status": "modified", "additions": 115, "deletions": 137, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_parser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fparser.rs?ref=40170885e799ebdefb24ed00865cd1c7800af491", "patch": "@@ -6,7 +6,7 @@ use crate::{\n     event::Event,\n     ParseError,\n     SyntaxKind::{self, EOF, ERROR, TOMBSTONE},\n-    Token, TokenSet, TokenSource, T,\n+    TokenSet, TokenSource, T,\n };\n \n /// `Parser` struct provides the low-level API for\n@@ -40,38 +40,6 @@ impl<'t> Parser<'t> {\n         self.nth(0)\n     }\n \n-    /// Returns the kinds of the current two tokens, if they are not separated\n-    /// by trivia.\n-    ///\n-    /// Useful for parsing things like `>>`.\n-    pub(crate) fn current2(&self) -> Option<(SyntaxKind, SyntaxKind)> {\n-        let c1 = self.nth(0);\n-        let c2 = self.nth(1);\n-\n-        if self.token_source.current().is_jointed_to_next {\n-            Some((c1, c2))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Returns the kinds of the current three tokens, if they are not separated\n-    /// by trivia.\n-    ///\n-    /// Useful for parsing things like `=>>`.\n-    pub(crate) fn current3(&self) -> Option<(SyntaxKind, SyntaxKind, SyntaxKind)> {\n-        let c1 = self.nth(0);\n-        let c2 = self.nth(1);\n-        let c3 = self.nth(2);\n-        if self.token_source.current().is_jointed_to_next\n-            && self.token_source.lookahead_nth(1).is_jointed_to_next\n-        {\n-            Some((c1, c2, c3))\n-        } else {\n-            None\n-        }\n-    }\n-\n     /// Lookahead operation: returns the kind of the next nth\n     /// token.\n     pub(crate) fn nth(&self, n: usize) -> SyntaxKind {\n@@ -81,33 +49,116 @@ impl<'t> Parser<'t> {\n         assert!(steps <= 10_000_000, \"the parser seems stuck\");\n         self.steps.set(steps + 1);\n \n-        // It is beecause the Dollar will appear between nth\n-        // Following code skips through it\n-        let mut non_dollars_count = 0;\n-        let mut i = 0;\n+        self.token_source.lookahead_nth(n).kind\n \n-        loop {\n-            let token = self.token_source.lookahead_nth(i);\n-            let mut kind = token.kind;\n-            if let Some((composited, step)) = self.is_composite(token, i) {\n-                kind = composited;\n-                i += step;\n-            } else {\n-                i += 1;\n-            }\n+        // // It is because the Dollar will appear between nth\n+        // // Following code skips through it\n+        // let mut non_dollars_count = 0;\n+        // let mut i = 0;\n \n-            match kind {\n-                EOF => return EOF,\n-                SyntaxKind::L_DOLLAR | SyntaxKind::R_DOLLAR => {}\n-                _ if non_dollars_count == n => return kind,\n-                _ => non_dollars_count += 1,\n-            }\n-        }\n+        // loop {\n+        //     let token = self.token_source.lookahead_nth(i);\n+        //     let mut kind = token.kind;\n+        //     if let Some((composited, step)) = self.is_composite(token, i) {\n+        //         kind = composited;\n+        //         i += step;\n+        //     } else {\n+        //         i += 1;\n+        //     }\n+\n+        //     match kind {\n+        //         EOF => return EOF,\n+        //         SyntaxKind::L_DOLLAR | SyntaxKind::R_DOLLAR => {}\n+        //         _ if non_dollars_count == n => return kind,\n+        //         _ => non_dollars_count += 1,\n+        //     }\n+        // }\n     }\n \n     /// Checks if the current token is `kind`.\n     pub(crate) fn at(&self, kind: SyntaxKind) -> bool {\n-        self.current() == kind\n+        self.nth_at(0, kind)\n+    }\n+\n+    pub(crate) fn nth_at(&self, n: usize, kind: SyntaxKind) -> bool {\n+        match kind {\n+            T![-=] => self.at_composite2(n, T![-], T![=]),\n+            T![->] => self.at_composite2(n, T![-], T![>]),\n+            T![::] => self.at_composite2(n, T![:], T![:]),\n+            T![!=] => self.at_composite2(n, T![!], T![=]),\n+            T![..] => self.at_composite2(n, T![.], T![.]),\n+            T![*=] => self.at_composite2(n, T![*], T![=]),\n+            T![/=] => self.at_composite2(n, T![/], T![=]),\n+            T![&&] => self.at_composite2(n, T![&], T![&]),\n+            T![&=] => self.at_composite2(n, T![&], T![=]),\n+            T![%=] => self.at_composite2(n, T![%], T![=]),\n+            T![^=] => self.at_composite2(n, T![^], T![=]),\n+            T![+=] => self.at_composite2(n, T![+], T![=]),\n+            T![<<] => self.at_composite2(n, T![<], T![<]),\n+            T![<=] => self.at_composite2(n, T![<], T![=]),\n+            T![==] => self.at_composite2(n, T![=], T![=]),\n+            T![=>] => self.at_composite2(n, T![=], T![>]),\n+            T![>=] => self.at_composite2(n, T![>], T![=]),\n+            T![>>] => self.at_composite2(n, T![>], T![>]),\n+            T![|=] => self.at_composite2(n, T![|], T![=]),\n+            T![||] => self.at_composite2(n, T![|], T![|]),\n+\n+            T![...] => self.at_composite3(n, T![.], T![.], T![.]),\n+            T![..=] => self.at_composite3(n, T![.], T![.], T![=]),\n+            T![<<=] => self.at_composite3(n, T![<], T![<], T![=]),\n+            T![>>=] => self.at_composite3(n, T![>], T![>], T![=]),\n+\n+            _ => self.token_source.lookahead_nth(n).kind == kind,\n+        }\n+    }\n+\n+    /// Consume the next token if `kind` matches.\n+    pub(crate) fn eat(&mut self, kind: SyntaxKind) -> bool {\n+        if !self.at(kind) {\n+            return false;\n+        }\n+        let n_raw_tokens = match kind {\n+            T![-=]\n+            | T![->]\n+            | T![::]\n+            | T![!=]\n+            | T![..]\n+            | T![*=]\n+            | T![/=]\n+            | T![&&]\n+            | T![&=]\n+            | T![%=]\n+            | T![^=]\n+            | T![+=]\n+            | T![<<]\n+            | T![<=]\n+            | T![==]\n+            | T![=>]\n+            | T![>=]\n+            | T![>>]\n+            | T![|=]\n+            | T![||] => 2,\n+\n+            T![...] | T![..=] | T![<<=] | T![>>=] => 3,\n+            _ => 1,\n+        };\n+        self.do_bump(kind, n_raw_tokens);\n+        true\n+    }\n+\n+    fn at_composite2(&self, n: usize, k1: SyntaxKind, k2: SyntaxKind) -> bool {\n+        let t1 = self.token_source.lookahead_nth(n + 0);\n+        let t2 = self.token_source.lookahead_nth(n + 1);\n+        t1.kind == k1 && t1.is_jointed_to_next && t2.kind == k2\n+    }\n+\n+    fn at_composite3(&self, n: usize, k1: SyntaxKind, k2: SyntaxKind, k3: SyntaxKind) -> bool {\n+        let t1 = self.token_source.lookahead_nth(n + 0);\n+        let t2 = self.token_source.lookahead_nth(n + 1);\n+        let t3 = self.token_source.lookahead_nth(n + 2);\n+        (t1.kind == k1 && t1.is_jointed_to_next)\n+            && (t2.kind == k2 && t2.is_jointed_to_next)\n+            && t3.kind == k3\n     }\n \n     /// Checks if the current token is in `kinds`.\n@@ -129,9 +180,15 @@ impl<'t> Parser<'t> {\n         Marker::new(pos)\n     }\n \n+    /// Consume the next token if `kind` matches.\n+    pub(crate) fn bump(&mut self, kind: SyntaxKind) {\n+        assert!(self.eat(kind));\n+    }\n+\n     /// Advances the parser by one token unconditionally\n     /// Mainly use in `token_tree` parsing\n-    pub(crate) fn bump_raw(&mut self) {\n+    #[allow(unused)]\n+    fn bump_raw(&mut self) {\n         let mut kind = self.token_source.current().kind;\n \n         // Skip dollars, do_bump will eat these later\n@@ -153,27 +210,7 @@ impl<'t> Parser<'t> {\n         if kind == EOF {\n             return;\n         }\n-\n-        use SyntaxKind::*;\n-\n-        // Handle parser composites\n-        match kind {\n-            T![...] | T![..=] => {\n-                self.bump_compound(kind, 3);\n-            }\n-            T![..] | T![::] | T![==] | T![=>] | T![!=] | T![->] => {\n-                self.bump_compound(kind, 2);\n-            }\n-            _ => {\n-                self.do_bump(kind, 1);\n-            }\n-        }\n-    }\n-\n-    /// Advances the parser by one token, asserting that it is exactly the expected token\n-    pub(crate) fn bump(&mut self, expected: SyntaxKind) {\n-        debug_assert!(self.nth(0) == expected);\n-        self.bump_any()\n+        self.do_bump(kind, 1)\n     }\n \n     /// Advances the parser by one token, remapping its kind.\n@@ -190,13 +227,6 @@ impl<'t> Parser<'t> {\n         self.do_bump(kind, 1);\n     }\n \n-    /// Advances the parser by `n` tokens, remapping its kind.\n-    /// This is useful to create compound tokens from parts. For\n-    /// example, an `<<` token is two consecutive remapped `<` tokens\n-    pub(crate) fn bump_compound(&mut self, kind: SyntaxKind, n: u8) {\n-        self.do_bump(kind, n);\n-    }\n-\n     /// Emit error with the `message`\n     /// FIXME: this should be much more fancy and support\n     /// structured errors with spans and notes, like rustc\n@@ -206,15 +236,6 @@ impl<'t> Parser<'t> {\n         self.push_event(Event::Error { msg })\n     }\n \n-    /// Consume the next token if `kind` matches.\n-    pub(crate) fn eat(&mut self, kind: SyntaxKind) -> bool {\n-        if !self.at(kind) {\n-            return false;\n-        }\n-        self.bump_any();\n-        true\n-    }\n-\n     /// Consume the next token if it is `kind` or emit an error\n     /// otherwise.\n     pub(crate) fn expect(&mut self, kind: SyntaxKind) -> bool {\n@@ -243,7 +264,7 @@ impl<'t> Parser<'t> {\n     }\n \n     fn do_bump(&mut self, kind: SyntaxKind, n_raw_tokens: u8) {\n-        self.eat_dollars();\n+        // self.eat_dollars();\n \n         for _ in 0..n_raw_tokens {\n             self.token_source.bump();\n@@ -256,50 +277,7 @@ impl<'t> Parser<'t> {\n         self.events.push(event)\n     }\n \n-    /// helper function for check if it is composite.\n-    fn is_composite(&self, first: Token, n: usize) -> Option<(SyntaxKind, usize)> {\n-        // We assume the dollars will not occuried between\n-        // mult-byte tokens\n-\n-        let jn1 = first.is_jointed_to_next;\n-        if !jn1 && first.kind != T![-] {\n-            return None;\n-        }\n-\n-        let second = self.token_source.lookahead_nth(n + 1);\n-        if first.kind == T![-] && second.kind == T![>] {\n-            return Some((T![->], 2));\n-        }\n-        if !jn1 {\n-            return None;\n-        }\n-\n-        match (first.kind, second.kind) {\n-            (T![:], T![:]) => return Some((T![::], 2)),\n-            (T![=], T![=]) => return Some((T![==], 2)),\n-            (T![=], T![>]) => return Some((T![=>], 2)),\n-            (T![!], T![=]) => return Some((T![!=], 2)),\n-            _ => {}\n-        }\n-\n-        if first.kind != T![.] || second.kind != T![.] {\n-            return None;\n-        }\n-\n-        let third = self.token_source.lookahead_nth(n + 2);\n-\n-        let jn2 = second.is_jointed_to_next;\n-        let la3 = third.kind;\n-\n-        if jn2 && la3 == T![.] {\n-            return Some((T![...], 3));\n-        }\n-        if la3 == T![=] {\n-            return Some((T![..=], 3));\n-        }\n-        return Some((T![..], 2));\n-    }\n-\n+    #[allow(unused)]\n     fn eat_dollars(&mut self) {\n         loop {\n             match self.token_source.current().kind {"}, {"sha": "45892060726adcc09b12198a997c98a9aaa279ae", "filename": "crates/ra_syntax/src/tests.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ftests.rs?ref=40170885e799ebdefb24ed00865cd1c7800af491", "patch": "@@ -15,6 +15,18 @@ fn lexer_tests() {\n     })\n }\n \n+#[test]\n+fn parse_smoke_test() {\n+    let code = r##\"\n+fn main() {\n+    println!(\"Hello, world!\")\n+}\n+    \"##;\n+\n+    let parse = SourceFile::parse(code);\n+    assert!(parse.ok().is_ok());\n+}\n+\n #[test]\n fn parser_tests() {\n     dir_tests(&test_data_dir(), &[\"parser/inline/ok\", \"parser/ok\"], |text, path| {\n@@ -75,7 +87,9 @@ fn self_hosting_parsing() {\n     {\n         count += 1;\n         let text = read_text(entry.path());\n-        SourceFile::parse(&text).ok().expect(\"There should be no errors in the file\");\n+        if let Err(errors) = SourceFile::parse(&text).ok() {\n+            panic!(\"Parsing errors:\\n{:?}\\n{}\\n\", errors, entry.path().display());\n+        }\n     }\n     assert!(\n         count > 30,"}, {"sha": "0d3f5722a5a3bfb0d4cb96f9bf6cb41418d0c853", "filename": "crates/ra_syntax/test_data/parser/ok/0054_qual_path_in_type_arg.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0054_qual_path_in_type_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0054_qual_path_in_type_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0054_qual_path_in_type_arg.rs?ref=40170885e799ebdefb24ed00865cd1c7800af491", "patch": "@@ -0,0 +1,5 @@\n+fn a() -> Foo<bar::Baz> {}\n+\n+fn b(_: impl FnMut(x::Y)) {}\n+\n+fn c(_: impl FnMut(&x::Y)) {}"}, {"sha": "7e1af254c8a463b50422bbff607b0e806b25f3ac", "filename": "crates/ra_syntax/test_data/parser/ok/0054_qual_path_in_type_arg.txt", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0054_qual_path_in_type_arg.txt", "raw_url": "https://github.com/rust-lang/rust/raw/40170885e799ebdefb24ed00865cd1c7800af491/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0054_qual_path_in_type_arg.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0054_qual_path_in_type_arg.txt?ref=40170885e799ebdefb24ed00865cd1c7800af491", "patch": "@@ -0,0 +1,126 @@\n+SOURCE_FILE@[0; 88)\n+  FN_DEF@[0; 26)\n+    FN_KW@[0; 2) \"fn\"\n+    WHITESPACE@[2; 3) \" \"\n+    NAME@[3; 4)\n+      IDENT@[3; 4) \"a\"\n+    PARAM_LIST@[4; 6)\n+      L_PAREN@[4; 5) \"(\"\n+      R_PAREN@[5; 6) \")\"\n+    WHITESPACE@[6; 7) \" \"\n+    RET_TYPE@[7; 23)\n+      THIN_ARROW@[7; 9) \"->\"\n+      WHITESPACE@[9; 10) \" \"\n+      PATH_TYPE@[10; 23)\n+        PATH@[10; 23)\n+          PATH_SEGMENT@[10; 23)\n+            NAME_REF@[10; 13)\n+              IDENT@[10; 13) \"Foo\"\n+            TYPE_ARG_LIST@[13; 23)\n+              L_ANGLE@[13; 14) \"<\"\n+              TYPE_ARG@[14; 22)\n+                PATH_TYPE@[14; 22)\n+                  PATH@[14; 22)\n+                    PATH@[14; 17)\n+                      PATH_SEGMENT@[14; 17)\n+                        NAME_REF@[14; 17)\n+                          IDENT@[14; 17) \"bar\"\n+                    COLONCOLON@[17; 19) \"::\"\n+                    PATH_SEGMENT@[19; 22)\n+                      NAME_REF@[19; 22)\n+                        IDENT@[19; 22) \"Baz\"\n+              R_ANGLE@[22; 23) \">\"\n+    WHITESPACE@[23; 24) \" \"\n+    BLOCK_EXPR@[24; 26)\n+      BLOCK@[24; 26)\n+        L_CURLY@[24; 25) \"{\"\n+        R_CURLY@[25; 26) \"}\"\n+  WHITESPACE@[26; 28) \"\\n\\n\"\n+  FN_DEF@[28; 56)\n+    FN_KW@[28; 30) \"fn\"\n+    WHITESPACE@[30; 31) \" \"\n+    NAME@[31; 32)\n+      IDENT@[31; 32) \"b\"\n+    PARAM_LIST@[32; 53)\n+      L_PAREN@[32; 33) \"(\"\n+      PARAM@[33; 52)\n+        PLACEHOLDER_PAT@[33; 34)\n+          UNDERSCORE@[33; 34) \"_\"\n+        COLON@[34; 35) \":\"\n+        WHITESPACE@[35; 36) \" \"\n+        IMPL_TRAIT_TYPE@[36; 52)\n+          IMPL_KW@[36; 40) \"impl\"\n+          WHITESPACE@[40; 41) \" \"\n+          TYPE_BOUND_LIST@[41; 52)\n+            TYPE_BOUND@[41; 52)\n+              PATH_TYPE@[41; 52)\n+                PATH@[41; 52)\n+                  PATH_SEGMENT@[41; 52)\n+                    NAME_REF@[41; 46)\n+                      IDENT@[41; 46) \"FnMut\"\n+                    PARAM_LIST@[46; 52)\n+                      L_PAREN@[46; 47) \"(\"\n+                      PARAM@[47; 51)\n+                        PATH_TYPE@[47; 51)\n+                          PATH@[47; 51)\n+                            PATH@[47; 48)\n+                              PATH_SEGMENT@[47; 48)\n+                                NAME_REF@[47; 48)\n+                                  IDENT@[47; 48) \"x\"\n+                            COLONCOLON@[48; 50) \"::\"\n+                            PATH_SEGMENT@[50; 51)\n+                              NAME_REF@[50; 51)\n+                                IDENT@[50; 51) \"Y\"\n+                      R_PAREN@[51; 52) \")\"\n+      R_PAREN@[52; 53) \")\"\n+    WHITESPACE@[53; 54) \" \"\n+    BLOCK_EXPR@[54; 56)\n+      BLOCK@[54; 56)\n+        L_CURLY@[54; 55) \"{\"\n+        R_CURLY@[55; 56) \"}\"\n+  WHITESPACE@[56; 58) \"\\n\\n\"\n+  FN_DEF@[58; 87)\n+    FN_KW@[58; 60) \"fn\"\n+    WHITESPACE@[60; 61) \" \"\n+    NAME@[61; 62)\n+      IDENT@[61; 62) \"c\"\n+    PARAM_LIST@[62; 84)\n+      L_PAREN@[62; 63) \"(\"\n+      PARAM@[63; 83)\n+        PLACEHOLDER_PAT@[63; 64)\n+          UNDERSCORE@[63; 64) \"_\"\n+        COLON@[64; 65) \":\"\n+        WHITESPACE@[65; 66) \" \"\n+        IMPL_TRAIT_TYPE@[66; 83)\n+          IMPL_KW@[66; 70) \"impl\"\n+          WHITESPACE@[70; 71) \" \"\n+          TYPE_BOUND_LIST@[71; 83)\n+            TYPE_BOUND@[71; 83)\n+              PATH_TYPE@[71; 83)\n+                PATH@[71; 83)\n+                  PATH_SEGMENT@[71; 83)\n+                    NAME_REF@[71; 76)\n+                      IDENT@[71; 76) \"FnMut\"\n+                    PARAM_LIST@[76; 83)\n+                      L_PAREN@[76; 77) \"(\"\n+                      PARAM@[77; 82)\n+                        REFERENCE_TYPE@[77; 82)\n+                          AMP@[77; 78) \"&\"\n+                          PATH_TYPE@[78; 82)\n+                            PATH@[78; 82)\n+                              PATH@[78; 79)\n+                                PATH_SEGMENT@[78; 79)\n+                                  NAME_REF@[78; 79)\n+                                    IDENT@[78; 79) \"x\"\n+                              COLONCOLON@[79; 81) \"::\"\n+                              PATH_SEGMENT@[81; 82)\n+                                NAME_REF@[81; 82)\n+                                  IDENT@[81; 82) \"Y\"\n+                      R_PAREN@[82; 83) \")\"\n+      R_PAREN@[83; 84) \")\"\n+    WHITESPACE@[84; 85) \" \"\n+    BLOCK_EXPR@[85; 87)\n+      BLOCK@[85; 87)\n+        L_CURLY@[85; 86) \"{\"\n+        R_CURLY@[86; 87) \"}\"\n+  WHITESPACE@[87; 88) \"\\n\""}]}