{"sha": "6c44bea64435fd3859439a6ecab7758855a13f07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNDRiZWE2NDQzNWZkMzg1OTQzOWE2ZWNhYjc3NTg4NTVhMTNmMDc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-04-18T21:42:18Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-04-24T17:59:44Z"}, "message": "syntax: Check paths in visibilities for type parameters\n\nsyntax: Merge PathParsingMode::NoTypesAllowed and PathParsingMode::ImportPrefix\nsyntax: Rename PathParsingMode and its variants to better express their purpose\nsyntax: Remove obsolete error message about 'self lifetime\nsyntax: Remove ALLOW_MODULE_PATHS workaround\nsyntax/resolve: Adjust some error messages\nresolve: Compare unhygienic (not renamed) names with keywords::Invalid, invalid identifiers may appear to be valid after renaming", "tree": {"sha": "8035ecf05376fd4cb0723d1dbce3da49e28fcc49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8035ecf05376fd4cb0723d1dbce3da49e28fcc49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c44bea64435fd3859439a6ecab7758855a13f07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c44bea64435fd3859439a6ecab7758855a13f07", "html_url": "https://github.com/rust-lang/rust/commit/6c44bea64435fd3859439a6ecab7758855a13f07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c44bea64435fd3859439a6ecab7758855a13f07/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b32d7b592306a2784585e842193db1546a2f9587", "url": "https://api.github.com/repos/rust-lang/rust/commits/b32d7b592306a2784585e842193db1546a2f9587", "html_url": "https://github.com/rust-lang/rust/commit/b32d7b592306a2784585e842193db1546a2f9587"}], "stats": {"total": 215, "additions": 110, "deletions": 105}, "files": [{"sha": "ed473da19176b3c1378eff1301c705b7f5335ad4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=6c44bea64435fd3859439a6ecab7758855a13f07", "patch": "@@ -112,15 +112,14 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             !segment.parameters.bindings().is_empty()\n         });\n         if found_param {\n-            self.session.span_err(path.span,\n-                                  \"type or lifetime parameter is found in import path\");\n+            self.session.span_err(path.span, \"type or lifetime parameters in import path\");\n         }\n \n         // Checking for special identifiers in path\n         // prevent `self` or `super` at beginning of global path\n         if path.global && path.segments.len() > 0 {\n             let first = path.segments[0].identifier.name;\n-            if first == keywords::Super.ident.name || first == keywords::SelfValue.ident.name {\n+            if first == keywords::Super.name() || first == keywords::SelfValue.name() {\n                 self.session.add_lint(\n                     lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH, id, path.span,\n                     format!(\"expected identifier, found keyword `{}`\", first)"}, {"sha": "293b4de71fac403cb809136d93aaddd00b082149", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6c44bea64435fd3859439a6ecab7758855a13f07", "patch": "@@ -62,7 +62,7 @@ use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{self, Span, Pos};\n use syntax::errors::DiagnosticBuilder;\n-use syntax::parse::token::{self, keywords, special_idents};\n+use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use rustc::hir::intravisit::{self, FnKind, Visitor};\n@@ -1954,7 +1954,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // plain insert (no renaming, types are not currently hygienic....)\n-        self_type_rib.bindings.insert(keywords::SelfType.ident.name, self_def);\n+        self_type_rib.bindings.insert(keywords::SelfType.name(), self_def);\n         self.type_ribs.push(self_type_rib);\n         f(self);\n         if !self.resolved {\n@@ -2197,7 +2197,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let is_invalid_self_type_name = path.segments.len() > 0 &&\n                                                         maybe_qself.is_none() &&\n                                                         path.segments[0].identifier.name ==\n-                                                        keywords::SelfType.ident.name;\n+                                                        keywords::SelfType.name();\n                         if is_invalid_self_type_name {\n                             resolve_error(self,\n                                           ty.span,\n@@ -2641,7 +2641,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                           namespace: Namespace,\n                           record_used: bool)\n                           -> Option<LocalDef> {\n-        if identifier.name == special_idents::Invalid.name {\n+        if identifier.unhygienic_name == keywords::Invalid.name() {\n             return Some(LocalDef::from_def(Def::Err));\n         }\n \n@@ -3073,7 +3073,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             });\n \n                             if method_scope &&\n-                                    &path_name[..] == keywords::SelfValue.ident.name.as_str() {\n+                                    &path_name[..] == keywords::SelfValue.name().as_str() {\n                                 resolve_error(self,\n                                               expr.span,\n                                               ResolutionError::SelfNotAvailableInStaticMethod);"}, {"sha": "001db0b13ca59f1df980c698b124a5913870ea71", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6c44bea64435fd3859439a6ecab7758855a13f07", "patch": "@@ -1486,7 +1486,7 @@ mod tests {\n     use ext::mtwt;\n     use fold::Folder;\n     use parse;\n-    use parse::token;\n+    use parse::token::{self, keywords};\n     use util::parser_testing::{string_to_parser};\n     use util::parser_testing::{string_to_pat, string_to_crate, strs_to_idents};\n     use visit;"}, {"sha": "ee9a197ce56ccb84cc39167d1c2be5974543d5ff", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=6c44bea64435fd3859439a6ecab7758855a13f07", "patch": "@@ -13,7 +13,7 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::base;\n use ext::build::AstBuilder;\n-use parse::parser::{Parser, PathParsingMode};\n+use parse::parser::{Parser, PathStyle};\n use parse::token::*;\n use parse::token;\n use ptr::P;\n@@ -401,7 +401,7 @@ pub fn parse_meta_item_panic(parser: &mut Parser) -> P<ast::MetaItem> {\n     panictry!(parser.parse_meta_item())\n }\n \n-pub fn parse_path_panic(parser: &mut Parser, mode: PathParsingMode) -> ast::Path {\n+pub fn parse_path_panic(parser: &mut Parser, mode: PathStyle) -> ast::Path {\n     panictry!(parser.parse_path(mode))\n }\n \n@@ -500,7 +500,7 @@ pub fn expand_quote_path(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n                         -> Box<base::MacResult+'static> {\n-    let mode = mk_parser_path(cx, sp, \"LifetimeAndTypesWithoutColons\");\n+    let mode = mk_parser_path(cx, sp, &[\"PathStyle\", \"Type\"]);\n     let expanded = expand_parse_call(cx, sp, \"parse_path_panic\", vec!(mode), tts);\n     base::MacEager::expr(expanded)\n }\n@@ -557,8 +557,9 @@ fn mk_token_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n-fn mk_parser_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n-    let idents = vec!(id_ext(\"syntax\"), id_ext(\"parse\"), id_ext(\"parser\"), id_ext(name));\n+fn mk_parser_path(cx: &ExtCtxt, sp: Span, names: &[&str]) -> P<ast::Expr> {\n+    let mut idents = vec![id_ext(\"syntax\"), id_ext(\"parse\"), id_ext(\"parser\")];\n+    idents.extend(names.iter().cloned().map(id_ext));\n     cx.expr_path(cx.path_global(sp, idents))\n }\n "}, {"sha": "89ecf02ee4c92d6894c806919edba00f3e0951c8", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=6c44bea64435fd3859439a6ecab7758855a13f07", "patch": "@@ -85,7 +85,7 @@ use codemap;\n use errors::FatalError;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n-use parse::parser::{LifetimeAndTypesWithoutColons, Parser};\n+use parse::parser::{PathStyle, Parser};\n use parse::token::{DocComment, MatchNt, SubstNt};\n use parse::token::{Token, Nonterminal};\n use parse::token;\n@@ -546,7 +546,7 @@ pub fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n             }\n         },\n         \"path\" => {\n-            token::NtPath(Box::new(panictry!(p.parse_path(LifetimeAndTypesWithoutColons))))\n+            token::NtPath(Box::new(panictry!(p.parse_path(PathStyle::Type))))\n         },\n         \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n         _ => {"}, {"sha": "c77671d89f88fc865d8ea65873c41eaf540ecdc7", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=6c44bea64435fd3859439a6ecab7758855a13f07", "patch": "@@ -1168,7 +1168,19 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     fn visit_vis(&mut self, vis: &'v ast::Visibility) {\n         let span = match *vis {\n             ast::Visibility::Crate(span) => span,\n-            ast::Visibility::Restricted { ref path, .. } => path.span,\n+            ast::Visibility::Restricted { ref path, .. } => {\n+                // Check for type parameters\n+                let found_param = path.segments.iter().any(|segment| {\n+                    !segment.parameters.types().is_empty() ||\n+                    !segment.parameters.lifetimes().is_empty() ||\n+                    !segment.parameters.bindings().is_empty()\n+                });\n+                if found_param {\n+                    self.context.span_handler.span_err(path.span, \"type or lifetime parameters \\\n+                                                                   in visibility path\");\n+                }\n+                path.span\n+            }\n             _ => return,\n         };\n         self.gate_feature(\"pub_restricted\", span, \"`pub(restricted)` syntax is experimental\");"}, {"sha": "2eda13adcb580f6565584a7ef027907324ed8605", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=6c44bea64435fd3859439a6ecab7758855a13f07", "patch": "@@ -13,8 +13,7 @@ use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n use codemap;\n use errors::{FatalError, Handler, DiagnosticBuilder};\n use ext::tt::transcribe::tt_next_token;\n-use parse::token::str_to_ident;\n-use parse::token;\n+use parse::token::{self, keywords, str_to_ident};\n use str::char_at;\n use rustc_unicode::property::Pattern_White_Space;\n \n@@ -1229,14 +1228,9 @@ impl<'a> StringReader<'a> {\n                     });\n                     let keyword_checking_token = &token::Ident(keyword_checking_ident);\n                     let last_bpos = self.last_pos;\n-                    if keyword_checking_token.is_keyword(token::keywords::SelfValue) {\n-                        self.err_span_(start,\n-                                       last_bpos,\n-                                       \"invalid lifetime name: 'self is no longer a special \\\n-                                        lifetime\");\n-                    } else if keyword_checking_token.is_any_keyword() &&\n-                       !keyword_checking_token.is_keyword(token::keywords::Static) {\n-                        self.err_span_(start, last_bpos, \"invalid lifetime name\");\n+                    if keyword_checking_token.is_any_keyword() &&\n+                       !keyword_checking_token.is_keyword(keywords::Static) {\n+                        self.err_span_(start, last_bpos, \"lifetimes cannot use keyword names\");\n                     }\n \n                     return token::Lifetime(ident);"}, {"sha": "a4d2c5b611064d48e94b3deac78ae41fd390cd85", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 57, "deletions": 64, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6c44bea64435fd3859439a6ecab7758855a13f07", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::PathParsingMode::*;\n-\n use abi::{self, Abi};\n use ast::BareFnTy;\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n@@ -51,7 +49,7 @@ use parse::common::SeqSep;\n use parse::lexer::{Reader, TokenAndSpan};\n use parse::obsolete::{ParserObsoleteMethods, ObsoleteSyntax};\n use parse::token::{self, intern, MatchNt, SubstNt, SpecialVarNt, InternedString};\n-use parse::token::{keywords, special_idents, SpecialMacroVar};\n+use parse::token::{keywords, SpecialMacroVar};\n use parse::{new_sub_parser_from_file, ParseSess};\n use util::parser::{AssocOp, Fixity};\n use print::pprust;\n@@ -69,26 +67,24 @@ bitflags! {\n         const RESTRICTION_STMT_EXPR         = 1 << 0,\n         const RESTRICTION_NO_STRUCT_LITERAL = 1 << 1,\n         const NO_NONINLINE_MOD  = 1 << 2,\n-        const ALLOW_MODULE_PATHS = 1 << 3,\n     }\n }\n \n type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute> >);\n \n-/// How to parse a path. There are four different kinds of paths, all of which\n+/// How to parse a path. There are three different kinds of paths, all of which\n /// are parsed somewhat differently.\n #[derive(Copy, Clone, PartialEq)]\n-pub enum PathParsingMode {\n-    /// A path with no type parameters; e.g. `foo::bar::Baz`\n-    NoTypesAllowed,\n-    /// Same as `NoTypesAllowed`, but may end with `::{` or `::*`, which are left unparsed\n-    ImportPrefix,\n+pub enum PathStyle {\n+    /// A path with no type parameters, e.g. `foo::bar::Baz`, used in imports or visibilities.\n+    Mod,\n     /// A path with a lifetime and type parameters, with no double colons\n-    /// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`\n-    LifetimeAndTypesWithoutColons,\n+    /// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`, used in types.\n+    /// Paths using this style can be passed into macros expecting `path` nonterminals.\n+    Type,\n     /// A path with a lifetime and type parameters with double colons before\n-    /// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\n-    LifetimeAndTypesWithColons,\n+    /// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`, used in expressions or patterns.\n+    Expr,\n }\n \n /// How to parse a bound, whether to allow bound modifiers such as `?`.\n@@ -292,7 +288,7 @@ impl TokenType {\n         match *self {\n             TokenType::Token(ref t) => format!(\"`{}`\", Parser::token_to_string(t)),\n             TokenType::Operator => \"an operator\".to_string(),\n-            TokenType::Keyword(kw) => format!(\"`{}`\", kw.ident.name),\n+            TokenType::Keyword(kw) => format!(\"`{}`\", kw.name()),\n         }\n     }\n }\n@@ -562,7 +558,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n-        self.check_used_keywords();\n+        self.check_strict_keywords();\n         self.check_reserved_keywords();\n         match self.token {\n             token::Ident(i) => {\n@@ -661,8 +657,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Signal an error if the given string is a strict keyword\n-    pub fn check_used_keywords(&mut self) {\n-        if self.token.is_used_keyword() {\n+    pub fn check_strict_keywords(&mut self) {\n+        if self.token.is_strict_keyword() {\n             let token_str = self.this_token_to_string();\n             let span = self.span;\n             self.span_err(span,\n@@ -1164,7 +1160,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_ty_path(&mut self) -> PResult<'a, TyKind> {\n-        Ok(TyKind::Path(None, self.parse_path(LifetimeAndTypesWithoutColons)?))\n+        Ok(TyKind::Path(None, self.parse_path(PathStyle::Type)?))\n     }\n \n     /// parse a TyKind::BareFn type:\n@@ -1467,11 +1463,11 @@ impl<'a> Parser<'a> {\n         } else if self.eat_lt() {\n \n             let (qself, path) =\n-                 self.parse_qualified_path(LifetimeAndTypesWithoutColons)?;\n+                 self.parse_qualified_path(PathStyle::Type)?;\n \n             TyKind::Path(Some(qself), path)\n         } else if self.is_path_start() {\n-            let path = self.parse_path(LifetimeAndTypesWithoutColons)?;\n+            let path = self.parse_path(PathStyle::Type)?;\n             if self.check(&token::Not) {\n                 // MACRO INVOCATION\n                 self.bump();\n@@ -1556,7 +1552,7 @@ impl<'a> Parser<'a> {\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n             let sp = self.last_span;\n-            let spanned = Spanned { span: sp, node: special_idents::Invalid };\n+            let spanned = Spanned { span: sp, node: keywords::Invalid.ident() };\n             P(Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable),\n@@ -1724,12 +1720,12 @@ impl<'a> Parser<'a> {\n     ///\n     /// `<T as U>::a`\n     /// `<T as U>::F::a::<S>`\n-    pub fn parse_qualified_path(&mut self, mode: PathParsingMode)\n+    pub fn parse_qualified_path(&mut self, mode: PathStyle)\n                                 -> PResult<'a, (QSelf, ast::Path)> {\n         let span = self.last_span;\n         let self_type = self.parse_ty_sum()?;\n         let mut path = if self.eat_keyword(keywords::As) {\n-            self.parse_path(LifetimeAndTypesWithoutColons)?\n+            self.parse_path(PathStyle::Type)?\n         } else {\n             ast::Path {\n                 span: span,\n@@ -1747,14 +1743,14 @@ impl<'a> Parser<'a> {\n         self.expect(&token::ModSep)?;\n \n         let segments = match mode {\n-            LifetimeAndTypesWithoutColons => {\n+            PathStyle::Type => {\n                 self.parse_path_segments_without_colons()?\n             }\n-            LifetimeAndTypesWithColons => {\n+            PathStyle::Expr => {\n                 self.parse_path_segments_with_colons()?\n             }\n-            NoTypesAllowed | ImportPrefix => {\n-                self.parse_path_segments_without_types(mode == ImportPrefix)?\n+            PathStyle::Mod => {\n+                self.parse_path_segments_without_types()?\n             }\n         };\n         path.segments.extend(segments);\n@@ -1768,7 +1764,7 @@ impl<'a> Parser<'a> {\n     /// mode. The `mode` parameter determines whether lifetimes, types, and/or\n     /// bounds are permitted and whether `::` must precede type parameter\n     /// groups.\n-    pub fn parse_path(&mut self, mode: PathParsingMode) -> PResult<'a, ast::Path> {\n+    pub fn parse_path(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n         // Check for a whole path...\n         let found = match self.token {\n             token::Interpolated(token::NtPath(_)) => Some(self.bump_and_get()),\n@@ -1785,14 +1781,14 @@ impl<'a> Parser<'a> {\n         // identifier followed by an optional lifetime and a set of types.\n         // A bound set is a set of type parameter bounds.\n         let segments = match mode {\n-            LifetimeAndTypesWithoutColons => {\n+            PathStyle::Type => {\n                 self.parse_path_segments_without_colons()?\n             }\n-            LifetimeAndTypesWithColons => {\n+            PathStyle::Expr => {\n                 self.parse_path_segments_with_colons()?\n             }\n-            NoTypesAllowed | ImportPrefix => {\n-                self.parse_path_segments_without_types(mode == ImportPrefix)?\n+            PathStyle::Mod => {\n+                self.parse_path_segments_without_types()?\n             }\n         };\n \n@@ -1907,10 +1903,9 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-\n     /// Examples:\n     /// - `a::b::c`\n-    pub fn parse_path_segments_without_types(&mut self, import_prefix: bool)\n+    pub fn parse_path_segments_without_types(&mut self)\n                                              -> PResult<'a, Vec<ast::PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n@@ -1924,7 +1919,7 @@ impl<'a> Parser<'a> {\n             });\n \n             // If we do not see a `::` or see `::{`/`::*`, stop.\n-            if !self.check(&token::ModSep) || import_prefix && self.is_import_coupler() {\n+            if !self.check(&token::ModSep) || self.is_import_coupler() {\n                 return Ok(segments);\n             } else {\n                 self.bump();\n@@ -2256,7 +2251,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 if self.eat_lt() {\n                     let (qself, path) =\n-                        self.parse_qualified_path(LifetimeAndTypesWithColons)?;\n+                        self.parse_qualified_path(PathStyle::Expr)?;\n                     hi = path.span.hi;\n                     return Ok(self.mk_expr(lo, hi, ExprKind::Path(Some(qself), path), attrs));\n                 }\n@@ -2338,13 +2333,13 @@ impl<'a> Parser<'a> {\n                     }\n                     hi = self.last_span.hi;\n                 } else if self.token.is_keyword(keywords::Let) {\n-                    // Catch this syntax error here, instead of in `check_used_keywords`, so\n+                    // Catch this syntax error here, instead of in `check_strict_keywords`, so\n                     // that we can explicitly mention that let is not to be used as an expression\n                     let mut db = self.fatal(\"expected expression, found statement (`let`)\");\n                     db.note(\"variable declaration using `let` is a statement\");\n                     return Err(db);\n                 } else if self.is_path_start() {\n-                    let pth = self.parse_path(LifetimeAndTypesWithColons)?;\n+                    let pth = self.parse_path(PathStyle::Expr)?;\n \n                     // `!`, as an operator, is prefix, so we know this isn't that\n                     if self.check(&token::Not) {\n@@ -2621,7 +2616,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(self.span, &format!(\"unexpected token: `{}`\", actual));\n \n                     let dot_pos = self.last_span.hi;\n-                    e = self.parse_dot_suffix(special_idents::Invalid,\n+                    e = self.parse_dot_suffix(keywords::Invalid.ident(),\n                                               mk_sp(dot_pos, dot_pos),\n                                               e, lo)?;\n                   }\n@@ -2698,9 +2693,8 @@ impl<'a> Parser<'a> {\n             _ => unreachable!()\n         };\n         // continue by trying to parse the `:ident` after `$name`\n-        if self.token == token::Colon && self.look_ahead(1, |t| t.is_ident() &&\n-                                                                !t.is_used_keyword() &&\n-                                                                !t.is_reserved_keyword()) {\n+        if self.token == token::Colon &&\n+                self.look_ahead(1, |t| t.is_ident() && !t.is_any_keyword()) {\n             self.bump();\n             sp = mk_sp(sp.lo, self.span.hi);\n             let nt_kind = self.parse_ident()?;\n@@ -3578,11 +3572,11 @@ impl<'a> Parser<'a> {\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path\n                 let (qself, path) =\n-                    self.parse_qualified_path(LifetimeAndTypesWithColons)?;\n+                    self.parse_qualified_path(PathStyle::Expr)?;\n                 (Some(qself), path)\n             } else {\n                 // Parse an unqualified path\n-                (None, self.parse_path(LifetimeAndTypesWithColons)?)\n+                (None, self.parse_path(PathStyle::Expr)?)\n             };\n             let hi = self.last_span.hi;\n             Ok(self.mk_expr(lo, hi, ExprKind::Path(qself, path), None))\n@@ -3676,11 +3670,11 @@ impl<'a> Parser<'a> {\n                     let (qself, path) = if self.eat_lt() {\n                         // Parse a qualified path\n                         let (qself, path) =\n-                            self.parse_qualified_path(LifetimeAndTypesWithColons)?;\n+                            self.parse_qualified_path(PathStyle::Expr)?;\n                         (Some(qself), path)\n                     } else {\n                         // Parse an unqualified path\n-                        (None, self.parse_path(LifetimeAndTypesWithColons)?)\n+                        (None, self.parse_path(PathStyle::Expr)?)\n                     };\n                     match self.token {\n                       token::DotDotDot => {\n@@ -3943,7 +3937,7 @@ impl<'a> Parser<'a> {\n             self.bump();\n \n             let id = match self.token {\n-                token::OpenDelim(_) => token::special_idents::Invalid, // no special identifier\n+                token::OpenDelim(_) => keywords::Invalid.ident(), // no special identifier\n                 _ => self.parse_ident()?,\n             };\n \n@@ -3955,7 +3949,7 @@ impl<'a> Parser<'a> {\n                 _ => {\n                     // we only expect an ident if we didn't parse one\n                     // above.\n-                    let ident_str = if id.name == token::special_idents::Invalid.name {\n+                    let ident_str = if id.name == keywords::Invalid.name() {\n                         \"identifier, \"\n                     } else {\n                         \"\"\n@@ -3981,7 +3975,7 @@ impl<'a> Parser<'a> {\n                 MacStmtStyle::NoBraces\n             };\n \n-            if id.name == token::special_idents::Invalid.name {\n+            if id.name == keywords::Invalid.name() {\n                 let mac = P(spanned(lo, hi, Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT }));\n                 let stmt = StmtKind::Mac(mac, style, attrs.into_thin_attrs());\n                 spanned(lo, hi, stmt)\n@@ -4611,10 +4605,10 @@ impl<'a> Parser<'a> {\n \n     fn expect_self_ident(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token {\n-            token::Ident(id) if id.name == keywords::SelfValue.ident.name => {\n+            token::Ident(id) if id.name == keywords::SelfValue.name() => {\n                 self.bump();\n                 // The hygiene context of `id` needs to be preserved here,\n-                // so we can't just return `SelfValue.ident`.\n+                // so we can't just return `SelfValue.ident()`.\n                 Ok(id)\n             },\n             _ => {\n@@ -4699,7 +4693,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                 }\n                 // error case, making bogus self ident:\n-                SelfKind::Value(keywords::SelfValue.ident)\n+                SelfKind::Value(keywords::SelfValue.ident())\n             }\n             token::Ident(..) => {\n                 if self.token.is_keyword(keywords::SelfValue) {\n@@ -4974,7 +4968,7 @@ impl<'a> Parser<'a> {\n             if delim != token::Brace {\n                 self.expect(&token::Semi)?\n             }\n-            Ok((token::special_idents::Invalid, vec![], ast::ImplItemKind::Macro(m)))\n+            Ok((keywords::Invalid.ident(), vec![], ast::ImplItemKind::Macro(m)))\n         } else {\n             let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n@@ -5069,7 +5063,7 @@ impl<'a> Parser<'a> {\n \n             self.expect(&token::OpenDelim(token::Brace))?;\n             self.expect(&token::CloseDelim(token::Brace))?;\n-            Ok((special_idents::Invalid,\n+            Ok((keywords::Invalid.ident(),\n              ItemKind::DefaultImpl(unsafety, opt_trait.unwrap()), None))\n         } else {\n             if opt_trait.is_some() {\n@@ -5085,7 +5079,7 @@ impl<'a> Parser<'a> {\n                 impl_items.push(self.parse_impl_item()?);\n             }\n \n-            Ok((special_idents::Invalid,\n+            Ok((keywords::Invalid.ident(),\n              ItemKind::Impl(unsafety, polarity, generics, opt_trait, ty, impl_items),\n              Some(attrs)))\n         }\n@@ -5094,7 +5088,7 @@ impl<'a> Parser<'a> {\n     /// Parse a::B<String,i32>\n     fn parse_trait_ref(&mut self) -> PResult<'a, TraitRef> {\n         Ok(ast::TraitRef {\n-            path: self.parse_path(LifetimeAndTypesWithoutColons)?,\n+            path: self.parse_path(PathStyle::Type)?,\n             ref_id: ast::DUMMY_NODE_ID,\n         })\n     }\n@@ -5254,16 +5248,15 @@ impl<'a> Parser<'a> {\n             self.expect(&token::CloseDelim(token::Paren))?;\n             Ok(Visibility::Crate(span))\n         } else {\n-            let path = self.with_res(Restrictions::ALLOW_MODULE_PATHS,\n-                                     |this| this.parse_path(NoTypesAllowed))?;\n+            let path = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::CloseDelim(token::Paren))?;\n             Ok(Visibility::Restricted { path: P(path), id: ast::DUMMY_NODE_ID })\n         }\n     }\n \n     /// Parse defaultness: DEFAULT or nothing\n     fn parse_defaultness(&mut self) -> PResult<'a, Defaultness> {\n-        if self.eat_contextual_keyword(special_idents::Default) {\n+        if self.eat_contextual_keyword(keywords::Default.ident()) {\n             Ok(Defaultness::Default)\n         } else {\n             Ok(Defaultness::Final)\n@@ -5591,7 +5584,7 @@ impl<'a> Parser<'a> {\n         };\n         Ok(self.mk_item(lo,\n                      last_span.hi,\n-                     special_idents::Invalid,\n+                     keywords::Invalid.ident(),\n                      ItemKind::ForeignMod(m),\n                      visibility,\n                      attrs))\n@@ -5730,7 +5723,7 @@ impl<'a> Parser<'a> {\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,\n-                                    token::special_idents::Invalid,\n+                                    keywords::Invalid.ident(),\n                                     item_,\n                                     visibility,\n                                     attrs);\n@@ -6021,7 +6014,7 @@ impl<'a> Parser<'a> {\n             let id = if self.token.is_ident() {\n                 self.parse_ident()?\n             } else {\n-                token::special_idents::Invalid // no special identifier\n+                keywords::Invalid.ident() // no special identifier\n             };\n             // eat a matched-delimiter token tree:\n             let delim = self.expect_open_delim()?;\n@@ -6118,7 +6111,7 @@ impl<'a> Parser<'a> {\n             let items = self.parse_path_list_items()?;\n             Ok(P(spanned(lo, self.span.hi, ViewPathList(prefix, items))))\n         } else {\n-            let prefix = self.parse_path(ImportPrefix)?;\n+            let prefix = self.parse_path(PathStyle::Mod)?;\n             if self.is_import_coupler() {\n                 // `foo::bar::{a, b}` or `foo::bar::*`\n                 self.bump();"}, {"sha": "7344f31535fba42fabf4850cc312de76c1fa4ccb", "filename": "src/test/compile-fail/import-ty-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Ftest%2Fcompile-fail%2Fimport-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Ftest%2Fcompile-fail%2Fimport-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-ty-params.rs?ref=6c44bea64435fd3859439a6ecab7758855a13f07", "patch": "@@ -20,6 +20,6 @@ macro_rules! import {\n     ($p: path) => (use $p;);\n }\n \n-import! { a::b::c::S<u8> } //~ERROR type or lifetime parameter is found in import path\n+import! { a::b::c::S<u8> } //~ERROR type or lifetime parameters in import path\n \n fn main() {}"}, {"sha": "04d8e9833045a27c49987a6f9edf374e72254ae4", "filename": "src/test/compile-fail/privacy/restricted/ty-params.rs", "status": "renamed", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fty-params.rs?ref=6c44bea64435fd3859439a6ecab7758855a13f07", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+#![feature(pub_restricted)]\n \n-fn baz(a: &'self isize) { } //~ ERROR invalid lifetime name: 'self is no longer a special lifetime\n+macro_rules! m {\n+    ($p: path) => (pub($p) struct Z;)\n+}\n \n-fn main() { }\n+struct S<T>(T);\n+m!{ S<u8> } //~ ERROR type or lifetime parameters in visibility path\n+\n+fn main() {}", "previous_filename": "src/test/parse-fail/lifetime-obsoleted-self.rs"}, {"sha": "b9c9d7a389b95dd63ef3375310fd0d454354ceed", "filename": "src/test/compile-fail/self_type_keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs?ref=6c44bea64435fd3859439a6ecab7758855a13f07", "patch": "@@ -14,7 +14,7 @@ struct Self;\n //~^ ERROR expected identifier, found keyword `Self`\n \n struct Bar<'Self>;\n-//~^ ERROR invalid lifetime name\n+//~^ ERROR lifetimes cannot use keyword names\n \n pub fn main() {\n     let Self = 5;"}, {"sha": "fc2598d1e9d2fa9a5bcbfedafcf9f9a86519d526", "filename": "src/test/parse-fail/issue-10412.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Ftest%2Fparse-fail%2Fissue-10412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Ftest%2Fparse-fail%2Fissue-10412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-10412.rs?ref=6c44bea64435fd3859439a6ecab7758855a13f07", "patch": "@@ -11,17 +11,17 @@\n // compile-flags: -Z parse-only -Z continue-parse-after-error\n \n \n-trait Serializable<'self, T> { //~ ERROR no longer a special lifetime\n-    fn serialize(val : &'self T) -> Vec<u8> ; //~ ERROR no longer a special lifetime\n-    fn deserialize(repr : &[u8]) -> &'self T; //~ ERROR no longer a special lifetime\n+trait Serializable<'self, T> { //~ ERROR lifetimes cannot use keyword names\n+    fn serialize(val : &'self T) -> Vec<u8> ; //~ ERROR lifetimes cannot use keyword names\n+    fn deserialize(repr : &[u8]) -> &'self T; //~ ERROR lifetimes cannot use keyword names\n }\n \n-impl<'self> Serializable<str> for &'self str { //~ ERROR no longer a special lifetime\n-    //~^ ERROR no longer a special lifetime\n-    fn serialize(val : &'self str) -> Vec<u8> { //~ ERROR no longer a special lifetime\n+impl<'self> Serializable<str> for &'self str { //~ ERROR lifetimes cannot use keyword names\n+    //~^ ERROR lifetimes cannot use keyword names\n+    fn serialize(val : &'self str) -> Vec<u8> { //~ ERROR lifetimes cannot use keyword names\n         vec!(1)\n     }\n-    fn deserialize(repr: &[u8]) -> &'self str { //~ ERROR no longer a special lifetime\n+    fn deserialize(repr: &[u8]) -> &'self str { //~ ERROR lifetimes cannot use keyword names\n         \"hi\"\n     }\n }"}, {"sha": "9ca81d9918ef32c68255697f9e2a23c81a8ac9bd", "filename": "src/test/parse-fail/lifetime-no-keyword.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Ftest%2Fparse-fail%2Flifetime-no-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c44bea64435fd3859439a6ecab7758855a13f07/src%2Ftest%2Fparse-fail%2Flifetime-no-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Flifetime-no-keyword.rs?ref=6c44bea64435fd3859439a6ecab7758855a13f07", "patch": "@@ -12,6 +12,7 @@\n \n fn foo<'a>(a: &'a isize) { }\n fn bar(a: &'static isize) { }\n-fn baz(a: &'let isize) { } //~ ERROR invalid lifetime name\n+fn baz(a: &'let isize) { } //~ ERROR lifetimes cannot use keyword names\n+fn zab(a: &'self isize) { } //~ ERROR lifetimes cannot use keyword names\n \n fn main() { }"}]}