{"sha": "9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMjI0YzJiZjE4ZWJmOGY4NzFlZmIyZTFhYmE0M2VkNzk3MGViYjc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-19T19:29:39Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-30T22:33:59Z"}, "message": "std: Re-enable at_exit()\n\nThe new semantics of this function are that the callbacks are run when the *main\nthread* exits, not when all threads have exited. This implies that other threads\nmay still be running when the `at_exit` callbacks are invoked and users need to\nbe prepared for this situation.\n\nUsers in the standard library have been audited in accordance to these new rules\nas well.\n\nCloses #20012", "tree": {"sha": "da18d5791e6841a1aa6a9469baca155d4ca9828d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da18d5791e6841a1aa6a9469baca155d4ca9828d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "comment_count": 6, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "html_url": "https://github.com/rust-lang/rust/commit/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2368c3c11ddab9d812c4ddec2e44579326ad347", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2368c3c11ddab9d812c4ddec2e44579326ad347", "html_url": "https://github.com/rust-lang/rust/commit/d2368c3c11ddab9d812c4ddec2e44579326ad347"}], "stats": {"total": 439, "additions": 192, "deletions": 247}, "files": [{"sha": "6ee8ae25f1bdd39e78be4c29aee2d2d4baa8467c", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -177,7 +177,7 @@ use std::mem;\n use std::os;\n use std::rt;\n use std::slice;\n-use std::sync::{Once, ONCE_INIT};\n+use std::sync::{Once, ONCE_INIT, StaticMutex, MUTEX_INIT};\n \n use regex::Regex;\n \n@@ -193,6 +193,8 @@ pub const MAX_LOG_LEVEL: u32 = 255;\n /// The default logging level of a crate if no other is specified.\n const DEFAULT_LOG_LEVEL: u32 = 1;\n \n+static LOCK: StaticMutex = MUTEX_INIT;\n+\n /// An unsafe constant that is the maximum logging level of any module\n /// specified. This is the first line of defense to determining whether a\n /// logging statement should be run.\n@@ -281,9 +283,18 @@ impl Drop for DefaultLogger {\n pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n-    match unsafe { FILTER.as_ref() } {\n-        Some(filter) if !filter.is_match(args.to_string()[]) => return,\n-        _ => {}\n+    unsafe {\n+        let _g = LOCK.lock();\n+        match FILTER as uint {\n+            0 => {}\n+            1 => panic!(\"cannot log after main thread has exited\"),\n+            n => {\n+                let filter = mem::transmute::<_, &Regex>(n);\n+                if !filter.is_match(args.to_string().as_slice()) {\n+                    return\n+                }\n+            }\n+        }\n     }\n \n     // Completely remove the local logger from TLS in case anyone attempts to\n@@ -401,9 +412,15 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n \n     // This assertion should never get tripped unless we're in an at_exit\n     // handler after logging has been torn down and a logging attempt was made.\n-    assert!(unsafe { !DIRECTIVES.is_null() });\n \n-    enabled(level, module, unsafe { (*DIRECTIVES).iter() })\n+    let _g = LOCK.lock();\n+    unsafe {\n+        assert!(DIRECTIVES as uint != 0);\n+        assert!(DIRECTIVES as uint != 1,\n+                \"cannot log after the main thread has exited\");\n+\n+        enabled(level, module, (*DIRECTIVES).iter())\n+    }\n }\n \n fn enabled(level: u32,\n@@ -459,14 +476,15 @@ fn init() {\n \n         // Schedule the cleanup for the globals for when the runtime exits.\n         rt::at_exit(move |:| {\n+            let _g = LOCK.lock();\n             assert!(!DIRECTIVES.is_null());\n             let _directives: Box<Vec<directive::LogDirective>> =\n                 mem::transmute(DIRECTIVES);\n-            DIRECTIVES = 0 as *const Vec<directive::LogDirective>;\n+            DIRECTIVES = 1 as *const Vec<directive::LogDirective>;\n \n             if !FILTER.is_null() {\n                 let _filter: Box<Regex> = mem::transmute(FILTER);\n-                FILTER = 0 as *const _;\n+                FILTER = 1 as *const _;\n             }\n         });\n     }"}, {"sha": "fa04efce86edeaffdc65392238cfe926e932e42b", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -26,29 +26,19 @@\n //! ```\n \n use self::StdSource::*;\n+use prelude::*;\n \n-use boxed::Box;\n use cell::RefCell;\n-use clone::Clone;\n use failure::LOCAL_STDERR;\n use fmt;\n-use io::{Reader, Writer, IoResult, IoError, OtherIoError, Buffer,\n-         standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n-use kinds::{Sync, Send};\n+use io::{IoResult, IoError, OtherIoError};\n+use io::{standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n use libc;\n use mem;\n-use option::Option;\n-use option::Option::{Some, None};\n-use ops::{Deref, DerefMut, FnOnce};\n-use result::Result::{Ok, Err};\n use rt;\n-use slice::SliceExt;\n-use str::StrExt;\n-use string::String;\n use sys::{fs, tty};\n-use sync::{Arc, Mutex, MutexGuard, Once, ONCE_INIT};\n+use sync::{Arc, Mutex, MutexGuard, StaticMutex, MUTEX_INIT};\n use uint;\n-use vec::Vec;\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n // platforms in all situations. Our story begins by splitting the world into two\n@@ -215,14 +205,15 @@ impl Reader for StdinReader {\n pub fn stdin() -> StdinReader {\n     // We're following the same strategy as kimundi's lazy_static library\n     static mut STDIN: *const StdinReader = 0 as *const StdinReader;\n-    static ONCE: Once = ONCE_INIT;\n+    static LOCK: StaticMutex = MUTEX_INIT;\n \n     unsafe {\n-        ONCE.doit(|| {\n-            // The default buffer capacity is 64k, but apparently windows doesn't like\n-            // 64k reads on stdin. See #13304 for details, but the idea is that on\n-            // windows we use a slightly smaller buffer that's been seen to be\n-            // acceptable.\n+        let _g = LOCK.lock();\n+        if STDIN as uint == 0 {\n+            // The default buffer capacity is 64k, but apparently windows\n+            // doesn't like 64k reads on stdin. See #13304 for details, but the\n+            // idea is that on windows we use a slightly smaller buffer that's\n+            // been seen to be acceptable.\n             let stdin = if cfg!(windows) {\n                 BufferedReader::with_capacity(8 * 1024, stdin_raw())\n             } else {\n@@ -235,11 +226,15 @@ pub fn stdin() -> StdinReader {\n \n             // Make sure to free it at exit\n             rt::at_exit(|| {\n-                mem::transmute::<_, Box<StdinReader>>(STDIN);\n-                STDIN = 0 as *const _;\n+                let g = LOCK.lock();\n+                let stdin = STDIN;\n+                STDIN = 1 as *const _;\n+                drop(g);\n+                mem::transmute::<_, Box<StdinReader>>(stdin);\n             });\n-        });\n-\n+        } else if STDIN as uint == 1 {\n+            panic!(\"accessing stdin after the main thread has exited\")\n+        }\n         (*STDIN).clone()\n     }\n }"}, {"sha": "5c70340fe102e7963f7388b3862b127fbc5a29a6", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -228,13 +228,13 @@ pub mod thread;\n pub mod sync;\n pub mod comm;\n \n+#[path = \"sys/common/mod.rs\"] mod sys_common;\n+\n #[cfg(unix)]\n #[path = \"sys/unix/mod.rs\"] mod sys;\n #[cfg(windows)]\n #[path = \"sys/windows/mod.rs\"] mod sys;\n \n-#[path = \"sys/common/mod.rs\"] mod sys_common;\n-\n pub mod rt;\n mod failure;\n "}, {"sha": "08dabd3b0b6038c86c9ad1bbe0a665ea7c733add", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -29,6 +29,8 @@ type Queue = Vec<Thunk>;\n static LOCK: Mutex = MUTEX_INIT;\n static mut QUEUE: *mut Queue = 0 as *mut Queue;\n \n+const DTOR_RUN_ITERS: uint = 10;\n+\n unsafe fn init() {\n     if QUEUE.is_null() {\n         let state: Box<Queue> = box Vec::new();\n@@ -49,7 +51,7 @@ pub fn cleanup() {\n     unsafe {\n         LOCK.lock();\n         let queue = QUEUE;\n-        QUEUE = 1 as *mut _;\n+        QUEUE = 1u as *mut _;\n         LOCK.unlock();\n \n         // make sure we're not recursively cleaning up"}, {"sha": "a4421f23c50b606a79e9b6acb41971221c42a4ea", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -92,9 +92,7 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n         // but we just do this to name the main thread and to give it correct\n         // info about the stack bounds.\n         let thread: Thread = NewThread::new(Some(\"<main>\".to_string()));\n-        thread_info::set((my_stack_bottom, my_stack_top),\n-                         sys::thread::guard::main(),\n-                         thread);\n+        thread_info::set(sys::thread::guard::main(), thread);\n \n         // By default, some platforms will send a *signal* when a EPIPE error\n         // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n@@ -133,20 +131,14 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     }\n }\n \n-/// Enqueues a procedure to run when the runtime is cleaned up\n-///\n-/// The procedure passed to this function will be executed as part of the\n-/// runtime cleanup phase. For normal rust programs, this means that it will run\n-/// after all other threads have exited.\n-///\n-/// The procedure is *not* executed with a local `Thread` available to it, so\n-/// primitives like logging, I/O, channels, spawning, etc, are *not* available.\n-/// This is meant for \"bare bones\" usage to clean up runtime details, this is\n-/// not meant as a general-purpose \"let's clean everything up\" function.\n+/// Enqueues a procedure to run when the main thread exits.\n ///\n /// It is forbidden for procedures to register more `at_exit` handlers when they\n /// are running, and doing so will lead to a process abort.\n-pub fn at_exit<F:FnOnce()+Send>(f: F) {\n+///\n+/// Note that other threads may still be running when `at_exit` routines start\n+/// running.\n+pub fn at_exit<F: FnOnce() + Send>(f: F) {\n     at_exit_imp::push(Thunk::new(f));\n }\n \n@@ -162,8 +154,5 @@ pub fn at_exit<F:FnOnce()+Send>(f: F) {\n pub unsafe fn cleanup() {\n     args::cleanup();\n     sys::stack_overflow::cleanup();\n-    // FIXME: (#20012): the resources being cleaned up by at_exit\n-    // currently are not prepared for cleanup to happen asynchronously\n-    // with detached threads using the resources; for now, we leak.\n-    // at_exit_imp::cleanup();\n+    at_exit_imp::cleanup();\n }"}, {"sha": "32fa126ded4b5d2d84a98663d817a5caf21052dc", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -68,7 +68,7 @@ use intrinsics;\n use libc::c_void;\n use mem;\n use sync::atomic;\n-use sync::{Once, ONCE_INIT};\n+use sys_common::mutex::{Mutex, MUTEX_INIT};\n \n use rt::libunwind as uw;\n \n@@ -587,11 +587,20 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) ->\n /// Doing this split took the LLVM IR line counts of `fn main() { panic!()\n /// }` from ~1900/3700 (-O/no opts) to 180/590.\n #[inline(never)] #[cold] // this is the slow path, please never inline this\n-fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) -> ! {\n+fn begin_unwind_inner(msg: Box<Any + Send>,\n+                      file_line: &(&'static str, uint)) -> ! {\n     // Make sure the default failure handler is registered before we look at the\n     // callbacks.\n-    static INIT: Once = ONCE_INIT;\n-    INIT.doit(|| unsafe { register(failure::on_fail); });\n+    unsafe {\n+        static LOCK: Mutex = MUTEX_INIT;\n+        static mut INIT: bool = false;\n+        LOCK.lock();\n+        if !INIT {\n+            register(failure::on_fail);\n+            INIT = true;\n+        }\n+        LOCK.unlock();\n+    }\n \n     // First, invoke call the user-defined callbacks triggered on thread panic.\n     //"}, {"sha": "7093c417b1140540d961c3c9701364a7af520bf6", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -20,6 +20,8 @@\n //! can be created in the future and there must be no active timers at that\n //! time.\n \n+#![macro_escape]\n+\n use prelude::*;\n \n use cell::UnsafeCell;\n@@ -68,6 +70,17 @@ struct RaceBox(helper_signal::signal);\n unsafe impl Send for RaceBox {}\n unsafe impl Sync for RaceBox {}\n \n+macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n+    static $name: Helper<$m> = Helper {\n+        lock: ::sync::MUTEX_INIT,\n+        cond: ::sync::CONDVAR_INIT,\n+        chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n+        signal: ::cell::UnsafeCell { value: 0 },\n+        initialized: ::cell::UnsafeCell { value: false },\n+        shutdown: ::cell::UnsafeCell { value: false },\n+    };\n+) }\n+\n impl<M: Send> Helper<M> {\n     /// Lazily boots a helper thread, becoming a no-op if the helper has already\n     /// been spawned.\n@@ -84,7 +97,7 @@ impl<M: Send> Helper<M> {\n     {\n         unsafe {\n             let _guard = self.lock.lock().unwrap();\n-            if !*self.initialized.get() {\n+            if *self.chan.get() as uint == 0 {\n                 let (tx, rx) = channel();\n                 *self.chan.get() = mem::transmute(box tx);\n                 let (receive, send) = helper_signal::new();\n@@ -93,15 +106,17 @@ impl<M: Send> Helper<M> {\n                 let receive = RaceBox(receive);\n \n                 let t = f();\n-                Thread::spawn(move |:| {\n+                Thread::spawn(move || {\n                     helper(receive.0, rx, t);\n                     let _g = self.lock.lock().unwrap();\n                     *self.shutdown.get() = true;\n                     self.cond.notify_one()\n                 }).detach();\n \n-                rt::at_exit(move|:| { self.shutdown() });\n+                rt::at_exit(move || { self.shutdown() });\n                 *self.initialized.get() = true;\n+            } else if *self.chan.get() as uint == 1 {\n+                panic!(\"cannot continue usage after shutdown\");\n             }\n         }\n     }\n@@ -116,7 +131,9 @@ impl<M: Send> Helper<M> {\n             // Must send and *then* signal to ensure that the child receives the\n             // message. Otherwise it could wake up and go to sleep before we\n             // send the message.\n-            assert!(!self.chan.get().is_null());\n+            assert!(*self.chan.get() as uint != 0);\n+            assert!(*self.chan.get() as uint != 1,\n+                    \"cannot continue usage after shutdown\");\n             (**self.chan.get()).send(msg);\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);\n         }\n@@ -129,9 +146,13 @@ impl<M: Send> Helper<M> {\n             // returns.\n             let mut guard = self.lock.lock().unwrap();\n \n+            let ptr = *self.chan.get();\n+            if ptr as uint == 1 {\n+                panic!(\"cannot continue usage after shutdown\");\n+            }\n             // Close the channel by destroying it\n             let chan: Box<Sender<M>> = mem::transmute(*self.chan.get());\n-            *self.chan.get() = 0 as *mut Sender<M>;\n+            *self.chan.get() = 1 as *mut Sender<M>;\n             drop(chan);\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);\n "}, {"sha": "6b2b325e638d798fc88fd50cdf85605688655361", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(missing_docs)]\n-#![allow(dead_code)]\n+#![macro_escape]\n \n use io::{mod, IoError, IoResult};\n use prelude::*;"}, {"sha": "322d2f202f7728436a2f3dd509cb5f16394e6d97", "filename": "src/libstd/sys/common/mutex.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -29,6 +29,7 @@ impl Mutex {\n     /// Behavior is undefined if the mutex is moved after the first method is\n     /// called on the mutex.\n     #[inline]\n+    #[allow(dead_code)] // sys is not exported yet\n     pub unsafe fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n \n     /// Lock the mutex blocking the current thread until it is available."}, {"sha": "24d22eb58c5e0f57df245801b87130444ab5deaf", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -22,7 +22,9 @@ use io::{IoResult, IoError};\n use sys::{mod, retry, c, sock_t, last_error, last_net_error, last_gai_error, close_sock,\n           wrlen, msglen_t, os, wouldblock, set_nonblocking, timer, ms_to_timeval,\n           decode_error_detailed};\n-use sync::{Mutex, MutexGuard};\n+use sync::Mutex;\n+#[cfg(not(target_os = \"linux\"))]\n+use sync::MutexGuard;\n use sys_common::{mod, keep_going, short_write, timeout};\n use prelude::*;\n use cmp;\n@@ -573,11 +575,13 @@ impl Drop for Inner {\n     fn drop(&mut self) { unsafe { close_sock(self.fd); } }\n }\n \n+#[cfg(not(target_os = \"linux\"))]\n pub struct Guard<'a> {\n     pub fd: sock_t,\n     pub guard: MutexGuard<'a, ()>,\n }\n \n+#[cfg(not(target_os = \"linux\"))]\n #[unsafe_destructor]\n impl<'a> Drop for Guard<'a> {\n     fn drop(&mut self) {"}, {"sha": "b7c4cfcd0f5fef8e758715ead568e4ac32fad3ec", "filename": "src/libstd/sys/common/rwlock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -26,6 +26,7 @@ impl RWLock {\n     /// Usage of an RWLock is undefined if it is moved after its first use (any\n     /// function calls below).\n     #[inline]\n+    #[allow(dead_code)] // sys is not exported yet\n     pub unsafe fn new() -> RWLock { RWLock(imp::RWLock::new()) }\n \n     /// Acquire shared access to the underlying lock, blocking the current"}, {"sha": "1966a9544e1a5205dcdcbd1cec78a0c99b05e44c", "filename": "src/libstd/sys/common/stack.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -121,37 +121,6 @@ pub unsafe fn record_os_managed_stack_bounds(stack_lo: uint, _stack_hi: uint) {\n     record_sp_limit(stack_lo + RED_ZONE);\n }\n \n-#[inline(always)]\n-pub unsafe fn record_rust_managed_stack_bounds(stack_lo: uint, stack_hi: uint) {\n-    // When the old runtime had segmented stacks, it used a calculation that was\n-    // \"limit + RED_ZONE + FUDGE\". The red zone was for things like dynamic\n-    // symbol resolution, llvm function calls, etc. In theory this red zone\n-    // value is 0, but it matters far less when we have gigantic stacks because\n-    // we don't need to be so exact about our stack budget. The \"fudge factor\"\n-    // was because LLVM doesn't emit a stack check for functions < 256 bytes in\n-    // size. Again though, we have giant stacks, so we round all these\n-    // calculations up to the nice round number of 20k.\n-    record_sp_limit(stack_lo + RED_ZONE);\n-\n-    return target_record_stack_bounds(stack_lo, stack_hi);\n-\n-    #[cfg(not(windows))] #[inline(always)]\n-    unsafe fn target_record_stack_bounds(_stack_lo: uint, _stack_hi: uint) {}\n-\n-    #[cfg(all(windows, target_arch = \"x86\"))] #[inline(always)]\n-    unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n-        // stack range is at TIB: %fs:0x04 (top) and %fs:0x08 (bottom)\n-        asm!(\"mov $0, %fs:0x04\" :: \"r\"(stack_hi) :: \"volatile\");\n-        asm!(\"mov $0, %fs:0x08\" :: \"r\"(stack_lo) :: \"volatile\");\n-    }\n-    #[cfg(all(windows, target_arch = \"x86_64\"))] #[inline(always)]\n-    unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n-        // stack range is at TIB: %gs:0x08 (top) and %gs:0x10 (bottom)\n-        asm!(\"mov $0, %gs:0x08\" :: \"r\"(stack_hi) :: \"volatile\");\n-        asm!(\"mov $0, %gs:0x10\" :: \"r\"(stack_lo) :: \"volatile\");\n-    }\n-}\n-\n /// Records the current limit of the stack as specified by `end`.\n ///\n /// This is stored in an OS-dependent location, likely inside of the thread"}, {"sha": "f32c1ea3658bfcb9bfda78f6b59baa06e8750de4", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -8,17 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(dead_code)] // stack_guard isn't used right now on all platforms\n+\n use core::prelude::*;\n \n use thread::Thread;\n use cell::RefCell;\n use string::String;\n \n struct ThreadInfo {\n-    // This field holds the known bounds of the stack in (lo, hi)\n-    // form. Not all threads necessarily know their precise bounds,\n-    // hence this is optional.\n-    stack_bounds: (uint, uint),\n     stack_guard: uint,\n     thread: Thread,\n }\n@@ -35,7 +33,6 @@ impl ThreadInfo {\n         THREAD_INFO.with(|c| {\n             if c.borrow().is_none() {\n                 *c.borrow_mut() = Some(ThreadInfo {\n-                    stack_bounds: (0, 0),\n                     stack_guard: 0,\n                     thread: NewThread::new(None),\n                 })\n@@ -53,10 +50,9 @@ pub fn stack_guard() -> uint {\n     ThreadInfo::with(|info| info.stack_guard)\n }\n \n-pub fn set(stack_bounds: (uint, uint), stack_guard: uint, thread: Thread) {\n+pub fn set(stack_guard: uint, thread: Thread) {\n     THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n     THREAD_INFO.with(move |c| *c.borrow_mut() = Some(ThreadInfo{\n-        stack_bounds: stack_bounds,\n         stack_guard: stack_guard,\n         thread: thread,\n     }));"}, {"sha": "cc69fbceacb335908986bad39ea286b3d723b27c", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -55,11 +55,11 @@\n //! ```\n \n #![allow(non_camel_case_types)]\n+#![allow(dead_code)] // sys isn't exported yet\n \n use prelude::*;\n \n use sync::atomic::{mod, AtomicUint};\n-use sync::{Mutex, Once, ONCE_INIT};\n \n use sys::thread_local as imp;\n \n@@ -140,9 +140,6 @@ pub const INIT_INNER: StaticKeyInner = StaticKeyInner {\n     key: atomic::INIT_ATOMIC_UINT,\n };\n \n-static INIT_KEYS: Once = ONCE_INIT;\n-static mut KEYS: *mut Mutex<Vec<imp::Key>> = 0 as *mut _;\n-\n impl StaticKey {\n     /// Gets the value associated with this TLS key\n     ///"}, {"sha": "0ec34fb1318210fbe8e05c0443db348d1be42e82", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -83,12 +83,12 @@\n /// to symbols. This is a bit of a hokey implementation as-is, but it works for\n /// all unix platforms we support right now, so it at least gets the job done.\n \n+use prelude::*;\n+\n use c_str::CString;\n-use io::{IoResult, Writer};\n+use io::IoResult;\n use libc;\n use mem;\n-use option::Option::{mod, Some, None};\n-use result::Result::{Ok, Err};\n use sync::{StaticMutex, MUTEX_INIT};\n \n use sys_common::backtrace::*;\n@@ -151,7 +151,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n     // I/O done here is blocking I/O, not green I/O, so we don't have to\n     // worry about this being a native vs green mutex.\n     static LOCK: StaticMutex = MUTEX_INIT;\n-    let _g = unsafe { LOCK.lock() };\n+    let _g = LOCK.lock();\n \n     try!(writeln!(w, \"stack backtrace:\"));\n \n@@ -241,12 +241,8 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n \n #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n-    use iter::{Iterator, IteratorExt};\n     use os;\n-    use path::GenericPath;\n-    use ptr::PtrExt;\n     use ptr;\n-    use slice::SliceExt;\n \n     ////////////////////////////////////////////////////////////////////////\n     // libbacktrace.h API"}, {"sha": "27fa74986730343fa14ae32d50c0f2b78b6ea67a", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -10,30 +10,14 @@\n \n #![allow(missing_docs)]\n #![allow(non_camel_case_types)]\n-#![allow(unused_imports)]\n-#![allow(dead_code)]\n-#![allow(unused_unsafe)]\n-#![allow(unused_mut)]\n \n extern crate libc;\n \n-use num;\n use num::{Int, SignedInt};\n use prelude::*;\n use io::{mod, IoResult, IoError};\n use sys_common::mkerr_libc;\n \n-macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n-    static $name: Helper<$m> = Helper {\n-        lock: ::sync::MUTEX_INIT,\n-        cond: ::sync::CONDVAR_INIT,\n-        chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n-        signal: ::cell::UnsafeCell { value: 0 },\n-        initialized: ::cell::UnsafeCell { value: false },\n-        shutdown: ::cell::UnsafeCell { value: false },\n-    };\n-) }\n-\n pub mod backtrace;\n pub mod c;\n pub mod ext;"}, {"sha": "c9cb46b0289f12893f894e9261770e7b84afc46d", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -11,7 +11,6 @@\n use cell::UnsafeCell;\n use kinds::Sync;\n use sys::sync as ffi;\n-use sys_common::mutex;\n \n pub struct Mutex { inner: UnsafeCell<ffi::pthread_mutex_t> }\n \n@@ -26,6 +25,7 @@ pub const MUTEX_INIT: Mutex = Mutex {\n \n unsafe impl Sync for Mutex {}\n \n+#[allow(dead_code)] // sys isn't exported yet\n impl Mutex {\n     #[inline]\n     pub unsafe fn new() -> Mutex {"}, {"sha": "446960ab92f4b9da1677126bd1879934e14fcc6e", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -10,17 +10,16 @@\n \n //! Implementation of `std::os` functionality for unix systems\n \n+#![allow(unused_imports)] // lots of cfg code here\n+\n use prelude::*;\n \n-use error::{FromError, Error};\n-use fmt;\n use io::{IoError, IoResult};\n-use libc::{mod, c_int, c_char, c_void};\n+use libc::{mod, c_int, c_char};\n+use os;\n use path::BytesContainer;\n use ptr;\n-use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use sys::fs::FileDesc;\n-use os;\n \n use os::TMPBUF_SZ;\n "}, {"sha": "3b868065f8f1cfe6f4a867976e6612179327659c", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -145,7 +145,7 @@ impl UnixStream {\n     fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n         let ret = Guard {\n             fd: self.fd(),\n-            guard: unsafe { self.inner.lock.lock().unwrap() },\n+            guard: self.inner.lock.lock().unwrap(),\n         };\n         assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret"}, {"sha": "48df8c4eced9d3f33b6be67c11da5bfb161eaa99", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -11,7 +11,7 @@ use self::Req::*;\n \n use libc::{mod, pid_t, c_void, c_int};\n use c_str::CString;\n-use io::{mod, IoResult, IoError, EndOfFile};\n+use io::{IoResult, EndOfFile};\n use mem;\n use os;\n use ptr;\n@@ -327,15 +327,15 @@ impl Process {\n         // The actual communication between the helper thread and this thread is\n         // quite simple, just a channel moving data around.\n \n-        unsafe { HELPER.boot(register_sigchld, waitpid_helper) }\n+        HELPER.boot(register_sigchld, waitpid_helper);\n \n         match self.try_wait() {\n             Some(ret) => return Ok(ret),\n             None => {}\n         }\n \n         let (tx, rx) = channel();\n-        unsafe { HELPER.send(NewChild(self.pid, tx, deadline)); }\n+        HELPER.send(NewChild(self.pid, tx, deadline));\n         return match rx.recv_opt() {\n             Ok(e) => Ok(e),\n             Err(()) => Err(timeout(\"wait timed out\")),\n@@ -419,8 +419,15 @@ impl Process {\n                             Ok(NewChild(pid, tx, deadline)) => {\n                                 active.push((pid, tx, deadline));\n                             }\n+                            // Once we've been disconnected it means the main\n+                            // thread is exiting (at_exit has run). We could\n+                            // still have active waiter for other threads, so\n+                            // we're just going to drop them all on the floor.\n+                            // This means that they won't receive a \"you're\n+                            // done\" message in which case they'll be considered\n+                            // as timed out, but more generally errors will\n+                            // start propagating.\n                             Err(comm::Disconnected) => {\n-                                assert!(active.len() == 0);\n                                 break 'outer;\n                             }\n                             Err(comm::Empty) => break,"}, {"sha": "4f9b06685ec0c5269106966ab536ca84dd621c29", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -17,6 +17,7 @@ pub const RWLOCK_INIT: RWLock = RWLock {\n     inner: UnsafeCell { value: ffi::PTHREAD_RWLOCK_INITIALIZER },\n };\n \n+#[allow(dead_code)] // sys isn't exported yet\n impl RWLock {\n     #[inline]\n     pub unsafe fn new() -> RWLock {"}, {"sha": "f1d7f1784d098834a0445ba5f3f6ddd5db3f16cb", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -34,7 +34,6 @@ impl Drop for Handler {\n \n #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n mod imp {\n-    use core::prelude::*;\n     use sys_common::stack;\n \n     use super::Handler;"}, {"sha": "696d3fb676df38f91cc3148a4f13ddd03c5e4f6d", "filename": "src/libstd/sys/unix/tcp.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -135,10 +135,6 @@ impl TcpAcceptor {\n         Err(sys_common::eof())\n     }\n \n-    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n-        net::sockname(self.fd(), libc::getsockname)\n-    }\n-\n     pub fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|a| sys::timer::now() + a).unwrap_or(0);\n     }"}, {"sha": "1ababbc0d855a99e1997079e8bc23748179778f1", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -100,7 +100,7 @@ pub fn now() -> u64 {\n fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n     let mut set: c::fd_set = unsafe { mem::zeroed() };\n \n-    let mut fd = FileDesc::new(input, true);\n+    let fd = FileDesc::new(input, true);\n     let mut timeout: libc::timeval = unsafe { mem::zeroed() };\n \n     // active timers are those which are able to be selected upon (and it's a\n@@ -168,8 +168,15 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n             1 => {\n                 loop {\n                     match messages.try_recv() {\n+                        // Once we've been disconnected it means the main thread\n+                        // is exiting (at_exit has run). We could still have\n+                        // active timers for other threads, so we're just going\n+                        // to drop them all on the floor. This is all we can\n+                        // really do, however, to prevent resource leakage. The\n+                        // remaining timers will likely start panicking quickly\n+                        // as they attempt to re-use this thread but are\n+                        // disallowed to do so.\n                         Err(comm::Disconnected) => {\n-                            assert!(active.len() == 0);\n                             break 'outer;\n                         }\n "}, {"sha": "d05047a220fcdf50205286c9b67611ce327bded2", "filename": "src/libstd/sys/unix/tty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftty.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -43,5 +43,4 @@ impl TTY {\n     pub fn get_winsize(&mut self) -> IoResult<(int, int)> {\n         Err(sys_common::unimpl())\n     }\n-    pub fn isatty(&self) -> bool { false }\n }"}, {"sha": "e5a37e5651b25905a774c2a4390437cbceff7813", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -7,19 +7,22 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-/// As always, windows has something very different than unix, we mainly want\n-/// to avoid having to depend too much on libunwind for windows.\n-///\n-/// If you google around, you'll find a fair bit of references to built-in\n-/// functions to get backtraces on windows. It turns out that most of these are\n-/// in an external library called dbghelp. I was unable to find this library\n-/// via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n-/// of it.\n-///\n-/// You'll also find that there's a function called CaptureStackBackTrace\n-/// mentioned frequently (which is also easy to use), but sadly I didn't have a\n-/// copy of that function in my mingw install (maybe it was broken?). Instead,\n-/// this takes the route of using StackWalk64 in order to walk the stack.\n+\n+//! As always, windows has something very different than unix, we mainly want\n+//! to avoid having to depend too much on libunwind for windows.\n+//!\n+//! If you google around, you'll find a fair bit of references to built-in\n+//! functions to get backtraces on windows. It turns out that most of these are\n+//! in an external library called dbghelp. I was unable to find this library\n+//! via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n+//! of it.\n+//!\n+//! You'll also find that there's a function called CaptureStackBackTrace\n+//! mentioned frequently (which is also easy to use), but sadly I didn't have a\n+//! copy of that function in my mingw install (maybe it was broken?). Instead,\n+//! this takes the route of using StackWalk64 in order to walk the stack.\n+\n+#![allow(dead_code)] // constants/fields aren't always used on all platforms\n \n use c_str::CString;\n use intrinsics;\n@@ -294,7 +297,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n     // According to windows documentation, all dbghelp functions are\n     // single-threaded.\n     static LOCK: StaticMutex = MUTEX_INIT;\n-    let _g = unsafe { LOCK.lock() };\n+    let _g = LOCK.lock();\n \n     // Open up dbghelp.dll, we don't link to it explicitly because it can't\n     // always be found. Additionally, it's nice having fewer dependencies."}, {"sha": "0aa7e539d781f10c6da5b255863b8009e6f96e1f", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -15,7 +15,6 @@\n #![allow(non_camel_case_types)]\n \n use libc;\n-use prelude::*;\n \n pub const WSADESCRIPTION_LEN: uint = 256;\n pub const WSASYS_STATUS_LEN: uint = 128;"}, {"sha": "523d9e9a3c24ce96d1385ffa9c0b46f4f12e720b", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -10,21 +10,17 @@\n \n //! Blocking Windows-based file I/O\n \n-use alloc::arc::Arc;\n use libc::{mod, c_int};\n \n-use c_str::CString;\n+use io;\n use mem;\n-use sys::os::fill_utf16_buf_and_decode;\n-use path;\n use ptr;\n-use str;\n-use io;\n+use sys::os::fill_utf16_buf_and_decode;\n \n use prelude::*;\n use sys;\n use sys::os;\n-use sys_common::{keep_going, eof, mkerr_libc};\n+use sys_common::{unimpl, mkerr_libc};\n \n use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n use io::{IoResult, IoError, FileStat, SeekStyle};\n@@ -445,7 +441,7 @@ pub fn stat(p: &Path) -> IoResult<FileStat> {\n // FIXME: move this to platform-specific modules (for now)?\n pub fn lstat(_p: &Path) -> IoResult<FileStat> {\n     // FIXME: implementation is missing\n-    Err(super::unimpl())\n+    Err(unimpl())\n }\n \n pub fn utime(p: &Path, atime: u64, mtime: u64) -> IoResult<()> {"}, {"sha": "15dc075cef9728a2f83f073656d24500065394c4", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -11,30 +11,14 @@\n #![allow(missing_docs)]\n #![allow(non_camel_case_types)]\n #![allow(non_snake_case)]\n-#![allow(unused_imports)]\n-#![allow(dead_code)]\n-#![allow(unused_unsafe)]\n-#![allow(unused_mut)]\n \n extern crate libc;\n \n-use num;\n use mem;\n use prelude::*;\n use io::{mod, IoResult, IoError};\n use sync::{Once, ONCE_INIT};\n \n-macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n-    static $name: Helper<$m> = Helper {\n-        lock: ::sync::MUTEX_INIT,\n-        cond: ::sync::CONDVAR_INIT,\n-        chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n-        signal: ::cell::UnsafeCell { value: 0 },\n-        initialized: ::cell::UnsafeCell { value: false },\n-        shutdown: ::cell::UnsafeCell { value: false },\n-    };\n-) }\n-\n pub mod backtrace;\n pub mod c;\n pub mod ext;\n@@ -179,14 +163,6 @@ pub fn init_net() {\n     }\n }\n \n-pub fn unimpl() -> IoError {\n-    IoError {\n-        kind: io::IoUnavailable,\n-        desc: \"operation is not implemented\",\n-        detail: None,\n-    }\n-}\n-\n pub fn to_utf16(s: Option<&str>) -> IoResult<Vec<u16>> {\n     match s {\n         Some(s) => Ok({"}, {"sha": "5a7be63e39f175097e8464a16b839b28207e550a", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -15,14 +15,12 @@\n \n use prelude::*;\n \n-use fmt;\n use io::{IoResult, IoError};\n-use libc::{c_int, c_char, c_void};\n+use libc::{c_int, c_void};\n use libc;\n use os;\n use path::BytesContainer;\n use ptr;\n-use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use sys::fs::FileDesc;\n use slice;\n "}, {"sha": "8b2fc3d9fb57ff9569e5f6c4f73687958a7e7f4c", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -365,7 +365,7 @@ impl UnixStream {\n         // acquire the lock.\n         //\n         // See comments in close_read() about why this lock is necessary.\n-        let guard = unsafe { self.inner.lock.lock() };\n+        let guard = self.inner.lock.lock();\n         if self.read_closed() {\n             return Err(eof())\n         }\n@@ -441,7 +441,7 @@ impl UnixStream {\n             // going after we woke up.\n             //\n             // See comments in close_read() about why this lock is necessary.\n-            let guard = unsafe { self.inner.lock.lock() };\n+            let guard = self.inner.lock.lock();\n             if self.write_closed() {\n                 return Err(epipe())\n             }\n@@ -516,14 +516,14 @@ impl UnixStream {\n         // close_read() between steps 1 and 2. By atomically executing steps 1\n         // and 2 with a lock with respect to close_read(), we're guaranteed that\n         // no thread will erroneously sit in a read forever.\n-        let _guard = unsafe { self.inner.lock.lock() };\n+        let _guard = self.inner.lock.lock();\n         self.inner.read_closed.store(true, atomic::SeqCst);\n         self.cancel_io()\n     }\n \n     pub fn close_write(&mut self) -> IoResult<()> {\n         // see comments in close_read() for why this lock is necessary\n-        let _guard = unsafe { self.inner.lock.lock() };\n+        let _guard = self.inner.lock.lock();\n         self.inner.write_closed.store(true, atomic::SeqCst);\n         self.cancel_io()\n     }"}, {"sha": "0c5a0eb6bb9cf15c1a5255aee6f1552c22f7f290", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -8,25 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc::{pid_t, c_void, c_int};\n+use prelude::*;\n+\n+use libc::{pid_t, c_void};\n use libc;\n use c_str::CString;\n use io;\n use mem;\n use os;\n use ptr;\n-use prelude::*;\n-use io::process::{ProcessExit, ExitStatus, ExitSignal};\n+use io::process::{ProcessExit, ExitStatus};\n use collections;\n use path::BytesContainer;\n use hash::Hash;\n use io::{IoResult, IoError};\n \n-use sys::fs;\n-use sys::{mod, retry, c, wouldblock, set_nonblocking, ms_to_timeval, timer};\n+use sys::timer;\n use sys::fs::FileDesc;\n-use sys_common::helper_thread::Helper;\n-use sys_common::{AsInner, mkerr_libc, timeout};\n+use sys_common::{AsInner, timeout};\n \n use io::fs::PathExtensions;\n \n@@ -121,8 +120,6 @@ impl Process {\n         use libc::funcs::extra::msvcrt::get_osfhandle;\n \n         use mem;\n-        use iter::{Iterator, IteratorExt};\n-        use str::StrExt;\n \n         if cfg.gid().is_some() || cfg.uid().is_some() {\n             return Err(IoError {"}, {"sha": "ab092f5a243279bb16623ba0fbd609c504c1c556", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -14,7 +14,7 @@ use ptr;\n use mem;\n use libc;\n use libc::types::os::arch::extra::{LPVOID, DWORD, LONG, BOOL};\n-use sys_common::{stack, thread_info};\n+use sys_common::stack;\n \n pub struct Handler {\n     _data: *mut libc::c_void\n@@ -30,14 +30,6 @@ impl Drop for Handler {\n     fn drop(&mut self) {}\n }\n \n-// get_task_info is called from an exception / signal handler.\n-// It returns the guard page of the current task or 0 if that\n-// guard page doesn't exist. None is returned if there's currently\n-// no local task.\n-unsafe fn get_task_guard_page() -> uint {\n-    thread_info::stack_guard()\n-}\n-\n // This is initialized in init() and only read from after\n static mut PAGE_SIZE: uint = 0;\n "}, {"sha": "339c724d9a9a1bfc4c11410f60f1cd83eb1ec02b", "filename": "src/libstd/sys/windows/tcp.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -14,11 +14,10 @@ use libc;\n use mem;\n use ptr;\n use prelude::*;\n-use super::{last_error, last_net_error, retry, sock_t};\n+use super::{last_error, last_net_error, sock_t};\n use sync::{Arc, atomic};\n-use sys::fs::FileDesc;\n use sys::{mod, c, set_nonblocking, wouldblock, timer};\n-use sys_common::{mod, timeout, eof, net};\n+use sys_common::{timeout, eof, net};\n \n pub use sys_common::net::TcpStream;\n \n@@ -205,10 +204,6 @@ impl TcpAcceptor {\n         Err(eof())\n     }\n \n-    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n-        net::sockname(self.socket(), libc::getsockname)\n-    }\n-\n     pub fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }"}, {"sha": "59ab5f5c4d990b776f2741ae6af69e134aff1dfd", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n-\n use boxed::Box;\n use cmp;\n use mem;"}, {"sha": "4ac57e37117877139bbe1a00ad8aae53ca9c084e", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -137,23 +137,29 @@ unsafe fn init_dtors() {\n     rt::at_exit(move|| {\n         DTOR_LOCK.lock();\n         let dtors = DTORS;\n-        DTORS = 0 as *mut _;\n+        DTORS = 1 as *mut _;\n         mem::transmute::<_, Box<Vec<(Key, Dtor)>>>(dtors);\n-        assert!(DTORS.is_null()); // can't re-init after destructing\n+        assert!(DTORS as uint == 1); // can't re-init after destructing\n         DTOR_LOCK.unlock();\n     });\n }\n \n unsafe fn register_dtor(key: Key, dtor: Dtor) {\n     DTOR_LOCK.lock();\n     init_dtors();\n+    assert!(DTORS as uint != 0);\n+    assert!(DTORS as uint != 1,\n+            \"cannot create new TLS keys after the main thread has exited\");\n     (*DTORS).push((key, dtor));\n     DTOR_LOCK.unlock();\n }\n \n unsafe fn unregister_dtor(key: Key) -> bool {\n     DTOR_LOCK.lock();\n     init_dtors();\n+    assert!(DTORS as uint != 0);\n+    assert!(DTORS as uint != 1,\n+            \"cannot unregister destructors after the main thread has exited\");\n     let ret = {\n         let dtors = &mut *DTORS;\n         let before = dtors.len();\n@@ -232,6 +238,7 @@ unsafe extern \"system\" fn on_tls_callback(h: LPVOID,\n     }\n }\n \n+#[allow(dead_code)] // not actually dead\n unsafe fn run_dtors() {\n     let mut any_run = true;\n     for _ in range(0, 5i) {"}, {"sha": "c0e67642a6466b6a1ad1b74244ecfa668c03f3a7", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -26,8 +26,6 @@ use libc;\n use ptr;\n use comm;\n \n-use sys::c;\n-use sys::fs::FileDesc;\n use sys_common::helper_thread::Helper;\n use prelude::*;\n use io::IoResult;\n@@ -80,9 +78,10 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) {\n                             None => {}\n                         }\n                     }\n+                    // See the comment in unix::timer for why we don't have any\n+                    // asserts here and why we're likely just leaving timers on\n+                    // the floor as we exit.\n                     Err(comm::Disconnected) => {\n-                        assert_eq!(objs.len(), 1);\n-                        assert_eq!(chans.len(), 0);\n                         break 'outer;\n                     }\n                     Err(..) => break"}, {"sha": "607bb05f54fd421a93d162df2801736cee992245", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -26,7 +26,6 @@\n //! to working in raw UTF-16, with such a wrapper around it.\n \n use super::c::{ReadConsoleW, WriteConsoleW, GetConsoleMode, SetConsoleMode};\n-use super::c::{ERROR_ILLEGAL_CHARACTER};\n use super::c::{ENABLE_ECHO_INPUT, ENABLE_EXTENDED_FLAGS};\n use super::c::{ENABLE_INSERT_MODE, ENABLE_LINE_INPUT};\n use super::c::{ENABLE_PROCESSED_INPUT, ENABLE_QUICK_EDIT_MODE};\n@@ -38,6 +37,8 @@ use prelude::*;\n use ptr;\n use str::from_utf8;\n \n+use sys_common::unimpl;\n+\n fn invalid_encoding() -> IoError {\n     IoError {\n         kind: io::InvalidInput,\n@@ -149,11 +150,8 @@ impl TTY {\n         // Make a CONSOLE_SCREEN_BUFFER_INFO\n         // Call GetConsoleScreenBufferInfo\n         // Maybe call GetLargestConsoleWindowSize instead?\n-        Err(super::unimpl())\n+        Err(unimpl())\n     }\n-\n-    // Let us magically declare this as a TTY\n-    pub fn isatty(&self) -> bool { true }\n }\n \n impl Drop for TTY {"}, {"sha": "cfdb5c2ec26cb59a00cc41eac2c4951e85bf1199", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7", "patch": "@@ -232,13 +232,10 @@ impl Builder {\n             let my_stack_top = addr as uint;\n             let my_stack_bottom = my_stack_top - stack_size + 1024;\n             unsafe {\n-                stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n+                stack::record_os_managed_stack_bounds(my_stack_bottom,\n+                                                      my_stack_top);\n+                thread_info::set(imp::guard::current(), their_thread);\n             }\n-            thread_info::set(\n-                (my_stack_bottom, my_stack_top),\n-                unsafe { imp::guard::current() },\n-                their_thread\n-            );\n \n             let mut output = None;\n             let f: Thunk<(), T> = if stdout.is_some() || stderr.is_some() {"}]}