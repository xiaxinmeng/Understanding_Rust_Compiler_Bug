{"sha": "9d3d4b1a19f57c57caa1803bc05b5619eb0df964", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkM2Q0YjFhMTlmNTdjNTdjYWExODAzYmMwNWI1NjE5ZWIwZGY5NjQ=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-07T11:28:08Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T19:02:34Z"}, "message": "Refactor lock-step", "tree": {"sha": "a80da9d9a3866fd2ff1920edb8cd51683c449a7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a80da9d9a3866fd2ff1920edb8cd51683c449a7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d3d4b1a19f57c57caa1803bc05b5619eb0df964", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3d4b1a19f57c57caa1803bc05b5619eb0df964", "html_url": "https://github.com/rust-lang/rust/commit/9d3d4b1a19f57c57caa1803bc05b5619eb0df964", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d3d4b1a19f57c57caa1803bc05b5619eb0df964/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a96cf12c1583978a1e07bcd26db152cb459e03c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a96cf12c1583978a1e07bcd26db152cb459e03c", "html_url": "https://github.com/rust-lang/rust/commit/6a96cf12c1583978a1e07bcd26db152cb459e03c"}], "stats": {"total": 66, "additions": 39, "deletions": 27}, "files": [{"sha": "a95f4c6c941cf7839cb59ed3dd465ab99aa708f9", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/9d3d4b1a19f57c57caa1803bc05b5619eb0df964/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3d4b1a19f57c57caa1803bc05b5619eb0df964/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9d3d4b1a19f57c57caa1803bc05b5619eb0df964", "patch": "@@ -267,29 +267,33 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n \n             // Check whether this segment takes generic arguments and the user has provided any.\n             let (generic_args, infer_types) = args_for_def_id(def_id);\n-            if let Some(ref generic_args) = generic_args {\n+\n+            let mut args = generic_args.iter().flat_map(|generic_args| generic_args.args.iter());\n+            let mut next_arg = args.next();\n+\n+            loop {\n                 // We're going to iterate through the generic arguments that the user\n                 // provided, matching them with the generic parameters we expect.\n                 // Mismatches can occur as a result of elided lifetimes, or for malformed\n                 // input. We try to handle both sensibly.\n-                'args: for arg in &generic_args.args {\n-                    while let Some(param) = next_param {\n+                let mut progress_arg = true;\n+                match (next_arg, next_param) {\n+                    (Some(arg), Some(param)) => {\n                         match (&param.kind, arg) {\n                             (GenericParamDefKind::Lifetime, GenericArg::Lifetime(_)) => {\n                                 push_kind(&mut substs, provided_kind(param, arg));\n                                 next_param = params.next();\n-                                continue 'args;\n                             }\n                             (GenericParamDefKind::Lifetime, GenericArg::Type(_)) => {\n                                 // We expected a lifetime argument, but got a type\n                                 // argument. That means we're inferring the lifetimes.\n                                 push_kind(&mut substs, inferred_kind(None, param, infer_types));\n                                 next_param = params.next();\n+                                progress_arg = false;\n                             }\n                             (GenericParamDefKind::Type { .. }, GenericArg::Type(_)) => {\n                                 push_kind(&mut substs, provided_kind(param, arg));\n                                 next_param = params.next();\n-                                continue 'args;\n                             }\n                             (GenericParamDefKind::Type { .. }, GenericArg::Lifetime(_)) => {\n                                 // We expected a type argument, but got a lifetime\n@@ -300,35 +304,43 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                 if err_if_invalid {\n                                     tcx.sess.delay_span_bug(span,\n                                         \"found a GenericArg::Lifetime where a \\\n-                                        GenericArg::Type was expected\");\n+                                            GenericArg::Type was expected\");\n+                                }\n+                                // Exhaust the iterator.\n+                                while next_arg.is_some() {\n+                                    next_arg = args.next();\n                                 }\n-                                break 'args;\n                             }\n                         }\n                     }\n-                    // We should never be able to reach this point with well-formed input.\n-                    // Getting to this point means the user supplied more arguments than\n-                    // there are parameters.\n-                    if err_if_invalid {\n-                        tcx.sess.delay_span_bug(span,\n-                            \"GenericArg did not have matching GenericParamDef\");\n-                    }\n-                }\n-            }\n-\n-            // If there are fewer arguments than parameters, it means\n-            // we're inferring the remaining arguments.\n-            while let Some(param) = next_param {\n-                match param.kind {\n-                    GenericParamDefKind::Lifetime => {\n-                        push_kind(&mut substs, inferred_kind(None, param, infer_types));\n+                    (Some(_), None) => {\n+                        // We should never be able to reach this point with well-formed input.\n+                        // Getting to this point means the user supplied more arguments than\n+                        // there are parameters.\n+                        if err_if_invalid {\n+                            tcx.sess.delay_span_bug(span,\n+                                \"GenericArg did not have matching GenericParamDef\");\n+                        }\n                     }\n-                    GenericParamDefKind::Type { .. } => {\n-                        let kind = inferred_kind(Some(&substs), param, infer_types);\n-                        push_kind(&mut substs, kind);\n+                    (None, Some(param)) => {\n+                        // If there are fewer arguments than parameters, it means\n+                        // we're inferring the remaining arguments.\n+                        match param.kind {\n+                            GenericParamDefKind::Lifetime => {\n+                                push_kind(&mut substs, inferred_kind(None, param, infer_types));\n+                            }\n+                            GenericParamDefKind::Type { .. } => {\n+                                let kind = inferred_kind(Some(&substs), param, infer_types);\n+                                push_kind(&mut substs, kind);\n+                            }\n+                        }\n+                        next_param = params.next();\n                     }\n+                    (None, None) => break,\n+                }\n+                if progress_arg {\n+                    next_arg = args.next();\n                 }\n-                next_param = params.next();\n             }\n         }\n "}]}