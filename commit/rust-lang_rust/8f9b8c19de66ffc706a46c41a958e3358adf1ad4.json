{"sha": "8f9b8c19de66ffc706a46c41a958e3358adf1ad4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmOWI4YzE5ZGU2NmZmYzcwNmE0NmM0MWE5NThlMzM1OGFkZjFhZDQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-28T01:01:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-28T01:01:48Z"}, "message": "Rollup merge of #62883 - Stargateur:refactoring-adapters, r=scottmcm\n\nRefactoring use common code between option, result and accum\n\n`Option` and `Result` have almost exactly the same code that in `accum.rs` that implement `Sum` and `Product`. This PR just move some code to use the same code for all of them. I believe is better to not implement this `Iterator` feature twice.\n\nI'm not very familiar with pub visibility hope I didn't make then public. However, maybe these adapters could be useful and we could think to make then pub.\n\n#59605\n#11084\n\nr? @pnkfelix", "tree": {"sha": "554fb5d717fc67f53a4326d969702bd4d977e410", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/554fb5d717fc67f53a4326d969702bd4d977e410"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f9b8c19de66ffc706a46c41a958e3358adf1ad4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdPPP8CRBK7hj4Ov3rIwAAdHIIAJ+HllOs0UaUucMPV2ITMpoI\nRTlWj7/CWTIkhyozQ+54vFy9vOoZjMddAnQn6rzEkpcar8eU0/likJW2esstpWhT\nvBG4XD+peaMF/tntxNoMae9ACJnWZPiG7baGIc98II2gE1feaO9ZuLE3qzXxkKVG\nRzvqkRmANkyRgLh41rGYEYGYnpPWVETL2f5KT7H+ATUtCH9ZL6xITBPQWRI6z99J\npH5Nq5rl9t0/Lw5XsIpPkfCsPrAp2I75Gt9JkJWD8hE5q01d98IPih9zbBWqroW9\nqcyvyKvnxBQXvwoeTtAEye6rwKcwRuyPvO3rTi9goQaKmxEnGeLY7XNr0Xmw90E=\n=eAlN\n-----END PGP SIGNATURE-----\n", "payload": "tree 554fb5d717fc67f53a4326d969702bd4d977e410\nparent ca0cd73f498449de4aaf6ff9bd620838e21e9b59\nparent 3334802c83070d63b85b5b2e5508c15bfaf6e254\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564275708 +0200\ncommitter GitHub <noreply@github.com> 1564275708 +0200\n\nRollup merge of #62883 - Stargateur:refactoring-adapters, r=scottmcm\n\nRefactoring use common code between option, result and accum\n\n`Option` and `Result` have almost exactly the same code that in `accum.rs` that implement `Sum` and `Product`. This PR just move some code to use the same code for all of them. I believe is better to not implement this `Iterator` feature twice.\n\nI'm not very familiar with pub visibility hope I didn't make then public. However, maybe these adapters could be useful and we could think to make then pub.\n\n#59605\n#11084\n\nr? @pnkfelix\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f9b8c19de66ffc706a46c41a958e3358adf1ad4", "html_url": "https://github.com/rust-lang/rust/commit/8f9b8c19de66ffc706a46c41a958e3358adf1ad4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f9b8c19de66ffc706a46c41a958e3358adf1ad4/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "html_url": "https://github.com/rust-lang/rust/commit/ca0cd73f498449de4aaf6ff9bd620838e21e9b59"}, {"sha": "3334802c83070d63b85b5b2e5508c15bfaf6e254", "url": "https://api.github.com/repos/rust-lang/rust/commits/3334802c83070d63b85b5b2e5508c15bfaf6e254", "html_url": "https://github.com/rust-lang/rust/commit/3334802c83070d63b85b5b2e5508c15bfaf6e254"}], "stats": {"total": 351, "additions": 141, "deletions": 210}, "files": [{"sha": "8eae52ffd3277e43a2b44048a53b83be93a72b8d", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/8f9b8c19de66ffc706a46c41a958e3358adf1ad4/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9b8c19de66ffc706a46c41a958e3358adf1ad4/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=8f9b8c19de66ffc706a46c41a958e3358adf1ad4", "patch": "@@ -2062,3 +2062,138 @@ impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator, F> FusedIterator for Inspect<I, F>\n     where F: FnMut(&I::Item) {}\n+\n+/// An iterator adapter that produces output as long as the underlying\n+/// iterator produces `Option::Some` values.\n+pub(crate) struct OptionShunt<I> {\n+    iter: I,\n+    exited_early: bool,\n+}\n+\n+impl<I, T> OptionShunt<I>\n+where\n+    I: Iterator<Item = Option<T>>,\n+{\n+    /// Process the given iterator as if it yielded a `T` instead of a\n+    /// `Option<T>`. Any `None` value will stop the inner iterator and\n+    /// the overall result will be a `None`.\n+    pub fn process<F, U>(iter: I, mut f: F) -> Option<U>\n+    where\n+        F: FnMut(&mut Self) -> U,\n+    {\n+        let mut shunt = OptionShunt::new(iter);\n+        let value = f(shunt.by_ref());\n+        shunt.reconstruct(value)\n+    }\n+\n+    fn new(iter: I) -> Self {\n+        OptionShunt {\n+            iter,\n+            exited_early: false,\n+        }\n+    }\n+\n+    /// Consume the adapter and rebuild a `Option` value.\n+    fn reconstruct<U>(self, val: U) -> Option<U> {\n+        if self.exited_early {\n+            None\n+        } else {\n+            Some(val)\n+        }\n+    }\n+}\n+\n+impl<I, T> Iterator for OptionShunt<I>\n+where\n+    I: Iterator<Item = Option<T>>,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.iter.next() {\n+            Some(Some(v)) => Some(v),\n+            Some(None) => {\n+                self.exited_early = true;\n+                None\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.exited_early {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper)\n+        }\n+    }\n+}\n+\n+/// An iterator adapter that produces output as long as the underlying\n+/// iterator produces `Result::Ok` values.\n+///\n+/// If an error is encountered, the iterator stops and the error is\n+/// stored. The error may be recovered later via `reconstruct`.\n+pub(crate) struct ResultShunt<I, E> {\n+    iter: I,\n+    error: Option<E>,\n+}\n+\n+impl<I, T, E> ResultShunt<I, E>\n+    where I: Iterator<Item = Result<T, E>>\n+{\n+    /// Process the given iterator as if it yielded a `T` instead of a\n+    /// `Result<T, _>`. Any errors will stop the inner iterator and\n+    /// the overall result will be an error.\n+    pub fn process<F, U>(iter: I, mut f: F) -> Result<U, E>\n+        where F: FnMut(&mut Self) -> U\n+    {\n+        let mut shunt = ResultShunt::new(iter);\n+        let value = f(shunt.by_ref());\n+        shunt.reconstruct(value)\n+    }\n+\n+    fn new(iter: I) -> Self {\n+        ResultShunt {\n+            iter,\n+            error: None,\n+        }\n+    }\n+\n+    /// Consume the adapter and rebuild a `Result` value. This should\n+    /// *always* be called, otherwise any potential error would be\n+    /// lost.\n+    fn reconstruct<U>(self, val: U) -> Result<U, E> {\n+        match self.error {\n+            None => Ok(val),\n+            Some(e) => Err(e),\n+        }\n+    }\n+}\n+\n+impl<I, T, E> Iterator for ResultShunt<I, E>\n+    where I: Iterator<Item = Result<T, E>>\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.iter.next() {\n+            Some(Ok(v)) => Some(v),\n+            Some(Err(e)) => {\n+                self.error = Some(e);\n+                None\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.error.is_some() {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper)\n+        }\n+    }\n+}"}, {"sha": "4a7d7f96b9b041c2a86acab81f9862837171e347", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f9b8c19de66ffc706a46c41a958e3358adf1ad4/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9b8c19de66ffc706a46c41a958e3358adf1ad4/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=8f9b8c19de66ffc706a46c41a958e3358adf1ad4", "patch": "@@ -360,7 +360,7 @@ pub use self::adapters::Flatten;\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n pub use self::adapters::Copied;\n \n-pub(crate) use self::adapters::TrustedRandomAccess;\n+pub(crate) use self::adapters::{TrustedRandomAccess, OptionShunt, ResultShunt};\n \n mod range;\n mod sources;"}, {"sha": "01b64fb08acf760da1ab29445a1e4867a8eadc8f", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 1, "deletions": 135, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/8f9b8c19de66ffc706a46c41a958e3358adf1ad4/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9b8c19de66ffc706a46c41a958e3358adf1ad4/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=8f9b8c19de66ffc706a46c41a958e3358adf1ad4", "patch": "@@ -1,5 +1,6 @@\n use crate::ops::{Mul, Add};\n use crate::num::Wrapping;\n+use crate::iter::adapters::{OptionShunt, ResultShunt};\n \n /// Trait to represent types that can be created by summing up an iterator.\n ///\n@@ -114,74 +115,6 @@ macro_rules! float_sum_product {\n integer_sum_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n float_sum_product! { f32 f64 }\n \n-/// An iterator adapter that produces output as long as the underlying\n-/// iterator produces `Result::Ok` values.\n-///\n-/// If an error is encountered, the iterator stops and the error is\n-/// stored. The error may be recovered later via `reconstruct`.\n-struct ResultShunt<I, E> {\n-    iter: I,\n-    error: Option<E>,\n-}\n-\n-impl<I, T, E> ResultShunt<I, E>\n-    where I: Iterator<Item = Result<T, E>>\n-{\n-    /// Process the given iterator as if it yielded a `T` instead of a\n-    /// `Result<T, _>`. Any errors will stop the inner iterator and\n-    /// the overall result will be an error.\n-    pub fn process<F, U>(iter: I, mut f: F) -> Result<U, E>\n-        where F: FnMut(&mut Self) -> U\n-    {\n-        let mut shunt = ResultShunt::new(iter);\n-        let value = f(shunt.by_ref());\n-        shunt.reconstruct(value)\n-    }\n-\n-    fn new(iter: I) -> Self {\n-        ResultShunt {\n-            iter,\n-            error: None,\n-        }\n-    }\n-\n-    /// Consume the adapter and rebuild a `Result` value. This should\n-    /// *always* be called, otherwise any potential error would be\n-    /// lost.\n-    fn reconstruct<U>(self, val: U) -> Result<U, E> {\n-        match self.error {\n-            None => Ok(val),\n-            Some(e) => Err(e),\n-        }\n-    }\n-}\n-\n-impl<I, T, E> Iterator for ResultShunt<I, E>\n-    where I: Iterator<Item = Result<T, E>>\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self.iter.next() {\n-            Some(Ok(v)) => Some(v),\n-            Some(Err(e)) => {\n-                self.error = Some(e);\n-                None\n-            }\n-            None => None,\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.error.is_some() {\n-            (0, Some(0))\n-        } else {\n-            let (_, upper) = self.iter.size_hint();\n-            (0, upper)\n-        }\n-    }\n-}\n-\n #[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n     where T: Sum<U>,\n@@ -224,73 +157,6 @@ impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n     }\n }\n \n-/// An iterator adapter that produces output as long as the underlying\n-/// iterator produces `Option::Some` values.\n-struct OptionShunt<I> {\n-    iter: I,\n-    exited_early: bool,\n-}\n-\n-impl<I, T> OptionShunt<I>\n-where\n-    I: Iterator<Item = Option<T>>,\n-{\n-    /// Process the given iterator as if it yielded a `T` instead of a\n-    /// `Option<T>`. Any `None` value will stop the inner iterator and\n-    /// the overall result will be a `None`.\n-    pub fn process<F, U>(iter: I, mut f: F) -> Option<U>\n-    where\n-        F: FnMut(&mut Self) -> U,\n-    {\n-        let mut shunt = OptionShunt::new(iter);\n-        let value = f(shunt.by_ref());\n-        shunt.reconstruct(value)\n-    }\n-\n-    fn new(iter: I) -> Self {\n-        OptionShunt {\n-            iter,\n-            exited_early: false,\n-        }\n-    }\n-\n-    /// Consume the adapter and rebuild a `Option` value.\n-    fn reconstruct<U>(self, val: U) -> Option<U> {\n-        if self.exited_early {\n-            None\n-        } else {\n-            Some(val)\n-        }\n-    }\n-}\n-\n-impl<I, T> Iterator for OptionShunt<I>\n-where\n-    I: Iterator<Item = Option<T>>,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self.iter.next() {\n-            Some(Some(v)) => Some(v),\n-            Some(None) => {\n-                self.exited_early = true;\n-                None\n-            }\n-            None => None,\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.exited_early {\n-            (0, Some(0))\n-        } else {\n-            let (_, upper) = self.iter.size_hint();\n-            (0, upper)\n-        }\n-    }\n-}\n-\n #[stable(feature = \"iter_arith_traits_option\", since = \"1.37.0\")]\n impl<T, U> Sum<Option<U>> for Option<T>\n where"}, {"sha": "70a87cfe5a78ab5ca87f0f90edc76ebbae526751", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8f9b8c19de66ffc706a46c41a958e3358adf1ad4/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9b8c19de66ffc706a46c41a958e3358adf1ad4/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=8f9b8c19de66ffc706a46c41a958e3358adf1ad4", "patch": "@@ -135,7 +135,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n+use crate::iter::{FromIterator, FusedIterator, TrustedLen, OptionShunt};\n use crate::{convert, fmt, hint, mem, ops::{self, Deref, DerefMut}};\n use crate::pin::Pin;\n \n@@ -1499,45 +1499,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n-        struct Adapter<Iter> {\n-            iter: Iter,\n-            found_none: bool,\n-        }\n-\n-        impl<T, Iter: Iterator<Item=Option<T>>> Iterator for Adapter<Iter> {\n-            type Item = T;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<T> {\n-                match self.iter.next() {\n-                    Some(Some(value)) => Some(value),\n-                    Some(None) => {\n-                        self.found_none = true;\n-                        None\n-                    }\n-                    None => None,\n-                }\n-            }\n-\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n-                if self.found_none {\n-                    (0, Some(0))\n-                } else {\n-                    let (_, upper) = self.iter.size_hint();\n-                    (0, upper)\n-                }\n-            }\n-        }\n-\n-        let mut adapter = Adapter { iter: iter.into_iter(), found_none: false };\n-        let v: V = FromIterator::from_iter(adapter.by_ref());\n-\n-        if adapter.found_none {\n-            None\n-        } else {\n-            Some(v)\n-        }\n+        OptionShunt::process(iter.into_iter(), |i| i.collect())\n     }\n }\n "}, {"sha": "559877ddd5a1ce0e166dd4afb5d0bf61a72fa4d6", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8f9b8c19de66ffc706a46c41a958e3358adf1ad4/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9b8c19de66ffc706a46c41a958e3358adf1ad4/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=8f9b8c19de66ffc706a46c41a958e3358adf1ad4", "patch": "@@ -231,7 +231,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fmt;\n-use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n+use crate::iter::{FromIterator, FusedIterator, TrustedLen, ResultShunt};\n use crate::ops::{self, Deref, DerefMut};\n \n /// `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).\n@@ -1343,39 +1343,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n-        struct Adapter<Iter, E> {\n-            iter: Iter,\n-            err: Option<E>,\n-        }\n-\n-        impl<T, E, Iter: Iterator<Item=Result<T, E>>> Iterator for Adapter<Iter, E> {\n-            type Item = T;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<T> {\n-                match self.iter.next() {\n-                    Some(Ok(value)) => Some(value),\n-                    Some(Err(err)) => {\n-                        self.err = Some(err);\n-                        None\n-                    }\n-                    None => None,\n-                }\n-            }\n-\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n-                let (_min, max) = self.iter.size_hint();\n-                (0, max)\n-            }\n-        }\n-\n-        let mut adapter = Adapter { iter: iter.into_iter(), err: None };\n-        let v: V = FromIterator::from_iter(adapter.by_ref());\n-\n-        match adapter.err {\n-            Some(err) => Err(err),\n-            None => Ok(v),\n-        }\n+        ResultShunt::process(iter.into_iter(), |i| i.collect())\n     }\n }\n "}]}