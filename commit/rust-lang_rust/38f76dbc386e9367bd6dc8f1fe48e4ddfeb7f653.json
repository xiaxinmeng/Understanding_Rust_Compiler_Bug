{"sha": "38f76dbc386e9367bd6dc8f1fe48e4ddfeb7f653", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4Zjc2ZGJjMzg2ZTkzNjdiZDZkYzhmMWZlNDhlNGRkZmViN2Y2NTM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-09-13T19:42:21Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-09-13T19:42:21Z"}, "message": "don't duplicate the code snippet in the \"trait unimplemented\" error\n\nnew error style:\n```\npath.rs:4:6: 4:7 error: the trait `core::marker::Sized` is not implemented for the type `[u8]` [E0277]\npath.rs:4 fn f(p: Path) {}\n               ^\npath.rs:4:6: 4:7 help: run `rustc --explain E0277` to see a detailed explanation\npath.rs:4:6: 4:7 note: `[u8]` does not have a constant size known at compile-time\npath.rs:4:6: 4:7 note: required because it appears within the type `std::sys::os_str::Slice`\npath.rs:4:6: 4:7 note: required because it appears within the type `std::ffi::os_str::OsStr`\npath.rs:4:6: 4:7 note: required because it appears within the type `std::path::Path`\npath.rs:4:6: 4:7 note: all local variables must have a statically known size\npath.rs:7:5: 7:36 error: the trait `core::marker::Send` is not implemented for the type `alloc::rc::Rc<()>` [E0277]\npath.rs:7     foo::<BTreeMap<Rc<()>, Rc<()>>>();\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\npath.rs:7:5: 7:36 help: run `rustc --explain E0277` to see a detailed explanation\npath.rs:7:5: 7:36 note: `alloc::rc::Rc<()>` cannot be sent between threads safely\npath.rs:7:5: 7:36 note: required because it appears within the type `collections::btree::node::Node<alloc::rc::Rc<()>, alloc::rc::Rc<()>>`\npath.rs:7:5: 7:36 note: required because it appears within the type `collections::btree::map::BTreeMap<alloc::rc::Rc<()>, alloc::rc::Rc<()>>`\npath.rs:7:5: 7:36 note: required by `foo`\nerror: aborting due to 2 previous errors\n```\n\nThis improves the #21793/#23286 situation", "tree": {"sha": "84fb0a6ca6b32bf28e6c64a8a4b399b96dcc653e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84fb0a6ca6b32bf28e6c64a8a4b399b96dcc653e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38f76dbc386e9367bd6dc8f1fe48e4ddfeb7f653", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38f76dbc386e9367bd6dc8f1fe48e4ddfeb7f653", "html_url": "https://github.com/rust-lang/rust/commit/38f76dbc386e9367bd6dc8f1fe48e4ddfeb7f653", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38f76dbc386e9367bd6dc8f1fe48e4ddfeb7f653/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfd76b364cd01695517467299618ef63f1c0cc07", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfd76b364cd01695517467299618ef63f1c0cc07", "html_url": "https://github.com/rust-lang/rust/commit/cfd76b364cd01695517467299618ef63f1c0cc07"}], "stats": {"total": 87, "additions": 46, "deletions": 41}, "files": [{"sha": "116e16d41c3094b0900ea763504c62711723ea70", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 46, "deletions": 40, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/38f76dbc386e9367bd6dc8f1fe48e4ddfeb7f653/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f76dbc386e9367bd6dc8f1fe48e4ddfeb7f653/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=38f76dbc386e9367bd6dc8f1fe48e4ddfeb7f653", "patch": "@@ -207,7 +207,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n                                                                       obligation.cause.span);\n                             if let Some(s) = custom_note {\n-                                infcx.tcx.sess.span_note(obligation.cause.span, &s);\n+                                infcx.tcx.sess.fileline_note(obligation.cause.span, &s);\n                             }\n                             note_obligation_cause(infcx, obligation);\n                         }\n@@ -305,29 +305,29 @@ pub fn report_object_safety_error<'tcx>(tcx: &ty::ctxt<'tcx>,\n     for violation in object_safety_violations(tcx, trait_def_id) {\n         match violation {\n             ObjectSafetyViolation::SizedSelf => {\n-                tcx.sess.span_note(\n+                tcx.sess.fileline_note(\n                     span,\n                     \"the trait cannot require that `Self : Sized`\");\n             }\n \n             ObjectSafetyViolation::SupertraitSelf => {\n-                tcx.sess.span_note(\n+                tcx.sess.fileline_note(\n                     span,\n                     \"the trait cannot use `Self` as a type parameter \\\n                      in the supertrait listing\");\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::StaticMethod) => {\n-                tcx.sess.span_note(\n+                tcx.sess.fileline_note(\n                     span,\n                     &format!(\"method `{}` has no receiver\",\n                              method.name));\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::ReferencesSelf) => {\n-                tcx.sess.span_note(\n+                tcx.sess.fileline_note(\n                     span,\n                     &format!(\"method `{}` references the `Self` type \\\n                               in its arguments or return type\",\n@@ -336,7 +336,7 @@ pub fn report_object_safety_error<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::Generic) => {\n-                tcx.sess.span_note(\n+                tcx.sess.fileline_note(\n                     span,\n                     &format!(\"method `{}` has generic type parameters\",\n                              method.name));\n@@ -458,111 +458,117 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n             note_obligation_cause_code(infcx, predicate, cause_span, subcode);\n         }\n         ObligationCauseCode::SliceOrArrayElem => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 &format!(\"slice and array elements must have `Sized` type\"));\n         }\n         ObligationCauseCode::ProjectionWf(data) => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 &format!(\"required so that the projection `{}` is well-formed\",\n                          data));\n         }\n         ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 &format!(\"required so that reference `{}` does not outlive its referent\",\n                          ref_ty));\n         }\n         ObligationCauseCode::ItemObligation(item_def_id) => {\n             let item_name = tcx.item_path_str(item_def_id);\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 &format!(\"required by `{}`\", item_name));\n         }\n         ObligationCauseCode::ObjectCastObligation(object_ty) => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 &format!(\n                     \"required for the cast to the object type `{}`\",\n                     infcx.ty_to_string(object_ty)));\n         }\n         ObligationCauseCode::RepeatVec => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 \"the `Copy` trait is required because the \\\n                  repeated element will be copied\");\n         }\n         ObligationCauseCode::VariableType(_) => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 \"all local variables must have a statically known size\");\n         }\n         ObligationCauseCode::ReturnType => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 \"the return type of a function must have a \\\n                  statically known size\");\n         }\n         ObligationCauseCode::AssignmentLhsSized => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 \"the left-hand-side of an assignment must have a statically known size\");\n         }\n         ObligationCauseCode::StructInitializerSized => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 \"structs must have a statically known size to be initialized\");\n         }\n-        ObligationCauseCode::ClosureCapture(var_id, closure_span, builtin_bound) => {\n+        ObligationCauseCode::ClosureCapture(var_id, _, builtin_bound) => {\n             let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n             let trait_name = tcx.item_path_str(def_id);\n             let name = tcx.local_var_name_str(var_id);\n-            span_note!(tcx.sess, closure_span,\n-                       \"the closure that captures `{}` requires that all captured variables \\\n-                       implement the trait `{}`\",\n-                       name,\n-                       trait_name);\n+            tcx.sess.fileline_note(\n+                cause_span,\n+                &format!(\"the closure that captures `{}` requires that all captured variables \\\n+                          implement the trait `{}`\",\n+                         name,\n+                         trait_name));\n         }\n         ObligationCauseCode::FieldSized => {\n-            span_note!(tcx.sess, cause_span,\n-                       \"only the last field of a struct or enum variant \\\n-                       may have a dynamically sized type\")\n+            tcx.sess.fileline_note(\n+                cause_span,\n+                \"only the last field of a struct or enum variant \\\n+                 may have a dynamically sized type\");\n         }\n         ObligationCauseCode::SharedStatic => {\n-            span_note!(tcx.sess, cause_span,\n-                       \"shared static variables must have a type that implements `Sync`\");\n+            tcx.sess.fileline_note(\n+                cause_span,\n+                \"shared static variables must have a type that implements `Sync`\");\n         }\n         ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            span_note!(tcx.sess, cause_span,\n-                       \"required because it appears within the type `{}`\",\n-                       parent_trait_ref.0.self_ty());\n+            tcx.sess.fileline_note(\n+                cause_span,\n+                &format!(\"required because it appears within the type `{}`\",\n+                         parent_trait_ref.0.self_ty()));\n             let parent_predicate = parent_trait_ref.to_predicate();\n             note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n         ObligationCauseCode::ImplDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            span_note!(tcx.sess, cause_span,\n-                       \"required because of the requirements on the impl of `{}` for `{}`\",\n-                       parent_trait_ref,\n-                       parent_trait_ref.0.self_ty());\n+            tcx.sess.fileline_note(\n+                cause_span,\n+                &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n+                         parent_trait_ref,\n+                         parent_trait_ref.0.self_ty()));\n             let parent_predicate = parent_trait_ref.to_predicate();\n             note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n         ObligationCauseCode::CompareImplMethodObligation => {\n-            span_note!(tcx.sess, cause_span,\n-                      \"the requirement `{}` appears on the impl method \\\n-                      but not on the corresponding trait method\",\n-                      predicate);\n+            tcx.sess.fileline_note(\n+                cause_span,\n+                &format!(\"the requirement `{}` appears on the impl method \\\n+                          but not on the corresponding trait method\",\n+                         predicate));\n         }\n     }\n }\n \n-pub fn suggest_new_overflow_limit(tcx: &ty::ctxt, span: Span) {\n+fn suggest_new_overflow_limit(tcx: &ty::ctxt, span: Span) {\n     let current_limit = tcx.sess.recursion_limit.get();\n     let suggested_limit = current_limit * 2;\n-    tcx.sess.span_note(\n+    tcx.sess.fileline_note(\n         span,\n         &format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\","}, {"sha": "4852c89799b8fba210dece119f2e90177d2c3998", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38f76dbc386e9367bd6dc8f1fe48e4ddfeb7f653/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f76dbc386e9367bd6dc8f1fe48e4ddfeb7f653/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=38f76dbc386e9367bd6dc8f1fe48e4ddfeb7f653", "patch": "@@ -29,7 +29,6 @@ pub use self::error_reporting::report_fulfillment_errors;\n pub use self::error_reporting::report_overflow_error;\n pub use self::error_reporting::report_selection_error;\n pub use self::error_reporting::report_object_safety_error;\n-pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;"}]}