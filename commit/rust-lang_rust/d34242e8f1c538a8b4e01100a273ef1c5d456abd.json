{"sha": "d34242e8f1c538a8b4e01100a273ef1c5d456abd", "node_id": "C_kwDOAAsO6NoAKGQzNDI0MmU4ZjFjNTM4YThiNGUwMTEwMGEyNzNlZjFjNWQ0NTZhYmQ", "commit": {"author": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-08-01T00:15:15Z"}, "committer": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-08-18T02:53:22Z"}, "message": "fix various issues", "tree": {"sha": "68f0d51444df87c0c36f51de0128348aeaa6ca9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68f0d51444df87c0c36f51de0128348aeaa6ca9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d34242e8f1c538a8b4e01100a273ef1c5d456abd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d34242e8f1c538a8b4e01100a273ef1c5d456abd", "html_url": "https://github.com/rust-lang/rust/commit/d34242e8f1c538a8b4e01100a273ef1c5d456abd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d34242e8f1c538a8b4e01100a273ef1c5d456abd/comments", "author": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc", "html_url": "https://github.com/rust-lang/rust/commit/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc"}], "stats": {"total": 377, "additions": 306, "deletions": 71}, "files": [{"sha": "fcf92dfc9f93515ec8c503b4a081a40b10d9c879", "filename": "src/shims/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fos_str.rs?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -74,7 +74,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         'mir: 'a,\n     {\n         #[cfg(windows)]\n-        pub fn u16vec_to_osstring<'tcx, 'a>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n+        pub fn u16vec_to_osstring<'tcx>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n             Ok(OsString::from_wide(&u16_vec[..]))\n         }\n         #[cfg(not(windows))]"}, {"sha": "a5205487981139e46b82533d2498a2ef29b66e3c", "filename": "src/shims/tls.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -244,10 +244,13 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.eval_windows(\"thread_local_key\", \"p_thread_callback\")?.to_pointer(this)?;\n         let thread_callback = this.get_ptr_fn(thread_callback)?.as_instance()?;\n \n-        // Technically, the reason should be `DLL_PROCESS_DETACH` when the main thread exits but std ignores it.\n+        // FIXME: Technically, the reason should be `DLL_PROCESS_DETACH` when the main thread exits\n+        // but std treats both the same.\n         let reason = this.eval_windows(\"c\", \"DLL_THREAD_DETACH\")?;\n \n         // The signature of this function is `unsafe extern \"system\" fn(h: c::LPVOID, dwReason: c::DWORD, pv: c::LPVOID)`.\n+        // FIXME: `h` should be a handle to the current module and what `pv` should be is unknown\n+        // but both are ignored by std\n         this.call_function(\n             thread_callback,\n             Abi::System { unwind: false },"}, {"sha": "9365ec9a21f4da02dc9e3dd33c13e006f2705ad0", "filename": "src/shims/unix/thread.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fthread.rs?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -13,11 +13,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n+        let thread_info_place = this.deref_operand(thread)?;\n+\n+        let start_routine = this.read_pointer(start_routine)?;\n+\n+        let func_arg = this.read_immediate(arg)?;\n+\n         this.start_thread(\n-            Some(thread),\n+            Some(thread_info_place),\n             start_routine,\n             Abi::C { unwind: false },\n-            arg,\n+            func_arg,\n             this.layout_of(this.tcx.types.usize)?,\n         )?;\n \n@@ -46,7 +52,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let thread_id = this.read_scalar(thread)?.to_machine_usize(this)?;\n-        this.detach_thread(thread_id.try_into().expect(\"thread ID should fit in u32\"), false)?;\n+        this.detach_thread(\n+            thread_id.try_into().expect(\"thread ID should fit in u32\"),\n+            /*allow_terminated_joined*/ false,\n+        )?;\n \n         Ok(0)\n     }"}, {"sha": "4c5e7a9b3138710c478747963aa59d3ae59c4e9d", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -122,7 +122,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     _ => this.invalid_handle(\"SetThreadDescription\")?,\n                 };\n \n-                this.set_thread_name_wide(thread, name);\n+                this.set_thread_name_wide(thread, &name);\n \n                 this.write_null(dest)?;\n             }"}, {"sha": "d853f3084d492fa0ade34f9d32f1f7f224432830", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -323,22 +323,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // FIXME: we should set last_error, but to what?\n                 this.write_null(dest)?;\n             }\n-            // this is only callable from std because we know that std ignores the return value\n-            \"SwitchToThread\" if this.frame_in_std() => {\n-                let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-\n-                this.yield_active_thread();\n-\n-                // FIXME: this should return a nonzero value if this call does result in switching to another thread.\n-                this.write_null(dest)?;\n-            }\n             \"GetStdHandle\" => {\n                 let [which] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let which = this.read_scalar(which)?.to_i32()?;\n                 // We just make this the identity function, so we know later in `NtWriteFile` which\n                 // one it is. This is very fake, but libtest needs it so we cannot make it a\n                 // std-only shim.\n+                // FIXME: this should return real HANDLEs when io support is added\n                 this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n             }\n             \"CloseHandle\" => {\n@@ -364,9 +356,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let [handle, timeout] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n \n-                this.WaitForSingleObject(handle, timeout)?;\n-\n-                this.write_scalar(Scalar::from_u32(0), dest)?;\n+                let ret = this.WaitForSingleObject(handle, timeout)?;\n+                this.write_scalar(Scalar::from_u32(ret), dest)?;\n             }\n             \"GetCurrentThread\" => {\n                 let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n@@ -382,6 +373,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"GetProcessHeap\" if this.frame_in_std() => {\n                 let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Just fake a HANDLE\n+                // It's fine to not use the Handle type here because its a stub\n                 this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n             }\n             \"GetModuleHandleA\" if this.frame_in_std() => {\n@@ -417,6 +409,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let result = this.GetCurrentProcessId()?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n+            // this is only callable from std because we know that std ignores the return value\n+            \"SwitchToThread\" if this.frame_in_std() => {\n+                let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.yield_active_thread();\n+\n+                // FIXME: this should return a nonzero value if this call does result in switching to another thread.\n+                this.write_null(dest)?;\n+            }\n \n             _ => return Ok(EmulateByNameResult::NotSupported),\n         }"}, {"sha": "443af1dfeaaa467b1904bd49a794335d2c65c774", "filename": "src/shims/windows/handle.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fshims%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fshims%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fhandle.rs?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -8,6 +8,14 @@ pub enum PseudoHandle {\n     CurrentThread,\n }\n \n+/// Miri representation of a Windows `HANDLE`\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum Handle {\n+    Null,\n+    Pseudo(PseudoHandle),\n+    Thread(ThreadId),\n+}\n+\n impl PseudoHandle {\n     const CURRENT_THREAD_VALUE: u32 = 0;\n \n@@ -25,14 +33,6 @@ impl PseudoHandle {\n     }\n }\n \n-/// Miri representation of a Windows `HANDLE`\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum Handle {\n-    Null,\n-    Pseudo(PseudoHandle),\n-    Thread(ThreadId),\n-}\n-\n impl Handle {\n     const NULL_DISCRIMINANT: u32 = 0;\n     const PSEUDO_DISCRIMINANT: u32 = 1;\n@@ -62,9 +62,7 @@ impl Handle {\n         let floor_log2 = variant_count.ilog2();\n \n         // we need to add one for non powers of two to compensate for the difference\n-        let ceil_log2 = if variant_count.is_power_of_two() { floor_log2 } else { floor_log2 + 1 };\n-\n-        ceil_log2\n+        if variant_count.is_power_of_two() { floor_log2 } else { floor_log2 + 1 }\n     }\n \n     /// Converts a handle into its machine representation.\n@@ -120,6 +118,7 @@ impl Handle {\n     pub fn to_scalar(self, cx: &impl HasDataLayout) -> Scalar<Provenance> {\n         // 64-bit handles are sign extended 32-bit handles\n         // see https://docs.microsoft.com/en-us/windows/win32/winprog64/interprocess-communication\n+        #[allow(clippy::cast_possible_wrap)] // we want it to wrap\n         let signed_handle = self.to_packed() as i32;\n         Scalar::from_machine_isize(signed_handle.into(), cx)\n     }\n@@ -130,6 +129,7 @@ impl Handle {\n     ) -> InterpResult<'tcx, Option<Self>> {\n         let sign_extended_handle = handle.to_machine_isize(cx)?;\n \n+        #[allow(clippy::cast_sign_loss)] // we want to lose the sign\n         let handle = if let Ok(signed_handle) = i32::try_from(sign_extended_handle) {\n             signed_handle as u32\n         } else {\n@@ -154,8 +154,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn CloseHandle(&mut self, handle_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        match Handle::from_scalar(this.read_scalar(handle_op)?.check_init()?, this)? {\n-            Some(Handle::Thread(thread)) => this.detach_thread(thread, true)?,\n+        let handle = this.read_scalar(handle_op)?.check_init()?;\n+\n+        match Handle::from_scalar(handle, this)? {\n+            Some(Handle::Thread(thread)) =>\n+                this.detach_thread(thread, /*allow_terminated_joined*/ true)?,\n             _ => this.invalid_handle(\"CloseHandle\")?,\n         }\n "}, {"sha": "06a5887d3e50920d94056831cd60df96c4ca89e9", "filename": "src/shims/windows/thread.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fshims%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fshims%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fthread.rs?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -19,55 +19,71 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, ThreadId> {\n         let this = self.eval_context_mut();\n \n-        if !this.ptr_is_null(this.read_pointer(security_op)?)? {\n-            throw_unsup_format!(\"non-null `lpThreadAttributes` in `CreateThread`\")\n-        }\n+        let security = this.read_pointer(security_op)?;\n \n         // stacksize is ignored, but still needs to be a valid usize\n-        let _ = this.read_scalar(stacksize_op)?.to_machine_usize(this)?;\n+        this.read_scalar(stacksize_op)?.to_machine_usize(this)?;\n+\n+        let start_routine = this.read_pointer(start_op)?;\n+\n+        let func_arg = this.read_immediate(arg_op)?;\n \n         let flags = this.read_scalar(flags_op)?.to_u32()?;\n \n+        let thread = if this.ptr_is_null(this.read_pointer(thread_op)?)? {\n+            None\n+        } else {\n+            let thread_info_place = this.deref_operand(thread_op)?;\n+            Some(thread_info_place)\n+        };\n+\n         let stack_size_param_is_a_reservation =\n             this.eval_windows(\"c\", \"STACK_SIZE_PARAM_IS_A_RESERVATION\")?.to_u32()?;\n \n+        // We ignore the stack size, so we also ignore the\n+        // `STACK_SIZE_PARAM_IS_A_RESERVATION` flag.\n         if flags != 0 && flags != stack_size_param_is_a_reservation {\n             throw_unsup_format!(\"unsupported `dwCreationFlags` {} in `CreateThread`\", flags)\n         }\n \n-        let thread =\n-            if this.ptr_is_null(this.read_pointer(thread_op)?)? { None } else { Some(thread_op) };\n+        if !this.ptr_is_null(security)? {\n+            throw_unsup_format!(\"non-null `lpThreadAttributes` in `CreateThread`\")\n+        }\n \n         this.start_thread(\n             thread,\n-            start_op,\n+            start_routine,\n             Abi::System { unwind: false },\n-            arg_op,\n+            func_arg,\n             this.layout_of(this.tcx.types.u32)?,\n         )\n     }\n \n     fn WaitForSingleObject(\n         &mut self,\n-        handle: &OpTy<'tcx, Provenance>,\n-        timeout: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx> {\n+        handle_op: &OpTy<'tcx, Provenance>,\n+        timeout_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, u32> {\n         let this = self.eval_context_mut();\n \n-        let thread = match Handle::from_scalar(this.read_scalar(handle)?.check_init()?, this)? {\n+        let handle = this.read_scalar(handle_op)?.check_init()?;\n+\n+        let timeout = this.read_scalar(timeout_op)?.to_u32()?;\n+\n+        let thread = match Handle::from_scalar(handle, this)? {\n             Some(Handle::Thread(thread)) => thread,\n-            // Unlike on posix, joining the current thread is not UB on windows.\n-            // It will just deadlock.\n+            // Unlike on posix, the outcome of joining the current thread is not documented.\n+            // On current Windows, it just deadlocks.\n             Some(Handle::Pseudo(PseudoHandle::CurrentThread)) => this.get_active_thread(),\n             _ => this.invalid_handle(\"WaitForSingleObject\")?,\n         };\n \n-        if this.read_scalar(timeout)?.to_u32()? != this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+        if timeout != this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n             throw_unsup_format!(\"`WaitForSingleObject` with non-infinite timeout\");\n         }\n \n         this.join_thread(thread)?;\n \n-        Ok(())\n+        Ok(0)\n     }\n }"}, {"sha": "b92728be208744300d6140eca3332d8541c29ecd", "filename": "src/thread.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -181,7 +181,7 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n }\n \n /// A specific moment in time.\n-#[derive(Debug, Copy, Clone)]\n+#[derive(Debug)]\n pub enum Time {\n     Monotonic(Instant),\n     RealTime(SystemTime),\n@@ -357,16 +357,19 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     ///\n     /// `allow_terminated_joined` allows detaching joined threads that have already terminated.\n     /// This matches Windows's behavior for `CloseHandle`.\n+    ///\n+    /// See <https://docs.microsoft.com/en-us/windows/win32/procthread/thread-handles-and-identifiers>:\n+    /// > The handle is valid until closed, even after the thread it represents has been terminated.\n     fn detach_thread(&mut self, id: ThreadId, allow_terminated_joined: bool) -> InterpResult<'tcx> {\n         trace!(\"detaching {:?}\", id);\n \n         let is_ub = if allow_terminated_joined && self.threads[id].state == ThreadState::Terminated\n         {\n+            // \"Detached\" in particular means \"not yet joined\". Redundant detaching is still UB.\n             self.threads[id].join_status == ThreadJoinStatus::Detached\n         } else {\n             self.threads[id].join_status != ThreadJoinStatus::Joinable\n         };\n-\n         if is_ub {\n             throw_ub_format!(\"trying to detach thread that was already detached or joined\");\n         }\n@@ -406,7 +409,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Mark that the active thread tries to exclusively join the thread with `joined_thread_id`.\n-    /// If the thread is already joined by another thread\n+    /// If the thread is already joined by another thread, it will throw UB\n     fn join_thread_exclusive(\n         &mut self,\n         joined_thread_id: ThreadId,\n@@ -424,7 +427,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             self.threads\n                 .iter()\n                 .all(|thread| thread.state != ThreadState::BlockedOnJoin(joined_thread_id)),\n-            \"a joinable thread already has threads waiting for its termination\"\n+            \"this thread already has threads waiting for its termination\"\n         );\n \n         self.join_thread(joined_thread_id, data_race)\n@@ -803,12 +806,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    fn set_thread_name_wide(&mut self, thread: ThreadId, new_thread_name: Vec<u16>) {\n+    fn set_thread_name_wide(&mut self, thread: ThreadId, new_thread_name: &[u16]) {\n         let this = self.eval_context_mut();\n-        this.machine.threads.set_thread_name(\n-            thread,\n-            new_thread_name.into_iter().flat_map(u16::to_ne_bytes).collect(),\n-        );\n+\n+        // The Windows `GetThreadDescription` shim to get the thread name isn't implemented, so being lossy is okay.\n+        // This is only read by diagnostics, which already use `from_utf8_lossy`.\n+        this.machine\n+            .threads\n+            .set_thread_name(thread, String::from_utf16_lossy(new_thread_name).into_bytes());\n     }\n \n     #[inline]"}, {"sha": "92b693c0fd6bf73171fb3a859a8f7ad39a7c87e8", "filename": "tests/fail/concurrency/libc_pthread_join_detached.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: trying to join a detached or already joined thread\n+error: Undefined Behavior: trying to join a detached thread\n   --> $DIR/libc_pthread_join_detached.rs:LL:CC\n    |\n-LL | ...   assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached thread\n+LL |         assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached thread\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "04ca4bbb3f6110db7b46644122a4be387fcd3ac1", "filename": "tests/fail/concurrency/libc_pthread_join_joined.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.rs?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -15,6 +15,6 @@ fn main() {\n         // assert_eq!(libc::pthread_attr_init(&mut attr), 0); FIXME: this function is not yet implemented.\n         assert_eq!(libc::pthread_create(&mut native, &attr, thread_start, ptr::null_mut()), 0);\n         assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n-        assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join a detached or already joined thread\n+        assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join an already joined thread\n     }\n }"}, {"sha": "f11b94cde8ee60613dee2491bd78de34633d7fc1", "filename": "tests/fail/concurrency/libc_pthread_join_joined.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: trying to join a detached or already joined thread\n+error: Undefined Behavior: trying to join an already joined thread\n   --> $DIR/libc_pthread_join_joined.rs:LL:CC\n    |\n-LL | ...   assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached or already joined thread\n+LL |         assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join an already joined thread\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "7576518216372370550127d3dbc1385964180851", "filename": "tests/fail/concurrency/libc_pthread_join_main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.rs?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -8,7 +8,7 @@ fn main() {\n     let thread_id: libc::pthread_t = unsafe { libc::pthread_self() };\n     let handle = thread::spawn(move || {\n         unsafe {\n-            assert_eq!(libc::pthread_join(thread_id, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join a detached or already joined thread\n+            assert_eq!(libc::pthread_join(thread_id, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join a detached thread\n         }\n     });\n     thread::yield_now();"}, {"sha": "c162f37b309f7109e0a660e30c749e5e854608b9", "filename": "tests/fail/concurrency/libc_pthread_join_main.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: trying to join a detached or already joined thread\n+error: Undefined Behavior: trying to join a detached thread\n   --> $DIR/libc_pthread_join_main.rs:LL:CC\n    |\n-LL | ...   assert_eq!(libc::pthread_join(thread_id, ptr::null_mut()), 0);\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached or already joined thread\n+LL |             assert_eq!(libc::pthread_join(thread_id, ptr::null_mut()), 0);\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached thread\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "966f416eeac7e5b8782446c41347b1c2b19503bb", "filename": "tests/fail/concurrency/libc_pthread_join_multiple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.rs?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -21,7 +21,7 @@ fn main() {\n         let mut native_copy: libc::pthread_t = mem::zeroed();\n         ptr::copy_nonoverlapping(&native, &mut native_copy, 1);\n         let handle = thread::spawn(move || {\n-            assert_eq!(libc::pthread_join(native_copy, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join a detached or already joined thread\n+            assert_eq!(libc::pthread_join(native_copy, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join an already joined thread\n         });\n         assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n         handle.join().unwrap();"}, {"sha": "c0c73086f14d60f93295fae70c2862dee96193f5", "filename": "tests/fail/concurrency/libc_pthread_join_multiple.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: trying to join a detached or already joined thread\n+error: Undefined Behavior: trying to join an already joined thread\n   --> $DIR/libc_pthread_join_multiple.rs:LL:CC\n    |\n LL | ...   assert_eq!(libc::pthread_join(native_copy, ptr::null_mut()), 0);\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached or already joined thread\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join an already joined thread\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "cde6d19ef25bb73813f1ea30238e484287423854", "filename": "tests/fail/concurrency/windows_join_main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -12,7 +12,7 @@ extern \"system\" {\n \n const INFINITE: u32 = u32::MAX;\n \n-// This is how miri represents the handle for thread 0.\n+// XXX HACK: This is how miri represents the handle for thread 0.\n // This value can be \"legitimately\" obtained by using `GetCurrentThread` with `DuplicateHandle`\n // but miri does not implement `DuplicateHandle` yet.\n const MAIN_THREAD: isize = (2i32 << 30) as isize;"}, {"sha": "3fd6e2d6f2426396a210f39b257adb40fd6c8911", "filename": "tests/pass/concurrency/tls_lib_drop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -1,3 +1,5 @@\n+//@ignore-target-windows: TLS destructor order is different on Windows.\n+\n use std::cell::RefCell;\n use std::thread;\n "}, {"sha": "e8c6538e701d3bb0feab1ffa46ece63ec1bf355c", "filename": "tests/pass/concurrency/tls_lib_drop_windows.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.rs?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -0,0 +1,191 @@\n+//@only-target-windows: TLS destructor order is different on Windows.\n+\n+use std::cell::RefCell;\n+use std::thread;\n+\n+struct TestCell {\n+    value: RefCell<u8>,\n+}\n+\n+impl Drop for TestCell {\n+    fn drop(&mut self) {\n+        for _ in 0..10 {\n+            thread::yield_now();\n+        }\n+        println!(\"Dropping: {} (should be before 'Continue main 1').\", *self.value.borrow())\n+    }\n+}\n+\n+thread_local! {\n+    static A: TestCell = TestCell { value: RefCell::new(0) };\n+    static A_CONST: TestCell = const { TestCell { value: RefCell::new(10) } };\n+}\n+\n+/// Check that destructors of the library thread locals are executed immediately\n+/// after a thread terminates.\n+fn check_destructors() {\n+    thread::spawn(|| {\n+        A.with(|f| {\n+            assert_eq!(*f.value.borrow(), 0);\n+            *f.value.borrow_mut() = 5;\n+        });\n+        A_CONST.with(|f| {\n+            assert_eq!(*f.value.borrow(), 10);\n+            *f.value.borrow_mut() = 15;\n+        });\n+    })\n+    .join()\n+    .unwrap();\n+    println!(\"Continue main 1.\")\n+}\n+\n+struct JoinCell {\n+    value: RefCell<Option<thread::JoinHandle<u8>>>,\n+}\n+\n+impl Drop for JoinCell {\n+    fn drop(&mut self) {\n+        for _ in 0..10 {\n+            thread::yield_now();\n+        }\n+        let join_handle = self.value.borrow_mut().take().unwrap();\n+        println!(\"Joining: {} (should be before 'Continue main 2').\", join_handle.join().unwrap());\n+    }\n+}\n+\n+thread_local! {\n+    static B: JoinCell = JoinCell { value: RefCell::new(None) };\n+}\n+\n+/// Check that the destructor can be blocked joining another thread.\n+fn check_blocking() {\n+    thread::spawn(|| {\n+        B.with(|f| {\n+            assert!(f.value.borrow().is_none());\n+            let handle = thread::spawn(|| 7);\n+            *f.value.borrow_mut() = Some(handle);\n+        });\n+    })\n+    .join()\n+    .unwrap();\n+    println!(\"Continue main 2.\");\n+    // Preempt the main thread so that the destructor gets executed and can join\n+    // the thread.\n+    thread::yield_now();\n+    thread::yield_now();\n+}\n+\n+// This test tests that TLS destructors have run before the thread joins. The\n+// test has no false positives (meaning: if the test fails, there's actually\n+// an ordering problem). It may have false negatives, where the test passes but\n+// join is not guaranteed to be after the TLS destructors. However, false\n+// negatives should be exceedingly rare due to judicious use of\n+// thread::yield_now and running the test several times.\n+fn join_orders_after_tls_destructors() {\n+    use std::sync::atomic::{AtomicU8, Ordering};\n+\n+    // We emulate a synchronous MPSC rendezvous channel using only atomics and\n+    // thread::yield_now. We can't use std::mpsc as the implementation itself\n+    // may rely on thread locals.\n+    //\n+    // The basic state machine for an SPSC rendezvous channel is:\n+    //           FRESH -> THREAD1_WAITING -> MAIN_THREAD_RENDEZVOUS\n+    // where the first transition is done by the \u201creceiving\u201d thread and the 2nd\n+    // transition is done by the \u201csending\u201d thread.\n+    //\n+    // We add an additional state `THREAD2_LAUNCHED` between `FRESH` and\n+    // `THREAD1_WAITING` to block until all threads are actually running.\n+    //\n+    // A thread that joins on the \u201creceiving\u201d thread completion should never\n+    // observe the channel in the `THREAD1_WAITING` state. If this does occur,\n+    // we switch to the \u201cpoison\u201d state `THREAD2_JOINED` and panic all around.\n+    // (This is equivalent to \u201csending\u201d from an alternate producer thread.)\n+    const FRESH: u8 = 0;\n+    const THREAD2_LAUNCHED: u8 = 1;\n+    const THREAD1_WAITING: u8 = 2;\n+    const MAIN_THREAD_RENDEZVOUS: u8 = 3;\n+    const THREAD2_JOINED: u8 = 4;\n+    static SYNC_STATE: AtomicU8 = AtomicU8::new(FRESH);\n+\n+    for _ in 0..10 {\n+        SYNC_STATE.store(FRESH, Ordering::SeqCst);\n+\n+        let jh = thread::Builder::new()\n+            .name(\"thread1\".into())\n+            .spawn(move || {\n+                struct TlDrop;\n+\n+                impl Drop for TlDrop {\n+                    fn drop(&mut self) {\n+                        let mut sync_state = SYNC_STATE.swap(THREAD1_WAITING, Ordering::SeqCst);\n+                        loop {\n+                            match sync_state {\n+                                THREAD2_LAUNCHED | THREAD1_WAITING => thread::yield_now(),\n+                                MAIN_THREAD_RENDEZVOUS => break,\n+                                THREAD2_JOINED =>\n+                                    panic!(\n+                                        \"Thread 1 still running after thread 2 joined on thread 1\"\n+                                    ),\n+                                v => unreachable!(\"sync state: {}\", v),\n+                            }\n+                            sync_state = SYNC_STATE.load(Ordering::SeqCst);\n+                        }\n+                    }\n+                }\n+\n+                thread_local! {\n+                    static TL_DROP: TlDrop = TlDrop;\n+                }\n+\n+                TL_DROP.with(|_| {});\n+\n+                loop {\n+                    match SYNC_STATE.load(Ordering::SeqCst) {\n+                        FRESH => thread::yield_now(),\n+                        THREAD2_LAUNCHED => break,\n+                        v => unreachable!(\"sync state: {}\", v),\n+                    }\n+                }\n+            })\n+            .unwrap();\n+\n+        let jh2 = thread::Builder::new()\n+            .name(\"thread2\".into())\n+            .spawn(move || {\n+                assert_eq!(SYNC_STATE.swap(THREAD2_LAUNCHED, Ordering::SeqCst), FRESH);\n+                jh.join().unwrap();\n+                match SYNC_STATE.swap(THREAD2_JOINED, Ordering::SeqCst) {\n+                    MAIN_THREAD_RENDEZVOUS => return,\n+                    THREAD2_LAUNCHED | THREAD1_WAITING => {\n+                        panic!(\"Thread 2 running after thread 1 join before main thread rendezvous\")\n+                    }\n+                    v => unreachable!(\"sync state: {:?}\", v),\n+                }\n+            })\n+            .unwrap();\n+\n+        loop {\n+            match SYNC_STATE.compare_exchange(\n+                THREAD1_WAITING,\n+                MAIN_THREAD_RENDEZVOUS,\n+                Ordering::SeqCst,\n+                Ordering::SeqCst,\n+            ) {\n+                Ok(_) => break,\n+                Err(FRESH) => thread::yield_now(),\n+                Err(THREAD2_LAUNCHED) => thread::yield_now(),\n+                Err(THREAD2_JOINED) => {\n+                    panic!(\"Main thread rendezvous after thread 2 joined thread 1\")\n+                }\n+                v => unreachable!(\"sync state: {:?}\", v),\n+            }\n+        }\n+        jh2.join().unwrap();\n+    }\n+}\n+\n+fn main() {\n+    check_destructors();\n+    check_blocking();\n+    join_orders_after_tls_destructors();\n+}"}, {"sha": "e5b8efcaf5fac8efe605d242be67dbd4d27995d9", "filename": "tests/pass/concurrency/tls_lib_drop_windows.stdout", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d34242e8f1c538a8b4e01100a273ef1c5d456abd/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.stdout?ref=d34242e8f1c538a8b4e01100a273ef1c5d456abd", "patch": "@@ -0,0 +1,5 @@\n+Dropping: 15 (should be before 'Continue main 1').\n+Dropping: 5 (should be before 'Continue main 1').\n+Continue main 1.\n+Joining: 7 (should be before 'Continue main 2').\n+Continue main 2."}]}