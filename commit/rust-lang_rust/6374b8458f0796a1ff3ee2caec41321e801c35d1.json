{"sha": "6374b8458f0796a1ff3ee2caec41321e801c35d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNzRiODQ1OGYwNzk2YTFmZjNlZTJjYWVjNDEzMjFlODAxYzM1ZDE=", "commit": {"author": {"name": "newpavlov", "email": "newpavlov@gmail.com", "date": "2019-08-29T17:13:15Z"}, "committer": {"name": "newpavlov", "email": "newpavlov@gmail.com", "date": "2019-08-29T17:13:15Z"}, "message": "update to wasi v0.7", "tree": {"sha": "dacefebb03498b2e44747c067d58393ca51fae1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dacefebb03498b2e44747c067d58393ca51fae1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6374b8458f0796a1ff3ee2caec41321e801c35d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6374b8458f0796a1ff3ee2caec41321e801c35d1", "html_url": "https://github.com/rust-lang/rust/commit/6374b8458f0796a1ff3ee2caec41321e801c35d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6374b8458f0796a1ff3ee2caec41321e801c35d1/comments", "author": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37721461d47d3840adc6d931b848a9db8e66ceaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/37721461d47d3840adc6d931b848a9db8e66ceaa", "html_url": "https://github.com/rust-lang/rust/commit/37721461d47d3840adc6d931b848a9db8e66ceaa"}], "stats": {"total": 133, "additions": 80, "deletions": 53}, "files": [{"sha": "3719b36236797599795a65646e6f4515c0a1bc49", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6374b8458f0796a1ff3ee2caec41321e801c35d1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6374b8458f0796a1ff3ee2caec41321e801c35d1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6374b8458f0796a1ff3ee2caec41321e801c35d1", "patch": "@@ -3866,6 +3866,7 @@ dependencies = [\n  \"rustc_msan\",\n  \"rustc_tsan\",\n  \"unwind\",\n+ \"wasi\",\n ]\n \n [[package]]\n@@ -4664,6 +4665,17 @@ dependencies = [\n  \"try-lock\",\n ]\n \n+[[package]]\n+name = \"wasi\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b89c3ce4ce14bdc6fb6beaf9ec7928ca331de5df7e5ea278375642a2f478570d\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"winapi\"\n version = \"0.2.8\""}, {"sha": "0d04b7a27403775aa52a200f15da654d27f52909", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6374b8458f0796a1ff3ee2caec41321e801c35d1/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6374b8458f0796a1ff3ee2caec41321e801c35d1/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=6374b8458f0796a1ff3ee2caec41321e801c35d1", "patch": "@@ -24,7 +24,7 @@ compiler_builtins = { version = \"0.1.16\" }\n profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n unwind = { path = \"../libunwind\" }\n hashbrown = { version = \"0.5.0\", features = ['rustc-dep-of-std'] }\n-wasi = { git = \"https://github.com/newpavlov/rust-wasi\", branch = \"safe_rework\", features = ['rustc-dep-of-std', 'alloc'] }\n+wasi = { version = \"0.7.0\", features = ['rustc-dep-of-std', 'alloc'] }\n \n [dependencies.backtrace]\n version = \"0.3.35\""}, {"sha": "5b7a8678b66eab724465219e46c4dd1f830acd10", "filename": "src/libstd/sys/wasi/fd.rs", "status": "modified", "additions": 56, "deletions": 48, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/6374b8458f0796a1ff3ee2caec41321e801c35d1/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6374b8458f0796a1ff3ee2caec41321e801c35d1/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs?ref=6374b8458f0796a1ff3ee2caec41321e801c35d1", "patch": "@@ -53,23 +53,23 @@ impl WasiFd {\n     }\n \n     pub fn datasync(&self) -> io::Result<()> {\n-        wasi::fd_datasync(self.fd).map_err(err2io)\n+        unsafe { wasi::fd_datasync(self.fd).map_err(err2io) }\n     }\n \n     pub fn pread(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n-        wasi::fd_pread(self.fd, iovec(bufs), offset).map_err(err2io)\n+        unsafe { wasi::fd_pread(self.fd, iovec(bufs), offset).map_err(err2io) }\n     }\n \n     pub fn pwrite(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n-        wasi::fd_pwrite(self.fd, ciovec(bufs), offset).map_err(err2io)\n+        unsafe { wasi::fd_pwrite(self.fd, ciovec(bufs), offset).map_err(err2io) }\n     }\n \n     pub fn read(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        wasi::fd_read(self.fd, iovec(bufs)).map_err(err2io)\n+        unsafe { wasi::fd_read(self.fd, iovec(bufs)).map_err(err2io) }\n     }\n \n     pub fn write(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        wasi::fd_write(self.fd, ciovec(bufs)).map_err(err2io)\n+        unsafe { wasi::fd_write(self.fd, ciovec(bufs)).map_err(err2io) }\n     }\n \n     pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n@@ -78,37 +78,37 @@ impl WasiFd {\n             SeekFrom::End(pos) => (wasi::WHENCE_END, pos),\n             SeekFrom::Current(pos) => (wasi::WHENCE_CUR, pos),\n         };\n-        wasi::fd_seek(self.fd, offset, whence).map_err(err2io)\n+        unsafe { wasi::fd_seek(self.fd, offset, whence).map_err(err2io) }\n     }\n \n     pub fn tell(&self) -> io::Result<u64> {\n-        wasi::fd_tell(self.fd).map_err(err2io)\n+        unsafe { wasi::fd_tell(self.fd).map_err(err2io) }\n     }\n \n     // FIXME: __wasi_fd_fdstat_get\n \n     pub fn set_flags(&self, flags: wasi::FdFlags) -> io::Result<()> {\n-        wasi::fd_fdstat_set_flags(self.fd, flags).map_err(err2io)\n+        unsafe { wasi::fd_fdstat_set_flags(self.fd, flags).map_err(err2io) }\n     }\n \n     pub fn set_rights(&self, base: wasi::Rights, inheriting: wasi::Rights) -> io::Result<()> {\n-        wasi::fd_fdstat_set_rights(self.fd, base, inheriting).map_err(err2io)\n+        unsafe { wasi::fd_fdstat_set_rights(self.fd, base, inheriting).map_err(err2io) }\n     }\n \n     pub fn sync(&self) -> io::Result<()> {\n-        wasi::fd_sync(self.fd).map_err(err2io)\n+        unsafe { wasi::fd_sync(self.fd).map_err(err2io) }\n     }\n \n     pub fn advise(&self, offset: u64, len: u64, advice: wasi::Advice) -> io::Result<()> {\n-        wasi::fd_advise(self.fd, offset, len, advice).map_err(err2io)\n+        unsafe { wasi::fd_advise(self.fd, offset, len, advice).map_err(err2io) }\n     }\n \n     pub fn allocate(&self, offset: u64, len: u64) -> io::Result<()> {\n-        wasi::fd_allocate(self.fd, offset, len).map_err(err2io)\n+        unsafe { wasi::fd_allocate(self.fd, offset, len).map_err(err2io) }\n     }\n \n     pub fn create_directory(&self, path: &[u8]) -> io::Result<()> {\n-        wasi::path_create_directory(self.fd, path).map_err(err2io)\n+        unsafe { wasi::path_create_directory(self.fd, path).map_err(err2io) }\n     }\n \n     pub fn link(\n@@ -118,8 +118,10 @@ impl WasiFd {\n         new_fd: &WasiFd,\n         new_path: &[u8],\n     ) -> io::Result<()> {\n-        wasi::path_link(self.fd, old_flags, old_path, new_fd.fd, new_path)\n-            .map_err(err2io)\n+        unsafe {\n+            wasi::path_link(self.fd, old_flags, old_path, new_fd.fd, new_path)\n+                .map_err(err2io)\n+        }\n     }\n \n     pub fn open(\n@@ -131,32 +133,35 @@ impl WasiFd {\n         fs_rights_inheriting: wasi::Rights,\n         fs_flags: wasi::FdFlags,\n     ) -> io::Result<WasiFd> {\n-        wasi::path_open(\n-            self.fd,\n-            dirflags,\n-            path,\n-            oflags,\n-            fs_rights_base,\n-            fs_rights_inheriting,\n-            fs_flags,\n-        ).map(|fd| unsafe { WasiFd::from_raw(fd) }).map_err(err2io)\n+        unsafe {\n+            wasi::path_open(\n+                self.fd,\n+                dirflags,\n+                path,\n+                oflags,\n+                fs_rights_base,\n+                fs_rights_inheriting,\n+                fs_flags,\n+            ).map(|fd| WasiFd::from_raw(fd)).map_err(err2io)\n+        }\n     }\n \n     pub fn readdir(&self, buf: &mut [u8], cookie: wasi::DirCookie) -> io::Result<usize> {\n-        wasi::fd_readdir(self.fd, buf, cookie).map_err(err2io)\n+        unsafe { wasi::fd_readdir(self.fd, buf, cookie).map_err(err2io) }\n     }\n \n     pub fn readlink(&self, path: &[u8], buf: &mut [u8]) -> io::Result<usize> {\n-        wasi::path_readlink(self.fd, path, buf).map_err(err2io)\n+        unsafe { wasi::path_readlink(self.fd, path, buf).map_err(err2io) }\n     }\n \n     pub fn rename(&self, old_path: &[u8], new_fd: &WasiFd, new_path: &[u8]) -> io::Result<()> {\n-        wasi::path_rename(self.fd, old_path, new_fd.fd, new_path)\n-            .map_err(err2io)\n+        unsafe {\n+            wasi::path_rename(self.fd, old_path, new_fd.fd, new_path).map_err(err2io)\n+        }\n     }\n \n     pub fn filestat_get(&self) -> io::Result<wasi::FileStat> {\n-        wasi::fd_filestat_get(self.fd).map_err(err2io)\n+        unsafe { wasi::fd_filestat_get(self.fd).map_err(err2io) }\n     }\n \n     pub fn filestat_set_times(\n@@ -165,20 +170,21 @@ impl WasiFd {\n         mtim: wasi::Timestamp,\n         fstflags: wasi::FstFlags,\n     ) -> io::Result<()> {\n-        wasi::fd_filestat_set_times(self.fd, atim, mtim, fstflags)\n-            .map_err(err2io)\n+        unsafe {\n+            wasi::fd_filestat_set_times(self.fd, atim, mtim, fstflags).map_err(err2io)\n+        }\n     }\n \n     pub fn filestat_set_size(&self, size: u64) -> io::Result<()> {\n-        wasi::fd_filestat_set_size(self.fd, size).map_err(err2io)\n+        unsafe { wasi::fd_filestat_set_size(self.fd, size).map_err(err2io) }\n     }\n \n     pub fn path_filestat_get(\n         &self,\n         flags: wasi::LookupFlags,\n         path: &[u8],\n     ) -> io::Result<wasi::FileStat> {\n-        wasi::path_filestat_get(self.fd, flags, path).map_err(err2io)\n+        unsafe { wasi::path_filestat_get(self.fd, flags, path).map_err(err2io) }\n     }\n \n     pub fn path_filestat_set_times(\n@@ -189,38 +195,40 @@ impl WasiFd {\n         mtim: wasi::Timestamp,\n         fstflags: wasi::FstFlags,\n     ) -> io::Result<()> {\n-        wasi::path_filestat_set_times(\n-            self.fd,\n-            flags,\n-            path,\n-            atim,\n-            mtim,\n-            fstflags,\n-        ).map_err(err2io)\n+        unsafe {\n+            wasi::path_filestat_set_times(\n+                self.fd,\n+                flags,\n+                path,\n+                atim,\n+                mtim,\n+                fstflags,\n+            ).map_err(err2io)\n+        }\n     }\n \n     pub fn symlink(&self, old_path: &[u8], new_path: &[u8]) -> io::Result<()> {\n-        wasi::path_symlink(old_path, self.fd, new_path).map_err(err2io)\n+        unsafe { wasi::path_symlink(old_path, self.fd, new_path).map_err(err2io) }\n     }\n \n     pub fn unlink_file(&self, path: &[u8]) -> io::Result<()> {\n-        wasi::path_unlink_file(self.fd, path).map_err(err2io)\n+        unsafe { wasi::path_unlink_file(self.fd, path).map_err(err2io) }\n     }\n \n     pub fn remove_directory(&self, path: &[u8]) -> io::Result<()> {\n-        wasi::path_remove_directory(self.fd, path).map_err(err2io)\n+        unsafe { wasi::path_remove_directory(self.fd, path).map_err(err2io) }\n     }\n \n     pub fn sock_recv(\n         &self,\n         ri_data: &mut [IoSliceMut<'_>],\n         ri_flags: wasi::RiFlags,\n     ) -> io::Result<(usize, wasi::RoFlags)> {\n-        wasi::sock_recv(self.fd, iovec(ri_data), ri_flags).map_err(err2io)\n+        unsafe { wasi::sock_recv(self.fd, iovec(ri_data), ri_flags).map_err(err2io) }\n     }\n \n     pub fn sock_send(&self, si_data: &[IoSlice<'_>], si_flags: wasi::SiFlags) -> io::Result<usize> {\n-        wasi::sock_send(self.fd, ciovec(si_data), si_flags).map_err(err2io)\n+        unsafe { wasi::sock_send(self.fd, ciovec(si_data), si_flags).map_err(err2io) }\n     }\n \n     pub fn sock_shutdown(&self, how: Shutdown) -> io::Result<()> {\n@@ -229,14 +237,14 @@ impl WasiFd {\n             Shutdown::Write => wasi::SHUT_WR,\n             Shutdown::Both => wasi::SHUT_WR | wasi::SHUT_RD,\n         };\n-        wasi::sock_shutdown(self.fd, how).map_err(err2io)\n+        unsafe { wasi::sock_shutdown(self.fd, how).map_err(err2io) }\n     }\n }\n \n impl Drop for WasiFd {\n     fn drop(&mut self) {\n         // FIXME: can we handle the return code here even though we can't on\n         // unix?\n-        let _ = wasi::fd_close(self.fd);\n+        let _ = unsafe { wasi::fd_close(self.fd) };\n     }\n }"}, {"sha": "517e3be9cb58c14273f3eb2c0e8526e29f70dbd4", "filename": "src/libstd/sys/wasi/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6374b8458f0796a1ff3ee2caec41321e801c35d1/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6374b8458f0796a1ff3ee2caec41321e801c35d1/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs?ref=6374b8458f0796a1ff3ee2caec41321e801c35d1", "patch": "@@ -69,10 +69,17 @@ pub fn unsupported_err() -> std_io::Error {\n \n pub fn decode_error_kind(errno: i32) -> std_io::ErrorKind {\n     use std_io::ErrorKind::*;\n-    match errno as libc::c_int {\n+    if errno > u16::max_value() as i32 || errno < 0 {\n+        return Other;\n+    }\n+    let code = match wasi::Error::new(errno as u16) {\n+        Some(code) => code,\n+        None => return Other,\n+    };\n+    match code {\n         wasi::ECONNREFUSED => ConnectionRefused,\n         wasi::ECONNRESET => ConnectionReset,\n-        wasi::EPERM | libc::EACCES => PermissionDenied,\n+        wasi::EPERM | wasi::EACCES => PermissionDenied,\n         wasi::EPIPE => BrokenPipe,\n         wasi::ENOTCONN => NotConnected,\n         wasi::ECONNABORTED => ConnectionAborted,\n@@ -84,7 +91,7 @@ pub fn decode_error_kind(errno: i32) -> std_io::ErrorKind {\n         wasi::ETIMEDOUT => TimedOut,\n         wasi::EEXIST => AlreadyExists,\n         wasi::EAGAIN => WouldBlock,\n-        _ => ErrorKind::Other,\n+        _ => Other,\n     }\n }\n "}, {"sha": "987bf7580838b9b2392ba1c03e7375dcfb5cb2cc", "filename": "src/libstd/sys/wasi/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6374b8458f0796a1ff3ee2caec41321e801c35d1/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6374b8458f0796a1ff3ee2caec41321e801c35d1/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs?ref=6374b8458f0796a1ff3ee2caec41321e801c35d1", "patch": "@@ -47,7 +47,7 @@ impl Thread {\n             u: wasi::raw::__wasi_subscription_u { clock: clock },\n         }];\n         let mut out: [wasi::Event; 1] = [unsafe { mem::zeroed() }];\n-        let n = wasi::poll_oneoff(&in_, &mut out).unwrap();\n+        let n = unsafe { wasi::poll_oneoff(&in_, &mut out).unwrap() };\n         let wasi::Event { userdata, error, type_, .. } = out[0];\n         match (n, userdata, error) {\n             (1, CLOCK_ID, 0) if type_ == wasi::EVENTTYPE_CLOCK => {}"}]}