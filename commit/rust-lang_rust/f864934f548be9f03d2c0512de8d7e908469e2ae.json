{"sha": "f864934f548be9f03d2c0512de8d7e908469e2ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NjQ5MzRmNTQ4YmU5ZjAzZDJjMDUxMmRlOGQ3ZTkwODQ2OWUyYWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-29T23:42:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-29T23:42:43Z"}, "message": "auto merge of #5628 : brson/rust/assert, r=brson", "tree": {"sha": "8199ebdfbabc8b0a537f7b9330716e3b9c71714a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8199ebdfbabc8b0a537f7b9330716e3b9c71714a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f864934f548be9f03d2c0512de8d7e908469e2ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f864934f548be9f03d2c0512de8d7e908469e2ae", "html_url": "https://github.com/rust-lang/rust/commit/f864934f548be9f03d2c0512de8d7e908469e2ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f864934f548be9f03d2c0512de8d7e908469e2ae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a17a9d41f6bf06daacb0aedb0cb2144dc4ba1c53", "url": "https://api.github.com/repos/rust-lang/rust/commits/a17a9d41f6bf06daacb0aedb0cb2144dc4ba1c53", "html_url": "https://github.com/rust-lang/rust/commit/a17a9d41f6bf06daacb0aedb0cb2144dc4ba1c53"}, {"sha": "1e91595520d0538e6003dc9186f1b0df5c25b77a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e91595520d0538e6003dc9186f1b0df5c25b77a", "html_url": "https://github.com/rust-lang/rust/commit/1e91595520d0538e6003dc9186f1b0df5c25b77a"}], "stats": {"total": 11861, "additions": 5924, "deletions": 5937}, "files": [{"sha": "24200459d90f385ca251a035d34fdb4ad39a07f9", "filename": "doc/rust.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -1971,7 +1971,7 @@ let v = ~[1,2,3];\n \n mutate(copy v);   // Pass a copy\n \n-fail_unless!(v[0] == 1); // Original was not modified\n+assert!(v[0] == 1); // Original was not modified\n ~~~~\n \n ### Unary move expressions\n@@ -2491,7 +2491,7 @@ An example of a tuple type and its use:\n type Pair<'self> = (int,&'self str);\n let p: Pair<'static> = (10,\"hello\");\n let (a, b) = p;\n-fail_unless!(b != \"world\");\n+assert!(b != \"world\");\n ~~~~\n \n \n@@ -2519,7 +2519,7 @@ An example of a vector type and its use:\n ~~~~\n let v: &[int] = &[7, 5, 3];\n let i: int = v[2];\n-fail_unless!(i == 3);\n+assert!(i == 3);\n ~~~~\n \n All in-bounds elements of a vector are always initialized,\n@@ -2925,7 +2925,7 @@ example of an _implicit dereference_ operation performed on box values:\n ~~~~~~~~\n struct Foo { y: int }\n let x = @Foo{y: 10};\n-fail_unless!(x.y == 10);\n+assert!(x.y == 10);\n ~~~~~~~~\n \n Other operations act on box values as single-word-sized address values. For"}, {"sha": "4a93eecac0da517db464d11ca8b7dc8f5127afd3", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -239,7 +239,7 @@ fn unix_time_in_microseconds() -> u64 {\n     }\n }\n \n-# fn main() { fail_unless!(fmt!(\"%?\", unix_time_in_microseconds()) != ~\"\"); }\n+# fn main() { assert!(fmt!(\"%?\", unix_time_in_microseconds()) != ~\"\"); }\n ~~~~\n \n The `#[nolink]` attribute indicates that there's no foreign library to"}, {"sha": "5168809e9aab717f9d261023fcaf45b1b472be3b", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -297,7 +297,7 @@ let result = ports.foldl(0, |accum, port| *accum + port.recv() );\n \n Rust has a built-in mechanism for raising exceptions. The `fail!()` macro\n (which can also be written with an error string as an argument: `fail!(\n-~reason)`) and the `fail_unless!` construct (which effectively calls `fail!()`\n+~reason)`) and the `assert!` construct (which effectively calls `fail!()`\n if a boolean expression is false) are both ways to raise exceptions. When a\n task raises an exception the task unwinds its stack---running destructors and\n freeing memory along the way---and then exits. Unlike exceptions in C++,\n@@ -339,7 +339,7 @@ let result: Result<int, ()> = do task::try {\n         fail!(~\"oops!\");\n     }\n };\n-fail_unless!(result.is_err());\n+assert!(result.is_err());\n ~~~\n \n Unlike `spawn`, the function spawned using `try` may return a value,\n@@ -401,7 +401,7 @@ do spawn {  // Bidirectionally linked\n     // Wait for the supervised child task to exist.\n     let message = receiver.recv();\n     // Kill both it and the parent task.\n-    fail_unless!(message != 42);\n+    assert!(message != 42);\n }\n do try {  // Unidirectionally linked\n     sender.send(42);\n@@ -507,13 +507,13 @@ do spawn {\n };\n \n from_child.send(22);\n-fail_unless!(from_child.recv() == ~\"22\");\n+assert!(from_child.recv() == ~\"22\");\n \n from_child.send(23);\n from_child.send(0);\n \n-fail_unless!(from_child.recv() == ~\"23\");\n-fail_unless!(from_child.recv() == ~\"0\");\n+assert!(from_child.recv() == ~\"23\");\n+assert!(from_child.recv() == ~\"0\");\n \n # }\n ~~~~"}, {"sha": "9344c43ba10adb290f69b4e1aec69c93be81b839", "filename": "doc/tutorial.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -381,7 +381,7 @@ expression to the given type.\n ~~~~\n let x: float = 4.0;\n let y: uint = x as uint;\n-fail_unless!(y == 4u);\n+assert!(y == 4u);\n ~~~~\n \n ## Syntax extensions\n@@ -850,8 +850,8 @@ Ending the function with a semicolon like so is equivalent to returning `()`.\n fn line(a: int, b: int, x: int) -> int { a * x + b  }\n fn oops(a: int, b: int, x: int) -> ()  { a * x + b; }\n \n-fail_unless!(8 == line(5, 3, 1));\n-fail_unless!(() == oops(5, 3, 1));\n+assert!(8 == line(5, 3, 1));\n+assert!(() == oops(5, 3, 1));\n ~~~~\n \n As with `match` expressions and `let` bindings, function arguments support\n@@ -1417,8 +1417,8 @@ and [`core::str`]. Here are some examples.\n let crayons = [Almond, AntiqueBrass, Apricot];\n \n // Check the length of the vector\n-fail_unless!(crayons.len() == 3);\n-fail_unless!(!crayons.is_empty());\n+assert!(crayons.len() == 3);\n+assert!(!crayons.is_empty());\n \n // Iterate over a vector, obtaining a pointer to each element\n for crayons.each |crayon| {"}, {"sha": "585fd1271a8fa3e2bc0879d1906da2b4bf5dd3e1", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -65,7 +65,7 @@ pub fn parse_config(args: ~[~str]) -> config {\n           getopts::optflag(~\"jit\"),\n           getopts::optflag(~\"newrt\")];\n \n-    fail_unless!(!args.is_empty());\n+    assert!(!args.is_empty());\n     let args_ = vec::tail(args);\n     let matches =\n         &match getopts::getopts(args_, opts) {"}, {"sha": "a96f36f5e702cf235dada6d0f3e6ca2204bbc850", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -25,7 +25,7 @@ fn target_env(lib_path: ~str, prog: ~str) -> ~[(~str,~str)] {\n     let mut env = os::env();\n \n     // Make sure we include the aux directory in the path\n-    fail_unless!(prog.ends_with(~\".exe\"));\n+    assert!(prog.ends_with(~\".exe\"));\n     let aux_path = prog.slice(0u, prog.len() - 4u) + ~\".libaux\";\n \n     env = do vec::map(env) |pair| {"}, {"sha": "3e3d70530dd3548f2bf143bd73807be775d2cf9a", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -292,30 +292,30 @@ pub fn test() {\n     }\n \n     assert_eq!(seq_range(10, 15), @[10, 11, 12, 13, 14]);\n-    fail_unless!(from_fn(5, |x| x+1) == @[1, 2, 3, 4, 5]);\n-    fail_unless!(from_elem(5, 3.14) == @[3.14, 3.14, 3.14, 3.14, 3.14]);\n+    assert!(from_fn(5, |x| x+1) == @[1, 2, 3, 4, 5]);\n+    assert!(from_elem(5, 3.14) == @[3.14, 3.14, 3.14, 3.14, 3.14]);\n }\n \n #[test]\n pub fn append_test() {\n-    fail_unless!(@[1,2,3] + @[4,5,6] == @[1,2,3,4,5,6]);\n+    assert!(@[1,2,3] + @[4,5,6] == @[1,2,3,4,5,6]);\n }\n \n #[test]\n pub fn test_from_owned() {\n-    fail_unless!(from_owned::<int>(~[]) == @[]);\n-    fail_unless!(from_owned(~[true]) == @[true]);\n-    fail_unless!(from_owned(~[1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n-    fail_unless!(from_owned(~[~\"abc\", ~\"123\"]) == @[~\"abc\", ~\"123\"]);\n-    fail_unless!(from_owned(~[~[42]]) == @[~[42]]);\n+    assert!(from_owned::<int>(~[]) == @[]);\n+    assert!(from_owned(~[true]) == @[true]);\n+    assert!(from_owned(~[1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n+    assert!(from_owned(~[~\"abc\", ~\"123\"]) == @[~\"abc\", ~\"123\"]);\n+    assert!(from_owned(~[~[42]]) == @[~[42]]);\n }\n \n #[test]\n pub fn test_from_slice() {\n-    fail_unless!(from_slice::<int>([]) == @[]);\n-    fail_unless!(from_slice([true]) == @[true]);\n-    fail_unless!(from_slice([1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n-    fail_unless!(from_slice([@\"abc\", @\"123\"]) == @[@\"abc\", @\"123\"]);\n-    fail_unless!(from_slice([@[42]]) == @[@[42]]);\n+    assert!(from_slice::<int>([]) == @[]);\n+    assert!(from_slice([true]) == @[true]);\n+    assert!(from_slice([1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n+    assert!(from_slice([@\"abc\", @\"123\"]) == @[@\"abc\", @\"123\"]);\n+    assert!(from_slice([@[42]]) == @[@[42]]);\n }\n "}, {"sha": "a30cb92693748a2cfe1af0fbe0e9debfe8e3b759", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -86,20 +86,20 @@ pub fn test_bool_from_str() {\n     use from_str::FromStr;\n \n     do all_values |v| {\n-        fail_unless!(Some(v) == FromStr::from_str(to_str(v)))\n+        assert!(Some(v) == FromStr::from_str(to_str(v)))\n     }\n }\n \n #[test]\n pub fn test_bool_to_str() {\n-    fail_unless!(to_str(false) == ~\"false\");\n-    fail_unless!(to_str(true) == ~\"true\");\n+    assert!(to_str(false) == ~\"false\");\n+    assert!(to_str(true) == ~\"true\");\n }\n \n #[test]\n pub fn test_bool_to_bit() {\n     do all_values |v| {\n-        fail_unless!(to_bit(v) == if is_true(v) { 1u8 } else { 0u8 });\n+        assert!(to_bit(v) == if is_true(v) { 1u8 } else { 0u8 });\n     }\n }\n "}, {"sha": "4369d4be217afa86eea0507b14bdec325660ebee", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -50,7 +50,7 @@ pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n  *\n  * # Example\n  *\n- *     fail_unless!(transmute(\"L\") == ~[76u8, 0u8]);\n+ *     assert!(transmute(\"L\") == ~[76u8, 0u8]);\n  */\n #[inline(always)]\n pub unsafe fn transmute<L, G>(thing: L) -> G {\n@@ -116,7 +116,7 @@ pub mod tests {\n \n     #[test]\n     pub fn test_reinterpret_cast() {\n-        fail_unless!(1u == unsafe { reinterpret_cast(&1) });\n+        assert!(1u == unsafe { reinterpret_cast(&1) });\n     }\n \n     #[test]\n@@ -127,8 +127,8 @@ pub mod tests {\n             let ptr: *int = transmute(box); // refcount 2\n             let _box1: @~str = reinterpret_cast(&ptr);\n             let _box2: @~str = reinterpret_cast(&ptr);\n-            fail_unless!(*_box1 == ~\"box box box\");\n-            fail_unless!(*_box2 == ~\"box box box\");\n+            assert!(*_box1 == ~\"box box box\");\n+            assert!(*_box2 == ~\"box box box\");\n             // Will destroy _box1 and _box2. Without the bump, this would\n             // use-after-free. With too many bumps, it would leak.\n         }\n@@ -140,15 +140,15 @@ pub mod tests {\n         unsafe {\n             let x = @100u8;\n             let x: *BoxRepr = transmute(x);\n-            fail_unless!((*x).data == 100);\n+            assert!((*x).data == 100);\n             let _x: @int = transmute(x);\n         }\n     }\n \n     #[test]\n     pub fn test_transmute2() {\n         unsafe {\n-            fail_unless!(~[76u8, 0u8] == transmute(~\"L\"));\n+            assert!(~[76u8, 0u8] == transmute(~\"L\"));\n         }\n     }\n }"}, {"sha": "28b3ebe4484c7b4f68de7d10fe15d2f0de75aa02", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -80,12 +80,12 @@ pub impl<T> Cell<T> {\n #[test]\n fn test_basic() {\n     let value_cell = Cell(~10);\n-    fail_unless!(!value_cell.is_empty());\n+    assert!(!value_cell.is_empty());\n     let value = value_cell.take();\n-    fail_unless!(value == ~10);\n-    fail_unless!(value_cell.is_empty());\n+    assert!(value == ~10);\n+    assert!(value_cell.is_empty());\n     value_cell.put_back(value);\n-    fail_unless!(!value_cell.is_empty());\n+    assert!(!value_cell.is_empty());\n }\n \n #[test]"}, {"sha": "4f1dbe6ab7f23a5af247a13bced81bd92e308893", "filename": "src/libcore/char.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -200,7 +200,7 @@ pub fn escape_unicode(c: char) -> ~str {\n     let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n                     else if c <= '\\uffff' { ('u', 4u) }\n                     else { ('U', 8u) });\n-    fail_unless!(str::len(s) <= pad);\n+    assert!(str::len(s) <= pad);\n     let mut out = ~\"\\\\\";\n     unsafe {\n         str::push_str(&mut out, str::from_char(c));\n@@ -258,32 +258,32 @@ impl Eq for char {\n \n #[test]\n fn test_is_lowercase() {\n-    fail_unless!(is_lowercase('a'));\n-    fail_unless!(is_lowercase('\u00f6'));\n-    fail_unless!(is_lowercase('\u00df'));\n-    fail_unless!(!is_lowercase('\u00dc'));\n-    fail_unless!(!is_lowercase('P'));\n+    assert!(is_lowercase('a'));\n+    assert!(is_lowercase('\u00f6'));\n+    assert!(is_lowercase('\u00df'));\n+    assert!(!is_lowercase('\u00dc'));\n+    assert!(!is_lowercase('P'));\n }\n \n #[test]\n fn test_is_uppercase() {\n-    fail_unless!(!is_uppercase('h'));\n-    fail_unless!(!is_uppercase('\u00e4'));\n-    fail_unless!(!is_uppercase('\u00df'));\n-    fail_unless!(is_uppercase('\u00d6'));\n-    fail_unless!(is_uppercase('T'));\n+    assert!(!is_uppercase('h'));\n+    assert!(!is_uppercase('\u00e4'));\n+    assert!(!is_uppercase('\u00df'));\n+    assert!(is_uppercase('\u00d6'));\n+    assert!(is_uppercase('T'));\n }\n \n #[test]\n fn test_is_whitespace() {\n-    fail_unless!(is_whitespace(' '));\n-    fail_unless!(is_whitespace('\\u2007'));\n-    fail_unless!(is_whitespace('\\t'));\n-    fail_unless!(is_whitespace('\\n'));\n+    assert!(is_whitespace(' '));\n+    assert!(is_whitespace('\\u2007'));\n+    assert!(is_whitespace('\\t'));\n+    assert!(is_whitespace('\\n'));\n \n-    fail_unless!(!is_whitespace('a'));\n-    fail_unless!(!is_whitespace('_'));\n-    fail_unless!(!is_whitespace('\\u0000'));\n+    assert!(!is_whitespace('a'));\n+    assert!(!is_whitespace('_'));\n+    assert!(!is_whitespace('\\u0000'));\n }\n \n #[test]\n@@ -299,24 +299,24 @@ fn test_to_digit() {\n     assert_eq!(to_digit('z', 36u), Some(35u));\n     assert_eq!(to_digit('Z', 36u), Some(35u));\n \n-    fail_unless!(to_digit(' ', 10u).is_none());\n-    fail_unless!(to_digit('$', 36u).is_none());\n+    assert!(to_digit(' ', 10u).is_none());\n+    assert!(to_digit('$', 36u).is_none());\n }\n \n #[test]\n fn test_is_ascii() {\n-   fail_unless!(str::all(~\"banana\", is_ascii));\n-   fail_unless!(! str::all(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", is_ascii));\n+   assert!(str::all(~\"banana\", is_ascii));\n+   assert!(! str::all(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", is_ascii));\n }\n \n #[test]\n fn test_is_digit() {\n-   fail_unless!(is_digit('2'));\n-   fail_unless!(is_digit('7'));\n-   fail_unless!(! is_digit('c'));\n-   fail_unless!(! is_digit('i'));\n-   fail_unless!(! is_digit('z'));\n-   fail_unless!(! is_digit('Q'));\n+   assert!(is_digit('2'));\n+   assert!(is_digit('7'));\n+   assert!(! is_digit('c'));\n+   assert!(! is_digit('i'));\n+   assert!(! is_digit('z'));\n+   assert!(! is_digit('Q'));\n }\n \n #[test]"}, {"sha": "a928d3bb2af1f126f2aa03c6ebb3c841afcb0a01", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -177,7 +177,7 @@ mod test {\n \n     #[test]\n     fn test_int_totaleq() {\n-        fail_unless!(5.equals(&5));\n-        fail_unless!(!2.equals(&17));\n+        assert!(5.equals(&5));\n+        assert!(!2.equals(&17));\n     }\n }"}, {"sha": "9fd6f1db793b0a6280cd1bc234fa083ab3f80d2f", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -465,6 +465,6 @@ pub mod test {\n             let _chan = chan;\n         }\n \n-        fail_unless!(!port.peek());\n+        assert!(!port.peek());\n     }\n }"}, {"sha": "ed94f2ef2c45cf52cc8dd7921c868cb05e1d3227", "filename": "src/libcore/condition.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcondition.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -127,7 +127,7 @@ mod test {\n             trouble(1);\n         }\n \n-        fail_unless!(inner_trapped);\n+        assert!(inner_trapped);\n     }\n \n     #[test]\n@@ -143,7 +143,7 @@ mod test {\n             trouble(1);\n         }\n \n-        fail_unless!(outer_trapped);\n+        assert!(outer_trapped);\n     }\n \n     fn nested_reraise_trap_test_inner() {\n@@ -160,7 +160,7 @@ mod test {\n             trouble(1);\n         }\n \n-        fail_unless!(inner_trapped);\n+        assert!(inner_trapped);\n     }\n \n     #[test]\n@@ -175,7 +175,7 @@ mod test {\n             nested_reraise_trap_test_inner();\n         }\n \n-        fail_unless!(outer_trapped);\n+        assert!(outer_trapped);\n     }\n \n     #[test]\n@@ -190,6 +190,6 @@ mod test {\n             trouble(1);\n         }\n \n-        fail_unless!(trapped);\n+        assert!(trapped);\n     }\n }"}, {"sha": "ee7c1651514fefa18027346b908e89c9e1f2eda5", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -171,7 +171,7 @@ priv impl<T> DList<T> {\n     // Remove a node from the list.\n     fn unlink(@mut self, nobe: @mut DListNode<T>) {\n         self.assert_mine(nobe);\n-        fail_unless!(self.size > 0);\n+        assert!(self.size > 0);\n         self.link(nobe.prev, nobe.next);\n         nobe.prev = None; // Release extraneous references.\n         nobe.next = None;\n@@ -193,7 +193,7 @@ priv impl<T> DList<T> {\n                    nobe: DListLink<T>,\n                    neighbour: @mut DListNode<T>) {\n         self.assert_mine(neighbour);\n-        fail_unless!(self.size > 0);\n+        assert!(self.size > 0);\n         self.link(neighbour.prev, nobe);\n         self.link(nobe, Some(neighbour));\n         self.size += 1;\n@@ -202,7 +202,7 @@ priv impl<T> DList<T> {\n                     neighbour: @mut DListNode<T>,\n                     nobe: DListLink<T>) {\n         self.assert_mine(neighbour);\n-        fail_unless!(self.size > 0);\n+        assert!(self.size > 0);\n         self.link(nobe, neighbour.next);\n         self.link(Some(neighbour), nobe);\n         self.size += 1;\n@@ -410,15 +410,15 @@ pub impl<T> DList<T> {\n     /// Check data structure integrity. O(n).\n     fn assert_consistent(@mut self) {\n         if self.hd.is_none() || self.tl.is_none() {\n-            fail_unless!(self.hd.is_none() && self.tl.is_none());\n+            assert!(self.hd.is_none() && self.tl.is_none());\n         }\n         // iterate forwards\n         let mut count = 0;\n         let mut link = self.peek_n();\n         let mut rabbit = link;\n         while link.is_some() {\n             let nobe = link.get();\n-            fail_unless!(nobe.linked);\n+            assert!(nobe.linked);\n             // check cycle\n             if rabbit.is_some() {\n                 rabbit = rabbit.get().next;\n@@ -427,19 +427,19 @@ pub impl<T> DList<T> {\n                 rabbit = rabbit.get().next;\n             }\n             if rabbit.is_some() {\n-                fail_unless!(!managed::mut_ptr_eq(rabbit.get(), nobe));\n+                assert!(!managed::mut_ptr_eq(rabbit.get(), nobe));\n             }\n             // advance\n             link = nobe.next_link();\n             count += 1;\n         }\n-        fail_unless!(count == self.len());\n+        assert!(count == self.len());\n         // iterate backwards - some of this is probably redundant.\n         link = self.peek_tail_n();\n         rabbit = link;\n         while link.is_some() {\n             let nobe = link.get();\n-            fail_unless!(nobe.linked);\n+            assert!(nobe.linked);\n             // check cycle\n             if rabbit.is_some() {\n                 rabbit = rabbit.get().prev;\n@@ -448,13 +448,13 @@ pub impl<T> DList<T> {\n                 rabbit = rabbit.get().prev;\n             }\n             if rabbit.is_some() {\n-                fail_unless!(!managed::mut_ptr_eq(rabbit.get(), nobe));\n+                assert!(!managed::mut_ptr_eq(rabbit.get(), nobe));\n             }\n             // advance\n             link = nobe.prev_link();\n             count -= 1;\n         }\n-        fail_unless!(count == 0);\n+        assert!(count == 0);\n     }\n }\n \n@@ -510,7 +510,7 @@ impl<T> BaseIter<T> for @mut DList<T> {\n         let mut link = self.peek_n();\n         while link.is_some() {\n             let nobe = link.get();\n-            fail_unless!(nobe.linked);\n+            assert!(nobe.linked);\n \n             {\n                 let frozen_nobe = &*nobe;\n@@ -563,7 +563,7 @@ mod tests {\n         abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 6);\n         abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 7);\n         abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 8);\n-        abcd.assert_consistent(); fail_unless!(abcd.is_empty());\n+        abcd.assert_consistent(); assert!(abcd.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append() {\n@@ -579,7 +579,7 @@ mod tests {\n         a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n         a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n         a.assert_consistent(); assert_eq!(a.pop().get(), 6);\n-        a.assert_consistent(); fail_unless!(a.is_empty());\n+        a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append_empty() {\n@@ -592,7 +592,7 @@ mod tests {\n         a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n         a.assert_consistent(); assert_eq!(a.pop().get(), 2);\n         a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n-        a.assert_consistent(); fail_unless!(a.is_empty());\n+        a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append_to_empty() {\n@@ -605,7 +605,7 @@ mod tests {\n         a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n         a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n         a.assert_consistent(); assert_eq!(a.pop().get(), 6);\n-        a.assert_consistent(); fail_unless!(a.is_empty());\n+        a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append_two_empty() {\n@@ -645,7 +645,7 @@ mod tests {\n         b.assert_consistent(); assert_eq!(b.pop().get(), 4);\n         b.assert_consistent(); assert_eq!(b.pop().get(), 5);\n         b.assert_consistent(); assert_eq!(b.pop().get(), 6);\n-        b.assert_consistent(); fail_unless!(b.is_empty());\n+        b.assert_consistent(); assert!(b.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_reverse() {\n@@ -657,7 +657,7 @@ mod tests {\n         a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n         a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n         a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n-        a.assert_consistent(); fail_unless!(a.is_empty());\n+        a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_reverse_empty() {\n@@ -681,7 +681,7 @@ mod tests {\n         a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n         a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n         a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n-        a.assert_consistent(); fail_unless!(a.is_empty());\n+        a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_clear() {\n@@ -694,8 +694,8 @@ mod tests {\n     pub fn test_dlist_is_empty() {\n         let empty = DList::<int>();\n         let full1 = from_vec(~[1,2,3]);\n-        fail_unless!(empty.is_empty());\n-        fail_unless!(!full1.is_empty());\n+        assert!(empty.is_empty());\n+        assert!(!full1.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_head_tail() {\n@@ -714,8 +714,8 @@ mod tests {\n         assert_eq!(l.tail(), 3);\n         assert_eq!(l.head(), 3);\n         assert_eq!(l.pop().get(), 3);\n-        fail_unless!(l.is_empty());\n-        fail_unless!(l.pop().is_none());\n+        assert!(l.is_empty());\n+        assert!(l.pop().is_none());\n     }\n     #[test]\n     pub fn test_dlist_pop_tail() {\n@@ -727,8 +727,8 @@ mod tests {\n         assert_eq!(l.tail(), 1);\n         assert_eq!(l.head(), 1);\n         assert_eq!(l.pop_tail().get(), 1);\n-        fail_unless!(l.is_empty());\n-        fail_unless!(l.pop_tail().is_none());\n+        assert!(l.is_empty());\n+        assert!(l.pop_tail().is_none());\n     }\n     #[test]\n     pub fn test_dlist_push() {\n@@ -786,7 +786,7 @@ mod tests {\n         l.assert_consistent(); assert_eq!(l.tail(), 3);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); fail_unless!(l.is_empty());\n+        l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_mid() {\n@@ -801,7 +801,7 @@ mod tests {\n         l.assert_consistent(); assert_eq!(l.tail(), 3);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); fail_unless!(l.is_empty());\n+        l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_tail() {\n@@ -816,7 +816,7 @@ mod tests {\n         l.assert_consistent(); assert_eq!(l.tail(), 2);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); fail_unless!(l.is_empty());\n+        l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_one_two() {\n@@ -832,7 +832,7 @@ mod tests {\n         l.assert_consistent(); assert_eq!(l.head(), 3);\n         l.assert_consistent(); assert_eq!(l.tail(), 3);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); fail_unless!(l.is_empty());\n+        l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_one_three() {\n@@ -847,7 +847,7 @@ mod tests {\n         l.assert_consistent(); assert_eq!(l.head(), 2);\n         l.assert_consistent(); assert_eq!(l.tail(), 2);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); fail_unless!(l.is_empty());\n+        l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_two_three() {\n@@ -862,7 +862,7 @@ mod tests {\n         l.assert_consistent(); assert_eq!(l.head(), 1);\n         l.assert_consistent(); assert_eq!(l.tail(), 1);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); fail_unless!(l.is_empty());\n+        l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_all() {\n@@ -874,8 +874,8 @@ mod tests {\n         l.assert_consistent(); l.remove(two);\n         l.assert_consistent(); l.remove(three);\n         l.assert_consistent(); l.remove(one); // Twenty-three is number one!\n-        l.assert_consistent(); fail_unless!(l.peek().is_none());\n-        l.assert_consistent(); fail_unless!(l.is_empty());\n+        l.assert_consistent(); assert!(l.peek().is_none());\n+        l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_insert_n_before() {\n@@ -891,7 +891,7 @@ mod tests {\n         l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); fail_unless!(l.is_empty());\n+        l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_insert_n_after() {\n@@ -907,7 +907,7 @@ mod tests {\n         l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); fail_unless!(l.is_empty());\n+        l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_insert_before_head() {\n@@ -922,7 +922,7 @@ mod tests {\n         l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); fail_unless!(l.is_empty());\n+        l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_insert_after_tail() {\n@@ -937,7 +937,7 @@ mod tests {\n         l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n         l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); fail_unless!(l.is_empty());\n+        l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     pub fn test_dlist_asymmetric_link() {"}, {"sha": "92f850cddd6d18e0a890e0460ff6b9df33465405", "filename": "src/libcore/either.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -176,15 +176,15 @@ fn test_either_left() {\n     let val = Left(10);\n     fn f_left(x: &int) -> bool { *x == 10 }\n     fn f_right(_x: &uint) -> bool { false }\n-    fail_unless!((either(f_left, f_right, &val)));\n+    assert!((either(f_left, f_right, &val)));\n }\n \n #[test]\n fn test_either_right() {\n     let val = Right(10u);\n     fn f_left(_x: &int) -> bool { false }\n     fn f_right(x: &uint) -> bool { *x == 10u }\n-    fail_unless!((either(f_left, f_right, &val)));\n+    assert!((either(f_left, f_right, &val)));\n }\n \n #[test]"}, {"sha": "a4f12f7da7e2e54e93ba80e8f140d9afffe1cdff", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -55,7 +55,7 @@ pub fn deflate_bytes(bytes: &const [u8]) -> ~[u8] {\n                                                    len as size_t,\n                                                    ptr::addr_of(&outsz),\n                                                    lz_norm);\n-            fail_unless!(res as int != 0);\n+            assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                             outsz as uint);\n             libc::free(res);\n@@ -73,7 +73,7 @@ pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n                                                      len as size_t,\n                                                      ptr::addr_of(&outsz),\n                                                      0);\n-            fail_unless!(res as int != 0);\n+            assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                             outsz as uint);\n             libc::free(res);\n@@ -102,6 +102,6 @@ fn test_flate_round_trip() {\n         debug!(\"%u bytes deflated to %u (%.1f%% size)\",\n                in.len(), cmp.len(),\n                100.0 * ((cmp.len() as float) / (in.len() as float)));\n-        fail_unless!((in == out));\n+        assert!((in == out));\n     }\n }"}, {"sha": "d31f35b011508eefaece318e5eca27226ff00815", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -456,7 +456,7 @@ pub fn test_siphash() {\n         let vec = u8to64_le!(vecs[t], 0);\n         let out = buf.hash_keyed(k0, k1);\n         debug!(\"got %?, expected %?\", out, vec);\n-        fail_unless!(vec == out);\n+        assert!(vec == out);\n \n         stream_full.reset();\n         stream_full.input(buf);\n@@ -465,7 +465,7 @@ pub fn test_siphash() {\n         let v = to_hex_str(&vecs[t]);\n         debug!(\"%d: (%s) => inc=%s full=%s\", t, v, i, f);\n \n-        fail_unless!(f == i && f == v);\n+        assert!(f == i && f == v);\n \n         buf += ~[t as u8];\n         stream_inc.input(~[t as u8]);\n@@ -477,20 +477,20 @@ pub fn test_siphash() {\n #[test] #[cfg(target_arch = \"arm\")]\n pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    fail_unless!((val as u64).hash() != (val as uint).hash());\n-    fail_unless!((val as u32).hash() == (val as uint).hash());\n+    assert!((val as u64).hash() != (val as uint).hash());\n+    assert!((val as u32).hash() == (val as uint).hash());\n }\n #[test] #[cfg(target_arch = \"x86_64\")]\n pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    fail_unless!((val as u64).hash() == (val as uint).hash());\n-    fail_unless!((val as u32).hash() != (val as uint).hash());\n+    assert!((val as u64).hash() == (val as uint).hash());\n+    assert!((val as u32).hash() != (val as uint).hash());\n }\n #[test] #[cfg(target_arch = \"x86\")]\n pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    fail_unless!((val as u64).hash() != (val as uint).hash());\n-    fail_unless!((val as u32).hash() == (val as uint).hash());\n+    assert!((val as u64).hash() != (val as uint).hash());\n+    assert!((val as u32).hash() == (val as uint).hash());\n }\n \n #[test]\n@@ -505,17 +505,17 @@ pub fn test_hash_idempotent() {\n pub fn test_hash_no_bytes_dropped_64() {\n     let val = 0xdeadbeef_deadbeef_u64;\n \n-    fail_unless!(val.hash() != zero_byte(val, 0).hash());\n-    fail_unless!(val.hash() != zero_byte(val, 1).hash());\n-    fail_unless!(val.hash() != zero_byte(val, 2).hash());\n-    fail_unless!(val.hash() != zero_byte(val, 3).hash());\n-    fail_unless!(val.hash() != zero_byte(val, 4).hash());\n-    fail_unless!(val.hash() != zero_byte(val, 5).hash());\n-    fail_unless!(val.hash() != zero_byte(val, 6).hash());\n-    fail_unless!(val.hash() != zero_byte(val, 7).hash());\n+    assert!(val.hash() != zero_byte(val, 0).hash());\n+    assert!(val.hash() != zero_byte(val, 1).hash());\n+    assert!(val.hash() != zero_byte(val, 2).hash());\n+    assert!(val.hash() != zero_byte(val, 3).hash());\n+    assert!(val.hash() != zero_byte(val, 4).hash());\n+    assert!(val.hash() != zero_byte(val, 5).hash());\n+    assert!(val.hash() != zero_byte(val, 6).hash());\n+    assert!(val.hash() != zero_byte(val, 7).hash());\n \n     fn zero_byte(val: u64, byte: uint) -> u64 {\n-        fail_unless!(byte < 8);\n+        assert!(byte < 8);\n         val & !(0xff << (byte * 8))\n     }\n }\n@@ -524,13 +524,13 @@ pub fn test_hash_no_bytes_dropped_64() {\n pub fn test_hash_no_bytes_dropped_32() {\n     let val = 0xdeadbeef_u32;\n \n-    fail_unless!(val.hash() != zero_byte(val, 0).hash());\n-    fail_unless!(val.hash() != zero_byte(val, 1).hash());\n-    fail_unless!(val.hash() != zero_byte(val, 2).hash());\n-    fail_unless!(val.hash() != zero_byte(val, 3).hash());\n+    assert!(val.hash() != zero_byte(val, 0).hash());\n+    assert!(val.hash() != zero_byte(val, 1).hash());\n+    assert!(val.hash() != zero_byte(val, 2).hash());\n+    assert!(val.hash() != zero_byte(val, 3).hash());\n \n     fn zero_byte(val: u32, byte: uint) -> u32 {\n-        fail_unless!(byte < 4);\n+        assert!(byte < 4);\n         val & !(0xff << (byte * 8))\n     }\n }"}, {"sha": "3df48ac70a241cd9f40ad6bf4338fcf9d8648b43", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 143, "deletions": 143, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -676,18 +676,18 @@ pub mod linear {\n         #[test]\n         pub fn test_insert() {\n             let mut m = LinearMap::new();\n-            fail_unless!(m.insert(1, 2));\n-            fail_unless!(m.insert(2, 4));\n-            fail_unless!(*m.get(&1) == 2);\n-            fail_unless!(*m.get(&2) == 4);\n+            assert!(m.insert(1, 2));\n+            assert!(m.insert(2, 4));\n+            assert!(*m.get(&1) == 2);\n+            assert!(*m.get(&2) == 4);\n         }\n \n         #[test]\n         fn test_find_mut() {\n             let mut m = LinearMap::new();\n-            fail_unless!(m.insert(1, 12));\n-            fail_unless!(m.insert(2, 8));\n-            fail_unless!(m.insert(5, 14));\n+            assert!(m.insert(1, 12));\n+            assert!(m.insert(2, 8));\n+            assert!(m.insert(5, 14));\n             let new = 100;\n             match m.find_mut(&5) {\n                 None => fail!(), Some(x) => *x = new\n@@ -698,110 +698,110 @@ pub mod linear {\n         #[test]\n         pub fn test_insert_overwrite() {\n             let mut m = LinearMap::new();\n-            fail_unless!(m.insert(1, 2));\n-            fail_unless!(*m.get(&1) == 2);\n-            fail_unless!(!m.insert(1, 3));\n-            fail_unless!(*m.get(&1) == 3);\n+            assert!(m.insert(1, 2));\n+            assert!(*m.get(&1) == 2);\n+            assert!(!m.insert(1, 3));\n+            assert!(*m.get(&1) == 3);\n         }\n \n         #[test]\n         pub fn test_insert_conflicts() {\n             let mut m = linear::linear_map_with_capacity(4);\n-            fail_unless!(m.insert(1, 2));\n-            fail_unless!(m.insert(5, 3));\n-            fail_unless!(m.insert(9, 4));\n-            fail_unless!(*m.get(&9) == 4);\n-            fail_unless!(*m.get(&5) == 3);\n-            fail_unless!(*m.get(&1) == 2);\n+            assert!(m.insert(1, 2));\n+            assert!(m.insert(5, 3));\n+            assert!(m.insert(9, 4));\n+            assert!(*m.get(&9) == 4);\n+            assert!(*m.get(&5) == 3);\n+            assert!(*m.get(&1) == 2);\n         }\n \n         #[test]\n         pub fn test_conflict_remove() {\n             let mut m = linear::linear_map_with_capacity(4);\n-            fail_unless!(m.insert(1, 2));\n-            fail_unless!(m.insert(5, 3));\n-            fail_unless!(m.insert(9, 4));\n-            fail_unless!(m.remove(&1));\n-            fail_unless!(*m.get(&9) == 4);\n-            fail_unless!(*m.get(&5) == 3);\n+            assert!(m.insert(1, 2));\n+            assert!(m.insert(5, 3));\n+            assert!(m.insert(9, 4));\n+            assert!(m.remove(&1));\n+            assert!(*m.get(&9) == 4);\n+            assert!(*m.get(&5) == 3);\n         }\n \n         #[test]\n         pub fn test_is_empty() {\n             let mut m = linear::linear_map_with_capacity(4);\n-            fail_unless!(m.insert(1, 2));\n-            fail_unless!(!m.is_empty());\n-            fail_unless!(m.remove(&1));\n-            fail_unless!(m.is_empty());\n+            assert!(m.insert(1, 2));\n+            assert!(!m.is_empty());\n+            assert!(m.remove(&1));\n+            assert!(m.is_empty());\n         }\n \n         #[test]\n         pub fn test_pop() {\n             let mut m = LinearMap::new();\n             m.insert(1, 2);\n-            fail_unless!(m.pop(&1) == Some(2));\n-            fail_unless!(m.pop(&1) == None);\n+            assert!(m.pop(&1) == Some(2));\n+            assert!(m.pop(&1) == None);\n         }\n \n         #[test]\n         pub fn test_swap() {\n             let mut m = LinearMap::new();\n-            fail_unless!(m.swap(1, 2) == None);\n-            fail_unless!(m.swap(1, 3) == Some(2));\n-            fail_unless!(m.swap(1, 4) == Some(3));\n+            assert!(m.swap(1, 2) == None);\n+            assert!(m.swap(1, 3) == Some(2));\n+            assert!(m.swap(1, 4) == Some(3));\n         }\n \n         #[test]\n         pub fn test_find_or_insert() {\n             let mut m = LinearMap::new::<int, int>();\n-            fail_unless!(m.find_or_insert(1, 2) == &2);\n-            fail_unless!(m.find_or_insert(1, 3) == &2);\n+            assert!(m.find_or_insert(1, 2) == &2);\n+            assert!(m.find_or_insert(1, 3) == &2);\n         }\n \n         #[test]\n         pub fn test_find_or_insert_with() {\n             let mut m = LinearMap::new::<int, int>();\n-            fail_unless!(m.find_or_insert_with(1, |_| 2) == &2);\n-            fail_unless!(m.find_or_insert_with(1, |_| 3) == &2);\n+            assert!(m.find_or_insert_with(1, |_| 2) == &2);\n+            assert!(m.find_or_insert_with(1, |_| 3) == &2);\n         }\n \n         #[test]\n         pub fn test_consume() {\n             let mut m = LinearMap::new();\n-            fail_unless!(m.insert(1, 2));\n-            fail_unless!(m.insert(2, 3));\n+            assert!(m.insert(1, 2));\n+            assert!(m.insert(2, 3));\n             let mut m2 = LinearMap::new();\n             do m.consume |k, v| {\n                 m2.insert(k, v);\n             }\n-            fail_unless!(m.len() == 0);\n-            fail_unless!(m2.len() == 2);\n-            fail_unless!(m2.get(&1) == &2);\n-            fail_unless!(m2.get(&2) == &3);\n+            assert!(m.len() == 0);\n+            assert!(m2.len() == 2);\n+            assert!(m2.get(&1) == &2);\n+            assert!(m2.get(&2) == &3);\n         }\n \n         #[test]\n         pub fn test_iterate() {\n             let mut m = linear::linear_map_with_capacity(4);\n             for uint::range(0, 32) |i| {\n-                fail_unless!(m.insert(i, i*2));\n+                assert!(m.insert(i, i*2));\n             }\n             let mut observed = 0;\n             for m.each |&(k, v)| {\n-                fail_unless!(*v == *k * 2);\n+                assert!(*v == *k * 2);\n                 observed |= (1 << *k);\n             }\n-            fail_unless!(observed == 0xFFFF_FFFF);\n+            assert!(observed == 0xFFFF_FFFF);\n         }\n \n         #[test]\n         pub fn test_find() {\n             let mut m = LinearMap::new();\n-            fail_unless!(m.find(&1).is_none());\n+            assert!(m.find(&1).is_none());\n             m.insert(1, 2);\n             match m.find(&1) {\n                 None => fail!(),\n-                Some(v) => fail_unless!(*v == 2)\n+                Some(v) => assert!(*v == 2)\n             }\n         }\n \n@@ -816,19 +816,19 @@ pub mod linear {\n             m2.insert(1, 2);\n             m2.insert(2, 3);\n \n-            fail_unless!(m1 != m2);\n+            assert!(m1 != m2);\n \n             m2.insert(3, 4);\n \n-            fail_unless!(m1 == m2);\n+            assert!(m1 == m2);\n         }\n \n         #[test]\n         pub fn test_expand() {\n             let mut m = LinearMap::new();\n \n-            fail_unless!(m.len() == 0);\n-            fail_unless!(m.is_empty());\n+            assert!(m.len() == 0);\n+            assert!(m.is_empty());\n \n             let mut i = 0u;\n             let old_resize_at = m.resize_at;\n@@ -837,8 +837,8 @@ pub mod linear {\n                 i += 1;\n             }\n \n-            fail_unless!(m.len() == i);\n-            fail_unless!(!m.is_empty());\n+            assert!(m.len() == i);\n+            assert!(!m.is_empty());\n         }\n     }\n \n@@ -852,160 +852,160 @@ pub mod linear {\n         fn test_disjoint() {\n             let mut xs = linear::LinearSet::new();\n             let mut ys = linear::LinearSet::new();\n-            fail_unless!(xs.is_disjoint(&ys));\n-            fail_unless!(ys.is_disjoint(&xs));\n-            fail_unless!(xs.insert(5));\n-            fail_unless!(ys.insert(11));\n-            fail_unless!(xs.is_disjoint(&ys));\n-            fail_unless!(ys.is_disjoint(&xs));\n-            fail_unless!(xs.insert(7));\n-            fail_unless!(xs.insert(19));\n-            fail_unless!(xs.insert(4));\n-            fail_unless!(ys.insert(2));\n-            fail_unless!(ys.insert(-11));\n-            fail_unless!(xs.is_disjoint(&ys));\n-            fail_unless!(ys.is_disjoint(&xs));\n-            fail_unless!(ys.insert(7));\n-            fail_unless!(!xs.is_disjoint(&ys));\n-            fail_unless!(!ys.is_disjoint(&xs));\n+            assert!(xs.is_disjoint(&ys));\n+            assert!(ys.is_disjoint(&xs));\n+            assert!(xs.insert(5));\n+            assert!(ys.insert(11));\n+            assert!(xs.is_disjoint(&ys));\n+            assert!(ys.is_disjoint(&xs));\n+            assert!(xs.insert(7));\n+            assert!(xs.insert(19));\n+            assert!(xs.insert(4));\n+            assert!(ys.insert(2));\n+            assert!(ys.insert(-11));\n+            assert!(xs.is_disjoint(&ys));\n+            assert!(ys.is_disjoint(&xs));\n+            assert!(ys.insert(7));\n+            assert!(!xs.is_disjoint(&ys));\n+            assert!(!ys.is_disjoint(&xs));\n         }\n \n         #[test]\n         fn test_subset_and_superset() {\n             let mut a = linear::LinearSet::new();\n-            fail_unless!(a.insert(0));\n-            fail_unless!(a.insert(5));\n-            fail_unless!(a.insert(11));\n-            fail_unless!(a.insert(7));\n+            assert!(a.insert(0));\n+            assert!(a.insert(5));\n+            assert!(a.insert(11));\n+            assert!(a.insert(7));\n \n             let mut b = linear::LinearSet::new();\n-            fail_unless!(b.insert(0));\n-            fail_unless!(b.insert(7));\n-            fail_unless!(b.insert(19));\n-            fail_unless!(b.insert(250));\n-            fail_unless!(b.insert(11));\n-            fail_unless!(b.insert(200));\n+            assert!(b.insert(0));\n+            assert!(b.insert(7));\n+            assert!(b.insert(19));\n+            assert!(b.insert(250));\n+            assert!(b.insert(11));\n+            assert!(b.insert(200));\n \n-            fail_unless!(!a.is_subset(&b));\n-            fail_unless!(!a.is_superset(&b));\n-            fail_unless!(!b.is_subset(&a));\n-            fail_unless!(!b.is_superset(&a));\n+            assert!(!a.is_subset(&b));\n+            assert!(!a.is_superset(&b));\n+            assert!(!b.is_subset(&a));\n+            assert!(!b.is_superset(&a));\n \n-            fail_unless!(b.insert(5));\n+            assert!(b.insert(5));\n \n-            fail_unless!(a.is_subset(&b));\n-            fail_unless!(!a.is_superset(&b));\n-            fail_unless!(!b.is_subset(&a));\n-            fail_unless!(b.is_superset(&a));\n+            assert!(a.is_subset(&b));\n+            assert!(!a.is_superset(&b));\n+            assert!(!b.is_subset(&a));\n+            assert!(b.is_superset(&a));\n         }\n \n         #[test]\n         fn test_intersection() {\n             let mut a = linear::LinearSet::new();\n             let mut b = linear::LinearSet::new();\n \n-            fail_unless!(a.insert(11));\n-            fail_unless!(a.insert(1));\n-            fail_unless!(a.insert(3));\n-            fail_unless!(a.insert(77));\n-            fail_unless!(a.insert(103));\n-            fail_unless!(a.insert(5));\n-            fail_unless!(a.insert(-5));\n-\n-            fail_unless!(b.insert(2));\n-            fail_unless!(b.insert(11));\n-            fail_unless!(b.insert(77));\n-            fail_unless!(b.insert(-9));\n-            fail_unless!(b.insert(-42));\n-            fail_unless!(b.insert(5));\n-            fail_unless!(b.insert(3));\n+            assert!(a.insert(11));\n+            assert!(a.insert(1));\n+            assert!(a.insert(3));\n+            assert!(a.insert(77));\n+            assert!(a.insert(103));\n+            assert!(a.insert(5));\n+            assert!(a.insert(-5));\n+\n+            assert!(b.insert(2));\n+            assert!(b.insert(11));\n+            assert!(b.insert(77));\n+            assert!(b.insert(-9));\n+            assert!(b.insert(-42));\n+            assert!(b.insert(5));\n+            assert!(b.insert(3));\n \n             let mut i = 0;\n             let expected = [3, 5, 11, 77];\n             for a.intersection(&b) |x| {\n-                fail_unless!(vec::contains(expected, x));\n+                assert!(vec::contains(expected, x));\n                 i += 1\n             }\n-            fail_unless!(i == expected.len());\n+            assert!(i == expected.len());\n         }\n \n         #[test]\n         fn test_difference() {\n             let mut a = linear::LinearSet::new();\n             let mut b = linear::LinearSet::new();\n \n-            fail_unless!(a.insert(1));\n-            fail_unless!(a.insert(3));\n-            fail_unless!(a.insert(5));\n-            fail_unless!(a.insert(9));\n-            fail_unless!(a.insert(11));\n+            assert!(a.insert(1));\n+            assert!(a.insert(3));\n+            assert!(a.insert(5));\n+            assert!(a.insert(9));\n+            assert!(a.insert(11));\n \n-            fail_unless!(b.insert(3));\n-            fail_unless!(b.insert(9));\n+            assert!(b.insert(3));\n+            assert!(b.insert(9));\n \n             let mut i = 0;\n             let expected = [1, 5, 11];\n             for a.difference(&b) |x| {\n-                fail_unless!(vec::contains(expected, x));\n+                assert!(vec::contains(expected, x));\n                 i += 1\n             }\n-            fail_unless!(i == expected.len());\n+            assert!(i == expected.len());\n         }\n \n         #[test]\n         fn test_symmetric_difference() {\n             let mut a = linear::LinearSet::new();\n             let mut b = linear::LinearSet::new();\n \n-            fail_unless!(a.insert(1));\n-            fail_unless!(a.insert(3));\n-            fail_unless!(a.insert(5));\n-            fail_unless!(a.insert(9));\n-            fail_unless!(a.insert(11));\n+            assert!(a.insert(1));\n+            assert!(a.insert(3));\n+            assert!(a.insert(5));\n+            assert!(a.insert(9));\n+            assert!(a.insert(11));\n \n-            fail_unless!(b.insert(-2));\n-            fail_unless!(b.insert(3));\n-            fail_unless!(b.insert(9));\n-            fail_unless!(b.insert(14));\n-            fail_unless!(b.insert(22));\n+            assert!(b.insert(-2));\n+            assert!(b.insert(3));\n+            assert!(b.insert(9));\n+            assert!(b.insert(14));\n+            assert!(b.insert(22));\n \n             let mut i = 0;\n             let expected = [-2, 1, 5, 11, 14, 22];\n             for a.symmetric_difference(&b) |x| {\n-                fail_unless!(vec::contains(expected, x));\n+                assert!(vec::contains(expected, x));\n                 i += 1\n             }\n-            fail_unless!(i == expected.len());\n+            assert!(i == expected.len());\n         }\n \n         #[test]\n         fn test_union() {\n             let mut a = linear::LinearSet::new();\n             let mut b = linear::LinearSet::new();\n \n-            fail_unless!(a.insert(1));\n-            fail_unless!(a.insert(3));\n-            fail_unless!(a.insert(5));\n-            fail_unless!(a.insert(9));\n-            fail_unless!(a.insert(11));\n-            fail_unless!(a.insert(16));\n-            fail_unless!(a.insert(19));\n-            fail_unless!(a.insert(24));\n-\n-            fail_unless!(b.insert(-2));\n-            fail_unless!(b.insert(1));\n-            fail_unless!(b.insert(5));\n-            fail_unless!(b.insert(9));\n-            fail_unless!(b.insert(13));\n-            fail_unless!(b.insert(19));\n+            assert!(a.insert(1));\n+            assert!(a.insert(3));\n+            assert!(a.insert(5));\n+            assert!(a.insert(9));\n+            assert!(a.insert(11));\n+            assert!(a.insert(16));\n+            assert!(a.insert(19));\n+            assert!(a.insert(24));\n+\n+            assert!(b.insert(-2));\n+            assert!(b.insert(1));\n+            assert!(b.insert(5));\n+            assert!(b.insert(9));\n+            assert!(b.insert(13));\n+            assert!(b.insert(19));\n \n             let mut i = 0;\n             let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n             for a.union(&b) |x| {\n-                fail_unless!(vec::contains(expected, x));\n+                assert!(vec::contains(expected, x));\n                 i += 1\n             }\n-            fail_unless!(i == expected.len());\n+            assert!(i == expected.len());\n         }\n     }\n }"}, {"sha": "60a0ee4fa9713df9129397fd60571c526f6b0334", "filename": "src/libcore/io.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -252,7 +252,7 @@ impl<T:Reader> ReaderUtil for T {\n                 let w = str::utf8_char_width(b0);\n                 let end = i + w;\n                 i += 1;\n-                fail_unless!((w > 0));\n+                assert!((w > 0));\n                 if w == 1 {\n                     chars.push(b0 as char);\n                     loop;\n@@ -265,8 +265,8 @@ impl<T:Reader> ReaderUtil for T {\n                 while i < end {\n                     let next = bytes[i] as int;\n                     i += 1;\n-                    fail_unless!((next > -1));\n-                    fail_unless!((next & 192 == 128));\n+                    assert!((next > -1));\n+                    assert!((next & 192 == 128));\n                     val <<= 6;\n                     val += (next & 63) as uint;\n                 }\n@@ -307,7 +307,7 @@ impl<T:Reader> ReaderUtil for T {\n         if vec::len(c) == 0 {\n             return -1 as char; // FIXME will this stay valid? // #2004\n         }\n-        fail_unless!((vec::len(c) == 1));\n+        assert!((vec::len(c) == 1));\n         return c[0];\n     }\n \n@@ -364,7 +364,7 @@ impl<T:Reader> ReaderUtil for T {\n     // FIXME int reading methods need to deal with eof - issue #2004\n \n     fn read_le_uint_n(&self, nbytes: uint) -> u64 {\n-        fail_unless!(nbytes > 0 && nbytes <= 8);\n+        assert!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0u64, pos = 0, i = nbytes;\n         while i > 0 {\n@@ -380,7 +380,7 @@ impl<T:Reader> ReaderUtil for T {\n     }\n \n     fn read_be_uint_n(&self, nbytes: uint) -> u64 {\n-        fail_unless!(nbytes > 0 && nbytes <= 8);\n+        assert!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0u64, i = nbytes;\n         while i > 0 {\n@@ -510,7 +510,7 @@ impl Reader for *libc::FILE {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         unsafe {\n             do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n-                fail_unless!(buf_len >= len);\n+                assert!(buf_len >= len);\n \n                 let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n                                         len as size_t, *self);\n@@ -531,7 +531,7 @@ impl Reader for *libc::FILE {\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n         unsafe {\n-            fail_unless!(libc::fseek(*self,\n+            assert!(libc::fseek(*self,\n                                      offset as c_long,\n                                      convert_whence(whence)) == 0 as c_int);\n         }\n@@ -717,7 +717,7 @@ impl Writer for *libc::FILE {\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n         unsafe {\n-            fail_unless!(libc::fseek(*self,\n+            assert!(libc::fseek(*self,\n                                      offset as c_long,\n                                      convert_whence(whence)) == 0 as c_int);\n         }\n@@ -845,7 +845,7 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n \n pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n                           f: &fn(v: &[u8]) -> T) -> T {\n-    fail_unless!(size <= 8u);\n+    assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n       2u => f(&[n as u8,\n@@ -877,7 +877,7 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n \n pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n                            f: &fn(v: &[u8]) -> T) -> T {\n-    fail_unless!(size <= 8u);\n+    assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n       2u => f(&[(n >> 8) as u8,\n@@ -912,7 +912,7 @@ pub fn u64_from_be_bytes(data: &const [u8],\n                          size: uint)\n                       -> u64 {\n     let mut sz = size;\n-    fail_unless!((sz <= 8u));\n+    assert!((sz <= 8u));\n     let mut val = 0_u64;\n     let mut pos = start;\n     while sz > 0u {\n@@ -1186,7 +1186,7 @@ pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n         // Make sure the vector has a trailing null and is proper utf8.\n         v.push(0);\n     }\n-    fail_unless!(str::is_utf8(v));\n+    assert!(str::is_utf8(v));\n \n     unsafe { ::cast::transmute(v) }\n }\n@@ -1261,7 +1261,7 @@ pub mod fsync {\n                 None => (),\n                 Some(level) => {\n                   // fail hard if not succesful\n-                  fail_unless!(((self.arg.fsync_fn)(self.arg.val, level)\n+                  assert!(((self.arg.fsync_fn)(self.arg.val, level)\n                     != -1));\n                 }\n             }\n@@ -1346,37 +1346,37 @@ mod tests {\n         let inp: @io::Reader = result::get(&io::file_reader(tmpfile));\n         let frood2: ~str = inp.read_c_str();\n         debug!(copy frood2);\n-        fail_unless!(frood == frood2);\n+        assert!(frood == frood2);\n     }\n \n     #[test]\n     fn test_readchars_empty() {\n         do io::with_str_reader(~\"\") |inp| {\n             let res : ~[char] = inp.read_chars(128);\n-            fail_unless!((vec::len(res) == 0));\n+            assert!((vec::len(res) == 0));\n         }\n     }\n \n     #[test]\n     fn test_read_line_utf8() {\n         do io::with_str_reader(~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\") |inp| {\n             let line = inp.read_line();\n-            fail_unless!(line == ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\");\n+            assert!(line == ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\");\n         }\n     }\n \n     #[test]\n     fn test_read_lines() {\n         do io::with_str_reader(~\"a\\nb\\nc\\n\") |inp| {\n-            fail_unless!(inp.read_lines() == ~[~\"a\", ~\"b\", ~\"c\"]);\n+            assert!(inp.read_lines() == ~[~\"a\", ~\"b\", ~\"c\"]);\n         }\n \n         do io::with_str_reader(~\"a\\nb\\nc\") |inp| {\n-            fail_unless!(inp.read_lines() == ~[~\"a\", ~\"b\", ~\"c\"]);\n+            assert!(inp.read_lines() == ~[~\"a\", ~\"b\", ~\"c\"]);\n         }\n \n         do io::with_str_reader(~\"\") |inp| {\n-            fail_unless!(inp.read_lines().is_empty());\n+            assert!(inp.read_lines().is_empty());\n         }\n     }\n \n@@ -1393,9 +1393,9 @@ mod tests {\n             do io::with_str_reader(s) |inp| {\n                 let res : ~[char] = inp.read_chars(len);\n                 if (len <= vec::len(ivals)) {\n-                    fail_unless!((vec::len(res) == len));\n+                    assert!((vec::len(res) == len));\n                 }\n-                fail_unless!(vec::slice(ivals, 0u, vec::len(res)) ==\n+                assert!(vec::slice(ivals, 0u, vec::len(res)) ==\n                              vec::map(res, |x| *x as int));\n             }\n         }\n@@ -1412,23 +1412,23 @@ mod tests {\n     fn test_readchar() {\n         do io::with_str_reader(~\"\u751f\") |inp| {\n             let res : char = inp.read_char();\n-            fail_unless!((res as int == 29983));\n+            assert!((res as int == 29983));\n         }\n     }\n \n     #[test]\n     fn test_readchar_empty() {\n         do io::with_str_reader(~\"\") |inp| {\n             let res : char = inp.read_char();\n-            fail_unless!((res as int == -1));\n+            assert!((res as int == -1));\n         }\n     }\n \n     #[test]\n     fn file_reader_not_exist() {\n         match io::file_reader(&Path(\"not a file\")) {\n           result::Err(copy e) => {\n-            fail_unless!(e == ~\"error opening not a file\");\n+            assert!(e == ~\"error opening not a file\");\n           }\n           result::Ok(_) => fail!()\n         }\n@@ -1469,7 +1469,7 @@ mod tests {\n     fn file_writer_bad_name() {\n         match io::file_writer(&Path(\"?/?\"), ~[]) {\n           result::Err(copy e) => {\n-            fail_unless!(str::starts_with(e, \"error opening\"));\n+            assert!(str::starts_with(e, \"error opening\"));\n           }\n           result::Ok(_) => fail!()\n         }\n@@ -1479,7 +1479,7 @@ mod tests {\n     fn buffered_file_writer_bad_name() {\n         match io::buffered_file_writer(&Path(\"?/?\")) {\n           result::Err(copy e) => {\n-            fail_unless!(str::starts_with(e, \"error opening\"));\n+            assert!(str::starts_with(e, \"error opening\"));\n           }\n           result::Ok(_) => fail!()\n         }\n@@ -1489,15 +1489,15 @@ mod tests {\n     fn bytes_buffer_overwrite() {\n         let wr = BytesWriter();\n         wr.write(~[0u8, 1u8, 2u8, 3u8]);\n-        fail_unless!(wr.bytes == ~[0u8, 1u8, 2u8, 3u8]);\n+        assert!(wr.bytes == ~[0u8, 1u8, 2u8, 3u8]);\n         wr.seek(-2, SeekCur);\n         wr.write(~[4u8, 5u8, 6u8, 7u8]);\n-        fail_unless!(wr.bytes == ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n+        assert!(wr.bytes == ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n         wr.seek(-2, SeekEnd);\n         wr.write(~[8u8]);\n         wr.seek(1, SeekSet);\n         wr.write(~[9u8]);\n-        fail_unless!(wr.bytes == ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n+        assert!(wr.bytes == ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n     }\n \n     #[test]\n@@ -1517,7 +1517,7 @@ mod tests {\n         {\n             let file = io::file_reader(&path).get();\n             for uints.each |i| {\n-                fail_unless!(file.read_le_u64() == *i);\n+                assert!(file.read_le_u64() == *i);\n             }\n         }\n     }\n@@ -1539,7 +1539,7 @@ mod tests {\n         {\n             let file = io::file_reader(&path).get();\n             for uints.each |i| {\n-                fail_unless!(file.read_be_u64() == *i);\n+                assert!(file.read_be_u64() == *i);\n             }\n         }\n     }\n@@ -1563,7 +1563,7 @@ mod tests {\n             for ints.each |i| {\n                 // this tests that the sign extension is working\n                 // (comparing the values as i32 would not test this)\n-                fail_unless!(file.read_be_int_n(4) == *i as i64);\n+                assert!(file.read_be_int_n(4) == *i as i64);\n             }\n         }\n     }\n@@ -1582,7 +1582,7 @@ mod tests {\n         {\n             let file = io::file_reader(&path).get();\n             let f = file.read_be_f32();\n-            fail_unless!(f == 8.1250);\n+            assert!(f == 8.1250);\n         }\n     }\n \n@@ -1599,8 +1599,8 @@ mod tests {\n \n         {\n             let file = io::file_reader(&path).get();\n-            fail_unless!(file.read_be_f32() == 8.1250);\n-            fail_unless!(file.read_le_f32() == 8.1250);\n+            assert!(file.read_be_f32() == 8.1250);\n+            assert!(file.read_le_f32() == 8.1250);\n         }\n     }\n }"}, {"sha": "234b710d238b0c824840fdd82858f96e5f0c0558", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -91,8 +91,8 @@ impl<T:Ord> Ord for @mut T {\n fn test() {\n     let x = @3;\n     let y = @3;\n-    fail_unless!((ptr_eq::<int>(x, x)));\n-    fail_unless!((ptr_eq::<int>(y, y)));\n-    fail_unless!((!ptr_eq::<int>(x, y)));\n-    fail_unless!((!ptr_eq::<int>(y, x)));\n+    assert!((ptr_eq::<int>(x, x)));\n+    assert!((ptr_eq::<int>(y, y)));\n+    assert!((!ptr_eq::<int>(x, y)));\n+    assert!((!ptr_eq::<int>(y, x)));\n }"}, {"sha": "e9639820e836b6c9a9d7c0617e31cca93c86a862", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -38,7 +38,7 @@ pub fn Mut<T>(t: T) -> Mut<T> {\n pub fn unwrap<T>(m: Mut<T>) -> T {\n     // Borrowck should prevent us from calling unwrap while the value\n     // is in use, as that would be a move from a borrowed value.\n-    fail_unless!((m.mode as uint) == (ReadOnly as uint));\n+    assert!((m.mode as uint) == (ReadOnly as uint));\n     let Data {value: value, mode: _} = m;\n     value\n }\n@@ -103,9 +103,9 @@ pub fn test_const_in_mut() {\n     let m = @Mut(1);\n     do m.borrow_mut |p| {\n         do m.borrow_const |q| {\n-            fail_unless!(*p == *q);\n+            assert!(*p == *q);\n             *p += 1;\n-            fail_unless!(*p == *q);\n+            assert!(*p == *q);\n         }\n     }\n }\n@@ -115,9 +115,9 @@ pub fn test_mut_in_const() {\n     let m = @Mut(1);\n     do m.borrow_const |p| {\n         do m.borrow_mut |q| {\n-            fail_unless!(*p == *q);\n+            assert!(*p == *q);\n             *q += 1;\n-            fail_unless!(*p == *q);\n+            assert!(*p == *q);\n         }\n     }\n }\n@@ -127,7 +127,7 @@ pub fn test_imm_in_const() {\n     let m = @Mut(1);\n     do m.borrow_const |p| {\n         do m.borrow_imm |q| {\n-            fail_unless!(*p == *q);\n+            assert!(*p == *q);\n         }\n     }\n }\n@@ -137,7 +137,7 @@ pub fn test_const_in_imm() {\n     let m = @Mut(1);\n     do m.borrow_imm |p| {\n         do m.borrow_const |q| {\n-            fail_unless!(*p == *q);\n+            assert!(*p == *q);\n         }\n     }\n }"}, {"sha": "6361a6a5cb75eab21f1713df9f16ef29d073496d", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -585,56 +585,56 @@ pub fn test_num() {\n     let ten: f32 = num::cast(10);\n     let two: f32 = num::cast(2);\n \n-    fail_unless!((ten.add(&two)    == num::cast(12)));\n-    fail_unless!((ten.sub(&two)    == num::cast(8)));\n-    fail_unless!((ten.mul(&two)    == num::cast(20)));\n-    fail_unless!((ten.div(&two)    == num::cast(5)));\n-    fail_unless!((ten.modulo(&two) == num::cast(0)));\n+    assert!((ten.add(&two)    == num::cast(12)));\n+    assert!((ten.sub(&two)    == num::cast(8)));\n+    assert!((ten.mul(&two)    == num::cast(20)));\n+    assert!((ten.div(&two)    == num::cast(5)));\n+    assert!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]\n fn test_numcast() {\n-    fail_unless!((20u     == 20f32.to_uint()));\n-    fail_unless!((20u8    == 20f32.to_u8()));\n-    fail_unless!((20u16   == 20f32.to_u16()));\n-    fail_unless!((20u32   == 20f32.to_u32()));\n-    fail_unless!((20u64   == 20f32.to_u64()));\n-    fail_unless!((20i     == 20f32.to_int()));\n-    fail_unless!((20i8    == 20f32.to_i8()));\n-    fail_unless!((20i16   == 20f32.to_i16()));\n-    fail_unless!((20i32   == 20f32.to_i32()));\n-    fail_unless!((20i64   == 20f32.to_i64()));\n-    fail_unless!((20f     == 20f32.to_float()));\n-    fail_unless!((20f32   == 20f32.to_f32()));\n-    fail_unless!((20f64   == 20f32.to_f64()));\n-\n-    fail_unless!((20f32 == NumCast::from(20u)));\n-    fail_unless!((20f32 == NumCast::from(20u8)));\n-    fail_unless!((20f32 == NumCast::from(20u16)));\n-    fail_unless!((20f32 == NumCast::from(20u32)));\n-    fail_unless!((20f32 == NumCast::from(20u64)));\n-    fail_unless!((20f32 == NumCast::from(20i)));\n-    fail_unless!((20f32 == NumCast::from(20i8)));\n-    fail_unless!((20f32 == NumCast::from(20i16)));\n-    fail_unless!((20f32 == NumCast::from(20i32)));\n-    fail_unless!((20f32 == NumCast::from(20i64)));\n-    fail_unless!((20f32 == NumCast::from(20f)));\n-    fail_unless!((20f32 == NumCast::from(20f32)));\n-    fail_unless!((20f32 == NumCast::from(20f64)));\n-\n-    fail_unless!((20f32 == num::cast(20u)));\n-    fail_unless!((20f32 == num::cast(20u8)));\n-    fail_unless!((20f32 == num::cast(20u16)));\n-    fail_unless!((20f32 == num::cast(20u32)));\n-    fail_unless!((20f32 == num::cast(20u64)));\n-    fail_unless!((20f32 == num::cast(20i)));\n-    fail_unless!((20f32 == num::cast(20i8)));\n-    fail_unless!((20f32 == num::cast(20i16)));\n-    fail_unless!((20f32 == num::cast(20i32)));\n-    fail_unless!((20f32 == num::cast(20i64)));\n-    fail_unless!((20f32 == num::cast(20f)));\n-    fail_unless!((20f32 == num::cast(20f32)));\n-    fail_unless!((20f32 == num::cast(20f64)));\n+    assert!((20u     == 20f32.to_uint()));\n+    assert!((20u8    == 20f32.to_u8()));\n+    assert!((20u16   == 20f32.to_u16()));\n+    assert!((20u32   == 20f32.to_u32()));\n+    assert!((20u64   == 20f32.to_u64()));\n+    assert!((20i     == 20f32.to_int()));\n+    assert!((20i8    == 20f32.to_i8()));\n+    assert!((20i16   == 20f32.to_i16()));\n+    assert!((20i32   == 20f32.to_i32()));\n+    assert!((20i64   == 20f32.to_i64()));\n+    assert!((20f     == 20f32.to_float()));\n+    assert!((20f32   == 20f32.to_f32()));\n+    assert!((20f64   == 20f32.to_f64()));\n+\n+    assert!((20f32 == NumCast::from(20u)));\n+    assert!((20f32 == NumCast::from(20u8)));\n+    assert!((20f32 == NumCast::from(20u16)));\n+    assert!((20f32 == NumCast::from(20u32)));\n+    assert!((20f32 == NumCast::from(20u64)));\n+    assert!((20f32 == NumCast::from(20i)));\n+    assert!((20f32 == NumCast::from(20i8)));\n+    assert!((20f32 == NumCast::from(20i16)));\n+    assert!((20f32 == NumCast::from(20i32)));\n+    assert!((20f32 == NumCast::from(20i64)));\n+    assert!((20f32 == NumCast::from(20f)));\n+    assert!((20f32 == NumCast::from(20f32)));\n+    assert!((20f32 == NumCast::from(20f64)));\n+\n+    assert!((20f32 == num::cast(20u)));\n+    assert!((20f32 == num::cast(20u8)));\n+    assert!((20f32 == num::cast(20u16)));\n+    assert!((20f32 == num::cast(20u32)));\n+    assert!((20f32 == num::cast(20u64)));\n+    assert!((20f32 == num::cast(20i)));\n+    assert!((20f32 == num::cast(20i8)));\n+    assert!((20f32 == num::cast(20i16)));\n+    assert!((20f32 == num::cast(20i32)));\n+    assert!((20f32 == num::cast(20i64)));\n+    assert!((20f32 == num::cast(20f)));\n+    assert!((20f32 == num::cast(20f32)));\n+    assert!((20f32 == num::cast(20f64)));\n }\n \n //"}, {"sha": "9e731e61ec49eb9db95bda9484299bb29ba2f41f", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -607,56 +607,56 @@ pub fn test_num() {\n     let ten: f64 = num::cast(10);\n     let two: f64 = num::cast(2);\n \n-    fail_unless!((ten.add(&two)    == num::cast(12)));\n-    fail_unless!((ten.sub(&two)    == num::cast(8)));\n-    fail_unless!((ten.mul(&two)    == num::cast(20)));\n-    fail_unless!((ten.div(&two)    == num::cast(5)));\n-    fail_unless!((ten.modulo(&two) == num::cast(0)));\n+    assert!((ten.add(&two)    == num::cast(12)));\n+    assert!((ten.sub(&two)    == num::cast(8)));\n+    assert!((ten.mul(&two)    == num::cast(20)));\n+    assert!((ten.div(&two)    == num::cast(5)));\n+    assert!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]\n fn test_numcast() {\n-    fail_unless!((20u   == 20f64.to_uint()));\n-    fail_unless!((20u8  == 20f64.to_u8()));\n-    fail_unless!((20u16 == 20f64.to_u16()));\n-    fail_unless!((20u32 == 20f64.to_u32()));\n-    fail_unless!((20u64 == 20f64.to_u64()));\n-    fail_unless!((20i   == 20f64.to_int()));\n-    fail_unless!((20i8  == 20f64.to_i8()));\n-    fail_unless!((20i16 == 20f64.to_i16()));\n-    fail_unless!((20i32 == 20f64.to_i32()));\n-    fail_unless!((20i64 == 20f64.to_i64()));\n-    fail_unless!((20f   == 20f64.to_float()));\n-    fail_unless!((20f32 == 20f64.to_f32()));\n-    fail_unless!((20f64 == 20f64.to_f64()));\n-\n-    fail_unless!((20f64 == NumCast::from(20u)));\n-    fail_unless!((20f64 == NumCast::from(20u8)));\n-    fail_unless!((20f64 == NumCast::from(20u16)));\n-    fail_unless!((20f64 == NumCast::from(20u32)));\n-    fail_unless!((20f64 == NumCast::from(20u64)));\n-    fail_unless!((20f64 == NumCast::from(20i)));\n-    fail_unless!((20f64 == NumCast::from(20i8)));\n-    fail_unless!((20f64 == NumCast::from(20i16)));\n-    fail_unless!((20f64 == NumCast::from(20i32)));\n-    fail_unless!((20f64 == NumCast::from(20i64)));\n-    fail_unless!((20f64 == NumCast::from(20f)));\n-    fail_unless!((20f64 == NumCast::from(20f32)));\n-    fail_unless!((20f64 == NumCast::from(20f64)));\n-\n-    fail_unless!((20f64 == num::cast(20u)));\n-    fail_unless!((20f64 == num::cast(20u8)));\n-    fail_unless!((20f64 == num::cast(20u16)));\n-    fail_unless!((20f64 == num::cast(20u32)));\n-    fail_unless!((20f64 == num::cast(20u64)));\n-    fail_unless!((20f64 == num::cast(20i)));\n-    fail_unless!((20f64 == num::cast(20i8)));\n-    fail_unless!((20f64 == num::cast(20i16)));\n-    fail_unless!((20f64 == num::cast(20i32)));\n-    fail_unless!((20f64 == num::cast(20i64)));\n-    fail_unless!((20f64 == num::cast(20f)));\n-    fail_unless!((20f64 == num::cast(20f32)));\n-    fail_unless!((20f64 == num::cast(20f64)));\n+    assert!((20u   == 20f64.to_uint()));\n+    assert!((20u8  == 20f64.to_u8()));\n+    assert!((20u16 == 20f64.to_u16()));\n+    assert!((20u32 == 20f64.to_u32()));\n+    assert!((20u64 == 20f64.to_u64()));\n+    assert!((20i   == 20f64.to_int()));\n+    assert!((20i8  == 20f64.to_i8()));\n+    assert!((20i16 == 20f64.to_i16()));\n+    assert!((20i32 == 20f64.to_i32()));\n+    assert!((20i64 == 20f64.to_i64()));\n+    assert!((20f   == 20f64.to_float()));\n+    assert!((20f32 == 20f64.to_f32()));\n+    assert!((20f64 == 20f64.to_f64()));\n+\n+    assert!((20f64 == NumCast::from(20u)));\n+    assert!((20f64 == NumCast::from(20u8)));\n+    assert!((20f64 == NumCast::from(20u16)));\n+    assert!((20f64 == NumCast::from(20u32)));\n+    assert!((20f64 == NumCast::from(20u64)));\n+    assert!((20f64 == NumCast::from(20i)));\n+    assert!((20f64 == NumCast::from(20i8)));\n+    assert!((20f64 == NumCast::from(20i16)));\n+    assert!((20f64 == NumCast::from(20i32)));\n+    assert!((20f64 == NumCast::from(20i64)));\n+    assert!((20f64 == NumCast::from(20f)));\n+    assert!((20f64 == NumCast::from(20f32)));\n+    assert!((20f64 == NumCast::from(20f64)));\n+\n+    assert!((20f64 == num::cast(20u)));\n+    assert!((20f64 == num::cast(20u8)));\n+    assert!((20f64 == num::cast(20u16)));\n+    assert!((20f64 == num::cast(20u32)));\n+    assert!((20f64 == num::cast(20u64)));\n+    assert!((20f64 == num::cast(20i)));\n+    assert!((20f64 == num::cast(20i8)));\n+    assert!((20f64 == num::cast(20i16)));\n+    assert!((20f64 == num::cast(20i32)));\n+    assert!((20f64 == num::cast(20i64)));\n+    assert!((20f64 == num::cast(20f)));\n+    assert!((20f64 == num::cast(20f32)));\n+    assert!((20f64 == num::cast(20f64)));\n }\n \n //"}, {"sha": "c80d52f496b49e9f6456922b29c6a14d7f99e8e2", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 169, "deletions": 169, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -181,7 +181,7 @@ pub fn to_str_exact(num: float, digits: uint) -> ~str {\n #[test]\n pub fn test_to_str_exact_do_decimal() {\n     let s = to_str_exact(5.0, 4u);\n-    fail_unless!(s == ~\"5.0000\");\n+    assert!(s == ~\"5.0000\");\n }\n \n /**\n@@ -501,248 +501,248 @@ impl ops::Neg<float> for float {\n \n #[test]\n pub fn test_from_str() {\n-   fail_unless!(from_str(~\"3\") == Some(3.));\n-   fail_unless!(from_str(~\"3.14\") == Some(3.14));\n-   fail_unless!(from_str(~\"+3.14\") == Some(3.14));\n-   fail_unless!(from_str(~\"-3.14\") == Some(-3.14));\n-   fail_unless!(from_str(~\"2.5E10\") == Some(25000000000.));\n-   fail_unless!(from_str(~\"2.5e10\") == Some(25000000000.));\n-   fail_unless!(from_str(~\"25000000000.E-10\") == Some(2.5));\n-   fail_unless!(from_str(~\".\") == Some(0.));\n-   fail_unless!(from_str(~\".e1\") == Some(0.));\n-   fail_unless!(from_str(~\".e-1\") == Some(0.));\n-   fail_unless!(from_str(~\"5.\") == Some(5.));\n-   fail_unless!(from_str(~\".5\") == Some(0.5));\n-   fail_unless!(from_str(~\"0.5\") == Some(0.5));\n-   fail_unless!(from_str(~\"-.5\") == Some(-0.5));\n-   fail_unless!(from_str(~\"-5\") == Some(-5.));\n-   fail_unless!(from_str(~\"inf\") == Some(infinity));\n-   fail_unless!(from_str(~\"+inf\") == Some(infinity));\n-   fail_unless!(from_str(~\"-inf\") == Some(neg_infinity));\n+   assert!(from_str(~\"3\") == Some(3.));\n+   assert!(from_str(~\"3.14\") == Some(3.14));\n+   assert!(from_str(~\"+3.14\") == Some(3.14));\n+   assert!(from_str(~\"-3.14\") == Some(-3.14));\n+   assert!(from_str(~\"2.5E10\") == Some(25000000000.));\n+   assert!(from_str(~\"2.5e10\") == Some(25000000000.));\n+   assert!(from_str(~\"25000000000.E-10\") == Some(2.5));\n+   assert!(from_str(~\".\") == Some(0.));\n+   assert!(from_str(~\".e1\") == Some(0.));\n+   assert!(from_str(~\".e-1\") == Some(0.));\n+   assert!(from_str(~\"5.\") == Some(5.));\n+   assert!(from_str(~\".5\") == Some(0.5));\n+   assert!(from_str(~\"0.5\") == Some(0.5));\n+   assert!(from_str(~\"-.5\") == Some(-0.5));\n+   assert!(from_str(~\"-5\") == Some(-5.));\n+   assert!(from_str(~\"inf\") == Some(infinity));\n+   assert!(from_str(~\"+inf\") == Some(infinity));\n+   assert!(from_str(~\"-inf\") == Some(neg_infinity));\n    // note: NaN != NaN, hence this slightly complex test\n    match from_str(~\"NaN\") {\n-       Some(f) => fail_unless!(is_NaN(f)),\n+       Some(f) => assert!(is_NaN(f)),\n        None => fail!()\n    }\n    // note: -0 == 0, hence these slightly more complex tests\n    match from_str(~\"-0\") {\n-       Some(v) if is_zero(v) => fail_unless!(is_negative(v)),\n+       Some(v) if is_zero(v) => assert!(is_negative(v)),\n        _ => fail!()\n    }\n    match from_str(~\"0\") {\n-       Some(v) if is_zero(v) => fail_unless!(is_positive(v)),\n+       Some(v) if is_zero(v) => assert!(is_positive(v)),\n        _ => fail!()\n    }\n \n-   fail_unless!(from_str(~\"\").is_none());\n-   fail_unless!(from_str(~\"x\").is_none());\n-   fail_unless!(from_str(~\" \").is_none());\n-   fail_unless!(from_str(~\"   \").is_none());\n-   fail_unless!(from_str(~\"e\").is_none());\n-   fail_unless!(from_str(~\"E\").is_none());\n-   fail_unless!(from_str(~\"E1\").is_none());\n-   fail_unless!(from_str(~\"1e1e1\").is_none());\n-   fail_unless!(from_str(~\"1e1.1\").is_none());\n-   fail_unless!(from_str(~\"1e1-1\").is_none());\n+   assert!(from_str(~\"\").is_none());\n+   assert!(from_str(~\"x\").is_none());\n+   assert!(from_str(~\" \").is_none());\n+   assert!(from_str(~\"   \").is_none());\n+   assert!(from_str(~\"e\").is_none());\n+   assert!(from_str(~\"E\").is_none());\n+   assert!(from_str(~\"E1\").is_none());\n+   assert!(from_str(~\"1e1e1\").is_none());\n+   assert!(from_str(~\"1e1.1\").is_none());\n+   assert!(from_str(~\"1e1-1\").is_none());\n }\n \n #[test]\n pub fn test_from_str_hex() {\n-   fail_unless!(from_str_hex(~\"a4\") == Some(164.));\n-   fail_unless!(from_str_hex(~\"a4.fe\") == Some(164.9921875));\n-   fail_unless!(from_str_hex(~\"-a4.fe\") == Some(-164.9921875));\n-   fail_unless!(from_str_hex(~\"+a4.fe\") == Some(164.9921875));\n-   fail_unless!(from_str_hex(~\"ff0P4\") == Some(0xff00 as float));\n-   fail_unless!(from_str_hex(~\"ff0p4\") == Some(0xff00 as float));\n-   fail_unless!(from_str_hex(~\"ff0p-4\") == Some(0xff as float));\n-   fail_unless!(from_str_hex(~\".\") == Some(0.));\n-   fail_unless!(from_str_hex(~\".p1\") == Some(0.));\n-   fail_unless!(from_str_hex(~\".p-1\") == Some(0.));\n-   fail_unless!(from_str_hex(~\"f.\") == Some(15.));\n-   fail_unless!(from_str_hex(~\".f\") == Some(0.9375));\n-   fail_unless!(from_str_hex(~\"0.f\") == Some(0.9375));\n-   fail_unless!(from_str_hex(~\"-.f\") == Some(-0.9375));\n-   fail_unless!(from_str_hex(~\"-f\") == Some(-15.));\n-   fail_unless!(from_str_hex(~\"inf\") == Some(infinity));\n-   fail_unless!(from_str_hex(~\"+inf\") == Some(infinity));\n-   fail_unless!(from_str_hex(~\"-inf\") == Some(neg_infinity));\n+   assert!(from_str_hex(~\"a4\") == Some(164.));\n+   assert!(from_str_hex(~\"a4.fe\") == Some(164.9921875));\n+   assert!(from_str_hex(~\"-a4.fe\") == Some(-164.9921875));\n+   assert!(from_str_hex(~\"+a4.fe\") == Some(164.9921875));\n+   assert!(from_str_hex(~\"ff0P4\") == Some(0xff00 as float));\n+   assert!(from_str_hex(~\"ff0p4\") == Some(0xff00 as float));\n+   assert!(from_str_hex(~\"ff0p-4\") == Some(0xff as float));\n+   assert!(from_str_hex(~\".\") == Some(0.));\n+   assert!(from_str_hex(~\".p1\") == Some(0.));\n+   assert!(from_str_hex(~\".p-1\") == Some(0.));\n+   assert!(from_str_hex(~\"f.\") == Some(15.));\n+   assert!(from_str_hex(~\".f\") == Some(0.9375));\n+   assert!(from_str_hex(~\"0.f\") == Some(0.9375));\n+   assert!(from_str_hex(~\"-.f\") == Some(-0.9375));\n+   assert!(from_str_hex(~\"-f\") == Some(-15.));\n+   assert!(from_str_hex(~\"inf\") == Some(infinity));\n+   assert!(from_str_hex(~\"+inf\") == Some(infinity));\n+   assert!(from_str_hex(~\"-inf\") == Some(neg_infinity));\n    // note: NaN != NaN, hence this slightly complex test\n    match from_str_hex(~\"NaN\") {\n-       Some(f) => fail_unless!(is_NaN(f)),\n+       Some(f) => assert!(is_NaN(f)),\n        None => fail!()\n    }\n    // note: -0 == 0, hence these slightly more complex tests\n    match from_str_hex(~\"-0\") {\n-       Some(v) if is_zero(v) => fail_unless!(is_negative(v)),\n+       Some(v) if is_zero(v) => assert!(is_negative(v)),\n        _ => fail!()\n    }\n    match from_str_hex(~\"0\") {\n-       Some(v) if is_zero(v) => fail_unless!(is_positive(v)),\n+       Some(v) if is_zero(v) => assert!(is_positive(v)),\n        _ => fail!()\n    }\n-   fail_unless!(from_str_hex(~\"e\") == Some(14.));\n-   fail_unless!(from_str_hex(~\"E\") == Some(14.));\n-   fail_unless!(from_str_hex(~\"E1\") == Some(225.));\n-   fail_unless!(from_str_hex(~\"1e1e1\") == Some(123361.));\n-   fail_unless!(from_str_hex(~\"1e1.1\") == Some(481.0625));\n-\n-   fail_unless!(from_str_hex(~\"\").is_none());\n-   fail_unless!(from_str_hex(~\"x\").is_none());\n-   fail_unless!(from_str_hex(~\" \").is_none());\n-   fail_unless!(from_str_hex(~\"   \").is_none());\n-   fail_unless!(from_str_hex(~\"p\").is_none());\n-   fail_unless!(from_str_hex(~\"P\").is_none());\n-   fail_unless!(from_str_hex(~\"P1\").is_none());\n-   fail_unless!(from_str_hex(~\"1p1p1\").is_none());\n-   fail_unless!(from_str_hex(~\"1p1.1\").is_none());\n-   fail_unless!(from_str_hex(~\"1p1-1\").is_none());\n+   assert!(from_str_hex(~\"e\") == Some(14.));\n+   assert!(from_str_hex(~\"E\") == Some(14.));\n+   assert!(from_str_hex(~\"E1\") == Some(225.));\n+   assert!(from_str_hex(~\"1e1e1\") == Some(123361.));\n+   assert!(from_str_hex(~\"1e1.1\") == Some(481.0625));\n+\n+   assert!(from_str_hex(~\"\").is_none());\n+   assert!(from_str_hex(~\"x\").is_none());\n+   assert!(from_str_hex(~\" \").is_none());\n+   assert!(from_str_hex(~\"   \").is_none());\n+   assert!(from_str_hex(~\"p\").is_none());\n+   assert!(from_str_hex(~\"P\").is_none());\n+   assert!(from_str_hex(~\"P1\").is_none());\n+   assert!(from_str_hex(~\"1p1p1\").is_none());\n+   assert!(from_str_hex(~\"1p1.1\").is_none());\n+   assert!(from_str_hex(~\"1p1-1\").is_none());\n }\n \n #[test]\n pub fn test_to_str_hex() {\n-   fail_unless!(to_str_hex(164.) == ~\"a4\");\n-   fail_unless!(to_str_hex(164.9921875) == ~\"a4.fe\");\n-   fail_unless!(to_str_hex(-164.9921875) == ~\"-a4.fe\");\n-   fail_unless!(to_str_hex(0xff00 as float) == ~\"ff00\");\n-   fail_unless!(to_str_hex(-(0xff00 as float)) == ~\"-ff00\");\n-   fail_unless!(to_str_hex(0.) == ~\"0\");\n-   fail_unless!(to_str_hex(15.) == ~\"f\");\n-   fail_unless!(to_str_hex(-15.) == ~\"-f\");\n-   fail_unless!(to_str_hex(0.9375) == ~\"0.f\");\n-   fail_unless!(to_str_hex(-0.9375) == ~\"-0.f\");\n-   fail_unless!(to_str_hex(infinity) == ~\"inf\");\n-   fail_unless!(to_str_hex(neg_infinity) == ~\"-inf\");\n-   fail_unless!(to_str_hex(NaN) == ~\"NaN\");\n-   fail_unless!(to_str_hex(0.) == ~\"0\");\n-   fail_unless!(to_str_hex(-0.) == ~\"-0\");\n+   assert!(to_str_hex(164.) == ~\"a4\");\n+   assert!(to_str_hex(164.9921875) == ~\"a4.fe\");\n+   assert!(to_str_hex(-164.9921875) == ~\"-a4.fe\");\n+   assert!(to_str_hex(0xff00 as float) == ~\"ff00\");\n+   assert!(to_str_hex(-(0xff00 as float)) == ~\"-ff00\");\n+   assert!(to_str_hex(0.) == ~\"0\");\n+   assert!(to_str_hex(15.) == ~\"f\");\n+   assert!(to_str_hex(-15.) == ~\"-f\");\n+   assert!(to_str_hex(0.9375) == ~\"0.f\");\n+   assert!(to_str_hex(-0.9375) == ~\"-0.f\");\n+   assert!(to_str_hex(infinity) == ~\"inf\");\n+   assert!(to_str_hex(neg_infinity) == ~\"-inf\");\n+   assert!(to_str_hex(NaN) == ~\"NaN\");\n+   assert!(to_str_hex(0.) == ~\"0\");\n+   assert!(to_str_hex(-0.) == ~\"-0\");\n }\n \n #[test]\n pub fn test_to_str_radix() {\n-   fail_unless!(to_str_radix(36., 36u) == ~\"10\");\n-   fail_unless!(to_str_radix(8.125, 2u) == ~\"1000.001\");\n+   assert!(to_str_radix(36., 36u) == ~\"10\");\n+   assert!(to_str_radix(8.125, 2u) == ~\"1000.001\");\n }\n \n #[test]\n pub fn test_from_str_radix() {\n-   fail_unless!(from_str_radix(~\"10\", 36u) == Some(36.));\n-   fail_unless!(from_str_radix(~\"1000.001\", 2u) == Some(8.125));\n+   assert!(from_str_radix(~\"10\", 36u) == Some(36.));\n+   assert!(from_str_radix(~\"1000.001\", 2u) == Some(8.125));\n }\n \n #[test]\n pub fn test_positive() {\n-  fail_unless!((is_positive(infinity)));\n-  fail_unless!((is_positive(1.)));\n-  fail_unless!((is_positive(0.)));\n-  fail_unless!((!is_positive(-1.)));\n-  fail_unless!((!is_positive(neg_infinity)));\n-  fail_unless!((!is_positive(1./neg_infinity)));\n-  fail_unless!((!is_positive(NaN)));\n+  assert!((is_positive(infinity)));\n+  assert!((is_positive(1.)));\n+  assert!((is_positive(0.)));\n+  assert!((!is_positive(-1.)));\n+  assert!((!is_positive(neg_infinity)));\n+  assert!((!is_positive(1./neg_infinity)));\n+  assert!((!is_positive(NaN)));\n }\n \n #[test]\n pub fn test_negative() {\n-  fail_unless!((!is_negative(infinity)));\n-  fail_unless!((!is_negative(1.)));\n-  fail_unless!((!is_negative(0.)));\n-  fail_unless!((is_negative(-1.)));\n-  fail_unless!((is_negative(neg_infinity)));\n-  fail_unless!((is_negative(1./neg_infinity)));\n-  fail_unless!((!is_negative(NaN)));\n+  assert!((!is_negative(infinity)));\n+  assert!((!is_negative(1.)));\n+  assert!((!is_negative(0.)));\n+  assert!((is_negative(-1.)));\n+  assert!((is_negative(neg_infinity)));\n+  assert!((is_negative(1./neg_infinity)));\n+  assert!((!is_negative(NaN)));\n }\n \n #[test]\n pub fn test_nonpositive() {\n-  fail_unless!((!is_nonpositive(infinity)));\n-  fail_unless!((!is_nonpositive(1.)));\n-  fail_unless!((!is_nonpositive(0.)));\n-  fail_unless!((is_nonpositive(-1.)));\n-  fail_unless!((is_nonpositive(neg_infinity)));\n-  fail_unless!((is_nonpositive(1./neg_infinity)));\n-  fail_unless!((!is_nonpositive(NaN)));\n+  assert!((!is_nonpositive(infinity)));\n+  assert!((!is_nonpositive(1.)));\n+  assert!((!is_nonpositive(0.)));\n+  assert!((is_nonpositive(-1.)));\n+  assert!((is_nonpositive(neg_infinity)));\n+  assert!((is_nonpositive(1./neg_infinity)));\n+  assert!((!is_nonpositive(NaN)));\n }\n \n #[test]\n pub fn test_nonnegative() {\n-  fail_unless!((is_nonnegative(infinity)));\n-  fail_unless!((is_nonnegative(1.)));\n-  fail_unless!((is_nonnegative(0.)));\n-  fail_unless!((!is_nonnegative(-1.)));\n-  fail_unless!((!is_nonnegative(neg_infinity)));\n-  fail_unless!((!is_nonnegative(1./neg_infinity)));\n-  fail_unless!((!is_nonnegative(NaN)));\n+  assert!((is_nonnegative(infinity)));\n+  assert!((is_nonnegative(1.)));\n+  assert!((is_nonnegative(0.)));\n+  assert!((!is_nonnegative(-1.)));\n+  assert!((!is_nonnegative(neg_infinity)));\n+  assert!((!is_nonnegative(1./neg_infinity)));\n+  assert!((!is_nonnegative(NaN)));\n }\n \n #[test]\n pub fn test_to_str_inf() {\n-    fail_unless!(to_str_digits(infinity, 10u) == ~\"inf\");\n-    fail_unless!(to_str_digits(-infinity, 10u) == ~\"-inf\");\n+    assert!(to_str_digits(infinity, 10u) == ~\"inf\");\n+    assert!(to_str_digits(-infinity, 10u) == ~\"-inf\");\n }\n \n #[test]\n pub fn test_round() {\n-    fail_unless!(round(5.8) == 6.0);\n-    fail_unless!(round(5.2) == 5.0);\n-    fail_unless!(round(3.0) == 3.0);\n-    fail_unless!(round(2.5) == 3.0);\n-    fail_unless!(round(-3.5) == -4.0);\n+    assert!(round(5.8) == 6.0);\n+    assert!(round(5.2) == 5.0);\n+    assert!(round(3.0) == 3.0);\n+    assert!(round(2.5) == 3.0);\n+    assert!(round(-3.5) == -4.0);\n }\n \n #[test]\n pub fn test_num() {\n     let ten: float = num::cast(10);\n     let two: float = num::cast(2);\n \n-    fail_unless!((ten.add(&two)    == num::cast(12)));\n-    fail_unless!((ten.sub(&two)    == num::cast(8)));\n-    fail_unless!((ten.mul(&two)    == num::cast(20)));\n-    fail_unless!((ten.div(&two)    == num::cast(5)));\n-    fail_unless!((ten.modulo(&two) == num::cast(0)));\n+    assert!((ten.add(&two)    == num::cast(12)));\n+    assert!((ten.sub(&two)    == num::cast(8)));\n+    assert!((ten.mul(&two)    == num::cast(20)));\n+    assert!((ten.div(&two)    == num::cast(5)));\n+    assert!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]\n fn test_numcast() {\n-    fail_unless!((20u   == 20f.to_uint()));\n-    fail_unless!((20u8  == 20f.to_u8()));\n-    fail_unless!((20u16 == 20f.to_u16()));\n-    fail_unless!((20u32 == 20f.to_u32()));\n-    fail_unless!((20u64 == 20f.to_u64()));\n-    fail_unless!((20i   == 20f.to_int()));\n-    fail_unless!((20i8  == 20f.to_i8()));\n-    fail_unless!((20i16 == 20f.to_i16()));\n-    fail_unless!((20i32 == 20f.to_i32()));\n-    fail_unless!((20i64 == 20f.to_i64()));\n-    fail_unless!((20f   == 20f.to_float()));\n-    fail_unless!((20f32 == 20f.to_f32()));\n-    fail_unless!((20f64 == 20f.to_f64()));\n-\n-    fail_unless!((20f == NumCast::from(20u)));\n-    fail_unless!((20f == NumCast::from(20u8)));\n-    fail_unless!((20f == NumCast::from(20u16)));\n-    fail_unless!((20f == NumCast::from(20u32)));\n-    fail_unless!((20f == NumCast::from(20u64)));\n-    fail_unless!((20f == NumCast::from(20i)));\n-    fail_unless!((20f == NumCast::from(20i8)));\n-    fail_unless!((20f == NumCast::from(20i16)));\n-    fail_unless!((20f == NumCast::from(20i32)));\n-    fail_unless!((20f == NumCast::from(20i64)));\n-    fail_unless!((20f == NumCast::from(20f)));\n-    fail_unless!((20f == NumCast::from(20f32)));\n-    fail_unless!((20f == NumCast::from(20f64)));\n-\n-    fail_unless!((20f == num::cast(20u)));\n-    fail_unless!((20f == num::cast(20u8)));\n-    fail_unless!((20f == num::cast(20u16)));\n-    fail_unless!((20f == num::cast(20u32)));\n-    fail_unless!((20f == num::cast(20u64)));\n-    fail_unless!((20f == num::cast(20i)));\n-    fail_unless!((20f == num::cast(20i8)));\n-    fail_unless!((20f == num::cast(20i16)));\n-    fail_unless!((20f == num::cast(20i32)));\n-    fail_unless!((20f == num::cast(20i64)));\n-    fail_unless!((20f == num::cast(20f)));\n-    fail_unless!((20f == num::cast(20f32)));\n-    fail_unless!((20f == num::cast(20f64)));\n+    assert!((20u   == 20f.to_uint()));\n+    assert!((20u8  == 20f.to_u8()));\n+    assert!((20u16 == 20f.to_u16()));\n+    assert!((20u32 == 20f.to_u32()));\n+    assert!((20u64 == 20f.to_u64()));\n+    assert!((20i   == 20f.to_int()));\n+    assert!((20i8  == 20f.to_i8()));\n+    assert!((20i16 == 20f.to_i16()));\n+    assert!((20i32 == 20f.to_i32()));\n+    assert!((20i64 == 20f.to_i64()));\n+    assert!((20f   == 20f.to_float()));\n+    assert!((20f32 == 20f.to_f32()));\n+    assert!((20f64 == 20f.to_f64()));\n+\n+    assert!((20f == NumCast::from(20u)));\n+    assert!((20f == NumCast::from(20u8)));\n+    assert!((20f == NumCast::from(20u16)));\n+    assert!((20f == NumCast::from(20u32)));\n+    assert!((20f == NumCast::from(20u64)));\n+    assert!((20f == NumCast::from(20i)));\n+    assert!((20f == NumCast::from(20i8)));\n+    assert!((20f == NumCast::from(20i16)));\n+    assert!((20f == NumCast::from(20i32)));\n+    assert!((20f == NumCast::from(20i64)));\n+    assert!((20f == NumCast::from(20f)));\n+    assert!((20f == NumCast::from(20f32)));\n+    assert!((20f == NumCast::from(20f64)));\n+\n+    assert!((20f == num::cast(20u)));\n+    assert!((20f == num::cast(20u8)));\n+    assert!((20f == num::cast(20u16)));\n+    assert!((20f == num::cast(20u32)));\n+    assert!((20f == num::cast(20u64)));\n+    assert!((20f == num::cast(20i)));\n+    assert!((20f == num::cast(20i8)));\n+    assert!((20f == num::cast(20i16)));\n+    assert!((20f == num::cast(20i32)));\n+    assert!((20f == num::cast(20i64)));\n+    assert!((20f == num::cast(20f)));\n+    assert!((20f == num::cast(20f32)));\n+    assert!((20f == num::cast(20f64)));\n }\n \n "}, {"sha": "a3cbd9fe7e3a4ddc3825030acb62c0e16f6f41c3", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -41,18 +41,18 @@ pub fn div(x: T, y: T) -> T { x / y }\n  *\n  * # Examples\n  * ~~~\n- * fail_unless!(int::rem(5 / 2) == 1);\n+ * assert!(int::rem(5 / 2) == 1);\n  * ~~~\n  *\n  * When faced with negative numbers, the result copies the sign of the\n  * dividend.\n  *\n  * ~~~\n- * fail_unless!(int::rem(2 / -3) ==  2);\n+ * assert!(int::rem(2 / -3) ==  2);\n  * ~~~\n  *\n  * ~~~\n- * fail_unless!(int::rem(-2 / 3) ==  -2);\n+ * assert!(int::rem(-2 / 3) ==  -2);\n  * ~~~\n  *\n  */\n@@ -95,7 +95,7 @@ pub fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n  * for int::range(1, 5) |i| {\n  *     sum += i;\n  * }\n- * fail_unless!(sum == 10);\n+ * assert!(sum == 10);\n  * ~~~\n  */\n #[inline(always)]\n@@ -275,134 +275,134 @@ impl ToStrRadix for T {\n \n #[test]\n fn test_from_str() {\n-    fail_unless!(from_str(~\"0\") == Some(0 as T));\n-    fail_unless!(from_str(~\"3\") == Some(3 as T));\n-    fail_unless!(from_str(~\"10\") == Some(10 as T));\n-    fail_unless!(i32::from_str(~\"123456789\") == Some(123456789 as i32));\n-    fail_unless!(from_str(~\"00100\") == Some(100 as T));\n+    assert!(from_str(~\"0\") == Some(0 as T));\n+    assert!(from_str(~\"3\") == Some(3 as T));\n+    assert!(from_str(~\"10\") == Some(10 as T));\n+    assert!(i32::from_str(~\"123456789\") == Some(123456789 as i32));\n+    assert!(from_str(~\"00100\") == Some(100 as T));\n \n-    fail_unless!(from_str(~\"-1\") == Some(-1 as T));\n-    fail_unless!(from_str(~\"-3\") == Some(-3 as T));\n-    fail_unless!(from_str(~\"-10\") == Some(-10 as T));\n-    fail_unless!(i32::from_str(~\"-123456789\") == Some(-123456789 as i32));\n-    fail_unless!(from_str(~\"-00100\") == Some(-100 as T));\n+    assert!(from_str(~\"-1\") == Some(-1 as T));\n+    assert!(from_str(~\"-3\") == Some(-3 as T));\n+    assert!(from_str(~\"-10\") == Some(-10 as T));\n+    assert!(i32::from_str(~\"-123456789\") == Some(-123456789 as i32));\n+    assert!(from_str(~\"-00100\") == Some(-100 as T));\n \n-    fail_unless!(from_str(~\" \").is_none());\n-    fail_unless!(from_str(~\"x\").is_none());\n+    assert!(from_str(~\" \").is_none());\n+    assert!(from_str(~\"x\").is_none());\n }\n \n #[test]\n fn test_parse_bytes() {\n     use str::to_bytes;\n-    fail_unless!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123 as T));\n-    fail_unless!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9 as T));\n-    fail_unless!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83 as T));\n-    fail_unless!(i32::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291 as i32));\n-    fail_unless!(i32::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n+    assert!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123 as T));\n+    assert!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9 as T));\n+    assert!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83 as T));\n+    assert!(i32::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291 as i32));\n+    assert!(i32::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n                  Some(65535 as i32));\n-    fail_unless!(i32::parse_bytes(to_bytes(~\"FFFF\"), 16u) ==\n+    assert!(i32::parse_bytes(to_bytes(~\"FFFF\"), 16u) ==\n                  Some(65535 as i32));\n-    fail_unless!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35 as T));\n-    fail_unless!(parse_bytes(to_bytes(~\"Z\"), 36u) == Some(35 as T));\n+    assert!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35 as T));\n+    assert!(parse_bytes(to_bytes(~\"Z\"), 36u) == Some(35 as T));\n \n-    fail_unless!(parse_bytes(to_bytes(~\"-123\"), 10u) == Some(-123 as T));\n-    fail_unless!(parse_bytes(to_bytes(~\"-1001\"), 2u) == Some(-9 as T));\n-    fail_unless!(parse_bytes(to_bytes(~\"-123\"), 8u) == Some(-83 as T));\n-    fail_unless!(i32::parse_bytes(to_bytes(~\"-123\"), 16u) ==\n+    assert!(parse_bytes(to_bytes(~\"-123\"), 10u) == Some(-123 as T));\n+    assert!(parse_bytes(to_bytes(~\"-1001\"), 2u) == Some(-9 as T));\n+    assert!(parse_bytes(to_bytes(~\"-123\"), 8u) == Some(-83 as T));\n+    assert!(i32::parse_bytes(to_bytes(~\"-123\"), 16u) ==\n                  Some(-291 as i32));\n-    fail_unless!(i32::parse_bytes(to_bytes(~\"-ffff\"), 16u) ==\n+    assert!(i32::parse_bytes(to_bytes(~\"-ffff\"), 16u) ==\n                  Some(-65535 as i32));\n-    fail_unless!(i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u) ==\n+    assert!(i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u) ==\n                  Some(-65535 as i32));\n-    fail_unless!(parse_bytes(to_bytes(~\"-z\"), 36u) == Some(-35 as T));\n-    fail_unless!(parse_bytes(to_bytes(~\"-Z\"), 36u) == Some(-35 as T));\n+    assert!(parse_bytes(to_bytes(~\"-z\"), 36u) == Some(-35 as T));\n+    assert!(parse_bytes(to_bytes(~\"-Z\"), 36u) == Some(-35 as T));\n \n-    fail_unless!(parse_bytes(to_bytes(~\"Z\"), 35u).is_none());\n-    fail_unless!(parse_bytes(to_bytes(~\"-9\"), 2u).is_none());\n+    assert!(parse_bytes(to_bytes(~\"Z\"), 35u).is_none());\n+    assert!(parse_bytes(to_bytes(~\"-9\"), 2u).is_none());\n }\n \n #[test]\n fn test_to_str() {\n-    fail_unless!((to_str_radix(0 as T, 10u) == ~\"0\"));\n-    fail_unless!((to_str_radix(1 as T, 10u) == ~\"1\"));\n-    fail_unless!((to_str_radix(-1 as T, 10u) == ~\"-1\"));\n-    fail_unless!((to_str_radix(127 as T, 16u) == ~\"7f\"));\n-    fail_unless!((to_str_radix(100 as T, 10u) == ~\"100\"));\n+    assert!((to_str_radix(0 as T, 10u) == ~\"0\"));\n+    assert!((to_str_radix(1 as T, 10u) == ~\"1\"));\n+    assert!((to_str_radix(-1 as T, 10u) == ~\"-1\"));\n+    assert!((to_str_radix(127 as T, 16u) == ~\"7f\"));\n+    assert!((to_str_radix(100 as T, 10u) == ~\"100\"));\n \n }\n \n #[test]\n fn test_int_to_str_overflow() {\n     let mut i8_val: i8 = 127_i8;\n-    fail_unless!((i8::to_str(i8_val) == ~\"127\"));\n+    assert!((i8::to_str(i8_val) == ~\"127\"));\n \n     i8_val += 1 as i8;\n-    fail_unless!((i8::to_str(i8_val) == ~\"-128\"));\n+    assert!((i8::to_str(i8_val) == ~\"-128\"));\n \n     let mut i16_val: i16 = 32_767_i16;\n-    fail_unless!((i16::to_str(i16_val) == ~\"32767\"));\n+    assert!((i16::to_str(i16_val) == ~\"32767\"));\n \n     i16_val += 1 as i16;\n-    fail_unless!((i16::to_str(i16_val) == ~\"-32768\"));\n+    assert!((i16::to_str(i16_val) == ~\"-32768\"));\n \n     let mut i32_val: i32 = 2_147_483_647_i32;\n-    fail_unless!((i32::to_str(i32_val) == ~\"2147483647\"));\n+    assert!((i32::to_str(i32_val) == ~\"2147483647\"));\n \n     i32_val += 1 as i32;\n-    fail_unless!((i32::to_str(i32_val) == ~\"-2147483648\"));\n+    assert!((i32::to_str(i32_val) == ~\"-2147483648\"));\n \n     let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-    fail_unless!((i64::to_str(i64_val) == ~\"9223372036854775807\"));\n+    assert!((i64::to_str(i64_val) == ~\"9223372036854775807\"));\n \n     i64_val += 1 as i64;\n-    fail_unless!((i64::to_str(i64_val) == ~\"-9223372036854775808\"));\n+    assert!((i64::to_str(i64_val) == ~\"-9223372036854775808\"));\n }\n \n #[test]\n fn test_int_from_str_overflow() {\n     let mut i8_val: i8 = 127_i8;\n-    fail_unless!((i8::from_str(~\"127\") == Some(i8_val)));\n-    fail_unless!((i8::from_str(~\"128\").is_none()));\n+    assert!((i8::from_str(~\"127\") == Some(i8_val)));\n+    assert!((i8::from_str(~\"128\").is_none()));\n \n     i8_val += 1 as i8;\n-    fail_unless!((i8::from_str(~\"-128\") == Some(i8_val)));\n-    fail_unless!((i8::from_str(~\"-129\").is_none()));\n+    assert!((i8::from_str(~\"-128\") == Some(i8_val)));\n+    assert!((i8::from_str(~\"-129\").is_none()));\n \n     let mut i16_val: i16 = 32_767_i16;\n-    fail_unless!((i16::from_str(~\"32767\") == Some(i16_val)));\n-    fail_unless!((i16::from_str(~\"32768\").is_none()));\n+    assert!((i16::from_str(~\"32767\") == Some(i16_val)));\n+    assert!((i16::from_str(~\"32768\").is_none()));\n \n     i16_val += 1 as i16;\n-    fail_unless!((i16::from_str(~\"-32768\") == Some(i16_val)));\n-    fail_unless!((i16::from_str(~\"-32769\").is_none()));\n+    assert!((i16::from_str(~\"-32768\") == Some(i16_val)));\n+    assert!((i16::from_str(~\"-32769\").is_none()));\n \n     let mut i32_val: i32 = 2_147_483_647_i32;\n-    fail_unless!((i32::from_str(~\"2147483647\") == Some(i32_val)));\n-    fail_unless!((i32::from_str(~\"2147483648\").is_none()));\n+    assert!((i32::from_str(~\"2147483647\") == Some(i32_val)));\n+    assert!((i32::from_str(~\"2147483648\").is_none()));\n \n     i32_val += 1 as i32;\n-    fail_unless!((i32::from_str(~\"-2147483648\") == Some(i32_val)));\n-    fail_unless!((i32::from_str(~\"-2147483649\").is_none()));\n+    assert!((i32::from_str(~\"-2147483648\") == Some(i32_val)));\n+    assert!((i32::from_str(~\"-2147483649\").is_none()));\n \n     let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-    fail_unless!((i64::from_str(~\"9223372036854775807\") == Some(i64_val)));\n-    fail_unless!((i64::from_str(~\"9223372036854775808\").is_none()));\n+    assert!((i64::from_str(~\"9223372036854775807\") == Some(i64_val)));\n+    assert!((i64::from_str(~\"9223372036854775808\").is_none()));\n \n     i64_val += 1 as i64;\n-    fail_unless!((i64::from_str(~\"-9223372036854775808\") == Some(i64_val)));\n-    fail_unless!((i64::from_str(~\"-9223372036854775809\").is_none()));\n+    assert!((i64::from_str(~\"-9223372036854775808\") == Some(i64_val)));\n+    assert!((i64::from_str(~\"-9223372036854775809\").is_none()));\n }\n \n #[test]\n pub fn test_num() {\n     let ten: T = num::cast(10);\n     let two: T = num::cast(2);\n \n-    fail_unless!((ten.add(&two)    == num::cast(12)));\n-    fail_unless!((ten.sub(&two)    == num::cast(8)));\n-    fail_unless!((ten.mul(&two)    == num::cast(20)));\n-    fail_unless!((ten.div(&two)    == num::cast(5)));\n-    fail_unless!((ten.modulo(&two) == num::cast(0)));\n+    assert!((ten.add(&two)    == num::cast(12)));\n+    assert!((ten.sub(&two)    == num::cast(8)));\n+    assert!((ten.mul(&two)    == num::cast(20)));\n+    assert!((ten.div(&two)    == num::cast(5)));\n+    assert!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]\n@@ -421,7 +421,7 @@ pub fn test_ranges() {\n     for range_step(36,30,-2) |i| {\n         l.push(i);\n     }\n-    fail_unless!(l == ~[0,1,2,\n+    assert!(l == ~[0,1,2,\n                         13,12,11,\n                         20,22,24,\n                         36,34,32]);"}, {"sha": "76be224af15b9828482c0a42701cb79737589fc2", "filename": "src/libcore/num/int-template/i16.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -43,45 +43,45 @@ impl NumCast for i16 {\n \n #[test]\n fn test_numcast() {\n-    fail_unless!((20u   == 20i16.to_uint()));\n-    fail_unless!((20u8  == 20i16.to_u8()));\n-    fail_unless!((20u16 == 20i16.to_u16()));\n-    fail_unless!((20u32 == 20i16.to_u32()));\n-    fail_unless!((20u64 == 20i16.to_u64()));\n-    fail_unless!((20i   == 20i16.to_int()));\n-    fail_unless!((20i8  == 20i16.to_i8()));\n-    fail_unless!((20i16 == 20i16.to_i16()));\n-    fail_unless!((20i32 == 20i16.to_i32()));\n-    fail_unless!((20i64 == 20i16.to_i64()));\n-    fail_unless!((20f   == 20i16.to_float()));\n-    fail_unless!((20f32 == 20i16.to_f32()));\n-    fail_unless!((20f64 == 20i16.to_f64()));\n+    assert!((20u   == 20i16.to_uint()));\n+    assert!((20u8  == 20i16.to_u8()));\n+    assert!((20u16 == 20i16.to_u16()));\n+    assert!((20u32 == 20i16.to_u32()));\n+    assert!((20u64 == 20i16.to_u64()));\n+    assert!((20i   == 20i16.to_int()));\n+    assert!((20i8  == 20i16.to_i8()));\n+    assert!((20i16 == 20i16.to_i16()));\n+    assert!((20i32 == 20i16.to_i32()));\n+    assert!((20i64 == 20i16.to_i64()));\n+    assert!((20f   == 20i16.to_float()));\n+    assert!((20f32 == 20i16.to_f32()));\n+    assert!((20f64 == 20i16.to_f64()));\n \n-    fail_unless!((20i16 == NumCast::from(20u)));\n-    fail_unless!((20i16 == NumCast::from(20u8)));\n-    fail_unless!((20i16 == NumCast::from(20u16)));\n-    fail_unless!((20i16 == NumCast::from(20u32)));\n-    fail_unless!((20i16 == NumCast::from(20u64)));\n-    fail_unless!((20i16 == NumCast::from(20i)));\n-    fail_unless!((20i16 == NumCast::from(20i8)));\n-    fail_unless!((20i16 == NumCast::from(20i16)));\n-    fail_unless!((20i16 == NumCast::from(20i32)));\n-    fail_unless!((20i16 == NumCast::from(20i64)));\n-    fail_unless!((20i16 == NumCast::from(20f)));\n-    fail_unless!((20i16 == NumCast::from(20f32)));\n-    fail_unless!((20i16 == NumCast::from(20f64)));\n+    assert!((20i16 == NumCast::from(20u)));\n+    assert!((20i16 == NumCast::from(20u8)));\n+    assert!((20i16 == NumCast::from(20u16)));\n+    assert!((20i16 == NumCast::from(20u32)));\n+    assert!((20i16 == NumCast::from(20u64)));\n+    assert!((20i16 == NumCast::from(20i)));\n+    assert!((20i16 == NumCast::from(20i8)));\n+    assert!((20i16 == NumCast::from(20i16)));\n+    assert!((20i16 == NumCast::from(20i32)));\n+    assert!((20i16 == NumCast::from(20i64)));\n+    assert!((20i16 == NumCast::from(20f)));\n+    assert!((20i16 == NumCast::from(20f32)));\n+    assert!((20i16 == NumCast::from(20f64)));\n \n-    fail_unless!((20i16 == num::cast(20u)));\n-    fail_unless!((20i16 == num::cast(20u8)));\n-    fail_unless!((20i16 == num::cast(20u16)));\n-    fail_unless!((20i16 == num::cast(20u32)));\n-    fail_unless!((20i16 == num::cast(20u64)));\n-    fail_unless!((20i16 == num::cast(20i)));\n-    fail_unless!((20i16 == num::cast(20i8)));\n-    fail_unless!((20i16 == num::cast(20i16)));\n-    fail_unless!((20i16 == num::cast(20i32)));\n-    fail_unless!((20i16 == num::cast(20i64)));\n-    fail_unless!((20i16 == num::cast(20f)));\n-    fail_unless!((20i16 == num::cast(20f32)));\n-    fail_unless!((20i16 == num::cast(20f64)));\n+    assert!((20i16 == num::cast(20u)));\n+    assert!((20i16 == num::cast(20u8)));\n+    assert!((20i16 == num::cast(20u16)));\n+    assert!((20i16 == num::cast(20u32)));\n+    assert!((20i16 == num::cast(20u64)));\n+    assert!((20i16 == num::cast(20i)));\n+    assert!((20i16 == num::cast(20i8)));\n+    assert!((20i16 == num::cast(20i16)));\n+    assert!((20i16 == num::cast(20i32)));\n+    assert!((20i16 == num::cast(20i64)));\n+    assert!((20i16 == num::cast(20f)));\n+    assert!((20i16 == num::cast(20f32)));\n+    assert!((20i16 == num::cast(20f64)));\n }"}, {"sha": "596d29aa2910ae31a5caaa097c6c069638f01353", "filename": "src/libcore/num/int-template/i32.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -43,45 +43,45 @@ impl NumCast for i32 {\n \n #[test]\n fn test_numcast() {\n-    fail_unless!((20u   == 20i32.to_uint()));\n-    fail_unless!((20u8  == 20i32.to_u8()));\n-    fail_unless!((20u16 == 20i32.to_u16()));\n-    fail_unless!((20u32 == 20i32.to_u32()));\n-    fail_unless!((20u64 == 20i32.to_u64()));\n-    fail_unless!((20i   == 20i32.to_int()));\n-    fail_unless!((20i8  == 20i32.to_i8()));\n-    fail_unless!((20i16 == 20i32.to_i16()));\n-    fail_unless!((20i32 == 20i32.to_i32()));\n-    fail_unless!((20i64 == 20i32.to_i64()));\n-    fail_unless!((20f   == 20i32.to_float()));\n-    fail_unless!((20f32 == 20i32.to_f32()));\n-    fail_unless!((20f64 == 20i32.to_f64()));\n+    assert!((20u   == 20i32.to_uint()));\n+    assert!((20u8  == 20i32.to_u8()));\n+    assert!((20u16 == 20i32.to_u16()));\n+    assert!((20u32 == 20i32.to_u32()));\n+    assert!((20u64 == 20i32.to_u64()));\n+    assert!((20i   == 20i32.to_int()));\n+    assert!((20i8  == 20i32.to_i8()));\n+    assert!((20i16 == 20i32.to_i16()));\n+    assert!((20i32 == 20i32.to_i32()));\n+    assert!((20i64 == 20i32.to_i64()));\n+    assert!((20f   == 20i32.to_float()));\n+    assert!((20f32 == 20i32.to_f32()));\n+    assert!((20f64 == 20i32.to_f64()));\n \n-    fail_unless!((20i32 == NumCast::from(20u)));\n-    fail_unless!((20i32 == NumCast::from(20u8)));\n-    fail_unless!((20i32 == NumCast::from(20u16)));\n-    fail_unless!((20i32 == NumCast::from(20u32)));\n-    fail_unless!((20i32 == NumCast::from(20u64)));\n-    fail_unless!((20i32 == NumCast::from(20i)));\n-    fail_unless!((20i32 == NumCast::from(20i8)));\n-    fail_unless!((20i32 == NumCast::from(20i16)));\n-    fail_unless!((20i32 == NumCast::from(20i32)));\n-    fail_unless!((20i32 == NumCast::from(20i64)));\n-    fail_unless!((20i32 == NumCast::from(20f)));\n-    fail_unless!((20i32 == NumCast::from(20f32)));\n-    fail_unless!((20i32 == NumCast::from(20f64)));\n+    assert!((20i32 == NumCast::from(20u)));\n+    assert!((20i32 == NumCast::from(20u8)));\n+    assert!((20i32 == NumCast::from(20u16)));\n+    assert!((20i32 == NumCast::from(20u32)));\n+    assert!((20i32 == NumCast::from(20u64)));\n+    assert!((20i32 == NumCast::from(20i)));\n+    assert!((20i32 == NumCast::from(20i8)));\n+    assert!((20i32 == NumCast::from(20i16)));\n+    assert!((20i32 == NumCast::from(20i32)));\n+    assert!((20i32 == NumCast::from(20i64)));\n+    assert!((20i32 == NumCast::from(20f)));\n+    assert!((20i32 == NumCast::from(20f32)));\n+    assert!((20i32 == NumCast::from(20f64)));\n \n-    fail_unless!((20i32 == num::cast(20u)));\n-    fail_unless!((20i32 == num::cast(20u8)));\n-    fail_unless!((20i32 == num::cast(20u16)));\n-    fail_unless!((20i32 == num::cast(20u32)));\n-    fail_unless!((20i32 == num::cast(20u64)));\n-    fail_unless!((20i32 == num::cast(20i)));\n-    fail_unless!((20i32 == num::cast(20i8)));\n-    fail_unless!((20i32 == num::cast(20i16)));\n-    fail_unless!((20i32 == num::cast(20i32)));\n-    fail_unless!((20i32 == num::cast(20i64)));\n-    fail_unless!((20i32 == num::cast(20f)));\n-    fail_unless!((20i32 == num::cast(20f32)));\n-    fail_unless!((20i32 == num::cast(20f64)));\n+    assert!((20i32 == num::cast(20u)));\n+    assert!((20i32 == num::cast(20u8)));\n+    assert!((20i32 == num::cast(20u16)));\n+    assert!((20i32 == num::cast(20u32)));\n+    assert!((20i32 == num::cast(20u64)));\n+    assert!((20i32 == num::cast(20i)));\n+    assert!((20i32 == num::cast(20i8)));\n+    assert!((20i32 == num::cast(20i16)));\n+    assert!((20i32 == num::cast(20i32)));\n+    assert!((20i32 == num::cast(20i64)));\n+    assert!((20i32 == num::cast(20f)));\n+    assert!((20i32 == num::cast(20f32)));\n+    assert!((20i32 == num::cast(20f64)));\n }"}, {"sha": "d02c46d9393104eaac8d82bc8e1aa0e0fd8ac0e4", "filename": "src/libcore/num/int-template/i64.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -43,45 +43,45 @@ impl NumCast for i64 {\n \n #[test]\n fn test_numcast() {\n-    fail_unless!((20u   == 20i64.to_uint()));\n-    fail_unless!((20u8  == 20i64.to_u8()));\n-    fail_unless!((20u16 == 20i64.to_u16()));\n-    fail_unless!((20u32 == 20i64.to_u32()));\n-    fail_unless!((20u64 == 20i64.to_u64()));\n-    fail_unless!((20i   == 20i64.to_int()));\n-    fail_unless!((20i8  == 20i64.to_i8()));\n-    fail_unless!((20i16 == 20i64.to_i16()));\n-    fail_unless!((20i32 == 20i64.to_i32()));\n-    fail_unless!((20i64 == 20i64.to_i64()));\n-    fail_unless!((20f   == 20i64.to_float()));\n-    fail_unless!((20f32 == 20i64.to_f32()));\n-    fail_unless!((20f64 == 20i64.to_f64()));\n+    assert!((20u   == 20i64.to_uint()));\n+    assert!((20u8  == 20i64.to_u8()));\n+    assert!((20u16 == 20i64.to_u16()));\n+    assert!((20u32 == 20i64.to_u32()));\n+    assert!((20u64 == 20i64.to_u64()));\n+    assert!((20i   == 20i64.to_int()));\n+    assert!((20i8  == 20i64.to_i8()));\n+    assert!((20i16 == 20i64.to_i16()));\n+    assert!((20i32 == 20i64.to_i32()));\n+    assert!((20i64 == 20i64.to_i64()));\n+    assert!((20f   == 20i64.to_float()));\n+    assert!((20f32 == 20i64.to_f32()));\n+    assert!((20f64 == 20i64.to_f64()));\n \n-    fail_unless!((20i64 == NumCast::from(20u)));\n-    fail_unless!((20i64 == NumCast::from(20u8)));\n-    fail_unless!((20i64 == NumCast::from(20u16)));\n-    fail_unless!((20i64 == NumCast::from(20u32)));\n-    fail_unless!((20i64 == NumCast::from(20u64)));\n-    fail_unless!((20i64 == NumCast::from(20i)));\n-    fail_unless!((20i64 == NumCast::from(20i8)));\n-    fail_unless!((20i64 == NumCast::from(20i16)));\n-    fail_unless!((20i64 == NumCast::from(20i32)));\n-    fail_unless!((20i64 == NumCast::from(20i64)));\n-    fail_unless!((20i64 == NumCast::from(20f)));\n-    fail_unless!((20i64 == NumCast::from(20f32)));\n-    fail_unless!((20i64 == NumCast::from(20f64)));\n+    assert!((20i64 == NumCast::from(20u)));\n+    assert!((20i64 == NumCast::from(20u8)));\n+    assert!((20i64 == NumCast::from(20u16)));\n+    assert!((20i64 == NumCast::from(20u32)));\n+    assert!((20i64 == NumCast::from(20u64)));\n+    assert!((20i64 == NumCast::from(20i)));\n+    assert!((20i64 == NumCast::from(20i8)));\n+    assert!((20i64 == NumCast::from(20i16)));\n+    assert!((20i64 == NumCast::from(20i32)));\n+    assert!((20i64 == NumCast::from(20i64)));\n+    assert!((20i64 == NumCast::from(20f)));\n+    assert!((20i64 == NumCast::from(20f32)));\n+    assert!((20i64 == NumCast::from(20f64)));\n \n-    fail_unless!((20i64 == num::cast(20u)));\n-    fail_unless!((20i64 == num::cast(20u8)));\n-    fail_unless!((20i64 == num::cast(20u16)));\n-    fail_unless!((20i64 == num::cast(20u32)));\n-    fail_unless!((20i64 == num::cast(20u64)));\n-    fail_unless!((20i64 == num::cast(20i)));\n-    fail_unless!((20i64 == num::cast(20i8)));\n-    fail_unless!((20i64 == num::cast(20i16)));\n-    fail_unless!((20i64 == num::cast(20i32)));\n-    fail_unless!((20i64 == num::cast(20i64)));\n-    fail_unless!((20i64 == num::cast(20f)));\n-    fail_unless!((20i64 == num::cast(20f32)));\n-    fail_unless!((20i64 == num::cast(20f64)));\n+    assert!((20i64 == num::cast(20u)));\n+    assert!((20i64 == num::cast(20u8)));\n+    assert!((20i64 == num::cast(20u16)));\n+    assert!((20i64 == num::cast(20u32)));\n+    assert!((20i64 == num::cast(20u64)));\n+    assert!((20i64 == num::cast(20i)));\n+    assert!((20i64 == num::cast(20i8)));\n+    assert!((20i64 == num::cast(20i16)));\n+    assert!((20i64 == num::cast(20i32)));\n+    assert!((20i64 == num::cast(20i64)));\n+    assert!((20i64 == num::cast(20f)));\n+    assert!((20i64 == num::cast(20f32)));\n+    assert!((20i64 == num::cast(20f64)));\n }"}, {"sha": "c0dd6e01d4b7f10b4977ea1ede0bb4c790c208bc", "filename": "src/libcore/num/int-template/i8.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -43,45 +43,45 @@ impl NumCast for i8 {\n \n #[test]\n fn test_numcast() {\n-    fail_unless!((20u   == 20i8.to_uint()));\n-    fail_unless!((20u8  == 20i8.to_u8()));\n-    fail_unless!((20u16 == 20i8.to_u16()));\n-    fail_unless!((20u32 == 20i8.to_u32()));\n-    fail_unless!((20u64 == 20i8.to_u64()));\n-    fail_unless!((20i   == 20i8.to_int()));\n-    fail_unless!((20i8  == 20i8.to_i8()));\n-    fail_unless!((20i16 == 20i8.to_i16()));\n-    fail_unless!((20i32 == 20i8.to_i32()));\n-    fail_unless!((20i64 == 20i8.to_i64()));\n-    fail_unless!((20f   == 20i8.to_float()));\n-    fail_unless!((20f32 == 20i8.to_f32()));\n-    fail_unless!((20f64 == 20i8.to_f64()));\n+    assert!((20u   == 20i8.to_uint()));\n+    assert!((20u8  == 20i8.to_u8()));\n+    assert!((20u16 == 20i8.to_u16()));\n+    assert!((20u32 == 20i8.to_u32()));\n+    assert!((20u64 == 20i8.to_u64()));\n+    assert!((20i   == 20i8.to_int()));\n+    assert!((20i8  == 20i8.to_i8()));\n+    assert!((20i16 == 20i8.to_i16()));\n+    assert!((20i32 == 20i8.to_i32()));\n+    assert!((20i64 == 20i8.to_i64()));\n+    assert!((20f   == 20i8.to_float()));\n+    assert!((20f32 == 20i8.to_f32()));\n+    assert!((20f64 == 20i8.to_f64()));\n \n-    fail_unless!((20i8 == NumCast::from(20u)));\n-    fail_unless!((20i8 == NumCast::from(20u8)));\n-    fail_unless!((20i8 == NumCast::from(20u16)));\n-    fail_unless!((20i8 == NumCast::from(20u32)));\n-    fail_unless!((20i8 == NumCast::from(20u64)));\n-    fail_unless!((20i8 == NumCast::from(20i)));\n-    fail_unless!((20i8 == NumCast::from(20i8)));\n-    fail_unless!((20i8 == NumCast::from(20i16)));\n-    fail_unless!((20i8 == NumCast::from(20i32)));\n-    fail_unless!((20i8 == NumCast::from(20i64)));\n-    fail_unless!((20i8 == NumCast::from(20f)));\n-    fail_unless!((20i8 == NumCast::from(20f32)));\n-    fail_unless!((20i8 == NumCast::from(20f64)));\n+    assert!((20i8 == NumCast::from(20u)));\n+    assert!((20i8 == NumCast::from(20u8)));\n+    assert!((20i8 == NumCast::from(20u16)));\n+    assert!((20i8 == NumCast::from(20u32)));\n+    assert!((20i8 == NumCast::from(20u64)));\n+    assert!((20i8 == NumCast::from(20i)));\n+    assert!((20i8 == NumCast::from(20i8)));\n+    assert!((20i8 == NumCast::from(20i16)));\n+    assert!((20i8 == NumCast::from(20i32)));\n+    assert!((20i8 == NumCast::from(20i64)));\n+    assert!((20i8 == NumCast::from(20f)));\n+    assert!((20i8 == NumCast::from(20f32)));\n+    assert!((20i8 == NumCast::from(20f64)));\n \n-    fail_unless!((20i8 == num::cast(20u)));\n-    fail_unless!((20i8 == num::cast(20u8)));\n-    fail_unless!((20i8 == num::cast(20u16)));\n-    fail_unless!((20i8 == num::cast(20u32)));\n-    fail_unless!((20i8 == num::cast(20u64)));\n-    fail_unless!((20i8 == num::cast(20i)));\n-    fail_unless!((20i8 == num::cast(20i8)));\n-    fail_unless!((20i8 == num::cast(20i16)));\n-    fail_unless!((20i8 == num::cast(20i32)));\n-    fail_unless!((20i8 == num::cast(20i64)));\n-    fail_unless!((20i8 == num::cast(20f)));\n-    fail_unless!((20i8 == num::cast(20f32)));\n-    fail_unless!((20i8 == num::cast(20f64)));\n+    assert!((20i8 == num::cast(20u)));\n+    assert!((20i8 == num::cast(20u8)));\n+    assert!((20i8 == num::cast(20u16)));\n+    assert!((20i8 == num::cast(20u32)));\n+    assert!((20i8 == num::cast(20u64)));\n+    assert!((20i8 == num::cast(20i)));\n+    assert!((20i8 == num::cast(20i8)));\n+    assert!((20i8 == num::cast(20i16)));\n+    assert!((20i8 == num::cast(20i32)));\n+    assert!((20i8 == num::cast(20i64)));\n+    assert!((20i8 == num::cast(20f)));\n+    assert!((20i8 == num::cast(20f32)));\n+    assert!((20i8 == num::cast(20f64)));\n }"}, {"sha": "ea8aec1222438e2bc01f106f2b8b4d0b81f6029c", "filename": "src/libcore/num/int-template/int.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -40,21 +40,21 @@ mod inst {\n \n     #[test]\n     fn test_pow() {\n-        fail_unless!((pow(0, 0u) == 1));\n-        fail_unless!((pow(0, 1u) == 0));\n-        fail_unless!((pow(0, 2u) == 0));\n-        fail_unless!((pow(-1, 0u) == 1));\n-        fail_unless!((pow(1, 0u) == 1));\n-        fail_unless!((pow(-3, 2u) == 9));\n-        fail_unless!((pow(-3, 3u) == -27));\n-        fail_unless!((pow(4, 9u) == 262144));\n+        assert!((pow(0, 0u) == 1));\n+        assert!((pow(0, 1u) == 0));\n+        assert!((pow(0, 2u) == 0));\n+        assert!((pow(-1, 0u) == 1));\n+        assert!((pow(1, 0u) == 1));\n+        assert!((pow(-3, 2u) == 9));\n+        assert!((pow(-3, 3u) == -27));\n+        assert!((pow(4, 9u) == 262144));\n     }\n \n     #[test]\n     fn test_overflows() {\n-        fail_unless!((::int::max_value > 0));\n-        fail_unless!((::int::min_value <= 0));\n-        fail_unless!((::int::min_value + ::int::max_value + 1 == 0));\n+        assert!((::int::max_value > 0));\n+        assert!((::int::min_value <= 0));\n+        assert!((::int::min_value + ::int::max_value + 1 == 0));\n     }\n }\n \n@@ -84,45 +84,45 @@ impl NumCast for int {\n \n #[test]\n fn test_numcast() {\n-    fail_unless!((20u   == 20i.to_uint()));\n-    fail_unless!((20u8  == 20i.to_u8()));\n-    fail_unless!((20u16 == 20i.to_u16()));\n-    fail_unless!((20u32 == 20i.to_u32()));\n-    fail_unless!((20u64 == 20i.to_u64()));\n-    fail_unless!((20i   == 20i.to_int()));\n-    fail_unless!((20i8  == 20i.to_i8()));\n-    fail_unless!((20i16 == 20i.to_i16()));\n-    fail_unless!((20i32 == 20i.to_i32()));\n-    fail_unless!((20i64 == 20i.to_i64()));\n-    fail_unless!((20f   == 20i.to_float()));\n-    fail_unless!((20f32 == 20i.to_f32()));\n-    fail_unless!((20f64 == 20i.to_f64()));\n+    assert!((20u   == 20i.to_uint()));\n+    assert!((20u8  == 20i.to_u8()));\n+    assert!((20u16 == 20i.to_u16()));\n+    assert!((20u32 == 20i.to_u32()));\n+    assert!((20u64 == 20i.to_u64()));\n+    assert!((20i   == 20i.to_int()));\n+    assert!((20i8  == 20i.to_i8()));\n+    assert!((20i16 == 20i.to_i16()));\n+    assert!((20i32 == 20i.to_i32()));\n+    assert!((20i64 == 20i.to_i64()));\n+    assert!((20f   == 20i.to_float()));\n+    assert!((20f32 == 20i.to_f32()));\n+    assert!((20f64 == 20i.to_f64()));\n \n-    fail_unless!((20i == NumCast::from(20u)));\n-    fail_unless!((20i == NumCast::from(20u8)));\n-    fail_unless!((20i == NumCast::from(20u16)));\n-    fail_unless!((20i == NumCast::from(20u32)));\n-    fail_unless!((20i == NumCast::from(20u64)));\n-    fail_unless!((20i == NumCast::from(20i)));\n-    fail_unless!((20i == NumCast::from(20i8)));\n-    fail_unless!((20i == NumCast::from(20i16)));\n-    fail_unless!((20i == NumCast::from(20i32)));\n-    fail_unless!((20i == NumCast::from(20i64)));\n-    fail_unless!((20i == NumCast::from(20f)));\n-    fail_unless!((20i == NumCast::from(20f32)));\n-    fail_unless!((20i == NumCast::from(20f64)));\n+    assert!((20i == NumCast::from(20u)));\n+    assert!((20i == NumCast::from(20u8)));\n+    assert!((20i == NumCast::from(20u16)));\n+    assert!((20i == NumCast::from(20u32)));\n+    assert!((20i == NumCast::from(20u64)));\n+    assert!((20i == NumCast::from(20i)));\n+    assert!((20i == NumCast::from(20i8)));\n+    assert!((20i == NumCast::from(20i16)));\n+    assert!((20i == NumCast::from(20i32)));\n+    assert!((20i == NumCast::from(20i64)));\n+    assert!((20i == NumCast::from(20f)));\n+    assert!((20i == NumCast::from(20f32)));\n+    assert!((20i == NumCast::from(20f64)));\n \n-    fail_unless!((20i == num::cast(20u)));\n-    fail_unless!((20i == num::cast(20u8)));\n-    fail_unless!((20i == num::cast(20u16)));\n-    fail_unless!((20i == num::cast(20u32)));\n-    fail_unless!((20i == num::cast(20u64)));\n-    fail_unless!((20i == num::cast(20i)));\n-    fail_unless!((20i == num::cast(20i8)));\n-    fail_unless!((20i == num::cast(20i16)));\n-    fail_unless!((20i == num::cast(20i32)));\n-    fail_unless!((20i == num::cast(20i64)));\n-    fail_unless!((20i == num::cast(20f)));\n-    fail_unless!((20i == num::cast(20f32)));\n-    fail_unless!((20i == num::cast(20f64)));\n+    assert!((20i == num::cast(20u)));\n+    assert!((20i == num::cast(20u8)));\n+    assert!((20i == num::cast(20u16)));\n+    assert!((20i == num::cast(20u32)));\n+    assert!((20i == num::cast(20u64)));\n+    assert!((20i == num::cast(20i)));\n+    assert!((20i == num::cast(20i8)));\n+    assert!((20i == num::cast(20i16)));\n+    assert!((20i == num::cast(20i32)));\n+    assert!((20i == num::cast(20i64)));\n+    assert!((20i == num::cast(20f)));\n+    assert!((20i == num::cast(20f32)));\n+    assert!((20i == num::cast(20f64)));\n }"}, {"sha": "daa36f9dc32f5953a93b5bbe80002be28e50fdbe", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -55,7 +55,7 @@ pub enum RoundMode {\n  *\n  * ~~~\n  * let twenty: f32 = num::cast(0x14);\n- * fail_unless!(twenty == 20f32);\n+ * assert!(twenty == 20f32);\n  * ~~~\n  */\n #[inline(always)]"}, {"sha": "400417284a279eb672a4f844e8a302e233de9a78", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -241,104 +241,104 @@ impl ToStrRadix for T {\n \n #[test]\n pub fn test_to_str() {\n-    fail_unless!(to_str_radix(0 as T, 10u) == ~\"0\");\n-    fail_unless!(to_str_radix(1 as T, 10u) == ~\"1\");\n-    fail_unless!(to_str_radix(2 as T, 10u) == ~\"2\");\n-    fail_unless!(to_str_radix(11 as T, 10u) == ~\"11\");\n-    fail_unless!(to_str_radix(11 as T, 16u) == ~\"b\");\n-    fail_unless!(to_str_radix(255 as T, 16u) == ~\"ff\");\n-    fail_unless!(to_str_radix(0xff as T, 10u) == ~\"255\");\n+    assert!(to_str_radix(0 as T, 10u) == ~\"0\");\n+    assert!(to_str_radix(1 as T, 10u) == ~\"1\");\n+    assert!(to_str_radix(2 as T, 10u) == ~\"2\");\n+    assert!(to_str_radix(11 as T, 10u) == ~\"11\");\n+    assert!(to_str_radix(11 as T, 16u) == ~\"b\");\n+    assert!(to_str_radix(255 as T, 16u) == ~\"ff\");\n+    assert!(to_str_radix(0xff as T, 10u) == ~\"255\");\n }\n \n #[test]\n pub fn test_from_str() {\n-    fail_unless!(from_str(~\"0\") == Some(0u as T));\n-    fail_unless!(from_str(~\"3\") == Some(3u as T));\n-    fail_unless!(from_str(~\"10\") == Some(10u as T));\n-    fail_unless!(u32::from_str(~\"123456789\") == Some(123456789 as u32));\n-    fail_unless!(from_str(~\"00100\") == Some(100u as T));\n+    assert!(from_str(~\"0\") == Some(0u as T));\n+    assert!(from_str(~\"3\") == Some(3u as T));\n+    assert!(from_str(~\"10\") == Some(10u as T));\n+    assert!(u32::from_str(~\"123456789\") == Some(123456789 as u32));\n+    assert!(from_str(~\"00100\") == Some(100u as T));\n \n-    fail_unless!(from_str(~\"\").is_none());\n-    fail_unless!(from_str(~\" \").is_none());\n-    fail_unless!(from_str(~\"x\").is_none());\n+    assert!(from_str(~\"\").is_none());\n+    assert!(from_str(~\" \").is_none());\n+    assert!(from_str(~\"x\").is_none());\n }\n \n #[test]\n pub fn test_parse_bytes() {\n     use str::to_bytes;\n-    fail_unless!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123u as T));\n-    fail_unless!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9u as T));\n-    fail_unless!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83u as T));\n-    fail_unless!(u16::parse_bytes(to_bytes(~\"123\"), 16u) ==\n+    assert!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123u as T));\n+    assert!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9u as T));\n+    assert!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83u as T));\n+    assert!(u16::parse_bytes(to_bytes(~\"123\"), 16u) ==\n                  Some(291u as u16));\n-    fail_unless!(u16::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n+    assert!(u16::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n                  Some(65535u as u16));\n-    fail_unless!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35u as T));\n+    assert!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35u as T));\n \n-    fail_unless!(parse_bytes(to_bytes(~\"Z\"), 10u).is_none());\n-    fail_unless!(parse_bytes(to_bytes(~\"_\"), 2u).is_none());\n+    assert!(parse_bytes(to_bytes(~\"Z\"), 10u).is_none());\n+    assert!(parse_bytes(to_bytes(~\"_\"), 2u).is_none());\n }\n \n #[test]\n fn test_uint_to_str_overflow() {\n     let mut u8_val: u8 = 255_u8;\n-    fail_unless!((u8::to_str(u8_val) == ~\"255\"));\n+    assert!((u8::to_str(u8_val) == ~\"255\"));\n \n     u8_val += 1 as u8;\n-    fail_unless!((u8::to_str(u8_val) == ~\"0\"));\n+    assert!((u8::to_str(u8_val) == ~\"0\"));\n \n     let mut u16_val: u16 = 65_535_u16;\n-    fail_unless!((u16::to_str(u16_val) == ~\"65535\"));\n+    assert!((u16::to_str(u16_val) == ~\"65535\"));\n \n     u16_val += 1 as u16;\n-    fail_unless!((u16::to_str(u16_val) == ~\"0\"));\n+    assert!((u16::to_str(u16_val) == ~\"0\"));\n \n     let mut u32_val: u32 = 4_294_967_295_u32;\n-    fail_unless!((u32::to_str(u32_val) == ~\"4294967295\"));\n+    assert!((u32::to_str(u32_val) == ~\"4294967295\"));\n \n     u32_val += 1 as u32;\n-    fail_unless!((u32::to_str(u32_val) == ~\"0\"));\n+    assert!((u32::to_str(u32_val) == ~\"0\"));\n \n     let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-    fail_unless!((u64::to_str(u64_val) == ~\"18446744073709551615\"));\n+    assert!((u64::to_str(u64_val) == ~\"18446744073709551615\"));\n \n     u64_val += 1 as u64;\n-    fail_unless!((u64::to_str(u64_val) == ~\"0\"));\n+    assert!((u64::to_str(u64_val) == ~\"0\"));\n }\n \n #[test]\n fn test_uint_from_str_overflow() {\n     let mut u8_val: u8 = 255_u8;\n-    fail_unless!((u8::from_str(~\"255\") == Some(u8_val)));\n-    fail_unless!((u8::from_str(~\"256\").is_none()));\n+    assert!((u8::from_str(~\"255\") == Some(u8_val)));\n+    assert!((u8::from_str(~\"256\").is_none()));\n \n     u8_val += 1 as u8;\n-    fail_unless!((u8::from_str(~\"0\") == Some(u8_val)));\n-    fail_unless!((u8::from_str(~\"-1\").is_none()));\n+    assert!((u8::from_str(~\"0\") == Some(u8_val)));\n+    assert!((u8::from_str(~\"-1\").is_none()));\n \n     let mut u16_val: u16 = 65_535_u16;\n-    fail_unless!((u16::from_str(~\"65535\") == Some(u16_val)));\n-    fail_unless!((u16::from_str(~\"65536\").is_none()));\n+    assert!((u16::from_str(~\"65535\") == Some(u16_val)));\n+    assert!((u16::from_str(~\"65536\").is_none()));\n \n     u16_val += 1 as u16;\n-    fail_unless!((u16::from_str(~\"0\") == Some(u16_val)));\n-    fail_unless!((u16::from_str(~\"-1\").is_none()));\n+    assert!((u16::from_str(~\"0\") == Some(u16_val)));\n+    assert!((u16::from_str(~\"-1\").is_none()));\n \n     let mut u32_val: u32 = 4_294_967_295_u32;\n-    fail_unless!((u32::from_str(~\"4294967295\") == Some(u32_val)));\n-    fail_unless!((u32::from_str(~\"4294967296\").is_none()));\n+    assert!((u32::from_str(~\"4294967295\") == Some(u32_val)));\n+    assert!((u32::from_str(~\"4294967296\").is_none()));\n \n     u32_val += 1 as u32;\n-    fail_unless!((u32::from_str(~\"0\") == Some(u32_val)));\n-    fail_unless!((u32::from_str(~\"-1\").is_none()));\n+    assert!((u32::from_str(~\"0\") == Some(u32_val)));\n+    assert!((u32::from_str(~\"-1\").is_none()));\n \n     let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-    fail_unless!((u64::from_str(~\"18446744073709551615\") == Some(u64_val)));\n-    fail_unless!((u64::from_str(~\"18446744073709551616\").is_none()));\n+    assert!((u64::from_str(~\"18446744073709551615\") == Some(u64_val)));\n+    assert!((u64::from_str(~\"18446744073709551616\").is_none()));\n \n     u64_val += 1 as u64;\n-    fail_unless!((u64::from_str(~\"0\") == Some(u64_val)));\n-    fail_unless!((u64::from_str(~\"-1\").is_none()));\n+    assert!((u64::from_str(~\"0\") == Some(u64_val)));\n+    assert!((u64::from_str(~\"-1\").is_none()));\n }\n \n #[test]\n@@ -372,7 +372,7 @@ pub fn test_ranges() {\n         l.push(i);\n     }\n \n-    fail_unless!(l == ~[0,1,2,\n+    assert!(l == ~[0,1,2,\n                         13,12,11,\n                         20,22,24,\n                         36,34,32]);\n@@ -397,11 +397,11 @@ pub fn test_num() {\n     let ten: T = num::cast(10);\n     let two: T = num::cast(2);\n \n-    fail_unless!((ten.add(&two)    == num::cast(12)));\n-    fail_unless!((ten.sub(&two)    == num::cast(8)));\n-    fail_unless!((ten.mul(&two)    == num::cast(20)));\n-    fail_unless!((ten.div(&two)    == num::cast(5)));\n-    fail_unless!((ten.modulo(&two) == num::cast(0)));\n+    assert!((ten.add(&two)    == num::cast(12)));\n+    assert!((ten.sub(&two)    == num::cast(8)));\n+    assert!((ten.mul(&two)    == num::cast(20)));\n+    assert!((ten.div(&two)    == num::cast(5)));\n+    assert!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]"}, {"sha": "7445a43e486456ac6aafdcdb1f8a3a0ff2c25073", "filename": "src/libcore/num/uint-template/u16.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -45,45 +45,45 @@ impl NumCast for u16 {\n \n #[test]\n fn test_numcast() {\n-    fail_unless!((20u   == 20u16.to_uint()));\n-    fail_unless!((20u8  == 20u16.to_u8()));\n-    fail_unless!((20u16 == 20u16.to_u16()));\n-    fail_unless!((20u32 == 20u16.to_u32()));\n-    fail_unless!((20u64 == 20u16.to_u64()));\n-    fail_unless!((20i   == 20u16.to_int()));\n-    fail_unless!((20i8  == 20u16.to_i8()));\n-    fail_unless!((20i16 == 20u16.to_i16()));\n-    fail_unless!((20i32 == 20u16.to_i32()));\n-    fail_unless!((20i64 == 20u16.to_i64()));\n-    fail_unless!((20f   == 20u16.to_float()));\n-    fail_unless!((20f32 == 20u16.to_f32()));\n-    fail_unless!((20f64 == 20u16.to_f64()));\n+    assert!((20u   == 20u16.to_uint()));\n+    assert!((20u8  == 20u16.to_u8()));\n+    assert!((20u16 == 20u16.to_u16()));\n+    assert!((20u32 == 20u16.to_u32()));\n+    assert!((20u64 == 20u16.to_u64()));\n+    assert!((20i   == 20u16.to_int()));\n+    assert!((20i8  == 20u16.to_i8()));\n+    assert!((20i16 == 20u16.to_i16()));\n+    assert!((20i32 == 20u16.to_i32()));\n+    assert!((20i64 == 20u16.to_i64()));\n+    assert!((20f   == 20u16.to_float()));\n+    assert!((20f32 == 20u16.to_f32()));\n+    assert!((20f64 == 20u16.to_f64()));\n \n-    fail_unless!((20u16 == NumCast::from(20u)));\n-    fail_unless!((20u16 == NumCast::from(20u8)));\n-    fail_unless!((20u16 == NumCast::from(20u16)));\n-    fail_unless!((20u16 == NumCast::from(20u32)));\n-    fail_unless!((20u16 == NumCast::from(20u64)));\n-    fail_unless!((20u16 == NumCast::from(20i)));\n-    fail_unless!((20u16 == NumCast::from(20i8)));\n-    fail_unless!((20u16 == NumCast::from(20i16)));\n-    fail_unless!((20u16 == NumCast::from(20i32)));\n-    fail_unless!((20u16 == NumCast::from(20i64)));\n-    fail_unless!((20u16 == NumCast::from(20f)));\n-    fail_unless!((20u16 == NumCast::from(20f32)));\n-    fail_unless!((20u16 == NumCast::from(20f64)));\n+    assert!((20u16 == NumCast::from(20u)));\n+    assert!((20u16 == NumCast::from(20u8)));\n+    assert!((20u16 == NumCast::from(20u16)));\n+    assert!((20u16 == NumCast::from(20u32)));\n+    assert!((20u16 == NumCast::from(20u64)));\n+    assert!((20u16 == NumCast::from(20i)));\n+    assert!((20u16 == NumCast::from(20i8)));\n+    assert!((20u16 == NumCast::from(20i16)));\n+    assert!((20u16 == NumCast::from(20i32)));\n+    assert!((20u16 == NumCast::from(20i64)));\n+    assert!((20u16 == NumCast::from(20f)));\n+    assert!((20u16 == NumCast::from(20f32)));\n+    assert!((20u16 == NumCast::from(20f64)));\n \n-    fail_unless!((20u16 == num::cast(20u)));\n-    fail_unless!((20u16 == num::cast(20u8)));\n-    fail_unless!((20u16 == num::cast(20u16)));\n-    fail_unless!((20u16 == num::cast(20u32)));\n-    fail_unless!((20u16 == num::cast(20u64)));\n-    fail_unless!((20u16 == num::cast(20i)));\n-    fail_unless!((20u16 == num::cast(20i8)));\n-    fail_unless!((20u16 == num::cast(20i16)));\n-    fail_unless!((20u16 == num::cast(20i32)));\n-    fail_unless!((20u16 == num::cast(20i64)));\n-    fail_unless!((20u16 == num::cast(20f)));\n-    fail_unless!((20u16 == num::cast(20f32)));\n-    fail_unless!((20u16 == num::cast(20f64)));\n+    assert!((20u16 == num::cast(20u)));\n+    assert!((20u16 == num::cast(20u8)));\n+    assert!((20u16 == num::cast(20u16)));\n+    assert!((20u16 == num::cast(20u32)));\n+    assert!((20u16 == num::cast(20u64)));\n+    assert!((20u16 == num::cast(20i)));\n+    assert!((20u16 == num::cast(20i8)));\n+    assert!((20u16 == num::cast(20i16)));\n+    assert!((20u16 == num::cast(20i32)));\n+    assert!((20u16 == num::cast(20i64)));\n+    assert!((20u16 == num::cast(20f)));\n+    assert!((20u16 == num::cast(20f32)));\n+    assert!((20u16 == num::cast(20f64)));\n }"}, {"sha": "cfc112be8a6d1a42d51f7ee96f8970363f3514ae", "filename": "src/libcore/num/uint-template/u32.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -45,45 +45,45 @@ impl NumCast for u32 {\n \n #[test]\n fn test_numcast() {\n-    fail_unless!((20u   == 20u64.to_uint()));\n-    fail_unless!((20u8  == 20u64.to_u8()));\n-    fail_unless!((20u16 == 20u64.to_u16()));\n-    fail_unless!((20u32 == 20u64.to_u32()));\n-    fail_unless!((20u64 == 20u64.to_u64()));\n-    fail_unless!((20i   == 20u64.to_int()));\n-    fail_unless!((20i8  == 20u64.to_i8()));\n-    fail_unless!((20i16 == 20u64.to_i16()));\n-    fail_unless!((20i32 == 20u64.to_i32()));\n-    fail_unless!((20i64 == 20u64.to_i64()));\n-    fail_unless!((20f   == 20u64.to_float()));\n-    fail_unless!((20f32 == 20u64.to_f32()));\n-    fail_unless!((20f64 == 20u64.to_f64()));\n+    assert!((20u   == 20u64.to_uint()));\n+    assert!((20u8  == 20u64.to_u8()));\n+    assert!((20u16 == 20u64.to_u16()));\n+    assert!((20u32 == 20u64.to_u32()));\n+    assert!((20u64 == 20u64.to_u64()));\n+    assert!((20i   == 20u64.to_int()));\n+    assert!((20i8  == 20u64.to_i8()));\n+    assert!((20i16 == 20u64.to_i16()));\n+    assert!((20i32 == 20u64.to_i32()));\n+    assert!((20i64 == 20u64.to_i64()));\n+    assert!((20f   == 20u64.to_float()));\n+    assert!((20f32 == 20u64.to_f32()));\n+    assert!((20f64 == 20u64.to_f64()));\n \n-    fail_unless!((20u64 == NumCast::from(20u)));\n-    fail_unless!((20u64 == NumCast::from(20u8)));\n-    fail_unless!((20u64 == NumCast::from(20u16)));\n-    fail_unless!((20u64 == NumCast::from(20u32)));\n-    fail_unless!((20u64 == NumCast::from(20u64)));\n-    fail_unless!((20u64 == NumCast::from(20i)));\n-    fail_unless!((20u64 == NumCast::from(20i8)));\n-    fail_unless!((20u64 == NumCast::from(20i16)));\n-    fail_unless!((20u64 == NumCast::from(20i32)));\n-    fail_unless!((20u64 == NumCast::from(20i64)));\n-    fail_unless!((20u64 == NumCast::from(20f)));\n-    fail_unless!((20u64 == NumCast::from(20f32)));\n-    fail_unless!((20u64 == NumCast::from(20f64)));\n+    assert!((20u64 == NumCast::from(20u)));\n+    assert!((20u64 == NumCast::from(20u8)));\n+    assert!((20u64 == NumCast::from(20u16)));\n+    assert!((20u64 == NumCast::from(20u32)));\n+    assert!((20u64 == NumCast::from(20u64)));\n+    assert!((20u64 == NumCast::from(20i)));\n+    assert!((20u64 == NumCast::from(20i8)));\n+    assert!((20u64 == NumCast::from(20i16)));\n+    assert!((20u64 == NumCast::from(20i32)));\n+    assert!((20u64 == NumCast::from(20i64)));\n+    assert!((20u64 == NumCast::from(20f)));\n+    assert!((20u64 == NumCast::from(20f32)));\n+    assert!((20u64 == NumCast::from(20f64)));\n \n-    fail_unless!((20u64 == num::cast(20u)));\n-    fail_unless!((20u64 == num::cast(20u8)));\n-    fail_unless!((20u64 == num::cast(20u16)));\n-    fail_unless!((20u64 == num::cast(20u32)));\n-    fail_unless!((20u64 == num::cast(20u64)));\n-    fail_unless!((20u64 == num::cast(20i)));\n-    fail_unless!((20u64 == num::cast(20i8)));\n-    fail_unless!((20u64 == num::cast(20i16)));\n-    fail_unless!((20u64 == num::cast(20i32)));\n-    fail_unless!((20u64 == num::cast(20i64)));\n-    fail_unless!((20u64 == num::cast(20f)));\n-    fail_unless!((20u64 == num::cast(20f32)));\n-    fail_unless!((20u64 == num::cast(20f64)));\n+    assert!((20u64 == num::cast(20u)));\n+    assert!((20u64 == num::cast(20u8)));\n+    assert!((20u64 == num::cast(20u16)));\n+    assert!((20u64 == num::cast(20u32)));\n+    assert!((20u64 == num::cast(20u64)));\n+    assert!((20u64 == num::cast(20i)));\n+    assert!((20u64 == num::cast(20i8)));\n+    assert!((20u64 == num::cast(20i16)));\n+    assert!((20u64 == num::cast(20i32)));\n+    assert!((20u64 == num::cast(20i64)));\n+    assert!((20u64 == num::cast(20f)));\n+    assert!((20u64 == num::cast(20f32)));\n+    assert!((20u64 == num::cast(20f64)));\n }"}, {"sha": "4e2f6640d697465c15970947535177cf554f73b1", "filename": "src/libcore/num/uint-template/u64.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -45,45 +45,45 @@ impl NumCast for u64 {\n \n #[test]\n fn test_numcast() {\n-    fail_unless!((20u   == 20u64.to_uint()));\n-    fail_unless!((20u8  == 20u64.to_u8()));\n-    fail_unless!((20u16 == 20u64.to_u16()));\n-    fail_unless!((20u32 == 20u64.to_u32()));\n-    fail_unless!((20u64 == 20u64.to_u64()));\n-    fail_unless!((20i   == 20u64.to_int()));\n-    fail_unless!((20i8  == 20u64.to_i8()));\n-    fail_unless!((20i16 == 20u64.to_i16()));\n-    fail_unless!((20i32 == 20u64.to_i32()));\n-    fail_unless!((20i64 == 20u64.to_i64()));\n-    fail_unless!((20f   == 20u64.to_float()));\n-    fail_unless!((20f32 == 20u64.to_f32()));\n-    fail_unless!((20f64 == 20u64.to_f64()));\n+    assert!((20u   == 20u64.to_uint()));\n+    assert!((20u8  == 20u64.to_u8()));\n+    assert!((20u16 == 20u64.to_u16()));\n+    assert!((20u32 == 20u64.to_u32()));\n+    assert!((20u64 == 20u64.to_u64()));\n+    assert!((20i   == 20u64.to_int()));\n+    assert!((20i8  == 20u64.to_i8()));\n+    assert!((20i16 == 20u64.to_i16()));\n+    assert!((20i32 == 20u64.to_i32()));\n+    assert!((20i64 == 20u64.to_i64()));\n+    assert!((20f   == 20u64.to_float()));\n+    assert!((20f32 == 20u64.to_f32()));\n+    assert!((20f64 == 20u64.to_f64()));\n \n-    fail_unless!((20u64 == NumCast::from(20u)));\n-    fail_unless!((20u64 == NumCast::from(20u8)));\n-    fail_unless!((20u64 == NumCast::from(20u16)));\n-    fail_unless!((20u64 == NumCast::from(20u32)));\n-    fail_unless!((20u64 == NumCast::from(20u64)));\n-    fail_unless!((20u64 == NumCast::from(20i)));\n-    fail_unless!((20u64 == NumCast::from(20i8)));\n-    fail_unless!((20u64 == NumCast::from(20i16)));\n-    fail_unless!((20u64 == NumCast::from(20i32)));\n-    fail_unless!((20u64 == NumCast::from(20i64)));\n-    fail_unless!((20u64 == NumCast::from(20f)));\n-    fail_unless!((20u64 == NumCast::from(20f32)));\n-    fail_unless!((20u64 == NumCast::from(20f64)));\n+    assert!((20u64 == NumCast::from(20u)));\n+    assert!((20u64 == NumCast::from(20u8)));\n+    assert!((20u64 == NumCast::from(20u16)));\n+    assert!((20u64 == NumCast::from(20u32)));\n+    assert!((20u64 == NumCast::from(20u64)));\n+    assert!((20u64 == NumCast::from(20i)));\n+    assert!((20u64 == NumCast::from(20i8)));\n+    assert!((20u64 == NumCast::from(20i16)));\n+    assert!((20u64 == NumCast::from(20i32)));\n+    assert!((20u64 == NumCast::from(20i64)));\n+    assert!((20u64 == NumCast::from(20f)));\n+    assert!((20u64 == NumCast::from(20f32)));\n+    assert!((20u64 == NumCast::from(20f64)));\n \n-    fail_unless!((20u64 == num::cast(20u)));\n-    fail_unless!((20u64 == num::cast(20u8)));\n-    fail_unless!((20u64 == num::cast(20u16)));\n-    fail_unless!((20u64 == num::cast(20u32)));\n-    fail_unless!((20u64 == num::cast(20u64)));\n-    fail_unless!((20u64 == num::cast(20i)));\n-    fail_unless!((20u64 == num::cast(20i8)));\n-    fail_unless!((20u64 == num::cast(20i16)));\n-    fail_unless!((20u64 == num::cast(20i32)));\n-    fail_unless!((20u64 == num::cast(20i64)));\n-    fail_unless!((20u64 == num::cast(20f)));\n-    fail_unless!((20u64 == num::cast(20f32)));\n-    fail_unless!((20u64 == num::cast(20f64)));\n+    assert!((20u64 == num::cast(20u)));\n+    assert!((20u64 == num::cast(20u8)));\n+    assert!((20u64 == num::cast(20u16)));\n+    assert!((20u64 == num::cast(20u32)));\n+    assert!((20u64 == num::cast(20u64)));\n+    assert!((20u64 == num::cast(20i)));\n+    assert!((20u64 == num::cast(20i8)));\n+    assert!((20u64 == num::cast(20i16)));\n+    assert!((20u64 == num::cast(20i32)));\n+    assert!((20u64 == num::cast(20i64)));\n+    assert!((20u64 == num::cast(20f)));\n+    assert!((20u64 == num::cast(20f32)));\n+    assert!((20u64 == num::cast(20f64)));\n }"}, {"sha": "52bc56b955cc1cd1e660f6914fc07c1b9b9a6744", "filename": "src/libcore/num/uint-template/u8.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -52,45 +52,45 @@ impl NumCast for u8 {\n \n #[test]\n fn test_numcast() {\n-    fail_unless!((20u     == 20u8.to_uint()));\n-    fail_unless!((20u8    == 20u8.to_u8()));\n-    fail_unless!((20u16   == 20u8.to_u16()));\n-    fail_unless!((20u32   == 20u8.to_u32()));\n-    fail_unless!((20u64   == 20u8.to_u64()));\n-    fail_unless!((20i     == 20u8.to_int()));\n-    fail_unless!((20i8    == 20u8.to_i8()));\n-    fail_unless!((20i16   == 20u8.to_i16()));\n-    fail_unless!((20i32   == 20u8.to_i32()));\n-    fail_unless!((20i64   == 20u8.to_i64()));\n-    fail_unless!((20f     == 20u8.to_float()));\n-    fail_unless!((20f32   == 20u8.to_f32()));\n-    fail_unless!((20f64   == 20u8.to_f64()));\n+    assert!((20u     == 20u8.to_uint()));\n+    assert!((20u8    == 20u8.to_u8()));\n+    assert!((20u16   == 20u8.to_u16()));\n+    assert!((20u32   == 20u8.to_u32()));\n+    assert!((20u64   == 20u8.to_u64()));\n+    assert!((20i     == 20u8.to_int()));\n+    assert!((20i8    == 20u8.to_i8()));\n+    assert!((20i16   == 20u8.to_i16()));\n+    assert!((20i32   == 20u8.to_i32()));\n+    assert!((20i64   == 20u8.to_i64()));\n+    assert!((20f     == 20u8.to_float()));\n+    assert!((20f32   == 20u8.to_f32()));\n+    assert!((20f64   == 20u8.to_f64()));\n \n-    fail_unless!((20u8 == NumCast::from(20u)));\n-    fail_unless!((20u8 == NumCast::from(20u8)));\n-    fail_unless!((20u8 == NumCast::from(20u16)));\n-    fail_unless!((20u8 == NumCast::from(20u32)));\n-    fail_unless!((20u8 == NumCast::from(20u64)));\n-    fail_unless!((20u8 == NumCast::from(20i)));\n-    fail_unless!((20u8 == NumCast::from(20i8)));\n-    fail_unless!((20u8 == NumCast::from(20i16)));\n-    fail_unless!((20u8 == NumCast::from(20i32)));\n-    fail_unless!((20u8 == NumCast::from(20i64)));\n-    fail_unless!((20u8 == NumCast::from(20f)));\n-    fail_unless!((20u8 == NumCast::from(20f32)));\n-    fail_unless!((20u8 == NumCast::from(20f64)));\n+    assert!((20u8 == NumCast::from(20u)));\n+    assert!((20u8 == NumCast::from(20u8)));\n+    assert!((20u8 == NumCast::from(20u16)));\n+    assert!((20u8 == NumCast::from(20u32)));\n+    assert!((20u8 == NumCast::from(20u64)));\n+    assert!((20u8 == NumCast::from(20i)));\n+    assert!((20u8 == NumCast::from(20i8)));\n+    assert!((20u8 == NumCast::from(20i16)));\n+    assert!((20u8 == NumCast::from(20i32)));\n+    assert!((20u8 == NumCast::from(20i64)));\n+    assert!((20u8 == NumCast::from(20f)));\n+    assert!((20u8 == NumCast::from(20f32)));\n+    assert!((20u8 == NumCast::from(20f64)));\n \n-    fail_unless!((20u8 == num::cast(20u)));\n-    fail_unless!((20u8 == num::cast(20u8)));\n-    fail_unless!((20u8 == num::cast(20u16)));\n-    fail_unless!((20u8 == num::cast(20u32)));\n-    fail_unless!((20u8 == num::cast(20u64)));\n-    fail_unless!((20u8 == num::cast(20i)));\n-    fail_unless!((20u8 == num::cast(20i8)));\n-    fail_unless!((20u8 == num::cast(20i16)));\n-    fail_unless!((20u8 == num::cast(20i32)));\n-    fail_unless!((20u8 == num::cast(20i64)));\n-    fail_unless!((20u8 == num::cast(20f)));\n-    fail_unless!((20u8 == num::cast(20f32)));\n-    fail_unless!((20u8 == num::cast(20f64)));\n+    assert!((20u8 == num::cast(20u)));\n+    assert!((20u8 == num::cast(20u8)));\n+    assert!((20u8 == num::cast(20u16)));\n+    assert!((20u8 == num::cast(20u32)));\n+    assert!((20u8 == num::cast(20u64)));\n+    assert!((20u8 == num::cast(20i)));\n+    assert!((20u8 == num::cast(20i8)));\n+    assert!((20u8 == num::cast(20i16)));\n+    assert!((20u8 == num::cast(20i32)));\n+    assert!((20u8 == num::cast(20i64)));\n+    assert!((20u8 == num::cast(20f)));\n+    assert!((20u8 == num::cast(20f32)));\n+    assert!((20u8 == num::cast(20f64)));\n }"}, {"sha": "16e53eb4b6c9719e7e6a36879856a03315e56601", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -143,61 +143,61 @@ pub mod inst {\n \n     #[test]\n     fn test_next_power_of_two() {\n-        fail_unless!((next_power_of_two(0u) == 0u));\n-        fail_unless!((next_power_of_two(1u) == 1u));\n-        fail_unless!((next_power_of_two(2u) == 2u));\n-        fail_unless!((next_power_of_two(3u) == 4u));\n-        fail_unless!((next_power_of_two(4u) == 4u));\n-        fail_unless!((next_power_of_two(5u) == 8u));\n-        fail_unless!((next_power_of_two(6u) == 8u));\n-        fail_unless!((next_power_of_two(7u) == 8u));\n-        fail_unless!((next_power_of_two(8u) == 8u));\n-        fail_unless!((next_power_of_two(9u) == 16u));\n-        fail_unless!((next_power_of_two(10u) == 16u));\n-        fail_unless!((next_power_of_two(11u) == 16u));\n-        fail_unless!((next_power_of_two(12u) == 16u));\n-        fail_unless!((next_power_of_two(13u) == 16u));\n-        fail_unless!((next_power_of_two(14u) == 16u));\n-        fail_unless!((next_power_of_two(15u) == 16u));\n-        fail_unless!((next_power_of_two(16u) == 16u));\n-        fail_unless!((next_power_of_two(17u) == 32u));\n-        fail_unless!((next_power_of_two(18u) == 32u));\n-        fail_unless!((next_power_of_two(19u) == 32u));\n-        fail_unless!((next_power_of_two(20u) == 32u));\n-        fail_unless!((next_power_of_two(21u) == 32u));\n-        fail_unless!((next_power_of_two(22u) == 32u));\n-        fail_unless!((next_power_of_two(23u) == 32u));\n-        fail_unless!((next_power_of_two(24u) == 32u));\n-        fail_unless!((next_power_of_two(25u) == 32u));\n-        fail_unless!((next_power_of_two(26u) == 32u));\n-        fail_unless!((next_power_of_two(27u) == 32u));\n-        fail_unless!((next_power_of_two(28u) == 32u));\n-        fail_unless!((next_power_of_two(29u) == 32u));\n-        fail_unless!((next_power_of_two(30u) == 32u));\n-        fail_unless!((next_power_of_two(31u) == 32u));\n-        fail_unless!((next_power_of_two(32u) == 32u));\n-        fail_unless!((next_power_of_two(33u) == 64u));\n-        fail_unless!((next_power_of_two(34u) == 64u));\n-        fail_unless!((next_power_of_two(35u) == 64u));\n-        fail_unless!((next_power_of_two(36u) == 64u));\n-        fail_unless!((next_power_of_two(37u) == 64u));\n-        fail_unless!((next_power_of_two(38u) == 64u));\n-        fail_unless!((next_power_of_two(39u) == 64u));\n+        assert!((next_power_of_two(0u) == 0u));\n+        assert!((next_power_of_two(1u) == 1u));\n+        assert!((next_power_of_two(2u) == 2u));\n+        assert!((next_power_of_two(3u) == 4u));\n+        assert!((next_power_of_two(4u) == 4u));\n+        assert!((next_power_of_two(5u) == 8u));\n+        assert!((next_power_of_two(6u) == 8u));\n+        assert!((next_power_of_two(7u) == 8u));\n+        assert!((next_power_of_two(8u) == 8u));\n+        assert!((next_power_of_two(9u) == 16u));\n+        assert!((next_power_of_two(10u) == 16u));\n+        assert!((next_power_of_two(11u) == 16u));\n+        assert!((next_power_of_two(12u) == 16u));\n+        assert!((next_power_of_two(13u) == 16u));\n+        assert!((next_power_of_two(14u) == 16u));\n+        assert!((next_power_of_two(15u) == 16u));\n+        assert!((next_power_of_two(16u) == 16u));\n+        assert!((next_power_of_two(17u) == 32u));\n+        assert!((next_power_of_two(18u) == 32u));\n+        assert!((next_power_of_two(19u) == 32u));\n+        assert!((next_power_of_two(20u) == 32u));\n+        assert!((next_power_of_two(21u) == 32u));\n+        assert!((next_power_of_two(22u) == 32u));\n+        assert!((next_power_of_two(23u) == 32u));\n+        assert!((next_power_of_two(24u) == 32u));\n+        assert!((next_power_of_two(25u) == 32u));\n+        assert!((next_power_of_two(26u) == 32u));\n+        assert!((next_power_of_two(27u) == 32u));\n+        assert!((next_power_of_two(28u) == 32u));\n+        assert!((next_power_of_two(29u) == 32u));\n+        assert!((next_power_of_two(30u) == 32u));\n+        assert!((next_power_of_two(31u) == 32u));\n+        assert!((next_power_of_two(32u) == 32u));\n+        assert!((next_power_of_two(33u) == 64u));\n+        assert!((next_power_of_two(34u) == 64u));\n+        assert!((next_power_of_two(35u) == 64u));\n+        assert!((next_power_of_two(36u) == 64u));\n+        assert!((next_power_of_two(37u) == 64u));\n+        assert!((next_power_of_two(38u) == 64u));\n+        assert!((next_power_of_two(39u) == 64u));\n     }\n \n     #[test]\n     fn test_overflows() {\n         use uint;\n-        fail_unless!((uint::max_value > 0u));\n-        fail_unless!((uint::min_value <= 0u));\n-        fail_unless!((uint::min_value + uint::max_value + 1u == 0u));\n+        assert!((uint::max_value > 0u));\n+        assert!((uint::min_value <= 0u));\n+        assert!((uint::min_value + uint::max_value + 1u == 0u));\n     }\n \n     #[test]\n     fn test_div() {\n-        fail_unless!((div_floor(3u, 4u) == 0u));\n-        fail_unless!((div_ceil(3u, 4u)  == 1u));\n-        fail_unless!((div_round(3u, 4u) == 1u));\n+        assert!((div_floor(3u, 4u) == 0u));\n+        assert!((div_ceil(3u, 4u)  == 1u));\n+        assert!((div_round(3u, 4u) == 1u));\n     }\n \n     #[test]\n@@ -206,7 +206,7 @@ pub mod inst {\n         let ten = 10 as uint;\n         let mut accum = 0;\n         for ten.times { accum += 1; }\n-        fail_unless!((accum == 10));\n+        assert!((accum == 10));\n     }\n }\n \n@@ -236,45 +236,45 @@ impl NumCast for uint {\n \n #[test]\n fn test_numcast() {\n-    fail_unless!((20u   == 20u.to_uint()));\n-    fail_unless!((20u8  == 20u.to_u8()));\n-    fail_unless!((20u16 == 20u.to_u16()));\n-    fail_unless!((20u32 == 20u.to_u32()));\n-    fail_unless!((20u64 == 20u.to_u64()));\n-    fail_unless!((20i   == 20u.to_int()));\n-    fail_unless!((20i8  == 20u.to_i8()));\n-    fail_unless!((20i16 == 20u.to_i16()));\n-    fail_unless!((20i32 == 20u.to_i32()));\n-    fail_unless!((20i64 == 20u.to_i64()));\n-    fail_unless!((20f   == 20u.to_float()));\n-    fail_unless!((20f32 == 20u.to_f32()));\n-    fail_unless!((20f64 == 20u.to_f64()));\n+    assert!((20u   == 20u.to_uint()));\n+    assert!((20u8  == 20u.to_u8()));\n+    assert!((20u16 == 20u.to_u16()));\n+    assert!((20u32 == 20u.to_u32()));\n+    assert!((20u64 == 20u.to_u64()));\n+    assert!((20i   == 20u.to_int()));\n+    assert!((20i8  == 20u.to_i8()));\n+    assert!((20i16 == 20u.to_i16()));\n+    assert!((20i32 == 20u.to_i32()));\n+    assert!((20i64 == 20u.to_i64()));\n+    assert!((20f   == 20u.to_float()));\n+    assert!((20f32 == 20u.to_f32()));\n+    assert!((20f64 == 20u.to_f64()));\n \n-    fail_unless!((20u == NumCast::from(20u)));\n-    fail_unless!((20u == NumCast::from(20u8)));\n-    fail_unless!((20u == NumCast::from(20u16)));\n-    fail_unless!((20u == NumCast::from(20u32)));\n-    fail_unless!((20u == NumCast::from(20u64)));\n-    fail_unless!((20u == NumCast::from(20i)));\n-    fail_unless!((20u == NumCast::from(20i8)));\n-    fail_unless!((20u == NumCast::from(20i16)));\n-    fail_unless!((20u == NumCast::from(20i32)));\n-    fail_unless!((20u == NumCast::from(20i64)));\n-    fail_unless!((20u == NumCast::from(20f)));\n-    fail_unless!((20u == NumCast::from(20f32)));\n-    fail_unless!((20u == NumCast::from(20f64)));\n+    assert!((20u == NumCast::from(20u)));\n+    assert!((20u == NumCast::from(20u8)));\n+    assert!((20u == NumCast::from(20u16)));\n+    assert!((20u == NumCast::from(20u32)));\n+    assert!((20u == NumCast::from(20u64)));\n+    assert!((20u == NumCast::from(20i)));\n+    assert!((20u == NumCast::from(20i8)));\n+    assert!((20u == NumCast::from(20i16)));\n+    assert!((20u == NumCast::from(20i32)));\n+    assert!((20u == NumCast::from(20i64)));\n+    assert!((20u == NumCast::from(20f)));\n+    assert!((20u == NumCast::from(20f32)));\n+    assert!((20u == NumCast::from(20f64)));\n \n-    fail_unless!((20u == num::cast(20u)));\n-    fail_unless!((20u == num::cast(20u8)));\n-    fail_unless!((20u == num::cast(20u16)));\n-    fail_unless!((20u == num::cast(20u32)));\n-    fail_unless!((20u == num::cast(20u64)));\n-    fail_unless!((20u == num::cast(20i)));\n-    fail_unless!((20u == num::cast(20i8)));\n-    fail_unless!((20u == num::cast(20i16)));\n-    fail_unless!((20u == num::cast(20i32)));\n-    fail_unless!((20u == num::cast(20i64)));\n-    fail_unless!((20u == num::cast(20f)));\n-    fail_unless!((20u == num::cast(20f32)));\n-    fail_unless!((20u == num::cast(20f64)));\n+    assert!((20u == num::cast(20u)));\n+    assert!((20u == num::cast(20u8)));\n+    assert!((20u == num::cast(20u16)));\n+    assert!((20u == num::cast(20u32)));\n+    assert!((20u == num::cast(20u64)));\n+    assert!((20u == num::cast(20i)));\n+    assert!((20u == num::cast(20i8)));\n+    assert!((20u == num::cast(20i16)));\n+    assert!((20u == num::cast(20i32)));\n+    assert!((20u == num::cast(20i64)));\n+    assert!((20u == num::cast(20f)));\n+    assert!((20u == num::cast(20f32)));\n+    assert!((20u == num::cast(20f64)));\n }"}, {"sha": "cd34d7ab0c0bbab7ca784cc41803c84de431bac9", "filename": "src/libcore/option.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -356,7 +356,7 @@ fn test_unwrap_ptr() {\n     let opt = Some(x);\n     let y = opt.unwrap();\n     let addr_y = ptr::addr_of(&(*y));\n-    fail_unless!(addr_x == addr_y);\n+    assert!(addr_x == addr_y);\n }\n \n #[test]\n@@ -366,7 +366,7 @@ fn test_unwrap_str() {\n     let opt = Some(x);\n     let y = opt.unwrap();\n     let addr_y = str::as_buf(y, |buf, _len| buf);\n-    fail_unless!(addr_x == addr_y);\n+    assert!(addr_x == addr_y);\n }\n \n #[test]\n@@ -392,7 +392,7 @@ fn test_unwrap_resource() {\n         let opt = Some(x);\n         let _y = opt.unwrap();\n     }\n-    fail_unless!(*i == 1);\n+    assert!(*i == 1);\n }\n \n #[test]\n@@ -403,8 +403,8 @@ fn test_option_dance() {\n     for x.each |_x| {\n         y2 = y.swap_unwrap();\n     }\n-    fail_unless!(y2 == 5);\n-    fail_unless!(y.is_none());\n+    assert!(y2 == 5);\n+    assert!(y.is_none());\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_option_too_much_dance() {\n@@ -424,15 +424,15 @@ fn test_option_while_some() {\n             None\n         }\n     }\n-    fail_unless!(i == 11);\n+    assert!(i == 11);\n }\n \n #[test]\n fn test_get_or_zero() {\n     let some_stuff = Some(42);\n-    fail_unless!(some_stuff.get_or_zero() == 42);\n+    assert!(some_stuff.get_or_zero() == 42);\n     let no_stuff: Option<int> = None;\n-    fail_unless!(no_stuff.get_or_zero() == 0);\n+    assert!(no_stuff.get_or_zero() == 0);\n }\n \n // Local Variables:"}, {"sha": "7dbc177399413ec43f185ff80b716ec6649bcbb3", "filename": "src/libcore/os.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -222,7 +222,7 @@ pub fn env() -> ~[(~str,~str)] {\n                 for str::each_splitn_char(*p, '=', 1) |s| { vs.push(s.to_owned()) }\n                 debug!(\"splitting: len: %u\",\n                     vs.len());\n-                fail_unless!(vs.len() == 2);\n+                assert!(vs.len() == 2);\n                 pairs.push((copy vs[0], copy vs[1]));\n             }\n             pairs\n@@ -366,7 +366,7 @@ pub fn waitpid(pid: pid_t) -> c_int {\n         use libc::funcs::posix01::wait::*;\n         let mut status = 0 as c_int;\n \n-        fail_unless!((waitpid(pid, &mut status, 0 as c_int) !=\n+        assert!((waitpid(pid, &mut status, 0 as c_int) !=\n                      (-1 as c_int)));\n         return status;\n     }\n@@ -380,7 +380,7 @@ pub fn pipe() -> Pipe {\n     unsafe {\n         let mut fds = Pipe {in: 0 as c_int,\n                         out: 0 as c_int };\n-        fail_unless!((libc::pipe(&mut fds.in) == (0 as c_int)));\n+        assert!((libc::pipe(&mut fds.in) == (0 as c_int)));\n         return Pipe {in: fds.in, out: fds.out};\n     }\n }\n@@ -399,9 +399,9 @@ pub fn pipe() -> Pipe {\n                     out: 0 as c_int };\n         let res = libc::pipe(&mut fds.in, 1024 as ::libc::c_uint,\n                              (libc::O_BINARY | libc::O_NOINHERIT) as c_int);\n-        fail_unless!((res == 0 as c_int));\n-        fail_unless!((fds.in != -1 as c_int && fds.in != 0 as c_int));\n-        fail_unless!((fds.out != -1 as c_int && fds.in != 0 as c_int));\n+        assert!((res == 0 as c_int));\n+        assert!((fds.in != -1 as c_int && fds.in != 0 as c_int));\n+        assert!((fds.out != -1 as c_int && fds.in != 0 as c_int));\n         return Pipe {in: fds.in, out: fds.out};\n     }\n }\n@@ -1277,21 +1277,21 @@ mod tests {\n     #[test]\n     pub fn test_args() {\n         let a = real_args();\n-        fail_unless!(a.len() >= 1);\n+        assert!(a.len() >= 1);\n     }\n \n     fn make_rand_name() -> ~str {\n         let rng: @rand::Rng = rand::Rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n-        fail_unless!(getenv(n).is_none());\n+        assert!(getenv(n).is_none());\n         n\n     }\n \n     #[test]\n     fn test_setenv() {\n         let n = make_rand_name();\n         setenv(n, ~\"VALUE\");\n-        fail_unless!(getenv(n) == option::Some(~\"VALUE\"));\n+        assert!(getenv(n) == option::Some(~\"VALUE\"));\n     }\n \n     #[test]\n@@ -1301,9 +1301,9 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, ~\"1\");\n         setenv(n, ~\"2\");\n-        fail_unless!(getenv(n) == option::Some(~\"2\"));\n+        assert!(getenv(n) == option::Some(~\"2\"));\n         setenv(n, ~\"\");\n-        fail_unless!(getenv(n) == option::Some(~\"\"));\n+        assert!(getenv(n) == option::Some(~\"\"));\n     }\n \n     // Windows GetEnvironmentVariable requires some extra work to make sure\n@@ -1318,33 +1318,33 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, s);\n         debug!(copy s);\n-        fail_unless!(getenv(n) == option::Some(s));\n+        assert!(getenv(n) == option::Some(s));\n     }\n \n     #[test]\n     fn test_self_exe_path() {\n         let path = os::self_exe_path();\n-        fail_unless!(path.is_some());\n+        assert!(path.is_some());\n         let path = path.get();\n         debug!(copy path);\n \n         // Hard to test this function\n-        fail_unless!(path.is_absolute);\n+        assert!(path.is_absolute);\n     }\n \n     #[test]\n     #[ignore]\n     fn test_env_getenv() {\n         let e = env();\n-        fail_unless!(vec::len(e) > 0u);\n+        assert!(vec::len(e) > 0u);\n         for vec::each(e) |p| {\n             let (n, v) = copy *p;\n             debug!(copy n);\n             let v2 = getenv(n);\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n             // from env() but not visible from getenv().\n-            fail_unless!(v2.is_none() || v2 == option::Some(v));\n+            assert!(v2.is_none() || v2 == option::Some(v));\n         }\n     }\n \n@@ -1354,15 +1354,15 @@ mod tests {\n \n         let mut e = env();\n         setenv(n, ~\"VALUE\");\n-        fail_unless!(!vec::contains(e, &(copy n, ~\"VALUE\")));\n+        assert!(!vec::contains(e, &(copy n, ~\"VALUE\")));\n \n         e = env();\n-        fail_unless!(vec::contains(e, &(n, ~\"VALUE\")));\n+        assert!(vec::contains(e, &(n, ~\"VALUE\")));\n     }\n \n     #[test]\n     fn test() {\n-        fail_unless!((!Path(\"test-path\").is_absolute));\n+        assert!((!Path(\"test-path\").is_absolute));\n \n         debug!(~\"Current working directory: \" + getcwd().to_str());\n \n@@ -1376,10 +1376,10 @@ mod tests {\n         let oldhome = getenv(~\"HOME\");\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n-        fail_unless!(os::homedir() == Some(Path(\"/home/MountainView\")));\n+        assert!(os::homedir() == Some(Path(\"/home/MountainView\")));\n \n         setenv(~\"HOME\", ~\"\");\n-        fail_unless!(os::homedir().is_none());\n+        assert!(os::homedir().is_none());\n \n         for oldhome.each |s| { setenv(~\"HOME\", *s) }\n     }\n@@ -1394,27 +1394,27 @@ mod tests {\n         setenv(~\"HOME\", ~\"\");\n         setenv(~\"USERPROFILE\", ~\"\");\n \n-        fail_unless!(os::homedir().is_none());\n+        assert!(os::homedir().is_none());\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n-        fail_unless!(os::homedir() == Some(Path(\"/home/MountainView\")));\n+        assert!(os::homedir() == Some(Path(\"/home/MountainView\")));\n \n         setenv(~\"HOME\", ~\"\");\n \n         setenv(~\"USERPROFILE\", ~\"/home/MountainView\");\n-        fail_unless!(os::homedir() == Some(Path(\"/home/MountainView\")));\n+        assert!(os::homedir() == Some(Path(\"/home/MountainView\")));\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n         setenv(~\"USERPROFILE\", ~\"/home/PaloAlto\");\n-        fail_unless!(os::homedir() == Some(Path(\"/home/MountainView\")));\n+        assert!(os::homedir() == Some(Path(\"/home/MountainView\")));\n \n         oldhome.each(|s| {setenv(~\"HOME\", *s);true});\n         olduserprofile.each(|s| {setenv(~\"USERPROFILE\", *s);true});\n     }\n \n     #[test]\n     fn tmpdir() {\n-        fail_unless!(!str::is_empty(os::tmpdir().to_str()));\n+        assert!(!str::is_empty(os::tmpdir().to_str()));\n     }\n \n     // Issue #712\n@@ -1427,7 +1427,7 @@ mod tests {\n     fn list_dir() {\n         let dirs = os::list_dir(&Path(\".\"));\n         // Just assuming that we've got some contents in the current directory\n-        fail_unless!((vec::len(dirs) > 0u));\n+        assert!((vec::len(dirs) > 0u));\n \n         for vec::each(dirs) |dir| {\n             debug!(copy *dir);\n@@ -1436,30 +1436,30 @@ mod tests {\n \n     #[test]\n     fn path_is_dir() {\n-        fail_unless!((os::path_is_dir(&Path(\".\"))));\n-        fail_unless!((!os::path_is_dir(&Path(\"test/stdtest/fs.rs\"))));\n+        assert!((os::path_is_dir(&Path(\".\"))));\n+        assert!((!os::path_is_dir(&Path(\"test/stdtest/fs.rs\"))));\n     }\n \n     #[test]\n     fn path_exists() {\n-        fail_unless!((os::path_exists(&Path(\".\"))));\n-        fail_unless!((!os::path_exists(&Path(\n+        assert!((os::path_exists(&Path(\".\"))));\n+        assert!((!os::path_exists(&Path(\n                      \"test/nonexistent-bogus-path\"))));\n     }\n \n     #[test]\n     fn copy_file_does_not_exist() {\n-      fail_unless!(!os::copy_file(&Path(\"test/nonexistent-bogus-path\"),\n+      assert!(!os::copy_file(&Path(\"test/nonexistent-bogus-path\"),\n                             &Path(\"test/other-bogus-path\")));\n-      fail_unless!(!os::path_exists(&Path(\"test/other-bogus-path\")));\n+      assert!(!os::path_exists(&Path(\"test/other-bogus-path\")));\n     }\n \n     #[test]\n     fn copy_file_ok() {\n         unsafe {\n           let tempdir = getcwd(); // would like to use $TMPDIR,\n                                   // doesn't seem to work on Linux\n-          fail_unless!((str::len(tempdir.to_str()) > 0u));\n+          assert!((str::len(tempdir.to_str()) > 0u));\n           let in = tempdir.push(\"in.txt\");\n           let out = tempdir.push(\"out.txt\");\n \n@@ -1469,24 +1469,24 @@ mod tests {\n                     libc::fopen(fromp, modebuf)\n                 }\n           };\n-          fail_unless!((ostream as uint != 0u));\n+          assert!((ostream as uint != 0u));\n           let s = ~\"hello\";\n           let mut buf = str::to_bytes(s) + ~[0 as u8];\n           do vec::as_mut_buf(buf) |b, _len| {\n-              fail_unless!((libc::fwrite(b as *c_void, 1u as size_t,\n+              assert!((libc::fwrite(b as *c_void, 1u as size_t,\n                                    (str::len(s) + 1u) as size_t, ostream)\n                       == buf.len() as size_t))\n           }\n-          fail_unless!((libc::fclose(ostream) == (0u as c_int)));\n+          assert!((libc::fclose(ostream) == (0u as c_int)));\n           let rs = os::copy_file(&in, &out);\n           if (!os::path_exists(&in)) {\n             fail!(fmt!(\"%s doesn't exist\", in.to_str()));\n           }\n-          fail_unless!((rs));\n+          assert!((rs));\n           let rslt = run::run_program(~\"diff\", ~[in.to_str(), out.to_str()]);\n-          fail_unless!((rslt == 0));\n-          fail_unless!((remove_file(&in)));\n-          fail_unless!((remove_file(&out)));\n+          assert!((rslt == 0));\n+          assert!((remove_file(&in)));\n+          assert!((remove_file(&out)));\n         }\n     }\n }"}, {"sha": "7de0f355dd21d4dd3277c894a1e27c767b6a22e9", "filename": "src/libcore/path.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -440,7 +440,7 @@ impl GenericPath for PosixPath {\n \n     fn with_filename(&self, f: &str) -> PosixPath {\n         unsafe {\n-            fail_unless!(! str::any(f, |c| windows::is_sep(c as u8)));\n+            assert!(! str::any(f, |c| windows::is_sep(c as u8)));\n             self.dir_path().push(f)\n         }\n     }\n@@ -485,7 +485,7 @@ impl GenericPath for PosixPath {\n     }\n \n     fn push_rel(&self, other: &PosixPath) -> PosixPath {\n-        fail_unless!(!other.is_absolute);\n+        assert!(!other.is_absolute);\n         self.push_many(other.components)\n     }\n \n@@ -657,7 +657,7 @@ impl GenericPath for WindowsPath {\n     }\n \n     fn with_filename(&self, f: &str) -> WindowsPath {\n-        fail_unless!(! str::any(f, |c| windows::is_sep(c as u8)));\n+        assert!(! str::any(f, |c| windows::is_sep(c as u8)));\n         self.dir_path().push(f)\n     }\n \n@@ -704,7 +704,7 @@ impl GenericPath for WindowsPath {\n     }\n \n     fn push_rel(&self, other: &WindowsPath) -> WindowsPath {\n-        fail_unless!(!other.is_absolute);\n+        assert!(!other.is_absolute);\n         self.push_many(other.components)\n     }\n \n@@ -891,30 +891,30 @@ mod tests {\n         let path = PosixPath(\"tmp/\");\n         let path = path.push(\"/hmm\");\n         let path = path.normalize();\n-        fail_unless!(~\"tmp/hmm\" == path.to_str());\n+        assert!(~\"tmp/hmm\" == path.to_str());\n \n         let path = WindowsPath(\"tmp/\");\n         let path = path.push(\"/hmm\");\n         let path = path.normalize();\n-        fail_unless!(~\"tmp\\\\hmm\" == path.to_str());\n+        assert!(~\"tmp\\\\hmm\" == path.to_str());\n     }\n \n     #[test]\n     fn test_filetype_foo_bar() {\n         let wp = PosixPath(\"foo.bar\");\n-        fail_unless!(wp.filetype() == Some(~\".bar\"));\n+        assert!(wp.filetype() == Some(~\".bar\"));\n \n         let wp = WindowsPath(\"foo.bar\");\n-        fail_unless!(wp.filetype() == Some(~\".bar\"));\n+        assert!(wp.filetype() == Some(~\".bar\"));\n     }\n \n     #[test]\n     fn test_filetype_foo() {\n         let wp = PosixPath(\"foo\");\n-        fail_unless!(wp.filetype() == None);\n+        assert!(wp.filetype() == None);\n \n         let wp = WindowsPath(\"foo\");\n-        fail_unless!(wp.filetype() == None);\n+        assert!(wp.filetype() == None);\n     }\n \n     #[test]\n@@ -925,7 +925,7 @@ mod tests {\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n-                fail_unless!(ss == sss);\n+                assert!(ss == sss);\n             }\n         }\n \n@@ -983,7 +983,7 @@ mod tests {\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n-                fail_unless!(ss == sss);\n+                assert!(ss == sss);\n             }\n         }\n \n@@ -999,42 +999,42 @@ mod tests {\n \n     #[test]\n     fn test_extract_unc_prefixes() {\n-        fail_unless!(windows::extract_unc_prefix(\"\\\\\\\\\").is_none());\n-        fail_unless!(windows::extract_unc_prefix(\"//\").is_none());\n-        fail_unless!(windows::extract_unc_prefix(\"\\\\\\\\hi\").is_none());\n-        fail_unless!(windows::extract_unc_prefix(\"//hi\").is_none());\n-        fail_unless!(windows::extract_unc_prefix(\"\\\\\\\\hi\\\\\") ==\n+        assert!(windows::extract_unc_prefix(\"\\\\\\\\\").is_none());\n+        assert!(windows::extract_unc_prefix(\"//\").is_none());\n+        assert!(windows::extract_unc_prefix(\"\\\\\\\\hi\").is_none());\n+        assert!(windows::extract_unc_prefix(\"//hi\").is_none());\n+        assert!(windows::extract_unc_prefix(\"\\\\\\\\hi\\\\\") ==\n             Some((~\"hi\", ~\"\\\\\")));\n-        fail_unless!(windows::extract_unc_prefix(\"//hi\\\\\") ==\n+        assert!(windows::extract_unc_prefix(\"//hi\\\\\") ==\n             Some((~\"hi\", ~\"\\\\\")));\n-        fail_unless!(windows::extract_unc_prefix(\"\\\\\\\\hi\\\\there\") ==\n+        assert!(windows::extract_unc_prefix(\"\\\\\\\\hi\\\\there\") ==\n             Some((~\"hi\", ~\"\\\\there\")));\n-        fail_unless!(windows::extract_unc_prefix(\"//hi/there\") ==\n+        assert!(windows::extract_unc_prefix(\"//hi/there\") ==\n             Some((~\"hi\", ~\"/there\")));\n-        fail_unless!(windows::extract_unc_prefix(\n+        assert!(windows::extract_unc_prefix(\n             \"\\\\\\\\hi\\\\there\\\\friends.txt\") ==\n             Some((~\"hi\", ~\"\\\\there\\\\friends.txt\")));\n-        fail_unless!(windows::extract_unc_prefix(\n+        assert!(windows::extract_unc_prefix(\n             \"//hi\\\\there\\\\friends.txt\") ==\n             Some((~\"hi\", ~\"\\\\there\\\\friends.txt\")));\n     }\n \n     #[test]\n     fn test_extract_drive_prefixes() {\n-        fail_unless!(windows::extract_drive_prefix(\"c\").is_none());\n-        fail_unless!(windows::extract_drive_prefix(\"c:\") ==\n+        assert!(windows::extract_drive_prefix(\"c\").is_none());\n+        assert!(windows::extract_drive_prefix(\"c:\") ==\n                      Some((~\"c\", ~\"\")));\n-        fail_unless!(windows::extract_drive_prefix(\"d:\") ==\n+        assert!(windows::extract_drive_prefix(\"d:\") ==\n                      Some((~\"d\", ~\"\")));\n-        fail_unless!(windows::extract_drive_prefix(\"z:\") ==\n+        assert!(windows::extract_drive_prefix(\"z:\") ==\n                      Some((~\"z\", ~\"\")));\n-        fail_unless!(windows::extract_drive_prefix(\"c:\\\\hi\") ==\n+        assert!(windows::extract_drive_prefix(\"c:\\\\hi\") ==\n                      Some((~\"c\", ~\"\\\\hi\")));\n-        fail_unless!(windows::extract_drive_prefix(\"d:hi\") ==\n+        assert!(windows::extract_drive_prefix(\"d:hi\") ==\n                      Some((~\"d\", ~\"hi\")));\n-        fail_unless!(windows::extract_drive_prefix(\"c:hi\\\\there.txt\") ==\n+        assert!(windows::extract_drive_prefix(\"c:hi\\\\there.txt\") ==\n                      Some((~\"c\", ~\"hi\\\\there.txt\")));\n-        fail_unless!(windows::extract_drive_prefix(\"c:\\\\hi\\\\there.txt\") ==\n+        assert!(windows::extract_drive_prefix(\"c:\\\\hi\\\\there.txt\") ==\n                      Some((~\"c\", ~\"\\\\hi\\\\there.txt\")));\n     }\n \n@@ -1046,7 +1046,7 @@ mod tests {\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n-                fail_unless!(ss == sss);\n+                assert!(ss == sss);\n             }\n         }\n \n@@ -1131,9 +1131,9 @@ mod tests {\n \n     #[test]\n     fn test_windows_path_restrictions() {\n-        fail_unless!(WindowsPath(\"hi\").is_restricted() == false);\n-        fail_unless!(WindowsPath(\"C:\\\\NUL\").is_restricted() == true);\n-        fail_unless!(WindowsPath(\"C:\\\\COM1.TXT\").is_restricted() == true);\n-        fail_unless!(WindowsPath(\"c:\\\\prn.exe\").is_restricted() == true);\n+        assert!(WindowsPath(\"hi\").is_restricted() == false);\n+        assert!(WindowsPath(\"C:\\\\NUL\").is_restricted() == true);\n+        assert!(WindowsPath(\"C:\\\\COM1.TXT\").is_restricted() == true);\n+        assert!(WindowsPath(\"c:\\\\prn.exe\").is_restricted() == true);\n     }\n }"}, {"sha": "18f8030d5b84e0f135f3083e40b8932f8ce9d8ee", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -153,7 +153,7 @@ pub impl PacketHeader {\n     unsafe fn mark_blocked(&self, this: *rust_task) -> State {\n         rustrt::rust_task_ref(this);\n         let old_task = swap_task(&mut self.blocked_task, this);\n-        fail_unless!(old_task.is_null());\n+        assert!(old_task.is_null());\n         swap_state_acq(&mut self.state, Blocked)\n     }\n \n@@ -175,7 +175,7 @@ pub impl PacketHeader {\n     // continuum. It ends making multiple unique pointers to the same\n     // thing. You'll proobably want to forget them when you're done.\n     unsafe fn buf_header(&self) -> ~BufferHeader {\n-        fail_unless!(self.buffer.is_not_null());\n+        assert!(self.buffer.is_not_null());\n         reinterpret_cast(&self.buffer)\n     }\n \n@@ -379,8 +379,8 @@ pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n-    fail_unless!(ptr::addr_of(&(p.header)) == header);\n-    fail_unless!(p.payload.is_none());\n+    assert!(ptr::addr_of(&(p.header)) == header);\n+    assert!(p.payload.is_none());\n     p.payload = Some(payload);\n     let old_state = swap_state_rel(&mut p.header.state, Full);\n     match old_state {\n@@ -482,7 +482,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n     debug!(\"blocked = %x this = %x old_task = %x\",\n            p.header.blocked_task as uint,\n            this as uint, old_task as uint);\n-    fail_unless!(old_task.is_null());\n+    assert!(old_task.is_null());\n     let mut first = true;\n     let mut count = SPIN_COUNT;\n     loop {\n@@ -527,7 +527,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n           Terminated => {\n             // This assert detects when we've accidentally unsafely\n             // casted too big of a number to a state.\n-            fail_unless!(old_state == Terminated);\n+            assert!(old_state == Terminated);\n \n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n@@ -576,7 +576,7 @@ fn sender_terminate<T:Owned>(p: *Packet<T>) {\n         fail!(~\"you dun goofed\")\n       }\n       Terminated => {\n-        fail_unless!(p.header.blocked_task.is_null());\n+        assert!(p.header.blocked_task.is_null());\n         // I have to clean up, use drop_glue\n       }\n     }\n@@ -587,20 +587,20 @@ fn receiver_terminate<T:Owned>(p: *Packet<T>) {\n     let p = unsafe { &*p };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n       Empty => {\n-        fail_unless!(p.header.blocked_task.is_null());\n+        assert!(p.header.blocked_task.is_null());\n         // the sender will clean up\n       }\n       Blocked => {\n         let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n         if !old_task.is_null() {\n             unsafe {\n                 rustrt::rust_task_deref(old_task);\n-                fail_unless!(old_task == rustrt::rust_get_task());\n+                assert!(old_task == rustrt::rust_get_task());\n             }\n         }\n       }\n       Terminated | Full => {\n-        fail_unless!(p.header.blocked_task.is_null());\n+        assert!(p.header.blocked_task.is_null());\n         // I have to clean up, use drop_glue\n       }\n     }\n@@ -663,7 +663,7 @@ pub fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n     debug!(\"%?, %?\", ready_packet, pkts[ready_packet]);\n \n     unsafe {\n-        fail_unless!((*pkts[ready_packet].header()).state == Full\n+        assert!((*pkts[ready_packet].header()).state == Full\n                      || (*pkts[ready_packet].header()).state == Terminated);\n     }\n \n@@ -995,6 +995,6 @@ pub mod test {\n             let _chan = chan;\n         }\n \n-        fail_unless!(!port.peek());\n+        assert!(!port.peek());\n     }\n }"}, {"sha": "fc95e320013e69f42f1093674c4de0be01d58b6c", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -352,29 +352,29 @@ pub fn test() {\n         let mut p = Pair {fst: 10, snd: 20};\n         let pptr: *mut Pair = &mut p;\n         let iptr: *mut int = cast::reinterpret_cast(&pptr);\n-        fail_unless!((*iptr == 10));;\n+        assert!((*iptr == 10));;\n         *iptr = 30;\n-        fail_unless!((*iptr == 30));\n-        fail_unless!((p.fst == 30));;\n+        assert!((*iptr == 30));\n+        assert!((p.fst == 30));;\n \n         *pptr = Pair {fst: 50, snd: 60};\n-        fail_unless!((*iptr == 50));\n-        fail_unless!((p.fst == 50));\n-        fail_unless!((p.snd == 60));\n+        assert!((*iptr == 50));\n+        assert!((p.fst == 50));\n+        assert!((p.snd == 60));\n \n         let mut v0 = ~[32000u16, 32001u16, 32002u16];\n         let mut v1 = ~[0u16, 0u16, 0u16];\n \n         copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 1u),\n                     offset(vec::raw::to_ptr(v0), 1u), 1u);\n-        fail_unless!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n+        assert!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n         copy_memory(vec::raw::to_mut_ptr(v1),\n                     offset(vec::raw::to_ptr(v0), 2u), 1u);\n-        fail_unless!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n+        assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n                       v1[2] == 0u16));\n         copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 2u),\n                     vec::raw::to_ptr(v0), 1u);\n-        fail_unless!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n+        assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n                       v1[2] == 32000u16));\n     }\n }\n@@ -386,11 +386,11 @@ pub fn test_position() {\n \n     let s = ~\"hello\";\n     unsafe {\n-        fail_unless!(2u == as_c_str(s, |p| position(p,\n+        assert!(2u == as_c_str(s, |p| position(p,\n             |c| *c == 'l' as c_char)));\n-        fail_unless!(4u == as_c_str(s, |p| position(p,\n+        assert!(4u == as_c_str(s, |p| position(p,\n             |c| *c == 'o' as c_char)));\n-        fail_unless!(5u == as_c_str(s, |p| position(p,\n+        assert!(5u == as_c_str(s, |p| position(p,\n             |c| *c == 0 as c_char)));\n     }\n }\n@@ -405,8 +405,8 @@ pub fn test_buf_len() {\n             do str::as_c_str(s2) |p2| {\n                 let v = ~[p0, p1, p2, null()];\n                 do vec::as_imm_buf(v) |vp, len| {\n-                    fail_unless!(unsafe { buf_len(vp) } == 3u);\n-                    fail_unless!(len == 4u);\n+                    assert!(unsafe { buf_len(vp) } == 3u);\n+                    assert!(len == 4u);\n                 }\n             }\n         }\n@@ -416,20 +416,20 @@ pub fn test_buf_len() {\n #[test]\n pub fn test_is_null() {\n    let p: *int = null();\n-   fail_unless!(p.is_null());\n-   fail_unless!(!p.is_not_null());\n+   assert!(p.is_null());\n+   assert!(!p.is_not_null());\n \n    let q = offset(p, 1u);\n-   fail_unless!(!q.is_null());\n-   fail_unless!(q.is_not_null());\n+   assert!(!q.is_null());\n+   assert!(q.is_not_null());\n \n    let mp: *mut int = mut_null();\n-   fail_unless!(mp.is_null());\n-   fail_unless!(!mp.is_not_null());\n+   assert!(mp.is_null());\n+   assert!(!mp.is_not_null());\n \n    let mq = mp.offset(1u);\n-   fail_unless!(!mq.is_null());\n-   fail_unless!(mq.is_not_null());\n+   assert!(!mq.is_null());\n+   assert!(mq.is_not_null());\n }\n \n #[cfg(test)]\n@@ -462,11 +462,11 @@ pub mod ptr_tests {\n                 debug!(\n                     \"test_ptr_array_each e: %s, a: %s\",\n                          expected, actual);\n-                fail_unless!(actual == expected);\n+                assert!(actual == expected);\n                 ctr += 1;\n                 iteration_count += 1;\n             });\n-            fail_unless!(iteration_count == 3u);\n+            assert!(iteration_count == 3u);\n         }\n     }\n     #[test]\n@@ -494,11 +494,11 @@ pub mod ptr_tests {\n                 debug!(\n                     \"test_ptr_array_each e: %s, a: %s\",\n                          expected, actual);\n-                fail_unless!(actual == expected);\n+                assert!(actual == expected);\n                 ctr += 1;\n                 iteration_count += 1;\n             });\n-            fail_unless!(iteration_count == 3);\n+            assert!(iteration_count == 3);\n         }\n     }\n     #[test]"}, {"sha": "a4e53418fc88e91236184a9825de7cc37feef225", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -240,7 +240,7 @@ impl RngUtil for @Rng {\n      * failing if start >= end\n      */\n     fn gen_int_range(&self, start: int, end: int) -> int {\n-        fail_unless!(start < end);\n+        assert!(start < end);\n         start + int::abs(self.gen_int() % (end - start))\n     }\n \n@@ -274,7 +274,7 @@ impl RngUtil for @Rng {\n      * failing if start >= end\n      */\n     fn gen_uint_range(&self, start: uint, end: uint) -> uint {\n-        fail_unless!(start < end);\n+        assert!(start < end);\n         start + (self.gen_uint() % (end - start))\n     }\n \n@@ -326,7 +326,7 @@ impl RngUtil for @Rng {\n      * Return a char randomly chosen from chars, failing if chars is empty\n      */\n     fn gen_char_from(&self, chars: &str) -> char {\n-        fail_unless!(!chars.is_empty());\n+        assert!(!chars.is_empty());\n         let mut cs = ~[];\n         for str::each_char(chars) |c| { cs.push(c) }\n         self.choose(cs)\n@@ -582,7 +582,7 @@ pub mod tests {\n         let seed = rand::seed();\n         let ra = rand::seeded_rng(seed);\n         let rb = rand::seeded_rng(seed);\n-        fail_unless!(ra.gen_str(100u) == rb.gen_str(100u));\n+        assert!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n@@ -591,7 +591,7 @@ pub mod tests {\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n         let ra = rand::seeded_rng(seed);\n         let rb = rand::seeded_rng(seed);\n-        fail_unless!(ra.gen_str(100u) == rb.gen_str(100u));\n+        assert!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n@@ -601,17 +601,17 @@ pub mod tests {\n         // Regression test that isaac is actually using the above vector\n         let r = ra.next();\n         error!(\"%?\", r);\n-        fail_unless!(r == 890007737u32 // on x86_64\n+        assert!(r == 890007737u32 // on x86_64\n                      || r == 2935188040u32); // on x86\n     }\n \n     #[test]\n     pub fn gen_int_range() {\n         let r = rand::Rng();\n         let a = r.gen_int_range(-3, 42);\n-        fail_unless!(a >= -3 && a < 42);\n-        fail_unless!(r.gen_int_range(0, 1) == 0);\n-        fail_unless!(r.gen_int_range(-12, -11) == -12);\n+        assert!(a >= -3 && a < 42);\n+        assert!(r.gen_int_range(0, 1) == 0);\n+        assert!(r.gen_int_range(-12, -11) == -12);\n     }\n \n     #[test]\n@@ -625,9 +625,9 @@ pub mod tests {\n     pub fn gen_uint_range() {\n         let r = rand::Rng();\n         let a = r.gen_uint_range(3u, 42u);\n-        fail_unless!(a >= 3u && a < 42u);\n-        fail_unless!(r.gen_uint_range(0u, 1u) == 0u);\n-        fail_unless!(r.gen_uint_range(12u, 13u) == 12u);\n+        assert!(a >= 3u && a < 42u);\n+        assert!(r.gen_uint_range(0u, 1u) == 0u);\n+        assert!(r.gen_uint_range(12u, 13u) == 12u);\n     }\n \n     #[test]\n@@ -648,8 +648,8 @@ pub mod tests {\n     #[test]\n     pub fn gen_weighted_bool() {\n         let r = rand::Rng();\n-        fail_unless!(r.gen_weighted_bool(0u) == true);\n-        fail_unless!(r.gen_weighted_bool(1u) == true);\n+        assert!(r.gen_weighted_bool(0u) == true);\n+        assert!(r.gen_weighted_bool(1u) == true);\n     }\n \n     #[test]\n@@ -658,40 +658,40 @@ pub mod tests {\n         debug!(r.gen_str(10u));\n         debug!(r.gen_str(10u));\n         debug!(r.gen_str(10u));\n-        fail_unless!(r.gen_str(0u).len() == 0u);\n-        fail_unless!(r.gen_str(10u).len() == 10u);\n-        fail_unless!(r.gen_str(16u).len() == 16u);\n+        assert!(r.gen_str(0u).len() == 0u);\n+        assert!(r.gen_str(10u).len() == 10u);\n+        assert!(r.gen_str(16u).len() == 16u);\n     }\n \n     #[test]\n     pub fn gen_bytes() {\n         let r = rand::Rng();\n-        fail_unless!(r.gen_bytes(0u).len() == 0u);\n-        fail_unless!(r.gen_bytes(10u).len() == 10u);\n-        fail_unless!(r.gen_bytes(16u).len() == 16u);\n+        assert!(r.gen_bytes(0u).len() == 0u);\n+        assert!(r.gen_bytes(10u).len() == 10u);\n+        assert!(r.gen_bytes(16u).len() == 16u);\n     }\n \n     #[test]\n     pub fn choose() {\n         let r = rand::Rng();\n-        fail_unless!(r.choose([1, 1, 1]) == 1);\n+        assert!(r.choose([1, 1, 1]) == 1);\n     }\n \n     #[test]\n     pub fn choose_option() {\n         let r = rand::Rng();\n         let x: Option<int> = r.choose_option([]);\n-        fail_unless!(x.is_none());\n-        fail_unless!(r.choose_option([1, 1, 1]) == Some(1));\n+        assert!(x.is_none());\n+        assert!(r.choose_option([1, 1, 1]) == Some(1));\n     }\n \n     #[test]\n     pub fn choose_weighted() {\n         let r = rand::Rng();\n-        fail_unless!(r.choose_weighted(~[\n+        assert!(r.choose_weighted(~[\n             rand::Weighted { weight: 1u, item: 42 },\n         ]) == 42);\n-        fail_unless!(r.choose_weighted(~[\n+        assert!(r.choose_weighted(~[\n             rand::Weighted { weight: 0u, item: 42 },\n             rand::Weighted { weight: 1u, item: 43 },\n         ]) == 43);\n@@ -700,23 +700,23 @@ pub mod tests {\n     #[test]\n     pub fn choose_weighted_option() {\n         let r = rand::Rng();\n-        fail_unless!(r.choose_weighted_option(~[\n+        assert!(r.choose_weighted_option(~[\n             rand::Weighted { weight: 1u, item: 42 },\n         ]) == Some(42));\n-        fail_unless!(r.choose_weighted_option(~[\n+        assert!(r.choose_weighted_option(~[\n             rand::Weighted { weight: 0u, item: 42 },\n             rand::Weighted { weight: 1u, item: 43 },\n         ]) == Some(43));\n         let v: Option<int> = r.choose_weighted_option([]);\n-        fail_unless!(v.is_none());\n+        assert!(v.is_none());\n     }\n \n     #[test]\n     pub fn weighted_vec() {\n         let r = rand::Rng();\n         let empty: ~[int] = ~[];\n-        fail_unless!(r.weighted_vec(~[]) == empty);\n-        fail_unless!(r.weighted_vec(~[\n+        assert!(r.weighted_vec(~[]) == empty);\n+        assert!(r.weighted_vec(~[\n             rand::Weighted { weight: 0u, item: 3u },\n             rand::Weighted { weight: 1u, item: 2u },\n             rand::Weighted { weight: 2u, item: 1u },\n@@ -727,16 +727,16 @@ pub mod tests {\n     pub fn shuffle() {\n         let r = rand::Rng();\n         let empty: ~[int] = ~[];\n-        fail_unless!(r.shuffle(~[]) == empty);\n-        fail_unless!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n+        assert!(r.shuffle(~[]) == empty);\n+        assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n     }\n \n     #[test]\n     pub fn task_rng() {\n         let r = rand::task_rng();\n         r.gen_int();\n-        fail_unless!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n-        fail_unless!(r.gen_uint_range(0u, 1u) == 0u);\n+        assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n+        assert!(r.gen_uint_range(0u, 1u) == 0u);\n     }\n \n     #[test]"}, {"sha": "a51f874f3712cbd93de163609bdb21f6aa3a46fe", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -229,7 +229,7 @@ pub impl ReprVisitor {\n         } else if mtbl == 1 {\n             // skip, this is ast::m_imm\n         } else {\n-            fail_unless!(mtbl == 2);\n+            assert!(mtbl == 2);\n             self.writer.write_str(\"const \");\n         }\n     }\n@@ -591,7 +591,7 @@ fn test_repr() {\n             error!(\"expected '%s', got '%s'\",\n                    e, s);\n         }\n-        fail_unless!(s == e);\n+        assert!(s == e);\n     }\n \n     exact_test(&10, \"10\");"}, {"sha": "24822f52e1e84f8b6b925688272f9403563e952e", "filename": "src/libcore/result.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -294,7 +294,7 @@ pub impl<T, E: Copy> Result<T, E> {\n  *         else { return ok(x+1u); }\n  *     }\n  *     map(~[1u, 2u, 3u], inc_conditionally).chain {|incd|\n- *         fail_unless!(incd == ~[2u, 3u, 4u]);\n+ *         assert!(incd == ~[2u, 3u, 4u]);\n  *     }\n  */\n #[inline(always)]\n@@ -337,7 +337,7 @@ pub fn map_opt<T,U:Copy,V:Copy>(\n pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n                 op: &fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n \n-    fail_unless!(vec::same_length(ss, ts));\n+    assert!(vec::same_length(ss, ts));\n     let n = vec::len(ts);\n     let mut vs = vec::with_capacity(n);\n     let mut i = 0u;\n@@ -360,7 +360,7 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n                          op: &fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n \n-    fail_unless!(vec::same_length(ss, ts));\n+    assert!(vec::same_length(ss, ts));\n     let n = vec::len(ts);\n     let mut i = 0u;\n     while i < n {\n@@ -407,50 +407,50 @@ mod tests {\n \n     #[test]\n     pub fn chain_success() {\n-        fail_unless!(get(&chain(op1(), op2)) == 667u);\n+        assert!(get(&chain(op1(), op2)) == 667u);\n     }\n \n     #[test]\n     pub fn chain_failure() {\n-        fail_unless!(get_err(&chain(op3(), op2)) == ~\"sadface\");\n+        assert!(get_err(&chain(op3(), op2)) == ~\"sadface\");\n     }\n \n     #[test]\n     pub fn test_impl_iter() {\n         let mut valid = false;\n         Ok::<~str, ~str>(~\"a\").iter(|_x| valid = true);\n-        fail_unless!(valid);\n+        assert!(valid);\n \n         Err::<~str, ~str>(~\"b\").iter(|_x| valid = false);\n-        fail_unless!(valid);\n+        assert!(valid);\n     }\n \n     #[test]\n     pub fn test_impl_iter_err() {\n         let mut valid = true;\n         Ok::<~str, ~str>(~\"a\").iter_err(|_x| valid = false);\n-        fail_unless!(valid);\n+        assert!(valid);\n \n         valid = false;\n         Err::<~str, ~str>(~\"b\").iter_err(|_x| valid = true);\n-        fail_unless!(valid);\n+        assert!(valid);\n     }\n \n     #[test]\n     pub fn test_impl_map() {\n-        fail_unless!(Ok::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Ok(~\"b\"));\n-        fail_unless!(Err::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Err(~\"a\"));\n+        assert!(Ok::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Ok(~\"b\"));\n+        assert!(Err::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Err(~\"a\"));\n     }\n \n     #[test]\n     pub fn test_impl_map_err() {\n-        fail_unless!(Ok::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Ok(~\"a\"));\n-        fail_unless!(Err::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Err(~\"b\"));\n+        assert!(Ok::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Ok(~\"a\"));\n+        assert!(Err::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Err(~\"b\"));\n     }\n \n     #[test]\n     pub fn test_get_ref_method() {\n         let foo: Result<int, ()> = Ok(100);\n-        fail_unless!(*foo.get_ref() == 100);\n+        assert!(*foo.get_ref() == 100);\n     }\n }"}, {"sha": "46ea5713e2af3687f330d41c5c2d39f8294760fe", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -93,7 +93,7 @@ pub impl Scheduler {\n     // That will be important for embedding the runtime into external\n     // event loops.\n     fn run(~self) -> ~Scheduler {\n-        fail_unless!(!self.in_task_context());\n+        assert!(!self.in_task_context());\n \n         // Give ownership of the scheduler (self) to the thread\n         do self.install |scheduler| {\n@@ -129,7 +129,7 @@ pub impl Scheduler {\n     // * Scheduler-context operations\n \n     fn resume_task_from_queue(&mut self) -> bool {\n-        fail_unless!(!self.in_task_context());\n+        assert!(!self.in_task_context());\n \n         let mut self = self;\n         match self.task_queue.pop_front() {\n@@ -145,15 +145,15 @@ pub impl Scheduler {\n     }\n \n     fn resume_task_immediately(&mut self, task: ~Task) {\n-        fail_unless!(!self.in_task_context());\n+        assert!(!self.in_task_context());\n \n         rtdebug!(\"scheduling a task\");\n \n         // Store the task in the scheduler so it can be grabbed later\n         self.current_task = Some(task);\n         self.swap_in_task();\n         // The running task should have passed ownership elsewhere\n-        fail_unless!(self.current_task.is_none());\n+        assert!(self.current_task.is_none());\n \n         // Running tasks may have asked us to do some cleanup\n         self.run_cleanup_jobs();\n@@ -165,7 +165,7 @@ pub impl Scheduler {\n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n     fn terminate_current_task(&mut self) {\n-        fail_unless!(self.in_task_context());\n+        assert!(self.in_task_context());\n \n         rtdebug!(\"ending running task\");\n \n@@ -184,7 +184,7 @@ pub impl Scheduler {\n     /// running task.  It gets transmuted to the scheduler's lifetime\n     /// and called while the task is blocked.\n     fn block_running_task_and_then(&mut self, f: &fn(&mut Scheduler, ~Task)) {\n-        fail_unless!(self.in_task_context());\n+        assert!(self.in_task_context());\n \n         rtdebug!(\"blocking task\");\n \n@@ -203,7 +203,7 @@ pub impl Scheduler {\n     /// You would want to think hard about doing this, e.g. if there are\n     /// pending I/O events it would be a bad idea.\n     fn resume_task_from_running_task_direct(&mut self, next_task: ~Task) {\n-        fail_unless!(self.in_task_context());\n+        assert!(self.in_task_context());\n \n         rtdebug!(\"switching tasks\");\n \n@@ -255,7 +255,7 @@ pub impl Scheduler {\n     }\n \n     fn run_cleanup_jobs(&mut self) {\n-        fail_unless!(!self.in_task_context());\n+        assert!(!self.in_task_context());\n         rtdebug!(\"running cleanup jobs\");\n \n         while !self.cleanup_jobs.is_empty() {\n@@ -273,7 +273,7 @@ pub impl Scheduler {\n     // XXX: Hack. This should return &'self mut but I don't know how to\n     // make the borrowcheck happy\n     fn task_from_last_cleanup_job(&mut self) -> &mut Task {\n-        fail_unless!(!self.cleanup_jobs.is_empty());\n+        assert!(!self.cleanup_jobs.is_empty());\n         let last_job: &'self mut CleanupJob = &mut self.cleanup_jobs[0];\n         let last_task: &'self Task = match last_job {\n             &RescheduleTask(~ref task) => task,\n@@ -358,7 +358,7 @@ impl ThreadLocalScheduler {\n         unsafe {\n             let key = match self { &ThreadLocalScheduler(key) => key };\n             let mut value: *mut c_void = tls::get(key);\n-            fail_unless!(value.is_not_null());\n+            assert!(value.is_not_null());\n             {\n                 let value_ptr = &mut value;\n                 let sched: &mut ~Scheduler = {\n@@ -374,7 +374,7 @@ impl ThreadLocalScheduler {\n         unsafe {\n             let key = match self { &ThreadLocalScheduler(key) => key };\n             let value: *mut c_void = tls::get(key);\n-            fail_unless!(value.is_not_null());\n+            assert!(value.is_not_null());\n             let sched = transmute(value);\n             tls::set(key, mut_null());\n             return sched;\n@@ -430,7 +430,7 @@ fn test_simple_scheduling() {\n         };\n         sched.task_queue.push_back(task);\n         sched.run();\n-        fail_unless!(task_ran);\n+        assert!(task_ran);\n     }\n }\n \n@@ -449,7 +449,7 @@ fn test_several_tasks() {\n             sched.task_queue.push_back(task);\n         }\n         sched.run();\n-        fail_unless!(task_count == total);\n+        assert!(task_count == total);\n     }\n }\n \n@@ -473,7 +473,7 @@ fn test_swap_tasks() {\n         };\n         sched.task_queue.push_back(task1);\n         sched.run();\n-        fail_unless!(count == 3);\n+        assert!(count == 3);\n     }\n }\n \n@@ -492,7 +492,7 @@ fn test_run_a_lot_of_tasks_queued() {\n         sched.task_queue.push_back(start_task);\n         sched.run();\n \n-        fail_unless!(count == MAX);\n+        assert!(count == MAX);\n \n         fn run_task(count_ptr: *mut int) {\n             do Scheduler::local |sched| {\n@@ -525,7 +525,7 @@ fn test_run_a_lot_of_tasks_direct() {\n         sched.task_queue.push_back(start_task);\n         sched.run();\n \n-        fail_unless!(count == MAX);\n+        assert!(count == MAX);\n \n         fn run_task(count_ptr: *mut int) {\n             do Scheduler::local |sched| {\n@@ -550,9 +550,9 @@ fn test_block_task() {\n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task = ~do Task::new(&mut sched.stack_pool) {\n             do Scheduler::local |sched| {\n-                fail_unless!(sched.in_task_context());\n+                assert!(sched.in_task_context());\n                 do sched.block_running_task_and_then() |sched, task| {\n-                    fail_unless!(!sched.in_task_context());\n+                    assert!(!sched.in_task_context());\n                     sched.task_queue.push_back(task);\n                 }\n             }"}, {"sha": "76111328b3aded73456435f753b1a84066e0e117", "filename": "src/libcore/rt/thread_local_storage.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread_local_storage.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -21,12 +21,12 @@ pub type Key = pthread_key_t;\n \n #[cfg(unix)]\n pub unsafe fn create(key: &mut Key) {\n-    unsafe { fail_unless!(0 == pthread_key_create(key, null())); }\n+    unsafe { assert!(0 == pthread_key_create(key, null())); }\n }\n \n #[cfg(unix)]\n pub unsafe fn set(key: Key, value: *mut c_void) {\n-    unsafe { fail_unless!(0 == pthread_setspecific(key, value)); }\n+    unsafe { assert!(0 == pthread_setspecific(key, value)); }\n }\n \n #[cfg(unix)]\n@@ -58,12 +58,12 @@ pub type Key = DWORD;\n pub unsafe fn create(key: &mut Key) {\n     static TLS_OUT_OF_INDEXES: DWORD = 0xFFFFFFFF;\n     *key = unsafe { TlsAlloc() };\n-    fail_unless!(*key != TLS_OUT_OF_INDEXES);\n+    assert!(*key != TLS_OUT_OF_INDEXES);\n }\n \n #[cfg(windows)]\n pub unsafe fn set(key: Key, value: *mut c_void) {\n-    unsafe { fail_unless!(0 != TlsSetValue(key, value)) }\n+    unsafe { assert!(0 != TlsSetValue(key, value)) }\n }\n \n #[cfg(windows)]\n@@ -88,10 +88,10 @@ fn tls_smoke_test() {\n         create(&mut key);\n         set(key, transmute(value));\n         let value: ~int = transmute(get(key));\n-        fail_unless!(value == ~20);\n+        assert!(value == ~20);\n         let value = ~30;\n         set(key, transmute(value));\n         let value: ~int = transmute(get(key));\n-        fail_unless!(value == ~30);\n+        assert!(value == ~30);\n     }\n }"}, {"sha": "a4aef7485d737076ec72a36add966f60809a5a66", "filename": "src/libcore/rt/uv/file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Ffile.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -25,7 +25,7 @@ impl Request for FsRequest;\n impl FsRequest {\n     fn new() -> FsRequest {\n         let fs_req = unsafe { malloc_req(UV_FS) };\n-        fail_unless!(fs_req.is_not_null());\n+        assert!(fs_req.is_not_null());\n         let fs_req = fs_req as *uvll::uv_write_t;\n         unsafe { uvll::set_data_for_req(fs_req, null::<()>()); }\n         NativeHandle::from_native_handle(fs_req)"}, {"sha": "32757d6376e73f84bf9f1c2e5b9c891d54ab7c3c", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -89,7 +89,7 @@ pub struct Loop {\n pub impl Loop {\n     fn new() -> Loop {\n         let handle = unsafe { uvll::loop_new() };\n-        fail_unless!(handle.is_not_null());\n+        assert!(handle.is_not_null());\n         NativeHandle::from_native_handle(handle)\n     }\n \n@@ -126,8 +126,8 @@ pub impl IdleWatcher {\n     fn new(loop_: &mut Loop) -> IdleWatcher {\n         unsafe {\n             let handle = uvll::idle_new();\n-            fail_unless!(handle.is_not_null());\n-            fail_unless!(0 == uvll::idle_init(loop_.native_handle(), handle));\n+            assert!(handle.is_not_null());\n+            assert!(0 == uvll::idle_init(loop_.native_handle(), handle));\n             uvll::set_data_for_uv_handle(handle, null::<()>());\n             NativeHandle::from_native_handle(handle)\n         }\n@@ -137,7 +137,7 @@ pub impl IdleWatcher {\n \n         set_watcher_callback(self, cb);\n         unsafe {\n-            fail_unless!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n+            assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n         };\n \n         extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n@@ -149,7 +149,7 @@ pub impl IdleWatcher {\n     }\n \n     fn stop(&mut self) {\n-        unsafe { fail_unless!(0 == uvll::idle_stop(self.native_handle())); }\n+        unsafe { assert!(0 == uvll::idle_stop(self.native_handle())); }\n     }\n \n     fn close(self) {\n@@ -183,7 +183,7 @@ pub impl UvError {\n         unsafe {\n             let inner = match self { &UvError(ref a) => a };\n             let name_str = uvll::err_name(inner);\n-            fail_unless!(name_str.is_not_null());\n+            assert!(name_str.is_not_null());\n             from_c_str(name_str)\n         }\n     }\n@@ -192,7 +192,7 @@ pub impl UvError {\n         unsafe {\n             let inner = match self { &UvError(ref a) => a };\n             let desc_str = uvll::strerror(inner);\n-            fail_unless!(desc_str.is_not_null());\n+            assert!(desc_str.is_not_null());\n             from_c_str(desc_str)\n         }\n     }\n@@ -208,7 +208,7 @@ impl ToStr for UvError {\n fn error_smoke_test() {\n     let err = uvll::uv_err_t { code: 1, sys_errno_: 1 };\n     let err: UvError = UvError(err);\n-    fail_unless!(err.to_str() == ~\"EOF: end of file\");\n+    assert!(err.to_str() == ~\"EOF: end of file\");\n }\n \n \n@@ -274,7 +274,7 @@ pub fn borrow_callback_from_watcher<H, W: Watcher + NativeHandle<*H>,\n     unsafe {\n         let handle = watcher.native_handle();\n         let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        fail_unless!(handle_data.is_not_null());\n+        assert!(handle_data.is_not_null());\n         let cb = transmute::<&*c_void, &~CB>(&handle_data);\n         return &**cb;\n     }\n@@ -287,7 +287,7 @@ pub fn take_callback_from_watcher<H, W: Watcher + NativeHandle<*H>, CB: Callback\n     unsafe {\n         let handle = watcher.native_handle();\n         let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        fail_unless!(handle_data.is_not_null());\n+        assert!(handle_data.is_not_null());\n         uvll::set_data_for_uv_handle(handle, null::<()>());\n         let cb: ~CB = transmute::<*c_void, ~CB>(handle_data);\n         let cb = match cb { ~cb => cb };\n@@ -341,16 +341,16 @@ fn test_slice_to_uv_buf() {\n     let slice = [0, .. 20];\n     let buf = slice_to_uv_buf(slice);\n \n-    fail_unless!(buf.len == 20);\n+    assert!(buf.len == 20);\n \n     unsafe {\n         let base = transmute::<*u8, *mut u8>(buf.base);\n         (*base) = 1;\n         (*ptr::mut_offset(base, 1)) = 2;\n     }\n \n-    fail_unless!(slice[0] == 1);\n-    fail_unless!(slice[1] == 2);\n+    assert!(slice[0] == 1);\n+    assert!(slice[1] == 2);\n }\n \n /// The uv buffer type\n@@ -367,7 +367,7 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n /// Transmute an owned vector to a Buf\n pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n     let data = unsafe { malloc(v.len() as size_t) } as *u8;\n-    fail_unless!(data.is_not_null());\n+    assert!(data.is_not_null());\n     do vec::as_imm_buf(v) |b, l| {\n         let data = data as *mut u8;\n         unsafe { ptr::copy_memory(data, b, l) }\n@@ -416,7 +416,7 @@ fn idle_smoke_test() {\n         let count_ptr: *mut int = &mut count;\n         do idle_watcher.start |idle_watcher, status| {\n             let mut idle_watcher = idle_watcher;\n-            fail_unless!(status.is_none());\n+            assert!(status.is_none());\n             if unsafe { *count_ptr == 10 } {\n                 idle_watcher.stop();\n                 idle_watcher.close();\n@@ -426,7 +426,7 @@ fn idle_smoke_test() {\n         }\n         loop_.run();\n         loop_.close();\n-        fail_unless!(count == 10);\n+        assert!(count == 10);\n     }\n }\n \n@@ -437,10 +437,10 @@ fn idle_start_stop_start() {\n         let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n         do idle_watcher.start |idle_watcher, status| {\n             let mut idle_watcher = idle_watcher;\n-            fail_unless!(status.is_none());\n+            assert!(status.is_none());\n             idle_watcher.stop();\n             do idle_watcher.start |idle_watcher, status| {\n-                fail_unless!(status.is_none());\n+                assert!(status.is_none());\n                 let mut idle_watcher = idle_watcher;\n                 idle_watcher.stop();\n                 idle_watcher.close();"}, {"sha": "edd3b379fbcc4b01208580ed41a70d133a72157e", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -104,15 +104,15 @@ pub impl StreamWatcher {\n     fn write(&mut self, msg: ~[u8], cb: ConnectionCallback) {\n         // XXX: Borrowck\n         let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        fail_unless!(data.write_cb.is_none());\n+        assert!(data.write_cb.is_none());\n         data.write_cb = Some(cb);\n \n         let req = WriteRequest::new();\n         let buf = vec_to_uv_buf(msg);\n         // XXX: Allocation\n         let bufs = ~[buf];\n         unsafe {\n-            fail_unless!(0 == uvll::write(req.native_handle(),\n+            assert!(0 == uvll::write(req.native_handle(),\n                                           self.native_handle(),\n                                           &bufs, write_cb));\n         }\n@@ -133,15 +133,15 @@ pub impl StreamWatcher {\n         let self_handle = self.native_handle() as *c_void;\n         let stream_handle = stream.native_handle() as *c_void;\n         unsafe {\n-            fail_unless!(0 == uvll::accept(self_handle, stream_handle));\n+            assert!(0 == uvll::accept(self_handle, stream_handle));\n         }\n     }\n \n     fn close(self, cb: NullCallback) {\n         {\n             let mut self = self;\n             let data = get_watcher_data(&mut self);\n-            fail_unless!(data.close_cb.is_none());\n+            assert!(data.close_cb.is_none());\n             data.close_cb = Some(cb);\n         }\n \n@@ -184,8 +184,8 @@ pub impl TcpWatcher {\n     fn new(loop_: &mut Loop) -> TcpWatcher {\n         unsafe {\n             let handle = malloc_handle(UV_TCP);\n-            fail_unless!(handle.is_not_null());\n-            fail_unless!(0 == uvll::tcp_init(loop_.native_handle(), handle));\n+            assert!(handle.is_not_null());\n+            assert!(0 == uvll::tcp_init(loop_.native_handle(), handle));\n             let mut watcher = NativeHandle::from_native_handle(handle);\n             install_watcher_data(&mut watcher);\n             return watcher;\n@@ -200,7 +200,7 @@ pub impl TcpWatcher {\n                         uvll::tcp_bind(self.native_handle(), addr)\n                     };\n                     // XXX: bind is likely to fail. need real error handling\n-                    fail_unless!(result == 0);\n+                    assert!(result == 0);\n                 }\n             }\n             _ => fail!()\n@@ -209,7 +209,7 @@ pub impl TcpWatcher {\n \n     fn connect(&mut self, address: IpAddr, cb: ConnectionCallback) {\n         unsafe {\n-            fail_unless!(get_watcher_data(self).connect_cb.is_none());\n+            assert!(get_watcher_data(self).connect_cb.is_none());\n             get_watcher_data(self).connect_cb = Some(cb);\n \n             let mut connect_watcher = ConnectRequest::new();\n@@ -218,7 +218,7 @@ pub impl TcpWatcher {\n                 Ipv4(*) => {\n                     do ip4_as_uv_ip4(address) |addr| {\n                         rtdebug!(\"connect_t: %x\", connect_handle as uint);\n-                        fail_unless!(0 == uvll::tcp_connect(connect_handle,\n+                        assert!(0 == uvll::tcp_connect(connect_handle,\n                                                             self.native_handle(),\n                                                             addr, connect_cb));\n                     }\n@@ -244,13 +244,13 @@ pub impl TcpWatcher {\n     fn listen(&mut self, cb: ConnectionCallback) {\n         // XXX: Borrowck\n         let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        fail_unless!(data.connect_cb.is_none());\n+        assert!(data.connect_cb.is_none());\n         data.connect_cb = Some(cb);\n \n         unsafe {\n             static BACKLOG: c_int = 128; // XXX should be configurable\n             // XXX: This can probably fail\n-            fail_unless!(0 == uvll::listen(self.native_handle(),\n+            assert!(0 == uvll::listen(self.native_handle(),\n                                            BACKLOG, connection_cb));\n         }\n \n@@ -291,7 +291,7 @@ impl ConnectRequest {\n         let connect_handle = unsafe {\n             malloc_req(UV_CONNECT)\n         };\n-        fail_unless!(connect_handle.is_not_null());\n+        assert!(connect_handle.is_not_null());\n         let connect_handle = connect_handle as *uvll::uv_connect_t;\n         ConnectRequest(connect_handle)\n     }\n@@ -328,7 +328,7 @@ pub impl WriteRequest {\n         let write_handle = unsafe {\n             malloc_req(UV_WRITE)\n         };\n-        fail_unless!(write_handle.is_not_null());\n+        assert!(write_handle.is_not_null());\n         let write_handle = write_handle as *uvll::uv_write_t;\n         WriteRequest(write_handle)\n     }\n@@ -365,8 +365,8 @@ fn connect_close() {\n         let addr = Ipv4(127, 0, 0, 1, 2923);\n         do tcp_watcher.connect(addr) |stream_watcher, status| {\n             rtdebug!(\"tcp_watcher.connect!\");\n-            fail_unless!(status.is_some());\n-            fail_unless!(status.get().name() == ~\"ECONNREFUSED\");\n+            assert!(status.is_some());\n+            assert!(status.get().name() == ~\"ECONNREFUSED\");\n             stream_watcher.close(||());\n         }\n         loop_.run();\n@@ -384,7 +384,7 @@ fn connect_read() {\n         do tcp_watcher.connect(addr) |stream_watcher, status| {\n             let mut stream_watcher = stream_watcher;\n             rtdebug!(\"tcp_watcher.connect!\");\n-            fail_unless!(status.is_none());\n+            assert!(status.is_none());\n             let alloc: AllocCallback = |size| {\n                 vec_to_uv_buf(vec::from_elem(size, 0))\n             };\n@@ -421,7 +421,7 @@ fn listen() {\n         rtdebug!(\"listening\");\n         do server_tcp_watcher.listen |server_stream_watcher, status| {\n             rtdebug!(\"listened!\");\n-            fail_unless!(status.is_none());\n+            assert!(status.is_none());\n             let mut server_stream_watcher = server_stream_watcher;\n             let mut loop_ = loop_;\n             let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n@@ -443,12 +443,12 @@ fn listen() {\n                     rtdebug!(\"got %d bytes\", nread);\n                     let buf = buf.unwrap();\n                     for buf.slice(0, nread as uint).each |byte| {\n-                        fail_unless!(*byte == count as u8);\n+                        assert!(*byte == count as u8);\n                         rtdebug!(\"%u\", *byte as uint);\n                         count += 1;\n                     }\n                 } else {\n-                    fail_unless!(count == MAX);\n+                    assert!(count == MAX);\n                     do stream_watcher.close {\n                         server_stream_watcher.close(||());\n                     }\n@@ -463,12 +463,12 @@ fn listen() {\n             let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n             do tcp_watcher.connect(addr) |stream_watcher, status| {\n                 rtdebug!(\"connecting\");\n-                fail_unless!(status.is_none());\n+                assert!(status.is_none());\n                 let mut stream_watcher = stream_watcher;\n                 let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n                 do stream_watcher.write(msg) |stream_watcher, status| {\n                     rtdebug!(\"writing\");\n-                    fail_unless!(status.is_none());\n+                    assert!(status.is_none());\n                     stream_watcher.close(||());\n                 }\n             }"}, {"sha": "37f29d1a5c0feee27bea79b0674bf092c3734ab1", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -59,7 +59,7 @@ impl EventLoop for UvEventLoop {\n     fn callback(&mut self, f: ~fn()) {\n         let mut idle_watcher =  IdleWatcher::new(self.uvio.uv_loop());\n         do idle_watcher.start |idle_watcher, status| {\n-            fail_unless!(status.is_none());\n+            assert!(status.is_none());\n             let mut idle_watcher = idle_watcher;\n             idle_watcher.stop();\n             idle_watcher.close();\n@@ -82,7 +82,7 @@ fn test_callback_run_once() {\n             unsafe { *count_ptr += 1 }\n         }\n         event_loop.run();\n-        fail_unless!(count == 1);\n+        assert!(count == 1);\n     }\n }\n \n@@ -105,13 +105,13 @@ impl IoFactory for UvIoFactory {\n         let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n \n         do Scheduler::local |scheduler| {\n-            fail_unless!(scheduler.in_task_context());\n+            assert!(scheduler.in_task_context());\n \n             // Block this task and take ownership, switch to scheduler context\n             do scheduler.block_running_task_and_then |scheduler, task| {\n \n                 rtdebug!(\"connect: entered scheduler context\");\n-                fail_unless!(!scheduler.in_task_context());\n+                assert!(!scheduler.in_task_context());\n                 let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n                 let task_cell = Cell(task);\n \n@@ -138,7 +138,7 @@ impl IoFactory for UvIoFactory {\n             }\n         }\n \n-        fail_unless!(!result_cell.is_empty());\n+        assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n \n@@ -179,7 +179,7 @@ impl TcpListener for UvTcpListener {\n         let server_tcp_watcher = self.watcher();\n \n         do Scheduler::local |scheduler| {\n-            fail_unless!(scheduler.in_task_context());\n+            assert!(scheduler.in_task_context());\n \n             do scheduler.block_running_task_and_then |_, task| {\n                 let task_cell = Cell(task);\n@@ -208,7 +208,7 @@ impl TcpListener for UvTcpListener {\n             }\n         }\n \n-        fail_unless!(!result_cell.is_empty());\n+        assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n }\n@@ -244,12 +244,12 @@ impl Stream for UvStream {\n         let result_cell_ptr: *Cell<Result<uint, ()>> = &result_cell;\n \n         do Scheduler::local |scheduler| {\n-            fail_unless!(scheduler.in_task_context());\n+            assert!(scheduler.in_task_context());\n             let watcher = self.watcher();\n             let buf_ptr: *&mut [u8] = &buf;\n             do scheduler.block_running_task_and_then |scheduler, task| {\n                 rtdebug!(\"read: entered scheduler context\");\n-                fail_unless!(!scheduler.in_task_context());\n+                assert!(!scheduler.in_task_context());\n                 let mut watcher = watcher;\n                 let task_cell = Cell(task);\n                 // XXX: We shouldn't reallocate these callbacks every\n@@ -267,7 +267,7 @@ impl Stream for UvStream {\n                     watcher.read_stop();\n \n                     let result = if status.is_none() {\n-                        fail_unless!(nread >= 0);\n+                        assert!(nread >= 0);\n                         Ok(nread as uint)\n                     } else {\n                         Err(())\n@@ -282,15 +282,15 @@ impl Stream for UvStream {\n             }\n         }\n \n-        fail_unless!(!result_cell.is_empty());\n+        assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), ()> {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<(), ()>> = &result_cell;\n         do Scheduler::local |scheduler| {\n-            fail_unless!(scheduler.in_task_context());\n+            assert!(scheduler.in_task_context());\n             let watcher = self.watcher();\n             let buf_ptr: *&[u8] = &buf;\n             do scheduler.block_running_task_and_then |_, task| {\n@@ -315,7 +315,7 @@ impl Stream for UvStream {\n             }\n         }\n \n-        fail_unless!(!result_cell.is_empty());\n+        assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n }\n@@ -330,7 +330,7 @@ fn test_simple_io_no_connect() {\n                 let io = sched.event_loop.io().unwrap();\n                 let addr = Ipv4(127, 0, 0, 1, 2926);\n                 let maybe_chan = io.connect(addr);\n-                fail_unless!(maybe_chan.is_none());\n+                assert!(maybe_chan.is_none());\n             }\n         };\n         sched.task_queue.push_back(task);\n@@ -361,10 +361,10 @@ fn test_simple_tcp_server_and_client() {\n                 let mut stream = listener.listen().unwrap();\n                 let mut buf = [0, .. 2048];\n                 let nread = stream.read(buf).unwrap();\n-                fail_unless!(nread == 8);\n+                assert!(nread == 8);\n                 for uint::range(0, nread) |i| {\n                     rtdebug!(\"%u\", buf[i] as uint);\n-                    fail_unless!(buf[i] == i as u8);\n+                    assert!(buf[i] == i as u8);\n                 }\n                 stream.close();\n                 listener.close();\n@@ -411,7 +411,7 @@ fn test_read_and_block() {\n                     let nread = stream.read(buf).unwrap();\n                     for uint::range(0, nread) |i| {\n                         let val = buf[i] as uint;\n-                        fail_unless!(val == current % 8);\n+                        assert!(val == current % 8);\n                         current += 1;\n                     }\n                     reads += 1;\n@@ -427,7 +427,7 @@ fn test_read_and_block() {\n                 }\n \n                 // Make sure we had multiple reads\n-                fail_unless!(reads > 1);\n+                assert!(reads > 1);\n \n                 stream.close();\n                 listener.close();"}, {"sha": "640a69743ba6a34cfb1295b783ea859ed7d1d312", "filename": "src/libcore/rt/uvll.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frt%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frt%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvll.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -97,10 +97,10 @@ pub enum uv_req_type {\n }\n \n pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n-    fail_unless!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n+    assert!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n     let size = unsafe { rust_uv_handle_size(handle as uint) };\n     let p = malloc(size);\n-    fail_unless!(p.is_not_null());\n+    assert!(p.is_not_null());\n     return p;\n }\n \n@@ -109,10 +109,10 @@ pub unsafe fn free_handle(v: *c_void) {\n }\n \n pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n-    fail_unless!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n+    assert!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n     let size = unsafe { rust_uv_req_size(req as uint) };\n     let p = malloc(size);\n-    fail_unless!(p.is_not_null());\n+    assert!(p.is_not_null());\n     return p;\n }\n \n@@ -123,14 +123,14 @@ pub unsafe fn free_req(v: *c_void) {\n #[test]\n fn handle_sanity_check() {\n     unsafe {\n-        fail_unless!(UV_HANDLE_TYPE_MAX as uint == rust_uv_handle_type_max());\n+        assert!(UV_HANDLE_TYPE_MAX as uint == rust_uv_handle_type_max());\n     }\n }\n \n #[test]\n fn request_sanity_check() {\n     unsafe {\n-        fail_unless!(UV_REQ_TYPE_MAX as uint == rust_uv_req_type_max());\n+        assert!(UV_REQ_TYPE_MAX as uint == rust_uv_req_type_max());\n     }\n }\n "}, {"sha": "8116ea952e425ee86fcd3f3c6db0df375bb8289a", "filename": "src/libcore/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -495,7 +495,7 @@ mod tests {\n \n         debug!(copy expected);\n         debug!(copy actual);\n-        fail_unless!((expected == actual));\n+        assert!((expected == actual));\n     }\n \n     #[test]\n@@ -504,7 +504,7 @@ mod tests {\n                                      &None, &None,\n                                      0i32, 0i32, 0i32);\n         let status = run::waitpid(pid);\n-        fail_unless!(status == 1);\n+        assert!(status == 1);\n     }\n \n }"}, {"sha": "c54a1048c4603583927569d2605dba2b3df30285", "filename": "src/libcore/str.rs", "status": "modified", "additions": 307, "deletions": 307, "changes": 614, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -45,7 +45,7 @@ Section: Creating a string\n  * Fails if invalid UTF-8\n  */\n pub fn from_bytes(vv: &const [u8]) -> ~str {\n-    fail_unless!(is_utf8(vv));\n+    assert!(is_utf8(vv));\n     return unsafe { raw::from_bytes(vv) };\n }\n \n@@ -75,7 +75,7 @@ impl ToStr for @str {\n  * Fails if invalid UTF-8\n  */\n pub fn from_byte(b: u8) -> ~str {\n-    fail_unless!(b < 128u8);\n+    assert!(b < 128u8);\n     unsafe { ::cast::transmute(~[b, 0u8]) }\n }\n \n@@ -264,7 +264,7 @@ Section: Adding to and removing from a string\n  */\n pub fn pop_char(s: &mut ~str) -> char {\n     let end = len(*s);\n-    fail_unless!(end > 0u);\n+    assert!(end > 0u);\n     let CharRange {ch, next} = char_range_at_reverse(*s, end);\n     unsafe { raw::set_len(s, next); }\n     return ch;\n@@ -429,8 +429,8 @@ pub fn substr<'a>(s: &'a str, begin: uint, n: uint) -> &'a str {\n  * the last character of the string\n  */\n pub fn slice<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-    fail_unless!(is_char_boundary(s, begin));\n-    fail_unless!(is_char_boundary(s, end));\n+    assert!(is_char_boundary(s, begin));\n+    assert!(is_char_boundary(s, end));\n     unsafe { raw::slice_bytes(s, begin, end) }\n }\n \n@@ -554,7 +554,7 @@ fn each_split_inner<'a>(s: &'a str,\n // See Issue #1932 for why this is a naive search\n fn iter_matches<'a,'b>(s: &'a str, sep: &'b str, f: &fn(uint, uint) -> bool) {\n     let sep_len = len(sep), l = len(s);\n-    fail_unless!(sep_len > 0u);\n+    assert!(sep_len > 0u);\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n \n     while i < l {\n@@ -598,7 +598,7 @@ fn iter_between_matches<'a,'b>(s: &'a str,\n  * ~~~\n  * let mut v = ~[];\n  * for each_split_str(\".XXX.YYY.\", \".\") |subs| { v.push(subs); }\n- * fail_unless!(v == [\"\", \"XXX\", \"YYY\", \"\"]);\n+ * assert!(v == [\"\", \"XXX\", \"YYY\", \"\"]);\n  * ~~~\n  */\n pub fn each_split_str<'a,'b>(s: &'a str,\n@@ -1179,8 +1179,8 @@ pub fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n pub fn find_char_between(s: &str, c: char, start: uint, end: uint)\n     -> Option<uint> {\n     if c < 128u as char {\n-        fail_unless!(start <= end);\n-        fail_unless!(end <= len(s));\n+        assert!(start <= end);\n+        assert!(end <= len(s));\n         let mut i = start;\n         let b = c as u8;\n         while i < end {\n@@ -1257,8 +1257,8 @@ pub fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n  */\n pub fn rfind_char_between(s: &str, c: char, start: uint, end: uint) -> Option<uint> {\n     if c < 128u as char {\n-        fail_unless!(start >= end);\n-        fail_unless!(start <= len(s));\n+        assert!(start >= end);\n+        assert!(start <= len(s));\n         let mut i = start;\n         let b = c as u8;\n         while i > end {\n@@ -1337,9 +1337,9 @@ pub fn find_from(s: &str, start: uint, f: &fn(char)\n  * boundary, as defined by `is_char_boundary`.\n  */\n pub fn find_between(s: &str, start: uint, end: uint, f: &fn(char) -> bool) -> Option<uint> {\n-    fail_unless!(start <= end);\n-    fail_unless!(end <= len(s));\n-    fail_unless!(is_char_boundary(s, start));\n+    assert!(start <= end);\n+    assert!(end <= len(s));\n+    assert!(is_char_boundary(s, start));\n     let mut i = start;\n     while i < end {\n         let CharRange {ch, next} = char_range_at(s, i);\n@@ -1414,9 +1414,9 @@ pub fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool) -> Option<uint> {\n  * boundary, as defined by `is_char_boundary`\n  */\n pub fn rfind_between(s: &str, start: uint, end: uint, f: &fn(char) -> bool) -> Option<uint> {\n-    fail_unless!(start >= end);\n-    fail_unless!(start <= len(s));\n-    fail_unless!(is_char_boundary(s, start));\n+    assert!(start >= end);\n+    assert!(start <= len(s));\n+    assert!(is_char_boundary(s, start));\n     let mut i = start;\n     while i > end {\n         let CharRange {ch, next: prev} = char_range_at_reverse(s, i);\n@@ -1502,7 +1502,7 @@ pub fn find_str_between<'a,'b>(haystack: &'a str,\n                                end:uint)\n                             -> Option<uint> {\n     // See Issue #1932 for why this is a naive search\n-    fail_unless!(end <= len(haystack));\n+    assert!(end <= len(haystack));\n     let needle_len = len(needle);\n     if needle_len == 0u { return Some(start); }\n     if needle_len > end { return None; }\n@@ -1664,11 +1664,11 @@ pub fn to_utf16(s: &str) -> ~[u16] {\n             if (ch & 0xFFFF_u32) == ch {\n                 // The BMP falls through (assuming non-surrogate, as it\n                 // should)\n-                fail_unless!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n+                assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n                 u.push(ch as u16)\n             } else {\n                 // Supplementary planes break into surrogates.\n-                fail_unless!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n+                assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n                 ch -= 0x1_0000_u32;\n                 let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n                 let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n@@ -1691,8 +1691,8 @@ pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n \n         } else {\n             let u2 = v[i+1u];\n-            fail_unless!(u >= 0xD800_u16 && u <= 0xDBFF_u16);\n-            fail_unless!(u2 >= 0xDC00_u16 && u2 <= 0xDFFF_u16);\n+            assert!(u >= 0xD800_u16 && u <= 0xDBFF_u16);\n+            assert!(u2 >= 0xDC00_u16 && u2 <= 0xDFFF_u16);\n             let mut c = (u - 0xD800_u16) as char;\n             c = c << 10;\n             c |= (u2 - 0xDC00_u16) as char;\n@@ -1732,8 +1732,8 @@ pub fn with_capacity(capacity: uint) -> ~str {\n  * The number of Unicode characters in `s` between the given indices.\n  */\n pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n-    fail_unless!(is_char_boundary(s, start));\n-    fail_unless!(is_char_boundary(s, end));\n+    assert!(is_char_boundary(s, start));\n+    assert!(is_char_boundary(s, end));\n     let mut i = start, len = 0u;\n     while i < end {\n         let next = char_range_at(s, i).next;\n@@ -1745,11 +1745,11 @@ pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n \n /// Counts the number of bytes taken by the `n` in `s` starting from `start`.\n pub fn count_bytes<'b>(s: &'b str, start: uint, n: uint) -> uint {\n-    fail_unless!(is_char_boundary(s, start));\n+    assert!(is_char_boundary(s, start));\n     let mut end = start, cnt = n;\n     let l = len(s);\n     while cnt > 0u {\n-        fail_unless!(end < l);\n+        assert!(end < l);\n         let next = char_range_at(s, end).next;\n         cnt -= 1u;\n         end = next;\n@@ -1832,14 +1832,14 @@ pub fn is_char_boundary(s: &str, index: uint) -> bool {\n pub fn char_range_at(s: &str, i: uint) -> CharRange {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n-    fail_unless!((w != 0u));\n+    assert!((w != 0u));\n     if w == 1u { return CharRange {ch: b0 as char, next: i + 1u}; }\n     let mut val = 0u;\n     let end = i + w;\n     let mut i = i + 1u;\n     while i < end {\n         let byte = s[i];\n-        fail_unless!((byte & 192u8 == tag_cont_u8));\n+        assert!((byte & 192u8 == tag_cont_u8));\n         val <<= 6u;\n         val += (byte & 63u8) as uint;\n         i += 1u;\n@@ -1910,7 +1910,7 @@ pub fn char_at_reverse(s: &str, i: uint) -> char {\n  */\n pub fn all_between(s: &str, start: uint, end: uint,\n                     it: &fn(char) -> bool) -> bool {\n-    fail_unless!(is_char_boundary(s, start));\n+    assert!(is_char_boundary(s, start));\n     let mut i = start;\n     while i < end {\n         let CharRange {ch, next} = char_range_at(s, i);\n@@ -2010,7 +2010,7 @@ pub fn as_bytes_slice<'a>(s: &'a str) -> &'a [u8] {\n pub fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n     do as_buf(s) |buf, len| {\n         // NB: len includes the trailing null.\n-        fail_unless!(len > 0);\n+        assert!(len > 0);\n         if unsafe { *(ptr::offset(buf,len-1)) != 0 } {\n             as_c_str(from_slice(s), f)\n         } else {\n@@ -2090,7 +2090,7 @@ pub fn reserve_at_least(s: &mut ~str, n: uint) {\n pub fn capacity(s: &const ~str) -> uint {\n     do as_bytes(s) |buf| {\n         let vcap = vec::capacity(buf);\n-        fail_unless!(vcap > 0u);\n+        assert!(vcap > 0u);\n         vcap - 1u\n     }\n }\n@@ -2147,7 +2147,7 @@ pub mod raw {\n         vec::raw::set_len(&mut v, len);\n         v.push(0u8);\n \n-        fail_unless!(is_utf8(v));\n+        assert!(is_utf8(v));\n         return ::cast::transmute(v);\n     }\n \n@@ -2175,7 +2175,7 @@ pub mod raw {\n     pub unsafe fn buf_as_slice<T>(buf: *u8, len: uint,\n                               f: &fn(v: &str) -> T) -> T {\n         let v = (buf, len + 1);\n-        fail_unless!(is_utf8(::cast::reinterpret_cast(&v)));\n+        assert!(is_utf8(::cast::reinterpret_cast(&v)));\n         f(::cast::transmute(v))\n     }\n \n@@ -2191,8 +2191,8 @@ pub mod raw {\n      */\n     pub unsafe fn slice_bytes_unique(s: &str, begin: uint, end: uint) -> ~str {\n         do as_buf(s) |sbuf, n| {\n-            fail_unless!((begin <= end));\n-            fail_unless!((end <= n));\n+            assert!((begin <= end));\n+            assert!((end <= n));\n \n             let mut v = vec::with_capacity(end - begin + 1u);\n             unsafe {\n@@ -2221,8 +2221,8 @@ pub mod raw {\n     #[inline]\n     pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> &str {\n         do as_buf(s) |sbuf, n| {\n-             fail_unless!((begin <= end));\n-             fail_unless!((end <= n));\n+             assert!((begin <= end));\n+             assert!((end <= n));\n \n              let tuple = (ptr::offset(sbuf, begin), end - begin + 1);\n              ::cast::reinterpret_cast(&tuple)\n@@ -2250,7 +2250,7 @@ pub mod raw {\n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n     pub unsafe fn pop_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n-        fail_unless!((len > 0u));\n+        assert!((len > 0u));\n         let b = s[len - 1u];\n         unsafe { set_len(s, len - 1u) };\n         return b;\n@@ -2259,7 +2259,7 @@ pub mod raw {\n     /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n     pub unsafe fn shift_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n-        fail_unless!((len > 0u));\n+        assert!((len > 0u));\n         let b = s[0];\n         *s = unsafe { raw::slice_bytes_unique(*s, 1u, len) };\n         return b;\n@@ -2281,7 +2281,7 @@ pub mod raw {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = vec::raw::to_ptr(a);\n             let c = from_buf_len(b, 3u);\n-            fail_unless!((c == ~\"AAA\"));\n+            assert!((c == ~\"AAA\"));\n         }\n     }\n \n@@ -2572,69 +2572,69 @@ mod tests {\n \n     #[test]\n     fn test_eq() {\n-        fail_unless!((eq(&~\"\", &~\"\")));\n-        fail_unless!((eq(&~\"foo\", &~\"foo\")));\n-        fail_unless!((!eq(&~\"foo\", &~\"bar\")));\n+        assert!((eq(&~\"\", &~\"\")));\n+        assert!((eq(&~\"foo\", &~\"foo\")));\n+        assert!((!eq(&~\"foo\", &~\"bar\")));\n     }\n \n     #[test]\n     fn test_eq_slice() {\n-        fail_unless!((eq_slice(slice(\"foobar\", 0, 3), \"foo\")));\n-        fail_unless!((eq_slice(slice(\"barfoo\", 3, 6), \"foo\")));\n-        fail_unless!((!eq_slice(\"foo1\", \"foo2\")));\n+        assert!((eq_slice(slice(\"foobar\", 0, 3), \"foo\")));\n+        assert!((eq_slice(slice(\"barfoo\", 3, 6), \"foo\")));\n+        assert!((!eq_slice(\"foo1\", \"foo2\")));\n     }\n \n     #[test]\n     fn test_le() {\n-        fail_unless!((le(&\"\", &\"\")));\n-        fail_unless!((le(&\"\", &\"foo\")));\n-        fail_unless!((le(&\"foo\", &\"foo\")));\n-        fail_unless!((!eq(&~\"foo\", &~\"bar\")));\n+        assert!((le(&\"\", &\"\")));\n+        assert!((le(&\"\", &\"foo\")));\n+        assert!((le(&\"foo\", &\"foo\")));\n+        assert!((!eq(&~\"foo\", &~\"bar\")));\n     }\n \n     #[test]\n     fn test_len() {\n-        fail_unless!((len(~\"\") == 0u));\n-        fail_unless!((len(~\"hello world\") == 11u));\n-        fail_unless!((len(~\"\\x63\") == 1u));\n-        fail_unless!((len(~\"\\xa2\") == 2u));\n-        fail_unless!((len(~\"\\u03c0\") == 2u));\n-        fail_unless!((len(~\"\\u2620\") == 3u));\n-        fail_unless!((len(~\"\\U0001d11e\") == 4u));\n+        assert!((len(~\"\") == 0u));\n+        assert!((len(~\"hello world\") == 11u));\n+        assert!((len(~\"\\x63\") == 1u));\n+        assert!((len(~\"\\xa2\") == 2u));\n+        assert!((len(~\"\\u03c0\") == 2u));\n+        assert!((len(~\"\\u2620\") == 3u));\n+        assert!((len(~\"\\U0001d11e\") == 4u));\n \n-        fail_unless!((char_len(~\"\") == 0u));\n-        fail_unless!((char_len(~\"hello world\") == 11u));\n-        fail_unless!((char_len(~\"\\x63\") == 1u));\n-        fail_unless!((char_len(~\"\\xa2\") == 1u));\n-        fail_unless!((char_len(~\"\\u03c0\") == 1u));\n-        fail_unless!((char_len(~\"\\u2620\") == 1u));\n-        fail_unless!((char_len(~\"\\U0001d11e\") == 1u));\n-        fail_unless!((char_len(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\") == 19u));\n+        assert!((char_len(~\"\") == 0u));\n+        assert!((char_len(~\"hello world\") == 11u));\n+        assert!((char_len(~\"\\x63\") == 1u));\n+        assert!((char_len(~\"\\xa2\") == 1u));\n+        assert!((char_len(~\"\\u03c0\") == 1u));\n+        assert!((char_len(~\"\\u2620\") == 1u));\n+        assert!((char_len(~\"\\U0001d11e\") == 1u));\n+        assert!((char_len(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\") == 19u));\n     }\n \n     #[test]\n     fn test_rfind_char() {\n-        fail_unless!(rfind_char(~\"hello\", 'l') == Some(3u));\n-        fail_unless!(rfind_char(~\"hello\", 'o') == Some(4u));\n-        fail_unless!(rfind_char(~\"hello\", 'h') == Some(0u));\n-        fail_unless!(rfind_char(~\"hello\", 'z').is_none());\n-        fail_unless!(rfind_char(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e') == Some(30u));\n+        assert!(rfind_char(~\"hello\", 'l') == Some(3u));\n+        assert!(rfind_char(~\"hello\", 'o') == Some(4u));\n+        assert!(rfind_char(~\"hello\", 'h') == Some(0u));\n+        assert!(rfind_char(~\"hello\", 'z').is_none());\n+        assert!(rfind_char(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e') == Some(30u));\n     }\n \n     #[test]\n     fn test_pop_char() {\n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n         let cc = pop_char(&mut data);\n-        fail_unless!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\" == data);\n-        fail_unless!('\u534e' == cc);\n+        assert!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\" == data);\n+        assert!('\u534e' == cc);\n     }\n \n     #[test]\n     fn test_pop_char_2() {\n         let mut data2 = ~\"\u534e\";\n         let cc2 = pop_char(&mut data2);\n-        fail_unless!(~\"\" == data2);\n-        fail_unless!('\u534e' == cc2);\n+        assert!(~\"\" == data2);\n+        assert!('\u534e' == cc2);\n     }\n \n     #[test]\n@@ -2652,7 +2652,7 @@ mod tests {\n             let mut v = ~[];\n             for each_split_char(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n-            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+            assert!(vec::all2(v, u, |a,b| a == b));\n         }\n         t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n         t(~\".hello.there\", '.', ~[~\"\", ~\"hello\", ~\"there\"]);\n@@ -2670,7 +2670,7 @@ mod tests {\n             let mut v = ~[];\n             for each_split_char(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n-            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+            assert!(vec::all2(v, u, |a,b| a == b));\n         }\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         t(data, 'V', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n@@ -2685,7 +2685,7 @@ mod tests {\n             for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n-            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+            assert!(vec::all2(v, u, |a,b| a == b));\n         }\n         t(~\"abc.hello.there\", '.', 0u, ~[~\"abc.hello.there\"]);\n         t(~\"abc.hello.there\", '.', 1u, ~[~\"abc\", ~\"hello.there\"]);\n@@ -2712,7 +2712,7 @@ mod tests {\n             for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n-            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+            assert!(vec::all2(v, u, |a,b| a == b));\n         }\n \n         t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e', 1u, ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n@@ -2731,7 +2731,7 @@ mod tests {\n             for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n-            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+            assert!(vec::all2(v, u, |a,b| a == b));\n         }\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         t(data, 'V', 1u, ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n@@ -2745,7 +2745,7 @@ mod tests {\n             let mut v = ~[];\n             for each_split_char_no_trailing(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n-            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+            assert!(vec::all2(v, u, |a,b| a == b));\n         }\n         t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n         t(~\".hello.there\", '.', ~[~\"\", ~\"hello\", ~\"there\"]);\n@@ -2764,7 +2764,7 @@ mod tests {\n             let mut v = ~[];\n             for each_split_char_no_trailing(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n-            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+            assert!(vec::all2(v, u, |a,b| a == b));\n         }\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         t(data, 'V', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n@@ -2776,7 +2776,7 @@ mod tests {\n         fn t<'a>(s: &str, sep: &'a str, u: &[~str]) {\n             let mut v = ~[];\n             for each_split_str(s, sep) |s| { v.push(s.to_owned()) }\n-            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+            assert!(vec::all2(v, u, |a,b| a == b));\n         }\n         t(~\"--1233345--\", ~\"12345\", ~[~\"--1233345--\"]);\n         t(~\"abc::hello::there\", ~\"::\", ~[~\"abc\", ~\"hello\", ~\"there\"]);\n@@ -2800,7 +2800,7 @@ mod tests {\n         fn t(s: &str, sepf: &fn(char) -> bool, u: &[~str]) {\n             let mut v = ~[];\n             for each_split(s, sepf) |s| { v.push(s.to_owned()) }\n-            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+            assert!(vec::all2(v, u, |a,b| a == b));\n         }\n \n         t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n@@ -2816,7 +2816,7 @@ mod tests {\n         fn t(s: &str, sepf: &fn(char) -> bool, u: &[~str]) {\n             let mut v = ~[];\n             for each_split_no_trailing(s, sepf) |s| { v.push(s.to_owned()) }\n-            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+            assert!(vec::all2(v, u, |a,b| a == b));\n         }\n \n         t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n@@ -2835,7 +2835,7 @@ mod tests {\n         fn t(s: &str, f: &fn(&str, &fn(&str) -> bool), u: &[~str]) {\n             let mut v = ~[];\n             for f(s) |s| { v.push(s.to_owned()) }\n-            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+            assert!(vec::all2(v, u, |a,b| a == b));\n         }\n \n         t(lf, each_line ,~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n@@ -2855,7 +2855,7 @@ mod tests {\n         fn t(s: &str, f: &fn(&str, &fn(&str) -> bool), u: &[~str]) {\n             let mut v = ~[];\n             for f(s) |s| { v.push(s.to_owned()) }\n-            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+            assert!(vec::all2(v, u, |a,b| a == b));\n         }\n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n@@ -2869,7 +2869,7 @@ mod tests {\n         fn t(s: &str, i: uint, u: &[~str]) {\n             let mut v = ~[];\n             for each_split_within(s, i) |s| { v.push(s.to_owned()) }\n-            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+            assert!(vec::all2(v, u, |a,b| a == b));\n         }\n         t(~\"\", 0, ~[]);\n         t(~\"\", 15, ~[]);\n@@ -2881,59 +2881,59 @@ mod tests {\n     #[test]\n     fn test_find_str() {\n         // byte positions\n-        fail_unless!(find_str(~\"banana\", ~\"apple pie\").is_none());\n-        fail_unless!(find_str(~\"\", ~\"\") == Some(0u));\n+        assert!(find_str(~\"banana\", ~\"apple pie\").is_none());\n+        assert!(find_str(~\"\", ~\"\") == Some(0u));\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(find_str(data, ~\"\")     == Some(0u));\n-        fail_unless!(find_str(data, ~\"\u0e1b\u0e23\u0e30\u0e40\") == Some( 0u));\n-        fail_unless!(find_str(data, ~\"\u0e30\u0e40\")   == Some( 6u));\n-        fail_unless!(find_str(data, ~\"\u4e2d\u534e\") == Some(27u));\n-        fail_unless!(find_str(data, ~\"\u0e44\u0e17\u534e\").is_none());\n+        assert!(find_str(data, ~\"\")     == Some(0u));\n+        assert!(find_str(data, ~\"\u0e1b\u0e23\u0e30\u0e40\") == Some( 0u));\n+        assert!(find_str(data, ~\"\u0e30\u0e40\")   == Some( 6u));\n+        assert!(find_str(data, ~\"\u4e2d\u534e\") == Some(27u));\n+        assert!(find_str(data, ~\"\u0e44\u0e17\u534e\").is_none());\n     }\n \n     #[test]\n     fn test_find_str_between() {\n         // byte positions\n-        fail_unless!(find_str_between(~\"\", ~\"\", 0u, 0u) == Some(0u));\n+        assert!(find_str_between(~\"\", ~\"\", 0u, 0u) == Some(0u));\n \n         let data = ~\"abcabc\";\n-        fail_unless!(find_str_between(data, ~\"ab\", 0u, 6u) == Some(0u));\n-        fail_unless!(find_str_between(data, ~\"ab\", 2u, 6u) == Some(3u));\n-        fail_unless!(find_str_between(data, ~\"ab\", 2u, 4u).is_none());\n+        assert!(find_str_between(data, ~\"ab\", 0u, 6u) == Some(0u));\n+        assert!(find_str_between(data, ~\"ab\", 2u, 6u) == Some(3u));\n+        assert!(find_str_between(data, ~\"ab\", 2u, 4u).is_none());\n \n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         data = data + data;\n-        fail_unless!(find_str_between(data, ~\"\", 0u, 43u) == Some(0u));\n-        fail_unless!(find_str_between(data, ~\"\", 6u, 43u) == Some(6u));\n+        assert!(find_str_between(data, ~\"\", 0u, 43u) == Some(0u));\n+        assert!(find_str_between(data, ~\"\", 6u, 43u) == Some(6u));\n \n-        fail_unless!(find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 0u, 43u) == Some( 0u));\n-        fail_unless!(find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 0u, 43u) == Some(12u));\n-        fail_unless!(find_str_between(data, ~\"\u0e22\u4e2d\", 0u, 43u) == Some(24u));\n-        fail_unless!(find_str_between(data, ~\"i\u1ec7t\", 0u, 43u) == Some(34u));\n-        fail_unless!(find_str_between(data, ~\"Nam\", 0u, 43u) == Some(40u));\n+        assert!(find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 0u, 43u) == Some( 0u));\n+        assert!(find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 0u, 43u) == Some(12u));\n+        assert!(find_str_between(data, ~\"\u0e22\u4e2d\", 0u, 43u) == Some(24u));\n+        assert!(find_str_between(data, ~\"i\u1ec7t\", 0u, 43u) == Some(34u));\n+        assert!(find_str_between(data, ~\"Nam\", 0u, 43u) == Some(40u));\n \n-        fail_unless!(find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 43u, 86u) == Some(43u));\n-        fail_unless!(find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 43u, 86u) == Some(55u));\n-        fail_unless!(find_str_between(data, ~\"\u0e22\u4e2d\", 43u, 86u) == Some(67u));\n-        fail_unless!(find_str_between(data, ~\"i\u1ec7t\", 43u, 86u) == Some(77u));\n-        fail_unless!(find_str_between(data, ~\"Nam\", 43u, 86u) == Some(83u));\n+        assert!(find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 43u, 86u) == Some(43u));\n+        assert!(find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 43u, 86u) == Some(55u));\n+        assert!(find_str_between(data, ~\"\u0e22\u4e2d\", 43u, 86u) == Some(67u));\n+        assert!(find_str_between(data, ~\"i\u1ec7t\", 43u, 86u) == Some(77u));\n+        assert!(find_str_between(data, ~\"Nam\", 43u, 86u) == Some(83u));\n     }\n \n     #[test]\n     fn test_substr() {\n         fn t(a: &str, b: &str, start: int) {\n-            fail_unless!(substr(a, start as uint, len(b)) == b);\n+            assert!(substr(a, start as uint, len(b)) == b);\n         }\n         t(\"hello\", \"llo\", 2);\n         t(\"hello\", \"el\", 1);\n-        fail_unless!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\" == substr(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 6u, 6u));\n+        assert!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\" == substr(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 6u, 6u));\n     }\n \n     #[test]\n     fn test_concat() {\n         fn t(v: &[~str], s: &str) {\n-            fail_unless!(concat(v) == s.to_str());\n+            assert!(concat(v) == s.to_str());\n         }\n         t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\"youknowI'mnogood\");\n         let v: ~[~str] = ~[];\n@@ -2944,7 +2944,7 @@ mod tests {\n     #[test]\n     fn test_connect() {\n         fn t(v: &[~str], sep: &str, s: &str) {\n-            fail_unless!(connect(v, sep) == s.to_str());\n+            assert!(connect(v, sep) == s.to_str());\n         }\n         t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"],\n           ~\" \", ~\"you know I'm no good\");\n@@ -2956,7 +2956,7 @@ mod tests {\n     #[test]\n     fn test_connect_slices() {\n         fn t(v: &[&str], sep: &str, s: &str) {\n-            fail_unless!(connect_slices(v, sep) == s.to_str());\n+            assert!(connect_slices(v, sep) == s.to_str());\n         }\n         t([\"you\", \"know\", \"I'm\", \"no\", \"good\"],\n           \" \", \"you know I'm no good\");\n@@ -2966,11 +2966,11 @@ mod tests {\n \n     #[test]\n     fn test_repeat() {\n-        fail_unless!(repeat(~\"x\", 4) == ~\"xxxx\");\n-        fail_unless!(repeat(~\"hi\", 4) == ~\"hihihihi\");\n-        fail_unless!(repeat(~\"\u0e44\u0e17\u534e\", 3) == ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\");\n-        fail_unless!(repeat(~\"\", 4) == ~\"\");\n-        fail_unless!(repeat(~\"hi\", 0) == ~\"\");\n+        assert!(repeat(~\"x\", 4) == ~\"xxxx\");\n+        assert!(repeat(~\"hi\", 4) == ~\"hihihihi\");\n+        assert!(repeat(~\"\u0e44\u0e17\u534e\", 3) == ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\");\n+        assert!(repeat(~\"\", 4) == ~\"\");\n+        assert!(repeat(~\"hi\", 0) == ~\"\");\n     }\n \n     #[test]\n@@ -2982,24 +2982,24 @@ mod tests {\n         let input = ~\"abcDEF\" + unicode + ~\"xyz:.;\";\n         let expected = ~\"ABCDEF\" + unicode + ~\"XYZ:.;\";\n         let actual = to_upper(input);\n-        fail_unless!(expected == actual);\n+        assert!(expected == actual);\n     }\n \n     #[test]\n     fn test_to_lower() {\n         unsafe {\n-            fail_unless!(~\"\" == map(~\"\",\n+            assert!(~\"\" == map(~\"\",\n                 |c| libc::tolower(c as c_char) as char));\n-            fail_unless!(~\"ymca\" == map(~\"YMCA\",\n+            assert!(~\"ymca\" == map(~\"YMCA\",\n                 |c| libc::tolower(c as c_char) as char));\n         }\n     }\n \n     #[test]\n     fn test_unsafe_slice() {\n-        fail_unless!(\"ab\" == unsafe {raw::slice_bytes(\"abc\", 0, 2)});\n-        fail_unless!(\"bc\" == unsafe {raw::slice_bytes(\"abc\", 1, 3)});\n-        fail_unless!(\"\" == unsafe {raw::slice_bytes(\"abc\", 1, 1)});\n+        assert!(\"ab\" == unsafe {raw::slice_bytes(\"abc\", 0, 2)});\n+        assert!(\"bc\" == unsafe {raw::slice_bytes(\"abc\", 1, 3)});\n+        assert!(\"\" == unsafe {raw::slice_bytes(\"abc\", 1, 1)});\n         fn a_million_letter_a() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n@@ -3013,44 +3013,44 @@ mod tests {\n             rs\n         }\n         let letters = a_million_letter_a();\n-        fail_unless!(half_a_million_letter_a() ==\n+        assert!(half_a_million_letter_a() ==\n             unsafe {raw::slice_bytes(letters, 0u, 500000)}.to_owned());\n     }\n \n     #[test]\n     fn test_starts_with() {\n-        fail_unless!((starts_with(~\"\", ~\"\")));\n-        fail_unless!((starts_with(~\"abc\", ~\"\")));\n-        fail_unless!((starts_with(~\"abc\", ~\"a\")));\n-        fail_unless!((!starts_with(~\"a\", ~\"abc\")));\n-        fail_unless!((!starts_with(~\"\", ~\"abc\")));\n+        assert!((starts_with(~\"\", ~\"\")));\n+        assert!((starts_with(~\"abc\", ~\"\")));\n+        assert!((starts_with(~\"abc\", ~\"a\")));\n+        assert!((!starts_with(~\"a\", ~\"abc\")));\n+        assert!((!starts_with(~\"\", ~\"abc\")));\n     }\n \n     #[test]\n     fn test_ends_with() {\n-        fail_unless!((ends_with(~\"\", ~\"\")));\n-        fail_unless!((ends_with(~\"abc\", ~\"\")));\n-        fail_unless!((ends_with(~\"abc\", ~\"c\")));\n-        fail_unless!((!ends_with(~\"a\", ~\"abc\")));\n-        fail_unless!((!ends_with(~\"\", ~\"abc\")));\n+        assert!((ends_with(~\"\", ~\"\")));\n+        assert!((ends_with(~\"abc\", ~\"\")));\n+        assert!((ends_with(~\"abc\", ~\"c\")));\n+        assert!((!ends_with(~\"a\", ~\"abc\")));\n+        assert!((!ends_with(~\"\", ~\"abc\")));\n     }\n \n     #[test]\n     fn test_is_empty() {\n-        fail_unless!((is_empty(~\"\")));\n-        fail_unless!((!is_empty(~\"a\")));\n+        assert!((is_empty(~\"\")));\n+        assert!((!is_empty(~\"a\")));\n     }\n \n     #[test]\n     fn test_replace() {\n         let a = ~\"a\";\n-        fail_unless!(replace(~\"\", a, ~\"b\") == ~\"\");\n-        fail_unless!(replace(~\"a\", a, ~\"b\") == ~\"b\");\n-        fail_unless!(replace(~\"ab\", a, ~\"b\") == ~\"bb\");\n+        assert!(replace(~\"\", a, ~\"b\") == ~\"\");\n+        assert!(replace(~\"a\", a, ~\"b\") == ~\"b\");\n+        assert!(replace(~\"ab\", a, ~\"b\") == ~\"bb\");\n         let test = ~\"test\";\n-        fail_unless!(replace(~\" test test \", test, ~\"toast\") ==\n+        assert!(replace(~\" test test \", test, ~\"toast\") ==\n             ~\" toast toast \");\n-        fail_unless!(replace(~\" test test \", test, ~\"\") == ~\"   \");\n+        assert!(replace(~\" test test \", test, ~\"\") == ~\"   \");\n     }\n \n     #[test]\n@@ -3060,7 +3060,7 @@ mod tests {\n \n         let a = ~\"\u0e1b\u0e23\u0e30\u0e40\";\n         let A = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        fail_unless!((replace(data, a, repl) ==  A));\n+        assert!((replace(data, a, repl) ==  A));\n     }\n \n     #[test]\n@@ -3070,7 +3070,7 @@ mod tests {\n \n         let b = ~\"\u0e30\u0e40\";\n         let B = ~\"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        fail_unless!((replace(data, b,   repl) ==  B));\n+        assert!((replace(data, b,   repl) ==  B));\n     }\n \n     #[test]\n@@ -3080,7 +3080,7 @@ mod tests {\n \n         let c = ~\"\u4e2d\u534e\";\n         let C = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n-        fail_unless!((replace(data, c, repl) ==  C));\n+        assert!((replace(data, c, repl) ==  C));\n     }\n \n     #[test]\n@@ -3089,21 +3089,21 @@ mod tests {\n         let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n         let d = ~\"\u0e44\u0e17\u534e\";\n-        fail_unless!((replace(data, d, repl) == data));\n+        assert!((replace(data, d, repl) == data));\n     }\n \n     #[test]\n     fn test_slice() {\n-        fail_unless!(\"ab\" == slice(\"abc\", 0, 2));\n-        fail_unless!(\"bc\" == slice(\"abc\", 1, 3));\n-        fail_unless!(\"\" == slice(\"abc\", 1, 1));\n-        fail_unless!(\"\\u65e5\" == slice(\"\\u65e5\\u672c\", 0, 3));\n+        assert!(\"ab\" == slice(\"abc\", 0, 2));\n+        assert!(\"bc\" == slice(\"abc\", 1, 3));\n+        assert!(\"\" == slice(\"abc\", 1, 1));\n+        assert!(\"\\u65e5\" == slice(\"\\u65e5\\u672c\", 0, 3));\n \n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        fail_unless!(\"\u0e1b\" == slice(data, 0, 3));\n-        fail_unless!(\"\u0e23\" == slice(data, 3, 6));\n-        fail_unless!(\"\" == slice(data, 3, 3));\n-        fail_unless!(\"\u534e\" == slice(data, 30, 33));\n+        assert!(\"\u0e1b\" == slice(data, 0, 3));\n+        assert!(\"\u0e23\" == slice(data, 3, 6));\n+        assert!(\"\" == slice(data, 3, 3));\n+        assert!(\"\u534e\" == slice(data, 30, 33));\n \n         fn a_million_letter_X() -> ~str {\n             let mut i = 0;\n@@ -3121,24 +3121,24 @@ mod tests {\n             rs\n         }\n         let letters = a_million_letter_X();\n-        fail_unless!(half_a_million_letter_X() ==\n+        assert!(half_a_million_letter_X() ==\n             slice(letters, 0u, 3u * 500000u).to_owned());\n     }\n \n     #[test]\n     fn test_slice_2() {\n         let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        fail_unless!(\"\u534e\" == slice(ss, 3u, 6u));\n-        fail_unless!(\"Vi\u1ec7t Nam\" == slice(ss, 6u, 16u));\n+        assert!(\"\u534e\" == slice(ss, 3u, 6u));\n+        assert!(\"Vi\u1ec7t Nam\" == slice(ss, 6u, 16u));\n \n-        fail_unless!(\"ab\" == slice(\"abc\", 0u, 2u));\n-        fail_unless!(\"bc\" == slice(\"abc\", 1u, 3u));\n-        fail_unless!(\"\" == slice(\"abc\", 1u, 1u));\n+        assert!(\"ab\" == slice(\"abc\", 0u, 2u));\n+        assert!(\"bc\" == slice(\"abc\", 1u, 3u));\n+        assert!(\"\" == slice(\"abc\", 1u, 1u));\n \n-        fail_unless!(\"\u4e2d\" == slice(ss, 0u, 3u));\n-        fail_unless!(\"\u534eV\" == slice(ss, 3u, 7u));\n-        fail_unless!(\"\" == slice(ss, 3u, 3u));\n+        assert!(\"\u4e2d\" == slice(ss, 0u, 3u));\n+        assert!(\"\u534eV\" == slice(ss, 3u, 7u));\n+        assert!(\"\" == slice(ss, 3u, 3u));\n         /*0: \u4e2d\n           3: \u534e\n           6: V\n@@ -3160,101 +3160,101 @@ mod tests {\n \n     #[test]\n     fn test_trim_left_chars() {\n-        fail_unless!(trim_left_chars(\" *** foo *** \", ~[]) ==\n+        assert!(trim_left_chars(\" *** foo *** \", ~[]) ==\n                      \" *** foo *** \");\n-        fail_unless!(trim_left_chars(\" *** foo *** \", ~['*', ' ']) ==\n+        assert!(trim_left_chars(\" *** foo *** \", ~['*', ' ']) ==\n                      \"foo *** \");\n-        fail_unless!(trim_left_chars(\" ***  *** \", ~['*', ' ']) == \"\");\n-        fail_unless!(trim_left_chars(\"foo *** \", ~['*', ' ']) ==\n+        assert!(trim_left_chars(\" ***  *** \", ~['*', ' ']) == \"\");\n+        assert!(trim_left_chars(\"foo *** \", ~['*', ' ']) ==\n                      \"foo *** \");\n     }\n \n     #[test]\n     fn test_trim_right_chars() {\n-        fail_unless!(trim_right_chars(\" *** foo *** \", ~[]) ==\n+        assert!(trim_right_chars(\" *** foo *** \", ~[]) ==\n                      \" *** foo *** \");\n-        fail_unless!(trim_right_chars(\" *** foo *** \", ~['*', ' ']) ==\n+        assert!(trim_right_chars(\" *** foo *** \", ~['*', ' ']) ==\n                      \" *** foo\");\n-        fail_unless!(trim_right_chars(\" ***  *** \", ~['*', ' ']) == \"\");\n-        fail_unless!(trim_right_chars(\" *** foo\", ~['*', ' ']) ==\n+        assert!(trim_right_chars(\" ***  *** \", ~['*', ' ']) == \"\");\n+        assert!(trim_right_chars(\" *** foo\", ~['*', ' ']) ==\n                      \" *** foo\");\n     }\n \n     #[test]\n     fn test_trim_chars() {\n-        fail_unless!(trim_chars(\" *** foo *** \", ~[]) == \" *** foo *** \");\n-        fail_unless!(trim_chars(\" *** foo *** \", ~['*', ' ']) == \"foo\");\n-        fail_unless!(trim_chars(\" ***  *** \", ~['*', ' ']) == \"\");\n-        fail_unless!(trim_chars(\"foo\", ~['*', ' ']) == \"foo\");\n+        assert!(trim_chars(\" *** foo *** \", ~[]) == \" *** foo *** \");\n+        assert!(trim_chars(\" *** foo *** \", ~['*', ' ']) == \"foo\");\n+        assert!(trim_chars(\" ***  *** \", ~['*', ' ']) == \"\");\n+        assert!(trim_chars(\"foo\", ~['*', ' ']) == \"foo\");\n     }\n \n     #[test]\n     fn test_trim_left() {\n-        fail_unless!((trim_left(\"\") == \"\"));\n-        fail_unless!((trim_left(\"a\") == \"a\"));\n-        fail_unless!((trim_left(\"    \") == \"\"));\n-        fail_unless!((trim_left(\"     blah\") == \"blah\"));\n-        fail_unless!((trim_left(\"   \\u3000  wut\") == \"wut\"));\n-        fail_unless!((trim_left(\"hey \") == \"hey \"));\n+        assert!((trim_left(\"\") == \"\"));\n+        assert!((trim_left(\"a\") == \"a\"));\n+        assert!((trim_left(\"    \") == \"\"));\n+        assert!((trim_left(\"     blah\") == \"blah\"));\n+        assert!((trim_left(\"   \\u3000  wut\") == \"wut\"));\n+        assert!((trim_left(\"hey \") == \"hey \"));\n     }\n \n     #[test]\n     fn test_trim_right() {\n-        fail_unless!((trim_right(\"\") == \"\"));\n-        fail_unless!((trim_right(\"a\") == \"a\"));\n-        fail_unless!((trim_right(\"    \") == \"\"));\n-        fail_unless!((trim_right(\"blah     \") == \"blah\"));\n-        fail_unless!((trim_right(\"wut   \\u3000  \") == \"wut\"));\n-        fail_unless!((trim_right(\" hey\") == \" hey\"));\n+        assert!((trim_right(\"\") == \"\"));\n+        assert!((trim_right(\"a\") == \"a\"));\n+        assert!((trim_right(\"    \") == \"\"));\n+        assert!((trim_right(\"blah     \") == \"blah\"));\n+        assert!((trim_right(\"wut   \\u3000  \") == \"wut\"));\n+        assert!((trim_right(\" hey\") == \" hey\"));\n     }\n \n     #[test]\n     fn test_trim() {\n-        fail_unless!((trim(\"\") == \"\"));\n-        fail_unless!((trim(\"a\") == \"a\"));\n-        fail_unless!((trim(\"    \") == \"\"));\n-        fail_unless!((trim(\"    blah     \") == \"blah\"));\n-        fail_unless!((trim(\"\\nwut   \\u3000  \") == \"wut\"));\n-        fail_unless!((trim(\" hey dude \") == \"hey dude\"));\n+        assert!((trim(\"\") == \"\"));\n+        assert!((trim(\"a\") == \"a\"));\n+        assert!((trim(\"    \") == \"\"));\n+        assert!((trim(\"    blah     \") == \"blah\"));\n+        assert!((trim(\"\\nwut   \\u3000  \") == \"wut\"));\n+        assert!((trim(\" hey dude \") == \"hey dude\"));\n     }\n \n     #[test]\n     fn test_is_whitespace() {\n-        fail_unless!((is_whitespace(~\"\")));\n-        fail_unless!((is_whitespace(~\" \")));\n-        fail_unless!((is_whitespace(~\"\\u2009\"))); // Thin space\n-        fail_unless!((is_whitespace(~\"  \\n\\t   \")));\n-        fail_unless!((!is_whitespace(~\"   _   \")));\n+        assert!((is_whitespace(~\"\")));\n+        assert!((is_whitespace(~\" \")));\n+        assert!((is_whitespace(~\"\\u2009\"))); // Thin space\n+        assert!((is_whitespace(~\"  \\n\\t   \")));\n+        assert!((!is_whitespace(~\"   _   \")));\n     }\n \n     #[test]\n     fn test_is_ascii() {\n-        fail_unless!((is_ascii(~\"\")));\n-        fail_unless!((is_ascii(~\"a\")));\n-        fail_unless!((!is_ascii(~\"\\u2009\")));\n+        assert!((is_ascii(~\"\")));\n+        assert!((is_ascii(~\"a\")));\n+        assert!((!is_ascii(~\"\\u2009\")));\n     }\n \n     #[test]\n     fn test_shift_byte() {\n         let mut s = ~\"ABC\";\n         let b = unsafe { raw::shift_byte(&mut s) };\n-        fail_unless!((s == ~\"BC\"));\n-        fail_unless!((b == 65u8));\n+        assert!((s == ~\"BC\"));\n+        assert!((b == 65u8));\n     }\n \n     #[test]\n     fn test_pop_byte() {\n         let mut s = ~\"ABC\";\n         let b = unsafe { raw::pop_byte(&mut s) };\n-        fail_unless!((s == ~\"AB\"));\n-        fail_unless!((b == 67u8));\n+        assert!((s == ~\"AB\"));\n+        assert!((b == 67u8));\n     }\n \n     #[test]\n     fn test_unsafe_from_bytes() {\n         let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n         let b = unsafe { raw::from_bytes(a) };\n-        fail_unless!((b == ~\"AAAAAAA\"));\n+        assert!((b == ~\"AAAAAAA\"));\n     }\n \n     #[test]\n@@ -3271,7 +3271,7 @@ mod tests {\n                   0x20_u8, 0x4e_u8, 0x61_u8,\n                   0x6d_u8];\n \n-        fail_unless!(ss == from_bytes(bb));\n+        assert!(ss == from_bytes(bb));\n     }\n \n     #[test]\n@@ -3298,7 +3298,7 @@ mod tests {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = vec::raw::to_ptr(a);\n             let c = raw::from_buf(b);\n-            fail_unless!((c == ~\"AAAAAAA\"));\n+            assert!((c == ~\"AAAAAAA\"));\n         }\n     }\n \n@@ -3314,20 +3314,20 @@ mod tests {\n     fn test_as_buf() {\n         let a = ~\"Abcdefg\";\n         let b = as_buf(a, |buf, _l| {\n-            fail_unless!(unsafe { *buf } == 65u8);\n+            assert!(unsafe { *buf } == 65u8);\n             100\n         });\n-        fail_unless!((b == 100));\n+        assert!((b == 100));\n     }\n \n     #[test]\n     fn test_as_buf_small() {\n         let a = ~\"A\";\n         let b = as_buf(a, |buf, _l| {\n-            fail_unless!(unsafe { *buf } == 65u8);\n+            assert!(unsafe { *buf } == 65u8);\n             100\n         });\n-        fail_unless!((b == 100));\n+        assert!((b == 100));\n     }\n \n     #[test]\n@@ -3336,7 +3336,7 @@ mod tests {\n             let s = ~\"hello\";\n             let sb = as_buf(s, |b, _l| b);\n             let s_cstr = raw::from_buf(sb);\n-            fail_unless!(s_cstr == s);\n+            assert!(s_cstr == s);\n         }\n     }\n \n@@ -3345,11 +3345,11 @@ mod tests {\n         let a = ~\"hello\";\n         do as_buf(a) |buf, len| {\n             unsafe {\n-                fail_unless!(a[0] == 'h' as u8);\n-                fail_unless!(*buf == 'h' as u8);\n-                fail_unless!(len == 6u);\n-                fail_unless!(*ptr::offset(buf,4u) == 'o' as u8);\n-                fail_unless!(*ptr::offset(buf,5u) == 0u8);\n+                assert!(a[0] == 'h' as u8);\n+                assert!(*buf == 'h' as u8);\n+                assert!(len == 6u);\n+                assert!(*ptr::offset(buf,4u) == 'o' as u8);\n+                assert!(*ptr::offset(buf,5u) == 0u8);\n             }\n         }\n     }\n@@ -3363,40 +3363,40 @@ mod tests {\n         let mut i: uint = 0u;\n         let n1: uint = len(s1);\n         let n2: uint = vec::len::<u8>(v);\n-        fail_unless!((n1 == n2));\n+        assert!((n1 == n2));\n         while i < n1 {\n             let a: u8 = s1[i];\n             let b: u8 = s2[i];\n             debug!(a);\n             debug!(b);\n-            fail_unless!((a == b));\n+            assert!((a == b));\n             i += 1u;\n         }\n     }\n \n     #[test]\n     fn test_contains() {\n-        fail_unless!(contains(~\"abcde\", ~\"bcd\"));\n-        fail_unless!(contains(~\"abcde\", ~\"abcd\"));\n-        fail_unless!(contains(~\"abcde\", ~\"bcde\"));\n-        fail_unless!(contains(~\"abcde\", ~\"\"));\n-        fail_unless!(contains(~\"\", ~\"\"));\n-        fail_unless!(!contains(~\"abcde\", ~\"def\"));\n-        fail_unless!(!contains(~\"\", ~\"a\"));\n+        assert!(contains(~\"abcde\", ~\"bcd\"));\n+        assert!(contains(~\"abcde\", ~\"abcd\"));\n+        assert!(contains(~\"abcde\", ~\"bcde\"));\n+        assert!(contains(~\"abcde\", ~\"\"));\n+        assert!(contains(~\"\", ~\"\"));\n+        assert!(!contains(~\"abcde\", ~\"def\"));\n+        assert!(!contains(~\"\", ~\"a\"));\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(contains(data, ~\"\u0e1b\u0e23\u0e30\u0e40\"));\n-        fail_unless!(contains(data, ~\"\u0e30\u0e40\"));\n-        fail_unless!(contains(data, ~\"\u4e2d\u534e\"));\n-        fail_unless!(!contains(data, ~\"\u0e44\u0e17\u534e\"));\n+        assert!(contains(data, ~\"\u0e1b\u0e23\u0e30\u0e40\"));\n+        assert!(contains(data, ~\"\u0e30\u0e40\"));\n+        assert!(contains(data, ~\"\u4e2d\u534e\"));\n+        assert!(!contains(data, ~\"\u0e44\u0e17\u534e\"));\n     }\n \n     #[test]\n     fn test_contains_char() {\n-        fail_unless!(contains_char(~\"abc\", 'b'));\n-        fail_unless!(contains_char(~\"a\", 'a'));\n-        fail_unless!(!contains_char(~\"abc\", 'd'));\n-        fail_unless!(!contains_char(~\"\", 'a'));\n+        assert!(contains_char(~\"abc\", 'b'));\n+        assert!(contains_char(~\"a\", 'a'));\n+        assert!(!contains_char(~\"abc\", 'd'));\n+        assert!(!contains_char(~\"\", 'a'));\n     }\n \n     #[test]\n@@ -3407,10 +3407,10 @@ mod tests {\n \n         for each_split_char(data, ' ') |xx| {\n             match ii {\n-              0 => fail_unless!(\"\\nMary\" == xx),\n-              1 => fail_unless!(\"had\"    == xx),\n-              2 => fail_unless!(\"a\"      == xx),\n-              3 => fail_unless!(\"little\" == xx),\n+              0 => assert!(\"\\nMary\" == xx),\n+              1 => assert!(\"had\"    == xx),\n+              2 => assert!(\"a\"      == xx),\n+              3 => assert!(\"little\" == xx),\n               _ => ()\n             }\n             ii += 1;\n@@ -3425,9 +3425,9 @@ mod tests {\n \n         for each_splitn_char(data, ' ', 2u) |xx| {\n             match ii {\n-              0 => fail_unless!(\"\\nMary\" == xx),\n-              1 => fail_unless!(\"had\"    == xx),\n-              2 => fail_unless!(\"a little lamb\\nLittle lamb\\n\" == xx),\n+              0 => assert!(\"\\nMary\" == xx),\n+              1 => assert!(\"had\"    == xx),\n+              2 => assert!(\"a little lamb\\nLittle lamb\\n\" == xx),\n               _ => ()\n             }\n             ii += 1;\n@@ -3442,10 +3442,10 @@ mod tests {\n \n         for each_word(data) |ww| {\n             match ii {\n-              0 => fail_unless!(\"Mary\"   == ww),\n-              1 => fail_unless!(\"had\"    == ww),\n-              2 => fail_unless!(\"a\"      == ww),\n-              3 => fail_unless!(\"little\" == ww),\n+              0 => assert!(\"Mary\"   == ww),\n+              1 => assert!(\"had\"    == ww),\n+              2 => assert!(\"a\"      == ww),\n+              3 => assert!(\"little\" == ww),\n               _ => ()\n             }\n             ii += 1;\n@@ -3462,9 +3462,9 @@ mod tests {\n \n         for each_line(lf) |x| {\n             match ii {\n-                0 => fail_unless!(\"\" == x),\n-                1 => fail_unless!(\"Mary had a little lamb\" == x),\n-                2 => fail_unless!(\"Little lamb\" == x),\n+                0 => assert!(\"\" == x),\n+                1 => assert!(\"Mary had a little lamb\" == x),\n+                2 => assert!(\"Little lamb\" == x),\n                 _ => ()\n             }\n             ii += 1;\n@@ -3474,35 +3474,35 @@ mod tests {\n     #[test]\n     fn test_map() {\n         unsafe {\n-            fail_unless!(~\"\" == map(~\"\", |c|\n+            assert!(~\"\" == map(~\"\", |c|\n                 libc::toupper(c as c_char) as char));\n-            fail_unless!(~\"YMCA\" == map(~\"ymca\",\n+            assert!(~\"YMCA\" == map(~\"ymca\",\n                                   |c| libc::toupper(c as c_char) as char));\n         }\n     }\n \n     #[test]\n     fn test_all() {\n-        fail_unless!(true  == all(~\"\", char::is_uppercase));\n-        fail_unless!(false == all(~\"ymca\", char::is_uppercase));\n-        fail_unless!(true  == all(~\"YMCA\", char::is_uppercase));\n-        fail_unless!(false == all(~\"yMCA\", char::is_uppercase));\n-        fail_unless!(false == all(~\"YMCy\", char::is_uppercase));\n+        assert!(true  == all(~\"\", char::is_uppercase));\n+        assert!(false == all(~\"ymca\", char::is_uppercase));\n+        assert!(true  == all(~\"YMCA\", char::is_uppercase));\n+        assert!(false == all(~\"yMCA\", char::is_uppercase));\n+        assert!(false == all(~\"YMCy\", char::is_uppercase));\n     }\n \n     #[test]\n     fn test_any() {\n-        fail_unless!(false  == any(~\"\", char::is_uppercase));\n-        fail_unless!(false == any(~\"ymca\", char::is_uppercase));\n-        fail_unless!(true  == any(~\"YMCA\", char::is_uppercase));\n-        fail_unless!(true == any(~\"yMCA\", char::is_uppercase));\n-        fail_unless!(true == any(~\"Ymcy\", char::is_uppercase));\n+        assert!(false  == any(~\"\", char::is_uppercase));\n+        assert!(false == any(~\"ymca\", char::is_uppercase));\n+        assert!(true  == any(~\"YMCA\", char::is_uppercase));\n+        assert!(true == any(~\"yMCA\", char::is_uppercase));\n+        assert!(true == any(~\"Ymcy\", char::is_uppercase));\n     }\n \n     #[test]\n     fn test_chars() {\n         let ss = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a',\n+        assert!(~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a',\n                        'm']\n             == to_chars(ss));\n     }\n@@ -3548,10 +3548,10 @@ mod tests {\n \n         for vec::each(pairs) |p| {\n             let (s, u) = copy *p;\n-            fail_unless!(to_utf16(s) == u);\n-            fail_unless!(from_utf16(u) == s);\n-            fail_unless!(from_utf16(to_utf16(s)) == s);\n-            fail_unless!(to_utf16(from_utf16(u)) == u);\n+            assert!(to_utf16(s) == u);\n+            assert!(from_utf16(u) == s);\n+            assert!(from_utf16(to_utf16(s)) == s);\n+            assert!(to_utf16(from_utf16(u)) == u);\n         }\n     }\n \n@@ -3561,7 +3561,7 @@ mod tests {\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = 0;\n         for v.each |ch| {\n-            fail_unless!(s.char_at(pos) == *ch);\n+            assert!(s.char_at(pos) == *ch);\n             pos += from_char(*ch).len();\n         }\n     }\n@@ -3572,7 +3572,7 @@ mod tests {\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = s.len();\n         for v.each_reverse |ch| {\n-            fail_unless!(s.char_at_reverse(pos) == *ch);\n+            assert!(s.char_at_reverse(pos) == *ch);\n             pos -= from_char(*ch).len();\n         }\n     }\n@@ -3588,15 +3588,15 @@ mod tests {\n         let mut pos = 0;\n \n         for s.each |b| {\n-            fail_unless!(b == v[pos]);\n+            assert!(b == v[pos]);\n             pos += 1;\n         }\n     }\n \n     #[test]\n     fn test_each_empty() {\n         for \"\".each |b| {\n-            fail_unless!(b == 0u8);\n+            assert!(b == 0u8);\n         }\n     }\n \n@@ -3611,17 +3611,17 @@ mod tests {\n         let mut pos = 0;\n \n         for s.eachi |i, b| {\n-            fail_unless!(pos == i);\n-            fail_unless!(b == v[pos]);\n+            assert!(pos == i);\n+            assert!(b == v[pos]);\n             pos += 1;\n         }\n     }\n \n     #[test]\n     fn test_eachi_empty() {\n         for \"\".eachi |i, b| {\n-            fail_unless!(i == 0);\n-            fail_unless!(b == 0);\n+            assert!(i == 0);\n+            assert!(b == 0);\n         }\n     }\n \n@@ -3637,14 +3637,14 @@ mod tests {\n \n         for s.each_reverse |b| {\n             pos -= 1;\n-            fail_unless!(b == v[pos]);\n+            assert!(b == v[pos]);\n         }\n     }\n \n     #[test]\n     fn test_each_empty_reverse() {\n         for \"\".each_reverse |b| {\n-            fail_unless!(b == 0u8);\n+            assert!(b == 0u8);\n         }\n     }\n \n@@ -3660,16 +3660,16 @@ mod tests {\n \n         for s.eachi_reverse |i, b| {\n             pos -= 1;\n-            fail_unless!(pos == i);\n-            fail_unless!(b == v[pos]);\n+            assert!(pos == i);\n+            assert!(b == v[pos]);\n         }\n     }\n \n     #[test]\n     fn test_eachi_reverse_empty() {\n         for \"\".eachi_reverse |i, b| {\n-            fail_unless!(i == 0);\n-            fail_unless!(b == 0);\n+            assert!(i == 0);\n+            assert!(b == 0);\n         }\n     }\n \n@@ -3679,7 +3679,7 @@ mod tests {\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = 0;\n         for s.each_char |ch| {\n-            fail_unless!(ch == v[pos]);\n+            assert!(ch == v[pos]);\n             pos += 1;\n         }\n     }\n@@ -3690,8 +3690,8 @@ mod tests {\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = 0;\n         for s.each_chari |i, ch| {\n-            fail_unless!(pos == i);\n-            fail_unless!(ch == v[pos]);\n+            assert!(pos == i);\n+            assert!(ch == v[pos]);\n             pos += 1;\n         }\n     }\n@@ -3703,7 +3703,7 @@ mod tests {\n         let mut pos = v.len();\n         for s.each_char_reverse |ch| {\n             pos -= 1;\n-            fail_unless!(ch == v[pos]);\n+            assert!(ch == v[pos]);\n         }\n     }\n \n@@ -3714,43 +3714,43 @@ mod tests {\n         let mut pos = v.len();\n         for s.each_chari_reverse |i, ch| {\n             pos -= 1;\n-            fail_unless!(pos == i);\n-            fail_unless!(ch == v[pos]);\n+            assert!(pos == i);\n+            assert!(ch == v[pos]);\n         }\n     }\n \n     #[test]\n     fn test_escape_unicode() {\n-        fail_unless!(escape_unicode(~\"abc\") == ~\"\\\\x61\\\\x62\\\\x63\");\n-        fail_unless!(escape_unicode(~\"a c\") == ~\"\\\\x61\\\\x20\\\\x63\");\n-        fail_unless!(escape_unicode(~\"\\r\\n\\t\") == ~\"\\\\x0d\\\\x0a\\\\x09\");\n-        fail_unless!(escape_unicode(~\"'\\\"\\\\\") == ~\"\\\\x27\\\\x22\\\\x5c\");\n-        fail_unless!(escape_unicode(~\"\\x00\\x01\\xfe\\xff\") ==\n+        assert!(escape_unicode(~\"abc\") == ~\"\\\\x61\\\\x62\\\\x63\");\n+        assert!(escape_unicode(~\"a c\") == ~\"\\\\x61\\\\x20\\\\x63\");\n+        assert!(escape_unicode(~\"\\r\\n\\t\") == ~\"\\\\x0d\\\\x0a\\\\x09\");\n+        assert!(escape_unicode(~\"'\\\"\\\\\") == ~\"\\\\x27\\\\x22\\\\x5c\");\n+        assert!(escape_unicode(~\"\\x00\\x01\\xfe\\xff\") ==\n                      ~\"\\\\x00\\\\x01\\\\xfe\\\\xff\");\n-        fail_unless!(escape_unicode(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\");\n-        fail_unless!(escape_unicode(~\"\\U00010000\\U0010ffff\") ==\n+        assert!(escape_unicode(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\");\n+        assert!(escape_unicode(~\"\\U00010000\\U0010ffff\") ==\n             ~\"\\\\U00010000\\\\U0010ffff\");\n-        fail_unless!(escape_unicode(~\"ab\\ufb00\") == ~\"\\\\x61\\\\x62\\\\ufb00\");\n-        fail_unless!(escape_unicode(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\x0d\");\n+        assert!(escape_unicode(~\"ab\\ufb00\") == ~\"\\\\x61\\\\x62\\\\ufb00\");\n+        assert!(escape_unicode(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\x0d\");\n     }\n \n     #[test]\n     fn test_escape_default() {\n-        fail_unless!(escape_default(~\"abc\") == ~\"abc\");\n-        fail_unless!(escape_default(~\"a c\") == ~\"a c\");\n-        fail_unless!(escape_default(~\"\\r\\n\\t\") == ~\"\\\\r\\\\n\\\\t\");\n-        fail_unless!(escape_default(~\"'\\\"\\\\\") == ~\"\\\\'\\\\\\\"\\\\\\\\\");\n-        fail_unless!(escape_default(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\");\n-        fail_unless!(escape_default(~\"\\U00010000\\U0010ffff\") ==\n+        assert!(escape_default(~\"abc\") == ~\"abc\");\n+        assert!(escape_default(~\"a c\") == ~\"a c\");\n+        assert!(escape_default(~\"\\r\\n\\t\") == ~\"\\\\r\\\\n\\\\t\");\n+        assert!(escape_default(~\"'\\\"\\\\\") == ~\"\\\\'\\\\\\\"\\\\\\\\\");\n+        assert!(escape_default(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\");\n+        assert!(escape_default(~\"\\U00010000\\U0010ffff\") ==\n             ~\"\\\\U00010000\\\\U0010ffff\");\n-        fail_unless!(escape_default(~\"ab\\ufb00\") == ~\"ab\\\\ufb00\");\n-        fail_unless!(escape_default(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\r\");\n+        assert!(escape_default(~\"ab\\ufb00\") == ~\"ab\\\\ufb00\");\n+        assert!(escape_default(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\r\");\n     }\n \n     #[test]\n     fn test_to_managed() {\n-        fail_unless!((~\"abc\").to_managed() == @\"abc\");\n-        fail_unless!(slice(\"abcdef\", 1, 5).to_managed() == @\"bcde\");\n+        assert!((~\"abc\").to_managed() == @\"abc\");\n+        assert!(slice(\"abcdef\", 1, 5).to_managed() == @\"bcde\");\n     }\n \n     #[test]"}, {"sha": "338893d2388b7eda8a459c337f3b69ef1ed33d39", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -170,57 +170,57 @@ pub mod tests {\n \n     #[test]\n     pub fn size_of_basic() {\n-        fail_unless!(size_of::<u8>() == 1u);\n-        fail_unless!(size_of::<u16>() == 2u);\n-        fail_unless!(size_of::<u32>() == 4u);\n-        fail_unless!(size_of::<u64>() == 8u);\n+        assert!(size_of::<u8>() == 1u);\n+        assert!(size_of::<u16>() == 2u);\n+        assert!(size_of::<u32>() == 4u);\n+        assert!(size_of::<u64>() == 8u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n     #[cfg(target_arch = \"mips\")]\n     pub fn size_of_32() {\n-        fail_unless!(size_of::<uint>() == 4u);\n-        fail_unless!(size_of::<*uint>() == 4u);\n+        assert!(size_of::<uint>() == 4u);\n+        assert!(size_of::<*uint>() == 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n     pub fn size_of_64() {\n-        fail_unless!(size_of::<uint>() == 8u);\n-        fail_unless!(size_of::<*uint>() == 8u);\n+        assert!(size_of::<uint>() == 8u);\n+        assert!(size_of::<*uint>() == 8u);\n     }\n \n     #[test]\n     pub fn nonzero_size_of_basic() {\n         type Z = [i8, ..0];\n-        fail_unless!(size_of::<Z>() == 0u);\n-        fail_unless!(nonzero_size_of::<Z>() == 1u);\n-        fail_unless!(nonzero_size_of::<uint>() == size_of::<uint>());\n+        assert!(size_of::<Z>() == 0u);\n+        assert!(nonzero_size_of::<Z>() == 1u);\n+        assert!(nonzero_size_of::<uint>() == size_of::<uint>());\n     }\n \n     #[test]\n     pub fn align_of_basic() {\n-        fail_unless!(pref_align_of::<u8>() == 1u);\n-        fail_unless!(pref_align_of::<u16>() == 2u);\n-        fail_unless!(pref_align_of::<u32>() == 4u);\n+        assert!(pref_align_of::<u8>() == 1u);\n+        assert!(pref_align_of::<u16>() == 2u);\n+        assert!(pref_align_of::<u32>() == 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n     #[cfg(target_arch = \"mips\")]\n     pub fn align_of_32() {\n-        fail_unless!(pref_align_of::<uint>() == 4u);\n-        fail_unless!(pref_align_of::<*uint>() == 4u);\n+        assert!(pref_align_of::<uint>() == 4u);\n+        assert!(pref_align_of::<*uint>() == 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n     pub fn align_of_64() {\n-        fail_unless!(pref_align_of::<uint>() == 8u);\n-        fail_unless!(pref_align_of::<*uint>() == 8u);\n+        assert!(pref_align_of::<uint>() == 8u);\n+        assert!(pref_align_of::<*uint>() == 8u);\n     }\n \n     #[test]\n@@ -229,7 +229,7 @@ pub mod tests {\n             let x = 10;\n             let f: &fn(int) -> int = |y| x + y;\n \n-            fail_unless!(f(20) == 30);\n+            assert!(f(20) == 30);\n \n             let original_closure: Closure = cast::transmute(f);\n \n@@ -242,7 +242,7 @@ pub mod tests {\n             };\n \n             let new_f: &fn(int) -> int = cast::transmute(new_closure);\n-            fail_unless!(new_f(20) == 30);\n+            assert!(new_f(20) == 30);\n         }\n     }\n }"}, {"sha": "261671f6de9aeaf0ebc56ffea5be0a090b0b65f9", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -92,17 +92,17 @@ fn test_tls_multitask() {\n         do task::spawn {\n             unsafe {\n                 // TLS shouldn't carry over.\n-                fail_unless!(local_data_get(my_key).is_none());\n+                assert!(local_data_get(my_key).is_none());\n                 local_data_set(my_key, @~\"child data\");\n-                fail_unless!(*(local_data_get(my_key).get()) ==\n+                assert!(*(local_data_get(my_key).get()) ==\n                     ~\"child data\");\n                 // should be cleaned up for us\n             }\n         }\n         // Must work multiple times\n-        fail_unless!(*(local_data_get(my_key).get()) == ~\"parent data\");\n-        fail_unless!(*(local_data_get(my_key).get()) == ~\"parent data\");\n-        fail_unless!(*(local_data_get(my_key).get()) == ~\"parent data\");\n+        assert!(*(local_data_get(my_key).get()) == ~\"parent data\");\n+        assert!(*(local_data_get(my_key).get()) == ~\"parent data\");\n+        assert!(*(local_data_get(my_key).get()) == ~\"parent data\");\n     }\n }\n \n@@ -112,7 +112,7 @@ fn test_tls_overwrite() {\n         fn my_key(_x: @~str) { }\n         local_data_set(my_key, @~\"first data\");\n         local_data_set(my_key, @~\"next data\"); // Shouldn't leak.\n-        fail_unless!(*(local_data_get(my_key).get()) == ~\"next data\");\n+        assert!(*(local_data_get(my_key).get()) == ~\"next data\");\n     }\n }\n \n@@ -121,9 +121,9 @@ fn test_tls_pop() {\n     unsafe {\n         fn my_key(_x: @~str) { }\n         local_data_set(my_key, @~\"weasel\");\n-        fail_unless!(*(local_data_pop(my_key).get()) == ~\"weasel\");\n+        assert!(*(local_data_pop(my_key).get()) == ~\"weasel\");\n         // Pop must remove the data from the map.\n-        fail_unless!(local_data_pop(my_key).is_none());\n+        assert!(local_data_pop(my_key).is_none());\n     }\n }\n \n@@ -144,7 +144,7 @@ fn test_tls_modify() {\n                 None                 => fail!(~\"missing value\")\n             }\n         });\n-        fail_unless!(*(local_data_pop(my_key).get()) == ~\"next data\");\n+        assert!(*(local_data_pop(my_key).get()) == ~\"next data\");\n     }\n }\n "}, {"sha": "43f5fa4654bc742c8e182db53453db1a29b4fb22", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -41,7 +41,7 @@ type TaskLocalMap = @mut ~[Option<TaskLocalElement>];\n \n extern fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n     unsafe {\n-        fail_unless!(!map_ptr.is_null());\n+        assert!(!map_ptr.is_null());\n         // Get and keep the single reference that was created at the\n         // beginning.\n         let _map: TaskLocalMap = cast::reinterpret_cast(&map_ptr);"}, {"sha": "ee454312e04431267c0efb41a634326836ed4689", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -840,14 +840,14 @@ fn test_add_wrapper() {\n fn test_future_result() {\n     let mut result = None;\n     do task().future_result(|+r| { result = Some(r); }).spawn { }\n-    fail_unless!(result.unwrap().recv() == Success);\n+    assert!(result.unwrap().recv() == Success);\n \n     result = None;\n     do task().future_result(|+r|\n         { result = Some(r); }).unlinked().spawn {\n         fail!();\n     }\n-    fail_unless!(result.unwrap().recv() == Failure);\n+    assert!(result.unwrap().recv() == Failure);\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -893,7 +893,7 @@ fn test_spawn_sched() {\n \n         do spawn_sched(SingleThreaded) {\n             let child_sched_id = unsafe { rt::rust_get_sched_id() };\n-            fail_unless!(parent_sched_id != child_sched_id);\n+            assert!(parent_sched_id != child_sched_id);\n \n             if (i == 0) {\n                 ch.send(());\n@@ -921,8 +921,8 @@ fn test_spawn_sched_childs_on_default_sched() {\n         do spawn {\n             let ch = ch.f.swap_unwrap();\n             let child_sched_id = unsafe { rt::rust_get_sched_id() };\n-            fail_unless!(parent_sched_id != child_sched_id);\n-            fail_unless!(child_sched_id == default_id);\n+            assert!(parent_sched_id != child_sched_id);\n+            assert!(child_sched_id == default_id);\n             ch.send(());\n         };\n     };\n@@ -1016,7 +1016,7 @@ fn avoid_copying_the_body(spawnfn: &fn(v: ~fn())) {\n     }\n \n     let x_in_child = p.recv();\n-    fail_unless!(x_in_parent == x_in_child);\n+    assert!(x_in_parent == x_in_child);\n }\n \n #[test]\n@@ -1171,7 +1171,7 @@ fn test_sched_thread_per_core() {\n         unsafe {\n             let cores = rt::rust_num_threads();\n             let reported_threads = rt::rust_sched_threads();\n-            fail_unless!((cores as uint == reported_threads as uint));\n+            assert!((cores as uint == reported_threads as uint));\n             chan.send(());\n         }\n     }\n@@ -1186,9 +1186,9 @@ fn test_spawn_thread_on_demand() {\n     do spawn_sched(ManualThreads(2)) || {\n         unsafe {\n             let max_threads = rt::rust_sched_threads();\n-            fail_unless!((max_threads as int == 2));\n+            assert!((max_threads as int == 2));\n             let running_threads = rt::rust_sched_current_nonlazy_threads();\n-            fail_unless!((running_threads as int == 1));\n+            assert!((running_threads as int == 1));\n \n             let (port2, chan2) = comm::stream();\n \n@@ -1197,7 +1197,7 @@ fn test_spawn_thread_on_demand() {\n             }\n \n             let running_threads2 = rt::rust_sched_current_nonlazy_threads();\n-            fail_unless!((running_threads2 as int == 2));\n+            assert!((running_threads2 as int == 2));\n \n             port2.recv();\n             chan.send(());"}, {"sha": "39e43ba6fc5e893f97f35588a1d7d71e585e5973", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -103,11 +103,11 @@ fn new_taskset() -> TaskSet {\n }\n fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n     let didnt_overwrite = tasks.insert(task);\n-    fail_unless!(didnt_overwrite);\n+    assert!(didnt_overwrite);\n }\n fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     let was_present = tasks.remove(&task);\n-    fail_unless!(was_present);\n+    assert!(was_present);\n }\n pub fn taskset_each(tasks: &TaskSet, blk: &fn(v: *rust_task) -> bool) {\n     tasks.each(|k| blk(*k))\n@@ -231,7 +231,7 @@ fn each_ancestor(list:        &mut AncestorList,\n             // NB: Takes a lock! (this ancestor node)\n             do access_ancestors(ancestor_arc) |nobe| {\n                 // Check monotonicity\n-                fail_unless!(last_generation > nobe.generation);\n+                assert!(last_generation > nobe.generation);\n                 /*##########################################################*\n                  * Step 1: Look at this ancestor group (call iterator block).\n                  *##########################################################*/\n@@ -423,7 +423,7 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n                 }\n             }\n             for taskset_each(&group.descendants) |child| {\n-                fail_unless!(child != me);\n+                assert!(child != me);\n                 rt::rust_task_kill_other(child);\n             }\n             // Only one task should ever do this.\n@@ -498,7 +498,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                         }\n                         None => 0 // the actual value doesn't really matter.\n                     };\n-                fail_unless!(new_generation < uint::max_value);\n+                assert!(new_generation < uint::max_value);\n                 // Build a new node in the ancestor list.\n                 AncestorList(Some(unstable::exclusive(AncestorNode {\n                     generation: new_generation,\n@@ -545,7 +545,7 @@ pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n                 DefaultScheduler => rt::new_task(),\n                 _ => new_task_in_sched(opts.sched)\n             };\n-            fail_unless!(!new_task.is_null());\n+            assert!(!new_task.is_null());\n             // Getting killed after here would leak the task.\n             let mut notify_chan = if opts.notify_chan.is_none() {\n                 None\n@@ -717,7 +717,7 @@ fn test_spawn_raw_notify_success() {\n     };\n     do spawn_raw(opts) {\n     }\n-    fail_unless!(notify_po.recv() == Success);\n+    assert!(notify_po.recv() == Success);\n }\n \n #[test]\n@@ -734,5 +734,5 @@ fn test_spawn_raw_notify_failure() {\n     do spawn_raw(opts) {\n         fail!();\n     }\n-    fail_unless!(notify_po.recv() == Failure);\n+    assert!(notify_po.recv() == Failure);\n }"}, {"sha": "a6004ed1241747fc295f8ee4f9fee0c68fe6c6c6", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -137,31 +137,31 @@ impl<A:ToStr> ToStr for @[A] {\n mod tests {\n     #[test]\n     fn test_simple_types() {\n-        fail_unless!(1i.to_str() == ~\"1\");\n-        fail_unless!((-1i).to_str() == ~\"-1\");\n-        fail_unless!(200u.to_str() == ~\"200\");\n-        fail_unless!(2u8.to_str() == ~\"2\");\n-        fail_unless!(true.to_str() == ~\"true\");\n-        fail_unless!(false.to_str() == ~\"false\");\n-        fail_unless!(().to_str() == ~\"()\");\n-        fail_unless!((~\"hi\").to_str() == ~\"hi\");\n-        fail_unless!((@\"hi\").to_str() == ~\"hi\");\n+        assert!(1i.to_str() == ~\"1\");\n+        assert!((-1i).to_str() == ~\"-1\");\n+        assert!(200u.to_str() == ~\"200\");\n+        assert!(2u8.to_str() == ~\"2\");\n+        assert!(true.to_str() == ~\"true\");\n+        assert!(false.to_str() == ~\"false\");\n+        assert!(().to_str() == ~\"()\");\n+        assert!((~\"hi\").to_str() == ~\"hi\");\n+        assert!((@\"hi\").to_str() == ~\"hi\");\n     }\n \n     #[test]\n     fn test_tuple_types() {\n-        fail_unless!((1, 2).to_str() == ~\"(1, 2)\");\n-        fail_unless!((~\"a\", ~\"b\", false).to_str() == ~\"(a, b, false)\");\n-        fail_unless!(((), ((), 100)).to_str() == ~\"((), ((), 100))\");\n+        assert!((1, 2).to_str() == ~\"(1, 2)\");\n+        assert!((~\"a\", ~\"b\", false).to_str() == ~\"(a, b, false)\");\n+        assert!(((), ((), 100)).to_str() == ~\"((), ((), 100))\");\n     }\n \n     #[test]\n     fn test_vectors() {\n         let x: ~[int] = ~[];\n-        fail_unless!(x.to_str() == ~\"[]\");\n-        fail_unless!((~[1]).to_str() == ~\"[1]\");\n-        fail_unless!((~[1, 2, 3]).to_str() == ~\"[1, 2, 3]\");\n-        fail_unless!((~[~[], ~[1], ~[1, 1]]).to_str() ==\n+        assert!(x.to_str() == ~\"[]\");\n+        assert!((~[1]).to_str() == ~\"[1]\");\n+        assert!((~[1, 2, 3]).to_str() == ~\"[1, 2, 3]\");\n+        assert!((~[~[], ~[1], ~[1, 1]]).to_str() ==\n                ~\"[[], [1], [1, 1]]\");\n     }\n }"}, {"sha": "5d87e2a296d3d23655320cb85802e8c5411f72b6", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -354,7 +354,7 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n \n #[cfg(test)]\n pub fn check_integrity<T>(trie: &TrieNode<T>) {\n-    fail_unless!(trie.count != 0);\n+    assert!(trie.count != 0);\n \n     let mut sum = 0;\n \n@@ -369,7 +369,7 @@ pub fn check_integrity<T>(trie: &TrieNode<T>) {\n         }\n     }\n \n-    fail_unless!(sum == trie.count);\n+    assert!(sum == trie.count);\n }\n \n #[cfg(test)]\n@@ -381,9 +381,9 @@ mod tests {\n     #[test]\n     fn test_find_mut() {\n         let mut m = TrieMap::new();\n-        fail_unless!(m.insert(1, 12));\n-        fail_unless!(m.insert(2, 8));\n-        fail_unless!(m.insert(5, 14));\n+        assert!(m.insert(1, 12));\n+        assert!(m.insert(2, 8));\n+        assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n             None => fail!(), Some(x) => *x = new\n@@ -397,32 +397,32 @@ mod tests {\n         let n = 300;\n \n         for uint::range_step(1, n, 2) |x| {\n-            fail_unless!(trie.insert(x, x + 1));\n-            fail_unless!(trie.contains_key(&x));\n+            assert!(trie.insert(x, x + 1));\n+            assert!(trie.contains_key(&x));\n             check_integrity(&trie.root);\n         }\n \n         for uint::range_step(0, n, 2) |x| {\n-            fail_unless!(!trie.contains_key(&x));\n-            fail_unless!(trie.insert(x, x + 1));\n+            assert!(!trie.contains_key(&x));\n+            assert!(trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n         }\n \n         for uint::range(0, n) |x| {\n-            fail_unless!(trie.contains_key(&x));\n-            fail_unless!(!trie.insert(x, x + 1));\n+            assert!(trie.contains_key(&x));\n+            assert!(!trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n         }\n \n         for uint::range_step(1, n, 2) |x| {\n-            fail_unless!(trie.remove(&x));\n-            fail_unless!(!trie.contains_key(&x));\n+            assert!(trie.remove(&x));\n+            assert!(!trie.contains_key(&x));\n             check_integrity(&trie.root);\n         }\n \n         for uint::range_step(0, n, 2) |x| {\n-            fail_unless!(trie.contains_key(&x));\n-            fail_unless!(!trie.insert(x, x + 1));\n+            assert!(trie.contains_key(&x));\n+            assert!(!trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n         }\n     }\n@@ -431,16 +431,16 @@ mod tests {\n     fn test_each() {\n         let mut m = TrieMap::new();\n \n-        fail_unless!(m.insert(3, 6));\n-        fail_unless!(m.insert(0, 0));\n-        fail_unless!(m.insert(4, 8));\n-        fail_unless!(m.insert(2, 4));\n-        fail_unless!(m.insert(1, 2));\n+        assert!(m.insert(3, 6));\n+        assert!(m.insert(0, 0));\n+        assert!(m.insert(4, 8));\n+        assert!(m.insert(2, 4));\n+        assert!(m.insert(1, 2));\n \n         let mut n = 0;\n         for m.each |&(k, v)| {\n-            fail_unless!(k == n);\n-            fail_unless!(*v == n * 2);\n+            assert!(k == n);\n+            assert!(*v == n * 2);\n             n += 1;\n         }\n     }\n@@ -456,10 +456,10 @@ mod tests {\n         let mut n = uint::max_value - 9999;\n         for m.each |&(k, v)| {\n             if n == uint::max_value - 5000 { break }\n-            fail_unless!(n < uint::max_value - 5000);\n+            assert!(n < uint::max_value - 5000);\n \n-            fail_unless!(k == n);\n-            fail_unless!(*v == n / 2);\n+            assert!(k == n);\n+            assert!(*v == n / 2);\n             n += 1;\n         }\n     }\n@@ -468,16 +468,16 @@ mod tests {\n     fn test_each_reverse() {\n         let mut m = TrieMap::new();\n \n-        fail_unless!(m.insert(3, 6));\n-        fail_unless!(m.insert(0, 0));\n-        fail_unless!(m.insert(4, 8));\n-        fail_unless!(m.insert(2, 4));\n-        fail_unless!(m.insert(1, 2));\n+        assert!(m.insert(3, 6));\n+        assert!(m.insert(0, 0));\n+        assert!(m.insert(4, 8));\n+        assert!(m.insert(2, 4));\n+        assert!(m.insert(1, 2));\n \n         let mut n = 4;\n         for m.each_reverse |&(k, v)| {\n-            fail_unless!(k == n);\n-            fail_unless!(*v == n * 2);\n+            assert!(k == n);\n+            assert!(*v == n * 2);\n             n -= 1;\n         }\n     }\n@@ -493,10 +493,10 @@ mod tests {\n         let mut n = uint::max_value;\n         for m.each_reverse |&(k, v)| {\n             if n == uint::max_value - 5000 { break }\n-            fail_unless!(n > uint::max_value - 5000);\n+            assert!(n > uint::max_value - 5000);\n \n-            fail_unless!(k == n);\n-            fail_unless!(*v == n / 2);\n+            assert!(k == n);\n+            assert!(*v == n / 2);\n             n -= 1;\n         }\n     }\n@@ -508,17 +508,17 @@ mod tests {\n \n         let mut trie = TrieSet::new();\n \n-        fail_unless!(trie.insert(x));\n-        fail_unless!(trie.insert(y));\n+        assert!(trie.insert(x));\n+        assert!(trie.insert(y));\n \n-        fail_unless!(trie.len() == 2);\n+        assert!(trie.len() == 2);\n \n         let expected = [x, y];\n \n         let mut i = 0;\n \n         for trie.each |x| {\n-            fail_unless!(expected[i] == *x);\n+            assert!(expected[i] == *x);\n             i += 1;\n         }\n     }"}, {"sha": "a5c86d592c6361c30c953fcf65ed7364bd306c0a", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -240,15 +240,15 @@ impl<A:Ord,B:Ord,C:Ord> Ord for (A, B, C) {\n #[test]\n fn test_tuple_ref() {\n     let x = (~\"foo\", ~\"bar\");\n-    fail_unless!(x.first_ref() == &~\"foo\");\n-    fail_unless!(x.second_ref() == &~\"bar\");\n+    assert!(x.first_ref() == &~\"foo\");\n+    assert!(x.second_ref() == &~\"bar\");\n }\n \n #[test]\n #[allow(non_implicitly_copyable_typarams)]\n fn test_tuple() {\n-    fail_unless!((948, 4039.48).first() == 948);\n-    fail_unless!((34.5, ~\"foo\").second() == ~\"foo\");\n-    fail_unless!(('a', 2).swap() == (2, 'a'));\n+    assert!((948, 4039.48).first() == 948);\n+    assert!((34.5, ~\"foo\").second() == ~\"foo\");\n+    assert!(('a', 2).swap() == (2, 'a'));\n }\n "}, {"sha": "665a3e1b6b6d4b7ee937701d645029f22e42b45a", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -81,7 +81,7 @@ pub fn run_in_bare_thread(f: ~fn()) {\n fn test_run_in_bare_thread() {\n     let i = 100;\n     do run_in_bare_thread {\n-        fail_unless!(i == 100);\n+        assert!(i == 100);\n     }\n }\n \n@@ -90,7 +90,7 @@ fn test_run_in_bare_thread_exchange() {\n     // Does the exchange heap work without the runtime?\n     let i = ~100;\n     do run_in_bare_thread {\n-        fail_unless!(i == ~100);\n+        assert!(i == ~100);\n     }\n }\n \n@@ -123,7 +123,7 @@ impl<T> Drop for ArcDestruct<T>{\n                 let data: ~ArcData<T> = cast::reinterpret_cast(&self.data);\n                 let new_count =\n                     intrinsics::atomic_xsub(&mut data.count, 1) - 1;\n-                fail_unless!(new_count >= 0);\n+                assert!(new_count >= 0);\n                 if new_count == 0 {\n                     // drop glue takes over.\n                 } else {\n@@ -163,7 +163,7 @@ pub unsafe fn get_shared_mutable_state<T:Owned>(\n {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        fail_unless!(ptr.count > 0);\n+        assert!(ptr.count > 0);\n         let r = cast::transmute(ptr.data.get_ref());\n         cast::forget(ptr);\n         return r;\n@@ -174,7 +174,7 @@ pub unsafe fn get_shared_immutable_state<'a,T:Owned>(\n         rc: &'a SharedMutableState<T>) -> &'a T {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        fail_unless!(ptr.count > 0);\n+        assert!(ptr.count > 0);\n         // Cast us back into the correct region\n         let r = cast::transmute_region(ptr.data.get_ref());\n         cast::forget(ptr);\n@@ -187,7 +187,7 @@ pub unsafe fn clone_shared_mutable_state<T:Owned>(rc: &SharedMutableState<T>)\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         let new_count = intrinsics::atomic_xadd(&mut ptr.count, 1) + 1;\n-        fail_unless!(new_count >= 2);\n+        assert!(new_count >= 2);\n         cast::forget(ptr);\n     }\n     ArcDestruct((*rc).data)\n@@ -338,7 +338,7 @@ pub mod tests {\n         for futures.each |f| { f.recv() }\n \n         do total.with |total| {\n-            fail_unless!(**total == num_tasks * count)\n+            assert!(**total == num_tasks * count)\n         };\n     }\n \n@@ -350,11 +350,11 @@ pub mod tests {\n         let x2 = x.clone();\n         do task::try || {\n             do x2.with |one| {\n-                fail_unless!(*one == 2);\n+                assert!(*one == 2);\n             }\n         };\n         do x.with |one| {\n-            fail_unless!(*one == 1);\n+            assert!(*one == 1);\n         }\n     }\n }"}, {"sha": "83f0c3695e82ff41d46343812d4ea778dff66759", "filename": "src/libcore/unstable/at_exit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Funstable%2Fat_exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Funstable%2Fat_exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fat_exit.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -80,7 +80,7 @@ fn test_at_exit() {\n     let i = 10;\n     do at_exit {\n         debug!(\"at_exit1\");\n-        fail_unless!(i == 10);\n+        assert!(i == 10);\n     }\n }\n \n@@ -90,8 +90,8 @@ fn test_at_exit_many() {\n     for uint::range(20, 100) |j| {\n         do at_exit {\n             debug!(\"at_exit2\");\n-            fail_unless!(i == 10);\n-            fail_unless!(j > i);\n+            assert!(i == 10);\n+            assert!(j > i);\n         }\n     }\n }"}, {"sha": "fdf99e9dffea67b38ecfe9fc88063af8a36161f7", "filename": "src/libcore/unstable/exchange_alloc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fexchange_alloc.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -20,11 +20,11 @@ use intrinsic::TyDesc;\n \n pub unsafe fn malloc(td: *TypeDesc, size: uint) -> *c_void {\n     unsafe {\n-        fail_unless!(td.is_not_null());\n+        assert!(td.is_not_null());\n \n         let total_size = get_box_size(size, (*td).align);\n         let p = c_malloc(total_size as size_t);\n-        fail_unless!(p.is_not_null());\n+        assert!(p.is_not_null());\n \n         // FIXME #3475: Converting between our two different tydesc types\n         let td: *TyDesc = transmute(td);\n@@ -57,7 +57,7 @@ pub unsafe fn free(ptr: *c_void) {\n     let exchange_count = &mut *rust_get_exchange_count_ptr();\n     atomic_xsub(exchange_count, 1);\n \n-    fail_unless!(ptr.is_not_null());\n+    assert!(ptr.is_not_null());\n     c_free(ptr);\n }\n ///Thin wrapper around libc::free, as with exchange_alloc::malloc_raw\n@@ -75,7 +75,7 @@ fn get_box_size(body_size: uint, body_align: uint) -> uint {\n // Rounds |size| to the nearest |alignment|. Invariant: |alignment| is a power\n // of two.\n fn align_to(size: uint, align: uint) -> uint {\n-    fail_unless!(align != 0);\n+    assert!(align != 0);\n     (size + align - 1) & !(align - 1)\n }\n "}, {"sha": "be2aecf0c2a3b30b4465cf1649773e5173abaa7d", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -340,11 +340,11 @@ pub mod ct {\n             parse_count(s, 0, s.len()) == Parsed::new(count, next)\n         }\n \n-        fail_unless!(test(\"\", CountImplied, 0));\n-        fail_unless!(test(\"*\", CountIsNextParam, 1));\n-        fail_unless!(test(\"*1\", CountIsNextParam, 1));\n-        fail_unless!(test(\"*1$\", CountIsParam(1), 3));\n-        fail_unless!(test(\"123\", CountIs(123), 3));\n+        assert!(test(\"\", CountImplied, 0));\n+        assert!(test(\"*\", CountIsNextParam, 1));\n+        assert!(test(\"*1\", CountIsNextParam, 1));\n+        assert!(test(\"*1$\", CountIsParam(1), 3));\n+        assert!(test(\"123\", CountIs(123), 3));\n     }\n \n     #[test]\n@@ -355,8 +355,8 @@ pub mod ct {\n \n         fn test(s: &str, flags: &[Flag], next: uint) {\n             let f = parse_flags(s, 0, s.len());\n-            fail_unless!(pack(f.val) == pack(flags));\n-            fail_unless!(f.next == next);\n+            assert!(pack(f.val) == pack(flags));\n+            assert!(f.next == next);\n         }\n \n         test(\"\", [], 0);\n@@ -367,7 +367,7 @@ pub mod ct {\n \n     #[test]\n     fn test_parse_fmt_string() {\n-        fail_unless!(parse_fmt_string(\"foo %s bar\", die) == ~[\n+        assert!(parse_fmt_string(\"foo %s bar\", die) == ~[\n             PieceString(~\"foo \"),\n             PieceConv(Conv {\n                 param: None,\n@@ -378,7 +378,7 @@ pub mod ct {\n             }),\n             PieceString(~\" bar\")]);\n \n-        fail_unless!(parse_fmt_string(\"%s\", die) == ~[\n+        assert!(parse_fmt_string(\"%s\", die) == ~[\n             PieceConv(Conv {\n                 param: None,\n                 flags: ~[],\n@@ -387,7 +387,7 @@ pub mod ct {\n                 ty: TyStr,\n             })]);\n \n-        fail_unless!(parse_fmt_string(\"%%%%\", die) == ~[\n+        assert!(parse_fmt_string(\"%%%%\", die) == ~[\n             PieceString(~\"%\"), PieceString(~\"%\")]);\n     }\n \n@@ -397,10 +397,10 @@ pub mod ct {\n             parse_parameter(s, 0, s.len()) == Parsed::new(param, next)\n         }\n \n-        fail_unless!(test(\"\", None, 0));\n-        fail_unless!(test(\"foo\", None, 0));\n-        fail_unless!(test(\"123\", None, 0));\n-        fail_unless!(test(\"123$\", Some(123), 4));\n+        assert!(test(\"\", None, 0));\n+        assert!(test(\"foo\", None, 0));\n+        assert!(test(\"123\", None, 0));\n+        assert!(test(\"123$\", Some(123), 4));\n     }\n \n     #[test]\n@@ -409,12 +409,12 @@ pub mod ct {\n             parse_precision(s, 0, s.len()) == Parsed::new(count, next)\n         }\n \n-        fail_unless!(test(\"\", CountImplied, 0));\n-        fail_unless!(test(\".\", CountIs(0), 1));\n-        fail_unless!(test(\".*\", CountIsNextParam, 2));\n-        fail_unless!(test(\".*1\", CountIsNextParam, 2));\n-        fail_unless!(test(\".*1$\", CountIsParam(1), 4));\n-        fail_unless!(test(\".123\", CountIs(123), 4));\n+        assert!(test(\"\", CountImplied, 0));\n+        assert!(test(\".\", CountIs(0), 1));\n+        assert!(test(\".*\", CountIsNextParam, 2));\n+        assert!(test(\".*1\", CountIsNextParam, 2));\n+        assert!(test(\".*1$\", CountIsParam(1), 4));\n+        assert!(test(\".123\", CountIs(123), 4));\n     }\n \n     #[test]\n@@ -423,17 +423,17 @@ pub mod ct {\n             parse_type(s, 0, s.len(), die) == Parsed::new(ty, 1)\n         }\n \n-        fail_unless!(test(\"b\", TyBool));\n-        fail_unless!(test(\"c\", TyChar));\n-        fail_unless!(test(\"d\", TyInt(Signed)));\n-        fail_unless!(test(\"f\", TyFloat));\n-        fail_unless!(test(\"i\", TyInt(Signed)));\n-        fail_unless!(test(\"o\", TyOctal));\n-        fail_unless!(test(\"s\", TyStr));\n-        fail_unless!(test(\"t\", TyBits));\n-        fail_unless!(test(\"x\", TyHex(CaseLower)));\n-        fail_unless!(test(\"X\", TyHex(CaseUpper)));\n-        fail_unless!(test(\"?\", TyPoly));\n+        assert!(test(\"b\", TyBool));\n+        assert!(test(\"c\", TyChar));\n+        assert!(test(\"d\", TyInt(Signed)));\n+        assert!(test(\"f\", TyFloat));\n+        assert!(test(\"i\", TyInt(Signed)));\n+        assert!(test(\"o\", TyOctal));\n+        assert!(test(\"s\", TyStr));\n+        assert!(test(\"t\", TyBits));\n+        assert!(test(\"x\", TyHex(CaseLower)));\n+        assert!(test(\"X\", TyHex(CaseUpper)));\n+        assert!(test(\"?\", TyPoly));\n     }\n \n     #[test]\n@@ -453,16 +453,16 @@ pub mod ct {\n     #[test]\n     fn test_peek_num() {\n         let s1 = \"\";\n-        fail_unless!(peek_num(s1, 0, s1.len()).is_none());\n+        assert!(peek_num(s1, 0, s1.len()).is_none());\n \n         let s2 = \"foo\";\n-        fail_unless!(peek_num(s2, 0, s2.len()).is_none());\n+        assert!(peek_num(s2, 0, s2.len()).is_none());\n \n         let s3 = \"123\";\n-        fail_unless!(peek_num(s3, 0, s3.len()) == Some(Parsed::new(123, 3)));\n+        assert!(peek_num(s3, 0, s3.len()) == Some(Parsed::new(123, 3)));\n \n         let s4 = \"123foo\";\n-        fail_unless!(peek_num(s4, 0, s4.len()) == Some(Parsed::new(123, 3)));\n+        assert!(peek_num(s4, 0, s4.len()) == Some(Parsed::new(123, 3)));\n     }\n }\n "}, {"sha": "4d2daa6f15027479add01487bf76f05b8ed2f977", "filename": "src/libcore/unstable/finally.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Ffinally.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -58,11 +58,11 @@ fn test_success() {\n     do (|| {\n         i = 10;\n     }).finally {\n-        fail_unless!(!failing());\n-        fail_unless!(i == 10);\n+        assert!(!failing());\n+        assert!(i == 10);\n         i = 20;\n     }\n-    fail_unless!(i == 20);\n+    assert!(i == 20);\n }\n \n #[test]\n@@ -74,16 +74,16 @@ fn test_fail() {\n         i = 10;\n         fail!();\n     }).finally {\n-        fail_unless!(failing());\n-        fail_unless!(i == 10);\n+        assert!(failing());\n+        assert!(i == 10);\n     }\n }\n \n #[test]\n fn test_retval() {\n     let closure: &fn() -> int = || 10;\n     let i = do closure.finally { };\n-    fail_unless!(i == 10);\n+    assert!(i == 10);\n }\n \n #[test]"}, {"sha": "ef5970658a19235b8f9346cf018f9161b0696980", "filename": "src/libcore/unstable/global.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fglobal.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -187,7 +187,7 @@ fn get_global_state() -> Exclusive<GlobalState> {\n         let prev_i = unsafe { atomic_cxchg(&mut *global_ptr, 0, state_i) };\n \n         // Sanity check that we're not trying to reinitialize after shutdown\n-        fail_unless!(prev_i != POISON);\n+        assert!(prev_i != POISON);\n \n         if prev_i == 0 {\n             // Successfully installed the global pointer\n@@ -201,7 +201,7 @@ fn get_global_state() -> Exclusive<GlobalState> {\n                 let prev_i = unsafe {\n                     atomic_cxchg(&mut *global_ptr, state_i, POISON)\n                 };\n-                fail_unless!(prev_i == state_i);\n+                assert!(prev_i == state_i);\n \n                 // Capture the global state object in the at_exit closure\n                 // so that it is destroyed at the right time\n@@ -245,7 +245,7 @@ fn test_clone_rc() {\n                     ~shared_mutable_state(10)\n                 };\n \n-                fail_unless!(get_shared_immutable_state(&val) == &10);\n+                assert!(get_shared_immutable_state(&val) == &10);\n             }\n         }\n     }\n@@ -273,7 +273,7 @@ fn test_modify() {\n             match v {\n                 Some(sms) => {\n                     let v = get_shared_immutable_state(sms);\n-                    fail_unless!(*v == 10);\n+                    assert!(*v == 10);\n                     None\n                 },\n                 _ => fail!()"}, {"sha": "8b24c2fa6f622994d598bd944eecd39e9167564f", "filename": "src/libcore/unstable/weak_task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -42,7 +42,7 @@ pub unsafe fn weaken_task(f: &fn(Port<ShutdownMsg>)) {\n     let shutdown_port = Cell(shutdown_port);\n     let task = get_task_id();\n     // Expect the weak task service to be alive\n-    fail_unless!(service.try_send(RegisterWeakTask(task, shutdown_chan)));\n+    assert!(service.try_send(RegisterWeakTask(task, shutdown_chan)));\n     unsafe { rust_dec_kernel_live_count(); }\n     do (|| {\n         f(shutdown_port.take())\n@@ -104,7 +104,7 @@ fn run_weak_task_service(port: Port<ServiceMsg>) {\n             RegisterWeakTask(task, shutdown_chan) => {\n                 let previously_unregistered =\n                     shutdown_map.insert(task, shutdown_chan);\n-                fail_unless!(previously_unregistered);\n+                assert!(previously_unregistered);\n             }\n             UnregisterWeakTask(task) => {\n                 match shutdown_map.pop(&task) {"}, {"sha": "a08e38c021fad49b9dded8364f5315784dd2054f", "filename": "src/libcore/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -82,7 +82,7 @@ terminate normally, but instead directly return from a function.\n \n ~~~\n fn choose_weighted_item(v: &[Item]) -> Item {\n-    fail_unless!(!v.is_empty());\n+    assert!(!v.is_empty());\n     let mut so_far = 0u;\n     for v.each |item| {\n         so_far += item.weight;\n@@ -110,23 +110,23 @@ mod tests {\n     pub fn identity_crisis() {\n         // Writing a test for the identity function. How did it come to this?\n         let x = ~[(5, false)];\n-        //FIXME #3387 fail_unless!(x.eq(id(copy x)));\n+        //FIXME #3387 assert!(x.eq(id(copy x)));\n         let y = copy x;\n-        fail_unless!(x.eq(&id(y)));\n+        assert!(x.eq(&id(y)));\n     }\n     #[test]\n     pub fn test_swap() {\n         let mut x = 31337;\n         let mut y = 42;\n         swap(&mut x, &mut y);\n-        fail_unless!(x == 42);\n-        fail_unless!(y == 31337);\n+        assert!(x == 42);\n+        assert!(y == 31337);\n     }\n     #[test]\n     pub fn test_replace() {\n         let mut x = Some(NonCopyable());\n         let y = replace(&mut x, None);\n-        fail_unless!(x.is_none());\n-        fail_unless!(y.is_some());\n+        assert!(x.is_none());\n+        assert!(y.is_some());\n     }\n }"}, {"sha": "566bceaa86f3f5c6939cb23b3ae8ec05c89901b0", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 348, "deletions": 348, "changes": 696, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -267,8 +267,8 @@ pub fn last_opt<'r,T>(v: &'r [T]) -> Option<&'r T> {\n /// Return a slice that points into another slice.\n #[inline(always)]\n pub fn slice<'r,T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n-    fail_unless!(start <= end);\n-    fail_unless!(end <= len(v));\n+    assert!(start <= end);\n+    assert!(end <= len(v));\n     do as_imm_buf(v) |p, _len| {\n         unsafe {\n             ::cast::reinterpret_cast(\n@@ -282,8 +282,8 @@ pub fn slice<'r,T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n #[inline(always)]\n pub fn mut_slice<'r,T>(v: &'r mut [T], start: uint, end: uint)\n                     -> &'r mut [T] {\n-    fail_unless!(start <= end);\n-    fail_unless!(end <= v.len());\n+    assert!(start <= end);\n+    assert!(end <= v.len());\n     do as_mut_buf(v) |p, _len| {\n         unsafe {\n             ::cast::reinterpret_cast(\n@@ -297,8 +297,8 @@ pub fn mut_slice<'r,T>(v: &'r mut [T], start: uint, end: uint)\n #[inline(always)]\n pub fn const_slice<'r,T>(v: &'r const [T], start: uint, end: uint)\n                       -> &'r const [T] {\n-    fail_unless!(start <= end);\n-    fail_unless!(end <= len(v));\n+    assert!(start <= end);\n+    assert!(end <= len(v));\n     do as_const_buf(v) |p, _len| {\n         unsafe {\n             ::cast::reinterpret_cast(\n@@ -454,7 +454,7 @@ pub fn partitioned<T:Copy>(v: &[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n /// Removes the first element from a vector and return it\n pub fn shift<T>(v: &mut ~[T]) -> T {\n     unsafe {\n-        fail_unless!(!v.is_empty());\n+        assert!(!v.is_empty());\n \n         if v.len() == 1 { return v.pop() }\n \n@@ -471,7 +471,7 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n         // Save the last element. We're going to overwrite its position\n         let mut work_elt = v.pop();\n         // We still should have room to work where what last element was\n-        fail_unless!(capacity(v) >= ln);\n+        assert!(capacity(v) >= ln);\n         // Pretend like we have the original length so we can use\n         // the vector copy_memory to overwrite the hole we just made\n         raw::set_len(&mut *v, ln);\n@@ -517,7 +517,7 @@ pub fn unshift<T>(v: &mut ~[T], x: T) {\n /// elements after position i one position to the right.\n pub fn insert<T>(v: &mut ~[T], i: uint, x: T) {\n     let len = v.len();\n-    fail_unless!(i <= len);\n+    assert!(i <= len);\n \n     v.push(x);\n     let mut j = len;\n@@ -531,7 +531,7 @@ pub fn insert<T>(v: &mut ~[T], i: uint, x: T) {\n /// all elements after position i one position to the left.\n pub fn remove<T>(v: &mut ~[T], i: uint) -> T {\n     let len = v.len();\n-    fail_unless!(i < len);\n+    assert!(i < len);\n \n     let mut j = i;\n     while j < len - 1 {\n@@ -656,7 +656,7 @@ pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n /// Shorten a vector, dropping excess elements.\n pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n     do as_mut_buf(*v) |p, oldlen| {\n-        fail_unless!(newlen <= oldlen);\n+        assert!(newlen <= oldlen);\n         unsafe {\n             // This loop is optimized out for non-drop types.\n             for uint::range(newlen, oldlen) |i| {\n@@ -1160,8 +1160,8 @@ pub fn position_between<T>(v: &[T],\n                            end: uint,\n                            f: &fn(t: &T) -> bool)\n                         -> Option<uint> {\n-    fail_unless!(start <= end);\n-    fail_unless!(end <= len(v));\n+    assert!(start <= end);\n+    assert!(end <= len(v));\n     let mut i = start;\n     while i < end { if f(&v[i]) { return Some::<uint>(i); } i += 1u; }\n     None\n@@ -1193,8 +1193,8 @@ pub fn rposition<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n  */\n pub fn rposition_between<T>(v: &[T], start: uint, end: uint,\n                              f: &fn(t: &T) -> bool) -> Option<uint> {\n-    fail_unless!(start <= end);\n-    fail_unless!(end <= len(v));\n+    assert!(start <= end);\n+    assert!(end <= len(v));\n     let mut i = end;\n     while i > start {\n         if f(&v[i - 1u]) { return Some::<uint>(i - 1u); }\n@@ -1250,7 +1250,7 @@ pub fn zip_slice<T:Copy,U:Copy>(v: &const [T], u: &const [U])\n     let mut zipped = ~[];\n     let sz = len(v);\n     let mut i = 0u;\n-    fail_unless!(sz == len(u));\n+    assert!(sz == len(u));\n     while i < sz {\n         unsafe { zipped.push((v[i], u[i])); i += 1u; }\n     }\n@@ -1265,7 +1265,7 @@ pub fn zip_slice<T:Copy,U:Copy>(v: &const [T], u: &const [U])\n  */\n pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n     let mut i = len(v);\n-    fail_unless!(i == len(u));\n+    assert!(i == len(u));\n     let mut w = with_capacity(i);\n     while i > 0 {\n         unsafe { w.push((v.pop(),u.pop())); }\n@@ -1444,7 +1444,7 @@ pub fn eachi_reverse<'r,T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n  */\n #[inline]\n pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n-    fail_unless!(len(v1) == len(v2));\n+    assert!(len(v1) == len(v2));\n     for uint::range(0u, len(v1)) |i| {\n         if !f(&v1[i], &v2[i]) {\n             return;\n@@ -1488,7 +1488,7 @@ pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n \n pub fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     let mut ww = ~[];\n-    fail_unless!(1u <= nn);\n+    assert!(1u <= nn);\n     for vec::eachi (xx) |ii, _x| {\n         let len = xx.len();\n         if ii+nn <= len {\n@@ -2267,8 +2267,8 @@ pub mod raw {\n     #[inline(always)]\n     pub unsafe fn copy_memory<T>(dst: &mut [T], src: &const [T],\n                                  count: uint) {\n-        fail_unless!(dst.len() >= count);\n-        fail_unless!(src.len() >= count);\n+        assert!(dst.len() >= count);\n+        assert!(src.len() >= count);\n \n         do as_mut_buf(dst) |p_dst, _len_dst| {\n             do as_const_buf(src) |p_src, _len_src| {\n@@ -2604,65 +2604,65 @@ mod tests {\n             let a = ~[1, 2, 3];\n             let mut ptr = raw::to_ptr(a);\n             let b = from_buf(ptr, 3u);\n-            fail_unless!(b.len() == 3u);\n-            fail_unless!(b[0] == 1);\n-            fail_unless!(b[1] == 2);\n-            fail_unless!(b[2] == 3);\n+            assert!(b.len() == 3u);\n+            assert!(b[0] == 1);\n+            assert!(b[1] == 2);\n+            assert!(b[2] == 3);\n \n             // Test on-heap copy-from-buf.\n             let c = ~[1, 2, 3, 4, 5];\n             ptr = raw::to_ptr(c);\n             let d = from_buf(ptr, 5u);\n-            fail_unless!(d.len() == 5u);\n-            fail_unless!(d[0] == 1);\n-            fail_unless!(d[1] == 2);\n-            fail_unless!(d[2] == 3);\n-            fail_unless!(d[3] == 4);\n-            fail_unless!(d[4] == 5);\n+            assert!(d.len() == 5u);\n+            assert!(d[0] == 1);\n+            assert!(d[1] == 2);\n+            assert!(d[2] == 3);\n+            assert!(d[3] == 4);\n+            assert!(d[4] == 5);\n         }\n     }\n \n     #[test]\n     fn test_from_fn() {\n         // Test on-stack from_fn.\n         let mut v = from_fn(3u, square);\n-        fail_unless!(v.len() == 3u);\n-        fail_unless!(v[0] == 0u);\n-        fail_unless!(v[1] == 1u);\n-        fail_unless!(v[2] == 4u);\n+        assert!(v.len() == 3u);\n+        assert!(v[0] == 0u);\n+        assert!(v[1] == 1u);\n+        assert!(v[2] == 4u);\n \n         // Test on-heap from_fn.\n         v = from_fn(5u, square);\n-        fail_unless!(v.len() == 5u);\n-        fail_unless!(v[0] == 0u);\n-        fail_unless!(v[1] == 1u);\n-        fail_unless!(v[2] == 4u);\n-        fail_unless!(v[3] == 9u);\n-        fail_unless!(v[4] == 16u);\n+        assert!(v.len() == 5u);\n+        assert!(v[0] == 0u);\n+        assert!(v[1] == 1u);\n+        assert!(v[2] == 4u);\n+        assert!(v[3] == 9u);\n+        assert!(v[4] == 16u);\n     }\n \n     #[test]\n     fn test_from_elem() {\n         // Test on-stack from_elem.\n         let mut v = from_elem(2u, 10u);\n-        fail_unless!(v.len() == 2u);\n-        fail_unless!(v[0] == 10u);\n-        fail_unless!(v[1] == 10u);\n+        assert!(v.len() == 2u);\n+        assert!(v[0] == 10u);\n+        assert!(v[1] == 10u);\n \n         // Test on-heap from_elem.\n         v = from_elem(6u, 20u);\n-        fail_unless!(v[0] == 20u);\n-        fail_unless!(v[1] == 20u);\n-        fail_unless!(v[2] == 20u);\n-        fail_unless!(v[3] == 20u);\n-        fail_unless!(v[4] == 20u);\n-        fail_unless!(v[5] == 20u);\n+        assert!(v[0] == 20u);\n+        assert!(v[1] == 20u);\n+        assert!(v[2] == 20u);\n+        assert!(v[3] == 20u);\n+        assert!(v[4] == 20u);\n+        assert!(v[5] == 20u);\n     }\n \n     #[test]\n     fn test_is_empty() {\n-        fail_unless!(is_empty::<int>(~[]));\n-        fail_unless!(!is_empty(~[0]));\n+        assert!(is_empty::<int>(~[]));\n+        assert!(!is_empty(~[0]));\n     }\n \n     #[test]\n@@ -2671,18 +2671,18 @@ mod tests {\n         let v0 : &[Z] = &[];\n         let v1 : &[Z] = &[[]];\n         let v2 : &[Z] = &[[], []];\n-        fail_unless!(sys::size_of::<Z>() == 0);\n-        fail_unless!(v0.len() == 0);\n-        fail_unless!(v1.len() == 1);\n-        fail_unless!(v2.len() == 2);\n+        assert!(sys::size_of::<Z>() == 0);\n+        assert!(v0.len() == 0);\n+        assert!(v1.len() == 1);\n+        assert!(v2.len() == 2);\n     }\n \n     #[test]\n     fn test_head() {\n         let mut a = ~[11];\n-        fail_unless!(a.head() == &11);\n+        assert!(a.head() == &11);\n         a = ~[11, 12];\n-        fail_unless!(a.head() == &11);\n+        assert!(a.head() == &11);\n     }\n \n     #[test]\n@@ -2696,19 +2696,19 @@ mod tests {\n     #[test]\n     fn test_head_opt() {\n         let mut a = ~[];\n-        fail_unless!(a.head_opt() == None);\n+        assert!(a.head_opt() == None);\n         a = ~[11];\n-        fail_unless!(a.head_opt().unwrap() == &11);\n+        assert!(a.head_opt().unwrap() == &11);\n         a = ~[11, 12];\n-        fail_unless!(a.head_opt().unwrap() == &11);\n+        assert!(a.head_opt().unwrap() == &11);\n     }\n \n     #[test]\n     fn test_tail() {\n         let mut a = ~[11];\n-        fail_unless!(a.tail() == &[]);\n+        assert!(a.tail() == &[]);\n         a = ~[11, 12];\n-        fail_unless!(a.tail() == &[12]);\n+        assert!(a.tail() == &[12]);\n     }\n \n     #[test]\n@@ -2722,9 +2722,9 @@ mod tests {\n     #[test]\n     fn test_tailn() {\n         let mut a = ~[11, 12, 13];\n-        fail_unless!(a.tailn(0) == &[11, 12, 13]);\n+        assert!(a.tailn(0) == &[11, 12, 13]);\n         a = ~[11, 12, 13];\n-        fail_unless!(a.tailn(2) == &[13]);\n+        assert!(a.tailn(2) == &[13]);\n     }\n \n     #[test]\n@@ -2738,9 +2738,9 @@ mod tests {\n     #[test]\n     fn test_init() {\n         let mut a = ~[11];\n-        fail_unless!(a.init() == &[]);\n+        assert!(a.init() == &[]);\n         a = ~[11, 12];\n-        fail_unless!(a.init() == &[11]);\n+        assert!(a.init() == &[11]);\n     }\n \n     #[init]\n@@ -2754,9 +2754,9 @@ mod tests {\n     #[test]\n     fn test_initn() {\n         let mut a = ~[11, 12, 13];\n-        fail_unless!(a.initn(0) == &[11, 12, 13]);\n+        assert!(a.initn(0) == &[11, 12, 13]);\n         a = ~[11, 12, 13];\n-        fail_unless!(a.initn(2) == &[11]);\n+        assert!(a.initn(2) == &[11]);\n     }\n \n     #[init]\n@@ -2770,9 +2770,9 @@ mod tests {\n     #[test]\n     fn test_last() {\n         let mut a = ~[11];\n-        fail_unless!(a.last() == &11);\n+        assert!(a.last() == &11);\n         a = ~[11, 12];\n-        fail_unless!(a.last() == &12);\n+        assert!(a.last() == &12);\n     }\n \n     #[test]\n@@ -2786,75 +2786,75 @@ mod tests {\n     #[test]\n     fn test_last_opt() {\n         let mut a = ~[];\n-        fail_unless!(a.last_opt() == None);\n+        assert!(a.last_opt() == None);\n         a = ~[11];\n-        fail_unless!(a.last_opt().unwrap() == &11);\n+        assert!(a.last_opt().unwrap() == &11);\n         a = ~[11, 12];\n-        fail_unless!(a.last_opt().unwrap() == &12);\n+        assert!(a.last_opt().unwrap() == &12);\n     }\n \n     #[test]\n     fn test_slice() {\n         // Test fixed length vector.\n         let vec_fixed = [1, 2, 3, 4];\n         let v_a = slice(vec_fixed, 1u, vec_fixed.len()).to_vec();\n-        fail_unless!(v_a.len() == 3u);\n-        fail_unless!(v_a[0] == 2);\n-        fail_unless!(v_a[1] == 3);\n-        fail_unless!(v_a[2] == 4);\n+        assert!(v_a.len() == 3u);\n+        assert!(v_a[0] == 2);\n+        assert!(v_a[1] == 3);\n+        assert!(v_a[2] == 4);\n \n         // Test on stack.\n         let vec_stack = &[1, 2, 3];\n         let v_b = slice(vec_stack, 1u, 3u).to_vec();\n-        fail_unless!(v_b.len() == 2u);\n-        fail_unless!(v_b[0] == 2);\n-        fail_unless!(v_b[1] == 3);\n+        assert!(v_b.len() == 2u);\n+        assert!(v_b[0] == 2);\n+        assert!(v_b[1] == 3);\n \n         // Test on managed heap.\n         let vec_managed = @[1, 2, 3, 4, 5];\n         let v_c = slice(vec_managed, 0u, 3u).to_vec();\n-        fail_unless!(v_c.len() == 3u);\n-        fail_unless!(v_c[0] == 1);\n-        fail_unless!(v_c[1] == 2);\n-        fail_unless!(v_c[2] == 3);\n+        assert!(v_c.len() == 3u);\n+        assert!(v_c[0] == 1);\n+        assert!(v_c[1] == 2);\n+        assert!(v_c[2] == 3);\n \n         // Test on exchange heap.\n         let vec_unique = ~[1, 2, 3, 4, 5, 6];\n         let v_d = slice(vec_unique, 1u, 6u).to_vec();\n-        fail_unless!(v_d.len() == 5u);\n-        fail_unless!(v_d[0] == 2);\n-        fail_unless!(v_d[1] == 3);\n-        fail_unless!(v_d[2] == 4);\n-        fail_unless!(v_d[3] == 5);\n-        fail_unless!(v_d[4] == 6);\n+        assert!(v_d.len() == 5u);\n+        assert!(v_d[0] == 2);\n+        assert!(v_d[1] == 3);\n+        assert!(v_d[2] == 4);\n+        assert!(v_d[3] == 5);\n+        assert!(v_d[4] == 6);\n     }\n \n     #[test]\n     fn test_pop() {\n         // Test on-heap pop.\n         let mut v = ~[1, 2, 3, 4, 5];\n         let e = v.pop();\n-        fail_unless!(v.len() == 4u);\n-        fail_unless!(v[0] == 1);\n-        fail_unless!(v[1] == 2);\n-        fail_unless!(v[2] == 3);\n-        fail_unless!(v[3] == 4);\n-        fail_unless!(e == 5);\n+        assert!(v.len() == 4u);\n+        assert!(v[0] == 1);\n+        assert!(v[1] == 2);\n+        assert!(v[2] == 3);\n+        assert!(v[3] == 4);\n+        assert!(e == 5);\n     }\n \n     #[test]\n     fn test_swap_remove() {\n         let mut v = ~[1, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n-        fail_unless!(v.len() == 4);\n-        fail_unless!(e == 1);\n-        fail_unless!(v[0] == 5);\n+        assert!(v.len() == 4);\n+        assert!(e == 1);\n+        assert!(v[0] == 5);\n         e = v.swap_remove(3);\n-        fail_unless!(v.len() == 3);\n-        fail_unless!(e == 4);\n-        fail_unless!(v[0] == 5);\n-        fail_unless!(v[1] == 2);\n-        fail_unless!(v[2] == 3);\n+        assert!(v.len() == 3);\n+        assert!(e == 4);\n+        assert!(v[0] == 5);\n+        assert!(v[1] == 2);\n+        assert!(v[2] == 3);\n     }\n \n     #[test]\n@@ -2863,83 +2863,83 @@ mod tests {\n         let mut v = ~[::unstable::exclusive(()), ::unstable::exclusive(()),\n                       ::unstable::exclusive(())];\n         let mut _e = v.swap_remove(0);\n-        fail_unless!(v.len() == 2);\n+        assert!(v.len() == 2);\n         _e = v.swap_remove(1);\n-        fail_unless!(v.len() == 1);\n+        assert!(v.len() == 1);\n         _e = v.swap_remove(0);\n-        fail_unless!(v.len() == 0);\n+        assert!(v.len() == 0);\n     }\n \n     #[test]\n     fn test_push() {\n         // Test on-stack push().\n         let mut v = ~[];\n         v.push(1);\n-        fail_unless!(v.len() == 1u);\n-        fail_unless!(v[0] == 1);\n+        assert!(v.len() == 1u);\n+        assert!(v[0] == 1);\n \n         // Test on-heap push().\n         v.push(2);\n-        fail_unless!(v.len() == 2u);\n-        fail_unless!(v[0] == 1);\n-        fail_unless!(v[1] == 2);\n+        assert!(v.len() == 2u);\n+        assert!(v[0] == 1);\n+        assert!(v[1] == 2);\n     }\n \n     #[test]\n     fn test_grow() {\n         // Test on-stack grow().\n         let mut v = ~[];\n         v.grow(2u, &1);\n-        fail_unless!(v.len() == 2u);\n-        fail_unless!(v[0] == 1);\n-        fail_unless!(v[1] == 1);\n+        assert!(v.len() == 2u);\n+        assert!(v[0] == 1);\n+        assert!(v[1] == 1);\n \n         // Test on-heap grow().\n         v.grow(3u, &2);\n-        fail_unless!(v.len() == 5u);\n-        fail_unless!(v[0] == 1);\n-        fail_unless!(v[1] == 1);\n-        fail_unless!(v[2] == 2);\n-        fail_unless!(v[3] == 2);\n-        fail_unless!(v[4] == 2);\n+        assert!(v.len() == 5u);\n+        assert!(v[0] == 1);\n+        assert!(v[1] == 1);\n+        assert!(v[2] == 2);\n+        assert!(v[3] == 2);\n+        assert!(v[4] == 2);\n     }\n \n     #[test]\n     fn test_grow_fn() {\n         let mut v = ~[];\n         v.grow_fn(3u, square);\n-        fail_unless!(v.len() == 3u);\n-        fail_unless!(v[0] == 0u);\n-        fail_unless!(v[1] == 1u);\n-        fail_unless!(v[2] == 4u);\n+        assert!(v.len() == 3u);\n+        assert!(v[0] == 0u);\n+        assert!(v[1] == 1u);\n+        assert!(v[2] == 4u);\n     }\n \n     #[test]\n     fn test_grow_set() {\n         let mut v = ~[1, 2, 3];\n         v.grow_set(4u, &4, 5);\n-        fail_unless!(v.len() == 5u);\n-        fail_unless!(v[0] == 1);\n-        fail_unless!(v[1] == 2);\n-        fail_unless!(v[2] == 3);\n-        fail_unless!(v[3] == 4);\n-        fail_unless!(v[4] == 5);\n+        assert!(v.len() == 5u);\n+        assert!(v[0] == 1);\n+        assert!(v[1] == 2);\n+        assert!(v[2] == 3);\n+        assert!(v[3] == 4);\n+        assert!(v[4] == 5);\n     }\n \n     #[test]\n     fn test_truncate() {\n         let mut v = ~[@6,@5,@4];\n         v.truncate(1);\n-        fail_unless!(v.len() == 1);\n-        fail_unless!(*(v[0]) == 6);\n+        assert!(v.len() == 1);\n+        assert!(*(v[0]) == 6);\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut v = ~[@6,@5,@4];\n         v.clear();\n-        fail_unless!(v.len() == 0);\n+        assert!(v.len() == 0);\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n@@ -2948,7 +2948,7 @@ mod tests {\n         fn case(a: ~[uint], b: ~[uint]) {\n             let mut v = a;\n             v.dedup();\n-            fail_unless!(v == b);\n+            assert!(v == b);\n         }\n         case(~[], ~[]);\n         case(~[1], ~[1]);\n@@ -2993,20 +2993,20 @@ mod tests {\n         // Test on-stack map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = map(v, square_ref);\n-        fail_unless!(w.len() == 3u);\n-        fail_unless!(w[0] == 1u);\n-        fail_unless!(w[1] == 4u);\n-        fail_unless!(w[2] == 9u);\n+        assert!(w.len() == 3u);\n+        assert!(w[0] == 1u);\n+        assert!(w[1] == 4u);\n+        assert!(w[2] == 9u);\n \n         // Test on-heap map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = map(v, square_ref);\n-        fail_unless!(w.len() == 5u);\n-        fail_unless!(w[0] == 1u);\n-        fail_unless!(w[1] == 4u);\n-        fail_unless!(w[2] == 9u);\n-        fail_unless!(w[3] == 16u);\n-        fail_unless!(w[4] == 25u);\n+        assert!(w.len() == 5u);\n+        assert!(w[0] == 1u);\n+        assert!(w[1] == 4u);\n+        assert!(w[2] == 9u);\n+        assert!(w[3] == 16u);\n+        assert!(w[4] == 25u);\n     }\n \n     #[test]\n@@ -3017,25 +3017,25 @@ mod tests {\n         let v1 = ~[5, 4, 3, 2, 1];\n         let u = map2::<int, int, int>(v0, v1, f);\n         let mut i = 0;\n-        while i < 5 { fail_unless!(v0[i] * v1[i] == u[i]); i += 1; }\n+        while i < 5 { assert!(v0[i] * v1[i] == u[i]); i += 1; }\n     }\n \n     #[test]\n     fn test_filter_mapped() {\n         // Test on-stack filter-map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = filter_mapped(v, square_if_odd_r);\n-        fail_unless!(w.len() == 2u);\n-        fail_unless!(w[0] == 1u);\n-        fail_unless!(w[1] == 9u);\n+        assert!(w.len() == 2u);\n+        assert!(w[0] == 1u);\n+        assert!(w[1] == 9u);\n \n         // Test on-heap filter-map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = filter_mapped(v, square_if_odd_r);\n-        fail_unless!(w.len() == 3u);\n-        fail_unless!(w[0] == 1u);\n-        fail_unless!(w[1] == 9u);\n-        fail_unless!(w[2] == 25u);\n+        assert!(w.len() == 3u);\n+        assert!(w[0] == 1u);\n+        assert!(w[1] == 9u);\n+        assert!(w[2] == 25u);\n \n         fn halve(i: &int) -> Option<int> {\n             if *i % 2 == 0 {\n@@ -3050,29 +3050,29 @@ mod tests {\n         let all_odd2: ~[int] = ~[];\n         let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n-        fail_unless!(filter_mapped(all_even, halve) ==\n+        assert!(filter_mapped(all_even, halve) ==\n                      map(all_even, halve_for_sure));\n-        fail_unless!(filter_mapped(all_odd1, halve) == ~[]);\n-        fail_unless!(filter_mapped(all_odd2, halve) == ~[]);\n-        fail_unless!(filter_mapped(mix, halve) == mix_dest);\n+        assert!(filter_mapped(all_odd1, halve) == ~[]);\n+        assert!(filter_mapped(all_odd2, halve) == ~[]);\n+        assert!(filter_mapped(mix, halve) == mix_dest);\n     }\n \n     #[test]\n     fn test_filter_map() {\n         // Test on-stack filter-map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = filter_map(v, square_if_odd_v);\n-        fail_unless!(w.len() == 2u);\n-        fail_unless!(w[0] == 1u);\n-        fail_unless!(w[1] == 9u);\n+        assert!(w.len() == 2u);\n+        assert!(w[0] == 1u);\n+        assert!(w[1] == 9u);\n \n         // Test on-heap filter-map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = filter_map(v, square_if_odd_v);\n-        fail_unless!(w.len() == 3u);\n-        fail_unless!(w[0] == 1u);\n-        fail_unless!(w[1] == 9u);\n-        fail_unless!(w[2] == 25u);\n+        assert!(w.len() == 3u);\n+        assert!(w[0] == 1u);\n+        assert!(w[1] == 9u);\n+        assert!(w[2] == 25u);\n \n         fn halve(i: int) -> Option<int> {\n             if i % 2 == 0 {\n@@ -3088,37 +3088,37 @@ mod tests {\n         let all_odd2: ~[int] = ~[];\n         let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n-        fail_unless!(filter_map(all_even, halve) ==\n+        assert!(filter_map(all_even, halve) ==\n                      map(all_even0, halve_for_sure));\n-        fail_unless!(filter_map(all_odd1, halve) == ~[]);\n-        fail_unless!(filter_map(all_odd2, halve) == ~[]);\n-        fail_unless!(filter_map(mix, halve) == mix_dest);\n+        assert!(filter_map(all_odd1, halve) == ~[]);\n+        assert!(filter_map(all_odd2, halve) == ~[]);\n+        assert!(filter_map(mix, halve) == mix_dest);\n     }\n \n     #[test]\n     fn test_filter() {\n-        fail_unless!(filter(~[1u, 2u, 3u], is_odd) == ~[1u, 3u]);\n-        fail_unless!(filter(~[1u, 2u, 4u, 8u, 16u], is_three) == ~[]);\n+        assert!(filter(~[1u, 2u, 3u], is_odd) == ~[1u, 3u]);\n+        assert!(filter(~[1u, 2u, 4u, 8u, 16u], is_three) == ~[]);\n     }\n \n     #[test]\n     fn test_retain() {\n         let mut v = ~[1, 2, 3, 4, 5];\n         v.retain(is_odd);\n-        fail_unless!(v == ~[1, 3, 5]);\n+        assert!(v == ~[1, 3, 5]);\n     }\n \n     #[test]\n     fn test_foldl() {\n         // Test on-stack fold.\n         let mut v = ~[1u, 2u, 3u];\n         let mut sum = foldl(0u, v, add);\n-        fail_unless!(sum == 6u);\n+        assert!(sum == 6u);\n \n         // Test on-heap fold.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         sum = foldl(0u, v, add);\n-        fail_unless!(sum == 15u);\n+        assert!(sum == 15u);\n     }\n \n     #[test]\n@@ -3128,7 +3128,7 @@ mod tests {\n         }\n         let mut v = ~[1, 2, 3, 4];\n         let sum = foldl(0, v, sub);\n-        fail_unless!(sum == -10);\n+        assert!(sum == -10);\n     }\n \n     #[test]\n@@ -3138,7 +3138,7 @@ mod tests {\n         }\n         let mut v = ~[1, 2, 3, 4];\n         let sum = foldr(v, 0, sub);\n-        fail_unless!(sum == -2);\n+        assert!(sum == -2);\n     }\n \n     #[test]\n@@ -3154,18 +3154,18 @@ mod tests {\n         for each(~[1, 2, 3]) |v| {\n             i += *v;\n         }\n-        fail_unless!(i == 6);\n+        assert!(i == 6);\n     }\n \n     #[test]\n     fn test_iteri() {\n         let mut i = 0;\n         for eachi(~[1, 2, 3]) |j, v| {\n-            if i == 0 { fail_unless!(*v == 1); }\n-            fail_unless!(j + 1u == *v as uint);\n+            if i == 0 { assert!(*v == 1); }\n+            assert!(j + 1u == *v as uint);\n             i += *v;\n         }\n-        fail_unless!(i == 6);\n+        assert!(i == 6);\n     }\n \n     #[test]\n@@ -3180,21 +3180,21 @@ mod tests {\n     fn test_each_reverse_nonempty() {\n         let mut i = 0;\n         for each_reverse(~[1, 2, 3]) |v| {\n-            if i == 0 { fail_unless!(*v == 3); }\n+            if i == 0 { assert!(*v == 3); }\n             i += *v\n         }\n-        fail_unless!(i == 6);\n+        assert!(i == 6);\n     }\n \n     #[test]\n     fn test_eachi_reverse() {\n         let mut i = 0;\n         for eachi_reverse(~[0, 1, 2]) |j, v| {\n-            if i == 0 { fail_unless!(*v == 2); }\n-            fail_unless!(j == *v as uint);\n+            if i == 0 { assert!(*v == 2); }\n+            assert!(j == *v as uint);\n             i += *v;\n         }\n-        fail_unless!(i == 3);\n+        assert!(i == 3);\n     }\n \n     #[test]\n@@ -3211,47 +3211,47 @@ mod tests {\n \n         results = ~[];\n         for each_permutation(~[]) |v| { results.push(from_slice(v)); }\n-        fail_unless!(results == ~[~[]]);\n+        assert!(results == ~[~[]]);\n \n         results = ~[];\n         for each_permutation(~[7]) |v| { results.push(from_slice(v)); }\n-        fail_unless!(results == ~[~[7]]);\n+        assert!(results == ~[~[7]]);\n \n         results = ~[];\n         for each_permutation(~[1,1]) |v| { results.push(from_slice(v)); }\n-        fail_unless!(results == ~[~[1,1],~[1,1]]);\n+        assert!(results == ~[~[1,1],~[1,1]]);\n \n         results = ~[];\n         for each_permutation(~[5,2,0]) |v| { results.push(from_slice(v)); }\n-        fail_unless!(results ==\n+        assert!(results ==\n             ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]]);\n     }\n \n     #[test]\n     fn test_any_and_all() {\n-        fail_unless!(any(~[1u, 2u, 3u], is_three));\n-        fail_unless!(!any(~[0u, 1u, 2u], is_three));\n-        fail_unless!(any(~[1u, 2u, 3u, 4u, 5u], is_three));\n-        fail_unless!(!any(~[1u, 2u, 4u, 5u, 6u], is_three));\n+        assert!(any(~[1u, 2u, 3u], is_three));\n+        assert!(!any(~[0u, 1u, 2u], is_three));\n+        assert!(any(~[1u, 2u, 3u, 4u, 5u], is_three));\n+        assert!(!any(~[1u, 2u, 4u, 5u, 6u], is_three));\n \n-        fail_unless!(all(~[3u, 3u, 3u], is_three));\n-        fail_unless!(!all(~[3u, 3u, 2u], is_three));\n-        fail_unless!(all(~[3u, 3u, 3u, 3u, 3u], is_three));\n-        fail_unless!(!all(~[3u, 3u, 0u, 1u, 2u], is_three));\n+        assert!(all(~[3u, 3u, 3u], is_three));\n+        assert!(!all(~[3u, 3u, 2u], is_three));\n+        assert!(all(~[3u, 3u, 3u, 3u, 3u], is_three));\n+        assert!(!all(~[3u, 3u, 0u, 1u, 2u], is_three));\n     }\n \n     #[test]\n     fn test_any2_and_all2() {\n \n-        fail_unless!(any2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal));\n-        fail_unless!(any2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal));\n-        fail_unless!(!any2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal));\n-        fail_unless!(any2(~[2u, 4u, 6u], ~[2u, 4u], is_equal));\n+        assert!(any2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal));\n+        assert!(any2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal));\n+        assert!(!any2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal));\n+        assert!(any2(~[2u, 4u, 6u], ~[2u, 4u], is_equal));\n \n-        fail_unless!(all2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal));\n-        fail_unless!(!all2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal));\n-        fail_unless!(!all2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal));\n-        fail_unless!(!all2(~[2u, 4u, 6u], ~[2u, 4u], is_equal));\n+        assert!(all2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal));\n+        assert!(!all2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal));\n+        assert!(!all2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal));\n+        assert!(!all2(~[2u, 4u, 6u], ~[2u, 4u], is_equal));\n     }\n \n     #[test]\n@@ -3261,305 +3261,305 @@ mod tests {\n \n         let z1 = zip(v1, v2);\n \n-        fail_unless!((1, 4) == z1[0]);\n-        fail_unless!((2, 5) == z1[1]);\n-        fail_unless!((3, 6) == z1[2]);\n+        assert!((1, 4) == z1[0]);\n+        assert!((2, 5) == z1[1]);\n+        assert!((3, 6) == z1[2]);\n \n         let (left, right) = unzip(z1);\n \n-        fail_unless!((1, 4) == (left[0], right[0]));\n-        fail_unless!((2, 5) == (left[1], right[1]));\n-        fail_unless!((3, 6) == (left[2], right[2]));\n+        assert!((1, 4) == (left[0], right[0]));\n+        assert!((2, 5) == (left[1], right[1]));\n+        assert!((3, 6) == (left[2], right[2]));\n     }\n \n     #[test]\n     fn test_position_elem() {\n-        fail_unless!(position_elem(~[], &1).is_none());\n+        assert!(position_elem(~[], &1).is_none());\n \n         let v1 = ~[1, 2, 3, 3, 2, 5];\n-        fail_unless!(position_elem(v1, &1) == Some(0u));\n-        fail_unless!(position_elem(v1, &2) == Some(1u));\n-        fail_unless!(position_elem(v1, &5) == Some(5u));\n-        fail_unless!(position_elem(v1, &4).is_none());\n+        assert!(position_elem(v1, &1) == Some(0u));\n+        assert!(position_elem(v1, &2) == Some(1u));\n+        assert!(position_elem(v1, &5) == Some(5u));\n+        assert!(position_elem(v1, &4).is_none());\n     }\n \n     #[test]\n     fn test_position() {\n         fn less_than_three(i: &int) -> bool { *i < 3 }\n         fn is_eighteen(i: &int) -> bool { *i == 18 }\n \n-        fail_unless!(position(~[], less_than_three).is_none());\n+        assert!(position(~[], less_than_three).is_none());\n \n         let v1 = ~[5, 4, 3, 2, 1];\n-        fail_unless!(position(v1, less_than_three) == Some(3u));\n-        fail_unless!(position(v1, is_eighteen).is_none());\n+        assert!(position(v1, less_than_three) == Some(3u));\n+        assert!(position(v1, is_eighteen).is_none());\n     }\n \n     #[test]\n     fn test_position_between() {\n-        fail_unless!(position_between(~[], 0u, 0u, f).is_none());\n+        assert!(position_between(~[], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        fail_unless!(position_between(v, 0u, 0u, f).is_none());\n-        fail_unless!(position_between(v, 0u, 1u, f).is_none());\n-        fail_unless!(position_between(v, 0u, 2u, f) == Some(1u));\n-        fail_unless!(position_between(v, 0u, 3u, f) == Some(1u));\n-        fail_unless!(position_between(v, 0u, 4u, f) == Some(1u));\n+        assert!(position_between(v, 0u, 0u, f).is_none());\n+        assert!(position_between(v, 0u, 1u, f).is_none());\n+        assert!(position_between(v, 0u, 2u, f) == Some(1u));\n+        assert!(position_between(v, 0u, 3u, f) == Some(1u));\n+        assert!(position_between(v, 0u, 4u, f) == Some(1u));\n \n-        fail_unless!(position_between(v, 1u, 1u, f).is_none());\n-        fail_unless!(position_between(v, 1u, 2u, f) == Some(1u));\n-        fail_unless!(position_between(v, 1u, 3u, f) == Some(1u));\n-        fail_unless!(position_between(v, 1u, 4u, f) == Some(1u));\n+        assert!(position_between(v, 1u, 1u, f).is_none());\n+        assert!(position_between(v, 1u, 2u, f) == Some(1u));\n+        assert!(position_between(v, 1u, 3u, f) == Some(1u));\n+        assert!(position_between(v, 1u, 4u, f) == Some(1u));\n \n-        fail_unless!(position_between(v, 2u, 2u, f).is_none());\n-        fail_unless!(position_between(v, 2u, 3u, f).is_none());\n-        fail_unless!(position_between(v, 2u, 4u, f) == Some(3u));\n+        assert!(position_between(v, 2u, 2u, f).is_none());\n+        assert!(position_between(v, 2u, 3u, f).is_none());\n+        assert!(position_between(v, 2u, 4u, f) == Some(3u));\n \n-        fail_unless!(position_between(v, 3u, 3u, f).is_none());\n-        fail_unless!(position_between(v, 3u, 4u, f) == Some(3u));\n+        assert!(position_between(v, 3u, 3u, f).is_none());\n+        assert!(position_between(v, 3u, 4u, f) == Some(3u));\n \n-        fail_unless!(position_between(v, 4u, 4u, f).is_none());\n+        assert!(position_between(v, 4u, 4u, f).is_none());\n     }\n \n     #[test]\n     fn test_find() {\n-        fail_unless!(find(~[], f).is_none());\n+        assert!(find(~[], f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        fail_unless!(find(v, f) == Some((1, 'b')));\n-        fail_unless!(find(v, g).is_none());\n+        assert!(find(v, f) == Some((1, 'b')));\n+        assert!(find(v, g).is_none());\n     }\n \n     #[test]\n     fn test_find_between() {\n-        fail_unless!(find_between(~[], 0u, 0u, f).is_none());\n+        assert!(find_between(~[], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        fail_unless!(find_between(v, 0u, 0u, f).is_none());\n-        fail_unless!(find_between(v, 0u, 1u, f).is_none());\n-        fail_unless!(find_between(v, 0u, 2u, f) == Some((1, 'b')));\n-        fail_unless!(find_between(v, 0u, 3u, f) == Some((1, 'b')));\n-        fail_unless!(find_between(v, 0u, 4u, f) == Some((1, 'b')));\n+        assert!(find_between(v, 0u, 0u, f).is_none());\n+        assert!(find_between(v, 0u, 1u, f).is_none());\n+        assert!(find_between(v, 0u, 2u, f) == Some((1, 'b')));\n+        assert!(find_between(v, 0u, 3u, f) == Some((1, 'b')));\n+        assert!(find_between(v, 0u, 4u, f) == Some((1, 'b')));\n \n-        fail_unless!(find_between(v, 1u, 1u, f).is_none());\n-        fail_unless!(find_between(v, 1u, 2u, f) == Some((1, 'b')));\n-        fail_unless!(find_between(v, 1u, 3u, f) == Some((1, 'b')));\n-        fail_unless!(find_between(v, 1u, 4u, f) == Some((1, 'b')));\n+        assert!(find_between(v, 1u, 1u, f).is_none());\n+        assert!(find_between(v, 1u, 2u, f) == Some((1, 'b')));\n+        assert!(find_between(v, 1u, 3u, f) == Some((1, 'b')));\n+        assert!(find_between(v, 1u, 4u, f) == Some((1, 'b')));\n \n-        fail_unless!(find_between(v, 2u, 2u, f).is_none());\n-        fail_unless!(find_between(v, 2u, 3u, f).is_none());\n-        fail_unless!(find_between(v, 2u, 4u, f) == Some((3, 'b')));\n+        assert!(find_between(v, 2u, 2u, f).is_none());\n+        assert!(find_between(v, 2u, 3u, f).is_none());\n+        assert!(find_between(v, 2u, 4u, f) == Some((3, 'b')));\n \n-        fail_unless!(find_between(v, 3u, 3u, f).is_none());\n-        fail_unless!(find_between(v, 3u, 4u, f) == Some((3, 'b')));\n+        assert!(find_between(v, 3u, 3u, f).is_none());\n+        assert!(find_between(v, 3u, 4u, f) == Some((3, 'b')));\n \n-        fail_unless!(find_between(v, 4u, 4u, f).is_none());\n+        assert!(find_between(v, 4u, 4u, f).is_none());\n     }\n \n     #[test]\n     fn test_rposition() {\n-        fail_unless!(find(~[], f).is_none());\n+        assert!(find(~[], f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        fail_unless!(position(v, f) == Some(1u));\n-        fail_unless!(position(v, g).is_none());\n+        assert!(position(v, f) == Some(1u));\n+        assert!(position(v, g).is_none());\n     }\n \n     #[test]\n     fn test_rposition_between() {\n-        fail_unless!(rposition_between(~[], 0u, 0u, f).is_none());\n+        assert!(rposition_between(~[], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        fail_unless!(rposition_between(v, 0u, 0u, f).is_none());\n-        fail_unless!(rposition_between(v, 0u, 1u, f).is_none());\n-        fail_unless!(rposition_between(v, 0u, 2u, f) == Some(1u));\n-        fail_unless!(rposition_between(v, 0u, 3u, f) == Some(1u));\n-        fail_unless!(rposition_between(v, 0u, 4u, f) == Some(3u));\n+        assert!(rposition_between(v, 0u, 0u, f).is_none());\n+        assert!(rposition_between(v, 0u, 1u, f).is_none());\n+        assert!(rposition_between(v, 0u, 2u, f) == Some(1u));\n+        assert!(rposition_between(v, 0u, 3u, f) == Some(1u));\n+        assert!(rposition_between(v, 0u, 4u, f) == Some(3u));\n \n-        fail_unless!(rposition_between(v, 1u, 1u, f).is_none());\n-        fail_unless!(rposition_between(v, 1u, 2u, f) == Some(1u));\n-        fail_unless!(rposition_between(v, 1u, 3u, f) == Some(1u));\n-        fail_unless!(rposition_between(v, 1u, 4u, f) == Some(3u));\n+        assert!(rposition_between(v, 1u, 1u, f).is_none());\n+        assert!(rposition_between(v, 1u, 2u, f) == Some(1u));\n+        assert!(rposition_between(v, 1u, 3u, f) == Some(1u));\n+        assert!(rposition_between(v, 1u, 4u, f) == Some(3u));\n \n-        fail_unless!(rposition_between(v, 2u, 2u, f).is_none());\n-        fail_unless!(rposition_between(v, 2u, 3u, f).is_none());\n-        fail_unless!(rposition_between(v, 2u, 4u, f) == Some(3u));\n+        assert!(rposition_between(v, 2u, 2u, f).is_none());\n+        assert!(rposition_between(v, 2u, 3u, f).is_none());\n+        assert!(rposition_between(v, 2u, 4u, f) == Some(3u));\n \n-        fail_unless!(rposition_between(v, 3u, 3u, f).is_none());\n-        fail_unless!(rposition_between(v, 3u, 4u, f) == Some(3u));\n+        assert!(rposition_between(v, 3u, 3u, f).is_none());\n+        assert!(rposition_between(v, 3u, 4u, f) == Some(3u));\n \n-        fail_unless!(rposition_between(v, 4u, 4u, f).is_none());\n+        assert!(rposition_between(v, 4u, 4u, f).is_none());\n     }\n \n     #[test]\n     fn test_rfind() {\n-        fail_unless!(rfind(~[], f).is_none());\n+        assert!(rfind(~[], f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        fail_unless!(rfind(v, f) == Some((3, 'b')));\n-        fail_unless!(rfind(v, g).is_none());\n+        assert!(rfind(v, f) == Some((3, 'b')));\n+        assert!(rfind(v, g).is_none());\n     }\n \n     #[test]\n     fn test_rfind_between() {\n-        fail_unless!(rfind_between(~[], 0u, 0u, f).is_none());\n+        assert!(rfind_between(~[], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        fail_unless!(rfind_between(v, 0u, 0u, f).is_none());\n-        fail_unless!(rfind_between(v, 0u, 1u, f).is_none());\n-        fail_unless!(rfind_between(v, 0u, 2u, f) == Some((1, 'b')));\n-        fail_unless!(rfind_between(v, 0u, 3u, f) == Some((1, 'b')));\n-        fail_unless!(rfind_between(v, 0u, 4u, f) == Some((3, 'b')));\n+        assert!(rfind_between(v, 0u, 0u, f).is_none());\n+        assert!(rfind_between(v, 0u, 1u, f).is_none());\n+        assert!(rfind_between(v, 0u, 2u, f) == Some((1, 'b')));\n+        assert!(rfind_between(v, 0u, 3u, f) == Some((1, 'b')));\n+        assert!(rfind_between(v, 0u, 4u, f) == Some((3, 'b')));\n \n-        fail_unless!(rfind_between(v, 1u, 1u, f).is_none());\n-        fail_unless!(rfind_between(v, 1u, 2u, f) == Some((1, 'b')));\n-        fail_unless!(rfind_between(v, 1u, 3u, f) == Some((1, 'b')));\n-        fail_unless!(rfind_between(v, 1u, 4u, f) == Some((3, 'b')));\n+        assert!(rfind_between(v, 1u, 1u, f).is_none());\n+        assert!(rfind_between(v, 1u, 2u, f) == Some((1, 'b')));\n+        assert!(rfind_between(v, 1u, 3u, f) == Some((1, 'b')));\n+        assert!(rfind_between(v, 1u, 4u, f) == Some((3, 'b')));\n \n-        fail_unless!(rfind_between(v, 2u, 2u, f).is_none());\n-        fail_unless!(rfind_between(v, 2u, 3u, f).is_none());\n-        fail_unless!(rfind_between(v, 2u, 4u, f) == Some((3, 'b')));\n+        assert!(rfind_between(v, 2u, 2u, f).is_none());\n+        assert!(rfind_between(v, 2u, 3u, f).is_none());\n+        assert!(rfind_between(v, 2u, 4u, f) == Some((3, 'b')));\n \n-        fail_unless!(rfind_between(v, 3u, 3u, f).is_none());\n-        fail_unless!(rfind_between(v, 3u, 4u, f) == Some((3, 'b')));\n+        assert!(rfind_between(v, 3u, 3u, f).is_none());\n+        assert!(rfind_between(v, 3u, 4u, f) == Some((3, 'b')));\n \n-        fail_unless!(rfind_between(v, 4u, 4u, f).is_none());\n+        assert!(rfind_between(v, 4u, 4u, f).is_none());\n     }\n \n     #[test]\n     fn reverse_and_reversed() {\n         let mut v: ~[int] = ~[10, 20];\n-        fail_unless!(v[0] == 10);\n-        fail_unless!(v[1] == 20);\n+        assert!(v[0] == 10);\n+        assert!(v[1] == 20);\n         reverse(v);\n-        fail_unless!(v[0] == 20);\n-        fail_unless!(v[1] == 10);\n+        assert!(v[0] == 20);\n+        assert!(v[1] == 10);\n         let v2 = reversed::<int>(~[10, 20]);\n-        fail_unless!(v2[0] == 20);\n-        fail_unless!(v2[1] == 10);\n+        assert!(v2[0] == 20);\n+        assert!(v2[1] == 10);\n         v[0] = 30;\n-        fail_unless!(v2[0] == 20);\n+        assert!(v2[0] == 20);\n         // Make sure they work with 0-length vectors too.\n \n         let v4 = reversed::<int>(~[]);\n-        fail_unless!(v4 == ~[]);\n+        assert!(v4 == ~[]);\n         let mut v3: ~[int] = ~[];\n         reverse::<int>(v3);\n     }\n \n     #[test]\n     fn reversed_mut() {\n         let mut v2 = reversed::<int>(~[10, 20]);\n-        fail_unless!(v2[0] == 20);\n-        fail_unless!(v2[1] == 10);\n+        assert!(v2[0] == 20);\n+        assert!(v2[1] == 10);\n     }\n \n     #[test]\n     fn test_split() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        fail_unless!(split(~[], f) == ~[]);\n-        fail_unless!(split(~[1, 2], f) == ~[~[1, 2]]);\n-        fail_unless!(split(~[3, 1, 2], f) == ~[~[], ~[1, 2]]);\n-        fail_unless!(split(~[1, 2, 3], f) == ~[~[1, 2], ~[]]);\n-        fail_unless!(split(~[1, 2, 3, 4, 3, 5], f) == ~[~[1, 2], ~[4], ~[5]]);\n+        assert!(split(~[], f) == ~[]);\n+        assert!(split(~[1, 2], f) == ~[~[1, 2]]);\n+        assert!(split(~[3, 1, 2], f) == ~[~[], ~[1, 2]]);\n+        assert!(split(~[1, 2, 3], f) == ~[~[1, 2], ~[]]);\n+        assert!(split(~[1, 2, 3, 4, 3, 5], f) == ~[~[1, 2], ~[4], ~[5]]);\n     }\n \n     #[test]\n     fn test_splitn() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        fail_unless!(splitn(~[], 1u, f) == ~[]);\n-        fail_unless!(splitn(~[1, 2], 1u, f) == ~[~[1, 2]]);\n-        fail_unless!(splitn(~[3, 1, 2], 1u, f) == ~[~[], ~[1, 2]]);\n-        fail_unless!(splitn(~[1, 2, 3], 1u, f) == ~[~[1, 2], ~[]]);\n-        fail_unless!(splitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n+        assert!(splitn(~[], 1u, f) == ~[]);\n+        assert!(splitn(~[1, 2], 1u, f) == ~[~[1, 2]]);\n+        assert!(splitn(~[3, 1, 2], 1u, f) == ~[~[], ~[1, 2]]);\n+        assert!(splitn(~[1, 2, 3], 1u, f) == ~[~[1, 2], ~[]]);\n+        assert!(splitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n                       ~[~[1, 2], ~[4, 3, 5]]);\n     }\n \n     #[test]\n     fn test_rsplit() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        fail_unless!(rsplit(~[], f) == ~[]);\n-        fail_unless!(rsplit(~[1, 2], f) == ~[~[1, 2]]);\n-        fail_unless!(rsplit(~[1, 2, 3], f) == ~[~[1, 2], ~[]]);\n-        fail_unless!(rsplit(~[1, 2, 3, 4, 3, 5], f) ==\n+        assert!(rsplit(~[], f) == ~[]);\n+        assert!(rsplit(~[1, 2], f) == ~[~[1, 2]]);\n+        assert!(rsplit(~[1, 2, 3], f) == ~[~[1, 2], ~[]]);\n+        assert!(rsplit(~[1, 2, 3, 4, 3, 5], f) ==\n             ~[~[1, 2], ~[4], ~[5]]);\n     }\n \n     #[test]\n     fn test_rsplitn() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        fail_unless!(rsplitn(~[], 1u, f) == ~[]);\n-        fail_unless!(rsplitn(~[1, 2], 1u, f) == ~[~[1, 2]]);\n-        fail_unless!(rsplitn(~[1, 2, 3], 1u, f) == ~[~[1, 2], ~[]]);\n-        fail_unless!(rsplitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n+        assert!(rsplitn(~[], 1u, f) == ~[]);\n+        assert!(rsplitn(~[1, 2], 1u, f) == ~[~[1, 2]]);\n+        assert!(rsplitn(~[1, 2, 3], 1u, f) == ~[~[1, 2], ~[]]);\n+        assert!(rsplitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n                        ~[~[1, 2, 3, 4], ~[5]]);\n     }\n \n     #[test]\n     fn test_partition() {\n         // FIXME (#4355 maybe): using v.partition here crashes\n-        fail_unless!(partition(~[], |x: &int| *x < 3) == (~[], ~[]));\n-        fail_unless!(partition(~[1, 2, 3], |x: &int| *x < 4) ==\n+        assert!(partition(~[], |x: &int| *x < 3) == (~[], ~[]));\n+        assert!(partition(~[1, 2, 3], |x: &int| *x < 4) ==\n             (~[1, 2, 3], ~[]));\n-        fail_unless!(partition(~[1, 2, 3], |x: &int| *x < 2) ==\n+        assert!(partition(~[1, 2, 3], |x: &int| *x < 2) ==\n             (~[1], ~[2, 3]));\n-        fail_unless!(partition(~[1, 2, 3], |x: &int| *x < 0) ==\n+        assert!(partition(~[1, 2, 3], |x: &int| *x < 0) ==\n             (~[], ~[1, 2, 3]));\n     }\n \n     #[test]\n     fn test_partitioned() {\n-        fail_unless!((~[]).partitioned(|x: &int| *x < 3) == (~[], ~[]));\n-        fail_unless!((~[1, 2, 3]).partitioned(|x: &int| *x < 4) ==\n+        assert!((~[]).partitioned(|x: &int| *x < 3) == (~[], ~[]));\n+        assert!((~[1, 2, 3]).partitioned(|x: &int| *x < 4) ==\n                      (~[1, 2, 3], ~[]));\n-        fail_unless!((~[1, 2, 3]).partitioned(|x: &int| *x < 2) ==\n+        assert!((~[1, 2, 3]).partitioned(|x: &int| *x < 2) ==\n                      (~[1], ~[2, 3]));\n-        fail_unless!((~[1, 2, 3]).partitioned(|x: &int| *x < 0) ==\n+        assert!((~[1, 2, 3]).partitioned(|x: &int| *x < 0) ==\n                      (~[], ~[1, 2, 3]));\n     }\n \n     #[test]\n     fn test_concat() {\n-        fail_unless!(concat(~[~[1], ~[2,3]]) == ~[1, 2, 3]);\n+        assert!(concat(~[~[1], ~[2,3]]) == ~[1, 2, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n-        fail_unless!(connect(~[], &0) == ~[]);\n-        fail_unless!(connect(~[~[1], ~[2, 3]], &0) == ~[1, 0, 2, 3]);\n-        fail_unless!(connect(~[~[1], ~[2], ~[3]], &0) == ~[1, 0, 2, 0, 3]);\n+        assert!(connect(~[], &0) == ~[]);\n+        assert!(connect(~[~[1], ~[2, 3]], &0) == ~[1, 0, 2, 3]);\n+        assert!(connect(~[~[1], ~[2], ~[3]], &0) == ~[1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n     fn test_windowed () {\n-        fail_unless!(~[~[1u,2u,3u],~[2u,3u,4u],~[3u,4u,5u],~[4u,5u,6u]]\n+        assert!(~[~[1u,2u,3u],~[2u,3u,4u],~[3u,4u,5u],~[4u,5u,6u]]\n                      == windowed (3u, ~[1u,2u,3u,4u,5u,6u]));\n \n-        fail_unless!(~[~[1u,2u,3u,4u],~[2u,3u,4u,5u],~[3u,4u,5u,6u]]\n+        assert!(~[~[1u,2u,3u,4u],~[2u,3u,4u,5u],~[3u,4u,5u,6u]]\n                      == windowed (4u, ~[1u,2u,3u,4u,5u,6u]));\n \n-        fail_unless!(~[] == windowed (7u, ~[1u,2u,3u,4u,5u,6u]));\n+        assert!(~[] == windowed (7u, ~[1u,2u,3u,4u,5u,6u]));\n     }\n \n     #[test]\n@@ -3573,26 +3573,26 @@ mod tests {\n     fn test_unshift() {\n         let mut x = ~[1, 2, 3];\n         x.unshift(0);\n-        fail_unless!(x == ~[0, 1, 2, 3]);\n+        assert!(x == ~[0, 1, 2, 3]);\n     }\n \n     #[test]\n     fn test_insert() {\n         let mut a = ~[1, 2, 4];\n         a.insert(2, 3);\n-        fail_unless!(a == ~[1, 2, 3, 4]);\n+        assert!(a == ~[1, 2, 3, 4]);\n \n         let mut a = ~[1, 2, 3];\n         a.insert(0, 0);\n-        fail_unless!(a == ~[0, 1, 2, 3]);\n+        assert!(a == ~[0, 1, 2, 3]);\n \n         let mut a = ~[1, 2, 3];\n         a.insert(3, 4);\n-        fail_unless!(a == ~[1, 2, 3, 4]);\n+        assert!(a == ~[1, 2, 3, 4]);\n \n         let mut a = ~[];\n         a.insert(0, 1);\n-        fail_unless!(a == ~[1]);\n+        assert!(a == ~[1]);\n     }\n \n     #[test]\n@@ -3607,15 +3607,15 @@ mod tests {\n     fn test_remove() {\n         let mut a = ~[1, 2, 3, 4];\n         a.remove(2);\n-        fail_unless!(a == ~[1, 2, 4]);\n+        assert!(a == ~[1, 2, 4]);\n \n         let mut a = ~[1, 2, 3];\n         a.remove(0);\n-        fail_unless!(a == ~[2, 3]);\n+        assert!(a == ~[2, 3]);\n \n         let mut a = ~[1];\n         a.remove(0);\n-        fail_unless!(a == ~[]);\n+        assert!(a == ~[]);\n     }\n \n     #[test]\n@@ -3630,19 +3630,19 @@ mod tests {\n     fn test_capacity() {\n         let mut v = ~[0u64];\n         reserve(&mut v, 10u);\n-        fail_unless!(capacity(&v) == 10u);\n+        assert!(capacity(&v) == 10u);\n         let mut v = ~[0u32];\n         reserve(&mut v, 10u);\n-        fail_unless!(capacity(&v) == 10u);\n+        assert!(capacity(&v) == 10u);\n     }\n \n     #[test]\n     fn test_slice_2() {\n         let v = ~[1, 2, 3, 4, 5];\n         let v = v.slice(1u, 3u);\n-        fail_unless!(v.len() == 2u);\n-        fail_unless!(v[0] == 2);\n-        fail_unless!(v[1] == 3);\n+        assert!(v.len() == 2u);\n+        assert!(v[0] == 2);\n+        assert!(v[1] == 3);\n     }\n \n "}, {"sha": "806a7aedd310404918a58e6fd78ec51d4fd92136", "filename": "src/libfuzzer/ast_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibfuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibfuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fast_match.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -29,13 +29,13 @@ fn builtin_equal<T>(&&a: T, &&b: T) -> bool { return a == b; }\n fn builtin_equal_int(&&a: int, &&b: int) -> bool { return a == b; }\n \n fn main() {\n-    fail_unless!((builtin_equal(5, 5)));\n-    fail_unless!((!builtin_equal(5, 4)));\n-    fail_unless!((!vec_equal(~[5, 5], ~[5], bind builtin_equal(_, _))));\n-    fail_unless!((!vec_equal(~[5, 5], ~[5], builtin_equal_int)));\n-    fail_unless!((!vec_equal(~[5, 5], ~[5, 4], builtin_equal_int)));\n-    fail_unless!((!vec_equal(~[5, 5], ~[4, 5], builtin_equal_int)));\n-    fail_unless!((vec_equal(~[5, 5], ~[5, 5], builtin_equal_int)));\n+    assert!((builtin_equal(5, 5)));\n+    assert!((!builtin_equal(5, 4)));\n+    assert!((!vec_equal(~[5, 5], ~[5], bind builtin_equal(_, _))));\n+    assert!((!vec_equal(~[5, 5], ~[5], builtin_equal_int)));\n+    assert!((!vec_equal(~[5, 5], ~[5, 4], builtin_equal_int)));\n+    assert!((!vec_equal(~[5, 5], ~[4, 5], builtin_equal_int)));\n+    assert!((vec_equal(~[5, 5], ~[5, 5], builtin_equal_int)));\n \n     error!(\"Pass\");\n }"}, {"sha": "c18d1f43b5678d71b0dea8d352e0d640f9bb5b2d", "filename": "src/libfuzzer/cycles.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibfuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibfuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fcycles.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -14,12 +14,12 @@ use uint::range;\n \n // random uint less than n\n fn under(r : rand::rng, n : uint) -> uint {\n-    fail_unless!(n != 0u); r.next() as uint % n\n+    assert!(n != 0u); r.next() as uint % n\n }\n \n // random choice from a vec\n fn choice<T:copy>(r : rand::rng, v : ~[const T]) -> T {\n-    fail_unless!(vec::len(v) != 0u); v[under(r, vec::len(v))]\n+    assert!(vec::len(v) != 0u); v[under(r, vec::len(v))]\n }\n \n // k in n chance of being true"}, {"sha": "aad48bbb8e636260748f3592de23e5275facb9fb", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -377,13 +377,13 @@ pub fn check_whole_compiler(code: ~str, suggested_filename_prefix: &Path,\n \n pub fn removeIfExists(filename: &Path) {\n     // So sketchy!\n-    fail_unless!(!contains(filename.to_str(), ~\" \"));\n+    assert!(!contains(filename.to_str(), ~\" \"));\n     run::program_output(~\"bash\", ~[~\"-c\", ~\"rm \" + filename.to_str()]);\n }\n \n pub fn removeDirIfExists(filename: &Path) {\n     // So sketchy!\n-    fail_unless!(!contains(filename.to_str(), ~\" \"));\n+    assert!(!contains(filename.to_str(), ~\" \"));\n     run::program_output(~\"bash\", ~[~\"-c\", ~\"rm -r \" + filename.to_str()]);\n }\n "}, {"sha": "2422c146e245f8110b160b7b5526975f011bd9b6", "filename": "src/libfuzzer/rand_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibfuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibfuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Frand_util.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -13,12 +13,12 @@ use std::rand;\n \n // random uint less than n\n fn under(r : rand::rng, n : uint) -> uint {\n-    fail_unless!(n != 0u); r.next() as uint % n\n+    assert!(n != 0u); r.next() as uint % n\n }\n \n // random choice from a vec\n fn choice<T:copy>(r : rand::rng, v : ~[T]) -> T {\n-    fail_unless!(vec::len(v) != 0u); v[under(r, vec::len(v))]\n+    assert!(vec::len(v) != 0u); v[under(r, vec::len(v))]\n }\n \n // 1 in n chance of being true\n@@ -49,12 +49,12 @@ fn shuffled<T:copy>(r : rand::rng, v : ~[T]) -> ~[T] {\n // * weighted_vec is O(total weight) space\n type weighted<T> = { weight: uint, item: T };\n fn weighted_choice<T:copy>(r : rand::rng, v : ~[weighted<T>]) -> T {\n-    fail_unless!(vec::len(v) != 0u);\n+    assert!(vec::len(v) != 0u);\n     let total = 0u;\n     for {weight: weight, item: _} in v {\n         total += weight;\n     }\n-    fail_unless!(total >= 0u);\n+    assert!(total >= 0u);\n     let chosen = under(r, total);\n     let so_far = 0u;\n     for {weight: weight, item: item} in v {"}, {"sha": "6c485df84b48406504b7106bddbe2be1adb058c3", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -118,7 +118,7 @@ pub fn get_rpath_relative_to_output(os: session::os,\n                                  -> Path {\n     use core::os;\n \n-    fail_unless!(not_win32(os));\n+    assert!(not_win32(os));\n \n     // Mac doesn't appear to support $ORIGIN\n     let prefix = match os {\n@@ -134,8 +134,8 @@ pub fn get_rpath_relative_to_output(os: session::os,\n \n // Find the relative path from one file to another\n pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n-    fail_unless!(abs1.is_absolute);\n-    fail_unless!(abs2.is_absolute);\n+    assert!(abs1.is_absolute);\n+    assert!(abs2.is_absolute);\n     let abs1 = abs1.normalize();\n     let abs2 = abs2.normalize();\n     debug!(\"finding relative path from %s to %s\",\n@@ -144,8 +144,8 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     let split2: &[~str] = abs2.components;\n     let len1 = vec::len(split1);\n     let len2 = vec::len(split2);\n-    fail_unless!(len1 > 0);\n-    fail_unless!(len2 > 0);\n+    assert!(len1 > 0);\n+    assert!(len2 > 0);\n \n     let max_common_path = uint::min(len1, len2) - 1;\n     let mut start_idx = 0;\n@@ -215,7 +215,7 @@ mod test {\n     pub fn test_rpaths_to_flags() {\n         let flags = rpaths_to_flags(~[Path(\"path1\"),\n                                       Path(\"path2\")]);\n-        fail_unless!(flags == ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"]);\n+        assert!(flags == ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"]);\n     }\n \n     #[test]\n@@ -226,21 +226,21 @@ mod test {\n         debug!(\"test_prefix_path: %s vs. %s\",\n                res.to_str(),\n                d.to_str());\n-        fail_unless!(str::ends_with(res.to_str(), d.to_str()));\n+        assert!(str::ends_with(res.to_str(), d.to_str()));\n     }\n \n     #[test]\n     pub fn test_prefix_rpath_abs() {\n         let res = get_install_prefix_rpath(\"triple\");\n-        fail_unless!(res.is_absolute);\n+        assert!(res.is_absolute);\n     }\n \n     #[test]\n     pub fn test_minimize1() {\n         let res = minimize_rpaths([Path(\"rpath1\"),\n                                    Path(\"rpath2\"),\n                                    Path(\"rpath1\")]);\n-        fail_unless!(res == ~[Path(\"rpath1\"), Path(\"rpath2\")]);\n+        assert!(res == ~[Path(\"rpath1\"), Path(\"rpath2\")]);\n     }\n \n     #[test]\n@@ -249,63 +249,63 @@ mod test {\n                                     Path(\"1a\"), Path(\"4a\"),Path(\"1a\"),\n                                     Path(\"2\"), Path(\"3\"), Path(\"4a\"),\n                                     Path(\"3\")]);\n-        fail_unless!(res == ~[Path(\"1a\"), Path(\"2\"), Path(\"4a\"), Path(\"3\")]);\n+        assert!(res == ~[Path(\"1a\"), Path(\"2\"), Path(\"4a\"), Path(\"3\")]);\n     }\n \n     #[test]\n     pub fn test_relative_to1() {\n         let p1 = Path(\"/usr/bin/rustc\");\n         let p2 = Path(\"/usr/lib/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        fail_unless!(res == Path(\"../lib\"));\n+        assert!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n     pub fn test_relative_to2() {\n         let p1 = Path(\"/usr/bin/rustc\");\n         let p2 = Path(\"/usr/bin/../lib/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        fail_unless!(res == Path(\"../lib\"));\n+        assert!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n     pub fn test_relative_to3() {\n         let p1 = Path(\"/usr/bin/whatever/rustc\");\n         let p2 = Path(\"/usr/lib/whatever/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        fail_unless!(res == Path(\"../../lib/whatever\"));\n+        assert!(res == Path(\"../../lib/whatever\"));\n     }\n \n     #[test]\n     pub fn test_relative_to4() {\n         let p1 = Path(\"/usr/bin/whatever/../rustc\");\n         let p2 = Path(\"/usr/lib/whatever/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        fail_unless!(res == Path(\"../lib/whatever\"));\n+        assert!(res == Path(\"../lib/whatever\"));\n     }\n \n     #[test]\n     pub fn test_relative_to5() {\n         let p1 = Path(\"/usr/bin/whatever/../rustc\");\n         let p2 = Path(\"/usr/lib/whatever/../mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        fail_unless!(res == Path(\"../lib\"));\n+        assert!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n     pub fn test_relative_to6() {\n         let p1 = Path(\"/1\");\n         let p2 = Path(\"/2/3\");\n         let res = get_relative_to(&p1, &p2);\n-        fail_unless!(res == Path(\"2\"));\n+        assert!(res == Path(\"2\"));\n     }\n \n     #[test]\n     pub fn test_relative_to7() {\n         let p1 = Path(\"/1/2\");\n         let p2 = Path(\"/3\");\n         let res = get_relative_to(&p1, &p2);\n-        fail_unless!(res == Path(\"..\"));\n+        assert!(res == Path(\"..\"));\n     }\n \n     #[test]\n@@ -318,7 +318,7 @@ mod test {\n         debug!(\"test_relative_tu8: %s vs. %s\",\n                res.to_str(),\n                Path(\".\").to_str());\n-        fail_unless!(res == Path(\".\"));\n+        assert!(res == Path(\".\"));\n     }\n \n     #[test]\n@@ -328,7 +328,7 @@ mod test {\n       let o = session::os_linux;\n       let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n-      fail_unless!(res.to_str() == ~\"$ORIGIN/../lib\");\n+      assert!(res.to_str() == ~\"$ORIGIN/../lib\");\n     }\n \n     #[test]\n@@ -337,7 +337,7 @@ mod test {\n         let o = session::os_freebsd;\n         let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n-        fail_unless!(res.to_str() == ~\"$ORIGIN/../lib\");\n+        assert!(res.to_str() == ~\"$ORIGIN/../lib\");\n     }\n \n     #[test]\n@@ -348,7 +348,7 @@ mod test {\n         let res = get_rpath_relative_to_output(o,\n                                                &Path(\"bin/rustc\"),\n                                                &Path(\"lib/libstd.so\"));\n-        fail_unless!(res.to_str() == ~\"@executable_path/../lib\");\n+        assert!(res.to_str() == ~\"@executable_path/../lib\");\n     }\n \n     #[test]\n@@ -358,6 +358,6 @@ mod test {\n                res.to_str(),\n                os::make_absolute(&Path(\"lib\")).to_str());\n \n-        fail_unless!(res == os::make_absolute(&Path(\"lib\")));\n+        assert!(res == os::make_absolute(&Path(\"lib\")));\n     }\n }"}, {"sha": "93bc64eafa32488c84e6c2d0228cae6f94c62e1c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -899,7 +899,7 @@ pub mod test {\n             ~\"rustc\", matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n         let cfg = build_configuration(sess, ~\"whatever\", str_input(~\"\"));\n-        fail_unless!((attr::contains_name(cfg, ~\"test\")));\n+        assert!((attr::contains_name(cfg, ~\"test\")));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n@@ -919,7 +919,7 @@ pub mod test {\n         let sess = build_session(sessopts, diagnostic::emit);\n         let cfg = build_configuration(sess, ~\"whatever\", str_input(~\"\"));\n         let test_items = attr::find_meta_items_by_name(cfg, ~\"test\");\n-        fail_unless!((vec::len(test_items) == 1u));\n+        assert!((vec::len(test_items) == 1u));\n     }\n }\n "}, {"sha": "d1f95dbeacca1380f1146285b15aa575f51bd009", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -378,43 +378,43 @@ pub mod test {\n     #[test]\n     pub fn bin_crate_type_attr_results_in_bin_output() {\n         let crate = make_crate(true, false);\n-        fail_unless!(!building_library(unknown_crate, crate, false));\n+        assert!(!building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n     pub fn lib_crate_type_attr_results_in_lib_output() {\n         let crate = make_crate(false, true);\n-        fail_unless!(building_library(unknown_crate, crate, false));\n+        assert!(building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n     pub fn bin_option_overrides_lib_crate_type() {\n         let crate = make_crate(false, true);\n-        fail_unless!(!building_library(bin_crate, crate, false));\n+        assert!(!building_library(bin_crate, crate, false));\n     }\n \n     #[test]\n     pub fn lib_option_overrides_bin_crate_type() {\n         let crate = make_crate(true, false);\n-        fail_unless!(building_library(lib_crate, crate, false));\n+        assert!(building_library(lib_crate, crate, false));\n     }\n \n     #[test]\n     pub fn bin_crate_type_is_default() {\n         let crate = make_crate(false, false);\n-        fail_unless!(!building_library(unknown_crate, crate, false));\n+        assert!(!building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n     pub fn test_option_overrides_lib_crate_type() {\n         let crate = make_crate(false, true);\n-        fail_unless!(!building_library(unknown_crate, crate, true));\n+        assert!(!building_library(unknown_crate, crate, true));\n     }\n \n     #[test]\n     pub fn test_option_does_not_override_requested_lib_type() {\n         let crate = make_crate(false, false);\n-        fail_unless!(building_library(lib_crate, crate, true));\n+        assert!(building_library(lib_crate, crate, true));\n     }\n }\n "}, {"sha": "34678d1803c17de3af72e300a80a39dc8776e1c4", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -1472,8 +1472,8 @@ pub struct TypeNames {\n }\n \n pub fn associate_type(tn: @TypeNames, s: @str, t: TypeRef) {\n-    fail_unless!(tn.type_names.insert(t, s));\n-    fail_unless!(tn.named_types.insert(s, t));\n+    assert!(tn.type_names.insert(t, s));\n+    assert!(tn.named_types.insert(s, t));\n }\n \n pub fn type_has_name(tn: @TypeNames, t: TypeRef) -> Option<@str> {"}, {"sha": "b8bf27d762799529a274bb9a57172b69509e1bb5", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -97,7 +97,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n                 }\n             }));\n \n-        fail_unless!(!matches.is_empty());\n+        assert!(!matches.is_empty());\n \n         if matches.len() != 1u {\n             diag.handler().warn("}, {"sha": "c836538e1e6c8edd173e2ae812de6e56ddfbaa3b", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -102,7 +102,7 @@ pub fn get_used_crate_files(cstore: &CStore) -> ~[Path] {\n }\n \n pub fn add_used_library(cstore: &mut CStore, lib: @~str) -> bool {\n-    fail_unless!(*lib != ~\"\");\n+    assert!(*lib != ~\"\");\n \n     if cstore.used_libraries.contains(&*lib) { return false; }\n     cstore.used_libraries.push(/*bad*/ copy *lib);"}, {"sha": "dcea22b09d6d610cc6cff416c44e1b3c5a5e036c", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -1003,7 +1003,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n-            fail_unless!((vec::len(meta_items) == 1u));\n+            assert!((vec::len(meta_items) == 1u));\n             let meta_item = meta_items[0];\n             attrs.push(\n                 codemap::spanned {"}, {"sha": "af9ab7d94f18513b5ccbc43112bea4324ae28e45", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -1082,7 +1082,7 @@ fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n         ebml_w.start_tag(tag_index_buckets_bucket);\n         for vec::each(**bucket) |elt| {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n-            fail_unless!(elt.pos < 0xffff_ffff);\n+            assert!(elt.pos < 0xffff_ffff);\n             writer.write_be_u32(elt.pos as u32);\n             write_fn(writer, elt.val);\n             ebml_w.end_tag();\n@@ -1092,7 +1092,7 @@ fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_index_table);\n     for bucket_locs.each |pos| {\n-        fail_unless!(*pos < 0xffff_ffff);\n+        assert!(*pos < 0xffff_ffff);\n         writer.write_be_u32(*pos as u32);\n     }\n     ebml_w.end_tag();\n@@ -1102,7 +1102,7 @@ fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n fn write_str(writer: @io::Writer, &&s: ~str) { writer.write_str(s); }\n \n fn write_int(writer: @io::Writer, &&n: int) {\n-    fail_unless!(n < 0x7fff_ffff);\n+    assert!(n < 0x7fff_ffff);\n     writer.write_be_u32(n as u32);\n }\n \n@@ -1163,8 +1163,8 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n     fn synthesize_link_attr(ecx: @EncodeContext, +items: ~[@meta_item]) ->\n        attribute {\n \n-        fail_unless!(!ecx.link_meta.name.is_empty());\n-        fail_unless!(!ecx.link_meta.vers.is_empty());\n+        assert!(!ecx.link_meta.name.is_empty());\n+        assert!(!ecx.link_meta.vers.is_empty());\n \n         let name_item =\n             attr::mk_name_value_item_str(@~\"name\",\n@@ -1230,7 +1230,7 @@ fn encode_crate_deps(ecx: @EncodeContext,\n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n         for deps.each |n| {\n-            fail_unless!((n.cnum == expected_cnum));\n+            assert!((n.cnum == expected_cnum));\n             expected_cnum += 1;\n         }\n "}, {"sha": "e233bf78d789d4f0a875c8eac53a4fd59d6216a0", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -142,12 +142,12 @@ fn parse_sigil(st: @mut PState) -> ast::Sigil {\n }\n \n fn parse_vstore(st: @mut PState) -> ty::vstore {\n-    fail_unless!(next(st) == '/');\n+    assert!(next(st) == '/');\n \n     let c = peek(st);\n     if '0' <= c && c <= '9' {\n         let n = parse_int(st) as uint;\n-        fail_unless!(next(st) == '|');\n+        assert!(next(st) == '|');\n         return ty::vstore_fixed(n);\n     }\n \n@@ -174,7 +174,7 @@ fn parse_substs(st: @mut PState, conv: conv_did) -> ty::substs {\n \n     let self_ty = parse_opt(st, || parse_ty(st, conv) );\n \n-    fail_unless!(next(st) == '[');\n+    assert!(next(st) == '[');\n     let mut params: ~[ty::t] = ~[];\n     while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n     st.pos = st.pos + 1u;\n@@ -191,13 +191,13 @@ fn parse_bound_region(st: @mut PState) -> ty::bound_region {\n       's' => ty::br_self,\n       'a' => {\n         let id = parse_int(st) as uint;\n-        fail_unless!(next(st) == '|');\n+        assert!(next(st) == '|');\n         ty::br_anon(id)\n       }\n       '[' => ty::br_named(st.tcx.sess.ident_of(parse_str(st, ']'))),\n       'c' => {\n         let id = parse_int(st);\n-        fail_unless!(next(st) == '|');\n+        assert!(next(st) == '|');\n         ty::br_cap_avoid(id, @parse_bound_region(st))\n       },\n       _ => fail!(~\"parse_bound_region: bad input\")\n@@ -210,16 +210,16 @@ fn parse_region(st: @mut PState) -> ty::Region {\n         ty::re_bound(parse_bound_region(st))\n       }\n       'f' => {\n-        fail_unless!(next(st) == '[');\n+        assert!(next(st) == '[');\n         let id = parse_int(st);\n-        fail_unless!(next(st) == '|');\n+        assert!(next(st) == '|');\n         let br = parse_bound_region(st);\n-        fail_unless!(next(st) == ']');\n+        assert!(next(st) == ']');\n         ty::re_free(id, br)\n       }\n       's' => {\n         let id = parse_int(st);\n-        fail_unless!(next(st) == '|');\n+        assert!(next(st) == '|');\n         ty::re_scope(id)\n       }\n       't' => {\n@@ -271,18 +271,18 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n       }\n       'c' => return ty::mk_char(st.tcx),\n       't' => {\n-        fail_unless!((next(st) == '['));\n+        assert!((next(st) == '['));\n         let def = parse_def(st, NominalType, conv);\n         let substs = parse_substs(st, conv);\n-        fail_unless!(next(st) == ']');\n+        assert!(next(st) == ']');\n         return ty::mk_enum(st.tcx, def, substs);\n       }\n       'x' => {\n-        fail_unless!(next(st) == '[');\n+        assert!(next(st) == '[');\n         let def = parse_def(st, NominalType, conv);\n         let substs = parse_substs(st, conv);\n         let store = parse_trait_store(st);\n-        fail_unless!(next(st) == ']');\n+        assert!(next(st) == ']');\n         return ty::mk_trait(st.tcx, def, substs, store);\n       }\n       'p' => {\n@@ -313,7 +313,7 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n         return ty::mk_estr(st.tcx, v);\n       }\n       'T' => {\n-        fail_unless!((next(st) == '['));\n+        assert!((next(st) == '['));\n         let mut params = ~[];\n         while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n         st.pos = st.pos + 1u;\n@@ -332,9 +332,9 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n       }\n       '#' => {\n         let pos = parse_hex(st);\n-        fail_unless!((next(st) == ':'));\n+        assert!((next(st) == ':'));\n         let len = parse_hex(st);\n-        fail_unless!((next(st) == '#'));\n+        assert!((next(st) == '#'));\n         let key = ty::creader_cache_key {cnum: st.crate,\n                                          pos: pos,\n                                          len: len };\n@@ -355,10 +355,10 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n       }\n       'B' => ty::mk_opaque_box(st.tcx),\n       'a' => {\n-          fail_unless!((next(st) == '['));\n+          assert!((next(st) == '['));\n           let did = parse_def(st, NominalType, conv);\n           let substs = parse_substs(st, conv);\n-          fail_unless!((next(st) == ']'));\n+          assert!((next(st) == ']'));\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n       c => { error!(\"unexpected char in type string: %c\", c); fail!();}\n@@ -472,7 +472,7 @@ fn parse_bare_fn_ty(st: @mut PState, conv: conv_did) -> ty::BareFnTy {\n }\n \n fn parse_sig(st: @mut PState, conv: conv_did) -> ty::FnSig {\n-    fail_unless!((next(st) == '['));\n+    assert!((next(st) == '['));\n     let mut inputs: ~[ty::arg] = ~[];\n     while peek(st) != ']' {\n         let mode = parse_mode(st);"}, {"sha": "8dcfaf2eb3510d569a08bc0e3638176ca08c8687", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -175,7 +175,7 @@ pub impl ExtendedDecodeContext {\n          */\n \n         // from_id_range should be non-empty\n-        fail_unless!(!ast_util::empty(self.from_id_range));\n+        assert!(!ast_util::empty(self.from_id_range));\n         (id - self.from_id_range.min + self.to_id_range.min)\n     }\n     fn tr_def_id(&self, did: ast::def_id) -> ast::def_id {\n@@ -212,7 +212,7 @@ pub impl ExtendedDecodeContext {\n          * refer to the current crate and to the new, inlined node-id.\n          */\n \n-        fail_unless!(did.crate == ast::local_crate);\n+        assert!(did.crate == ast::local_crate);\n         ast::def_id { crate: ast::local_crate, node: self.tr_id(did.node) }\n     }\n     fn tr_span(&self, _span: span) -> span {\n@@ -1232,7 +1232,7 @@ fn roundtrip(in_item: Option<@ast::item>) {\n     debug!(\"expected string: %s\", exp_str);\n     debug!(\"actual string  : %s\", out_str);\n \n-    fail_unless!(exp_str == out_str);\n+    assert!(exp_str == out_str);\n }\n \n #[test]\n@@ -1279,7 +1279,7 @@ fn test_simplification() {\n     ).get());\n     match (item_out, item_exp) {\n       (ast::ii_item(item_out), ast::ii_item(item_exp)) => {\n-        fail_unless!(pprust::item_to_str(item_out,\n+        assert!(pprust::item_to_str(item_out,\n                                          ext_cx.parse_sess().interner)\n                      == pprust::item_to_str(item_exp,\n                                             ext_cx.parse_sess().interner));"}, {"sha": "fdea403cc2a00f21d19f4d68d1563726d91613da", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -132,7 +132,7 @@ pub fn raw_pat(p: @pat) -> @pat {\n }\n \n pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n-    fail_unless!((!pats.is_empty()));\n+    assert!((!pats.is_empty()));\n     let ext = match is_useful(cx, &pats.map(|p| ~[*p]), ~[wild()]) {\n         not_useful => {\n             // This is good, wildcard pattern isn't reachable"}, {"sha": "024d862461d8332638bba853237bb79fede112df", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -882,7 +882,7 @@ fn check_item_path_statement(cx: ty::ctxt, it: @ast::item) {\n fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n-        fail_unless!(!ident.is_empty());\n+        assert!(!ident.is_empty());\n         let ident = ident_without_trailing_underscores(*ident);\n         let ident = ident_without_leading_underscores(ident);\n         char::is_uppercase(str::char_at(ident, 0)) &&"}, {"sha": "e9e226d36d1f5d9aa09a8392d5b6705d7a90f689", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -733,7 +733,7 @@ pub impl Liveness {\n     fn live_on_entry(&self, ln: LiveNode, var: Variable)\n         -> Option<LiveNodeKind> {\n \n-        fail_unless!(ln.is_valid());\n+        assert!(ln.is_valid());\n         let reader = self.users[self.idx(ln, var)].reader;\n         if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n     }\n@@ -748,14 +748,14 @@ pub impl Liveness {\n     }\n \n     fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n-        fail_unless!(ln.is_valid());\n+        assert!(ln.is_valid());\n         self.users[self.idx(ln, var)].used\n     }\n \n     fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n         -> Option<LiveNodeKind> {\n \n-        fail_unless!(ln.is_valid());\n+        assert!(ln.is_valid());\n         let writer = self.users[self.idx(ln, var)].writer;\n         if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n     }\n@@ -1465,9 +1465,9 @@ pub impl Liveness {\n         // repeat until fixed point is reached:\n         while self.merge_from_succ(ln, body_ln, first_merge) {\n             first_merge = false;\n-            fail_unless!(cond_ln == self.propagate_through_opt_expr(cond,\n+            assert!(cond_ln == self.propagate_through_opt_expr(cond,\n                                                                     ln));\n-            fail_unless!(body_ln == self.with_loop_nodes(expr.id, succ, ln,\n+            assert!(body_ln == self.with_loop_nodes(expr.id, succ, ln,\n             || {\n                 self.propagate_through_block(body, cond_ln)\n             }));"}, {"sha": "f6025548d71c012c2591725805274ba4456f8e81", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -463,7 +463,7 @@ pub impl DetermineRpCtxt {\n     /// variance `variance`.  If `id` was already parameterized, then\n     /// the new variance is joined with the old variance.\n     fn add_rp(&mut self, id: ast::node_id, variance: region_variance) {\n-        fail_unless!(id != 0);\n+        assert!(id != 0);\n         let old_variance = self.region_paramd_items.find(&id).\n                                 map_consume(|x| *x);\n         let joined_variance = match old_variance {"}, {"sha": "8503fa2e2cdbe7fae078e4a9219ffa8afb0815c0", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -1407,7 +1407,7 @@ pub impl Resolver {\n                     match view_path.node {\n                         view_path_simple(_, full_path, _, _) => {\n                             let path_len = full_path.idents.len();\n-                            fail_unless!(path_len != 0);\n+                            assert!(path_len != 0);\n \n                             for full_path.idents.eachi |i, ident| {\n                                 if i != path_len - 1 {\n@@ -2083,7 +2083,7 @@ pub impl Resolver {\n         // Decrement the count of unresolved imports.\n         match resolution_result {\n             Success(()) => {\n-                fail_unless!(self.unresolved_imports >= 1);\n+                assert!(self.unresolved_imports >= 1);\n                 self.unresolved_imports -= 1;\n             }\n             _ => {\n@@ -2099,7 +2099,7 @@ pub impl Resolver {\n         if !resolution_result.indeterminate() {\n             match *import_directive.subclass {\n                 GlobImport => {\n-                    fail_unless!(module_.glob_count >= 1);\n+                    assert!(module_.glob_count >= 1);\n                     module_.glob_count -= 1;\n                 }\n                 SingleImport(*) => {\n@@ -2266,7 +2266,7 @@ pub impl Resolver {\n         }\n \n         // We've successfully resolved the import. Write the results in.\n-        fail_unless!(module_.import_resolutions.contains_key(&target));\n+        assert!(module_.import_resolutions.contains_key(&target));\n         let import_resolution = module_.import_resolutions.get(&target);\n \n         match value_result {\n@@ -2329,7 +2329,7 @@ pub impl Resolver {\n             }\n         }\n \n-        fail_unless!(import_resolution.outstanding_references >= 1);\n+        assert!(import_resolution.outstanding_references >= 1);\n         import_resolution.outstanding_references -= 1;\n \n         debug!(\"(resolving single import) successfully resolved import\");\n@@ -2359,7 +2359,7 @@ pub impl Resolver {\n             return Indeterminate;\n         }\n \n-        fail_unless!(containing_module.glob_count == 0);\n+        assert!(containing_module.glob_count == 0);\n \n         // Add all resolved imports from the containing module.\n         for containing_module.import_resolutions.each\n@@ -2560,7 +2560,7 @@ pub impl Resolver {\n                                       span: span)\n                                    -> ResolveResult<@mut Module> {\n         let module_path_len = module_path.len();\n-        fail_unless!(module_path_len > 0);\n+        assert!(module_path_len > 0);\n \n         debug!(\"(resolving module path for import) processing `%s` rooted at \\\n                `%s`\",\n@@ -2923,7 +2923,7 @@ pub impl Resolver {\n         // If this is a search of all imports, we should be done with glob\n         // resolution at this point.\n         if name_search_type == SearchItemsAndAllImports {\n-            fail_unless!(module_.glob_count == 0);\n+            assert!(module_.glob_count == 0);\n         }\n \n         // Check the list of resolved imports."}, {"sha": "12eaeb77d1103354858140db3812d8980ec978ba", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -1259,7 +1259,7 @@ pub fn compile_submatch(bcx: block,\n     /*\n       For an empty match, a fall-through case must exist\n      */\n-    fail_unless!((m.len() > 0u || chk.is_some()));\n+    assert!((m.len() > 0u || chk.is_some()));\n     let _icx = bcx.insn_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx(), dm = tcx.def_map;"}, {"sha": "b854addf0b1a2ee6f6d1131b0dcb7cf789a67aa1", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -139,7 +139,7 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n                 CEnum(discrs.min(), discrs.max())\n             } else if cases.len() == 1 {\n                 // Equivalent to a struct/tuple/newtype.\n-                fail_unless!(cases[0].discr == 0);\n+                assert!(cases[0].discr == 0);\n                 Univariant(mk_struct(cx, cases[0].tys), false)\n             } else {\n                 // The general case.  Since there's at least one\n@@ -191,7 +191,7 @@ fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n             // To get \"the\" type of a general enum, we pick the case\n             // with the largest alignment (so it will always align\n             // correctly in containing structures) and pad it out.\n-            fail_unless!(sts.len() >= 1);\n+            assert!(sts.len() >= 1);\n             let mut most_aligned = None;\n             let mut largest_align = 0;\n             let mut largest_size = 0;\n@@ -300,16 +300,16 @@ pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n     match *r {\n         CEnum(min, max) => {\n-            fail_unless!(min <= discr && discr <= max);\n+            assert!(min <= discr && discr <= max);\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n         }\n         Univariant(ref st, true) => {\n-            fail_unless!(discr == 0);\n+            assert!(discr == 0);\n             Store(bcx, C_bool(true),\n                   GEPi(bcx, val, [0, st.fields.len() - 1]))\n         }\n         Univariant(*) => {\n-            fail_unless!(discr == 0);\n+            assert!(discr == 0);\n         }\n         General(*) => {\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n@@ -325,7 +325,7 @@ pub fn num_args(r: &Repr, discr: int) -> uint {\n     match *r {\n         CEnum(*) => 0,\n         Univariant(ref st, dtor) => {\n-            fail_unless!(discr == 0);\n+            assert!(discr == 0);\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n         General(ref cases) => cases[discr as uint].fields.len() - 1\n@@ -343,7 +343,7 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n             bcx.ccx().sess.bug(~\"element access in C-like enum\")\n         }\n         Univariant(ref st, _dtor) => {\n-            fail_unless!(discr == 0);\n+            assert!(discr == 0);\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n         General(ref cases) => {\n@@ -401,12 +401,12 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n                    vals: &[ValueRef]) -> ValueRef {\n     match *r {\n         CEnum(min, max) => {\n-            fail_unless!(vals.len() == 0);\n-            fail_unless!(min <= discr && discr <= max);\n+            assert!(vals.len() == 0);\n+            assert!(min <= discr && discr <= max);\n             C_int(ccx, discr)\n         }\n         Univariant(ref st, _dro) => {\n-            fail_unless!(discr == 0);\n+            assert!(discr == 0);\n             C_struct(build_const_struct(ccx, st, vals))\n         }\n         General(ref cases) => {\n@@ -431,7 +431,7 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n  */\n fn build_const_struct(ccx: @CrateContext, st: &Struct, vals: &[ValueRef])\n     -> ~[ValueRef] {\n-    fail_unless!(vals.len() == st.fields.len());\n+    assert!(vals.len() == st.fields.len());\n \n     let mut offset = 0;\n     let mut cfields = ~[];\n@@ -447,7 +447,7 @@ fn build_const_struct(ccx: @CrateContext, st: &Struct, vals: &[ValueRef])\n             cfields.push(padding(target_offset - offset));\n             offset = target_offset;\n         }\n-        fail_unless!(!is_undef(vals[i]));\n+        assert!(!is_undef(vals[i]));\n         // If that assert fails, could change it to wrap in a struct?\n         // (See `const_struct_field` for why real fields must not be undef.)\n         cfields.push(vals[i]);"}, {"sha": "f1988096a7e0e16d2b1c62d9f80563661145814c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -314,7 +314,7 @@ pub fn non_gc_box_cast(bcx: block, val: ValueRef) -> ValueRef {\n     unsafe {\n         debug!(\"non_gc_box_cast\");\n         add_comment(bcx, ~\"non_gc_box_cast\");\n-        fail_unless!(llvm::LLVMGetPointerAddressSpace(val_ty(val)) ==\n+        assert!(llvm::LLVMGetPointerAddressSpace(val_ty(val)) ==\n                      gc_box_addrspace || bcx.unreachable);\n         let non_gc_t = T_ptr(llvm::LLVMGetElementType(val_ty(val)));\n         PointerCast(bcx, val, non_gc_t)\n@@ -489,7 +489,7 @@ pub fn get_res_dtor(ccx: @CrateContext, did: ast::def_id,\n         let did = if did.crate != ast::local_crate {\n             inline::maybe_instantiate_inline(ccx, did, true)\n         } else { did };\n-        fail_unless!(did.crate == ast::local_crate);\n+        assert!(did.crate == ast::local_crate);\n         let (val, _) =\n             monomorphize::monomorphic_fn(ccx, did, substs, None, None, None);\n \n@@ -1336,7 +1336,7 @@ pub fn cleanup_and_leave(bcx: block,\n         }\n         cur = match cur.parent {\n           Some(next) => next,\n-          None => { fail_unless!(upto.is_none()); break; }\n+          None => { assert!(upto.is_none()); break; }\n         };\n     }\n     match leave {\n@@ -1523,7 +1523,7 @@ pub fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n     let ccx = bcx.ccx();\n     let llty = type_of::type_of(ccx, t);\n     if ty::type_has_params(t) { debug!(\"%s\", ty_to_str(ccx.tcx, t)); }\n-    fail_unless!(!ty::type_has_params(t));\n+    assert!(!ty::type_has_params(t));\n     let val = alloca(bcx, llty);\n     return val;\n }\n@@ -2471,7 +2471,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             // Want parent_id and not id, because id is the dtor's type\n             let class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n             // This code shouldn't be reached if the class is generic\n-            fail_unless!(!ty::type_has_params(class_ty));\n+            assert!(!ty::type_has_params(class_ty));\n             let lldty = unsafe {\n                 T_fn(~[\n                     T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n@@ -2491,7 +2491,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             let llfn;\n             match v.node.kind {\n                 ast::tuple_variant_kind(ref args) => {\n-                    fail_unless!(args.len() != 0u);\n+                    assert!(args.len() != 0u);\n                     let pth = vec::append(/*bad*/copy *pth,\n                                           ~[path_name(enm.ident),\n                                             path_name((*v).node.name)]);"}, {"sha": "ab0e2f38a0b9430288677fda442a6bd4cc5b001a", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -813,7 +813,7 @@ pub fn Phi(cx: block, Ty: TypeRef, vals: &[ValueRef], bbs: &[BasicBlockRef])\n     -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n-        fail_unless!(vals.len() == bbs.len());\n+        assert!(vals.len() == bbs.len());\n         let phi = EmptyPhi(cx, Ty);\n         count_insn(cx, \"addincoming\");\n         llvm::LLVMAddIncoming(phi, vec::raw::to_ptr(vals),\n@@ -1033,7 +1033,7 @@ pub fn Trap(cx: block) {\n         let T: ValueRef = str::as_c_str(~\"llvm.trap\", |buf| {\n             llvm::LLVMGetNamedFunction(M, buf)\n         });\n-        fail_unless!((T as int != 0));\n+        assert!((T as int != 0));\n         let Args: ~[ValueRef] = ~[];\n         unsafe {\n             count_insn(cx, \"trap\");\n@@ -1047,7 +1047,7 @@ pub fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n                   NumClauses: uint) -> ValueRef {\n     unsafe {\n         check_not_terminated(cx);\n-        fail_unless!(!cx.unreachable);\n+        assert!(!cx.unreachable);\n         count_insn(cx, \"landingpad\");\n         return llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n                                       NumClauses as c_uint, noname());"}, {"sha": "0377ed15a2d1e2d1b5a281322e6761cda4fc6856", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -133,7 +133,7 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n             }\n             ast::def_variant(tid, vid) => {\n                 // nullary variants are not callable\n-                fail_unless!(ty::enum_variant_with_id(bcx.tcx(),\n+                assert!(ty::enum_variant_with_id(bcx.tcx(),\n                                                       tid,\n                                                       vid).args.len() > 0u);\n                 fn_callee(bcx, trans_fn_ref(bcx, vid, ref_expr.id))\n@@ -231,7 +231,7 @@ pub fn trans_fn_ref_with_vtables(\n            vtables);\n     let _indenter = indenter();\n \n-    fail_unless!(type_params.all(|t| !ty::type_needs_infer(*t)));\n+    assert!(type_params.all(|t| !ty::type_needs_infer(*t)));\n \n     // Polytype of the function item (may have type params)\n     let fn_tpt = ty::lookup_item_type(tcx, def_id);\n@@ -286,7 +286,7 @@ pub fn trans_fn_ref_with_vtables(\n     // Create a monomorphic verison of generic functions\n     if must_monomorphise {\n         // Should be either intra-crate or inlined.\n-        fail_unless!(def_id.crate == ast::local_crate);\n+        assert!(def_id.crate == ast::local_crate);\n \n         let mut (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, type_params,\n@@ -705,7 +705,7 @@ pub fn trans_arg_expr(bcx: block,\n         // FIXME(#3548) use the adjustments table\n         match autoref_arg {\n             DoAutorefArg => {\n-                fail_unless!(!\n+                assert!(!\n                     bcx.ccx().maps.moves_map.contains(&arg_expr.id));\n                 val = arg_datum.to_ref_llval(bcx);\n             }"}, {"sha": "0ef9d4af6048719a79d549784f0a394ae9320829", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -271,7 +271,7 @@ pub fn build_closure(bcx0: block,\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n             moves::CapRef => {\n-                fail_unless!(sigil == ast::BorrowedSigil);\n+                assert!(sigil == ast::BorrowedSigil);\n                 env_vals.push(EnvValue {action: EnvRef,\n                                         datum: datum});\n             }"}, {"sha": "e9fc36bbd7d3e5730e2c0b69abd4a79416bce1bb", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -255,8 +255,8 @@ pub struct param_substs {\n \n pub impl param_substs {\n     fn validate(&self) {\n-        for self.tys.each |t| { fail_unless!(!ty::type_needs_infer(*t)); }\n-        for self.self_ty.each |t| { fail_unless!(!ty::type_needs_infer(*t)); }\n+        for self.tys.each |t| { assert!(!ty::type_needs_infer(*t)); }\n+        for self.self_ty.each |t| { assert!(!ty::type_needs_infer(*t)); }\n     }\n }\n \n@@ -1359,7 +1359,7 @@ pub fn monomorphize_type(bcx: block, t: ty::t) -> ty::t {\n         Some(substs) => {\n             ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n         }\n-        _ => { fail_unless!(!ty::type_has_params(t)); t }\n+        _ => { assert!(!ty::type_has_params(t)); t }\n     }\n }\n "}, {"sha": "2443c9998f1353965cdd85cad2fe7ed3779406bb", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -74,7 +74,7 @@ pub fn const_lit(cx: @CrateContext, e: @ast::expr, lit: ast::lit)\n pub fn const_ptrcast(cx: @CrateContext, a: ValueRef, t: TypeRef) -> ValueRef {\n     unsafe {\n         let b = llvm::LLVMConstPointerCast(a, T_ptr(t));\n-        fail_unless!(cx.const_globals.insert(b as int, a));\n+        assert!(cx.const_globals.insert(b as int, a));\n         b\n     }\n }\n@@ -116,7 +116,7 @@ fn const_deref_ptr(cx: @CrateContext, v: ValueRef) -> ValueRef {\n         None => v\n     };\n     unsafe {\n-        fail_unless!(llvm::LLVMIsGlobalConstant(v) == True);\n+        assert!(llvm::LLVMIsGlobalConstant(v) == True);\n         llvm::LLVMGetInitializer(v)\n     }\n }\n@@ -131,7 +131,7 @@ fn const_deref(cx: @CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n     -> (ValueRef, ty::t) {\n     match ty::deref(cx.tcx, t, explicit) {\n         Some(ref mt) => {\n-            fail_unless!(mt.mutbl != ast::m_mutbl);\n+            assert!(mt.mutbl != ast::m_mutbl);\n             let dv = match ty::get(t).sty {\n                 ty::ty_ptr(*) | ty::ty_rptr(*) => {\n                      const_deref_ptr(cx, v)\n@@ -197,8 +197,8 @@ pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             match adj.autoref {\n                 None => { }\n                 Some(ref autoref) => {\n-                    fail_unless!(autoref.region == ty::re_static);\n-                    fail_unless!(autoref.mutbl != ast::m_mutbl);\n+                    assert!(autoref.region == ty::re_static);\n+                    assert!(autoref.mutbl != ast::m_mutbl);\n                     // Don't copy data to do a deref+ref.\n                     let llptr = match maybe_ptr {\n                         Some(ptr) => ptr,\n@@ -211,8 +211,8 @@ pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                         ty::AutoBorrowVec => {\n                             let size = machine::llsize_of(cx,\n                                                           val_ty(llconst));\n-                            fail_unless!(abi::slice_elt_base == 0);\n-                            fail_unless!(abi::slice_elt_len == 1);\n+                            assert!(abi::slice_elt_base == 0);\n+                            assert!(abi::slice_elt_len == 1);\n                             llconst = C_struct(~[llptr, size]);\n                         }\n                         _ => {\n@@ -375,7 +375,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n               let len = match ty::get(bt).sty {\n-                  ty::ty_estr(*) => {fail_unless!(len > 0); len - 1},\n+                  ty::ty_estr(*) => {assert!(len > 0); len - 1},\n                   _ => len\n               };\n               if iv >= len {\n@@ -494,14 +494,14 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             }\n           }\n           ast::expr_path(pth) => {\n-            fail_unless!(pth.types.len() == 0);\n+            assert!(pth.types.len() == 0);\n             match cx.tcx.def_map.find(&e.id) {\n                 Some(&ast::def_fn(def_id, _purity)) => {\n                     if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx, def_id).ty;\n                         base::trans_external_path(cx, def_id, ty)\n                     } else {\n-                        fail_unless!(ast_util::is_local(def_id));\n+                        assert!(ast_util::is_local(def_id));\n                         base::get_item_val(cx, def_id.node)\n                     }\n                 }"}, {"sha": "c2235b763e230852b876c0b12523ac60321952a8", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -47,7 +47,7 @@ pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n             bcx = expr::trans_into(bcx, e, dest);\n         }\n         None => {\n-            fail_unless!(dest == expr::Ignore || bcx.unreachable);\n+            assert!(dest == expr::Ignore || bcx.unreachable);\n         }\n     }\n     return bcx;"}, {"sha": "869fdc20a65587dfff978362782efb9459ed403b", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -247,19 +247,19 @@ pub impl Datum {\n                       action: CopyAction, datum: Datum) -> block {\n         debug!(\"store_to_datum(self=%s, action=%?, datum=%s)\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n-        fail_unless!(datum.mode.is_by_ref());\n+        assert!(datum.mode.is_by_ref());\n         self.store_to(bcx, id, action, datum.val)\n     }\n \n     fn move_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n                     -> block {\n-        fail_unless!(datum.mode.is_by_ref());\n+        assert!(datum.mode.is_by_ref());\n         self.move_to(bcx, action, datum.val)\n     }\n \n     fn copy_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n                     -> block {\n-        fail_unless!(datum.mode.is_by_ref());\n+        assert!(datum.mode.is_by_ref());\n         self.copy_to(bcx, action, datum.val)\n     }\n \n@@ -372,7 +372,7 @@ pub impl Datum {\n          * Schedules this datum for cleanup in `bcx`.  The datum\n          * must be an rvalue. */\n \n-        fail_unless!(self.source == RevokeClean);\n+        assert!(self.source == RevokeClean);\n         match self.mode {\n             ByValue => {\n                 add_clean_temp_immediate(bcx, self.val, self.ty);\n@@ -393,7 +393,7 @@ pub impl Datum {\n                     // Lvalues which potentially need to be dropped\n                     // must be passed by ref, so that we can zero them\n                     // out.\n-                    fail_unless!(self.mode.is_by_ref());\n+                    assert!(self.mode.is_by_ref());\n                     zero_mem(bcx, self.val, self.ty);\n                 }\n             }\n@@ -697,7 +697,7 @@ pub impl Datum {\n                         // changing the type, so I am putting this\n                         // code in place here to do the right\n                         // thing if this change ever goes through.\n-                        fail_unless!(ty::type_is_immediate(ty));\n+                        assert!(ty::type_is_immediate(ty));\n                         (Some(Datum {ty: ty, ..*self}), bcx)\n                     }\n                 };\n@@ -737,7 +737,7 @@ pub impl Datum {\n                         // except for changing the type, so I am putting this\n                         // code in place here to do the right thing if this\n                         // change ever goes through.\n-                        fail_unless!(ty::type_is_immediate(ty));\n+                        assert!(ty::type_is_immediate(ty));\n                         (Some(Datum {ty: ty, ..*self}), bcx)\n                     }\n                 }\n@@ -797,7 +797,7 @@ pub impl Datum {\n         // either we were asked to deref a specific number of times,\n         // in which case we should have, or we asked to deref as many\n         // times as we can\n-        fail_unless!(derefs == max || max == uint::max_value);\n+        assert!(derefs == max || max == uint::max_value);\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n \n@@ -817,7 +817,7 @@ pub impl DatumBlock {\n     }\n \n     fn assert_by_ref(&self) -> DatumBlock {\n-        fail_unless!(self.datum.mode.is_by_ref());\n+        assert!(self.datum.mode.is_by_ref());\n         *self\n     }\n "}, {"sha": "dc910f9f178e395b1050c867b307e2b0671a748e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -278,7 +278,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         debug!(\"add_env(closure_ty=%s)\", ty_to_str(tcx, closure_ty));\n         let scratch = scratch_datum(bcx, closure_ty, false);\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n-        fail_unless!(datum.appropriate_mode() == ByValue);\n+        assert!(datum.appropriate_mode() == ByValue);\n         Store(bcx, datum.to_appropriate_llval(bcx), llfn);\n         let llenv = GEPi(bcx, scratch.val, [0u, abi::fn_field_box]);\n         Store(bcx, base::null_env_ptr(bcx), llenv);\n@@ -457,7 +457,7 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         }\n         ast::expr_binary(op, lhs, rhs) => {\n             // if overloaded, would be RvalueDpsExpr\n-            fail_unless!(!bcx.ccx().maps.method_map.contains_key(&expr.id));\n+            assert!(!bcx.ccx().maps.method_map.contains_key(&expr.id));\n \n             return trans_binary(bcx, expr, op, lhs, rhs);\n         }\n@@ -1301,10 +1301,10 @@ fn trans_unary_datum(bcx: block,\n     let _icx = bcx.insn_ctxt(\"trans_unary_datum\");\n \n     // if deref, would be LvalueExpr\n-    fail_unless!(op != ast::deref);\n+    assert!(op != ast::deref);\n \n     // if overloaded, would be RvalueDpsExpr\n-    fail_unless!(!bcx.ccx().maps.method_map.contains_key(&un_expr.id));\n+    assert!(!bcx.ccx().maps.method_map.contains_key(&un_expr.id));\n \n     let un_ty = expr_ty(bcx, un_expr);\n     let sub_ty = expr_ty(bcx, sub_expr);"}, {"sha": "1b27d21e6f46466dee0760d9f0e6948c9c71ace7", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -401,7 +401,7 @@ pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n     let ty_visitor_name = special_idents::ty_visitor;\n-    fail_unless!(bcx.ccx().tcx.intrinsic_defs.contains_key(&ty_visitor_name));\n+    assert!(bcx.ccx().tcx.intrinsic_defs.contains_key(&ty_visitor_name));\n     let (trait_id, ty) = *bcx.ccx().tcx.intrinsic_defs.get(&ty_visitor_name);\n     let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), ty)));\n     bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, trait_id);\n@@ -489,7 +489,7 @@ pub fn trans_struct_drop(bcx: block,\n         // Class dtors have no explicit args, so the params should\n         // just consist of the output pointer and the environment\n         // (self)\n-        fail_unless!((params.len() == 2));\n+        assert!((params.len() == 2));\n \n         // If we need to take a reference to the class (because it's using\n         // the Drop trait), do so now.\n@@ -675,7 +675,7 @@ pub fn declare_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n     let _icx = ccx.insn_ctxt(\"declare_tydesc\");\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n-    fail_unless!(!*ccx.finished_tydescs);\n+    assert!(!*ccx.finished_tydescs);\n \n     let llty = type_of(ccx, t);\n "}, {"sha": "ed9000e7418a46fea60292e8cae2b4978237b92c", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -327,7 +327,7 @@ pub fn trans_static_method_callee(bcx: block,\n \n     match vtbls[bound_index] {\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n-            fail_unless!(rcvr_substs.all(|t| !ty::type_needs_infer(*t)));\n+            assert!(rcvr_substs.all(|t| !ty::type_needs_infer(*t)));\n \n             let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n             let callee_substs = combine_impl_and_methods_tps("}, {"sha": "71e8f7c2125f254e35dab0fe7c53af8ab1c8cb50", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -47,7 +47,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                       impl_did_opt: Option<ast::def_id>,\n                       ref_id: Option<ast::node_id>) ->\n                       (ValueRef, bool) {\n-    fail_unless!(real_substs.all(|t| !ty::type_needs_infer(*t)));\n+    assert!(real_substs.all(|t| !ty::type_needs_infer(*t)));\n     let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs, |t| {\n@@ -57,8 +57,8 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         }\n     });\n \n-    for real_substs.each() |s| { fail_unless!(!ty::type_has_params(*s)); }\n-    for substs.each() |s| { fail_unless!(!ty::type_has_params(*s)); }\n+    for real_substs.each() |s| { assert!(!ty::type_has_params(*s)); }\n+    for substs.each() |s| { assert!(!ty::type_has_params(*s)); }\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n     // XXX: Bad copy.\n     let hash_id = make_mono_id(ccx, fn_id, copy substs, vtables, impl_did_opt,"}, {"sha": "a9869f15875c7e0949db2b466cf909046241cce8", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -336,7 +336,7 @@ pub fn emit_calls_to_trait_visit_ty(bcx: block,\n                                  -> block {\n     use syntax::parse::token::special_idents::tydesc;\n     let final = sub_block(bcx, ~\"final\");\n-    fail_unless!(bcx.ccx().tcx.intrinsic_defs.contains_key(&tydesc));\n+    assert!(bcx.ccx().tcx.intrinsic_defs.contains_key(&tydesc));\n     let (_, tydesc_ty) = *bcx.ccx().tcx.intrinsic_defs.get(&tydesc);\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);\n     let mut r = Reflector {"}, {"sha": "a9381647b3326d64a3343bd91031c7c5555b4538", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -68,7 +68,7 @@ pub fn type_of_fn_from_ty(cx: @CrateContext, fty: ty::t) -> TypeRef {\n }\n \n pub fn type_of_non_gc_box(cx: @CrateContext, t: ty::t) -> TypeRef {\n-    fail_unless!(!ty::type_needs_infer(t));\n+    assert!(!ty::type_needs_infer(t));\n \n     let t_norm = ty::normalize_ty(cx.tcx, t);\n     if t != t_norm {"}, {"sha": "425f14b7c0707cba4a8d779df66fdcec92e45770", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -2005,7 +2005,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // If this assertion failures, it is likely because of a\n                 // failure in the cross-crate inlining code to translate a\n                 // def-id.\n-                fail_unless!(p.def_id.crate == ast::local_crate);\n+                assert!(p.def_id.crate == ast::local_crate);\n \n                 param_bounds_to_contents(\n                     cx, *cx.ty_param_bounds.get(&p.def_id.node))\n@@ -3559,7 +3559,7 @@ pub fn trait_supertraits(cx: ctxt,\n \n     // Not in the cache. It had better be in the metadata, which means it\n     // shouldn't be local.\n-    fail_unless!(!is_local(id));\n+    assert!(!is_local(id));\n \n     // Get the supertraits out of the metadata and create the\n     // InstantiatedTraitRef for each.\n@@ -3591,7 +3591,7 @@ pub fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n         // If the lookup in trait_method_cache fails, assume that the trait\n         // method we're trying to look up is in a different crate, and look\n         // for it there.\n-        fail_unless!(id.crate != ast::local_crate);\n+        assert!(id.crate != ast::local_crate);\n         let result = csearch::get_trait_methods(cx, id);\n \n         // Store the trait method in the local trait_method_cache so that\n@@ -3912,7 +3912,7 @@ pub fn lookup_item_type(cx: ctxt,\n         return tpt;\n       }\n       None => {\n-        fail_unless!(did.crate != ast::local_crate);\n+        assert!(did.crate != ast::local_crate);\n         let tyt = csearch::get_type(cx, did);\n         cx.tcache.insert(did, tyt);\n         return tyt;"}, {"sha": "697649a4187c24bff0f41b3ad60cd376e57affba", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -585,7 +585,7 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + Durable>(\n     // The caller should not both provide explicit bound lifetime\n     // names and expected types.  Either we infer the bound lifetime\n     // names or they are provided, but not both.\n-    fail_unless!(lifetimes.is_empty() || expected_sig.is_none());\n+    assert!(lifetimes.is_empty() || expected_sig.is_none());\n \n     debug!(\"ty_of_fn_decl\");\n     let _i = indenter();"}, {"sha": "f13964329579093925e5b18d89bec0d650dd74f8", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -1802,7 +1802,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         if check_completeness && !error_happened {\n             // Make sure the programmer specified all the fields.\n-            fail_unless!(fields_found <= field_types.len());\n+            assert!(fields_found <= field_types.len());\n             if fields_found < field_types.len() {\n                 let mut missing_fields = ~[];\n                 for field_types.each |class_field| {\n@@ -3412,8 +3412,8 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n       ~\"visit_tydesc\" => {\n           let tydesc_name = special_idents::tydesc;\n           let ty_visitor_name = tcx.sess.ident_of(~\"TyVisitor\");\n-          fail_unless!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n-          fail_unless!(ccx.tcx.intrinsic_defs.contains_key(&ty_visitor_name));\n+          assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n+          assert!(ccx.tcx.intrinsic_defs.contains_key(&ty_visitor_name));\n           let (_, tydesc_ty) = *tcx.intrinsic_defs.get(&tydesc_name);\n           let (_, visitor_trait) = *tcx.intrinsic_defs.get(&ty_visitor_name);\n "}, {"sha": "dfc5f218d67d0f15ec2757d4dac974adea1b0d03", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -712,7 +712,7 @@ pub mod guarantor {\n             ast::expr_copy(*) |\n             ast::expr_repeat(*) |\n             ast::expr_vec(*) => {\n-                fail_unless!(!ty::expr_is_lval(\n+                assert!(!ty::expr_is_lval(\n                     rcx.fcx.tcx(), rcx.fcx.inh.method_map, expr));\n                 None\n             }"}, {"sha": "a1eaa1f6a339406a3e21d83577bbf22b895e9682", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -181,7 +181,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n         Some(ty) => ty,\n         None => {\n             // fixup_ty can only fail if this is early resolution\n-            fail_unless!(is_early);\n+            assert!(is_early);\n             // The type has unconstrained type variables in it, so we can't\n             // do early resolution on it. Return some completely bogus vtable\n             // information: we aren't storing it anyways.\n@@ -367,7 +367,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                                                               is_early) {\n                                 Some(ref substs) => (/*bad*/copy *substs),\n                                 None => {\n-                                    fail_unless!(is_early);\n+                                    assert!(is_early);\n                                     // Bail out with a bogus answer\n                                     return Some(vtable_param(0, 0));\n                                 }"}, {"sha": "4fc9e8d19ae1f1a6e57515a047ff182bc382847d", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -797,7 +797,7 @@ pub impl CoherenceChecker {\n     }\n \n     fn span_of_impl(&self, implementation: @Impl) -> span {\n-        fail_unless!(implementation.did.crate == local_crate);\n+        assert!(implementation.did.crate == local_crate);\n         match self.crate_context.tcx.items.find(&implementation.did.node) {\n             Some(&node_item(item, _)) => {\n                 return item.span;"}, {"sha": "d8093d571a111920a8ccc8504427d7b0fbe5f1d6", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -586,7 +586,7 @@ pub impl InferCtxt {\n \n     /// Execute `f` and commit the bindings if successful\n     fn commit<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n-        fail_unless!(!self.in_snapshot());\n+        assert!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n         do indent {\n@@ -679,7 +679,7 @@ pub impl InferCtxt {\n         let region_var = self.next_region_var_nb(span);\n \n         // add lb_region as a lower bound on the newly built variable\n-        fail_unless!(self.region_vars.make_subregion(span,\n+        assert!(self.region_vars.make_subregion(span,\n                                                      lb_region,\n                                                      region_var).is_ok());\n "}, {"sha": "d9f00451dd57eeed665be11a9fccb8498071154d", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -671,7 +671,7 @@ pub impl RegionVarBindings {\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n-                fail_unless!(self.var_spans.len() == vid.to_uint() + 1);\n+                assert!(self.var_spans.len() == vid.to_uint() + 1);\n                 self.var_spans.pop();\n               }\n               AddConstraint(ref constraint) => {\n@@ -731,7 +731,7 @@ pub impl RegionVarBindings {\n \n     fn add_constraint(&mut self, +constraint: Constraint, span: span) {\n         // cannot add constraints once regions are resolved\n-        fail_unless!(self.values.is_empty());\n+        assert!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: add_constraint(%?)\", constraint);\n \n@@ -747,7 +747,7 @@ pub impl RegionVarBindings {\n                       sub: Region,\n                       sup: Region) -> cres<()> {\n         // cannot add constraints once regions are resolved\n-        fail_unless!(self.values.is_empty());\n+        assert!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: make_subregion(%?, %?)\", sub, sup);\n         match (sub, sup) {\n@@ -789,7 +789,7 @@ pub impl RegionVarBindings {\n                    b: Region)\n                 -> cres<Region> {\n         // cannot add constraints once regions are resolved\n-        fail_unless!(self.values.is_empty());\n+        assert!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: lub_regions(%?, %?)\", a, b);\n         match (a, b) {\n@@ -815,7 +815,7 @@ pub impl RegionVarBindings {\n                    b: Region)\n                 -> cres<Region> {\n         // cannot add constraints once regions are resolved\n-        fail_unless!(self.values.is_empty());\n+        assert!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: glb_regions(%?, %?)\", a, b);\n         match (a, b) {\n@@ -1359,7 +1359,7 @@ pub impl RegionVarBindings {\n \n         return match a_node.value {\n             NoValue => {\n-                fail_unless!(a_node.classification == Contracting);\n+                assert!(a_node.classification == Contracting);\n                 a_node.value = Value(b_region);\n                 true // changed\n             }\n@@ -1617,15 +1617,15 @@ pub impl RegionVarBindings {\n                   }\n \n                   ConstrainRegSubVar(region, _) => {\n-                    fail_unless!(dir == Incoming);\n+                    assert!(dir == Incoming);\n                     result.push(SpannedRegion {\n                         region: region,\n                         span: edge.span\n                     });\n                   }\n \n                   ConstrainVarSubReg(_, region) => {\n-                    fail_unless!(dir == Outgoing);\n+                    assert!(dir == Outgoing);\n                     result.push(SpannedRegion {\n                         region: region,\n                         span: edge.span"}, {"sha": "c208d1d24fc6297979b27d2cb49d22b42cf81455", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -114,9 +114,9 @@ pub impl ResolveState {\n         // n.b. This is a hokey mess because the current fold doesn't\n         // allow us to pass back errors in any useful way.\n \n-        fail_unless!(vec::is_empty(self.v_seen));\n+        assert!(vec::is_empty(self.v_seen));\n         let rty = indent(|| self.resolve_type(typ) );\n-        fail_unless!(vec::is_empty(self.v_seen));\n+        assert!(vec::is_empty(self.v_seen));\n         match self.err {\n           None => {\n             debug!(\"Resolved to %s + %s (modes=%x)\","}, {"sha": "52a0300c5a089655d1be6491929ae3c18f7e2215", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -110,7 +110,7 @@ pub impl Env {\n                       m: &ast::_mod,\n                       idx: uint,\n                       names: &[~str]) -> Option<ast::node_id> {\n-            fail_unless!(idx < names.len());\n+            assert!(idx < names.len());\n             for m.items.each |item| {\n                 if self.tcx.sess.str_of(item.ident) == names[idx] {\n                     return search(self, *item, idx+1, names);"}, {"sha": "75dac7fd7c5df61963c6fdf5e0496d1147106310", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -131,7 +131,7 @@ pub impl InferCtxt {\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n-            fail_unless!(node_a.rank == node_b.rank);\n+            assert!(node_a.rank == node_b.rank);\n             self.set(node_b.root, Redirect(node_a.root));\n             (node_a.root, node_a.rank + 1)\n         }"}, {"sha": "2df9884911e55ba97266c422a656444ac0ab5b5f", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -184,7 +184,7 @@ pub struct CrateCtxt {\n // Functions that write types into the node type table\n pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n     debug!(\"write_ty_to_tcx(%d, %s)\", node_id, ppaux::ty_to_str(tcx, ty));\n-    fail_unless!(!ty::type_needs_infer(ty));\n+    assert!(!ty::type_needs_infer(ty));\n     tcx.node_types.insert(node_id as uint, ty);\n }\n pub fn write_substs_to_tcx(tcx: ty::ctxt,\n@@ -193,7 +193,7 @@ pub fn write_substs_to_tcx(tcx: ty::ctxt,\n     if substs.len() > 0u {\n         debug!(\"write_substs_to_tcx(%d, %?)\", node_id,\n                substs.map(|t| ppaux::ty_to_str(tcx, *t)));\n-        fail_unless!(substs.all(|t| !ty::type_needs_infer(*t)));\n+        assert!(substs.all(|t| !ty::type_needs_infer(*t)));\n         tcx.node_type_substs.insert(node_id, substs);\n     }\n }"}, {"sha": "eeca90dbecd5dab63d4f35ba00ea5cf658bce12b", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -180,7 +180,7 @@ impl region_scope for MethodRscope {\n         })\n     }\n     fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n-        fail_unless!(self.variance.is_some() || self.self_ty.is_borrowed());\n+        assert!(self.variance.is_some() || self.self_ty.is_borrowed());\n         match self.variance {\n             None => {}  // must be borrowed self, so this is OK\n             Some(_) => {"}, {"sha": "3b905c612a5c64ee81ece657751f75896ca9e9bd", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -138,7 +138,7 @@ fn should_prune_unconfigured_items() {\n     let source = ~\"#[cfg(shut_up_and_leave_me_alone)]fn a() { }\";\n     do from_str(source) |srv| {\n         do exec(srv) |ctxt| {\n-            fail_unless!(vec::is_empty(ctxt.ast.node.module.items));\n+            assert!(vec::is_empty(ctxt.ast.node.module.items));\n         }\n     }\n }\n@@ -148,7 +148,7 @@ fn srv_should_build_ast_map() {\n     let source = ~\"fn a() { }\";\n     do from_str(source) |srv| {\n         do exec(srv) |ctxt| {\n-            fail_unless!(!ctxt.ast_map.is_empty())\n+            assert!(!ctxt.ast_map.is_empty())\n         };\n     }\n }\n@@ -164,6 +164,6 @@ fn srv_should_return_request_result() {\n     let source = ~\"fn a() { }\";\n     do from_str(source) |srv| {\n         let result = exec(srv, |_ctxt| 1000 );\n-        fail_unless!(result == 1000);\n+        assert!(result == 1000);\n     }\n }"}, {"sha": "213198e6f2158a07981e9248ac39cf060e116d6b", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -71,23 +71,23 @@ fn should_extract_crate_name_from_link_attribute() {\n     let source = ~\"#[link(name = \\\"snuggles\\\")]\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_crate(attrs);\n-    fail_unless!(attrs.name == Some(~\"snuggles\"));\n+    assert!(attrs.name == Some(~\"snuggles\"));\n }\n \n #[test]\n fn should_not_extract_crate_name_if_no_link_attribute() {\n     let source = ~\"\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_crate(attrs);\n-    fail_unless!(attrs.name == None);\n+    assert!(attrs.name == None);\n }\n \n #[test]\n fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n     let source = ~\"#[link(whatever)]\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_crate(attrs);\n-    fail_unless!(attrs.name == None);\n+    assert!(attrs.name == None);\n }\n \n pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n@@ -106,15 +106,15 @@ fn parse_desc_should_handle_undocumented_mods() {\n     let source = ~\"\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_desc(attrs);\n-    fail_unless!(attrs == None);\n+    assert!(attrs == None);\n }\n \n #[test]\n fn parse_desc_should_parse_simple_doc_attributes() {\n     let source = ~\"#[doc = \\\"basic\\\"]\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_desc(attrs);\n-    fail_unless!(attrs == Some(~\"basic\"));\n+    assert!(attrs == Some(~\"basic\"));\n }\n \n pub fn parse_hidden(attrs: ~[ast::attribute]) -> bool {\n@@ -133,28 +133,28 @@ pub fn parse_hidden(attrs: ~[ast::attribute]) -> bool {\n fn should_parse_hidden_attribute() {\n     let source = ~\"#[doc(hidden)]\";\n     let attrs = test::parse_attributes(source);\n-    fail_unless!(parse_hidden(attrs) == true);\n+    assert!(parse_hidden(attrs) == true);\n }\n \n #[test]\n fn should_parse_hidden_attribute_with_other_docs() {\n     let source = ~\"#[doc = \\\"foo\\\"] #[doc(hidden)] #[doc = \\\"foo\\\"]\";\n     let attrs = test::parse_attributes(source);\n-    fail_unless!(parse_hidden(attrs) == true);\n+    assert!(parse_hidden(attrs) == true);\n }\n \n #[test]\n fn should_not_parse_non_hidden_attribute() {\n     let source = ~\"#[doc = \\\"\\\"]\";\n     let attrs = test::parse_attributes(source);\n-    fail_unless!(parse_hidden(attrs) == false);\n+    assert!(parse_hidden(attrs) == false);\n }\n \n #[test]\n fn should_concatenate_multiple_doc_comments() {\n     let source = ~\"/// foo\\n/// bar\";\n     let desc = parse_desc(test::parse_attributes(source));\n-    fail_unless!(desc == Some(~\"foo\\nbar\"));\n+    assert!(desc == Some(~\"foo\\nbar\"));\n }\n \n "}, {"sha": "b550155140f0bee91946c04c82fd0991b5997fd5", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -81,7 +81,7 @@ fn fold_crate(\n #[test]\n fn should_replace_top_module_name_with_crate_name() {\n     let doc = test::mk_doc(~\"#[link(name = \\\"bond\\\")];\");\n-    fail_unless!(doc.cratemod().name() == ~\"bond\");\n+    assert!(doc.cratemod().name() == ~\"bond\");\n }\n \n fn fold_item(\n@@ -124,25 +124,25 @@ fn parse_item_attrs<T:Owned>(\n #[test]\n fn should_should_extract_mod_attributes() {\n     let doc = test::mk_doc(~\"#[doc = \\\"test\\\"] mod a { }\");\n-    fail_unless!(doc.cratemod().mods()[0].desc() == Some(~\"test\"));\n+    assert!(doc.cratemod().mods()[0].desc() == Some(~\"test\"));\n }\n \n #[test]\n fn should_extract_top_mod_attributes() {\n     let doc = test::mk_doc(~\"#[doc = \\\"test\\\"];\");\n-    fail_unless!(doc.cratemod().desc() == Some(~\"test\"));\n+    assert!(doc.cratemod().desc() == Some(~\"test\"));\n }\n \n #[test]\n fn should_extract_foreign_fn_attributes() {\n     let doc = test::mk_doc(~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-    fail_unless!(doc.cratemod().nmods()[0].fns[0].desc() == Some(~\"test\"));\n+    assert!(doc.cratemod().nmods()[0].fns[0].desc() == Some(~\"test\"));\n }\n \n #[test]\n fn should_extract_fn_attributes() {\n     let doc = test::mk_doc(~\"#[doc = \\\"test\\\"] fn a() -> int { }\");\n-    fail_unless!(doc.cratemod().fns()[0].desc() == Some(~\"test\"));\n+    assert!(doc.cratemod().fns()[0].desc() == Some(~\"test\"));\n }\n \n fn fold_enum(\n@@ -194,13 +194,13 @@ fn fold_enum(\n fn should_extract_enum_docs() {\n     let doc = test::mk_doc(~\"#[doc = \\\"b\\\"]\\\n                             enum a { v }\");\n-    fail_unless!(doc.cratemod().enums()[0].desc() == Some(~\"b\"));\n+    assert!(doc.cratemod().enums()[0].desc() == Some(~\"b\"));\n }\n \n #[test]\n fn should_extract_variant_docs() {\n     let doc = test::mk_doc(~\"enum a { #[doc = \\\"c\\\"] v }\");\n-    fail_unless!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"c\"));\n+    assert!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"c\"));\n }\n \n fn fold_trait(\n@@ -253,7 +253,7 @@ fn merge_method_attrs(\n     };\n \n     do vec::map2(docs, attrs) |doc, attrs| {\n-        fail_unless!(doc.name == attrs.first());\n+        assert!(doc.name == attrs.first());\n         let desc = attrs.second();\n \n         doc::MethodDoc {\n@@ -266,7 +266,7 @@ fn merge_method_attrs(\n #[test]\n fn should_extract_trait_docs() {\n     let doc = test::mk_doc(~\"#[doc = \\\"whatever\\\"] trait i { fn a(); }\");\n-    fail_unless!(doc.cratemod().traits()[0].desc() == Some(~\"whatever\"));\n+    assert!(doc.cratemod().traits()[0].desc() == Some(~\"whatever\"));\n }\n \n #[test]\n@@ -276,7 +276,7 @@ fn should_extract_trait_method_docs() {\n          #[doc = \\\"desc\\\"]\\\n          fn f(a: bool) -> bool;\\\n          }\");\n-    fail_unless!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"desc\"));\n+    assert!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"desc\"));\n }\n \n \n@@ -297,7 +297,7 @@ fn fold_impl(\n fn should_extract_impl_docs() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\"whatever\\\"] impl int { fn a() { } }\");\n-    fail_unless!(doc.cratemod().impls()[0].desc() == Some(~\"whatever\"));\n+    assert!(doc.cratemod().impls()[0].desc() == Some(~\"whatever\"));\n }\n \n #[test]\n@@ -307,7 +307,7 @@ fn should_extract_impl_method_docs() {\n          #[doc = \\\"desc\\\"]\\\n          fn f(a: bool) -> bool { }\\\n          }\");\n-    fail_unless!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"desc\"));\n+    assert!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"desc\"));\n }\n \n #[cfg(test)]"}, {"sha": "62ddec7a1199cd7b976423fd327c97803806194c", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -253,7 +253,7 @@ fn should_find_pandoc() {\n         ProgramOutput { status: 0, out: ~\"pandoc 1.8.2.1\", err: ~\"\" }\n     };\n     let result = maybe_find_pandoc(&config, None, mock_program_output);\n-    fail_unless!(result == result::Ok(Some(~\"pandoc\")));\n+    assert!(result == result::Ok(Some(~\"pandoc\")));\n }\n \n #[test]\n@@ -266,7 +266,7 @@ fn should_error_with_no_pandoc() {\n         ProgramOutput { status: 1, out: ~\"\", err: ~\"\" }\n     };\n     let result = maybe_find_pandoc(&config, None, mock_program_output);\n-    fail_unless!(result == result::Err(~\"couldn't find pandoc\"));\n+    assert!(result == result::Err(~\"couldn't find pandoc\"));\n }\n \n #[cfg(test)]\n@@ -283,100 +283,100 @@ mod test {\n #[test]\n fn should_error_with_no_crates() {\n     let config = test::parse_config(~[~\"rustdoc\"]);\n-    fail_unless!(config.get_err() == ~\"no crates specified\");\n+    assert!(config.get_err() == ~\"no crates specified\");\n }\n \n #[test]\n fn should_error_with_multiple_crates() {\n     let config =\n         test::parse_config(~[~\"rustdoc\", ~\"crate1.rc\", ~\"crate2.rc\"]);\n-    fail_unless!(config.get_err() == ~\"multiple crates specified\");\n+    assert!(config.get_err() == ~\"multiple crates specified\");\n }\n \n #[test]\n fn should_set_output_dir_to_cwd_if_not_provided() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    fail_unless!(config.get().output_dir == Path(\".\"));\n+    assert!(config.get().output_dir == Path(\".\"));\n }\n \n #[test]\n fn should_set_output_dir_if_provided() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-dir\", ~\"snuggles\"\n     ]);\n-    fail_unless!(config.get().output_dir == Path(\"snuggles\"));\n+    assert!(config.get().output_dir == Path(\"snuggles\"));\n }\n \n #[test]\n fn should_set_output_format_to_pandoc_html_if_not_provided() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    fail_unless!(config.get().output_format == PandocHtml);\n+    assert!(config.get().output_format == PandocHtml);\n }\n \n #[test]\n fn should_set_output_format_to_markdown_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"markdown\"\n     ]);\n-    fail_unless!(config.get().output_format == Markdown);\n+    assert!(config.get().output_format == Markdown);\n }\n \n #[test]\n fn should_set_output_format_to_pandoc_html_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"html\"\n     ]);\n-    fail_unless!(config.get().output_format == PandocHtml);\n+    assert!(config.get().output_format == PandocHtml);\n }\n \n #[test]\n fn should_error_on_bogus_format() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"bogus\"\n     ]);\n-    fail_unless!(config.get_err() == ~\"unknown output format 'bogus'\");\n+    assert!(config.get_err() == ~\"unknown output format 'bogus'\");\n }\n \n #[test]\n fn should_set_output_style_to_doc_per_mod_by_default() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    fail_unless!(config.get().output_style == DocPerMod);\n+    assert!(config.get().output_style == DocPerMod);\n }\n \n #[test]\n fn should_set_output_style_to_one_doc_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-crate\"\n     ]);\n-    fail_unless!(config.get().output_style == DocPerCrate);\n+    assert!(config.get().output_style == DocPerCrate);\n }\n \n #[test]\n fn should_set_output_style_to_doc_per_mod_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-mod\"\n     ]);\n-    fail_unless!(config.get().output_style == DocPerMod);\n+    assert!(config.get().output_style == DocPerMod);\n }\n \n #[test]\n fn should_error_on_bogus_output_style() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"bogus\"\n     ]);\n-    fail_unless!(config.get_err() == ~\"unknown output style 'bogus'\");\n+    assert!(config.get_err() == ~\"unknown output style 'bogus'\");\n }\n \n #[test]\n fn should_set_pandoc_command_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--pandoc-cmd\", ~\"panda-bear-doc\"\n     ]);\n-    fail_unless!(config.get().pandoc_cmd == Some(~\"panda-bear-doc\"));\n+    assert!(config.get().pandoc_cmd == Some(~\"panda-bear-doc\"));\n }\n \n #[test]\n fn should_set_pandoc_command_when_using_pandoc() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    fail_unless!(config.get().pandoc_cmd == Some(~\"pandoc\"));\n+    assert!(config.get().pandoc_cmd == Some(~\"pandoc\"));\n }"}, {"sha": "7c50af40f337a0d3c6466cae5a6f8164d7c75b53", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -84,21 +84,21 @@ fn fold_impl(fold: &fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n #[test]\n fn should_promote_desc() {\n     let doc = test::mk_doc(~\"#[doc = \\\"desc\\\"] mod m { }\");\n-    fail_unless!(doc.cratemod().mods()[0].brief() == Some(~\"desc\"));\n+    assert!(doc.cratemod().mods()[0].brief() == Some(~\"desc\"));\n }\n \n #[test]\n fn should_promote_trait_method_desc() {\n     let doc = test::mk_doc(~\"trait i { #[doc = \\\"desc\\\"] fn a(); }\");\n-    fail_unless!(doc.cratemod().traits()[0].methods[0].brief ==\n+    assert!(doc.cratemod().traits()[0].methods[0].brief ==\n         Some(~\"desc\"));\n }\n \n #[test]\n fn should_promote_impl_method_desc() {\n     let doc = test::mk_doc(\n         ~\"impl int { #[doc = \\\"desc\\\"] fn a() { } }\");\n-    fail_unless!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"desc\"));\n+    assert!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"desc\"));\n }\n \n #[cfg(test)]\n@@ -222,20 +222,20 @@ fn paragraphs(s: &str) -> ~[~str] {\n #[test]\n fn test_paragraphs_1() {\n     let paras = paragraphs(~\"1\\n\\n2\");\n-    fail_unless!(paras == ~[~\"1\", ~\"2\"]);\n+    assert!(paras == ~[~\"1\", ~\"2\"]);\n }\n \n #[test]\n fn test_paragraphs_2() {\n     let paras = paragraphs(~\"\\n\\n1\\n1\\n\\n2\\n\\n\");\n-    fail_unless!(paras == ~[~\"1\\n1\", ~\"2\"]);\n+    assert!(paras == ~[~\"1\\n1\", ~\"2\"]);\n }\n \n #[test]\n fn should_promote_short_descs() {\n     let desc = Some(~\"desc\");\n     let brief = extract(copy desc);\n-    fail_unless!(brief == desc);\n+    assert!(brief == desc);\n }\n \n #[test]\n@@ -249,7 +249,7 @@ Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n     let brief = extract(desc);\n-    fail_unless!(brief == None);\n+    assert!(brief == None);\n }\n \n #[test]\n@@ -263,7 +263,7 @@ Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n     let brief = extract(desc);\n-    fail_unless!(brief == Some(\n+    assert!(brief == Some(\n         ~\"Warkworth Castle is a ruined medieval building in the town\"));\n }\n \n@@ -278,7 +278,7 @@ Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n     let brief = extract(desc);\n-    fail_unless!(brief == Some(\n+    assert!(brief == Some(\n         ~\"Warkworth..Castle is a ruined medieval building in the town\"));\n }\n \n@@ -293,6 +293,6 @@ Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n     let brief = extract(desc);\n-    fail_unless!(brief == Some(\n+    assert!(brief == Some(\n         ~\"Warkworth... Castle is a ruined medieval building in the town\"));\n }"}, {"sha": "949573be05ebb433be25823cbd6b8a1f4ccf6f78", "filename": "src/librustdoc/escape_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fescape_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fescape_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fescape_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -27,5 +27,5 @@ fn escape(s: &str) -> ~str {\n fn should_escape_backslashes() {\n     let s = ~\"\\\\n\";\n     let r = escape(s);\n-    fail_unless!(r == ~\"\\\\\\\\n\");\n+    assert!(r == ~\"\\\\\\\\n\");\n }"}, {"sha": "1d6d569e1c29dde0286c6f165c548da52715bb42", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -185,8 +185,8 @@ fn constdoc_from_const(itemdoc: doc::ItemDoc) -> doc::ConstDoc {\n #[test]\n fn should_extract_const_name_and_id() {\n     let doc = test::mk_doc(~\"static a: int = 0;\");\n-    fail_unless!(doc.cratemod().consts()[0].id() != 0);\n-    fail_unless!(doc.cratemod().consts()[0].name() == ~\"a\");\n+    assert!(doc.cratemod().consts()[0].id() != 0);\n+    assert!(doc.cratemod().consts()[0].name() == ~\"a\");\n }\n \n fn enumdoc_from_enum(\n@@ -216,14 +216,14 @@ fn variantdoc_from_variant(variant: &ast::variant) -> doc::VariantDoc {\n #[test]\n fn should_extract_enums() {\n     let doc = test::mk_doc(~\"enum e { v }\");\n-    fail_unless!(doc.cratemod().enums()[0].id() != 0);\n-    fail_unless!(doc.cratemod().enums()[0].name() == ~\"e\");\n+    assert!(doc.cratemod().enums()[0].id() != 0);\n+    assert!(doc.cratemod().enums()[0].name() == ~\"e\");\n }\n \n #[test]\n fn should_extract_enum_variants() {\n     let doc = test::mk_doc(~\"enum e { v }\");\n-    fail_unless!(doc.cratemod().enums()[0].variants[0].name == ~\"v\");\n+    assert!(doc.cratemod().enums()[0].variants[0].name == ~\"v\");\n }\n \n fn traitdoc_from_trait(\n@@ -262,13 +262,13 @@ fn traitdoc_from_trait(\n #[test]\n fn should_extract_traits() {\n     let doc = test::mk_doc(~\"trait i { fn f(); }\");\n-    fail_unless!(doc.cratemod().traits()[0].name() == ~\"i\");\n+    assert!(doc.cratemod().traits()[0].name() == ~\"i\");\n }\n \n #[test]\n fn should_extract_trait_methods() {\n     let doc = test::mk_doc(~\"trait i { fn f(); }\");\n-    fail_unless!(doc.cratemod().traits()[0].methods[0].name == ~\"f\");\n+    assert!(doc.cratemod().traits()[0].methods[0].name == ~\"f\");\n }\n \n fn impldoc_from_impl(\n@@ -296,7 +296,7 @@ fn impldoc_from_impl(\n #[test]\n fn should_extract_impl_methods() {\n     let doc = test::mk_doc(~\"impl int { fn f() { } }\");\n-    fail_unless!(doc.cratemod().impls()[0].methods[0].name == ~\"f\");\n+    assert!(doc.cratemod().impls()[0].methods[0].name == ~\"f\");\n }\n \n fn tydoc_from_ty(\n@@ -311,7 +311,7 @@ fn tydoc_from_ty(\n #[test]\n fn should_extract_tys() {\n     let doc = test::mk_doc(~\"type a = int;\");\n-    fail_unless!(doc.cratemod().types()[0].name() == ~\"a\");\n+    assert!(doc.cratemod().types()[0].name() == ~\"a\");\n }\n \n fn structdoc_from_struct(\n@@ -333,13 +333,13 @@ fn structdoc_from_struct(\n #[test]\n fn should_extract_structs() {\n     let doc = test::mk_doc(~\"struct Foo { field: () }\");\n-    fail_unless!(doc.cratemod().structs()[0].name() == ~\"Foo\");\n+    assert!(doc.cratemod().structs()[0].name() == ~\"Foo\");\n }\n \n #[test]\n fn should_extract_struct_fields() {\n     let doc = test::mk_doc(~\"struct Foo { field: () }\");\n-    fail_unless!(doc.cratemod().structs()[0].fields[0] == ~\"field\");\n+    assert!(doc.cratemod().structs()[0].fields[0] == ~\"field\");\n }\n \n #[cfg(test)]\n@@ -359,35 +359,35 @@ mod test {\n     #[test]\n     pub fn extract_empty_crate() {\n         let doc = mk_doc(~\"\");\n-        fail_unless!(vec::is_empty(doc.cratemod().mods()));\n-        fail_unless!(vec::is_empty(doc.cratemod().fns()));\n+        assert!(vec::is_empty(doc.cratemod().mods()));\n+        assert!(vec::is_empty(doc.cratemod().fns()));\n     }\n \n     #[test]\n     pub fn extract_mods() {\n         let doc = mk_doc(~\"mod a { mod b { } mod c { } }\");\n-        fail_unless!(doc.cratemod().mods()[0].name() == ~\"a\");\n-        fail_unless!(doc.cratemod().mods()[0].mods()[0].name() == ~\"b\");\n-        fail_unless!(doc.cratemod().mods()[0].mods()[1].name() == ~\"c\");\n+        assert!(doc.cratemod().mods()[0].name() == ~\"a\");\n+        assert!(doc.cratemod().mods()[0].mods()[0].name() == ~\"b\");\n+        assert!(doc.cratemod().mods()[0].mods()[1].name() == ~\"c\");\n     }\n \n     #[test]\n     pub fn extract_fns_from_foreign_mods() {\n         let doc = mk_doc(~\"extern { fn a(); }\");\n-        fail_unless!(doc.cratemod().nmods()[0].fns[0].name() == ~\"a\");\n+        assert!(doc.cratemod().nmods()[0].fns[0].name() == ~\"a\");\n     }\n \n     #[test]\n     pub fn extract_mods_deep() {\n         let doc = mk_doc(~\"mod a { mod b { mod c { } } }\");\n-        fail_unless!(doc.cratemod().mods()[0].mods()[0].mods()[0].name() ==\n+        assert!(doc.cratemod().mods()[0].mods()[0].mods()[0].name() ==\n             ~\"c\");\n     }\n \n     #[test]\n     pub fn extract_should_set_mod_ast_id() {\n         let doc = mk_doc(~\"mod a { }\");\n-        fail_unless!(doc.cratemod().mods()[0].id() != 0);\n+        assert!(doc.cratemod().mods()[0].id() != 0);\n     }\n \n     #[test]\n@@ -396,30 +396,30 @@ mod test {\n             ~\"fn a() { } \\\n               mod b { fn c() {\n              } }\");\n-        fail_unless!(doc.cratemod().fns()[0].name() == ~\"a\");\n-        fail_unless!(doc.cratemod().mods()[0].fns()[0].name() == ~\"c\");\n+        assert!(doc.cratemod().fns()[0].name() == ~\"a\");\n+        assert!(doc.cratemod().mods()[0].fns()[0].name() == ~\"c\");\n     }\n \n     #[test]\n     pub fn extract_should_set_fn_ast_id() {\n         let doc = mk_doc(~\"fn a() { }\");\n-        fail_unless!(doc.cratemod().fns()[0].id() != 0);\n+        assert!(doc.cratemod().fns()[0].id() != 0);\n     }\n \n     #[test]\n     pub fn extract_should_use_default_crate_name() {\n         let source = ~\"\";\n         let ast = parse::from_str(source);\n         let doc = extract(ast, ~\"burp\");\n-        fail_unless!(doc.cratemod().name() == ~\"burp\");\n+        assert!(doc.cratemod().name() == ~\"burp\");\n     }\n \n     #[test]\n     pub fn extract_from_seq_srv() {\n         let source = ~\"\";\n         do astsrv::from_str(source) |srv| {\n             let doc = from_srv(srv, ~\"name\");\n-            fail_unless!(doc.cratemod().name() == ~\"name\");\n+            assert!(doc.cratemod().name() == ~\"name\");\n         }\n     }\n }"}, {"sha": "d2f97b66bb6527201dc141b8396f0c21aa485517", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -373,7 +373,7 @@ fn default_fold_should_produce_same_doc() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    fail_unless!(doc == folded);\n+    assert!(doc == folded);\n }\n \n #[test]\n@@ -383,7 +383,7 @@ fn default_fold_should_produce_same_consts() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    fail_unless!(doc == folded);\n+    assert!(doc == folded);\n }\n \n #[test]\n@@ -393,7 +393,7 @@ fn default_fold_should_produce_same_enums() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    fail_unless!(doc == folded);\n+    assert!(doc == folded);\n }\n \n #[test]\n@@ -403,5 +403,5 @@ fn default_parallel_fold_should_produce_same_doc() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_par_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    fail_unless!(doc == folded);\n+    assert!(doc == folded);\n }"}, {"sha": "55901b4904aa32879783194ca6c9942aa0f41e6d", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -164,27 +164,27 @@ fn pandoc_header_id(header: &str) -> ~str {\n \n #[test]\n fn should_remove_punctuation_from_headers() {\n-    fail_unless!(pandoc_header_id(~\"impl foo of bar<A>\") ==\n+    assert!(pandoc_header_id(~\"impl foo of bar<A>\") ==\n         ~\"impl-foo-of-bara\");\n-    fail_unless!(pandoc_header_id(~\"impl of num::num for int\")\n+    assert!(pandoc_header_id(~\"impl of num::num for int\")\n         == ~\"impl-of-numnum-for-int\");\n-    fail_unless!(pandoc_header_id(~\"impl of num::num for int/&\")\n+    assert!(pandoc_header_id(~\"impl of num::num for int/&\")\n         == ~\"impl-of-numnum-for-int\");\n-    fail_unless!(pandoc_header_id(~\"impl of num::num for ^int\")\n+    assert!(pandoc_header_id(~\"impl of num::num for ^int\")\n         == ~\"impl-of-numnum-for-int\");\n-    fail_unless!(pandoc_header_id(~\"impl for & condvar\")\n+    assert!(pandoc_header_id(~\"impl for & condvar\")\n         == ~\"impl-for-condvar\");\n-    fail_unless!(pandoc_header_id(~\"impl of Select<T, U> for (Left, Right)\")\n+    assert!(pandoc_header_id(~\"impl of Select<T, U> for (Left, Right)\")\n                  == ~\"impl-of-selectt-u-for-left-right\");\n-    fail_unless!(pandoc_header_id(~\"impl of Condition<'self, T, U>\")\n+    assert!(pandoc_header_id(~\"impl of Condition<'self, T, U>\")\n                  == ~\"impl-of-conditionself-t-u\");\n-    fail_unless!(pandoc_header_id(~\"impl of Condition<T: Copy + Clone>\")\n+    assert!(pandoc_header_id(~\"impl of Condition<T: Copy + Clone>\")\n                  == ~\"impl-of-conditiont-copy-clone\");\n }\n \n #[test]\n fn should_trim_whitespace_after_removing_punctuation() {\n-    fail_unless!(pandoc_header_id(\"impl foo for ()\") == ~\"impl-foo-for\");\n+    assert!(pandoc_header_id(\"impl foo for ()\") == ~\"impl-foo-for\");\n }\n \n #[test]\n@@ -193,13 +193,13 @@ fn should_index_mod_contents() {\n         config::DocPerCrate,\n         ~\"mod a { } fn b() { }\"\n     );\n-    fail_unless!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+    assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n         kind: ~\"Module\",\n         name: ~\"a\",\n         brief: None,\n         link: ~\"#module-a\"\n     });\n-    fail_unless!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n+    assert!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n         kind: ~\"Function\",\n         name: ~\"b\",\n         brief: None,\n@@ -213,13 +213,13 @@ fn should_index_mod_contents_multi_page() {\n         config::DocPerMod,\n         ~\"mod a { } fn b() { }\"\n     );\n-    fail_unless!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+    assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n         kind: ~\"Module\",\n         name: ~\"a\",\n         brief: None,\n         link: ~\"a.html\"\n     });\n-    fail_unless!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n+    assert!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n         kind: ~\"Function\",\n         name: ~\"b\",\n         brief: None,\n@@ -233,7 +233,7 @@ fn should_index_foreign_mod_pages() {\n         config::DocPerMod,\n         ~\"extern mod a { }\"\n     );\n-    fail_unless!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+    assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n         kind: ~\"Foreign module\",\n         name: ~\"a\",\n         brief: None,\n@@ -247,7 +247,7 @@ fn should_add_brief_desc_to_index() {\n         config::DocPerMod,\n         ~\"#[doc = \\\"test\\\"] mod a { }\"\n     );\n-    fail_unless!((&doc.cratemod().index).get().entries[0].brief\n+    assert!((&doc.cratemod().index).get().entries[0].brief\n         == Some(~\"test\"));\n }\n \n@@ -257,7 +257,7 @@ fn should_index_foreign_mod_contents() {\n         config::DocPerCrate,\n         ~\"extern mod a { fn b(); }\"\n     );\n-    fail_unless!((&doc.cratemod().nmods()[0].index).get().entries[0]\n+    assert!((&doc.cratemod().nmods()[0].index).get().entries[0]\n         == doc::IndexEntry {\n         kind: ~\"Function\",\n         name: ~\"b\","}, {"sha": "8c4cd26bb7c119aaf2467fd2fc0e82f5085fbd2c", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -91,9 +91,9 @@ fn should_write_modules_last() {\n     let idx_c = str::find_str(markdown, ~\"# Module `c`\").get();\n     let idx_d = str::find_str(markdown, ~\"## Function `d`\").get();\n \n-    fail_unless!(idx_b < idx_d);\n-    fail_unless!(idx_d < idx_a);\n-    fail_unless!(idx_a < idx_c);\n+    assert!(idx_b < idx_d);\n+    assert!(idx_d < idx_a);\n+    assert!(idx_a < idx_c);\n }\n \n struct Ctxt {\n@@ -175,10 +175,10 @@ fn should_write_title_for_each_page() {\n         let (page, markdown) = po.recv();\n         match page {\n           doc::CratePage(_) => {\n-            fail_unless!(str::contains(markdown, ~\"% Crate core\"));\n+            assert!(str::contains(markdown, ~\"% Crate core\"));\n           }\n           doc::ItemPage(_) => {\n-            fail_unless!(str::contains(markdown, ~\"% Module a\"));\n+            assert!(str::contains(markdown, ~\"% Module a\"));\n           }\n         }\n     }\n@@ -248,7 +248,7 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n         fullpath\n       }\n       &doc::ImplTag(ref doc) => {\n-        fail_unless!(doc.self_ty.is_some());\n+        assert!(doc.self_ty.is_some());\n           let bounds = if (&doc.bounds_str).is_some() {\n               fmt!(\" where %s\", (&doc.bounds_str).get())\n           } else {\n@@ -326,7 +326,7 @@ fn write_mod(\n #[test]\n fn should_write_full_path_to_mod() {\n     let markdown = test::render(~\"mod a { mod b { mod c { } } }\");\n-    fail_unless!(str::contains(markdown, ~\"# Module `a::b::c`\"));\n+    assert!(str::contains(markdown, ~\"# Module `a::b::c`\"));\n }\n \n fn write_common(\n@@ -371,7 +371,7 @@ fn should_write_sections() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    fail_unless!(str::contains(markdown, ~\"#### Header\\n\\nBody\\n\\n\"));\n+    assert!(str::contains(markdown, ~\"#### Header\\n\\nBody\\n\\n\"));\n }\n \n fn write_mod_contents(\n@@ -428,7 +428,7 @@ fn item_header_lvl(doc: &doc::ItemTag) -> Hlvl {\n #[test]\n fn should_write_crate_description() {\n     let markdown = test::render(~\"#[doc = \\\"this is the crate\\\"];\");\n-    fail_unless!(str::contains(markdown, ~\"this is the crate\"));\n+    assert!(str::contains(markdown, ~\"this is the crate\"));\n }\n \n fn write_index(ctxt: &Ctxt, index: doc::Index) {\n@@ -457,7 +457,7 @@ fn write_index(ctxt: &Ctxt, index: doc::Index) {\n #[test]\n fn should_write_index() {\n     let markdown = test::render(~\"mod a { } mod b { }\");\n-    fail_unless!(str::contains(\n+    assert!(str::contains(\n         markdown,\n         ~\"\\n\\n* [Module `a`](#module-a)\\n\\\n          * [Module `b`](#module-b)\\n\\n\"\n@@ -467,19 +467,19 @@ fn should_write_index() {\n #[test]\n fn should_write_index_brief() {\n     let markdown = test::render(~\"#[doc = \\\"test\\\"] mod a { }\");\n-    fail_unless!(str::contains(markdown, ~\"(#module-a) - test\\n\"));\n+    assert!(str::contains(markdown, ~\"(#module-a) - test\\n\"));\n }\n \n #[test]\n fn should_not_write_index_if_no_entries() {\n     let markdown = test::render(~\"\");\n-    fail_unless!(!str::contains(markdown, ~\"\\n\\n\\n\"));\n+    assert!(!str::contains(markdown, ~\"\\n\\n\\n\"));\n }\n \n #[test]\n fn should_write_index_for_foreign_mods() {\n     let markdown = test::render(~\"extern mod a { fn a(); }\");\n-    fail_unless!(str::contains(\n+    assert!(str::contains(\n         markdown,\n         ~\"\\n\\n* [Function `a`](#function-a)\\n\\n\"\n     ));\n@@ -500,22 +500,22 @@ fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n #[test]\n fn should_write_foreign_mods() {\n     let markdown = test::render(~\"#[doc = \\\"test\\\"] extern mod a { }\");\n-    fail_unless!(str::contains(markdown, ~\"Foreign module `a`\"));\n-    fail_unless!(str::contains(markdown, ~\"test\"));\n+    assert!(str::contains(markdown, ~\"Foreign module `a`\"));\n+    assert!(str::contains(markdown, ~\"test\"));\n }\n \n #[test]\n fn should_write_foreign_fns() {\n     let markdown = test::render(\n         ~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n-    fail_unless!(str::contains(markdown, ~\"test\"));\n+    assert!(str::contains(markdown, ~\"test\"));\n }\n \n #[test]\n fn should_write_foreign_fn_headers() {\n     let markdown = test::render(\n         ~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n-    fail_unless!(str::contains(markdown, ~\"## Function `a`\"));\n+    assert!(str::contains(markdown, ~\"## Function `a`\"));\n }\n \n fn write_fn(\n@@ -561,19 +561,19 @@ fn code_block_indent(s: ~str) -> ~str {\n #[test]\n fn write_markdown_should_write_function_header() {\n     let markdown = test::render(~\"fn func() { }\");\n-    fail_unless!(str::contains(markdown, ~\"## Function `func`\"));\n+    assert!(str::contains(markdown, ~\"## Function `func`\"));\n }\n \n #[test]\n fn should_write_the_function_signature() {\n     let markdown = test::render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-    fail_unless!(str::contains(markdown, ~\"\\n    fn a()\\n\"));\n+    assert!(str::contains(markdown, ~\"\\n    fn a()\\n\"));\n }\n \n #[test]\n fn should_insert_blank_line_after_fn_signature() {\n     let markdown = test::render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-    fail_unless!(str::contains(markdown, ~\"fn a()\\n\\n\"));\n+    assert!(str::contains(markdown, ~\"fn a()\\n\\n\"));\n }\n \n #[test]\n@@ -594,13 +594,13 @@ fn should_correctly_indent_fn_signature() {\n         ]\n     };\n     let markdown = test::write_markdown_str(doc);\n-    fail_unless!(str::contains(markdown, ~\"    line 1\\n    line 2\"));\n+    assert!(str::contains(markdown, ~\"    line 1\\n    line 2\"));\n }\n \n #[test]\n fn should_leave_blank_line_between_fn_header_and_sig() {\n     let markdown = test::render(~\"fn a() { }\");\n-    fail_unless!(str::contains(markdown, ~\"Function `a`\\n\\n    fn a()\"));\n+    assert!(str::contains(markdown, ~\"Function `a`\\n\\n    fn a()\"));\n }\n \n fn write_const(\n@@ -614,15 +614,15 @@ fn write_const(\n #[test]\n fn should_write_const_header() {\n     let markdown = test::render(~\"static a: bool = true;\");\n-    fail_unless!(str::contains(markdown, ~\"## Const `a`\\n\\n\"));\n+    assert!(str::contains(markdown, ~\"## Const `a`\\n\\n\"));\n }\n \n #[test]\n fn should_write_const_description() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"b\\\"]\\\n          static a: bool = true;\");\n-    fail_unless!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n+    assert!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n }\n \n fn write_enum(\n@@ -636,14 +636,14 @@ fn write_enum(\n #[test]\n fn should_write_enum_header() {\n     let markdown = test::render(~\"enum a { b }\");\n-    fail_unless!(str::contains(markdown, ~\"## Enum `a`\\n\\n\"));\n+    assert!(str::contains(markdown, ~\"## Enum `a`\\n\\n\"));\n }\n \n #[test]\n fn should_write_enum_description() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"b\\\"] enum a { b }\");\n-    fail_unless!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n+    assert!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n }\n \n fn write_variants(\n@@ -664,7 +664,7 @@ fn write_variants(\n }\n \n fn write_variant(ctxt: &Ctxt, doc: doc::VariantDoc) {\n-    fail_unless!(doc.sig.is_some());\n+    assert!(doc.sig.is_some());\n     let sig = (&doc.sig).get();\n     match copy doc.desc {\n       Some(desc) => {\n@@ -682,7 +682,7 @@ fn should_write_variant_list() {\n         ~\"enum a { \\\n          #[doc = \\\"test\\\"] b, \\\n          #[doc = \\\"test\\\"] c }\");\n-    fail_unless!(str::contains(\n+    assert!(str::contains(\n         markdown,\n         ~\"\\n\\n#### Variants\\n\\\n          \\n* `b` - test\\\n@@ -692,7 +692,7 @@ fn should_write_variant_list() {\n #[test]\n fn should_write_variant_list_without_descs() {\n     let markdown = test::render(~\"enum a { b, c }\");\n-    fail_unless!(str::contains(\n+    assert!(str::contains(\n         markdown,\n         ~\"\\n\\n#### Variants\\n\\\n          \\n* `b`\\\n@@ -702,7 +702,7 @@ fn should_write_variant_list_without_descs() {\n #[test]\n fn should_write_variant_list_with_signatures() {\n     let markdown = test::render(~\"enum a { b(int), #[doc = \\\"a\\\"] c(int) }\");\n-    fail_unless!(str::contains(\n+    assert!(str::contains(\n         markdown,\n         ~\"\\n\\n#### Variants\\n\\\n          \\n* `b(int)`\\\n@@ -733,28 +733,28 @@ fn write_method(ctxt: &Ctxt, doc: doc::MethodDoc) {\n #[test]\n fn should_write_trait_header() {\n     let markdown = test::render(~\"trait i { fn a(); }\");\n-    fail_unless!(str::contains(markdown, ~\"## Trait `i`\"));\n+    assert!(str::contains(markdown, ~\"## Trait `i`\"));\n }\n \n #[test]\n fn should_write_trait_desc() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"desc\\\"] trait i { fn a(); }\");\n-    fail_unless!(str::contains(markdown, ~\"desc\"));\n+    assert!(str::contains(markdown, ~\"desc\"));\n }\n \n #[test]\n fn should_write_trait_method_header() {\n     let markdown = test::render(\n         ~\"trait i { fn a(); }\");\n-    fail_unless!(str::contains(markdown, ~\"### Method `a`\"));\n+    assert!(str::contains(markdown, ~\"### Method `a`\"));\n }\n \n #[test]\n fn should_write_trait_method_signature() {\n     let markdown = test::render(\n         ~\"trait i { fn a(&self); }\");\n-    fail_unless!(str::contains(markdown, ~\"\\n    fn a(&self)\"));\n+    assert!(str::contains(markdown, ~\"\\n    fn a(&self)\"));\n }\n \n fn write_impl(ctxt: &Ctxt, doc: doc::ImplDoc) {\n@@ -765,41 +765,41 @@ fn write_impl(ctxt: &Ctxt, doc: doc::ImplDoc) {\n #[test]\n fn should_write_impl_header() {\n     let markdown = test::render(~\"impl int { fn a() { } }\");\n-    fail_unless!(str::contains(markdown, ~\"## Implementation for `int`\"));\n+    assert!(str::contains(markdown, ~\"## Implementation for `int`\"));\n }\n \n #[test]\n fn should_write_impl_header_with_bounds() {\n     let markdown = test::render(~\"impl <T> int<T> { }\");\n-    fail_unless!(str::contains(markdown, ~\"## Implementation for `int<T>` where `<T>`\"));\n+    assert!(str::contains(markdown, ~\"## Implementation for `int<T>` where `<T>`\"));\n }\n \n #[test]\n fn should_write_impl_header_with_trait() {\n     let markdown = test::render(~\"impl j for int { fn a() { } }\");\n-    fail_unless!(str::contains(markdown,\n+    assert!(str::contains(markdown,\n         ~\"## Implementation of `j` for `int`\"));\n }\n \n #[test]\n fn should_write_impl_desc() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"desc\\\"] impl int { fn a() { } }\");\n-    fail_unless!(str::contains(markdown, ~\"desc\"));\n+    assert!(str::contains(markdown, ~\"desc\"));\n }\n \n #[test]\n fn should_write_impl_method_header() {\n     let markdown = test::render(\n         ~\"impl int { fn a() { } }\");\n-    fail_unless!(str::contains(markdown, ~\"### Method `a`\"));\n+    assert!(str::contains(markdown, ~\"### Method `a`\"));\n }\n \n #[test]\n fn should_write_impl_method_signature() {\n     let markdown = test::render(\n         ~\"impl int { fn a(&mut self) { } }\");\n-    fail_unless!(str::contains(markdown, ~\"\\n    fn a(&mut self)\"));\n+    assert!(str::contains(markdown, ~\"\\n    fn a(&mut self)\"));\n }\n \n fn write_type(\n@@ -813,20 +813,20 @@ fn write_type(\n #[test]\n fn should_write_type_header() {\n     let markdown = test::render(~\"type t = int;\");\n-    fail_unless!(str::contains(markdown, ~\"## Type `t`\"));\n+    assert!(str::contains(markdown, ~\"## Type `t`\"));\n }\n \n #[test]\n fn should_write_type_desc() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"desc\\\"] type t = int;\");\n-    fail_unless!(str::contains(markdown, ~\"\\n\\ndesc\\n\\n\"));\n+    assert!(str::contains(markdown, ~\"\\n\\ndesc\\n\\n\"));\n }\n \n #[test]\n fn should_write_type_signature() {\n     let markdown = test::render(~\"type t = int;\");\n-    fail_unless!(str::contains(markdown, ~\"\\n\\n    type t = int\\n\\n\"));\n+    assert!(str::contains(markdown, ~\"\\n\\n    type t = int\\n\\n\"));\n }\n \n fn put_struct(\n@@ -840,7 +840,7 @@ fn put_struct(\n #[test]\n fn should_put_struct_header() {\n     let markdown = test::render(~\"struct S { field: () }\");\n-    fail_unless!(str::contains(markdown, ~\"## Struct `S`\\n\\n\"));\n+    assert!(str::contains(markdown, ~\"## Struct `S`\\n\\n\"));\n }\n \n #[cfg(test)]\n@@ -927,12 +927,12 @@ mod test {\n     #[test]\n     pub fn write_markdown_should_write_mod_headers() {\n         let markdown = render(~\"mod moo { }\");\n-        fail_unless!(str::contains(markdown, ~\"# Module `moo`\"));\n+        assert!(str::contains(markdown, ~\"# Module `moo`\"));\n     }\n \n     #[test]\n     pub fn should_leave_blank_line_after_header() {\n         let markdown = render(~\"mod morp { }\");\n-        fail_unless!(str::contains(markdown, ~\"Module `morp`\\n\\n\"));\n+        assert!(str::contains(markdown, ~\"Module `morp`\\n\\n\"));\n     }\n }"}, {"sha": "2011649995ecdda213eec81782aea6034a888dfa", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -92,7 +92,7 @@ fn pandoc_writer(\n     config: config::Config,\n     page: doc::Page\n ) -> Writer {\n-    fail_unless!(config.pandoc_cmd.is_some());\n+    assert!(config.pandoc_cmd.is_some());\n     let pandoc_cmd = (&config.pandoc_cmd).get();\n     let filename = make_local_filename(config, page);\n \n@@ -201,7 +201,7 @@ pub fn make_filename(\n                 config.output_style == config::DocPerMod {\n                 ~\"index\"\n             } else {\n-                fail_unless!(doc.topmod.name() != ~\"\");\n+                assert!(doc.topmod.name() != ~\"\");\n                 doc.topmod.name()\n             }\n           }\n@@ -229,7 +229,7 @@ fn should_use_markdown_file_name_based_off_crate() {\n     let doc = test::mk_doc(~\"test\", ~\"\");\n     let page = doc::CratePage(doc.CrateDoc());\n     let filename = make_local_filename(config, page);\n-    fail_unless!(filename.to_str() == ~\"output/dir/test.md\");\n+    assert!(filename.to_str() == ~\"output/dir/test.md\");\n }\n \n #[test]\n@@ -243,7 +243,7 @@ fn should_name_html_crate_file_name_index_html_when_doc_per_mod() {\n     let doc = test::mk_doc(~\"\", ~\"\");\n     let page = doc::CratePage(doc.CrateDoc());\n     let filename = make_local_filename(config, page);\n-    fail_unless!(filename.to_str() == ~\"output/dir/index.html\");\n+    assert!(filename.to_str() == ~\"output/dir/index.html\");\n }\n \n #[test]\n@@ -258,7 +258,7 @@ fn should_name_mod_file_names_by_path() {\n     let modb = copy doc.cratemod().mods()[0].mods()[0];\n     let page = doc::ItemPage(doc::ModTag(modb));\n     let filename = make_local_filename(config, page);\n-    fail_unless!(filename == Path(\"output/dir/a_b.html\"));\n+    assert!(filename == Path(\"output/dir/a_b.html\"));\n }\n \n #[cfg(test)]"}, {"sha": "55f17f5c1501d37709f90fe10790cee08b89d96d", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -155,19 +155,19 @@ fn should_not_split_the_doc_into_pages_for_doc_per_crate() {\n         config::DocPerCrate,\n         ~\"mod a { } mod b { mod c { } }\"\n     );\n-    fail_unless!(doc.pages.len() == 1u);\n+    assert!(doc.pages.len() == 1u);\n }\n \n #[test]\n fn should_make_a_page_for_every_mod() {\n     let doc = test::mk_doc(~\"mod a { }\");\n-    fail_unless!(doc.pages.mods()[0].name() == ~\"a\");\n+    assert!(doc.pages.mods()[0].name() == ~\"a\");\n }\n \n #[test]\n fn should_remove_mods_from_containing_mods() {\n     let doc = test::mk_doc(~\"mod a { }\");\n-    fail_unless!(vec::is_empty(doc.cratemod().mods()));\n+    assert!(vec::is_empty(doc.cratemod().mods()));\n }\n \n #[cfg(test)]"}, {"sha": "52d6e8d9cd6706859b56aff0e3f941f9f0a598f4", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -93,6 +93,6 @@ fn test_run_passes() {\n         ];\n         let doc = extract::from_srv(srv.clone(), ~\"one\");\n         let doc = run_passes(srv, doc, passes);\n-        fail_unless!(doc.cratemod().name() == ~\"onetwothree\");\n+        assert!(doc.cratemod().name() == ~\"onetwothree\");\n     }\n }"}, {"sha": "dab60e0e0c05f6e4100b9ae170919b7e8f8e963b", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -98,9 +98,9 @@ fn should_record_mod_paths() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = run(srv.clone(), doc);\n-        fail_unless!(doc.cratemod().mods()[0].mods()[0].mods()[0].path()\n+        assert!(doc.cratemod().mods()[0].mods()[0].mods()[0].path()\n             == ~[~\"a\", ~\"b\"]);\n-        fail_unless!(doc.cratemod().mods()[0].mods()[1].mods()[0].path()\n+        assert!(doc.cratemod().mods()[0].mods()[1].mods()[0].path()\n             == ~[~\"a\", ~\"d\"]);\n     }\n }\n@@ -111,7 +111,7 @@ fn should_record_fn_paths() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = run(srv.clone(), doc);\n-        fail_unless!(doc.cratemod().mods()[0].fns()[0].path() == ~[~\"a\"]);\n+        assert!(doc.cratemod().mods()[0].fns()[0].path() == ~[~\"a\"]);\n     }\n }\n "}, {"sha": "f46d183ffcfaf41dc348052d4e105f164ac68d6a", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -66,7 +66,7 @@ fn should_prune_hidden_items() {\n     use core::vec;\n \n     let doc = test::mk_doc(~\"#[doc(hidden)] mod a { }\");\n-    fail_unless!(vec::is_empty(doc.cratemod().mods()))\n+    assert!(vec::is_empty(doc.cratemod().mods()))\n }\n \n #[cfg(test)]"}, {"sha": "a1f8fdb75d9eacb80fa64d00fdf776b0de26208a", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -85,7 +85,7 @@ fn strip_priv_methods(\n         let ast_method = do methods.find |m| {\n             extract::to_str(m.ident) == method.name\n         };\n-        fail_unless!(ast_method.is_some());\n+        assert!(ast_method.is_some());\n         let ast_method = ast_method.unwrap();\n         match ast_method.vis {\n             ast::public => true,\n@@ -157,7 +157,7 @@ fn is_visible(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n #[test]\n fn should_prune_items_without_pub_modifier() {\n     let doc = test::mk_doc(~\"mod a { }\");\n-    fail_unless!(vec::is_empty(doc.cratemod().mods()));\n+    assert!(vec::is_empty(doc.cratemod().mods()));\n }\n \n #[test]\n@@ -168,7 +168,7 @@ fn should_not_prune_trait_impls() {\n           trait Foo { } \\\n           impl Foo for int { } \\\n           \");\n-    fail_unless!(!doc.cratemod().impls().is_empty());\n+    assert!(!doc.cratemod().impls().is_empty());\n }\n \n #[test]\n@@ -178,7 +178,7 @@ fn should_prune_associated_methods_without_vis_modifier_on_impls_without_vis_mod\n           pub fn bar() { }\\\n           fn baz() { }\\\n           }\");\n-    fail_unless!(doc.cratemod().impls()[0].methods.len() == 1);\n+    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n }\n \n #[test]\n@@ -188,7 +188,7 @@ fn should_prune_priv_associated_methods_on_impls_without_vis_modifier() {\n           pub fn bar() { }\\\n           priv fn baz() { }\\\n           }\");\n-    fail_unless!(doc.cratemod().impls()[0].methods.len() == 1);\n+    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n }\n \n #[test]\n@@ -198,7 +198,7 @@ fn should_prune_priv_associated_methods_on_pub_impls() {\n           fn bar() { }\\\n           priv fn baz() { }\\\n           }\");\n-    fail_unless!(doc.cratemod().impls()[0].methods.len() == 1);\n+    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n }\n \n #[test]\n@@ -208,7 +208,7 @@ fn should_prune_associated_methods_without_vis_modifier_on_priv_impls() {\n           pub fn bar() { }\\\n           fn baz() { }\\\n           }\");\n-    fail_unless!(doc.cratemod().impls()[0].methods.len() == 1);\n+    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n }\n \n #[test]\n@@ -218,7 +218,7 @@ fn should_prune_priv_associated_methods_on_priv_impls() {\n           pub fn bar() { }\\\n           priv fn baz() { }\\\n           }\");\n-    fail_unless!(doc.cratemod().impls()[0].methods.len() == 1);\n+    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n }\n \n #[test]\n@@ -227,7 +227,7 @@ fn should_prune_associated_impls_with_no_pub_methods() {\n         ~\"priv impl Foo {\\\n           fn baz() { }\\\n           }\");\n-    fail_unless!(doc.cratemod().impls().is_empty());\n+    assert!(doc.cratemod().impls().is_empty());\n }\n \n #[test]\n@@ -236,7 +236,7 @@ fn should_not_prune_associated_impls_with_pub_methods() {\n         ~\" \\\n           impl Foo { pub fn bar() { } } \\\n           \");\n-    fail_unless!(!doc.cratemod().impls().is_empty());\n+    assert!(!doc.cratemod().impls().is_empty());\n }\n \n "}, {"sha": "788f84b06c2e8d38615f963170d14c8cce526cd9", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -168,7 +168,7 @@ fn should_create_section_headers() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    fail_unless!(str::contains(\n+    assert!(str::contains(\n         doc.cratemod().mods()[0].item.sections[0].header,\n         ~\"Header\"));\n }\n@@ -181,7 +181,7 @@ fn should_create_section_bodies() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    fail_unless!(str::contains(\n+    assert!(str::contains(\n         doc.cratemod().mods()[0].item.sections[0].body,\n         ~\"Body\"));\n }\n@@ -194,7 +194,7 @@ fn should_not_create_sections_from_indented_headers() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    fail_unless!(vec::is_empty(doc.cratemod().mods()[0].item.sections));\n+    assert!(vec::is_empty(doc.cratemod().mods()[0].item.sections));\n }\n \n #[test]\n@@ -206,10 +206,10 @@ fn should_remove_section_text_from_main_desc() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    fail_unless!(!str::contains(\n+    assert!(!str::contains(\n         doc.cratemod().mods()[0].desc().get(),\n         ~\"Header\"));\n-    fail_unless!(!str::contains(\n+    assert!(!str::contains(\n         doc.cratemod().mods()[0].desc().get(),\n         ~\"Body\"));\n }\n@@ -222,7 +222,7 @@ fn should_eliminate_desc_if_it_is_just_whitespace() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    fail_unless!(doc.cratemod().mods()[0].desc() == None);\n+    assert!(doc.cratemod().mods()[0].desc() == None);\n }\n \n #[test]\n@@ -233,7 +233,7 @@ fn should_sectionalize_trait_methods() {\n          # Header\\n\\\n          Body\\\"]\\\n          fn a(); }\");\n-    fail_unless!(doc.cratemod().traits()[0].methods[0].sections.len() == 1u);\n+    assert!(doc.cratemod().traits()[0].methods[0].sections.len() == 1u);\n }\n \n #[test]\n@@ -244,7 +244,7 @@ fn should_sectionalize_impl_methods() {\n          # Header\\n\\\n          Body\\\"]\\\n          fn a() { } }\");\n-    fail_unless!(doc.cratemod().impls()[0].methods[0].sections.len() == 1u);\n+    assert!(doc.cratemod().impls()[0].methods[0].sections.len() == 1u);\n }\n \n #[cfg(test)]"}, {"sha": "86b2cc634fd04b1bc2371f5f52c67f626abfd57f", "filename": "src/librustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_name_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -31,7 +31,7 @@ fn test() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass().f)(srv.clone(), doc);\n-        fail_unless!(doc.cratemod().items[0].name() == ~\"y\");\n-        fail_unless!(doc.cratemod().items[1].name() == ~\"z\");\n+        assert!(doc.cratemod().items[0].name() == ~\"y\");\n+        assert!(doc.cratemod().items[1].name() == ~\"z\");\n     }\n }"}, {"sha": "d75565d4ec8246dc57f53fdcb335c68295cccd30", "filename": "src/librustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_type_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -55,14 +55,14 @@ fn test() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass().f)(srv.clone(), doc);\n-        fail_unless!(doc.cratemod().items[0].name() == ~\"iconst\");\n-        fail_unless!(doc.cratemod().items[1].name() == ~\"itype\");\n-        fail_unless!(doc.cratemod().items[2].name() == ~\"ienum\");\n-        fail_unless!(doc.cratemod().items[3].name() == ~\"istruct\");\n-        fail_unless!(doc.cratemod().items[4].name() == ~\"itrait\");\n-        fail_unless!(doc.cratemod().items[5].name() == ~\"__extensions__\");\n-        fail_unless!(doc.cratemod().items[6].name() == ~\"ifn\");\n-        fail_unless!(doc.cratemod().items[7].name() == ~\"imod\");\n-        fail_unless!(doc.cratemod().items[8].name() == ~\"inmod\");\n+        assert!(doc.cratemod().items[0].name() == ~\"iconst\");\n+        assert!(doc.cratemod().items[1].name() == ~\"itype\");\n+        assert!(doc.cratemod().items[2].name() == ~\"ienum\");\n+        assert!(doc.cratemod().items[3].name() == ~\"istruct\");\n+        assert!(doc.cratemod().items[4].name() == ~\"itrait\");\n+        assert!(doc.cratemod().items[5].name() == ~\"__extensions__\");\n+        assert!(doc.cratemod().items[6].name() == ~\"ifn\");\n+        assert!(doc.cratemod().items[7].name() == ~\"imod\");\n+        assert!(doc.cratemod().items[8].name() == ~\"inmod\");\n     }\n }"}, {"sha": "dc7bc8b9df21f0e5b67985e5258fa5173938ade7", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -67,10 +67,10 @@ fn test() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass(~\"\", name_lteq).f)(srv.clone(), doc);\n-        fail_unless!(doc.cratemod().mods()[0].name() == ~\"w\");\n-        fail_unless!(doc.cratemod().mods()[1].items[0].name() == ~\"x\");\n-        fail_unless!(doc.cratemod().mods()[1].items[1].name() == ~\"y\");\n-        fail_unless!(doc.cratemod().mods()[1].name() == ~\"z\");\n+        assert!(doc.cratemod().mods()[0].name() == ~\"w\");\n+        assert!(doc.cratemod().mods()[1].items[0].name() == ~\"x\");\n+        assert!(doc.cratemod().mods()[1].items[1].name() == ~\"y\");\n+        assert!(doc.cratemod().mods()[1].name() == ~\"z\");\n     }\n }\n \n@@ -84,10 +84,10 @@ fn should_be_stable() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass(~\"\", always_eq).f)(srv.clone(), doc);\n-        fail_unless!(doc.cratemod().mods()[0].items[0].name() == ~\"b\");\n-        fail_unless!(doc.cratemod().mods()[1].items[0].name() == ~\"d\");\n+        assert!(doc.cratemod().mods()[0].items[0].name() == ~\"b\");\n+        assert!(doc.cratemod().mods()[1].items[0].name() == ~\"d\");\n         let doc = (mk_pass(~\"\", always_eq).f)(srv.clone(), doc);\n-        fail_unless!(doc.cratemod().mods()[0].items[0].name() == ~\"b\");\n-        fail_unless!(doc.cratemod().mods()[1].items[0].name() == ~\"d\");\n+        assert!(doc.cratemod().mods()[0].items[0].name() == ~\"b\");\n+        assert!(doc.cratemod().mods()[1].items[0].name() == ~\"d\");\n     }\n }"}, {"sha": "b5e9b452d148bfe797f4aa0ae02a570abecf53ed", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -140,89 +140,89 @@ fn fold_impl(\n #[test]\n fn should_execute_op_on_enum_brief() {\n     let doc = test::mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n-    fail_unless!(doc.cratemod().enums()[0].brief() == Some(~\"a\"));\n+    assert!(doc.cratemod().enums()[0].brief() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_enum_desc() {\n     let doc = test::mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n-    fail_unless!(doc.cratemod().enums()[0].desc() == Some(~\"a\"));\n+    assert!(doc.cratemod().enums()[0].desc() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_variant_desc() {\n     let doc = test::mk_doc(~\"enum a { #[doc = \\\" a \\\"] b }\");\n-    fail_unless!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"a\"));\n+    assert!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_trait_brief() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n-    fail_unless!(doc.cratemod().traits()[0].brief() == Some(~\"a\"));\n+    assert!(doc.cratemod().traits()[0].brief() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_trait_desc() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n-    fail_unless!(doc.cratemod().traits()[0].desc() == Some(~\"a\"));\n+    assert!(doc.cratemod().traits()[0].desc() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_trait_method_brief() {\n     let doc = test::mk_doc(\n         ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n-    fail_unless!(doc.cratemod().traits()[0].methods[0].brief == Some(~\"a\"));\n+    assert!(doc.cratemod().traits()[0].methods[0].brief == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_trait_method_desc() {\n     let doc = test::mk_doc(\n         ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n-    fail_unless!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"a\"));\n+    assert!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_impl_brief() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n-    fail_unless!(doc.cratemod().impls()[0].brief() == Some(~\"a\"));\n+    assert!(doc.cratemod().impls()[0].brief() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_impl_desc() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n-    fail_unless!(doc.cratemod().impls()[0].desc() == Some(~\"a\"));\n+    assert!(doc.cratemod().impls()[0].desc() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_impl_method_brief() {\n     let doc = test::mk_doc(\n         ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n-    fail_unless!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"a\"));\n+    assert!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_impl_method_desc() {\n     let doc = test::mk_doc(\n         ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n-    fail_unless!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"a\"));\n+    assert!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_type_brief() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] type t = int;\");\n-    fail_unless!(doc.cratemod().types()[0].brief() == Some(~\"a\"));\n+    assert!(doc.cratemod().types()[0].brief() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_type_desc() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] type t = int;\");\n-    fail_unless!(doc.cratemod().types()[0].desc() == Some(~\"a\"));\n+    assert!(doc.cratemod().types()[0].desc() == Some(~\"a\"));\n }\n \n #[test]\n@@ -232,7 +232,7 @@ fn should_execute_on_item_section_headers() {\n          #    Header    \\n\\\n          Body\\\"]\\\n          fn a() { }\");\n-    fail_unless!(doc.cratemod().fns()[0].sections()[0].header == ~\"Header\");\n+    assert!(doc.cratemod().fns()[0].sections()[0].header == ~\"Header\");\n }\n \n #[test]\n@@ -242,7 +242,7 @@ fn should_execute_on_item_section_bodies() {\n          # Header\\n\\\n          Body      \\\"]\\\n          fn a() { }\");\n-    fail_unless!(doc.cratemod().fns()[0].sections()[0].body == ~\"Body\");\n+    assert!(doc.cratemod().fns()[0].sections()[0].body == ~\"Body\");\n }\n \n #[test]\n@@ -253,7 +253,7 @@ fn should_execute_on_trait_method_section_headers() {\n          # Header    \\n\\\n          Body\\\"]\\\n          fn a(); }\");\n-    fail_unless!(doc.cratemod().traits()[0].methods[0].sections[0].header\n+    assert!(doc.cratemod().traits()[0].methods[0].sections[0].header\n         == ~\"Header\");\n }\n \n@@ -265,7 +265,7 @@ fn should_execute_on_trait_method_section_bodies() {\n          # Header\\n\\\n          Body     \\\"]\\\n          fn a(); }\");\n-    fail_unless!(doc.cratemod().traits()[0].methods[0].sections[0].body ==\n+    assert!(doc.cratemod().traits()[0].methods[0].sections[0].body ==\n         ~\"Body\");\n }\n \n@@ -277,7 +277,7 @@ fn should_execute_on_impl_method_section_headers() {\n          # Header   \\n\\\n          Body\\\"]\\\n          fn a() { } }\");\n-    fail_unless!(doc.cratemod().impls()[0].methods[0].sections[0].header\n+    assert!(doc.cratemod().impls()[0].methods[0].sections[0].header\n         == ~\"Header\");\n }\n \n@@ -289,7 +289,7 @@ fn should_execute_on_impl_method_section_bodies() {\n          # Header\\n\\\n          Body    \\\"]\\\n          fn a() { } }\");\n-    fail_unless!(doc.cratemod().impls()[0].methods[0].sections[0].body ==\n+    assert!(doc.cratemod().impls()[0].methods[0].sections[0].body ==\n         ~\"Body\");\n }\n "}, {"sha": "ca543a27189dce6ac71f2a80e64f19f384afaa05", "filename": "src/librustdoc/trim_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftrim_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -29,7 +29,7 @@ fn should_trim_text() {\n     let doc = test::mk_doc(~\"#[doc = \\\" desc \\\"] \\\n                             mod m {\n                             }\");\n-    fail_unless!(doc.cratemod().mods()[0].desc() == Some(~\"desc\"));\n+    assert!(doc.cratemod().mods()[0].desc() == Some(~\"desc\"));\n }\n \n #[cfg(test)]"}, {"sha": "293799d85b2a472a3d98909a8d135a71506cd70e", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -86,13 +86,13 @@ fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n #[test]\n fn should_add_fn_sig() {\n     let doc = test::mk_doc(~\"fn a<T>() -> int { }\");\n-    fail_unless!(doc.cratemod().fns()[0].sig == Some(~\"fn a<T>() -> int\"));\n+    assert!(doc.cratemod().fns()[0].sig == Some(~\"fn a<T>() -> int\"));\n }\n \n #[test]\n fn should_add_foreign_fn_sig() {\n     let doc = test::mk_doc(~\"extern mod a { fn a<T>() -> int; }\");\n-    fail_unless!(doc.cratemod().nmods()[0].fns[0].sig ==\n+    assert!(doc.cratemod().nmods()[0].fns[0].sig ==\n         Some(~\"fn a<T>() -> int\"));\n }\n \n@@ -122,7 +122,7 @@ fn fold_const(\n #[test]\n fn should_add_const_types() {\n     let doc = test::mk_doc(~\"static a: bool = true;\");\n-    fail_unless!(doc.cratemod().consts()[0].sig == Some(~\"bool\"));\n+    assert!(doc.cratemod().consts()[0].sig == Some(~\"bool\"));\n }\n \n fn fold_enum(\n@@ -166,7 +166,7 @@ fn fold_enum(\n #[test]\n fn should_add_variant_sigs() {\n     let doc = test::mk_doc(~\"enum a { b(int) }\");\n-    fail_unless!(doc.cratemod().enums()[0].variants[0].sig ==\n+    assert!(doc.cratemod().enums()[0].variants[0].sig ==\n         Some(~\"b(int)\"));\n }\n \n@@ -263,7 +263,7 @@ fn get_method_sig(\n #[test]\n fn should_add_trait_method_sigs() {\n     let doc = test::mk_doc(~\"trait i { fn a<T>(&mut self) -> int; }\");\n-    fail_unless!(doc.cratemod().traits()[0].methods[0].sig\n+    assert!(doc.cratemod().traits()[0].methods[0].sig\n         == Some(~\"fn a<T>(&mut self) -> int\"));\n }\n \n@@ -308,31 +308,31 @@ fn fold_impl(\n #[test]\n fn should_add_impl_bounds() {\n     let doc = test::mk_doc(~\"impl<T, U: Copy, V: Copy + Clone> Option<T, U, V> { }\");\n-    fail_unless!(doc.cratemod().impls()[0].bounds_str == Some(~\"<T, U: Copy, V: Copy + Clone>\"));\n+    assert!(doc.cratemod().impls()[0].bounds_str == Some(~\"<T, U: Copy, V: Copy + Clone>\"));\n }\n \n #[test]\n fn should_add_impl_trait_types() {\n     let doc = test::mk_doc(~\"impl j for int { fn a<T>() { } }\");\n-    fail_unless!(doc.cratemod().impls()[0].trait_types[0] == ~\"j\");\n+    assert!(doc.cratemod().impls()[0].trait_types[0] == ~\"j\");\n }\n \n #[test]\n fn should_not_add_impl_trait_types_if_none() {\n     let doc = test::mk_doc(~\"impl int { fn a() { } }\");\n-    fail_unless!(vec::len(doc.cratemod().impls()[0].trait_types) == 0);\n+    assert!(vec::len(doc.cratemod().impls()[0].trait_types) == 0);\n }\n \n #[test]\n fn should_add_impl_self_ty() {\n     let doc = test::mk_doc(~\"impl int { fn a() { } }\");\n-    fail_unless!(doc.cratemod().impls()[0].self_ty == Some(~\"int\"));\n+    assert!(doc.cratemod().impls()[0].self_ty == Some(~\"int\"));\n }\n \n #[test]\n fn should_add_impl_method_sigs() {\n     let doc = test::mk_doc(~\"impl int { fn a<T>(&self) -> int { fail!() } }\");\n-    fail_unless!(doc.cratemod().impls()[0].methods[0].sig\n+    assert!(doc.cratemod().impls()[0].methods[0].sig\n         == Some(~\"fn a<T>(&self) -> int\"));\n }\n \n@@ -372,7 +372,7 @@ fn fold_type(\n #[test]\n fn should_add_type_signatures() {\n     let doc = test::mk_doc(~\"type t<T> = int;\");\n-    fail_unless!(doc.cratemod().types()[0].sig == Some(~\"type t<T> = int\"));\n+    assert!(doc.cratemod().types()[0].sig == Some(~\"type t<T> = int\"));\n }\n \n fn fold_struct(\n@@ -425,22 +425,22 @@ fn strip_struct_extra_stuff(item: @ast::item) -> @ast::item {\n #[test]\n fn should_add_struct_defs() {\n     let doc = test::mk_doc(~\"struct S { field: () }\");\n-    fail_unless!((&doc.cratemod().structs()[0].sig).get().contains(\n+    assert!((&doc.cratemod().structs()[0].sig).get().contains(\n         \"struct S {\"));\n }\n \n #[test]\n fn should_not_serialize_struct_drop_blocks() {\n     // All we care about are the fields\n     let doc = test::mk_doc(~\"struct S { field: (), drop { } }\");\n-    fail_unless!(!(&doc.cratemod().structs()[0].sig).get().contains(\"drop\"));\n+    assert!(!(&doc.cratemod().structs()[0].sig).get().contains(\"drop\"));\n }\n \n #[test]\n fn should_not_serialize_struct_attrs() {\n     // All we care about are the fields\n     let doc = test::mk_doc(~\"#[wut] struct S { field: () }\");\n-    fail_unless!(!(&doc.cratemod().structs()[0].sig).get().contains(\"wut\"));\n+    assert!(!(&doc.cratemod().structs()[0].sig).get().contains(\"wut\"));\n }\n \n #[cfg(test)]"}, {"sha": "19877fea1fdd623c6e77501d2e3c440635618ba0", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -84,7 +84,7 @@ fn unindent(s: &str) -> ~str {\n             if str::is_whitespace(*line) {\n                 copy *line\n             } else {\n-                fail_unless!(str::len(*line) >= min_indent);\n+                assert!(str::len(*line) >= min_indent);\n                 str::slice(*line, min_indent, str::len(*line)).to_owned()\n             }\n         };\n@@ -98,14 +98,14 @@ fn unindent(s: &str) -> ~str {\n fn should_unindent() {\n     let s = ~\"    line1\\n    line2\";\n     let r = unindent(s);\n-    fail_unless!(r == ~\"line1\\nline2\");\n+    assert!(r == ~\"line1\\nline2\");\n }\n \n #[test]\n fn should_unindent_multiple_paragraphs() {\n     let s = ~\"    line1\\n\\n    line2\";\n     let r = unindent(s);\n-    fail_unless!(r == ~\"line1\\n\\nline2\");\n+    assert!(r == ~\"line1\\n\\nline2\");\n }\n \n #[test]\n@@ -114,7 +114,7 @@ fn should_leave_multiple_indent_levels() {\n     // base indentation and should be preserved\n     let s = ~\"    line1\\n\\n        line2\";\n     let r = unindent(s);\n-    fail_unless!(r == ~\"line1\\n\\n    line2\");\n+    assert!(r == ~\"line1\\n\\n    line2\");\n }\n \n #[test]\n@@ -126,12 +126,12 @@ fn should_ignore_first_line_indent() {\n     //          and continue here\"]\n     let s = ~\"line1\\n    line2\";\n     let r = unindent(s);\n-    fail_unless!(r == ~\"line1\\nline2\");\n+    assert!(r == ~\"line1\\nline2\");\n }\n \n #[test]\n fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n     let s = ~\"line1\\n\\n    line2\";\n     let r = unindent(s);\n-    fail_unless!(r == ~\"line1\\n\\n    line2\");\n+    assert!(r == ~\"line1\\n\\n    line2\");\n }"}, {"sha": "cd64061af03929e0019a0a32f4dd0a0de0003379", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -790,19 +790,19 @@ pub fn link_exe(src: &Path, dest: &Path) -> bool {\n \n #[test]\n fn test_is_cmd() {\n-    fail_unless!(is_cmd(~\"build\"));\n-    fail_unless!(is_cmd(~\"clean\"));\n-    fail_unless!(is_cmd(~\"do\"));\n-    fail_unless!(is_cmd(~\"info\"));\n-    fail_unless!(is_cmd(~\"install\"));\n-    fail_unless!(is_cmd(~\"prefer\"));\n-    fail_unless!(is_cmd(~\"test\"));\n-    fail_unless!(is_cmd(~\"uninstall\"));\n-    fail_unless!(is_cmd(~\"unprefer\"));\n+    assert!(is_cmd(~\"build\"));\n+    assert!(is_cmd(~\"clean\"));\n+    assert!(is_cmd(~\"do\"));\n+    assert!(is_cmd(~\"info\"));\n+    assert!(is_cmd(~\"install\"));\n+    assert!(is_cmd(~\"prefer\"));\n+    assert!(is_cmd(~\"test\"));\n+    assert!(is_cmd(~\"uninstall\"));\n+    assert!(is_cmd(~\"unprefer\"));\n }\n \n #[test]\n fn test_parse_name() {\n-    fail_unless!(parse_name(~\"org.mozilla.servo\").get() == ~\"servo\");\n-    fail_unless!(parse_name(~\"org. mozilla.servo 2131\").is_err());\n+    assert!(parse_name(~\"org.mozilla.servo\").get() == ~\"servo\");\n+    assert!(parse_name(~\"org. mozilla.servo 2131\").is_err());\n }"}, {"sha": "ac8dd1a5d652301d193b04ba62fe12b0e77b47a2", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -44,7 +44,7 @@ pub impl<'self> Condvar<'self> {\n      */\n     #[inline(always)]\n     fn wait_on(&self, condvar_id: uint) {\n-        fail_unless!(!*self.failed);\n+        assert!(!*self.failed);\n         self.cond.wait_on(condvar_id);\n         // This is why we need to wrap sync::condvar.\n         check_poison(self.is_mutex, *self.failed);\n@@ -60,7 +60,7 @@ pub impl<'self> Condvar<'self> {\n      */\n     #[inline(always)]\n     fn signal_on(&self, condvar_id: uint) -> bool {\n-        fail_unless!(!*self.failed);\n+        assert!(!*self.failed);\n         self.cond.signal_on(condvar_id)\n     }\n \n@@ -74,7 +74,7 @@ pub impl<'self> Condvar<'self> {\n      */\n     #[inline(always)]\n     fn broadcast_on(&self, condvar_id: uint) -> uint {\n-        fail_unless!(!*self.failed);\n+        assert!(!*self.failed);\n         self.cond.broadcast_on(condvar_id)\n     }\n }\n@@ -230,7 +230,7 @@ struct PoisonOnFail {\n impl Drop for PoisonOnFail {\n     fn finalize(&self) {\n         unsafe {\n-            /* fail_unless!(!*self.failed);\n+            /* assert!(!*self.failed);\n                -- might be false in case of cond.wait() */\n             if task::failing() {\n                 *self.failed = true;\n@@ -392,7 +392,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n         // of this cast is removing the mutability.)\n         let new_data = unsafe { cast::transmute_immut(data) };\n         // Downgrade ensured the token belonged to us. Just a sanity check.\n-        fail_unless!(ptr::ref_eq(&state.data, new_data));\n+        assert!(ptr::ref_eq(&state.data, new_data));\n         // Produce new token\n         RWReadMode {\n             data: new_data,\n@@ -505,13 +505,13 @@ mod tests {\n             let arc_v = p.recv();\n \n             let v = *arc::get::<~[int]>(&arc_v);\n-            fail_unless!(v[3] == 4);\n+            assert!(v[3] == 4);\n         };\n \n         let c = p.recv();\n         c.send(arc::clone(&arc_v));\n \n-        fail_unless!((*arc::get(&arc_v))[2] == 3);\n+        assert!((*arc::get(&arc_v))[2] == 3);\n \n         info!(arc_v);\n     }\n@@ -532,7 +532,7 @@ mod tests {\n         }\n         do arc.access_cond |state, cond| {\n             comm::send_one(c.take(), ());\n-            fail_unless!(!*state);\n+            assert!(!*state);\n             while !*state {\n                 cond.wait();\n             }\n@@ -549,7 +549,7 @@ mod tests {\n             do arc2.access_cond |one, cond| {\n                 cond.signal();\n                 // Parent should fail when it wakes up.\n-                fail_unless!(*one == 0);\n+                assert!(*one == 0);\n             }\n         }\n \n@@ -566,11 +566,11 @@ mod tests {\n         let arc2 = ~arc.clone();\n         do task::try || {\n             do arc2.access |one| {\n-                fail_unless!(*one == 2);\n+                assert!(*one == 2);\n             }\n         };\n         do arc.access |one| {\n-            fail_unless!(*one == 1);\n+            assert!(*one == 1);\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -579,11 +579,11 @@ mod tests {\n         let arc2 = (*arc).clone();\n         do task::try || {\n             do arc2.write |one| {\n-                fail_unless!(*one == 2);\n+                assert!(*one == 2);\n             }\n         };\n         do arc.read |one| {\n-            fail_unless!(*one == 1);\n+            assert!(*one == 1);\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -592,11 +592,11 @@ mod tests {\n         let arc2 = (*arc).clone();\n         do task::try || {\n             do arc2.write |one| {\n-                fail_unless!(*one == 2);\n+                assert!(*one == 2);\n             }\n         };\n         do arc.write |one| {\n-            fail_unless!(*one == 1);\n+            assert!(*one == 1);\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -606,12 +606,12 @@ mod tests {\n         do task::try || {\n             do arc2.write_downgrade |write_mode| {\n                 do (&write_mode).write |one| {\n-                    fail_unless!(*one == 2);\n+                    assert!(*one == 2);\n                 }\n             }\n         };\n         do arc.write |one| {\n-            fail_unless!(*one == 1);\n+            assert!(*one == 1);\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -620,11 +620,11 @@ mod tests {\n         let arc2 = (*arc).clone();\n         do task::try || {\n             do arc2.read |one| {\n-                fail_unless!(*one == 2);\n+                assert!(*one == 2);\n             }\n         };\n         do arc.read |one| {\n-            fail_unless!(*one == 1);\n+            assert!(*one == 1);\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -633,11 +633,11 @@ mod tests {\n         let arc2 = (*arc).clone();\n         do task::try || {\n             do arc2.read |one| {\n-                fail_unless!(*one == 2);\n+                assert!(*one == 2);\n             }\n         };\n         do arc.write |one| {\n-            fail_unless!(*one == 1);\n+            assert!(*one == 1);\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -648,12 +648,12 @@ mod tests {\n             do arc2.write_downgrade |write_mode| {\n                 let read_mode = arc2.downgrade(write_mode);\n                 do (&read_mode).read |one| {\n-                    fail_unless!(*one == 2);\n+                    assert!(*one == 2);\n                 }\n             }\n         };\n         do arc.write |one| {\n-            fail_unless!(*one == 1);\n+            assert!(*one == 1);\n         }\n     }\n     #[test]\n@@ -681,7 +681,7 @@ mod tests {\n             do task::task().future_result(|+r| children.push(r)).spawn\n                 || {\n                 do arc3.read |num| {\n-                    fail_unless!(*num >= 0);\n+                    assert!(*num >= 0);\n                 }\n             }\n         }\n@@ -691,7 +691,7 @@ mod tests {\n \n         // Wait for writer to finish\n         p.recv();\n-        do arc.read |num| { fail_unless!(*num == 10); }\n+        do arc.read |num| { assert!(*num == 10); }\n     }\n     #[test]\n     pub fn test_rw_downgrade() {\n@@ -712,7 +712,7 @@ mod tests {\n             do task::spawn || {\n                 rp1.recv(); // wait for downgrader to give go-ahead\n                 do arcn.read |state| {\n-                    fail_unless!(*state == 31337);\n+                    assert!(*state == 31337);\n                     rc2.send(());\n                 }\n             }\n@@ -724,15 +724,15 @@ mod tests {\n         do task::spawn || {\n             wp1.recv();\n             do arc2.write_cond |state, cond| {\n-                fail_unless!(*state == 0);\n+                assert!(*state == 0);\n                 *state = 42;\n                 cond.signal();\n             }\n             wp1.recv();\n             do arc2.write |state| {\n                 // This shouldn't happen until after the downgrade read\n                 // section, and all other readers, finish.\n-                fail_unless!(*state == 31337);\n+                assert!(*state == 31337);\n                 *state = 42;\n             }\n             wc2.send(());\n@@ -745,7 +745,7 @@ mod tests {\n                 while *state == 0 {\n                     cond.wait();\n                 }\n-                fail_unless!(*state == 42);\n+                assert!(*state == 42);\n                 *state = 31337;\n                 // send to other readers\n                 for vec::each(reader_convos) |x| {\n@@ -763,7 +763,7 @@ mod tests {\n                     }\n                 }\n                 wc1.send(()); // tell writer to try again\n-                fail_unless!(*state == 31337);\n+                assert!(*state == 31337);\n             }\n         }\n "}, {"sha": "0266f2d8631cf8880d07c1ed58a20856838f90f6", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -159,23 +159,23 @@ mod tests {\n \n     #[test]\n     pub fn test_to_base64() {\n-        fail_unless!((~\"\").to_base64()       == ~\"\");\n-        fail_unless!((~\"f\").to_base64()      == ~\"Zg==\");\n-        fail_unless!((~\"fo\").to_base64()     == ~\"Zm8=\");\n-        fail_unless!((~\"foo\").to_base64()    == ~\"Zm9v\");\n-        fail_unless!((~\"foob\").to_base64()   == ~\"Zm9vYg==\");\n-        fail_unless!((~\"fooba\").to_base64()  == ~\"Zm9vYmE=\");\n-        fail_unless!((~\"foobar\").to_base64() == ~\"Zm9vYmFy\");\n+        assert!((~\"\").to_base64()       == ~\"\");\n+        assert!((~\"f\").to_base64()      == ~\"Zg==\");\n+        assert!((~\"fo\").to_base64()     == ~\"Zm8=\");\n+        assert!((~\"foo\").to_base64()    == ~\"Zm9v\");\n+        assert!((~\"foob\").to_base64()   == ~\"Zm9vYg==\");\n+        assert!((~\"fooba\").to_base64()  == ~\"Zm9vYmE=\");\n+        assert!((~\"foobar\").to_base64() == ~\"Zm9vYmFy\");\n     }\n \n     #[test]\n     pub fn test_from_base64() {\n-        fail_unless!((~\"\").from_base64() == str::to_bytes(~\"\"));\n-        fail_unless!((~\"Zg==\").from_base64() == str::to_bytes(~\"f\"));\n-        fail_unless!((~\"Zm8=\").from_base64() == str::to_bytes(~\"fo\"));\n-        fail_unless!((~\"Zm9v\").from_base64() == str::to_bytes(~\"foo\"));\n-        fail_unless!((~\"Zm9vYg==\").from_base64() == str::to_bytes(~\"foob\"));\n-        fail_unless!((~\"Zm9vYmE=\").from_base64() == str::to_bytes(~\"fooba\"));\n-        fail_unless!((~\"Zm9vYmFy\").from_base64() == str::to_bytes(~\"foobar\"));\n+        assert!((~\"\").from_base64() == str::to_bytes(~\"\"));\n+        assert!((~\"Zg==\").from_base64() == str::to_bytes(~\"f\"));\n+        assert!((~\"Zm8=\").from_base64() == str::to_bytes(~\"fo\"));\n+        assert!((~\"Zm9v\").from_base64() == str::to_bytes(~\"foo\"));\n+        assert!((~\"Zm9vYg==\").from_base64() == str::to_bytes(~\"foob\"));\n+        assert!((~\"Zm9vYmE=\").from_base64() == str::to_bytes(~\"fooba\"));\n+        assert!((~\"Zm9vYmFy\").from_base64() == str::to_bytes(~\"foobar\"));\n     }\n }"}, {"sha": "35b1a28a465cd535dd429c6bf99246f9523f0224", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 125, "deletions": 125, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -162,7 +162,7 @@ impl Sub<BigUint, BigUint> for BigUint {\n             lo\n         };\n \n-        fail_unless!(borrow == 0);     // <=> fail_unless!((self >= other));\n+        assert!(borrow == 0);     // <=> assert!((self >= other));\n         return BigUint::new(diff);\n     }\n }\n@@ -351,7 +351,7 @@ pub impl BigUint {\n             n <<= 1;\n             shift += 1;\n         }\n-        fail_unless!(shift < BigDigit::bits);\n+        assert!(shift < BigDigit::bits);\n         let (d, m) = divmod_inner(self << shift, other << shift);\n         return (d, m >> shift);\n \n@@ -390,7 +390,7 @@ pub impl BigUint {\n             for an.each_reverse |elt| {\n                 let ai = BigDigit::to_uint(carry, *elt);\n                 let di = ai / (bn as uint);\n-                fail_unless!(di < BigDigit::base);\n+                assert!(di < BigDigit::base);\n                 carry = (ai % (bn as uint)) as BigDigit;\n                 d = ~[di as BigDigit] + d;\n             }\n@@ -434,7 +434,7 @@ pub impl BigUint {\n     }\n \n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        fail_unless!(1 < radix && radix <= 16);\n+        assert!(1 < radix && radix <= 16);\n         let (base, max_len) = get_radix_base(radix);\n         if base == BigDigit::base {\n             return fill_concat(self.data, radix, max_len)\n@@ -510,7 +510,7 @@ pub impl BigUint {\n \n #[cfg(target_arch = \"x86_64\")]\n priv fn get_radix_base(radix: uint) -> (uint, uint) {\n-    fail_unless!(1 < radix && radix <= 16);\n+    assert!(1 < radix && radix <= 16);\n     match radix {\n         2  => (4294967296, 32),\n         3  => (3486784401, 20),\n@@ -535,7 +535,7 @@ priv fn get_radix_base(radix: uint) -> (uint, uint) {\n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"mips\")]\n priv fn get_radix_base(radix: uint) -> (uint, uint) {\n-    fail_unless!(1 < radix && radix <= 16);\n+    assert!(1 < radix && radix <= 16);\n     match radix {\n         2  => (65536, 16),\n         3  => (59049, 10),\n@@ -784,7 +784,7 @@ pub impl BigInt {\n         if ss < os { return -1; }\n         if ss > os { return  1; }\n \n-        fail_unless!(ss == os);\n+        assert!(ss == os);\n         match ss {\n             Zero  => 0,\n             Plus  => self.data.cmp(&other.data),\n@@ -871,7 +871,7 @@ mod biguint_tests {\n     #[test]\n     fn test_from_slice() {\n         fn check(slice: &[BigDigit], data: &[BigDigit]) {\n-            fail_unless!(data == BigUint::from_slice(slice).data);\n+            assert!(data == BigUint::from_slice(slice).data);\n         }\n         check(~[1], ~[1]);\n         check(~[0, 0, 0], ~[]);\n@@ -889,30 +889,30 @@ mod biguint_tests {\n             for vec::slice(data, i, data.len()).eachi |j0, nj| {\n                 let j = j0 + i;\n                 if i == j {\n-                    fail_unless!(ni.cmp(nj) == 0);\n-                    fail_unless!(nj.cmp(ni) == 0);\n-                    fail_unless!(ni == nj);\n-                    fail_unless!(!(ni != nj));\n-                    fail_unless!(ni <= nj);\n-                    fail_unless!(ni >= nj);\n-                    fail_unless!(!(ni < nj));\n-                    fail_unless!(!(ni > nj));\n+                    assert!(ni.cmp(nj) == 0);\n+                    assert!(nj.cmp(ni) == 0);\n+                    assert!(ni == nj);\n+                    assert!(!(ni != nj));\n+                    assert!(ni <= nj);\n+                    assert!(ni >= nj);\n+                    assert!(!(ni < nj));\n+                    assert!(!(ni > nj));\n                 } else {\n-                    fail_unless!(ni.cmp(nj) < 0);\n-                    fail_unless!(nj.cmp(ni) > 0);\n+                    assert!(ni.cmp(nj) < 0);\n+                    assert!(nj.cmp(ni) > 0);\n \n-                    fail_unless!(!(ni == nj));\n-                    fail_unless!(ni != nj);\n+                    assert!(!(ni == nj));\n+                    assert!(ni != nj);\n \n-                    fail_unless!(ni <= nj);\n-                    fail_unless!(!(ni >= nj));\n-                    fail_unless!(ni < nj);\n-                    fail_unless!(!(ni > nj));\n+                    assert!(ni <= nj);\n+                    assert!(!(ni >= nj));\n+                    assert!(ni < nj);\n+                    assert!(!(ni > nj));\n \n-                    fail_unless!(!(nj <= ni));\n-                    fail_unless!(nj >= ni);\n-                    fail_unless!(!(nj < ni));\n-                    fail_unless!(nj > ni);\n+                    assert!(!(nj <= ni));\n+                    assert!(nj >= ni);\n+                    assert!(!(nj < ni));\n+                    assert!(nj > ni);\n                 }\n             }\n         }\n@@ -921,7 +921,7 @@ mod biguint_tests {\n     #[test]\n     fn test_shl() {\n         fn check(v: ~[BigDigit], shift: uint, ans: ~[BigDigit]) {\n-            fail_unless!(BigUint::new(v) << shift == BigUint::new(ans));\n+            assert!(BigUint::new(v) << shift == BigUint::new(ans));\n         }\n \n         check(~[], 3, ~[]);\n@@ -966,7 +966,7 @@ mod biguint_tests {\n     #[ignore(cfg(target_arch = \"mips\"))]\n     fn test_shr() {\n         fn check(v: ~[BigDigit], shift: uint, ans: ~[BigDigit]) {\n-            fail_unless!(BigUint::new(v) >> shift == BigUint::new(ans));\n+            assert!(BigUint::new(v) >> shift == BigUint::new(ans));\n         }\n \n         check(~[], 3, ~[]);\n@@ -1008,8 +1008,8 @@ mod biguint_tests {\n     fn test_convert_int() {\n         fn check(v: ~[BigDigit], i: int) {\n             let b = BigUint::new(v);\n-            fail_unless!(b == IntConvertible::from_int(i));\n-            fail_unless!(b.to_int() == i);\n+            assert!(b == IntConvertible::from_int(i));\n+            assert!(b.to_int() == i);\n         }\n \n         check(~[], 0);\n@@ -1018,17 +1018,17 @@ mod biguint_tests {\n         check(~[ 0,  1], ((uint::max_value >> BigDigit::bits) + 1) as int);\n         check(~[-1, -1 >> 1], int::max_value);\n \n-        fail_unless!(BigUint::new(~[0, -1]).to_int() == int::max_value);\n-        fail_unless!(BigUint::new(~[0, 0, 1]).to_int() == int::max_value);\n-        fail_unless!(BigUint::new(~[0, 0, -1]).to_int() == int::max_value);\n+        assert!(BigUint::new(~[0, -1]).to_int() == int::max_value);\n+        assert!(BigUint::new(~[0, 0, 1]).to_int() == int::max_value);\n+        assert!(BigUint::new(~[0, 0, -1]).to_int() == int::max_value);\n     }\n \n     #[test]\n     fn test_convert_uint() {\n         fn check(v: ~[BigDigit], u: uint) {\n             let b = BigUint::new(v);\n-            fail_unless!(b == BigUint::from_uint(u));\n-            fail_unless!(b.to_uint() == u);\n+            assert!(b == BigUint::from_uint(u));\n+            assert!(b.to_uint() == u);\n         }\n \n         check(~[], 0);\n@@ -1038,8 +1038,8 @@ mod biguint_tests {\n         check(~[ 0, -1], uint::max_value << BigDigit::bits);\n         check(~[-1, -1], uint::max_value);\n \n-        fail_unless!(BigUint::new(~[0, 0, 1]).to_uint()  == uint::max_value);\n-        fail_unless!(BigUint::new(~[0, 0, -1]).to_uint() == uint::max_value);\n+        assert!(BigUint::new(~[0, 0, 1]).to_uint()  == uint::max_value);\n+        assert!(BigUint::new(~[0, 0, -1]).to_uint() == uint::max_value);\n     }\n \n     static sum_triples: &'static [(&'static [BigDigit],\n@@ -1064,8 +1064,8 @@ mod biguint_tests {\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n \n-            fail_unless!(a + b == c);\n-            fail_unless!(b + a == c);\n+            assert!(a + b == c);\n+            assert!(b + a == c);\n         }\n     }\n \n@@ -1077,8 +1077,8 @@ mod biguint_tests {\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n \n-            fail_unless!(c - a == b);\n-            fail_unless!(c - b == a);\n+            assert!(c - a == b);\n+            assert!(c - b == a);\n         }\n     }\n \n@@ -1128,8 +1128,8 @@ mod biguint_tests {\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n \n-            fail_unless!(a * b == c);\n-            fail_unless!(b * a == c);\n+            assert!(a * b == c);\n+            assert!(b * a == c);\n         }\n \n         for divmod_quadruples.each |elm| {\n@@ -1139,8 +1139,8 @@ mod biguint_tests {\n             let c = BigUint::from_slice(cVec);\n             let d = BigUint::from_slice(dVec);\n \n-            fail_unless!(a == b * c + d);\n-            fail_unless!(a == c * b + d);\n+            assert!(a == b * c + d);\n+            assert!(a == c * b + d);\n         }\n     }\n \n@@ -1153,10 +1153,10 @@ mod biguint_tests {\n             let c = BigUint::from_slice(cVec);\n \n             if a.is_not_zero() {\n-                fail_unless!(c.divmod(&a) == (b, Zero::zero()));\n+                assert!(c.divmod(&a) == (b, Zero::zero()));\n             }\n             if b.is_not_zero() {\n-                fail_unless!(c.divmod(&b) == (a, Zero::zero()));\n+                assert!(c.divmod(&b) == (a, Zero::zero()));\n             }\n         }\n \n@@ -1167,7 +1167,7 @@ mod biguint_tests {\n             let c = BigUint::from_slice(cVec);\n             let d = BigUint::from_slice(dVec);\n \n-            if b.is_not_zero() { fail_unless!(a.divmod(&b) == (c, d)); }\n+            if b.is_not_zero() { assert!(a.divmod(&b) == (c, d)); }\n         }\n     }\n \n@@ -1234,7 +1234,7 @@ mod biguint_tests {\n             let &(n, rs) = num_pair;\n             for rs.each |str_pair| {\n                 let &(radix, str) = str_pair;\n-                fail_unless!(n.to_str_radix(radix) == str);\n+                assert!(n.to_str_radix(radix) == str);\n             }\n         }\n     }\n@@ -1245,13 +1245,13 @@ mod biguint_tests {\n             let &(n, rs) = num_pair;\n             for rs.each |str_pair| {\n                 let &(radix, str) = str_pair;\n-                fail_unless!(Some(n) == BigUint::from_str_radix(str, radix));\n+                assert!(Some(n) == BigUint::from_str_radix(str, radix));\n             }\n         }\n \n-        fail_unless!(BigUint::from_str_radix(~\"Z\", 10) == None);\n-        fail_unless!(BigUint::from_str_radix(~\"_\", 2) == None);\n-        fail_unless!(BigUint::from_str_radix(~\"-1\", 10) == None);\n+        assert!(BigUint::from_str_radix(~\"Z\", 10) == None);\n+        assert!(BigUint::from_str_radix(~\"_\", 2) == None);\n+        assert!(BigUint::from_str_radix(~\"-1\", 10) == None);\n     }\n \n     #[test]\n@@ -1269,7 +1269,7 @@ mod biguint_tests {\n             let ans = match BigUint::from_str_radix(s, 10) {\n                 Some(x) => x, None => fail!()\n             };\n-            fail_unless!(n == ans);\n+            assert!(n == ans);\n         }\n \n         check(3, \"6\");\n@@ -1291,7 +1291,7 @@ mod bigint_tests {\n         fn check(inp_s: Sign, inp_n: uint, ans_s: Sign, ans_n: uint) {\n             let inp = BigInt::from_biguint(inp_s, BigUint::from_uint(inp_n));\n             let ans = BigInt { sign: ans_s, data: BigUint::from_uint(ans_n)};\n-            fail_unless!(inp == ans);\n+            assert!(inp == ans);\n         }\n         check(Plus, 1, Plus, 1);\n         check(Plus, 0, Zero, 0);\n@@ -1311,30 +1311,30 @@ mod bigint_tests {\n             for vec::slice(nums, i, nums.len()).eachi |j0, nj| {\n                 let j = i + j0;\n                 if i == j {\n-                    fail_unless!(ni.cmp(nj) == 0);\n-                    fail_unless!(nj.cmp(ni) == 0);\n-                    fail_unless!(ni == nj);\n-                    fail_unless!(!(ni != nj));\n-                    fail_unless!(ni <= nj);\n-                    fail_unless!(ni >= nj);\n-                    fail_unless!(!(ni < nj));\n-                    fail_unless!(!(ni > nj));\n+                    assert!(ni.cmp(nj) == 0);\n+                    assert!(nj.cmp(ni) == 0);\n+                    assert!(ni == nj);\n+                    assert!(!(ni != nj));\n+                    assert!(ni <= nj);\n+                    assert!(ni >= nj);\n+                    assert!(!(ni < nj));\n+                    assert!(!(ni > nj));\n                 } else {\n-                    fail_unless!(ni.cmp(nj) < 0);\n-                    fail_unless!(nj.cmp(ni) > 0);\n+                    assert!(ni.cmp(nj) < 0);\n+                    assert!(nj.cmp(ni) > 0);\n \n-                    fail_unless!(!(ni == nj));\n-                    fail_unless!(ni != nj);\n+                    assert!(!(ni == nj));\n+                    assert!(ni != nj);\n \n-                    fail_unless!(ni <= nj);\n-                    fail_unless!(!(ni >= nj));\n-                    fail_unless!(ni < nj);\n-                    fail_unless!(!(ni > nj));\n+                    assert!(ni <= nj);\n+                    assert!(!(ni >= nj));\n+                    assert!(ni < nj);\n+                    assert!(!(ni > nj));\n \n-                    fail_unless!(!(nj <= ni));\n-                    fail_unless!(nj >= ni);\n-                    fail_unless!(!(nj < ni));\n-                    fail_unless!(nj > ni);\n+                    assert!(!(nj <= ni));\n+                    assert!(nj >= ni);\n+                    assert!(!(nj < ni));\n+                    assert!(nj > ni);\n                 }\n             }\n         }\n@@ -1343,8 +1343,8 @@ mod bigint_tests {\n     #[test]\n     fn test_convert_int() {\n         fn check(b: BigInt, i: int) {\n-            fail_unless!(b == IntConvertible::from_int(i));\n-            fail_unless!(b.to_int() == i);\n+            assert!(b == IntConvertible::from_int(i));\n+            assert!(b.to_int() == i);\n         }\n \n         check(Zero::zero(), 0);\n@@ -1353,29 +1353,29 @@ mod bigint_tests {\n             Plus, BigUint::from_uint(int::max_value as uint)\n         ), int::max_value);\n \n-        fail_unless!(BigInt::from_biguint(\n+        assert!(BigInt::from_biguint(\n             Plus, BigUint::from_uint(int::max_value as uint + 1)\n         ).to_int() == int::max_value);\n-        fail_unless!(BigInt::from_biguint(\n+        assert!(BigInt::from_biguint(\n             Plus, BigUint::new(~[1, 2, 3])\n         ).to_int() == int::max_value);\n \n         check(BigInt::from_biguint(\n             Minus, BigUint::from_uint(-int::min_value as uint)\n         ), int::min_value);\n-        fail_unless!(BigInt::from_biguint(\n+        assert!(BigInt::from_biguint(\n             Minus, BigUint::from_uint(-int::min_value as uint + 1)\n         ).to_int() == int::min_value);\n-        fail_unless!(BigInt::from_biguint(\n+        assert!(BigInt::from_biguint(\n             Minus, BigUint::new(~[1, 2, 3])\n         ).to_int() == int::min_value);\n     }\n \n     #[test]\n     fn test_convert_uint() {\n         fn check(b: BigInt, u: uint) {\n-            fail_unless!(b == BigInt::from_uint(u));\n-            fail_unless!(b.to_uint() == u);\n+            assert!(b == BigInt::from_uint(u));\n+            assert!(b.to_uint() == u);\n         }\n \n         check(Zero::zero(), 0);\n@@ -1384,14 +1384,14 @@ mod bigint_tests {\n         check(\n             BigInt::from_biguint(Plus, BigUint::from_uint(uint::max_value)),\n             uint::max_value);\n-        fail_unless!(BigInt::from_biguint(\n+        assert!(BigInt::from_biguint(\n             Plus, BigUint::new(~[1, 2, 3])\n         ).to_uint() == uint::max_value);\n \n-        fail_unless!(BigInt::from_biguint(\n+        assert!(BigInt::from_biguint(\n             Minus, BigUint::from_uint(uint::max_value)\n         ).to_uint() == 0);\n-        fail_unless!(BigInt::from_biguint(\n+        assert!(BigInt::from_biguint(\n             Minus, BigUint::new(~[1, 2, 3])\n         ).to_uint() == 0);\n     }\n@@ -1418,14 +1418,14 @@ mod bigint_tests {\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            fail_unless!(a + b == c);\n-            fail_unless!(b + a == c);\n-            fail_unless!(c + (-a) == b);\n-            fail_unless!(c + (-b) == a);\n-            fail_unless!(a + (-c) == (-b));\n-            fail_unless!(b + (-c) == (-a));\n-            fail_unless!((-a) + (-b) == (-c));\n-            fail_unless!(a + (-a) == Zero::zero());\n+            assert!(a + b == c);\n+            assert!(b + a == c);\n+            assert!(c + (-a) == b);\n+            assert!(c + (-b) == a);\n+            assert!(a + (-c) == (-b));\n+            assert!(b + (-c) == (-a));\n+            assert!((-a) + (-b) == (-c));\n+            assert!(a + (-a) == Zero::zero());\n         }\n     }\n \n@@ -1437,14 +1437,14 @@ mod bigint_tests {\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            fail_unless!(c - a == b);\n-            fail_unless!(c - b == a);\n-            fail_unless!((-b) - a == (-c));\n-            fail_unless!((-a) - b == (-c));\n-            fail_unless!(b - (-a) == c);\n-            fail_unless!(a - (-b) == c);\n-            fail_unless!((-c) - (-a) == (-b));\n-            fail_unless!(a - a == Zero::zero());\n+            assert!(c - a == b);\n+            assert!(c - b == a);\n+            assert!((-b) - a == (-c));\n+            assert!((-a) - b == (-c));\n+            assert!(b - (-a) == c);\n+            assert!(a - (-b) == c);\n+            assert!((-c) - (-a) == (-b));\n+            assert!(a - a == Zero::zero());\n         }\n     }\n \n@@ -1494,11 +1494,11 @@ mod bigint_tests {\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            fail_unless!(a * b == c);\n-            fail_unless!(b * a == c);\n+            assert!(a * b == c);\n+            assert!(b * a == c);\n \n-            fail_unless!((-a) * b == -c);\n-            fail_unless!((-b) * a == -c);\n+            assert!((-a) * b == -c);\n+            assert!((-b) * a == -c);\n         }\n \n         for divmod_quadruples.each |elm| {\n@@ -1508,8 +1508,8 @@ mod bigint_tests {\n             let c = BigInt::from_slice(Plus, cVec);\n             let d = BigInt::from_slice(Plus, dVec);\n \n-            fail_unless!(a == b * c + d);\n-            fail_unless!(a == c * b + d);\n+            assert!(a == b * c + d);\n+            assert!(a == c * b + d);\n         }\n     }\n \n@@ -1518,12 +1518,12 @@ mod bigint_tests {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_d: &BigInt, ans_m: &BigInt) {\n             let (d, m) = a.divmod(b);\n             if m.is_not_zero() {\n-                fail_unless!(m.sign == b.sign);\n+                assert!(m.sign == b.sign);\n             }\n-            fail_unless!(m.abs() <= b.abs());\n-            fail_unless!(*a == b * d + m);\n-            fail_unless!(d == *ans_d);\n-            fail_unless!(m == *ans_m);\n+            assert!(m.abs() <= b.abs());\n+            assert!(*a == b * d + m);\n+            assert!(d == *ans_d);\n+            assert!(m == *ans_m);\n         }\n \n         fn check(a: &BigInt, b: &BigInt, d: &BigInt, m: &BigInt) {\n@@ -1569,12 +1569,12 @@ mod bigint_tests {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_q: &BigInt, ans_r: &BigInt) {\n             let (q, r) = a.quotrem(b);\n             if r.is_not_zero() {\n-                fail_unless!(r.sign == a.sign);\n+                assert!(r.sign == a.sign);\n             }\n-            fail_unless!(r.abs() <= b.abs());\n-            fail_unless!(*a == b * q + r);\n-            fail_unless!(q == *ans_q);\n-            fail_unless!(r == *ans_r);\n+            assert!(r.abs() <= b.abs());\n+            assert!(*a == b * q + r);\n+            assert!(q == *ans_q);\n+            assert!(r == *ans_r);\n         }\n \n         fn check(a: &BigInt, b: &BigInt, q: &BigInt, r: &BigInt) {\n@@ -1609,7 +1609,7 @@ mod bigint_tests {\n     #[test]\n     fn test_to_str_radix() {\n         fn check(n: int, ans: &str) {\n-            fail_unless!(ans == IntConvertible::from_int::<BigInt>(\n+            assert!(ans == IntConvertible::from_int::<BigInt>(\n                 n).to_str_radix(10));\n         }\n         check(10, \"10\");\n@@ -1624,7 +1624,7 @@ mod bigint_tests {\n     fn test_from_str_radix() {\n         fn check(s: &str, ans: Option<int>) {\n             let ans = ans.map(|&n| IntConvertible::from_int(n));\n-            fail_unless!(BigInt::from_str_radix(s, 10) == ans);\n+            assert!(BigInt::from_str_radix(s, 10) == ans);\n         }\n         check(\"10\", Some(10));\n         check(\"1\", Some(1));\n@@ -1637,11 +1637,11 @@ mod bigint_tests {\n \n     #[test]\n     fn test_neg() {\n-        fail_unless!(-BigInt::new(Plus,  ~[1, 1, 1]) ==\n+        assert!(-BigInt::new(Plus,  ~[1, 1, 1]) ==\n             BigInt::new(Minus, ~[1, 1, 1]));\n-        fail_unless!(-BigInt::new(Minus, ~[1, 1, 1]) ==\n+        assert!(-BigInt::new(Minus, ~[1, 1, 1]) ==\n             BigInt::new(Plus,  ~[1, 1, 1]));\n-        fail_unless!(-Zero::zero::<BigInt>() == Zero::zero::<BigInt>());\n+        assert!(-Zero::zero::<BigInt>() == Zero::zero::<BigInt>());\n     }\n }\n "}, {"sha": "f69e2130e71417f008a719fdbf63e82634a128a4", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 114, "deletions": 114, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -132,7 +132,7 @@ pub impl BigBitv {\n     fn process(&mut self, b: &BigBitv, nbits: uint,\n                op: &fn(uint, uint) -> uint) -> bool {\n         let len = b.storage.len();\n-        fail_unless!((self.storage.len() == len));\n+        assert!((self.storage.len() == len));\n         let mut changed = false;\n         for uint::range(0, len) |i| {\n             let mask = big_mask(nbits, i);\n@@ -300,7 +300,7 @@ pub impl Bitv {\n     /// Retrieve the value at index `i`\n     #[inline(always)]\n     fn get(&self, i: uint) -> bool {\n-       fail_unless!((i < self.nbits));\n+       assert!((i < self.nbits));\n        match self.rep {\n          Big(ref b)   => b.get(i),\n          Small(ref s) => s.get(i)\n@@ -314,7 +314,7 @@ pub impl Bitv {\n      */\n     #[inline(always)]\n     fn set(&mut self, i: uint, x: bool) {\n-      fail_unless!((i < self.nbits));\n+      assert!((i < self.nbits));\n       match self.rep {\n         Big(ref mut b)   => b.set(i, x),\n         Small(ref mut s) => s.set(i, x)\n@@ -484,7 +484,7 @@ pub impl Bitv {\n      * the bitvector and vector must have the same length\n      */\n     fn eq_vec(&self, v: ~[uint]) -> bool {\n-        fail_unless!(self.nbits == v.len());\n+        assert!(self.nbits == v.len());\n         let mut i = 0;\n         while i < self.nbits {\n             let w0 = self.get(i);\n@@ -725,7 +725,7 @@ impl Set<uint> for BitvSet {\n         let nbits = self.capacity();\n         if value >= nbits {\n             let newsize = uint::max(value, nbits * 2) / uint::bits + 1;\n-            fail_unless!(newsize > self.bitv.storage.len());\n+            assert!(newsize > self.bitv.storage.len());\n             self.bitv.storage.grow(newsize, &0);\n         }\n         self.size += 1;\n@@ -884,10 +884,10 @@ mod tests {\n     #[test]\n     pub fn test_to_str() {\n         let zerolen = Bitv::new(0u, false);\n-        fail_unless!(zerolen.to_str() == ~\"\");\n+        assert!(zerolen.to_str() == ~\"\");\n \n         let eightbits = Bitv::new(8u, false);\n-        fail_unless!(eightbits.to_str() == ~\"00000000\");\n+        assert!(eightbits.to_str() == ~\"00000000\");\n     }\n \n     #[test]\n@@ -896,24 +896,24 @@ mod tests {\n         let mut exp;\n         act = Bitv::new(0u, false);\n         exp = vec::from_elem::<uint>(0u, 0u);\n-        fail_unless!(act.eq_vec(exp));\n+        assert!(act.eq_vec(exp));\n     }\n \n     #[test]\n     pub fn test_1_element() {\n         let mut act;\n         act = Bitv::new(1u, false);\n-        fail_unless!(act.eq_vec(~[0u]));\n+        assert!(act.eq_vec(~[0u]));\n         act = Bitv::new(1u, true);\n-        fail_unless!(act.eq_vec(~[1u]));\n+        assert!(act.eq_vec(~[1u]));\n     }\n \n     #[test]\n     pub fn test_2_elements() {\n         let mut b = bitv::Bitv::new(2, false);\n         b.set(0, true);\n         b.set(1, false);\n-        fail_unless!(b.to_str() == ~\"10\");\n+        assert!(b.to_str() == ~\"10\");\n     }\n \n     #[test]\n@@ -922,11 +922,11 @@ mod tests {\n         // all 0\n \n         act = Bitv::new(10u, false);\n-        fail_unless!((act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u])));\n+        assert!((act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u])));\n         // all 1\n \n         act = Bitv::new(10u, true);\n-        fail_unless!((act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u])));\n+        assert!((act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u])));\n         // mixed\n \n         act = Bitv::new(10u, false);\n@@ -935,7 +935,7 @@ mod tests {\n         act.set(2u, true);\n         act.set(3u, true);\n         act.set(4u, true);\n-        fail_unless!((act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u])));\n+        assert!((act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u])));\n         // mixed\n \n         act = Bitv::new(10u, false);\n@@ -944,15 +944,15 @@ mod tests {\n         act.set(7u, true);\n         act.set(8u, true);\n         act.set(9u, true);\n-        fail_unless!((act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u])));\n+        assert!((act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u])));\n         // mixed\n \n         act = Bitv::new(10u, false);\n         act.set(0u, true);\n         act.set(3u, true);\n         act.set(6u, true);\n         act.set(9u, true);\n-        fail_unless!((act.eq_vec(~[1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u])));\n+        assert!((act.eq_vec(~[1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u])));\n     }\n \n     #[test]\n@@ -961,14 +961,14 @@ mod tests {\n         // all 0\n \n         act = Bitv::new(31u, false);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n         act = Bitv::new(31u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u]));\n@@ -983,7 +983,7 @@ mod tests {\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n@@ -998,7 +998,7 @@ mod tests {\n         act.set(21u, true);\n         act.set(22u, true);\n         act.set(23u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n@@ -1012,7 +1012,7 @@ mod tests {\n         act.set(28u, true);\n         act.set(29u, true);\n         act.set(30u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u]));\n@@ -1022,7 +1022,7 @@ mod tests {\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u]));\n@@ -1034,14 +1034,14 @@ mod tests {\n         // all 0\n \n         act = Bitv::new(32u, false);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n         act = Bitv::new(32u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n@@ -1056,7 +1056,7 @@ mod tests {\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n@@ -1071,7 +1071,7 @@ mod tests {\n         act.set(21u, true);\n         act.set(22u, true);\n         act.set(23u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n@@ -1086,7 +1086,7 @@ mod tests {\n         act.set(29u, true);\n         act.set(30u, true);\n         act.set(31u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n@@ -1097,7 +1097,7 @@ mod tests {\n         act.set(17u, true);\n         act.set(30u, true);\n         act.set(31u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 1u]));\n@@ -1109,14 +1109,14 @@ mod tests {\n         // all 0\n \n         act = Bitv::new(33u, false);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n         act = Bitv::new(33u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n@@ -1131,7 +1131,7 @@ mod tests {\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n@@ -1146,7 +1146,7 @@ mod tests {\n         act.set(21u, true);\n         act.set(22u, true);\n         act.set(23u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n@@ -1161,7 +1161,7 @@ mod tests {\n         act.set(29u, true);\n         act.set(30u, true);\n         act.set(31u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 0u]));\n@@ -1173,7 +1173,7 @@ mod tests {\n         act.set(30u, true);\n         act.set(31u, true);\n         act.set(32u, true);\n-        fail_unless!(act.eq_vec(\n+        assert!(act.eq_vec(\n                        ~[0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 1u, 1u]));\n@@ -1183,14 +1183,14 @@ mod tests {\n     pub fn test_equal_differing_sizes() {\n         let v0 = Bitv::new(10u, false);\n         let v1 = Bitv::new(11u, false);\n-        fail_unless!(!v0.equal(&v1));\n+        assert!(!v0.equal(&v1));\n     }\n \n     #[test]\n     pub fn test_equal_greatly_differing_sizes() {\n         let v0 = Bitv::new(10u, false);\n         let v1 = Bitv::new(110u, false);\n-        fail_unless!(!v0.equal(&v1));\n+        assert!(!v0.equal(&v1));\n     }\n \n     #[test]\n@@ -1201,7 +1201,7 @@ mod tests {\n         let mut b = bitv::Bitv::new(1, true);\n         b.set(0, true);\n \n-        fail_unless!(a.equal(&b));\n+        assert!(a.equal(&b));\n     }\n \n     #[test]\n@@ -1216,38 +1216,38 @@ mod tests {\n             b.set(i, true);\n         }\n \n-        fail_unless!(a.equal(&b));\n+        assert!(a.equal(&b));\n     }\n \n     #[test]\n     pub fn test_from_bytes() {\n         let bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n         let str = ~\"10110110\" + ~\"00000000\" + ~\"11111111\";\n-        fail_unless!(bitv.to_str() == str);\n+        assert!(bitv.to_str() == str);\n     }\n \n     #[test]\n     pub fn test_to_bytes() {\n         let mut bv = Bitv::new(3, true);\n         bv.set(1, false);\n-        fail_unless!(bv.to_bytes() == ~[0b10100000]);\n+        assert!(bv.to_bytes() == ~[0b10100000]);\n \n         let mut bv = Bitv::new(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n-        fail_unless!(bv.to_bytes() == ~[0b00100000, 0b10000000]);\n+        assert!(bv.to_bytes() == ~[0b00100000, 0b10000000]);\n     }\n \n     #[test]\n     pub fn test_from_bools() {\n-        fail_unless!(from_bools([true, false, true, true]).to_str() ==\n+        assert!(from_bools([true, false, true, true]).to_str() ==\n             ~\"1011\");\n     }\n \n     #[test]\n     pub fn test_to_bools() {\n         let bools = ~[false, false, true, false, false, true, true, false];\n-        fail_unless!(from_bytes([0b00100110]).to_bools() == bools);\n+        assert!(from_bytes([0b00100110]).to_bools() == bools);\n     }\n \n     #[test]\n@@ -1258,10 +1258,10 @@ mod tests {\n         b1.set(1, true);\n         b2.set(1, true);\n         b2.set(2, true);\n-        fail_unless!(b1.difference(&b2));\n-        fail_unless!(b1[0]);\n-        fail_unless!(!b1[1]);\n-        fail_unless!(!b1[2]);\n+        assert!(b1.difference(&b2));\n+        assert!(b1[0]);\n+        assert!(!b1[1]);\n+        assert!(!b1[2]);\n     }\n \n     #[test]\n@@ -1272,10 +1272,10 @@ mod tests {\n         b1.set(40, true);\n         b2.set(40, true);\n         b2.set(80, true);\n-        fail_unless!(b1.difference(&b2));\n-        fail_unless!(b1[0]);\n-        fail_unless!(!b1[40]);\n-        fail_unless!(!b1[80]);\n+        assert!(b1.difference(&b2));\n+        assert!(b1[0]);\n+        assert!(!b1[40]);\n+        assert!(!b1[80]);\n     }\n \n     #[test]\n@@ -1299,131 +1299,131 @@ mod tests {\n     #[test]\n     pub fn test_bitv_set_basic() {\n         let mut b = BitvSet::new();\n-        fail_unless!(b.insert(3));\n-        fail_unless!(!b.insert(3));\n-        fail_unless!(b.contains(&3));\n-        fail_unless!(b.insert(400));\n-        fail_unless!(!b.insert(400));\n-        fail_unless!(b.contains(&400));\n-        fail_unless!(b.len() == 2);\n+        assert!(b.insert(3));\n+        assert!(!b.insert(3));\n+        assert!(b.contains(&3));\n+        assert!(b.insert(400));\n+        assert!(!b.insert(400));\n+        assert!(b.contains(&400));\n+        assert!(b.len() == 2);\n     }\n \n     #[test]\n     fn test_bitv_set_intersection() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n \n-        fail_unless!(a.insert(11));\n-        fail_unless!(a.insert(1));\n-        fail_unless!(a.insert(3));\n-        fail_unless!(a.insert(77));\n-        fail_unless!(a.insert(103));\n-        fail_unless!(a.insert(5));\n+        assert!(a.insert(11));\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(77));\n+        assert!(a.insert(103));\n+        assert!(a.insert(5));\n \n-        fail_unless!(b.insert(2));\n-        fail_unless!(b.insert(11));\n-        fail_unless!(b.insert(77));\n-        fail_unless!(b.insert(5));\n-        fail_unless!(b.insert(3));\n+        assert!(b.insert(2));\n+        assert!(b.insert(11));\n+        assert!(b.insert(77));\n+        assert!(b.insert(5));\n+        assert!(b.insert(3));\n \n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n         for a.intersection(&b) |x| {\n-            fail_unless!(*x == expected[i]);\n+            assert!(*x == expected[i]);\n             i += 1\n         }\n-        fail_unless!(i == expected.len());\n+        assert!(i == expected.len());\n     }\n \n     #[test]\n     fn test_bitv_set_difference() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n \n-        fail_unless!(a.insert(1));\n-        fail_unless!(a.insert(3));\n-        fail_unless!(a.insert(5));\n-        fail_unless!(a.insert(200));\n-        fail_unless!(a.insert(500));\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(200));\n+        assert!(a.insert(500));\n \n-        fail_unless!(b.insert(3));\n-        fail_unless!(b.insert(200));\n+        assert!(b.insert(3));\n+        assert!(b.insert(200));\n \n         let mut i = 0;\n         let expected = [1, 5, 500];\n         for a.difference(&b) |x| {\n-            fail_unless!(*x == expected[i]);\n+            assert!(*x == expected[i]);\n             i += 1\n         }\n-        fail_unless!(i == expected.len());\n+        assert!(i == expected.len());\n     }\n \n     #[test]\n     fn test_bitv_set_symmetric_difference() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n \n-        fail_unless!(a.insert(1));\n-        fail_unless!(a.insert(3));\n-        fail_unless!(a.insert(5));\n-        fail_unless!(a.insert(9));\n-        fail_unless!(a.insert(11));\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(9));\n+        assert!(a.insert(11));\n \n-        fail_unless!(b.insert(3));\n-        fail_unless!(b.insert(9));\n-        fail_unless!(b.insert(14));\n-        fail_unless!(b.insert(220));\n+        assert!(b.insert(3));\n+        assert!(b.insert(9));\n+        assert!(b.insert(14));\n+        assert!(b.insert(220));\n \n         let mut i = 0;\n         let expected = [1, 5, 11, 14, 220];\n         for a.symmetric_difference(&b) |x| {\n-            fail_unless!(*x == expected[i]);\n+            assert!(*x == expected[i]);\n             i += 1\n         }\n-        fail_unless!(i == expected.len());\n+        assert!(i == expected.len());\n     }\n \n     #[test]\n     pub fn test_bitv_set_union() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n-        fail_unless!(a.insert(1));\n-        fail_unless!(a.insert(3));\n-        fail_unless!(a.insert(5));\n-        fail_unless!(a.insert(9));\n-        fail_unless!(a.insert(11));\n-        fail_unless!(a.insert(160));\n-        fail_unless!(a.insert(19));\n-        fail_unless!(a.insert(24));\n-\n-        fail_unless!(b.insert(1));\n-        fail_unless!(b.insert(5));\n-        fail_unless!(b.insert(9));\n-        fail_unless!(b.insert(13));\n-        fail_unless!(b.insert(19));\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(9));\n+        assert!(a.insert(11));\n+        assert!(a.insert(160));\n+        assert!(a.insert(19));\n+        assert!(a.insert(24));\n+\n+        assert!(b.insert(1));\n+        assert!(b.insert(5));\n+        assert!(b.insert(9));\n+        assert!(b.insert(13));\n+        assert!(b.insert(19));\n \n         let mut i = 0;\n         let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160];\n         for a.union(&b) |x| {\n-            fail_unless!(*x == expected[i]);\n+            assert!(*x == expected[i]);\n             i += 1\n         }\n-        fail_unless!(i == expected.len());\n+        assert!(i == expected.len());\n     }\n \n     #[test]\n     pub fn test_bitv_remove() {\n         let mut a = BitvSet::new();\n \n-        fail_unless!(a.insert(1));\n-        fail_unless!(a.remove(&1));\n+        assert!(a.insert(1));\n+        assert!(a.remove(&1));\n \n-        fail_unless!(a.insert(100));\n-        fail_unless!(a.remove(&100));\n+        assert!(a.insert(100));\n+        assert!(a.remove(&100));\n \n-        fail_unless!(a.insert(1000));\n-        fail_unless!(a.remove(&1000));\n-        fail_unless!(a.capacity() == uint::bits);\n+        assert!(a.insert(1000));\n+        assert!(a.remove(&1000));\n+        assert!(a.capacity() == uint::bits);\n     }\n \n     fn rng() -> @rand::Rng {"}, {"sha": "113c8130349ff92068b64ba07b173da36c2f361b", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -122,7 +122,7 @@ pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: @fn())\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n pub fn get<T:Copy>(t: CVec<T>, ofs: uint) -> T {\n-    fail_unless!(ofs < len(t));\n+    assert!(ofs < len(t));\n     return unsafe { *ptr::mut_offset(t.base, ofs) };\n }\n \n@@ -132,7 +132,7 @@ pub fn get<T:Copy>(t: CVec<T>, ofs: uint) -> T {\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n pub fn set<T:Copy>(t: CVec<T>, ofs: uint, v: T) {\n-    fail_unless!(ofs < len(t));\n+    assert!(ofs < len(t));\n     unsafe { *ptr::mut_offset(t.base, ofs) = v };\n }\n \n@@ -159,7 +159,7 @@ mod tests {\n         unsafe {\n             let mem = libc::malloc(n);\n \n-            fail_unless!(mem as int != 0);\n+            assert!(mem as int != 0);\n \n             return unsafe { c_vec_with_dtor(mem as *mut u8, n as uint,\n                                          || unsafe { free(mem) }) };\n@@ -172,9 +172,9 @@ mod tests {\n \n         set(cv, 3u, 8u8);\n         set(cv, 4u, 9u8);\n-        fail_unless!(get(cv, 3u) == 8u8);\n-        fail_unless!(get(cv, 4u) == 9u8);\n-        fail_unless!(len(cv) == 16u);\n+        assert!(get(cv, 3u) == 8u8);\n+        assert!(get(cv, 4u) == 9u8);\n+        assert!(len(cv) == 16u);\n     }\n \n     #[test]\n@@ -202,7 +202,7 @@ mod tests {\n \n         set(cv, 0u, 32u8);\n         set(cv, 1u, 33u8);\n-        fail_unless!(unsafe { *p } == 32u8);\n+        assert!(unsafe { *p } == 32u8);\n         set(cv, 2u, 34u8); /* safety */\n     }\n "}, {"sha": "5d7f64a7c8fa0427a2f82d5ce3bf98f6da689f7c", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -53,15 +53,15 @@ impl FuzzyEq<f64> for f64 {\n \n #[test]\n fn test_fuzzy_equals() {\n-    fail_unless!((&1.0f).fuzzy_eq(&1.0));\n-    fail_unless!((&1.0f32).fuzzy_eq(&1.0f32));\n-    fail_unless!((&1.0f64).fuzzy_eq(&1.0f64));\n+    assert!((&1.0f).fuzzy_eq(&1.0));\n+    assert!((&1.0f32).fuzzy_eq(&1.0f32));\n+    assert!((&1.0f64).fuzzy_eq(&1.0f64));\n }\n \n #[test]\n fn test_fuzzy_eq_eps() {\n-    fail_unless!((&1.2f).fuzzy_eq_eps(&0.9, &0.5));\n-    fail_unless!(!(&1.5f).fuzzy_eq_eps(&0.9, &0.5));\n+    assert!((&1.2f).fuzzy_eq_eps(&0.9, &0.5));\n+    assert!(!(&1.5f).fuzzy_eq_eps(&0.9, &0.5));\n }\n \n #[test]\n@@ -87,16 +87,16 @@ mod test_complex{\n         let a = Complex {r: 0.9, i: 0.9};\n         let b = Complex {r: 0.9, i: 0.9};\n \n-        fail_unless!((a.fuzzy_eq(&b)));\n+        assert!((a.fuzzy_eq(&b)));\n     }\n \n     #[test]\n     fn test_fuzzy_eq_eps() {\n         let other = Complex {r: 0.9, i: 0.9};\n \n-        fail_unless!((&Complex {r: 0.9, i: 1.2}).fuzzy_eq_eps(&other, &0.5));\n-        fail_unless!((&Complex {r: 1.2, i: 0.9}).fuzzy_eq_eps(&other, &0.5));\n-        fail_unless!(!(&Complex {r: 0.9, i: 1.5}).fuzzy_eq_eps(&other, &0.5));\n-        fail_unless!(!(&Complex {r: 1.5, i: 0.9}).fuzzy_eq_eps(&other, &0.5));\n+        assert!((&Complex {r: 0.9, i: 1.2}).fuzzy_eq_eps(&other, &0.5));\n+        assert!((&Complex {r: 1.2, i: 0.9}).fuzzy_eq_eps(&other, &0.5));\n+        assert!(!(&Complex {r: 0.9, i: 1.5}).fuzzy_eq_eps(&other, &0.5));\n+        assert!(!(&Complex {r: 1.5, i: 0.9}).fuzzy_eq_eps(&other, &0.5));\n     }\n }"}, {"sha": "0e0347406aecf4f56ed09a3c7127a58e814c62d6", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -105,7 +105,7 @@ mod test {\n         left.send(~\"abc\");\n         right.send(123);\n \n-        fail_unless!(left.recv() == 123);\n-        fail_unless!(right.recv() == ~\"abc\");\n+        assert!(left.recv() == 123);\n+        assert!(right.recv() == ~\"abc\");\n     }\n }"}, {"sha": "e029b882472f08a4c6722d95cff03ee94ac8c29f", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -120,7 +120,7 @@ pub impl<T> Deque<T> {\n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere.\n fn grow<T>(nelts: uint, lo: uint, elts: &mut [Option<T>]) -> ~[Option<T>] {\n-    fail_unless!(nelts == elts.len());\n+    assert!(nelts == elts.len());\n     let mut rv = ~[];\n \n     do rv.grow_fn(nelts + 1) |i| {\n@@ -145,46 +145,46 @@ mod tests {\n     #[test]\n     fn test_simple() {\n         let mut d = Deque::new();\n-        fail_unless!(d.len() == 0u);\n+        assert!(d.len() == 0u);\n         d.add_front(17);\n         d.add_front(42);\n         d.add_back(137);\n-        fail_unless!(d.len() == 3u);\n+        assert!(d.len() == 3u);\n         d.add_back(137);\n-        fail_unless!(d.len() == 4u);\n+        assert!(d.len() == 4u);\n         debug!(d.peek_front());\n-        fail_unless!(*d.peek_front() == 42);\n+        assert!(*d.peek_front() == 42);\n         debug!(d.peek_back());\n-        fail_unless!(*d.peek_back() == 137);\n+        assert!(*d.peek_back() == 137);\n         let mut i: int = d.pop_front();\n         debug!(i);\n-        fail_unless!(i == 42);\n+        assert!(i == 42);\n         i = d.pop_back();\n         debug!(i);\n-        fail_unless!(i == 137);\n+        assert!(i == 137);\n         i = d.pop_back();\n         debug!(i);\n-        fail_unless!(i == 137);\n+        assert!(i == 137);\n         i = d.pop_back();\n         debug!(i);\n-        fail_unless!(i == 17);\n-        fail_unless!(d.len() == 0u);\n+        assert!(i == 17);\n+        assert!(d.len() == 0u);\n         d.add_back(3);\n-        fail_unless!(d.len() == 1u);\n+        assert!(d.len() == 1u);\n         d.add_front(2);\n-        fail_unless!(d.len() == 2u);\n+        assert!(d.len() == 2u);\n         d.add_back(4);\n-        fail_unless!(d.len() == 3u);\n+        assert!(d.len() == 3u);\n         d.add_front(1);\n-        fail_unless!(d.len() == 4u);\n+        assert!(d.len() == 4u);\n         debug!(d.get(0));\n         debug!(d.get(1));\n         debug!(d.get(2));\n         debug!(d.get(3));\n-        fail_unless!(*d.get(0) == 1);\n-        fail_unless!(*d.get(1) == 2);\n-        fail_unless!(*d.get(2) == 3);\n-        fail_unless!(*d.get(3) == 4);\n+        assert!(*d.get(0) == 1);\n+        assert!(*d.get(1) == 2);\n+        assert!(*d.get(2) == 3);\n+        assert!(*d.get(3) == 4);\n     }\n \n     #[test]\n@@ -195,62 +195,62 @@ mod tests {\n         let d: @int = @175;\n \n         let mut deq = Deque::new();\n-        fail_unless!(deq.len() == 0);\n+        assert!(deq.len() == 0);\n         deq.add_front(a);\n         deq.add_front(b);\n         deq.add_back(c);\n-        fail_unless!(deq.len() == 3);\n+        assert!(deq.len() == 3);\n         deq.add_back(d);\n-        fail_unless!(deq.len() == 4);\n-        fail_unless!(*deq.peek_front() == b);\n-        fail_unless!(*deq.peek_back() == d);\n-        fail_unless!(deq.pop_front() == b);\n-        fail_unless!(deq.pop_back() == d);\n-        fail_unless!(deq.pop_back() == c);\n-        fail_unless!(deq.pop_back() == a);\n-        fail_unless!(deq.len() == 0);\n+        assert!(deq.len() == 4);\n+        assert!(*deq.peek_front() == b);\n+        assert!(*deq.peek_back() == d);\n+        assert!(deq.pop_front() == b);\n+        assert!(deq.pop_back() == d);\n+        assert!(deq.pop_back() == c);\n+        assert!(deq.pop_back() == a);\n+        assert!(deq.len() == 0);\n         deq.add_back(c);\n-        fail_unless!(deq.len() == 1);\n+        assert!(deq.len() == 1);\n         deq.add_front(b);\n-        fail_unless!(deq.len() == 2);\n+        assert!(deq.len() == 2);\n         deq.add_back(d);\n-        fail_unless!(deq.len() == 3);\n+        assert!(deq.len() == 3);\n         deq.add_front(a);\n-        fail_unless!(deq.len() == 4);\n-        fail_unless!(*deq.get(0) == a);\n-        fail_unless!(*deq.get(1) == b);\n-        fail_unless!(*deq.get(2) == c);\n-        fail_unless!(*deq.get(3) == d);\n+        assert!(deq.len() == 4);\n+        assert!(*deq.get(0) == a);\n+        assert!(*deq.get(1) == b);\n+        assert!(*deq.get(2) == c);\n+        assert!(*deq.get(3) == d);\n     }\n \n     fn test_parameterized<T:Copy + Eq + Durable>(a: T, b: T, c: T, d: T) {\n         let mut deq = Deque::new();\n-        fail_unless!(deq.len() == 0);\n+        assert!(deq.len() == 0);\n         deq.add_front(a);\n         deq.add_front(b);\n         deq.add_back(c);\n-        fail_unless!(deq.len() == 3);\n+        assert!(deq.len() == 3);\n         deq.add_back(d);\n-        fail_unless!(deq.len() == 4);\n-        fail_unless!(*deq.peek_front() == b);\n-        fail_unless!(*deq.peek_back() == d);\n-        fail_unless!(deq.pop_front() == b);\n-        fail_unless!(deq.pop_back() == d);\n-        fail_unless!(deq.pop_back() == c);\n-        fail_unless!(deq.pop_back() == a);\n-        fail_unless!(deq.len() == 0);\n+        assert!(deq.len() == 4);\n+        assert!(*deq.peek_front() == b);\n+        assert!(*deq.peek_back() == d);\n+        assert!(deq.pop_front() == b);\n+        assert!(deq.pop_back() == d);\n+        assert!(deq.pop_back() == c);\n+        assert!(deq.pop_back() == a);\n+        assert!(deq.len() == 0);\n         deq.add_back(c);\n-        fail_unless!(deq.len() == 1);\n+        assert!(deq.len() == 1);\n         deq.add_front(b);\n-        fail_unless!(deq.len() == 2);\n+        assert!(deq.len() == 2);\n         deq.add_back(d);\n-        fail_unless!(deq.len() == 3);\n+        assert!(deq.len() == 3);\n         deq.add_front(a);\n-        fail_unless!(deq.len() == 4);\n-        fail_unless!(*deq.get(0) == a);\n-        fail_unless!(*deq.get(1) == b);\n-        fail_unless!(*deq.get(2) == c);\n-        fail_unless!(*deq.get(3) == d);\n+        assert!(deq.len() == 4);\n+        assert!(*deq.get(0) == a);\n+        assert!(*deq.get(1) == b);\n+        assert!(*deq.get(2) == c);\n+        assert!(*deq.get(3) == d);\n     }\n \n     #[deriving(Eq)]"}, {"sha": "bc9fc3553fe2f7bce782b104089b381ff8141b35", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -179,22 +179,22 @@ pub mod reader {\n     pub fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n \n     pub fn doc_as_u8(d: Doc) -> u8 {\n-        fail_unless!(d.end == d.start + 1u);\n+        assert!(d.end == d.start + 1u);\n         (*d.data)[d.start]\n     }\n \n     pub fn doc_as_u16(d: Doc) -> u16 {\n-        fail_unless!(d.end == d.start + 2u);\n+        assert!(d.end == d.start + 2u);\n         io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n-        fail_unless!(d.end == d.start + 4u);\n+        assert!(d.end == d.start + 4u);\n         io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n-        fail_unless!(d.end == d.start + 8u);\n+        assert!(d.end == d.start + 8u);\n         io::u64_from_be_bytes(*d.data, d.start, 8u)\n     }\n \n@@ -559,7 +559,7 @@ pub mod writer {\n     priv impl Encoder {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_uint(&self, t: EbmlEncoderTag, v: uint) {\n-            fail_unless!(v <= 0xFFFF_FFFF_u);\n+            assert!(v <= 0xFFFF_FFFF_u);\n             self.wr_tagged_u32(t as uint, v as u32);\n         }\n \n@@ -713,7 +713,7 @@ mod tests {\n             let deser = reader::Decoder(ebml_doc);\n             let v1 = serialize::Decodable::decode(&deser);\n             debug!(\"v1 == %?\", v1);\n-            fail_unless!(v == v1);\n+            assert!(v == v1);\n         }\n \n         test_v(Some(22));"}, {"sha": "74e7ad9dc3f6d1cc1c4ea2590e079724ec9f359e", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -358,8 +358,8 @@ pub mod flatteners {\n \n     impl<T:Copy + Owned> Unflattener<T> for PodUnflattener<T> {\n         fn unflatten(&self, buf: ~[u8]) -> T {\n-            fail_unless!(size_of::<T>() != 0);\n-            fail_unless!(size_of::<T>() == buf.len());\n+            assert!(size_of::<T>() != 0);\n+            assert!(size_of::<T>() == buf.len());\n             let addr_of_init: &u8 = unsafe { &*vec::raw::to_ptr(buf) };\n             let addr_of_value: &T = unsafe { cast::transmute(addr_of_init) };\n             copy *addr_of_value\n@@ -368,7 +368,7 @@ pub mod flatteners {\n \n     impl<T:Copy + Owned> Flattener<T> for PodFlattener<T> {\n         fn flatten(&self, val: T) -> ~[u8] {\n-            fail_unless!(size_of::<T>() != 0);\n+            assert!(size_of::<T>() != 0);\n             let val: *T = ptr::to_unsafe_ptr(&val);\n             let byte_value = val as *u8;\n             unsafe { vec::from_buf(byte_value, size_of::<T>()) }\n@@ -519,11 +519,11 @@ pub mod bytepipes {\n             let mut left = count;\n             let mut bytes = ~[];\n             while !self.reader.eof() && left > 0 {\n-                fail_unless!(left <= count);\n-                fail_unless!(left > 0);\n+                assert!(left <= count);\n+                assert!(left > 0);\n                 let new_bytes = self.reader.read_bytes(left);\n                 bytes.push_all(new_bytes);\n-                fail_unless!(new_bytes.len() <= left);\n+                assert!(new_bytes.len() <= left);\n                 left -= new_bytes.len();\n             }\n \n@@ -576,7 +576,7 @@ pub mod bytepipes {\n                 return Some(bytes);\n             } else if vec::uniq_len(&const self.buf) > 0 {\n                 let mut bytes = ::core::util::replace(&mut self.buf, ~[]);\n-                fail_unless!(count > bytes.len());\n+                assert!(count > bytes.len());\n                 match self.try_recv(count - bytes.len()) {\n                     Some(rest) => {\n                         bytes.push_all(rest);\n@@ -587,7 +587,7 @@ pub mod bytepipes {\n             } else if vec::uniq_len(&const self.buf) == 0 {\n                 match self.port.try_recv() {\n                     Some(buf) => {\n-                        fail_unless!(!buf.is_empty());\n+                        assert!(!buf.is_empty());\n                         self.buf = buf;\n                         return self.try_recv(count);\n                     }\n@@ -655,7 +655,7 @@ mod test {\n         let port = serial::reader_port(reader);\n \n         let res: int = port.recv();\n-        fail_unless!(res == 10i);\n+        assert!(res == 10i);\n     }\n \n     #[test]\n@@ -669,7 +669,7 @@ mod test {\n         }\n \n         for int::range(0, 10) |i| {\n-            fail_unless!(i == port.recv())\n+            assert!(i == port.recv())\n         }\n     }\n \n@@ -684,7 +684,7 @@ mod test {\n         }\n \n         for int::range(0, 10) |i| {\n-            fail_unless!(@i == port.recv())\n+            assert!(@i == port.recv())\n         }\n     }\n \n@@ -701,7 +701,7 @@ mod test {\n         let port = pod::reader_port(reader);\n \n         let res: int = port.recv();\n-        fail_unless!(res == 10);\n+        assert!(res == 10);\n     }\n \n     #[test]\n@@ -715,7 +715,7 @@ mod test {\n         }\n \n         for int::range(0, 10) |i| {\n-            fail_unless!(i == port.recv())\n+            assert!(i == port.recv())\n         }\n     }\n \n@@ -799,7 +799,7 @@ mod test {\n                 kill_ch.send(None)\n             };\n \n-            fail_unless!(listen_res.is_ok());\n+            assert!(listen_res.is_ok());\n         }\n \n         // Client task\n@@ -812,7 +812,7 @@ mod test {\n             debug!(\"connecting\");\n             let iotask = &uv::global_loop::get();\n             let connect_result = tcp::connect(copy addr, port, iotask);\n-            fail_unless!(connect_result.is_ok());\n+            assert!(connect_result.is_ok());\n             let sock = result::unwrap(connect_result);\n             let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(sock);\n \n@@ -833,7 +833,7 @@ mod test {\n             debug!(\"accepting connection\");\n             let accept_result = tcp::accept(conn);\n             debug!(\"accepted\");\n-            fail_unless!(accept_result.is_ok());\n+            assert!(accept_result.is_ok());\n             let sock = result::unwrap(accept_result);\n             res_chan.send(());\n \n@@ -845,7 +845,7 @@ mod test {\n             for int::range(0, 10) |i| {\n                 let j = port.recv();\n                 debug!(\"receieved %?\", j);\n-                fail_unless!(i == j);\n+                assert!(i == j);\n             }\n \n             // The test is over!\n@@ -891,7 +891,7 @@ mod test {\n             let bytes = ~[];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n-            fail_unless!(res.is_none());\n+            assert!(res.is_none());\n         }\n \n         #[test]\n@@ -908,7 +908,7 @@ mod test {\n             let bytes = ~[0];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n-            fail_unless!(res.is_none());\n+            assert!(res.is_none());\n         }\n \n         #[test]\n@@ -926,7 +926,7 @@ mod test {\n             let bytes = CONTINUE.to_vec() + ~[0];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n-            fail_unless!(res.is_none());\n+            assert!(res.is_none());\n         }\n \n         #[test]\n@@ -939,7 +939,7 @@ mod test {\n         }\n \n         fn test_try_recv_none4<P:BytePort>(+loader: PortLoader<P>) {\n-            fail_unless!(do task::try || {\n+            assert!(do task::try || {\n                 static CONTINUE: [u8, ..4] = [0xAA, 0xBB, 0xCC, 0xDD];\n                 // The control word is followed by a valid length,\n                 // then undeserializable garbage"}, {"sha": "a4887306d2a93cdf649823cb6061aa885064caf5", "filename": "src/libstd/future.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -155,39 +155,39 @@ pub mod test {\n     #[test]\n     pub fn test_from_value() {\n         let f = from_value(~\"snail\");\n-        fail_unless!(f.get() == ~\"snail\");\n+        assert!(f.get() == ~\"snail\");\n     }\n \n     #[test]\n     pub fn test_from_port() {\n         let (ch, po) = oneshot::init();\n         send_one(ch, ~\"whale\");\n         let f = from_port(po);\n-        fail_unless!(f.get() == ~\"whale\");\n+        assert!(f.get() == ~\"whale\");\n     }\n \n     #[test]\n     pub fn test_from_fn() {\n         let f = from_fn(|| ~\"brail\");\n-        fail_unless!(f.get() == ~\"brail\");\n+        assert!(f.get() == ~\"brail\");\n     }\n \n     #[test]\n     pub fn test_interface_get() {\n         let f = from_value(~\"fail\");\n-        fail_unless!(f.get() == ~\"fail\");\n+        assert!(f.get() == ~\"fail\");\n     }\n \n     #[test]\n     pub fn test_get_ref_method() {\n         let f = from_value(22);\n-        fail_unless!(*f.get_ref() == 22);\n+        assert!(*f.get_ref() == 22);\n     }\n \n     #[test]\n     pub fn test_spawn() {\n         let f = spawn(|| ~\"bale\");\n-        fail_unless!(f.get() == ~\"bale\");\n+        assert!(f.get() == ~\"bale\");\n     }\n \n     #[test]\n@@ -204,7 +204,7 @@ pub mod test {\n         let f = do spawn { copy expected };\n         do task::spawn || {\n             let actual = f.get();\n-            fail_unless!(actual == expected);\n+            assert!(actual == expected);\n         }\n     }\n }"}, {"sha": "df37c48ebe8b8b1704ca7a8c4923cea1eaac0339", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -484,7 +484,7 @@ pub mod groups {\n     pub fn reqopt(short_name: &str, long_name: &str,\n                   desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n-        fail_unless!(len == 1 || len == 0);\n+        assert!(len == 1 || len == 0);\n         return OptGroup { short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n@@ -497,7 +497,7 @@ pub mod groups {\n     pub fn optopt(short_name: &str, long_name: &str,\n                   desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n-        fail_unless!(len == 1 || len == 0);\n+        assert!(len == 1 || len == 0);\n         return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n@@ -510,7 +510,7 @@ pub mod groups {\n     pub fn optflag(short_name: &str, long_name: &str,\n                    desc: &str) -> OptGroup {\n         let len = short_name.len();\n-        fail_unless!(len == 1 || len == 0);\n+        assert!(len == 1 || len == 0);\n         return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: ~\"\",\n@@ -523,7 +523,7 @@ pub mod groups {\n     pub fn optflagopt(short_name: &str, long_name: &str,\n                       desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n-        fail_unless!(len == 1 || len == 0);\n+        assert!(len == 1 || len == 0);\n         return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n@@ -539,7 +539,7 @@ pub mod groups {\n     pub fn optmulti(short_name: &str, long_name: &str,\n                     desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n-        fail_unless!(len == 1 || len == 0);\n+        assert!(len == 1 || len == 0);\n         return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n@@ -666,11 +666,11 @@ mod tests {\n \n     pub fn check_fail_type(f: Fail_, ft: FailType) {\n         match f {\n-          ArgumentMissing(_) => fail_unless!(ft == ArgumentMissing_),\n-          UnrecognizedOption(_) => fail_unless!(ft == UnrecognizedOption_),\n-          OptionMissing(_) => fail_unless!(ft == OptionMissing_),\n-          OptionDuplicated(_) => fail_unless!(ft == OptionDuplicated_),\n-          UnexpectedArgument(_) => fail_unless!(ft == UnexpectedArgument_)\n+          ArgumentMissing(_) => assert!(ft == ArgumentMissing_),\n+          UnrecognizedOption(_) => assert!(ft == UnrecognizedOption_),\n+          OptionMissing(_) => assert!(ft == OptionMissing_),\n+          OptionDuplicated(_) => assert!(ft == OptionDuplicated_),\n+          UnexpectedArgument(_) => assert!(ft == UnexpectedArgument_)\n         }\n     }\n \n@@ -683,8 +683,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            fail_unless!((opt_present(m, ~\"test\")));\n-            fail_unless!((opt_str(m, ~\"test\") == ~\"20\"));\n+            assert!((opt_present(m, ~\"test\")));\n+            assert!((opt_str(m, ~\"test\") == ~\"20\"));\n           }\n           _ => { fail!(~\"test_reqopt_long failed\"); }\n         }\n@@ -730,8 +730,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            fail_unless!((opt_present(m, ~\"t\")));\n-            fail_unless!((opt_str(m, ~\"t\") == ~\"20\"));\n+            assert!((opt_present(m, ~\"t\")));\n+            assert!((opt_str(m, ~\"t\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -779,8 +779,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            fail_unless!((opt_present(m, ~\"test\")));\n-            fail_unless!((opt_str(m, ~\"test\") == ~\"20\"));\n+            assert!((opt_present(m, ~\"test\")));\n+            assert!((opt_str(m, ~\"test\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -792,7 +792,7 @@ mod tests {\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => fail_unless!(!opt_present(m, ~\"test\")),\n+          Ok(ref m) => assert!(!opt_present(m, ~\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -826,8 +826,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            fail_unless!((opt_present(m, ~\"t\")));\n-            fail_unless!((opt_str(m, ~\"t\") == ~\"20\"));\n+            assert!((opt_present(m, ~\"t\")));\n+            assert!((opt_str(m, ~\"t\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -839,7 +839,7 @@ mod tests {\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => fail_unless!(!opt_present(m, ~\"t\")),\n+          Ok(ref m) => assert!(!opt_present(m, ~\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -874,7 +874,7 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => fail_unless!(opt_present(m, ~\"test\")),\n+          Ok(ref m) => assert!(opt_present(m, ~\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -885,7 +885,7 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => fail_unless!(!opt_present(m, ~\"test\")),\n+          Ok(ref m) => assert!(!opt_present(m, ~\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -921,7 +921,7 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => fail_unless!(opt_present(m, ~\"t\")),\n+          Ok(ref m) => assert!(opt_present(m, ~\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -932,7 +932,7 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => fail_unless!(!opt_present(m, ~\"t\")),\n+          Ok(ref m) => assert!(!opt_present(m, ~\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -946,7 +946,7 @@ mod tests {\n           Ok(ref m) => {\n             // The next variable after the flag is just a free argument\n \n-            fail_unless!((m.free[0] == ~\"20\"));\n+            assert!((m.free[0] == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -971,7 +971,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            fail_unless!((opt_count(m, ~\"v\") == 1));\n+            assert!((opt_count(m, ~\"v\") == 1));\n           }\n           _ => fail!()\n         }\n@@ -984,7 +984,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            fail_unless!((opt_count(m, ~\"v\") == 2));\n+            assert!((opt_count(m, ~\"v\") == 2));\n           }\n           _ => fail!()\n         }\n@@ -997,7 +997,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            fail_unless!((opt_count(m, ~\"v\") == 2));\n+            assert!((opt_count(m, ~\"v\") == 2));\n           }\n           _ => fail!()\n         }\n@@ -1010,7 +1010,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            fail_unless!((opt_count(m, ~\"verbose\") == 1));\n+            assert!((opt_count(m, ~\"verbose\") == 1));\n           }\n           _ => fail!()\n         }\n@@ -1023,7 +1023,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            fail_unless!((opt_count(m, ~\"verbose\") == 2));\n+            assert!((opt_count(m, ~\"verbose\") == 2));\n           }\n           _ => fail!()\n         }\n@@ -1037,8 +1037,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            fail_unless!((opt_present(m, ~\"test\")));\n-            fail_unless!((opt_str(m, ~\"test\") == ~\"20\"));\n+            assert!((opt_present(m, ~\"test\")));\n+            assert!((opt_str(m, ~\"test\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -1050,7 +1050,7 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => fail_unless!(!opt_present(m, ~\"test\")),\n+          Ok(ref m) => assert!(!opt_present(m, ~\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -1073,11 +1073,11 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-              fail_unless!((opt_present(m, ~\"test\")));\n-              fail_unless!((opt_str(m, ~\"test\") == ~\"20\"));\n+              assert!((opt_present(m, ~\"test\")));\n+              assert!((opt_str(m, ~\"test\") == ~\"20\"));\n               let pair = opt_strs(m, ~\"test\");\n-              fail_unless!((pair[0] == ~\"20\"));\n-              fail_unless!((pair[1] == ~\"30\"));\n+              assert!((pair[0] == ~\"20\"));\n+              assert!((pair[1] == ~\"30\"));\n           }\n           _ => fail!()\n         }\n@@ -1090,8 +1090,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            fail_unless!((opt_present(m, ~\"t\")));\n-            fail_unless!((opt_str(m, ~\"t\") == ~\"20\"));\n+            assert!((opt_present(m, ~\"t\")));\n+            assert!((opt_str(m, ~\"t\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -1103,7 +1103,7 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => fail_unless!(!opt_present(m, ~\"t\")),\n+          Ok(ref m) => assert!(!opt_present(m, ~\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -1126,11 +1126,11 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            fail_unless!((opt_present(m, ~\"t\")));\n-            fail_unless!((opt_str(m, ~\"t\") == ~\"20\"));\n+            assert!((opt_present(m, ~\"t\")));\n+            assert!((opt_str(m, ~\"t\") == ~\"20\"));\n             let pair = opt_strs(m, ~\"t\");\n-            fail_unless!((pair[0] == ~\"20\"));\n-            fail_unless!((pair[1] == ~\"30\"));\n+            assert!((pair[0] == ~\"20\"));\n+            assert!((pair[1] == ~\"30\"));\n           }\n           _ => fail!()\n         }\n@@ -1171,20 +1171,20 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            fail_unless!((m.free[0] == ~\"prog\"));\n-            fail_unless!((m.free[1] == ~\"free1\"));\n-            fail_unless!((opt_str(m, ~\"s\") == ~\"20\"));\n-            fail_unless!((m.free[2] == ~\"free2\"));\n-            fail_unless!((opt_present(m, ~\"flag\")));\n-            fail_unless!((opt_str(m, ~\"long\") == ~\"30\"));\n-            fail_unless!((opt_present(m, ~\"f\")));\n+            assert!((m.free[0] == ~\"prog\"));\n+            assert!((m.free[1] == ~\"free1\"));\n+            assert!((opt_str(m, ~\"s\") == ~\"20\"));\n+            assert!((m.free[2] == ~\"free2\"));\n+            assert!((opt_present(m, ~\"flag\")));\n+            assert!((opt_str(m, ~\"long\") == ~\"30\"));\n+            assert!((opt_present(m, ~\"f\")));\n             let pair = opt_strs(m, ~\"m\");\n-            fail_unless!((pair[0] == ~\"40\"));\n-            fail_unless!((pair[1] == ~\"50\"));\n+            assert!((pair[0] == ~\"40\"));\n+            assert!((pair[1] == ~\"50\"));\n             let pair = opt_strs(m, ~\"n\");\n-            fail_unless!((pair[0] == ~\"-A B\"));\n-            fail_unless!((pair[1] == ~\"-60 70\"));\n-            fail_unless!((!opt_present(m, ~\"notpresent\")));\n+            assert!((pair[0] == ~\"-A B\"));\n+            assert!((pair[1] == ~\"-60 70\"));\n+            assert!((!opt_present(m, ~\"notpresent\")));\n           }\n           _ => fail!()\n         }\n@@ -1198,18 +1198,18 @@ mod tests {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        fail_unless!(opts_present(matches, ~[~\"e\"]));\n-        fail_unless!(opts_present(matches, ~[~\"encrypt\"]));\n-        fail_unless!(opts_present(matches, ~[~\"encrypt\", ~\"e\"]));\n-        fail_unless!(opts_present(matches, ~[~\"e\", ~\"encrypt\"]));\n-        fail_unless!(!opts_present(matches, ~[~\"f\"]));\n-        fail_unless!(!opts_present(matches, ~[~\"thing\"]));\n-        fail_unless!(!opts_present(matches, ~[]));\n+        assert!(opts_present(matches, ~[~\"e\"]));\n+        assert!(opts_present(matches, ~[~\"encrypt\"]));\n+        assert!(opts_present(matches, ~[~\"encrypt\", ~\"e\"]));\n+        assert!(opts_present(matches, ~[~\"e\", ~\"encrypt\"]));\n+        assert!(!opts_present(matches, ~[~\"f\"]));\n+        assert!(!opts_present(matches, ~[~\"thing\"]));\n+        assert!(!opts_present(matches, ~[]));\n \n-        fail_unless!(opts_str(matches, ~[~\"e\"]) == ~\"foo\");\n-        fail_unless!(opts_str(matches, ~[~\"encrypt\"]) == ~\"foo\");\n-        fail_unless!(opts_str(matches, ~[~\"e\", ~\"encrypt\"]) == ~\"foo\");\n-        fail_unless!(opts_str(matches, ~[~\"encrypt\", ~\"e\"]) == ~\"foo\");\n+        assert!(opts_str(matches, ~[~\"e\"]) == ~\"foo\");\n+        assert!(opts_str(matches, ~[~\"encrypt\"]) == ~\"foo\");\n+        assert!(opts_str(matches, ~[~\"e\", ~\"encrypt\"]) == ~\"foo\");\n+        assert!(opts_str(matches, ~[~\"encrypt\", ~\"e\"]) == ~\"foo\");\n     }\n \n     #[test]\n@@ -1220,17 +1220,17 @@ mod tests {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        fail_unless!(opts_present(matches, ~[~\"L\"]));\n-        fail_unless!(opts_str(matches, ~[~\"L\"]) == ~\"foo\");\n-        fail_unless!(opts_present(matches, ~[~\"M\"]));\n-        fail_unless!(opts_str(matches, ~[~\"M\"]) == ~\".\");\n+        assert!(opts_present(matches, ~[~\"L\"]));\n+        assert!(opts_str(matches, ~[~\"L\"]) == ~\"foo\");\n+        assert!(opts_present(matches, ~[~\"M\"]));\n+        assert!(opts_str(matches, ~[~\"M\"]) == ~\".\");\n \n     }\n \n     #[test]\n     pub fn test_groups_reqopt() {\n         let opt = groups::reqopt(~\"b\", ~\"banana\", ~\"some bananas\", ~\"VAL\");\n-        fail_unless!(opt == OptGroup { short_name: ~\"b\",\n+        assert!(opt == OptGroup { short_name: ~\"b\",\n                         long_name: ~\"banana\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some bananas\",\n@@ -1241,7 +1241,7 @@ mod tests {\n     #[test]\n     pub fn test_groups_optopt() {\n         let opt = groups::optopt(~\"a\", ~\"apple\", ~\"some apples\", ~\"VAL\");\n-        fail_unless!(opt == OptGroup { short_name: ~\"a\",\n+        assert!(opt == OptGroup { short_name: ~\"a\",\n                         long_name: ~\"apple\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some apples\",\n@@ -1252,7 +1252,7 @@ mod tests {\n     #[test]\n     pub fn test_groups_optflag() {\n         let opt = groups::optflag(~\"k\", ~\"kiwi\", ~\"some kiwis\");\n-        fail_unless!(opt == OptGroup { short_name: ~\"k\",\n+        assert!(opt == OptGroup { short_name: ~\"k\",\n                         long_name: ~\"kiwi\",\n                         hint: ~\"\",\n                         desc: ~\"some kiwis\",\n@@ -1264,7 +1264,7 @@ mod tests {\n     pub fn test_groups_optflagopt() {\n         let opt = groups::optflagopt(~\"p\", ~\"pineapple\",\n                                        ~\"some pineapples\", ~\"VAL\");\n-        fail_unless!(opt == OptGroup { short_name: ~\"p\",\n+        assert!(opt == OptGroup { short_name: ~\"p\",\n                         long_name: ~\"pineapple\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some pineapples\",\n@@ -1276,7 +1276,7 @@ mod tests {\n     pub fn test_groups_optmulti() {\n         let opt = groups::optmulti(~\"l\", ~\"lime\",\n                                      ~\"some limes\", ~\"VAL\");\n-        fail_unless!(opt == OptGroup { short_name: ~\"l\",\n+        assert!(opt == OptGroup { short_name: ~\"l\",\n                         long_name: ~\"lime\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some limes\",\n@@ -1290,7 +1290,7 @@ mod tests {\n         let verbose = groups::reqopt(~\"b\", ~\"banana\",\n                                        ~\"some bananas\", ~\"VAL\");\n \n-        fail_unless!(groups::long_to_short(&verbose) == short);\n+        assert!(groups::long_to_short(&verbose) == short);\n     }\n \n     #[test]\n@@ -1315,7 +1315,7 @@ mod tests {\n                             ~\"-p\", ~\"16\", ~\"l\", ~\"35\"];\n \n         // FIXME #4681: sort options here?\n-        fail_unless!(getopts(sample_args, short)\n+        assert!(getopts(sample_args, short)\n             == groups::getopts(sample_args, verbose));\n     }\n \n@@ -1347,7 +1347,7 @@ Options:\n \n         debug!(\"expected: <<%s>>\", expected);\n         debug!(\"generated: <<%s>>\", generated_usage);\n-        fail_unless!(generated_usage == expected);\n+        assert!(generated_usage == expected);\n     }\n \n     #[test]\n@@ -1376,7 +1376,7 @@ Options:\n \n         debug!(\"expected: <<%s>>\", expected);\n         debug!(\"generated: <<%s>>\", usage);\n-        fail_unless!(usage == expected)\n+        assert!(usage == expected)\n     }\n }\n "}, {"sha": "63d461ed4d3bf5327ac066063ab5e8ff1e108c23", "filename": "src/libstd/list.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -165,37 +165,37 @@ mod tests {\n         let full1 = from_vec(~[1]);\n         let full2 = from_vec(~['r', 'u']);\n \n-        fail_unless!(is_empty(empty));\n-        fail_unless!(!is_empty(full1));\n-        fail_unless!(!is_empty(full2));\n+        assert!(is_empty(empty));\n+        assert!(!is_empty(full1));\n+        assert!(!is_empty(full2));\n     }\n \n     #[test]\n     pub fn test_from_vec() {\n         let l = from_vec(~[0, 1, 2]);\n \n-        fail_unless!((head(l) == 0));\n+        assert!((head(l) == 0));\n \n         let tail_l = tail(l);\n-        fail_unless!((head(tail_l) == 1));\n+        assert!((head(tail_l) == 1));\n \n         let tail_tail_l = tail(tail_l);\n-        fail_unless!((head(tail_tail_l) == 2));\n+        assert!((head(tail_tail_l) == 2));\n     }\n \n     #[test]\n     pub fn test_from_vec_empty() {\n         let empty : @list::List<int> = from_vec(~[]);\n-        fail_unless!((empty == @list::Nil::<int>));\n+        assert!((empty == @list::Nil::<int>));\n     }\n \n     #[test]\n     pub fn test_foldl() {\n         fn add(a: &uint, b: &int) -> uint { return *a + (*b as uint); }\n         let l = from_vec(~[0, 1, 2, 3, 4]);\n         let empty = @list::Nil::<int>;\n-        fail_unless!((list::foldl(0u, l, add) == 10u));\n-        fail_unless!((list::foldl(0u, empty, add) == 0u));\n+        assert!((list::foldl(0u, l, add) == 10u));\n+        assert!((list::foldl(0u, empty, add) == 0u));\n     }\n \n     #[test]\n@@ -204,46 +204,46 @@ mod tests {\n             *a - *b\n         }\n         let l = from_vec(~[1, 2, 3, 4]);\n-        fail_unless!((list::foldl(0, l, sub) == -10));\n+        assert!((list::foldl(0, l, sub) == -10));\n     }\n \n     #[test]\n     pub fn test_find_success() {\n         fn match_(i: &int) -> bool { return *i == 2; }\n         let l = from_vec(~[0, 1, 2]);\n-        fail_unless!((list::find(l, match_) == option::Some(2)));\n+        assert!((list::find(l, match_) == option::Some(2)));\n     }\n \n     #[test]\n     pub fn test_find_fail() {\n         fn match_(_i: &int) -> bool { return false; }\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::Nil::<int>;\n-        fail_unless!((list::find(l, match_) == option::None::<int>));\n-        fail_unless!((list::find(empty, match_) == option::None::<int>));\n+        assert!((list::find(l, match_) == option::None::<int>));\n+        assert!((list::find(empty, match_) == option::None::<int>));\n     }\n \n     #[test]\n     pub fn test_has() {\n         let l = from_vec(~[5, 8, 6]);\n         let empty = @list::Nil::<int>;\n-        fail_unless!((list::has(l, 5)));\n-        fail_unless!((!list::has(l, 7)));\n-        fail_unless!((list::has(l, 8)));\n-        fail_unless!((!list::has(empty, 5)));\n+        assert!((list::has(l, 5)));\n+        assert!((!list::has(l, 7)));\n+        assert!((list::has(l, 8)));\n+        assert!((!list::has(empty, 5)));\n     }\n \n     #[test]\n     pub fn test_len() {\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::Nil::<int>;\n-        fail_unless!((list::len(l) == 3u));\n-        fail_unless!((list::len(empty) == 0u));\n+        assert!((list::len(l) == 3u));\n+        assert!((list::len(empty) == 0u));\n     }\n \n     #[test]\n     pub fn test_append() {\n-        fail_unless!(from_vec(~[1,2,3,4])\n+        assert!(from_vec(~[1,2,3,4])\n             == list::append(list::from_vec(~[1,2]), list::from_vec(~[3,4])));\n     }\n }"}, {"sha": "8f35376a6f1f1e922276aaa268ed6a4086d96fef", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -125,17 +125,17 @@ pub fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n \n #[test]\n fn test_md4() {\n-    fail_unless!(md4_text(~\"\") == ~\"31d6cfe0d16ae931b73c59d7e0c089c0\");\n-    fail_unless!(md4_text(~\"a\") == ~\"bde52cb31de33e46245e05fbdbd6fb24\");\n-    fail_unless!(md4_text(~\"abc\") == ~\"a448017aaf21d8525fc10ae87aa6729d\");\n-    fail_unless!(md4_text(~\"message digest\") ==\n+    assert!(md4_text(~\"\") == ~\"31d6cfe0d16ae931b73c59d7e0c089c0\");\n+    assert!(md4_text(~\"a\") == ~\"bde52cb31de33e46245e05fbdbd6fb24\");\n+    assert!(md4_text(~\"abc\") == ~\"a448017aaf21d8525fc10ae87aa6729d\");\n+    assert!(md4_text(~\"message digest\") ==\n         ~\"d9130a8164549fe818874806e1c7014b\");\n-    fail_unless!(md4_text(~\"abcdefghijklmnopqrstuvwxyz\") ==\n+    assert!(md4_text(~\"abcdefghijklmnopqrstuvwxyz\") ==\n         ~\"d79e1c308aa5bbcdeea8ed63df412da9\");\n-    fail_unless!(md4_text(\n+    assert!(md4_text(\n         ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\n         0123456789\") == ~\"043f8582f241db351ce627e153e7f0e4\");\n-    fail_unless!(md4_text(~\"1234567890123456789012345678901234567890123456789\\\n+    assert!(md4_text(~\"1234567890123456789012345678901234567890123456789\\\n                      0123456789012345678901234567890\") ==\n         ~\"e33b4ddc9c38f2199c3e7b164fcc0536\");\n }"}, {"sha": "6403e0eb5c47acf4ad9ed7d521b5cfd24badffd8", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -379,7 +379,7 @@ mod test {\n     #[test]\n     fn test_ip_ipv4_parse_and_format_ip() {\n         let localhost_str = ~\"127.0.0.1\";\n-        fail_unless!(format_addr(&v4::parse_addr(localhost_str))\n+        assert!(format_addr(&v4::parse_addr(localhost_str))\n                 == localhost_str)\n     }\n     #[test]\n@@ -388,14 +388,14 @@ mod test {\n         let format_result = format_addr(&v6::parse_addr(localhost_str));\n         debug!(\"results: expected: '%s' actual: '%s'\",\n             localhost_str, format_result);\n-        fail_unless!(format_result == localhost_str);\n+        assert!(format_result == localhost_str);\n     }\n     #[test]\n     fn test_ip_ipv4_bad_parse() {\n         match v4::try_parse_addr(~\"b4df00d\") {\n           result::Err(ref err_info) => {\n             debug!(\"got error as expected %?\", err_info);\n-            fail_unless!(true);\n+            assert!(true);\n           }\n           result::Ok(ref addr) => {\n             fail!(fmt!(\"Expected failure, but got addr %?\", addr));\n@@ -408,7 +408,7 @@ mod test {\n         match v6::try_parse_addr(~\"::,~2234k;\") {\n           result::Err(ref err_info) => {\n             debug!(\"got error as expected %?\", err_info);\n-            fail_unless!(true);\n+            assert!(true);\n           }\n           result::Ok(ref addr) => {\n             fail!(fmt!(\"Expected failure, but got addr %?\", addr));\n@@ -439,14 +439,14 @@ mod test {\n         }\n         // at least one result.. this is going to vary from system\n         // to system, based on stuff like the contents of /etc/hosts\n-        fail_unless!(!results.is_empty());\n+        assert!(!results.is_empty());\n     }\n     #[test]\n     #[ignore(reason = \"valgrind says it's leaky\")]\n     fn test_ip_get_addr_bad_input() {\n         let localhost_name = ~\"sjkl234m,./sdf\";\n         let iotask = &uv::global_loop::get();\n         let ga_result = get_addr(localhost_name, iotask);\n-        fail_unless!(result::is_err(&ga_result));\n+        assert!(result::is_err(&ga_result));\n     }\n }"}, {"sha": "8a51af8573f0600629925478d2f54a5d474329c4", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -876,7 +876,7 @@ impl io::Reader for TcpSocketBuf {\n         let mut count: uint = 0;\n \n         loop {\n-          fail_unless!(count < len);\n+          assert!(count < len);\n \n           // If possible, copy up to `len` bytes from the internal\n           // `data.buf` into `buf`\n@@ -897,7 +897,7 @@ impl io::Reader for TcpSocketBuf {\n                 }\n           }\n \n-          fail_unless!(count <= len);\n+          assert!(count <= len);\n           if count == len {\n               break;\n           }\n@@ -1589,15 +1589,15 @@ pub mod test {\n             server_port,\n             expected_req,\n             hl_loop);\n-        fail_unless!(actual_resp_result.is_ok());\n+        assert!(actual_resp_result.is_ok());\n         let actual_resp = actual_resp_result.get();\n         let actual_req = server_result_po.recv();\n         debug!(\"REQ: expected: '%s' actual: '%s'\",\n                        expected_req, actual_req);\n         debug!(\"RESP: expected: '%s' actual: '%s'\",\n                        expected_resp, actual_resp);\n-        fail_unless!(str::contains(actual_req, expected_req));\n-        fail_unless!(str::contains(actual_resp, expected_resp));\n+        assert!(str::contains(actual_req, expected_req));\n+        assert!(str::contains(actual_resp, expected_resp));\n     }\n     pub fn impl_gl_tcp_ipv4_get_peer_addr() {\n         let hl_loop = &uv::global_loop::get();\n@@ -1630,9 +1630,9 @@ pub mod test {\n \n         debug!(\"testing peer address\");\n         // This is what we are actually testing!\n-        fail_unless!(net::ip::format_addr(&sock.get_peer_addr()) ==\n+        assert!(net::ip::format_addr(&sock.get_peer_addr()) ==\n             ~\"127.0.0.1\");\n-        fail_unless!(net::ip::get_port(&sock.get_peer_addr()) == 8887);\n+        assert!(net::ip::get_port(&sock.get_peer_addr()) == 8887);\n \n         // Fulfill the protocol the test server expects\n         let resp_bytes = str::to_bytes(~\"ping\");\n@@ -1693,7 +1693,7 @@ pub mod test {\n             hl_loop);\n         match listen_err {\n           AddressInUse => {\n-            fail_unless!(true);\n+            assert!(true);\n           }\n           _ => {\n             fail!(~\"expected address_in_use listen error,\"+\n@@ -1712,7 +1712,7 @@ pub mod test {\n                             hl_loop);\n         match listen_err {\n           AccessDenied => {\n-            fail_unless!(true);\n+            assert!(true);\n           }\n           _ => {\n             fail!(~\"expected address_in_use listen error,\"+\n@@ -1749,7 +1749,7 @@ pub mod test {\n         let server_addr = ip::v4::parse_addr(server_ip);\n         let conn_result = connect(server_addr, server_port, iotask);\n         if result::is_err(&conn_result) {\n-            fail_unless!(false);\n+            assert!(false);\n         }\n         let sock_buf = @socket_buf(result::unwrap(conn_result));\n         buf_write(sock_buf, expected_req);\n@@ -1764,8 +1764,8 @@ pub mod test {\n                        expected_req, actual_req);\n         debug!(\"RESP: expected: '%s' actual: '%s'\",\n                        expected_resp, actual_resp);\n-        fail_unless!(str::contains(actual_req, expected_req));\n-        fail_unless!(str::contains(actual_resp, expected_resp));\n+        assert!(str::contains(actual_req, expected_req));\n+        assert!(str::contains(actual_resp, expected_resp));\n     }\n \n     pub fn impl_tcp_socket_impl_reader_handles_eof() {\n@@ -1796,15 +1796,15 @@ pub mod test {\n         let server_addr = ip::v4::parse_addr(server_ip);\n         let conn_result = connect(server_addr, server_port, hl_loop);\n         if result::is_err(&conn_result) {\n-            fail_unless!(false);\n+            assert!(false);\n         }\n         let sock_buf = @socket_buf(result::unwrap(conn_result));\n         buf_write(sock_buf, expected_req);\n \n         let buf_reader = sock_buf as @Reader;\n         let actual_response = str::from_bytes(buf_reader.read_whole_stream());\n         debug!(\"Actual response: %s\", actual_response);\n-        fail_unless!(expected_resp == actual_response);\n+        assert!(expected_resp == actual_response);\n     }\n \n     fn buf_write<W:io::Writer>(w: &W, val: &str) {"}, {"sha": "d23784953ef99fc82c62bc157b9cf4bb2594bc96", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 164, "deletions": 164, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -733,83 +733,83 @@ impl to_bytes::IterBytes for Url {\n #[test]\n fn test_split_char_first() {\n     let (u,v) = split_char_first(~\"hello, sweet world\", ',');\n-    fail_unless!(u == ~\"hello\");\n-    fail_unless!(v == ~\" sweet world\");\n+    assert!(u == ~\"hello\");\n+    assert!(v == ~\" sweet world\");\n \n     let (u,v) = split_char_first(~\"hello sweet world\", ',');\n-    fail_unless!(u == ~\"hello sweet world\");\n-    fail_unless!(v == ~\"\");\n+    assert!(u == ~\"hello sweet world\");\n+    assert!(v == ~\"\");\n }\n \n #[test]\n fn test_get_authority() {\n     let (u, h, p, r) = get_authority(\n         \"//user:pass@rust-lang.org/something\").unwrap();\n-    fail_unless!(u == Some(UserInfo::new(~\"user\", Some(~\"pass\"))));\n-    fail_unless!(h == ~\"rust-lang.org\");\n-    fail_unless!(p.is_none());\n-    fail_unless!(r == ~\"/something\");\n+    assert!(u == Some(UserInfo::new(~\"user\", Some(~\"pass\"))));\n+    assert!(h == ~\"rust-lang.org\");\n+    assert!(p.is_none());\n+    assert!(r == ~\"/something\");\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org:8000?something\").unwrap();\n-    fail_unless!(u.is_none());\n-    fail_unless!(h == ~\"rust-lang.org\");\n-    fail_unless!(p == Some(~\"8000\"));\n-    fail_unless!(r == ~\"?something\");\n+    assert!(u.is_none());\n+    assert!(h == ~\"rust-lang.org\");\n+    assert!(p == Some(~\"8000\"));\n+    assert!(r == ~\"?something\");\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org#blah\").unwrap();\n-    fail_unless!(u.is_none());\n-    fail_unless!(h == ~\"rust-lang.org\");\n-    fail_unless!(p.is_none());\n-    fail_unless!(r == ~\"#blah\");\n+    assert!(u.is_none());\n+    assert!(h == ~\"rust-lang.org\");\n+    assert!(p.is_none());\n+    assert!(r == ~\"#blah\");\n \n     // ipv6 tests\n     let (_, h, _, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\").unwrap();\n-    fail_unless!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    assert!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n \n     let (_, h, p, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\").unwrap();\n-    fail_unless!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n-    fail_unless!(p == Some(~\"8000\"));\n+    assert!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    assert!(p == Some(~\"8000\"));\n \n     let (u, h, p, _) = get_authority(\n         \"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"\n     ).unwrap();\n-    fail_unless!(u == Some(UserInfo::new(~\"us\", Some(~\"p\"))));\n-    fail_unless!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n-    fail_unless!(p == Some(~\"8000\"));\n+    assert!(u == Some(UserInfo::new(~\"us\", Some(~\"p\"))));\n+    assert!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    assert!(p == Some(~\"8000\"));\n \n     // invalid authorities;\n-    fail_unless!(get_authority(\"//user:pass@rust-lang:something\").is_err());\n-    fail_unless!(get_authority(\"//user@rust-lang:something:/path\").is_err());\n-    fail_unless!(get_authority(\n+    assert!(get_authority(\"//user:pass@rust-lang:something\").is_err());\n+    assert!(get_authority(\"//user@rust-lang:something:/path\").is_err());\n+    assert!(get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:800a\").is_err());\n-    fail_unless!(get_authority(\n+    assert!(get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\").is_err());\n \n     // these parse as empty, because they don't start with '//'\n     let (_, h, _, _) = get_authority(~\"user:pass@rust-lang\").unwrap();\n-    fail_unless!(h == ~\"\");\n+    assert!(h == ~\"\");\n     let (_, h, _, _) = get_authority(~\"rust-lang.org\").unwrap();\n-    fail_unless!(h == ~\"\");\n+    assert!(h == ~\"\");\n }\n \n #[test]\n fn test_get_path() {\n     let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n-    fail_unless!(p == ~\"/something+ orother\");\n-    fail_unless!(r == ~\"\");\n+    assert!(p == ~\"/something+ orother\");\n+    assert!(r == ~\"\");\n     let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n-    fail_unless!(p == ~\"test@email.com\");\n-    fail_unless!(r == ~\"#fragment\");\n+    assert!(p == ~\"test@email.com\");\n+    assert!(r == ~\"#fragment\");\n     let (p, r) = get_path(~\"/gen/:addr=?q=v\", false).unwrap();\n-    fail_unless!(p == ~\"/gen/:addr=\");\n-    fail_unless!(r == ~\"?q=v\");\n+    assert!(p == ~\"/gen/:addr=\");\n+    assert!(r == ~\"?q=v\");\n \n     //failure cases\n-    fail_unless!(get_path(~\"something?q\", true).is_err());\n+    assert!(get_path(~\"something?q\", true).is_err());\n }\n \n #[cfg(test)]\n@@ -826,247 +826,247 @@ mod tests {\n \n         let up = from_str(url);\n         let u = up.unwrap();\n-        fail_unless!(u.scheme == ~\"http\");\n+        assert!(u.scheme == ~\"http\");\n         let userinfo = u.user.get_ref();\n-        fail_unless!(userinfo.user == ~\"user\");\n-        fail_unless!(userinfo.pass.get_ref() == &~\"pass\");\n-        fail_unless!(u.host == ~\"rust-lang.org\");\n-        fail_unless!(u.path == ~\"/doc\");\n-        fail_unless!(u.query == ~[(~\"s\", ~\"v\")]);\n-        fail_unless!(u.fragment.get_ref() == &~\"something\");\n+        assert!(userinfo.user == ~\"user\");\n+        assert!(userinfo.pass.get_ref() == &~\"pass\");\n+        assert!(u.host == ~\"rust-lang.org\");\n+        assert!(u.path == ~\"/doc\");\n+        assert!(u.query == ~[(~\"s\", ~\"v\")]);\n+        assert!(u.fragment.get_ref() == &~\"something\");\n     }\n \n     #[test]\n     pub fn test_url_parse_host_slash() {\n         let urlstr = ~\"http://0.42.42.42/\";\n         let url = from_str(urlstr).unwrap();\n-        fail_unless!(url.host == ~\"0.42.42.42\");\n-        fail_unless!(url.path == ~\"/\");\n+        assert!(url.host == ~\"0.42.42.42\");\n+        assert!(url.path == ~\"/\");\n     }\n \n     #[test]\n     pub fn test_url_with_underscores() {\n         let urlstr = ~\"http://dotcom.com/file_name.html\";\n         let url = from_str(urlstr).unwrap();\n-        fail_unless!(url.path == ~\"/file_name.html\");\n+        assert!(url.path == ~\"/file_name.html\");\n     }\n \n     #[test]\n     pub fn test_url_with_dashes() {\n         let urlstr = ~\"http://dotcom.com/file-name.html\";\n         let url = from_str(urlstr).unwrap();\n-        fail_unless!(url.path == ~\"/file-name.html\");\n+        assert!(url.path == ~\"/file-name.html\");\n     }\n \n     #[test]\n     pub fn test_no_scheme() {\n-        fail_unless!(get_scheme(\"noschemehere.html\").is_err());\n+        assert!(get_scheme(\"noschemehere.html\").is_err());\n     }\n \n     #[test]\n     pub fn test_invalid_scheme_errors() {\n-        fail_unless!(from_str(\"99://something\").is_err());\n-        fail_unless!(from_str(\"://something\").is_err());\n+        assert!(from_str(\"99://something\").is_err());\n+        assert!(from_str(\"://something\").is_err());\n     }\n \n     #[test]\n     pub fn test_full_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n-        fail_unless!(from_str(url).unwrap().to_str() == url);\n+        assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_userless_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc?s=v#something\";\n-        fail_unless!(from_str(url).unwrap().to_str() == url);\n+        assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_queryless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc#something\";\n-        fail_unless!(from_str(url).unwrap().to_str() == url);\n+        assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_empty_query_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?#something\";\n         let should_be = ~\"http://user:pass@rust-lang.org/doc#something\";\n-        fail_unless!(from_str(url).unwrap().to_str() == should_be);\n+        assert!(from_str(url).unwrap().to_str() == should_be);\n     }\n \n     #[test]\n     pub fn test_fragmentless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?q=v\";\n-        fail_unless!(from_str(url).unwrap().to_str() == url);\n+        assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_minimal_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc\";\n-        fail_unless!(from_str(url).unwrap().to_str() == url);\n+        assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_scheme_host_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org\";\n-        fail_unless!(from_str(url).unwrap().to_str() == url);\n+        assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_pathless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org?q=v#something\";\n-        fail_unless!(from_str(url).unwrap().to_str() == url);\n+        assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_scheme_host_fragment_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org#something\";\n-        fail_unless!(from_str(url).unwrap().to_str() == url);\n+        assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_url_component_encoding() {\n         let url = ~\"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n         let u = from_str(url).unwrap();\n-        fail_unless!(u.path == ~\"/doc uments\");\n-        fail_unless!(u.query == ~[(~\"ba%d \", ~\"#&+\")]);\n+        assert!(u.path == ~\"/doc uments\");\n+        assert!(u.query == ~[(~\"ba%d \", ~\"#&+\")]);\n     }\n \n     #[test]\n     pub fn test_url_without_authority() {\n         let url = ~\"mailto:test@email.com\";\n-        fail_unless!(from_str(url).unwrap().to_str() == url);\n+        assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_encode() {\n-        fail_unless!(encode(\"\") == ~\"\");\n-        fail_unless!(encode(\"http://example.com\") == ~\"http://example.com\");\n-        fail_unless!(encode(\"foo bar% baz\") == ~\"foo%20bar%25%20baz\");\n-        fail_unless!(encode(\" \") == ~\"%20\");\n-        fail_unless!(encode(\"!\") == ~\"!\");\n-        fail_unless!(encode(\"\\\"\") == ~\"\\\"\");\n-        fail_unless!(encode(\"#\") == ~\"#\");\n-        fail_unless!(encode(\"$\") == ~\"$\");\n-        fail_unless!(encode(\"%\") == ~\"%25\");\n-        fail_unless!(encode(\"&\") == ~\"&\");\n-        fail_unless!(encode(\"'\") == ~\"%27\");\n-        fail_unless!(encode(\"(\") == ~\"(\");\n-        fail_unless!(encode(\")\") == ~\")\");\n-        fail_unless!(encode(\"*\") == ~\"*\");\n-        fail_unless!(encode(\"+\") == ~\"+\");\n-        fail_unless!(encode(\",\") == ~\",\");\n-        fail_unless!(encode(\"/\") == ~\"/\");\n-        fail_unless!(encode(\":\") == ~\":\");\n-        fail_unless!(encode(\";\") == ~\";\");\n-        fail_unless!(encode(\"=\") == ~\"=\");\n-        fail_unless!(encode(\"?\") == ~\"?\");\n-        fail_unless!(encode(\"@\") == ~\"@\");\n-        fail_unless!(encode(\"[\") == ~\"[\");\n-        fail_unless!(encode(\"]\") == ~\"]\");\n+        assert!(encode(\"\") == ~\"\");\n+        assert!(encode(\"http://example.com\") == ~\"http://example.com\");\n+        assert!(encode(\"foo bar% baz\") == ~\"foo%20bar%25%20baz\");\n+        assert!(encode(\" \") == ~\"%20\");\n+        assert!(encode(\"!\") == ~\"!\");\n+        assert!(encode(\"\\\"\") == ~\"\\\"\");\n+        assert!(encode(\"#\") == ~\"#\");\n+        assert!(encode(\"$\") == ~\"$\");\n+        assert!(encode(\"%\") == ~\"%25\");\n+        assert!(encode(\"&\") == ~\"&\");\n+        assert!(encode(\"'\") == ~\"%27\");\n+        assert!(encode(\"(\") == ~\"(\");\n+        assert!(encode(\")\") == ~\")\");\n+        assert!(encode(\"*\") == ~\"*\");\n+        assert!(encode(\"+\") == ~\"+\");\n+        assert!(encode(\",\") == ~\",\");\n+        assert!(encode(\"/\") == ~\"/\");\n+        assert!(encode(\":\") == ~\":\");\n+        assert!(encode(\";\") == ~\";\");\n+        assert!(encode(\"=\") == ~\"=\");\n+        assert!(encode(\"?\") == ~\"?\");\n+        assert!(encode(\"@\") == ~\"@\");\n+        assert!(encode(\"[\") == ~\"[\");\n+        assert!(encode(\"]\") == ~\"]\");\n     }\n \n     #[test]\n     pub fn test_encode_component() {\n-        fail_unless!(encode_component(\"\") == ~\"\");\n-        fail_unless!(encode_component(\"http://example.com\") ==\n+        assert!(encode_component(\"\") == ~\"\");\n+        assert!(encode_component(\"http://example.com\") ==\n             ~\"http%3A%2F%2Fexample.com\");\n-        fail_unless!(encode_component(\"foo bar% baz\") ==\n+        assert!(encode_component(\"foo bar% baz\") ==\n             ~\"foo%20bar%25%20baz\");\n-        fail_unless!(encode_component(\" \") == ~\"%20\");\n-        fail_unless!(encode_component(\"!\") == ~\"%21\");\n-        fail_unless!(encode_component(\"#\") == ~\"%23\");\n-        fail_unless!(encode_component(\"$\") == ~\"%24\");\n-        fail_unless!(encode_component(\"%\") == ~\"%25\");\n-        fail_unless!(encode_component(\"&\") == ~\"%26\");\n-        fail_unless!(encode_component(\"'\") == ~\"%27\");\n-        fail_unless!(encode_component(\"(\") == ~\"%28\");\n-        fail_unless!(encode_component(\")\") == ~\"%29\");\n-        fail_unless!(encode_component(\"*\") == ~\"%2A\");\n-        fail_unless!(encode_component(\"+\") == ~\"%2B\");\n-        fail_unless!(encode_component(\",\") == ~\"%2C\");\n-        fail_unless!(encode_component(\"/\") == ~\"%2F\");\n-        fail_unless!(encode_component(\":\") == ~\"%3A\");\n-        fail_unless!(encode_component(\";\") == ~\"%3B\");\n-        fail_unless!(encode_component(\"=\") == ~\"%3D\");\n-        fail_unless!(encode_component(\"?\") == ~\"%3F\");\n-        fail_unless!(encode_component(\"@\") == ~\"%40\");\n-        fail_unless!(encode_component(\"[\") == ~\"%5B\");\n-        fail_unless!(encode_component(\"]\") == ~\"%5D\");\n+        assert!(encode_component(\" \") == ~\"%20\");\n+        assert!(encode_component(\"!\") == ~\"%21\");\n+        assert!(encode_component(\"#\") == ~\"%23\");\n+        assert!(encode_component(\"$\") == ~\"%24\");\n+        assert!(encode_component(\"%\") == ~\"%25\");\n+        assert!(encode_component(\"&\") == ~\"%26\");\n+        assert!(encode_component(\"'\") == ~\"%27\");\n+        assert!(encode_component(\"(\") == ~\"%28\");\n+        assert!(encode_component(\")\") == ~\"%29\");\n+        assert!(encode_component(\"*\") == ~\"%2A\");\n+        assert!(encode_component(\"+\") == ~\"%2B\");\n+        assert!(encode_component(\",\") == ~\"%2C\");\n+        assert!(encode_component(\"/\") == ~\"%2F\");\n+        assert!(encode_component(\":\") == ~\"%3A\");\n+        assert!(encode_component(\";\") == ~\"%3B\");\n+        assert!(encode_component(\"=\") == ~\"%3D\");\n+        assert!(encode_component(\"?\") == ~\"%3F\");\n+        assert!(encode_component(\"@\") == ~\"%40\");\n+        assert!(encode_component(\"[\") == ~\"%5B\");\n+        assert!(encode_component(\"]\") == ~\"%5D\");\n     }\n \n     #[test]\n     pub fn test_decode() {\n-        fail_unless!(decode(\"\") == ~\"\");\n-        fail_unless!(decode(\"abc/def 123\") == ~\"abc/def 123\");\n-        fail_unless!(decode(\"abc%2Fdef%20123\") == ~\"abc%2Fdef 123\");\n-        fail_unless!(decode(\"%20\") == ~\" \");\n-        fail_unless!(decode(\"%21\") == ~\"%21\");\n-        fail_unless!(decode(\"%22\") == ~\"%22\");\n-        fail_unless!(decode(\"%23\") == ~\"%23\");\n-        fail_unless!(decode(\"%24\") == ~\"%24\");\n-        fail_unless!(decode(\"%25\") == ~\"%\");\n-        fail_unless!(decode(\"%26\") == ~\"%26\");\n-        fail_unless!(decode(\"%27\") == ~\"'\");\n-        fail_unless!(decode(\"%28\") == ~\"%28\");\n-        fail_unless!(decode(\"%29\") == ~\"%29\");\n-        fail_unless!(decode(\"%2A\") == ~\"%2A\");\n-        fail_unless!(decode(\"%2B\") == ~\"%2B\");\n-        fail_unless!(decode(\"%2C\") == ~\"%2C\");\n-        fail_unless!(decode(\"%2F\") == ~\"%2F\");\n-        fail_unless!(decode(\"%3A\") == ~\"%3A\");\n-        fail_unless!(decode(\"%3B\") == ~\"%3B\");\n-        fail_unless!(decode(\"%3D\") == ~\"%3D\");\n-        fail_unless!(decode(\"%3F\") == ~\"%3F\");\n-        fail_unless!(decode(\"%40\") == ~\"%40\");\n-        fail_unless!(decode(\"%5B\") == ~\"%5B\");\n-        fail_unless!(decode(\"%5D\") == ~\"%5D\");\n+        assert!(decode(\"\") == ~\"\");\n+        assert!(decode(\"abc/def 123\") == ~\"abc/def 123\");\n+        assert!(decode(\"abc%2Fdef%20123\") == ~\"abc%2Fdef 123\");\n+        assert!(decode(\"%20\") == ~\" \");\n+        assert!(decode(\"%21\") == ~\"%21\");\n+        assert!(decode(\"%22\") == ~\"%22\");\n+        assert!(decode(\"%23\") == ~\"%23\");\n+        assert!(decode(\"%24\") == ~\"%24\");\n+        assert!(decode(\"%25\") == ~\"%\");\n+        assert!(decode(\"%26\") == ~\"%26\");\n+        assert!(decode(\"%27\") == ~\"'\");\n+        assert!(decode(\"%28\") == ~\"%28\");\n+        assert!(decode(\"%29\") == ~\"%29\");\n+        assert!(decode(\"%2A\") == ~\"%2A\");\n+        assert!(decode(\"%2B\") == ~\"%2B\");\n+        assert!(decode(\"%2C\") == ~\"%2C\");\n+        assert!(decode(\"%2F\") == ~\"%2F\");\n+        assert!(decode(\"%3A\") == ~\"%3A\");\n+        assert!(decode(\"%3B\") == ~\"%3B\");\n+        assert!(decode(\"%3D\") == ~\"%3D\");\n+        assert!(decode(\"%3F\") == ~\"%3F\");\n+        assert!(decode(\"%40\") == ~\"%40\");\n+        assert!(decode(\"%5B\") == ~\"%5B\");\n+        assert!(decode(\"%5D\") == ~\"%5D\");\n     }\n \n     #[test]\n     pub fn test_decode_component() {\n-        fail_unless!(decode_component(\"\") == ~\"\");\n-        fail_unless!(decode_component(\"abc/def 123\") == ~\"abc/def 123\");\n-        fail_unless!(decode_component(\"abc%2Fdef%20123\") == ~\"abc/def 123\");\n-        fail_unless!(decode_component(\"%20\") == ~\" \");\n-        fail_unless!(decode_component(\"%21\") == ~\"!\");\n-        fail_unless!(decode_component(\"%22\") == ~\"\\\"\");\n-        fail_unless!(decode_component(\"%23\") == ~\"#\");\n-        fail_unless!(decode_component(\"%24\") == ~\"$\");\n-        fail_unless!(decode_component(\"%25\") == ~\"%\");\n-        fail_unless!(decode_component(\"%26\") == ~\"&\");\n-        fail_unless!(decode_component(\"%27\") == ~\"'\");\n-        fail_unless!(decode_component(\"%28\") == ~\"(\");\n-        fail_unless!(decode_component(\"%29\") == ~\")\");\n-        fail_unless!(decode_component(\"%2A\") == ~\"*\");\n-        fail_unless!(decode_component(\"%2B\") == ~\"+\");\n-        fail_unless!(decode_component(\"%2C\") == ~\",\");\n-        fail_unless!(decode_component(\"%2F\") == ~\"/\");\n-        fail_unless!(decode_component(\"%3A\") == ~\":\");\n-        fail_unless!(decode_component(\"%3B\") == ~\";\");\n-        fail_unless!(decode_component(\"%3D\") == ~\"=\");\n-        fail_unless!(decode_component(\"%3F\") == ~\"?\");\n-        fail_unless!(decode_component(\"%40\") == ~\"@\");\n-        fail_unless!(decode_component(\"%5B\") == ~\"[\");\n-        fail_unless!(decode_component(\"%5D\") == ~\"]\");\n+        assert!(decode_component(\"\") == ~\"\");\n+        assert!(decode_component(\"abc/def 123\") == ~\"abc/def 123\");\n+        assert!(decode_component(\"abc%2Fdef%20123\") == ~\"abc/def 123\");\n+        assert!(decode_component(\"%20\") == ~\" \");\n+        assert!(decode_component(\"%21\") == ~\"!\");\n+        assert!(decode_component(\"%22\") == ~\"\\\"\");\n+        assert!(decode_component(\"%23\") == ~\"#\");\n+        assert!(decode_component(\"%24\") == ~\"$\");\n+        assert!(decode_component(\"%25\") == ~\"%\");\n+        assert!(decode_component(\"%26\") == ~\"&\");\n+        assert!(decode_component(\"%27\") == ~\"'\");\n+        assert!(decode_component(\"%28\") == ~\"(\");\n+        assert!(decode_component(\"%29\") == ~\")\");\n+        assert!(decode_component(\"%2A\") == ~\"*\");\n+        assert!(decode_component(\"%2B\") == ~\"+\");\n+        assert!(decode_component(\"%2C\") == ~\",\");\n+        assert!(decode_component(\"%2F\") == ~\"/\");\n+        assert!(decode_component(\"%3A\") == ~\":\");\n+        assert!(decode_component(\"%3B\") == ~\";\");\n+        assert!(decode_component(\"%3D\") == ~\"=\");\n+        assert!(decode_component(\"%3F\") == ~\"?\");\n+        assert!(decode_component(\"%40\") == ~\"@\");\n+        assert!(decode_component(\"%5B\") == ~\"[\");\n+        assert!(decode_component(\"%5D\") == ~\"]\");\n     }\n \n     #[test]\n     pub fn test_encode_form_urlencoded() {\n         let mut m = LinearMap::new();\n-        fail_unless!(encode_form_urlencoded(&m) == ~\"\");\n+        assert!(encode_form_urlencoded(&m) == ~\"\");\n \n         m.insert(~\"\", ~[]);\n         m.insert(~\"foo\", ~[]);\n-        fail_unless!(encode_form_urlencoded(&m) == ~\"\");\n+        assert!(encode_form_urlencoded(&m) == ~\"\");\n \n         let mut m = LinearMap::new();\n         m.insert(~\"foo\", ~[~\"bar\", ~\"123\"]);\n-        fail_unless!(encode_form_urlencoded(&m) == ~\"foo=bar&foo=123\");\n+        assert!(encode_form_urlencoded(&m) == ~\"foo=bar&foo=123\");\n \n         let mut m = LinearMap::new();\n         m.insert(~\"foo bar\", ~[~\"abc\", ~\"12 = 34\"]);\n-        fail_unless!(encode_form_urlencoded(&m) ==\n+        assert!(encode_form_urlencoded(&m) ==\n             ~\"foo+bar=abc&foo+bar=12+%3D+34\");\n     }\n \n@@ -1075,13 +1075,13 @@ mod tests {\n         // FIXME #4449: Commented out because this causes an ICE, but only\n         // on FreeBSD\n         /*\n-        fail_unless!(decode_form_urlencoded(~[]).len() == 0);\n+        assert!(decode_form_urlencoded(~[]).len() == 0);\n \n         let s = str::to_bytes(\"a=1&foo+bar=abc&foo+bar=12+%3D+34\");\n         let form = decode_form_urlencoded(s);\n-        fail_unless!(form.len() == 2);\n-        fail_unless!(form.get_ref(&~\"a\") == &~[~\"1\"]);\n-        fail_unless!(form.get_ref(&~\"foo bar\") == &~[~\"abc\", ~\"12 = 34\"]);\n+        assert!(form.len() == 2);\n+        assert!(form.get_ref(&~\"a\") == &~[~\"1\"]);\n+        assert!(form.get_ref(&~\"foo bar\") == &~[~\"abc\", ~\"12 = 34\"]);\n         */\n     }\n }"}, {"sha": "bb83cfc494b4c414cf6824263cb1bccac8a10828", "filename": "src/libstd/par.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -68,7 +68,7 @@ fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n                             cast::reinterpret_cast(&slice);\n                         info!(\"slice: %?\",\n                                        (base, vec::len(slice), end - base));\n-                        fail_unless!((vec::len(slice) == end - base));\n+                        assert!((vec::len(slice) == end - base));\n                         f(base, slice)\n                     }\n                 };\n@@ -79,12 +79,12 @@ fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n         info!(\"tasks spawned\");\n \n         info!(\"num_tasks: %?\", (num_tasks, futures.len()));\n-        fail_unless!((num_tasks == futures.len()));\n+        assert!((num_tasks == futures.len()));\n \n         let r = do futures.map() |ys| {\n             ys.get()\n         };\n-        fail_unless!((r.len() == futures.len()));\n+        assert!((r.len() == futures.len()));\n         r\n     }\n }\n@@ -115,7 +115,7 @@ pub fn mapi<A:Copy + Owned,B:Copy + Owned>(\n     });\n     let r = vec::concat(slices);\n     info!(\"%?\", (r.len(), xs.len()));\n-    fail_unless!((r.len() == xs.len()));\n+    assert!((r.len() == xs.len()));\n     r\n }\n "}, {"sha": "1fb79fcab2823c95547b119947be0d87698b86e4", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -197,87 +197,87 @@ mod tests {\n         let mut sorted = merge_sort(data, le);\n         let mut heap = from_vec(data);\n         while !heap.is_empty() {\n-            fail_unless!(heap.top() == sorted.last());\n-            fail_unless!(heap.pop() == sorted.pop());\n+            assert!(heap.top() == sorted.last());\n+            assert!(heap.pop() == sorted.pop());\n         }\n     }\n \n     #[test]\n     fn test_push() {\n         let mut heap = from_vec(~[2, 4, 9]);\n-        fail_unless!(heap.len() == 3);\n-        fail_unless!(*heap.top() == 9);\n+        assert!(heap.len() == 3);\n+        assert!(*heap.top() == 9);\n         heap.push(11);\n-        fail_unless!(heap.len() == 4);\n-        fail_unless!(*heap.top() == 11);\n+        assert!(heap.len() == 4);\n+        assert!(*heap.top() == 11);\n         heap.push(5);\n-        fail_unless!(heap.len() == 5);\n-        fail_unless!(*heap.top() == 11);\n+        assert!(heap.len() == 5);\n+        assert!(*heap.top() == 11);\n         heap.push(27);\n-        fail_unless!(heap.len() == 6);\n-        fail_unless!(*heap.top() == 27);\n+        assert!(heap.len() == 6);\n+        assert!(*heap.top() == 27);\n         heap.push(3);\n-        fail_unless!(heap.len() == 7);\n-        fail_unless!(*heap.top() == 27);\n+        assert!(heap.len() == 7);\n+        assert!(*heap.top() == 27);\n         heap.push(103);\n-        fail_unless!(heap.len() == 8);\n-        fail_unless!(*heap.top() == 103);\n+        assert!(heap.len() == 8);\n+        assert!(*heap.top() == 103);\n     }\n \n     #[test]\n     fn test_push_unique() {\n         let mut heap = from_vec(~[~2, ~4, ~9]);\n-        fail_unless!(heap.len() == 3);\n-        fail_unless!(*heap.top() == ~9);\n+        assert!(heap.len() == 3);\n+        assert!(*heap.top() == ~9);\n         heap.push(~11);\n-        fail_unless!(heap.len() == 4);\n-        fail_unless!(*heap.top() == ~11);\n+        assert!(heap.len() == 4);\n+        assert!(*heap.top() == ~11);\n         heap.push(~5);\n-        fail_unless!(heap.len() == 5);\n-        fail_unless!(*heap.top() == ~11);\n+        assert!(heap.len() == 5);\n+        assert!(*heap.top() == ~11);\n         heap.push(~27);\n-        fail_unless!(heap.len() == 6);\n-        fail_unless!(*heap.top() == ~27);\n+        assert!(heap.len() == 6);\n+        assert!(*heap.top() == ~27);\n         heap.push(~3);\n-        fail_unless!(heap.len() == 7);\n-        fail_unless!(*heap.top() == ~27);\n+        assert!(heap.len() == 7);\n+        assert!(*heap.top() == ~27);\n         heap.push(~103);\n-        fail_unless!(heap.len() == 8);\n-        fail_unless!(*heap.top() == ~103);\n+        assert!(heap.len() == 8);\n+        assert!(*heap.top() == ~103);\n     }\n \n     #[test]\n     fn test_push_pop() {\n         let mut heap = from_vec(~[5, 5, 2, 1, 3]);\n-        fail_unless!(heap.len() == 5);\n-        fail_unless!(heap.push_pop(6) == 6);\n-        fail_unless!(heap.len() == 5);\n-        fail_unless!(heap.push_pop(0) == 5);\n-        fail_unless!(heap.len() == 5);\n-        fail_unless!(heap.push_pop(4) == 5);\n-        fail_unless!(heap.len() == 5);\n-        fail_unless!(heap.push_pop(1) == 4);\n-        fail_unless!(heap.len() == 5);\n+        assert!(heap.len() == 5);\n+        assert!(heap.push_pop(6) == 6);\n+        assert!(heap.len() == 5);\n+        assert!(heap.push_pop(0) == 5);\n+        assert!(heap.len() == 5);\n+        assert!(heap.push_pop(4) == 5);\n+        assert!(heap.len() == 5);\n+        assert!(heap.push_pop(1) == 4);\n+        assert!(heap.len() == 5);\n     }\n \n     #[test]\n     fn test_replace() {\n         let mut heap = from_vec(~[5, 5, 2, 1, 3]);\n-        fail_unless!(heap.len() == 5);\n-        fail_unless!(heap.replace(6) == 5);\n-        fail_unless!(heap.len() == 5);\n-        fail_unless!(heap.replace(0) == 6);\n-        fail_unless!(heap.len() == 5);\n-        fail_unless!(heap.replace(4) == 5);\n-        fail_unless!(heap.len() == 5);\n-        fail_unless!(heap.replace(1) == 4);\n-        fail_unless!(heap.len() == 5);\n+        assert!(heap.len() == 5);\n+        assert!(heap.replace(6) == 5);\n+        assert!(heap.len() == 5);\n+        assert!(heap.replace(0) == 6);\n+        assert!(heap.len() == 5);\n+        assert!(heap.replace(4) == 5);\n+        assert!(heap.len() == 5);\n+        assert!(heap.replace(1) == 4);\n+        assert!(heap.len() == 5);\n     }\n \n     fn check_to_vec(data: ~[int]) {\n         let heap = from_vec(data);\n-        fail_unless!(merge_sort(heap.to_vec(), le) == merge_sort(data, le));\n-        fail_unless!(heap.to_sorted_vec() == merge_sort(data, le));\n+        assert!(merge_sort(heap.to_vec(), le) == merge_sort(data, le));\n+        assert!(heap.to_sorted_vec() == merge_sort(data, le));\n     }\n \n     #[test]\n@@ -305,7 +305,7 @@ mod tests {\n     #[test]\n     fn test_empty_maybe_pop() {\n         let mut heap = new::<int>();\n-        fail_unless!(heap.maybe_pop().is_none());\n+        assert!(heap.maybe_pop().is_none());\n     }\n \n     #[test]\n@@ -316,7 +316,7 @@ mod tests {\n     #[test]\n     fn test_empty_maybe_top() {\n         let empty = new::<int>();\n-        fail_unless!(empty.maybe_top().is_none());\n+        assert!(empty.maybe_top().is_none());\n     }\n \n     #[test]"}, {"sha": "61f50069d89976db65bb44184a7efe8fab6cda14", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -704,7 +704,7 @@ pub mod node {\n      */\n     pub fn of_substr_unsafer(str: @~str, byte_start: uint, byte_len: uint,\n                              char_len: uint) -> @Node {\n-        fail_unless!((byte_start + byte_len <= str::len(*str)));\n+        assert!((byte_start + byte_len <= str::len(*str)));\n         let candidate = @Leaf(Leaf {\n             byte_offset: byte_start,\n             byte_len: byte_len,\n@@ -1313,17 +1313,17 @@ mod tests {\n \n     #[test]\n     fn trivial() {\n-        fail_unless!(char_len(empty()) == 0u);\n-        fail_unless!(byte_len(empty()) == 0u);\n+        assert!(char_len(empty()) == 0u);\n+        assert!(byte_len(empty()) == 0u);\n     }\n \n     #[test]\n     fn of_string1() {\n         let sample = @~\"0123456789ABCDE\";\n         let r      = of_str(sample);\n \n-        fail_unless!(char_len(r) == str::char_len(*sample));\n-        fail_unless!(rope_to_string(r) == *sample);\n+        assert!(char_len(r) == str::char_len(*sample));\n+        assert!(rope_to_string(r) == *sample);\n     }\n \n     #[test]\n@@ -1338,8 +1338,8 @@ mod tests {\n         }\n         let sample = @*buf;\n         let r      = of_str(sample);\n-        fail_unless!(char_len(r) == str::char_len(*sample));\n-        fail_unless!(rope_to_string(r) == *sample);\n+        assert!(char_len(r) == str::char_len(*sample));\n+        assert!(rope_to_string(r) == *sample);\n \n         let mut string_iter = 0u;\n         let string_len  = str::len(*sample);\n@@ -1359,7 +1359,7 @@ mod tests {\n             }\n         }\n \n-        fail_unless!(equal);\n+        assert!(equal);\n     }\n \n     #[test]\n@@ -1384,7 +1384,7 @@ mod tests {\n             }\n         }\n \n-        fail_unless!(len == str::char_len(*sample));\n+        assert!(len == str::char_len(*sample));\n     }\n \n     #[test]\n@@ -1405,11 +1405,11 @@ mod tests {\n         while i < 8 { r2 = append_rope(r2, r2); i+= 1;}\n \n \n-        fail_unless!(eq(r1, r2));\n+        assert!(eq(r1, r2));\n         let r3 = bal(r2);\n-        fail_unless!(char_len(r1) == char_len(r3));\n+        assert!(char_len(r1) == char_len(r3));\n \n-        fail_unless!(eq(r1, r3));\n+        assert!(eq(r1, r3));\n     }\n \n     #[test]\n@@ -1426,23 +1426,23 @@ mod tests {\n         for uint::range(0u, char_len(r)) |i| {\n             r2 = append_char(r2, char_at(r, i));\n         }\n-        fail_unless!(eq(r, r2));\n+        assert!(eq(r, r2));\n \n         let mut r3 = empty();\n         for uint::range(0u, char_len(r)) |i| {\n             r3 = prepend_char(r3, char_at(r, char_len(r) - i - 1u));\n         }\n-        fail_unless!(eq(r, r3));\n+        assert!(eq(r, r3));\n \n         //Additional sanity checks\n         let balr = bal(r);\n         let bal2 = bal(r2);\n         let bal3 = bal(r3);\n-        fail_unless!(eq(r, balr));\n-        fail_unless!(eq(r, bal2));\n-        fail_unless!(eq(r, bal3));\n-        fail_unless!(eq(r2, r3));\n-        fail_unless!(eq(bal2, bal3));\n+        assert!(eq(r, balr));\n+        assert!(eq(r, bal2));\n+        assert!(eq(r, bal3));\n+        assert!(eq(r2, r3));\n+        assert!(eq(bal2, bal3));\n     }\n \n     #[test]\n@@ -1457,6 +1457,6 @@ mod tests {\n         //Same rope, obtained with rope::concat\n         let r2 = concat(vec::from_elem(10u, chunk));\n \n-        fail_unless!(eq(r, r2));\n+        assert!(eq(r, r2));\n     }\n }"}, {"sha": "83fab365d8d62b5f9cab5d2c64c817dd46099441", "filename": "src/libstd/semver.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsemver.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -239,74 +239,74 @@ pub fn parse(s: &str) -> Option<Version> {\n \n #[test]\n fn test_parse() {\n-    fail_unless!(parse(\"\") == None);\n-    fail_unless!(parse(\"  \") == None);\n-    fail_unless!(parse(\"1\") == None);\n-    fail_unless!(parse(\"1.2\") == None);\n-    fail_unless!(parse(\"1.2\") == None);\n-    fail_unless!(parse(\"1\") == None);\n-    fail_unless!(parse(\"1.2\") == None);\n-    fail_unless!(parse(\"1.2.3-\") == None);\n-    fail_unless!(parse(\"a.b.c\") == None);\n-    fail_unless!(parse(\"1.2.3 abc\") == None);\n-\n-    fail_unless!(parse(\"1.2.3\") == Some(Version {\n+    assert!(parse(\"\") == None);\n+    assert!(parse(\"  \") == None);\n+    assert!(parse(\"1\") == None);\n+    assert!(parse(\"1.2\") == None);\n+    assert!(parse(\"1.2\") == None);\n+    assert!(parse(\"1\") == None);\n+    assert!(parse(\"1.2\") == None);\n+    assert!(parse(\"1.2.3-\") == None);\n+    assert!(parse(\"a.b.c\") == None);\n+    assert!(parse(\"1.2.3 abc\") == None);\n+\n+    assert!(parse(\"1.2.3\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[],\n         build: ~[],\n     }));\n-    fail_unless!(parse(\"  1.2.3  \") == Some(Version {\n+    assert!(parse(\"  1.2.3  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[],\n         build: ~[],\n     }));\n-    fail_unless!(parse(\"1.2.3-alpha1\") == Some(Version {\n+    assert!(parse(\"1.2.3-alpha1\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[AlphaNumeric(~\"alpha1\")],\n         build: ~[]\n     }));\n-    fail_unless!(parse(\"  1.2.3-alpha1  \") == Some(Version {\n+    assert!(parse(\"  1.2.3-alpha1  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[AlphaNumeric(~\"alpha1\")],\n         build: ~[]\n     }));\n-    fail_unless!(parse(\"1.2.3+build5\") == Some(Version {\n+    assert!(parse(\"1.2.3+build5\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[],\n         build: ~[AlphaNumeric(~\"build5\")]\n     }));\n-    fail_unless!(parse(\"  1.2.3+build5  \") == Some(Version {\n+    assert!(parse(\"  1.2.3+build5  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[],\n         build: ~[AlphaNumeric(~\"build5\")]\n     }));\n-    fail_unless!(parse(\"1.2.3-alpha1+build5\") == Some(Version {\n+    assert!(parse(\"1.2.3-alpha1+build5\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[AlphaNumeric(~\"alpha1\")],\n         build: ~[AlphaNumeric(~\"build5\")]\n     }));\n-    fail_unless!(parse(\"  1.2.3-alpha1+build5  \") == Some(Version {\n+    assert!(parse(\"  1.2.3-alpha1+build5  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[AlphaNumeric(~\"alpha1\")],\n         build: ~[AlphaNumeric(~\"build5\")]\n     }));\n-    fail_unless!(parse(\"1.2.3-1.alpha1.9+build5.7.3aedf  \") == Some(Version {\n+    assert!(parse(\"1.2.3-1.alpha1.9+build5.7.3aedf  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n@@ -320,54 +320,54 @@ fn test_parse() {\n \n #[test]\n fn test_eq() {\n-    fail_unless!(parse(\"1.2.3\")        == parse(\"1.2.3\"));\n-    fail_unless!(parse(\"1.2.3-alpha1\") == parse(\"1.2.3-alpha1\"));\n+    assert!(parse(\"1.2.3\")        == parse(\"1.2.3\"));\n+    assert!(parse(\"1.2.3-alpha1\") == parse(\"1.2.3-alpha1\"));\n }\n \n #[test]\n fn test_ne() {\n-    fail_unless!(parse(\"0.0.0\")       != parse(\"0.0.1\"));\n-    fail_unless!(parse(\"0.0.0\")       != parse(\"0.1.0\"));\n-    fail_unless!(parse(\"0.0.0\")       != parse(\"1.0.0\"));\n-    fail_unless!(parse(\"1.2.3-alpha\") != parse(\"1.2.3-beta\"));\n+    assert!(parse(\"0.0.0\")       != parse(\"0.0.1\"));\n+    assert!(parse(\"0.0.0\")       != parse(\"0.1.0\"));\n+    assert!(parse(\"0.0.0\")       != parse(\"1.0.0\"));\n+    assert!(parse(\"1.2.3-alpha\") != parse(\"1.2.3-beta\"));\n }\n \n #[test]\n fn test_lt() {\n-    fail_unless!(parse(\"0.0.0\")        < parse(\"1.2.3-alpha2\"));\n-    fail_unless!(parse(\"1.0.0\")        < parse(\"1.2.3-alpha2\"));\n-    fail_unless!(parse(\"1.2.0\")        < parse(\"1.2.3-alpha2\"));\n-    fail_unless!(parse(\"1.2.3-alpha1\") < parse(\"1.2.3\"));\n-    fail_unless!(parse(\"1.2.3-alpha1\") < parse(\"1.2.3-alpha2\"));\n-    fail_unless!(!(parse(\"1.2.3-alpha2\") < parse(\"1.2.3-alpha2\")));\n+    assert!(parse(\"0.0.0\")        < parse(\"1.2.3-alpha2\"));\n+    assert!(parse(\"1.0.0\")        < parse(\"1.2.3-alpha2\"));\n+    assert!(parse(\"1.2.0\")        < parse(\"1.2.3-alpha2\"));\n+    assert!(parse(\"1.2.3-alpha1\") < parse(\"1.2.3\"));\n+    assert!(parse(\"1.2.3-alpha1\") < parse(\"1.2.3-alpha2\"));\n+    assert!(!(parse(\"1.2.3-alpha2\") < parse(\"1.2.3-alpha2\")));\n }\n \n #[test]\n fn test_le() {\n-    fail_unless!(parse(\"0.0.0\")        <= parse(\"1.2.3-alpha2\"));\n-    fail_unless!(parse(\"1.0.0\")        <= parse(\"1.2.3-alpha2\"));\n-    fail_unless!(parse(\"1.2.0\")        <= parse(\"1.2.3-alpha2\"));\n-    fail_unless!(parse(\"1.2.3-alpha1\") <= parse(\"1.2.3-alpha2\"));\n-    fail_unless!(parse(\"1.2.3-alpha2\") <= parse(\"1.2.3-alpha2\"));\n+    assert!(parse(\"0.0.0\")        <= parse(\"1.2.3-alpha2\"));\n+    assert!(parse(\"1.0.0\")        <= parse(\"1.2.3-alpha2\"));\n+    assert!(parse(\"1.2.0\")        <= parse(\"1.2.3-alpha2\"));\n+    assert!(parse(\"1.2.3-alpha1\") <= parse(\"1.2.3-alpha2\"));\n+    assert!(parse(\"1.2.3-alpha2\") <= parse(\"1.2.3-alpha2\"));\n }\n \n #[test]\n fn test_gt() {\n-    fail_unless!(parse(\"1.2.3-alpha2\") > parse(\"0.0.0\"));\n-    fail_unless!(parse(\"1.2.3-alpha2\") > parse(\"1.0.0\"));\n-    fail_unless!(parse(\"1.2.3-alpha2\") > parse(\"1.2.0\"));\n-    fail_unless!(parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha1\"));\n-    fail_unless!(parse(\"1.2.3\")        > parse(\"1.2.3-alpha2\"));\n-    fail_unless!(!(parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha2\")));\n+    assert!(parse(\"1.2.3-alpha2\") > parse(\"0.0.0\"));\n+    assert!(parse(\"1.2.3-alpha2\") > parse(\"1.0.0\"));\n+    assert!(parse(\"1.2.3-alpha2\") > parse(\"1.2.0\"));\n+    assert!(parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha1\"));\n+    assert!(parse(\"1.2.3\")        > parse(\"1.2.3-alpha2\"));\n+    assert!(!(parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha2\")));\n }\n \n #[test]\n fn test_ge() {\n-    fail_unless!(parse(\"1.2.3-alpha2\") >= parse(\"0.0.0\"));\n-    fail_unless!(parse(\"1.2.3-alpha2\") >= parse(\"1.0.0\"));\n-    fail_unless!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.0\"));\n-    fail_unless!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha1\"));\n-    fail_unless!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha2\"));\n+    assert!(parse(\"1.2.3-alpha2\") >= parse(\"0.0.0\"));\n+    assert!(parse(\"1.2.3-alpha2\") >= parse(\"1.0.0\"));\n+    assert!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.0\"));\n+    assert!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha1\"));\n+    assert!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha2\"));\n }\n \n #[test]\n@@ -388,7 +388,7 @@ fn test_spec_order() {\n     while i < vs.len() {\n         let a = parse(vs[i-1]).get();\n         let b = parse(vs[i]).get();\n-        fail_unless!(a < b);\n+        assert!(a < b);\n         i += 1;\n     }\n }"}, {"sha": "1a2d4a87d98866a03064d2020e6534685eef75cd", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -74,7 +74,7 @@ pub fn sha1() -> @Sha1 {\n           work_buf: @mut ~[u32]};\n \n     fn add_input(st: &mut Sha1State, msg: &const [u8]) {\n-        fail_unless!((!st.computed));\n+        assert!((!st.computed));\n         for vec::each_const(msg) |element| {\n             st.msg_block[st.msg_block_idx] = *element;\n             st.msg_block_idx += 1u;\n@@ -90,8 +90,8 @@ pub fn sha1() -> @Sha1 {\n         }\n     }\n     fn process_msg_block(st: &mut Sha1State) {\n-        fail_unless!((vec::len(st.h) == digest_buf_len));\n-        fail_unless!((vec::uniq_len(st.work_buf) == work_buf_len));\n+        assert!((vec::len(st.h) == digest_buf_len));\n+        assert!((vec::uniq_len(st.work_buf) == work_buf_len));\n         let mut t: int; // Loop counter\n         let mut w = st.work_buf;\n \n@@ -192,7 +192,7 @@ pub fn sha1() -> @Sha1 {\n      * can be assumed that the message digest has been computed.\n      */\n     fn pad_msg(st: &mut Sha1State) {\n-        fail_unless!((vec::len((*st).msg_block) == msg_block_len));\n+        assert!((vec::len((*st).msg_block) == msg_block_len));\n \n         /*\n          * Check to see if the current message block is too small to hold\n@@ -230,7 +230,7 @@ pub fn sha1() -> @Sha1 {\n \n     impl Sha1 for Sha1State {\n         fn reset(&mut self) {\n-            fail_unless!((vec::len(self.h) == digest_buf_len));\n+            assert!((vec::len(self.h) == digest_buf_len));\n             self.len_low = 0u32;\n             self.len_high = 0u32;\n             self.msg_block_idx = 0u;\n@@ -366,13 +366,13 @@ mod tests {\n             ];\n             let tests = fips_180_1_tests + wikipedia_tests;\n             fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n-                fail_unless!((vec::len::<u8>(v0) == vec::len::<u8>(v1)));\n+                assert!((vec::len::<u8>(v0) == vec::len::<u8>(v1)));\n                 let len = vec::len::<u8>(v0);\n                 let mut i = 0u;\n                 while i < len {\n                     let a = v0[i];\n                     let b = v1[i];\n-                    fail_unless!((a == b));\n+                    assert!((a == b));\n                     i += 1u;\n                 }\n             }\n@@ -385,8 +385,8 @@ mod tests {\n                 check_vec_eq(t.output, out);\n \n                 let out_str = sh.result_str();\n-                fail_unless!((out_str.len() == 40));\n-                fail_unless!((out_str == t.output_str));\n+                assert!((out_str.len() == 40));\n+                assert!((out_str == t.output_str));\n \n                 sh.reset();\n             }\n@@ -406,8 +406,8 @@ mod tests {\n                 check_vec_eq(t.output, out);\n \n                 let out_str = sh.result_str();\n-                fail_unless!((out_str.len() == 40));\n-                fail_unless!((out_str == t.output_str));\n+                assert!((out_str.len() == 40));\n+                assert!((out_str == t.output_str));\n \n                 sh.reset();\n             }"}, {"sha": "b6c5ec03068cd74e9bf88f16774deb8ec125a6b6", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -177,9 +177,9 @@ mod tests {\n     #[test]\n     fn test_find_mut() {\n         let mut m = SmallIntMap::new();\n-        fail_unless!(m.insert(1, 12));\n-        fail_unless!(m.insert(2, 8));\n-        fail_unless!(m.insert(5, 14));\n+        assert!(m.insert(1, 12));\n+        assert!(m.insert(2, 8));\n+        assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n             None => fail!(), Some(x) => *x = new\n@@ -190,30 +190,30 @@ mod tests {\n     #[test]\n     fn test_len() {\n         let mut map = SmallIntMap::new();\n-        fail_unless!(map.len() == 0);\n-        fail_unless!(map.is_empty());\n-        fail_unless!(map.insert(5, 20));\n-        fail_unless!(map.len() == 1);\n-        fail_unless!(!map.is_empty());\n-        fail_unless!(map.insert(11, 12));\n-        fail_unless!(map.len() == 2);\n-        fail_unless!(!map.is_empty());\n-        fail_unless!(map.insert(14, 22));\n-        fail_unless!(map.len() == 3);\n-        fail_unless!(!map.is_empty());\n+        assert!(map.len() == 0);\n+        assert!(map.is_empty());\n+        assert!(map.insert(5, 20));\n+        assert!(map.len() == 1);\n+        assert!(!map.is_empty());\n+        assert!(map.insert(11, 12));\n+        assert!(map.len() == 2);\n+        assert!(!map.is_empty());\n+        assert!(map.insert(14, 22));\n+        assert!(map.len() == 3);\n+        assert!(!map.is_empty());\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut map = SmallIntMap::new();\n-        fail_unless!(map.insert(5, 20));\n-        fail_unless!(map.insert(11, 12));\n-        fail_unless!(map.insert(14, 22));\n+        assert!(map.insert(5, 20));\n+        assert!(map.insert(11, 12));\n+        assert!(map.insert(14, 22));\n         map.clear();\n-        fail_unless!(map.is_empty());\n-        fail_unless!(map.find(&5).is_none());\n-        fail_unless!(map.find(&11).is_none());\n-        fail_unless!(map.find(&14).is_none());\n+        assert!(map.is_empty());\n+        assert!(map.find(&5).is_none());\n+        assert!(map.find(&11).is_none());\n+        assert!(map.find(&14).is_none());\n     }\n \n     #[test]\n@@ -238,11 +238,11 @@ mod tests {\n         map.update_with_key(3, 2, addMoreToCount);\n \n         // check the total counts\n-        fail_unless!(map.find(&3).get() == &10);\n-        fail_unless!(map.find(&5).get() == &3);\n-        fail_unless!(map.find(&9).get() == &1);\n+        assert!(map.find(&3).get() == &10);\n+        assert!(map.find(&5).get() == &3);\n+        assert!(map.find(&9).get() == &1);\n \n         // sadly, no sevens were counted\n-        fail_unless!(map.find(&7).is_none());\n+        assert!(map.find(&7).is_none());\n     }\n }"}, {"sha": "40a12895175674f1dde813b7ff7299ff30bca5c5", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -223,15 +223,15 @@ pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n     let size = array.len();\n     let mut start = start;\n-    fail_unless!(start <= size);\n+    assert!(start <= size);\n \n     if start == 0 { start += 1; }\n \n     while start < size {\n         let pivot = array[start];\n         let mut left = 0;\n         let mut right = start;\n-        fail_unless!(left <= right);\n+        assert!(left <= right);\n \n         while left < right {\n             let mid = (left + right) >> 1;\n@@ -241,7 +241,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n                 left = mid+1;\n             }\n         }\n-        fail_unless!(left == right);\n+        assert!(left == right);\n         let mut n = start-left;\n \n         copy_vec(array, left+1, array, left, n);\n@@ -272,7 +272,7 @@ fn min_run_length(n: uint) -> uint {\n \n fn count_run_ascending<T:Copy + Ord>(array: &mut [T]) -> uint {\n     let size = array.len();\n-    fail_unless!(size > 0);\n+    assert!(size > 0);\n     if size == 1 { return 1; }\n \n     let mut run = 2;\n@@ -295,7 +295,7 @@ fn gallop_left<T:Copy + Ord>(key: &const T,\n                              hint: uint)\n                           -> uint {\n     let size = array.len();\n-    fail_unless!(size != 0 && hint < size);\n+    assert!(size != 0 && hint < size);\n \n     let mut last_ofs = 0;\n     let mut ofs = 1;\n@@ -326,7 +326,7 @@ fn gallop_left<T:Copy + Ord>(key: &const T,\n         last_ofs = hint - ofs;\n         ofs = hint - tmp;\n     }\n-    fail_unless!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n+    assert!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n \n     last_ofs += 1;\n     while last_ofs < ofs {\n@@ -337,7 +337,7 @@ fn gallop_left<T:Copy + Ord>(key: &const T,\n             ofs = m;\n         }\n     }\n-    fail_unless!(last_ofs == ofs);\n+    assert!(last_ofs == ofs);\n     return ofs;\n }\n \n@@ -346,7 +346,7 @@ fn gallop_right<T:Copy + Ord>(key: &const T,\n                               hint: uint)\n                            -> uint {\n     let size = array.len();\n-    fail_unless!(size != 0 && hint < size);\n+    assert!(size != 0 && hint < size);\n \n     let mut last_ofs = 0;\n     let mut ofs = 1;\n@@ -378,7 +378,7 @@ fn gallop_right<T:Copy + Ord>(key: &const T,\n         ofs = hint - tmp;\n     }\n \n-    fail_unless!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n+    assert!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n \n     last_ofs += 1;\n     while last_ofs < ofs {\n@@ -390,7 +390,7 @@ fn gallop_right<T:Copy + Ord>(key: &const T,\n             ofs = m;\n         }\n     }\n-    fail_unless!(last_ofs == ofs);\n+    assert!(last_ofs == ofs);\n     return ofs;\n }\n \n@@ -420,16 +420,16 @@ impl<T:Copy + Ord> MergeState<T> {\n \n     fn merge_at(&mut self, n: uint, array: &mut [T]) {\n         let mut size = self.runs.len();\n-        fail_unless!(size >= 2);\n-        fail_unless!(n == size-2 || n == size-3);\n+        assert!(size >= 2);\n+        assert!(n == size-2 || n == size-3);\n \n         let mut b1 = self.runs[n].base;\n         let mut l1 = self.runs[n].len;\n         let b2 = self.runs[n+1].base;\n         let l2 = self.runs[n+1].len;\n \n-        fail_unless!(l1 > 0 && l2 > 0);\n-        fail_unless!(b1 + l1 == b2);\n+        assert!(l1 > 0 && l2 > 0);\n+        assert!(b1 + l1 == b2);\n \n         self.runs[n].len = l1 + l2;\n         if n == size-3 {\n@@ -458,7 +458,7 @@ impl<T:Copy + Ord> MergeState<T> {\n \n     fn merge_lo(&mut self, array: &mut [T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n-        fail_unless!(len1 != 0 && len2 != 0 && base1+len1 == base2);\n+        assert!(len1 != 0 && len2 != 0 && base1+len1 == base2);\n \n         let mut tmp = ~[];\n         for uint::range(base1, base1+len1) |i| {\n@@ -491,7 +491,7 @@ impl<T:Copy + Ord> MergeState<T> {\n             let mut break_outer = false;\n \n             loop {\n-                fail_unless!(len1 > 1 && len2 != 0);\n+                assert!(len1 > 1 && len2 != 0);\n                 if array[c2] < tmp[c1] {\n                     array[dest] <-> array[c2];\n                     dest += 1; c2 += 1; len2 -= 1;\n@@ -515,7 +515,7 @@ impl<T:Copy + Ord> MergeState<T> {\n \n             // Start to gallop\n             loop {\n-                fail_unless!(len1 > 1 && len2 != 0);\n+                assert!(len1 > 1 && len2 != 0);\n \n                 let tmp_view = vec::const_slice(tmp, c1, c1+len1);\n                 count1 = gallop_right(&const array[c2], tmp_view, 0);\n@@ -550,21 +550,21 @@ impl<T:Copy + Ord> MergeState<T> {\n         self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n \n         if len1 == 1 {\n-            fail_unless!(len2 > 0);\n+            assert!(len2 > 0);\n             copy_vec(array, dest, array, c2, len2);\n             array[dest+len2] <-> tmp[c1];\n         } else if len1 == 0 {\n             fail!(~\"Comparison violates its contract!\");\n         } else {\n-            fail_unless!(len2 == 0);\n-            fail_unless!(len1 > 1);\n+            assert!(len2 == 0);\n+            assert!(len1 > 1);\n             copy_vec(array, dest, tmp, c1, len1);\n         }\n     }\n \n     fn merge_hi(&mut self, array: &mut [T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n-        fail_unless!(len1 != 1 && len2 != 0 && base1 + len1 == base2);\n+        assert!(len1 != 1 && len2 != 0 && base1 + len1 == base2);\n \n         let mut tmp = ~[];\n         for uint::range(base2, base2+len2) |i| {\n@@ -599,7 +599,7 @@ impl<T:Copy + Ord> MergeState<T> {\n             let mut break_outer = false;\n \n             loop {\n-                fail_unless!(len1 != 0 && len2 > 1);\n+                assert!(len1 != 0 && len2 > 1);\n                 if tmp[c2] < array[c1] {\n                     array[dest] <-> array[c1];\n                     dest -= 1; c1 -= 1; len1 -= 1;\n@@ -623,7 +623,7 @@ impl<T:Copy + Ord> MergeState<T> {\n \n             // Start to gallop\n             loop {\n-                fail_unless!(len2 > 1 && len1 != 0);\n+                assert!(len2 > 1 && len1 != 0);\n \n                 let tmp_view = vec::mut_slice(array, base1, base1+len1);\n                 count1 = len1 - gallop_right(\n@@ -669,16 +669,16 @@ impl<T:Copy + Ord> MergeState<T> {\n         self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n \n         if len2 == 1 {\n-            fail_unless!(len1 > 0);\n+            assert!(len1 > 0);\n             dest -= len1;\n             c1 -= len1;\n             copy_vec(array, dest+1, array, c1+1, len1);\n             array[dest] <-> tmp[c2];\n         } else if len2 == 0 {\n             fail!(~\"Comparison violates its contract!\");\n         } else {\n-            fail_unless!(len1 == 0);\n-            fail_unless!(len2 != 0);\n+            assert!(len1 == 0);\n+            assert!(len2 != 0);\n             copy_vec(array, dest-(len2-1), tmp, 0, len2);\n         }\n     }\n@@ -718,7 +718,7 @@ fn copy_vec<T:Copy>(dest: &mut [T],\n                     from: &const [T],\n                     s2: uint,\n                     len: uint) {\n-    fail_unless!(s1+len <= dest.len() && s2+len <= from.len());\n+    assert!(s1+len <= dest.len() && s2+len <= from.len());\n \n     let mut slice = ~[];\n     for uint::range(s2, s2+len) |i| {\n@@ -742,7 +742,7 @@ mod test_qsort3 {\n         let mut i = 0;\n         while i < len {\n             // debug!(v2[i]);\n-            fail_unless!((v2[i] == v1[i]));\n+            assert!((v2[i] == v1[i]));\n             i += 1;\n         }\n     }\n@@ -787,7 +787,7 @@ mod test_qsort {\n         let mut i = 0u;\n         while i < len {\n             // debug!(v2[i]);\n-            fail_unless!((v2[i] == v1[i]));\n+            assert!((v2[i] == v1[i]));\n             i += 1;\n         }\n     }\n@@ -832,7 +832,7 @@ mod test_qsort {\n         for vec::each(pairs) |p| {\n             let (a, b) = *p;\n             debug!(\"%d %d\", a, b);\n-            fail_unless!((a == b));\n+            assert!((a == b));\n         }\n     }\n }\n@@ -853,7 +853,7 @@ mod tests {\n         let mut i = 0u;\n         while i < len {\n             debug!(v3[i]);\n-            fail_unless!((v3[i] == v2[i]));\n+            assert!((v3[i] == v2[i]));\n             i += 1;\n         }\n     }\n@@ -880,7 +880,7 @@ mod tests {\n         pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let mut v1 = ~[3, 2, 1];\n         let v2 = merge_sort(v1, le);\n-        fail_unless!(v2 == ~[1, 2, 3]);\n+        assert!(v2 == ~[1, 2, 3]);\n     }\n \n     #[test]\n@@ -901,7 +901,7 @@ mod tests {\n         let names2 = ~[\"Alex Andy\", \"Jack Brown\", \"joe bob\", \"Joe Bob\",\n                        \"JOE Bob\", \"JOE BOB\", \"Sally Mae\"];\n         let names3 = merge_sort(names1, ile);\n-        fail_unless!(names3 == names2);\n+        assert!(names3 == names2);\n     }\n }\n \n@@ -938,7 +938,7 @@ mod test_tim_sort {\n         let mut i = 0u;\n         while i < len {\n             // debug!(v2[i]);\n-            fail_unless!((v2[i] == v1[i]));\n+            assert!((v2[i] == v1[i]));\n             i += 1u;\n         }\n     }"}, {"sha": "6513a671ab343d8f3cb8d7a6e95cc85bd73fecd9", "filename": "src/libstd/stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstats.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -36,22 +36,22 @@ impl<'self> Stats for &'self [f64] {\n     }\n \n     fn min(self) -> f64 {\n-        fail_unless!(self.len() != 0);\n+        assert!(self.len() != 0);\n         vec::foldl(self[0], self, |p,q| cmp::min(p, *q))\n     }\n \n     fn max(self) -> f64 {\n-        fail_unless!(self.len() != 0);\n+        assert!(self.len() != 0);\n         vec::foldl(self[0], self, |p,q| cmp::max(p, *q))\n     }\n \n     fn mean(self) -> f64 {\n-        fail_unless!(self.len() != 0);\n+        assert!(self.len() != 0);\n         self.sum() / (self.len() as f64)\n     }\n \n     fn median(self) -> f64 {\n-        fail_unless!(self.len() != 0);\n+        assert!(self.len() != 0);\n         let mut tmp = vec::from_slice(self);\n         sort::tim_sort(tmp);\n         if tmp.len() & 1 == 0 {"}, {"sha": "99b3a122d9f702d1768545b2540c7d13e1959d4f", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -595,7 +595,7 @@ pub impl RWlock {\n             do task::unkillable {\n                 let mut first_reader = false;\n                 do self.state.with |state| {\n-                    fail_unless!(!state.read_mode);\n+                    assert!(!state.read_mode);\n                     state.read_mode = true;\n                     first_reader = (state.read_count == 0);\n                     state.read_count += 1;\n@@ -626,8 +626,8 @@ impl<'self> Drop for RWlockReleaseRead<'self> {\n             do task::unkillable {\n                 let mut last_reader = false;\n                 do self.lock.state.with |state| {\n-                    fail_unless!(state.read_mode);\n-                    fail_unless!(state.read_count > 0);\n+                    assert!(state.read_mode);\n+                    assert!(state.read_count > 0);\n                     state.read_count -= 1;\n                     if state.read_count == 0 {\n                         last_reader = true;\n@@ -663,7 +663,7 @@ impl<'self> Drop for RWlockReleaseDowngrade<'self> {\n                 let mut writer_or_last_reader = false;\n                 do self.lock.state.with |state| {\n                     if state.read_mode {\n-                        fail_unless!(state.read_count > 0);\n+                        assert!(state.read_count > 0);\n                         state.read_count -= 1;\n                         if state.read_count == 0 {\n                             // Case 1: Writer downgraded & was the last reader\n@@ -852,7 +852,7 @@ mod tests {\n         access_shared(sharedstate, m, 10);\n         let _ = p.recv();\n \n-        fail_unless!(*sharedstate == 20);\n+        assert!(*sharedstate == 20);\n \n         fn access_shared(sharedstate: &mut int, m: &Mutex, n: uint) {\n             for n.times {\n@@ -874,7 +874,7 @@ mod tests {\n             do task::spawn || {\n                 do m2.lock_cond |cond| {\n                     let woken = cond.signal();\n-                    fail_unless!(woken);\n+                    assert!(woken);\n                 }\n             }\n             cond.wait();\n@@ -892,7 +892,7 @@ mod tests {\n         let _ = port.recv(); // Wait until child gets in the mutex\n         do m.lock_cond |cond| {\n             let woken = cond.signal();\n-            fail_unless!(woken);\n+            assert!(woken);\n         }\n         let _ = port.recv(); // Wait until child wakes up\n     }\n@@ -918,7 +918,7 @@ mod tests {\n         for ports.each |port| { let _ = port.recv(); }\n         do m.lock_cond |cond| {\n             let num_woken = cond.broadcast();\n-            fail_unless!(num_woken == num_waiters);\n+            assert!(num_woken == num_waiters);\n         }\n         // wait until all children wake up\n         for ports.each |port| { let _ = port.recv(); }\n@@ -939,7 +939,7 @@ mod tests {\n             do m.lock_cond |_x| { }\n         };\n         do m2.lock_cond |cond| {\n-            fail_unless!(!cond.signal());\n+            assert!(!cond.signal());\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -953,7 +953,7 @@ mod tests {\n                 fail!();\n             }\n         };\n-        fail_unless!(result.is_err());\n+        assert!(result.is_err());\n         // child task must have finished by the time try returns\n         do m.lock { }\n     }\n@@ -976,11 +976,11 @@ mod tests {\n                 cond.wait(); // block forever\n             }\n         };\n-        fail_unless!(result.is_err());\n+        assert!(result.is_err());\n         // child task must have finished by the time try returns\n         do m.lock_cond |cond| {\n             let woken = cond.signal();\n-            fail_unless!(!woken);\n+            assert!(!woken);\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -1013,12 +1013,12 @@ mod tests {\n             c.send(sibling_convos); // let parent wait on all children\n             fail!();\n         };\n-        fail_unless!(result.is_err());\n+        assert!(result.is_err());\n         // child task must have finished by the time try returns\n         for vec::each(p.recv()) |p| { p.recv(); } // wait on all its siblings\n         do m.lock_cond |cond| {\n             let woken = cond.broadcast();\n-            fail_unless!(woken == 0);\n+            assert!(woken == 0);\n         }\n         struct SendOnFailure {\n             c: comm::Chan<()>,\n@@ -1069,25 +1069,25 @@ mod tests {\n                 }\n             }\n         };\n-        fail_unless!(result.is_err());\n+        assert!(result.is_err());\n     }\n     #[test] #[ignore(cfg(windows))]\n     pub fn test_mutex_no_condvars() {\n         let result = do task::try {\n             let m = ~mutex_with_condvars(0);\n             do m.lock_cond |cond| { cond.wait(); }\n         };\n-        fail_unless!(result.is_err());\n+        assert!(result.is_err());\n         let result = do task::try {\n             let m = ~mutex_with_condvars(0);\n             do m.lock_cond |cond| { cond.signal(); }\n         };\n-        fail_unless!(result.is_err());\n+        assert!(result.is_err());\n         let result = do task::try {\n             let m = ~mutex_with_condvars(0);\n             do m.lock_cond |cond| { cond.broadcast(); }\n         };\n-        fail_unless!(result.is_err());\n+        assert!(result.is_err());\n     }\n     /************************************************************************\n      * Reader/writer lock tests\n@@ -1129,7 +1129,7 @@ mod tests {\n         access_shared(sharedstate, x, mode2, 10);\n         let _ = p.recv();\n \n-        fail_unless!(*sharedstate == 20);\n+        assert!(*sharedstate == 20);\n \n         fn access_shared(sharedstate: &mut int, x: &RWlock, mode: RWlockMode,\n                          n: uint) {\n@@ -1223,7 +1223,7 @@ mod tests {\n             do task::spawn || {\n                 do x2.write_cond |cond| {\n                     let woken = cond.signal();\n-                    fail_unless!(woken);\n+                    assert!(woken);\n                 }\n             }\n             cond.wait();\n@@ -1242,7 +1242,7 @@ mod tests {\n         do x.read { } // Must be able to get in as a reader in the meantime\n         do x.write_cond |cond| { // Or as another writer\n             let woken = cond.signal();\n-            fail_unless!(woken);\n+            assert!(woken);\n         }\n         let _ = port.recv(); // Wait until child wakes up\n         do x.read { } // Just for good measure\n@@ -1281,7 +1281,7 @@ mod tests {\n         for ports.each |port| { let _ = port.recv(); }\n         do lock_cond(x, dg2) |cond| {\n             let num_woken = cond.broadcast();\n-            fail_unless!(num_woken == num_waiters);\n+            assert!(num_woken == num_waiters);\n         }\n         // wait until all children wake up\n         for ports.each |port| { let _ = port.recv(); }\n@@ -1308,7 +1308,7 @@ mod tests {\n                 fail!();\n             }\n         };\n-        fail_unless!(result.is_err());\n+        assert!(result.is_err());\n         // child task must have finished by the time try returns\n         do lock_rwlock_in_mode(x, mode2) { }\n     }"}, {"sha": "aed6721b78ea16baaa16d6ffccbd27befcb85f7e", "filename": "src/libstd/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask_pool.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -49,7 +49,7 @@ pub impl<T> TaskPool<T> {\n            opt_sched_mode: Option<SchedMode>,\n            init_fn_factory: ~fn() -> ~fn(uint) -> T)\n         -> TaskPool<T> {\n-        fail_unless!(n_tasks >= 1);\n+        assert!(n_tasks >= 1);\n \n         let channels = do vec::from_fn(n_tasks) |i| {\n             let (port, chan) = comm::stream::<Msg<T>>();"}, {"sha": "895ccbc820b162d168883d68e5feb0deec22069d", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -30,5 +30,5 @@ pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n fn test_mkdtemp() {\n     let p = mkdtemp(&Path(\".\"), \"foobar\").unwrap();\n     os::remove_dir(&p);\n-    fail_unless!(str::ends_with(p.to_str(), \"foobar\"));\n+    assert!(str::ends_with(p.to_str(), \"foobar\"));\n }"}, {"sha": "022f1f8564ece8c0a21cccc485e468a3c8f94467", "filename": "src/libstd/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -60,7 +60,7 @@ pub fn color_supported() -> bool {\n }\n \n pub fn set_color(writer: @io::Writer, first_char: u8, color: u8) {\n-    fail_unless!((color < 16u8));\n+    assert!((color < 16u8));\n     esc(writer);\n     let mut color = color;\n     if color >= 8u8 { writer.write(~['1' as u8, ';' as u8]); color -= 8u8; }"}, {"sha": "7c5591d839e204608e07743512d3e62c4629115f", "filename": "src/libstd/test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -282,7 +282,7 @@ pub fn run_tests_console(opts: &TestOpts,\n \n     run_tests(opts, tests, |x| callback(&x, st));\n \n-    fail_unless!(st.passed + st.failed +\n+    assert!(st.passed + st.failed +\n                  st.ignored + st.benchmarked == st.total);\n     let success = st.failed == 0u;\n \n@@ -403,7 +403,7 @@ fn should_sort_failures_before_printing_them() {\n \n     let apos = str::find_str(s, ~\"a\").get();\n     let bpos = str::find_str(s, ~\"b\").get();\n-    fail_unless!(apos < bpos);\n+    assert!(apos < bpos);\n }\n \n fn use_color() -> bool { return get_concurrency() == 1; }\n@@ -797,7 +797,7 @@ mod tests {\n         let ch = SharedChan(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n-        fail_unless!(res != TrOk);\n+        assert!(res != TrOk);\n     }\n \n     #[test]\n@@ -815,7 +815,7 @@ mod tests {\n         let ch = SharedChan(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n-        fail_unless!(res == TrIgnored);\n+        assert!(res == TrIgnored);\n     }\n \n     #[test]\n@@ -834,7 +834,7 @@ mod tests {\n         let ch = SharedChan(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n-        fail_unless!(res == TrOk);\n+        assert!(res == TrOk);\n     }\n \n     #[test]\n@@ -852,7 +852,7 @@ mod tests {\n         let ch = SharedChan(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n-        fail_unless!(res == TrFailed);\n+        assert!(res == TrFailed);\n     }\n \n     #[test]\n@@ -862,7 +862,7 @@ mod tests {\n           either::Left(copy o) => o,\n           _ => fail!(~\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n-        fail_unless!(~\"filter\" == opts.filter.get());\n+        assert!(~\"filter\" == opts.filter.get());\n     }\n \n     #[test]\n@@ -872,7 +872,7 @@ mod tests {\n           either::Left(copy o) => o,\n           _ => fail!(~\"Malformed arg in parse_ignored_flag\")\n         };\n-        fail_unless!((opts.run_ignored));\n+        assert!((opts.run_ignored));\n     }\n \n     #[test]\n@@ -912,9 +912,9 @@ mod tests {\n         ];\n         let filtered = filter_tests(&opts, tests);\n \n-        fail_unless!((vec::len(filtered) == 1));\n-        fail_unless!((filtered[0].desc.name.to_str() == ~\"1\"));\n-        fail_unless!((filtered[0].desc.ignore == false));\n+        assert!((vec::len(filtered) == 1));\n+        assert!((filtered[0].desc.name.to_str() == ~\"1\"));\n+        assert!((filtered[0].desc.ignore == false));\n     }\n \n     #[test]\n@@ -969,7 +969,7 @@ mod tests {\n         for vec::each(pairs) |p| {\n             match *p {\n                 (ref a, ref b) => {\n-                    fail_unless!((*a == b.desc.name.to_str()));\n+                    assert!((*a == b.desc.name.to_str()));\n                 }\n             }\n         }"}, {"sha": "3af193e87486bc872facd483a242f3981429ea72", "filename": "src/libstd/time.rs", "status": "modified", "additions": 182, "deletions": 182, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -53,7 +53,7 @@ pub struct Timespec { sec: i64, nsec: i32 }\n  */\n pub impl Timespec {\n     fn new(sec: i64, nsec: i32) -> Timespec {\n-        fail_unless!(nsec >= 0 && nsec < NSEC_PER_SEC);\n+        assert!(nsec >= 0 && nsec < NSEC_PER_SEC);\n         Timespec { sec: sec, nsec: nsec }\n     }\n }\n@@ -883,17 +883,17 @@ mod tests {\n         let tv1 = get_time();\n         debug!(\"tv1=%? sec + %? nsec\", tv1.sec as uint, tv1.nsec as uint);\n \n-        fail_unless!(tv1.sec > some_recent_date);\n-        fail_unless!(tv1.nsec < 1000000000i32);\n+        assert!(tv1.sec > some_recent_date);\n+        assert!(tv1.nsec < 1000000000i32);\n \n         let tv2 = get_time();\n         debug!(\"tv2=%? sec + %? nsec\", tv2.sec as uint, tv2.nsec as uint);\n \n-        fail_unless!(tv2.sec >= tv1.sec);\n-        fail_unless!(tv2.sec < some_future_date);\n-        fail_unless!(tv2.nsec < 1000000000i32);\n+        assert!(tv2.sec >= tv1.sec);\n+        assert!(tv2.sec < some_future_date);\n+        assert!(tv2.nsec < 1000000000i32);\n         if tv2.sec == tv1.sec {\n-            fail_unless!(tv2.nsec >= tv1.nsec);\n+            assert!(tv2.nsec >= tv1.nsec);\n         }\n     }\n \n@@ -902,16 +902,16 @@ mod tests {\n         let ns1 = precise_time_ns();\n \n         debug!(\"s0=%s sec\", float::to_str_digits(s0, 9u));\n-        fail_unless!(s0 > 0.);\n+        assert!(s0 > 0.);\n         let ns0 = (s0 * 1000000000.) as u64;\n         debug!(\"ns0=%? ns\", ns0);\n \n         debug!(\"ns1=%? ns\", ns0);\n-        fail_unless!(ns1 >= ns0);\n+        assert!(ns1 >= ns0);\n \n         let ns2 = precise_time_ns();\n         debug!(\"ns2=%? ns\", ns0);\n-        fail_unless!(ns2 >= ns1);\n+        assert!(ns2 >= ns1);\n     }\n \n     pub fn test_at_utc() {\n@@ -921,18 +921,18 @@ mod tests {\n         let time = ::time::Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n \n-        fail_unless!(utc.tm_sec == 30_i32);\n-        fail_unless!(utc.tm_min == 31_i32);\n-        fail_unless!(utc.tm_hour == 23_i32);\n-        fail_unless!(utc.tm_mday == 13_i32);\n-        fail_unless!(utc.tm_mon == 1_i32);\n-        fail_unless!(utc.tm_year == 109_i32);\n-        fail_unless!(utc.tm_wday == 5_i32);\n-        fail_unless!(utc.tm_yday == 43_i32);\n-        fail_unless!(utc.tm_isdst == 0_i32);\n-        fail_unless!(utc.tm_gmtoff == 0_i32);\n-        fail_unless!(utc.tm_zone == ~\"UTC\");\n-        fail_unless!(utc.tm_nsec == 54321_i32);\n+        assert!(utc.tm_sec == 30_i32);\n+        assert!(utc.tm_min == 31_i32);\n+        assert!(utc.tm_hour == 23_i32);\n+        assert!(utc.tm_mday == 13_i32);\n+        assert!(utc.tm_mon == 1_i32);\n+        assert!(utc.tm_year == 109_i32);\n+        assert!(utc.tm_wday == 5_i32);\n+        assert!(utc.tm_yday == 43_i32);\n+        assert!(utc.tm_isdst == 0_i32);\n+        assert!(utc.tm_gmtoff == 0_i32);\n+        assert!(utc.tm_zone == ~\"UTC\");\n+        assert!(utc.tm_nsec == 54321_i32);\n     }\n \n     pub fn test_at() {\n@@ -944,23 +944,23 @@ mod tests {\n \n         error!(\"time_at: %?\", local);\n \n-        fail_unless!(local.tm_sec == 30_i32);\n-        fail_unless!(local.tm_min == 31_i32);\n-        fail_unless!(local.tm_hour == 15_i32);\n-        fail_unless!(local.tm_mday == 13_i32);\n-        fail_unless!(local.tm_mon == 1_i32);\n-        fail_unless!(local.tm_year == 109_i32);\n-        fail_unless!(local.tm_wday == 5_i32);\n-        fail_unless!(local.tm_yday == 43_i32);\n-        fail_unless!(local.tm_isdst == 0_i32);\n-        fail_unless!(local.tm_gmtoff == -28800_i32);\n+        assert!(local.tm_sec == 30_i32);\n+        assert!(local.tm_min == 31_i32);\n+        assert!(local.tm_hour == 15_i32);\n+        assert!(local.tm_mday == 13_i32);\n+        assert!(local.tm_mon == 1_i32);\n+        assert!(local.tm_year == 109_i32);\n+        assert!(local.tm_wday == 5_i32);\n+        assert!(local.tm_yday == 43_i32);\n+        assert!(local.tm_isdst == 0_i32);\n+        assert!(local.tm_gmtoff == -28800_i32);\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let zone = &local.tm_zone;\n-        fail_unless!(*zone == ~\"PST\" || *zone == ~\"Pacific Standard Time\");\n+        assert!(*zone == ~\"PST\" || *zone == ~\"Pacific Standard Time\");\n \n-        fail_unless!(local.tm_nsec == 54321_i32);\n+        assert!(local.tm_nsec == 54321_i32);\n     }\n \n     pub fn test_to_timespec() {\n@@ -970,8 +970,8 @@ mod tests {\n         let time = ::time::Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n \n-        fail_unless!(utc.to_timespec() == time);\n-        fail_unless!(utc.to_local().to_timespec() == time);\n+        assert!(utc.to_timespec() == time);\n+        assert!(utc.to_local().to_timespec() == time);\n     }\n \n     pub fn test_conversions() {\n@@ -982,12 +982,12 @@ mod tests {\n         let utc = at_utc(time);\n         let local = at(time);\n \n-        fail_unless!(local.to_local() == local);\n-        fail_unless!(local.to_utc() == utc);\n-        fail_unless!(local.to_utc().to_local() == local);\n-        fail_unless!(utc.to_utc() == utc);\n-        fail_unless!(utc.to_local() == local);\n-        fail_unless!(utc.to_local().to_utc() == utc);\n+        assert!(local.to_local() == local);\n+        assert!(local.to_utc() == utc);\n+        assert!(local.to_utc().to_local() == local);\n+        assert!(utc.to_utc() == utc);\n+        assert!(utc.to_local() == local);\n+        assert!(utc.to_local().to_utc() == utc);\n     }\n \n     pub fn test_strptime() {\n@@ -996,41 +996,41 @@ mod tests {\n \n         match strptime(~\"\", ~\"\") {\n           Ok(ref tm) => {\n-            fail_unless!(tm.tm_sec == 0_i32);\n-            fail_unless!(tm.tm_min == 0_i32);\n-            fail_unless!(tm.tm_hour == 0_i32);\n-            fail_unless!(tm.tm_mday == 0_i32);\n-            fail_unless!(tm.tm_mon == 0_i32);\n-            fail_unless!(tm.tm_year == 0_i32);\n-            fail_unless!(tm.tm_wday == 0_i32);\n-            fail_unless!(tm.tm_isdst== 0_i32);\n-            fail_unless!(tm.tm_gmtoff == 0_i32);\n-            fail_unless!(tm.tm_zone == ~\"\");\n-            fail_unless!(tm.tm_nsec == 0_i32);\n+            assert!(tm.tm_sec == 0_i32);\n+            assert!(tm.tm_min == 0_i32);\n+            assert!(tm.tm_hour == 0_i32);\n+            assert!(tm.tm_mday == 0_i32);\n+            assert!(tm.tm_mon == 0_i32);\n+            assert!(tm.tm_year == 0_i32);\n+            assert!(tm.tm_wday == 0_i32);\n+            assert!(tm.tm_isdst== 0_i32);\n+            assert!(tm.tm_gmtoff == 0_i32);\n+            assert!(tm.tm_zone == ~\"\");\n+            assert!(tm.tm_nsec == 0_i32);\n           }\n           Err(_) => ()\n         }\n \n         let format = ~\"%a %b %e %T %Y\";\n-        fail_unless!(strptime(~\"\", format) == Err(~\"Invalid time\"));\n-        fail_unless!(strptime(~\"Fri Feb 13 15:31:30\", format)\n+        assert!(strptime(~\"\", format) == Err(~\"Invalid time\"));\n+        assert!(strptime(~\"Fri Feb 13 15:31:30\", format)\n             == Err(~\"Invalid time\"));\n \n         match strptime(~\"Fri Feb 13 15:31:30 2009\", format) {\n           Err(copy e) => fail!(e),\n           Ok(ref tm) => {\n-            fail_unless!(tm.tm_sec == 30_i32);\n-            fail_unless!(tm.tm_min == 31_i32);\n-            fail_unless!(tm.tm_hour == 15_i32);\n-            fail_unless!(tm.tm_mday == 13_i32);\n-            fail_unless!(tm.tm_mon == 1_i32);\n-            fail_unless!(tm.tm_year == 109_i32);\n-            fail_unless!(tm.tm_wday == 5_i32);\n-            fail_unless!(tm.tm_yday == 0_i32);\n-            fail_unless!(tm.tm_isdst == 0_i32);\n-            fail_unless!(tm.tm_gmtoff == 0_i32);\n-            fail_unless!(tm.tm_zone == ~\"\");\n-            fail_unless!(tm.tm_nsec == 0_i32);\n+            assert!(tm.tm_sec == 30_i32);\n+            assert!(tm.tm_min == 31_i32);\n+            assert!(tm.tm_hour == 15_i32);\n+            assert!(tm.tm_mday == 13_i32);\n+            assert!(tm.tm_mon == 1_i32);\n+            assert!(tm.tm_year == 109_i32);\n+            assert!(tm.tm_wday == 5_i32);\n+            assert!(tm.tm_yday == 0_i32);\n+            assert!(tm.tm_isdst == 0_i32);\n+            assert!(tm.tm_gmtoff == 0_i32);\n+            assert!(tm.tm_zone == ~\"\");\n+            assert!(tm.tm_nsec == 0_i32);\n           }\n         }\n \n@@ -1050,7 +1050,7 @@ mod tests {\n             ~\"Friday\",\n             ~\"Saturday\"\n         ]) |day| {\n-            fail_unless!(test(*day, ~\"%A\"));\n+            assert!(test(*day, ~\"%A\"));\n         }\n \n         for vec::each([\n@@ -1062,7 +1062,7 @@ mod tests {\n             ~\"Fri\",\n             ~\"Sat\"\n         ]) |day| {\n-            fail_unless!(test(*day, ~\"%a\"));\n+            assert!(test(*day, ~\"%a\"));\n         }\n \n         for vec::each([\n@@ -1079,7 +1079,7 @@ mod tests {\n             ~\"November\",\n             ~\"December\"\n         ]) |day| {\n-            fail_unless!(test(*day, ~\"%B\"));\n+            assert!(test(*day, ~\"%B\"));\n         }\n \n         for vec::each([\n@@ -1096,56 +1096,56 @@ mod tests {\n             ~\"Nov\",\n             ~\"Dec\"\n         ]) |day| {\n-            fail_unless!(test(*day, ~\"%b\"));\n+            assert!(test(*day, ~\"%b\"));\n         }\n \n-        fail_unless!(test(~\"19\", ~\"%C\"));\n-        fail_unless!(test(~\"Fri Feb 13 23:31:30 2009\", ~\"%c\"));\n-        fail_unless!(test(~\"02/13/09\", ~\"%D\"));\n-        fail_unless!(test(~\"03\", ~\"%d\"));\n-        fail_unless!(test(~\"13\", ~\"%d\"));\n-        fail_unless!(test(~\" 3\", ~\"%e\"));\n-        fail_unless!(test(~\"13\", ~\"%e\"));\n-        fail_unless!(test(~\"2009-02-13\", ~\"%F\"));\n-        fail_unless!(test(~\"03\", ~\"%H\"));\n-        fail_unless!(test(~\"13\", ~\"%H\"));\n-        fail_unless!(test(~\"03\", ~\"%I\")); // FIXME (#2350): flesh out\n-        fail_unless!(test(~\"11\", ~\"%I\")); // FIXME (#2350): flesh out\n-        fail_unless!(test(~\"044\", ~\"%j\"));\n-        fail_unless!(test(~\" 3\", ~\"%k\"));\n-        fail_unless!(test(~\"13\", ~\"%k\"));\n-        fail_unless!(test(~\" 1\", ~\"%l\"));\n-        fail_unless!(test(~\"11\", ~\"%l\"));\n-        fail_unless!(test(~\"03\", ~\"%M\"));\n-        fail_unless!(test(~\"13\", ~\"%M\"));\n-        fail_unless!(test(~\"\\n\", ~\"%n\"));\n-        fail_unless!(test(~\"am\", ~\"%P\"));\n-        fail_unless!(test(~\"pm\", ~\"%P\"));\n-        fail_unless!(test(~\"AM\", ~\"%p\"));\n-        fail_unless!(test(~\"PM\", ~\"%p\"));\n-        fail_unless!(test(~\"23:31\", ~\"%R\"));\n-        fail_unless!(test(~\"11:31:30 AM\", ~\"%r\"));\n-        fail_unless!(test(~\"11:31:30 PM\", ~\"%r\"));\n-        fail_unless!(test(~\"03\", ~\"%S\"));\n-        fail_unless!(test(~\"13\", ~\"%S\"));\n-        fail_unless!(test(~\"15:31:30\", ~\"%T\"));\n-        fail_unless!(test(~\"\\t\", ~\"%t\"));\n-        fail_unless!(test(~\"1\", ~\"%u\"));\n-        fail_unless!(test(~\"7\", ~\"%u\"));\n-        fail_unless!(test(~\"13-Feb-2009\", ~\"%v\"));\n-        fail_unless!(test(~\"0\", ~\"%w\"));\n-        fail_unless!(test(~\"6\", ~\"%w\"));\n-        fail_unless!(test(~\"2009\", ~\"%Y\"));\n-        fail_unless!(test(~\"09\", ~\"%y\"));\n-        fail_unless!(result::unwrap(strptime(~\"UTC\", ~\"%Z\")).tm_zone ==\n+        assert!(test(~\"19\", ~\"%C\"));\n+        assert!(test(~\"Fri Feb 13 23:31:30 2009\", ~\"%c\"));\n+        assert!(test(~\"02/13/09\", ~\"%D\"));\n+        assert!(test(~\"03\", ~\"%d\"));\n+        assert!(test(~\"13\", ~\"%d\"));\n+        assert!(test(~\" 3\", ~\"%e\"));\n+        assert!(test(~\"13\", ~\"%e\"));\n+        assert!(test(~\"2009-02-13\", ~\"%F\"));\n+        assert!(test(~\"03\", ~\"%H\"));\n+        assert!(test(~\"13\", ~\"%H\"));\n+        assert!(test(~\"03\", ~\"%I\")); // FIXME (#2350): flesh out\n+        assert!(test(~\"11\", ~\"%I\")); // FIXME (#2350): flesh out\n+        assert!(test(~\"044\", ~\"%j\"));\n+        assert!(test(~\" 3\", ~\"%k\"));\n+        assert!(test(~\"13\", ~\"%k\"));\n+        assert!(test(~\" 1\", ~\"%l\"));\n+        assert!(test(~\"11\", ~\"%l\"));\n+        assert!(test(~\"03\", ~\"%M\"));\n+        assert!(test(~\"13\", ~\"%M\"));\n+        assert!(test(~\"\\n\", ~\"%n\"));\n+        assert!(test(~\"am\", ~\"%P\"));\n+        assert!(test(~\"pm\", ~\"%P\"));\n+        assert!(test(~\"AM\", ~\"%p\"));\n+        assert!(test(~\"PM\", ~\"%p\"));\n+        assert!(test(~\"23:31\", ~\"%R\"));\n+        assert!(test(~\"11:31:30 AM\", ~\"%r\"));\n+        assert!(test(~\"11:31:30 PM\", ~\"%r\"));\n+        assert!(test(~\"03\", ~\"%S\"));\n+        assert!(test(~\"13\", ~\"%S\"));\n+        assert!(test(~\"15:31:30\", ~\"%T\"));\n+        assert!(test(~\"\\t\", ~\"%t\"));\n+        assert!(test(~\"1\", ~\"%u\"));\n+        assert!(test(~\"7\", ~\"%u\"));\n+        assert!(test(~\"13-Feb-2009\", ~\"%v\"));\n+        assert!(test(~\"0\", ~\"%w\"));\n+        assert!(test(~\"6\", ~\"%w\"));\n+        assert!(test(~\"2009\", ~\"%Y\"));\n+        assert!(test(~\"09\", ~\"%y\"));\n+        assert!(result::unwrap(strptime(~\"UTC\", ~\"%Z\")).tm_zone ==\n             ~\"UTC\");\n-        fail_unless!(result::unwrap(strptime(~\"PST\", ~\"%Z\")).tm_zone ==\n+        assert!(result::unwrap(strptime(~\"PST\", ~\"%Z\")).tm_zone ==\n             ~\"\");\n-        fail_unless!(result::unwrap(strptime(~\"-0000\", ~\"%z\")).tm_gmtoff ==\n+        assert!(result::unwrap(strptime(~\"-0000\", ~\"%z\")).tm_gmtoff ==\n             0);\n-        fail_unless!(result::unwrap(strptime(~\"-0800\", ~\"%z\")).tm_gmtoff ==\n+        assert!(result::unwrap(strptime(~\"-0800\", ~\"%z\")).tm_gmtoff ==\n             0);\n-        fail_unless!(test(~\"%\", ~\"%%\"));\n+        assert!(test(~\"%\", ~\"%%\"));\n     }\n \n     pub fn test_ctime() {\n@@ -1158,8 +1158,8 @@ mod tests {\n \n         error!(\"test_ctime: %? %?\", utc.ctime(), local.ctime());\n \n-        fail_unless!(utc.ctime()   == ~\"Fri Feb 13 23:31:30 2009\");\n-        fail_unless!(local.ctime() == ~\"Fri Feb 13 15:31:30 2009\");\n+        assert!(utc.ctime()   == ~\"Fri Feb 13 23:31:30 2009\");\n+        assert!(local.ctime() == ~\"Fri Feb 13 15:31:30 2009\");\n     }\n \n     pub fn test_strftime() {\n@@ -1170,69 +1170,69 @@ mod tests {\n         let utc = at_utc(time);\n         let local = at(time);\n \n-        fail_unless!(local.strftime(~\"\") == ~\"\");\n-        fail_unless!(local.strftime(~\"%A\") == ~\"Friday\");\n-        fail_unless!(local.strftime(~\"%a\") == ~\"Fri\");\n-        fail_unless!(local.strftime(~\"%B\") == ~\"February\");\n-        fail_unless!(local.strftime(~\"%b\") == ~\"Feb\");\n-        fail_unless!(local.strftime(~\"%C\") == ~\"20\");\n-        fail_unless!(local.strftime(~\"%c\") == ~\"Fri Feb 13 15:31:30 2009\");\n-        fail_unless!(local.strftime(~\"%D\") == ~\"02/13/09\");\n-        fail_unless!(local.strftime(~\"%d\") == ~\"13\");\n-        fail_unless!(local.strftime(~\"%e\") == ~\"13\");\n-        fail_unless!(local.strftime(~\"%F\") == ~\"2009-02-13\");\n-        // fail_unless!(local.strftime(\"%G\") == \"2009\");\n-        // fail_unless!(local.strftime(\"%g\") == \"09\");\n-        fail_unless!(local.strftime(~\"%H\") == ~\"15\");\n-        fail_unless!(local.strftime(~\"%I\") == ~\"03\");\n-        fail_unless!(local.strftime(~\"%j\") == ~\"044\");\n-        fail_unless!(local.strftime(~\"%k\") == ~\"15\");\n-        fail_unless!(local.strftime(~\"%l\") == ~\" 3\");\n-        fail_unless!(local.strftime(~\"%M\") == ~\"31\");\n-        fail_unless!(local.strftime(~\"%m\") == ~\"02\");\n-        fail_unless!(local.strftime(~\"%n\") == ~\"\\n\");\n-        fail_unless!(local.strftime(~\"%P\") == ~\"pm\");\n-        fail_unless!(local.strftime(~\"%p\") == ~\"PM\");\n-        fail_unless!(local.strftime(~\"%R\") == ~\"15:31\");\n-        fail_unless!(local.strftime(~\"%r\") == ~\"03:31:30 PM\");\n-        fail_unless!(local.strftime(~\"%S\") == ~\"30\");\n-        fail_unless!(local.strftime(~\"%s\") == ~\"1234567890\");\n-        fail_unless!(local.strftime(~\"%T\") == ~\"15:31:30\");\n-        fail_unless!(local.strftime(~\"%t\") == ~\"\\t\");\n-        // fail_unless!(local.strftime(\"%U\") == \"06\");\n-        fail_unless!(local.strftime(~\"%u\") == ~\"5\");\n-        // fail_unless!(local.strftime(\"%V\") == \"07\");\n-        fail_unless!(local.strftime(~\"%v\") == ~\"13-Feb-2009\");\n-        // fail_unless!(local.strftime(\"%W\") == \"06\");\n-        fail_unless!(local.strftime(~\"%w\") == ~\"5\");\n+        assert!(local.strftime(~\"\") == ~\"\");\n+        assert!(local.strftime(~\"%A\") == ~\"Friday\");\n+        assert!(local.strftime(~\"%a\") == ~\"Fri\");\n+        assert!(local.strftime(~\"%B\") == ~\"February\");\n+        assert!(local.strftime(~\"%b\") == ~\"Feb\");\n+        assert!(local.strftime(~\"%C\") == ~\"20\");\n+        assert!(local.strftime(~\"%c\") == ~\"Fri Feb 13 15:31:30 2009\");\n+        assert!(local.strftime(~\"%D\") == ~\"02/13/09\");\n+        assert!(local.strftime(~\"%d\") == ~\"13\");\n+        assert!(local.strftime(~\"%e\") == ~\"13\");\n+        assert!(local.strftime(~\"%F\") == ~\"2009-02-13\");\n+        // assert!(local.strftime(\"%G\") == \"2009\");\n+        // assert!(local.strftime(\"%g\") == \"09\");\n+        assert!(local.strftime(~\"%H\") == ~\"15\");\n+        assert!(local.strftime(~\"%I\") == ~\"03\");\n+        assert!(local.strftime(~\"%j\") == ~\"044\");\n+        assert!(local.strftime(~\"%k\") == ~\"15\");\n+        assert!(local.strftime(~\"%l\") == ~\" 3\");\n+        assert!(local.strftime(~\"%M\") == ~\"31\");\n+        assert!(local.strftime(~\"%m\") == ~\"02\");\n+        assert!(local.strftime(~\"%n\") == ~\"\\n\");\n+        assert!(local.strftime(~\"%P\") == ~\"pm\");\n+        assert!(local.strftime(~\"%p\") == ~\"PM\");\n+        assert!(local.strftime(~\"%R\") == ~\"15:31\");\n+        assert!(local.strftime(~\"%r\") == ~\"03:31:30 PM\");\n+        assert!(local.strftime(~\"%S\") == ~\"30\");\n+        assert!(local.strftime(~\"%s\") == ~\"1234567890\");\n+        assert!(local.strftime(~\"%T\") == ~\"15:31:30\");\n+        assert!(local.strftime(~\"%t\") == ~\"\\t\");\n+        // assert!(local.strftime(\"%U\") == \"06\");\n+        assert!(local.strftime(~\"%u\") == ~\"5\");\n+        // assert!(local.strftime(\"%V\") == \"07\");\n+        assert!(local.strftime(~\"%v\") == ~\"13-Feb-2009\");\n+        // assert!(local.strftime(\"%W\") == \"06\");\n+        assert!(local.strftime(~\"%w\") == ~\"5\");\n         // handle \"%X\"\n         // handle \"%x\"\n-        fail_unless!(local.strftime(~\"%Y\") == ~\"2009\");\n-        fail_unless!(local.strftime(~\"%y\") == ~\"09\");\n+        assert!(local.strftime(~\"%Y\") == ~\"2009\");\n+        assert!(local.strftime(~\"%y\") == ~\"09\");\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let zone = local.strftime(~\"%Z\");\n-        fail_unless!(zone == ~\"PST\" || zone == ~\"Pacific Standard Time\");\n+        assert!(zone == ~\"PST\" || zone == ~\"Pacific Standard Time\");\n \n-        fail_unless!(local.strftime(~\"%z\") == ~\"-0800\");\n-        fail_unless!(local.strftime(~\"%%\") == ~\"%\");\n+        assert!(local.strftime(~\"%z\") == ~\"-0800\");\n+        assert!(local.strftime(~\"%%\") == ~\"%\");\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let rfc822 = local.rfc822();\n         let prefix = ~\"Fri, 13 Feb 2009 15:31:30 \";\n-        fail_unless!(rfc822 == prefix + ~\"PST\" ||\n+        assert!(rfc822 == prefix + ~\"PST\" ||\n                      rfc822 == prefix + ~\"Pacific Standard Time\");\n \n-        fail_unless!(local.ctime() == ~\"Fri Feb 13 15:31:30 2009\");\n-        fail_unless!(local.rfc822z() == ~\"Fri, 13 Feb 2009 15:31:30 -0800\");\n-        fail_unless!(local.rfc3339() == ~\"2009-02-13T15:31:30-08:00\");\n+        assert!(local.ctime() == ~\"Fri Feb 13 15:31:30 2009\");\n+        assert!(local.rfc822z() == ~\"Fri, 13 Feb 2009 15:31:30 -0800\");\n+        assert!(local.rfc3339() == ~\"2009-02-13T15:31:30-08:00\");\n \n-        fail_unless!(utc.ctime() == ~\"Fri Feb 13 23:31:30 2009\");\n-        fail_unless!(utc.rfc822() == ~\"Fri, 13 Feb 2009 23:31:30 GMT\");\n-        fail_unless!(utc.rfc822z() == ~\"Fri, 13 Feb 2009 23:31:30 -0000\");\n-        fail_unless!(utc.rfc3339() == ~\"2009-02-13T23:31:30Z\");\n+        assert!(utc.ctime() == ~\"Fri Feb 13 23:31:30 2009\");\n+        assert!(utc.rfc822() == ~\"Fri, 13 Feb 2009 23:31:30 GMT\");\n+        assert!(utc.rfc822z() == ~\"Fri, 13 Feb 2009 23:31:30 -0000\");\n+        assert!(utc.rfc3339() == ~\"2009-02-13T23:31:30Z\");\n     }\n \n     pub fn test_timespec_eq_ord() {\n@@ -1244,28 +1244,28 @@ mod tests {\n         let d = &Timespec::new(2, 1);\n         let e = &Timespec::new(2, 1);\n \n-        fail_unless!(eq(d, e));\n-        fail_unless!(ne(c, e));\n+        assert!(eq(d, e));\n+        assert!(ne(c, e));\n \n-        fail_unless!(lt(a, b));\n-        fail_unless!(lt(b, c));\n-        fail_unless!(lt(c, d));\n+        assert!(lt(a, b));\n+        assert!(lt(b, c));\n+        assert!(lt(c, d));\n \n-        fail_unless!(le(a, b));\n-        fail_unless!(le(b, c));\n-        fail_unless!(le(c, d));\n-        fail_unless!(le(d, e));\n-        fail_unless!(le(e, d));\n+        assert!(le(a, b));\n+        assert!(le(b, c));\n+        assert!(le(c, d));\n+        assert!(le(d, e));\n+        assert!(le(e, d));\n \n-        fail_unless!(ge(b, a));\n-        fail_unless!(ge(c, b));\n-        fail_unless!(ge(d, c));\n-        fail_unless!(ge(e, d));\n-        fail_unless!(ge(d, e));\n+        assert!(ge(b, a));\n+        assert!(ge(c, b));\n+        assert!(ge(d, c));\n+        assert!(ge(e, d));\n+        assert!(ge(d, e));\n \n-        fail_unless!(gt(b, a));\n-        fail_unless!(gt(c, b));\n-        fail_unless!(gt(d, c));\n+        assert!(gt(b, a));\n+        assert!(gt(c, b));\n+        assert!(gt(d, c));\n     }\n \n     #[test]"}, {"sha": "229d1a07caaabbe4f79262e5d9566d657eafcae9", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -261,14 +261,14 @@ mod test {\n \n             match recv_timeout(hl_loop, 10u, &test_po) {\n               Some(val) => {\n-                fail_unless!(val == expected);\n+                assert!(val == expected);\n                 successes += 1;\n               }\n               _ => failures += 1\n             };\n         }\n \n-        fail_unless!(successes > times / 2);\n+        assert!(successes > times / 2);\n     }\n \n     #[test]\n@@ -292,6 +292,6 @@ mod test {\n             };\n         }\n \n-        fail_unless!(successes > times / 2);\n+        assert!(successes > times / 2);\n     }\n }"}, {"sha": "d0868da4408d4c85720ed30344197b7bf3f028d0", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 163, "deletions": 163, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -725,24 +725,24 @@ mod test_treemap {\n \n     #[test]\n     fn find_empty() {\n-        let m = TreeMap::new::<int, int>(); fail_unless!(m.find(&5) == None);\n+        let m = TreeMap::new::<int, int>(); assert!(m.find(&5) == None);\n     }\n \n     #[test]\n     fn find_not_found() {\n         let mut m = TreeMap::new();\n-        fail_unless!(m.insert(1, 2));\n-        fail_unless!(m.insert(5, 3));\n-        fail_unless!(m.insert(9, 3));\n-        fail_unless!(m.find(&2) == None);\n+        assert!(m.insert(1, 2));\n+        assert!(m.insert(5, 3));\n+        assert!(m.insert(9, 3));\n+        assert!(m.find(&2) == None);\n     }\n \n     #[test]\n     fn test_find_mut() {\n         let mut m = TreeMap::new();\n-        fail_unless!(m.insert(1, 12));\n-        fail_unless!(m.insert(2, 8));\n-        fail_unless!(m.insert(5, 14));\n+        assert!(m.insert(1, 12));\n+        assert!(m.insert(2, 8));\n+        assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n           None => fail!(), Some(x) => *x = new\n@@ -753,24 +753,24 @@ mod test_treemap {\n     #[test]\n     fn insert_replace() {\n         let mut m = TreeMap::new();\n-        fail_unless!(m.insert(5, 2));\n-        fail_unless!(m.insert(2, 9));\n-        fail_unless!(!m.insert(2, 11));\n-        fail_unless!(m.find(&2).unwrap() == &11);\n+        assert!(m.insert(5, 2));\n+        assert!(m.insert(2, 9));\n+        assert!(!m.insert(2, 11));\n+        assert!(m.find(&2).unwrap() == &11);\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut m = TreeMap::new();\n         m.clear();\n-        fail_unless!(m.insert(5, 11));\n-        fail_unless!(m.insert(12, -3));\n-        fail_unless!(m.insert(19, 2));\n+        assert!(m.insert(5, 11));\n+        assert!(m.insert(12, -3));\n+        assert!(m.insert(19, 2));\n         m.clear();\n-        fail_unless!(m.find(&5).is_none());\n-        fail_unless!(m.find(&12).is_none());\n-        fail_unless!(m.find(&19).is_none());\n-        fail_unless!(m.is_empty());\n+        assert!(m.find(&5).is_none());\n+        assert!(m.find(&12).is_none());\n+        assert!(m.find(&19).is_none());\n+        assert!(m.is_empty());\n     }\n \n     #[test]\n@@ -785,41 +785,41 @@ mod test_treemap {\n         m.insert(copy k1, copy v1);\n         m.insert(copy k2, copy v2);\n \n-        fail_unless!(m.find(&k2) == Some(&v2));\n-        fail_unless!(m.find(&k1) == Some(&v1));\n+        assert!(m.find(&k2) == Some(&v2));\n+        assert!(m.find(&k1) == Some(&v1));\n     }\n \n     fn check_equal<K: Eq + TotalOrd, V: Eq>(ctrl: &[(K, V)],\n                                             map: &TreeMap<K, V>) {\n-        fail_unless!(ctrl.is_empty() == map.is_empty());\n+        assert!(ctrl.is_empty() == map.is_empty());\n         for ctrl.each |x| {\n             let &(k, v) = x;\n-            fail_unless!(map.find(&k).unwrap() == &v)\n+            assert!(map.find(&k).unwrap() == &v)\n         }\n         for map.each |&(map_k, map_v)| {\n             let mut found = false;\n             for ctrl.each |x| {\n                 let &(ctrl_k, ctrl_v) = x;\n                 if *map_k == ctrl_k {\n-                    fail_unless!(*map_v == ctrl_v);\n+                    assert!(*map_v == ctrl_v);\n                     found = true;\n                     break;\n                 }\n             }\n-            fail_unless!(found);\n+            assert!(found);\n         }\n     }\n \n     fn check_left<K: TotalOrd, V>(node: &Option<~TreeNode<K, V>>,\n                                   parent: &~TreeNode<K, V>) {\n         match *node {\n           Some(ref r) => {\n-            fail_unless!(r.key.cmp(&parent.key) == Less);\n-            fail_unless!(r.level == parent.level - 1); // left is black\n+            assert!(r.key.cmp(&parent.key) == Less);\n+            assert!(r.level == parent.level - 1); // left is black\n             check_left(&r.left, r);\n             check_right(&r.right, r, false);\n           }\n-          None => fail_unless!(parent.level == 1) // parent is leaf\n+          None => assert!(parent.level == 1) // parent is leaf\n         }\n     }\n \n@@ -828,15 +828,15 @@ mod test_treemap {\n                                    parent_red: bool) {\n         match *node {\n           Some(ref r) => {\n-            fail_unless!(r.key.cmp(&parent.key) == Greater);\n+            assert!(r.key.cmp(&parent.key) == Greater);\n             let red = r.level == parent.level;\n-            if parent_red { fail_unless!(!red) } // no dual horizontal links\n+            if parent_red { assert!(!red) } // no dual horizontal links\n             // Right red or black\n-            fail_unless!(red || r.level == parent.level - 1);\n+            assert!(red || r.level == parent.level - 1);\n             check_left(&r.left, r);\n             check_right(&r.right, r, red);\n           }\n-          None => fail_unless!(parent.level == 1) // parent is leaf\n+          None => assert!(parent.level == 1) // parent is leaf\n         }\n     }\n \n@@ -856,7 +856,7 @@ mod test_treemap {\n         let mut ctrl = ~[];\n \n         check_equal(ctrl, &map);\n-        fail_unless!(map.find(&5).is_none());\n+        assert!(map.find(&5).is_none());\n \n         let rng = rand::seeded_rng(&[42]);\n \n@@ -865,7 +865,7 @@ mod test_treemap {\n                 let k = rng.gen_int();\n                 let v = rng.gen_int();\n                 if !ctrl.contains(&(k, v)) {\n-                    fail_unless!(map.insert(k, v));\n+                    assert!(map.insert(k, v));\n                     ctrl.push((k, v));\n                     check_structure(&map);\n                     check_equal(ctrl, &map);\n@@ -875,7 +875,7 @@ mod test_treemap {\n             for 30.times {\n                 let r = rng.gen_uint_range(0, ctrl.len());\n                 let (key, _) = vec::remove(&mut ctrl, r);\n-                fail_unless!(map.remove(&key));\n+                assert!(map.remove(&key));\n                 check_structure(&map);\n                 check_equal(ctrl, &map);\n             }\n@@ -885,36 +885,36 @@ mod test_treemap {\n     #[test]\n     fn test_len() {\n         let mut m = TreeMap::new();\n-        fail_unless!(m.insert(3, 6));\n-        fail_unless!(m.len() == 1);\n-        fail_unless!(m.insert(0, 0));\n-        fail_unless!(m.len() == 2);\n-        fail_unless!(m.insert(4, 8));\n-        fail_unless!(m.len() == 3);\n-        fail_unless!(m.remove(&3));\n-        fail_unless!(m.len() == 2);\n-        fail_unless!(!m.remove(&5));\n-        fail_unless!(m.len() == 2);\n-        fail_unless!(m.insert(2, 4));\n-        fail_unless!(m.len() == 3);\n-        fail_unless!(m.insert(1, 2));\n-        fail_unless!(m.len() == 4);\n+        assert!(m.insert(3, 6));\n+        assert!(m.len() == 1);\n+        assert!(m.insert(0, 0));\n+        assert!(m.len() == 2);\n+        assert!(m.insert(4, 8));\n+        assert!(m.len() == 3);\n+        assert!(m.remove(&3));\n+        assert!(m.len() == 2);\n+        assert!(!m.remove(&5));\n+        assert!(m.len() == 2);\n+        assert!(m.insert(2, 4));\n+        assert!(m.len() == 3);\n+        assert!(m.insert(1, 2));\n+        assert!(m.len() == 4);\n     }\n \n     #[test]\n     fn test_each() {\n         let mut m = TreeMap::new();\n \n-        fail_unless!(m.insert(3, 6));\n-        fail_unless!(m.insert(0, 0));\n-        fail_unless!(m.insert(4, 8));\n-        fail_unless!(m.insert(2, 4));\n-        fail_unless!(m.insert(1, 2));\n+        assert!(m.insert(3, 6));\n+        assert!(m.insert(0, 0));\n+        assert!(m.insert(4, 8));\n+        assert!(m.insert(2, 4));\n+        assert!(m.insert(1, 2));\n \n         let mut n = 0;\n         for m.each |&(k, v)| {\n-            fail_unless!(*k == n);\n-            fail_unless!(*v == n * 2);\n+            assert!(*k == n);\n+            assert!(*v == n * 2);\n             n += 1;\n         }\n     }\n@@ -923,16 +923,16 @@ mod test_treemap {\n     fn test_each_reverse() {\n         let mut m = TreeMap::new();\n \n-        fail_unless!(m.insert(3, 6));\n-        fail_unless!(m.insert(0, 0));\n-        fail_unless!(m.insert(4, 8));\n-        fail_unless!(m.insert(2, 4));\n-        fail_unless!(m.insert(1, 2));\n+        assert!(m.insert(3, 6));\n+        assert!(m.insert(0, 0));\n+        assert!(m.insert(4, 8));\n+        assert!(m.insert(2, 4));\n+        assert!(m.insert(1, 2));\n \n         let mut n = 4;\n         for m.each_reverse |&(k, v)| {\n-            fail_unless!(*k == n);\n-            fail_unless!(*v == n * 2);\n+            assert!(*k == n);\n+            assert!(*v == n * 2);\n             n -= 1;\n         }\n     }\n@@ -942,49 +942,49 @@ mod test_treemap {\n         let mut a = TreeMap::new();\n         let mut b = TreeMap::new();\n \n-        fail_unless!(a == b);\n-        fail_unless!(a.insert(0, 5));\n-        fail_unless!(a != b);\n-        fail_unless!(b.insert(0, 4));\n-        fail_unless!(a != b);\n-        fail_unless!(a.insert(5, 19));\n-        fail_unless!(a != b);\n-        fail_unless!(!b.insert(0, 5));\n-        fail_unless!(a != b);\n-        fail_unless!(b.insert(5, 19));\n-        fail_unless!(a == b);\n+        assert!(a == b);\n+        assert!(a.insert(0, 5));\n+        assert!(a != b);\n+        assert!(b.insert(0, 4));\n+        assert!(a != b);\n+        assert!(a.insert(5, 19));\n+        assert!(a != b);\n+        assert!(!b.insert(0, 5));\n+        assert!(a != b);\n+        assert!(b.insert(5, 19));\n+        assert!(a == b);\n     }\n \n     #[test]\n     fn test_lt() {\n         let mut a = TreeMap::new();\n         let mut b = TreeMap::new();\n \n-        fail_unless!(!(a < b) && !(b < a));\n-        fail_unless!(b.insert(0, 5));\n-        fail_unless!(a < b);\n-        fail_unless!(a.insert(0, 7));\n-        fail_unless!(!(a < b) && !(b < a));\n-        fail_unless!(b.insert(-2, 0));\n-        fail_unless!(b < a);\n-        fail_unless!(a.insert(-5, 2));\n-        fail_unless!(a < b);\n-        fail_unless!(a.insert(6, 2));\n-        fail_unless!(a < b && !(b < a));\n+        assert!(!(a < b) && !(b < a));\n+        assert!(b.insert(0, 5));\n+        assert!(a < b);\n+        assert!(a.insert(0, 7));\n+        assert!(!(a < b) && !(b < a));\n+        assert!(b.insert(-2, 0));\n+        assert!(b < a);\n+        assert!(a.insert(-5, 2));\n+        assert!(a < b);\n+        assert!(a.insert(6, 2));\n+        assert!(a < b && !(b < a));\n     }\n \n     #[test]\n     fn test_ord() {\n         let mut a = TreeMap::new();\n         let mut b = TreeMap::new();\n \n-        fail_unless!(a <= b && a >= b);\n-        fail_unless!(a.insert(1, 1));\n-        fail_unless!(a > b && a >= b);\n-        fail_unless!(b < a && b <= a);\n-        fail_unless!(b.insert(2, 2));\n-        fail_unless!(b > a && b >= a);\n-        fail_unless!(a < b && a <= b);\n+        assert!(a <= b && a >= b);\n+        assert!(a.insert(1, 1));\n+        assert!(a > b && a >= b);\n+        assert!(b < a && b <= a);\n+        assert!(b.insert(2, 2));\n+        assert!(b > a && b >= a);\n+        assert!(a < b && a <= b);\n     }\n \n     #[test]\n@@ -996,22 +996,22 @@ mod test_treemap {\n         let (x4, y4) = (29, 5);\n         let (x5, y5) = (103, 3);\n \n-        fail_unless!(m.insert(x1, y1));\n-        fail_unless!(m.insert(x2, y2));\n-        fail_unless!(m.insert(x3, y3));\n-        fail_unless!(m.insert(x4, y4));\n-        fail_unless!(m.insert(x5, y5));\n+        assert!(m.insert(x1, y1));\n+        assert!(m.insert(x2, y2));\n+        assert!(m.insert(x3, y3));\n+        assert!(m.insert(x4, y4));\n+        assert!(m.insert(x5, y5));\n \n         let m = m;\n         let mut a = m.iter();\n \n-        fail_unless!(map_next(&mut a).unwrap() == (&x1, &y1));\n-        fail_unless!(map_next(&mut a).unwrap() == (&x2, &y2));\n-        fail_unless!(map_next(&mut a).unwrap() == (&x3, &y3));\n-        fail_unless!(map_next(&mut a).unwrap() == (&x4, &y4));\n-        fail_unless!(map_next(&mut a).unwrap() == (&x5, &y5));\n+        assert!(map_next(&mut a).unwrap() == (&x1, &y1));\n+        assert!(map_next(&mut a).unwrap() == (&x2, &y2));\n+        assert!(map_next(&mut a).unwrap() == (&x3, &y3));\n+        assert!(map_next(&mut a).unwrap() == (&x4, &y4));\n+        assert!(map_next(&mut a).unwrap() == (&x5, &y5));\n \n-        fail_unless!(map_next(&mut a).is_none());\n+        assert!(map_next(&mut a).is_none());\n \n         let mut b = m.iter();\n \n@@ -1020,7 +1020,7 @@ mod test_treemap {\n         let mut i = 0;\n \n         for map_advance(&mut b) |x| {\n-            fail_unless!(expected[i] == x);\n+            assert!(expected[i] == x);\n             i += 1;\n \n             if i == 2 {\n@@ -1029,7 +1029,7 @@ mod test_treemap {\n         }\n \n         for map_advance(&mut b) |x| {\n-            fail_unless!(expected[i] == x);\n+            assert!(expected[i] == x);\n             i += 1;\n         }\n     }\n@@ -1043,80 +1043,80 @@ mod test_set {\n     fn test_clear() {\n         let mut s = TreeSet::new();\n         s.clear();\n-        fail_unless!(s.insert(5));\n-        fail_unless!(s.insert(12));\n-        fail_unless!(s.insert(19));\n+        assert!(s.insert(5));\n+        assert!(s.insert(12));\n+        assert!(s.insert(19));\n         s.clear();\n-        fail_unless!(!s.contains(&5));\n-        fail_unless!(!s.contains(&12));\n-        fail_unless!(!s.contains(&19));\n-        fail_unless!(s.is_empty());\n+        assert!(!s.contains(&5));\n+        assert!(!s.contains(&12));\n+        assert!(!s.contains(&19));\n+        assert!(s.is_empty());\n     }\n \n     #[test]\n     fn test_disjoint() {\n         let mut xs = TreeSet::new();\n         let mut ys = TreeSet::new();\n-        fail_unless!(xs.is_disjoint(&ys));\n-        fail_unless!(ys.is_disjoint(&xs));\n-        fail_unless!(xs.insert(5));\n-        fail_unless!(ys.insert(11));\n-        fail_unless!(xs.is_disjoint(&ys));\n-        fail_unless!(ys.is_disjoint(&xs));\n-        fail_unless!(xs.insert(7));\n-        fail_unless!(xs.insert(19));\n-        fail_unless!(xs.insert(4));\n-        fail_unless!(ys.insert(2));\n-        fail_unless!(ys.insert(-11));\n-        fail_unless!(xs.is_disjoint(&ys));\n-        fail_unless!(ys.is_disjoint(&xs));\n-        fail_unless!(ys.insert(7));\n-        fail_unless!(!xs.is_disjoint(&ys));\n-        fail_unless!(!ys.is_disjoint(&xs));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(xs.insert(5));\n+        assert!(ys.insert(11));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(xs.insert(7));\n+        assert!(xs.insert(19));\n+        assert!(xs.insert(4));\n+        assert!(ys.insert(2));\n+        assert!(ys.insert(-11));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(ys.insert(7));\n+        assert!(!xs.is_disjoint(&ys));\n+        assert!(!ys.is_disjoint(&xs));\n     }\n \n     #[test]\n     fn test_subset_and_superset() {\n         let mut a = TreeSet::new();\n-        fail_unless!(a.insert(0));\n-        fail_unless!(a.insert(5));\n-        fail_unless!(a.insert(11));\n-        fail_unless!(a.insert(7));\n+        assert!(a.insert(0));\n+        assert!(a.insert(5));\n+        assert!(a.insert(11));\n+        assert!(a.insert(7));\n \n         let mut b = TreeSet::new();\n-        fail_unless!(b.insert(0));\n-        fail_unless!(b.insert(7));\n-        fail_unless!(b.insert(19));\n-        fail_unless!(b.insert(250));\n-        fail_unless!(b.insert(11));\n-        fail_unless!(b.insert(200));\n+        assert!(b.insert(0));\n+        assert!(b.insert(7));\n+        assert!(b.insert(19));\n+        assert!(b.insert(250));\n+        assert!(b.insert(11));\n+        assert!(b.insert(200));\n \n-        fail_unless!(!a.is_subset(&b));\n-        fail_unless!(!a.is_superset(&b));\n-        fail_unless!(!b.is_subset(&a));\n-        fail_unless!(!b.is_superset(&a));\n+        assert!(!a.is_subset(&b));\n+        assert!(!a.is_superset(&b));\n+        assert!(!b.is_subset(&a));\n+        assert!(!b.is_superset(&a));\n \n-        fail_unless!(b.insert(5));\n+        assert!(b.insert(5));\n \n-        fail_unless!(a.is_subset(&b));\n-        fail_unless!(!a.is_superset(&b));\n-        fail_unless!(!b.is_subset(&a));\n-        fail_unless!(b.is_superset(&a));\n+        assert!(a.is_subset(&b));\n+        assert!(!a.is_superset(&b));\n+        assert!(!b.is_subset(&a));\n+        assert!(b.is_superset(&a));\n     }\n \n     #[test]\n     fn test_each() {\n         let mut m = TreeSet::new();\n \n-        fail_unless!(m.insert(3));\n-        fail_unless!(m.insert(0));\n-        fail_unless!(m.insert(4));\n-        fail_unless!(m.insert(2));\n-        fail_unless!(m.insert(1));\n+        assert!(m.insert(3));\n+        assert!(m.insert(0));\n+        assert!(m.insert(4));\n+        assert!(m.insert(2));\n+        assert!(m.insert(1));\n \n         let mut n = 0;\n         for m.each |x| {\n-            fail_unless!(*x == n);\n+            assert!(*x == n);\n             n += 1\n         }\n     }\n@@ -1125,15 +1125,15 @@ mod test_set {\n     fn test_each_reverse() {\n         let mut m = TreeSet::new();\n \n-        fail_unless!(m.insert(3));\n-        fail_unless!(m.insert(0));\n-        fail_unless!(m.insert(4));\n-        fail_unless!(m.insert(2));\n-        fail_unless!(m.insert(1));\n+        assert!(m.insert(3));\n+        assert!(m.insert(0));\n+        assert!(m.insert(4));\n+        assert!(m.insert(2));\n+        assert!(m.insert(1));\n \n         let mut n = 4;\n         for m.each_reverse |x| {\n-            fail_unless!(*x == n);\n+            assert!(*x == n);\n             n -= 1\n         }\n     }\n@@ -1143,15 +1143,15 @@ mod test_set {\n         let mut set_a = TreeSet::new();\n         let mut set_b = TreeSet::new();\n \n-        for a.each |x| { fail_unless!(set_a.insert(*x)) }\n-        for b.each |y| { fail_unless!(set_b.insert(*y)) }\n+        for a.each |x| { assert!(set_a.insert(*x)) }\n+        for b.each |y| { assert!(set_b.insert(*y)) }\n \n         let mut i = 0;\n         for f(&set_a, &set_b) |x| {\n-            fail_unless!(*x == expected[i]);\n+            assert!(*x == expected[i]);\n             i += 1;\n         }\n-        fail_unless!(i == expected.len());\n+        assert!(i == expected.len());\n     }\n \n     #[test]"}, {"sha": "77996de6d8394a4995935926d72583fde32a2074", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -224,25 +224,25 @@ mod tests {\n \n     #[test]\n     fn test_is_digit() {\n-        fail_unless!((unicode::icu::is_digit('0')));\n-        fail_unless!((!unicode::icu::is_digit('m')));\n+        assert!((unicode::icu::is_digit('0')));\n+        assert!((!unicode::icu::is_digit('m')));\n     }\n \n     #[test]\n     fn test_is_lower() {\n-        fail_unless!((unicode::icu::is_lower('m')));\n-        fail_unless!((!unicode::icu::is_lower('M')));\n+        assert!((unicode::icu::is_lower('m')));\n+        assert!((!unicode::icu::is_lower('M')));\n     }\n \n     #[test]\n     fn test_is_space() {\n-        fail_unless!((unicode::icu::is_space(' ')));\n-        fail_unless!((!unicode::icu::is_space('m')));\n+        assert!((unicode::icu::is_space(' ')));\n+        assert!((!unicode::icu::is_space('m')));\n     }\n \n     #[test]\n     fn test_is_upper() {\n-        fail_unless!((unicode::icu::is_upper('M')));\n-        fail_unless!((!unicode::icu::is_upper('m')));\n+        assert!((unicode::icu::is_upper('M')));\n+        assert!((!unicode::icu::is_upper('m')));\n     }\n }"}, {"sha": "fe40fc6a78b41293f2483b0ebc95a4826360e5c7", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -188,7 +188,7 @@ extern fn tear_down_walk_cb(handle: *libc::c_void, arg: *libc::c_void) {\n     // pretty much, if we still have an active handle and it is *not*\n     // the async handle that facilities global loop communication, we\n     // want to barf out and fail\n-    fail_unless!(handle == arg);\n+    assert!(handle == arg);\n }\n \n extern fn tear_down_close_cb(handle: *ll::uv_async_t) {"}, {"sha": "7582a7cff513cdb05c667886941dcb1a99cb7fe4", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -1339,7 +1339,7 @@ pub mod test {\n                     stream as *libc::c_void);\n                 let err_msg = get_last_err_info(test_loop);\n                 debug!(err_msg);\n-                fail_unless!(false);\n+                assert!(false);\n             }\n             debug!(~\"finishing on_connect_cb\");\n         }\n@@ -1411,12 +1411,12 @@ pub mod test {\n                 }\n                 else {\n                    debug!(~\"tcp_connect() failure\");\n-                   fail_unless!(false);\n+                   assert!(false);\n                 }\n             }\n             else {\n                 debug!(~\"tcp_init() failure\");\n-                fail_unless!(false);\n+                assert!(false);\n             }\n             loop_delete(test_loop);\n         }\n@@ -1492,7 +1492,7 @@ pub mod test {\n                         debug!(get_last_err_info(\n                             get_loop_for_uv_handle(client_stream_ptr\n                                 as *libc::c_void)));\n-                        fail_unless!(false);\n+                        assert!(false);\n                     }\n                 }\n                 else {\n@@ -1552,19 +1552,19 @@ pub mod test {\n                     else {\n                         debug!(\"server_connection_cb: bad read:%d\",\n                                         read_result as int);\n-                        fail_unless!(false);\n+                        assert!(false);\n                     }\n                 }\n                 else {\n                     debug!(\"server_connection_cb: bad accept: %d\",\n                                 accept_result as int);\n-                    fail_unless!(false);\n+                    assert!(false);\n                 }\n             }\n             else {\n                 debug!(\"server_connection_cb: bad client init: %d\",\n                             client_init_result as int);\n-                fail_unless!(false);\n+                assert!(false);\n             }\n         }\n     }\n@@ -1683,25 +1683,25 @@ pub mod test {\n                         else {\n                             debug!(\"uv_async_init failure: %d\",\n                                     async_result as int);\n-                            fail_unless!(false);\n+                            assert!(false);\n                         }\n                     }\n                     else {\n                         debug!(\"non-zero result on uv_listen: %d\",\n                                     listen_result as int);\n-                        fail_unless!(false);\n+                        assert!(false);\n                     }\n                 }\n                 else {\n                     debug!(\"non-zero result on uv_tcp_bind: %d\",\n                                 bind_result as int);\n-                    fail_unless!(false);\n+                    assert!(false);\n                 }\n             }\n             else {\n                 debug!(\"non-zero result on uv_tcp_init: %d\",\n                             tcp_init_result as int);\n-                fail_unless!(false);\n+                assert!(false);\n             }\n             loop_delete(test_loop);\n         }\n@@ -1749,8 +1749,8 @@ pub mod test {\n             let msg_from_client = server_port.recv();\n             let msg_from_server = client_port.recv();\n \n-            fail_unless!(str::contains(msg_from_client, kill_server_msg));\n-            fail_unless!(str::contains(msg_from_server, server_resp_msg));\n+            assert!(str::contains(msg_from_client, kill_server_msg));\n+            assert!(str::contains(msg_from_server, server_resp_msg));\n         }\n     }\n \n@@ -1794,7 +1794,7 @@ pub mod test {\n                     t_name, rust_size, foreign_size as uint);\n                 debug!(output);\n             }\n-            fail_unless!(sizes_match);\n+            assert!(sizes_match);\n         }\n     }\n \n@@ -1859,7 +1859,7 @@ pub mod test {\n             // .. can't get the uv::ll::sockaddr_in6 to == 28 :/\n             // .. so the type always appears to be 32 in size.. which is\n             // good, i guess.. better too big than too little\n-            fail_unless!((4u+foreign_handle_size as uint) ==\n+            assert!((4u+foreign_handle_size as uint) ==\n                 rust_handle_size);\n         }\n     }\n@@ -1874,7 +1874,7 @@ pub mod test {\n                               foreign_handle_size as uint, rust_handle_size);\n             debug!(output);\n             // FIXME #1645 .. see note above about struct padding\n-            fail_unless!((4u+foreign_handle_size as uint) ==\n+            assert!((4u+foreign_handle_size as uint) ==\n                 rust_handle_size);\n         }\n     }"}, {"sha": "7a8aff121a86dc4da40163b01e933b2bec3cf597", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -246,7 +246,7 @@ pub impl FileMap {\n     fn next_line(&self, +pos: BytePos) {\n         // the new charpos must be > the last one (or it's the first one).\n         let lines = &mut *self.lines;\n-        fail_unless!((lines.len() == 0) || (lines[lines.len() - 1] < pos));\n+        assert!((lines.len() == 0) || (lines[lines.len() - 1] < pos));\n         self.lines.push(pos);\n     }\n \n@@ -264,7 +264,7 @@ pub impl FileMap {\n     }\n \n     pub fn record_multibyte_char(&self, pos: BytePos, bytes: uint) {\n-        fail_unless!(bytes >=2 && bytes <= 4);\n+        assert!(bytes >=2 && bytes <= 4);\n         let mbc = MultiByteChar {\n             pos: pos,\n             bytes: bytes,\n@@ -387,7 +387,7 @@ pub impl CodeMap {\n     pub fn span_to_snippet(&self, sp: span) -> ~str {\n         let begin = self.lookup_byte_offset(sp.lo);\n         let end = self.lookup_byte_offset(sp.hi);\n-        fail_unless!(begin.fm.start_pos == end.fm.start_pos);\n+        assert!(begin.fm.start_pos == end.fm.start_pos);\n         return str::slice(*begin.fm.src,\n                           begin.pos.to_uint(), end.pos.to_uint()).to_owned();\n     }\n@@ -449,7 +449,7 @@ priv impl CodeMap {\n         debug!(\"codemap: char pos %? is on the line at char pos %?\",\n                chpos, linechpos);\n         debug!(\"codemap: byte is on line: %?\", line);\n-        fail_unless!(chpos >= linechpos);\n+        assert!(chpos >= linechpos);\n         return Loc {\n             file: f,\n             line: line,\n@@ -488,7 +488,7 @@ priv impl CodeMap {\n                 total_extra_bytes += mbc.bytes;\n                 // We should never see a byte position in the middle of a\n                 // character\n-                fail_unless!(bpos == mbc.pos\n+                assert!(bpos == mbc.pos\n                     || bpos.to_uint() >= mbc.pos.to_uint() + mbc.bytes);\n             } else {\n                 break;"}, {"sha": "09498f09a29273b48f1ee83b606d86d5a073b8c3", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -449,19 +449,6 @@ pub fn core_macros() -> ~str {\n         )\n     )\n \n-    macro_rules! fail_unless(\n-        ($cond:expr) => {\n-            if !$cond {\n-                ::core::sys::fail_assert(stringify!($cond), file!(), line!())\n-            }\n-        };\n-        ($cond:expr, $msg:expr) => {\n-            if !$cond {\n-                ::core::sys::fail_assert($msg, file!(), line!())\n-            }\n-        }\n-    )\n-\n     macro_rules! assert(\n         ($cond:expr) => {\n             if !$cond {"}, {"sha": "ca8a17dad67c007d054ac5d348030a9858e53547", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -54,7 +54,7 @@ impl gen_send for message {\n           message(ref _id, span, ref tys, this, Some(ref next_state)) => {\n             debug!(\"pipec: next state exists\");\n             let next = this.proto.get_state(next_state.state);\n-            fail_unless!(next_state.tys.len() ==\n+            assert!(next_state.tys.len() ==\n                 next.generics.ty_params.len());\n             let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n             let args_ast = vec::map2(arg_names, *tys, |n, t| cx.arg(*n, *t));"}, {"sha": "f74fbbc3c03f79212942d827d617fccded822350", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -407,7 +407,7 @@ pub fn parse(\n             }\n         }\n \n-        fail_unless!(cur_eis.len() > 0u);\n+        assert!(cur_eis.len() > 0u);\n     }\n }\n "}, {"sha": "f90ff21cdf0046f8c6ff984549fd2955bc984146", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -48,7 +48,7 @@ pub fn is_doc_comment(s: &str) -> bool {\n }\n \n pub fn doc_comment_style(comment: &str) -> ast::attr_style {\n-    fail_unless!(is_doc_comment(comment));\n+    assert!(is_doc_comment(comment));\n     if comment.starts_with(~\"//!\") || comment.starts_with(~\"/*!\") {\n         ast::attr_inner\n     } else {\n@@ -134,7 +134,7 @@ fn read_to_eol(rdr: @mut StringReader) -> ~str {\n \n fn read_one_line_comment(rdr: @mut StringReader) -> ~str {\n     let val = read_to_eol(rdr);\n-    fail_unless!((val[0] == '/' as u8 && val[1] == '/' as u8) ||\n+    assert!((val[0] == '/' as u8 && val[1] == '/' as u8) ||\n                  (val[0] == '#' as u8 && val[1] == '!' as u8));\n     return val;\n }\n@@ -247,7 +247,7 @@ fn read_block_comment(rdr: @mut StringReader,\n             bump(rdr);\n         }\n         if !is_block_non_doc_comment(curr_line) { return; }\n-        fail_unless!(!curr_line.contains_char('\\n'));\n+        assert!(!curr_line.contains_char('\\n'));\n         lines.push(curr_line);\n     } else {\n         let mut level: int = 1;"}, {"sha": "17d6ba3ac9378f783cf9c7e159baa98547809415", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -187,7 +187,7 @@ pub fn bump(rdr: @mut StringReader) {\n     rdr.last_pos = rdr.pos;\n     let current_byte_offset = byte_offset(rdr).to_uint();;\n     if current_byte_offset < (*rdr.src).len() {\n-        fail_unless!(rdr.curr != -1 as char);\n+        assert!(rdr.curr != -1 as char);\n         let last_char = rdr.curr;\n         let next = str::char_range_at(*rdr.src, current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n@@ -314,7 +314,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n }\n \n pub fn is_block_non_doc_comment(s: &str) -> bool {\n-    fail_unless!(s.len() >= 1u);\n+    assert!(s.len() >= 1u);\n     str::all_between(s, 1u, s.len() - 1u, |ch| ch == '*')\n }\n "}, {"sha": "22e659fa5744e8a5cd809b3ff5c0d51cd400e8d2", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -214,7 +214,7 @@ pub fn next_node_id(sess: @mut ParseSess) -> node_id {\n     let rv = sess.next_id;\n     sess.next_id += 1;\n     // ID 0 is reserved for the crate and doesn't actually exist in the AST\n-    fail_unless!(rv != 0);\n+    assert!(rv != 0);\n     return rv;\n }\n "}, {"sha": "ac0e42fc65d8f6f8f4f92abfbbb4d3296037b46a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -2529,7 +2529,7 @@ pub impl Parser {\n \n     fn parse_block(&self) -> blk {\n         let (attrs, blk) = self.parse_inner_attrs_and_block(false);\n-        fail_unless!(vec::is_empty(attrs));\n+        assert!(vec::is_empty(attrs));\n         return blk;\n     }\n \n@@ -3922,7 +3922,7 @@ pub impl Parser {\n         foreign_items_allowed: bool,\n         macros_allowed: bool\n     ) -> item_or_view_item {\n-        fail_unless!(items_allowed != foreign_items_allowed);\n+        assert!(items_allowed != foreign_items_allowed);\n \n         maybe_whole!(iovi self, nt_item);\n         let lo = self.span.lo;\n@@ -4333,13 +4333,13 @@ pub impl Parser {\n                         view_items.push(view_item);\n                     }\n                     iovi_item(item) => {\n-                        fail_unless!(items_allowed);\n+                        assert!(items_allowed);\n                         items.push(item);\n                         attrs = self.parse_outer_attributes();\n                         break;\n                     }\n                     iovi_foreign_item(foreign_item) => {\n-                        fail_unless!(foreign_items_allowed);\n+                        assert!(foreign_items_allowed);\n                         foreign_items.push(foreign_item);\n                         attrs = self.parse_outer_attributes();\n                         break;\n@@ -4364,11 +4364,11 @@ pub impl Parser {\n                         view_items.push(view_item);\n                     }\n                     iovi_item(item) => {\n-                        fail_unless!(items_allowed);\n+                        assert!(items_allowed);\n                         items.push(item)\n                     }\n                     iovi_foreign_item(foreign_item) => {\n-                        fail_unless!(foreign_items_allowed);\n+                        assert!(foreign_items_allowed);\n                         foreign_items.push(foreign_item);\n                     }\n                 }"}, {"sha": "e742bdc056aa0e1e782a3084df20af24d57612a9", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -117,7 +117,7 @@ pub fn tok_str(++t: token) -> ~str {\n pub fn buf_str(toks: ~[token], szs: ~[int], left: uint, right: uint,\n                lim: uint) -> ~str {\n     let n = vec::len(toks);\n-    fail_unless!(n == vec::len(szs));\n+    assert!(n == vec::len(szs));\n     let mut i = left;\n     let mut L = lim;\n     let mut s = ~\"[\";\n@@ -369,24 +369,24 @@ pub impl Printer {\n         } else {\n             self.top += 1u;\n             self.top %= self.buf_len;\n-            fail_unless!((self.top != self.bottom));\n+            assert!((self.top != self.bottom));\n         }\n         self.scan_stack[self.top] = x;\n     }\n     fn scan_pop(&mut self) -> uint {\n-        fail_unless!((!self.scan_stack_empty));\n+        assert!((!self.scan_stack_empty));\n         let x = self.scan_stack[self.top];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else { self.top += self.buf_len - 1u; self.top %= self.buf_len; }\n         return x;\n     }\n     fn scan_top(&mut self) -> uint {\n-        fail_unless!((!self.scan_stack_empty));\n+        assert!((!self.scan_stack_empty));\n         return self.scan_stack[self.top];\n     }\n     fn scan_pop_bottom(&mut self) -> uint {\n-        fail_unless!((!self.scan_stack_empty));\n+        assert!((!self.scan_stack_empty));\n         let x = self.scan_stack[self.bottom];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n@@ -396,7 +396,7 @@ pub impl Printer {\n     fn advance_right(&mut self) {\n         self.right += 1u;\n         self.right %= self.buf_len;\n-        fail_unless!((self.right != self.left));\n+        assert!((self.right != self.left));\n     }\n     fn advance_left(&mut self, ++x: token, L: int) {\n         debug!(\"advnce_left ~[%u,%u], sizeof(%u)=%d\", self.left, self.right,\n@@ -406,7 +406,7 @@ pub impl Printer {\n             match x {\n               BREAK(b) => self.left_total += b.blank_space,\n               STRING(_, len) => {\n-                fail_unless!((len == L)); self.left_total += len;\n+                assert!((len == L)); self.left_total += len;\n               }\n               _ => ()\n             }\n@@ -498,7 +498,7 @@ pub impl Printer {\n           END => {\n             debug!(\"print END -> pop END\");\n             let print_stack = &*self.print_stack;\n-            fail_unless!((print_stack.len() != 0u));\n+            assert!((print_stack.len() != 0u));\n             self.print_stack.pop();\n           }\n           BREAK(b) => {\n@@ -532,8 +532,8 @@ pub impl Printer {\n           }\n           STRING(s, len) => {\n             debug!(\"print STRING(%s)\", *s);\n-            fail_unless!((L == len));\n-            // fail_unless!(L <= space);\n+            assert!((L == len));\n+            // assert!(L <= space);\n             self.space -= len;\n             self.print_str(*s);\n           }"}, {"sha": "7ca5fba4c819383fa0be927685b4b5c058553ac6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -1294,8 +1294,8 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         print_fn_block_args(s, decl);\n         space(s.s);\n         // }\n-        fail_unless!(body.node.stmts.is_empty());\n-        fail_unless!(body.node.expr.is_some());\n+        assert!(body.node.stmts.is_empty());\n+        assert!(body.node.expr.is_some());\n         // we extract the block, so as not to create another set of boxes\n         match body.node.expr.get().node {\n             ast::expr_block(ref blk) => {\n@@ -1445,7 +1445,7 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n \n         // if any are mut, all are mut\n         if locs.any(|l| l.node.is_mutbl) {\n-            fail_unless!(locs.all(|l| l.node.is_mutbl));\n+            assert!(locs.all(|l| l.node.is_mutbl));\n             word_nbsp(s, ~\"mut\");\n         }\n \n@@ -2080,7 +2080,7 @@ pub fn maybe_print_comment(s: @ps, pos: BytePos) {\n pub fn print_comment(s: @ps, cmnt: comments::cmnt) {\n     match cmnt.style {\n       comments::mixed => {\n-        fail_unless!((vec::len(cmnt.lines) == 1u));\n+        assert!((vec::len(cmnt.lines) == 1u));\n         zerobreak(s.s);\n         word(s.s, cmnt.lines[0]);\n         zerobreak(s.s);"}, {"sha": "d6ebf4d346bcc5e1bb7d83e7d596d053863d2b43", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -34,13 +34,13 @@ fn ascending<M: Map<uint, uint>>(map: &mut M, n_keys: uint) {\n \n     do timed(\"search\") {\n         for uint::range(0, n_keys) |i| {\n-            fail_unless!(map.find(&i).unwrap() == &(i + 1));\n+            assert!(map.find(&i).unwrap() == &(i + 1));\n         }\n     }\n \n     do timed(\"remove\") {\n         for uint::range(0, n_keys) |i| {\n-            fail_unless!(map.remove(&i));\n+            assert!(map.remove(&i));\n         }\n     }\n }\n@@ -56,13 +56,13 @@ fn descending<M: Map<uint, uint>>(map: &mut M, n_keys: uint) {\n \n     do timed(\"search\") {\n         for uint::range_rev(n_keys, 0) |i| {\n-            fail_unless!(map.find(&i).unwrap() == &(i + 1));\n+            assert!(map.find(&i).unwrap() == &(i + 1));\n         }\n     }\n \n     do timed(\"remove\") {\n         for uint::range_rev(n_keys, 0) |i| {\n-            fail_unless!(map.remove(&i));\n+            assert!(map.remove(&i));\n         }\n     }\n }\n@@ -77,13 +77,13 @@ fn vector<M: Map<uint, uint>>(map: &mut M, n_keys: uint, dist: &[uint]) {\n \n     do timed(\"search\") {\n         for uint::range(0, n_keys) |i| {\n-            fail_unless!(map.find(&dist[i]).unwrap() == &(i + 1));\n+            assert!(map.find(&dist[i]).unwrap() == &(i + 1));\n         }\n     }\n \n     do timed(\"remove\") {\n         for uint::range(0, n_keys) |i| {\n-            fail_unless!(map.remove(&dist[i]));\n+            assert!(map.remove(&dist[i]));\n         }\n     }\n }"}, {"sha": "a3210108dcc1709ac2110149e1e74ae02d0e7c83", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -42,7 +42,7 @@ pub impl Results {\n                 }\n \n                 for uint::range(0, num_keys) |i| {\n-                    fail_unless!(set.contains(&i));\n+                    assert!(set.contains(&i));\n                 }\n             }\n         }\n@@ -64,7 +64,7 @@ pub impl Results {\n \n             do timed(&mut self.delete_ints) {\n                 for uint::range(0, num_keys) |i| {\n-                    fail_unless!(set.remove(&i));\n+                    assert!(set.remove(&i));\n                 }\n             }\n         }\n@@ -82,7 +82,7 @@ pub impl Results {\n \n                 for uint::range(0, num_keys) |i| {\n                     let s = uint::to_str(i);\n-                    fail_unless!(set.contains(&s));\n+                    assert!(set.contains(&s));\n                 }\n             }\n         }\n@@ -104,7 +104,7 @@ pub impl Results {\n             }\n             do timed(&mut self.delete_strings) {\n                 for uint::range(0, num_keys) |i| {\n-                    fail_unless!(set.remove(&uint::to_str(i)));\n+                    assert!(set.remove(&uint::to_str(i)));\n                 }\n             }\n         }"}, {"sha": "a156f915faca758c33cbc00294f02a8a833c6a7e", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -300,7 +300,7 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n             };\n             result\n         };\n-        fail_unless!((colors.len() == old_len));\n+        assert!((colors.len() == old_len));\n     }\n \n     // Convert the results.\n@@ -468,7 +468,7 @@ fn main() {\n \n             if do_validate {\n                 let start = time::precise_time_s();\n-                fail_unless!((validate(copy edges, *root, bfs_tree)));\n+                assert!((validate(copy edges, *root, bfs_tree)));\n                 let stop = time::precise_time_s();\n \n                 io::stdout().write_line(\n@@ -488,7 +488,7 @@ fn main() {\n \n             if do_validate {\n                 let start = time::precise_time_s();\n-                fail_unless!((validate(copy edges, *root, bfs_tree)));\n+                assert!((validate(copy edges, *root, bfs_tree)));\n                 let stop = time::precise_time_s();\n \n                 io::stdout().write_line(\n@@ -508,7 +508,7 @@ fn main() {\n \n         if do_validate {\n             let start = time::precise_time_s();\n-            fail_unless!((validate(copy edges, *root, bfs_tree)));\n+            assert!((validate(copy edges, *root, bfs_tree)));\n             let stop = time::precise_time_s();\n \n             io::stdout().write_line(fmt!(\"Validation completed in %? seconds.\","}, {"sha": "50647e8c100dc14ca1cbe2c54e9da816af2d3a59", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -95,7 +95,7 @@ fn run(args: &[~str]) {\n     io::stdout().write_str(fmt!(\"Test took %? seconds\\n\", elapsed));\n     let thruput = ((size / workers * workers) as float) / (elapsed as float);\n     io::stdout().write_str(fmt!(\"Throughput=%f per sec\\n\", thruput));\n-    fail_unless!(result == num_bytes * size);\n+    assert!(result == num_bytes * size);\n }\n \n fn main() {"}, {"sha": "77e64818f7e6c023bacb077a06c41353ae015975", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -92,7 +92,7 @@ fn run(args: &[~str]) {\n     io::stdout().write_str(fmt!(\"Test took %? seconds\\n\", elapsed));\n     let thruput = ((size / workers * workers) as float) / (elapsed as float);\n     io::stdout().write_str(fmt!(\"Throughput=%f per sec\\n\", thruput));\n-    fail_unless!(result == num_bytes * size);\n+    assert!(result == num_bytes * size);\n }\n \n fn main() {"}, {"sha": "a90afd418d88153a7f7dbccad29be52e9fd0aaf8", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -73,7 +73,7 @@ fn stress_task(&&id: int) {\n     let mut i = 0;\n     loop {\n         let n = 15;\n-        fail_unless!((fib(n) == fib(n)));\n+        assert!((fib(n) == fib(n)));\n         i += 1;\n         error!(\"%d: Completed %d iterations\", id, i);\n     }"}, {"sha": "4b0d34d23151178bbb18e60003fb22f1339403b6", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -22,7 +22,7 @@ fn append_sequential(min: uint, max: uint, map: &mut SmallIntMap<uint>) {\n \n fn check_sequential(min: uint, max: uint, map: &SmallIntMap<uint>) {\n     for uint::range(min, max) |i| {\n-        fail_unless!(*map.get(&i) == i + 22u);\n+        assert!(*map.get(&i) == i + 22u);\n     }\n }\n "}, {"sha": "9221da8b55738ac69c0cacdbfd158d30a5274d05", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -63,7 +63,7 @@ pub impl Sudoku {\n     }\n \n     pub fn read(reader: @io::Reader) -> Sudoku {\n-        fail_unless!(reader.read_line() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n+        assert!(reader.read_line() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n \n         let mut g = vec::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n         while !reader.eof() {\n@@ -212,30 +212,30 @@ static default_solution: [[u8, ..9], ..9] = [\n \n #[test]\n fn colors_new_works() {\n-    fail_unless!(*Colors::new(1) == 1022u16);\n-    fail_unless!(*Colors::new(2) == 1020u16);\n-    fail_unless!(*Colors::new(3) == 1016u16);\n-    fail_unless!(*Colors::new(4) == 1008u16);\n-    fail_unless!(*Colors::new(5) == 992u16);\n-    fail_unless!(*Colors::new(6) == 960u16);\n-    fail_unless!(*Colors::new(7) == 896u16);\n-    fail_unless!(*Colors::new(8) == 768u16);\n-    fail_unless!(*Colors::new(9) == 512u16);\n+    assert!(*Colors::new(1) == 1022u16);\n+    assert!(*Colors::new(2) == 1020u16);\n+    assert!(*Colors::new(3) == 1016u16);\n+    assert!(*Colors::new(4) == 1008u16);\n+    assert!(*Colors::new(5) == 992u16);\n+    assert!(*Colors::new(6) == 960u16);\n+    assert!(*Colors::new(7) == 896u16);\n+    assert!(*Colors::new(8) == 768u16);\n+    assert!(*Colors::new(9) == 512u16);\n }\n \n #[test]\n fn colors_next_works() {\n-    fail_unless!(Colors(0).next() == 0u8);\n-    fail_unless!(Colors(2).next() == 1u8);\n-    fail_unless!(Colors(4).next() == 2u8);\n-    fail_unless!(Colors(8).next() == 3u8);\n-    fail_unless!(Colors(16).next() == 4u8);\n-    fail_unless!(Colors(32).next() == 5u8);\n-    fail_unless!(Colors(64).next() == 6u8);\n-    fail_unless!(Colors(128).next() == 7u8);\n-    fail_unless!(Colors(256).next() == 8u8);\n-    fail_unless!(Colors(512).next() == 9u8);\n-    fail_unless!(Colors(1024).next() == 0u8);\n+    assert!(Colors(0).next() == 0u8);\n+    assert!(Colors(2).next() == 1u8);\n+    assert!(Colors(4).next() == 2u8);\n+    assert!(Colors(8).next() == 3u8);\n+    assert!(Colors(16).next() == 4u8);\n+    assert!(Colors(32).next() == 5u8);\n+    assert!(Colors(64).next() == 6u8);\n+    assert!(Colors(128).next() == 7u8);\n+    assert!(Colors(256).next() == 8u8);\n+    assert!(Colors(512).next() == 9u8);\n+    assert!(Colors(1024).next() == 0u8);\n }\n \n #[test]\n@@ -247,7 +247,7 @@ fn colors_remove_works() {\n     colors.remove(1);\n \n     // THEN\n-    fail_unless!(colors.next() == 2u8);\n+    assert!(colors.next() == 2u8);\n }\n \n #[test]\n@@ -260,7 +260,7 @@ fn check_default_sudoku_solution() {\n     sudoku.solve();\n \n     // THEN\n-    fail_unless!(sudoku.equal(&solution));\n+    assert!(sudoku.equal(&solution));\n }\n \n fn main() {"}, {"sha": "d7514320e36d50d4182e531deded28346a9dd753", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -51,7 +51,7 @@ fn spawn_supervised_blocking(myname: &str, +f: ~fn()) {\n     task::task().future_result(|+r| res = Some(r)).supervised().spawn(f);\n     error!(\"%s group waiting\", myname);\n     let x = res.unwrap().recv();\n-    fail_unless!(x == task::Success);\n+    assert!(x == task::Success);\n }\n \n fn main() {\n@@ -81,5 +81,5 @@ fn main() {\n         error!(\"Grandparent group wakes up and fails\");\n         fail!();\n     };\n-    fail_unless!(x.is_err());\n+    assert!(x.is_err());\n }"}, {"sha": "e2dd13a4405d1fea80a402bd4e73a3678084b159", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -18,5 +18,5 @@ fn main() {\n         //~^ ERROR cannot infer an appropriate lifetime\n     }\n     // Adding this line causes a method unification failure instead\n-    // do (&option::unwrap(y)).read |state| { fail_unless!(*state == 1); }\n+    // do (&option::unwrap(y)).read |state| { assert!(*state == 1); }\n }"}, {"sha": "78a50a4f2124219f437fb681519f21ef70e42b04", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -18,5 +18,5 @@ fn main() {\n         y = Some(write_mode);\n     }\n     // Adding this line causes a method unification failure instead\n-    // do (&option::unwrap(y)).write |state| { fail_unless!(*state == 1); }\n+    // do (&option::unwrap(y)).write |state| { assert!(*state == 1); }\n }"}, {"sha": "ecd31d0dde456ed83b1a2e66c4714891a35ed78c", "filename": "src/test/compile-fail/autoderef-full-lval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -22,10 +22,10 @@ fn main() {\n     let b: clam = clam{x: @10, y: @20};\n     let z: int = a.x + b.y; //~ ERROR binary operation + cannot be applied to type `@int`\n     debug!(z);\n-    fail_unless!((z == 21));\n+    assert!((z == 21));\n     let forty: fish = fish{a: @40};\n     let two: fish = fish{a: @2};\n     let answer: int = forty.a + two.a;  //~ ERROR binary operation + cannot be applied to type `@int`\n     debug!(answer);\n-    fail_unless!((answer == 42));\n+    assert!((answer == 42));\n }"}, {"sha": "ffc160ac1111828b8601cc9fb69555aecb0d210a", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     c.send(false);\n     match x {\n         Some(z) if z.recv() => { fail!() }, //~ ERROR cannot bind by-move into a pattern guard\n-        Some(z) => { fail_unless!(!z.recv()); },\n+        Some(z) => { assert!(!z.recv()); },\n         None => fail!()\n     }\n }"}, {"sha": "42c5ffe3e916baa13f6629fa2afbcc7fdfffcff2", "filename": "src/test/compile-fail/block-arg-as-stmt-with-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -19,5 +19,5 @@ fn compute1() -> float {\n fn main() {\n     let x = compute1();\n     debug!(x);\n-    fail_unless!((x == -4f));\n+    assert!((x == -4f));\n }"}, {"sha": "14cb37d775c43e410b6c9a09ed7dd720bc222e07", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -16,8 +16,8 @@ fn box_imm() {\n     let mut v = ~3;\n     do borrow(v) |w| { //~ NOTE loan of mutable local variable granted here\n         v = ~4; //~ ERROR assigning to captured outer mutable variable in a stack closure prohibited due to outstanding loan\n-        fail_unless!(*v == 3);\n-        fail_unless!(*w == 4);\n+        assert!(*v == 3);\n+        assert!(*w == 4);\n     }\n }\n "}, {"sha": "aad86241e9a437fb97332c7ae8b9db319974d888", "filename": "src/test/compile-fail/borrowck-ref-mut-of-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -16,5 +16,5 @@ fn destructure(x: Option<int>) -> int {\n }\n \n fn main() {\n-    fail_unless!(destructure(Some(22)) == 22);\n+    assert!(destructure(Some(22)) == 22);\n }"}, {"sha": "558a54787183dbe2ead866eb45996e13cde0a47d", "filename": "src/test/compile-fail/cast-from-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -9,4 +9,4 @@\n // except according to those terms.\n \n // error-pattern: cast from nil: `()` as `u32`\n-fn main() { let u = (fail_unless!(true) as u32); }\n+fn main() { let u = (assert!(true) as u32); }"}, {"sha": "1ad190827dae9b0b228e7417ce5a372e1032943d", "filename": "src/test/compile-fail/crateresolve5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -18,5 +18,5 @@ extern mod cr5_2 (name = \"crateresolve5\", vers = \"0.2\");\n \n fn main() {\n     // Nominal types from two multiple versions of a crate are different types\n-    fail_unless!(cr5_1::nominal() == cr5_2::nominal()); //~ ERROR mismatched types: expected\n+    assert!(cr5_1::nominal() == cr5_2::nominal()); //~ ERROR mismatched types: expected\n }"}, {"sha": "4466c07518fece94f3f2bc948591a722837121b8", "filename": "src/test/compile-fail/do2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fdo2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fdo2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo2.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -11,6 +11,6 @@\n fn f(f: @fn(int) -> bool) -> bool { f(10i) }\n \n fn main() {\n-    fail_unless!(do f() |i| { i == 10i } == 10i);\n+    assert!(do f() |i| { i == 10i } == 10i);\n     //~^ ERROR: expected `bool` but found `int`\n }"}, {"sha": "fc5132d65104f3083d733f2dc937b80cb03da06c", "filename": "src/test/compile-fail/issue-1896-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -20,5 +20,5 @@ fn main () {\n \n     let myInt: uint = (aFn.theFn)();\n \n-    fail_unless!(myInt == 10);\n+    assert!(myInt == 10);\n }"}, {"sha": "fd6e5a762b248f4095a39debda3c4fe4426e594d", "filename": "src/test/compile-fail/issue-2467.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,5 +12,5 @@ enum test { thing = 3u } //~ ERROR mismatched types\n //~^ ERROR expected signed integer constant\n fn main() {\n     error!(thing as int);\n-    fail_unless!((thing as int == 3));\n+    assert!((thing as int == 3));\n }"}, {"sha": "9c2d7baa23c263bfd64af193c460bf4919bbd4f7", "filename": "src/test/compile-fail/issue-2548.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -38,8 +38,8 @@ fn main() {\n \n         let mut v = ~[];\n         v = ~[(res)] + v; //~ instantiating a type parameter with an incompatible type `foo`, which does not fulfill `Copy`\n-        fail_unless!((v.len() == 2));\n+        assert!((v.len() == 2));\n     }\n \n-    fail_unless!(*x == 1);\n+    assert!(*x == 1);\n }"}, {"sha": "927e81db5c1c499ee4f777eaae4a3c826db233c6", "filename": "src/test/compile-fail/issue-2969.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -15,5 +15,5 @@ fn main()\n    let mut x = [1, 2, 4];\n    let v : &int = &x[2];\n    x[2] = 6;\n-   fail_unless!(*v == 6);\n+   assert!(*v == 6);\n }"}, {"sha": "35f8557c32b608ff7bd1626aa446bff00b74bb23", "filename": "src/test/compile-fail/issue-3888.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -25,17 +25,17 @@ fn vec_peek<'r, T>(v: &'r [T]) -> Option< (&'r T, &'r [T]) > {\n \n fn test_peek_empty_stack() {\n     let v : &[int] = &[];\n-    fail_unless!((None == vec_peek(v)));\n+    assert!((None == vec_peek(v)));\n }\n \n fn test_peek_empty_unique() {\n     let v : ~[int] = ~[];\n-    fail_unless!((None == vec_peek(v)));\n+    assert!((None == vec_peek(v)));\n }\n \n fn test_peek_empty_managed() {\n     let v : @[int] = @[];\n-    fail_unless!((None == vec_peek(v)));\n+    assert!((None == vec_peek(v)));\n }\n \n "}, {"sha": "90c46e5d602c9a08dc5c204f85b292639efef51a", "filename": "src/test/compile-fail/issue-511.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-511.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,7 +12,7 @@ extern mod std;\n use core::cmp::Eq;\n \n fn f<T:Eq>(o: &mut Option<T>) {\n-    fail_unless!(*o == option::None);\n+    assert!(*o == option::None);\n }\n \n fn main() {"}, {"sha": "df08652ea0ad8f6cf6ce1c2e786232df0292e2b2", "filename": "src/test/compile-fail/issue-818.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fissue-818.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fissue-818.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-818.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -20,5 +20,5 @@ mod ctr {\n fn main() {\n     let c = ctr::new(42);\n     let c2 = ctr::inc(c);\n-    fail_unless!(*c2 == 5); //~ ERROR can only dereference enums with a single, public variant\n+    assert!(*c2 == 5); //~ ERROR can only dereference enums with a single, public variant\n }"}, {"sha": "f5153265308e14bf5c6fd4010dbd8fe17b5f7ce4", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -27,5 +27,5 @@ fn main() {\n         let x: &'blk int = &3;\n         repeater(@x)\n     };\n-    fail_unless!(3 == *(y.get())); //~ ERROR reference is not valid\n+    assert!(3 == *(y.get())); //~ ERROR reference is not valid\n }"}, {"sha": "bb0ba87c098cffe59f24e8b845de0712b1489bc2", "filename": "src/test/compile-fail/kindck-owned-trait-scoped.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -30,7 +30,7 @@ fn to_foo<T:Copy>(t: T) {\n     let v = &3;\n     struct F<T> { f: T }\n     let x = @F {f:t} as @foo;\n-    fail_unless!(x.foo(v) == 3);\n+    assert!(x.foo(v) == 3);\n }\n \n fn to_foo_2<T:Copy>(t: T) -> @foo {"}, {"sha": "f8ea5dda183366df38ecfa9544f08d21d4406a97", "filename": "src/test/compile-fail/mod_file_correct_spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -13,5 +13,5 @@\n mod mod_file_aux;\n \n fn main() {\n-    fail_unless!(mod_file_aux::bar() == 10); //~ ERROR unresolved name\n+    assert!(mod_file_aux::bar() == 10); //~ ERROR unresolved name\n }"}, {"sha": "17ca8dca27352684dcd2db29d142226fbb7d33b8", "filename": "src/test/compile-fail/mod_file_not_exist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -11,5 +11,5 @@\n mod not_a_real_file; //~ ERROR not_a_real_file.rs\n \n fn main() {\n-    fail_unless!(mod_file_aux::bar() == 10);\n+    assert!(mod_file_aux::bar() == 10);\n }"}, {"sha": "827c77bda471d8ddcf43cc0f0ae32b4a613084f7", "filename": "src/test/compile-fail/mod_file_with_path_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,5 +12,5 @@\n mod m; //~ ERROR not_a_real_file.rs\n \n fn main() {\n-    fail_unless!(m::foo() == 10);\n+    assert!(m::foo() == 10);\n }"}, {"sha": "4994bb323d9c5460d9beae29d0a7eb8e6543d5ad", "filename": "src/test/compile-fail/mode-inference-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -18,6 +18,6 @@ fn apply_int(f: &fn(int) -> int, a: int) -> int { f(a) }\n \n fn main() {\n     let f = {|i| i};\n-    fail_unless!(apply_int(f, 2) == 2);\n-    fail_unless!(apply(f, 2) == 2); //~ ERROR expected argument mode &&\n+    assert!(apply_int(f, 2) == 2);\n+    assert!(apply(f, 2) == 2); //~ ERROR expected argument mode &&\n }"}, {"sha": "da75dfd010685fe8ab0387912e6c003e781ab0ed", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -19,10 +19,10 @@ fn main() {\n     \n     do task::spawn() {\n         let v = *arc::get(&arc_v);\n-        fail_unless!(v[3] == 4);\n+        assert!(v[3] == 4);\n     };\n \n-    fail_unless!((*arc::get(&arc_v))[2] == 3);\n+    assert!((*arc::get(&arc_v))[2] == 3);\n \n     info!(arc_v);\n }"}, {"sha": "75cd706985c64785ebef85ae60c71bc8b7331d5e", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -17,10 +17,10 @@ fn main() {\n \n     do task::spawn() { //~ NOTE `arc_v` moved into closure environment here\n         let v = *arc::get(&arc_v);\n-        fail_unless!(v[3] == 4);\n+        assert!(v[3] == 4);\n     };\n \n-    fail_unless!((*arc::get(&arc_v))[2] == 3); //~ ERROR use of moved value: `arc_v`\n+    assert!((*arc::get(&arc_v))[2] == 3); //~ ERROR use of moved value: `arc_v`\n \n     info!(arc_v);\n }"}, {"sha": "e8b01765a447d3cd332ffce76eb8b27a45c53066", "filename": "src/test/compile-fail/noncopyable-match-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     let x = Some(unstable::exclusive(false));\n     match x {\n         Some(copy z) => { //~ ERROR copying a value of non-copyable type\n-            do z.with |b| { fail_unless!(!*b); }\n+            do z.with |b| { assert!(!*b); }\n         }\n         None => fail!()\n     }"}, {"sha": "a44c113269b98f4a77f6473fa13041a5fa5319a8", "filename": "src/test/compile-fail/omitted-arg-wrong-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fomitted-arg-wrong-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fomitted-arg-wrong-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fomitted-arg-wrong-types.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,9 +12,9 @@\n fn let_in<T>(x: T, f: &fn(T)) {}\n \n fn main() {\n-    let_in(3u, |i| { fail_unless!(i == 3); });\n+    let_in(3u, |i| { assert!(i == 3); });\n     //~^ ERROR expected `uint` but found `int`\n \n-    let_in(3, |i| { fail_unless!(i == 3u); });\n+    let_in(3, |i| { assert!(i == 3u); });\n     //~^ ERROR expected `int` but found `uint`\n }"}, {"sha": "5a8f80845e16ff63493ee950c15f37b64b93873d", "filename": "src/test/compile-fail/private-struct-field-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field-cross-crate.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -14,5 +14,5 @@ use cci_class::kitties::*;\n \n fn main() {\n   let nyan : cat = cat(52u, 99);\n-  fail_unless!((nyan.meows == 52u));   //~ ERROR field `meows` is private\n+  assert!((nyan.meows == 52u));   //~ ERROR field `meows` is private\n }"}, {"sha": "2f6a51e16372944443eca76be27877415ad9d8f5", "filename": "src/test/compile-fail/private-struct-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -20,5 +20,5 @@ mod cat {\n \n fn main() {\n     let nyan = cat::new_cat();\n-    fail_unless!(nyan.meows == 52);    //~ ERROR field `meows` is private\n+    assert!(nyan.meows == 52);    //~ ERROR field `meows` is private\n }"}, {"sha": "9a4974849a50d8b61f38f1eeb3b42b0eed4a7afe", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -37,5 +37,5 @@ mod argparse {\n fn main () {\n     let f : argparse::Flag = argparse::flag(~\"flag\", ~\"My flag\");\n     let updated_flag = f.set_desc(~\"My new flag\");\n-    fail_unless!(updated_flag.desc == \"My new flag\");\n+    assert!(updated_flag.desc == \"My new flag\");\n }"}, {"sha": "a8b7ae1b9c8e4c436a90bb0058fc1656ff76bddc", "filename": "src/test/compile-fail/regions-infer-borrow-scope-too-big.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -19,7 +19,7 @@ fn x_coord<'r>(p: &'r point) -> &'r int {\n \n fn foo(p: @point) -> &int {\n     let xc = x_coord(p); //~ ERROR illegal borrow\n-    fail_unless!(*xc == 3);\n+    assert!(*xc == 3);\n     return xc;\n }\n "}, {"sha": "bf8f227b5730edd9c07e4815227f4d4c290e1bbf", "filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -19,10 +19,10 @@ fn foo(cond: &fn() -> bool, box: &fn() -> @int) {\n \t// of this borrow is the fn body as a whole.\n         y = borrow(x); //~ ERROR illegal borrow: cannot root managed value long enough\n \n-        fail_unless!(*x == *y);\n+        assert!(*x == *y);\n         if cond() { break; }\n     }\n-    fail_unless!(*y != 0);\n+    assert!(*y != 0);\n }\n \n fn main() {}"}, {"sha": "ff75ba4473de7d854d160442f1ac176b2a757337", "filename": "src/test/compile-fail/regions-trait-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -34,5 +34,5 @@ fn get_v(gc: @get_ctxt) -> uint {\n fn main() {\n     let ctxt = ctxt { v: 22u };\n     let hc = has_ctxt { c: &ctxt };\n-    fail_unless!(get_v(@hc as @get_ctxt) == 22u);\n+    assert!(get_v(@hc as @get_ctxt) == 22u);\n }"}, {"sha": "7d75ac743493151e8fc9d7723bd7baef1b513f9d", "filename": "src/test/compile-fail/regions-var-type-out-of-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -15,7 +15,7 @@ fn foo(cond: bool) {\n \n     if cond {\n         x = &3; //~ ERROR illegal borrow: borrowed value does not live long enough\n-        fail_unless!((*x == 3));\n+        assert!((*x == 3));\n     }\n }\n "}, {"sha": "f2ef1d1952505c09ba85aae43a1eda241b026277", "filename": "src/test/compile-fail/tag-type-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Ftag-type-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Ftag-type-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-type-args.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,6 +12,6 @@\n \n enum quux<T> { bar }\n \n-fn foo(c: quux) { fail_unless!((false)); }\n+fn foo(c: quux) { assert!((false)); }\n \n fn main() { fail!(); }"}, {"sha": "dd0ae87f3118dfd279a8c1e6af8a4b78d4a406ef", "filename": "src/test/compile-fail/vtable-res-trait-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -29,5 +29,5 @@ fn call_it<B:TraitB>(b: B)  -> int {\n \n fn main() {\n     let x = 3i;\n-    fail_unless!(call_it(x) == 22);\n+    assert!(call_it(x) == 22);\n }"}, {"sha": "6f9aa28f11a939739c0678e59a70ac7ce74f662e", "filename": "src/test/pretty/do1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fpretty%2Fdo1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fpretty%2Fdo1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdo1.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,4 +12,4 @@\n \n fn f(f: @fn(int)) { f(10) }\n \n-fn main() { do f |i| { fail_unless!(i == 10) } }\n+fn main() { do f |i| { assert!(i == 10) } }"}, {"sha": "1ea0e1041327187643d09832a5e166e6d1c79c9c", "filename": "src/test/pretty/record-trailing-comma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fpretty%2Frecord-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Fpretty%2Frecord-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Frecord-trailing-comma.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -18,5 +18,5 @@ struct Thing {\n fn main() {\n     let sth = Thing{x: 0, y: 1,};\n     let sth2 = Thing{y: 9 , ..sth};\n-    fail_unless!(sth.x + sth2.y == 9);\n+    assert!(sth.x + sth2.y == 9);\n }"}, {"sha": "07813b91e571d7407e0cebc92b6be388ae380b25", "filename": "src/test/run-fail/assert-as-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Fassert-as-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Fassert-as-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-as-macro.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -1,6 +1,6 @@\n // error-pattern:assertion failed: 1 == 2\n \n fn main() {\n-    fail_unless!(1 == 2);\n+    assert!(1 == 2);\n }\n "}, {"sha": "42cf79af66ee80626288eecc899ce8969ec6194e", "filename": "src/test/run-fail/fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Ffail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Ffail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,4 +12,4 @@\n \n \n // error-pattern:1 == 2\n-fn main() { fail_unless!((1 == 2)); }\n+fn main() { assert!((1 == 2)); }"}, {"sha": "95050a4dcf19eb51e1c3b5944527c43e3b99ca5d", "filename": "src/test/run-fail/issue-2761.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Fissue-2761.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Fissue-2761.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2761.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -11,5 +11,5 @@\n // error-pattern:custom message\n \n fn main() {\n-    fail_unless!(false, \"custom message\");\n+    assert!(false, \"custom message\");\n }"}, {"sha": "054d6f697ae349086357971641f8acf9a8e91e6e", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -13,7 +13,7 @@\n // error-pattern:1 == 2\n extern mod std;\n \n-fn child() { fail_unless!((1 == 2)); }\n+fn child() { assert!((1 == 2)); }\n \n fn main() {\n     let (p, _c) = comm::stream::<int>();"}, {"sha": "3dc87e190a5d858ce4abad87fd4cb032d2efd139", "filename": "src/test/run-fail/linked-failure4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure4.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -11,7 +11,7 @@\n \n // error-pattern:1 == 2\n \n-fn child() { fail_unless!((1 == 2)); }\n+fn child() { assert!((1 == 2)); }\n \n fn parent() {\n     let (p, _c) = comm::stream::<int>();"}, {"sha": "38b73ea56980ee6cb155d61ce9a0c0059af92e62", "filename": "src/test/run-fail/str-overrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -15,5 +15,5 @@ fn main() {\n     let s: ~str = ~\"hello\";\n \n     // Bounds-check failure.\n-    fail_unless!((s[5] == 0x0 as u8));\n+    assert!((s[5] == 0x0 as u8));\n }"}, {"sha": "11c9de6e14f450659d586fdc27f87c6decfcdac3", "filename": "src/test/run-fail/task-spawn-barefn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -17,5 +17,5 @@ fn main() {\n }\n \n fn startfn() {\n-    fail_unless!(str::is_empty(~\"Ensure that the child task runs by failing\"));\n+    assert!(str::is_empty(~\"Ensure that the child task runs by failing\"));\n }"}, {"sha": "41cf92d92b855c5440b338b879432b4b9199c4e9", "filename": "src/test/run-fail/unwind-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Funwind-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Funwind-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-alt.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -16,7 +16,7 @@ fn test_box() {\n fn test_str() {\n   let res = match false { true => { ~\"happy\" },\n      _ => fail!(~\"non-exhaustive match failure\") };\n-  fail_unless!(res == ~\"happy\");\n+  assert!(res == ~\"happy\");\n }\n fn main() {\n     test_box();"}, {"sha": "0e685a7a4693d13bac763f4dddcae5f880d72231", "filename": "src/test/run-fail/unwind-assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Funwind-assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Funwind-assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-assert.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     let a = @0;\n-    fail_unless!(false);\n+    assert!(false);\n }"}, {"sha": "ab9dcf32781be5fbb619f4e79cdfc2804f692f14", "filename": "src/test/run-fail/vec-overrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-overrun.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -14,8 +14,8 @@\n fn main() {\n     let v: ~[int] = ~[10];\n     let x: int = 0;\n-    fail_unless!((v[x] == 10));\n+    assert!((v[x] == 10));\n     // Bounds-check failure.\n \n-    fail_unless!((v[x + 2] == 20));\n+    assert!((v[x + 2] == 20));\n }"}, {"sha": "6f403fd772193609ca153ba733bea73cf000703c", "filename": "src/test/run-fail/vec-underrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-underrun.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -14,8 +14,8 @@\n fn main() {\n     let v: ~[int] = ~[10, 20];\n     let x: int = 0;\n-    fail_unless!((v[x] == 10));\n+    assert!((v[x] == 10));\n     // Bounds-check failure.\n \n-    fail_unless!((v[x - 1] == 20));\n+    assert!((v[x - 1] == 20));\n }"}, {"sha": "87bb8669046386fdd9355693eb61ac21e1e35630", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -15,15 +15,15 @@ extern mod std;\n use core::vec::{same_length, zip};\n \n fn enum_chars(start: u8, end: u8) -> ~[char] {\n-    fail_unless!(start < end);\n+    assert!(start < end);\n     let mut i = start;\n     let mut r = ~[];\n     while i <= end { r.push(i as char); i += 1 as u8; }\n     return r;\n }\n \n fn enum_uints(start: uint, end: uint) -> ~[uint] {\n-    fail_unless!(start < end);\n+    assert!(start < end);\n     let mut i = start;\n     let mut r = ~[];\n     while i <= end { r.push(i); i += 1; }\n@@ -35,7 +35,7 @@ fn main() {\n     let chars = enum_chars(a, j);\n     let ints = enum_uints(k, l);\n \n-    fail_unless!(same_length(chars, ints));\n+    assert!(same_length(chars, ints));\n     let ps = zip(chars, ints);\n     fail!(~\"the impossible happened\");\n }"}, {"sha": "9c7caebc2eb6e1b223c1461a80bc239aa335b770", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -84,7 +84,7 @@ fn check_pp<T>(cx: fake_ext_ctxt,\n     stdout().write_line(s);\n     if expect != ~\"\" {\n         error!(\"expect: '%s', got: '%s'\", expect, s);\n-        fail_unless!(s == expect);\n+        assert!(s == expect);\n     }\n }\n "}, {"sha": "e3a544af309b2774311204036febecb4c63a6466", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -20,6 +20,6 @@ fn f<A:Copy + 'static>(a: A, b: u16) -> @fn() -> (A, u16) {\n pub fn main() {\n     let (a, b) = f(22_u64, 44u16)();\n     debug!(\"a=%? b=%?\", a, b);\n-    fail_unless!(a == 22u64);\n-    fail_unless!(b == 44u16);\n+    assert!(a == 22u64);\n+    assert!(b == 44u16);\n }"}, {"sha": "847e6fce8ee61f16a1abfaa0d973455057471020", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -35,6 +35,6 @@ pub fn main() {\n     make_cycle(z);\n     let (a, b) = z();\n     debug!(\"a=%u b=%u\", *a as uint, b as uint);\n-    fail_unless!(*a == x);\n-    fail_unless!(b == y);\n+    assert!(*a == x);\n+    assert!(b == y);\n }"}, {"sha": "0497f11202f3b9a71c8ddc58f9ce564b412583a8", "filename": "src/test/run-pass/alt-implicit-copy-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -14,7 +14,7 @@ pub fn main() {\n     let mut x = ~Pair {a: ~10, b: ~20};\n     match x {\n       ~Pair {a: ref mut a, b: ref mut b} => {\n-        fail_unless!(**a == 10); *a = ~30; fail_unless!(**a == 30);\n+        assert!(**a == 10); *a = ~30; assert!(**a == 30);\n       }\n     }\n }"}, {"sha": "8e71d8d4a6708d1823d144cd474a64a1e06b04b4", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -25,7 +25,7 @@ fn foo(s: @int) {\n       _ => { debug!(\"?\"); fail!(); }\n     }\n     debug!(::core::sys::refcount(s));\n-    fail_unless!((::core::sys::refcount(s) == count + 1u));\n+    assert!((::core::sys::refcount(s) == count + 1u));\n     let _ = ::core::sys::refcount(s); // don't get bitten by last-use.\n }\n \n@@ -39,5 +39,5 @@ pub fn main() {\n     debug!(\"%u\", ::core::sys::refcount(s));\n     let count2 = ::core::sys::refcount(s);\n     let _ = ::core::sys::refcount(s); // don't get bitten by last-use.\n-    fail_unless!(count == count2);\n+    assert!(count == count2);\n }"}, {"sha": "d6a8afbc4e734c400ef6f9dbcfba393ae58ce3a4", "filename": "src/test/run-pass/alt-pattern-lit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -18,4 +18,4 @@ fn altlit(f: int) -> int {\n     }\n }\n \n-pub fn main() { fail_unless!((altlit(10) == 20)); fail_unless!((altlit(11) == 22)); }\n+pub fn main() { assert!((altlit(10) == 20)); assert!((altlit(11) == 22)); }"}, {"sha": "1ece3b5fd93b6239aeda97257c0e1646a6bb947b", "filename": "src/test/run-pass/alt-ref-binding-in-guard-3256.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,7 +12,7 @@ pub fn main() {\n     let x = Some(unstable::exclusive(true));\n     match x {\n         Some(ref z) if z.with(|b| *b) => {\n-            do z.with |b| { fail_unless!(*b); }\n+            do z.with |b| { assert!(*b); }\n         },\n         _ => fail!()\n     }"}, {"sha": "9ef414d1170be9c157ebcd234009a9acaa8efe03", "filename": "src/test/run-pass/alt-ref-binding-mut-option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut-option.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -14,5 +14,5 @@ pub fn main() {\n       None => {}\n       Some(ref mut p) => { *p += 1; }\n     }\n-    fail_unless!(v == Some(23));\n+    assert!(v == Some(23));\n }"}, {"sha": "2bd55b46784b869281f847f20d288c9c8ca0c348", "filename": "src/test/run-pass/alt-ref-binding-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -21,5 +21,5 @@ fn destructure(x: &mut Rec) {\n pub fn main() {\n     let mut v = Rec {f: 22};\n     destructure(&mut v);\n-    fail_unless!(v.f == 23);\n+    assert!(v.f == 23);\n }"}, {"sha": "23b3062a83a8fc059ecf982c30d42a204c411848", "filename": "src/test/run-pass/alt-ref-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -16,5 +16,5 @@ fn destructure(x: Option<int>) -> int {\n }\n \n pub fn main() {\n-    fail_unless!(destructure(Some(22)) == 22);\n+    assert!(destructure(Some(22)) == 22);\n }"}, {"sha": "e41ec8a99e93f6d62e8e80702157c8718650862e", "filename": "src/test/run-pass/alt-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-str.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -24,7 +24,7 @@ pub fn main() {\n     }\n \n     let x = match ~\"a\" { ~\"a\" => 1, ~\"b\" => 2, _ => fail!() };\n-    fail_unless!((x == 1));\n+    assert!((x == 1));\n \n     match ~\"a\" { ~\"a\" => { } ~\"b\" => { }, _ => fail!() }\n "}, {"sha": "e2e1bf540c2ce5a60d4f949b2b0aa8e5a02c6145", "filename": "src/test/run-pass/alt-tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-tag.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -32,7 +32,7 @@ pub fn main() {\n     let gray: color = rgb(127, 127, 127);\n     let clear: color = rgba(50, 150, 250, 0);\n     let red: color = hsl(0, 255, 255);\n-    fail_unless!((process(gray) == 127));\n-    fail_unless!((process(clear) == 0));\n-    fail_unless!((process(red) == 255));\n+    assert!((process(gray) == 127));\n+    assert!((process(clear) == 0));\n+    assert!((process(red) == 255));\n }"}, {"sha": "2fb0a345157ee9450375db7755c494ea4e505845", "filename": "src/test/run-pass/alt-unique-bind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,7 +12,7 @@ pub fn main() {\n     match ~100 {\n       ~x => {\n         debug!(\"%?\", x);\n-        fail_unless!(x == 100);\n+        assert!(x == 100);\n       }\n     }\n }"}, {"sha": "d5d2e20cba3d508f4e3d21bdef6a98c9da16010e", "filename": "src/test/run-pass/alt-with-ret-arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -16,6 +16,6 @@ pub fn main() {\n         None => return (),\n         Some(num) => num as u32\n     };\n-    fail_unless!(f == 1234u32);\n+    assert!(f == 1234u32);\n     error!(f)\n }"}, {"sha": "d61c1214633fcc59e926ec8ac8b180ef65bd0f20", "filename": "src/test/run-pass/argument-passing.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargument-passing.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -23,9 +23,9 @@ fn f2(a: int, f: &fn(int)) -> int { f(1); return a; }\n \n pub fn main() {\n     let mut a = X {x: 1}, b = 2, c = 3;\n-    fail_unless!((f1(&mut a, &mut b, c) == 6));\n-    fail_unless!((a.x == 0));\n-    fail_unless!((b == 10));\n-    fail_unless!((f2(a.x, |x| a.x = 50) == 0));\n-    fail_unless!((a.x == 50));\n+    assert!((f1(&mut a, &mut b, c) == 6));\n+    assert!((a.x == 0));\n+    assert!((b == 10));\n+    assert!((f2(a.x, |x| a.x = 50) == 0));\n+    assert!((a.x == 50));\n }"}, {"sha": "a0512ffff2a4f85c34ba6f4f7ab2147644fa8158", "filename": "src/test/run-pass/arith-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Farith-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Farith-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-0.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -13,5 +13,5 @@\n pub fn main() {\n     let a: int = 10;\n     debug!(a);\n-    fail_unless!((a * (a - 1) == 90));\n+    assert!((a * (a - 1) == 90));\n }"}, {"sha": "c0db96f99c7f4658a16e277f709070b17c43abfb", "filename": "src/test/run-pass/arith-1.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Farith-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Farith-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-1.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,22 +12,22 @@\n \n pub fn main() {\n     let i32_a: int = 10;\n-    fail_unless!((i32_a == 10));\n-    fail_unless!((i32_a - 10 == 0));\n-    fail_unless!((i32_a / 10 == 1));\n-    fail_unless!((i32_a - 20 == -10));\n-    fail_unless!((i32_a << 10 == 10240));\n-    fail_unless!((i32_a << 16 == 655360));\n-    fail_unless!((i32_a * 16 == 160));\n-    fail_unless!((i32_a * i32_a * i32_a == 1000));\n-    fail_unless!((i32_a * i32_a * i32_a * i32_a == 10000));\n-    fail_unless!((i32_a * i32_a / i32_a * i32_a == 100));\n-    fail_unless!((i32_a * (i32_a - 1) << 2 + i32_a == 368640));\n+    assert!((i32_a == 10));\n+    assert!((i32_a - 10 == 0));\n+    assert!((i32_a / 10 == 1));\n+    assert!((i32_a - 20 == -10));\n+    assert!((i32_a << 10 == 10240));\n+    assert!((i32_a << 16 == 655360));\n+    assert!((i32_a * 16 == 160));\n+    assert!((i32_a * i32_a * i32_a == 1000));\n+    assert!((i32_a * i32_a * i32_a * i32_a == 10000));\n+    assert!((i32_a * i32_a / i32_a * i32_a == 100));\n+    assert!((i32_a * (i32_a - 1) << 2 + i32_a == 368640));\n     let i32_b: int = 0x10101010;\n-    fail_unless!((i32_b + 1 - 1 == i32_b));\n-    fail_unless!((i32_b << 1 == i32_b << 1));\n-    fail_unless!((i32_b >> 1 == i32_b >> 1));\n-    fail_unless!((i32_b & i32_b << 1 == 0));\n+    assert!((i32_b + 1 - 1 == i32_b));\n+    assert!((i32_b << 1 == i32_b << 1));\n+    assert!((i32_b >> 1 == i32_b >> 1));\n+    assert!((i32_b & i32_b << 1 == 0));\n     debug!(i32_b | i32_b << 1);\n-    fail_unless!((i32_b | i32_b << 1 == 0x30303030));\n+    assert!((i32_b | i32_b << 1 == 0x30303030));\n }"}, {"sha": "70df6e46e59d7c4c115214193bdaf126cb12cd55", "filename": "src/test/run-pass/arith-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Farith-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Farith-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-2.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,6 +12,6 @@\n \n pub fn main() {\n     let i32_c: int = 0x10101010;\n-    fail_unless!(i32_c + i32_c * 2 / 3 * 2 + (i32_c - 7 % 3) ==\n+    assert!(i32_c + i32_c * 2 / 3 * 2 + (i32_c - 7 % 3) ==\n                  i32_c + i32_c * 2 / 3 * 2 + (i32_c - 7 % 3));\n }"}, {"sha": "a921d9f7ddc7bf661ab20a871fcd003ede86e00c", "filename": "src/test/run-pass/arith-unsigned.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Farith-unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Farith-unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-unsigned.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -13,24 +13,24 @@\n \n // Unsigned integer operations\n pub fn main() {\n-    fail_unless!((0u8 < 255u8));\n-    fail_unless!((0u8 <= 255u8));\n-    fail_unless!((255u8 > 0u8));\n-    fail_unless!((255u8 >= 0u8));\n-    fail_unless!((250u8 / 10u8 == 25u8));\n-    fail_unless!((255u8 % 10u8 == 5u8));\n-    fail_unless!((0u16 < 60000u16));\n-    fail_unless!((0u16 <= 60000u16));\n-    fail_unless!((60000u16 > 0u16));\n-    fail_unless!((60000u16 >= 0u16));\n-    fail_unless!((60000u16 / 10u16 == 6000u16));\n-    fail_unless!((60005u16 % 10u16 == 5u16));\n-    fail_unless!((0u32 < 4000000000u32));\n-    fail_unless!((0u32 <= 4000000000u32));\n-    fail_unless!((4000000000u32 > 0u32));\n-    fail_unless!((4000000000u32 >= 0u32));\n-    fail_unless!((4000000000u32 / 10u32 == 400000000u32));\n-    fail_unless!((4000000005u32 % 10u32 == 5u32));\n+    assert!((0u8 < 255u8));\n+    assert!((0u8 <= 255u8));\n+    assert!((255u8 > 0u8));\n+    assert!((255u8 >= 0u8));\n+    assert!((250u8 / 10u8 == 25u8));\n+    assert!((255u8 % 10u8 == 5u8));\n+    assert!((0u16 < 60000u16));\n+    assert!((0u16 <= 60000u16));\n+    assert!((60000u16 > 0u16));\n+    assert!((60000u16 >= 0u16));\n+    assert!((60000u16 / 10u16 == 6000u16));\n+    assert!((60005u16 % 10u16 == 5u16));\n+    assert!((0u32 < 4000000000u32));\n+    assert!((0u32 <= 4000000000u32));\n+    assert!((4000000000u32 > 0u32));\n+    assert!((4000000000u32 >= 0u32));\n+    assert!((4000000000u32 / 10u32 == 400000000u32));\n+    assert!((4000000005u32 % 10u32 == 5u32));\n     // 64-bit numbers have some flakiness yet. Not tested\n \n }"}, {"sha": "7bc1354c3cefe9ee817e8e401dc47c2e6cffd94a", "filename": "src/test/run-pass/artificial-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fartificial-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fartificial-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fartificial-block.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -10,4 +10,4 @@\n \n fn f() -> int { { return 3; } }\n \n-pub fn main() { fail_unless!((f() == 3)); }\n+pub fn main() { assert!((f() == 3)); }"}, {"sha": "dc0850b24f1f68156ab9a1e182579fdf185b1cf8", "filename": "src/test/run-pass/assign-assign.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fassign-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fassign-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassign-assign.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,21 +12,21 @@\n fn test_assign() {\n     let mut x: int;\n     let mut y: () = x = 10;\n-    fail_unless!((x == 10));\n+    assert!((x == 10));\n     let mut z = x = 11;\n-    fail_unless!((x == 11));\n+    assert!((x == 11));\n     z = x = 12;\n-    fail_unless!((x == 12));\n+    assert!((x == 12));\n }\n \n fn test_assign_op() {\n     let mut x: int = 0;\n     let mut y: () = x += 10;\n-    fail_unless!((x == 10));\n+    assert!((x == 10));\n     let mut z = x += 11;\n-    fail_unless!((x == 21));\n+    assert!((x == 21));\n     z = x += 12;\n-    fail_unless!((x == 33));\n+    assert!((x == 33));\n }\n \n pub fn main() { test_assign(); test_assign_op(); }"}, {"sha": "c557aa7e223831aac747688acad2f4fcb0958c94", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -41,17 +41,17 @@ fn length<A, T: iterable<A>>(x: T) -> uint {\n pub fn main() {\n     let x = ~[0,1,2,3];\n     // Call a method\n-    for x.iterate() |y| { fail_unless!(x[*y] == *y); }\n+    for x.iterate() |y| { assert!(x[*y] == *y); }\n     // Call a parameterized function\n-    fail_unless!(length(x.clone()) == vec::len(x));\n+    assert!(length(x.clone()) == vec::len(x));\n     // Call a parameterized function, with type arguments that require\n     // a borrow\n-    fail_unless!(length::<int, &[int]>(x) == vec::len(x));\n+    assert!(length::<int, &[int]>(x) == vec::len(x));\n \n     // Now try it with a type that *needs* to be borrowed\n     let z = [0,1,2,3];\n     // Call a method\n-    for z.iterate() |y| { fail_unless!(z[*y] == *y); }\n+    for z.iterate() |y| { assert!(z[*y] == *y); }\n     // Call a parameterized function\n-    fail_unless!(length::<int, &[int]>(z) == vec::len(z));\n+    assert!(length::<int, &[int]>(z) == vec::len(z));\n }"}, {"sha": "c4d4f305a62dbf853dd917f2ce41f453686e6f34", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -34,7 +34,7 @@ fn test_prettyprint<A:Encodable<prettyprint::Serializer>>(\n         a.encode(&prettyprint::Serializer(w))\n     };\n     debug!(\"s == %?\", s);\n-    fail_unless!(s == *expected);\n+    assert!(s == *expected);\n }\n \n fn test_ebml<A:\n@@ -48,7 +48,7 @@ fn test_ebml<A:\n     };\n     let d = EBReader::Doc(@bytes);\n     let a2: A = Decodable::decode(&EBReader::Decoder(d));\n-    fail_unless!(*a1 == a2);\n+    assert!(*a1 == a2);\n }\n \n #[auto_encode]"}, {"sha": "e988028dd115865abd9d70b337a79d6e8c6bd18e", "filename": "src/test/run-pass/auto-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-loop.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -13,5 +13,5 @@ pub fn main() {\n     for vec::each(~[1, 2, 3, 4, 5]) |x| {\n         sum += *x;\n     }\n-    fail_unless!((sum == 15));\n+    assert!((sum == 15));\n }"}, {"sha": "bac6d1aa740a89c8632388c9da13d1afbf6485c1", "filename": "src/test/run-pass/auto-ref-newtype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -19,6 +19,6 @@ pub impl Foo {\n \n pub fn main() {\n     let m = Foo(3);\n-    fail_unless!(m.len() == 3);\n+    assert!(m.len() == 3);\n }\n "}, {"sha": "1dc56132875d46d3fc7dc451d26c2b2bcec2fbc2", "filename": "src/test/run-pass/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -17,13 +17,13 @@ trait MyIter {\n }\n \n impl<'self> MyIter for &'self [int] {\n-    fn test_imm(&self) { fail_unless!(self[0] == 1) }\n-    fn test_const(&const self) { fail_unless!(self[0] == 1) }\n+    fn test_imm(&self) { assert!(self[0] == 1) }\n+    fn test_const(&const self) { assert!(self[0] == 1) }\n }\n \n impl<'self> MyIter for &'self str {\n-    fn test_imm(&self) { fail_unless!(*self == \"test\") }\n-    fn test_const(&const self) { fail_unless!(*self == \"test\") }\n+    fn test_imm(&self) { assert!(*self == \"test\") }\n+    fn test_const(&const self) { assert!(*self == \"test\") }\n }\n \n pub fn main() {"}, {"sha": "03e847e237d3ae4c076dc66a09f3c3d4700e7875", "filename": "src/test/run-pass/auto-ref-sliceable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -22,5 +22,5 @@ pub fn main() {\n     let mut v = ~[1];\n     v.push_val(2);\n     v.push_val(3);\n-    fail_unless!(v == ~[1, 2, 3]);\n+    assert!(v == ~[1, 2, 3]);\n }"}, {"sha": "afaafd45b7b6fa5f5fa53497581f727e48ed134f", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -13,7 +13,7 @@ fn f<T:Copy>(x: ~[T]) -> T { return x[0]; }\n fn g(act: &fn(~[int]) -> int) -> int { return act(~[1, 2, 3]); }\n \n pub fn main() {\n-    fail_unless!((g(f) == 1));\n+    assert!((g(f) == 1));\n     let f1: &fn(~[~str]) -> ~str = f;\n-    fail_unless!((f1(~[~\"x\", ~\"y\", ~\"z\"]) == ~\"x\"));\n+    assert!((f1(~[~\"x\", ~\"y\", ~\"z\"]) == ~\"x\"));\n }"}, {"sha": "2d6f03c1daf2058e516f775f90b4e75c0ed67ccd", "filename": "src/test/run-pass/autoderef-method-newtype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -20,5 +20,5 @@ struct foo(uint);\n \n pub fn main() {\n     let x = foo(3u);\n-    fail_unless!(x.double() == 6u);\n+    assert!(x.double() == 6u);\n }"}, {"sha": "32f09369d981717014262a2e3f49e2b73f5d974d", "filename": "src/test/run-pass/autoderef-method-on-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -18,5 +18,5 @@ impl double for uint {\n \n pub fn main() {\n     let x = @(@3u as @double);\n-    fail_unless!(x.double() == 6u);\n+    assert!(x.double() == 6u);\n }"}, {"sha": "eaef1ae3477a798fa21e10b26d5b06a944dc39ba", "filename": "src/test/run-pass/autoderef-method-priority.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -25,5 +25,5 @@ impl double for @uint {\n \n pub fn main() {\n     let x = @3u;\n-    fail_unless!(x.double() == 6u);\n+    assert!(x.double() == 6u);\n }"}, {"sha": "c04efd7e18f540b2def853e114cca28fec1ee6dd", "filename": "src/test/run-pass/autoderef-method-twice-but-not-thrice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -18,5 +18,5 @@ impl double for @uint {\n \n pub fn main() {\n     let x = @@@@@3u;\n-    fail_unless!(x.double() == 6u);\n+    assert!(x.double() == 6u);\n }"}, {"sha": "0a2a93d40d186c2214352bc57e10681bd8f179ec", "filename": "src/test/run-pass/autoderef-method-twice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -18,5 +18,5 @@ impl double for uint {\n \n pub fn main() {\n     let x = @@3u;\n-    fail_unless!(x.double() == 6u);\n+    assert!(x.double() == 6u);\n }"}, {"sha": "b704011ad9882a61a6b5ad36567715210e67a845", "filename": "src/test/run-pass/autoderef-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautoderef-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautoderef-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -18,5 +18,5 @@ impl double for uint {\n \n pub fn main() {\n     let x = @3u;\n-    fail_unless!(x.double() == 6u);\n+    assert!(x.double() == 6u);\n }"}, {"sha": "5325242b99c33825f1d7ec23a4d32d0a45a02202", "filename": "src/test/run-pass/autoref-intermediate-types-issue-3585.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -26,5 +26,5 @@ impl Foo for uint {\n \n pub fn main() {\n     let x = @3u;\n-    fail_unless!(x.foo() == ~\"@3\");\n+    assert!(x.foo() == ~\"@3\");\n }"}, {"sha": "41aa2042796898aaf2761cf1c3ac3b88878cbcea", "filename": "src/test/run-pass/big-literals.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbig-literals.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -11,11 +11,11 @@\n // except according to those terms.\n \n pub fn main() {\n-    fail_unless!(0xffffffffu32 == (-1 as u32));\n-    fail_unless!(4294967295u32 == (-1 as u32));\n-    fail_unless!(0xffffffffffffffffu64 == (-1 as u64));\n-    fail_unless!(18446744073709551615u64 == (-1 as u64));\n+    assert!(0xffffffffu32 == (-1 as u32));\n+    assert!(4294967295u32 == (-1 as u32));\n+    assert!(0xffffffffffffffffu64 == (-1 as u64));\n+    assert!(18446744073709551615u64 == (-1 as u64));\n \n-    fail_unless!(-2147483648i32 - 1i32 == 2147483647i32);\n-    fail_unless!(-9223372036854775808i64 - 1i64 == 9223372036854775807i64);\n+    assert!(-2147483648i32 - 1i32 == 2147483647i32);\n+    assert!(-9223372036854775808i64 - 1i64 == 9223372036854775807i64);\n }"}, {"sha": "50dbefdd086a9813b6d8165519c4a3e6e94fadb6", "filename": "src/test/run-pass/binary-minus-without-space.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,5 +12,5 @@\n \n pub fn main() {\n     match -1 { -1 => {}, _ => fail!(~\"wat\") }\n-    fail_unless!(1-1 == 0);\n+    assert!(1-1 == 0);\n }"}, {"sha": "e0a2d1ffa1c95eeca0bfb93cee803f50e09b0081", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -11,55 +11,55 @@\n // Binop corner cases\n \n fn test_nil() {\n-    fail_unless!((() == ()));\n-    fail_unless!((!(() != ())));\n-    fail_unless!((!(() < ())));\n-    fail_unless!((() <= ()));\n-    fail_unless!((!(() > ())));\n-    fail_unless!((() >= ()));\n+    assert!((() == ()));\n+    assert!((!(() != ())));\n+    assert!((!(() < ())));\n+    assert!((() <= ()));\n+    assert!((!(() > ())));\n+    assert!((() >= ()));\n }\n \n fn test_bool() {\n-    fail_unless!((!(true < false)));\n-    fail_unless!((!(true <= false)));\n-    fail_unless!((true > false));\n-    fail_unless!((true >= false));\n+    assert!((!(true < false)));\n+    assert!((!(true <= false)));\n+    assert!((true > false));\n+    assert!((true >= false));\n \n-    fail_unless!((false < true));\n-    fail_unless!((false <= true));\n-    fail_unless!((!(false > true)));\n-    fail_unless!((!(false >= true)));\n+    assert!((false < true));\n+    assert!((false <= true));\n+    assert!((!(false > true)));\n+    assert!((!(false >= true)));\n \n     // Bools support bitwise binops\n-    fail_unless!((false & false == false));\n-    fail_unless!((true & false == false));\n-    fail_unless!((true & true == true));\n-    fail_unless!((false | false == false));\n-    fail_unless!((true | false == true));\n-    fail_unless!((true | true == true));\n-    fail_unless!((false ^ false == false));\n-    fail_unless!((true ^ false == true));\n-    fail_unless!((true ^ true == false));\n+    assert!((false & false == false));\n+    assert!((true & false == false));\n+    assert!((true & true == true));\n+    assert!((false | false == false));\n+    assert!((true | false == true));\n+    assert!((true | true == true));\n+    assert!((false ^ false == false));\n+    assert!((true ^ false == true));\n+    assert!((true ^ true == false));\n }\n \n fn test_char() {\n     let ch10 = 10 as char;\n     let ch4 = 4 as char;\n     let ch2 = 2 as char;\n-    fail_unless!((ch10 + ch4 == 14 as char));\n-    fail_unless!((ch10 - ch4 == 6 as char));\n-    fail_unless!((ch10 * ch4 == 40 as char));\n-    fail_unless!((ch10 / ch4 == ch2));\n-    fail_unless!((ch10 % ch4 == ch2));\n-    fail_unless!((ch10 >> ch2 == ch2));\n-    fail_unless!((ch10 << ch4 == 160 as char));\n-    fail_unless!((ch10 | ch4 == 14 as char));\n-    fail_unless!((ch10 & ch2 == ch2));\n-    fail_unless!((ch10 ^ ch2 == 8 as char));\n+    assert!((ch10 + ch4 == 14 as char));\n+    assert!((ch10 - ch4 == 6 as char));\n+    assert!((ch10 * ch4 == 40 as char));\n+    assert!((ch10 / ch4 == ch2));\n+    assert!((ch10 % ch4 == ch2));\n+    assert!((ch10 >> ch2 == ch2));\n+    assert!((ch10 << ch4 == 160 as char));\n+    assert!((ch10 | ch4 == 14 as char));\n+    assert!((ch10 & ch2 == ch2));\n+    assert!((ch10 ^ ch2 == 8 as char));\n }\n \n fn test_box() {\n-    fail_unless!((@10 == @10));\n+    assert!((@10 == @10));\n }\n \n fn test_ptr() {\n@@ -68,14 +68,14 @@ fn test_ptr() {\n         let p2: *u8 = ::core::cast::reinterpret_cast(&0);\n         let p3: *u8 = ::core::cast::reinterpret_cast(&1);\n \n-        fail_unless!(p1 == p2);\n-        fail_unless!(p1 != p3);\n-        fail_unless!(p1 < p3);\n-        fail_unless!(p1 <= p3);\n-        fail_unless!(p3 > p1);\n-        fail_unless!(p3 >= p3);\n-        fail_unless!(p1 <= p2);\n-        fail_unless!(p1 >= p2);\n+        assert!(p1 == p2);\n+        assert!(p1 != p3);\n+        assert!(p1 < p3);\n+        assert!(p1 <= p3);\n+        assert!(p3 > p1);\n+        assert!(p3 >= p3);\n+        assert!(p1 <= p2);\n+        assert!(p1 >= p2);\n     }\n }\n \n@@ -110,11 +110,11 @@ fn test_class() {\n          (::core::cast::reinterpret_cast::<*p, uint>(&ptr::addr_of(&q))),\n          (::core::cast::reinterpret_cast::<*p, uint>(&ptr::addr_of(&r))));\n   }\n-  fail_unless!((q == r));\n+  assert!((q == r));\n   r.y = 17;\n-  fail_unless!((r.y != q.y));\n-  fail_unless!((r.y == 17));\n-  fail_unless!((q != r));\n+  assert!((r.y != q.y));\n+  assert!((r.y == 17));\n+  assert!((q != r));\n }\n \n pub fn main() {"}, {"sha": "1a67329ff82b0bc64a072accf47bd3396a30aecb", "filename": "src/test/run-pass/bitwise.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fbitwise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fbitwise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitwise.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,12 +12,12 @@\n \n #[cfg(target_arch = \"x86\")]\n fn target() {\n-    fail_unless!((-1000 as uint >> 3u == 536870787u));\n+    assert!((-1000 as uint >> 3u == 536870787u));\n }\n \n #[cfg(target_arch = \"x86_64\")]\n fn target() {\n-    fail_unless!((-1000 as uint >> 3u == 2305843009213693827u));\n+    assert!((-1000 as uint >> 3u == 2305843009213693827u));\n }\n \n fn general() {\n@@ -28,14 +28,14 @@ fn general() {\n     a = a ^ b;\n     debug!(a);\n     debug!(b);\n-    fail_unless!((b == 1));\n-    fail_unless!((a == 2));\n-    fail_unless!((!0xf0 & 0xff == 0xf));\n-    fail_unless!((0xf0 | 0xf == 0xff));\n-    fail_unless!((0xf << 4 == 0xf0));\n-    fail_unless!((0xf0 >> 4 == 0xf));\n-    fail_unless!((-16 >> 2 == -4));\n-    fail_unless!((0b1010_1010 | 0b0101_0101 == 0xff));\n+    assert!((b == 1));\n+    assert!((a == 2));\n+    assert!((!0xf0 & 0xff == 0xf));\n+    assert!((0xf0 | 0xf == 0xff));\n+    assert!((0xf << 4 == 0xf0));\n+    assert!((0xf0 >> 4 == 0xf));\n+    assert!((-16 >> 2 == -4));\n+    assert!((0b1010_1010 | 0b0101_0101 == 0xff));\n }\n \n pub fn main() {"}, {"sha": "22d495e2c1ba27f99ad794e9ddf8139b02e92065", "filename": "src/test/run-pass/block-arg-call-as.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -24,9 +24,9 @@ fn asBlock( f : &fn()->uint ) -> uint {\n \n pub fn main() {\n    let x = asSendfn(|| 22u);\n-   fail_unless!((x == 22u));\n+   assert!((x == 22u));\n    let x = asLambda(|| 22u);\n-   fail_unless!((x == 22u));\n+   assert!((x == 22u));\n    let x = asBlock(|| 22u);\n-   fail_unless!((x == 22u));\n+   assert!((x == 22u));\n }"}, {"sha": "74756d27fe763c613edb8c347301c364aafcdfef", "filename": "src/test/run-pass/block-arg-can-be-followed-by-binop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -14,5 +14,5 @@ pub fn main() {\n     // Trailing expressions don't require parentheses:\n     let y = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n \n-    fail_unless!(y == 15f);\n+    assert!(y == 15f);\n }"}, {"sha": "4cadb883d9962e602f6b5ae6037835f59a937483", "filename": "src/test/run-pass/block-arg-can-be-followed-by-block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,5 +12,5 @@ pub fn main() {\n     fn f(i: &fn() -> uint) -> uint { i() }\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n     let z = do do vec::foldl(f, v) |x, _y| { x } { 22u };\n-    fail_unless!(z == 22u);\n+    assert!(z == 22u);\n }"}, {"sha": "ac584324cece861cf1ad980ef6fe2181444242b7", "filename": "src/test/run-pass/block-arg-can-be-followed-by-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -12,5 +12,5 @@ pub fn main() {\n     fn f(i: uint) -> uint { i }\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n     let z = do vec::foldl(f, v) |x, _y| { x } (22u);\n-    fail_unless!(z == 22u);\n+    assert!(z == 22u);\n }"}, {"sha": "ce0b85f414b3959d83feffd4409a23efe1f3b9cb", "filename": "src/test/run-pass/block-arg-in-parentheses.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -28,9 +28,9 @@ fn w_ret(v: ~[int]) -> int {\n }\n \n pub fn main() {\n-    fail_unless!(w_semi(~[0, 1, 2, 3]) == -10);\n-    fail_unless!(w_paren1(~[0, 1, 2, 3]) == -4);\n-    fail_unless!(w_paren2(~[0, 1, 2, 3]) == -4);\n-    fail_unless!(w_ret(~[0, 1, 2, 3]) == -4);\n+    assert!(w_semi(~[0, 1, 2, 3]) == -10);\n+    assert!(w_paren1(~[0, 1, 2, 3]) == -4);\n+    assert!(w_paren2(~[0, 1, 2, 3]) == -4);\n+    assert!(w_ret(~[0, 1, 2, 3]) == -4);\n }\n "}, {"sha": "d8aeba355d14764210284216b4e722dcf0571c03", "filename": "src/test/run-pass/block-arg-used-as-any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -14,5 +14,5 @@ fn call_any(f: &fn() -> uint) -> uint {\n \n pub fn main() {\n     let x_r = do call_any { 22u };\n-    fail_unless!(x_r == 22u);\n+    assert!(x_r == 22u);\n }"}, {"sha": "2a7bfe4e3287645f5507db820c33fcfe39825460", "filename": "src/test/run-pass/block-arg-used-as-lambda.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -19,6 +19,6 @@ pub fn main() {\n     let x_r = x(22u);\n     let y_r = y(x_r);\n \n-    fail_unless!(x_r == 44u);\n-    fail_unless!(y_r == 88u);\n+    assert!(x_r == 44u);\n+    assert!(y_r == 88u);\n }"}, {"sha": "4fecbd4e956b3eea6ba6f85a6890a29cf1ea5ee1", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -19,20 +19,20 @@ pub fn main() {\n \n     // Usable at all:\n     let mut any_negative = do vec::any(v) |e| { float::is_negative(*e) };\n-    fail_unless!(any_negative);\n+    assert!(any_negative);\n \n     // Higher precedence than assignments:\n     any_negative = do vec::any(v) |e| { float::is_negative(*e) };\n-    fail_unless!(any_negative);\n+    assert!(any_negative);\n \n     // Higher precedence than unary operations:\n     let abs_v = do vec::map(v) |e| { float::abs(*e) };\n-    fail_unless!(do vec::all(abs_v) |e| { float::is_nonnegative(*e) });\n-    fail_unless!(!do vec::any(abs_v) |e| { float::is_negative(*e) });\n+    assert!(do vec::all(abs_v) |e| { float::is_nonnegative(*e) });\n+    assert!(!do vec::any(abs_v) |e| { float::is_negative(*e) });\n \n     // Usable in funny statement-like forms:\n     if !do vec::any(v) |e| { float::is_positive(*e) } {\n-        fail_unless!(false);\n+        assert!(false);\n     }\n     match do vec::all(v) |e| { float::is_negative(*e) } {\n         true => { fail!(~\"incorrect answer.\"); }\n@@ -51,12 +51,12 @@ pub fn main() {\n     let w = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n     let y = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n     let z = 10f + do vec::foldl(0f, v) |x, y| { x + *y };\n-    fail_unless!(w == y);\n-    fail_unless!(y == z);\n+    assert!(w == y);\n+    assert!(y == z);\n \n     // In the tail of a block\n     let w =\n         if true { do vec::any(abs_v) |e| { float::is_nonnegative(*e) } }\n       else { false };\n-    fail_unless!(w);\n+    assert!(w);\n }"}, {"sha": "d8f6f167f208a1e281e5d857153c3830a537cb12", "filename": "src/test/run-pass/block-expr-precedence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -58,8 +58,8 @@ pub fn main() {\n \n   let num = 12;\n \n-  fail_unless!(if (true) { 12 } else { 12 } - num == 0);\n-  fail_unless!(12 - if (true) { 12 } else { 12 } == 0);\n+  assert!(if (true) { 12 } else { 12 } - num == 0);\n+  assert!(12 - if (true) { 12 } else { 12 } == 0);\n   if (true) { 12; } {-num};\n   if (true) { 12; }; {-num};\n   if (true) { 12; };;; -num;"}, {"sha": "5a4b2f8bfd66319187c6f6973e7d8bd9d23b037c", "filename": "src/test/run-pass/block-fn-coerce.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -11,7 +11,7 @@\n fn force(f: &fn() -> int) -> int { return f(); }\n pub fn main() {\n     fn f() -> int { return 7; }\n-    fail_unless!((force(f) == 7));\n+    assert!((force(f) == 7));\n     let g = {||force(f)};\n-    fail_unless!((g() == 7));\n+    assert!((g() == 7));\n }"}, {"sha": "0a3458ed8141a10e15b820557c4300a38f4becb9", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f864934f548be9f03d2c0512de8d7e908469e2ae/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=f864934f548be9f03d2c0512de8d7e908469e2ae", "patch": "@@ -21,5 +21,5 @@ pub fn main() {\n         }\n     });\n     error!(odds);\n-    fail_unless!((odds == 4));\n+    assert!((odds == 4));\n }"}]}