{"sha": "b21425de3c6be4264b875e68c8a28b424c27b8c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMTQyNWRlM2M2YmU0MjY0Yjg3NWU2OGM4YTI4YjQyNGMyN2I4YzQ=", "commit": {"author": {"name": "Sasha Pourcelot", "email": "sasha.pourcelot@iomentum.com", "date": "2021-08-16T13:22:36Z"}, "committer": {"name": "Sasha Pourcelot", "email": "sasha.pourcelot@iomentum.com", "date": "2021-09-09T15:44:40Z"}, "message": "Emit proper errors on missing closure braces\n\nThis commit focuses on emitting clean errors for the following syntax\nerror:\n\n```\nSome(42).map(|a|\n    dbg!(a);\n    a\n);\n```\n\nPrevious implementation tried to recover after parsing the closure body\n(the `dbg` expression) by replacing the next `;` with a `,`, which made\nthe next expression belong to the next function argument. As such, the\nfollowing errors were emitted (among others):\n  - the semicolon token was not expected,\n  - a is not in scope,\n  - Option::map is supposed to take one argument, not two.\n\nThis commit allows us to gracefully handle this situation by adding\ngiving the parser the ability to remember when it has just parsed a\nclosure body inside a function call. When this happens, we can treat the\nunexpected `;` specifically and try to parse as much statements as\npossible in order to eat the whole block. When we can't parse statements\nanymore, we generate a clean error indicating that the braces are\nmissing, and return an ExprKind::Err.", "tree": {"sha": "5211cbd09df091d8121ebaf3848b6a43415ca743", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5211cbd09df091d8121ebaf3848b6a43415ca743"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b21425de3c6be4264b875e68c8a28b424c27b8c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b21425de3c6be4264b875e68c8a28b424c27b8c4", "html_url": "https://github.com/rust-lang/rust/commit/b21425de3c6be4264b875e68c8a28b424c27b8c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b21425de3c6be4264b875e68c8a28b424c27b8c4/comments", "author": {"login": "scrabsha", "id": 25402018, "node_id": "MDQ6VXNlcjI1NDAyMDE4", "avatar_url": "https://avatars.githubusercontent.com/u/25402018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scrabsha", "html_url": "https://github.com/scrabsha", "followers_url": "https://api.github.com/users/scrabsha/followers", "following_url": "https://api.github.com/users/scrabsha/following{/other_user}", "gists_url": "https://api.github.com/users/scrabsha/gists{/gist_id}", "starred_url": "https://api.github.com/users/scrabsha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scrabsha/subscriptions", "organizations_url": "https://api.github.com/users/scrabsha/orgs", "repos_url": "https://api.github.com/users/scrabsha/repos", "events_url": "https://api.github.com/users/scrabsha/events{/privacy}", "received_events_url": "https://api.github.com/users/scrabsha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scrabsha", "id": 25402018, "node_id": "MDQ6VXNlcjI1NDAyMDE4", "avatar_url": "https://avatars.githubusercontent.com/u/25402018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scrabsha", "html_url": "https://github.com/scrabsha", "followers_url": "https://api.github.com/users/scrabsha/followers", "following_url": "https://api.github.com/users/scrabsha/following{/other_user}", "gists_url": "https://api.github.com/users/scrabsha/gists{/gist_id}", "starred_url": "https://api.github.com/users/scrabsha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scrabsha/subscriptions", "organizations_url": "https://api.github.com/users/scrabsha/orgs", "repos_url": "https://api.github.com/users/scrabsha/repos", "events_url": "https://api.github.com/users/scrabsha/events{/privacy}", "received_events_url": "https://api.github.com/users/scrabsha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "497ee321af3b8496eaccd7af7b437f18bab81abf", "url": "https://api.github.com/repos/rust-lang/rust/commits/497ee321af3b8496eaccd7af7b437f18bab81abf", "html_url": "https://github.com/rust-lang/rust/commit/497ee321af3b8496eaccd7af7b437f18bab81abf"}], "stats": {"total": 243, "additions": 234, "deletions": 9}, "files": [{"sha": "dc80dab8c6c5f9d55f4c480a1ae932966fd74141", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b21425de3c6be4264b875e68c8a28b424c27b8c4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21425de3c6be4264b875e68c8a28b424c27b8c4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=b21425de3c6be4264b875e68c8a28b424c27b8c4", "patch": "@@ -1,9 +1,12 @@\n use super::pat::{RecoverColon, RecoverComma, PARAM_EXPECTED};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n-use super::{AttrWrapper, BlockMode, ForceCollect, Parser, PathStyle, Restrictions, TokenType};\n+use super::{\n+    AttrWrapper, BlockMode, ClosureSpans, ForceCollect, Parser, PathStyle, Restrictions, TokenType,\n+};\n use super::{SemiColonMode, SeqSep, TokenExpectType, TrailingToken};\n use crate::maybe_recover_from_interpolated_ty_qpath;\n \n+use ast::token::DelimToken;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Token, TokenKind};\n use rustc_ast::tokenstream::Spacing;\n@@ -91,6 +94,8 @@ impl<'a> Parser<'a> {\n     /// Parses an expression.\n     #[inline]\n     pub fn parse_expr(&mut self) -> PResult<'a, P<Expr>> {\n+        self.current_closure.take();\n+\n         self.parse_expr_res(Restrictions::empty(), None)\n     }\n \n@@ -1736,7 +1741,7 @@ impl<'a> Parser<'a> {\n         let capture_clause = self.parse_capture_clause()?;\n         let decl = self.parse_fn_block_decl()?;\n         let decl_hi = self.prev_token.span;\n-        let body = match decl.output {\n+        let mut body = match decl.output {\n             FnRetTy::Default(_) => {\n                 let restrictions = self.restrictions - Restrictions::STMT_EXPR;\n                 self.parse_expr_res(restrictions, None)?\n@@ -1753,11 +1758,28 @@ impl<'a> Parser<'a> {\n             self.sess.gated_spans.gate(sym::async_closure, span);\n         }\n \n-        Ok(self.mk_expr(\n+        if self.token.kind == TokenKind::Semi && self.token_cursor.frame.delim == DelimToken::Paren\n+        {\n+            // It is likely that the closure body is a block but where the\n+            // braces have been removed. We will recover and eat the next\n+            // statements later in the parsing process.\n+            body = self.mk_expr_err(body.span);\n+        }\n+\n+        let body_span = body.span;\n+\n+        let closure = self.mk_expr(\n             lo.to(body.span),\n             ExprKind::Closure(capture_clause, asyncness, movability, decl, body, lo.to(decl_hi)),\n             attrs,\n-        ))\n+        );\n+\n+        // Disable recovery for closure body\n+        let spans =\n+            ClosureSpans { whole_closure: closure.span, closing_pipe: decl_hi, body: body_span };\n+        self.current_closure = Some(spans);\n+\n+        Ok(closure)\n     }\n \n     /// Parses an optional `move` prefix to a closure-like construct."}, {"sha": "5c701fefd17de95b0d95dfaeaa64f625f61f27e2", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 98, "deletions": 5, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/b21425de3c6be4264b875e68c8a28b424c27b8c4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21425de3c6be4264b875e68c8a28b424c27b8c4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=b21425de3c6be4264b875e68c8a28b424c27b8c4", "patch": "@@ -142,6 +142,17 @@ pub struct Parser<'a> {\n     /// If present, this `Parser` is not parsing Rust code but rather a macro call.\n     subparser_name: Option<&'static str>,\n     capture_state: CaptureState,\n+    /// This allows us to recover when the user forget to add braces around\n+    /// multiple statements in the closure body.\n+    pub current_closure: Option<ClosureSpans>,\n+}\n+\n+/// Stores span informations about a closure.\n+#[derive(Clone)]\n+pub struct ClosureSpans {\n+    pub whole_closure: Span,\n+    pub closing_pipe: Span,\n+    pub body: Span,\n }\n \n /// Indicates a range of tokens that should be replaced by\n@@ -440,6 +451,7 @@ impl<'a> Parser<'a> {\n                 replace_ranges: Vec::new(),\n                 inner_attr_ranges: Default::default(),\n             },\n+            current_closure: None,\n         };\n \n         // Make parser point to the first token.\n@@ -761,19 +773,41 @@ impl<'a> Parser<'a> {\n                     first = false;\n                 } else {\n                     match self.expect(t) {\n-                        Ok(false) => {}\n+                        Ok(false) => {\n+                            self.current_closure.take();\n+                        }\n                         Ok(true) => {\n+                            self.current_closure.take();\n                             recovered = true;\n                             break;\n                         }\n                         Err(mut expect_err) => {\n                             let sp = self.prev_token.span.shrink_to_hi();\n                             let token_str = pprust::token_kind_to_string(t);\n \n-                            // Attempt to keep parsing if it was a similar separator.\n-                            if let Some(ref tokens) = t.similar_tokens() {\n-                                if tokens.contains(&self.token.kind) && !unclosed_delims {\n-                                    self.bump();\n+                            match self.current_closure.take() {\n+                                Some(closure_spans) if self.token.kind == TokenKind::Semi => {\n+                                    // Finding a semicolon instead of a comma\n+                                    // after a closure body indicates that the\n+                                    // closure body may be a block but the user\n+                                    // forgot to put braces around its\n+                                    // statements.\n+\n+                                    self.recover_missing_braces_around_closure_body(\n+                                        closure_spans,\n+                                        expect_err,\n+                                    )?;\n+\n+                                    continue;\n+                                }\n+\n+                                _ => {\n+                                    // Attempt to keep parsing if it was a similar separator.\n+                                    if let Some(ref tokens) = t.similar_tokens() {\n+                                        if tokens.contains(&self.token.kind) && !unclosed_delims {\n+                                            self.bump();\n+                                        }\n+                                    }\n                                 }\n                             }\n \n@@ -839,6 +873,65 @@ impl<'a> Parser<'a> {\n         Ok((v, trailing, recovered))\n     }\n \n+    fn recover_missing_braces_around_closure_body(\n+        &mut self,\n+        closure_spans: ClosureSpans,\n+        mut expect_err: DiagnosticBuilder<'_>,\n+    ) -> PResult<'a, ()> {\n+        let initial_semicolon = self.token.span;\n+\n+        while self.eat(&TokenKind::Semi) {\n+            let _ = self.parse_stmt(ForceCollect::Yes)?;\n+        }\n+\n+        expect_err.set_primary_message(\n+            \"closure bodies that contain statements must be surrounded by braces\",\n+        );\n+\n+        let preceding_pipe_span = closure_spans.closing_pipe;\n+        let following_token_span = self.token.span;\n+\n+        let mut first_note = MultiSpan::from(vec![initial_semicolon]);\n+        first_note.push_span_label(\n+            initial_semicolon,\n+            \"this `;` turns the preceding closure into a statement\".to_string(),\n+        );\n+        first_note.push_span_label(\n+            closure_spans.body,\n+            \"this expression is a statement because of the trailing semicolon\".to_string(),\n+        );\n+        expect_err.span_note(first_note, \"statement found outside of a block\");\n+\n+        let mut second_note = MultiSpan::from(vec![closure_spans.whole_closure]);\n+        second_note.push_span_label(\n+            closure_spans.whole_closure,\n+            \"this is the parsed closure...\".to_string(),\n+        );\n+        second_note.push_span_label(\n+            following_token_span,\n+            \"...but likely you meant the closure to end here\".to_string(),\n+        );\n+        expect_err.span_note(second_note, \"the closure body may be incorrectly delimited\");\n+\n+        expect_err.set_span(vec![preceding_pipe_span, following_token_span]);\n+\n+        let opening_suggestion_str = \" {\".to_string();\n+        let closing_suggestion_str = \"}\".to_string();\n+\n+        expect_err.multipart_suggestion(\n+            \"try adding braces\",\n+            vec![\n+                (preceding_pipe_span.shrink_to_hi(), opening_suggestion_str),\n+                (following_token_span.shrink_to_lo(), closing_suggestion_str),\n+            ],\n+            Applicability::MaybeIncorrect,\n+        );\n+\n+        expect_err.emit();\n+\n+        Ok(())\n+    }\n+\n     /// Parses a sequence, not including the closing delimiter. The function\n     /// `f` must consume tokens until reaching the next separator or\n     /// closing bracket."}, {"sha": "c50b9a12b6d44dbf7b5fa666dbd540f62a7f9119", "filename": "src/test/ui/expr/malformed_closure/missing_braces_around_block.fixed", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b21425de3c6be4264b875e68c8a28b424c27b8c4/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fmissing_braces_around_block.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b21425de3c6be4264b875e68c8a28b424c27b8c4/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fmissing_braces_around_block.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fmissing_braces_around_block.fixed?ref=b21425de3c6be4264b875e68c8a28b424c27b8c4", "patch": "@@ -0,0 +1,19 @@\n+// This snippet ensures that no attempt to recover on a semicolon instead of\n+// comma is made next to a closure body.\n+//\n+// If this recovery happens, then plenty of errors are emitted. Here, we expect\n+// only one error.\n+//\n+// This is part of issue #88065:\n+// https://github.com/rust-lang/rust/issues/88065\n+\n+// run-rustfix\n+\n+fn main() {\n+    let num = 5;\n+    (1..num).reduce(|a, b| {\n+        //~^ ERROR: closure bodies that contain statements must be surrounded by braces\n+        println!(\"{}\", a);\n+        a * b\n+    }).unwrap();\n+}"}, {"sha": "58c81f3a6e2a940cb9725efd72ec2d1c430b92ac", "filename": "src/test/ui/expr/malformed_closure/missing_braces_around_block.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b21425de3c6be4264b875e68c8a28b424c27b8c4/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fmissing_braces_around_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21425de3c6be4264b875e68c8a28b424c27b8c4/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fmissing_braces_around_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fmissing_braces_around_block.rs?ref=b21425de3c6be4264b875e68c8a28b424c27b8c4", "patch": "@@ -0,0 +1,19 @@\n+// This snippet ensures that no attempt to recover on a semicolon instead of\n+// comma is made next to a closure body.\n+//\n+// If this recovery happens, then plenty of errors are emitted. Here, we expect\n+// only one error.\n+//\n+// This is part of issue #88065:\n+// https://github.com/rust-lang/rust/issues/88065\n+\n+// run-rustfix\n+\n+fn main() {\n+    let num = 5;\n+    (1..num).reduce(|a, b|\n+        //~^ ERROR: closure bodies that contain statements must be surrounded by braces\n+        println!(\"{}\", a);\n+        a * b\n+    ).unwrap();\n+}"}, {"sha": "dac9a8cfc69d49a30d7698369a0674501dce324c", "filename": "src/test/ui/expr/malformed_closure/missing_braces_around_block.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b21425de3c6be4264b875e68c8a28b424c27b8c4/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fmissing_braces_around_block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b21425de3c6be4264b875e68c8a28b424c27b8c4/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fmissing_braces_around_block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fmissing_braces_around_block.stderr?ref=b21425de3c6be4264b875e68c8a28b424c27b8c4", "patch": "@@ -0,0 +1,38 @@\n+error: closure bodies that contain statements must be surrounded by braces\n+  --> $DIR/missing_braces_around_block.rs:14:26\n+   |\n+LL |     (1..num).reduce(|a, b|\n+   |                          ^\n+...\n+LL |     ).unwrap();\n+   |     ^\n+   |\n+note: statement found outside of a block\n+  --> $DIR/missing_braces_around_block.rs:16:26\n+   |\n+LL |         println!(\"{}\", a);\n+   |         -----------------^ this `;` turns the preceding closure into a statement\n+   |         |\n+   |         this expression is a statement because of the trailing semicolon\n+note: the closure body may be incorrectly delimited\n+  --> $DIR/missing_braces_around_block.rs:14:21\n+   |\n+LL |       (1..num).reduce(|a, b|\n+   |  _____________________^\n+LL | |\n+LL | |         println!(\"{}\", a);\n+   | |_________________________^ this is the parsed closure...\n+LL |           a * b\n+LL |       ).unwrap();\n+   |       - ...but likely you meant the closure to end here\n+help: try adding braces\n+   |\n+LL ~     (1..num).reduce(|a, b| {\n+LL |\n+LL |         println!(\"{}\", a);\n+LL |         a * b\n+LL ~     }).unwrap();\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "e4341e196877bb1252da5ee93924f5aeac0f6518", "filename": "src/test/ui/expr/malformed_closure/ruby_style_closure.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b21425de3c6be4264b875e68c8a28b424c27b8c4/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21425de3c6be4264b875e68c8a28b424c27b8c4/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.rs?ref=b21425de3c6be4264b875e68c8a28b424c27b8c4", "patch": "@@ -0,0 +1,16 @@\n+// Part of issue #27300.\n+// The problem here is that ruby-style closures are parsed as blocks whose\n+// first statement is a closure. See the issue for more details:\n+// https://github.com/rust-lang/rust/issues/27300\n+\n+// Note: this test represents what the compiler currently emits. The error\n+// message will be improved later.\n+\n+fn main() {\n+    let p = Some(45).and_then({\n+        //~^ expected a `FnOnce<({integer},)>` closure, found `Option<_>`\n+        |x| println!(\"doubling {}\", x);\n+        Some(x * 2)\n+        //~^ ERROR: cannot find value `x` in this scope\n+    });\n+}"}, {"sha": "99df0632b4c3383bdf3a100e79ae754b4b2c0063", "filename": "src/test/ui/expr/malformed_closure/ruby_style_closure.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b21425de3c6be4264b875e68c8a28b424c27b8c4/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b21425de3c6be4264b875e68c8a28b424c27b8c4/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr?ref=b21425de3c6be4264b875e68c8a28b424c27b8c4", "patch": "@@ -0,0 +1,18 @@\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/ruby_style_closure.rs:13:14\n+   |\n+LL |         Some(x * 2)\n+   |              ^ not found in this scope\n+\n+error[E0277]: expected a `FnOnce<({integer},)>` closure, found `Option<_>`\n+  --> $DIR/ruby_style_closure.rs:10:22\n+   |\n+LL |     let p = Some(45).and_then({\n+   |                      ^^^^^^^^ expected an `FnOnce<({integer},)>` closure, found `Option<_>`\n+   |\n+   = help: the trait `FnOnce<({integer},)>` is not implemented for `Option<_>`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0277, E0425.\n+For more information about an error, try `rustc --explain E0277`."}]}