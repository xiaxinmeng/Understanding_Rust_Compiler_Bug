{"sha": "1e7ef03b40127b58692bc272a4b765c7a05bb851", "node_id": "C_kwDOAAsO6NoAKDFlN2VmMDNiNDAxMjdiNTg2OTJiYzI3MmE0Yjc2NWM3YTA1YmI4NTE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-22T22:19:41Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-22T22:23:16Z"}, "message": "Use ty_error_with_guaranteed in many more places", "tree": {"sha": "1c9baaf1ab1220a73db3c29d7817eafd25626c64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c9baaf1ab1220a73db3c29d7817eafd25626c64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e7ef03b40127b58692bc272a4b765c7a05bb851", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e7ef03b40127b58692bc272a4b765c7a05bb851", "html_url": "https://github.com/rust-lang/rust/commit/1e7ef03b40127b58692bc272a4b765c7a05bb851", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e7ef03b40127b58692bc272a4b765c7a05bb851/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdbc4329cb781c7768ffa6d76c8fa2d032d3fe20", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdbc4329cb781c7768ffa6d76c8fa2d032d3fe20", "html_url": "https://github.com/rust-lang/rust/commit/fdbc4329cb781c7768ffa6d76c8fa2d032d3fe20"}], "stats": {"total": 538, "additions": 309, "deletions": 229}, "files": [{"sha": "8f4c98e07cd42245b37d49f7a82212ae94550957", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -1,5 +1,6 @@\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::vec_map::VecMap;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n use rustc_infer::infer::TyCtxtInferExt as _;\n@@ -149,13 +150,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // once we convert the generic parameters to those of the opaque type.\n             if let Some(prev) = result.get_mut(&opaque_type_key.def_id) {\n                 if prev.ty != ty {\n-                    if !ty.references_error() {\n+                    let guar = ty.error_reported().err().unwrap_or_else(|| {\n                         prev.report_mismatch(\n                             &OpaqueHiddenType { ty, span: concrete_type.span },\n                             infcx.tcx,\n-                        );\n-                    }\n-                    prev.ty = infcx.tcx.ty_error();\n+                        )\n+                    });\n+                    prev.ty = infcx.tcx.ty_error_with_guaranteed(guar);\n                 }\n                 // Pick a better span if there is one.\n                 // FIXME(oli-obk): collect multiple spans for better diagnostics down the road.\n@@ -254,13 +255,13 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             .remap_generic_params_to_declaration_params(opaque_type_key, self.tcx, false)\n             .ty;\n \n-        if !check_opaque_type_parameter_valid(\n+        if let Err(guar) = check_opaque_type_parameter_valid(\n             self.tcx,\n             opaque_type_key,\n             origin,\n             instantiated_ty.span,\n         ) {\n-            return self.tcx.ty_error();\n+            return self.tcx.ty_error_with_guaranteed(guar);\n         }\n \n         // Only check this for TAIT. RPIT already supports `tests/ui/impl-trait/nested-return-type2.rs`\n@@ -335,7 +336,7 @@ fn check_opaque_type_parameter_valid(\n     opaque_type_key: OpaqueTypeKey<'_>,\n     origin: OpaqueTyOrigin,\n     span: Span,\n-) -> bool {\n+) -> Result<(), ErrorGuaranteed> {\n     match origin {\n         // No need to check return position impl trait (RPIT)\n         // because for type and const parameters they are correct\n@@ -358,7 +359,7 @@ fn check_opaque_type_parameter_valid(\n         // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n         //\n         // which would error here on all of the `'static` args.\n-        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n+        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return Ok(()),\n         // Check these\n         OpaqueTyOrigin::TyAlias => {}\n     }\n@@ -379,13 +380,13 @@ fn check_opaque_type_parameter_valid(\n             // Prevent `fn foo() -> Foo<u32>` from being defining.\n             let opaque_param = opaque_generics.param_at(i, tcx);\n             let kind = opaque_param.kind.descr();\n-            tcx.sess.emit_err(NonGenericOpaqueTypeParam {\n+\n+            return Err(tcx.sess.emit_err(NonGenericOpaqueTypeParam {\n                 ty: arg,\n                 kind,\n                 span,\n                 param_span: tcx.def_span(opaque_param.def_id),\n-            });\n-            return false;\n+            }));\n         }\n     }\n \n@@ -396,12 +397,13 @@ fn check_opaque_type_parameter_valid(\n                 .into_iter()\n                 .map(|i| tcx.def_span(opaque_generics.param_at(i, tcx).def_id))\n                 .collect();\n-            tcx.sess\n+            return Err(tcx\n+                .sess\n                 .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n                 .span_note(spans, &format!(\"{} used multiple times\", descr))\n-                .emit();\n-            return false;\n+                .emit());\n         }\n     }\n-    true\n+\n+    Ok(())\n }"}, {"sha": "72129af7ec44915f75b2dc9c8fb65743bfc973a2", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -270,12 +270,13 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                 .and(type_op::normalize::Normalize::new(ty))\n                 .fully_perform(self.infcx)\n                 .unwrap_or_else(|_| {\n-                    self.infcx\n+                    let guar = self\n+                        .infcx\n                         .tcx\n                         .sess\n                         .delay_span_bug(span, &format!(\"failed to normalize {:?}\", ty));\n                     TypeOpOutput {\n-                        output: self.infcx.tcx.ty_error(),\n+                        output: self.infcx.tcx.ty_error_with_guaranteed(guar),\n                         constraints: None,\n                         error_info: None,\n                     }"}, {"sha": "ccaf005964bfcecac733a300cf3dd3ac7a529274", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -529,9 +529,9 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         for elem in place.projection.iter() {\n             if place_ty.variant_index.is_none() {\n-                if place_ty.ty.references_error() {\n+                if let Err(guar) = place_ty.ty.error_reported() {\n                     assert!(self.errors_reported);\n-                    return PlaceTy::from_ty(self.tcx().ty_error());\n+                    return PlaceTy::from_ty(self.tcx().ty_error_with_guaranteed(guar));\n                 }\n             }\n             place_ty = self.sanitize_projection(place_ty, elem, place, location, context);"}, {"sha": "df6ee2b4badd8d7c4c81d1fe334cd25b0ac2d747", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -518,8 +518,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             .type_of(param.def_id)\n                             .no_bound_vars()\n                             .expect(\"const parameter types cannot be generic\");\n-                        if ty.references_error() {\n-                            return tcx.const_error(ty).into();\n+                        if let Err(guar) = ty.error_reported() {\n+                            return tcx.const_error_with_guaranteed(ty, guar).into();\n                         }\n                         if !infer_args && has_default {\n                             tcx.const_param_default(param.def_id).subst(tcx, substs.unwrap()).into()\n@@ -1579,15 +1579,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     false\n                 });\n                 if references_self {\n-                    tcx.sess\n+                    let guar = tcx\n+                        .sess\n                         .delay_span_bug(span, \"trait object projection bounds reference `Self`\");\n                     let substs: Vec<_> = b\n                         .projection_ty\n                         .substs\n                         .iter()\n                         .map(|arg| {\n                             if arg.walk().any(|arg| arg == dummy_self.into()) {\n-                                return tcx.ty_error().into();\n+                                return tcx.ty_error_with_guaranteed(guar).into();\n                             }\n                             arg\n                         })\n@@ -3064,7 +3065,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let ty = self.ast_ty_to_ty_inner(qself, false, true);\n                 self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, qself, segment, false)\n                     .map(|(ty, _, _)| ty)\n-                    .unwrap_or_else(|_| tcx.ty_error())\n+                    .unwrap_or_else(|guar| tcx.ty_error_with_guaranteed(guar))\n             }\n             &hir::TyKind::Path(hir::QPath::LangItem(lang_item, span, _)) => {\n                 let def_id = tcx.require_lang_item(lang_item, Some(span));"}, {"sha": "54cc81483e4719e47f74f08c745fdff53f873697", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -319,8 +319,8 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                 ItemKind::Impl(hir::Impl { self_ty, .. }) => {\n                     match self_ty.find_self_aliases() {\n                         spans if spans.len() > 0 => {\n-                            tcx.sess.emit_err(crate::errors::SelfInImplSelf { span: spans.into(), note: (), });\n-                            tcx.ty_error()\n+                            let guar = tcx.sess.emit_err(crate::errors::SelfInImplSelf { span: spans.into(), note: () });\n+                            tcx.ty_error_with_guaranteed(guar)\n                         },\n                         _ => icx.to_ty(*self_ty),\n                     }\n@@ -599,8 +599,11 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n             // // constant does not contain interior mutability.\n             // ```\n             let tables = self.tcx.typeck(item_def_id);\n-            if let Some(_) = tables.tainted_by_errors {\n-                self.found = Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error() });\n+            if let Some(guar) = tables.tainted_by_errors {\n+                self.found = Some(ty::OpaqueHiddenType {\n+                    span: DUMMY_SP,\n+                    ty: self.tcx.ty_error_with_guaranteed(guar),\n+                });\n                 return;\n             }\n             let Some(&typeck_hidden_ty) = tables.concrete_opaque_types.get(&self.def_id) else {\n@@ -618,8 +621,8 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n                 debug!(?concrete_type, \"found constraint\");\n                 if let Some(prev) = &mut self.found {\n                     if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n-                        prev.report_mismatch(&concrete_type, self.tcx);\n-                        prev.ty = self.tcx.ty_error();\n+                        let guar = prev.report_mismatch(&concrete_type, self.tcx);\n+                        prev.ty = self.tcx.ty_error_with_guaranteed(guar);\n                     }\n                 } else {\n                     self.found = Some(concrete_type);\n@@ -814,11 +817,11 @@ fn find_opaque_ty_constraints_for_rpit(\n \n     concrete.map(|concrete| concrete.ty).unwrap_or_else(|| {\n         let table = tcx.typeck(owner_def_id);\n-        if let Some(_) = table.tainted_by_errors {\n+        if let Some(guar) = table.tainted_by_errors {\n             // Some error in the\n             // owner fn prevented us from populating\n             // the `concrete_opaque_types` table.\n-            tcx.ty_error()\n+            tcx.ty_error_with_guaranteed(guar)\n         } else {\n             table.concrete_opaque_types.get(&def_id).map(|ty| ty.ty).unwrap_or_else(|| {\n                 // We failed to resolve the opaque type or it"}, {"sha": "07a48bea866c5661a7fe00f4fb889f98d3729231", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -3,6 +3,7 @@\n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use hir::def::DefKind;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir_analysis::astconv::AstConv;\n@@ -488,17 +489,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n         let expected_span =\n             expected_sig.cause_span.unwrap_or_else(|| self.tcx.def_span(expr_def_id));\n-        self.report_arg_count_mismatch(\n-            expected_span,\n-            closure_span,\n-            expected_args,\n-            found_args,\n-            true,\n-            closure_arg_span,\n-        )\n-        .emit();\n-\n-        let error_sig = self.error_sig_of_closure(decl);\n+        let guar = self\n+            .report_arg_count_mismatch(\n+                expected_span,\n+                closure_span,\n+                expected_args,\n+                found_args,\n+                true,\n+                closure_arg_span,\n+            )\n+            .emit();\n+\n+        let error_sig = self.error_sig_of_closure(decl, guar);\n \n         self.closure_sigs(expr_def_id, body, error_sig)\n     }\n@@ -792,13 +794,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Converts the types that the user supplied, in case that doing\n     /// so should yield an error, but returns back a signature where\n     /// all parameters are of type `TyErr`.\n-    fn error_sig_of_closure(&self, decl: &hir::FnDecl<'_>) -> ty::PolyFnSig<'tcx> {\n+    fn error_sig_of_closure(\n+        &self,\n+        decl: &hir::FnDecl<'_>,\n+        guar: ErrorGuaranteed,\n+    ) -> ty::PolyFnSig<'tcx> {\n         let astconv: &dyn AstConv<'_> = self;\n+        let err_ty = self.tcx.ty_error_with_guaranteed(guar);\n \n         let supplied_arguments = decl.inputs.iter().map(|a| {\n             // Convert the types that the user supplied (if any), but ignore them.\n             astconv.ast_ty_to_ty(a);\n-            self.tcx.ty_error()\n+            err_ty\n         });\n \n         if let hir::FnRetTy::Return(ref output) = decl.output {\n@@ -807,7 +814,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let result = ty::Binder::dummy(self.tcx.mk_fn_sig(\n             supplied_arguments,\n-            self.tcx.ty_error(),\n+            err_ty,\n             decl.c_variadic,\n             hir::Unsafety::Normal,\n             Abi::RustCall,"}, {"sha": "2ca710cb6935b143ac7e4f165217a0e615284cd8", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -170,14 +170,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         debug!(\"Coerce.tys({:?} => {:?})\", a, b);\n \n         // Just ignore error types.\n-        if a.references_error() || b.references_error() {\n+        if let Err(guar) = (a, b).error_reported() {\n             // Best-effort try to unify these types -- we're already on the error path,\n             // so this will have the side-effect of making sure we have no ambiguities\n             // due to `[type error]` and `_` not coercing together.\n             let _ = self.commit_if_ok(|_| {\n                 self.at(&self.cause, self.param_env).define_opaque_types(true).eq(a, b)\n             });\n-            return success(vec![], self.fcx.tcx.ty_error(), vec![]);\n+            return success(vec![], self.fcx.tcx.ty_error_with_guaranteed(guar), vec![]);\n         }\n \n         // Coercing from `!` to any type is allowed:\n@@ -997,7 +997,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (adjustments, _) = self.register_infer_ok_obligations(ok);\n         self.apply_adjustments(expr, adjustments);\n-        Ok(if expr_ty.references_error() { self.tcx.ty_error() } else { target })\n+        Ok(if let Err(guar) = expr_ty.error_reported() {\n+            self.tcx.ty_error_with_guaranteed(guar)\n+        } else {\n+            target\n+        })\n     }\n \n     /// Same as `try_coerce()`, but without side-effects.\n@@ -1434,8 +1438,8 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n \n         // If we see any error types, just propagate that error\n         // upwards.\n-        if expression_ty.references_error() || self.merged_ty().references_error() {\n-            self.final_ty = Some(fcx.tcx.ty_error());\n+        if let Err(guar) = (expression_ty, self.merged_ty()).error_reported() {\n+            self.final_ty = Some(fcx.tcx.ty_error_with_guaranteed(guar));\n             return;\n         }\n "}, {"sha": "efc0175b277858b4e9ebec55454f215392c10c34", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 59, "deletions": 40, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -1033,7 +1033,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         let result_ty = coerce.complete(self);\n-        if cond_ty.references_error() { self.tcx.ty_error() } else { result_ty }\n+        if let Err(guar) = cond_ty.error_reported() {\n+            self.tcx.ty_error_with_guaranteed(guar)\n+        } else {\n+            result_ty\n+        }\n     }\n \n     /// Type check assignment expression `expr` of form `lhs = rhs`.\n@@ -1155,8 +1159,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n \n-        if lhs_ty.references_error() || rhs_ty.references_error() {\n-            self.tcx.ty_error()\n+        if let Err(guar) = (lhs_ty, rhs_ty).error_reported() {\n+            self.tcx.ty_error_with_guaranteed(guar)\n         } else {\n             self.tcx.mk_unit()\n         }\n@@ -1274,8 +1278,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let t_expr = self.resolve_vars_if_possible(t_expr);\n \n         // Eagerly check for some obvious errors.\n-        if t_expr.references_error() || t_cast.references_error() {\n-            self.tcx.ty_error()\n+        if let Err(guar) = (t_expr, t_cast).error_reported() {\n+            self.tcx.ty_error_with_guaranteed(guar)\n         } else {\n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n@@ -1296,7 +1300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     deferred_cast_checks.push(cast_check);\n                     t_cast\n                 }\n-                Err(_) => self.tcx.ty_error(),\n+                Err(guar) => self.tcx.ty_error_with_guaranteed(guar),\n             }\n         }\n     }\n@@ -1423,8 +1427,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n-        if element_ty.references_error() {\n-            return tcx.ty_error();\n+        if let Err(guar) = element_ty.error_reported() {\n+            return tcx.ty_error_with_guaranteed(guar);\n         }\n \n         self.check_repeat_element_needs_copy_bound(element, count, element_ty);\n@@ -1493,8 +1497,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => self.check_expr_with_expectation(&e, NoExpectation),\n         });\n         let tuple = self.tcx.mk_tup(elt_ts_iter);\n-        if tuple.references_error() {\n-            self.tcx.ty_error()\n+        if let Err(guar) = tuple.error_reported() {\n+            self.tcx.ty_error_with_guaranteed(guar)\n         } else {\n             self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n             tuple\n@@ -1510,9 +1514,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base_expr: &'tcx Option<&'tcx hir::Expr<'tcx>>,\n     ) -> Ty<'tcx> {\n         // Find the relevant variant\n-        let Some((variant, adt_ty)) = self.check_struct_path(qpath, expr.hir_id) else {\n-            self.check_struct_fields_on_error(fields, base_expr);\n-            return self.tcx.ty_error();\n+        let (variant, adt_ty) = match self.check_struct_path(qpath, expr.hir_id) {\n+            Ok(data) => data,\n+            Err(guar) => {\n+                self.check_struct_fields_on_error(fields, base_expr);\n+                return self.tcx.ty_error_with_guaranteed(guar);\n+            }\n         };\n \n         // Prohibit struct expressions when non-exhaustive flag is set.\n@@ -1594,12 +1601,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.field_ty(field.span, v_field, substs)\n             } else {\n                 error_happened = true;\n-                if let Some(prev_span) = seen_fields.get(&ident) {\n+                let guar = if let Some(prev_span) = seen_fields.get(&ident) {\n                     tcx.sess.emit_err(FieldMultiplySpecifiedInInitializer {\n                         span: field.ident.span,\n                         prev_span: *prev_span,\n                         ident,\n-                    });\n+                    })\n                 } else {\n                     self.report_unknown_field(\n                         adt_ty,\n@@ -1608,10 +1615,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ast_fields,\n                         adt.variant_descr(),\n                         expr_span,\n-                    );\n-                }\n+                    )\n+                };\n \n-                tcx.ty_error()\n+                tcx.ty_error_with_guaranteed(guar)\n             };\n \n             // Make sure to give a type to the field even if there's\n@@ -1994,14 +2001,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         skip_fields: &[hir::ExprField<'_>],\n         kind_name: &str,\n         expr_span: Span,\n-    ) {\n+    ) -> ErrorGuaranteed {\n         if variant.is_recovered() {\n-            self.set_tainted_by_errors(\n-                self.tcx\n-                    .sess\n-                    .delay_span_bug(expr_span, \"parser recovered but no error was emitted\"),\n-            );\n-            return;\n+            let guar = self\n+                .tcx\n+                .sess\n+                .delay_span_bug(expr_span, \"parser recovered but no error was emitted\");\n+            self.set_tainted_by_errors(guar);\n+            return guar;\n         }\n         let mut err = self.err_ctxt().type_error_struct_with_diag(\n             field.ident.span,\n@@ -2115,7 +2122,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n             }\n         }\n-        err.emit();\n+        err.emit()\n     }\n \n     // Return a hint about the closest match in field names\n@@ -2256,21 +2263,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // (#90483) apply adjustments to avoid ExprUseVisitor from\n             // creating erroneous projection.\n             self.apply_adjustments(base, adjustments);\n-            self.ban_private_field_access(expr, base_ty, field, did, expected.only_has_type(self));\n-            return self.tcx().ty_error();\n+            let guar = self.ban_private_field_access(\n+                expr,\n+                base_ty,\n+                field,\n+                did,\n+                expected.only_has_type(self),\n+            );\n+            return self.tcx().ty_error_with_guaranteed(guar);\n         }\n \n-        if field.name == kw::Empty {\n+        let guar = if field.name == kw::Empty {\n+            self.tcx.sess.delay_span_bug(field.span, \"field name with no name\")\n         } else if self.method_exists(\n             field,\n             base_ty,\n             expr.hir_id,\n             true,\n             expected.only_has_type(self),\n         ) {\n-            self.ban_take_value_of_method(expr, base_ty, field);\n+            self.ban_take_value_of_method(expr, base_ty, field)\n         } else if !base_ty.is_primitive_ty() {\n-            self.ban_nonexisting_field(field, base, expr, base_ty);\n+            self.ban_nonexisting_field(field, base, expr, base_ty)\n         } else {\n             let field_name = field.to_string();\n             let mut err = type_error_struct!(\n@@ -2339,10 +2353,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                 }\n             }\n-            err.emit();\n-        }\n+            err.emit()\n+        };\n \n-        self.tcx().ty_error()\n+        self.tcx().ty_error_with_guaranteed(guar)\n     }\n \n     fn suggest_await_on_field_access(\n@@ -2388,7 +2402,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base: &'tcx hir::Expr<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n         base_ty: Ty<'tcx>,\n-    ) {\n+    ) -> ErrorGuaranteed {\n         debug!(\n             \"ban_nonexisting_field: field={:?}, base={:?}, expr={:?}, base_ty={:?}\",\n             ident, base, expr, base_ty\n@@ -2436,7 +2450,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             HelpUseLatestEdition::new().add_to_diagnostic(&mut err);\n         }\n \n-        err.emit();\n+        err.emit()\n     }\n \n     fn ban_private_field_access(\n@@ -2446,7 +2460,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: Ident,\n         base_did: DefId,\n         return_ty: Option<Ty<'tcx>>,\n-    ) {\n+    ) -> ErrorGuaranteed {\n         let struct_path = self.tcx().def_path_str(base_did);\n         let kind_name = self.tcx().def_kind(base_did).descr(base_did);\n         let mut err = struct_span_err!(\n@@ -2469,10 +2483,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 None,\n             );\n         }\n-        err.emit();\n+        err.emit()\n     }\n \n-    fn ban_take_value_of_method(&self, expr: &hir::Expr<'tcx>, expr_t: Ty<'tcx>, field: Ident) {\n+    fn ban_take_value_of_method(\n+        &self,\n+        expr: &hir::Expr<'tcx>,\n+        expr_t: Ty<'tcx>,\n+        field: Ident,\n+    ) -> ErrorGuaranteed {\n         let mut err = type_error_struct!(\n             self.tcx().sess,\n             field.span,\n@@ -2544,7 +2563,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.help(\"methods are immutable and cannot be assigned to\");\n         }\n \n-        err.emit();\n+        err.emit()\n     }\n \n     fn point_at_param_definition(&self, err: &mut Diagnostic, param: ty::ParamTy) {"}, {"sha": "25acc23f323704f648bfb19e23f8b89a2cdeac1a", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -701,7 +701,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub(in super::super) fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {\n-        vec![self.tcx.ty_error(); len]\n+        let ty_error = self.tcx.ty_error();\n+        vec![ty_error; len]\n     }\n \n     /// Unifies the output type with the expected type early, for more coercions"}, {"sha": "d724fe2008067665923074b53ec398e7662a2cb8", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -10,7 +10,9 @@ use crate::{\n };\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_errors::{pluralize, Applicability, Diagnostic, DiagnosticId, MultiSpan};\n+use rustc_errors::{\n+    pluralize, Applicability, Diagnostic, DiagnosticId, ErrorGuaranteed, MultiSpan,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -1294,15 +1296,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         qpath: &QPath<'_>,\n         hir_id: hir::HirId,\n-    ) -> Option<(&'tcx ty::VariantDef, Ty<'tcx>)> {\n+    ) -> Result<(&'tcx ty::VariantDef, Ty<'tcx>), ErrorGuaranteed> {\n         let path_span = qpath.span();\n         let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, hir_id);\n         let variant = match def {\n             Res::Err => {\n-                self.set_tainted_by_errors(\n-                    self.tcx.sess.delay_span_bug(path_span, \"`Res::Err` but no error emitted\"),\n-                );\n-                return None;\n+                let guar =\n+                    self.tcx.sess.delay_span_bug(path_span, \"`Res::Err` but no error emitted\");\n+                self.set_tainted_by_errors(guar);\n+                return Err(guar);\n             }\n             Res::Def(DefKind::Variant, _) => match ty.normalized.ty_adt_def() {\n                 Some(adt) => {\n@@ -1330,28 +1332,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Check bounds on type arguments used in the path.\n             self.add_required_obligations_for_hir(path_span, did, substs, hir_id);\n \n-            Some((variant, ty.normalized))\n+            Ok((variant, ty.normalized))\n         } else {\n-            match ty.normalized.kind() {\n-                ty::Error(_) => {\n+            Err(match *ty.normalized.kind() {\n+                ty::Error(guar) => {\n                     // E0071 might be caused by a spelling error, which will have\n                     // already caused an error message and probably a suggestion\n                     // elsewhere. Refrain from emitting more unhelpful errors here\n                     // (issue #88844).\n+                    guar\n                 }\n-                _ => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        path_span,\n-                        E0071,\n-                        \"expected struct, variant or union type, found {}\",\n-                        ty.normalized.sort_string(self.tcx)\n-                    )\n-                    .span_label(path_span, \"not a struct\")\n-                    .emit();\n-                }\n-            }\n-            None\n+                _ => struct_span_err!(\n+                    self.tcx.sess,\n+                    path_span,\n+                    E0071,\n+                    \"expected struct, variant or union type, found {}\",\n+                    ty.normalized.sort_string(self.tcx)\n+                )\n+                .span_label(path_span, \"not a struct\")\n+                .emit(),\n+            })\n         }\n     }\n \n@@ -1715,9 +1715,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat: &'tcx hir::Pat<'tcx>,\n         ty: Ty<'tcx>,\n     ) {\n-        if ty.references_error() {\n+        if let Err(guar) = ty.error_reported() {\n             // Override the types everywhere with `err()` to avoid knock on errors.\n-            let err = self.tcx.ty_error();\n+            let err = self.tcx.ty_error_with_guaranteed(guar);\n             self.write_ty(hir_id, err);\n             self.write_ty(pat.hir_id, err);\n             let local_ty = LocalTy { decl_ty: err, revealed_ty: err };\n@@ -1746,7 +1746,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let result = self\n                     .astconv()\n                     .associated_path_to_ty(hir_id, path_span, ty.raw, qself, segment, true);\n-                let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n+                let ty = result\n+                    .map(|(ty, _, _)| ty)\n+                    .unwrap_or_else(|guar| self.tcx().ty_error_with_guaranteed(guar));\n                 let ty = self.handle_raw_ty(path_span, ty);\n                 let result = result.map(|(_, kind, def_id)| (kind, def_id));\n "}, {"sha": "2ce2a3ca29982bd199dd8be71d375678de7f99ab", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -631,7 +631,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             Err(errors) => {\n                 let actual = self.resolve_vars_if_possible(operand_ty);\n-                if !actual.references_error() {\n+                let guar = actual.error_reported().err().unwrap_or_else(|| {\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,\n                         ex.span,\n@@ -701,9 +701,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    err.emit();\n-                }\n-                self.tcx.ty_error()\n+                    err.emit()\n+                });\n+                self.tcx.ty_error_with_guaranteed(guar)\n             }\n         }\n     }"}, {"sha": "23f4ba5559cf55488f01ef677aea4ae9bc3d4f56", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 128, "deletions": 94, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -475,8 +475,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let (Some((true, ..)), _) | (_, Some((true, ..))) = (lhs, rhs) {\n             // There exists a side that didn't meet our criteria that the end-point\n             // be of a numeric or char type, as checked in `calc_side` above.\n-            self.emit_err_pat_range(span, lhs, rhs);\n-            return self.tcx.ty_error();\n+            let guar = self.emit_err_pat_range(span, lhs, rhs);\n+            return self.tcx.ty_error_with_guaranteed(guar);\n         }\n \n         // Unify each side with `expected`.\n@@ -511,8 +511,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let Some((ref mut fail, _, _)) = rhs {\n                 *fail = true;\n             }\n-            self.emit_err_pat_range(span, lhs, rhs);\n-            return self.tcx.ty_error();\n+            let guar = self.emit_err_pat_range(span, lhs, rhs);\n+            return self.tcx.ty_error_with_guaranteed(guar);\n         }\n         ty\n     }\n@@ -528,7 +528,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         lhs: Option<(bool, Ty<'tcx>, Span)>,\n         rhs: Option<(bool, Ty<'tcx>, Span)>,\n-    ) {\n+    ) -> ErrorGuaranteed {\n         let span = match (lhs, rhs) {\n             (Some((true, ..)), Some((true, ..))) => span,\n             (Some((true, _, sp)), _) => sp,\n@@ -573,7 +573,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     type between two end-points, you can use a guard.\",\n             );\n         }\n-        err.emit();\n+        err.emit()\n     }\n \n     fn check_pat_ident(\n@@ -807,29 +807,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn check_dereferenceable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat<'_>) -> bool {\n+    pub fn check_dereferenceable(\n+        &self,\n+        span: Span,\n+        expected: Ty<'tcx>,\n+        inner: &Pat<'_>,\n+    ) -> Result<(), ErrorGuaranteed> {\n         if let PatKind::Binding(..) = inner.kind\n             && let Some(mt) = self.shallow_resolve(expected).builtin_deref(true)\n             && let ty::Dynamic(..) = mt.ty.kind()\n         {\n-                    // This is \"x = SomeTrait\" being reduced from\n-                    // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n-                    let type_str = self.ty_to_string(expected);\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0033,\n-                        \"type `{}` cannot be dereferenced\",\n-                        type_str\n-                    );\n-                    err.span_label(span, format!(\"type `{type_str}` cannot be dereferenced\"));\n-                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(CANNOT_IMPLICITLY_DEREF_POINTER_TRAIT_OBJ);\n-                    }\n-                    err.emit();\n-                    return false;\n-                }\n-        true\n+            // This is \"x = SomeTrait\" being reduced from\n+            // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n+            let type_str = self.ty_to_string(expected);\n+            let mut err = struct_span_err!(\n+                self.tcx.sess,\n+                span,\n+                E0033,\n+                \"type `{}` cannot be dereferenced\",\n+                type_str\n+            );\n+            err.span_label(span, format!(\"type `{type_str}` cannot be dereferenced\"));\n+            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                err.note(CANNOT_IMPLICITLY_DEREF_POINTER_TRAIT_OBJ);\n+            }\n+            return Err(err.emit());\n+        }\n+        Ok(())\n     }\n \n     fn check_pat_struct(\n@@ -843,13 +847,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         // Resolve the path and check the definition for errors.\n-        let Some((variant, pat_ty)) = self.check_struct_path(qpath, pat.hir_id) else {\n-            let err = self.tcx.ty_error();\n-            for field in fields {\n-                let ti = ti;\n-                self.check_pat(field.pat, err, def_bm, ti);\n+        let (variant, pat_ty) = match self.check_struct_path(qpath, pat.hir_id) {\n+            Ok(data) => data,\n+            Err(guar) => {\n+                let err = self.tcx.ty_error_with_guaranteed(guar);\n+                for field in fields {\n+                    let ti = ti;\n+                    self.check_pat(field.pat, err, def_bm, ti);\n+                }\n+                return err;\n             }\n-            return err;\n         };\n \n         // Type-check the path.\n@@ -1349,9 +1356,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let ident = tcx.adjust_ident(field.ident, variant.def_id);\n             let field_ty = match used_fields.entry(ident) {\n                 Occupied(occupied) => {\n-                    self.error_field_already_bound(span, field.ident, *occupied.get());\n                     no_field_errors = false;\n-                    tcx.ty_error()\n+                    let guar = self.error_field_already_bound(span, field.ident, *occupied.get());\n+                    tcx.ty_error_with_guaranteed(guar)\n                 }\n                 Vacant(vacant) => {\n                     vacant.insert(span);\n@@ -1536,7 +1543,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn error_field_already_bound(&self, span: Span, ident: Ident, other_field: Span) {\n+    fn error_field_already_bound(\n+        &self,\n+        span: Span,\n+        ident: Ident,\n+        other_field: Span,\n+    ) -> ErrorGuaranteed {\n         struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -1546,7 +1558,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n         .span_label(span, format!(\"multiple uses of `{ident}` in pattern\"))\n         .span_label(other_field, format!(\"first use of `{ident}`\"))\n-        .emit();\n+        .emit()\n     }\n \n     fn error_inexistent_fields(\n@@ -1919,19 +1931,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n-        let (box_ty, inner_ty) = if self.check_dereferenceable(span, expected, inner) {\n-            // Here, `demand::subtype` is good enough, but I don't\n-            // think any errors can be introduced by using `demand::eqtype`.\n-            let inner_ty = self.next_ty_var(TypeVariableOrigin {\n-                kind: TypeVariableOriginKind::TypeInference,\n-                span: inner.span,\n-            });\n-            let box_ty = tcx.mk_box(inner_ty);\n-            self.demand_eqtype_pat(span, expected, box_ty, ti);\n-            (box_ty, inner_ty)\n-        } else {\n-            let err = tcx.ty_error();\n-            (err, err)\n+        let (box_ty, inner_ty) = match self.check_dereferenceable(span, expected, inner) {\n+            Ok(()) => {\n+                // Here, `demand::subtype` is good enough, but I don't\n+                // think any errors can be introduced by using `demand::eqtype`.\n+                let inner_ty = self.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeInference,\n+                    span: inner.span,\n+                });\n+                let box_ty = tcx.mk_box(inner_ty);\n+                self.demand_eqtype_pat(span, expected, box_ty, ti);\n+                (box_ty, inner_ty)\n+            }\n+            Err(guar) => {\n+                let err = tcx.ty_error_with_guaranteed(guar);\n+                (err, err)\n+            }\n         };\n         self.check_pat(inner, inner_ty, def_bm, ti);\n         box_ty\n@@ -1949,37 +1964,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected = self.shallow_resolve(expected);\n-        let (ref_ty, inner_ty) = if self.check_dereferenceable(pat.span, expected, inner) {\n-            // `demand::subtype` would be good enough, but using `eqtype` turns\n-            // out to be equally general. See (note_1) for details.\n-\n-            // Take region, inner-type from expected type if we can,\n-            // to avoid creating needless variables. This also helps with\n-            // the bad interactions of the given hack detailed in (note_1).\n-            debug!(\"check_pat_ref: expected={:?}\", expected);\n-            match *expected.kind() {\n-                ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => (expected, r_ty),\n-                _ => {\n-                    let inner_ty = self.next_ty_var(TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeInference,\n-                        span: inner.span,\n-                    });\n-                    let ref_ty = self.new_ref_ty(pat.span, mutbl, inner_ty);\n-                    debug!(\"check_pat_ref: demanding {:?} = {:?}\", expected, ref_ty);\n-                    let err = self.demand_eqtype_pat_diag(pat.span, expected, ref_ty, ti);\n-\n-                    // Look for a case like `fn foo(&foo: u32)` and suggest\n-                    // `fn foo(foo: &u32)`\n-                    if let Some(mut err) = err {\n-                        self.borrow_pat_suggestion(&mut err, pat);\n-                        err.emit();\n+        let (ref_ty, inner_ty) = match self.check_dereferenceable(pat.span, expected, inner) {\n+            Ok(()) => {\n+                // `demand::subtype` would be good enough, but using `eqtype` turns\n+                // out to be equally general. See (note_1) for details.\n+\n+                // Take region, inner-type from expected type if we can,\n+                // to avoid creating needless variables. This also helps with\n+                // the bad interactions of the given hack detailed in (note_1).\n+                debug!(\"check_pat_ref: expected={:?}\", expected);\n+                match *expected.kind() {\n+                    ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => (expected, r_ty),\n+                    _ => {\n+                        let inner_ty = self.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeInference,\n+                            span: inner.span,\n+                        });\n+                        let ref_ty = self.new_ref_ty(pat.span, mutbl, inner_ty);\n+                        debug!(\"check_pat_ref: demanding {:?} = {:?}\", expected, ref_ty);\n+                        let err = self.demand_eqtype_pat_diag(pat.span, expected, ref_ty, ti);\n+\n+                        // Look for a case like `fn foo(&foo: u32)` and suggest\n+                        // `fn foo(foo: &u32)`\n+                        if let Some(mut err) = err {\n+                            self.borrow_pat_suggestion(&mut err, pat);\n+                            err.emit();\n+                        }\n+                        (ref_ty, inner_ty)\n                     }\n-                    (ref_ty, inner_ty)\n                 }\n             }\n-        } else {\n-            let err = tcx.ty_error();\n-            (err, err)\n+            Err(guar) => {\n+                let err = tcx.ty_error_with_guaranteed(guar);\n+                (err, err)\n+            }\n         };\n         self.check_pat(inner, inner_ty, def_bm, ti);\n         ref_ty\n@@ -2027,10 +2045,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Slice(element_ty) => (element_ty, Some(expected), expected),\n             // The expected type must be an array or slice, but was neither, so error.\n             _ => {\n-                if !expected.references_error() {\n-                    self.error_expected_array_or_slice(span, expected, ti);\n-                }\n-                let err = self.tcx.ty_error();\n+                let guar = expected\n+                    .error_reported()\n+                    .err()\n+                    .unwrap_or_else(|| self.error_expected_array_or_slice(span, expected, ti));\n+                let err = self.tcx.ty_error_with_guaranteed(guar);\n                 (err, Some(err), err)\n             }\n         };\n@@ -2063,7 +2082,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         len: ty::Const<'tcx>,\n         min_len: u64,\n     ) -> (Option<Ty<'tcx>>, Ty<'tcx>) {\n-        if let Some(len) = len.try_eval_target_usize(self.tcx, self.param_env) {\n+        let guar = if let Some(len) = len.try_eval_target_usize(self.tcx, self.param_env) {\n             // Now we know the length...\n             if slice.is_none() {\n                 // ...and since there is no variable-length pattern,\n@@ -2073,15 +2092,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     return (None, arr_ty);\n                 }\n \n-                self.error_scrutinee_inconsistent_length(span, min_len, len);\n+                self.error_scrutinee_inconsistent_length(span, min_len, len)\n             } else if let Some(pat_len) = len.checked_sub(min_len) {\n                 // The variable-length pattern was there,\n                 // so it has an array type with the remaining elements left as its size...\n                 return (Some(self.tcx.mk_array(element_ty, pat_len)), arr_ty);\n             } else {\n                 // ...however, in this case, there were no remaining elements.\n                 // That is, the slice pattern requires more than the array type offers.\n-                self.error_scrutinee_with_rest_inconsistent_length(span, min_len, len);\n+                self.error_scrutinee_with_rest_inconsistent_length(span, min_len, len)\n             }\n         } else if slice.is_none() {\n             // We have a pattern with a fixed length,\n@@ -2093,14 +2112,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // We have a variable-length pattern and don't know the array length.\n             // This happens if we have e.g.,\n             // `let [a, b, ..] = arr` where `arr: [T; N]` where `const N: usize`.\n-            self.error_scrutinee_unfixed_length(span);\n-        }\n+            self.error_scrutinee_unfixed_length(span)\n+        };\n \n         // If we get here, we must have emitted an error.\n-        (Some(self.tcx.ty_error()), arr_ty)\n+        (Some(self.tcx.ty_error_with_guaranteed(guar)), arr_ty)\n     }\n \n-    fn error_scrutinee_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {\n+    fn error_scrutinee_inconsistent_length(\n+        &self,\n+        span: Span,\n+        min_len: u64,\n+        size: u64,\n+    ) -> ErrorGuaranteed {\n         struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -2111,10 +2135,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             size,\n         )\n         .span_label(span, format!(\"expected {} element{}\", size, pluralize!(size)))\n-        .emit();\n+        .emit()\n     }\n \n-    fn error_scrutinee_with_rest_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {\n+    fn error_scrutinee_with_rest_inconsistent_length(\n+        &self,\n+        span: Span,\n+        min_len: u64,\n+        size: u64,\n+    ) -> ErrorGuaranteed {\n         struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -2128,20 +2157,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             span,\n             format!(\"pattern cannot match array of {} element{}\", size, pluralize!(size),),\n         )\n-        .emit();\n+        .emit()\n     }\n \n-    fn error_scrutinee_unfixed_length(&self, span: Span) {\n+    fn error_scrutinee_unfixed_length(&self, span: Span) -> ErrorGuaranteed {\n         struct_span_err!(\n             self.tcx.sess,\n             span,\n             E0730,\n             \"cannot pattern-match on an array without a fixed length\",\n         )\n-        .emit();\n+        .emit()\n     }\n \n-    fn error_expected_array_or_slice(&self, span: Span, expected_ty: Ty<'tcx>, ti: TopInfo<'tcx>) {\n+    fn error_expected_array_or_slice(\n+        &self,\n+        span: Span,\n+        expected_ty: Ty<'tcx>,\n+        ti: TopInfo<'tcx>,\n+    ) -> ErrorGuaranteed {\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -2185,7 +2219,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n         err.span_label(span, format!(\"pattern cannot match with input type `{expected_ty}`\"));\n-        err.emit();\n+        err.emit()\n     }\n \n     fn is_slice_or_array_or_vector(&self, ty: Ty<'tcx>) -> (bool, Ty<'tcx>) {"}, {"sha": "c8b1c7f76f40d1f168190e99a8a4f3a568fd3878", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -35,6 +35,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, DocLinkResMap, LifetimeRes, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LocalDefIdMap};\n@@ -1358,7 +1359,7 @@ pub struct OpaqueHiddenType<'tcx> {\n }\n \n impl<'tcx> OpaqueHiddenType<'tcx> {\n-    pub fn report_mismatch(&self, other: &Self, tcx: TyCtxt<'tcx>) {\n+    pub fn report_mismatch(&self, other: &Self, tcx: TyCtxt<'tcx>) -> ErrorGuaranteed {\n         // Found different concrete types for the opaque type.\n         let sub_diag = if self.span == other.span {\n             TypeMismatchReason::ConflictType { span: self.span }\n@@ -1370,7 +1371,7 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n             other_ty: other.ty,\n             other_span: other.span,\n             sub: sub_diag,\n-        });\n+        })\n     }\n \n     #[instrument(level = \"debug\", skip(tcx), ret)]"}, {"sha": "cc00844d974e5c70c7fe1dfb3073dade49b9a273", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -639,7 +639,7 @@ fn construct_error(\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def);\n     let generator_kind = tcx.generator_kind(def);\n \n-    let ty = tcx.ty_error();\n+    let ty = tcx.ty_error_with_guaranteed(err);\n     let num_params = match body_owner_kind {\n         hir::BodyOwnerKind::Fn => tcx.fn_sig(def).skip_binder().inputs().skip_binder().len(),\n         hir::BodyOwnerKind::Closure => {"}, {"sha": "ceea9d6cbffca28d5e03224a3621f1af6cff879d", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -1213,8 +1213,8 @@ struct Progress<'tcx> {\n }\n \n impl<'tcx> Progress<'tcx> {\n-    fn error(tcx: TyCtxt<'tcx>) -> Self {\n-        Progress { term: tcx.ty_error().into(), obligations: vec![] }\n+    fn error(tcx: TyCtxt<'tcx>, guar: ErrorGuaranteed) -> Self {\n+        Progress { term: tcx.ty_error_with_guaranteed(guar).into(), obligations: vec![] }\n     }\n \n     fn with_addl_obligations(mut self, mut obligations: Vec<PredicateObligation<'tcx>>) -> Self {\n@@ -1240,8 +1240,8 @@ fn project<'cx, 'tcx>(\n         )));\n     }\n \n-    if obligation.predicate.references_error() {\n-        return Ok(Projected::Progress(Progress::error(selcx.tcx())));\n+    if let Err(guar) = obligation.predicate.error_reported() {\n+        return Ok(Projected::Progress(Progress::error(selcx.tcx(), guar)));\n     }\n \n     let mut candidates = ProjectionCandidateSet::None;\n@@ -2097,8 +2097,9 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n \n     let param_env = obligation.param_env;\n-    let Ok(assoc_ty) = specialization_graph::assoc_def(tcx, impl_def_id, assoc_item_id) else {\n-        return Progress { term: tcx.ty_error().into(), obligations: nested };\n+    let assoc_ty = match specialization_graph::assoc_def(tcx, impl_def_id, assoc_item_id) {\n+        Ok(assoc_ty) => assoc_ty,\n+        Err(guar) => return Progress::error(tcx, guar),\n     };\n \n     if !assoc_ty.item.defaultness(tcx).has_value() {\n@@ -2194,8 +2195,9 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n     let mut obligations = data.nested;\n \n     let trait_fn_def_id = tcx.impl_trait_in_trait_parent(obligation.predicate.def_id);\n-    let Ok(leaf_def) = specialization_graph::assoc_def(tcx, data.impl_def_id, trait_fn_def_id) else {\n-        return Progress { term: tcx.ty_error().into(), obligations };\n+    let leaf_def = match specialization_graph::assoc_def(tcx, data.impl_def_id, trait_fn_def_id) {\n+        Ok(assoc_ty) => assoc_ty,\n+        Err(guar) => return Progress::error(tcx, guar),\n     };\n     if !leaf_def.item.defaultness(tcx).has_value() {\n         return Progress { term: tcx.ty_error().into(), obligations };\n@@ -2269,7 +2271,10 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n         obligation.recursion_depth + 1,\n         tcx.bound_return_position_impl_trait_in_trait_tys(impl_fn_def_id)\n             .map_bound(|tys| {\n-                tys.map_or_else(|_| tcx.ty_error(), |tys| tys[&obligation.predicate.def_id])\n+                tys.map_or_else(\n+                    |guar| tcx.ty_error_with_guaranteed(guar),\n+                    |tys| tys[&obligation.predicate.def_id],\n+                )\n             })\n             .subst(tcx, impl_fn_substs),\n         &mut obligations,"}, {"sha": "e3e0740f4100d4f53c8b9c7d69111d86bf525c59", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7ef03b40127b58692bc272a4b765c7a05bb851/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=1e7ef03b40127b58692bc272a4b765c7a05bb851", "patch": "@@ -2443,15 +2443,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // the placeholder trait ref may fail due the Generalizer relation\n                 // raising a CyclicalTy error due to a sub_root_var relation\n                 // for a variable being generalized...\n-                self.infcx.tcx.sess.delay_span_bug(\n+                let guar = self.infcx.tcx.sess.delay_span_bug(\n                     obligation.cause.span,\n                     &format!(\n                         \"Impl {:?} was matchable against {:?} but now is not\",\n                         impl_def_id, obligation\n                     ),\n                 );\n                 let value = self.infcx.fresh_substs_for_item(obligation.cause.span, impl_def_id);\n-                let err = self.tcx().ty_error();\n+                let err = self.tcx().ty_error_with_guaranteed(guar);\n                 let value = value.fold_with(&mut BottomUpFolder {\n                     tcx: self.tcx(),\n                     ty_op: |_| err,"}]}