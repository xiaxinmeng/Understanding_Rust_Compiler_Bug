{"sha": "477c16d45bb93cc92611b56614ce2b823bffab8d", "node_id": "C_kwDOAAsO6NoAKDQ3N2MxNmQ0NWJiOTNjYzkyNjExYjU2NjE0Y2UyYjgyM2JmZmFiOGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-19T15:08:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-19T15:08:49Z"}, "message": "Auto merge of #8957 - Jarcho:more_pass_merges, r=flip1995\n\nMore lint pass merges\n\nchangelog: None", "tree": {"sha": "fa7593746fa6f1b1fd402c79d1c342c8a495cf92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa7593746fa6f1b1fd402c79d1c342c8a495cf92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/477c16d45bb93cc92611b56614ce2b823bffab8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/477c16d45bb93cc92611b56614ce2b823bffab8d", "html_url": "https://github.com/rust-lang/rust/commit/477c16d45bb93cc92611b56614ce2b823bffab8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/477c16d45bb93cc92611b56614ce2b823bffab8d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "868dba9f65a40ffd406baba9ca301b4dc33ff641", "url": "https://api.github.com/repos/rust-lang/rust/commits/868dba9f65a40ffd406baba9ca301b4dc33ff641", "html_url": "https://github.com/rust-lang/rust/commit/868dba9f65a40ffd406baba9ca301b4dc33ff641"}, {"sha": "d8808db006cf4fde950076f1112ca465bcaf72ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8808db006cf4fde950076f1112ca465bcaf72ef", "html_url": "https://github.com/rust-lang/rust/commit/d8808db006cf4fde950076f1112ca465bcaf72ef"}], "stats": {"total": 3642, "additions": 1727, "deletions": 1915}, "files": [{"sha": "5b4b2c631c89cd97df28d7e475934b38f19bbb18", "filename": "clippy_lints/src/as_underscore.rs", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fas_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fas_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fas_underscore.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,74 +0,0 @@\n-use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, TyKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Check for the usage of `as _` conversion using inferred type.\n-    ///\n-    /// ### Why is this bad?\n-    /// The conversion might include lossy conversion and dangerous cast that might go\n-    /// undetected due to the type being inferred.\n-    ///\n-    /// The lint is allowed by default as using `_` is less wordy than always specifying the type.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// fn foo(n: usize) {}\n-    /// let n: u16 = 256;\n-    /// foo(n as _);\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// fn foo(n: usize) {}\n-    /// let n: u16 = 256;\n-    /// foo(n as usize);\n-    /// ```\n-    #[clippy::version = \"1.63.0\"]\n-    pub AS_UNDERSCORE,\n-    restriction,\n-    \"detects `as _` conversion\"\n-}\n-declare_lint_pass!(AsUnderscore => [AS_UNDERSCORE]);\n-\n-impl<'tcx> LateLintPass<'tcx> for AsUnderscore {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n-        if in_external_macro(cx.sess(), expr.span) {\n-            return;\n-        }\n-\n-        if let ExprKind::Cast(_, ty) = expr.kind && let TyKind::Infer = ty.kind {\n-\n-            let ty_resolved = cx.typeck_results().expr_ty(expr);\n-            if let ty::Error(_) = ty_resolved.kind() {\n-                span_lint_and_help(\n-                    cx,\n-                AS_UNDERSCORE,\n-                expr.span,\n-                \"using `as _` conversion\",\n-                None,\n-                \"consider giving the type explicitly\",\n-                );\n-            } else {\n-            span_lint_and_then(\n-                cx,\n-                AS_UNDERSCORE,\n-                expr.span,\n-                \"using `as _` conversion\",\n-                |diag| {\n-                    diag.span_suggestion(\n-                        ty.span,\n-                        \"consider giving the type explicitly\",\n-                        ty_resolved,\n-                        Applicability::MachineApplicable,\n-                    );\n-            }\n-            );\n-        }\n-        }\n-    }\n-}"}, {"sha": "0993adbae2e6bfdb37c27b85335549c83c773dc9", "filename": "clippy_lints/src/borrow_as_ptr.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fborrow_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fborrow_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fborrow_as_ptr.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,99 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_no_std_crate;\n-use clippy_utils::source::snippet_opt;\n-use clippy_utils::{meets_msrv, msrvs};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, TyKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_semver::RustcVersion;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for the usage of `&expr as *const T` or\n-    /// `&mut expr as *mut T`, and suggest using `ptr::addr_of` or\n-    /// `ptr::addr_of_mut` instead.\n-    ///\n-    /// ### Why is this bad?\n-    /// This would improve readability and avoid creating a reference\n-    /// that points to an uninitialized value or unaligned place.\n-    /// Read the `ptr::addr_of` docs for more information.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let val = 1;\n-    /// let p = &val as *const i32;\n-    ///\n-    /// let mut val_mut = 1;\n-    /// let p_mut = &mut val_mut as *mut i32;\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let val = 1;\n-    /// let p = std::ptr::addr_of!(val);\n-    ///\n-    /// let mut val_mut = 1;\n-    /// let p_mut = std::ptr::addr_of_mut!(val_mut);\n-    /// ```\n-    #[clippy::version = \"1.60.0\"]\n-    pub BORROW_AS_PTR,\n-    pedantic,\n-    \"borrowing just to cast to a raw pointer\"\n-}\n-\n-impl_lint_pass!(BorrowAsPtr => [BORROW_AS_PTR]);\n-\n-pub struct BorrowAsPtr {\n-    msrv: Option<RustcVersion>,\n-}\n-\n-impl BorrowAsPtr {\n-    #[must_use]\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self { msrv }\n-    }\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for BorrowAsPtr {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if !meets_msrv(self.msrv, msrvs::BORROW_AS_PTR) {\n-            return;\n-        }\n-\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::Cast(left_expr, ty) = &expr.kind;\n-            if let TyKind::Ptr(_) = ty.kind;\n-            if let ExprKind::AddrOf(BorrowKind::Ref, mutability, e) = &left_expr.kind;\n-\n-            then {\n-                let core_or_std = if is_no_std_crate(cx) { \"core\" } else { \"std\" };\n-                let macro_name = match mutability {\n-                    Mutability::Not => \"addr_of\",\n-                    Mutability::Mut => \"addr_of_mut\",\n-                };\n-\n-                span_lint_and_sugg(\n-                    cx,\n-                    BORROW_AS_PTR,\n-                    expr.span,\n-                    \"borrow as raw pointer\",\n-                    \"try\",\n-                    format!(\n-                        \"{}::ptr::{}!({})\",\n-                        core_or_std,\n-                        macro_name,\n-                        snippet_opt(cx, e.span).unwrap()\n-                    ),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-\n-    extract_msrv_attr!(LateContext);\n-}"}, {"sha": "326ce34082af7c233b8f2d1dc44cc185a81fdb08", "filename": "clippy_lints/src/bytecount.rs", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,103 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::match_type;\n-use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{path_to_local_id, paths, peel_blocks, peel_ref_operators, strip_pat_refs};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Closure, Expr, ExprKind, PatKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, UintTy};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for naive byte counts\n-    ///\n-    /// ### Why is this bad?\n-    /// The [`bytecount`](https://crates.io/crates/bytecount)\n-    /// crate has methods to count your bytes faster, especially for large slices.\n-    ///\n-    /// ### Known problems\n-    /// If you have predominantly small slices, the\n-    /// `bytecount::count(..)` method may actually be slower. However, if you can\n-    /// ensure that less than 2\u00b3\u00b2-1 matches arise, the `naive_count_32(..)` can be\n-    /// faster in those cases.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let vec = vec![1_u8];\n-    /// let count = vec.iter().filter(|x| **x == 0u8).count();\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// # let vec = vec![1_u8];\n-    /// let count = bytecount::count(&vec, 0u8);\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub NAIVE_BYTECOUNT,\n-    pedantic,\n-    \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\"\n-}\n-\n-declare_lint_pass!(ByteCount => [NAIVE_BYTECOUNT]);\n-\n-impl<'tcx> LateLintPass<'tcx> for ByteCount {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(count, [count_recv], _) = expr.kind;\n-            if count.ident.name == sym::count;\n-            if let ExprKind::MethodCall(filter, [filter_recv, filter_arg], _) = count_recv.kind;\n-            if filter.ident.name == sym!(filter);\n-            if let ExprKind::Closure(&Closure { body, .. }) = filter_arg.kind;\n-            let body = cx.tcx.hir().body(body);\n-            if let [param] = body.params;\n-            if let PatKind::Binding(_, arg_id, _, _) = strip_pat_refs(param.pat).kind;\n-            if let ExprKind::Binary(ref op, l, r) = body.value.kind;\n-            if op.node == BinOpKind::Eq;\n-            if match_type(cx,\n-                       cx.typeck_results().expr_ty(filter_recv).peel_refs(),\n-                       &paths::SLICE_ITER);\n-            let operand_is_arg = |expr| {\n-                let expr = peel_ref_operators(cx, peel_blocks(expr));\n-                path_to_local_id(expr, arg_id)\n-            };\n-            let needle = if operand_is_arg(l) {\n-                r\n-            } else if operand_is_arg(r) {\n-                l\n-            } else {\n-                return;\n-            };\n-            if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n-            if !is_local_used(cx, needle, arg_id);\n-            then {\n-                let haystack = if let ExprKind::MethodCall(path, args, _) =\n-                        filter_recv.kind {\n-                    let p = path.ident.name;\n-                    if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n-                        &args[0]\n-                    } else {\n-                        filter_recv\n-                    }\n-                } else {\n-                    filter_recv\n-                };\n-                let mut applicability = Applicability::MaybeIncorrect;\n-                span_lint_and_sugg(\n-                    cx,\n-                    NAIVE_BYTECOUNT,\n-                    expr.span,\n-                    \"you appear to be counting bytes the naive way\",\n-                    \"consider using the bytecount crate\",\n-                    format!(\"bytecount::count({}, {})\",\n-                            snippet_with_applicability(cx, haystack.span, \"..\", &mut applicability),\n-                            snippet_with_applicability(cx, needle.span, \"..\", &mut applicability)),\n-                    applicability,\n-                );\n-            }\n-        };\n-    }\n-}"}, {"sha": "d70dbf5b23904aa282d7be16b3c025add46f1781", "filename": "clippy_lints/src/bytes_count_to_len.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fbytes_count_to_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fbytes_count_to_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytes_count_to_len.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,70 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{match_def_path, paths};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// It checks for `str::bytes().count()` and suggests replacing it with\n-    /// `str::len()`.\n-    ///\n-    /// ### Why is this bad?\n-    /// `str::bytes().count()` is longer and may not be as performant as using\n-    /// `str::len()`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// \"hello\".bytes().count();\n-    /// String::from(\"hello\").bytes().count();\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// \"hello\".len();\n-    /// String::from(\"hello\").len();\n-    /// ```\n-    #[clippy::version = \"1.62.0\"]\n-    pub BYTES_COUNT_TO_LEN,\n-    complexity,\n-    \"Using `bytes().count()` when `len()` performs the same functionality\"\n-}\n-\n-declare_lint_pass!(BytesCountToLen => [BYTES_COUNT_TO_LEN]);\n-\n-impl<'tcx> LateLintPass<'tcx> for BytesCountToLen {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if_chain! {\n-            if let hir::ExprKind::MethodCall(_, expr_args, _) = &expr.kind;\n-            if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-            if match_def_path(cx, expr_def_id, &paths::ITER_COUNT);\n-\n-            if let [bytes_expr] = &**expr_args;\n-            if let hir::ExprKind::MethodCall(_, bytes_args, _) = &bytes_expr.kind;\n-            if let Some(bytes_def_id) = cx.typeck_results().type_dependent_def_id(bytes_expr.hir_id);\n-            if match_def_path(cx, bytes_def_id, &paths::STR_BYTES);\n-\n-            if let [str_expr] = &**bytes_args;\n-            let ty = cx.typeck_results().expr_ty(str_expr).peel_refs();\n-\n-            if is_type_diagnostic_item(cx, ty, sym::String) || ty.kind() == &ty::Str;\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                span_lint_and_sugg(\n-                    cx,\n-                    BYTES_COUNT_TO_LEN,\n-                    expr.span,\n-                    \"using long and hard to read `.bytes().count()`\",\n-                    \"consider calling `.len()` instead\",\n-                    format!(\"{}.len()\", snippet_with_applicability(cx, str_expr.span, \"..\", &mut applicability)),\n-                    applicability\n-                );\n-            }\n-        };\n-    }\n-}"}, {"sha": "bef196565a2a3ecf8da0df185097d05e8c7ee409", "filename": "clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,85 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n-use rustc_hir::{Expr, ExprKind, PathSegment};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{source_map::Spanned, symbol::sym, Span};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for calls to `ends_with` with possible file extensions\n-    /// and suggests to use a case-insensitive approach instead.\n-    ///\n-    /// ### Why is this bad?\n-    /// `ends_with` is case-sensitive and may not detect files with a valid extension.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// fn is_rust_file(filename: &str) -> bool {\n-    ///     filename.ends_with(\".rs\")\n-    /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// fn is_rust_file(filename: &str) -> bool {\n-    ///     let filename = std::path::Path::new(filename);\n-    ///     filename.extension()\n-    ///         .map_or(false, |ext| ext.eq_ignore_ascii_case(\"rs\"))\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.51.0\"]\n-    pub CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n-    pedantic,\n-    \"Checks for calls to ends_with with case-sensitive file extensions\"\n-}\n-\n-declare_lint_pass!(CaseSensitiveFileExtensionComparisons => [CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS]);\n-\n-fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Span> {\n-    if_chain! {\n-        if let ExprKind::MethodCall(PathSegment { ident, .. }, [obj, extension, ..], span) = expr.kind;\n-        if ident.as_str() == \"ends_with\";\n-        if let ExprKind::Lit(Spanned { node: LitKind::Str(ext_literal, ..), ..}) = extension.kind;\n-        if (2..=6).contains(&ext_literal.as_str().len());\n-        if ext_literal.as_str().starts_with('.');\n-        if ext_literal.as_str().chars().skip(1).all(|c| c.is_uppercase() || c.is_ascii_digit())\n-            || ext_literal.as_str().chars().skip(1).all(|c| c.is_lowercase() || c.is_ascii_digit());\n-        then {\n-            let mut ty = ctx.typeck_results().expr_ty(obj);\n-            ty = match ty.kind() {\n-                ty::Ref(_, ty, ..) => *ty,\n-                _ => ty\n-            };\n-\n-            match ty.kind() {\n-                ty::Str => {\n-                    return Some(span);\n-                },\n-                ty::Adt(def, _) => {\n-                    if ctx.tcx.is_diagnostic_item(sym::String, def.did()) {\n-                        return Some(span);\n-                    }\n-                },\n-                _ => { return None; }\n-            }\n-        }\n-    }\n-    None\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for CaseSensitiveFileExtensionComparisons {\n-    fn check_expr(&mut self, ctx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if let Some(span) = check_case_sensitive_file_extension_comparison(ctx, expr) {\n-            span_lint_and_help(\n-                ctx,\n-                CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n-                span,\n-                \"case-sensitive file extension comparison\",\n-                None,\n-                \"consider using a case-insensitive comparison instead\",\n-            );\n-        }\n-    }\n-}"}, {"sha": "56e894c6261eeb27884db1f098eea1e145aca589", "filename": "clippy_lints/src/casts/as_underscore.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fcasts%2Fas_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fcasts%2Fas_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fas_underscore.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,25 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, Ty, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::AS_UNDERSCORE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ty: &'tcx Ty<'_>) {\n+    if matches!(ty.kind, TyKind::Infer) {\n+        span_lint_and_then(cx, AS_UNDERSCORE, expr.span, \"using `as _` conversion\", |diag| {\n+            let ty_resolved = cx.typeck_results().expr_ty(expr);\n+            if let ty::Error(_) = ty_resolved.kind() {\n+                diag.help(\"consider giving the type explicitly\");\n+            } else {\n+                diag.span_suggestion(\n+                    ty.span,\n+                    \"consider giving the type explicitly\",\n+                    ty_resolved,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        });\n+    }\n+}"}, {"sha": "6e1f8cd64f077936122944ef2fa61792a356cbf2", "filename": "clippy_lints/src/casts/borrow_as_ptr.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fcasts%2Fborrow_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fcasts%2Fborrow_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fborrow_as_ptr.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,37 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_no_std_crate;\n+use clippy_utils::source::snippet_with_context;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, Ty, TyKind};\n+use rustc_lint::LateContext;\n+\n+use super::BORROW_AS_PTR;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    cast_expr: &'tcx Expr<'_>,\n+    cast_to: &'tcx Ty<'_>,\n+) {\n+    if matches!(cast_to.kind, TyKind::Ptr(_))\n+        && let ExprKind::AddrOf(BorrowKind::Ref, mutability, e) = cast_expr.kind\n+    {\n+        let core_or_std = if is_no_std_crate(cx) { \"core\" } else { \"std\" };\n+        let macro_name = match mutability {\n+            Mutability::Not => \"addr_of\",\n+            Mutability::Mut => \"addr_of_mut\",\n+        };\n+        let mut app = Applicability::MachineApplicable;\n+        let snip = snippet_with_context(cx, e.span, cast_expr.span.ctxt(), \"..\", &mut app).0;\n+\n+        span_lint_and_sugg(\n+            cx,\n+            BORROW_AS_PTR,\n+            expr.span,\n+            \"borrow as raw pointer\",\n+            \"try\",\n+            format!(\"{}::ptr::{}!({})\", core_or_std, macro_name, snip),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}"}, {"sha": "644edefb8fe99e2d5118cef2df12b22b897fafe2", "filename": "clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 75, "deletions": 4, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -1,3 +1,5 @@\n+mod as_underscore;\n+mod borrow_as_ptr;\n mod cast_abs_to_unsigned;\n mod cast_enum_constructor;\n mod cast_lossless;\n@@ -16,7 +18,7 @@ mod ptr_as_ptr;\n mod unnecessary_cast;\n mod utils;\n \n-use clippy_utils::is_hir_ty_cfg_dependant;\n+use clippy_utils::{is_hir_ty_cfg_dependant, meets_msrv, msrvs};\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -506,6 +508,67 @@ declare_clippy_lint! {\n     \"casting the result of `abs()` to an unsigned integer can panic\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Check for the usage of `as _` conversion using inferred type.\n+    ///\n+    /// ### Why is this bad?\n+    /// The conversion might include lossy conversion and dangerous cast that might go\n+    /// undetected due to the type being inferred.\n+    ///\n+    /// The lint is allowed by default as using `_` is less wordy than always specifying the type.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn foo(n: usize) {}\n+    /// let n: u16 = 256;\n+    /// foo(n as _);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn foo(n: usize) {}\n+    /// let n: u16 = 256;\n+    /// foo(n as usize);\n+    /// ```\n+    #[clippy::version = \"1.63.0\"]\n+    pub AS_UNDERSCORE,\n+    restriction,\n+    \"detects `as _` conversion\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for the usage of `&expr as *const T` or\n+    /// `&mut expr as *mut T`, and suggest using `ptr::addr_of` or\n+    /// `ptr::addr_of_mut` instead.\n+    ///\n+    /// ### Why is this bad?\n+    /// This would improve readability and avoid creating a reference\n+    /// that points to an uninitialized value or unaligned place.\n+    /// Read the `ptr::addr_of` docs for more information.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let val = 1;\n+    /// let p = &val as *const i32;\n+    ///\n+    /// let mut val_mut = 1;\n+    /// let p_mut = &mut val_mut as *mut i32;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let val = 1;\n+    /// let p = std::ptr::addr_of!(val);\n+    ///\n+    /// let mut val_mut = 1;\n+    /// let p_mut = std::ptr::addr_of_mut!(val_mut);\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub BORROW_AS_PTR,\n+    pedantic,\n+    \"borrowing just to cast to a raw pointer\"\n+}\n+\n pub struct Casts {\n     msrv: Option<RustcVersion>,\n }\n@@ -534,7 +597,9 @@ impl_lint_pass!(Casts => [\n     PTR_AS_PTR,\n     CAST_ENUM_TRUNCATION,\n     CAST_ENUM_CONSTRUCTOR,\n-    CAST_ABS_TO_UNSIGNED\n+    CAST_ABS_TO_UNSIGNED,\n+    AS_UNDERSCORE,\n+    BORROW_AS_PTR,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Casts {\n@@ -547,8 +612,8 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             return;\n         }\n \n-        if let ExprKind::Cast(cast_expr, cast_to) = expr.kind {\n-            if is_hir_ty_cfg_dependant(cx, cast_to) {\n+        if let ExprKind::Cast(cast_expr, cast_to_hir) = expr.kind {\n+            if is_hir_ty_cfg_dependant(cx, cast_to_hir) {\n                 return;\n             }\n             let (cast_from, cast_to) = (\n@@ -575,6 +640,12 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n                 cast_lossless::check(cx, expr, cast_expr, cast_from, cast_to, self.msrv);\n                 cast_enum_constructor::check(cx, expr, cast_expr, cast_from);\n             }\n+\n+            as_underscore::check(cx, expr, cast_to_hir);\n+\n+            if meets_msrv(self.msrv, msrvs::BORROW_AS_PTR) {\n+                borrow_as_ptr::check(cx, expr, cast_expr, cast_to_hir);\n+            }\n         }\n \n         cast_ref_to_mut::check(cx, expr);"}, {"sha": "529f7babaa5eab516e5f2a7744f4d31cef4afd4a", "filename": "clippy_lints/src/get_first.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fget_first.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fget_first.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fget_first.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,68 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{is_slice_of_primitives, match_def_path, paths};\n-use if_chain::if_chain;\n-use rustc_ast::LitKind;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Spanned;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for using `x.get(0)` instead of\n-    /// `x.first()`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Using `x.first()` is easier to read and has the same\n-    /// result.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = vec![2, 3, 5];\n-    /// let first_element = x.get(0);\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// let x = vec![2, 3, 5];\n-    /// let first_element = x.first();\n-    /// ```\n-    #[clippy::version = \"1.63.0\"]\n-    pub GET_FIRST,\n-    style,\n-    \"Using `x.get(0)` when `x.first()` is simpler\"\n-}\n-declare_lint_pass!(GetFirst => [GET_FIRST]);\n-\n-impl<'tcx> LateLintPass<'tcx> for GetFirst {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if_chain! {\n-            if let hir::ExprKind::MethodCall(_, [struct_calling_on, method_arg], _) = &expr.kind;\n-            if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-            if match_def_path(cx, expr_def_id, &paths::SLICE_GET);\n-\n-            if let Some(_) = is_slice_of_primitives(cx, struct_calling_on);\n-            if let hir::ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = method_arg.kind;\n-\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let slice_name = snippet_with_applicability(\n-                    cx,\n-                    struct_calling_on.span, \"..\",\n-                    &mut applicability,\n-                );\n-                span_lint_and_sugg(\n-                    cx,\n-                    GET_FIRST,\n-                    expr.span,\n-                    &format!(\"accessing first element with `{0}.get(0)`\", slice_name),\n-                    \"try\",\n-                    format!(\"{}.first()\", slice_name),\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "4128096b43ae04eb6b0e883a03e21cb32aa0a628", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -20,7 +20,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(booleans::NONMINIMAL_BOOL),\n     LintId::of(booleans::OVERLY_COMPLEX_BOOL_EXPR),\n     LintId::of(borrow_deref_ref::BORROW_DEREF_REF),\n-    LintId::of(bytes_count_to_len::BYTES_COUNT_TO_LEN),\n     LintId::of(casts::CAST_ABS_TO_UNSIGNED),\n     LintId::of(casts::CAST_ENUM_CONSTRUCTOR),\n     LintId::of(casts::CAST_ENUM_TRUNCATION),\n@@ -82,7 +81,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(functions::NOT_UNSAFE_PTR_ARG_DEREF),\n     LintId::of(functions::RESULT_UNIT_ERR),\n     LintId::of(functions::TOO_MANY_ARGUMENTS),\n-    LintId::of(get_first::GET_FIRST),\n     LintId::of(if_let_mutex::IF_LET_MUTEX),\n     LintId::of(indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n     LintId::of(infinite_iter::INFINITE_ITER),\n@@ -129,7 +127,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(manual_rem_euclid::MANUAL_REM_EUCLID),\n     LintId::of(manual_retain::MANUAL_RETAIN),\n     LintId::of(manual_strip::MANUAL_STRIP),\n-    LintId::of(map_clone::MAP_CLONE),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n@@ -151,6 +148,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(mem_replace::MEM_REPLACE_WITH_DEFAULT),\n     LintId::of(mem_replace::MEM_REPLACE_WITH_UNINIT),\n     LintId::of(methods::BIND_INSTEAD_OF_MAP),\n+    LintId::of(methods::BYTES_COUNT_TO_LEN),\n     LintId::of(methods::BYTES_NTH),\n     LintId::of(methods::CHARS_LAST_CMP),\n     LintId::of(methods::CHARS_NEXT_CMP),\n@@ -162,6 +160,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::FILTER_MAP_IDENTITY),\n     LintId::of(methods::FILTER_NEXT),\n     LintId::of(methods::FLAT_MAP_IDENTITY),\n+    LintId::of(methods::GET_FIRST),\n     LintId::of(methods::GET_LAST_WITH_LEN),\n     LintId::of(methods::INSPECT_FOR_EACH),\n     LintId::of(methods::INTO_ITER_ON_REF),\n@@ -179,13 +178,16 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n     LintId::of(methods::MANUAL_SPLIT_ONCE),\n     LintId::of(methods::MANUAL_STR_REPEAT),\n+    LintId::of(methods::MAP_CLONE),\n     LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n     LintId::of(methods::MAP_FLATTEN),\n     LintId::of(methods::MAP_IDENTITY),\n+    LintId::of(methods::MUT_MUTEX_LOCK),\n     LintId::of(methods::NEEDLESS_OPTION_AS_DEREF),\n     LintId::of(methods::NEEDLESS_OPTION_TAKE),\n     LintId::of(methods::NEEDLESS_SPLITN),\n     LintId::of(methods::NEW_RET_NO_SELF),\n+    LintId::of(methods::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(methods::NO_EFFECT_REPLACE),\n     LintId::of(methods::OBFUSCATED_IF_ELSE),\n     LintId::of(methods::OK_EXPECT),\n@@ -194,6 +196,8 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::OPTION_MAP_OR_NONE),\n     LintId::of(methods::OR_FUN_CALL),\n     LintId::of(methods::OR_THEN_UNWRAP),\n+    LintId::of(methods::RANGE_ZIP_WITH_LEN),\n+    LintId::of(methods::REPEAT_ONCE),\n     LintId::of(methods::RESULT_MAP_OR_INTO_OPTION),\n     LintId::of(methods::SEARCH_IS_SOME),\n     LintId::of(methods::SHOULD_IMPLEMENT_TRAIT),\n@@ -204,13 +208,16 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::SUSPICIOUS_MAP),\n     LintId::of(methods::SUSPICIOUS_SPLITN),\n     LintId::of(methods::UNINIT_ASSUMED_INIT),\n+    LintId::of(methods::UNIT_HASH),\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),\n     LintId::of(methods::UNNECESSARY_FIND_MAP),\n     LintId::of(methods::UNNECESSARY_FOLD),\n     LintId::of(methods::UNNECESSARY_LAZY_EVALUATIONS),\n+    LintId::of(methods::UNNECESSARY_SORT_BY),\n     LintId::of(methods::UNNECESSARY_TO_OWNED),\n     LintId::of(methods::UNWRAP_OR_ELSE_DEFAULT),\n     LintId::of(methods::USELESS_ASREF),\n+    LintId::of(methods::VEC_RESIZE_TO_ZERO),\n     LintId::of(methods::WRONG_SELF_CONVENTION),\n     LintId::of(methods::ZST_OFFSET),\n     LintId::of(minmax::MIN_MAX),\n@@ -226,7 +233,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(misc_early::ZERO_PREFIXED_LITERAL),\n     LintId::of(mixed_read_write_in_expression::DIVERGING_SUB_EXPRESSION),\n     LintId::of(mut_key::MUTABLE_KEY_TYPE),\n-    LintId::of(mut_mutex_lock::MUT_MUTEX_LOCK),\n     LintId::of(mut_reference::UNNECESSARY_MUT_PASSED),\n     LintId::of(needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE),\n     LintId::of(needless_bool::BOOL_COMPARISON),\n@@ -246,7 +252,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n-    LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n     LintId::of(operators::ASSIGN_OP_PATTERN),\n     LintId::of(operators::BAD_BIT_MASK),\n@@ -276,7 +281,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n     LintId::of(question_mark::QUESTION_MARK),\n     LintId::of(ranges::MANUAL_RANGE_CONTAINS),\n-    LintId::of(ranges::RANGE_ZIP_WITH_LEN),\n     LintId::of(ranges::REVERSED_EMPTY_RANGES),\n     LintId::of(rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT),\n     LintId::of(read_zero_byte_vec::READ_ZERO_BYTE_VEC),\n@@ -287,7 +291,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n     LintId::of(reference::DEREF_ADDROF),\n     LintId::of(regex::INVALID_REGEX),\n-    LintId::of(repeat_once::REPEAT_ONCE),\n     LintId::of(returns::LET_AND_RETURN),\n     LintId::of(returns::NEEDLESS_RETURN),\n     LintId::of(self_named_constructors::SELF_NAMED_CONSTRUCTORS),\n@@ -315,26 +318,24 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(transmute::TRANSMUTE_INT_TO_FLOAT),\n     LintId::of(transmute::TRANSMUTE_NUM_TO_BYTES),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_REF),\n+    LintId::of(transmute::TRANSMUTING_NULL),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::USELESS_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n-    LintId::of(transmuting_null::TRANSMUTING_NULL),\n     LintId::of(types::BORROWED_BOX),\n     LintId::of(types::BOX_COLLECTION),\n     LintId::of(types::REDUNDANT_ALLOCATION),\n     LintId::of(types::TYPE_COMPLEXITY),\n     LintId::of(types::VEC_BOX),\n     LintId::of(unicode::INVISIBLE_CHARACTERS),\n     LintId::of(uninit_vec::UNINIT_VEC),\n-    LintId::of(unit_hash::UNIT_HASH),\n     LintId::of(unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n     LintId::of(unit_types::LET_UNIT_VALUE),\n     LintId::of(unit_types::UNIT_ARG),\n     LintId::of(unit_types::UNIT_CMP),\n     LintId::of(unnamed_address::FN_ADDRESS_COMPARISONS),\n     LintId::of(unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n     LintId::of(unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS),\n-    LintId::of(unnecessary_sort_by::UNNECESSARY_SORT_BY),\n     LintId::of(unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n     LintId::of(unused_io_amount::UNUSED_IO_AMOUNT),\n     LintId::of(unused_unit::UNUSED_UNIT),\n@@ -344,7 +345,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(useless_conversion::USELESS_CONVERSION),\n     LintId::of(vec::USELESS_VEC),\n     LintId::of(vec_init_then_push::VEC_INIT_THEN_PUSH),\n-    LintId::of(vec_resize_to_zero::VEC_RESIZE_TO_ZERO),\n     LintId::of(write::POSITIONAL_NAMED_FORMAT_PARAMETERS),\n     LintId::of(write::PRINTLN_EMPTY_STRING),\n     LintId::of(write::PRINT_LITERAL),"}, {"sha": "0f7433a79be300893d4ad90b96ec85ecf20b1e5e", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -6,7 +6,6 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(attrs::DEPRECATED_CFG_ATTR),\n     LintId::of(booleans::NONMINIMAL_BOOL),\n     LintId::of(borrow_deref_ref::BORROW_DEREF_REF),\n-    LintId::of(bytes_count_to_len::BYTES_COUNT_TO_LEN),\n     LintId::of(casts::CHAR_LIT_AS_U8),\n     LintId::of(casts::UNNECESSARY_CAST),\n     LintId::of(dereference::EXPLICIT_AUTO_DEREF),\n@@ -33,6 +32,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(matches::NEEDLESS_MATCH),\n     LintId::of(matches::WILDCARD_IN_OR_PATTERNS),\n     LintId::of(methods::BIND_INSTEAD_OF_MAP),\n+    LintId::of(methods::BYTES_COUNT_TO_LEN),\n     LintId::of(methods::CLONE_ON_COPY),\n     LintId::of(methods::FILTER_MAP_IDENTITY),\n     LintId::of(methods::FILTER_NEXT),\n@@ -51,10 +51,13 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(methods::OPTION_AS_REF_DEREF),\n     LintId::of(methods::OPTION_FILTER_MAP),\n     LintId::of(methods::OR_THEN_UNWRAP),\n+    LintId::of(methods::RANGE_ZIP_WITH_LEN),\n+    LintId::of(methods::REPEAT_ONCE),\n     LintId::of(methods::SEARCH_IS_SOME),\n     LintId::of(methods::SKIP_WHILE_NEXT),\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),\n     LintId::of(methods::UNNECESSARY_FIND_MAP),\n+    LintId::of(methods::UNNECESSARY_SORT_BY),\n     LintId::of(methods::USELESS_ASREF),\n     LintId::of(misc::SHORT_CIRCUIT_STATEMENT),\n     LintId::of(misc_early::UNNEEDED_WILDCARD_PATTERN),\n@@ -76,11 +79,9 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n     LintId::of(precedence::PRECEDENCE),\n     LintId::of(ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n-    LintId::of(ranges::RANGE_ZIP_WITH_LEN),\n     LintId::of(redundant_closure_call::REDUNDANT_CLOSURE_CALL),\n     LintId::of(redundant_slicing::REDUNDANT_SLICING),\n     LintId::of(reference::DEREF_ADDROF),\n-    LintId::of(repeat_once::REPEAT_ONCE),\n     LintId::of(strings::STRING_FROM_UTF8_AS_BYTES),\n     LintId::of(strlen_on_c_strings::STRLEN_ON_C_STRINGS),\n     LintId::of(swap::MANUAL_SWAP),\n@@ -99,7 +100,6 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(types::TYPE_COMPLEXITY),\n     LintId::of(types::VEC_BOX),\n     LintId::of(unit_types::UNIT_ARG),\n-    LintId::of(unnecessary_sort_by::UNNECESSARY_SORT_BY),\n     LintId::of(unwrap::UNNECESSARY_UNWRAP),\n     LintId::of(useless_conversion::USELESS_CONVERSION),\n     LintId::of(zero_div_zero::ZERO_DIVIDED_BY_ZERO),"}, {"sha": "bb94037ec2e7949ba52a2b25ba0bd89ae6794e89", "filename": "clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -39,12 +39,14 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(mem_replace::MEM_REPLACE_WITH_UNINIT),\n     LintId::of(methods::CLONE_DOUBLE_REF),\n     LintId::of(methods::ITERATOR_STEP_BY_ZERO),\n+    LintId::of(methods::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(methods::SUSPICIOUS_SPLITN),\n     LintId::of(methods::UNINIT_ASSUMED_INIT),\n+    LintId::of(methods::UNIT_HASH),\n+    LintId::of(methods::VEC_RESIZE_TO_ZERO),\n     LintId::of(methods::ZST_OFFSET),\n     LintId::of(minmax::MIN_MAX),\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n-    LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n     LintId::of(operators::BAD_BIT_MASK),\n     LintId::of(operators::CMP_NAN),\n@@ -62,17 +64,15 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(serde_api::SERDE_API_MISUSE),\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(swap::ALMOST_SWAPPED),\n+    LintId::of(transmute::TRANSMUTING_NULL),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n-    LintId::of(transmuting_null::TRANSMUTING_NULL),\n     LintId::of(unicode::INVISIBLE_CHARACTERS),\n     LintId::of(uninit_vec::UNINIT_VEC),\n-    LintId::of(unit_hash::UNIT_HASH),\n     LintId::of(unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n     LintId::of(unit_types::UNIT_CMP),\n     LintId::of(unnamed_address::FN_ADDRESS_COMPARISONS),\n     LintId::of(unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n     LintId::of(unused_io_amount::UNUSED_IO_AMOUNT),\n     LintId::of(unwrap::PANICKING_UNWRAP),\n-    LintId::of(vec_resize_to_zero::VEC_RESIZE_TO_ZERO),\n ])"}, {"sha": "db475950086d0c30f7b0e8f3fd07f281f66507ab", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -38,7 +38,6 @@ store.register_lints(&[\n     almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE,\n     approx_const::APPROX_CONSTANT,\n     as_conversions::AS_CONVERSIONS,\n-    as_underscore::AS_UNDERSCORE,\n     asm_syntax::INLINE_ASM_X86_ATT_SYNTAX,\n     asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX,\n     assertions_on_constants::ASSERTIONS_ON_CONSTANTS,\n@@ -59,16 +58,14 @@ store.register_lints(&[\n     bool_assert_comparison::BOOL_ASSERT_COMPARISON,\n     booleans::NONMINIMAL_BOOL,\n     booleans::OVERLY_COMPLEX_BOOL_EXPR,\n-    borrow_as_ptr::BORROW_AS_PTR,\n     borrow_deref_ref::BORROW_DEREF_REF,\n-    bytecount::NAIVE_BYTECOUNT,\n-    bytes_count_to_len::BYTES_COUNT_TO_LEN,\n     cargo::CARGO_COMMON_METADATA,\n     cargo::MULTIPLE_CRATE_VERSIONS,\n     cargo::NEGATIVE_FEATURE_NAMES,\n     cargo::REDUNDANT_FEATURE_NAMES,\n     cargo::WILDCARD_DEPENDENCIES,\n-    case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+    casts::AS_UNDERSCORE,\n+    casts::BORROW_AS_PTR,\n     casts::CAST_ABS_TO_UNSIGNED,\n     casts::CAST_ENUM_CONSTRUCTOR,\n     casts::CAST_ENUM_TRUNCATION,\n@@ -177,7 +174,6 @@ store.register_lints(&[\n     functions::TOO_MANY_ARGUMENTS,\n     functions::TOO_MANY_LINES,\n     future_not_send::FUTURE_NOT_SEND,\n-    get_first::GET_FIRST,\n     if_let_mutex::IF_LET_MUTEX,\n     if_not_else::IF_NOT_ELSE,\n     if_then_some_else_none::IF_THEN_SOME_ELSE_NONE,\n@@ -247,12 +243,9 @@ store.register_lints(&[\n     manual_empty_string_creations::MANUAL_EMPTY_STRING_CREATIONS,\n     manual_instant_elapsed::MANUAL_INSTANT_ELAPSED,\n     manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n-    manual_ok_or::MANUAL_OK_OR,\n     manual_rem_euclid::MANUAL_REM_EUCLID,\n     manual_retain::MANUAL_RETAIN,\n     manual_strip::MANUAL_STRIP,\n-    map_clone::MAP_CLONE,\n-    map_err_ignore::MAP_ERR_IGNORE,\n     map_unit_fn::OPTION_MAP_UNIT_FN,\n     map_unit_fn::RESULT_MAP_UNIT_FN,\n     match_result_ok::MATCH_RESULT_OK,\n@@ -285,7 +278,9 @@ store.register_lints(&[\n     mem_replace::MEM_REPLACE_WITH_DEFAULT,\n     mem_replace::MEM_REPLACE_WITH_UNINIT,\n     methods::BIND_INSTEAD_OF_MAP,\n+    methods::BYTES_COUNT_TO_LEN,\n     methods::BYTES_NTH,\n+    methods::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n     methods::CHARS_LAST_CMP,\n     methods::CHARS_NEXT_CMP,\n     methods::CLONED_INSTEAD_OF_COPIED,\n@@ -303,6 +298,7 @@ store.register_lints(&[\n     methods::FLAT_MAP_IDENTITY,\n     methods::FLAT_MAP_OPTION,\n     methods::FROM_ITER_INSTEAD_OF_COLLECT,\n+    methods::GET_FIRST,\n     methods::GET_LAST_WITH_LEN,\n     methods::GET_UNWRAP,\n     methods::IMPLICIT_CLONE,\n@@ -323,17 +319,23 @@ store.register_lints(&[\n     methods::ITER_WITH_DRAIN,\n     methods::MANUAL_FILTER_MAP,\n     methods::MANUAL_FIND_MAP,\n+    methods::MANUAL_OK_OR,\n     methods::MANUAL_SATURATING_ARITHMETIC,\n     methods::MANUAL_SPLIT_ONCE,\n     methods::MANUAL_STR_REPEAT,\n+    methods::MAP_CLONE,\n     methods::MAP_COLLECT_RESULT_UNIT,\n+    methods::MAP_ERR_IGNORE,\n     methods::MAP_FLATTEN,\n     methods::MAP_IDENTITY,\n     methods::MAP_UNWRAP_OR,\n+    methods::MUT_MUTEX_LOCK,\n+    methods::NAIVE_BYTECOUNT,\n     methods::NEEDLESS_OPTION_AS_DEREF,\n     methods::NEEDLESS_OPTION_TAKE,\n     methods::NEEDLESS_SPLITN,\n     methods::NEW_RET_NO_SELF,\n+    methods::NONSENSICAL_OPEN_OPTIONS,\n     methods::NO_EFFECT_REPLACE,\n     methods::OBFUSCATED_IF_ELSE,\n     methods::OK_EXPECT,\n@@ -342,25 +344,33 @@ store.register_lints(&[\n     methods::OPTION_MAP_OR_NONE,\n     methods::OR_FUN_CALL,\n     methods::OR_THEN_UNWRAP,\n+    methods::PATH_BUF_PUSH_OVERWRITE,\n+    methods::RANGE_ZIP_WITH_LEN,\n+    methods::REPEAT_ONCE,\n     methods::RESULT_MAP_OR_INTO_OPTION,\n     methods::SEARCH_IS_SOME,\n     methods::SHOULD_IMPLEMENT_TRAIT,\n     methods::SINGLE_CHAR_ADD_STR,\n     methods::SINGLE_CHAR_PATTERN,\n     methods::SKIP_WHILE_NEXT,\n+    methods::STABLE_SORT_PRIMITIVE,\n     methods::STRING_EXTEND_CHARS,\n     methods::SUSPICIOUS_MAP,\n     methods::SUSPICIOUS_SPLITN,\n     methods::UNINIT_ASSUMED_INIT,\n+    methods::UNIT_HASH,\n     methods::UNNECESSARY_FILTER_MAP,\n     methods::UNNECESSARY_FIND_MAP,\n     methods::UNNECESSARY_FOLD,\n     methods::UNNECESSARY_JOIN,\n     methods::UNNECESSARY_LAZY_EVALUATIONS,\n+    methods::UNNECESSARY_SORT_BY,\n     methods::UNNECESSARY_TO_OWNED,\n     methods::UNWRAP_OR_ELSE_DEFAULT,\n     methods::UNWRAP_USED,\n     methods::USELESS_ASREF,\n+    methods::VEC_RESIZE_TO_ZERO,\n+    methods::VERBOSE_FILE_READS,\n     methods::WRONG_SELF_CONVENTION,\n     methods::ZST_OFFSET,\n     minmax::MIN_MAX,\n@@ -389,7 +399,6 @@ store.register_lints(&[\n     module_style::SELF_NAMED_MODULE_FILES,\n     mut_key::MUTABLE_KEY_TYPE,\n     mut_mut::MUT_MUT,\n-    mut_mutex_lock::MUT_MUTEX_LOCK,\n     mut_reference::UNNECESSARY_MUT_PASSED,\n     mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL,\n     mutex_atomic::MUTEX_ATOMIC,\n@@ -421,7 +430,6 @@ store.register_lints(&[\n     nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES,\n     octal_escapes::OCTAL_ESCAPES,\n     only_used_in_recursion::ONLY_USED_IN_RECURSION,\n-    open_options::NONSENSICAL_OPEN_OPTIONS,\n     operators::ABSURD_EXTREME_COMPARISONS,\n     operators::ARITHMETIC,\n     operators::ASSIGN_OP_PATTERN,\n@@ -460,7 +468,6 @@ store.register_lints(&[\n     partialeq_to_none::PARTIALEQ_TO_NONE,\n     pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE,\n     pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF,\n-    path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE,\n     pattern_type_mismatch::PATTERN_TYPE_MISMATCH,\n     precedence::PRECEDENCE,\n     ptr::CMP_NULL,\n@@ -473,7 +480,6 @@ store.register_lints(&[\n     ranges::MANUAL_RANGE_CONTAINS,\n     ranges::RANGE_MINUS_ONE,\n     ranges::RANGE_PLUS_ONE,\n-    ranges::RANGE_ZIP_WITH_LEN,\n     ranges::REVERSED_EMPTY_RANGES,\n     rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT,\n     read_zero_byte_vec::READ_ZERO_BYTE_VEC,\n@@ -489,7 +495,6 @@ store.register_lints(&[\n     reference::DEREF_ADDROF,\n     regex::INVALID_REGEX,\n     regex::TRIVIAL_REGEX,\n-    repeat_once::REPEAT_ONCE,\n     return_self_not_must_use::RETURN_SELF_NOT_MUST_USE,\n     returns::LET_AND_RETURN,\n     returns::NEEDLESS_RETURN,\n@@ -504,7 +509,6 @@ store.register_lints(&[\n     single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS,\n     size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT,\n     slow_vector_initialization::SLOW_VECTOR_INITIALIZATION,\n-    stable_sort_primitive::STABLE_SORT_PRIMITIVE,\n     std_instead_of_core::ALLOC_INSTEAD_OF_CORE,\n     std_instead_of_core::STD_INSTEAD_OF_ALLOC,\n     std_instead_of_core::STD_INSTEAD_OF_CORE,\n@@ -540,10 +544,10 @@ store.register_lints(&[\n     transmute::TRANSMUTE_PTR_TO_PTR,\n     transmute::TRANSMUTE_PTR_TO_REF,\n     transmute::TRANSMUTE_UNDEFINED_REPR,\n+    transmute::TRANSMUTING_NULL,\n     transmute::UNSOUND_COLLECTION_TRANSMUTE,\n     transmute::USELESS_TRANSMUTE,\n     transmute::WRONG_TRANSMUTE,\n-    transmuting_null::TRANSMUTING_NULL,\n     types::BORROWED_BOX,\n     types::BOX_COLLECTION,\n     types::LINKEDLIST,\n@@ -558,7 +562,6 @@ store.register_lints(&[\n     unicode::NON_ASCII_LITERAL,\n     unicode::UNICODE_NOT_NFC,\n     uninit_vec::UNINIT_VEC,\n-    unit_hash::UNIT_HASH,\n     unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD,\n     unit_types::LET_UNIT_VALUE,\n     unit_types::UNIT_ARG,\n@@ -567,7 +570,6 @@ store.register_lints(&[\n     unnamed_address::VTABLE_ADDRESS_COMPARISONS,\n     unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS,\n     unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS,\n-    unnecessary_sort_by::UNNECESSARY_SORT_BY,\n     unnecessary_wraps::UNNECESSARY_WRAPS,\n     unnested_or_patterns::UNNESTED_OR_PATTERNS,\n     unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,\n@@ -584,8 +586,6 @@ store.register_lints(&[\n     useless_conversion::USELESS_CONVERSION,\n     vec::USELESS_VEC,\n     vec_init_then_push::VEC_INIT_THEN_PUSH,\n-    vec_resize_to_zero::VEC_RESIZE_TO_ZERO,\n-    verbose_file_reads::VERBOSE_FILE_READS,\n     wildcard_imports::ENUM_GLOB_USE,\n     wildcard_imports::WILDCARD_IMPORTS,\n     write::POSITIONAL_NAMED_FORMAT_PARAMETERS,"}, {"sha": "dc50816452f351b165232d51c92ed931c53f8b85", "filename": "clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -17,6 +17,7 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(methods::ITER_ON_EMPTY_COLLECTIONS),\n     LintId::of(methods::ITER_ON_SINGLE_ITEMS),\n     LintId::of(methods::ITER_WITH_DRAIN),\n+    LintId::of(methods::PATH_BUF_PUSH_OVERWRITE),\n     LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n     LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n     LintId::of(mutex_atomic::MUTEX_ATOMIC),\n@@ -25,7 +26,6 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n     LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(option_if_let_else::OPTION_IF_LET_ELSE),\n-    LintId::of(path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE),\n     LintId::of(redundant_pub_crate::REDUNDANT_PUB_CRATE),\n     LintId::of(regex::TRIVIAL_REGEX),\n     LintId::of(strings::STRING_LIT_AS_BYTES),"}, {"sha": "13474127e8d75c9681bc61f530593f0c527916cb", "filename": "clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -4,9 +4,7 @@\n \n store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(attrs::INLINE_ALWAYS),\n-    LintId::of(borrow_as_ptr::BORROW_AS_PTR),\n-    LintId::of(bytecount::NAIVE_BYTECOUNT),\n-    LintId::of(case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS),\n+    LintId::of(casts::BORROW_AS_PTR),\n     LintId::of(casts::CAST_LOSSLESS),\n     LintId::of(casts::CAST_POSSIBLE_TRUNCATION),\n     LintId::of(casts::CAST_POSSIBLE_WRAP),\n@@ -50,20 +48,23 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(macro_use::MACRO_USE_IMPORTS),\n     LintId::of(manual_assert::MANUAL_ASSERT),\n     LintId::of(manual_instant_elapsed::MANUAL_INSTANT_ELAPSED),\n-    LintId::of(manual_ok_or::MANUAL_OK_OR),\n     LintId::of(matches::MATCH_BOOL),\n     LintId::of(matches::MATCH_ON_VEC_ITEMS),\n     LintId::of(matches::MATCH_SAME_ARMS),\n     LintId::of(matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS),\n     LintId::of(matches::MATCH_WILD_ERR_ARM),\n     LintId::of(matches::SINGLE_MATCH_ELSE),\n+    LintId::of(methods::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS),\n     LintId::of(methods::CLONED_INSTEAD_OF_COPIED),\n     LintId::of(methods::FILTER_MAP_NEXT),\n     LintId::of(methods::FLAT_MAP_OPTION),\n     LintId::of(methods::FROM_ITER_INSTEAD_OF_COLLECT),\n     LintId::of(methods::IMPLICIT_CLONE),\n     LintId::of(methods::INEFFICIENT_TO_STRING),\n+    LintId::of(methods::MANUAL_OK_OR),\n     LintId::of(methods::MAP_UNWRAP_OR),\n+    LintId::of(methods::NAIVE_BYTECOUNT),\n+    LintId::of(methods::STABLE_SORT_PRIMITIVE),\n     LintId::of(methods::UNNECESSARY_JOIN),\n     LintId::of(misc::USED_UNDERSCORE_BINDING),\n     LintId::of(mismatching_type_param_order::MISMATCHING_TYPE_PARAM_ORDER),\n@@ -85,7 +86,6 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(ref_option_ref::REF_OPTION_REF),\n     LintId::of(return_self_not_must_use::RETURN_SELF_NOT_MUST_USE),\n     LintId::of(semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED),\n-    LintId::of(stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n     LintId::of(strings::STRING_ADD_ASSIGN),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_PTR),\n     LintId::of(types::LINKEDLIST),"}, {"sha": "dd1e1e1a8e33d82088578a75adcaa49cf7db7128", "filename": "clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -4,11 +4,11 @@\n \n store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n     LintId::of(as_conversions::AS_CONVERSIONS),\n-    LintId::of(as_underscore::AS_UNDERSCORE),\n     LintId::of(asm_syntax::INLINE_ASM_X86_ATT_SYNTAX),\n     LintId::of(asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX),\n     LintId::of(assertions_on_result_states::ASSERTIONS_ON_RESULT_STATES),\n     LintId::of(attrs::ALLOW_ATTRIBUTES_WITHOUT_REASON),\n+    LintId::of(casts::AS_UNDERSCORE),\n     LintId::of(casts::FN_TO_NUMERIC_CAST_ANY),\n     LintId::of(create_dir::CREATE_DIR),\n     LintId::of(dbg_macro::DBG_MACRO),\n@@ -30,7 +30,6 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(large_include_file::LARGE_INCLUDE_FILE),\n     LintId::of(let_underscore::LET_UNDERSCORE_MUST_USE),\n     LintId::of(literal_representation::DECIMAL_LITERAL_REPRESENTATION),\n-    LintId::of(map_err_ignore::MAP_ERR_IGNORE),\n     LintId::of(matches::REST_PAT_IN_FULLY_BOUND_STRUCTS),\n     LintId::of(matches::TRY_ERR),\n     LintId::of(matches::WILDCARD_ENUM_MATCH_ARM),\n@@ -39,7 +38,9 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(methods::EXPECT_USED),\n     LintId::of(methods::FILETYPE_IS_FILE),\n     LintId::of(methods::GET_UNWRAP),\n+    LintId::of(methods::MAP_ERR_IGNORE),\n     LintId::of(methods::UNWRAP_USED),\n+    LintId::of(methods::VERBOSE_FILE_READS),\n     LintId::of(misc_early::SEPARATED_LITERAL_SUFFIX),\n     LintId::of(misc_early::UNNEEDED_FIELD_PATTERN),\n     LintId::of(misc_early::UNSEPARATED_LITERAL_SUFFIX),\n@@ -81,7 +82,6 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(unicode::NON_ASCII_LITERAL),\n     LintId::of(unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS),\n     LintId::of(unwrap_in_result::UNWRAP_IN_RESULT),\n-    LintId::of(verbose_file_reads::VERBOSE_FILE_READS),\n     LintId::of(write::PRINT_STDERR),\n     LintId::of(write::PRINT_STDOUT),\n     LintId::of(write::USE_DEBUG),"}, {"sha": "d34aadd1d3773d327010f2d659ba9da64ef5a2da", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -29,7 +29,6 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(functions::DOUBLE_MUST_USE),\n     LintId::of(functions::MUST_USE_UNIT),\n     LintId::of(functions::RESULT_UNIT_ERR),\n-    LintId::of(get_first::GET_FIRST),\n     LintId::of(inherent_to_string::INHERENT_TO_STRING),\n     LintId::of(init_numbered_fields::INIT_NUMBERED_FIELDS),\n     LintId::of(len_zero::COMPARISON_TO_EMPTY),\n@@ -46,7 +45,6 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(manual_bits::MANUAL_BITS),\n     LintId::of(manual_empty_string_creations::MANUAL_EMPTY_STRING_CREATIONS),\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n-    LintId::of(map_clone::MAP_CLONE),\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n     LintId::of(matches::COLLAPSIBLE_MATCH),\n     LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n@@ -62,14 +60,17 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(methods::CHARS_LAST_CMP),\n     LintId::of(methods::CHARS_NEXT_CMP),\n     LintId::of(methods::ERR_EXPECT),\n+    LintId::of(methods::GET_FIRST),\n     LintId::of(methods::INTO_ITER_ON_REF),\n     LintId::of(methods::IS_DIGIT_ASCII_RADIX),\n     LintId::of(methods::ITER_CLONED_COLLECT),\n     LintId::of(methods::ITER_NEXT_SLICE),\n     LintId::of(methods::ITER_NTH_ZERO),\n     LintId::of(methods::ITER_SKIP_NEXT),\n     LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n+    LintId::of(methods::MAP_CLONE),\n     LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n+    LintId::of(methods::MUT_MUTEX_LOCK),\n     LintId::of(methods::NEW_RET_NO_SELF),\n     LintId::of(methods::OBFUSCATED_IF_ELSE),\n     LintId::of(methods::OK_EXPECT),\n@@ -89,7 +90,6 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(misc_early::DUPLICATE_UNDERSCORE_ARGUMENT),\n     LintId::of(misc_early::MIXED_CASE_HEX_LITERALS),\n     LintId::of(misc_early::REDUNDANT_PATTERN),\n-    LintId::of(mut_mutex_lock::MUT_MUTEX_LOCK),\n     LintId::of(mut_reference::UNNECESSARY_MUT_PASSED),\n     LintId::of(needless_late_init::NEEDLESS_LATE_INIT),\n     LintId::of(needless_parens_on_range_literals::NEEDLESS_PARENS_ON_RANGE_LITERALS),"}, {"sha": "dbea55a04d62d8ae78bb7ae766009b078c4b06ec", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -170,7 +170,6 @@ mod renamed_lints;\n mod almost_complete_letter_range;\n mod approx_const;\n mod as_conversions;\n-mod as_underscore;\n mod asm_syntax;\n mod assertions_on_constants;\n mod assertions_on_result_states;\n@@ -180,12 +179,8 @@ mod await_holding_invalid;\n mod blocks_in_if_conditions;\n mod bool_assert_comparison;\n mod booleans;\n-mod borrow_as_ptr;\n mod borrow_deref_ref;\n-mod bytecount;\n-mod bytes_count_to_len;\n mod cargo;\n-mod case_sensitive_file_extension_comparisons;\n mod casts;\n mod checked_conversions;\n mod cognitive_complexity;\n@@ -238,7 +233,6 @@ mod from_over_into;\n mod from_str_radix_10;\n mod functions;\n mod future_not_send;\n-mod get_first;\n mod if_let_mutex;\n mod if_not_else;\n mod if_then_some_else_none;\n@@ -276,12 +270,9 @@ mod manual_bits;\n mod manual_empty_string_creations;\n mod manual_instant_elapsed;\n mod manual_non_exhaustive;\n-mod manual_ok_or;\n mod manual_rem_euclid;\n mod manual_retain;\n mod manual_strip;\n-mod map_clone;\n-mod map_err_ignore;\n mod map_unit_fn;\n mod match_result_ok;\n mod matches;\n@@ -300,7 +291,6 @@ mod mixed_read_write_in_expression;\n mod module_style;\n mod mut_key;\n mod mut_mut;\n-mod mut_mutex_lock;\n mod mut_reference;\n mod mutable_debug_assertion;\n mod mutex_atomic;\n@@ -325,7 +315,6 @@ mod non_send_fields_in_send_ty;\n mod nonstandard_macro_braces;\n mod octal_escapes;\n mod only_used_in_recursion;\n-mod open_options;\n mod operators;\n mod option_env_unwrap;\n mod option_if_let_else;\n@@ -335,7 +324,6 @@ mod panic_unimplemented;\n mod partialeq_ne_impl;\n mod partialeq_to_none;\n mod pass_by_ref_or_value;\n-mod path_buf_push_overwrite;\n mod pattern_type_mismatch;\n mod precedence;\n mod ptr;\n@@ -355,7 +343,6 @@ mod redundant_static_lifetimes;\n mod ref_option_ref;\n mod reference;\n mod regex;\n-mod repeat_once;\n mod return_self_not_must_use;\n mod returns;\n mod same_name_method;\n@@ -367,7 +354,6 @@ mod single_char_lifetime_names;\n mod single_component_path_imports;\n mod size_of_in_element_count;\n mod slow_vector_initialization;\n-mod stable_sort_primitive;\n mod std_instead_of_core;\n mod strings;\n mod strlen_on_c_strings;\n@@ -381,18 +367,15 @@ mod to_digit_is_some;\n mod trailing_empty_array;\n mod trait_bounds;\n mod transmute;\n-mod transmuting_null;\n mod types;\n mod undocumented_unsafe_blocks;\n mod unicode;\n mod uninit_vec;\n-mod unit_hash;\n mod unit_return_expecting_ord;\n mod unit_types;\n mod unnamed_address;\n mod unnecessary_owned_empty_strings;\n mod unnecessary_self_imports;\n-mod unnecessary_sort_by;\n mod unnecessary_wraps;\n mod unnested_or_patterns;\n mod unsafe_removed_from_name;\n@@ -408,8 +391,6 @@ mod use_self;\n mod useless_conversion;\n mod vec;\n mod vec_init_then_push;\n-mod vec_resize_to_zero;\n-mod verbose_file_reads;\n mod wildcard_imports;\n mod write;\n mod zero_div_zero;\n@@ -597,7 +578,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(blocks_in_if_conditions::BlocksInIfConditions));\n     store.register_late_pass(|| Box::new(unicode::Unicode));\n     store.register_late_pass(|| Box::new(uninit_vec::UninitVec));\n-    store.register_late_pass(|| Box::new(unit_hash::UnitHash));\n     store.register_late_pass(|| Box::new(unit_return_expecting_ord::UnitReturnExpectingOrd));\n     store.register_late_pass(|| Box::new(strings::StringAdd));\n     store.register_late_pass(|| Box::new(implicit_return::ImplicitReturn));\n@@ -635,8 +615,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(needless_question_mark::NeedlessQuestionMark));\n     store.register_late_pass(move || Box::new(casts::Casts::new(msrv)));\n     store.register_early_pass(move || Box::new(unnested_or_patterns::UnnestedOrPatterns::new(msrv)));\n-    store.register_late_pass(move || Box::new(map_clone::MapClone::new(msrv)));\n-\n     store.register_late_pass(|| Box::new(size_of_in_element_count::SizeOfInElementCount));\n     store.register_late_pass(|| Box::new(same_name_method::SameNameMethod));\n     let max_suggested_slice_pattern_length = conf.max_suggested_slice_pattern_length;\n@@ -646,15 +624,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n             msrv,\n         ))\n     });\n-    store.register_late_pass(|| Box::new(map_err_ignore::MapErrIgnore));\n     store.register_late_pass(|| Box::new(shadow::Shadow::default()));\n     store.register_late_pass(|| Box::new(unit_types::UnitTypes));\n     store.register_late_pass(|| Box::new(loops::Loops));\n     store.register_late_pass(|| Box::new(main_recursion::MainRecursion::default()));\n     store.register_late_pass(|| Box::new(lifetimes::Lifetimes));\n     store.register_late_pass(|| Box::new(entry::HashMapPass));\n     store.register_late_pass(|| Box::new(minmax::MinMaxPass));\n-    store.register_late_pass(|| Box::new(open_options::OpenOptions));\n     store.register_late_pass(|| Box::new(zero_div_zero::ZeroDiv));\n     store.register_late_pass(|| Box::new(mutex_atomic::Mutex));\n     store.register_late_pass(|| Box::new(needless_update::NeedlessUpdate));\n@@ -720,7 +696,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     );\n     store.register_late_pass(move || Box::new(pass_by_ref_or_value));\n     store.register_late_pass(|| Box::new(ref_option_ref::RefOptionRef));\n-    store.register_late_pass(|| Box::new(bytecount::ByteCount));\n     store.register_late_pass(|| Box::new(infinite_iter::InfiniteIter));\n     store.register_late_pass(|| Box::new(inline_fn_without_body::InlineFnWithoutBody));\n     store.register_late_pass(|| Box::new(useless_conversion::UselessConversion::default()));\n@@ -738,12 +713,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(ptr_offset_with_cast::PtrOffsetWithCast));\n     store.register_late_pass(|| Box::new(redundant_clone::RedundantClone));\n     store.register_late_pass(|| Box::new(slow_vector_initialization::SlowVectorInit));\n-    store.register_late_pass(|| Box::new(unnecessary_sort_by::UnnecessarySortBy));\n     store.register_late_pass(move || Box::new(unnecessary_wraps::UnnecessaryWraps::new(avoid_breaking_exported_api)));\n     store.register_late_pass(|| Box::new(assertions_on_constants::AssertionsOnConstants));\n     store.register_late_pass(|| Box::new(assertions_on_result_states::AssertionsOnResultStates));\n-    store.register_late_pass(|| Box::new(transmuting_null::TransmutingNull));\n-    store.register_late_pass(|| Box::new(path_buf_push_overwrite::PathBufPushOverwrite));\n     store.register_late_pass(|| Box::new(inherent_to_string::InherentToString));\n     let max_trait_bounds = conf.max_trait_bounds;\n     store.register_late_pass(move || Box::new(trait_bounds::TraitBounds::new(max_trait_bounds)));\n@@ -819,7 +791,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| Box::new(option_env_unwrap::OptionEnvUnwrap));\n     let warn_on_all_wildcard_imports = conf.warn_on_all_wildcard_imports;\n     store.register_late_pass(move || Box::new(wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports)));\n-    store.register_late_pass(|| Box::new(verbose_file_reads::VerboseFileReads));\n     store.register_late_pass(|| Box::new(redundant_pub_crate::RedundantPubCrate::default()));\n     store.register_late_pass(|| Box::new(unnamed_address::UnnamedAddress));\n     store.register_late_pass(move || Box::new(dereference::Dereferencing::new(msrv)));\n@@ -828,9 +799,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(if_let_mutex::IfLetMutex));\n     store.register_late_pass(|| Box::new(if_not_else::IfNotElse));\n     store.register_late_pass(|| Box::new(equatable_if_let::PatternEquality));\n-    store.register_late_pass(|| Box::new(mut_mutex_lock::MutMutexLock));\n     store.register_late_pass(|| Box::new(manual_async_fn::ManualAsyncFn));\n-    store.register_late_pass(|| Box::new(vec_resize_to_zero::VecResizeToZero));\n     store.register_late_pass(|| Box::new(panic_in_result_fn::PanicInResultFn));\n     let single_char_binding_names_threshold = conf.single_char_binding_names_threshold;\n     store.register_early_pass(move || {\n@@ -842,10 +811,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(move || Box::new(nonstandard_macro_braces::MacroBraces::new(&macro_matcher)));\n     store.register_late_pass(|| Box::new(macro_use::MacroUseImports::default()));\n     store.register_late_pass(|| Box::new(pattern_type_mismatch::PatternTypeMismatch));\n-    store.register_late_pass(|| Box::new(stable_sort_primitive::StableSortPrimitive));\n-    store.register_late_pass(|| Box::new(repeat_once::RepeatOnce));\n     store.register_late_pass(|| Box::new(unwrap_in_result::UnwrapInResult));\n-    store.register_late_pass(|| Box::new(manual_ok_or::ManualOkOr));\n     store.register_late_pass(|| Box::new(semicolon_if_nothing_returned::SemicolonIfNothingReturned));\n     store.register_late_pass(|| Box::new(async_yields_async::AsyncYieldsAsync));\n     let disallowed_methods = conf.disallowed_methods.clone();\n@@ -857,9 +823,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(strings::StringToString));\n     store.register_late_pass(|| Box::new(zero_sized_map_values::ZeroSizedMapValues));\n     store.register_late_pass(|| Box::new(vec_init_then_push::VecInitThenPush::default()));\n-    store.register_late_pass(|| {\n-        Box::new(case_sensitive_file_extension_comparisons::CaseSensitiveFileExtensionComparisons)\n-    });\n     store.register_late_pass(|| Box::new(redundant_slicing::RedundantSlicing));\n     store.register_late_pass(|| Box::new(from_str_radix_10::FromStrRadix10));\n     store.register_late_pass(move || Box::new(if_then_some_else_none::IfThenSomeElseNone::new(msrv)));\n@@ -894,7 +857,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(return_self_not_must_use::ReturnSelfNotMustUse));\n     store.register_late_pass(|| Box::new(init_numbered_fields::NumberedFields));\n     store.register_early_pass(|| Box::new(single_char_lifetime_names::SingleCharLifetimeNames));\n-    store.register_late_pass(move || Box::new(borrow_as_ptr::BorrowAsPtr::new(msrv)));\n     store.register_late_pass(move || Box::new(manual_bits::ManualBits::new(msrv)));\n     store.register_late_pass(|| Box::new(default_union_representation::DefaultUnionRepresentation));\n     store.register_early_pass(|| Box::new(doc_link_with_quotes::DocLinkWithQuotes));\n@@ -912,18 +874,15 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(unnecessary_owned_empty_strings::UnnecessaryOwnedEmptyStrings));\n     store.register_early_pass(|| Box::new(pub_use::PubUse));\n     store.register_late_pass(|| Box::new(format_push_string::FormatPushString));\n-    store.register_late_pass(|| Box::new(bytes_count_to_len::BytesCountToLen));\n     let max_include_file_size = conf.max_include_file_size;\n     store.register_late_pass(move || Box::new(large_include_file::LargeIncludeFile::new(max_include_file_size)));\n     store.register_late_pass(|| Box::new(strings::TrimSplitWhitespace));\n     store.register_late_pass(|| Box::new(rc_clone_in_vec_init::RcCloneInVecInit));\n     store.register_early_pass(|| Box::new(duplicate_mod::DuplicateMod::default()));\n-    store.register_late_pass(|| Box::new(get_first::GetFirst));\n     store.register_early_pass(|| Box::new(unused_rounding::UnusedRounding));\n     store.register_early_pass(move || Box::new(almost_complete_letter_range::AlmostCompleteLetterRange::new(msrv)));\n     store.register_late_pass(|| Box::new(swap_ptr_to_ref::SwapPtrToRef));\n     store.register_late_pass(|| Box::new(mismatching_type_param_order::TypeParamMismatch));\n-    store.register_late_pass(|| Box::new(as_underscore::AsUnderscore));\n     store.register_late_pass(|| Box::new(read_zero_byte_vec::ReadZeroByteVec));\n     store.register_late_pass(|| Box::new(default_instead_of_iter_empty::DefaultIterEmpty));\n     store.register_late_pass(move || Box::new(manual_rem_euclid::ManualRemEuclid::new(msrv)));"}, {"sha": "cf5004399b884cb67e8e1553e4d7aaa9ab9eba5f", "filename": "clippy_lints/src/manual_ok_or.rs", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_ok_or.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,95 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_lang_ctor, path_to_local_id};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{ResultErr, ResultOk};\n-use rustc_hir::{Closure, Expr, ExprKind, PatKind};\n-use rustc_lint::LintContext;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    ///\n-    /// Finds patterns that reimplement `Option::ok_or`.\n-    ///\n-    /// ### Why is this bad?\n-    ///\n-    /// Concise code helps focusing on behavior instead of boilerplate.\n-    ///\n-    /// ### Examples\n-    /// ```rust\n-    /// let foo: Option<i32> = None;\n-    /// foo.map_or(Err(\"error\"), |v| Ok(v));\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// let foo: Option<i32> = None;\n-    /// foo.ok_or(\"error\");\n-    /// ```\n-    #[clippy::version = \"1.49.0\"]\n-    pub MANUAL_OK_OR,\n-    pedantic,\n-    \"finds patterns that can be encoded more concisely with `Option::ok_or`\"\n-}\n-\n-declare_lint_pass!(ManualOkOr => [MANUAL_OK_OR]);\n-\n-impl<'tcx> LateLintPass<'tcx> for ManualOkOr {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, scrutinee: &'tcx Expr<'tcx>) {\n-        if in_external_macro(cx.sess(), scrutinee.span) {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::MethodCall(method_segment, [receiver, or_expr, map_expr], _) = scrutinee.kind;\n-            if method_segment.ident.name == sym!(map_or);\n-            let ty = cx.typeck_results().expr_ty(receiver);\n-            if is_type_diagnostic_item(cx, ty, sym::Option);\n-            if is_ok_wrapping(cx, map_expr);\n-            if let ExprKind::Call(Expr { kind: ExprKind::Path(err_path), .. }, &[ref err_arg]) = or_expr.kind;\n-            if is_lang_ctor(cx, err_path, ResultErr);\n-            if let Some(method_receiver_snippet) = snippet_opt(cx, receiver.span);\n-            if let Some(err_arg_snippet) = snippet_opt(cx, err_arg.span);\n-            if let Some(indent) = indent_of(cx, scrutinee.span);\n-            then {\n-                let reindented_err_arg_snippet =\n-                    reindent_multiline(err_arg_snippet.into(), true, Some(indent + 4));\n-                span_lint_and_sugg(\n-                    cx,\n-                    MANUAL_OK_OR,\n-                    scrutinee.span,\n-                    \"this pattern reimplements `Option::ok_or`\",\n-                    \"replace with\",\n-                    format!(\n-                        \"{}.ok_or({})\",\n-                        method_receiver_snippet,\n-                        reindented_err_arg_snippet\n-                    ),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Path(ref qpath) = map_expr.kind {\n-        if is_lang_ctor(cx, qpath, ResultOk) {\n-            return true;\n-        }\n-    }\n-    if_chain! {\n-        if let ExprKind::Closure(&Closure { body, .. }) = map_expr.kind;\n-        let body = cx.tcx.hir().body(body);\n-        if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind;\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(ok_path), .. }, &[ref ok_arg]) = body.value.kind;\n-        if is_lang_ctor(cx, ok_path, ResultOk);\n-        then { path_to_local_id(ok_arg, param_id) } else { false }\n-    }\n-}"}, {"sha": "95c312f1fe26b19216c0573697d3ca5cca040920", "filename": "clippy_lints/src/map_clone.rs", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,167 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::{is_copy, is_type_diagnostic_item};\n-use clippy_utils::{is_trait_method, meets_msrv, msrvs, peel_blocks};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::mir::Mutability;\n-use rustc_middle::ty;\n-use rustc_middle::ty::adjustment::Adjust;\n-use rustc_semver::RustcVersion;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::Ident;\n-use rustc_span::{sym, Span};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for usage of `map(|x| x.clone())` or\n-    /// dereferencing closures for `Copy` types, on `Iterator` or `Option`,\n-    /// and suggests `cloned()` or `copied()` instead\n-    ///\n-    /// ### Why is this bad?\n-    /// Readability, this can be written more concisely\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = vec![42, 43];\n-    /// let y = x.iter();\n-    /// let z = y.map(|i| *i);\n-    /// ```\n-    ///\n-    /// The correct use would be:\n-    ///\n-    /// ```rust\n-    /// let x = vec![42, 43];\n-    /// let y = x.iter();\n-    /// let z = y.cloned();\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MAP_CLONE,\n-    style,\n-    \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\"\n-}\n-\n-pub struct MapClone {\n-    msrv: Option<RustcVersion>,\n-}\n-\n-impl_lint_pass!(MapClone => [MAP_CLONE]);\n-\n-impl MapClone {\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self { msrv }\n-    }\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for MapClone {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, e: &hir::Expr<'_>) {\n-        if e.span.from_expansion() {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let hir::ExprKind::MethodCall(method, args, _) = e.kind;\n-            if args.len() == 2;\n-            if method.ident.name == sym::map;\n-            let ty = cx.typeck_results().expr_ty(&args[0]);\n-            if is_type_diagnostic_item(cx, ty, sym::Option) || is_trait_method(cx, e, sym::Iterator);\n-            if let hir::ExprKind::Closure(&hir::Closure { body, .. }) = args[1].kind;\n-            then {\n-                let closure_body = cx.tcx.hir().body(body);\n-                let closure_expr = peel_blocks(&closure_body.value);\n-                match closure_body.params[0].pat.kind {\n-                    hir::PatKind::Ref(inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n-                        hir::BindingAnnotation::Unannotated, .., name, None\n-                    ) = inner.kind {\n-                        if ident_eq(name, closure_expr) {\n-                            self.lint_explicit_closure(cx, e.span, args[0].span, true);\n-                        }\n-                    },\n-                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, .., name, None) => {\n-                        match closure_expr.kind {\n-                            hir::ExprKind::Unary(hir::UnOp::Deref, inner) => {\n-                                if ident_eq(name, inner) {\n-                                    if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind() {\n-                                        self.lint_explicit_closure(cx, e.span, args[0].span, true);\n-                                    }\n-                                }\n-                            },\n-                            hir::ExprKind::MethodCall(method, [obj], _) => if_chain! {\n-                                if ident_eq(name, obj) && method.ident.name == sym::clone;\n-                                if let Some(fn_id) = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id);\n-                                if let Some(trait_id) = cx.tcx.trait_of_item(fn_id);\n-                                if cx.tcx.lang_items().clone_trait().map_or(false, |id| id == trait_id);\n-                                // no autoderefs\n-                                if !cx.typeck_results().expr_adjustments(obj).iter()\n-                                    .any(|a| matches!(a.kind, Adjust::Deref(Some(..))));\n-                                then {\n-                                    let obj_ty = cx.typeck_results().expr_ty(obj);\n-                                    if let ty::Ref(_, ty, mutability) = obj_ty.kind() {\n-                                        if matches!(mutability, Mutability::Not) {\n-                                            let copy = is_copy(cx, *ty);\n-                                            self.lint_explicit_closure(cx, e.span, args[0].span, copy);\n-                                        }\n-                                    } else {\n-                                        lint_needless_cloning(cx, e.span, args[0].span);\n-                                    }\n-                                }\n-                            },\n-                            _ => {},\n-                        }\n-                    },\n-                    _ => {},\n-                }\n-            }\n-        }\n-    }\n-\n-    extract_msrv_attr!(LateContext);\n-}\n-\n-fn ident_eq(name: Ident, path: &hir::Expr<'_>) -> bool {\n-    if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = path.kind {\n-        path.segments.len() == 1 && path.segments[0].ident == name\n-    } else {\n-        false\n-    }\n-}\n-\n-fn lint_needless_cloning(cx: &LateContext<'_>, root: Span, receiver: Span) {\n-    span_lint_and_sugg(\n-        cx,\n-        MAP_CLONE,\n-        root.trim_start(receiver).unwrap(),\n-        \"you are needlessly cloning iterator elements\",\n-        \"remove the `map` call\",\n-        String::new(),\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n-impl MapClone {\n-    fn lint_explicit_closure(&self, cx: &LateContext<'_>, replace: Span, root: Span, is_copy: bool) {\n-        let mut applicability = Applicability::MachineApplicable;\n-\n-        let (message, sugg_method) = if is_copy && meets_msrv(self.msrv, msrvs::ITERATOR_COPIED) {\n-            (\"you are using an explicit closure for copying elements\", \"copied\")\n-        } else {\n-            (\"you are using an explicit closure for cloning elements\", \"cloned\")\n-        };\n-\n-        span_lint_and_sugg(\n-            cx,\n-            MAP_CLONE,\n-            replace,\n-            message,\n-            &format!(\"consider calling the dedicated `{}` method\", sugg_method),\n-            format!(\n-                \"{}.{}()\",\n-                snippet_with_applicability(cx, root, \"..\", &mut applicability),\n-                sugg_method,\n-            ),\n-            applicability,\n-        );\n-    }\n-}"}, {"sha": "1e542447c96eca92b3668e723c5bef92393abb68", "filename": "clippy_lints/src/map_err_ignore.rs", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_err_ignore.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,154 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use rustc_hir::{CaptureBy, Closure, Expr, ExprKind, PatKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for instances of `map_err(|_| Some::Enum)`\n-    ///\n-    /// ### Why is this bad?\n-    /// This `map_err` throws away the original error rather than allowing the enum to contain and report the cause of the error\n-    ///\n-    /// ### Example\n-    /// Before:\n-    /// ```rust\n-    /// use std::fmt;\n-    ///\n-    /// #[derive(Debug)]\n-    /// enum Error {\n-    ///     Indivisible,\n-    ///     Remainder(u8),\n-    /// }\n-    ///\n-    /// impl fmt::Display for Error {\n-    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-    ///         match self {\n-    ///             Error::Indivisible => write!(f, \"could not divide input by three\"),\n-    ///             Error::Remainder(remainder) => write!(\n-    ///                 f,\n-    ///                 \"input is not divisible by three, remainder = {}\",\n-    ///                 remainder\n-    ///             ),\n-    ///         }\n-    ///     }\n-    /// }\n-    ///\n-    /// impl std::error::Error for Error {}\n-    ///\n-    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n-    ///     input\n-    ///         .parse::<i32>()\n-    ///         .map_err(|_| Error::Indivisible)\n-    ///         .map(|v| v % 3)\n-    ///         .and_then(|remainder| {\n-    ///             if remainder == 0 {\n-    ///                 Ok(())\n-    ///             } else {\n-    ///                 Err(Error::Remainder(remainder as u8))\n-    ///             }\n-    ///         })\n-    /// }\n-    ///  ```\n-    ///\n-    ///  After:\n-    ///  ```rust\n-    /// use std::{fmt, num::ParseIntError};\n-    ///\n-    /// #[derive(Debug)]\n-    /// enum Error {\n-    ///     Indivisible(ParseIntError),\n-    ///     Remainder(u8),\n-    /// }\n-    ///\n-    /// impl fmt::Display for Error {\n-    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-    ///         match self {\n-    ///             Error::Indivisible(_) => write!(f, \"could not divide input by three\"),\n-    ///             Error::Remainder(remainder) => write!(\n-    ///                 f,\n-    ///                 \"input is not divisible by three, remainder = {}\",\n-    ///                 remainder\n-    ///             ),\n-    ///         }\n-    ///     }\n-    /// }\n-    ///\n-    /// impl std::error::Error for Error {\n-    ///     fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n-    ///         match self {\n-    ///             Error::Indivisible(source) => Some(source),\n-    ///             _ => None,\n-    ///         }\n-    ///     }\n-    /// }\n-    ///\n-    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n-    ///     input\n-    ///         .parse::<i32>()\n-    ///         .map_err(Error::Indivisible)\n-    ///         .map(|v| v % 3)\n-    ///         .and_then(|remainder| {\n-    ///             if remainder == 0 {\n-    ///                 Ok(())\n-    ///             } else {\n-    ///                 Err(Error::Remainder(remainder as u8))\n-    ///             }\n-    ///         })\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.48.0\"]\n-    pub MAP_ERR_IGNORE,\n-    restriction,\n-    \"`map_err` should not ignore the original error\"\n-}\n-\n-declare_lint_pass!(MapErrIgnore => [MAP_ERR_IGNORE]);\n-\n-impl<'tcx> LateLintPass<'tcx> for MapErrIgnore {\n-    // do not try to lint if this is from a macro or desugaring\n-    fn check_expr(&mut self, cx: &LateContext<'_>, e: &Expr<'_>) {\n-        if e.span.from_expansion() {\n-            return;\n-        }\n-\n-        // check if this is a method call (e.g. x.foo())\n-        if let ExprKind::MethodCall(method, [_, arg], _) = e.kind {\n-            // only work if the method name is `map_err` and there are only 2 arguments (e.g. x.map_err(|_|[1]\n-            // Enum::Variant[2]))\n-            if method.ident.name == sym!(map_err) {\n-                // make sure the first argument is a closure, and grab the CaptureRef, BodyId, and fn_decl_span\n-                // fields\n-                if let ExprKind::Closure(&Closure {\n-                    capture_clause,\n-                    body,\n-                    fn_decl_span,\n-                    ..\n-                }) = arg.kind\n-                {\n-                    // check if this is by Reference (meaning there's no move statement)\n-                    if capture_clause == CaptureBy::Ref {\n-                        // Get the closure body to check the parameters and values\n-                        let closure_body = cx.tcx.hir().body(body);\n-                        // make sure there's only one parameter (`|_|`)\n-                        if closure_body.params.len() == 1 {\n-                            // make sure that parameter is the wild token (`_`)\n-                            if let PatKind::Wild = closure_body.params[0].pat.kind {\n-                                // span the area of the closure capture and warn that the\n-                                // original error will be thrown away\n-                                span_lint_and_help(\n-                                    cx,\n-                                    MAP_ERR_IGNORE,\n-                                    fn_decl_span,\n-                                    \"`map_err(|_|...` wildcard pattern discards the original error\",\n-                                    None,\n-                                    \"consider storing the original error as a source in the new error, or silence this warning using an ignored identifier (`.map_err(|_foo| ...`)\",\n-                                );\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "6a7c63d76f72c8afee58a465bec5ba33a21e5436", "filename": "clippy_lints/src/methods/bytecount.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,70 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::visitors::is_local_used;\n+use clippy_utils::{path_to_local_id, paths, peel_blocks, peel_ref_operators, strip_pat_refs};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Closure, Expr, ExprKind, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, UintTy};\n+use rustc_span::sym;\n+\n+use super::NAIVE_BYTECOUNT;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    filter_recv: &'tcx Expr<'_>,\n+    filter_arg: &'tcx Expr<'_>,\n+) {\n+    if_chain! {\n+        if let ExprKind::Closure(&Closure { body, .. }) = filter_arg.kind;\n+        let body = cx.tcx.hir().body(body);\n+        if let [param] = body.params;\n+        if let PatKind::Binding(_, arg_id, _, _) = strip_pat_refs(param.pat).kind;\n+        if let ExprKind::Binary(ref op, l, r) = body.value.kind;\n+        if op.node == BinOpKind::Eq;\n+        if match_type(cx,\n+                    cx.typeck_results().expr_ty(filter_recv).peel_refs(),\n+                    &paths::SLICE_ITER);\n+        let operand_is_arg = |expr| {\n+            let expr = peel_ref_operators(cx, peel_blocks(expr));\n+            path_to_local_id(expr, arg_id)\n+        };\n+        let needle = if operand_is_arg(l) {\n+            r\n+        } else if operand_is_arg(r) {\n+            l\n+        } else {\n+            return;\n+        };\n+        if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n+        if !is_local_used(cx, needle, arg_id);\n+        then {\n+            let haystack = if let ExprKind::MethodCall(path, args, _) =\n+                    filter_recv.kind {\n+                let p = path.ident.name;\n+                if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n+                    &args[0]\n+                } else {\n+                    filter_recv\n+                }\n+            } else {\n+                filter_recv\n+            };\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            span_lint_and_sugg(\n+                cx,\n+                NAIVE_BYTECOUNT,\n+                expr.span,\n+                \"you appear to be counting bytes the naive way\",\n+                \"consider using the bytecount crate\",\n+                format!(\"bytecount::count({}, {})\",\n+                        snippet_with_applicability(cx, haystack.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, needle.span, \"..\", &mut applicability)),\n+                applicability,\n+            );\n+        }\n+    };\n+}"}, {"sha": "fcfc25b523dac4d6dc16ff284fea4fe55e4d2e2f", "filename": "clippy_lints/src/methods/bytes_count_to_len.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fbytes_count_to_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fbytes_count_to_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbytes_count_to_len.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,37 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::BYTES_COUNT_TO_LEN;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    count_recv: &'tcx hir::Expr<'_>,\n+    bytes_recv: &'tcx hir::Expr<'_>,\n+) {\n+    if_chain! {\n+        if let Some(bytes_id) = cx.typeck_results().type_dependent_def_id(count_recv.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(bytes_id);\n+        if cx.tcx.type_of(impl_id).is_str();\n+        let ty = cx.typeck_results().expr_ty(bytes_recv).peel_refs();\n+        if ty.is_str() || is_type_diagnostic_item(cx, ty, sym::String);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                BYTES_COUNT_TO_LEN,\n+                expr.span,\n+                \"using long and hard to read `.bytes().count()`\",\n+                \"consider calling `.len()` instead\",\n+                format!(\"{}.len()\", snippet_with_applicability(cx, bytes_recv.span, \"..\", &mut applicability)),\n+                applicability\n+            );\n+        }\n+    };\n+}"}, {"sha": "b3c2c7c9a2dcc3a70cac63fe2363ecf238a1d514", "filename": "clippy_lints/src/methods/case_sensitive_file_extension_comparisons.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fcase_sensitive_file_extension_comparisons.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,41 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_span::{source_map::Spanned, symbol::sym, Span};\n+\n+use super::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    call_span: Span,\n+    recv: &'tcx Expr<'_>,\n+    arg: &'tcx Expr<'_>,\n+) {\n+    if_chain! {\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if cx.tcx.type_of(impl_id).is_str();\n+        if let ExprKind::Lit(Spanned { node: LitKind::Str(ext_literal, ..), ..}) = arg.kind;\n+        if (2..=6).contains(&ext_literal.as_str().len());\n+        let ext_str = ext_literal.as_str();\n+        if ext_str.starts_with('.');\n+        if ext_str.chars().skip(1).all(|c| c.is_uppercase() || c.is_ascii_digit())\n+            || ext_str.chars().skip(1).all(|c| c.is_lowercase() || c.is_ascii_digit());\n+        let recv_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n+        if recv_ty.is_str() || is_type_diagnostic_item(cx, recv_ty, sym::String);\n+        then {\n+            span_lint_and_help(\n+                cx,\n+                CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+                call_span,\n+                \"case-sensitive file extension comparison\",\n+                None,\n+                \"consider using a case-insensitive comparison instead\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "4de77de74042171a65e7092def7c30cad1895558", "filename": "clippy_lints/src/methods/get_first.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fget_first.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fget_first.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fget_first.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,39 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_slice_of_primitives;\n+use clippy_utils::source::snippet_with_applicability;\n+use if_chain::if_chain;\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Spanned;\n+\n+use super::GET_FIRST;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    recv: &'tcx hir::Expr<'_>,\n+    arg: &'tcx hir::Expr<'_>,\n+) {\n+    if_chain! {\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if cx.tcx.type_of(impl_id).is_slice();\n+        if let Some(_) = is_slice_of_primitives(cx, recv);\n+        if let hir::ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = arg.kind;\n+        then {\n+            let mut app = Applicability::MachineApplicable;\n+            let slice_name = snippet_with_applicability(cx, recv.span, \"..\", &mut app);\n+            span_lint_and_sugg(\n+                cx,\n+                GET_FIRST,\n+                expr.span,\n+                &format!(\"accessing first element with `{0}.get(0)`\", slice_name),\n+                \"try\",\n+                format!(\"{}.first()\", slice_name),\n+                app,\n+            );\n+        }\n+    }\n+}"}, {"sha": "ffd2f4a38b8ac1ac92ec391abca7716e811ebe7b", "filename": "clippy_lints/src/methods/manual_ok_or.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,64 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_lang_ctor, path_to_local_id};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{ResultErr, ResultOk};\n+use rustc_hir::{Closure, Expr, ExprKind, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use super::MANUAL_OK_OR;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    recv: &'tcx Expr<'_>,\n+    or_expr: &'tcx Expr<'_>,\n+    map_expr: &'tcx Expr<'_>,\n+) {\n+    if_chain! {\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::Option);\n+        if let ExprKind::Call(Expr { kind: ExprKind::Path(err_path), .. }, [err_arg]) = or_expr.kind;\n+        if is_lang_ctor(cx, err_path, ResultErr);\n+        if is_ok_wrapping(cx, map_expr);\n+        if let Some(recv_snippet) = snippet_opt(cx, recv.span);\n+        if let Some(err_arg_snippet) = snippet_opt(cx, err_arg.span);\n+        if let Some(indent) = indent_of(cx, expr.span);\n+        then {\n+            let reindented_err_arg_snippet = reindent_multiline(err_arg_snippet.into(), true, Some(indent + 4));\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_OK_OR,\n+                expr.span,\n+                \"this pattern reimplements `Option::ok_or`\",\n+                \"replace with\",\n+                format!(\n+                    \"{}.ok_or({})\",\n+                    recv_snippet,\n+                    reindented_err_arg_snippet\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n+    if let ExprKind::Path(ref qpath) = map_expr.kind {\n+        if is_lang_ctor(cx, qpath, ResultOk) {\n+            return true;\n+        }\n+    }\n+    if_chain! {\n+        if let ExprKind::Closure(&Closure { body, .. }) = map_expr.kind;\n+        let body = cx.tcx.hir().body(body);\n+        if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind;\n+        if let ExprKind::Call(Expr { kind: ExprKind::Path(ok_path), .. }, &[ref ok_arg]) = body.value.kind;\n+        if is_lang_ctor(cx, ok_path, ResultOk);\n+        then { path_to_local_id(ok_arg, param_id) } else { false }\n+    }\n+}"}, {"sha": "ffedda95ff8e57870170c940bebf4933f107e3e4", "filename": "clippy_lints/src/methods/map_clone.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,122 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::{is_copy, is_type_diagnostic_item};\n+use clippy_utils::{is_diag_trait_item, meets_msrv, msrvs, peel_blocks};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::mir::Mutability;\n+use rustc_middle::ty;\n+use rustc_middle::ty::adjustment::Adjust;\n+use rustc_semver::RustcVersion;\n+use rustc_span::symbol::Ident;\n+use rustc_span::{sym, Span};\n+\n+use super::MAP_CLONE;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'_>,\n+    e: &hir::Expr<'_>,\n+    recv: &hir::Expr<'_>,\n+    arg: &'tcx hir::Expr<'_>,\n+    msrv: Option<RustcVersion>,\n+) {\n+    if_chain! {\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(e.hir_id);\n+        if cx.tcx.impl_of_method(method_id)\n+            .map_or(false, |id| is_type_diagnostic_item(cx, cx.tcx.type_of(id), sym::Option))\n+            || is_diag_trait_item(cx, method_id, sym::Iterator);\n+        if let hir::ExprKind::Closure(&hir::Closure{ body, .. }) = arg.kind;\n+        then {\n+            let closure_body = cx.tcx.hir().body(body);\n+            let closure_expr = peel_blocks(&closure_body.value);\n+            match closure_body.params[0].pat.kind {\n+                hir::PatKind::Ref(inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n+                    hir::BindingAnnotation::Unannotated, .., name, None\n+                ) = inner.kind {\n+                    if ident_eq(name, closure_expr) {\n+                        lint_explicit_closure(cx, e.span, recv.span, true, msrv);\n+                    }\n+                },\n+                hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, .., name, None) => {\n+                    match closure_expr.kind {\n+                        hir::ExprKind::Unary(hir::UnOp::Deref, inner) => {\n+                            if ident_eq(name, inner) {\n+                                if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind() {\n+                                    lint_explicit_closure(cx, e.span, recv.span, true, msrv);\n+                                }\n+                            }\n+                        },\n+                        hir::ExprKind::MethodCall(method, [obj], _) => if_chain! {\n+                            if ident_eq(name, obj) && method.ident.name == sym::clone;\n+                            if let Some(fn_id) = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id);\n+                            if let Some(trait_id) = cx.tcx.trait_of_item(fn_id);\n+                            if cx.tcx.lang_items().clone_trait().map_or(false, |id| id == trait_id);\n+                            // no autoderefs\n+                            if !cx.typeck_results().expr_adjustments(obj).iter()\n+                                .any(|a| matches!(a.kind, Adjust::Deref(Some(..))));\n+                            then {\n+                                let obj_ty = cx.typeck_results().expr_ty(obj);\n+                                if let ty::Ref(_, ty, mutability) = obj_ty.kind() {\n+                                    if matches!(mutability, Mutability::Not) {\n+                                        let copy = is_copy(cx, *ty);\n+                                        lint_explicit_closure(cx, e.span, recv.span, copy, msrv);\n+                                    }\n+                                } else {\n+                                    lint_needless_cloning(cx, e.span, recv.span);\n+                                }\n+                            }\n+                        },\n+                        _ => {},\n+                    }\n+                },\n+                _ => {},\n+            }\n+        }\n+    }\n+}\n+\n+fn ident_eq(name: Ident, path: &hir::Expr<'_>) -> bool {\n+    if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = path.kind {\n+        path.segments.len() == 1 && path.segments[0].ident == name\n+    } else {\n+        false\n+    }\n+}\n+\n+fn lint_needless_cloning(cx: &LateContext<'_>, root: Span, receiver: Span) {\n+    span_lint_and_sugg(\n+        cx,\n+        MAP_CLONE,\n+        root.trim_start(receiver).unwrap(),\n+        \"you are needlessly cloning iterator elements\",\n+        \"remove the `map` call\",\n+        String::new(),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn lint_explicit_closure(cx: &LateContext<'_>, replace: Span, root: Span, is_copy: bool, msrv: Option<RustcVersion>) {\n+    let mut applicability = Applicability::MachineApplicable;\n+\n+    let (message, sugg_method) = if is_copy && meets_msrv(msrv, msrvs::ITERATOR_COPIED) {\n+        (\"you are using an explicit closure for copying elements\", \"copied\")\n+    } else {\n+        (\"you are using an explicit closure for cloning elements\", \"cloned\")\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        MAP_CLONE,\n+        replace,\n+        message,\n+        &format!(\"consider calling the dedicated `{}` method\", sugg_method),\n+        format!(\n+            \"{}.{}()\",\n+            snippet_with_applicability(cx, root, \"..\", &mut applicability),\n+            sugg_method,\n+        ),\n+        applicability,\n+    );\n+}"}, {"sha": "1fb6617145e718bb0a9f116f955a3c5a73a30f09", "filename": "clippy_lints/src/methods/map_err_ignore.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_err_ignore.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,34 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use rustc_hir::{CaptureBy, Closure, Expr, ExprKind, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::MAP_ERR_IGNORE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'_>, e: &Expr<'_>, arg: &'tcx Expr<'_>) {\n+    if let Some(method_id) = cx.typeck_results().type_dependent_def_id(e.hir_id)\n+        && let Some(impl_id) = cx.tcx.impl_of_method(method_id)\n+        && is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::Result)\n+        && let ExprKind::Closure(&Closure {\n+            capture_clause: CaptureBy::Ref,\n+            body,\n+            fn_decl_span,\n+            ..\n+        }) = arg.kind\n+        && let closure_body = cx.tcx.hir().body(body)\n+        && let [param] = closure_body.params\n+        && let PatKind::Wild = param.pat.kind\n+    {\n+        // span the area of the closure capture and warn that the\n+        // original error will be thrown away\n+        span_lint_and_help(\n+            cx,\n+            MAP_ERR_IGNORE,\n+            fn_decl_span,\n+            \"`map_err(|_|...` wildcard pattern discards the original error\",\n+            None,\n+            \"consider storing the original error as a source in the new error, or silence this warning using an ignored identifier (`.map_err(|_foo| ...`)\",\n+        );\n+    }\n+}"}, {"sha": "1cfe8c4191efab8bae143d30f57d090e6ab92e17", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 670, "deletions": 5, "changes": 675, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -1,5 +1,8 @@\n mod bind_instead_of_map;\n+mod bytecount;\n+mod bytes_count_to_len;\n mod bytes_nth;\n+mod case_sensitive_file_extension_comparisons;\n mod chars_cmp;\n mod chars_cmp_with_unwrap;\n mod chars_last_cmp;\n@@ -21,6 +24,7 @@ mod filter_next;\n mod flat_map_identity;\n mod flat_map_option;\n mod from_iter_instead_of_collect;\n+mod get_first;\n mod get_last_with_len;\n mod get_unwrap;\n mod implicit_clone;\n@@ -38,51 +42,66 @@ mod iter_overeager_cloned;\n mod iter_skip_next;\n mod iter_with_drain;\n mod iterator_step_by_zero;\n+mod manual_ok_or;\n mod manual_saturating_arithmetic;\n mod manual_str_repeat;\n+mod map_clone;\n mod map_collect_result_unit;\n+mod map_err_ignore;\n mod map_flatten;\n mod map_identity;\n mod map_unwrap_or;\n+mod mut_mutex_lock;\n mod needless_option_as_deref;\n mod needless_option_take;\n mod no_effect_replace;\n mod obfuscated_if_else;\n mod ok_expect;\n+mod open_options;\n mod option_as_ref_deref;\n mod option_map_or_none;\n mod option_map_unwrap_or;\n mod or_fun_call;\n mod or_then_unwrap;\n+mod path_buf_push_overwrite;\n+mod range_zip_with_len;\n+mod repeat_once;\n mod search_is_some;\n mod single_char_add_str;\n mod single_char_insert_string;\n mod single_char_pattern;\n mod single_char_push_string;\n mod skip_while_next;\n+mod stable_sort_primitive;\n mod str_splitn;\n mod string_extend_chars;\n mod suspicious_map;\n mod suspicious_splitn;\n mod uninit_assumed_init;\n+mod unit_hash;\n mod unnecessary_filter_map;\n mod unnecessary_fold;\n mod unnecessary_iter_cloned;\n mod unnecessary_join;\n mod unnecessary_lazy_eval;\n+mod unnecessary_sort_by;\n mod unnecessary_to_owned;\n mod unwrap_or_else_default;\n mod unwrap_used;\n mod useless_asref;\n mod utils;\n+mod vec_resize_to_zero;\n+mod verbose_file_reads;\n mod wrong_self_convention;\n mod zst_offset;\n \n use bind_instead_of_map::BindInsteadOfMap;\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_adt_constructor, contains_ty, implements_trait, is_copy, is_type_diagnostic_item};\n-use clippy_utils::{contains_return, get_trait_def_id, iter_input_pats, meets_msrv, msrvs, paths, return_ty};\n+use clippy_utils::{\n+    contains_return, get_trait_def_id, is_trait_method, iter_input_pats, meets_msrv, msrvs, paths, return_ty,\n+};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -2368,6 +2387,577 @@ declare_clippy_lint! {\n     \"Iterator for empty array\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for naive byte counts\n+    ///\n+    /// ### Why is this bad?\n+    /// The [`bytecount`](https://crates.io/crates/bytecount)\n+    /// crate has methods to count your bytes faster, especially for large slices.\n+    ///\n+    /// ### Known problems\n+    /// If you have predominantly small slices, the\n+    /// `bytecount::count(..)` method may actually be slower. However, if you can\n+    /// ensure that less than 2\u00b3\u00b2-1 matches arise, the `naive_count_32(..)` can be\n+    /// faster in those cases.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let vec = vec![1_u8];\n+    /// let count = vec.iter().filter(|x| **x == 0u8).count();\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// # let vec = vec![1_u8];\n+    /// let count = bytecount::count(&vec, 0u8);\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub NAIVE_BYTECOUNT,\n+    pedantic,\n+    \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// It checks for `str::bytes().count()` and suggests replacing it with\n+    /// `str::len()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// `str::bytes().count()` is longer and may not be as performant as using\n+    /// `str::len()`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// \"hello\".bytes().count();\n+    /// String::from(\"hello\").bytes().count();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// \"hello\".len();\n+    /// String::from(\"hello\").len();\n+    /// ```\n+    #[clippy::version = \"1.62.0\"]\n+    pub BYTES_COUNT_TO_LEN,\n+    complexity,\n+    \"Using `bytes().count()` when `len()` performs the same functionality\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for calls to `ends_with` with possible file extensions\n+    /// and suggests to use a case-insensitive approach instead.\n+    ///\n+    /// ### Why is this bad?\n+    /// `ends_with` is case-sensitive and may not detect files with a valid extension.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn is_rust_file(filename: &str) -> bool {\n+    ///     filename.ends_with(\".rs\")\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn is_rust_file(filename: &str) -> bool {\n+    ///     let filename = std::path::Path::new(filename);\n+    ///     filename.extension()\n+    ///         .map_or(false, |ext| ext.eq_ignore_ascii_case(\"rs\"))\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.51.0\"]\n+    pub CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+    pedantic,\n+    \"Checks for calls to ends_with with case-sensitive file extensions\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for using `x.get(0)` instead of\n+    /// `x.first()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Using `x.first()` is easier to read and has the same\n+    /// result.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = vec![2, 3, 5];\n+    /// let first_element = x.get(0);\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = vec![2, 3, 5];\n+    /// let first_element = x.first();\n+    /// ```\n+    #[clippy::version = \"1.63.0\"]\n+    pub GET_FIRST,\n+    style,\n+    \"Using `x.get(0)` when `x.first()` is simpler\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Finds patterns that reimplement `Option::ok_or`.\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// Concise code helps focusing on behavior instead of boilerplate.\n+    ///\n+    /// ### Examples\n+    /// ```rust\n+    /// let foo: Option<i32> = None;\n+    /// foo.map_or(Err(\"error\"), |v| Ok(v));\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let foo: Option<i32> = None;\n+    /// foo.ok_or(\"error\");\n+    /// ```\n+    #[clippy::version = \"1.49.0\"]\n+    pub MANUAL_OK_OR,\n+    pedantic,\n+    \"finds patterns that can be encoded more concisely with `Option::ok_or`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usage of `map(|x| x.clone())` or\n+    /// dereferencing closures for `Copy` types, on `Iterator` or `Option`,\n+    /// and suggests `cloned()` or `copied()` instead\n+    ///\n+    /// ### Why is this bad?\n+    /// Readability, this can be written more concisely\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = vec![42, 43];\n+    /// let y = x.iter();\n+    /// let z = y.map(|i| *i);\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    ///\n+    /// ```rust\n+    /// let x = vec![42, 43];\n+    /// let y = x.iter();\n+    /// let z = y.cloned();\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MAP_CLONE,\n+    style,\n+    \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for instances of `map_err(|_| Some::Enum)`\n+    ///\n+    /// ### Why is this bad?\n+    /// This `map_err` throws away the original error rather than allowing the enum to contain and report the cause of the error\n+    ///\n+    /// ### Example\n+    /// Before:\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// #[derive(Debug)]\n+    /// enum Error {\n+    ///     Indivisible,\n+    ///     Remainder(u8),\n+    /// }\n+    ///\n+    /// impl fmt::Display for Error {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         match self {\n+    ///             Error::Indivisible => write!(f, \"could not divide input by three\"),\n+    ///             Error::Remainder(remainder) => write!(\n+    ///                 f,\n+    ///                 \"input is not divisible by three, remainder = {}\",\n+    ///                 remainder\n+    ///             ),\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for Error {}\n+    ///\n+    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n+    ///     input\n+    ///         .parse::<i32>()\n+    ///         .map_err(|_| Error::Indivisible)\n+    ///         .map(|v| v % 3)\n+    ///         .and_then(|remainder| {\n+    ///             if remainder == 0 {\n+    ///                 Ok(())\n+    ///             } else {\n+    ///                 Err(Error::Remainder(remainder as u8))\n+    ///             }\n+    ///         })\n+    /// }\n+    ///  ```\n+    ///\n+    ///  After:\n+    ///  ```rust\n+    /// use std::{fmt, num::ParseIntError};\n+    ///\n+    /// #[derive(Debug)]\n+    /// enum Error {\n+    ///     Indivisible(ParseIntError),\n+    ///     Remainder(u8),\n+    /// }\n+    ///\n+    /// impl fmt::Display for Error {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         match self {\n+    ///             Error::Indivisible(_) => write!(f, \"could not divide input by three\"),\n+    ///             Error::Remainder(remainder) => write!(\n+    ///                 f,\n+    ///                 \"input is not divisible by three, remainder = {}\",\n+    ///                 remainder\n+    ///             ),\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for Error {\n+    ///     fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n+    ///         match self {\n+    ///             Error::Indivisible(source) => Some(source),\n+    ///             _ => None,\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n+    ///     input\n+    ///         .parse::<i32>()\n+    ///         .map_err(Error::Indivisible)\n+    ///         .map(|v| v % 3)\n+    ///         .and_then(|remainder| {\n+    ///             if remainder == 0 {\n+    ///                 Ok(())\n+    ///             } else {\n+    ///                 Err(Error::Remainder(remainder as u8))\n+    ///             }\n+    ///         })\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.48.0\"]\n+    pub MAP_ERR_IGNORE,\n+    restriction,\n+    \"`map_err` should not ignore the original error\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `&mut Mutex::lock` calls\n+    ///\n+    /// ### Why is this bad?\n+    /// `Mutex::lock` is less efficient than\n+    /// calling `Mutex::get_mut`. In addition you also have a statically\n+    /// guarantee that the mutex isn't locked, instead of just a runtime\n+    /// guarantee.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// use std::sync::{Arc, Mutex};\n+    ///\n+    /// let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    /// let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n+    ///\n+    /// let mut value = value_mutex.lock().unwrap();\n+    /// *value += 1;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::sync::{Arc, Mutex};\n+    ///\n+    /// let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    /// let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n+    ///\n+    /// let value = value_mutex.get_mut().unwrap();\n+    /// *value += 1;\n+    /// ```\n+    #[clippy::version = \"1.49.0\"]\n+    pub MUT_MUTEX_LOCK,\n+    style,\n+    \"`&mut Mutex::lock` does unnecessary locking\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for duplicate open options as well as combinations\n+    /// that make no sense.\n+    ///\n+    /// ### Why is this bad?\n+    /// In the best case, the code will be harder to read than\n+    /// necessary. I don't know the worst case.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// use std::fs::OpenOptions;\n+    ///\n+    /// OpenOptions::new().read(true).truncate(true);\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub NONSENSICAL_OPEN_OPTIONS,\n+    correctness,\n+    \"nonsensical combination of options for opening a file\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///* Checks for [push](https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.push)\n+    /// calls on `PathBuf` that can cause overwrites.\n+    ///\n+    /// ### Why is this bad?\n+    /// Calling `push` with a root path at the start can overwrite the\n+    /// previous defined path.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// use std::path::PathBuf;\n+    ///\n+    /// let mut x = PathBuf::from(\"/foo\");\n+    /// x.push(\"/bar\");\n+    /// assert_eq!(x, PathBuf::from(\"/bar\"));\n+    /// ```\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// use std::path::PathBuf;\n+    ///\n+    /// let mut x = PathBuf::from(\"/foo\");\n+    /// x.push(\"bar\");\n+    /// assert_eq!(x, PathBuf::from(\"/foo/bar\"));\n+    /// ```\n+    #[clippy::version = \"1.36.0\"]\n+    pub PATH_BUF_PUSH_OVERWRITE,\n+    nursery,\n+    \"calling `push` with file system root on `PathBuf` can overwrite it\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for zipping a collection with the range of\n+    /// `0.._.len()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// The code is better expressed with `.enumerate()`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = vec![1];\n+    /// let _ = x.iter().zip(0..x.len());\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x = vec![1];\n+    /// let _ = x.iter().enumerate();\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub RANGE_ZIP_WITH_LEN,\n+    complexity,\n+    \"zipping iterator with a range when `enumerate()` would do\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usage of `.repeat(1)` and suggest the following method for each types.\n+    /// - `.to_string()` for `str`\n+    /// - `.clone()` for `String`\n+    /// - `.to_vec()` for `slice`\n+    ///\n+    /// The lint will evaluate constant expressions and values as arguments of `.repeat(..)` and emit a message if\n+    /// they are equivalent to `1`. (Related discussion in [rust-clippy#7306](https://github.com/rust-lang/rust-clippy/issues/7306))\n+    ///\n+    /// ### Why is this bad?\n+    /// For example, `String.repeat(1)` is equivalent to `.clone()`. If cloning\n+    /// the string is the intention behind this, `clone()` should be used.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x = String::from(\"hello world\").repeat(1);\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x = String::from(\"hello world\").clone();\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.47.0\"]\n+    pub REPEAT_ONCE,\n+    complexity,\n+    \"using `.repeat(1)` instead of `String.clone()`, `str.to_string()` or `slice.to_vec()` \"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// When sorting primitive values (integers, bools, chars, as well\n+    /// as arrays, slices, and tuples of such items), it is typically better to\n+    /// use an unstable sort than a stable sort.\n+    ///\n+    /// ### Why is this bad?\n+    /// Typically, using a stable sort consumes more memory and cpu cycles.\n+    /// Because values which compare equal are identical, preserving their\n+    /// relative order (the guarantee that a stable sort provides) means\n+    /// nothing, while the extra costs still apply.\n+    ///\n+    /// ### Known problems\n+    ///\n+    /// As pointed out in\n+    /// [issue #8241](https://github.com/rust-lang/rust-clippy/issues/8241),\n+    /// a stable sort can instead be significantly faster for certain scenarios\n+    /// (eg. when a sorted vector is extended with new data and resorted).\n+    ///\n+    /// For more information and benchmarking results, please refer to the\n+    /// issue linked above.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut vec = vec![2, 1, 3];\n+    /// vec.sort();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut vec = vec![2, 1, 3];\n+    /// vec.sort_unstable();\n+    /// ```\n+    #[clippy::version = \"1.47.0\"]\n+    pub STABLE_SORT_PRIMITIVE,\n+    pedantic,\n+    \"use of sort() when sort_unstable() is equivalent\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects `().hash(_)`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Hashing a unit value doesn't do anything as the implementation of `Hash` for `()` is a no-op.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::hash::Hash;\n+    /// # use std::collections::hash_map::DefaultHasher;\n+    /// # enum Foo { Empty, WithValue(u8) }\n+    /// # use Foo::*;\n+    /// # let mut state = DefaultHasher::new();\n+    /// # let my_enum = Foo::Empty;\n+    /// match my_enum {\n+    /// \tEmpty => ().hash(&mut state),\n+    /// \tWithValue(x) => x.hash(&mut state),\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::hash::Hash;\n+    /// # use std::collections::hash_map::DefaultHasher;\n+    /// # enum Foo { Empty, WithValue(u8) }\n+    /// # use Foo::*;\n+    /// # let mut state = DefaultHasher::new();\n+    /// # let my_enum = Foo::Empty;\n+    /// match my_enum {\n+    /// \tEmpty => 0_u8.hash(&mut state),\n+    /// \tWithValue(x) => x.hash(&mut state),\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.58.0\"]\n+    pub UNIT_HASH,\n+    correctness,\n+    \"hashing a unit value, which does nothing\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects uses of `Vec::sort_by` passing in a closure\n+    /// which compares the two arguments, either directly or indirectly.\n+    ///\n+    /// ### Why is this bad?\n+    /// It is more clear to use `Vec::sort_by_key` (or `Vec::sort` if\n+    /// possible) than to use `Vec::sort_by` and a more complicated\n+    /// closure.\n+    ///\n+    /// ### Known problems\n+    /// If the suggested `Vec::sort_by_key` uses Reverse and it isn't already\n+    /// imported by a use statement, then it will need to be added manually.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # struct A;\n+    /// # impl A { fn foo(&self) {} }\n+    /// # let mut vec: Vec<A> = Vec::new();\n+    /// vec.sort_by(|a, b| a.foo().cmp(&b.foo()));\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # struct A;\n+    /// # impl A { fn foo(&self) {} }\n+    /// # let mut vec: Vec<A> = Vec::new();\n+    /// vec.sort_by_key(|a| a.foo());\n+    /// ```\n+    #[clippy::version = \"1.46.0\"]\n+    pub UNNECESSARY_SORT_BY,\n+    complexity,\n+    \"Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Finds occurrences of `Vec::resize(0, an_int)`\n+    ///\n+    /// ### Why is this bad?\n+    /// This is probably an argument inversion mistake.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// vec!(1, 2, 3, 4, 5).resize(0, 5)\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// vec!(1, 2, 3, 4, 5).clear()\n+    /// ```\n+    #[clippy::version = \"1.46.0\"]\n+    pub VEC_RESIZE_TO_ZERO,\n+    correctness,\n+    \"emptying a vector with `resize(0, an_int)` instead of `clear()` is probably an argument inversion mistake\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for use of File::read_to_end and File::read_to_string.\n+    ///\n+    /// ### Why is this bad?\n+    /// `fs::{read, read_to_string}` provide the same functionality when `buf` is empty with fewer imports and no intermediate values.\n+    /// See also: [fs::read docs](https://doc.rust-lang.org/std/fs/fn.read.html), [fs::read_to_string docs](https://doc.rust-lang.org/std/fs/fn.read_to_string.html)\n+    ///\n+    /// ### Example\n+    /// ```rust,no_run\n+    /// # use std::io::Read;\n+    /// # use std::fs::File;\n+    /// let mut f = File::open(\"foo.txt\").unwrap();\n+    /// let mut bytes = Vec::new();\n+    /// f.read_to_end(&mut bytes).unwrap();\n+    /// ```\n+    /// Can be written more concisely as\n+    /// ```rust,no_run\n+    /// # use std::fs;\n+    /// let mut bytes = fs::read(\"foo.txt\").unwrap();\n+    /// ```\n+    #[clippy::version = \"1.44.0\"]\n+    pub VERBOSE_FILE_READS,\n+    restriction,\n+    \"use of `File::read_to_end` or `File::read_to_string`\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -2471,7 +3061,24 @@ impl_lint_pass!(Methods => [\n     NO_EFFECT_REPLACE,\n     OBFUSCATED_IF_ELSE,\n     ITER_ON_SINGLE_ITEMS,\n-    ITER_ON_EMPTY_COLLECTIONS\n+    ITER_ON_EMPTY_COLLECTIONS,\n+    NAIVE_BYTECOUNT,\n+    BYTES_COUNT_TO_LEN,\n+    CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+    GET_FIRST,\n+    MANUAL_OK_OR,\n+    MAP_CLONE,\n+    MAP_ERR_IGNORE,\n+    MUT_MUTEX_LOCK,\n+    NONSENSICAL_OPEN_OPTIONS,\n+    PATH_BUF_PUSH_OVERWRITE,\n+    RANGE_ZIP_WITH_LEN,\n+    REPEAT_ONCE,\n+    STABLE_SORT_PRIMITIVE,\n+    UNIT_HASH,\n+    UNNECESSARY_SORT_BY,\n+    VEC_RESIZE_TO_ZERO,\n+    VERBOSE_FILE_READS,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2726,17 +3333,24 @@ impl Methods {\n                     },\n                     _ => {},\n                 },\n-                (\"count\", []) => match method_call(recv) {\n+                (\"count\", []) if is_trait_method(cx, expr, sym::Iterator) => match method_call(recv) {\n                     Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, true, false),\n                     Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), [recv2], _)) => {\n                         iter_count::check(cx, expr, recv2, name2);\n                     },\n                     Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n+                    Some((\"filter\", [recv2, arg], _)) => bytecount::check(cx, expr, recv2, arg),\n+                    Some((\"bytes\", [recv2], _)) => bytes_count_to_len::check(cx, expr, recv, recv2),\n                     _ => {},\n                 },\n                 (\"drain\", [arg]) => {\n                     iter_with_drain::check(cx, expr, recv, span, arg);\n                 },\n+                (\"ends_with\", [arg]) => {\n+                    if let ExprKind::MethodCall(_, _, span) = expr.kind {\n+                        case_sensitive_file_extension_comparisons::check(cx, expr, span, recv, arg);\n+                    }\n+                },\n                 (\"expect\", [_]) => match method_call(recv) {\n                     Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n                     Some((\"err\", [recv], err_span)) => err_expect::check(cx, expr, recv, self.msrv, span, err_span),\n@@ -2769,8 +3383,14 @@ impl Methods {\n                         inspect_for_each::check(cx, expr, span2);\n                     }\n                 },\n-                (\"get\", [arg]) => get_last_with_len::check(cx, expr, recv, arg),\n+                (\"get\", [arg]) => {\n+                    get_first::check(cx, expr, recv, arg);\n+                    get_last_with_len::check(cx, expr, recv, arg);\n+                },\n                 (\"get_or_insert_with\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"get_or_insert\"),\n+                (\"hash\", [arg]) => {\n+                    unit_hash::check(cx, expr, recv, arg);\n+                },\n                 (\"is_file\", []) => filetype_is_file::check(cx, expr, recv),\n                 (\"is_digit\", [radix]) => is_digit_ascii_radix::check(cx, expr, recv, radix, self.msrv),\n                 (\"is_none\", []) => check_is_some_is_none(cx, expr, recv, false),\n@@ -2790,7 +3410,15 @@ impl Methods {\n                         }\n                     }\n                 },\n+                (\"lock\", []) => {\n+                    mut_mutex_lock::check(cx, expr, recv, span);\n+                },\n                 (name @ (\"map\" | \"map_err\"), [m_arg]) => {\n+                    if name == \"map\" {\n+                        map_clone::check(cx, expr, recv, m_arg, self.msrv);\n+                    } else {\n+                        map_err_ignore::check(cx, expr, m_arg);\n+                    }\n                     if let Some((name, [recv2, args @ ..], span2)) = method_call(recv) {\n                         match (name, args) {\n                             (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, self.msrv),\n@@ -2806,7 +3434,10 @@ impl Methods {\n                     }\n                     map_identity::check(cx, expr, recv, m_arg, name, span);\n                 },\n-                (\"map_or\", [def, map]) => option_map_or_none::check(cx, expr, recv, def, map),\n+                (\"map_or\", [def, map]) => {\n+                    option_map_or_none::check(cx, expr, recv, def, map);\n+                    manual_ok_or::check(cx, expr, recv, def, map);\n+                },\n                 (\"next\", []) => {\n                     if let Some((name2, [recv2, args2 @ ..], _)) = method_call(recv) {\n                         match (name2, args2) {\n@@ -2828,11 +3459,38 @@ impl Methods {\n                     _ => iter_nth_zero::check(cx, expr, recv, n_arg),\n                 },\n                 (\"ok_or_else\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"ok_or\"),\n+                (\"open\", [_]) => {\n+                    open_options::check(cx, expr, recv);\n+                },\n                 (\"or_else\", [arg]) => {\n                     if !bind_instead_of_map::ResultOrElseErrInfo::check(cx, expr, recv, arg) {\n                         unnecessary_lazy_eval::check(cx, expr, recv, arg, \"or\");\n                     }\n                 },\n+                (\"push\", [arg]) => {\n+                    path_buf_push_overwrite::check(cx, expr, arg);\n+                },\n+                (\"read_to_end\", [_]) => {\n+                    verbose_file_reads::check(cx, expr, recv, verbose_file_reads::READ_TO_END_MSG);\n+                },\n+                (\"read_to_string\", [_]) => {\n+                    verbose_file_reads::check(cx, expr, recv, verbose_file_reads::READ_TO_STRING_MSG);\n+                },\n+                (\"repeat\", [arg]) => {\n+                    repeat_once::check(cx, expr, recv, arg);\n+                },\n+                (\"resize\", [count_arg, default_arg]) => {\n+                    vec_resize_to_zero::check(cx, expr, count_arg, default_arg, span);\n+                },\n+                (\"sort\", []) => {\n+                    stable_sort_primitive::check(cx, expr, recv);\n+                },\n+                (\"sort_by\", [arg]) => {\n+                    unnecessary_sort_by::check(cx, expr, recv, arg, false);\n+                },\n+                (\"sort_unstable_by\", [arg]) => {\n+                    unnecessary_sort_by::check(cx, expr, recv, arg, true);\n+                },\n                 (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n                     if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n                         suspicious_splitn::check(cx, name, expr, recv, count);\n@@ -2901,6 +3559,13 @@ impl Methods {\n                 (\"replace\" | \"replacen\", [arg1, arg2] | [arg1, arg2, _]) => {\n                     no_effect_replace::check(cx, expr, arg1, arg2);\n                 },\n+                (\"zip\", [arg]) => {\n+                    if let ExprKind::MethodCall(name, [iter_recv], _) = recv.kind\n+                        && name.ident.name == sym::iter\n+                    {\n+                        range_zip_with_len::check(cx, expr, iter_recv, arg);\n+                    }\n+                },\n                 _ => {},\n             }\n         }"}, {"sha": "bd8458a222e2922e1d68c3d26e9b37fc0f084d20", "filename": "clippy_lints/src/methods/mut_mutex_lock.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmut_mutex_lock.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,30 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, Mutability};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::{sym, Span};\n+\n+use super::MUT_MUTEX_LOCK;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'tcx>, recv: &'tcx Expr<'tcx>, name_span: Span) {\n+    if_chain! {\n+        if let ty::Ref(_, _, Mutability::Mut) = cx.typeck_results().expr_ty(recv).kind();\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(ex.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::Mutex);\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                MUT_MUTEX_LOCK,\n+                name_span,\n+                \"calling `&mut Mutex::lock` unnecessarily locks an exclusive (mutable) reference\",\n+                \"change this to\",\n+                \"get_mut\".to_owned(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+}"}, {"sha": "c3112823e3469eeb576f601f8ed71f31a19b5dd9", "filename": "clippy_lints/src/methods/open_options.rs", "status": "renamed", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -3,43 +3,19 @@ use clippy_utils::paths;\n use clippy_utils::ty::match_type;\n use rustc_ast::ast::LitKind;\n use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_lint::LateContext;\n use rustc_span::source_map::{Span, Spanned};\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for duplicate open options as well as combinations\n-    /// that make no sense.\n-    ///\n-    /// ### Why is this bad?\n-    /// In the best case, the code will be harder to read than\n-    /// necessary. I don't know the worst case.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// use std::fs::OpenOptions;\n-    ///\n-    /// OpenOptions::new().read(true).truncate(true);\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub NONSENSICAL_OPEN_OPTIONS,\n-    correctness,\n-    \"nonsensical combination of options for opening a file\"\n-}\n-\n-declare_lint_pass!(OpenOptions => [NONSENSICAL_OPEN_OPTIONS]);\n+use super::NONSENSICAL_OPEN_OPTIONS;\n \n-impl<'tcx> LateLintPass<'tcx> for OpenOptions {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::MethodCall(path, [self_arg, ..], _) = &e.kind {\n-            let obj_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n-            if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n-                let mut options = Vec::new();\n-                get_open_options(cx, self_arg, &mut options);\n-                check_open_options(cx, &options, e.span);\n-            }\n-        }\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, recv: &'tcx Expr<'_>) {\n+    if let Some(method_id) = cx.typeck_results().type_dependent_def_id(e.hir_id)\n+        && let Some(impl_id) = cx.tcx.impl_of_method(method_id)\n+        && match_type(cx, cx.tcx.type_of(impl_id), &paths::OPEN_OPTIONS)\n+    {\n+        let mut options = Vec::new();\n+        get_open_options(cx, recv, &mut options);\n+        check_open_options(cx, &options, e.span);\n     }\n }\n ", "previous_filename": "clippy_lints/src/open_options.rs"}, {"sha": "0cc28c0dcb3d044c7b8a0d0ca86cf637fabbe306", "filename": "clippy_lints/src/methods/path_buf_push_overwrite.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fpath_buf_push_overwrite.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,37 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+use std::path::{Component, Path};\n+\n+use super::PATH_BUF_PUSH_OVERWRITE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arg: &'tcx Expr<'_>) {\n+    if_chain! {\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::PathBuf);\n+        if let ExprKind::Lit(ref lit) = arg.kind;\n+        if let LitKind::Str(ref path_lit, _) = lit.node;\n+        if let pushed_path = Path::new(path_lit.as_str());\n+        if let Some(pushed_path_lit) = pushed_path.to_str();\n+        if pushed_path.has_root();\n+        if let Some(root) = pushed_path.components().next();\n+        if root == Component::RootDir;\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                PATH_BUF_PUSH_OVERWRITE,\n+                lit.span,\n+                \"calling `push` with '/' or '\\\\' (file system root) will overwrite the previous path definition\",\n+                \"try\",\n+                format!(\"\\\"{}\\\"\", pushed_path_lit.trim_start_matches(|c| c == '/' || c == '\\\\')),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "00a2a0d14d1132946ef80749581d3e0e12644ea8", "filename": "clippy_lints/src/methods/range_zip_with_len.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,34 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{higher, SpanlessEq};\n+use clippy_utils::{is_integer_const, is_trait_method};\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::RANGE_ZIP_WITH_LEN;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, recv: &'tcx Expr<'_>, zip_arg: &'tcx Expr<'_>) {\n+    if_chain! {\n+        if is_trait_method(cx, expr, sym::Iterator);\n+        // range expression in `.zip()` call: `0..x.len()`\n+        if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::Range::hir(zip_arg);\n+        if is_integer_const(cx, start, 0);\n+        // `.len()` call\n+        if let ExprKind::MethodCall(len_path, [len_recv], _) = end.kind;\n+        if len_path.ident.name == sym::len;\n+        // `.iter()` and `.len()` called on same `Path`\n+        if let ExprKind::Path(QPath::Resolved(_, iter_path)) = recv.kind;\n+        if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_recv.kind;\n+        if SpanlessEq::new(cx).eq_path_segments(iter_path.segments, len_path.segments);\n+        then {\n+            span_lint(cx,\n+                RANGE_ZIP_WITH_LEN,\n+                expr.span,\n+                &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n+                    snippet(cx, recv.span, \"_\"))\n+            );\n+        }\n+    }\n+}"}, {"sha": "0a14f9216ab383f44f197a25820471a84c09f29f", "filename": "clippy_lints/src/methods/repeat_once.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,52 @@\n+use clippy_utils::consts::{constant_context, Constant};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::REPEAT_ONCE;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    recv: &'tcx Expr<'_>,\n+    repeat_arg: &'tcx Expr<'_>,\n+) {\n+    if constant_context(cx, cx.typeck_results()).expr(repeat_arg) == Some(Constant::Int(1)) {\n+        let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n+        if ty.is_str() {\n+            span_lint_and_sugg(\n+                cx,\n+                REPEAT_ONCE,\n+                expr.span,\n+                \"calling `repeat(1)` on str\",\n+                \"consider using `.to_string()` instead\",\n+                format!(\"{}.to_string()\", snippet(cx, recv.span, r#\"\"...\"\"#)),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if ty.builtin_index().is_some() {\n+            span_lint_and_sugg(\n+                cx,\n+                REPEAT_ONCE,\n+                expr.span,\n+                \"calling `repeat(1)` on slice\",\n+                \"consider using `.to_vec()` instead\",\n+                format!(\"{}.to_vec()\", snippet(cx, recv.span, r#\"\"...\"\"#)),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if is_type_diagnostic_item(cx, ty, sym::String) {\n+            span_lint_and_sugg(\n+                cx,\n+                REPEAT_ONCE,\n+                expr.span,\n+                \"calling `repeat(1)` on a string literal\",\n+                \"consider using `.clone()` instead\",\n+                format!(\"{}.clone()\", snippet(cx, recv.span, r#\"\"...\"\"#)),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "91951c65bb3095aebbeefb7fb105b35f53c05047", "filename": "clippy_lints/src/methods/stable_sort_primitive.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstable_sort_primitive.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,31 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::is_slice_of_primitives;\n+use clippy_utils::source::snippet_with_context;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+\n+use super::STABLE_SORT_PRIMITIVE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, recv: &'tcx Expr<'_>) {\n+    if let Some(method_id) = cx.typeck_results().type_dependent_def_id(e.hir_id)\n+        && let Some(impl_id) = cx.tcx.impl_of_method(method_id)\n+        && cx.tcx.type_of(impl_id).is_slice()\n+        && let Some(slice_type) = is_slice_of_primitives(cx, recv)\n+    {\n+        span_lint_and_then(\n+            cx,\n+            STABLE_SORT_PRIMITIVE,\n+            e.span,\n+            &format!(\"used `sort` on primitive type `{}`\", slice_type),\n+            |diag| {\n+                let mut app = Applicability::MachineApplicable;\n+                let recv_snip = snippet_with_context(cx, recv.span, e.span.ctxt(), \"..\", &mut app).0;\n+                diag.span_suggestion(e.span, \"try\", format!(\"{}.sort_unstable()\", recv_snip), app);\n+                diag.note(\n+                    \"an unstable sort typically performs faster without any observable difference for this data type\",\n+                );\n+            },\n+        );\n+    }\n+}"}, {"sha": "3c7955bc46981bae4c0d989d3d9c5cbbf5c715ea", "filename": "clippy_lints/src/methods/unit_hash.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Funit_hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Funit_hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funit_hash.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,29 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::is_trait_method;\n+use clippy_utils::source::snippet;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::UNIT_HASH;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, recv: &'tcx Expr<'_>, arg: &'tcx Expr<'_>) {\n+    if is_trait_method(cx, expr, sym::Hash) && cx.typeck_results().expr_ty(recv).is_unit() {\n+        span_lint_and_then(\n+            cx,\n+            UNIT_HASH,\n+            expr.span,\n+            \"this call to `hash` on the unit type will do nothing\",\n+            |diag| {\n+                diag.span_suggestion(\n+                    expr.span,\n+                    \"remove the call to `hash` or consider using\",\n+                    format!(\"0_u8.hash({})\", snippet(cx, arg.span, \"..\"),),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                diag.note(\"the implementation of `Hash` for `()` is a no-op\");\n+            },\n+        );\n+    }\n+}"}, {"sha": "1966990bd774f929a37551329aff18832c326c17", "filename": "clippy_lints/src/methods/unnecessary_sort_by.rs", "status": "renamed", "additions": 61, "deletions": 95, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -1,51 +1,17 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_trait_method;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n+use clippy_utils::ty::implements_trait;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Closure, Expr, ExprKind, Mutability, Param, Pat, PatKind, Path, PathSegment, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::LateContext;\n use rustc_middle::ty::{self, subst::GenericArgKind};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n use rustc_span::symbol::Ident;\n use std::iter;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Detects uses of `Vec::sort_by` passing in a closure\n-    /// which compares the two arguments, either directly or indirectly.\n-    ///\n-    /// ### Why is this bad?\n-    /// It is more clear to use `Vec::sort_by_key` (or `Vec::sort` if\n-    /// possible) than to use `Vec::sort_by` and a more complicated\n-    /// closure.\n-    ///\n-    /// ### Known problems\n-    /// If the suggested `Vec::sort_by_key` uses Reverse and it isn't already\n-    /// imported by a use statement, then it will need to be added manually.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # struct A;\n-    /// # impl A { fn foo(&self) {} }\n-    /// # let mut vec: Vec<A> = Vec::new();\n-    /// vec.sort_by(|a, b| a.foo().cmp(&b.foo()));\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// # struct A;\n-    /// # impl A { fn foo(&self) {} }\n-    /// # let mut vec: Vec<A> = Vec::new();\n-    /// vec.sort_by_key(|a| a.foo());\n-    /// ```\n-    #[clippy::version = \"1.46.0\"]\n-    pub UNNECESSARY_SORT_BY,\n-    complexity,\n-    \"Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer\"\n-}\n-\n-declare_lint_pass!(UnnecessarySortBy => [UNNECESSARY_SORT_BY]);\n+use super::UNNECESSARY_SORT_BY;\n \n enum LintTrigger {\n     Sort(SortDetection),\n@@ -54,15 +20,13 @@ enum LintTrigger {\n \n struct SortDetection {\n     vec_name: String,\n-    unstable: bool,\n }\n \n struct SortByKeyDetection {\n     vec_name: String,\n     closure_arg: String,\n     closure_body: String,\n     reverse: bool,\n-    unstable: bool,\n }\n \n /// Detect if the two expressions are mirrored (identical, except one\n@@ -150,20 +114,20 @@ fn mirrored_exprs(a_expr: &Expr<'_>, a_ident: &Ident, b_expr: &Expr<'_>, b_ident\n     }\n }\n \n-fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n+fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg: &Expr<'_>) -> Option<LintTrigger> {\n     if_chain! {\n-        if let ExprKind::MethodCall(name_ident, args, _) = &expr.kind;\n-        if let name = name_ident.ident.name.to_ident_string();\n-        if name == \"sort_by\" || name == \"sort_unstable_by\";\n-        if let [vec, Expr { kind: ExprKind::Closure(Closure { body: closure_body_id, .. }), .. }] = args;\n-        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(vec), sym::Vec);\n-        if let closure_body = cx.tcx.hir().body(*closure_body_id);\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if cx.tcx.type_of(impl_id).is_slice();\n+        if let ExprKind::Closure(&Closure { body, .. }) = arg.kind;\n+        if let closure_body = cx.tcx.hir().body(body);\n         if let &[\n             Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},\n             Param { pat: Pat { kind: PatKind::Binding(_, _, right_ident, _), .. }, .. }\n         ] = &closure_body.params;\n-        if let ExprKind::MethodCall(method_path, [ref left_expr, ref right_expr], _) = &closure_body.value.kind;\n+        if let ExprKind::MethodCall(method_path, [left_expr, right_expr], _) = closure_body.value.kind;\n         if method_path.ident.name == sym::cmp;\n+        if is_trait_method(cx, &closure_body.value, sym::Ord);\n         then {\n             let (closure_body, closure_arg, reverse) = if mirrored_exprs(\n                 left_expr,\n@@ -177,19 +141,18 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n             } else {\n                 return None;\n             };\n-            let vec_name = Sugg::hir(cx, &args[0], \"..\").to_string();\n-            let unstable = name == \"sort_unstable_by\";\n+            let vec_name = Sugg::hir(cx, recv, \"..\").to_string();\n \n             if_chain! {\n-            if let ExprKind::Path(QPath::Resolved(_, Path {\n-                segments: [PathSegment { ident: left_name, .. }], ..\n-            })) = &left_expr.kind;\n-            if left_name == left_ident;\n-            if cx.tcx.get_diagnostic_item(sym::Ord).map_or(false, |id| {\n-                implements_trait(cx, cx.typeck_results().expr_ty(left_expr), id, &[])\n-            });\n+                if let ExprKind::Path(QPath::Resolved(_, Path {\n+                    segments: [PathSegment { ident: left_name, .. }], ..\n+                })) = &left_expr.kind;\n+                if left_name == left_ident;\n+                if cx.tcx.get_diagnostic_item(sym::Ord).map_or(false, |id| {\n+                    implements_trait(cx, cx.typeck_results().expr_ty(left_expr), id, &[])\n+                });\n                 then {\n-                    return Some(LintTrigger::Sort(SortDetection { vec_name, unstable }));\n+                    return Some(LintTrigger::Sort(SortDetection { vec_name }));\n                 }\n             }\n \n@@ -199,7 +162,6 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n                     closure_arg,\n                     closure_body,\n                     reverse,\n-                    unstable,\n                 }));\n             }\n         }\n@@ -213,46 +175,50 @@ fn expr_borrows(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     matches!(ty.kind(), ty::Ref(..)) || ty.walk().any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n }\n \n-impl LateLintPass<'_> for UnnecessarySortBy {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        match detect_lint(cx, expr) {\n-            Some(LintTrigger::SortByKey(trigger)) => span_lint_and_sugg(\n-                cx,\n-                UNNECESSARY_SORT_BY,\n-                expr.span,\n-                \"use Vec::sort_by_key here instead\",\n-                \"try\",\n-                format!(\n-                    \"{}.sort{}_by_key(|{}| {})\",\n-                    trigger.vec_name,\n-                    if trigger.unstable { \"_unstable\" } else { \"\" },\n-                    trigger.closure_arg,\n-                    if trigger.reverse {\n-                        format!(\"std::cmp::Reverse({})\", trigger.closure_body)\n-                    } else {\n-                        trigger.closure_body.to_string()\n-                    },\n-                ),\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    recv: &'tcx Expr<'_>,\n+    arg: &'tcx Expr<'_>,\n+    is_unstable: bool,\n+) {\n+    match detect_lint(cx, expr, recv, arg) {\n+        Some(LintTrigger::SortByKey(trigger)) => span_lint_and_sugg(\n+            cx,\n+            UNNECESSARY_SORT_BY,\n+            expr.span,\n+            \"use Vec::sort_by_key here instead\",\n+            \"try\",\n+            format!(\n+                \"{}.sort{}_by_key(|{}| {})\",\n+                trigger.vec_name,\n+                if is_unstable { \"_unstable\" } else { \"\" },\n+                trigger.closure_arg,\n                 if trigger.reverse {\n-                    Applicability::MaybeIncorrect\n+                    format!(\"std::cmp::Reverse({})\", trigger.closure_body)\n                 } else {\n-                    Applicability::MachineApplicable\n+                    trigger.closure_body.to_string()\n                 },\n             ),\n-            Some(LintTrigger::Sort(trigger)) => span_lint_and_sugg(\n-                cx,\n-                UNNECESSARY_SORT_BY,\n-                expr.span,\n-                \"use Vec::sort here instead\",\n-                \"try\",\n-                format!(\n-                    \"{}.sort{}()\",\n-                    trigger.vec_name,\n-                    if trigger.unstable { \"_unstable\" } else { \"\" },\n-                ),\n-                Applicability::MachineApplicable,\n+            if trigger.reverse {\n+                Applicability::MaybeIncorrect\n+            } else {\n+                Applicability::MachineApplicable\n+            },\n+        ),\n+        Some(LintTrigger::Sort(trigger)) => span_lint_and_sugg(\n+            cx,\n+            UNNECESSARY_SORT_BY,\n+            expr.span,\n+            \"use Vec::sort here instead\",\n+            \"try\",\n+            format!(\n+                \"{}.sort{}()\",\n+                trigger.vec_name,\n+                if is_unstable { \"_unstable\" } else { \"\" },\n             ),\n-            None => {},\n-        }\n+            Applicability::MachineApplicable,\n+        ),\n+        None => {},\n     }\n }", "previous_filename": "clippy_lints/src/unnecessary_sort_by.rs"}, {"sha": "02d8364cb2959c17d1471a6c3479e6c26b7c7c4e", "filename": "clippy_lints/src/methods/vec_resize_to_zero.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fvec_resize_to_zero.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,45 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Spanned;\n+use rustc_span::{sym, Span};\n+\n+use super::VEC_RESIZE_TO_ZERO;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    count_arg: &'tcx Expr<'_>,\n+    default_arg: &'tcx Expr<'_>,\n+    name_span: Span,\n+) {\n+    if_chain! {\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::Vec);\n+        if let ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = count_arg.kind;\n+        if let ExprKind::Lit(Spanned { node: LitKind::Int(..), .. }) = default_arg.kind;\n+        then {\n+            let method_call_span = expr.span.with_lo(name_span.lo());\n+            span_lint_and_then(\n+                cx,\n+                VEC_RESIZE_TO_ZERO,\n+                expr.span,\n+                \"emptying a vector with `resize`\",\n+                |db| {\n+                    db.help(\"the arguments may be inverted...\");\n+                    db.span_suggestion(\n+                        method_call_span,\n+                        \"...or you can empty the vector with\",\n+                        \"clear()\".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                },\n+            );\n+        }\n+    }\n+}"}, {"sha": "2fe5ae9a9ad8fda3a9c80f8143ac603764d1ad8b", "filename": "clippy_lints/src/methods/verbose_file_reads.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Fmethods%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fverbose_file_reads.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,28 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::is_trait_method;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::VERBOSE_FILE_READS;\n+\n+pub(super) const READ_TO_END_MSG: (&str, &str) = (\"use of `File::read_to_end`\", \"consider using `fs::read` instead\");\n+pub(super) const READ_TO_STRING_MSG: (&str, &str) = (\n+    \"use of `File::read_to_string`\",\n+    \"consider using `fs::read_to_string` instead\",\n+);\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    recv: &'tcx Expr<'_>,\n+    (msg, help): (&str, &str),\n+) {\n+    if is_trait_method(cx, expr, sym::IoRead)\n+        && matches!(recv.kind, ExprKind::Path(QPath::Resolved(None, _)))\n+        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty_adjusted(recv).peel_refs(), sym::File)\n+    {\n+        span_lint_and_help(cx, VERBOSE_FILE_READS, expr.span, msg, None, help);\n+    }\n+}"}, {"sha": "b7f981faa2d42c6491d8745fc9b76168bd4a2fe6", "filename": "clippy_lints/src/mut_mutex_lock.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mutex_lock.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,70 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, Mutability};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `&mut Mutex::lock` calls\n-    ///\n-    /// ### Why is this bad?\n-    /// `Mutex::lock` is less efficient than\n-    /// calling `Mutex::get_mut`. In addition you also have a statically\n-    /// guarantee that the mutex isn't locked, instead of just a runtime\n-    /// guarantee.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// use std::sync::{Arc, Mutex};\n-    ///\n-    /// let mut value_rc = Arc::new(Mutex::new(42_u8));\n-    /// let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n-    ///\n-    /// let mut value = value_mutex.lock().unwrap();\n-    /// *value += 1;\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// use std::sync::{Arc, Mutex};\n-    ///\n-    /// let mut value_rc = Arc::new(Mutex::new(42_u8));\n-    /// let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n-    ///\n-    /// let value = value_mutex.get_mut().unwrap();\n-    /// *value += 1;\n-    /// ```\n-    #[clippy::version = \"1.49.0\"]\n-    pub MUT_MUTEX_LOCK,\n-    style,\n-    \"`&mut Mutex::lock` does unnecessary locking\"\n-}\n-\n-declare_lint_pass!(MutMutexLock => [MUT_MUTEX_LOCK]);\n-\n-impl<'tcx> LateLintPass<'tcx> for MutMutexLock {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, ex: &'tcx Expr<'tcx>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(path, [self_arg, ..], _) = &ex.kind;\n-            if path.ident.name == sym!(lock);\n-            let ty = cx.typeck_results().expr_ty(self_arg);\n-            if let ty::Ref(_, inner_ty, Mutability::Mut) = ty.kind();\n-            if is_type_diagnostic_item(cx, *inner_ty, sym::Mutex);\n-            then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    MUT_MUTEX_LOCK,\n-                    path.ident.span,\n-                    \"calling `&mut Mutex::lock` unnecessarily locks an exclusive (mutable) reference\",\n-                    \"change this to\",\n-                    \"get_mut\".to_owned(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "bc6a918f7035544ace250e7516c78731b1edd98e", "filename": "clippy_lints/src/path_buf_push_overwrite.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,72 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::sym;\n-use std::path::{Component, Path};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    ///* Checks for [push](https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.push)\n-    /// calls on `PathBuf` that can cause overwrites.\n-    ///\n-    /// ### Why is this bad?\n-    /// Calling `push` with a root path at the start can overwrite the\n-    /// previous defined path.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// use std::path::PathBuf;\n-    ///\n-    /// let mut x = PathBuf::from(\"/foo\");\n-    /// x.push(\"/bar\");\n-    /// assert_eq!(x, PathBuf::from(\"/bar\"));\n-    /// ```\n-    /// Could be written:\n-    ///\n-    /// ```rust\n-    /// use std::path::PathBuf;\n-    ///\n-    /// let mut x = PathBuf::from(\"/foo\");\n-    /// x.push(\"bar\");\n-    /// assert_eq!(x, PathBuf::from(\"/foo/bar\"));\n-    /// ```\n-    #[clippy::version = \"1.36.0\"]\n-    pub PATH_BUF_PUSH_OVERWRITE,\n-    nursery,\n-    \"calling `push` with file system root on `PathBuf` can overwrite it\"\n-}\n-\n-declare_lint_pass!(PathBufPushOverwrite => [PATH_BUF_PUSH_OVERWRITE]);\n-\n-impl<'tcx> LateLintPass<'tcx> for PathBufPushOverwrite {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(path, [recv, get_index_arg], _) = expr.kind;\n-            if path.ident.name == sym!(push);\n-            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv).peel_refs(), sym::PathBuf);\n-            if let ExprKind::Lit(ref lit) = get_index_arg.kind;\n-            if let LitKind::Str(ref path_lit, _) = lit.node;\n-            if let pushed_path = Path::new(path_lit.as_str());\n-            if let Some(pushed_path_lit) = pushed_path.to_str();\n-            if pushed_path.has_root();\n-            if let Some(root) = pushed_path.components().next();\n-            if root == Component::RootDir;\n-            then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    PATH_BUF_PUSH_OVERWRITE,\n-                    lit.span,\n-                    \"calling `push` with '/' or '\\\\' (file system root) will overwrite the previous path definition\",\n-                    \"try\",\n-                    format!(\"\\\"{}\\\"\", pushed_path_lit.trim_start_matches(|c| c == '/' || c == '\\\\')),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "490f345d2970777634c6554ec54cbb5fd5c040cb", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 6, "deletions": 67, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -1,46 +1,20 @@\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::higher;\n use clippy_utils::source::{snippet, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{get_parent_expr, in_constant, is_integer_const, meets_msrv, msrvs, path_to_local};\n-use clippy_utils::{higher, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind, HirId, PathSegment, QPath};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, HirId};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::sym;\n use std::cmp::Ordering;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for zipping a collection with the range of\n-    /// `0.._.len()`.\n-    ///\n-    /// ### Why is this bad?\n-    /// The code is better expressed with `.enumerate()`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = vec![1];\n-    /// let _ = x.iter().zip(0..x.len());\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x = vec![1];\n-    /// let _ = x.iter().enumerate();\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub RANGE_ZIP_WITH_LEN,\n-    complexity,\n-    \"zipping iterator with a range when `enumerate()` would do\"\n-}\n-\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for exclusive ranges where 1 is added to the\n@@ -198,7 +172,6 @@ impl Ranges {\n }\n \n impl_lint_pass!(Ranges => [\n-    RANGE_ZIP_WITH_LEN,\n     RANGE_PLUS_ONE,\n     RANGE_MINUS_ONE,\n     REVERSED_EMPTY_RANGES,\n@@ -207,16 +180,10 @@ impl_lint_pass!(Ranges => [\n \n impl<'tcx> LateLintPass<'tcx> for Ranges {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        match expr.kind {\n-            ExprKind::MethodCall(path, args, _) => {\n-                check_range_zip_with_len(cx, path, args, expr.span);\n-            },\n-            ExprKind::Binary(ref op, l, r) => {\n-                if meets_msrv(self.msrv, msrvs::RANGE_CONTAINS) {\n-                    check_possible_range_contains(cx, op.node, l, r, expr, expr.span);\n-                }\n-            },\n-            _ => {},\n+        if let ExprKind::Binary(ref op, l, r) = expr.kind {\n+            if meets_msrv(self.msrv, msrvs::RANGE_CONTAINS) {\n+                check_possible_range_contains(cx, op.node, l, r, expr, expr.span);\n+            }\n         }\n \n         check_exclusive_range_plus_one(cx, expr);\n@@ -380,34 +347,6 @@ fn check_range_bounds<'a>(cx: &'a LateContext<'_>, ex: &'a Expr<'_>) -> Option<R\n     None\n }\n \n-fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args: &[Expr<'_>], span: Span) {\n-    if_chain! {\n-        if path.ident.as_str() == \"zip\";\n-        if let [iter, zip_arg] = args;\n-        // `.iter()` call\n-        if let ExprKind::MethodCall(iter_path, [iter_caller, ..], _) = iter.kind;\n-        if iter_path.ident.name == sym::iter;\n-        // range expression in `.zip()` call: `0..x.len()`\n-        if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::Range::hir(zip_arg);\n-        if is_integer_const(cx, start, 0);\n-        // `.len()` call\n-        if let ExprKind::MethodCall(len_path, [len_caller], _) = end.kind;\n-        if len_path.ident.name == sym::len;\n-        // `.iter()` and `.len()` called on same `Path`\n-        if let ExprKind::Path(QPath::Resolved(_, iter_path)) = iter_caller.kind;\n-        if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_caller.kind;\n-        if SpanlessEq::new(cx).eq_path_segments(iter_path.segments, len_path.segments);\n-        then {\n-            span_lint(cx,\n-                RANGE_ZIP_WITH_LEN,\n-                span,\n-                &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n-                    snippet(cx, iter_caller.span, \"_\"))\n-            );\n-        }\n-    }\n-}\n-\n // exclusive range plus one: `x..(y+1)`\n fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {"}, {"sha": "898c70ace66f35776c42c3b6a866022af81c7751", "filename": "clippy_lints/src/repeat_once.rs", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frepeat_once.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,89 +0,0 @@\n-use clippy_utils::consts::{constant_context, Constant};\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for usage of `.repeat(1)` and suggest the following method for each types.\n-    /// - `.to_string()` for `str`\n-    /// - `.clone()` for `String`\n-    /// - `.to_vec()` for `slice`\n-    ///\n-    /// The lint will evaluate constant expressions and values as arguments of `.repeat(..)` and emit a message if\n-    /// they are equivalent to `1`. (Related discussion in [rust-clippy#7306](https://github.com/rust-lang/rust-clippy/issues/7306))\n-    ///\n-    /// ### Why is this bad?\n-    /// For example, `String.repeat(1)` is equivalent to `.clone()`. If cloning\n-    /// the string is the intention behind this, `clone()` should be used.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// fn main() {\n-    ///     let x = String::from(\"hello world\").repeat(1);\n-    /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// fn main() {\n-    ///     let x = String::from(\"hello world\").clone();\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.47.0\"]\n-    pub REPEAT_ONCE,\n-    complexity,\n-    \"using `.repeat(1)` instead of `String.clone()`, `str.to_string()` or `slice.to_vec()` \"\n-}\n-\n-declare_lint_pass!(RepeatOnce => [REPEAT_ONCE]);\n-\n-impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(path, [receiver, count], _) = &expr.kind;\n-            if path.ident.name == sym!(repeat);\n-            if constant_context(cx, cx.typeck_results()).expr(count) == Some(Constant::Int(1));\n-            if !receiver.span.from_expansion();\n-            then {\n-                let ty = cx.typeck_results().expr_ty(receiver).peel_refs();\n-                if ty.is_str() {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        REPEAT_ONCE,\n-                        expr.span,\n-                        \"calling `repeat(1)` on str\",\n-                        \"consider using `.to_string()` instead\",\n-                        format!(\"{}.to_string()\", snippet(cx, receiver.span, r#\"\"...\"\"#)),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else if ty.builtin_index().is_some() {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        REPEAT_ONCE,\n-                        expr.span,\n-                        \"calling `repeat(1)` on slice\",\n-                        \"consider using `.to_vec()` instead\",\n-                        format!(\"{}.to_vec()\", snippet(cx, receiver.span, r#\"\"...\"\"#)),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else if is_type_diagnostic_item(cx, ty, sym::String) {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        REPEAT_ONCE,\n-                        expr.span,\n-                        \"calling `repeat(1)` on a string literal\",\n-                        \"consider using `.clone()` instead\",\n-                        format!(\"{}.clone()\", snippet(cx, receiver.span, r#\"\"...\"\"#)),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "6d54935f81ab26e29d03b3eac6e1fc33e2c88ea9", "filename": "clippy_lints/src/stable_sort_primitive.rs", "status": "removed", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,144 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::{is_slice_of_primitives, sugg::Sugg};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// When sorting primitive values (integers, bools, chars, as well\n-    /// as arrays, slices, and tuples of such items), it is typically better to\n-    /// use an unstable sort than a stable sort.\n-    ///\n-    /// ### Why is this bad?\n-    /// Typically, using a stable sort consumes more memory and cpu cycles.\n-    /// Because values which compare equal are identical, preserving their\n-    /// relative order (the guarantee that a stable sort provides) means\n-    /// nothing, while the extra costs still apply.\n-    ///\n-    /// ### Known problems\n-    ///\n-    /// As pointed out in\n-    /// [issue #8241](https://github.com/rust-lang/rust-clippy/issues/8241),\n-    /// a stable sort can instead be significantly faster for certain scenarios\n-    /// (eg. when a sorted vector is extended with new data and resorted).\n-    ///\n-    /// For more information and benchmarking results, please refer to the\n-    /// issue linked above.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let mut vec = vec![2, 1, 3];\n-    /// vec.sort();\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let mut vec = vec![2, 1, 3];\n-    /// vec.sort_unstable();\n-    /// ```\n-    #[clippy::version = \"1.47.0\"]\n-    pub STABLE_SORT_PRIMITIVE,\n-    pedantic,\n-    \"use of sort() when sort_unstable() is equivalent\"\n-}\n-\n-declare_lint_pass!(StableSortPrimitive => [STABLE_SORT_PRIMITIVE]);\n-\n-/// The three \"kinds\" of sorts\n-enum SortingKind {\n-    Vanilla,\n-    /* The other kinds of lint are currently commented out because they\n-     * can map distinct values to equal ones. If the key function is\n-     * provably one-to-one, or if the Cmp function conserves equality,\n-     * then they could be linted on, but I don't know if we can check\n-     * for that. */\n-\n-    /* ByKey,\n-     * ByCmp, */\n-}\n-impl SortingKind {\n-    /// The name of the stable version of this kind of sort\n-    fn stable_name(&self) -> &str {\n-        match self {\n-            SortingKind::Vanilla => \"sort\",\n-            /* SortingKind::ByKey => \"sort_by_key\",\n-             * SortingKind::ByCmp => \"sort_by\", */\n-        }\n-    }\n-    /// The name of the unstable version of this kind of sort\n-    fn unstable_name(&self) -> &str {\n-        match self {\n-            SortingKind::Vanilla => \"sort_unstable\",\n-            /* SortingKind::ByKey => \"sort_unstable_by_key\",\n-             * SortingKind::ByCmp => \"sort_unstable_by\", */\n-        }\n-    }\n-    /// Takes the name of a function call and returns the kind of sort\n-    /// that corresponds to that function name (or None if it isn't)\n-    fn from_stable_name(name: &str) -> Option<SortingKind> {\n-        match name {\n-            \"sort\" => Some(SortingKind::Vanilla),\n-            // \"sort_by\" => Some(SortingKind::ByCmp),\n-            // \"sort_by_key\" => Some(SortingKind::ByKey),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-/// A detected instance of this lint\n-struct LintDetection {\n-    slice_name: String,\n-    method: SortingKind,\n-    method_args: String,\n-    slice_type: String,\n-}\n-\n-fn detect_stable_sort_primitive(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintDetection> {\n-    if_chain! {\n-        if let ExprKind::MethodCall(method_name, [slice, args @ ..], _) = &expr.kind;\n-        if let Some(method) = SortingKind::from_stable_name(method_name.ident.name.as_str());\n-        if let Some(slice_type) = is_slice_of_primitives(cx, slice);\n-        then {\n-            let args_str = args.iter().map(|arg| Sugg::hir(cx, arg, \"..\").to_string()).collect::<Vec<String>>().join(\", \");\n-            Some(LintDetection { slice_name: Sugg::hir(cx, slice, \"..\").to_string(), method, method_args: args_str, slice_type })\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl LateLintPass<'_> for StableSortPrimitive {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if let Some(detection) = detect_stable_sort_primitive(cx, expr) {\n-            span_lint_and_then(\n-                cx,\n-                STABLE_SORT_PRIMITIVE,\n-                expr.span,\n-                format!(\n-                    \"used `{}` on primitive type `{}`\",\n-                    detection.method.stable_name(),\n-                    detection.slice_type,\n-                )\n-                .as_str(),\n-                |diag| {\n-                    diag.span_suggestion(\n-                        expr.span,\n-                        \"try\",\n-                        format!(\n-                            \"{}.{}({})\",\n-                            detection.slice_name,\n-                            detection.method.unstable_name(),\n-                            detection.method_args,\n-                        ),\n-                        Applicability::MachineApplicable,\n-                    );\n-                    diag.note(\n-                        \"an unstable sort typically performs faster without any observable difference for this data type\",\n-                    );\n-                },\n-            );\n-        }\n-    }\n-}"}, {"sha": "424a6e9264e4b96680b6e4a09cfab81e2a36083f", "filename": "clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -9,6 +9,7 @@ mod transmute_ptr_to_ref;\n mod transmute_ref_to_ref;\n mod transmute_undefined_repr;\n mod transmutes_expressible_as_ptr_casts;\n+mod transmuting_null;\n mod unsound_collection_transmute;\n mod useless_transmute;\n mod utils;\n@@ -386,6 +387,28 @@ declare_clippy_lint! {\n     \"transmute to or from a type with an undefined representation\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for transmute calls which would receive a null pointer.\n+    ///\n+    /// ### Why is this bad?\n+    /// Transmuting a null pointer is undefined behavior.\n+    ///\n+    /// ### Known problems\n+    /// Not all cases can be detected at the moment of this writing.\n+    /// For example, variables which hold a null pointer and are then fed to a `transmute`\n+    /// call, aren't detectable yet.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let null_ref: &u64 = unsafe { std::mem::transmute(0 as *const u64) };\n+    /// ```\n+    #[clippy::version = \"1.35.0\"]\n+    pub TRANSMUTING_NULL,\n+    correctness,\n+    \"transmutes from a null pointer to a reference, which is undefined behavior\"\n+}\n+\n pub struct Transmute {\n     msrv: Option<RustcVersion>,\n }\n@@ -404,6 +427,7 @@ impl_lint_pass!(Transmute => [\n     UNSOUND_COLLECTION_TRANSMUTE,\n     TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n     TRANSMUTE_UNDEFINED_REPR,\n+    TRANSMUTING_NULL,\n ]);\n impl Transmute {\n     #[must_use]\n@@ -436,6 +460,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n \n                 let linted = wrong_transmute::check(cx, e, from_ty, to_ty)\n                     | crosspointer_transmute::check(cx, e, from_ty, to_ty)\n+                    | transmuting_null::check(cx, e, arg, to_ty)\n                     | transmute_ptr_to_ref::check(cx, e, from_ty, to_ty, arg, path, self.msrv)\n                     | transmute_int_to_char::check(cx, e, from_ty, to_ty, arg, const_context)\n                     | transmute_ref_to_ref::check(cx, e, from_ty, to_ty, arg, const_context)"}, {"sha": "c4981124f396634e75a606c0d8775b920b9ec8ff", "filename": "clippy_lints/src/transmute/transmuting_null.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/clippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -0,0 +1,61 @@\n+use clippy_utils::consts::{constant_context, Constant};\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::is_expr_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_ast::LitKind;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+use rustc_span::symbol::sym;\n+\n+use super::TRANSMUTING_NULL;\n+\n+const LINT_MSG: &str = \"transmuting a known null pointer into a reference\";\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arg: &'tcx Expr<'_>, to_ty: Ty<'tcx>) -> bool {\n+    if !to_ty.is_ref() {\n+        return false;\n+    }\n+\n+    // Catching transmute over constants that resolve to `null`.\n+    let mut const_eval_context = constant_context(cx, cx.typeck_results());\n+    if_chain! {\n+        if let ExprKind::Path(ref _qpath) = arg.kind;\n+        if let Some(Constant::RawPtr(x)) = const_eval_context.expr(arg);\n+        if x == 0;\n+        then {\n+            span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n+            return true;\n+        }\n+    }\n+\n+    // Catching:\n+    // `std::mem::transmute(0 as *const i32)`\n+    if_chain! {\n+        if let ExprKind::Cast(inner_expr, _cast_ty) = arg.kind;\n+        if let ExprKind::Lit(ref lit) = inner_expr.kind;\n+        if let LitKind::Int(0, _) = lit.node;\n+        then {\n+            span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n+            return true;\n+        }\n+    }\n+\n+    // Catching:\n+    // `std::mem::transmute(std::ptr::null::<i32>())`\n+    if_chain! {\n+        if let ExprKind::Call(func1, []) = arg.kind;\n+        if is_expr_diagnostic_item(cx, func1, sym::ptr_null);\n+        then {\n+            span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n+            return true;\n+        }\n+    }\n+\n+    // FIXME:\n+    // Also catch transmutations of variables which are known nulls.\n+    // To do this, MIR const propagation seems to be the better tool.\n+    // Whenever MIR const prop routines are more developed, this will\n+    // become available. As of this writing (25/03/19) it is not yet.\n+    false\n+}"}, {"sha": "7939dfedc3a2b4fb6d39555f29a3596828895861", "filename": "clippy_lints/src/transmuting_null.rs", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,89 +0,0 @@\n-use clippy_utils::consts::{constant_context, Constant};\n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::is_expr_diagnostic_item;\n-use if_chain::if_chain;\n-use rustc_ast::LitKind;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for transmute calls which would receive a null pointer.\n-    ///\n-    /// ### Why is this bad?\n-    /// Transmuting a null pointer is undefined behavior.\n-    ///\n-    /// ### Known problems\n-    /// Not all cases can be detected at the moment of this writing.\n-    /// For example, variables which hold a null pointer and are then fed to a `transmute`\n-    /// call, aren't detectable yet.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let null_ref: &u64 = unsafe { std::mem::transmute(0 as *const u64) };\n-    /// ```\n-    #[clippy::version = \"1.35.0\"]\n-    pub TRANSMUTING_NULL,\n-    correctness,\n-    \"transmutes from a null pointer to a reference, which is undefined behavior\"\n-}\n-\n-declare_lint_pass!(TransmutingNull => [TRANSMUTING_NULL]);\n-\n-const LINT_MSG: &str = \"transmuting a known null pointer into a reference\";\n-\n-impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if in_external_macro(cx.sess(), expr.span) {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::Call(func, [arg]) = expr.kind;\n-            if is_expr_diagnostic_item(cx, func, sym::transmute);\n-\n-            then {\n-                // Catching transmute over constants that resolve to `null`.\n-                let mut const_eval_context = constant_context(cx, cx.typeck_results());\n-                if_chain! {\n-                    if let ExprKind::Path(ref _qpath) = arg.kind;\n-                    if let Some(Constant::RawPtr(x)) = const_eval_context.expr(arg);\n-                    if x == 0;\n-                    then {\n-                        span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG)\n-                    }\n-                }\n-\n-                // Catching:\n-                // `std::mem::transmute(0 as *const i32)`\n-                if_chain! {\n-                    if let ExprKind::Cast(inner_expr, _cast_ty) = arg.kind;\n-                    if let ExprKind::Lit(ref lit) = inner_expr.kind;\n-                    if let LitKind::Int(0, _) = lit.node;\n-                    then {\n-                        span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG)\n-                    }\n-                }\n-\n-                // Catching:\n-                // `std::mem::transmute(std::ptr::null::<i32>())`\n-                if_chain! {\n-                    if let ExprKind::Call(func1, []) = arg.kind;\n-                    if is_expr_diagnostic_item(cx, func1, sym::ptr_null);\n-                    then {\n-                        span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG)\n-                    }\n-                }\n-\n-                // FIXME:\n-                // Also catch transmutations of variables which are known nulls.\n-                // To do this, MIR const propagation seems to be the better tool.\n-                // Whenever MIR const prop routines are more developed, this will\n-                // become available. As of this writing (25/03/19) it is not yet.\n-            }\n-        }\n-    }\n-}"}, {"sha": "88ca0cb20a12c59dc66bf903e31dd9962932f8c5", "filename": "clippy_lints/src/unit_hash.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Funit_hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Funit_hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_hash.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,78 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::snippet;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Detects `().hash(_)`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Hashing a unit value doesn't do anything as the implementation of `Hash` for `()` is a no-op.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # use std::hash::Hash;\n-    /// # use std::collections::hash_map::DefaultHasher;\n-    /// # enum Foo { Empty, WithValue(u8) }\n-    /// # use Foo::*;\n-    /// # let mut state = DefaultHasher::new();\n-    /// # let my_enum = Foo::Empty;\n-    /// match my_enum {\n-    /// \tEmpty => ().hash(&mut state),\n-    /// \tWithValue(x) => x.hash(&mut state),\n-    /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// # use std::hash::Hash;\n-    /// # use std::collections::hash_map::DefaultHasher;\n-    /// # enum Foo { Empty, WithValue(u8) }\n-    /// # use Foo::*;\n-    /// # let mut state = DefaultHasher::new();\n-    /// # let my_enum = Foo::Empty;\n-    /// match my_enum {\n-    /// \tEmpty => 0_u8.hash(&mut state),\n-    /// \tWithValue(x) => x.hash(&mut state),\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.58.0\"]\n-    pub UNIT_HASH,\n-    correctness,\n-    \"hashing a unit value, which does nothing\"\n-}\n-declare_lint_pass!(UnitHash => [UNIT_HASH]);\n-\n-impl<'tcx> LateLintPass<'tcx> for UnitHash {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(name_ident, args, _) = &expr.kind;\n-            if name_ident.ident.name == sym::hash;\n-            if let [recv, state_param] = args;\n-            if cx.typeck_results().expr_ty(recv).is_unit();\n-            then {\n-                span_lint_and_then(\n-                    cx,\n-                    UNIT_HASH,\n-                    expr.span,\n-                    \"this call to `hash` on the unit type will do nothing\",\n-                    |diag| {\n-                        diag.span_suggestion(\n-                            expr.span,\n-                            \"remove the call to `hash` or consider using\",\n-                            format!(\n-                                \"0_u8.hash({})\",\n-                                snippet(cx, state_param.span, \"..\"),\n-                            ),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        diag.note(\"the implementation of `Hash` for `()` is a no-op\");\n-                    }\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "0fee3e812d286db1a143c583455b8e12a8e00062", "filename": "clippy_lints/src/vec_resize_to_zero.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,64 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::{match_def_path, paths};\n-use if_chain::if_chain;\n-use rustc_ast::LitKind;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Spanned;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Finds occurrences of `Vec::resize(0, an_int)`\n-    ///\n-    /// ### Why is this bad?\n-    /// This is probably an argument inversion mistake.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// vec!(1, 2, 3, 4, 5).resize(0, 5)\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// vec!(1, 2, 3, 4, 5).clear()\n-    /// ```\n-    #[clippy::version = \"1.46.0\"]\n-    pub VEC_RESIZE_TO_ZERO,\n-    correctness,\n-    \"emptying a vector with `resize(0, an_int)` instead of `clear()` is probably an argument inversion mistake\"\n-}\n-\n-declare_lint_pass!(VecResizeToZero => [VEC_RESIZE_TO_ZERO]);\n-\n-impl<'tcx> LateLintPass<'tcx> for VecResizeToZero {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let hir::ExprKind::MethodCall(path_segment, args, _) = expr.kind;\n-            if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-            if match_def_path(cx, method_def_id, &paths::VEC_RESIZE) && args.len() == 3;\n-            if let ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = args[1].kind;\n-            if let ExprKind::Lit(Spanned { node: LitKind::Int(..), .. }) = args[2].kind;\n-            then {\n-                let method_call_span = expr.span.with_lo(path_segment.ident.span.lo());\n-                span_lint_and_then(\n-                    cx,\n-                    VEC_RESIZE_TO_ZERO,\n-                    expr.span,\n-                    \"emptying a vector with `resize`\",\n-                    |db| {\n-                        db.help(\"the arguments may be inverted...\");\n-                        db.span_suggestion(\n-                            method_call_span,\n-                            \"...or you can empty the vector with\",\n-                            \"clear()\".to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    },\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "afd0077a658049160feb972d23c7a0391769602c", "filename": "clippy_lints/src/verbose_file_reads.rs", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868dba9f65a40ffd406baba9ca301b4dc33ff641/clippy_lints%2Fsrc%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fverbose_file_reads.rs?ref=868dba9f65a40ffd406baba9ca301b4dc33ff641", "patch": "@@ -1,88 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::paths;\n-use clippy_utils::ty::match_type;\n-use if_chain::if_chain;\n-use rustc_hir::{Expr, ExprKind, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for use of File::read_to_end and File::read_to_string.\n-    ///\n-    /// ### Why is this bad?\n-    /// `fs::{read, read_to_string}` provide the same functionality when `buf` is empty with fewer imports and no intermediate values.\n-    /// See also: [fs::read docs](https://doc.rust-lang.org/std/fs/fn.read.html), [fs::read_to_string docs](https://doc.rust-lang.org/std/fs/fn.read_to_string.html)\n-    ///\n-    /// ### Example\n-    /// ```rust,no_run\n-    /// # use std::io::Read;\n-    /// # use std::fs::File;\n-    /// let mut f = File::open(\"foo.txt\").unwrap();\n-    /// let mut bytes = Vec::new();\n-    /// f.read_to_end(&mut bytes).unwrap();\n-    /// ```\n-    /// Can be written more concisely as\n-    /// ```rust,no_run\n-    /// # use std::fs;\n-    /// let mut bytes = fs::read(\"foo.txt\").unwrap();\n-    /// ```\n-    #[clippy::version = \"1.44.0\"]\n-    pub VERBOSE_FILE_READS,\n-    restriction,\n-    \"use of `File::read_to_end` or `File::read_to_string`\"\n-}\n-\n-declare_lint_pass!(VerboseFileReads => [VERBOSE_FILE_READS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for VerboseFileReads {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if is_file_read_to_end(cx, expr) {\n-            span_lint_and_help(\n-                cx,\n-                VERBOSE_FILE_READS,\n-                expr.span,\n-                \"use of `File::read_to_end`\",\n-                None,\n-                \"consider using `fs::read` instead\",\n-            );\n-        } else if is_file_read_to_string(cx, expr) {\n-            span_lint_and_help(\n-                cx,\n-                VERBOSE_FILE_READS,\n-                expr.span,\n-                \"use of `File::read_to_string`\",\n-                None,\n-                \"consider using `fs::read_to_string` instead\",\n-            );\n-        }\n-    }\n-}\n-\n-fn is_file_read_to_end<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    if_chain! {\n-        if let ExprKind::MethodCall(method_name, [recv, ..], _) = expr.kind;\n-        if method_name.ident.as_str() == \"read_to_end\";\n-        if let ExprKind::Path(QPath::Resolved(None, _)) = &recv.kind;\n-        let ty = cx.typeck_results().expr_ty(recv);\n-        if match_type(cx, ty, &paths::FILE);\n-        then {\n-            return true\n-        }\n-    }\n-    false\n-}\n-\n-fn is_file_read_to_string<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    if_chain! {\n-        if let ExprKind::MethodCall(method_name, exprs, _) = expr.kind;\n-        if method_name.ident.as_str() == \"read_to_string\";\n-        if let ExprKind::Path(QPath::Resolved(None, _)) = &exprs[0].kind;\n-        let ty = cx.typeck_results().expr_ty(&exprs[0]);\n-        if match_type(cx, ty, &paths::FILE);\n-        then {\n-            return true\n-        }\n-    }\n-    false\n-}"}, {"sha": "a8307e741cf17b0c8ff64fd53cf2096b22c7f068", "filename": "tests/ui/vec_resize_to_zero.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/tests%2Fui%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/tests%2Fui%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_resize_to_zero.rs?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -1,15 +1,19 @@\n #![warn(clippy::vec_resize_to_zero)]\n \n fn main() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+\n     // applicable here\n-    vec![1, 2, 3, 4, 5].resize(0, 5);\n+    v.resize(0, 5);\n \n     // not applicable\n-    vec![1, 2, 3, 4, 5].resize(2, 5);\n+    v.resize(2, 5);\n+\n+    let mut v = vec![\"foo\", \"bar\", \"baz\"];\n \n     // applicable here, but only implemented for integer literals for now\n-    vec![\"foo\", \"bar\", \"baz\"].resize(0, \"bar\");\n+    v.resize(0, \"bar\");\n \n     // not applicable\n-    vec![\"foo\", \"bar\", \"baz\"].resize(2, \"bar\")\n+    v.resize(2, \"bar\")\n }"}, {"sha": "7428cf62d6c429554d8a54e37cc641dfb93f8536", "filename": "tests/ui/vec_resize_to_zero.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/477c16d45bb93cc92611b56614ce2b823bffab8d/tests%2Fui%2Fvec_resize_to_zero.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/477c16d45bb93cc92611b56614ce2b823bffab8d/tests%2Fui%2Fvec_resize_to_zero.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_resize_to_zero.stderr?ref=477c16d45bb93cc92611b56614ce2b823bffab8d", "patch": "@@ -1,10 +1,10 @@\n error: emptying a vector with `resize`\n-  --> $DIR/vec_resize_to_zero.rs:5:5\n+  --> $DIR/vec_resize_to_zero.rs:7:5\n    |\n-LL |     vec![1, 2, 3, 4, 5].resize(0, 5);\n-   |     ^^^^^^^^^^^^^^^^^^^^------------\n-   |                         |\n-   |                         help: ...or you can empty the vector with: `clear()`\n+LL |     v.resize(0, 5);\n+   |     ^^------------\n+   |       |\n+   |       help: ...or you can empty the vector with: `clear()`\n    |\n    = note: `-D clippy::vec-resize-to-zero` implied by `-D warnings`\n    = help: the arguments may be inverted..."}]}