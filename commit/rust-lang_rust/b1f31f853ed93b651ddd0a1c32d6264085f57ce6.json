{"sha": "b1f31f853ed93b651ddd0a1c32d6264085f57ce6", "node_id": "C_kwDOAAsO6NoAKGIxZjMxZjg1M2VkOTNiNjUxZGRkMGExYzMyZDYyNjQwODVmNTdjZTY", "commit": {"author": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2022-06-14T14:03:26Z"}, "committer": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2022-06-16T17:36:51Z"}, "message": "ctfe: limit hashing of big const allocations when interning\n\nBig const allocations hash a large amount of data for interning:\nthe whole bytes buffer, and the 1/8th sized initmask, with FxHash.\nThis hash function is made for shorter keys.\n\nThis only hashes the length, and head and tail of these buffers, to\nlimit possible collisions while avoiding most of the hashing work.", "tree": {"sha": "c00b1bc676c8d420c40ef45241fc6a8e1f7bff78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c00b1bc676c8d420c40ef45241fc6a8e1f7bff78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1f31f853ed93b651ddd0a1c32d6264085f57ce6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1f31f853ed93b651ddd0a1c32d6264085f57ce6", "html_url": "https://github.com/rust-lang/rust/commit/b1f31f853ed93b651ddd0a1c32d6264085f57ce6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1f31f853ed93b651ddd0a1c32d6264085f57ce6/comments", "author": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d35d972e6974d40d30362344ea619a5b560aae20", "url": "https://api.github.com/repos/rust-lang/rust/commits/d35d972e6974d40d30362344ea619a5b560aae20", "html_url": "https://github.com/rust-lang/rust/commit/d35d972e6974d40d30362344ea619a5b560aae20"}], "stats": {"total": 73, "additions": 71, "deletions": 2}, "files": [{"sha": "ad79d9adb00a5192bf7ac181a13f61992f0786ee", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 71, "deletions": 2, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b1f31f853ed93b651ddd0a1c32d6264085f57ce6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f31f853ed93b651ddd0a1c32d6264085f57ce6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=b1f31f853ed93b651ddd0a1c32d6264085f57ce6", "patch": "@@ -3,6 +3,7 @@\n use std::borrow::Cow;\n use std::convert::{TryFrom, TryInto};\n use std::fmt;\n+use std::hash;\n use std::iter;\n use std::ops::{Deref, Range};\n use std::ptr;\n@@ -25,7 +26,7 @@ use crate::ty;\n /// Its public API is rather low-level, working directly with allocation offsets and a custom error\n /// type to account for the lack of an AllocId on this level. The Miri/CTFE core engine `memory`\n /// module provides higher-level access.\n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n+#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct Allocation<Tag = AllocId, Extra = ()> {\n     /// The actual bytes of the allocation.\n@@ -49,6 +50,46 @@ pub struct Allocation<Tag = AllocId, Extra = ()> {\n     pub extra: Extra,\n }\n \n+/// This is the maximum size we will hash at a time from these two structures, when interning. Note,\n+/// we hash that amount of bytes twice: at the start, and at the end of a buffer. Used when an\n+/// `Allocation` and its `InitMask` are large: we only partially hash the larger fields in that\n+/// situation. See the comment at the top of their respective `Hash` impl for more details.\n+const MAX_BYTES_TO_HASH: usize = 64;\n+\n+/// This is the maximum size (in bytes) for which a buffer will be fully hashed when interning.\n+/// Otherwise, it will be partially hashed in 2 slices, requiring at least 2 `MAX_BYTES_TO_HASH`\n+/// bytes.\n+const MAX_HASHED_BUFFER_LEN: usize = 2 * MAX_BYTES_TO_HASH;\n+\n+// Const allocations are only hashed for interning. However, they can be large, making the hashing\n+// expensive especially since it uses `FxHash`: it's better suited to short keys, not potentially\n+// big buffers like the actual bytes of allocation. We can partially hash some fields when they're\n+// large.\n+impl hash::Hash for Allocation {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        // Partially hash the `bytes` buffer when it is large. To limit collisions with common\n+        // prefixes and suffixes, we hash the length and some slices of the buffer.\n+        let byte_count = self.bytes.len();\n+        if byte_count > MAX_HASHED_BUFFER_LEN {\n+            // Hash the buffer's length.\n+            byte_count.hash(state);\n+\n+            // And its head and tail.\n+            self.bytes[..MAX_BYTES_TO_HASH].hash(state);\n+            self.bytes[byte_count - MAX_BYTES_TO_HASH..].hash(state);\n+        } else {\n+            self.bytes.hash(state);\n+        }\n+\n+        // Hash the other fields as usual.\n+        self.relocations.hash(state);\n+        self.init_mask.hash(state);\n+        self.align.hash(state);\n+        self.mutability.hash(state);\n+        self.extra.hash(state);\n+    }\n+}\n+\n /// Interned types generally have an `Outer` type and an `Inner` type, where\n /// `Outer` is a newtype around `Interned<Inner>`, and all the operations are\n /// done on `Outer`, because all occurrences are interned. E.g. `Ty` is an\n@@ -640,13 +681,41 @@ type Block = u64;\n \n /// A bitmask where each bit refers to the byte with the same index. If the bit is `true`, the byte\n /// is initialized. If it is `false` the byte is uninitialized.\n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n+#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct InitMask {\n     blocks: Vec<Block>,\n     len: Size,\n }\n \n+// Const allocations are only hashed for interning. However, they can be large, making the hashing\n+// expensive especially since it uses `FxHash`: it's better suited to short keys, not potentially\n+// big buffers like the allocation's init mask. We can partially hash some fields when they're\n+// large.\n+impl hash::Hash for InitMask {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        const MAX_BLOCKS_TO_HASH: usize = MAX_BYTES_TO_HASH / std::mem::size_of::<Block>();\n+        const MAX_BLOCKS_LEN: usize = MAX_HASHED_BUFFER_LEN / std::mem::size_of::<Block>();\n+\n+        // Partially hash the `blocks` buffer when it is large. To limit collisions with common\n+        // prefixes and suffixes, we hash the length and some slices of the buffer.\n+        let block_count = self.blocks.len();\n+        if block_count > MAX_BLOCKS_LEN {\n+            // Hash the buffer's length.\n+            block_count.hash(state);\n+\n+            // And its head and tail.\n+            self.blocks[..MAX_BLOCKS_TO_HASH].hash(state);\n+            self.blocks[block_count - MAX_BLOCKS_TO_HASH..].hash(state);\n+        } else {\n+            self.blocks.hash(state);\n+        }\n+\n+        // Hash the other fields as usual.\n+        self.len.hash(state);\n+    }\n+}\n+\n impl InitMask {\n     pub const BLOCK_SIZE: u64 = 64;\n "}]}