{"sha": "f127aba96d1f0610f854e54a3386023c2331b1f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMjdhYmE5NmQxZjA2MTBmODU0ZTU0YTMzODYwMjNjMjMzMWIxZjM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-02-12T19:36:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-12T19:36:51Z"}, "message": "Rollup merge of #67954 - nikic:new-pm, r=nagisa\n\nSupport new LLVM pass manager\n\nAdd support for the new LLVM pass manager behind a `-Z new-llvm-pass-manager=on` option. Both the pre-link optimization and LTO pipelines use the new pass manager. There's some bits that are not supported yet:\n\n * `-C passes`. NewPM requires an entirely different way of specifying custom pass pipelines. We should probably expose that functionality, but it doesn't directly map to what `-C passes` does.\n * NewPM has no support for custom inline parameters right now. We'd have to add upstream support for that first.\n * NewPM does not support PGO at O0 in LLVM 9 (which is why those tests fail with NewPM enabled). This is supported in LLVM 10.\n * NewPM does not support MergeFunctions in LLVM 9. I've landed this upstream just before the cut, so we'll be able to re-enable that with LLVM 10.\n\nCloses #64289.\n\nr? @ghost", "tree": {"sha": "a3fe45dbbbb7b48ef6155e47fb828fe50a625d24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3fe45dbbbb7b48ef6155e47fb828fe50a625d24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f127aba96d1f0610f854e54a3386023c2331b1f3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeRFPTCRBK7hj4Ov3rIwAAdHIIAIDuCqG9RDj7/VHnh26yeQ+y\nM6Bylm2pw/uIWVEFTxWCOpoftuOHRkgzNm4Ta04nZQBep19phqbi0sn1xzj4wP1D\nTHzFOSVrLlJp4onA54cy1hfmpT1vlxu4HnNmgUCYH0MPlg8xs8hqYq/YUObGgK1c\nCMkAYUMX85zRAx1RdQ5AM+JSgy5A8a8irTZHe4WVaxbHjxpcmMLWfutCLl3FE8J0\nTJ601Ca2IlZA1iRaNnsFcIPgfHPFGcS3/HWa1hWeJPevBxJDs5rIZ5UVOJD2OvkG\nxulINqeSMHAtY+hfPoKS5YMxbpBfxHfOQqriS+XJcORWwnu47krW4dQ7Ipd2/Xc=\n=JXdy\n-----END PGP SIGNATURE-----\n", "payload": "tree a3fe45dbbbb7b48ef6155e47fb828fe50a625d24\nparent 2d2be570970d784db5539a1d309cd22b85be910a\nparent c6b0803202c95abd614c8ea448f7c7ff948da31a\nauthor Dylan DPC <dylan.dpc@gmail.com> 1581536211 +0100\ncommitter GitHub <noreply@github.com> 1581536211 +0100\n\nRollup merge of #67954 - nikic:new-pm, r=nagisa\n\nSupport new LLVM pass manager\n\nAdd support for the new LLVM pass manager behind a `-Z new-llvm-pass-manager=on` option. Both the pre-link optimization and LTO pipelines use the new pass manager. There's some bits that are not supported yet:\n\n * `-C passes`. NewPM requires an entirely different way of specifying custom pass pipelines. We should probably expose that functionality, but it doesn't directly map to what `-C passes` does.\n * NewPM has no support for custom inline parameters right now. We'd have to add upstream support for that first.\n * NewPM does not support PGO at O0 in LLVM 9 (which is why those tests fail with NewPM enabled). This is supported in LLVM 10.\n * NewPM does not support MergeFunctions in LLVM 9. I've landed this upstream just before the cut, so we'll be able to re-enable that with LLVM 10.\n\nCloses #64289.\n\nr? @ghost\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f127aba96d1f0610f854e54a3386023c2331b1f3", "html_url": "https://github.com/rust-lang/rust/commit/f127aba96d1f0610f854e54a3386023c2331b1f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f127aba96d1f0610f854e54a3386023c2331b1f3/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d2be570970d784db5539a1d309cd22b85be910a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d2be570970d784db5539a1d309cd22b85be910a", "html_url": "https://github.com/rust-lang/rust/commit/2d2be570970d784db5539a1d309cd22b85be910a"}, {"sha": "c6b0803202c95abd614c8ea448f7c7ff948da31a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6b0803202c95abd614c8ea448f7c7ff948da31a", "html_url": "https://github.com/rust-lang/rust/commit/c6b0803202c95abd614c8ea448f7c7ff948da31a"}], "stats": {"total": 490, "additions": 453, "deletions": 37}, "files": [{"sha": "e3d69fc5c76dfcc87f39ec1b6c9c558959b7380c", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=f127aba96d1f0610f854e54a3386023c2331b1f3", "patch": "@@ -584,6 +584,20 @@ pub(crate) fn run_pass_manager(\n     //      tools/lto/LTOCodeGenerator.cpp\n     debug!(\"running the pass manager\");\n     unsafe {\n+        if write::should_use_new_llvm_pass_manager(config) {\n+            let opt_stage = if thin { llvm::OptStage::ThinLTO } else { llvm::OptStage::FatLTO };\n+            let opt_level = config.opt_level.unwrap_or(config::OptLevel::No);\n+            // See comment below for why this is necessary.\n+            let opt_level = if let config::OptLevel::No = opt_level {\n+                config::OptLevel::Less\n+            } else {\n+                opt_level\n+            };\n+            write::optimize_with_new_llvm_pass_manager(module, config, opt_level, opt_stage);\n+            debug!(\"lto done\");\n+            return;\n+        }\n+\n         let pm = llvm::LLVMCreatePassManager();\n         llvm::LLVMAddAnalysisPasses(module.module_llvm.tm, pm);\n "}, {"sha": "9008970847a59987204b4dd3e6ca4261eef0db86", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 107, "deletions": 18, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=f127aba96d1f0610f854e54a3386023c2331b1f3", "patch": "@@ -111,6 +111,18 @@ pub fn to_llvm_opt_settings(\n     }\n }\n \n+fn to_pass_builder_opt_level(cfg: config::OptLevel) -> llvm::PassBuilderOptLevel {\n+    use config::OptLevel::*;\n+    match cfg {\n+        No => llvm::PassBuilderOptLevel::O0,\n+        Less => llvm::PassBuilderOptLevel::O1,\n+        Default => llvm::PassBuilderOptLevel::O2,\n+        Aggressive => llvm::PassBuilderOptLevel::O3,\n+        Size => llvm::PassBuilderOptLevel::Os,\n+        SizeMin => llvm::PassBuilderOptLevel::Oz,\n+    }\n+}\n+\n // If find_features is true this won't access `sess.crate_types` by assuming\n // that `is_pie_binary` is false. When we discover LLVM target features\n // `sess.crate_types` is uninitialized so we cannot access it.\n@@ -303,6 +315,88 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n     }\n }\n \n+fn get_pgo_gen_path(config: &ModuleConfig) -> Option<CString> {\n+    match config.pgo_gen {\n+        SwitchWithOptPath::Enabled(ref opt_dir_path) => {\n+            let path = if let Some(dir_path) = opt_dir_path {\n+                dir_path.join(\"default_%m.profraw\")\n+            } else {\n+                PathBuf::from(\"default_%m.profraw\")\n+            };\n+\n+            Some(CString::new(format!(\"{}\", path.display())).unwrap())\n+        }\n+        SwitchWithOptPath::Disabled => None,\n+    }\n+}\n+\n+fn get_pgo_use_path(config: &ModuleConfig) -> Option<CString> {\n+    config\n+        .pgo_use\n+        .as_ref()\n+        .map(|path_buf| CString::new(path_buf.to_string_lossy().as_bytes()).unwrap())\n+}\n+\n+pub(crate) fn should_use_new_llvm_pass_manager(config: &ModuleConfig) -> bool {\n+    // We only support the new pass manager starting with LLVM 9.\n+    if llvm_util::get_major_version() < 9 {\n+        return false;\n+    }\n+\n+    // The new pass manager is disabled by default.\n+    config.new_llvm_pass_manager.unwrap_or(false)\n+}\n+\n+pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n+    module: &ModuleCodegen<ModuleLlvm>,\n+    config: &ModuleConfig,\n+    opt_level: config::OptLevel,\n+    opt_stage: llvm::OptStage,\n+) {\n+    let unroll_loops =\n+        opt_level != config::OptLevel::Size && opt_level != config::OptLevel::SizeMin;\n+    let using_thin_buffers = opt_stage == llvm::OptStage::PreLinkThinLTO || config.bitcode_needed();\n+    let pgo_gen_path = get_pgo_gen_path(config);\n+    let pgo_use_path = get_pgo_use_path(config);\n+    let is_lto = opt_stage == llvm::OptStage::ThinLTO || opt_stage == llvm::OptStage::FatLTO;\n+    // Sanitizer instrumentation is only inserted during the pre-link optimization stage.\n+    let sanitizer_options = if !is_lto {\n+        config.sanitizer.as_ref().map(|s| llvm::SanitizerOptions {\n+            sanitize_memory: *s == Sanitizer::Memory,\n+            sanitize_thread: *s == Sanitizer::Thread,\n+            sanitize_address: *s == Sanitizer::Address,\n+            sanitize_recover: config.sanitizer_recover.contains(s),\n+            sanitize_memory_track_origins: config.sanitizer_memory_track_origins as c_int,\n+        })\n+    } else {\n+        None\n+    };\n+\n+    // FIXME: NewPM doesn't provide a facility to pass custom InlineParams.\n+    // We would have to add upstream support for this first, before we can support\n+    // config.inline_threshold and our more aggressive default thresholds.\n+    // FIXME: NewPM uses an different and more explicit way to textually represent\n+    // pass pipelines. It would probably make sense to expose this, but it would\n+    // require a different format than the current -C passes.\n+    llvm::LLVMRustOptimizeWithNewPassManager(\n+        module.module_llvm.llmod(),\n+        &*module.module_llvm.tm,\n+        to_pass_builder_opt_level(opt_level),\n+        opt_stage,\n+        config.no_prepopulate_passes,\n+        config.verify_llvm_ir,\n+        using_thin_buffers,\n+        config.merge_functions,\n+        unroll_loops,\n+        config.vectorize_slp,\n+        config.vectorize_loop,\n+        config.no_builtins,\n+        sanitizer_options.as_ref(),\n+        pgo_gen_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n+        pgo_use_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n+    );\n+}\n+\n // Unsafe due to LLVM calls.\n pub(crate) unsafe fn optimize(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n@@ -327,6 +421,17 @@ pub(crate) unsafe fn optimize(\n     }\n \n     if let Some(opt_level) = config.opt_level {\n+        if should_use_new_llvm_pass_manager(config) {\n+            let opt_stage = match cgcx.lto {\n+                Lto::Fat => llvm::OptStage::PreLinkFatLTO,\n+                Lto::Thin | Lto::ThinLocal => llvm::OptStage::PreLinkThinLTO,\n+                _ if cgcx.opts.cg.linker_plugin_lto.enabled() => llvm::OptStage::PreLinkThinLTO,\n+                _ => llvm::OptStage::PreLinkNoLTO,\n+            };\n+            optimize_with_new_llvm_pass_manager(module, config, opt_level, opt_stage);\n+            return Ok(());\n+        }\n+\n         // Create the two optimizing pass managers. These mirror what clang\n         // does, and are by populated by LLVM's default PassManagerBuilder.\n         // Each manager has a different set of passes, but they also share\n@@ -757,24 +862,8 @@ pub unsafe fn with_llvm_pmb(\n     let opt_size =\n         config.opt_size.map(|x| to_llvm_opt_settings(x).1).unwrap_or(llvm::CodeGenOptSizeNone);\n     let inline_threshold = config.inline_threshold;\n-\n-    let pgo_gen_path = match config.pgo_gen {\n-        SwitchWithOptPath::Enabled(ref opt_dir_path) => {\n-            let path = if let Some(dir_path) = opt_dir_path {\n-                dir_path.join(\"default_%m.profraw\")\n-            } else {\n-                PathBuf::from(\"default_%m.profraw\")\n-            };\n-\n-            Some(CString::new(format!(\"{}\", path.display())).unwrap())\n-        }\n-        SwitchWithOptPath::Disabled => None,\n-    };\n-\n-    let pgo_use_path = config\n-        .pgo_use\n-        .as_ref()\n-        .map(|path_buf| CString::new(path_buf.to_string_lossy().as_bytes()).unwrap());\n+    let pgo_gen_path = get_pgo_gen_path(config);\n+    let pgo_use_path = get_pgo_use_path(config);\n \n     llvm::LLVMRustConfigurePassManagerBuilder(\n         builder,"}, {"sha": "ab6c55becdb0249acc3c03d8dd15228278cff994", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=f127aba96d1f0610f854e54a3386023c2331b1f3", "patch": "@@ -781,13 +781,18 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         align: Align,\n         flags: MemFlags,\n     ) {\n-        let ptr_width = &self.sess().target.target.target_pointer_width;\n-        let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n-        let llintrinsicfn = self.get_intrinsic(&intrinsic_key);\n+        let is_volatile = flags.contains(MemFlags::VOLATILE);\n         let ptr = self.pointercast(ptr, self.type_i8p());\n-        let align = self.const_u32(align.bytes() as u32);\n-        let volatile = self.const_bool(flags.contains(MemFlags::VOLATILE));\n-        self.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None);\n+        unsafe {\n+            llvm::LLVMRustBuildMemSet(\n+                self.llbuilder,\n+                ptr,\n+                align.bytes() as c_uint,\n+                fill_byte,\n+                size,\n+                is_volatile,\n+            );\n+        }\n     }\n \n     fn select(\n@@ -985,11 +990,11 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn lifetime_start(&mut self, ptr: &'ll Value, size: Size) {\n-        self.call_lifetime_intrinsic(\"llvm.lifetime.start\", ptr, size);\n+        self.call_lifetime_intrinsic(\"llvm.lifetime.start.p0i8\", ptr, size);\n     }\n \n     fn lifetime_end(&mut self, ptr: &'ll Value, size: Size) {\n-        self.call_lifetime_intrinsic(\"llvm.lifetime.end\", ptr, size);\n+        self.call_lifetime_intrinsic(\"llvm.lifetime.end.p0i8\", ptr, size);\n     }\n \n     fn call("}, {"sha": "46f461b98c8de0ee7207a78769002305c64978da", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=f127aba96d1f0610f854e54a3386023c2331b1f3", "patch": "@@ -562,10 +562,6 @@ impl CodegenCx<'b, 'tcx> {\n             t_v8f64: t_f64, 8;\n         }\n \n-        ifn!(\"llvm.memset.p0i8.i16\", fn(i8p, t_i8, t_i16, t_i32, i1) -> void);\n-        ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n-        ifn!(\"llvm.memset.p0i8.i64\", fn(i8p, t_i8, t_i64, t_i32, i1) -> void);\n-\n         ifn!(\"llvm.trap\", fn() -> void);\n         ifn!(\"llvm.debugtrap\", fn() -> void);\n         ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);\n@@ -830,8 +826,8 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.usub.sat.i64\", fn(t_i64, t_i64) -> t_i64);\n         ifn!(\"llvm.usub.sat.i128\", fn(t_i128, t_i128) -> t_i128);\n \n-        ifn!(\"llvm.lifetime.start\", fn(t_i64, i8p) -> void);\n-        ifn!(\"llvm.lifetime.end\", fn(t_i64, i8p) -> void);\n+        ifn!(\"llvm.lifetime.start.p0i8\", fn(t_i64, i8p) -> void);\n+        ifn!(\"llvm.lifetime.end.p0i8\", fn(t_i64, i8p) -> void);\n \n         ifn!(\"llvm.expect.i1\", fn(i1, i1) -> i1);\n         ifn!(\"llvm.eh.typeid.for\", fn(i8p) -> t_i32);"}, {"sha": "f12bfe0e80ace578c220bfcfb9cad59258291b41", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=f127aba96d1f0610f854e54a3386023c2331b1f3", "patch": "@@ -402,6 +402,38 @@ pub enum CodeGenOptLevel {\n     Aggressive,\n }\n \n+/// LLVMRustPassBuilderOptLevel\n+#[repr(C)]\n+pub enum PassBuilderOptLevel {\n+    O0,\n+    O1,\n+    O2,\n+    O3,\n+    Os,\n+    Oz,\n+}\n+\n+/// LLVMRustOptStage\n+#[derive(PartialEq)]\n+#[repr(C)]\n+pub enum OptStage {\n+    PreLinkNoLTO,\n+    PreLinkThinLTO,\n+    PreLinkFatLTO,\n+    ThinLTO,\n+    FatLTO,\n+}\n+\n+/// LLVMRustSanitizerOptions\n+#[repr(C)]\n+pub struct SanitizerOptions {\n+    pub sanitize_memory: bool,\n+    pub sanitize_thread: bool,\n+    pub sanitize_address: bool,\n+    pub sanitize_recover: bool,\n+    pub sanitize_memory_track_origins: c_int,\n+}\n+\n /// LLVMRelocMode\n #[derive(Copy, Clone, PartialEq)]\n #[repr(C)]\n@@ -1316,6 +1348,14 @@ extern \"C\" {\n         Size: &'a Value,\n         IsVolatile: bool,\n     ) -> &'a Value;\n+    pub fn LLVMRustBuildMemSet(\n+        B: &Builder<'a>,\n+        Dst: &'a Value,\n+        DstAlign: c_uint,\n+        Val: &'a Value,\n+        Size: &'a Value,\n+        IsVolatile: bool,\n+    ) -> &'a Value;\n     pub fn LLVMBuildSelect(\n         B: &Builder<'a>,\n         If: &'a Value,\n@@ -1889,6 +1929,23 @@ extern \"C\" {\n         Output: *const c_char,\n         FileType: FileType,\n     ) -> LLVMRustResult;\n+    pub fn LLVMRustOptimizeWithNewPassManager(\n+        M: &'a Module,\n+        TM: &'a TargetMachine,\n+        OptLevel: PassBuilderOptLevel,\n+        OptStage: OptStage,\n+        NoPrepopulatePasses: bool,\n+        VerifyIR: bool,\n+        UseThinLTOBuffers: bool,\n+        MergeFunctions: bool,\n+        UnrollLoops: bool,\n+        SLPVectorize: bool,\n+        LoopVectorize: bool,\n+        DisableSimplifyLibCalls: bool,\n+        SanitizerOptions: Option<&SanitizerOptions>,\n+        PGOGenPath: *const c_char,\n+        PGOUsePath: *const c_char,\n+    );\n     pub fn LLVMRustPrintModule(\n         M: &'a Module,\n         Output: *const c_char,"}, {"sha": "92f795acc543805912c670656eb2e9239289190d", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=f127aba96d1f0610f854e54a3386023c2331b1f3", "patch": "@@ -88,6 +88,7 @@ pub struct ModuleConfig {\n     pub vectorize_slp: bool,\n     pub merge_functions: bool,\n     pub inline_threshold: Option<usize>,\n+    pub new_llvm_pass_manager: Option<bool>,\n     // Instead of creating an object file by doing LLVM codegen, just\n     // make the object file bitcode. Provides easy compatibility with\n     // emscripten's ecc compiler, when used as the linker.\n@@ -132,6 +133,7 @@ impl ModuleConfig {\n             vectorize_slp: false,\n             merge_functions: false,\n             inline_threshold: None,\n+            new_llvm_pass_manager: None,\n         }\n     }\n \n@@ -140,6 +142,7 @@ impl ModuleConfig {\n         self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n         self.no_builtins = no_builtins || sess.target.target.options.no_builtins;\n         self.inline_threshold = sess.opts.cg.inline_threshold;\n+        self.new_llvm_pass_manager = sess.opts.debugging_opts.new_llvm_pass_manager;\n         self.obj_is_bitcode =\n             sess.target.target.options.obj_is_bitcode || sess.opts.cg.linker_plugin_lto.enabled();\n         let embed_bitcode ="}, {"sha": "a794670d7b8fe58b4ba4a6e9b094f1df2d312146", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=f127aba96d1f0610f854e54a3386023c2331b1f3", "patch": "@@ -968,4 +968,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"compile without linking\"),\n     link_only: bool = (false, parse_bool, [TRACKED],\n         \"link the `.rlink` file generated by `-Z no-link`\"),\n+    new_llvm_pass_manager: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"use new LLVM pass manager\"),\n }"}, {"sha": "15e2251d763214789e515070d8b870bfddd78f5c", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 243, "deletions": 1, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=f127aba96d1f0610f854e54a3386023c2331b1f3", "patch": "@@ -12,6 +12,11 @@\n #include \"llvm/IR/AutoUpgrade.h\"\n #include \"llvm/IR/AssemblyAnnotationWriter.h\"\n #include \"llvm/IR/IntrinsicInst.h\"\n+#include \"llvm/IR/Verifier.h\"\n+#include \"llvm/Passes/PassBuilder.h\"\n+#if LLVM_VERSION_GE(9, 0)\n+#include \"llvm/Passes/StandardInstrumentations.h\"\n+#endif\n #include \"llvm/Support/CBindingWrapping.h\"\n #include \"llvm/Support/FileSystem.h\"\n #include \"llvm/Support/Host.h\"\n@@ -32,9 +37,12 @@\n #include \"llvm/Transforms/Instrumentation/ThreadSanitizer.h\"\n #include \"llvm/Transforms/Instrumentation/MemorySanitizer.h\"\n #endif\n+#if LLVM_VERSION_GE(9, 0)\n+#include \"llvm/Transforms/Utils/CanonicalizeAliases.h\"\n+#endif\n+#include \"llvm/Transforms/Utils/NameAnonGlobals.h\"\n \n using namespace llvm;\n-using namespace llvm::legacy;\n \n typedef struct LLVMOpaquePass *LLVMPassRef;\n typedef struct LLVMOpaqueTargetMachine *LLVMTargetMachineRef;\n@@ -314,6 +322,34 @@ static CodeGenOpt::Level fromRust(LLVMRustCodeGenOptLevel Level) {\n   }\n }\n \n+enum class LLVMRustPassBuilderOptLevel {\n+  O0,\n+  O1,\n+  O2,\n+  O3,\n+  Os,\n+  Oz,\n+};\n+\n+static PassBuilder::OptimizationLevel fromRust(LLVMRustPassBuilderOptLevel Level) {\n+  switch (Level) {\n+  case LLVMRustPassBuilderOptLevel::O0:\n+    return PassBuilder::O0;\n+  case LLVMRustPassBuilderOptLevel::O1:\n+    return PassBuilder::O1;\n+  case LLVMRustPassBuilderOptLevel::O2:\n+    return PassBuilder::O2;\n+  case LLVMRustPassBuilderOptLevel::O3:\n+    return PassBuilder::O3;\n+  case LLVMRustPassBuilderOptLevel::Os:\n+    return PassBuilder::Os;\n+  case LLVMRustPassBuilderOptLevel::Oz:\n+    return PassBuilder::Oz;\n+  default:\n+    report_fatal_error(\"Bad PassBuilderOptLevel.\");\n+  }\n+}\n+\n enum class LLVMRustRelocMode {\n   Default,\n   Static,\n@@ -604,6 +640,212 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,\n   return LLVMRustResult::Success;\n }\n \n+enum class LLVMRustOptStage {\n+  PreLinkNoLTO,\n+  PreLinkThinLTO,\n+  PreLinkFatLTO,\n+  ThinLTO,\n+  FatLTO,\n+};\n+\n+struct LLVMRustSanitizerOptions {\n+  bool SanitizeMemory;\n+  bool SanitizeThread;\n+  bool SanitizeAddress;\n+  bool SanitizeRecover;\n+  int SanitizeMemoryTrackOrigins;\n+};\n+\n+extern \"C\" void\n+LLVMRustOptimizeWithNewPassManager(\n+    LLVMModuleRef ModuleRef,\n+    LLVMTargetMachineRef TMRef,\n+    LLVMRustPassBuilderOptLevel OptLevelRust,\n+    LLVMRustOptStage OptStage,\n+    bool NoPrepopulatePasses, bool VerifyIR, bool UseThinLTOBuffers,\n+    bool MergeFunctions, bool UnrollLoops, bool SLPVectorize, bool LoopVectorize,\n+    bool DisableSimplifyLibCalls,\n+    LLVMRustSanitizerOptions *SanitizerOptions,\n+    const char *PGOGenPath, const char *PGOUsePath) {\n+#if LLVM_VERSION_GE(9, 0)\n+  Module *TheModule = unwrap(ModuleRef);\n+  TargetMachine *TM = unwrap(TMRef);\n+  PassBuilder::OptimizationLevel OptLevel = fromRust(OptLevelRust);\n+\n+  // FIXME: MergeFunctions is not supported by NewPM yet.\n+  (void) MergeFunctions;\n+\n+  PipelineTuningOptions PTO;\n+  PTO.LoopUnrolling = UnrollLoops;\n+  PTO.LoopInterleaving = UnrollLoops;\n+  PTO.LoopVectorization = LoopVectorize;\n+  PTO.SLPVectorization = SLPVectorize;\n+\n+  PassInstrumentationCallbacks PIC;\n+  StandardInstrumentations SI;\n+  SI.registerCallbacks(PIC);\n+\n+  Optional<PGOOptions> PGOOpt;\n+  if (PGOGenPath) {\n+    assert(!PGOUsePath);\n+    PGOOpt = PGOOptions(PGOGenPath, \"\", \"\", PGOOptions::IRInstr);\n+  } else if (PGOUsePath) {\n+    assert(!PGOGenPath);\n+    PGOOpt = PGOOptions(PGOUsePath, \"\", \"\", PGOOptions::IRUse);\n+  }\n+\n+  PassBuilder PB(TM, PTO, PGOOpt, &PIC);\n+\n+  // FIXME: We may want to expose this as an option.\n+  bool DebugPassManager = false;\n+  LoopAnalysisManager LAM(DebugPassManager);\n+  FunctionAnalysisManager FAM(DebugPassManager);\n+  CGSCCAnalysisManager CGAM(DebugPassManager);\n+  ModuleAnalysisManager MAM(DebugPassManager);\n+\n+  FAM.registerPass([&] { return PB.buildDefaultAAPipeline(); });\n+\n+  Triple TargetTriple(TheModule->getTargetTriple());\n+  std::unique_ptr<TargetLibraryInfoImpl> TLII(new TargetLibraryInfoImpl(TargetTriple));\n+  if (DisableSimplifyLibCalls)\n+    TLII->disableAllFunctions();\n+  FAM.registerPass([&] { return TargetLibraryAnalysis(*TLII); });\n+\n+  PB.registerModuleAnalyses(MAM);\n+  PB.registerCGSCCAnalyses(CGAM);\n+  PB.registerFunctionAnalyses(FAM);\n+  PB.registerLoopAnalyses(LAM);\n+  PB.crossRegisterProxies(LAM, FAM, CGAM, MAM);\n+\n+  // We manually collect pipeline callbacks so we can apply them at O0, where the\n+  // PassBuilder does not create a pipeline.\n+  std::vector<std::function<void(ModulePassManager &)>> PipelineStartEPCallbacks;\n+  std::vector<std::function<void(FunctionPassManager &, PassBuilder::OptimizationLevel)>>\n+      OptimizerLastEPCallbacks;\n+\n+  if (VerifyIR) {\n+    PipelineStartEPCallbacks.push_back([VerifyIR](ModulePassManager &MPM) {\n+        MPM.addPass(VerifierPass());\n+    });\n+  }\n+\n+  if (SanitizerOptions) {\n+    if (SanitizerOptions->SanitizeMemory) {\n+      MemorySanitizerOptions Options(\n+          SanitizerOptions->SanitizeMemoryTrackOrigins,\n+          SanitizerOptions->SanitizeRecover,\n+          /*CompileKernel=*/false);\n+#if LLVM_VERSION_GE(10, 0)\n+      PipelineStartEPCallbacks.push_back([Options](ModulePassManager &MPM) {\n+        MPM.addPass(MemorySanitizerPass(Options));\n+      });\n+#endif\n+      OptimizerLastEPCallbacks.push_back(\n+        [Options](FunctionPassManager &FPM, PassBuilder::OptimizationLevel Level) {\n+          FPM.addPass(MemorySanitizerPass(Options));\n+        }\n+      );\n+    }\n+\n+    if (SanitizerOptions->SanitizeThread) {\n+#if LLVM_VERSION_GE(10, 0)\n+      PipelineStartEPCallbacks.push_back([](ModulePassManager &MPM) {\n+        MPM.addPass(ThreadSanitizerPass());\n+      });\n+#endif\n+      OptimizerLastEPCallbacks.push_back(\n+        [](FunctionPassManager &FPM, PassBuilder::OptimizationLevel Level) {\n+          FPM.addPass(ThreadSanitizerPass());\n+        }\n+      );\n+    }\n+\n+    if (SanitizerOptions->SanitizeAddress) {\n+      // FIXME: Rust does not expose the UseAfterScope option.\n+      PipelineStartEPCallbacks.push_back([&](ModulePassManager &MPM) {\n+        MPM.addPass(RequireAnalysisPass<ASanGlobalsMetadataAnalysis, Module>());\n+      });\n+      OptimizerLastEPCallbacks.push_back(\n+        [SanitizerOptions](FunctionPassManager &FPM, PassBuilder::OptimizationLevel Level) {\n+          FPM.addPass(AddressSanitizerPass(\n+              /*CompileKernel=*/false, SanitizerOptions->SanitizeRecover));\n+        }\n+      );\n+      PipelineStartEPCallbacks.push_back(\n+        [SanitizerOptions](ModulePassManager &MPM) {\n+          MPM.addPass(ModuleAddressSanitizerPass(\n+              /*CompileKernel=*/false, SanitizerOptions->SanitizeRecover));\n+        }\n+      );\n+    }\n+  }\n+\n+  ModulePassManager MPM(DebugPassManager);\n+  if (!NoPrepopulatePasses) {\n+    if (OptLevel == PassBuilder::O0) {\n+      for (const auto &C : PipelineStartEPCallbacks)\n+        C(MPM);\n+\n+      if (!OptimizerLastEPCallbacks.empty()) {\n+        FunctionPassManager FPM(DebugPassManager);\n+        for (const auto &C : OptimizerLastEPCallbacks)\n+          C(FPM, OptLevel);\n+        MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n+      }\n+\n+      MPM.addPass(AlwaysInlinerPass(/*InsertLifetimeIntrinsics=*/false));\n+\n+#if LLVM_VERSION_GE(10, 0)\n+      if (PGOOpt) {\n+        PB.addPGOInstrPassesForO0(\n+            MPM, DebugPassManager, PGOOpt->Action == PGOOptions::IRInstr,\n+            /*IsCS=*/false, PGOOpt->ProfileFile, PGOOpt->ProfileRemappingFile);\n+      }\n+#endif\n+    } else {\n+      for (const auto &C : PipelineStartEPCallbacks)\n+        PB.registerPipelineStartEPCallback(C);\n+      for (const auto &C : OptimizerLastEPCallbacks)\n+        PB.registerOptimizerLastEPCallback(C);\n+\n+      switch (OptStage) {\n+      case LLVMRustOptStage::PreLinkNoLTO:\n+        MPM = PB.buildPerModuleDefaultPipeline(OptLevel, DebugPassManager);\n+        break;\n+      case LLVMRustOptStage::PreLinkThinLTO:\n+        MPM = PB.buildThinLTOPreLinkDefaultPipeline(OptLevel, DebugPassManager);\n+        break;\n+      case LLVMRustOptStage::PreLinkFatLTO:\n+        MPM = PB.buildLTOPreLinkDefaultPipeline(OptLevel, DebugPassManager);\n+        break;\n+      case LLVMRustOptStage::ThinLTO:\n+        // FIXME: Does it make sense to pass the ModuleSummaryIndex?\n+        // It only seems to be needed for C++ specific optimizations.\n+        MPM = PB.buildThinLTODefaultPipeline(OptLevel, DebugPassManager, nullptr);\n+        break;\n+      case LLVMRustOptStage::FatLTO:\n+        MPM = PB.buildLTODefaultPipeline(OptLevel, DebugPassManager, nullptr);\n+        break;\n+      }\n+    }\n+  }\n+\n+  if (UseThinLTOBuffers) {\n+    MPM.addPass(CanonicalizeAliasesPass());\n+    MPM.addPass(NameAnonGlobalPass());\n+  }\n+\n+  // Upgrade all calls to old intrinsics first.\n+  for (Module::iterator I = TheModule->begin(), E = TheModule->end(); I != E;)\n+    UpgradeCallsToIntrinsic(&*I++); // must be post-increment, as we remove\n+\n+  MPM.run(*TheModule, MAM);\n+#else\n+  // The new pass manager has been available for a long time,\n+  // but we don't bother supporting it on old LLVM versions.\n+  report_fatal_error(\"New pass manager only supported since LLVM 9\");\n+#endif\n+}\n \n // Callback to demangle function name\n // Parameters:"}, {"sha": "49b6e1bfec38d1aa86144af2b3da3a89a777d67f", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=f127aba96d1f0610f854e54a3386023c2331b1f3", "patch": "@@ -1296,6 +1296,14 @@ extern \"C\" LLVMValueRef LLVMRustBuildMemMove(LLVMBuilderRef B,\n #endif\n }\n \n+extern \"C\" LLVMValueRef LLVMRustBuildMemSet(LLVMBuilderRef B,\n+                                            LLVMValueRef Dst, unsigned DstAlign,\n+                                            LLVMValueRef Val,\n+                                            LLVMValueRef Size, bool IsVolatile) {\n+  return wrap(unwrap(B)->CreateMemSet(\n+      unwrap(Dst), unwrap(Val), unwrap(Size), DstAlign, IsVolatile));\n+}\n+\n extern \"C\" LLVMValueRef\n LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMValueRef Fn, LLVMValueRef *Args,\n                     unsigned NumArgs, LLVMBasicBlockRef Then,"}, {"sha": "8ea41c5d44bb1fe410807d3324a003fc8504d2ca", "filename": "src/test/codegen/sanitizer-memory-track-orgins.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f127aba96d1f0610f854e54a3386023c2331b1f3/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs?ref=f127aba96d1f0610f854e54a3386023c2331b1f3", "patch": "@@ -15,10 +15,10 @@\n #![crate_type=\"lib\"]\n \n // MSAN-0-NOT: @__msan_track_origins\n-// MSAN-1:     @__msan_track_origins = weak_odr local_unnamed_addr constant i32 1\n-// MSAN-2:     @__msan_track_origins = weak_odr local_unnamed_addr constant i32 2\n-// MSAN-1-LTO: @__msan_track_origins = weak_odr local_unnamed_addr constant i32 1\n-// MSAN-2-LTO: @__msan_track_origins = weak_odr local_unnamed_addr constant i32 2\n+// MSAN-1:     @__msan_track_origins = weak_odr {{.*}}constant i32 1\n+// MSAN-2:     @__msan_track_origins = weak_odr {{.*}}constant i32 2\n+// MSAN-1-LTO: @__msan_track_origins = weak_odr {{.*}}constant i32 1\n+// MSAN-2-LTO: @__msan_track_origins = weak_odr {{.*}}constant i32 2\n //\n // MSAN-0-LABEL: define void @copy(\n // MSAN-1-LABEL: define void @copy("}]}