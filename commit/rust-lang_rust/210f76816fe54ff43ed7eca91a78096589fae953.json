{"sha": "210f76816fe54ff43ed7eca91a78096589fae953", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMGY3NjgxNmZlNTRmZjQzZWQ3ZWNhOTFhNzgwOTY1ODlmYWU5NTM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-03T23:00:46Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-05T22:34:01Z"}, "message": "handle gen/kill sets together", "tree": {"sha": "dbb46f4908d7fa7f46f958fa6e32fd9edca519e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbb46f4908d7fa7f46f958fa6e32fd9edca519e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/210f76816fe54ff43ed7eca91a78096589fae953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/210f76816fe54ff43ed7eca91a78096589fae953", "html_url": "https://github.com/rust-lang/rust/commit/210f76816fe54ff43ed7eca91a78096589fae953", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/210f76816fe54ff43ed7eca91a78096589fae953/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "243c5a5faaed0c34f0f236c1f168e10b4cc97d25", "url": "https://api.github.com/repos/rust-lang/rust/commits/243c5a5faaed0c34f0f236c1f168e10b4cc97d25", "html_url": "https://github.com/rust-lang/rust/commit/243c5a5faaed0c34f0f236c1f168e10b4cc97d25"}], "stats": {"total": 102, "additions": 51, "deletions": 51}, "files": [{"sha": "e7a25c212c36773706410c79fdf5fd03f3ac7256", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 16, "deletions": 50, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/210f76816fe54ff43ed7eca91a78096589fae953/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210f76816fe54ff43ed7eca91a78096589fae953/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=210f76816fe54ff43ed7eca91a78096589fae953", "patch": "@@ -14,7 +14,6 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::{self, Mir, Location};\n-use rustc_data_structures::bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -504,7 +503,6 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n         let stmt = &mir[location.block].statements[location.statement_index];\n         let loc_map = &move_data.loc_map;\n         let path_map = &move_data.path_map;\n-        let bits_per_block = self.bits_per_block();\n \n         match stmt.kind {\n             // this analysis only tries to find moves explicitly\n@@ -515,21 +513,15 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n             _ => {\n                 debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n                        stmt, location, &loc_map[location]);\n-                for move_index in &loc_map[location] {\n-                    // Every path deinitialized by a *particular move*\n-                    // has corresponding bit, \"gen'ed\" (i.e. set)\n-                    // here, in dataflow vector\n-                    zero_to_one(sets.gen_set.words_mut(), *move_index);\n-                }\n+                // Every path deinitialized by a *particular move*\n+                // has corresponding bit, \"gen'ed\" (i.e. set)\n+                // here, in dataflow vector\n+                sets.gen_all_and_assert_dead(&loc_map[location]);\n             }\n         }\n \n         for_location_inits(tcx, mir, move_data, location,\n-            |mpi| for moi in &path_map[mpi] {\n-                assert!(moi.index() < bits_per_block);\n-                sets.kill_set.add(&moi);\n-            }\n-        );\n+                           |mpi| sets.kill_all(&path_map[mpi]));\n     }\n \n     fn terminator_effect(&self,\n@@ -543,18 +535,10 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n \n         debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n                term, location, &loc_map[location]);\n-        let bits_per_block = self.bits_per_block();\n-        for move_index in &loc_map[location] {\n-            assert!(move_index.index() < bits_per_block);\n-            zero_to_one(sets.gen_set.words_mut(), *move_index);\n-        }\n+        sets.gen_all_and_assert_dead(&loc_map[location]);\n \n         for_location_inits(tcx, mir, move_data, location,\n-            |mpi| for moi in &path_map[mpi] {\n-                assert!(moi.index() < bits_per_block);\n-                sets.kill_set.add(&moi);\n-            }\n-        );\n+                           |mpi| sets.kill_all(&path_map[mpi]));\n     }\n \n     fn propagate_call_return(&self,\n@@ -585,11 +569,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n     }\n \n     fn start_block_effect(&self, sets: &mut BlockSets<InitIndex>) {\n-        let bits_per_block = self.bits_per_block();\n-        for init_index in (0..self.mir.arg_count).map(InitIndex::new) {\n-            assert!(init_index.index() < bits_per_block);\n-            sets.gen_set.add(&init_index);\n-        }\n+        sets.gen_all((0..self.mir.arg_count).map(InitIndex::new));\n     }\n     fn statement_effect(&self,\n                         sets: &mut BlockSets<InitIndex>,\n@@ -599,26 +579,19 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n         let init_path_map = &move_data.init_path_map;\n         let init_loc_map = &move_data.init_loc_map;\n         let rev_lookup = &move_data.rev_lookup;\n-        let bits_per_block = self.bits_per_block();\n \n         debug!(\"statement {:?} at loc {:?} initializes move_indexes {:?}\",\n                stmt, location, &init_loc_map[location]);\n-        for init_index in &init_loc_map[location] {\n-            assert!(init_index.index() < bits_per_block);\n-            sets.gen_set.add(init_index);\n-        }\n+        sets.gen_all(&init_loc_map[location]);\n \n         match stmt.kind {\n             mir::StatementKind::StorageDead(local) => {\n                 // End inits for StorageDead, so that an immutable variable can\n                 // be reinitialized on the next iteration of the loop.\n                 if let LookupResult::Exact(mpi) = rev_lookup.find(&mir::Place::Local(local)) {\n                     debug!(\"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n-                        stmt, location, &init_path_map[mpi]);\n-                    for ii in &init_path_map[mpi] {\n-                        assert!(ii.index() < bits_per_block);\n-                        sets.kill_set.add(&ii);\n-                    }\n+                           stmt, location, &init_path_map[mpi]);\n+                    sets.kill_all(&init_path_map[mpi]);\n                 }\n             }\n             _ => {}\n@@ -634,13 +607,11 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n         let init_loc_map = &move_data.init_loc_map;\n         debug!(\"terminator {:?} at loc {:?} initializes move_indexes {:?}\",\n                term, location, &init_loc_map[location]);\n-        let bits_per_block = self.bits_per_block();\n-        for init_index in &init_loc_map[location] {\n-            if move_data.inits[*init_index].kind != InitKind::NonPanicPathOnly {\n-                assert!(init_index.index() < bits_per_block);\n-                sets.gen_set.add(init_index);\n-            }\n-        }\n+        sets.gen_all(\n+            init_loc_map[location].iter().filter(|init_index| {\n+                move_data.inits[**init_index].kind != InitKind::NonPanicPathOnly\n+            })\n+        );\n     }\n \n     fn propagate_call_return(&self,\n@@ -663,11 +634,6 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n-    let retval = bitvec.set_bit(move_index.index());\n-    assert!(retval);\n-}\n-\n impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {"}, {"sha": "12722979706fc6921eed8c696b738f71e5ffc30c", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/210f76816fe54ff43ed7eca91a78096589fae953/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210f76816fe54ff43ed7eca91a78096589fae953/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=210f76816fe54ff43ed7eca91a78096589fae953", "patch": "@@ -18,6 +18,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::mir::{self, Mir, BasicBlock, BasicBlockData, Location, Statement, Terminator};\n use rustc::session::Session;\n \n+use std::borrow::Borrow;\n use std::fmt::{self, Debug};\n use std::io;\n use std::mem;\n@@ -492,10 +493,39 @@ impl<'a, E:Idx> BlockSets<'a, E> {\n         self.gen_set.add(e);\n         self.kill_set.remove(e);\n     }\n+    fn gen_all<I>(&mut self, i: I)\n+        where I: IntoIterator,\n+              I::Item: Borrow<E>\n+    {\n+        for j in i {\n+            self.gen(j.borrow());\n+        }\n+    }\n+\n+    fn gen_all_and_assert_dead<I>(&mut self, i: I)\n+        where I: IntoIterator,\n+        I::Item: Borrow<E>\n+    {\n+        for j in i {\n+            let j = j.borrow();\n+            let retval = self.gen_set.add(j);\n+            self.kill_set.remove(j);\n+            assert!(retval);\n+        }\n+    }\n+\n     fn kill(&mut self, e: &E) {\n         self.gen_set.remove(e);\n         self.kill_set.add(e);\n     }\n+    fn kill_all<I>(&mut self, i: I)\n+        where I: IntoIterator,\n+              I::Item: Borrow<E>\n+    {\n+        for j in i {\n+            self.kill(j.borrow());\n+        }\n+    }\n }\n \n impl<E:Idx> AllSets<E> {"}, {"sha": "2bd6f75df1b1ff138befe6bf9a9a9cbff91617f7", "filename": "src/test/compile-fail/borrowck/borrowck-move-moved-value-into-closure.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/210f76816fe54ff43ed7eca91a78096589fae953/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-moved-value-into-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210f76816fe54ff43ed7eca91a78096589fae953/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-moved-value-into-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-moved-value-into-closure.rs?ref=210f76816fe54ff43ed7eca91a78096589fae953", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n #![feature(box_syntax)]\n \n fn call_f<F:FnOnce() -> isize>(f: F) -> isize {\n@@ -18,5 +21,6 @@ fn main() {\n     let t: Box<_> = box 3;\n \n     call_f(move|| { *t + 1 });\n-    call_f(move|| { *t + 1 }); //~ ERROR capture of moved value\n+    call_f(move|| { *t + 1 }); //[ast]~ ERROR capture of moved value\n+    //[mir]~^ ERROR use of moved value\n }"}]}