{"sha": "c4471b0b9c9b3762c8030c44835b614f90deaf75", "node_id": "C_kwDOAAsO6NoAKGM0NDcxYjBiOWM5YjM3NjJjODAzMGM0NDgzNWI2MTRmOTBkZWFmNzU", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-12-24T06:34:30Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-01-09T14:02:17Z"}, "message": "rustc_metadata: Stop passing `CrateMetadataRef` by reference\n\nIt's already a (fat) reference.\nDouble referencing it creates lifetime issues for its methods that want to return iterators.", "tree": {"sha": "e31f4b8cef03d169d873faae4afa76300f769f28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e31f4b8cef03d169d873faae4afa76300f769f28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4471b0b9c9b3762c8030c44835b614f90deaf75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4471b0b9c9b3762c8030c44835b614f90deaf75", "html_url": "https://github.com/rust-lang/rust/commit/c4471b0b9c9b3762c8030c44835b614f90deaf75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4471b0b9c9b3762c8030c44835b614f90deaf75/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e19ca1d946269f7b7eb13171531caf2e16f42076", "url": "https://api.github.com/repos/rust-lang/rust/commits/e19ca1d946269f7b7eb13171531caf2e16f42076", "html_url": "https://github.com/rust-lang/rust/commit/e19ca1d946269f7b7eb13171531caf2e16f42076"}], "stats": {"total": 196, "additions": 98, "deletions": 98}, "files": [{"sha": "493c815ff011561075d3c6a8a1bc88a6877c14bd", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 98, "deletions": 98, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/c4471b0b9c9b3762c8030c44835b614f90deaf75/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4471b0b9c9b3762c8030c44835b614f90deaf75/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=c4471b0b9c9b3762c8030c44835b614f90deaf75", "patch": "@@ -218,40 +218,40 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a MetadataBlob, &'tcx Session) {\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadataRef<'a> {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for CrateMetadataRef<'a> {\n     #[inline]\n     fn blob(self) -> &'a MetadataBlob {\n-        &self.blob\n+        &self.cdata.blob\n     }\n     #[inline]\n     fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n-        Some(*self)\n+        Some(self)\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, &'tcx Session) {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (CrateMetadataRef<'a>, &'tcx Session) {\n     #[inline]\n     fn blob(self) -> &'a MetadataBlob {\n-        &self.0.blob\n+        &self.0.cdata.blob\n     }\n     #[inline]\n     fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n-        Some(*self.0)\n+        Some(self.0)\n     }\n     #[inline]\n     fn sess(self) -> Option<&'tcx Session> {\n-        Some(&self.1)\n+        Some(self.1)\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, TyCtxt<'tcx>) {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (CrateMetadataRef<'a>, TyCtxt<'tcx>) {\n     #[inline]\n     fn blob(self) -> &'a MetadataBlob {\n-        &self.0.blob\n+        &self.0.cdata.blob\n     }\n     #[inline]\n     fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n-        Some(*self.0)\n+        Some(self.0)\n     }\n     #[inline]\n     fn tcx(self) -> Option<TyCtxt<'tcx>> {\n@@ -414,9 +414,9 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for SyntaxContext {\n             Ok(cdata\n                 .root\n                 .syntax_contexts\n-                .get(&cdata, id)\n+                .get(cdata, id)\n                 .unwrap_or_else(|| panic!(\"Missing SyntaxContext {:?} for crate {:?}\", id, cname))\n-                .decode((&cdata, sess)))\n+                .decode((cdata, sess)))\n         })\n     }\n }\n@@ -442,15 +442,15 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n             let expn_data = crate_data\n                 .root\n                 .expn_data\n-                .get(&crate_data, index)\n+                .get(crate_data, index)\n                 .unwrap()\n-                .decode((&crate_data, sess));\n+                .decode((crate_data, sess));\n             let expn_hash = crate_data\n                 .root\n                 .expn_hashes\n-                .get(&crate_data, index)\n+                .get(crate_data, index)\n                 .unwrap()\n-                .decode((&crate_data, sess));\n+                .decode((crate_data, sess));\n             (expn_data, expn_hash)\n         });\n         Ok(expn_id)\n@@ -706,7 +706,7 @@ impl CrateRoot<'_> {\n }\n \n impl<'a, 'tcx> CrateMetadataRef<'a> {\n-    fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n+    fn raw_proc_macro(self, id: DefIndex) -> &'a ProcMacro {\n         // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n         // with items in 'raw_proc_macros'.\n         let pos = self\n@@ -721,7 +721,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n-    fn opt_item_ident(&self, item_index: DefIndex, sess: &Session) -> Option<Ident> {\n+    fn opt_item_ident(self, item_index: DefIndex, sess: &Session) -> Option<Ident> {\n         let name = self.def_key(item_index).disambiguated_data.data.get_opt_name()?;\n         let span = match self.root.tables.ident_span.get(self, item_index) {\n             Some(lazy_span) => lazy_span.decode((self, sess)),\n@@ -737,15 +737,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         Some(Ident::new(name, span))\n     }\n \n-    fn item_ident(&self, item_index: DefIndex, sess: &Session) -> Ident {\n+    fn item_ident(self, item_index: DefIndex, sess: &Session) -> Ident {\n         self.opt_item_ident(item_index, sess).expect(\"no encoded ident for item\")\n     }\n \n-    fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind> {\n+    fn maybe_kind(self, item_id: DefIndex) -> Option<EntryKind> {\n         self.root.tables.kind.get(self, item_id).map(|k| k.decode(self))\n     }\n \n-    fn kind(&self, item_id: DefIndex) -> EntryKind {\n+    fn kind(self, item_id: DefIndex) -> EntryKind {\n         self.maybe_kind(item_id).unwrap_or_else(|| {\n             bug!(\n                 \"CrateMetadata::kind({:?}): id not found, in crate {:?} with number {}\",\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         })\n     }\n \n-    fn def_kind(&self, item_id: DefIndex) -> DefKind {\n+    fn def_kind(self, item_id: DefIndex) -> DefKind {\n         self.root.tables.def_kind.get(self, item_id).map(|k| k.decode(self)).unwrap_or_else(|| {\n             bug!(\n                 \"CrateMetadata::def_kind({:?}): id not found, in crate {:?} with number {}\",\n@@ -767,7 +767,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         })\n     }\n \n-    fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n+    fn get_span(self, index: DefIndex, sess: &Session) -> Span {\n         self.root\n             .tables\n             .span\n@@ -776,7 +776,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, sess))\n     }\n \n-    fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n+    fn load_proc_macro(self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n         let (name, kind, helper_attrs) = match *self.raw_proc_macro(id) {\n             ProcMacro::CustomDerive { trait_name, attributes, client } => {\n                 let helper_attrs =\n@@ -807,7 +807,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n-    fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n+    fn get_trait_def(self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n         match self.kind(item_id) {\n             EntryKind::Trait(data) => {\n                 let data = data.decode((self, sess));\n@@ -837,7 +837,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_variant(\n-        &self,\n+        self,\n         kind: &EntryKind,\n         index: DefIndex,\n         parent_did: DefId,\n@@ -886,7 +886,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n-    fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n+    fn get_adt_def(self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n         let kind = self.kind(item_id);\n         let did = self.local_def_id(item_id);\n \n@@ -914,15 +914,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_explicit_predicates(\n-        &self,\n+        self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.root.tables.explicit_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n     fn get_inferred_outlives(\n-        &self,\n+        self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n@@ -935,15 +935,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_super_predicates(\n-        &self,\n+        self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.root.tables.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n     fn get_explicit_item_bounds(\n-        &self,\n+        self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n@@ -955,11 +955,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .unwrap_or_default()\n     }\n \n-    fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n+    fn get_generics(self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n         self.root.tables.generics.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n-    fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+    fn get_type(self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         self.root\n             .tables\n             .ty\n@@ -968,78 +968,78 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, tcx))\n     }\n \n-    fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n+    fn get_stability(self, id: DefIndex) -> Option<attr::Stability> {\n         self.root.tables.stability.get(self, id).map(|stab| stab.decode(self))\n     }\n \n-    fn get_const_stability(&self, id: DefIndex) -> Option<attr::ConstStability> {\n+    fn get_const_stability(self, id: DefIndex) -> Option<attr::ConstStability> {\n         self.root.tables.const_stability.get(self, id).map(|stab| stab.decode(self))\n     }\n \n-    fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n+    fn get_deprecation(self, id: DefIndex) -> Option<attr::Deprecation> {\n         self.root.tables.deprecation.get(self, id).map(|depr| depr.decode(self))\n     }\n \n-    fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n+    fn get_visibility(self, id: DefIndex) -> ty::Visibility {\n         self.root.tables.visibility.get(self, id).unwrap().decode(self)\n     }\n \n-    fn get_impl_data(&self, id: DefIndex) -> ImplData {\n+    fn get_impl_data(self, id: DefIndex) -> ImplData {\n         match self.kind(id) {\n             EntryKind::Impl(data) => data.decode(self),\n             _ => bug!(),\n         }\n     }\n \n-    fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n+    fn get_parent_impl(self, id: DefIndex) -> Option<DefId> {\n         self.get_impl_data(id).parent_impl\n     }\n \n-    fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n+    fn get_impl_polarity(self, id: DefIndex) -> ty::ImplPolarity {\n         self.get_impl_data(id).polarity\n     }\n \n-    fn get_impl_defaultness(&self, id: DefIndex) -> hir::Defaultness {\n+    fn get_impl_defaultness(self, id: DefIndex) -> hir::Defaultness {\n         self.get_impl_data(id).defaultness\n     }\n \n-    fn get_impl_constness(&self, id: DefIndex) -> hir::Constness {\n+    fn get_impl_constness(self, id: DefIndex) -> hir::Constness {\n         self.get_impl_data(id).constness\n     }\n \n-    fn get_trait_item_def_id(&self, id: DefIndex) -> Option<DefId> {\n+    fn get_trait_item_def_id(self, id: DefIndex) -> Option<DefId> {\n         self.root.tables.trait_item_def_id.get(self, id).map(|d| d.decode(self))\n     }\n \n-    fn get_coerce_unsized_info(&self, id: DefIndex) -> Option<ty::adjustment::CoerceUnsizedInfo> {\n+    fn get_coerce_unsized_info(self, id: DefIndex) -> Option<ty::adjustment::CoerceUnsizedInfo> {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n \n-    fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n+    fn get_impl_trait(self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n         self.root.tables.impl_trait_ref.get(self, id).map(|tr| tr.decode((self, tcx)))\n     }\n \n-    fn get_expn_that_defined(&self, id: DefIndex, sess: &Session) -> ExpnId {\n+    fn get_expn_that_defined(self, id: DefIndex, sess: &Session) -> ExpnId {\n         self.root.tables.expn_that_defined.get(self, id).unwrap().decode((self, sess))\n     }\n \n     fn get_const_param_default(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n     ) -> rustc_middle::ty::Const<'tcx> {\n         self.root.tables.const_defaults.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n-    fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(Symbol, Option<Symbol>)] {\n+    fn get_lib_features(self, tcx: TyCtxt<'tcx>) -> &'tcx [(Symbol, Option<Symbol>)] {\n         // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n         // features or an empty Vec. Both don't cause ICEs.\n         tcx.arena.alloc_from_iter(self.root.lib_features.decode(self))\n     }\n \n     /// Iterates over the language items in the given crate.\n-    fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n+    fn get_lang_items(self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n         if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n@@ -1054,7 +1054,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     /// Iterates over the diagnostic items in the given crate.\n-    fn get_diagnostic_items(&self) -> DiagnosticItems {\n+    fn get_diagnostic_items(self) -> DiagnosticItems {\n         if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not export any diagnostic-items to the target.\n             Default::default()\n@@ -1079,7 +1079,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     /// Module here is understood in name resolution sense - it can be a `mod` item,\n     /// or a crate root, or an enum, or a trait.\n     fn for_each_module_child(\n-        &self,\n+        self,\n         id: DefIndex,\n         mut callback: impl FnMut(ModChild),\n         sess: &Session,\n@@ -1177,15 +1177,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn is_ctfe_mir_available(&self, id: DefIndex) -> bool {\n+    fn is_ctfe_mir_available(self, id: DefIndex) -> bool {\n         self.root.tables.mir_for_ctfe.get(self, id).is_some()\n     }\n \n-    fn is_item_mir_available(&self, id: DefIndex) -> bool {\n+    fn is_item_mir_available(self, id: DefIndex) -> bool {\n         self.root.tables.mir.get(self, id).is_some()\n     }\n \n-    fn module_expansion(&self, id: DefIndex, sess: &Session) -> ExpnId {\n+    fn module_expansion(self, id: DefIndex, sess: &Session) -> ExpnId {\n         match self.kind(id) {\n             EntryKind::Mod(_) | EntryKind::Enum(_) | EntryKind::Trait(_) => {\n                 self.get_expn_that_defined(id, sess)\n@@ -1194,7 +1194,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n+    fn get_optimized_mir(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n         self.root\n             .tables\n             .mir\n@@ -1205,7 +1205,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, tcx))\n     }\n \n-    fn get_mir_for_ctfe(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n+    fn get_mir_for_ctfe(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n         self.root\n             .tables\n             .mir_for_ctfe\n@@ -1217,7 +1217,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_thir_abstract_const(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n     ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n@@ -1228,7 +1228,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .map_or(Ok(None), |v| Ok(Some(v.decode((self, tcx)))))\n     }\n \n-    fn get_unused_generic_params(&self, id: DefIndex) -> FiniteBitSet<u32> {\n+    fn get_unused_generic_params(self, id: DefIndex) -> FiniteBitSet<u32> {\n         self.root\n             .tables\n             .unused_generic_params\n@@ -1237,7 +1237,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .unwrap_or_default()\n     }\n \n-    fn get_promoted_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> IndexVec<Promoted, Body<'tcx>> {\n+    fn get_promoted_mir(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> IndexVec<Promoted, Body<'tcx>> {\n         self.root\n             .tables\n             .promoted_mir\n@@ -1248,7 +1248,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, tcx))\n     }\n \n-    fn mir_const_qualif(&self, id: DefIndex) -> mir::ConstQualifs {\n+    fn mir_const_qualif(self, id: DefIndex) -> mir::ConstQualifs {\n         match self.kind(id) {\n             EntryKind::AnonConst(qualif, _)\n             | EntryKind::Const(qualif, _)\n@@ -1263,14 +1263,14 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_fn_has_self_parameter(&self, id: DefIndex) -> bool {\n+    fn get_fn_has_self_parameter(self, id: DefIndex) -> bool {\n         match self.kind(id) {\n             EntryKind::AssocFn(data) => data.decode(self).has_self,\n             _ => false,\n         }\n     }\n \n-    fn get_associated_item_def_ids(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [DefId] {\n+    fn get_associated_item_def_ids(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [DefId] {\n         if let Some(children) = self.root.tables.children.get(self, id) {\n             tcx.arena.alloc_from_iter(\n                 children.decode((self, tcx.sess)).map(|child_index| self.local_def_id(child_index)),\n@@ -1280,7 +1280,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_associated_item(&self, id: DefIndex, sess: &Session) -> ty::AssocItem {\n+    fn get_associated_item(self, id: DefIndex, sess: &Session) -> ty::AssocItem {\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n         let ident = self.item_ident(id, sess);\n@@ -1307,11 +1307,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_item_variances(&'a self, id: DefIndex) -> impl Iterator<Item = ty::Variance> + 'a {\n+    fn get_item_variances(self, id: DefIndex) -> impl Iterator<Item = ty::Variance> + 'a {\n         self.root.tables.variances.get(self, id).unwrap_or_else(Lazy::empty).decode(self)\n     }\n \n-    fn get_ctor_def_id_and_kind(&self, node_id: DefIndex) -> Option<(DefId, CtorKind)> {\n+    fn get_ctor_def_id_and_kind(self, node_id: DefIndex) -> Option<(DefId, CtorKind)> {\n         match self.kind(node_id) {\n             EntryKind::Struct(data, _) | EntryKind::Variant(data) => {\n                 let vdata = data.decode(self);\n@@ -1322,7 +1322,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_item_attrs(\n-        &'a self,\n+        self,\n         id: DefIndex,\n         sess: &'a Session,\n     ) -> impl Iterator<Item = ast::Attribute> + 'a {\n@@ -1346,7 +1346,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, sess))\n     }\n \n-    fn get_struct_field_names(&self, id: DefIndex, sess: &Session) -> Vec<Spanned<Symbol>> {\n+    fn get_struct_field_names(self, id: DefIndex, sess: &Session) -> Vec<Spanned<Symbol>> {\n         self.root\n             .tables\n             .children\n@@ -1357,7 +1357,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .collect()\n     }\n \n-    fn get_struct_field_visibilities(&self, id: DefIndex) -> Vec<Visibility> {\n+    fn get_struct_field_visibilities(self, id: DefIndex) -> Vec<Visibility> {\n         self.root\n             .tables\n             .children\n@@ -1369,7 +1369,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_inherent_implementations_for_type(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n     ) -> &'tcx [DefId] {\n@@ -1384,20 +1384,20 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n-    fn get_traits(&'a self) -> impl Iterator<Item = DefId> + 'a {\n-        self.root.traits.decode(self).map(|index| self.local_def_id(index))\n+    fn get_traits(self) -> impl Iterator<Item = DefId> + 'a {\n+        self.root.traits.decode(self).map(move |index| self.local_def_id(index))\n     }\n \n-    fn get_trait_impls(&'a self) -> impl Iterator<Item = (DefId, Option<SimplifiedType>)> + 'a {\n-        self.trait_impls.values().flat_map(move |impls| {\n+    fn get_trait_impls(self) -> impl Iterator<Item = (DefId, Option<SimplifiedType>)> + 'a {\n+        self.cdata.trait_impls.values().flat_map(move |impls| {\n             impls\n                 .decode(self)\n-                .map(|(idx, simplified_self_ty)| (self.local_def_id(idx), simplified_self_ty))\n+                .map(move |(idx, simplified_self_ty)| (self.local_def_id(idx), simplified_self_ty))\n         })\n     }\n \n     fn get_implementations_of_trait(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         trait_def_id: DefId,\n     ) -> &'tcx [(DefId, Option<SimplifiedType>)] {\n@@ -1424,7 +1424,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n+    fn get_trait_of_item(self, id: DefIndex) -> Option<DefId> {\n         let def_key = self.def_key(id);\n         match def_key.disambiguated_data.data {\n             DefPathData::TypeNs(..) | DefPathData::ValueNs(..) => (),\n@@ -1437,7 +1437,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         })\n     }\n \n-    fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLib> {\n+    fn get_native_libraries(self, sess: &Session) -> Vec<NativeLib> {\n         if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n@@ -1446,7 +1446,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_proc_macro_quoted_span(&self, index: usize, sess: &Session) -> Span {\n+    fn get_proc_macro_quoted_span(self, index: usize, sess: &Session) -> Span {\n         self.root\n             .tables\n             .proc_macro_quoted_spans\n@@ -1455,7 +1455,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, sess))\n     }\n \n-    fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> Lrc<FxHashMap<DefId, ForeignModule>> {\n+    fn get_foreign_modules(self, tcx: TyCtxt<'tcx>) -> Lrc<FxHashMap<DefId, ForeignModule>> {\n         if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules.\n             Lrc::new(FxHashMap::default())\n@@ -1467,7 +1467,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_dylib_dependency_formats(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(CrateNum, LinkagePreference)] {\n         tcx.arena.alloc_from_iter(\n@@ -1478,7 +1478,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n-    fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n+    fn get_missing_lang_items(self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n         if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n@@ -1487,7 +1487,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_fn_param_names(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [Ident] {\n+    fn get_fn_param_names(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [Ident] {\n         let param_names = match self.kind(id) {\n             EntryKind::Fn(data) | EntryKind::ForeignFn(data) => data.decode(self).param_names,\n             EntryKind::AssocFn(data) => data.decode(self).fn_data.param_names,\n@@ -1497,7 +1497,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn exported_symbols(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(ExportedSymbol<'tcx>, SymbolExportLevel)] {\n         if self.root.is_proc_macro_crate() {\n@@ -1509,7 +1509,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_rendered_const(&self, id: DefIndex) -> String {\n+    fn get_rendered_const(self, id: DefIndex) -> String {\n         match self.kind(id) {\n             EntryKind::AnonConst(_, data)\n             | EntryKind::Const(_, data)\n@@ -1518,7 +1518,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_macro(&self, id: DefIndex, sess: &Session) -> MacroDef {\n+    fn get_macro(self, id: DefIndex, sess: &Session) -> MacroDef {\n         match self.kind(id) {\n             EntryKind::MacroDef(macro_def) => macro_def.decode((self, sess)),\n             _ => bug!(),\n@@ -1527,7 +1527,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     // This replicates some of the logic of the crate-local `is_const_fn_raw` query, because we\n     // don't serialize constness for tuple variant and tuple struct constructors.\n-    fn is_const_fn_raw(&self, id: DefIndex) -> bool {\n+    fn is_const_fn_raw(self, id: DefIndex) -> bool {\n         let constness = match self.kind(id) {\n             EntryKind::AssocFn(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n@@ -1538,7 +1538,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         constness == hir::Constness::Const\n     }\n \n-    fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n+    fn asyncness(self, id: DefIndex) -> hir::IsAsync {\n         match self.kind(id) {\n             EntryKind::Fn(data) => data.decode(self).asyncness,\n             EntryKind::AssocFn(data) => data.decode(self).fn_data.asyncness,\n@@ -1547,7 +1547,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn is_foreign_item(&self, id: DefIndex) -> bool {\n+    fn is_foreign_item(self, id: DefIndex) -> bool {\n         match self.kind(id) {\n             EntryKind::ForeignImmStatic | EntryKind::ForeignMutStatic | EntryKind::ForeignFn(_) => {\n                 true\n@@ -1556,27 +1556,27 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn static_mutability(&self, id: DefIndex) -> Option<hir::Mutability> {\n+    fn static_mutability(self, id: DefIndex) -> Option<hir::Mutability> {\n         match self.kind(id) {\n             EntryKind::ImmStatic | EntryKind::ForeignImmStatic => Some(hir::Mutability::Not),\n             EntryKind::MutStatic | EntryKind::ForeignMutStatic => Some(hir::Mutability::Mut),\n             _ => None,\n         }\n     }\n \n-    fn generator_kind(&self, id: DefIndex) -> Option<hir::GeneratorKind> {\n+    fn generator_kind(self, id: DefIndex) -> Option<hir::GeneratorKind> {\n         match self.kind(id) {\n             EntryKind::Generator(data) => Some(data),\n             _ => None,\n         }\n     }\n \n-    fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n+    fn fn_sig(self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n         self.root.tables.fn_sig.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     #[inline]\n-    fn def_key(&self, index: DefIndex) -> DefKey {\n+    fn def_key(self, index: DefIndex) -> DefKey {\n         *self\n             .def_key_cache\n             .lock()\n@@ -1585,13 +1585,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     // Returns the path leading to the thing with this `id`.\n-    fn def_path(&self, id: DefIndex) -> DefPath {\n+    fn def_path(self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n         DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n     fn def_path_hash_unlocked(\n-        &self,\n+        self,\n         index: DefIndex,\n         def_path_hashes: &mut FxHashMap<DefIndex, DefPathHash>,\n     ) -> DefPathHash {\n@@ -1601,17 +1601,17 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     #[inline]\n-    fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n+    fn def_path_hash(self, index: DefIndex) -> DefPathHash {\n         let mut def_path_hashes = self.def_path_hash_cache.lock();\n         self.def_path_hash_unlocked(index, &mut def_path_hashes)\n     }\n \n     #[inline]\n-    fn def_path_hash_to_def_index(&self, hash: DefPathHash) -> DefIndex {\n+    fn def_path_hash_to_def_index(self, hash: DefPathHash) -> DefIndex {\n         self.def_path_hash_map.def_path_hash_to_def_index(&hash)\n     }\n \n-    fn expn_hash_to_expn_id(&self, sess: &Session, index_guess: u32, hash: ExpnHash) -> ExpnId {\n+    fn expn_hash_to_expn_id(self, sess: &Session, index_guess: u32, hash: ExpnHash) -> ExpnId {\n         debug_assert_eq!(ExpnId::from_hash(hash), None);\n         let index_guess = ExpnIndex::from_u32(index_guess);\n         let old_hash = self.root.expn_hashes.get(self, index_guess).map(|lazy| lazy.decode(self));\n@@ -1669,7 +1669,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     ///\n     /// Proc macro crates don't currently export spans, so this function does not have\n     /// to work for them.\n-    fn imported_source_files(&self, sess: &Session) -> &'a [ImportedSourceFile] {\n+    fn imported_source_files(self, sess: &Session) -> &'a [ImportedSourceFile] {\n         // Translate the virtual `/rustc/$hash` prefix back to a real directory\n         // that should hold actual sources, where possible.\n         //"}]}