{"sha": "f54c31391408214a890bada228fd3b2eb932b8a7", "node_id": "C_kwDOAAsO6NoAKGY1NGMzMTM5MTQwODIxNGE4OTBiYWRhMjI4ZmQzYjJlYjkzMmI4YTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-07T10:33:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-07T10:33:13Z"}, "message": "Auto merge of #13547 - Veykril:line-index, r=Veykril\n\ninternal: Optimize `apply_document_changes` a bit\n\ncc https://github.com/rust-lang/rust-analyzer/issues/13538", "tree": {"sha": "6af42d114893ec35e00d90359ac27a3f45a834b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6af42d114893ec35e00d90359ac27a3f45a834b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f54c31391408214a890bada228fd3b2eb932b8a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f54c31391408214a890bada228fd3b2eb932b8a7", "html_url": "https://github.com/rust-lang/rust/commit/f54c31391408214a890bada228fd3b2eb932b8a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f54c31391408214a890bada228fd3b2eb932b8a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "774207741933465722a79b212afabd76829c3f07", "url": "https://api.github.com/repos/rust-lang/rust/commits/774207741933465722a79b212afabd76829c3f07", "html_url": "https://github.com/rust-lang/rust/commit/774207741933465722a79b212afabd76829c3f07"}, {"sha": "28afe570682c98d7612c79a5ef523e2ed47ac7d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/28afe570682c98d7612c79a5ef523e2ed47ac7d0", "html_url": "https://github.com/rust-lang/rust/commit/28afe570682c98d7612c79a5ef523e2ed47ac7d0"}], "stats": {"total": 184, "additions": 117, "deletions": 67}, "files": [{"sha": "1b8f56187a02bf78f214fc0dacb7087ba16fc45d", "filename": "crates/ide-db/src/line_index.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f54c31391408214a890bada228fd3b2eb932b8a7/crates%2Fide-db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54c31391408214a890bada228fd3b2eb932b8a7/crates%2Fide-db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fline_index.rs?ref=f54c31391408214a890bada228fd3b2eb932b8a7", "patch": "@@ -58,8 +58,11 @@ impl LineIndex {\n         let mut utf16_lines = NoHashHashMap::default();\n         let mut utf16_chars = Vec::new();\n \n-        let mut newlines = vec![0.into()];\n-        let mut curr_row @ mut curr_col = 0.into();\n+        let mut newlines = Vec::with_capacity(16);\n+        newlines.push(TextSize::from(0));\n+\n+        let mut curr_row = 0.into();\n+        let mut curr_col = 0.into();\n         let mut line = 0;\n         for c in text.chars() {\n             let c_len = TextSize::of(c);"}, {"sha": "7636c3da7f9afef09a2946ffbee839fc627258b4", "filename": "crates/rust-analyzer/src/line_index.rs", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f54c31391408214a890bada228fd3b2eb932b8a7/crates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54c31391408214a890bada228fd3b2eb932b8a7/crates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fline_index.rs?ref=f54c31391408214a890bada228fd3b2eb932b8a7", "patch": "@@ -27,10 +27,6 @@ pub(crate) enum LineEndings {\n impl LineEndings {\n     /// Replaces `\\r\\n` with `\\n` in-place in `src`.\n     pub(crate) fn normalize(src: String) -> (String, LineEndings) {\n-        if !src.as_bytes().contains(&b'\\r') {\n-            return (src, LineEndings::Unix);\n-        }\n-\n         // We replace `\\r\\n` with `\\n` in-place, which doesn't break utf-8 encoding.\n         // While we *can* call `as_mut_vec` and do surgery on the live string\n         // directly, let's rather steal the contents of `src`. This makes the code\n@@ -39,10 +35,19 @@ impl LineEndings {\n         let mut buf = src.into_bytes();\n         let mut gap_len = 0;\n         let mut tail = buf.as_mut_slice();\n+        let mut crlf_seen = false;\n+\n+        let find_crlf = |src: &[u8]| src.windows(2).position(|it| it == b\"\\r\\n\");\n+\n         loop {\n             let idx = match find_crlf(&tail[gap_len..]) {\n-                None => tail.len(),\n-                Some(idx) => idx + gap_len,\n+                None if crlf_seen => tail.len(),\n+                // SAFETY: buf is unchanged and therefor still contains utf8 data\n+                None => return (unsafe { String::from_utf8_unchecked(buf) }, LineEndings::Unix),\n+                Some(idx) => {\n+                    crlf_seen = true;\n+                    idx + gap_len\n+                }\n             };\n             tail.copy_within(gap_len..idx, 0);\n             tail = &mut tail[idx - gap_len..];\n@@ -54,15 +59,48 @@ impl LineEndings {\n \n         // Account for removed `\\r`.\n         // After `set_len`, `buf` is guaranteed to contain utf-8 again.\n-        let new_len = buf.len() - gap_len;\n         let src = unsafe {\n+            let new_len = buf.len() - gap_len;\n             buf.set_len(new_len);\n             String::from_utf8_unchecked(buf)\n         };\n-        return (src, LineEndings::Dos);\n+        (src, LineEndings::Dos)\n+    }\n+}\n \n-        fn find_crlf(src: &[u8]) -> Option<usize> {\n-            src.windows(2).position(|it| it == b\"\\r\\n\")\n-        }\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn unix() {\n+        let src = \"a\\nb\\nc\\n\\n\\n\\n\";\n+        let (res, endings) = LineEndings::normalize(src.into());\n+        assert_eq!(endings, LineEndings::Unix);\n+        assert_eq!(res, src);\n+    }\n+\n+    #[test]\n+    fn dos() {\n+        let src = \"\\r\\na\\r\\n\\r\\nb\\r\\nc\\r\\n\\r\\n\\r\\n\\r\\n\";\n+        let (res, endings) = LineEndings::normalize(src.into());\n+        assert_eq!(endings, LineEndings::Dos);\n+        assert_eq!(res, \"\\na\\n\\nb\\nc\\n\\n\\n\\n\");\n+    }\n+\n+    #[test]\n+    fn mixed() {\n+        let src = \"a\\r\\nb\\r\\nc\\r\\n\\n\\r\\n\\n\";\n+        let (res, endings) = LineEndings::normalize(src.into());\n+        assert_eq!(endings, LineEndings::Dos);\n+        assert_eq!(res, \"a\\nb\\nc\\n\\n\\n\\n\");\n+    }\n+\n+    #[test]\n+    fn none() {\n+        let src = \"abc\";\n+        let (res, endings) = LineEndings::normalize(src.into());\n+        assert_eq!(endings, LineEndings::Unix);\n+        assert_eq!(res, src);\n     }\n }"}, {"sha": "0971dc36f3a5c84ef1f1ab34ae0da88c4ce70edc", "filename": "crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 59, "deletions": 52, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/f54c31391408214a890bada228fd3b2eb932b8a7/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54c31391408214a890bada228fd3b2eb932b8a7/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=f54c31391408214a890bada228fd3b2eb932b8a7", "patch": "@@ -1,5 +1,5 @@\n //! Utilities for LSP-related boilerplate code.\n-use std::{ops::Range, sync::Arc};\n+use std::{mem, ops::Range, sync::Arc};\n \n use lsp_server::Notification;\n \n@@ -133,11 +133,37 @@ impl GlobalState {\n }\n \n pub(crate) fn apply_document_changes(\n-    old_text: &mut String,\n-    content_changes: Vec<lsp_types::TextDocumentContentChangeEvent>,\n-) {\n+    file_contents: impl FnOnce() -> String,\n+    mut content_changes: Vec<lsp_types::TextDocumentContentChangeEvent>,\n+) -> String {\n+    // Skip to the last full document change, as it invalidates all previous changes anyways.\n+    let mut start = content_changes\n+        .iter()\n+        .rev()\n+        .position(|change| change.range.is_none())\n+        .map(|idx| content_changes.len() - idx - 1)\n+        .unwrap_or(0);\n+\n+    let mut text: String = match content_changes.get_mut(start) {\n+        // peek at the first content change as an optimization\n+        Some(lsp_types::TextDocumentContentChangeEvent { range: None, text, .. }) => {\n+            let text = mem::take(text);\n+            start += 1;\n+\n+            // The only change is a full document update\n+            if start == content_changes.len() {\n+                return text;\n+            }\n+            text\n+        }\n+        Some(_) => file_contents(),\n+        // we received no content changes\n+        None => return file_contents(),\n+    };\n+\n     let mut line_index = LineIndex {\n-        index: Arc::new(ide::LineIndex::new(old_text)),\n+        // the index will be overwritten in the bottom loop's first iteration\n+        index: Arc::new(ide::LineIndex::new(&text)),\n         // We don't care about line endings or offset encoding here.\n         endings: LineEndings::Unix,\n         encoding: PositionEncoding::Utf16,\n@@ -148,38 +174,20 @@ pub(crate) fn apply_document_changes(\n     // Some clients (e.g. Code) sort the ranges in reverse. As an optimization, we\n     // remember the last valid line in the index and only rebuild it if needed.\n     // The VFS will normalize the end of lines to `\\n`.\n-    enum IndexValid {\n-        All,\n-        UpToLineExclusive(u32),\n-    }\n-\n-    impl IndexValid {\n-        fn covers(&self, line: u32) -> bool {\n-            match *self {\n-                IndexValid::UpToLineExclusive(to) => to > line,\n-                _ => true,\n-            }\n-        }\n-    }\n-\n-    let mut index_valid = IndexValid::All;\n+    let mut index_valid = !0u32;\n     for change in content_changes {\n-        match change.range {\n-            Some(range) => {\n-                if !index_valid.covers(range.end.line) {\n-                    line_index.index = Arc::new(ide::LineIndex::new(old_text));\n-                }\n-                index_valid = IndexValid::UpToLineExclusive(range.start.line);\n-                if let Ok(range) = from_proto::text_range(&line_index, range) {\n-                    old_text.replace_range(Range::<usize>::from(range), &change.text);\n-                }\n+        // The None case can't happen as we have handled it above already\n+        if let Some(range) = change.range {\n+            if index_valid <= range.end.line {\n+                *Arc::make_mut(&mut line_index.index) = ide::LineIndex::new(&text);\n             }\n-            None => {\n-                *old_text = change.text;\n-                index_valid = IndexValid::UpToLineExclusive(0);\n+            index_valid = range.start.line;\n+            if let Ok(range) = from_proto::text_range(&line_index, range) {\n+                text.replace_range(Range::<usize>::from(range), &change.text);\n             }\n         }\n     }\n+    text\n }\n \n /// Checks that the edits inside the completion and the additional edits do not overlap.\n@@ -242,51 +250,50 @@ mod tests {\n             };\n         }\n \n-        let mut text = String::new();\n-        apply_document_changes(&mut text, vec![]);\n+        let text = apply_document_changes(|| String::new(), vec![]);\n         assert_eq!(text, \"\");\n-        apply_document_changes(\n-            &mut text,\n+        let text = apply_document_changes(\n+            || text,\n             vec![TextDocumentContentChangeEvent {\n                 range: None,\n                 range_length: None,\n                 text: String::from(\"the\"),\n             }],\n         );\n         assert_eq!(text, \"the\");\n-        apply_document_changes(&mut text, c![0, 3; 0, 3 => \" quick\"]);\n+        let text = apply_document_changes(|| text, c![0, 3; 0, 3 => \" quick\"]);\n         assert_eq!(text, \"the quick\");\n-        apply_document_changes(&mut text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n+        let text = apply_document_changes(|| text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n         assert_eq!(text, \"quick foxes\");\n-        apply_document_changes(&mut text, c![0, 11; 0, 11 => \"\\ndream\"]);\n+        let text = apply_document_changes(|| text, c![0, 11; 0, 11 => \"\\ndream\"]);\n         assert_eq!(text, \"quick foxes\\ndream\");\n-        apply_document_changes(&mut text, c![1, 0; 1, 0 => \"have \"]);\n+        let text = apply_document_changes(|| text, c![1, 0; 1, 0 => \"have \"]);\n         assert_eq!(text, \"quick foxes\\nhave dream\");\n-        apply_document_changes(\n-            &mut text,\n+        let text = apply_document_changes(\n+            || text,\n             c![0, 0; 0, 0 => \"the \", 1, 4; 1, 4 => \" quiet\", 1, 16; 1, 16 => \"s\\n\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nhave quiet dreams\\n\");\n-        apply_document_changes(&mut text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n+        let text = apply_document_changes(|| text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n         assert_eq!(text, \"the quick foxes\\n\\nhave quiet dreams\\n\\n\");\n-        apply_document_changes(\n-            &mut text,\n+        let text = apply_document_changes(\n+            || text,\n             c![1, 0; 1, 0 => \"DREAM\", 2, 0; 2, 0 => \"they \", 3, 0; 3, 0 => \"DON'T THEY?\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nDREAM\\nthey have quiet dreams\\nDON'T THEY?\\n\");\n-        apply_document_changes(&mut text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n+        let text = apply_document_changes(|| text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n         assert_eq!(text, \"the quick \\nthey have quiet dreams\\n\");\n \n-        text = String::from(\"\u2764\ufe0f\");\n-        apply_document_changes(&mut text, c![0, 0; 0, 0 => \"a\"]);\n+        let text = String::from(\"\u2764\ufe0f\");\n+        let text = apply_document_changes(|| text, c![0, 0; 0, 0 => \"a\"]);\n         assert_eq!(text, \"a\u2764\ufe0f\");\n \n-        text = String::from(\"a\\nb\");\n-        apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n+        let text = String::from(\"a\\nb\");\n+        let text = apply_document_changes(|| text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n         assert_eq!(text, \"adcb\");\n \n-        text = String::from(\"a\\nb\");\n-        apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n+        let text = String::from(\"a\\nb\");\n+        let text = apply_document_changes(|| text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n         assert_eq!(text, \"a\u021bc\\ncb\");\n     }\n "}, {"sha": "6e5da58fe372af1fa1c07b89d309b741c5404aff", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f54c31391408214a890bada228fd3b2eb932b8a7/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54c31391408214a890bada228fd3b2eb932b8a7/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=f54c31391408214a890bada228fd3b2eb932b8a7", "patch": "@@ -759,8 +759,10 @@ impl GlobalState {\n \n                     let vfs = &mut this.vfs.write().0;\n                     let file_id = vfs.file_id(&path).unwrap();\n-                    let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n-                    apply_document_changes(&mut text, params.content_changes);\n+                    let text = apply_document_changes(\n+                        || std::str::from_utf8(vfs.file_contents(file_id)).unwrap().into(),\n+                        params.content_changes,\n+                    );\n \n                     vfs.set_file_contents(path, Some(text.into_bytes()));\n                 }"}]}