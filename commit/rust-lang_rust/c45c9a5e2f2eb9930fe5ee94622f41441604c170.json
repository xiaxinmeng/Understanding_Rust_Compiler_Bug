{"sha": "c45c9a5e2f2eb9930fe5ee94622f41441604c170", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NWM5YTVlMmYyZWI5OTMwZmU1ZWU5NDYyMmY0MTQ0MTYwNGMxNzA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-21T22:13:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T23:54:31Z"}, "message": "librustc: De-`@mut` `NameBindings::type_def`", "tree": {"sha": "ec6e13fb3e630a33e889ef02bae69fdaaaaf3ee9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec6e13fb3e630a33e889ef02bae69fdaaaaf3ee9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c45c9a5e2f2eb9930fe5ee94622f41441604c170", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c45c9a5e2f2eb9930fe5ee94622f41441604c170", "html_url": "https://github.com/rust-lang/rust/commit/c45c9a5e2f2eb9930fe5ee94622f41441604c170", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c45c9a5e2f2eb9930fe5ee94622f41441604c170/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc1ea7887c1815164af8b3cf301d42c2a7a0b9ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc1ea7887c1815164af8b3cf301d42c2a7a0b9ab", "html_url": "https://github.com/rust-lang/rust/commit/bc1ea7887c1815164af8b3cf301d42c2a7a0b9ab"}], "stats": {"total": 68, "additions": 35, "deletions": 33}, "files": [{"sha": "d59a1154c3f6fe2d118c5c97b6c8e08af12c525e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c45c9a5e2f2eb9930fe5ee94622f41441604c170/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45c9a5e2f2eb9930fe5ee94622f41441604c170/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=c45c9a5e2f2eb9930fe5ee94622f41441604c170", "patch": "@@ -488,6 +488,7 @@ impl Module {\n }\n \n // Records a possibly-private type definition.\n+#[deriving(Clone)]\n struct TypeNsDef {\n     is_public: bool, // see note in ImportResolution about how to use this\n     module_def: Option<@Module>,\n@@ -505,7 +506,7 @@ struct ValueNsDef {\n // Records the definitions (at most one for each namespace) that a name is\n // bound to.\n struct NameBindings {\n-    type_def: Option<TypeNsDef>,    //< Meaning in type namespace.\n+    type_def: RefCell<Option<TypeNsDef>>,   //< Meaning in type namespace.\n     value_def: Option<ValueNsDef>,  //< Meaning in value namespace.\n }\n \n@@ -528,22 +529,22 @@ impl NameBindings {\n         // Merges the module with the existing type def or creates a new one.\n         let module_ = @Module::new(parent_link, def_id, kind, external,\n                                        is_public);\n-        match self.type_def {\n+        match self.type_def.get() {\n             None => {\n-                self.type_def = Some(TypeNsDef {\n+                self.type_def.set(Some(TypeNsDef {\n                     is_public: is_public,\n                     module_def: Some(module_),\n                     type_def: None,\n                     type_span: Some(sp)\n-                });\n+                }));\n             }\n             Some(type_def) => {\n-                self.type_def = Some(TypeNsDef {\n+                self.type_def.set(Some(TypeNsDef {\n                     is_public: is_public,\n                     module_def: Some(module_),\n                     type_span: Some(sp),\n                     type_def: type_def.type_def\n-                });\n+                }));\n             }\n         }\n     }\n@@ -556,16 +557,16 @@ impl NameBindings {\n                        external: bool,\n                        is_public: bool,\n                        _sp: Span) {\n-        match self.type_def {\n+        match self.type_def.get() {\n             None => {\n                 let module = @Module::new(parent_link, def_id, kind,\n                                               external, is_public);\n-                self.type_def = Some(TypeNsDef {\n+                self.type_def.set(Some(TypeNsDef {\n                     is_public: is_public,\n                     module_def: Some(module),\n                     type_def: None,\n                     type_span: None,\n-                })\n+                }))\n             }\n             Some(type_def) => {\n                 match type_def.module_def {\n@@ -575,12 +576,12 @@ impl NameBindings {\n                                                       kind,\n                                                       external,\n                                                       is_public);\n-                        self.type_def = Some(TypeNsDef {\n+                        self.type_def.set(Some(TypeNsDef {\n                             is_public: is_public,\n                             module_def: Some(module),\n                             type_def: type_def.type_def,\n                             type_span: None,\n-                        })\n+                        }))\n                     }\n                     Some(module_def) => module_def.kind.set(kind),\n                 }\n@@ -591,22 +592,22 @@ impl NameBindings {\n     /// Records a type definition.\n     fn define_type(&mut self, def: Def, sp: Span, is_public: bool) {\n         // Merges the type with the existing type def or creates a new one.\n-        match self.type_def {\n+        match self.type_def.get() {\n             None => {\n-                self.type_def = Some(TypeNsDef {\n+                self.type_def.set(Some(TypeNsDef {\n                     module_def: None,\n                     type_def: Some(def),\n                     type_span: Some(sp),\n                     is_public: is_public,\n-                });\n+                }));\n             }\n             Some(type_def) => {\n-                self.type_def = Some(TypeNsDef {\n+                self.type_def.set(Some(TypeNsDef {\n                     type_def: Some(def),\n                     type_span: Some(sp),\n                     module_def: type_def.module_def,\n                     is_public: is_public,\n-                });\n+                }));\n             }\n         }\n     }\n@@ -619,7 +620,8 @@ impl NameBindings {\n \n     /// Returns the module node if applicable.\n     fn get_module_if_available(&self) -> Option<@Module> {\n-        match self.type_def {\n+        let type_def = self.type_def.borrow();\n+        match *type_def.get() {\n             Some(ref type_def) => (*type_def).module_def,\n             None => None\n         }\n@@ -641,14 +643,14 @@ impl NameBindings {\n \n     fn defined_in_namespace(&self, namespace: Namespace) -> bool {\n         match namespace {\n-            TypeNS   => return self.type_def.is_some(),\n+            TypeNS   => return self.type_def.get().is_some(),\n             ValueNS  => return self.value_def.is_some()\n         }\n     }\n \n     fn defined_in_public_namespace(&self, namespace: Namespace) -> bool {\n         match namespace {\n-            TypeNS => match self.type_def {\n+            TypeNS => match self.type_def.get() {\n                 Some(def) => def.is_public, None => false\n             },\n             ValueNS => match self.value_def {\n@@ -660,10 +662,10 @@ impl NameBindings {\n     fn def_for_namespace(&self, namespace: Namespace) -> Option<Def> {\n         match namespace {\n             TypeNS => {\n-                match self.type_def {\n+                match self.type_def.get() {\n                     None => None,\n-                    Some(ref type_def) => {\n-                        match (*type_def).type_def {\n+                    Some(type_def) => {\n+                        match type_def.type_def {\n                             Some(type_def) => Some(type_def),\n                             None => {\n                                 match type_def.module_def {\n@@ -693,7 +695,7 @@ impl NameBindings {\n         if self.defined_in_namespace(namespace) {\n             match namespace {\n                 TypeNS  => {\n-                    match self.type_def {\n+                    match self.type_def.get() {\n                         None => None,\n                         Some(type_def) => type_def.type_span\n                     }\n@@ -713,7 +715,7 @@ impl NameBindings {\n \n fn NameBindings() -> NameBindings {\n     NameBindings {\n-        type_def: None,\n+        type_def: RefCell::new(None),\n         value_def: None\n     }\n }\n@@ -1607,7 +1609,7 @@ impl Resolver {\n         match def {\n           DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n           DefTy(def_id) => {\n-            match child_name_bindings.type_def {\n+            match child_name_bindings.type_def.get() {\n               Some(TypeNsDef { module_def: Some(module_def), .. }) => {\n                 debug!(\"(building reduced graph for external crate) \\\n                         already created module\");\n@@ -1799,7 +1801,7 @@ impl Resolver {\n                                 // Process the static methods. First,\n                                 // create the module.\n                                 let type_module;\n-                                match child_name_bindings.type_def {\n+                                match child_name_bindings.type_def.get() {\n                                     Some(TypeNsDef {\n                                         module_def: Some(module_def),\n                                         ..\n@@ -2212,12 +2214,12 @@ impl Resolver {\n     fn create_name_bindings_from_module(module: @Module)\n                                             -> NameBindings {\n         NameBindings {\n-            type_def: Some(TypeNsDef {\n+            type_def: RefCell::new(Some(TypeNsDef {\n                 is_public: false,\n                 module_def: Some(module),\n                 type_def: None,\n                 type_span: None\n-            }),\n+            })),\n             value_def: None,\n         }\n     }\n@@ -2396,7 +2398,7 @@ impl Resolver {\n         match type_result {\n             BoundResult(target_module, name_bindings) => {\n                 debug!(\"(resolving single import) found type target: {:?}\",\n-                        name_bindings.type_def.unwrap().type_def);\n+                        name_bindings.type_def.get().unwrap().type_def);\n                 import_resolution.type_target =\n                     Some(Target::new(target_module, name_bindings));\n                 import_resolution.type_id = directive.id;\n@@ -2649,7 +2651,7 @@ impl Resolver {\n                 Success((target, used_proxy)) => {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n-                    match target.bindings.type_def {\n+                    match target.bindings.type_def.get() {\n                         Some(type_def) => {\n                             match type_def.module_def {\n                                 None => {\n@@ -2970,9 +2972,9 @@ impl Resolver {\n         match resolve_result {\n             Success((target, _)) => {\n                 let bindings = &mut *target.bindings;\n-                match bindings.type_def {\n-                    Some(ref type_def) => {\n-                        match (*type_def).module_def {\n+                match bindings.type_def.get() {\n+                    Some(type_def) => {\n+                        match type_def.module_def {\n                             None => {\n                                 error!(\"!!! (resolving module in lexical \\\n                                         scope) module wasn't actually a \\"}]}