{"sha": "d5558e67ef86bda546eca72778aeeeda24420926", "node_id": "C_kwDOAAsO6NoAKGQ1NTU4ZTY3ZWY4NmJkYTU0NmVjYTcyNzc4YWVlZWRhMjQ0MjA5MjY", "commit": {"author": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2023-03-17T01:23:46Z"}, "committer": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2023-03-19T03:23:19Z"}, "message": "The name of NativeLib will be presented", "tree": {"sha": "fd82733ae7b4224df33be30836614288464359f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd82733ae7b4224df33be30836614288464359f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5558e67ef86bda546eca72778aeeeda24420926", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5558e67ef86bda546eca72778aeeeda24420926", "html_url": "https://github.com/rust-lang/rust/commit/d5558e67ef86bda546eca72778aeeeda24420926", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5558e67ef86bda546eca72778aeeeda24420926/comments", "author": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c22f154e3fb6eca7dd1e83575564a5ea44d661bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c22f154e3fb6eca7dd1e83575564a5ea44d661bc", "html_url": "https://github.com/rust-lang/rust/commit/c22f154e3fb6eca7dd1e83575564a5ea44d661bc"}], "stats": {"total": 127, "additions": 71, "deletions": 56}, "files": [{"sha": "64742bbb986642f52f10bc62667ef99d262f4122", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d5558e67ef86bda546eca72778aeeeda24420926/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5558e67ef86bda546eca72778aeeeda24420926/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=d5558e67ef86bda546eca72778aeeeda24420926", "patch": "@@ -358,9 +358,9 @@ fn link_rlib<'a>(\n             let (data, _) = create_wrapper_file(sess, b\".bundled_lib\".to_vec(), &src);\n             let wrapper_file = emit_wrapper_file(sess, &data, tmpdir, filename.as_str());\n             packed_bundled_libs.push(wrapper_file);\n-        } else if let Some(name) = lib.name {\n+        } else {\n             let path =\n-                find_native_static_library(name.as_str(), lib.verbatim, &lib_search_paths, sess);\n+                find_native_static_library(lib.name.as_str(), lib.verbatim, &lib_search_paths, sess);\n             ab.add_archive(&path, Box::new(|_| false)).unwrap_or_else(|error| {\n                 sess.emit_fatal(errors::AddNativeLibrary { library_path: path, error })});\n         }\n@@ -436,7 +436,7 @@ fn collate_raw_dylibs<'a, 'b>(\n     for lib in used_libraries {\n         if lib.kind == NativeLibKind::RawDylib {\n             let ext = if lib.verbatim { \"\" } else { \".dll\" };\n-            let name = format!(\"{}{}\", lib.name.expect(\"unnamed raw-dylib library\"), ext);\n+            let name = format!(\"{}{}\", lib.name, ext);\n             let imports = dylib_table.entry(name.clone()).or_default();\n             for import in &lib.dll_imports {\n                 if let Some(old_import) = imports.insert(import.name, import) {\n@@ -1294,7 +1294,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n         .iter()\n         .filter(|l| relevant_lib(sess, l))\n         .filter_map(|lib| {\n-            let name = lib.name?;\n+            let name = lib.name;\n             match lib.kind {\n                 NativeLibKind::Static { bundle: Some(false), .. }\n                 | NativeLibKind::Dylib { .. }\n@@ -1315,6 +1315,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n                 // These are included, no need to print them\n                 NativeLibKind::Static { bundle: None | Some(true), .. }\n                 | NativeLibKind::LinkArg\n+                | NativeLibKind::WasmImportModule\n                 | NativeLibKind::RawDylib => None,\n             }\n         })\n@@ -2273,21 +2274,18 @@ fn add_native_libs_from_crate(\n \n     let mut last = (None, NativeLibKind::Unspecified, false);\n     for lib in native_libs {\n-        let Some(name) = lib.name else {\n-            continue;\n-        };\n         if !relevant_lib(sess, lib) {\n             continue;\n         }\n \n         // Skip if this library is the same as the last.\n-        last = if (lib.name, lib.kind, lib.verbatim) == last {\n+        last = if (Some(lib.name), lib.kind, lib.verbatim) == last {\n             continue;\n         } else {\n-            (lib.name, lib.kind, lib.verbatim)\n+            (Some(lib.name), lib.kind, lib.verbatim)\n         };\n \n-        let name = name.as_str();\n+        let name = lib.name.as_str();\n         let verbatim = lib.verbatim;\n         match lib.kind {\n             NativeLibKind::Static { bundle, whole_archive } => {\n@@ -2344,6 +2342,7 @@ fn add_native_libs_from_crate(\n             NativeLibKind::RawDylib => {\n                 // Handled separately in `linker_with_args`.\n             }\n+            NativeLibKind::WasmImportModule => {}\n             NativeLibKind::LinkArg => {\n                 if link_static {\n                     cmd.arg(name);"}, {"sha": "18d17b1a0137c1e027c2dcc4029b3712a5c6b1e6", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5558e67ef86bda546eca72778aeeeda24420926/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5558e67ef86bda546eca72778aeeeda24420926/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=d5558e67ef86bda546eca72778aeeeda24420926", "patch": "@@ -595,7 +595,7 @@ fn wasm_import_module_map(tcx: TyCtxt<'_>, cnum: CrateNum) -> FxHashMap<DefId, S\n \n     let mut ret = FxHashMap::default();\n     for (def_id, lib) in tcx.foreign_modules(cnum).iter() {\n-        let module = def_id_to_native_lib.get(&def_id).and_then(|s| s.wasm_import_module);\n+        let module = def_id_to_native_lib.get(&def_id).and_then(|s| s.wasm_import_module());\n         let Some(module) = module else { continue };\n         ret.extend(lib.foreign_items.iter().map(|id| {\n             assert_eq!(id.krate, cnum);"}, {"sha": "81227b04e8a7efe0690b6a98db20af8883d593a3", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5558e67ef86bda546eca72778aeeeda24420926/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5558e67ef86bda546eca72778aeeeda24420926/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=d5558e67ef86bda546eca72778aeeeda24420926", "patch": "@@ -118,7 +118,7 @@ bitflags::bitflags! {\n #[derive(Clone, Debug, Encodable, Decodable, HashStable)]\n pub struct NativeLib {\n     pub kind: NativeLibKind,\n-    pub name: Option<Symbol>,\n+    pub name: Symbol,\n     pub filename: Option<Symbol>,\n     pub cfg: Option<ast::MetaItem>,\n     pub verbatim: bool,"}, {"sha": "b855c8e433266470195b6033923ddb784f459185", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 34, "deletions": 41, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d5558e67ef86bda546eca72778aeeeda24420926/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5558e67ef86bda546eca72778aeeeda24420926/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=d5558e67ef86bda546eca72778aeeeda24420926", "patch": "@@ -46,14 +46,13 @@ pub fn find_native_static_library(\n }\n \n fn find_bundled_library(\n-    name: Option<Symbol>,\n+    name: Symbol,\n     verbatim: Option<bool>,\n     kind: NativeLibKind,\n     has_cfg: bool,\n     sess: &Session,\n ) -> Option<Symbol> {\n     if let NativeLibKind::Static { bundle: Some(true) | None, whole_archive } = kind\n-        && let Some(name) = name\n         && sess.crate_types().iter().any(|t| matches!(t, &CrateType::Rlib | CrateType::Staticlib))\n         && (sess.opts.unstable_opts.packed_bundled_libs || has_cfg || whole_archive == Some(true))\n     {\n@@ -337,10 +336,16 @@ impl<'tcx> Collector<'tcx> {\n                 if name.is_some() || kind.is_some() || modifiers.is_some() || cfg.is_some() {\n                     sess.emit_err(errors::IncompatibleWasmLink { span });\n                 }\n-            } else if name.is_none() {\n-                sess.emit_err(errors::LinkRequiresName { span: m.span });\n             }\n \n+            if wasm_import_module.is_some() {\n+                (name, kind) = (wasm_import_module, Some(NativeLibKind::WasmImportModule));\n+            }\n+            let Some((name, name_span)) = name else {\n+                sess.emit_err(errors::LinkRequiresName { span: m.span });\n+                continue;\n+            };\n+\n             // Do this outside of the loop so that `import_name_type` can be specified before `kind`.\n             if let Some((_, span)) = import_name_type {\n                 if kind != Some(NativeLibKind::RawDylib) {\n@@ -350,8 +355,8 @@ impl<'tcx> Collector<'tcx> {\n \n             let dll_imports = match kind {\n                 Some(NativeLibKind::RawDylib) => {\n-                    if let Some((name, span)) = name && name.as_str().contains('\\0') {\n-                        sess.emit_err(errors::RawDylibNoNul { span });\n+                    if name.as_str().contains('\\0') {\n+                        sess.emit_err(errors::RawDylibNoNul { span: name_span });\n                     }\n                     foreign_mod_items\n                         .iter()\n@@ -390,7 +395,6 @@ impl<'tcx> Collector<'tcx> {\n                 }\n             };\n \n-            let name = name.map(|(name, _)| name);\n             let kind = kind.unwrap_or(NativeLibKind::Unspecified);\n             let filename = find_bundled_library(name, verbatim, kind, cfg.is_some(), sess);\n             self.libs.push(NativeLib {\n@@ -399,7 +403,6 @@ impl<'tcx> Collector<'tcx> {\n                 kind,\n                 cfg,\n                 foreign_module: Some(it.owner_id.to_def_id()),\n-                wasm_import_module: wasm_import_module.map(|(name, _)| name),\n                 verbatim,\n                 dll_imports,\n             });\n@@ -416,11 +419,7 @@ impl<'tcx> Collector<'tcx> {\n                 self.tcx.sess.emit_err(errors::LibFrameworkApple);\n             }\n             if let Some(ref new_name) = lib.new_name {\n-                let any_duplicate = self\n-                    .libs\n-                    .iter()\n-                    .filter_map(|lib| lib.name.as_ref())\n-                    .any(|n| n.as_str() == lib.name);\n+                let any_duplicate = self.libs.iter().any(|n| n.name.as_str() == lib.name);\n                 if new_name.is_empty() {\n                     self.tcx.sess.emit_err(errors::EmptyRenamingTarget { lib_name: &lib.name });\n                 } else if !any_duplicate {\n@@ -445,41 +444,36 @@ impl<'tcx> Collector<'tcx> {\n             let mut existing = self\n                 .libs\n                 .drain_filter(|lib| {\n-                    if let Some(lib_name) = lib.name {\n-                        if lib_name.as_str() == passed_lib.name {\n-                            // FIXME: This whole logic is questionable, whether modifiers are\n-                            // involved or not, library reordering and kind overriding without\n-                            // explicit `:rename` in particular.\n-                            if lib.has_modifiers() || passed_lib.has_modifiers() {\n-                                match lib.foreign_module {\n-                                    Some(def_id) => {\n-                                        self.tcx.sess.emit_err(errors::NoLinkModOverride {\n-                                            span: Some(self.tcx.def_span(def_id)),\n-                                        })\n-                                    }\n-                                    None => self\n-                                        .tcx\n-                                        .sess\n-                                        .emit_err(errors::NoLinkModOverride { span: None }),\n-                                };\n-                            }\n-                            if passed_lib.kind != NativeLibKind::Unspecified {\n-                                lib.kind = passed_lib.kind;\n-                            }\n-                            if let Some(new_name) = &passed_lib.new_name {\n-                                lib.name = Some(Symbol::intern(new_name));\n-                            }\n-                            lib.verbatim = passed_lib.verbatim;\n-                            return true;\n+                    if lib.name.as_str() == passed_lib.name {\n+                        // FIXME: This whole logic is questionable, whether modifiers are\n+                        // involved or not, library reordering and kind overriding without\n+                        // explicit `:rename` in particular.\n+                        if lib.has_modifiers() || passed_lib.has_modifiers() {\n+                            match lib.foreign_module {\n+                                Some(def_id) => self.tcx.sess.emit_err(errors::NoLinkModOverride {\n+                                    span: Some(self.tcx.def_span(def_id)),\n+                                }),\n+                                None => {\n+                                    self.tcx.sess.emit_err(errors::NoLinkModOverride { span: None })\n+                                }\n+                            };\n+                        }\n+                        if passed_lib.kind != NativeLibKind::Unspecified {\n+                            lib.kind = passed_lib.kind;\n+                        }\n+                        if let Some(new_name) = &passed_lib.new_name {\n+                            lib.name = Symbol::intern(new_name);\n                         }\n+                        lib.verbatim = passed_lib.verbatim;\n+                        return true;\n                     }\n                     false\n                 })\n                 .collect::<Vec<_>>();\n             if existing.is_empty() {\n                 // Add if not found\n                 let new_name: Option<&str> = passed_lib.new_name.as_deref();\n-                let name = Some(Symbol::intern(new_name.unwrap_or(&passed_lib.name)));\n+                let name = Symbol::intern(new_name.unwrap_or(&passed_lib.name));\n                 let sess = self.tcx.sess;\n                 let filename =\n                     find_bundled_library(name, passed_lib.verbatim, passed_lib.kind, false, sess);\n@@ -489,7 +483,6 @@ impl<'tcx> Collector<'tcx> {\n                     kind: passed_lib.kind,\n                     cfg: None,\n                     foreign_module: None,\n-                    wasm_import_module: None,\n                     verbatim: passed_lib.verbatim,\n                     dll_imports: Vec::new(),\n                 });"}, {"sha": "a262c06d91f039b6b47bd68a093557db315f9bd9", "filename": "compiler/rustc_session/src/cstore.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5558e67ef86bda546eca72778aeeeda24420926/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5558e67ef86bda546eca72778aeeeda24420926/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcstore.rs?ref=d5558e67ef86bda546eca72778aeeeda24420926", "patch": "@@ -67,12 +67,11 @@ pub enum LinkagePreference {\n #[derive(Debug, Encodable, Decodable, HashStable_Generic)]\n pub struct NativeLib {\n     pub kind: NativeLibKind,\n-    pub name: Option<Symbol>,\n+    pub name: Symbol,\n     /// If packed_bundled_libs enabled, actual filename of library is stored.\n     pub filename: Option<Symbol>,\n     pub cfg: Option<ast::MetaItem>,\n     pub foreign_module: Option<DefId>,\n-    pub wasm_import_module: Option<Symbol>,\n     pub verbatim: Option<bool>,\n     pub dll_imports: Vec<DllImport>,\n }\n@@ -81,6 +80,10 @@ impl NativeLib {\n     pub fn has_modifiers(&self) -> bool {\n         self.verbatim.is_some() || self.kind.has_modifiers()\n     }\n+\n+    pub fn wasm_import_module(&self) -> Option<Symbol> {\n+        if self.kind == NativeLibKind::WasmImportModule { Some(self.name) } else { None }\n+    }\n }\n \n /// Different ways that the PE Format can decorate a symbol name."}, {"sha": "3b3d4ca5d6b21e3c15cf8b70ec8244683eee70e0", "filename": "compiler/rustc_session/src/utils.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5558e67ef86bda546eca72778aeeeda24420926/compiler%2Frustc_session%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5558e67ef86bda546eca72778aeeeda24420926/compiler%2Frustc_session%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Futils.rs?ref=d5558e67ef86bda546eca72778aeeeda24420926", "patch": "@@ -37,6 +37,10 @@ pub enum NativeLibKind {\n     /// Argument which is passed to linker, relative order with libraries and other arguments\n     /// is preserved\n     LinkArg,\n+\n+    /// Module imported from WebAssembly\n+    WasmImportModule,\n+\n     /// The library kind wasn't specified, `Dylib` is currently used as a default.\n     Unspecified,\n }\n@@ -50,7 +54,10 @@ impl NativeLibKind {\n             NativeLibKind::Dylib { as_needed } | NativeLibKind::Framework { as_needed } => {\n                 as_needed.is_some()\n             }\n-            NativeLibKind::RawDylib | NativeLibKind::Unspecified | NativeLibKind::LinkArg => false,\n+            NativeLibKind::RawDylib\n+            | NativeLibKind::Unspecified\n+            | NativeLibKind::LinkArg\n+            | NativeLibKind::WasmImportModule => false,\n         }\n     }\n "}, {"sha": "2f740e55389730bf0550a9124ea68583b223e0b7", "filename": "tests/ui/linkage-attr/issue-109144.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5558e67ef86bda546eca72778aeeeda24420926/tests%2Fui%2Flinkage-attr%2Fissue-109144.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5558e67ef86bda546eca72778aeeeda24420926/tests%2Fui%2Flinkage-attr%2Fissue-109144.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flinkage-attr%2Fissue-109144.rs?ref=d5558e67ef86bda546eca72778aeeeda24420926", "patch": "@@ -0,0 +1,4 @@\n+#![crate_type = \"lib\"]\n+#[link(kind = \"static\", modifiers = \"+whole-archive,+bundle\")]\n+//~^ ERROR `#[link]` attribute requires a `name = \"string\"` argument\n+extern  {}"}, {"sha": "33187cfdbb63674aa8235a72f6c82ff50dc991c3", "filename": "tests/ui/linkage-attr/issue-109144.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5558e67ef86bda546eca72778aeeeda24420926/tests%2Fui%2Flinkage-attr%2Fissue-109144.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5558e67ef86bda546eca72778aeeeda24420926/tests%2Fui%2Flinkage-attr%2Fissue-109144.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flinkage-attr%2Fissue-109144.stderr?ref=d5558e67ef86bda546eca72778aeeeda24420926", "patch": "@@ -0,0 +1,9 @@\n+error[E0459]: `#[link]` attribute requires a `name = \"string\"` argument\n+  --> $DIR/issue-109144.rs:2:1\n+   |\n+LL | #[link(kind = \"static\", modifiers = \"+whole-archive,+bundle\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `name` argument\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0459`."}]}