{"sha": "003a3f8cd3ea4594e2c2bc89c05562a202868ce0", "node_id": "C_kwDOAAsO6NoAKDAwM2EzZjhjZDNlYTQ1OTRlMmMyYmM4OWMwNTU2MmEyMDI4NjhjZTA", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-10-20T07:59:07Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-10-30T23:16:39Z"}, "message": "Use `br` instead of `switch` in more cases.\n\n`codegen_switchint_terminator` already uses `br` instead of `switch`\nwhen there is one normal target plus the `otherwise` target. But there's\nanother common case with two normal targets and an `otherwise` target\nthat points to an empty unreachable BB. This comes up a lot when\nswitching on the tags of enums that use niches.\n\nThe pattern looks like this:\n```\nbb1:                                              ; preds = %bb6\n  %3 = load i8, ptr %_2, align 1, !range !9, !noundef !4\n  %4 = sub i8 %3, 2\n  %5 = icmp eq i8 %4, 0\n  %_6 = select i1 %5, i64 0, i64 1\n  switch i64 %_6, label %bb3 [\n    i64 0, label %bb4\n    i64 1, label %bb2\n  ]\n\nbb3:                                              ; preds = %bb1\n  unreachable\n```\nThis commit adds code to convert the `switch` to a `br`:\n```\nbb1:                                              ; preds = %bb6\n  %3 = load i8, ptr %_2, align 1, !range !9, !noundef !4\n  %4 = sub i8 %3, 2\n  %5 = icmp eq i8 %4, 0\n  %_6 = select i1 %5, i64 0, i64 1\n  %6 = icmp eq i64 %_6, 0\n  br i1 %6, label %bb4, label %bb2\n\nbb3:                                              ; No predecessors!\n  unreachable\n```\nThis has a surprisingly large effect on compile times, with reductions\nof 5% on debug builds of some crates. The reduction is all due to LLVM\ntaking less time. Maybe LLVM is just much better at handling `br` than\n`switch`.\n\nThe resulting code is still suboptimal.\n- The `icmp`, `select`, `icmp` sequence is silly, converting an `i1` to an `i64`\n  and back to an `i1`. But with the current code structure it's hard to avoid,\n  and LLVM will easily clean it up, in opt builds at least.\n- `bb3` is usually now truly dead code (though not always, so it can't\n  be removed universally).", "tree": {"sha": "eded7bafa2d9a51eff572a3510d175c3a494191b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eded7bafa2d9a51eff572a3510d175c3a494191b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/003a3f8cd3ea4594e2c2bc89c05562a202868ce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/003a3f8cd3ea4594e2c2bc89c05562a202868ce0", "html_url": "https://github.com/rust-lang/rust/commit/003a3f8cd3ea4594e2c2bc89c05562a202868ce0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/003a3f8cd3ea4594e2c2bc89c05562a202868ce0/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f42b6fa7cad0d221b0c5407dca70b085784b1b5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f42b6fa7cad0d221b0c5407dca70b085784b1b5e", "html_url": "https://github.com/rust-lang/rust/commit/f42b6fa7cad0d221b0c5407dca70b085784b1b5e"}], "stats": {"total": 147, "additions": 116, "deletions": 31}, "files": [{"sha": "0802067cde65d85478612cfa1021312d89cfe3f3", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/003a3f8cd3ea4594e2c2bc89c05562a202868ce0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003a3f8cd3ea4594e2c2bc89c05562a202868ce0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=003a3f8cd3ea4594e2c2bc89c05562a202868ce0", "patch": "@@ -17,6 +17,7 @@ use rustc_middle::mir::{self, AssertKind, SwitchTargets};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Instance, Ty, TypeVisitable};\n+use rustc_session::config::OptLevel;\n use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n use rustc_symbol_mangling::typeid::typeid_for_fnabi;\n@@ -286,12 +287,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         assert_eq!(discr.layout.ty, switch_ty);\n         let mut target_iter = targets.iter();\n         if target_iter.len() == 1 {\n-            // If there are two targets (one conditional, one fallback), emit br instead of switch\n+            // If there are two targets (one conditional, one fallback), emit `br` instead of\n+            // `switch`.\n             let (test_value, target) = target_iter.next().unwrap();\n             let lltrue = helper.llbb_with_cleanup(self, target);\n             let llfalse = helper.llbb_with_cleanup(self, targets.otherwise());\n             if switch_ty == bx.tcx().types.bool {\n-                // Don't generate trivial icmps when switching on bool\n+                // Don't generate trivial icmps when switching on bool.\n                 match test_value {\n                     0 => bx.cond_br(discr.immediate(), llfalse, lltrue),\n                     1 => bx.cond_br(discr.immediate(), lltrue, llfalse),\n@@ -303,6 +305,30 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n                 bx.cond_br(cmp, lltrue, llfalse);\n             }\n+        } else if self.cx.sess().opts.optimize == OptLevel::No\n+            && target_iter.len() == 2\n+            && self.mir[targets.otherwise()].is_empty_unreachable()\n+        {\n+            // In unoptimized builds, if there are two normal targets and the `otherwise` target is\n+            // an unreachable BB, emit `br` instead of `switch`. This leaves behind the unreachable\n+            // BB, which will usually (but not always) be dead code.\n+            //\n+            // Why only in unoptimized builds?\n+            // - In unoptimized builds LLVM uses FastISel which does not support switches, so it\n+            //   must fall back to the to the slower SelectionDAG isel. Therefore, using `br` gives\n+            //   significant compile time speedups for unoptimized builds.\n+            // - In optimized builds the above doesn't hold, and using `br` sometimes results in\n+            //   worse generated code because LLVM can no longer tell that the value being switched\n+            //   on can only have two values, e.g. 0 and 1.\n+            //\n+            let (test_value1, target1) = target_iter.next().unwrap();\n+            let (_test_value2, target2) = target_iter.next().unwrap();\n+            let ll1 = helper.llbb_with_cleanup(self, target1);\n+            let ll2 = helper.llbb_with_cleanup(self, target2);\n+            let switch_llty = bx.immediate_backend_type(bx.layout_of(switch_ty));\n+            let llval = bx.const_uint_big(switch_llty, test_value1);\n+            let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n+            bx.cond_br(cmp, ll1, ll2);\n         } else {\n             bx.switch(\n                 discr.immediate(),"}, {"sha": "068daaadbdac21fa6d6984552801cf4c5fa70280", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/003a3f8cd3ea4594e2c2bc89c05562a202868ce0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003a3f8cd3ea4594e2c2bc89c05562a202868ce0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=003a3f8cd3ea4594e2c2bc89c05562a202868ce0", "patch": "@@ -1186,6 +1186,11 @@ impl<'tcx> BasicBlockData<'tcx> {\n     pub fn visitable(&self, index: usize) -> &dyn MirVisitable<'tcx> {\n         if index < self.statements.len() { &self.statements[index] } else { &self.terminator }\n     }\n+\n+    /// Does the block have no statements and an unreachable terminator?\n+    pub fn is_empty_unreachable(&self) -> bool {\n+        self.statements.is_empty() && matches!(self.terminator().kind, TerminatorKind::Unreachable)\n+    }\n }\n \n impl<O> AssertKind<O> {"}, {"sha": "36402cc7353ff2c1cebf6ab71b79ce55c4e0eafe", "filename": "src/test/codegen/match-optimized.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/003a3f8cd3ea4594e2c2bc89c05562a202868ce0/src%2Ftest%2Fcodegen%2Fmatch-optimized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003a3f8cd3ea4594e2c2bc89c05562a202868ce0/src%2Ftest%2Fcodegen%2Fmatch-optimized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch-optimized.rs?ref=003a3f8cd3ea4594e2c2bc89c05562a202868ce0", "patch": "@@ -0,0 +1,60 @@\n+// compile-flags: -C no-prepopulate-passes -O\n+\n+#![crate_type = \"lib\"]\n+\n+pub enum E {\n+    A,\n+    B,\n+    C,\n+}\n+\n+// CHECK-LABEL: @exhaustive_match\n+#[no_mangle]\n+pub fn exhaustive_match(e: E) -> u8 {\n+// CHECK: switch{{.*}}, label %[[OTHERWISE:[a-zA-Z0-9_]+]] [\n+// CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[A:[a-zA-Z0-9_]+]]\n+// CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[B:[a-zA-Z0-9_]+]]\n+// CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[C:[a-zA-Z0-9_]+]]\n+// CHECK-NEXT: ]\n+// CHECK: [[OTHERWISE]]:\n+// CHECK-NEXT: unreachable\n+//\n+// CHECK: [[A]]:\n+// CHECK-NEXT: store i8 0, {{i8\\*|ptr}} %1, align 1\n+// CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n+// CHECK: [[B]]:\n+// CHECK-NEXT: store i8 1, {{i8\\*|ptr}} %1, align 1\n+// CHECK-NEXT: br label %[[EXIT]]\n+// CHECK: [[C]]:\n+// CHECK-NEXT: store i8 2, {{i8\\*|ptr}} %1, align 1\n+// CHECK-NEXT: br label %[[EXIT]]\n+    match e {\n+        E::A => 0,\n+        E::B => 1,\n+        E::C => 2,\n+    }\n+}\n+\n+#[repr(u16)]\n+pub enum E2 {\n+    A = 13,\n+    B = 42,\n+}\n+\n+// For optimized code we produce a switch with an unreachable target as the `otherwise` so LLVM\n+// knows the possible values. Compare with `src/test/codegen/match-unoptimized.rs`.\n+\n+// CHECK-LABEL: @exhaustive_match_2\n+#[no_mangle]\n+pub fn exhaustive_match_2(e: E2) -> u8 {\n+    // CHECK: switch i16 %{{.+}}, label %[[UNREACH:.+]] [\n+    // CHECK-NEXT: i16 13,\n+    // CHECK-NEXT: i16 42,\n+    // CHECK-NEXT: ]\n+    // CHECK: [[UNREACH]]:\n+    // CHECK-NEXT: unreachable\n+    match e {\n+        E2::A => 0,\n+        E2::B => 1,\n+    }\n+}"}, {"sha": "be40b29e3d3e1a7fbd5b0b7b92d9ae59818092ed", "filename": "src/test/codegen/match-unoptimized.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/003a3f8cd3ea4594e2c2bc89c05562a202868ce0/src%2Ftest%2Fcodegen%2Fmatch-unoptimized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003a3f8cd3ea4594e2c2bc89c05562a202868ce0/src%2Ftest%2Fcodegen%2Fmatch-unoptimized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch-unoptimized.rs?ref=003a3f8cd3ea4594e2c2bc89c05562a202868ce0", "patch": "@@ -0,0 +1,23 @@\n+// compile-flags: -C no-prepopulate-passes -Copt-level=0\n+\n+#![crate_type = \"lib\"]\n+\n+#[repr(u16)]\n+pub enum E2 {\n+    A = 13,\n+    B = 42,\n+}\n+\n+// For unoptimized code we produce a `br` instead of a `switch`. Compare with\n+// `src/test/codegen/match-optimized.rs`\n+\n+// CHECK-LABEL: @exhaustive_match_2\n+#[no_mangle]\n+pub fn exhaustive_match_2(e: E2) -> u8 {\n+    // CHECK: %[[CMP:.+]] = icmp eq i16 %{{.+}}, 13\n+    // CHECK-NEXT: br i1 %[[CMP:.+]],\n+    match e {\n+        E2::A => 0,\n+        E2::B => 1,\n+    }\n+}"}, {"sha": "b203641fddbd051b62a88131fc43105b4a6ea007", "filename": "src/test/codegen/match.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f42b6fa7cad0d221b0c5407dca70b085784b1b5e/src%2Ftest%2Fcodegen%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f42b6fa7cad0d221b0c5407dca70b085784b1b5e/src%2Ftest%2Fcodegen%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch.rs?ref=f42b6fa7cad0d221b0c5407dca70b085784b1b5e", "patch": "@@ -1,29 +0,0 @@\n-// compile-flags: -C no-prepopulate-passes\n-\n-#![crate_type = \"lib\"]\n-\n-pub enum E {\n-    A,\n-    B,\n-}\n-\n-// CHECK-LABEL: @exhaustive_match\n-#[no_mangle]\n-pub fn exhaustive_match(e: E) -> u8 {\n-// CHECK: switch{{.*}}, label %[[OTHERWISE:[a-zA-Z0-9_]+]] [\n-// CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[A:[a-zA-Z0-9_]+]]\n-// CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[B:[a-zA-Z0-9_]+]]\n-// CHECK-NEXT: ]\n-// CHECK: [[OTHERWISE]]:\n-// CHECK-NEXT: unreachable\n-// CHECK: [[A]]:\n-// CHECK-NEXT: store i8 0, {{i8\\*|ptr}} %1, align 1\n-// CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n-// CHECK: [[B]]:\n-// CHECK-NEXT: store i8 1, {{i8\\*|ptr}} %1, align 1\n-// CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n-    match e {\n-        E::A => 0,\n-        E::B => 1,\n-    }\n-}"}]}