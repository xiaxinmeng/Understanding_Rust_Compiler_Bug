{"sha": "2364b58b870926a25e0ddc25573e345c8fe049e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNjRiNThiODcwOTI2YTI1ZTBkZGMyNTU3M2UzNDVjOGZlMDQ5ZTY=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-09-26T20:13:37Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-09-26T22:15:06Z"}, "message": "Update dataflow impls to reflect new interface", "tree": {"sha": "16e6aedbc69ad7665fa1c8538d55a05aa8161297", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16e6aedbc69ad7665fa1c8538d55a05aa8161297"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2364b58b870926a25e0ddc25573e345c8fe049e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2364b58b870926a25e0ddc25573e345c8fe049e6", "html_url": "https://github.com/rust-lang/rust/commit/2364b58b870926a25e0ddc25573e345c8fe049e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2364b58b870926a25e0ddc25573e345c8fe049e6/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43e6ef876f8d2aab6e7fe28c5d929686e81beac4", "url": "https://api.github.com/repos/rust-lang/rust/commits/43e6ef876f8d2aab6e7fe28c5d929686e81beac4", "html_url": "https://github.com/rust-lang/rust/commit/43e6ef876f8d2aab6e7fe28c5d929686e81beac4"}], "stats": {"total": 149, "additions": 116, "deletions": 33}, "files": [{"sha": "d4b9600f766f8b7583aebd961b74859633ba364f", "filename": "compiler/rustc_mir/src/dataflow/impls/mod.rs", "status": "modified", "additions": 116, "deletions": 33, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/2364b58b870926a25e0ddc25573e345c8fe049e6/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2364b58b870926a25e0ddc25573e345c8fe049e6/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs?ref=2364b58b870926a25e0ddc25573e345c8fe049e6", "patch": "@@ -6,7 +6,6 @@ use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, Body, Location};\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_target::abi::VariantIdx;\n \n use super::MoveDataParamEnv;\n \n@@ -19,6 +18,7 @@ use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;\n use super::on_lookup_result_bits;\n use crate::dataflow::drop_flag_effects;\n+use crate::dataflow::framework::SwitchIntEdgeEffects;\n \n mod borrowed_locals;\n pub(super) mod borrows;\n@@ -352,24 +352,46 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n         );\n     }\n \n-    fn discriminant_switch_effect(\n+    fn switch_int_edge_effects<G: GenKill<Self::Idx>>(\n         &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        _block: mir::BasicBlock,\n-        enum_place: mir::Place<'tcx>,\n-        _adt: &ty::AdtDef,\n-        variant: VariantIdx,\n+        block: mir::BasicBlock,\n+        discr: &mir::Operand<'tcx>,\n+        edge_effects: &mut impl SwitchIntEdgeEffects<G>,\n     ) {\n-        // Kill all move paths that correspond to variants we know to be inactive along this\n-        // particular outgoing edge of a `SwitchInt`.\n-        drop_flag_effects::on_all_inactive_variants(\n-            self.tcx,\n-            self.body,\n-            self.move_data(),\n-            enum_place,\n-            variant,\n-            |mpi| trans.kill(mpi),\n-        );\n+        let enum_ = discr.place().and_then(|discr| {\n+            switch_on_enum_discriminant(self.tcx, &self.body, &self.body[block], discr)\n+        });\n+\n+        let (enum_place, enum_def) = match enum_ {\n+            Some(x) => x,\n+            None => return,\n+        };\n+\n+        let mut discriminants = enum_def.discriminants(self.tcx);\n+        edge_effects.apply(|trans, edge| {\n+            let value = match edge.value {\n+                Some(x) => x,\n+                None => return,\n+            };\n+\n+            // MIR building adds discriminants to the `values` array in the same order as they\n+            // are yielded by `AdtDef::discriminants`. We rely on this to match each\n+            // discriminant in `values` to its corresponding variant in linear time.\n+            let (variant, _) = discriminants\n+                .find(|&(_, discr)| discr.val == value)\n+                .expect(\"Order of `AdtDef::discriminants` differed from `SwitchInt::values`\");\n+\n+            // Kill all move paths that correspond to variants we know to be inactive along this\n+            // particular outgoing edge of a `SwitchInt`.\n+            drop_flag_effects::on_all_inactive_variants(\n+                self.tcx,\n+                self.body,\n+                self.move_data(),\n+                enum_place,\n+                variant,\n+                |mpi| trans.kill(mpi),\n+            );\n+        });\n     }\n }\n \n@@ -441,28 +463,50 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n         );\n     }\n \n-    fn discriminant_switch_effect(\n+    fn switch_int_edge_effects<G: GenKill<Self::Idx>>(\n         &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        _block: mir::BasicBlock,\n-        enum_place: mir::Place<'tcx>,\n-        _adt: &ty::AdtDef,\n-        variant: VariantIdx,\n+        block: mir::BasicBlock,\n+        discr: &mir::Operand<'tcx>,\n+        edge_effects: &mut impl SwitchIntEdgeEffects<G>,\n     ) {\n         if !self.mark_inactive_variants_as_uninit {\n             return;\n         }\n \n-        // Mark all move paths that correspond to variants other than this one as maybe\n-        // uninitialized (in reality, they are *definitely* uninitialized).\n-        drop_flag_effects::on_all_inactive_variants(\n-            self.tcx,\n-            self.body,\n-            self.move_data(),\n-            enum_place,\n-            variant,\n-            |mpi| trans.gen(mpi),\n-        );\n+        let enum_ = discr.place().and_then(|discr| {\n+            switch_on_enum_discriminant(self.tcx, &self.body, &self.body[block], discr)\n+        });\n+\n+        let (enum_place, enum_def) = match enum_ {\n+            Some(x) => x,\n+            None => return,\n+        };\n+\n+        let mut discriminants = enum_def.discriminants(self.tcx);\n+        edge_effects.apply(|trans, edge| {\n+            let value = match edge.value {\n+                Some(x) => x,\n+                None => return,\n+            };\n+\n+            // MIR building adds discriminants to the `values` array in the same order as they\n+            // are yielded by `AdtDef::discriminants`. We rely on this to match each\n+            // discriminant in `values` to its corresponding variant in linear time.\n+            let (variant, _) = discriminants\n+                .find(|&(_, discr)| discr.val == value)\n+                .expect(\"Order of `AdtDef::discriminants` differed from `SwitchInt::values`\");\n+\n+            // Mark all move paths that correspond to variants other than this one as maybe\n+            // uninitialized (in reality, they are *definitely* uninitialized).\n+            drop_flag_effects::on_all_inactive_variants(\n+                self.tcx,\n+                self.body,\n+                self.move_data(),\n+                enum_place,\n+                variant,\n+                |mpi| trans.gen(mpi),\n+            );\n+        });\n     }\n }\n \n@@ -624,3 +668,42 @@ impl<'tcx> GenKillAnalysis<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n         }\n     }\n }\n+\n+/// Inspect a `SwitchInt`-terminated basic block to see if the condition of that `SwitchInt` is\n+/// an enum discriminant.\n+///\n+/// We expect such blocks to have a call to `discriminant` as their last statement like so:\n+///\n+/// ```text\n+/// ...\n+/// _42 = discriminant(_1)\n+/// SwitchInt(_42, ..)\n+/// ```\n+///\n+/// If the basic block matches this pattern, this function returns the place corresponding to the\n+/// enum (`_1` in the example above) as well as the `AdtDef` of that enum.\n+fn switch_on_enum_discriminant(\n+    tcx: TyCtxt<'tcx>,\n+    body: &'mir mir::Body<'tcx>,\n+    block: &'mir mir::BasicBlockData<'tcx>,\n+    switch_on: mir::Place<'tcx>,\n+) -> Option<(mir::Place<'tcx>, &'tcx ty::AdtDef)> {\n+    match block.statements.last().map(|stmt| &stmt.kind) {\n+        Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated))))\n+            if *lhs == switch_on =>\n+        {\n+            match &discriminated.ty(body, tcx).ty.kind() {\n+                ty::Adt(def, _) => Some((*discriminated, def)),\n+\n+                // `Rvalue::Discriminant` is also used to get the active yield point for a\n+                // generator, but we do not need edge-specific effects in that case. This may\n+                // change in the future.\n+                ty::Generator(..) => None,\n+\n+                t => bug!(\"`discriminant` called on unexpected type {:?}\", t),\n+            }\n+        }\n+\n+        _ => None,\n+    }\n+}"}]}