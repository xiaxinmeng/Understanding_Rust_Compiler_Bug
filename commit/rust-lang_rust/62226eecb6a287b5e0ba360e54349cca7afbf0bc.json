{"sha": "62226eecb6a287b5e0ba360e54349cca7afbf0bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMjI2ZWVjYjZhMjg3YjVlMGJhMzYwZTU0MzQ5Y2NhN2FmYmYwYmM=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-11-02T19:39:30Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-04-22T12:24:30Z"}, "message": "Improve BinaryHeap::retain.\n\nIt now doesn't fully rebuild the heap, but only the parts that are\nnecessary.", "tree": {"sha": "0865b6c6899ff955405b7c11d69baf4b7dd996fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0865b6c6899ff955405b7c11d69baf4b7dd996fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62226eecb6a287b5e0ba360e54349cca7afbf0bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62226eecb6a287b5e0ba360e54349cca7afbf0bc", "html_url": "https://github.com/rust-lang/rust/commit/62226eecb6a287b5e0ba360e54349cca7afbf0bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62226eecb6a287b5e0ba360e54349cca7afbf0bc/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88b99dec2a4d103b8153ca9300bf0fbebdf65bda", "url": "https://api.github.com/repos/rust-lang/rust/commits/88b99dec2a4d103b8153ca9300bf0fbebdf65bda", "html_url": "https://github.com/rust-lang/rust/commit/88b99dec2a4d103b8153ca9300bf0fbebdf65bda"}], "stats": {"total": 85, "additions": 53, "deletions": 32}, "files": [{"sha": "a201af0103070afa544b539b16b50ceb5fd90353", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 53, "deletions": 32, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/62226eecb6a287b5e0ba360e54349cca7afbf0bc/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62226eecb6a287b5e0ba360e54349cca7afbf0bc/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=62226eecb6a287b5e0ba360e54349cca7afbf0bc", "patch": "@@ -652,6 +652,43 @@ impl<T: Ord> BinaryHeap<T> {\n         unsafe { self.sift_up(start, pos) };\n     }\n \n+    /// Rebuild assuming data[0..start] is still a proper heap.\n+    fn rebuild_tail(&mut self, start: usize) {\n+        if start == self.len() {\n+            return;\n+        }\n+\n+        let tail_len = self.len() - start;\n+\n+        #[inline(always)]\n+        fn log2_fast(x: usize) -> usize {\n+            (usize::BITS - x.leading_zeros() - 1) as usize\n+        }\n+\n+        // `rebuild` takes O(self.len()) operations\n+        // and about 2 * self.len() comparisons in the worst case\n+        // while repeating `sift_up` takes O(tail_len * log(start)) operations\n+        // and about 1 * tail_len * log_2(start) comparisons in the worst case,\n+        // assuming start >= tail_len. For larger heaps, the crossover point\n+        // no longer follows this reasoning and was determined empirically.\n+        let better_to_rebuild = if start < tail_len {\n+            true\n+        } else if self.len() <= 2048 {\n+            2 * self.len() < tail_len * log2_fast(start)\n+        } else {\n+            2 * self.len() < tail_len * 11\n+        };\n+\n+        if better_to_rebuild {\n+            self.rebuild();\n+        } else {\n+            for i in start..self.len() {\n+                // SAFETY: The index `i` is always less than self.len().\n+                unsafe { self.sift_up(0, i) };\n+            }\n+        }\n+    }\n+\n     fn rebuild(&mut self) {\n         let mut n = self.len() / 2;\n         while n > 0 {\n@@ -689,37 +726,11 @@ impl<T: Ord> BinaryHeap<T> {\n             swap(self, other);\n         }\n \n-        if other.is_empty() {\n-            return;\n-        }\n-\n-        #[inline(always)]\n-        fn log2_fast(x: usize) -> usize {\n-            (usize::BITS - x.leading_zeros() - 1) as usize\n-        }\n+        let start = self.data.len();\n \n-        // `rebuild` takes O(len1 + len2) operations\n-        // and about 2 * (len1 + len2) comparisons in the worst case\n-        // while `extend` takes O(len2 * log(len1)) operations\n-        // and about 1 * len2 * log_2(len1) comparisons in the worst case,\n-        // assuming len1 >= len2. For larger heaps, the crossover point\n-        // no longer follows this reasoning and was determined empirically.\n-        #[inline]\n-        fn better_to_rebuild(len1: usize, len2: usize) -> bool {\n-            let tot_len = len1 + len2;\n-            if tot_len <= 2048 {\n-                2 * tot_len < len2 * log2_fast(len1)\n-            } else {\n-                2 * tot_len < len2 * 11\n-            }\n-        }\n+        self.data.append(&mut other.data);\n \n-        if better_to_rebuild(self.len(), other.len()) {\n-            self.data.append(&mut other.data);\n-            self.rebuild();\n-        } else {\n-            self.extend(other.drain());\n-        }\n+        self.rebuild_tail(start);\n     }\n \n     /// Returns an iterator which retrieves elements in heap order.\n@@ -770,12 +781,22 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.into_sorted_vec(), [-10, 2, 4])\n     /// ```\n     #[unstable(feature = \"binary_heap_retain\", issue = \"71503\")]\n-    pub fn retain<F>(&mut self, f: F)\n+    pub fn retain<F>(&mut self, mut f: F)\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        self.data.retain(f);\n-        self.rebuild();\n+        let mut first_removed = self.len();\n+        let mut i = 0;\n+        self.data.retain(|e| {\n+            let keep = f(e);\n+            if !keep && i < first_removed {\n+                first_removed = i;\n+            }\n+            i += 1;\n+            keep\n+        });\n+        // data[0..first_removed] is untouched, so we only need to rebuild the tail:\n+        self.rebuild_tail(first_removed);\n     }\n }\n "}]}