{"sha": "cab44fb076b4bc56a5877304a7b7617325cb8573", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYjQ0ZmIwNzZiNGJjNTZhNTg3NzMwNGE3Yjc2MTczMjVjYjg1NzM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-13T01:14:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-24T22:41:59Z"}, "message": "std: Introduce a Runtime trait\n\nThis trait is used to abstract the differences between 1:1 and M:N scheduling\nand is the sole dispatch point for the differences between these two scheduling\nmodes.\n\nThis, and the following series of commits, is not intended to compile. Only\nafter the entire transition is complete are programs expected to compile.", "tree": {"sha": "8fa176a9042a610bcbfbc2a9e910db97fb122310", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fa176a9042a610bcbfbc2a9e910db97fb122310"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cab44fb076b4bc56a5877304a7b7617325cb8573", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cab44fb076b4bc56a5877304a7b7617325cb8573", "html_url": "https://github.com/rust-lang/rust/commit/cab44fb076b4bc56a5877304a7b7617325cb8573", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cab44fb076b4bc56a5877304a7b7617325cb8573/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32e730f122f06202eb48aefcc2cef6ee3e279a2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/32e730f122f06202eb48aefcc2cef6ee3e279a2f", "html_url": "https://github.com/rust-lang/rust/commit/32e730f122f06202eb48aefcc2cef6ee3e279a2f"}], "stats": {"total": 294, "additions": 25, "deletions": 269}, "files": [{"sha": "be35e7579b7840474879b730e04135425f41b4f4", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 25, "deletions": 269, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/cab44fb076b4bc56a5877304a7b7617325cb8573/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab44fb076b4bc56a5877304a7b7617325cb8573/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=cab44fb076b4bc56a5877304a7b7617325cb8573", "patch": "@@ -185,41 +185,33 @@ pub mod args;\n // Support for dynamic borrowck\n pub mod borrowck;\n \n-/// Set up a default runtime configuration, given compiler-supplied arguments.\n-///\n-/// This is invoked by the `start` _language item_ (unstable::lang) to\n-/// run a Rust executable.\n-///\n-/// # Arguments\n-///\n-/// * `argc` & `argv` - The argument vector. On Unix this information is used\n-///   by os::args.\n-///\n-/// # Return value\n-///\n-/// The return value is used as the process return code. 0 on success, 101 on error.\n-pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n-\n-    init(argc, argv);\n-    let exit_code = run(main);\n-    // unsafe is ok b/c we're sure that the runtime is gone\n-    unsafe { cleanup(); }\n+/// The default error code of the rust runtime if the main task fails instead\n+/// of exiting cleanly.\n+pub static DEFAULT_ERROR_CODE: int = 101;\n \n-    return exit_code;\n-}\n-\n-/// Like `start` but creates an additional scheduler on the current thread,\n-/// which in most cases will be the 'main' thread, and pins the main task to it.\n+/// The interface to the current runtime.\n ///\n-/// This is appropriate for running code that must execute on the main thread,\n-/// such as the platform event loop and GUI.\n-pub fn start_on_main_thread(argc: int, argv: **u8, main: proc()) -> int {\n-    init(argc, argv);\n-    let exit_code = run_on_main_thread(main);\n-    // unsafe is ok b/c we're sure that the runtime is gone\n-    unsafe { cleanup(); }\n-\n-    return exit_code;\n+/// This trait is used as the abstraction between 1:1 and M:N scheduling. The\n+/// two independent crates, libnative and libgreen, both have objects which\n+/// implement this trait. The goal of this trait is to encompass all the\n+/// fundamental differences in functionality between the 1:1 and M:N runtime\n+/// modes.\n+pub trait Runtime {\n+    // Necessary scheduling functions, used for channels and blocking I/O\n+    // (sometimes).\n+    fn yield_now(~self, cur_task: ~Task);\n+    fn maybe_yield(~self, cur_task: ~Task);\n+    fn deschedule(~self, times: uint, cur_task: ~Task,\n+                  f: |BlockedTask| -> Result<(), BlockedTask>);\n+    fn reawaken(~self, to_wake: ~Task, can_resched: bool);\n+\n+    // Miscellaneous calls which are very different depending on what context\n+    // you're in.\n+    fn spawn_sibling(~self, cur_task: ~Task, opts: TaskOpts, f: proc());\n+    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;\n+\n+    // XXX: This is a serious code smell and this should not exist at all.\n+    fn wrap(~self) -> ~Any;\n }\n \n /// One-time runtime initialization.\n@@ -250,239 +242,3 @@ pub unsafe fn cleanup() {\n     args::cleanup();\n     local_ptr::cleanup();\n }\n-\n-/// Execute the main function in a scheduler.\n-///\n-/// Configures the runtime according to the environment, by default\n-/// using a task scheduler with the same number of threads as cores.\n-/// Returns a process exit code.\n-pub fn run(main: proc()) -> int {\n-    run_(main, false)\n-}\n-\n-pub fn run_on_main_thread(main: proc()) -> int {\n-    run_(main, true)\n-}\n-\n-fn run_(main: proc(), use_main_sched: bool) -> int {\n-    static DEFAULT_ERROR_CODE: int = 101;\n-\n-    let nscheds = util::default_sched_threads();\n-\n-    let mut main = Some(main);\n-\n-    // The shared list of sleeping schedulers.\n-    let sleepers = SleeperList::new();\n-\n-    // Create a work queue for each scheduler, ntimes. Create an extra\n-    // for the main thread if that flag is set. We won't steal from it.\n-    let mut pool = deque::BufferPool::new();\n-    let arr = vec::from_fn(nscheds, |_| pool.deque());\n-    let (workers, stealers) = vec::unzip(arr.move_iter());\n-\n-    // The schedulers.\n-    let mut scheds = ~[];\n-    // Handles to the schedulers. When the main task ends these will be\n-    // sent the Shutdown message to terminate the schedulers.\n-    let mut handles = ~[];\n-\n-    for worker in workers.move_iter() {\n-        rtdebug!(\"inserting a regular scheduler\");\n-\n-        // Every scheduler is driven by an I/O event loop.\n-        let loop_ = new_event_loop();\n-        let mut sched = ~Scheduler::new(loop_,\n-                                        worker,\n-                                        stealers.clone(),\n-                                        sleepers.clone());\n-        let handle = sched.make_handle();\n-\n-        scheds.push(sched);\n-        handles.push(handle);\n-    }\n-\n-    // If we need a main-thread task then create a main thread scheduler\n-    // that will reject any task that isn't pinned to it\n-    let main_sched = if use_main_sched {\n-\n-        // Create a friend handle.\n-        let mut friend_sched = scheds.pop();\n-        let friend_handle = friend_sched.make_handle();\n-        scheds.push(friend_sched);\n-\n-        // This scheduler needs a queue that isn't part of the stealee\n-        // set.\n-        let (worker, _) = pool.deque();\n-\n-        let main_loop = new_event_loop();\n-        let mut main_sched = ~Scheduler::new_special(main_loop,\n-                                                     worker,\n-                                                     stealers.clone(),\n-                                                     sleepers.clone(),\n-                                                     false,\n-                                                     Some(friend_handle));\n-        let mut main_handle = main_sched.make_handle();\n-        // Allow the scheduler to exit when the main task exits.\n-        // Note: sending the shutdown message also prevents the scheduler\n-        // from pushing itself to the sleeper list, which is used for\n-        // waking up schedulers for work stealing; since this is a\n-        // non-work-stealing scheduler it should not be adding itself\n-        // to the list.\n-        main_handle.send(Shutdown);\n-        Some(main_sched)\n-    } else {\n-        None\n-    };\n-\n-    // Create a shared cell for transmitting the process exit\n-    // code from the main task to this function.\n-    let exit_code = UnsafeArc::new(AtomicInt::new(0));\n-    let exit_code_clone = exit_code.clone();\n-\n-    // Used to sanity check that the runtime only exits once\n-    let exited_already = UnsafeArc::new(AtomicBool::new(false));\n-\n-    // When the main task exits, after all the tasks in the main\n-    // task tree, shut down the schedulers and set the exit code.\n-    let handles = handles;\n-    let on_exit: proc(TaskResult) = proc(exit_success) {\n-        unsafe {\n-            assert!(!(*exited_already.get()).swap(true, SeqCst),\n-                    \"the runtime already exited\");\n-        }\n-\n-        let mut handles = handles;\n-        for handle in handles.mut_iter() {\n-            handle.send(Shutdown);\n-        }\n-\n-        unsafe {\n-            let exit_code = if exit_success.is_ok() {\n-                use rt::util;\n-\n-                // If we're exiting successfully, then return the global\n-                // exit status, which can be set programmatically.\n-                util::get_exit_status()\n-            } else {\n-                DEFAULT_ERROR_CODE\n-            };\n-            (*exit_code_clone.get()).store(exit_code, SeqCst);\n-        }\n-    };\n-\n-    let mut threads = ~[];\n-    let mut on_exit = Some(on_exit);\n-\n-    if !use_main_sched {\n-\n-        // In the case where we do not use a main_thread scheduler we\n-        // run the main task in one of our threads.\n-\n-        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n-                                            None,\n-                                            ::util::replace(&mut main,\n-                                                            None).unwrap());\n-        main_task.name = Some(SendStrStatic(\"<main>\"));\n-        main_task.death.on_exit = ::util::replace(&mut on_exit, None);\n-\n-        let sched = scheds.pop();\n-        let main_task = main_task;\n-        let thread = do Thread::start {\n-            sched.bootstrap(main_task);\n-        };\n-        threads.push(thread);\n-    }\n-\n-    // Run each remaining scheduler in a thread.\n-    for sched in scheds.move_rev_iter() {\n-        rtdebug!(\"creating regular schedulers\");\n-        let thread = do Thread::start {\n-            let mut sched = sched;\n-            let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool, None) || {\n-                rtdebug!(\"boostraping a non-primary scheduler\");\n-            };\n-            sched.bootstrap(bootstrap_task);\n-        };\n-        threads.push(thread);\n-    }\n-\n-    // If we do have a main thread scheduler, run it now.\n-\n-    if use_main_sched {\n-        rtdebug!(\"about to create the main scheduler task\");\n-\n-        let mut main_sched = main_sched.unwrap();\n-\n-        let home = Sched(main_sched.make_handle());\n-        let mut main_task = ~Task::new_root_homed(&mut main_sched.stack_pool,\n-                                                  None,\n-                                                  home,\n-                                                  ::util::replace(&mut main,\n-                                                                  None).\n-                                                                  unwrap());\n-        main_task.name = Some(SendStrStatic(\"<main>\"));\n-        main_task.death.on_exit = ::util::replace(&mut on_exit, None);\n-        rtdebug!(\"bootstrapping main_task\");\n-\n-        main_sched.bootstrap(main_task);\n-    }\n-\n-    rtdebug!(\"waiting for threads\");\n-\n-    // Wait for schedulers\n-    for thread in threads.move_iter() {\n-        thread.join();\n-    }\n-\n-    // Return the exit code\n-    unsafe {\n-        (*exit_code.get()).load(SeqCst)\n-    }\n-}\n-\n-pub fn in_sched_context() -> bool {\n-    unsafe {\n-        let task_ptr: Option<*mut Task> = Local::try_unsafe_borrow();\n-        match task_ptr {\n-            Some(task) => {\n-                match (*task).task_type {\n-                    SchedTask => true,\n-                    _ => false\n-                }\n-            }\n-            None => false\n-        }\n-    }\n-}\n-\n-pub fn in_green_task_context() -> bool {\n-    unsafe {\n-        let task: Option<*mut Task> = Local::try_unsafe_borrow();\n-        match task {\n-            Some(task) => {\n-                match (*task).task_type {\n-                    GreenTask(_) => true,\n-                    _ => false\n-                }\n-            }\n-            None => false\n-        }\n-    }\n-}\n-\n-pub fn new_event_loop() -> ~rtio::EventLoop {\n-    match crate_map::get_crate_map() {\n-        None => {}\n-        Some(map) => {\n-            match map.event_loop_factory {\n-                None => {}\n-                Some(factory) => return factory()\n-            }\n-        }\n-    }\n-\n-    // If the crate map didn't specify a factory to create an event loop, then\n-    // instead just use a basic event loop missing all I/O services to at least\n-    // get the scheduler running.\n-    return basic::event_loop();\n-}"}]}