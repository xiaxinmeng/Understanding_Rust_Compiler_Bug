{"sha": "ec547202b4fa11cd351b29d076391d2913364fc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNTQ3MjAyYjRmYTExY2QzNTFiMjlkMDc2MzkxZDI5MTMzNjRmYzY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-11-18T22:51:52Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-11-19T16:25:20Z"}, "message": "expand: Cleanup attribute collection in invocation collector", "tree": {"sha": "7ad84f1eba6f1e7dad4b1d10338cce20a8aec785", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ad84f1eba6f1e7dad4b1d10338cce20a8aec785"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec547202b4fa11cd351b29d076391d2913364fc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec547202b4fa11cd351b29d076391d2913364fc6", "html_url": "https://github.com/rust-lang/rust/commit/ec547202b4fa11cd351b29d076391d2913364fc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec547202b4fa11cd351b29d076391d2913364fc6/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfb690eaa93fabc6a61b24f2a8e4ad7f2c3689a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfb690eaa93fabc6a61b24f2a8e4ad7f2c3689a7", "html_url": "https://github.com/rust-lang/rust/commit/dfb690eaa93fabc6a61b24f2a8e4ad7f2c3689a7"}], "stats": {"total": 180, "additions": 39, "deletions": 141}, "files": [{"sha": "22334a63988dc7c9e284a197db227fd19bd0e361", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 39, "deletions": 141, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/ec547202b4fa11cd351b29d076391d2913364fc6/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec547202b4fa11cd351b29d076391d2913364fc6/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=ec547202b4fa11cd351b29d076391d2913364fc6", "patch": "@@ -1016,11 +1016,9 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(\n         &mut self,\n-        attr: Option<ast::Attribute>,\n-        derives: Vec<Path>,\n+        (attr, derives, after_derive): (Option<ast::Attribute>, Vec<Path>, bool),\n         item: Annotatable,\n         kind: AstFragmentKind,\n-        after_derive: bool,\n     ) -> AstFragment {\n         self.collect(\n             kind,\n@@ -1048,34 +1046,34 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n \n     /// If `item` is an attr invocation, remove and return the macro attribute and derive traits.\n-    fn classify_item(\n+    fn take_first_attr(\n         &mut self,\n         item: &mut impl HasAttrs,\n-    ) -> (Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool) {\n+    ) -> Option<(Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool)> {\n         let (mut attr, mut traits, mut after_derive) = (None, Vec::new(), false);\n \n         item.visit_attrs(|mut attrs| {\n             attr = self.find_attr_invoc(&mut attrs, &mut after_derive);\n             traits = collect_derives(&mut self.cx, &mut attrs);\n         });\n \n-        (attr, traits, after_derive)\n+        if attr.is_some() || !traits.is_empty() { Some((attr, traits, after_derive)) } else { None }\n     }\n \n-    /// Alternative to `classify_item()` that ignores `#[derive]` so invocations fallthrough\n+    /// Alternative to `take_first_attr()` that ignores `#[derive]` so invocations fallthrough\n     /// to the unused-attributes lint (making it an error on statements and expressions\n     /// is a breaking change)\n-    fn classify_nonitem(\n+    fn take_first_attr_no_derive(\n         &mut self,\n         nonitem: &mut impl HasAttrs,\n-    ) -> (Option<ast::Attribute>, /* after_derive */ bool) {\n+    ) -> Option<(Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool)> {\n         let (mut attr, mut after_derive) = (None, false);\n \n         nonitem.visit_attrs(|mut attrs| {\n             attr = self.find_attr_invoc(&mut attrs, &mut after_derive);\n         });\n \n-        (attr, after_derive)\n+        attr.map(|attr| (Some(attr), Vec::new(), after_derive))\n     }\n \n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n@@ -1119,23 +1117,14 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         visit_clobber(expr.deref_mut(), |mut expr| {\n             self.cfg.configure_expr_kind(&mut expr.kind);\n \n-            // ignore derives so they remain unused\n-            let (attr, after_derive) = self.classify_nonitem(&mut expr);\n-\n-            if let Some(ref attr_value) = attr {\n+            if let Some(attr) = self.take_first_attr_no_derive(&mut expr) {\n                 // Collect the invoc regardless of whether or not attributes are permitted here\n                 // expansion will eat the attribute so it won't error later.\n-                self.cfg.maybe_emit_expr_attr_err(attr_value);\n+                attr.0.as_ref().map(|attr| self.cfg.maybe_emit_expr_attr_err(attr));\n \n                 // AstFragmentKind::Expr requires the macro to emit an expression.\n                 return self\n-                    .collect_attr(\n-                        attr,\n-                        vec![],\n-                        Annotatable::Expr(P(expr)),\n-                        AstFragmentKind::Expr,\n-                        after_derive,\n-                    )\n+                    .collect_attr(attr, Annotatable::Expr(P(expr)), AstFragmentKind::Expr)\n                     .make_expr()\n                     .into_inner();\n             }\n@@ -1153,16 +1142,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_arm(&mut self, arm: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n         let mut arm = configure!(self, arm);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut arm);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut arm) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Arm(arm),\n-                    AstFragmentKind::Arms,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Arm(arm), AstFragmentKind::Arms)\n                 .make_arms();\n         }\n \n@@ -1172,16 +1154,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_field(&mut self, field: ast::Field) -> SmallVec<[ast::Field; 1]> {\n         let mut field = configure!(self, field);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut field);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut field) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Field(field),\n-                    AstFragmentKind::Fields,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Field(field), AstFragmentKind::Fields)\n                 .make_fields();\n         }\n \n@@ -1191,16 +1166,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_field_pattern(&mut self, fp: ast::FieldPat) -> SmallVec<[ast::FieldPat; 1]> {\n         let mut fp = configure!(self, fp);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut fp);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut fp) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::FieldPat(fp),\n-                    AstFragmentKind::FieldPats,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::FieldPat(fp), AstFragmentKind::FieldPats)\n                 .make_field_patterns();\n         }\n \n@@ -1210,16 +1178,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_param(&mut self, p: ast::Param) -> SmallVec<[ast::Param; 1]> {\n         let mut p = configure!(self, p);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut p);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut p) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Param(p),\n-                    AstFragmentKind::Params,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Param(p), AstFragmentKind::Params)\n                 .make_params();\n         }\n \n@@ -1229,16 +1190,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_struct_field(&mut self, sf: ast::StructField) -> SmallVec<[ast::StructField; 1]> {\n         let mut sf = configure!(self, sf);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut sf);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut sf) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::StructField(sf),\n-                    AstFragmentKind::StructFields,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::StructField(sf), AstFragmentKind::StructFields)\n                 .make_struct_fields();\n         }\n \n@@ -1248,16 +1202,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_variant(&mut self, variant: ast::Variant) -> SmallVec<[ast::Variant; 1]> {\n         let mut variant = configure!(self, variant);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut variant);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut variant) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Variant(variant),\n-                    AstFragmentKind::Variants,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Variant(variant), AstFragmentKind::Variants)\n                 .make_variants();\n         }\n \n@@ -1269,20 +1216,11 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         expr.filter_map(|mut expr| {\n             self.cfg.configure_expr_kind(&mut expr.kind);\n \n-            // Ignore derives so they remain unused.\n-            let (attr, after_derive) = self.classify_nonitem(&mut expr);\n-\n-            if let Some(ref attr_value) = attr {\n-                self.cfg.maybe_emit_expr_attr_err(attr_value);\n+            if let Some(attr) = self.take_first_attr_no_derive(&mut expr) {\n+                attr.0.as_ref().map(|attr| self.cfg.maybe_emit_expr_attr_err(attr));\n \n                 return self\n-                    .collect_attr(\n-                        attr,\n-                        vec![],\n-                        Annotatable::Expr(P(expr)),\n-                        AstFragmentKind::OptExpr,\n-                        after_derive,\n-                    )\n+                    .collect_attr(attr, Annotatable::Expr(P(expr)), AstFragmentKind::OptExpr)\n                     .make_opt_expr()\n                     .map(|expr| expr.into_inner());\n             }\n@@ -1321,25 +1259,13 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n \n         // we'll expand attributes on expressions separately\n         if !stmt.is_expr() {\n-            let (attr, derives, after_derive) = if stmt.is_item() {\n-                // FIXME: Handle custom attributes on statements (#15701)\n-                (None, vec![], false)\n-            } else {\n-                // ignore derives on non-item statements so it falls through\n-                // to the unused-attributes lint\n-                let (attr, after_derive) = self.classify_nonitem(&mut stmt);\n-                (attr, vec![], after_derive)\n-            };\n+            // FIXME: Handle custom attributes on statements (#15701).\n+            let attr =\n+                if stmt.is_item() { None } else { self.take_first_attr_no_derive(&mut stmt) };\n \n-            if attr.is_some() || !derives.is_empty() {\n+            if let Some(attr) = attr {\n                 return self\n-                    .collect_attr(\n-                        attr,\n-                        derives,\n-                        Annotatable::Stmt(P(stmt)),\n-                        AstFragmentKind::Stmts,\n-                        after_derive,\n-                    )\n+                    .collect_attr(attr, Annotatable::Stmt(P(stmt)), AstFragmentKind::Stmts)\n                     .make_stmts();\n             }\n         }\n@@ -1379,16 +1305,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let mut item = configure!(self, item);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut item);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut item) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Item(item),\n-                    AstFragmentKind::Items,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Item(item), AstFragmentKind::Items)\n                 .make_items();\n         }\n \n@@ -1482,16 +1401,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n         let mut item = configure!(self, item);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut item);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut item) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::TraitItem(item),\n-                    AstFragmentKind::TraitItems,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::TraitItem(item), AstFragmentKind::TraitItems)\n                 .make_trait_items();\n         }\n \n@@ -1512,16 +1424,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n         let mut item = configure!(self, item);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut item);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut item) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::ImplItem(item),\n-                    AstFragmentKind::ImplItems,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::ImplItem(item), AstFragmentKind::ImplItems)\n                 .make_impl_items();\n         }\n \n@@ -1562,16 +1467,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         &mut self,\n         mut foreign_item: P<ast::ForeignItem>,\n     ) -> SmallVec<[P<ast::ForeignItem>; 1]> {\n-        let (attr, traits, after_derive) = self.classify_item(&mut foreign_item);\n-\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut foreign_item) {\n             return self\n                 .collect_attr(\n                     attr,\n-                    traits,\n                     Annotatable::ForeignItem(foreign_item),\n                     AstFragmentKind::ForeignItems,\n-                    after_derive,\n                 )\n                 .make_foreign_items();\n         }\n@@ -1606,15 +1507,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     ) -> SmallVec<[ast::GenericParam; 1]> {\n         let mut param = configure!(self, param);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut param);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut param) {\n             return self\n                 .collect_attr(\n                     attr,\n-                    traits,\n                     Annotatable::GenericParam(param),\n                     AstFragmentKind::GenericParams,\n-                    after_derive,\n                 )\n                 .make_generic_params();\n         }"}]}