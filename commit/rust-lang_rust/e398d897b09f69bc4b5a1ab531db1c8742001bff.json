{"sha": "e398d897b09f69bc4b5a1ab531db1c8742001bff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzOThkODk3YjA5ZjY5YmM0YjVhMWFiNTMxZGIxYzg3NDIwMDFiZmY=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-12T14:51:59Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-12T15:02:00Z"}, "message": "Move NonExhaustive checks to the relevant match branches", "tree": {"sha": "297353d9f1049043fe6bc674c3ef423347216bb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/297353d9f1049043fe6bc674c3ef423347216bb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e398d897b09f69bc4b5a1ab531db1c8742001bff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e398d897b09f69bc4b5a1ab531db1c8742001bff", "html_url": "https://github.com/rust-lang/rust/commit/e398d897b09f69bc4b5a1ab531db1c8742001bff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e398d897b09f69bc4b5a1ab531db1c8742001bff/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "357d53c4ce6eed4d93fe1ed576613687d34d10b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/357d53c4ce6eed4d93fe1ed576613687d34d10b2", "html_url": "https://github.com/rust-lang/rust/commit/357d53c4ce6eed4d93fe1ed576613687d34d10b2"}], "stats": {"total": 105, "additions": 54, "deletions": 51}, "files": [{"sha": "8e574cc961b2b0d5ae9b4cdc2800f1e8cf72cdb1", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 54, "deletions": 51, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e398d897b09f69bc4b5a1ab531db1c8742001bff/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e398d897b09f69bc4b5a1ab531db1c8742001bff/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=e398d897b09f69bc4b5a1ab531db1c8742001bff", "patch": "@@ -560,13 +560,6 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn is_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n-        match ty.kind {\n-            ty::Adt(adt_def, ..) => adt_def.is_variant_list_non_exhaustive(),\n-            _ => false,\n-        }\n-    }\n-\n     fn is_local(&self, ty: Ty<'tcx>) -> bool {\n         match ty.kind {\n             ty::Adt(adt_def, ..) => adt_def.did.is_local(),\n@@ -1133,7 +1126,7 @@ fn all_constructors<'a, 'tcx>(\n     pcx: PatCtxt<'tcx>,\n ) -> Vec<Constructor<'tcx>> {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n-    let ctors = match pcx.ty.kind {\n+    match pcx.ty.kind {\n         ty::Bool => [true, false]\n             .iter()\n             .map(|&b| ConstantValue(ty::Const::from_bool(cx.tcx, b), pcx.span))\n@@ -1150,17 +1143,49 @@ fn all_constructors<'a, 'tcx>(\n                 vec![VarLenSlice(0, 0)]\n             }\n         }\n-        ty::Adt(def, substs) if def.is_enum() => def\n-            .variants\n-            .iter()\n-            .filter(|v| {\n-                !cx.tcx.features().exhaustive_patterns\n-                    || !v\n-                        .uninhabited_from(cx.tcx, substs, def.adt_kind())\n-                        .contains(cx.tcx, cx.module)\n-            })\n-            .map(|v| Variant(v.def_id))\n-            .collect(),\n+        ty::Adt(def, substs) if def.is_enum() => {\n+            let ctors: Vec<_> = def\n+                .variants\n+                .iter()\n+                .filter(|v| {\n+                    !cx.tcx.features().exhaustive_patterns\n+                        || !v\n+                            .uninhabited_from(cx.tcx, substs, def.adt_kind())\n+                            .contains(cx.tcx, cx.module)\n+                })\n+                .map(|v| Variant(v.def_id))\n+                .collect();\n+\n+            // If our scrutinee is *privately* an empty enum, we must treat it as though it had an\n+            // \"unknown\" constructor (in that case, all other patterns obviously can't be variants)\n+            // to avoid exposing its emptyness. See the `match_privately_empty` test for details.\n+            // FIXME: currently the only way I know of something can be a privately-empty enum is\n+            // when the exhaustive_patterns feature flag is not present, so this is only needed for\n+            // that case.\n+            let is_privately_empty = ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n+            // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n+            // additionnal \"unknown\" constructor.\n+            let is_declared_nonexhaustive =\n+                def.is_variant_list_non_exhaustive() && !cx.is_local(pcx.ty);\n+\n+            if is_privately_empty || is_declared_nonexhaustive {\n+                // There is no point in enumerating all possible variants, because the user can't\n+                // actually match against them themselves. So we return only the fictitious\n+                // constructor.\n+                // E.g., in an example like:\n+                // ```\n+                //     let err: io::ErrorKind = ...;\n+                //     match err {\n+                //         io::ErrorKind::NotFound => {},\n+                //     }\n+                // ```\n+                // we don't want to show every possible IO error, but instead have only `_` as the\n+                // witness.\n+                vec![NonExhaustive]\n+            } else {\n+                ctors\n+            }\n+        }\n         ty::Char => {\n             vec![\n                 // The valid Unicode Scalar Value ranges.\n@@ -1180,6 +1205,15 @@ fn all_constructors<'a, 'tcx>(\n                 ),\n             ]\n         }\n+        ty::Int(_) | ty::Uint(_)\n+            if pcx.ty.is_ptr_sized_integral()\n+                && !cx.tcx.features().precise_pointer_size_matching =>\n+        {\n+            // `usize`/`isize` are not allowed to be matched exhaustively unless the\n+            // `precise_pointer_size_matching` feature is enabled. So we treat those types like\n+            // `#[non_exhaustive]` enums by returning a special unmatcheable constructor.\n+            vec![NonExhaustive]\n+        }\n         ty::Int(ity) => {\n             let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n@@ -1198,38 +1232,7 @@ fn all_constructors<'a, 'tcx>(\n                 vec![Single]\n             }\n         }\n-    };\n-\n-    // FIXME: currently the only way I know of something can\n-    // be a privately-empty enum is when the exhaustive_patterns\n-    // feature flag is not present, so this is only\n-    // needed for that case.\n-    let is_privately_empty = ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n-    let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n-    let is_non_exhaustive = is_privately_empty\n-        || is_declared_nonexhaustive\n-        || (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n-    if is_non_exhaustive {\n-        // If our scrutinee is *privately* an empty enum, we must treat it as though it had an\n-        // \"unknown\" constructor (in that case, all other patterns obviously can't be variants) to\n-        // avoid exposing its emptyness. See the `match_privately_empty` test for details.\n-        //\n-        // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an additionnal\n-        // \"unknown\" constructor. However there is no point in enumerating all possible variants,\n-        // because the user can't actually match against them themselves. So we return only the\n-        // fictitious constructor.\n-        // E.g., in an example like:\n-        // ```\n-        //     let err: io::ErrorKind = ...;\n-        //     match err {\n-        //         io::ErrorKind::NotFound => {},\n-        //     }\n-        // ```\n-        // we don't want to show every possible IO error, but instead have only `_` as the witness.\n-        return vec![NonExhaustive];\n-    }\n-\n-    ctors\n+    }\n }\n \n /// An inclusive interval, used for precise integer exhaustiveness checking."}]}