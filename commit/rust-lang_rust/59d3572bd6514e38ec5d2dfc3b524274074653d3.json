{"sha": "59d3572bd6514e38ec5d2dfc3b524274074653d3", "node_id": "C_kwDOAAsO6NoAKDU5ZDM1NzJiZDY1MTRlMzhlYzVkMmRmYzNiNTI0Mjc0MDc0NjUzZDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-15T21:53:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-15T21:53:07Z"}, "message": "Auto merge of #2758 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "c57813bd1e93312f265ead2df13e5a9f885b17e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c57813bd1e93312f265ead2df13e5a9f885b17e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59d3572bd6514e38ec5d2dfc3b524274074653d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59d3572bd6514e38ec5d2dfc3b524274074653d3", "html_url": "https://github.com/rust-lang/rust/commit/59d3572bd6514e38ec5d2dfc3b524274074653d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59d3572bd6514e38ec5d2dfc3b524274074653d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd952c8c694c28b9bb95a5d98c90186381e225c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd952c8c694c28b9bb95a5d98c90186381e225c2", "html_url": "https://github.com/rust-lang/rust/commit/cd952c8c694c28b9bb95a5d98c90186381e225c2"}, {"sha": "b23795229781a2125fade078fa610bc47cc75b16", "url": "https://api.github.com/repos/rust-lang/rust/commits/b23795229781a2125fade078fa610bc47cc75b16", "html_url": "https://github.com/rust-lang/rust/commit/b23795229781a2125fade078fa610bc47cc75b16"}], "stats": {"total": 6126, "additions": 4613, "deletions": 1513}, "files": [{"sha": "d20f19e60e86033722853348908ff38b73898ac4", "filename": ".git-blame-ignore-revs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/.git-blame-ignore-revs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/.git-blame-ignore-revs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.git-blame-ignore-revs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -8,3 +8,5 @@ a06baa56b95674fc626b3c3fd680d6a65357fe60\n 283abbf0e7d20176f76006825b5c52e9a4234e4c\n # format libstd/sys\n c34fbfaad38cf5829ef5cfe780dc9d58480adeaa\n+# move tests\n+cf2dff2b1e3fa55fa5415d524200070d0d7aacfe"}, {"sha": "a7b70cea927d0c3b41bbcb4b0cee906be469d192", "filename": ".github/ISSUE_TEMPLATE/diagnostics.md", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cd952c8c694c28b9bb95a5d98c90186381e225c2/.github%2FISSUE_TEMPLATE%2Fdiagnostics.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd952c8c694c28b9bb95a5d98c90186381e225c2/.github%2FISSUE_TEMPLATE%2Fdiagnostics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fdiagnostics.md?ref=cd952c8c694c28b9bb95a5d98c90186381e225c2", "patch": "@@ -1,46 +0,0 @@\n----\n-name: Diagnostic issue\n-about: Create a bug report or feature request for a change to `rustc`'s error output\n-labels: A-diagnostics, T-compiler\n----\n-<!--\n-Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\n-along with any information you feel relevant to replicating the bug.\n-\n-If you cannot produce a minimal reproduction case (something that would work in\n-isolation), please provide the steps or even link to a repository that causes\n-the problematic output to occur.\n--->\n-\n-Given the following code: <!-- Please provide a link to play.rust-lang.org -->\n-\n-```rust\n-<code>\n-```\n-\n-The current output is:\n-\n-```\n-<rustc output>\n-```\n-\n-<!-- The following is not always necessary. -->\n-Ideally the output should look like:\n-\n-```\n-<proposed output>\n-```\n-\n-<!--\n-If the problem is not self-explanatory, please provide a rationale for the\n-change.\n--->\n-\n-<!--\n-If dramatically different output is caused by small changes, consider also\n-adding them here.\n-\n-If you're using the stable version of the compiler, you should also check if the\n-bug also exists in the beta or nightly versions. The output might also be\n-different depending on the Edition.\n--->"}, {"sha": "873fbaaf654fd15a28a131f069144243523eb5fa", "filename": ".github/ISSUE_TEMPLATE/diagnostics.yaml", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/.github%2FISSUE_TEMPLATE%2Fdiagnostics.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/.github%2FISSUE_TEMPLATE%2Fdiagnostics.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fdiagnostics.yaml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,65 @@\n+name: Diagnostic issue\n+description: Create a bug report or feature request for a change to `rustc`'s error output\n+labels: [\"A-diagnostics\", \"T-compiler\"]\n+body:\n+  - type: markdown\n+    attributes:\n+      value: |\n+        Thank you for filing a diagnostics bug report! \ud83d\udc1b\n+\n+        Please provide a short summary of the bug, along with any information you feel relevant to replicating the bug.\n+\n+        If you cannot produce a minimal reproduction case (something that would work in isolation), please provide the steps or even link to a repository that causes the problematic output to occur.\n+  - type: textarea\n+    id: code\n+    attributes:\n+      label: Code\n+      description: Please provide code that can reproduce the problem\n+      placeholder: code\n+      render: Rust\n+    validations:\n+      required: true\n+  - type: textarea\n+    id: output\n+    attributes:\n+      label: Current output\n+      description: Please provide the `rustc` output you see\n+      placeholder: rustc output\n+      render: Shell\n+    validations:\n+      required: true\n+  - type: textarea\n+    id: desired-output\n+    attributes:\n+      label: Desired output\n+      description: Please provide what the output *should* be\n+      placeholder: proposed output\n+      render: Shell\n+    validations:\n+      required: false\n+  - type: textarea\n+    id: rationale\n+    attributes:\n+      label: Rationale and extra context\n+      description: If the problem is not self-explanatory, please provide a rationale for the change.\n+    validations:\n+      required: false\n+  - type: textarea\n+    id: other-output\n+    attributes:\n+      label: Other cases\n+      description: If dramatically different output is caused by small changes, consider also adding them here.\n+      render: Rust\n+    validations:\n+      required: false\n+  - type: markdown\n+    attributes:\n+      value: |\n+        If you're using the stable version of the compiler, you should also check if the bug also exists in the beta or nightly versions. The output might also be different depending on the Edition.\n+  - type: textarea\n+    id: extra\n+    attributes:\n+      label: Anything else?\n+      description: If you have more details you want to give us to reproduce this issue, please add it here\n+    validations:\n+      required: false\n\\ No newline at end of file"}, {"sha": "9ccda17a6ef47e41bc8cb41b906769b49c0d4cdf", "filename": ".github/ISSUE_TEMPLATE/documentation.md", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cd952c8c694c28b9bb95a5d98c90186381e225c2/.github%2FISSUE_TEMPLATE%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd952c8c694c28b9bb95a5d98c90186381e225c2/.github%2FISSUE_TEMPLATE%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fdocumentation.md?ref=cd952c8c694c28b9bb95a5d98c90186381e225c2", "patch": "@@ -1,31 +0,0 @@\n----\n-name: Documentation problem\n-about: Create a report for a documentation problem.\n-labels: A-docs\n----\n-<!--\n-\n-Thank you for finding a documentation problem! \ud83d\udcda\n-\n-Documentation problems might be grammatical issues, typos, or unclear wording, please provide details regarding the documentation including where it is present.\n-\n-Note: If your issue is for one of these, please use their dedicated issue tracker instead:\n-\n-- The Rust Book: https://github.com/rust-lang/book/issues\n-- Rust by Example: https://github.com/rust-lang/rust-by-example/issues\n-- The Edition Guide: https://github.com/rust-lang/edition-guide/issues\n-- The Cargo Book: https://github.com/rust-lang/cargo/issues\n-- The Clippy Book: https://github.com/rust-lang/rust-clippy/issues\n-- The Reference: https://github.com/rust-lang/reference/issues\n-- The Rustonomicon: https://github.com/rust-lang/nomicon/issues\n-- The Embedded Book: https://github.com/rust-embedded/book/issues\n-\n-All other documentation issues should be filed here.\n-\n-Or, if you find an issue related to rustdoc (e.g. doctest, rustdoc UI), please use the bug report or blank issue template instead.\n-\n--->\n-\n-### Location\n-\n-### Summary"}, {"sha": "712b32759ae01427d087a47bed286643d6ada6fb", "filename": ".github/ISSUE_TEMPLATE/documentation.yaml", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/.github%2FISSUE_TEMPLATE%2Fdocumentation.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/.github%2FISSUE_TEMPLATE%2Fdocumentation.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fdocumentation.yaml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,38 @@\n+name: Documentation problem\n+description: Create a report for a documentation problem.\n+labels: [\"A-docs\"]\n+body:\n+  - type: markdown\n+    attributes:\n+      value: |\n+        Thank you for finding a documentation problem! \ud83d\udcda\n+\n+        Documentation problems might be grammatical issues, typos, or unclear wording, please provide details regarding the documentation including where it is present.\n+\n+        Note: If your issue is for one of these, please use their dedicated issue tracker instead:\n+        - [The Rust Book](https://github.com/rust-lang/book/issues)\n+        - [Rust by Example](https://github.com/rust-lang/rust-by-example/issues)\n+        - [The Edition Guide](https://github.com/rust-lang/edition-guide/issues)\n+        - [The Cargo Book](https://github.com/rust-lang/cargo/issues)\n+        - [The Clippy Book](https://github.com/rust-lang/rust-clippy/issues)\n+        - [The Reference](https://github.com/rust-lang/reference/issues)\n+        - [The Rustonomicon](https://github.com/rust-lang/nomicon/issues)\n+        - [The Embedded Book](https://github.com/rust-embedded/book/issues)\n+\n+        All other documentation issues should be filed here.\n+\n+        Or, if you find an issue related to rustdoc (e.g. doctest, rustdoc UI), please use the bug report or blank issue template instead.\n+\n+  - type: textarea\n+    id: location\n+    attributes:\n+      label: Location\n+    validations:\n+      required: true \n+\n+  - type: textarea\n+    id: summary\n+    attributes:\n+      label: Summary\n+    validations:\n+      required: true \n\\ No newline at end of file"}, {"sha": "03bc4bab45137c76d85bdd644f76d8640a614ab3", "filename": ".github/ISSUE_TEMPLATE/ice.md", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cd952c8c694c28b9bb95a5d98c90186381e225c2/.github%2FISSUE_TEMPLATE%2Fice.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd952c8c694c28b9bb95a5d98c90186381e225c2/.github%2FISSUE_TEMPLATE%2Fice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.md?ref=cd952c8c694c28b9bb95a5d98c90186381e225c2", "patch": "@@ -1,52 +0,0 @@\n----\n-name: Internal Compiler Error\n-about: Create a report for an internal compiler error in rustc.\n-labels: C-bug, I-ICE, T-compiler\n----\n-<!--\n-Thank you for finding an Internal Compiler Error! \ud83e\uddca  If possible, try to provide\n-a minimal verifiable example. You can read \"Rust Bug Minimization Patterns\" for\n-how to create smaller examples.\n-\n-http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n-\n--->\n-\n-### Code\n-\n-```Rust\n-<code>\n-```\n-\n-\n-### Meta\n-<!--\n-If you're using the stable version of the compiler, you should also check if the\n-bug also exists in the beta or nightly versions.\n--->\n-\n-`rustc --version --verbose`:\n-```\n-<version>\n-```\n-\n-### Error output\n-\n-```\n-<output>\n-```\n-\n-<!--\n-Include a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\n-environment. E.g. `RUST_BACKTRACE=1 cargo build`.\n--->\n-<details><summary><strong>Backtrace</strong></summary>\n-<p>\n-\n-```\n-<backtrace>\n-```\n-\n-</p>\n-</details>\n-"}, {"sha": "54136cc6d439d7dcd8b918dc20d0bd4c6eb5322d", "filename": ".github/ISSUE_TEMPLATE/ice.yaml", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/.github%2FISSUE_TEMPLATE%2Fice.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/.github%2FISSUE_TEMPLATE%2Fice.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.yaml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,82 @@\n+name: Internal Compiler Error\n+description: Create a report for an internal compiler error in `rustc`\n+labels: [\"C-bug\", \"I-ICE\", \"T-compiler\"]\n+title: \"[ICE]: \"\n+body:\n+  - type: markdown\n+    attributes:\n+      value: |\n+        Thank you for finding an Internal Compiler Error! \ud83e\uddca\n+\n+        If possible, try to provide a minimal verifiable example.\n+\n+        You can read \"[Rust Bug Minimization Patterns](http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/)\" for how to create smaller examples.\n+\n+  - type: textarea\n+    id: code\n+    attributes:\n+      label: Code\n+      description: Please provide code or a link to a repository that can reproduce the problem\n+      placeholder: code\n+      render: Rust\n+    validations:\n+      required: false\n+\n+  - type: checkboxes\n+    attributes:\n+      label: Affected release channels\n+      description: If you're using the stable version of the compiler, you should also check if the bug also exists in the beta or nightly versions\n+      options:\n+        - label: Previous Stable\n+          required: false\n+        - label: Current Stable\n+          required: false\n+        - label: Current Beta\n+          required: false\n+        - label: Current Nightly\n+          required: false\n+\n+  - type: textarea\n+    id: version\n+    attributes:\n+      label: Rust Version\n+      description: Please provide the `rustc` version, `rustc --version --verbose`\n+      placeholder: |\n+        $ rustc --version --verbose\n+        rustc 1.XX.Y (SHORTHASH DATE)\n+        binary: rustc\n+        commit-hash: LONGHASHVALUE\n+        commit-date: DATE\n+        host: PLATFORMTRIPLE\n+        release: 1.XX.Y\n+        LLVM version: XX.YY.ZZ\n+      render: Shell\n+    validations:\n+      required: true\n+\n+  - type: textarea\n+    id: output\n+    attributes:\n+      label: Current error output\n+      description: Please provide the `rustc` output you see\n+      placeholder: output\n+      render: Shell\n+    validations:\n+      required: false\n+\n+  - type: textarea\n+    id: backtrace\n+    attributes:\n+      label: Backtrace\n+      description: Include a backtrace in the code block by setting `RUST_BACKTRACE=full` in your environment, e.g. `RUST_BACKTRACE=full cargo build`\n+      render: Shell\n+    validations:\n+      required: true\n+\n+  - type: textarea\n+    id: extra\n+    attributes:\n+      label: Anything else?\n+      description: If you have more details you want to give us to reproduce this issue, please add it here\n+    validations:\n+      required: false\n\\ No newline at end of file"}, {"sha": "5511d301775590f8f9cec20e81a88d0b4afdae2c", "filename": "Cargo.lock", "status": "modified", "additions": 98, "deletions": 67, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -35,6 +35,17 @@ dependencies = [\n  \"version_check\",\n ]\n \n+[[package]]\n+name = \"ahash\"\n+version = \"0.8.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bf6ccdb167abbf410dcb915cabd428929d7f6a04980b54a11f26a39f1c7f7107\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"once_cell\",\n+ \"version_check\",\n+]\n+\n [[package]]\n name = \"aho-corasick\"\n version = \"0.7.18\"\n@@ -107,7 +118,7 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"276881980556fdadeb88aa1ffc667e4d2e8fe72531dfabcb7a82bb3c9ea9ba31\"\n dependencies = [\n- \"object\",\n+ \"object 0.29.0\",\n ]\n \n [[package]]\n@@ -193,7 +204,7 @@ dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"miniz_oxide\",\n- \"object\",\n+ \"object 0.29.0\",\n  \"rustc-demangle\",\n ]\n \n@@ -340,7 +351,7 @@ dependencies = [\n  \"cargo-test-macro\",\n  \"cargo-test-support\",\n  \"cargo-util\",\n- \"clap 4.0.15\",\n+ \"clap 4.0.32\",\n  \"crates-io\",\n  \"curl\",\n  \"curl-sys\",\n@@ -644,26 +655,27 @@ dependencies = [\n \n [[package]]\n name = \"clap\"\n-version = \"4.0.15\"\n+version = \"4.0.32\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6bf8832993da70a4c6d13c581f4463c2bdda27b9bf1c5498dc4365543abe6d6f\"\n+checksum = \"a7db700bc935f9e43e88d00b0850dae18a63773cfbec6d8e070fccf7fef89a39\"\n dependencies = [\n- \"atty\",\n  \"bitflags\",\n- \"clap_derive 4.0.13\",\n+ \"clap_derive 4.0.21\",\n  \"clap_lex 0.3.0\",\n+ \"is-terminal\",\n  \"once_cell\",\n  \"strsim\",\n  \"termcolor\",\n+ \"terminal_size\",\n ]\n \n [[package]]\n name = \"clap_complete\"\n-version = \"3.1.1\"\n+version = \"4.0.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"df6f3613c0a3cddfd78b41b10203eb322cb29b600cbdf808a7d3db95691b8e25\"\n+checksum = \"10861370d2ba66b0f5989f83ebf35db6421713fd92351790e7fdd6c36774c56b\"\n dependencies = [\n- \"clap 3.2.20\",\n+ \"clap 4.0.32\",\n ]\n \n [[package]]\n@@ -681,9 +693,9 @@ dependencies = [\n \n [[package]]\n name = \"clap_derive\"\n-version = \"4.0.13\"\n+version = \"4.0.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c42f169caba89a7d512b5418b09864543eeb4d497416c917d7137863bd2076ad\"\n+checksum = \"0177313f9f02afc995627906bbd8967e2be069f5261954222dac78290c2b9014\"\n dependencies = [\n  \"heck\",\n  \"proc-macro-error\",\n@@ -1773,9 +1785,9 @@ dependencies = [\n \n [[package]]\n name = \"gimli\"\n-version = \"0.26.1\"\n+version = \"0.26.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"78cc372d058dcf6d5ecd98510e7fbc9e5aec4d21de70f65fea8fecebcd881bd4\"\n+checksum = \"22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d\"\n dependencies = [\n  \"compiler_builtins\",\n  \"fallible-iterator\",\n@@ -1886,12 +1898,21 @@ version = \"0.12.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n dependencies = [\n- \"ahash\",\n+ \"ahash 0.7.4\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.13.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"33ff8ae62cd3a9102e5637afc8452c55acf3844001bd5374e0b0bd7b6616c038\"\n+dependencies = [\n+ \"ahash 0.8.2\",\n+]\n+\n [[package]]\n name = \"heck\"\n version = \"0.4.0\"\n@@ -2128,12 +2149,12 @@ checksum = \"ce23b50ad8242c51a442f3ff322d56b02f08852c77e4c0b4d3fd684abc89c683\"\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.9.1\"\n+version = \"1.9.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"10a35a97730320ffe8e2d410b5d3b69279b98d2c14bdb8b70ea89ecf7888d41e\"\n+checksum = \"1885e79c1fc4b10f0e172c475f458b7f7b93061064d98c3293e98c5ba0c8b399\"\n dependencies = [\n  \"autocfg\",\n- \"hashbrown\",\n+ \"hashbrown 0.12.3\",\n  \"rustc-rayon\",\n  \"serde\",\n ]\n@@ -2273,7 +2294,7 @@ name = \"jsondoclint\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n- \"clap 4.0.15\",\n+ \"clap 4.0.32\",\n  \"fs-err\",\n  \"rustdoc-json-types\",\n  \"serde\",\n@@ -2529,21 +2550,21 @@ dependencies = [\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.4.21\"\n+version = \"0.4.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"23f3e133c6d515528745ffd3b9f0c7d975ae039f0b6abb099f2168daa2afb4f9\"\n+checksum = \"d1ed28d5903dde77bd5182645078a37ee57014cac6ccb2d54e1d6496386648e4\"\n dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n  \"chrono\",\n- \"clap 3.2.20\",\n+ \"clap 4.0.32\",\n  \"clap_complete\",\n  \"elasticlunr-rs\",\n- \"env_logger 0.9.0\",\n+ \"env_logger 0.10.0\",\n  \"handlebars 4.3.3\",\n- \"lazy_static\",\n  \"log\",\n  \"memchr\",\n+ \"once_cell\",\n  \"opener\",\n  \"pulldown-cmark 0.9.2\",\n  \"regex\",\n@@ -2739,13 +2760,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n dependencies = [\n  \"compiler_builtins\",\n+ \"memchr\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"object\"\n+version = \"0.30.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8d864c91689fdc196779b98dba0aceac6118594c2df6ee5d943eb6a8df4d107a\"\n+dependencies = [\n  \"crc32fast\",\n  \"flate2\",\n- \"hashbrown\",\n+ \"hashbrown 0.13.1\",\n  \"indexmap\",\n  \"memchr\",\n- \"rustc-std-workspace-alloc\",\n- \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n@@ -3013,29 +3043,29 @@ dependencies = [\n \n [[package]]\n name = \"pest\"\n-version = \"2.3.0\"\n+version = \"2.5.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4b0560d531d1febc25a3c9398a62a71256c0178f2e3443baedd9ad4bb8c9deb4\"\n+checksum = \"0f6e86fb9e7026527a0d46bc308b841d73170ef8f443e1807f6ef88526a816d4\"\n dependencies = [\n  \"thiserror\",\n  \"ucd-trie\",\n ]\n \n [[package]]\n name = \"pest_derive\"\n-version = \"2.3.0\"\n+version = \"2.5.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"905708f7f674518498c1f8d644481440f476d39ca6ecae83319bba7c6c12da91\"\n+checksum = \"96504449aa860c8dcde14f9fba5c58dc6658688ca1fe363589d6327b8662c603\"\n dependencies = [\n  \"pest\",\n  \"pest_generator\",\n ]\n \n [[package]]\n name = \"pest_generator\"\n-version = \"2.3.0\"\n+version = \"2.5.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5803d8284a629cc999094ecd630f55e91b561a1d1ba75e233b00ae13b91a69ad\"\n+checksum = \"798e0220d1111ae63d66cb66a5dcb3fc2d986d520b98e49e1852bfdb11d7c5e7\"\n dependencies = [\n  \"pest\",\n  \"pest_meta\",\n@@ -3046,13 +3076,13 @@ dependencies = [\n \n [[package]]\n name = \"pest_meta\"\n-version = \"2.3.0\"\n+version = \"2.5.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1538eb784f07615c6d9a8ab061089c6c54a344c5b4301db51990ca1c241e8c04\"\n+checksum = \"984298b75898e30a843e278a9f2452c31e349a073a0ce6fd950a12a74464e065\"\n dependencies = [\n  \"once_cell\",\n  \"pest\",\n- \"sha-1\",\n+ \"sha1\",\n ]\n \n [[package]]\n@@ -3498,7 +3528,7 @@ dependencies = [\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap 3.2.20\",\n+ \"clap 4.0.32\",\n  \"env_logger 0.7.1\",\n  \"mdbook\",\n ]\n@@ -3790,7 +3820,7 @@ dependencies = [\n  \"cstr\",\n  \"libc\",\n  \"measureme\",\n- \"object\",\n+ \"object 0.30.1\",\n  \"rustc-demangle\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3825,7 +3855,7 @@ dependencies = [\n  \"itertools\",\n  \"jobserver\",\n  \"libc\",\n- \"object\",\n+ \"object 0.30.1\",\n  \"pathdiff\",\n  \"regex\",\n  \"rustc_arena\",\n@@ -4273,6 +4303,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"rustc_span\",\n  \"tracing\",\n+ \"tracing-core\",\n  \"tracing-subscriber\",\n  \"tracing-tree\",\n ]\n@@ -4683,7 +4714,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"scoped-tls\",\n- \"sha-1\",\n+ \"sha1\",\n  \"sha2\",\n  \"tracing\",\n  \"unicode-width\",\n@@ -5092,17 +5123,6 @@ dependencies = [\n  \"serde\",\n ]\n \n-[[package]]\n-name = \"sha-1\"\n-version = \"0.10.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"028f48d513f9678cda28f6e4064755b3fbb2af6acd672f2c209b62323f7aea0f\"\n-dependencies = [\n- \"cfg-if\",\n- \"cpufeatures\",\n- \"digest\",\n-]\n-\n [[package]]\n name = \"sha1\"\n version = \"0.10.5\"\n@@ -5305,11 +5325,11 @@ dependencies = [\n  \"core\",\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n- \"hashbrown\",\n+ \"hashbrown 0.12.3\",\n  \"hermit-abi 0.2.6\",\n  \"libc\",\n  \"miniz_oxide\",\n- \"object\",\n+ \"object 0.29.0\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n@@ -5477,6 +5497,16 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n+[[package]]\n+name = \"terminal_size\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cb20089a8ba2b69debd491f8d2d023761cbf196e999218c591fa1e7e15a21907\"\n+dependencies = [\n+ \"rustix\",\n+ \"windows-sys\",\n+]\n+\n [[package]]\n name = \"termize\"\n version = \"0.1.1\"\n@@ -5528,18 +5558,18 @@ checksum = \"ceb05e71730d396f960f8f3901cdb41be2d339b303e9d7d3a07c5ff0536e671b\"\n \n [[package]]\n name = \"thiserror\"\n-version = \"1.0.33\"\n+version = \"1.0.38\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3d0a539a918745651435ac7db7a18761589a94cd7e94cd56999f828bf73c8a57\"\n+checksum = \"6a9cd18aa97d5c45c6603caea1da6628790b37f7a34b6ca89522331c5180fed0\"\n dependencies = [\n  \"thiserror-impl\",\n ]\n \n [[package]]\n name = \"thiserror-impl\"\n-version = \"1.0.33\"\n+version = \"1.0.38\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c251e90f708e16c49a16f4917dc2131e75222b72edfa9cb7f7c58ae56aae0c09\"\n+checksum = \"1fb327af4685e4d03fa8cbcf1716380da910eeb2bb8be417e7f9fd3fb164f36f\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -5548,13 +5578,13 @@ dependencies = [\n \n [[package]]\n name = \"thorin-dwp\"\n-version = \"0.3.0\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e6cb0c7868d7f90407531108ab03263d9452a8811b7cdd87675343a40d4aa254\"\n+checksum = \"da8fbf660a019b6bf11ea95762041464aa9099cc293b6a66d77cea5107619671\"\n dependencies = [\n  \"gimli\",\n- \"hashbrown\",\n- \"object\",\n+ \"hashbrown 0.12.3\",\n+ \"object 0.30.1\",\n  \"tracing\",\n ]\n \n@@ -5571,6 +5601,7 @@ dependencies = [\n name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n+ \"cargo-platform 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargo_metadata 0.14.0\",\n  \"ignore\",\n  \"lazy_static\",\n@@ -5692,9 +5723,9 @@ dependencies = [\n \n [[package]]\n name = \"topological-sort\"\n-version = \"0.1.0\"\n+version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"aa7c7f42dea4b1b99439786f5633aeb9c14c1b53f75e282803c2ec2ad545873c\"\n+checksum = \"ea68304e134ecd095ac6c3574494fc62b909f416c4fca77e440530221e549d3d\"\n \n [[package]]\n name = \"tracing\"\n@@ -5820,9 +5851,9 @@ dependencies = [\n \n [[package]]\n name = \"ucd-trie\"\n-version = \"0.1.3\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"56dee185309b50d1f11bfedef0fe6d036842e3fb77413abef29f8f8d1c5d4c1c\"\n+checksum = \"9e79c4d996edb816c91e4308506774452e55e95c3c9de07b6729e17e15a5ef81\"\n \n [[package]]\n name = \"ui_test\"\n@@ -6089,9 +6120,9 @@ checksum = \"6454029bf181f092ad1b853286f23e2c507d8e8194d01d92da4a55c274a5508c\"\n \n [[package]]\n name = \"version_check\"\n-version = \"0.9.3\"\n+version = \"0.9.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5fecdca9a5291cc2b8dcf7dc02453fee791a280f3743cb0905f8822ae463b3fe\"\n+checksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n \n [[package]]\n name = \"vte\""}, {"sha": "f4cb459f32fddee1bcc78c465ae6916b8a92736e", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1100,7 +1100,7 @@ pub enum FieldsShape {\n         /// named `inverse_memory_index`.\n         ///\n         // FIXME(eddyb) build a better abstraction for permutations, if possible.\n-        // FIXME(camlorn) also consider small vector  optimization here.\n+        // FIXME(camlorn) also consider small vector optimization here.\n         memory_index: Vec<u32>,\n     },\n }"}, {"sha": "bc6d2cf12c78aaaeb80e5a50aa936f64cf49d8dd", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -416,8 +416,7 @@ fn compute_hir_hash(\n \n pub fn lower_to_hir(tcx: TyCtxt<'_>, (): ()) -> hir::Crate<'_> {\n     let sess = tcx.sess;\n-    let krate = tcx.untracked_crate.steal();\n-    let mut resolver = tcx.resolver_for_lowering(()).steal();\n+    let (mut resolver, krate) = tcx.resolver_for_lowering(()).steal();\n \n     let ast_index = index_crate(&resolver.node_id_to_def_id, &krate);\n     let mut owners = IndexVec::from_fn_n("}, {"sha": "968c1f49b95c00ccec072fc253421936dc258f90", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 144, "deletions": 4, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -6,6 +6,7 @@ use rustc_errors::{\n     struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n+use rustc_hir::def::Res;\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, LangItem};\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -20,7 +21,7 @@ use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n \n@@ -29,6 +30,7 @@ use crate::borrowck_errors;\n \n use crate::diagnostics::conflict_errors::StorageDeadOrDrop::LocalStorageDead;\n use crate::diagnostics::find_all_local_uses;\n+use crate::diagnostics::mutability_errors::mut_borrow_of_mutable_ref;\n use crate::{\n     borrow_set::BorrowData, diagnostics::Instance, prefixes::IsPrefixOf,\n     InitializationRequiringAction, MirBorrowckCtxt, PrefixSet, WriteKind,\n@@ -356,7 +358,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let Some(hir::Node::Item(hir::Item {\n             kind: hir::ItemKind::Fn(_, _, body_id),\n             ..\n-        })) = hir.find(hir.local_def_id_to_hir_id(self.mir_def_id()))\n+        })) = hir.find(self.mir_hir_id())\n             && let Some(hir::Node::Expr(expr)) = hir.find(body_id.hir_id)\n         {\n             let place = &self.move_data.move_paths[mpi].place;\n@@ -948,7 +950,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n             (BorrowKind::Mut { .. }, BorrowKind::Shared) => {\n                 first_borrow_desc = \"immutable \";\n-                self.cannot_reborrow_already_borrowed(\n+                let mut err = self.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     &msg_place,\n@@ -958,7 +960,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     \"immutable\",\n                     &msg_borrow,\n                     None,\n-                )\n+                );\n+                self.suggest_binding_for_closure_capture_self(\n+                    &mut err,\n+                    issued_borrow.borrowed_place,\n+                    &issued_spans,\n+                );\n+                err\n             }\n \n             (BorrowKind::Mut { .. }, BorrowKind::Mut { .. }) => {\n@@ -1240,6 +1248,138 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    fn suggest_binding_for_closure_capture_self(\n+        &self,\n+        err: &mut Diagnostic,\n+        borrowed_place: Place<'tcx>,\n+        issued_spans: &UseSpans<'tcx>,\n+    ) {\n+        let UseSpans::ClosureUse { capture_kind_span, .. } = issued_spans else { return };\n+        let hir = self.infcx.tcx.hir();\n+\n+        // check whether the borrowed place is capturing `self` by mut reference\n+        let local = borrowed_place.local;\n+        let Some(_) = self\n+            .body\n+            .local_decls\n+            .get(local)\n+            .map(|l| mut_borrow_of_mutable_ref(l, self.local_names[local])) else { return };\n+\n+        struct ExpressionFinder<'hir> {\n+            capture_span: Span,\n+            closure_change_spans: Vec<Span>,\n+            closure_arg_span: Option<Span>,\n+            in_closure: bool,\n+            suggest_arg: String,\n+            hir: rustc_middle::hir::map::Map<'hir>,\n+            closure_local_id: Option<hir::HirId>,\n+            closure_call_changes: Vec<(Span, String)>,\n+        }\n+        impl<'hir> Visitor<'hir> for ExpressionFinder<'hir> {\n+            fn visit_expr(&mut self, e: &'hir hir::Expr<'hir>) {\n+                if e.span.contains(self.capture_span) {\n+                    if let hir::ExprKind::Closure(&hir::Closure {\n+                            movability: None,\n+                            body,\n+                            fn_arg_span,\n+                            fn_decl: hir::FnDecl{ inputs, .. },\n+                            ..\n+                        }) = e.kind &&\n+                        let Some(hir::Node::Expr(body )) = self.hir.find(body.hir_id) {\n+                            self.suggest_arg = \"this: &Self\".to_string();\n+                            if inputs.len() > 0 {\n+                                self.suggest_arg.push_str(\", \");\n+                            }\n+                            self.in_closure = true;\n+                            self.closure_arg_span = fn_arg_span;\n+                            self.visit_expr(body);\n+                            self.in_closure = false;\n+                    }\n+                }\n+                if let hir::Expr { kind: hir::ExprKind::Path(path), .. } = e {\n+                    if let hir::QPath::Resolved(_, hir::Path { segments: [seg], ..}) = path &&\n+                        seg.ident.name == kw::SelfLower && self.in_closure {\n+                            self.closure_change_spans.push(e.span);\n+                    }\n+                }\n+                hir::intravisit::walk_expr(self, e);\n+            }\n+\n+            fn visit_local(&mut self, local: &'hir hir::Local<'hir>) {\n+                if let hir::Pat { kind: hir::PatKind::Binding(_, hir_id, _ident, _), .. } = local.pat &&\n+                    let Some(init) = local.init\n+                {\n+                    if let hir::Expr { kind: hir::ExprKind::Closure(&hir::Closure {\n+                            movability: None,\n+                            ..\n+                        }), .. } = init &&\n+                        init.span.contains(self.capture_span) {\n+                            self.closure_local_id = Some(*hir_id);\n+                    }\n+                }\n+                hir::intravisit::walk_local(self, local);\n+            }\n+\n+            fn visit_stmt(&mut self, s: &'hir hir::Stmt<'hir>) {\n+                if let hir::StmtKind::Semi(e) = s.kind &&\n+                    let hir::ExprKind::Call(hir::Expr { kind: hir::ExprKind::Path(path), ..}, args) = e.kind &&\n+                    let hir::QPath::Resolved(_, hir::Path { segments: [seg], ..}) = path &&\n+                    let Res::Local(hir_id) = seg.res &&\n+                        Some(hir_id) == self.closure_local_id {\n+                        let (span, arg_str) = if args.len() > 0 {\n+                            (args[0].span.shrink_to_lo(), \"self, \".to_string())\n+                        } else {\n+                            let span = e.span.trim_start(seg.ident.span).unwrap_or(e.span);\n+                            (span, \"(self)\".to_string())\n+                        };\n+                        self.closure_call_changes.push((span, arg_str));\n+                }\n+                hir::intravisit::walk_stmt(self, s);\n+            }\n+        }\n+\n+        if let Some(hir::Node::ImplItem(\n+                    hir::ImplItem { kind: hir::ImplItemKind::Fn(_fn_sig, body_id), .. }\n+                )) = hir.find(self.mir_hir_id()) &&\n+            let Some(hir::Node::Expr(expr)) = hir.find(body_id.hir_id) {\n+            let mut finder = ExpressionFinder {\n+                capture_span: *capture_kind_span,\n+                closure_change_spans: vec![],\n+                closure_arg_span: None,\n+                in_closure: false,\n+                suggest_arg: String::new(),\n+                closure_local_id: None,\n+                closure_call_changes: vec![],\n+                hir,\n+            };\n+            finder.visit_expr(expr);\n+\n+            if finder.closure_change_spans.is_empty() || finder.closure_call_changes.is_empty() {\n+                return;\n+            }\n+\n+            let mut sugg = vec![];\n+            let sm = self.infcx.tcx.sess.source_map();\n+\n+            if let Some(span) = finder.closure_arg_span {\n+                sugg.push((sm.next_point(span.shrink_to_lo()).shrink_to_hi(), finder.suggest_arg));\n+            }\n+            for span in finder.closure_change_spans {\n+                sugg.push((span, \"this\".to_string()));\n+            }\n+\n+            for (span, suggest) in finder.closure_call_changes {\n+                sugg.push((span, suggest));\n+            }\n+\n+            err.multipart_suggestion_verbose(\n+                \"try explicitly pass `&Self` into the Closure as an argument\",\n+                sugg,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n     /// Returns the description of the root place for a conflicting borrow and the full\n     /// descriptions of the places that caused the conflict.\n     ///"}, {"sha": "45b15c2c5bd7062451a9b947584ecacb2f504d0f", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1094,7 +1094,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n+pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n     debug!(\"local_info: {:?}, ty.kind(): {:?}\", local_decl.local_info, local_decl.ty.kind());\n \n     match local_decl.local_info.as_deref() {"}, {"sha": "f3050a6ef3f07f7964cf58a23bc3a858dd05b717", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -79,7 +79,7 @@ impl<'tcx> RegionErrors<'tcx> {\n     #[track_caller]\n     pub fn push(&mut self, val: impl Into<RegionErrorKind<'tcx>>) {\n         let val = val.into();\n-        self.1.sess.delay_span_bug(DUMMY_SP, \"{val:?}\");\n+        self.1.sess.delay_span_bug(DUMMY_SP, format!(\"{val:?}\"));\n         self.0.push(val);\n     }\n     pub fn is_empty(&self) -> bool {"}, {"sha": "918fb2d69237e4cb48b125a85daab2a60f8635dc", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -209,7 +209,7 @@ fn place_components_conflict<'tcx>(\n             match (elem, &base_ty.kind(), access) {\n                 (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n                 | (_, _, Shallow(Some(ArtificialField::ShallowBorrow))) => {\n-                    // The array length is like  additional fields on the\n+                    // The array length is like additional fields on the\n                     // type; it does not overlap any existing data there.\n                     // Furthermore, if cannot actually be a prefix of any\n                     // borrowed place (at least in MIR as it is currently.)"}, {"sha": "c6e42336ef8ca42a8cac048f084202ae46340c00", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -235,7 +235,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     /// # Parameters\n     ///\n     /// - `def_id`, the `impl Trait` type\n-    /// - `substs`, the substs  used to instantiate this opaque type\n+    /// - `substs`, the substs used to instantiate this opaque type\n     /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n     ///   `opaque_defn.concrete_ty`\n     #[instrument(level = \"debug\", skip(self))]"}, {"sha": "9c1bcd431ec4933b2d858b5d6eb21bcffbfabe69", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -11,7 +11,10 @@ bitflags = \"1.0\"\n cstr = \"0.2\"\n libc = \"0.2\"\n measureme = \"10.0.0\"\n-object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read\"] }\n+object = { version = \"0.30.1\", default-features = false, features = [\n+    \"std\",\n+    \"read\",\n+] }\n tracing = \"0.1\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc-demangle = \"0.1.21\""}, {"sha": "0d2d2ec68a23f3adf9ac9d928d0a435bb67c6c9b", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -15,7 +15,7 @@ tracing = \"0.1\"\n libc = \"0.2.50\"\n jobserver = \"0.1.22\"\n tempfile = \"3.2\"\n-thorin-dwp = \"0.3\"\n+thorin-dwp = \"0.4\"\n pathdiff = \"0.2.0\"\n serde_json = \"1.0.59\"\n snap = \"1\"\n@@ -44,6 +44,6 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_const_eval = { path = \"../rustc_const_eval\" }\n \n [dependencies.object]\n-version = \"0.29.0\"\n+version = \"0.30.1\"\n default-features = false\n features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"unaligned\", \"archive\", \"write\"]"}, {"sha": "b148e4185a68a795ce5f2c02e8e164dbcee8cada", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1231,12 +1231,21 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                     sess.emit_fatal(errors::LinkerFileStem);\n                 });\n \n+                // Remove any version postfix.\n+                let stem = stem\n+                    .rsplit_once('-')\n+                    .and_then(|(lhs, rhs)| rhs.chars().all(char::is_numeric).then_some(lhs))\n+                    .unwrap_or(stem);\n+\n+                // GCC can have an optional target prefix.\n                 let flavor = if stem == \"emcc\" {\n                     LinkerFlavor::EmCc\n                 } else if stem == \"gcc\"\n                     || stem.ends_with(\"-gcc\")\n+                    || stem == \"g++\"\n+                    || stem.ends_with(\"-g++\")\n                     || stem == \"clang\"\n-                    || stem.ends_with(\"-clang\")\n+                    || stem == \"clang++\"\n                 {\n                     LinkerFlavor::from_cli(LinkerFlavorCli::Gcc, &sess.target)\n                 } else if stem == \"wasm-ld\" || stem.ends_with(\"-wasm-ld\") {"}, {"sha": "7d3c14fec5fbf91e26146346386c3faf4c38c724", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -100,7 +100,13 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n     };\n     let architecture = match &sess.target.arch[..] {\n         \"arm\" => Architecture::Arm,\n-        \"aarch64\" => Architecture::Aarch64,\n+        \"aarch64\" => {\n+            if sess.target.pointer_width == 32 {\n+                Architecture::Aarch64_Ilp32\n+            } else {\n+                Architecture::Aarch64\n+            }\n+        }\n         \"x86\" => Architecture::I386,\n         \"s390x\" => Architecture::S390x,\n         \"mips\" => Architecture::Mips,\n@@ -165,11 +171,23 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n                 };\n             e_flags\n         }\n-        Architecture::Riscv64 if sess.target.options.features.contains(\"+d\") => {\n-            // copied from `riscv64-linux-gnu-gcc foo.c -c`, note though\n-            // that the `+d` target feature represents whether the double\n-            // float abi is enabled.\n-            let e_flags = elf::EF_RISCV_RVC | elf::EF_RISCV_FLOAT_ABI_DOUBLE;\n+        Architecture::Riscv32 | Architecture::Riscv64 => {\n+            // Source: https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/079772828bd10933d34121117a222b4cc0ee2200/riscv-elf.adoc\n+            let mut e_flags: u32 = 0x0;\n+            let features = &sess.target.options.features;\n+            // Check if compressed is enabled\n+            if features.contains(\"+c\") {\n+                e_flags |= elf::EF_RISCV_RVC;\n+            }\n+\n+            // Select the appropriate floating-point ABI\n+            if features.contains(\"+d\") {\n+                e_flags |= elf::EF_RISCV_FLOAT_ABI_DOUBLE;\n+            } else if features.contains(\"+f\") {\n+                e_flags |= elf::EF_RISCV_FLOAT_ABI_SINGLE;\n+            } else {\n+                e_flags |= elf::EF_RISCV_FLOAT_ABI_SOFT;\n+            }\n             e_flags\n         }\n         _ => 0,"}, {"sha": "a62e5dec4b8643aba7ebc69ff4ffc5c6e67e1db5", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -231,6 +231,10 @@ fn run_compiler(\n         registry: diagnostics_registry(),\n     };\n \n+    if !tracing::dispatcher::has_been_set() {\n+        init_rustc_env_logger_with_backtrace_option(&config.opts.unstable_opts.log_backtrace);\n+    }\n+\n     match make_input(config.opts.error_format, &matches.free) {\n         Err(reported) => return Err(reported),\n         Ok(Some((input, input_file_path))) => {\n@@ -1300,7 +1304,14 @@ pub fn install_ice_hook() {\n /// This allows tools to enable rust logging without having to magically match rustc's\n /// tracing crate version.\n pub fn init_rustc_env_logger() {\n-    if let Err(error) = rustc_log::init_rustc_env_logger() {\n+    init_rustc_env_logger_with_backtrace_option(&None);\n+}\n+\n+/// This allows tools to enable rust logging without having to magically match rustc's\n+/// tracing crate version. In contrast to `init_rustc_env_logger` it allows you to\n+/// choose a target module you wish to show backtraces along with its logging.\n+pub fn init_rustc_env_logger_with_backtrace_option(backtrace_target: &Option<String>) {\n+    if let Err(error) = rustc_log::init_rustc_env_logger_with_backtrace_option(backtrace_target) {\n         early_error(ErrorOutputType::default(), &error.to_string());\n     }\n }\n@@ -1366,7 +1377,6 @@ mod signal_handler {\n pub fn main() -> ! {\n     let start_time = Instant::now();\n     let start_rss = get_resident_set_size();\n-    init_rustc_env_logger();\n     signal_handler::install();\n     let mut callbacks = TimePassesCallbacks::default();\n     install_ice_hook();"}, {"sha": "ca72b7faa9289b64f3f069e6adb0c07265347b8c", "filename": "compiler/rustc_error_messages/locales/en-US/hir_typeck.ftl", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -46,3 +46,14 @@ hir_typeck_add_missing_parentheses_in_range = you must surround the range in par\n \n hir_typeck_op_trait_generic_params =\n     `{$method_name}` must not have any generic parameters\n+\n+hir_typeck_lang_start_incorrect_number_params = incorrect number of parameters for the `start` lang item\n+hir_typeck_lang_start_incorrect_number_params_note_expected_count = the `start` lang item should have four parameters, but found {$found_param_count}\n+\n+hir_typeck_lang_start_expected_sig_note = the `start` lang item should have the signature `fn(fn() -> T, isize, *const *const u8, u8) -> isize`\n+\n+hir_typeck_lang_start_incorrect_param = parameter {$param_num} of the `start` lang item is incorrect\n+    .suggestion = change the type from `{$found_ty}` to `{$expected_ty}`\n+\n+hir_typeck_lang_start_incorrect_ret_ty = the return type of the `start` lang item is incorrect\n+    .suggestion = change the type from `{$found_ty}` to `{$expected_ty}`"}, {"sha": "688b044722260ce0dc7070b425cd43e79f22aaf1", "filename": "compiler/rustc_error_messages/locales/en-US/interface.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -41,3 +41,6 @@ interface_rustc_error_unexpected_annotation =\n \n interface_failed_writing_file =\n     failed to write file {$path}: {$error}\"\n+\n+interface_proc_macro_crate_panic_abort =\n+    building proc macro crate with `panic=abort` may crash the compiler should the proc-macro panic"}, {"sha": "91857dd227ddd602bb0eeee9eee8a291faa3ebbc", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -4,6 +4,9 @@\n -passes_see_issue =\n     see issue #{$issue} <https://github.com/rust-lang/rust/issues/{$issue}> for more information\n \n+passes_incorrect_do_not_recommend_location =\n+    `#[do_not_recommend]` can only be placed on trait implementations\n+\n passes_outer_crate_level_attr =\n     crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n "}, {"sha": "ffde8480c02117283c3ac7c47d96f4c48dcabe58", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -31,11 +31,11 @@ use rustc_span::edition::Edition;\n use rustc_span::hygiene::{AstPass, ExpnData, ExpnKind, LocalExpnId};\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, FileName, RealFileName, Span, DUMMY_SP};\n+use rustc_span::{BytePos, FileName, Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n use std::iter;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::rc::Rc;\n \n pub(crate) use rustc_span::hygiene::MacroKind;\n@@ -1423,8 +1423,10 @@ fn pretty_printing_compatibility_hack(item: &Item, sess: &ParseSess) -> bool {\n             if let [variant] = &*enum_def.variants {\n                 if variant.ident.name == sym::Input {\n                     let filename = sess.source_map().span_to_filename(item.ident.span);\n-                    if let FileName::Real(RealFileName::LocalPath(path)) = filename {\n-                        if let Some(c) = path\n+                    if let FileName::Real(real) = filename {\n+                        if let Some(c) = real\n+                            .local_path()\n+                            .unwrap_or(Path::new(\"\"))\n                             .components()\n                             .flat_map(|c| c.as_os_str().to_str())\n                             .find(|c| c.starts_with(\"rental\") || c.starts_with(\"allsorts-rental\"))"}, {"sha": "9031c04849dfe99b648089008f44b98f70034565", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 166, "deletions": 22, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -27,6 +27,7 @@ use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::{GenericArg, GenericArgs, OpaqueTyOrigin};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::GenericParamDefKind;\n@@ -510,9 +511,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             return tcx.const_error(ty).into();\n                         }\n                         if !infer_args && has_default {\n-                            tcx.bound_const_param_default(param.def_id)\n-                                .subst(tcx, substs.unwrap())\n-                                .into()\n+                            tcx.const_param_default(param.def_id).subst(tcx, substs.unwrap()).into()\n                         } else {\n                             if infer_args {\n                                 self.astconv.ct_infer(ty, Some(param), self.span).into()\n@@ -1643,8 +1642,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn report_ambiguous_associated_type(\n         &self,\n         span: Span,\n-        type_str: &str,\n-        trait_str: &str,\n+        types: &[String],\n+        traits: &[String],\n         name: Symbol,\n     ) -> ErrorGuaranteed {\n         let mut err = struct_span_err!(self.tcx().sess, span, E0223, \"ambiguous associated type\");\n@@ -1655,19 +1654,92 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .keys()\n             .any(|full_span| full_span.contains(span))\n         {\n-            err.span_suggestion(\n+            err.span_suggestion_verbose(\n                 span.shrink_to_lo(),\n                 \"you are looking for the module in `std`, not the primitive type\",\n                 \"std::\",\n                 Applicability::MachineApplicable,\n             );\n         } else {\n-            err.span_suggestion(\n-                span,\n-                \"use fully-qualified syntax\",\n-                format!(\"<{} as {}>::{}\", type_str, trait_str, name),\n-                Applicability::HasPlaceholders,\n-            );\n+            match (types, traits) {\n+                ([], []) => {\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        &format!(\n+                            \"if there were a type named `Type` that implements a trait named \\\n+                             `Trait` with associated type `{name}`, you could use the \\\n+                             fully-qualified path\",\n+                        ),\n+                        format!(\"<Type as Trait>::{name}\"),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                ([], [trait_str]) => {\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        &format!(\n+                            \"if there were a type named `Example` that implemented `{trait_str}`, \\\n+                             you could use the fully-qualified path\",\n+                        ),\n+                        format!(\"<Example as {trait_str}>::{name}\"),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                ([], traits) => {\n+                    err.span_suggestions(\n+                        span,\n+                        &format!(\n+                            \"if there were a type named `Example` that implemented one of the \\\n+                             traits with associated type `{name}`, you could use the \\\n+                             fully-qualified path\",\n+                        ),\n+                        traits\n+                            .iter()\n+                            .map(|trait_str| format!(\"<Example as {trait_str}>::{name}\"))\n+                            .collect::<Vec<_>>(),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                ([type_str], []) => {\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        &format!(\n+                            \"if there were a trait named `Example` with associated type `{name}` \\\n+                             implemented for `{type_str}`, you could use the fully-qualified path\",\n+                        ),\n+                        format!(\"<{type_str} as Example>::{name}\"),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                (types, []) => {\n+                    err.span_suggestions(\n+                        span,\n+                        &format!(\n+                            \"if there were a trait named `Example` with associated type `{name}` \\\n+                             implemented for one of the types, you could use the fully-qualified \\\n+                             path\",\n+                        ),\n+                        types\n+                            .into_iter()\n+                            .map(|type_str| format!(\"<{type_str} as Example>::{name}\")),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                (types, traits) => {\n+                    let mut suggestions = vec![];\n+                    for type_str in types {\n+                        for trait_str in traits {\n+                            suggestions.push(format!(\"<{type_str} as {trait_str}>::{name}\"));\n+                        }\n+                    }\n+                    err.span_suggestions(\n+                        span,\n+                        \"use the fully-qualified path\",\n+                        suggestions,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n         }\n         err.emit()\n     }\n@@ -1994,7 +2066,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 };\n \n                 self.one_bound_for_assoc_type(\n-                    || traits::supertraits(tcx, ty::Binder::dummy(trait_ref)),\n+                    || traits::supertraits(tcx, ty::Binder::dummy(trait_ref.subst_identity())),\n                     || \"Self\".to_string(),\n                     assoc_ident,\n                     span,\n@@ -2050,12 +2122,64 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     err.emit()\n                 } else if let Err(reported) = qself_ty.error_reported() {\n                     reported\n+                } else if let ty::Alias(ty::Opaque, alias_ty) = qself_ty.kind() {\n+                    // `<impl Trait as OtherTrait>::Assoc` makes no sense.\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        tcx.def_span(alias_ty.def_id),\n+                        E0667,\n+                        \"`impl Trait` is not allowed in path parameters\"\n+                    )\n+                    .emit() // Already reported in an earlier stage.\n                 } else {\n+                    // Find all the `impl`s that `qself_ty` has for any trait that has the\n+                    // associated type, so that we suggest the right one.\n+                    let infcx = tcx.infer_ctxt().build();\n+                    // We create a fresh `ty::ParamEnv` instead of the one for `self.item_def_id()`\n+                    // to avoid a cycle error in `src/test/ui/resolve/issue-102946.rs`.\n+                    let param_env = ty::ParamEnv::empty();\n+                    let traits: Vec<_> = self\n+                        .tcx()\n+                        .all_traits()\n+                        .filter(|trait_def_id| {\n+                            // Consider only traits with the associated type\n+                            tcx.associated_items(*trait_def_id)\n+                                .in_definition_order()\n+                                .any(|i| {\n+                                    i.kind.namespace() == Namespace::TypeNS\n+                                        && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident\n+                                        && matches!(i.kind, ty::AssocKind::Type)\n+                                })\n+                            // Consider only accessible traits\n+                            && tcx.visibility(*trait_def_id)\n+                                .is_accessible_from(self.item_def_id(), tcx)\n+                            && tcx.all_impls(*trait_def_id)\n+                                .any(|impl_def_id| {\n+                                    let trait_ref = tcx.impl_trait_ref(impl_def_id);\n+                                    trait_ref.map_or(false, |trait_ref| {\n+                                        let impl_ = trait_ref.subst(\n+                                            tcx,\n+                                            infcx.fresh_substs_for_item(span, impl_def_id),\n+                                        );\n+                                        infcx\n+                                            .can_eq(\n+                                                param_env,\n+                                                tcx.erase_regions(impl_.self_ty()),\n+                                                tcx.erase_regions(qself_ty),\n+                                            )\n+                                            .is_ok()\n+                                    })\n+                                    && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n+                                })\n+                        })\n+                        .map(|trait_def_id| tcx.def_path_str(trait_def_id))\n+                        .collect();\n+\n                     // Don't print `TyErr` to the user.\n                     self.report_ambiguous_associated_type(\n                         span,\n-                        &qself_ty.to_string(),\n-                        \"Trait\",\n+                        &[qself_ty.to_string()],\n+                        &traits,\n                         assoc_ident.name,\n                     )\n                 };\n@@ -2173,16 +2297,30 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let is_part_of_self_trait_constraints = def_id == trait_def_id;\n             let is_part_of_fn_in_self_trait = parent_def_id == Some(trait_def_id);\n \n-            let type_name = if is_part_of_self_trait_constraints || is_part_of_fn_in_self_trait {\n-                \"Self\"\n+            let type_names = if is_part_of_self_trait_constraints || is_part_of_fn_in_self_trait {\n+                vec![\"Self\".to_string()]\n             } else {\n-                \"Type\"\n+                // Find all the types that have an `impl` for the trait.\n+                tcx.all_impls(trait_def_id)\n+                    .filter(|impl_def_id| {\n+                        // Consider only accessible traits\n+                        tcx.visibility(*impl_def_id).is_accessible_from(self.item_def_id(), tcx)\n+                            && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n+                    })\n+                    .filter_map(|impl_def_id| tcx.impl_trait_ref(impl_def_id))\n+                    .map(|impl_| impl_.subst_identity().self_ty())\n+                    // We don't care about blanket impls.\n+                    .filter(|self_ty| !self_ty.has_non_region_param())\n+                    .map(|self_ty| tcx.erase_regions(self_ty).to_string())\n+                    .collect()\n             };\n-\n+            // FIXME: also look at `tcx.generics_of(self.item_def_id()).params` any that\n+            // references the trait. Relevant for the first case in\n+            // `src/test/ui/associated-types/associated-types-in-ambiguous-context.rs`\n             let reported = self.report_ambiguous_associated_type(\n                 span,\n-                type_name,\n-                &path_str,\n+                &type_names,\n+                &[path_str],\n                 item_segment.ident.name,\n             );\n             return tcx.ty_error_with_guaranteed(reported)\n@@ -3167,7 +3305,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let label = \"add `dyn` keyword before this trait\";\n                 let mut diag =\n                     rustc_errors::struct_span_err!(tcx.sess, self_ty.span, E0782, \"{}\", msg);\n-                diag.multipart_suggestion_verbose(label, sugg, Applicability::MachineApplicable);\n+                if self_ty.span.can_be_used_for_suggestions() {\n+                    diag.multipart_suggestion_verbose(\n+                        label,\n+                        sugg,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n                 // check if the impl trait that we are considering is a impl of a local trait\n                 self.maybe_lint_blanket_trait_impl(&self_ty, &mut diag);\n                 diag.emit();"}, {"sha": "e58669433e2189c501620fd0af3f826f2accd333", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -540,7 +540,7 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n                     tcx,\n                     it.span,\n                     it.owner_id.def_id,\n-                    impl_trait_ref,\n+                    impl_trait_ref.subst_identity(),\n                     &impl_.items,\n                 );\n                 check_on_unimplemented(tcx, it);"}, {"sha": "609c8377f68b554efb6b9de3b072b702621ec7c1", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 152, "deletions": 14, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2,7 +2,9 @@ use super::potentially_plural_count;\n use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n use hir::def_id::{DefId, LocalDefId};\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed};\n+use rustc_errors::{\n+    pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed, MultiSpan,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n@@ -320,15 +322,6 @@ fn compare_method_predicate_entailment<'tcx>(\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(unnormalized_impl_fty.into())),\n         ));\n     }\n-    let emit_implied_wf_lint = || {\n-        infcx.tcx.struct_span_lint_hir(\n-            rustc_session::lint::builtin::IMPLIED_BOUNDS_ENTAILMENT,\n-            impl_m_hir_id,\n-            infcx.tcx.def_span(impl_m.def_id),\n-            \"impl method assumes more implied bounds than the corresponding trait method\",\n-            |lint| lint,\n-        );\n-    };\n \n     // Check that all obligations are satisfied by the implementation's\n     // version.\n@@ -346,7 +339,7 @@ fn compare_method_predicate_entailment<'tcx>(\n                 )\n                 .map(|()| {\n                     // If the skip-mode was successful, emit a lint.\n-                    emit_implied_wf_lint();\n+                    emit_implied_wf_lint(infcx.tcx, impl_m, impl_m_hir_id, vec![]);\n                 });\n             }\n             CheckImpliedWfMode::Skip => {\n@@ -382,8 +375,16 @@ fn compare_method_predicate_entailment<'tcx>(\n                     CheckImpliedWfMode::Skip,\n                 )\n                 .map(|()| {\n+                    let bad_args = extract_bad_args_for_implies_lint(\n+                        tcx,\n+                        &errors,\n+                        (trait_m, trait_sig),\n+                        // Unnormalized impl sig corresponds to the HIR types written\n+                        (impl_m, unnormalized_impl_sig),\n+                        impl_m_hir_id,\n+                    );\n                     // If the skip-mode was successful, emit a lint.\n-                    emit_implied_wf_lint();\n+                    emit_implied_wf_lint(tcx, impl_m, impl_m_hir_id, bad_args);\n                 });\n             }\n             CheckImpliedWfMode::Skip => {\n@@ -400,6 +401,141 @@ fn compare_method_predicate_entailment<'tcx>(\n     Ok(())\n }\n \n+fn extract_bad_args_for_implies_lint<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    errors: &[infer::RegionResolutionError<'tcx>],\n+    (trait_m, trait_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n+    (impl_m, impl_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n+    hir_id: hir::HirId,\n+) -> Vec<(Span, Option<String>)> {\n+    let mut blame_generics = vec![];\n+    for error in errors {\n+        // Look for the subregion origin that contains an input/output type\n+        let origin = match error {\n+            infer::RegionResolutionError::ConcreteFailure(o, ..) => o,\n+            infer::RegionResolutionError::GenericBoundFailure(o, ..) => o,\n+            infer::RegionResolutionError::SubSupConflict(_, _, o, ..) => o,\n+            infer::RegionResolutionError::UpperBoundUniverseConflict(.., o, _) => o,\n+        };\n+        // Extract (possible) input/output types from origin\n+        match origin {\n+            infer::SubregionOrigin::Subtype(trace) => {\n+                if let Some((a, b)) = trace.values.ty() {\n+                    blame_generics.extend([a, b]);\n+                }\n+            }\n+            infer::SubregionOrigin::RelateParamBound(_, ty, _) => blame_generics.push(*ty),\n+            infer::SubregionOrigin::ReferenceOutlivesReferent(ty, _) => blame_generics.push(*ty),\n+            _ => {}\n+        }\n+    }\n+\n+    let fn_decl = tcx.hir().fn_decl_by_hir_id(hir_id).unwrap();\n+    let opt_ret_ty = match fn_decl.output {\n+        hir::FnRetTy::DefaultReturn(_) => None,\n+        hir::FnRetTy::Return(ty) => Some(ty),\n+    };\n+\n+    // Map late-bound regions from trait to impl, so the names are right.\n+    let mapping = std::iter::zip(\n+        tcx.fn_sig(trait_m.def_id).bound_vars(),\n+        tcx.fn_sig(impl_m.def_id).bound_vars(),\n+    )\n+    .filter_map(|(impl_bv, trait_bv)| {\n+        if let ty::BoundVariableKind::Region(impl_bv) = impl_bv\n+            && let ty::BoundVariableKind::Region(trait_bv) = trait_bv\n+        {\n+            Some((impl_bv, trait_bv))\n+        } else {\n+            None\n+        }\n+    })\n+    .collect();\n+\n+    // For each arg, see if it was in the \"blame\" of any of the region errors.\n+    // If so, then try to produce a suggestion to replace the argument type with\n+    // one from the trait.\n+    let mut bad_args = vec![];\n+    for (idx, (ty, hir_ty)) in\n+        std::iter::zip(impl_sig.inputs_and_output, fn_decl.inputs.iter().chain(opt_ret_ty))\n+            .enumerate()\n+    {\n+        let expected_ty = trait_sig.inputs_and_output[idx]\n+            .fold_with(&mut RemapLateBound { tcx, mapping: &mapping });\n+        if blame_generics.iter().any(|blame| ty.contains(*blame)) {\n+            let expected_ty_sugg = expected_ty.to_string();\n+            bad_args.push((\n+                hir_ty.span,\n+                // Only suggest something if it actually changed.\n+                (expected_ty_sugg != ty.to_string()).then_some(expected_ty_sugg),\n+            ));\n+        }\n+    }\n+\n+    bad_args\n+}\n+\n+struct RemapLateBound<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    mapping: &'a FxHashMap<ty::BoundRegionKind, ty::BoundRegionKind>,\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for RemapLateBound<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        if let ty::ReFree(fr) = *r {\n+            self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n+                bound_region: self\n+                    .mapping\n+                    .get(&fr.bound_region)\n+                    .copied()\n+                    .unwrap_or(fr.bound_region),\n+                ..fr\n+            }))\n+        } else {\n+            r\n+        }\n+    }\n+}\n+\n+fn emit_implied_wf_lint<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_m: &ty::AssocItem,\n+    hir_id: hir::HirId,\n+    bad_args: Vec<(Span, Option<String>)>,\n+) {\n+    let span: MultiSpan = if bad_args.is_empty() {\n+        tcx.def_span(impl_m.def_id).into()\n+    } else {\n+        bad_args.iter().map(|(span, _)| *span).collect::<Vec<_>>().into()\n+    };\n+    tcx.struct_span_lint_hir(\n+        rustc_session::lint::builtin::IMPLIED_BOUNDS_ENTAILMENT,\n+        hir_id,\n+        span,\n+        \"impl method assumes more implied bounds than the corresponding trait method\",\n+        |lint| {\n+            let bad_args: Vec<_> =\n+                bad_args.into_iter().filter_map(|(span, sugg)| Some((span, sugg?))).collect();\n+            if !bad_args.is_empty() {\n+                lint.multipart_suggestion(\n+                    format!(\n+                        \"replace {} type{} to make the impl signature compatible\",\n+                        pluralize!(\"this\", bad_args.len()),\n+                        pluralize!(bad_args.len())\n+                    ),\n+                    bad_args,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            lint\n+        },\n+    );\n+}\n+\n #[derive(Debug, PartialEq, Eq)]\n enum CheckImpliedWfMode {\n     /// Checks implied well-formedness of the impl method. If it fails, we will\n@@ -480,7 +616,8 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n ) -> Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed> {\n     let impl_m = tcx.opt_associated_item(def_id).unwrap();\n     let trait_m = tcx.opt_associated_item(impl_m.trait_item_def_id.unwrap()).unwrap();\n-    let impl_trait_ref = tcx.impl_trait_ref(impl_m.impl_container(tcx).unwrap()).unwrap();\n+    let impl_trait_ref =\n+        tcx.impl_trait_ref(impl_m.impl_container(tcx).unwrap()).unwrap().subst_identity();\n     let param_env = tcx.param_env(def_id);\n \n     // First, check a few of the same things as `compare_impl_method`,\n@@ -1548,7 +1685,8 @@ pub(super) fn compare_impl_const_raw(\n ) -> Result<(), ErrorGuaranteed> {\n     let impl_const_item = tcx.associated_item(impl_const_item_def);\n     let trait_const_item = tcx.associated_item(trait_const_item_def);\n-    let impl_trait_ref = tcx.impl_trait_ref(impl_const_item.container_id(tcx)).unwrap();\n+    let impl_trait_ref =\n+        tcx.impl_trait_ref(impl_const_item.container_id(tcx)).unwrap().subst_identity();\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     let impl_c_span = tcx.def_span(impl_const_item_def.to_def_id());"}, {"sha": "912e0ec560b49e9768e482ec31ffa98a8740ecd3", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -182,7 +182,7 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         hir::ItemKind::Impl(ref impl_) => {\n             let is_auto = tcx\n                 .impl_trait_ref(def_id)\n-                .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n+                .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.skip_binder().def_id));\n             if let (hir::Defaultness::Default { .. }, true) = (impl_.defaultness, is_auto) {\n                 let sp = impl_.of_trait.as_ref().map_or(item.span, |t| t.path.span);\n                 let mut err =\n@@ -1253,8 +1253,12 @@ fn check_impl<'tcx>(\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold).\n-                let trait_ref = tcx.impl_trait_ref(item.owner_id).unwrap();\n-                let trait_ref = wfcx.normalize(ast_trait_ref.path.span, None, trait_ref);\n+                let trait_ref = tcx.impl_trait_ref(item.owner_id).unwrap().subst_identity();\n+                let trait_ref = wfcx.normalize(\n+                    ast_trait_ref.path.span,\n+                    Some(WellFormedLoc::Ty(item.hir_id().expect_owner().def_id)),\n+                    trait_ref,\n+                );\n                 let trait_pred = ty::TraitPredicate {\n                     trait_ref,\n                     constness: match constness {\n@@ -1263,14 +1267,21 @@ fn check_impl<'tcx>(\n                     },\n                     polarity: ty::ImplPolarity::Positive,\n                 };\n-                let obligations = traits::wf::trait_obligations(\n+                let mut obligations = traits::wf::trait_obligations(\n                     wfcx.infcx,\n                     wfcx.param_env,\n                     wfcx.body_id,\n                     &trait_pred,\n                     ast_trait_ref.path.span,\n                     item,\n                 );\n+                for obligation in &mut obligations {\n+                    if let Some(pred) = obligation.predicate.to_opt_poly_trait_pred()\n+                        && pred.self_ty().skip_binder() == trait_ref.self_ty()\n+                    {\n+                        obligation.cause.span = ast_self_ty.span;\n+                    }\n+                }\n                 debug!(?obligations);\n                 wfcx.register_obligations(obligations);\n             }\n@@ -1339,7 +1350,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n                     // is incorrect when dealing with unused substs, for example\n                     // for `struct Foo<const N: usize, const M: usize = { 1 - 2 }>`\n                     // we should eagerly error.\n-                    let default_ct = tcx.const_param_default(param.def_id);\n+                    let default_ct = tcx.const_param_default(param.def_id).subst_identity();\n                     if !default_ct.needs_subst() {\n                         wfcx.register_wf_obligation(\n                             tcx.def_span(param.def_id),\n@@ -1385,7 +1396,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n             GenericParamDefKind::Const { .. } => {\n                 // If the param has a default, ...\n                 if is_our_default(param) {\n-                    let default_ct = tcx.const_param_default(param.def_id);\n+                    let default_ct = tcx.const_param_default(param.def_id).subst_identity();\n                     // ... and it's not a dependent default, ...\n                     if !default_ct.needs_subst() {\n                         // ... then substitute it with the default."}, {"sha": "4edd9221ab2ea1573469e76a539dd11bc409bbe7", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -192,7 +192,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n     let source = tcx.type_of(impl_did);\n     assert!(!source.has_escaping_bound_vars());\n     let target = {\n-        let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+        let trait_ref = tcx.impl_trait_ref(impl_did).unwrap().subst_identity();\n         assert_eq!(trait_ref.def_id, dispatch_from_dyn_trait);\n \n         trait_ref.substs.type_at(1)\n@@ -354,7 +354,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n     });\n \n     let source = tcx.type_of(impl_did);\n-    let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+    let trait_ref = tcx.impl_trait_ref(impl_did).unwrap().subst_identity();\n     assert_eq!(trait_ref.def_id, coerce_unsized_trait);\n     let target = trait_ref.substs.type_at(1);\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\", source, target);"}, {"sha": "d3b5778ba3b7d61130b41fde472f4d08deec7689", "filename": "compiler/rustc_hir_analysis/src/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -128,7 +128,7 @@ fn coherent_trait(tcx: TyCtxt<'_>, def_id: DefId) {\n \n     let impls = tcx.hir().trait_impls(def_id);\n     for &impl_def_id in impls {\n-        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().subst_identity();\n \n         check_impl(tcx, impl_def_id, trait_ref);\n         check_object_overlap(tcx, impl_def_id, trait_ref);"}, {"sha": "0aadc9f311b033e4ec3983d86fd8b072c4b85f2b", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -21,7 +21,7 @@ pub(crate) fn orphan_check_impl(\n     tcx: TyCtxt<'_>,\n     impl_def_id: LocalDefId,\n ) -> Result<(), ErrorGuaranteed> {\n-    let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+    let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().subst_identity();\n     trait_ref.error_reported()?;\n \n     let ret = do_orphan_check_impl(tcx, trait_ref, impl_def_id);"}, {"sha": "a485768e37b832c551740a167bc64c20efb0df4a", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -14,6 +14,7 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let hir::ItemKind::Impl(ref impl_) = item.kind else { bug!() };\n \n     if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n+        let trait_ref = trait_ref.subst_identity();\n         let trait_def = tcx.trait_def(trait_ref.def_id);\n         let unsafe_attr =\n             impl_.generics.params.iter().find(|p| p.pure_wrt_drop).map(|_| \"may_dangle\");"}, {"sha": "35f47dfc1a5e289b038e15041e93ff421ddd5149", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1339,18 +1339,22 @@ fn suggest_impl_trait<'tcx>(\n     None\n }\n \n-fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n+fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::EarlyBinder<ty::TraitRef<'_>>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n     let item = tcx.hir().expect_item(def_id.expect_local());\n     match item.kind {\n-        hir::ItemKind::Impl(ref impl_) => impl_.of_trait.as_ref().map(|ast_trait_ref| {\n-            let selfty = tcx.type_of(def_id);\n-            icx.astconv().instantiate_mono_trait_ref(\n-                ast_trait_ref,\n-                selfty,\n-                check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n-            )\n-        }),\n+        hir::ItemKind::Impl(ref impl_) => impl_\n+            .of_trait\n+            .as_ref()\n+            .map(|ast_trait_ref| {\n+                let selfty = tcx.type_of(def_id);\n+                icx.astconv().instantiate_mono_trait_ref(\n+                    ast_trait_ref,\n+                    selfty,\n+                    check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n+                )\n+            })\n+            .map(ty::EarlyBinder),\n         _ => bug!(),\n     }\n }"}, {"sha": "62ad0a6c0fc82fb8018a8e6339daa7368e0161c0", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -87,7 +87,8 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n         Node::Item(item) => match item.kind {\n             ItemKind::Impl(ref impl_) => {\n                 if impl_.defaultness.is_default() {\n-                    is_default_impl_trait = tcx.impl_trait_ref(def_id).map(ty::Binder::dummy);\n+                    is_default_impl_trait =\n+                        tcx.impl_trait_ref(def_id).map(|t| ty::Binder::dummy(t.subst_identity()));\n                 }\n                 &impl_.generics\n             }\n@@ -251,7 +252,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n     // for details.\n     if let Node::Item(&Item { kind: ItemKind::Impl { .. }, .. }) = node {\n         let self_ty = tcx.type_of(def_id);\n-        let trait_ref = tcx.impl_trait_ref(def_id);\n+        let trait_ref = tcx.impl_trait_ref(def_id).map(ty::EarlyBinder::subst_identity);\n         cgp::setup_constraining_predicates(\n             tcx,\n             &mut predicates,"}, {"sha": "2dbfc1bc9a229c4a4a069ddf76ab79cbb26db179", "filename": "compiler/rustc_hir_analysis/src/hir_wf_check.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -114,51 +114,63 @@ fn diagnostic_hir_wf_check<'tcx>(\n     // Get the starting `hir::Ty` using our `WellFormedLoc`.\n     // We will walk 'into' this type to try to find\n     // a more precise span for our predicate.\n-    let ty = match loc {\n+    let tys = match loc {\n         WellFormedLoc::Ty(_) => match hir.get(hir_id) {\n             hir::Node::ImplItem(item) => match item.kind {\n-                hir::ImplItemKind::Type(ty) => Some(ty),\n-                hir::ImplItemKind::Const(ty, _) => Some(ty),\n+                hir::ImplItemKind::Type(ty) => vec![ty],\n+                hir::ImplItemKind::Const(ty, _) => vec![ty],\n                 ref item => bug!(\"Unexpected ImplItem {:?}\", item),\n             },\n             hir::Node::TraitItem(item) => match item.kind {\n-                hir::TraitItemKind::Type(_, ty) => ty,\n-                hir::TraitItemKind::Const(ty, _) => Some(ty),\n+                hir::TraitItemKind::Type(_, ty) => ty.into_iter().collect(),\n+                hir::TraitItemKind::Const(ty, _) => vec![ty],\n                 ref item => bug!(\"Unexpected TraitItem {:?}\", item),\n             },\n             hir::Node::Item(item) => match item.kind {\n-                hir::ItemKind::Static(ty, _, _) | hir::ItemKind::Const(ty, _) => Some(ty),\n-                hir::ItemKind::Impl(ref impl_) => {\n-                    assert!(impl_.of_trait.is_none(), \"Unexpected trait impl: {:?}\", impl_);\n-                    Some(impl_.self_ty)\n-                }\n+                hir::ItemKind::Static(ty, _, _) | hir::ItemKind::Const(ty, _) => vec![ty],\n+                hir::ItemKind::Impl(ref impl_) => match &impl_.of_trait {\n+                    Some(t) => t\n+                        .path\n+                        .segments\n+                        .last()\n+                        .iter()\n+                        .flat_map(|seg| seg.args().args)\n+                        .filter_map(|arg| {\n+                            if let hir::GenericArg::Type(ty) = arg { Some(*ty) } else { None }\n+                        })\n+                        .chain([impl_.self_ty])\n+                        .collect(),\n+                    None => {\n+                        vec![impl_.self_ty]\n+                    }\n+                },\n                 ref item => bug!(\"Unexpected item {:?}\", item),\n             },\n-            hir::Node::Field(field) => Some(field.ty),\n+            hir::Node::Field(field) => vec![field.ty],\n             hir::Node::ForeignItem(ForeignItem {\n                 kind: ForeignItemKind::Static(ty, _), ..\n-            }) => Some(*ty),\n+            }) => vec![*ty],\n             hir::Node::GenericParam(hir::GenericParam {\n                 kind: hir::GenericParamKind::Type { default: Some(ty), .. },\n                 ..\n-            }) => Some(*ty),\n+            }) => vec![*ty],\n             ref node => bug!(\"Unexpected node {:?}\", node),\n         },\n         WellFormedLoc::Param { function: _, param_idx } => {\n             let fn_decl = hir.fn_decl_by_hir_id(hir_id).unwrap();\n             // Get return type\n             if param_idx as usize == fn_decl.inputs.len() {\n                 match fn_decl.output {\n-                    hir::FnRetTy::Return(ty) => Some(ty),\n+                    hir::FnRetTy::Return(ty) => vec![ty],\n                     // The unit type `()` is always well-formed\n-                    hir::FnRetTy::DefaultReturn(_span) => None,\n+                    hir::FnRetTy::DefaultReturn(_span) => vec![],\n                 }\n             } else {\n-                Some(&fn_decl.inputs[param_idx as usize])\n+                vec![&fn_decl.inputs[param_idx as usize]]\n             }\n         }\n     };\n-    if let Some(ty) = ty {\n+    for ty in tys {\n         visitor.visit_ty(ty);\n     }\n     visitor.cause"}, {"sha": "4fe893442b9bd2987c0ed22233a1eb88a2fe5c9c", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -85,7 +85,7 @@ fn enforce_impl_params_are_constrained(tcx: TyCtxt<'_>, impl_def_id: LocalDefId)\n     }\n     let impl_generics = tcx.generics_of(impl_def_id);\n     let impl_predicates = tcx.predicates_of(impl_def_id);\n-    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n+    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).map(ty::EarlyBinder::subst_identity);\n \n     let mut input_parameters = cgp::parameters_for_impl(impl_self_ty, impl_trait_ref);\n     cgp::identify_constrained_generic_params("}, {"sha": "bcda26c4cc854156c2c7ed4fdfa75d8e1e95a2e7", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -90,7 +90,7 @@ pub(super) fn check_min_specialization(tcx: TyCtxt<'_>, impl_def_id: LocalDefId)\n \n fn parent_specialization_node(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId) -> Option<Node> {\n     let trait_ref = tcx.impl_trait_ref(impl1_def_id)?;\n-    let trait_def = tcx.trait_def(trait_ref.def_id);\n+    let trait_def = tcx.trait_def(trait_ref.skip_binder().def_id);\n \n     let impl2_node = trait_def.ancestors(tcx, impl1_def_id.to_def_id()).ok()?.nth(1)?;\n \n@@ -207,7 +207,7 @@ fn unconstrained_parent_impl_substs<'tcx>(\n     let impl_generic_predicates = tcx.predicates_of(impl_def_id);\n     let mut unconstrained_parameters = FxHashSet::default();\n     let mut constrained_params = FxHashSet::default();\n-    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n+    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).map(ty::EarlyBinder::subst_identity);\n \n     // Unfortunately the functions in `constrained_generic_parameters` don't do\n     // what we want here. We want only a list of constrained parameters while\n@@ -370,7 +370,7 @@ fn check_predicates<'tcx>(\n     });\n \n     // Include the well-formed predicates of the type parameters of the impl.\n-    for arg in tcx.impl_trait_ref(impl1_def_id).unwrap().substs {\n+    for arg in tcx.impl_trait_ref(impl1_def_id).unwrap().subst_identity().substs {\n         let infcx = &tcx.infer_ctxt().build();\n         let obligations = wf::obligations(\n             infcx,"}, {"sha": "f1a4f94cd0151e9f4c2b30526c2d3e0413bd123e", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -659,8 +659,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         if !self.maybe_suggest_bad_array_definition(&mut err, call_expr, callee_expr) {\n-            if let Some((maybe_def, output_ty, _)) =\n-                self.extract_callable_info(callee_expr, callee_ty)\n+            if let Some((maybe_def, output_ty, _)) = self.extract_callable_info(callee_ty)\n                 && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n             {\n                 let descr = match maybe_def {"}, {"sha": "57feefbcab6c8cc25b246e313fbf2fbd39f2dced", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 132, "deletions": 1, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,4 +1,7 @@\n use crate::coercion::CoerceMany;\n+use crate::errors::{\n+    LangStartIncorrectNumberArgs, LangStartIncorrectParam, LangStartIncorrectRetTy,\n+};\n use crate::gather_locals::GatherLocalsVisitor;\n use crate::FnCtxt;\n use crate::GeneratorTypes;\n@@ -9,8 +12,9 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir_analysis::check::fn_maybe_err;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::RegionVariableOrigin;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Binder, Ty, TyCtxt};\n use rustc_span::def_id::LocalDefId;\n+use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use std::cell::RefCell;\n \n@@ -168,6 +172,10 @@ pub(super) fn check_fn<'a, 'tcx>(\n         check_panic_info_fn(tcx, panic_impl_did.expect_local(), fn_sig, decl, declared_ret_ty);\n     }\n \n+    if let Some(lang_start_defid) = tcx.lang_items().start_fn() && lang_start_defid == hir.local_def_id(fn_id).to_def_id() {\n+        check_lang_start_fn(tcx, fn_sig, decl, fn_def_id);\n+    }\n+\n     gen_ty\n }\n \n@@ -223,3 +231,126 @@ fn check_panic_info_fn(\n         tcx.sess.span_err(span, \"should have no const parameters\");\n     }\n }\n+\n+fn check_lang_start_fn<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    fn_sig: ty::FnSig<'tcx>,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n+    def_id: LocalDefId,\n+) {\n+    let inputs = fn_sig.inputs();\n+\n+    let arg_count = inputs.len();\n+    if arg_count != 4 {\n+        tcx.sess.emit_err(LangStartIncorrectNumberArgs {\n+            params_span: tcx.def_span(def_id),\n+            found_param_count: arg_count,\n+        });\n+    }\n+\n+    // only check args if they should exist by checking the count\n+    // note: this does not handle args being shifted or their order swapped very nicely\n+    // but it's a lang item, users shouldn't frequently encounter this\n+\n+    // first arg is `main: fn() -> T`\n+    if let Some(&main_arg) = inputs.get(0) {\n+        // make a Ty for the generic on the fn for diagnostics\n+        // FIXME: make the lang item generic checks check for the right generic *kind*\n+        // for example `start`'s generic should be a type parameter\n+        let generics = tcx.generics_of(def_id);\n+        let fn_generic = generics.param_at(0, tcx);\n+        let generic_tykind =\n+            ty::Param(ty::ParamTy { index: fn_generic.index, name: fn_generic.name });\n+        let generic_ty = tcx.mk_ty(generic_tykind);\n+        let expected_fn_sig =\n+            tcx.mk_fn_sig([].iter(), &generic_ty, false, hir::Unsafety::Normal, Abi::Rust);\n+        let expected_ty = tcx.mk_fn_ptr(Binder::dummy(expected_fn_sig));\n+\n+        // we emit the same error to suggest changing the arg no matter what's wrong with the arg\n+        let emit_main_fn_arg_err = || {\n+            tcx.sess.emit_err(LangStartIncorrectParam {\n+                param_span: decl.inputs[0].span,\n+                param_num: 1,\n+                expected_ty: expected_ty,\n+                found_ty: main_arg,\n+            });\n+        };\n+\n+        if let ty::FnPtr(main_fn_sig) = main_arg.kind() {\n+            let main_fn_inputs = main_fn_sig.inputs();\n+            if main_fn_inputs.iter().count() != 0 {\n+                emit_main_fn_arg_err();\n+            }\n+\n+            let output = main_fn_sig.output();\n+            output.map_bound(|ret_ty| {\n+                // if the output ty is a generic, it's probably the right one\n+                if !matches!(ret_ty.kind(), ty::Param(_)) {\n+                    emit_main_fn_arg_err();\n+                }\n+            });\n+        } else {\n+            emit_main_fn_arg_err();\n+        }\n+    }\n+\n+    // second arg is isize\n+    if let Some(&argc_arg) = inputs.get(1) {\n+        if argc_arg != tcx.types.isize {\n+            tcx.sess.emit_err(LangStartIncorrectParam {\n+                param_span: decl.inputs[1].span,\n+                param_num: 2,\n+                expected_ty: tcx.types.isize,\n+                found_ty: argc_arg,\n+            });\n+        }\n+    }\n+\n+    // third arg is `*const *const u8`\n+    if let Some(&argv_arg) = inputs.get(2) {\n+        let mut argv_is_okay = false;\n+        if let ty::RawPtr(outer_ptr) = argv_arg.kind() {\n+            if outer_ptr.mutbl.is_not() {\n+                if let ty::RawPtr(inner_ptr) = outer_ptr.ty.kind() {\n+                    if inner_ptr.mutbl.is_not() && inner_ptr.ty == tcx.types.u8 {\n+                        argv_is_okay = true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        if !argv_is_okay {\n+            let inner_ptr_ty =\n+                tcx.mk_ptr(ty::TypeAndMut { mutbl: hir::Mutability::Not, ty: tcx.types.u8 });\n+            let expected_ty =\n+                tcx.mk_ptr(ty::TypeAndMut { mutbl: hir::Mutability::Not, ty: inner_ptr_ty });\n+            tcx.sess.emit_err(LangStartIncorrectParam {\n+                param_span: decl.inputs[2].span,\n+                param_num: 3,\n+                expected_ty,\n+                found_ty: argv_arg,\n+            });\n+        }\n+    }\n+\n+    // fourth arg is `sigpipe: u8`\n+    if let Some(&sigpipe_arg) = inputs.get(3) {\n+        if sigpipe_arg != tcx.types.u8 {\n+            tcx.sess.emit_err(LangStartIncorrectParam {\n+                param_span: decl.inputs[3].span,\n+                param_num: 4,\n+                expected_ty: tcx.types.u8,\n+                found_ty: sigpipe_arg,\n+            });\n+        }\n+    }\n+\n+    // output type is isize\n+    if fn_sig.output() != tcx.types.isize {\n+        tcx.sess.emit_err(LangStartIncorrectRetTy {\n+            ret_span: decl.output.span(),\n+            expected_ty: tcx.types.isize,\n+            found_ty: fn_sig.output(),\n+        });\n+    }\n+}"}, {"sha": "665dc8b6a2f2a4ed18091fb4952e550ca82ba30c", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -85,6 +85,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n         self.check_for_range_as_method_call(err, expr, expr_ty, expected);\n         self.check_for_binding_assigned_block_without_tail_expression(err, expr, expr_ty, expected);\n+        self.check_wrong_return_type_due_to_generic_arg(err, expr, expr_ty);\n     }\n \n     /// Requires that the two types unify, and prints an error message if\n@@ -1941,4 +1942,77 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.span_label(block.span, \"this block is missing a tail expression\");\n         }\n     }\n+\n+    fn check_wrong_return_type_due_to_generic_arg(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        checked_ty: Ty<'tcx>,\n+    ) {\n+        let Some(hir::Node::Expr(parent_expr)) = self.tcx.hir().find_parent(expr.hir_id) else { return; };\n+        enum CallableKind {\n+            Function,\n+            Method,\n+            Constructor,\n+        }\n+        let mut maybe_emit_help = |def_id: hir::def_id::DefId,\n+                                   callable: rustc_span::symbol::Ident,\n+                                   args: &[hir::Expr<'_>],\n+                                   kind: CallableKind| {\n+            let arg_idx = args.iter().position(|a| a.hir_id == expr.hir_id).unwrap();\n+            let fn_ty = self.tcx.bound_type_of(def_id).0;\n+            if !fn_ty.is_fn() {\n+                return;\n+            }\n+            let fn_sig = fn_ty.fn_sig(self.tcx).skip_binder();\n+            let Some(&arg) = fn_sig.inputs().get(arg_idx + if matches!(kind, CallableKind::Method) { 1 } else { 0 }) else { return; };\n+            if matches!(arg.kind(), ty::Param(_))\n+                && fn_sig.output().contains(arg)\n+                && self.node_ty(args[arg_idx].hir_id) == checked_ty\n+            {\n+                let mut multi_span: MultiSpan = parent_expr.span.into();\n+                multi_span.push_span_label(\n+                    args[arg_idx].span,\n+                    format!(\n+                        \"this argument influences the {} of `{}`\",\n+                        if matches!(kind, CallableKind::Constructor) {\n+                            \"type\"\n+                        } else {\n+                            \"return type\"\n+                        },\n+                        callable\n+                    ),\n+                );\n+                err.span_help(\n+                    multi_span,\n+                    format!(\n+                        \"the {} `{}` due to the type of the argument passed\",\n+                        match kind {\n+                            CallableKind::Function => \"return type of this call is\",\n+                            CallableKind::Method => \"return type of this call is\",\n+                            CallableKind::Constructor => \"type constructed contains\",\n+                        },\n+                        checked_ty\n+                    ),\n+                );\n+            }\n+        };\n+        match parent_expr.kind {\n+            hir::ExprKind::Call(fun, args) => {\n+                let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = fun.kind else { return; };\n+                let hir::def::Res::Def(kind, def_id) = path.res else { return; };\n+                let callable_kind = if matches!(kind, hir::def::DefKind::Ctor(_, _)) {\n+                    CallableKind::Constructor\n+                } else {\n+                    CallableKind::Function\n+                };\n+                maybe_emit_help(def_id, path.segments[0].ident, args, callable_kind);\n+            }\n+            hir::ExprKind::MethodCall(method, _receiver, args, _span) => {\n+                let Some(def_id) = self.typeck_results.borrow().type_dependent_def_id(parent_expr.hir_id) else { return; };\n+                maybe_emit_help(def_id, method.ident, args, CallableKind::Method)\n+            }\n+            _ => return,\n+        }\n+    }\n }"}, {"sha": "5b4fd5e4a5283833b8eaa051df969a021e165161", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -172,3 +172,36 @@ impl AddToDiagnostic for TypeMismatchFruTypo {\n         );\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_lang_start_incorrect_number_params)]\n+#[note(hir_typeck_lang_start_incorrect_number_params_note_expected_count)]\n+#[note(hir_typeck_lang_start_expected_sig_note)]\n+pub struct LangStartIncorrectNumberArgs {\n+    #[primary_span]\n+    pub params_span: Span,\n+    pub found_param_count: usize,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_lang_start_incorrect_param)]\n+pub struct LangStartIncorrectParam<'tcx> {\n+    #[primary_span]\n+    #[suggestion(style = \"short\", code = \"{expected_ty}\", applicability = \"machine-applicable\")]\n+    pub param_span: Span,\n+\n+    pub param_num: usize,\n+    pub expected_ty: Ty<'tcx>,\n+    pub found_ty: Ty<'tcx>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_lang_start_incorrect_ret_ty)]\n+pub struct LangStartIncorrectRetTy<'tcx> {\n+    #[primary_span]\n+    #[suggestion(style = \"short\", code = \"{expected_ty}\", applicability = \"machine-applicable\")]\n+    pub ret_span: Span,\n+\n+    pub expected_ty: Ty<'tcx>,\n+    pub found_ty: Ty<'tcx>,\n+}"}, {"sha": "c8cda0dc90c6daf39095057859453ec164196609", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -417,7 +417,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                                 // Named constants have to be equated with the value\n                                 // being matched, so that's a read of the value being matched.\n                                 //\n-                                // FIXME: We don't actually  reads for ZSTs.\n+                                // FIXME: We don't actually reads for ZSTs.\n                                 needs_to_be_read = true;\n                             }\n                             _ => {"}, {"sha": "6ed8adb47425a80197d6a2453f54302953fbb376", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1224,9 +1224,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     GenericParamDefKind::Const { has_default } => {\n                         if !infer_args && has_default {\n-                            tcx.bound_const_param_default(param.def_id)\n-                                .subst(tcx, substs.unwrap())\n-                                .into()\n+                            tcx.const_param_default(param.def_id).subst(tcx, substs.unwrap()).into()\n                         } else {\n                             self.fcx.var_for_def(self.span, param)\n                         }"}, {"sha": "4d673ac91472f10f2351b4ba265eaed4cd6b8329", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 6, "deletions": 97, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -11,7 +11,6 @@ use rustc_hir::{\n     Expr, ExprKind, GenericBound, Node, Path, QPath, Stmt, StmtKind, TyKind, WherePredicate,\n };\n use rustc_hir_analysis::astconv::AstConv;\n-use rustc_infer::infer;\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{\n@@ -23,9 +22,9 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt;\n use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use rustc_trait_selection::traits::NormalizeExt;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(crate) fn body_fn_sig(&self) -> Option<ty::FnSig<'tcx>> {\n@@ -94,7 +93,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         found: Ty<'tcx>,\n         can_satisfy: impl FnOnce(Ty<'tcx>) -> bool,\n     ) -> bool {\n-        let Some((def_id_or_name, output, inputs)) = self.extract_callable_info(expr, found)\n+        let Some((def_id_or_name, output, inputs)) = self.extract_callable_info(found)\n             else { return false; };\n         if can_satisfy(output) {\n             let (sugg_call, mut applicability) = match inputs.len() {\n@@ -163,99 +162,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// because the callable type must also be well-formed to be called.\n     pub(in super::super) fn extract_callable_info(\n         &self,\n-        expr: &Expr<'_>,\n-        found: Ty<'tcx>,\n+        ty: Ty<'tcx>,\n     ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)> {\n-        // Autoderef is useful here because sometimes we box callables, etc.\n-        let Some((def_id_or_name, output, inputs)) = self.autoderef(expr.span, found).silence_errors().find_map(|(found, _)| {\n-            match *found.kind() {\n-                ty::FnPtr(fn_sig) =>\n-                    Some((DefIdOrName::Name(\"function pointer\"), fn_sig.output(), fn_sig.inputs())),\n-                ty::FnDef(def_id, _) => {\n-                    let fn_sig = found.fn_sig(self.tcx);\n-                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs()))\n-                }\n-                ty::Closure(def_id, substs) => {\n-                    let fn_sig = substs.as_closure().sig();\n-                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs().map_bound(|inputs| &inputs[1..])))\n-                }\n-                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                    self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n-                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n-                        // args tuple will always be substs[1]\n-                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                        {\n-                            Some((\n-                                DefIdOrName::DefId(def_id),\n-                                pred.kind().rebind(proj.term.ty().unwrap()),\n-                                pred.kind().rebind(args.as_slice()),\n-                            ))\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                }\n-                ty::Dynamic(data, _, ty::Dyn) => {\n-                    data.iter().find_map(|pred| {\n-                        if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n-                        && Some(proj.def_id) == self.tcx.lang_items().fn_once_output()\n-                        // for existential projection, substs are shifted over by 1\n-                        && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n-                        {\n-                            Some((\n-                                DefIdOrName::Name(\"trait object\"),\n-                                pred.rebind(proj.term.ty().unwrap()),\n-                                pred.rebind(args.as_slice()),\n-                            ))\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                }\n-                ty::Param(param) => {\n-                    let def_id = self.tcx.generics_of(self.body_id.owner).type_param(&param, self.tcx).def_id;\n-                    self.tcx.predicates_of(self.body_id.owner).predicates.iter().find_map(|(pred, _)| {\n-                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n-                        && proj.projection_ty.self_ty() == found\n-                        // args tuple will always be substs[1]\n-                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                        {\n-                            Some((\n-                                DefIdOrName::DefId(def_id),\n-                                pred.kind().rebind(proj.term.ty().unwrap()),\n-                                pred.kind().rebind(args.as_slice()),\n-                            ))\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                }\n-                _ => None,\n-            }\n-        }) else { return None; };\n-\n-        let output = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, output);\n-        let inputs = inputs\n-            .skip_binder()\n-            .iter()\n-            .map(|ty| {\n-                self.replace_bound_vars_with_fresh_vars(\n-                    expr.span,\n-                    infer::FnCall,\n-                    inputs.rebind(*ty),\n-                )\n-            })\n-            .collect();\n-\n-        // We don't want to register any extra obligations, which should be\n-        // implied by wf, but also because that would possibly result in\n-        // erroneous errors later on.\n-        let infer::InferOk { value: output, obligations: _ } =\n-            self.at(&self.misc(expr.span), self.param_env).normalize(output);\n-\n-        if output.is_ty_var() { None } else { Some((def_id_or_name, output, inputs)) }\n+        self.err_ctxt().extract_callable_info(self.body_id, self.param_env, ty)\n     }\n \n     pub fn suggest_two_fn_call(\n@@ -267,9 +176,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         rhs_ty: Ty<'tcx>,\n         can_satisfy: impl FnOnce(Ty<'tcx>, Ty<'tcx>) -> bool,\n     ) -> bool {\n-        let Some((_, lhs_output_ty, lhs_inputs)) = self.extract_callable_info(lhs_expr, lhs_ty)\n+        let Some((_, lhs_output_ty, lhs_inputs)) = self.extract_callable_info(lhs_ty)\n             else { return false; };\n-        let Some((_, rhs_output_ty, rhs_inputs)) = self.extract_callable_info(rhs_expr, rhs_ty)\n+        let Some((_, rhs_output_ty, rhs_inputs)) = self.extract_callable_info(rhs_ty)\n             else { return false; };\n \n         if can_satisfy(lhs_output_ty, rhs_output_ty) {"}, {"sha": "948a14604d4376929fe0b49c6a0d3ee347ee8701", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -232,7 +232,7 @@ pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError<'tcx>>;\n pub enum Mode {\n     // An expression of the form `receiver.method_name(...)`.\n     // Autoderefs are performed on `receiver`, lookup is done based on the\n-    // `self` argument  of the method, and static methods aren't considered.\n+    // `self` argument of the method, and static methods aren't considered.\n     MethodCall,\n     // An expression of the form `Type::item` or `<T>::item`.\n     // No autoderefs are performed, lookup is done based on the type each\n@@ -1587,11 +1587,29 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         let o = self.resolve_vars_if_possible(o);\n                         if !self.predicate_may_hold(&o) {\n                             result = ProbeResult::NoMatch;\n-                            possibly_unsatisfied_predicates.push((\n-                                o.predicate,\n-                                None,\n-                                Some(o.cause),\n-                            ));\n+                            let parent_o = o.clone();\n+                            let implied_obligations =\n+                                traits::elaborate_obligations(self.tcx, vec![o]);\n+                            for o in implied_obligations {\n+                                let parent = if o == parent_o {\n+                                    None\n+                                } else {\n+                                    if o.predicate.to_opt_poly_trait_pred().map(|p| p.def_id())\n+                                        == self.tcx.lang_items().sized_trait()\n+                                    {\n+                                        // We don't care to talk about implicit `Sized` bounds.\n+                                        continue;\n+                                    }\n+                                    Some(parent_o.predicate)\n+                                };\n+                                if !self.predicate_may_hold(&o) {\n+                                    possibly_unsatisfied_predicates.push((\n+                                        o.predicate,\n+                                        parent,\n+                                        Some(o.cause),\n+                                    ));\n+                                }\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "2e1fc4c38b542d5cae2f9e6b281fd652f8c409ec", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 60, "deletions": 20, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -505,19 +505,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                             _ => None,\n                         };\n-                        if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n-                            if let Some(g) = kind.generics() {\n-                                let key = (\n-                                    g.tail_span_for_predicate_suggestion(),\n-                                    g.add_where_or_trailing_comma(),\n-                                );\n-                                type_params\n-                                    .entry(key)\n-                                    .or_insert_with(FxHashSet::default)\n-                                    .insert(obligation.to_owned());\n-                            }\n+                        if let Some(hir::Node::Item(hir::Item { kind, .. })) = node\n+                            && let Some(g) = kind.generics()\n+                        {\n+                            let key = (\n+                                g.tail_span_for_predicate_suggestion(),\n+                                g.add_where_or_trailing_comma(),\n+                            );\n+                            type_params\n+                                .entry(key)\n+                                .or_insert_with(FxHashSet::default)\n+                                .insert(obligation.to_owned());\n+                            return true;\n                         }\n                     }\n+                    false\n                 };\n             let mut bound_span_label = |self_ty: Ty<'_>, obligation: &str, quiet: &str| {\n                 let msg = format!(\n@@ -692,7 +694,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             \"auto trait is invoked with no method error, but no error reported?\",\n                         );\n                     }\n-                    Some(_) => unreachable!(),\n+                    Some(Node::Item(hir::Item {\n+                        ident, kind: hir::ItemKind::Trait(..), ..\n+                    })) => {\n+                        skip_list.insert(p);\n+                        let entry = spanned_predicates.entry(ident.span);\n+                        let entry = entry.or_insert_with(|| {\n+                            (FxHashSet::default(), FxHashSet::default(), Vec::new())\n+                        });\n+                        entry.0.insert(cause.span);\n+                        entry.1.insert((ident.span, \"\"));\n+                        entry.1.insert((cause.span, \"unsatisfied trait bound introduced here\"));\n+                        entry.2.push(p);\n+                    }\n+                    Some(node) => unreachable!(\"encountered `{node:?}`\"),\n                     None => (),\n                 }\n             }\n@@ -719,19 +734,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 unsatisfied_bounds = true;\n             }\n \n+            let mut suggested_bounds = FxHashSet::default();\n             // The requirements that didn't have an `impl` span to show.\n             let mut bound_list = unsatisfied_predicates\n                 .iter()\n                 .filter_map(|(pred, parent_pred, _cause)| {\n+                    let mut suggested = false;\n                     format_pred(*pred).map(|(p, self_ty)| {\n-                        collect_type_param_suggestions(self_ty, *pred, &p);\n+                        if let Some(parent) = parent_pred && suggested_bounds.contains(parent) {\n+                            // We don't suggest `PartialEq` when we already suggest `Eq`.\n+                        } else if !suggested_bounds.contains(pred) {\n+                            if collect_type_param_suggestions(self_ty, *pred, &p) {\n+                                suggested = true;\n+                                suggested_bounds.insert(pred);\n+                            }\n+                        }\n                         (\n                             match parent_pred {\n                                 None => format!(\"`{}`\", &p),\n                                 Some(parent_pred) => match format_pred(*parent_pred) {\n                                     None => format!(\"`{}`\", &p),\n                                     Some((parent_p, _)) => {\n-                                        collect_type_param_suggestions(self_ty, *parent_pred, &p);\n+                                        if !suggested\n+                                            && !suggested_bounds.contains(pred)\n+                                            && !suggested_bounds.contains(parent_pred)\n+                                        {\n+                                            if collect_type_param_suggestions(\n+                                                self_ty,\n+                                                *parent_pred,\n+                                                &p,\n+                                            ) {\n+                                                suggested_bounds.insert(pred);\n+                                            }\n+                                        }\n                                         format!(\"`{}`\\nwhich is required by `{}`\", p, parent_p)\n                                     }\n                                 },\n@@ -1037,7 +1072,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // the impl, if local to crate (item may be defaulted), else nothing.\n                     let Some(item) = self.associated_value(impl_did, item_name).or_else(|| {\n                         let impl_trait_ref = self.tcx.impl_trait_ref(impl_did)?;\n-                        self.associated_value(impl_trait_ref.def_id, item_name)\n+                        self.associated_value(impl_trait_ref.skip_binder().def_id, item_name)\n                     }) else {\n                         continue;\n                     };\n@@ -1055,7 +1090,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let insertion = match self.tcx.impl_trait_ref(impl_did) {\n                         None => String::new(),\n                         Some(trait_ref) => {\n-                            format!(\" of the trait `{}`\", self.tcx.def_path_str(trait_ref.def_id))\n+                            format!(\n+                                \" of the trait `{}`\",\n+                                self.tcx.def_path_str(trait_ref.skip_binder().def_id)\n+                            )\n                         }\n                     };\n \n@@ -1086,7 +1124,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     if let Some(sugg_span) = sugg_span\n                         && let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n-                        let path = self.tcx.def_path_str(trait_ref.def_id);\n+                        let path = self.tcx.def_path_str(trait_ref.skip_binder().def_id);\n \n                         let ty = match item.kind {\n                             ty::AssocKind::Const | ty::AssocKind::Type => rcvr_ty,\n@@ -2581,7 +2619,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             self.tcx.impl_polarity(*imp_did) == ty::ImplPolarity::Negative\n                         })\n                         .any(|imp_did| {\n-                            let imp = self.tcx.impl_trait_ref(imp_did).unwrap();\n+                            let imp = self.tcx.impl_trait_ref(imp_did).unwrap().subst_identity();\n                             let imp_simp =\n                                 simplify_type(self.tcx, imp.self_ty(), TreatParams::AsPlaceholder);\n                             imp_simp.map_or(false, |s| s == simp_rcvr_ty)\n@@ -2662,8 +2700,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         found: Ty<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> bool {\n-        let Some((_def_id_or_name, output, _inputs)) = self.extract_callable_info(expr, found)\n-        else { return false; };\n+        let Some((_def_id_or_name, output, _inputs)) =\n+            self.extract_callable_info(found) else {\n+                return false;\n+        };\n \n         if !self.can_coerce(output, expected) {\n             return false;"}, {"sha": "abd99fc74dacc323b664a50f396b4911f15a6be5", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1782,9 +1782,9 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                             // like when you have two references but one is `usize` and the other\n                             // is `f32`. In those cases we still want to show the `note`. If the\n                             // value from `ef` is `Infer(_)`, then we ignore it.\n-                            if !ef.expected.is_ty_infer() {\n+                            if !ef.expected.is_ty_or_numeric_infer() {\n                                 ef.expected != values.expected\n-                            } else if !ef.found.is_ty_infer() {\n+                            } else if !ef.found.is_ty_or_numeric_infer() {\n                                 ef.found != values.found\n                             } else {\n                                 false\n@@ -1923,6 +1923,22 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         (ty::Tuple(fields), _) => {\n                             self.emit_tuple_wrap_err(&mut err, span, found, fields)\n                         }\n+                        // If a byte was expected and the found expression is a char literal\n+                        // containing a single ASCII character, perhaps the user meant to write `b'c'` to\n+                        // specify a byte literal\n+                        (ty::Uint(ty::UintTy::U8), ty::Char) => {\n+                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n+                                && let Some(code) = code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n+                                && code.chars().next().map_or(false, |c| c.is_ascii())\n+                            {\n+                                err.span_suggestion(\n+                                    span,\n+                                    \"if you meant to write a byte literal, prefix with `b`\",\n+                                    format!(\"b'{}'\", escape_literal(code)),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                        }\n                         // If a character was expected and the found expression is a string literal\n                         // containing a single character, perhaps the user meant to write `'c'` to\n                         // specify a character literal (issue #92479)"}, {"sha": "b8c843a8a5a225f36b692f6c786d29f4a9c85d4b", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -78,7 +78,7 @@ impl InferenceDiagnosticsData {\n     }\n \n     fn where_x_is_kind(&self, in_type: Ty<'_>) -> &'static str {\n-        if in_type.is_ty_infer() {\n+        if in_type.is_ty_or_numeric_infer() {\n             \"\"\n         } else if self.name == \"_\" {\n             // FIXME: Consider specializing this message if there is a single `_`\n@@ -195,12 +195,12 @@ fn ty_to_string<'tcx>(\n         // invalid pseudo-syntax, we want the `fn`-pointer output instead.\n         (ty::FnDef(..), _) => ty.fn_sig(infcx.tcx).print(printer).unwrap().into_buffer(),\n         (_, Some(def_id))\n-            if ty.is_ty_infer()\n+            if ty.is_ty_or_numeric_infer()\n                 && infcx.tcx.get_diagnostic_item(sym::iterator_collect_fn) == Some(def_id) =>\n         {\n             \"Vec<_>\".to_string()\n         }\n-        _ if ty.is_ty_infer() => \"/* Type */\".to_string(),\n+        _ if ty.is_ty_or_numeric_infer() => \"/* Type */\".to_string(),\n         // FIXME: The same thing for closures, but this only works when the closure\n         // does not capture anything.\n         //\n@@ -680,7 +680,7 @@ impl<'tcx> InferSourceKind<'tcx> {\n             | InferSourceKind::ClosureReturn { ty, .. } => {\n                 if ty.is_closure() {\n                     (\"closure\", closure_as_fn_str(infcx, ty))\n-                } else if !ty.is_ty_infer() {\n+                } else if !ty.is_ty_or_numeric_infer() {\n                     (\"normal\", ty_to_string(infcx, ty, None))\n                 } else {\n                     (\"other\", String::new())\n@@ -813,7 +813,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n         self.attempt += 1;\n         if let Some(InferSource { kind: InferSourceKind::GenericArg { def_id: did, ..}, .. }) = self.infer_source\n             && let InferSourceKind::LetBinding { ref ty, ref mut def_id, ..} = new_source.kind\n-            && ty.is_ty_infer()\n+            && ty.is_ty_or_numeric_infer()\n         {\n             // Customize the output so we talk about `let x: Vec<_> = iter.collect();` instead of\n             // `let x: _ = iter.collect();`, as this is a very common case."}, {"sha": "021e741ee2f710b871fb74f33e65cedb1f6152fc", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -320,6 +320,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             .impl_trait_ref(impl_def_id)\n             else { return; };\n         let trait_substs = trait_ref\n+            .subst_identity()\n             // Replace the explicit self type with `Self` for better suggestion rendering\n             .with_self_ty(self.tcx, self.tcx.mk_ty_param(0, kw::SelfUpper))\n             .substs;"}, {"sha": "bad07561811bcab8a647b807b84d8a52d10487b7", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,7 +1,7 @@\n use smallvec::smallvec;\n \n use crate::infer::outlives::components::{push_outlives_components, Component};\n-use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n+use crate::traits::{self, Obligation, ObligationCause, PredicateObligation};\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_middle::ty::{self, ToPredicate, TyCtxt};\n use rustc_span::symbol::Ident;\n@@ -145,16 +145,28 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n-                let obligations = predicates.predicates.iter().map(|&(mut pred, _)| {\n+                let obligations = predicates.predicates.iter().map(|&(mut pred, span)| {\n                     // when parent predicate is non-const, elaborate it to non-const predicates.\n                     if data.constness == ty::BoundConstness::NotConst {\n                         pred = pred.without_const(tcx);\n                     }\n \n+                    let cause = obligation.cause.clone().derived_cause(\n+                        bound_predicate.rebind(data),\n+                        |derived| {\n+                            traits::ImplDerivedObligation(Box::new(\n+                                traits::ImplDerivedObligationCause {\n+                                    derived,\n+                                    impl_def_id: data.def_id(),\n+                                    span,\n+                                },\n+                            ))\n+                        },\n+                    );\n                     predicate_obligation(\n                         pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n                         obligation.param_env,\n-                        obligation.cause.clone(),\n+                        cause,\n                     )\n                 });\n                 debug!(?data, ?obligations, \"super_predicates\");"}, {"sha": "f817c5bc1cd73fd08a6440c0abf4df017a13bb53", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -45,6 +45,7 @@ rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }\n rustc_privacy = { path = \"../rustc_privacy\" }\n rustc_query_impl = { path = \"../rustc_query_impl\" }\n rustc_resolve = { path = \"../rustc_resolve\" }\n+rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n "}, {"sha": "15d7e977bbe881511d6c68a1798b5a70be164608", "filename": "compiler/rustc_interface/src/errors.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -87,3 +87,7 @@ pub struct FailedWritingFile<'a> {\n     pub path: &'a Path,\n     pub error: io::Error,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(interface_proc_macro_crate_panic_abort)]\n+pub struct ProcMacroCratePanicAbort;"}, {"sha": "50c40206d8026f66626a3ac07b9c1e0c117dbc3d", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,7 +1,8 @@\n use crate::errors::{\n     CantEmitMIR, EmojiIdentifier, ErrorWritingDependencies, FerrisIdentifier,\n     GeneratedFileConflictsWithDirectory, InputFileWouldBeOverWritten, MixedBinCrate,\n-    MixedProcMacroCrate, OutDirError, ProcMacroDocWithoutArg, TempsDirError,\n+    MixedProcMacroCrate, OutDirError, ProcMacroCratePanicAbort, ProcMacroDocWithoutArg,\n+    TempsDirError,\n };\n use crate::interface::{Compiler, Result};\n use crate::proc_macro_decls;\n@@ -36,6 +37,7 @@ use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::FileName;\n+use rustc_target::spec::PanicStrategy;\n use rustc_trait_selection::traits;\n \n use std::any::Any;\n@@ -380,6 +382,10 @@ pub fn configure_and_expand(\n         }\n     }\n \n+    if is_proc_macro_crate && sess.panic_strategy() == PanicStrategy::Abort {\n+        sess.emit_warning(ProcMacroCratePanicAbort);\n+    }\n+\n     // For backwards compatibility, we don't try to run proc macro injection\n     // if rustdoc is run on a proc macro crate without '--crate-type proc-macro' being\n     // specified. This should only affect users who manually invoke 'rustdoc', as\n@@ -817,23 +823,26 @@ pub fn create_global_ctxt<'tcx>(\n                 lint_store,\n                 arena,\n                 hir_arena,\n-                untracked_resolutions,\n                 untracked,\n-                krate,\n                 dep_graph,\n                 queries.on_disk_cache.as_ref().map(OnDiskCache::as_dyn),\n                 queries.as_dyn(),\n                 rustc_query_impl::query_callbacks(arena),\n-                crate_name,\n-                outputs,\n             )\n         })\n     });\n \n     let mut qcx = QueryContext { gcx };\n     qcx.enter(|tcx| {\n-        tcx.feed_unit_query()\n-            .resolver_for_lowering(tcx.arena.alloc(Steal::new(untracked_resolver_for_lowering)))\n+        let feed = tcx.feed_unit_query();\n+        feed.resolver_for_lowering(\n+            tcx.arena.alloc(Steal::new((untracked_resolver_for_lowering, krate))),\n+        );\n+        feed.resolutions(tcx.arena.alloc(untracked_resolutions));\n+        feed.output_filenames(tcx.arena.alloc(std::sync::Arc::new(outputs)));\n+        feed.features_query(sess.features_untracked());\n+        let feed = tcx.feed_local_crate();\n+        feed.crate_name(crate_name);\n     });\n     qcx\n }"}, {"sha": "07b28cc86cee1c95601f320e5ead863001913ab7", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -748,6 +748,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(link_only, true);\n     tracked!(llvm_plugins, vec![String::from(\"plugin_name\")]);\n     tracked!(location_detail, LocationDetail { file: true, line: false, column: false });\n+    tracked!(log_backtrace, Some(\"filter\".to_string()));\n     tracked!(maximal_hir_to_mir_coverage, true);\n     tracked!(merge_functions, Some(MergeFunctions::Disabled));\n     tracked!(mir_emit_retag, true);"}, {"sha": "e9eb14ea18800f0fe187d0a40d33ed6c425f6d15", "filename": "compiler/rustc_lint/src/expect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -11,7 +11,7 @@ pub(crate) fn provide(providers: &mut Providers) {\n }\n \n fn check_expectations(tcx: TyCtxt<'_>, tool_filter: Option<Symbol>) {\n-    if !tcx.sess.features_untracked().enabled(sym::lint_reasons) {\n+    if !tcx.features().enabled(sym::lint_reasons) {\n         return;\n     }\n "}, {"sha": "f2ee9ab1a19873cfac16b3e6f2c29c253a5267a5", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1105,6 +1105,7 @@ impl UnusedDelimLint for UnusedBraces {\n                                 || matches!(expr.kind, ast::ExprKind::Lit(_)))\n                             && !cx.sess().source_map().is_multiline(value.span)\n                             && value.attrs.is_empty()\n+                            && !expr.span.from_expansion()\n                             && !value.span.from_expansion()\n                             && !inner.span.from_expansion()\n                         {"}, {"sha": "6cdf50970836a99ab5a7c73033a5d68ff202c0bd", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -4033,10 +4033,10 @@ declare_lint! {\n     ///\n     /// This can be used to implement an unsound API if used incorrectly.\n     pub IMPLIED_BOUNDS_ENTAILMENT,\n-    Warn,\n+    Deny,\n     \"impl method assumes more implied bounds than its corresponding trait method\",\n     @future_incompatible = FutureIncompatibleInfo {\n         reference: \"issue #105572 <https://github.com/rust-lang/rust/issues/105572>\",\n-        reason: FutureIncompatibilityReason::FutureReleaseError,\n+        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n     };\n }"}, {"sha": "7f955b0a75090ee7234784612bdd1a316a80f47b", "filename": "compiler/rustc_log/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_log%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_log%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_log%2FCargo.toml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -7,6 +7,7 @@ edition = \"2021\"\n tracing = \"0.1.28\"\n tracing-subscriber = { version = \"0.3.3\", default-features = false, features = [\"fmt\", \"env-filter\", \"smallvec\", \"parking_lot\", \"ansi\"] }\n tracing-tree = \"0.2.0\"\n+tracing-core = \"0.1.28\"\n \n [dev-dependencies]\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "fc1cabd2de95134ab892f7e9f06b8b09d90e2fa2", "filename": "compiler/rustc_log/src/lib.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_log%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_log%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_log%2Fsrc%2Flib.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -45,16 +45,34 @@\n use std::env::{self, VarError};\n use std::fmt::{self, Display};\n use std::io::{self, IsTerminal};\n+use tracing_core::{Event, Subscriber};\n use tracing_subscriber::filter::{Directive, EnvFilter, LevelFilter};\n+use tracing_subscriber::fmt::{\n+    format::{self, FormatEvent, FormatFields},\n+    FmtContext,\n+};\n use tracing_subscriber::layer::SubscriberExt;\n \n pub fn init_rustc_env_logger() -> Result<(), Error> {\n-    init_env_logger(\"RUSTC_LOG\")\n+    init_rustc_env_logger_with_backtrace_option(&None)\n+}\n+\n+pub fn init_rustc_env_logger_with_backtrace_option(\n+    backtrace_target: &Option<String>,\n+) -> Result<(), Error> {\n+    init_env_logger_with_backtrace_option(\"RUSTC_LOG\", backtrace_target)\n }\n \n /// In contrast to `init_rustc_env_logger` this allows you to choose an env var\n /// other than `RUSTC_LOG`.\n pub fn init_env_logger(env: &str) -> Result<(), Error> {\n+    init_env_logger_with_backtrace_option(env, &None)\n+}\n+\n+pub fn init_env_logger_with_backtrace_option(\n+    env: &str,\n+    backtrace_target: &Option<String>,\n+) -> Result<(), Error> {\n     let filter = match env::var(env) {\n         Ok(env) => EnvFilter::new(env),\n         _ => EnvFilter::default().add_directive(Directive::from(LevelFilter::WARN)),\n@@ -88,11 +106,47 @@ pub fn init_env_logger(env: &str) -> Result<(), Error> {\n     let layer = layer.with_thread_ids(true).with_thread_names(true);\n \n     let subscriber = tracing_subscriber::Registry::default().with(filter).with(layer);\n-    tracing::subscriber::set_global_default(subscriber).unwrap();\n+    match backtrace_target {\n+        Some(str) => {\n+            let fmt_layer = tracing_subscriber::fmt::layer()\n+                .with_writer(io::stderr)\n+                .without_time()\n+                .event_format(BacktraceFormatter { backtrace_target: str.to_string() });\n+            let subscriber = subscriber.with(fmt_layer);\n+            tracing::subscriber::set_global_default(subscriber).unwrap();\n+        }\n+        None => {\n+            tracing::subscriber::set_global_default(subscriber).unwrap();\n+        }\n+    };\n \n     Ok(())\n }\n \n+struct BacktraceFormatter {\n+    backtrace_target: String,\n+}\n+\n+impl<S, N> FormatEvent<S, N> for BacktraceFormatter\n+where\n+    S: Subscriber + for<'a> tracing_subscriber::registry::LookupSpan<'a>,\n+    N: for<'a> FormatFields<'a> + 'static,\n+{\n+    fn format_event(\n+        &self,\n+        _ctx: &FmtContext<'_, S, N>,\n+        mut writer: format::Writer<'_>,\n+        event: &Event<'_>,\n+    ) -> fmt::Result {\n+        let target = event.metadata().target();\n+        if !target.contains(&self.backtrace_target) {\n+            return Ok(());\n+        }\n+        let backtrace = std::backtrace::Backtrace::capture();\n+        writeln!(writer, \"stack backtrace: \\n{:?}\", backtrace)\n+    }\n+}\n+\n pub fn stdout_isatty() -> bool {\n     io::stdout().is_terminal()\n }"}, {"sha": "58b91e7b4f858ae4b2ff3be0c28e34ca7ebc401d", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1555,7 +1555,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 self.tables.impl_defaultness.set(def_id.index, *defaultness);\n                 self.tables.constness.set(def_id.index, *constness);\n \n-                let trait_ref = self.tcx.impl_trait_ref(def_id);\n+                let trait_ref = self.tcx.impl_trait_ref(def_id).map(ty::EarlyBinder::skip_binder);\n                 if let Some(trait_ref) = trait_ref {\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n                     if let Ok(mut an) = trait_def.ancestors(self.tcx, def_id) {\n@@ -1899,6 +1899,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         for id in tcx.hir().items() {\n             if matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n                 if let Some(trait_ref) = tcx.impl_trait_ref(id.owner_id) {\n+                    let trait_ref = trait_ref.subst_identity();\n+\n                     let simplified_self_ty = fast_reject::simplify_type(\n                         self.tcx,\n                         trait_ref.self_ty(),"}, {"sha": "5b7b096b4edf1a903beb400bb27b6e2de463d515", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -359,8 +359,8 @@ define_tables! {\n     variances_of: Table<DefIndex, LazyArray<ty::Variance>>,\n     fn_sig: Table<DefIndex, LazyValue<ty::PolyFnSig<'static>>>,\n     codegen_fn_attrs: Table<DefIndex, LazyValue<CodegenFnAttrs>>,\n-    impl_trait_ref: Table<DefIndex, LazyValue<ty::TraitRef<'static>>>,\n-    const_param_default: Table<DefIndex, LazyValue<rustc_middle::ty::Const<'static>>>,\n+    impl_trait_ref: Table<DefIndex, LazyValue<ty::EarlyBinder<ty::TraitRef<'static>>>>,\n+    const_param_default: Table<DefIndex, LazyValue<ty::EarlyBinder<rustc_middle::ty::Const<'static>>>>,\n     object_lifetime_default: Table<DefIndex, LazyValue<ObjectLifetimeDefault>>,\n     optimized_mir: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'static>>>,"}, {"sha": "f816d614500a07b9322ae679745de27cb097fc98", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -30,7 +30,12 @@ macro_rules! arena_types {\n             [decode] typeck_results: rustc_middle::ty::TypeckResults<'tcx>,\n             [decode] borrowck_result:\n                 rustc_middle::mir::BorrowCheckResult<'tcx>,\n-            [] resolver: rustc_data_structures::steal::Steal<rustc_middle::ty::ResolverAstLowering>,\n+            [] resolver: rustc_data_structures::steal::Steal<(\n+                rustc_middle::ty::ResolverAstLowering,\n+                rustc_data_structures::sync::Lrc<rustc_ast::Crate>,\n+            )>,\n+            [] output_filenames: std::sync::Arc<rustc_session::config::OutputFilenames>,\n+            [] resolutions: rustc_middle::ty::ResolverGlobalCtxt,\n             [decode] unsafety_check_result: rustc_middle::mir::UnsafetyCheckResult,\n             [decode] code_region: rustc_middle::mir::coverage::CodeRegion,\n             [] const_allocs: rustc_middle::mir::interpret::Allocation,"}, {"sha": "dedc65f4cbf45b27352e5b395d30a3c5f88a3c7d", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -102,6 +102,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn impl_subject(self, def_id: DefId) -> ImplSubject<'tcx> {\n         self.impl_trait_ref(def_id)\n+            .map(|t| t.subst_identity())\n             .map(ImplSubject::Trait)\n             .unwrap_or_else(|| ImplSubject::Inherent(self.type_of(def_id)))\n     }"}, {"sha": "b3acf815e0c10e931045db237c919ce7191d1acd", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -27,12 +27,12 @@ rustc_queries! {\n     }\n \n     query resolutions(_: ()) -> &'tcx ty::ResolverGlobalCtxt {\n-        eval_always\n+        feedable\n         no_hash\n         desc { \"getting the resolver outputs\" }\n     }\n \n-    query resolver_for_lowering(_: ()) -> &'tcx Steal<ty::ResolverAstLowering> {\n+    query resolver_for_lowering(_: ()) -> &'tcx Steal<(ty::ResolverAstLowering, Lrc<ast::Crate>)> {\n         feedable\n         no_hash\n         desc { \"getting the resolver for lowering\" }\n@@ -142,7 +142,7 @@ rustc_queries! {\n \n     /// Given the def_id of a const-generic parameter, computes the associated default const\n     /// parameter. e.g. `fn example<const N: usize=3>` called on `N` would return `3`.\n-    query const_param_default(param: DefId) -> ty::Const<'tcx> {\n+    query const_param_default(param: DefId) -> ty::EarlyBinder<ty::Const<'tcx>> {\n         desc { |tcx| \"computing const default for a given parameter `{}`\", tcx.def_path_str(param)  }\n         cache_on_disk_if { param.is_local() }\n         separate_provide_extern\n@@ -737,7 +737,7 @@ rustc_queries! {\n \n     /// Given an `impl_id`, return the trait it implements.\n     /// Return `None` if this is an inherent impl.\n-    query impl_trait_ref(impl_id: DefId) -> Option<ty::TraitRef<'tcx>> {\n+    query impl_trait_ref(impl_id: DefId) -> Option<ty::EarlyBinder<ty::TraitRef<'tcx>>> {\n         desc { |tcx| \"computing trait implemented by `{}`\", tcx.def_path_str(impl_id) }\n         cache_on_disk_if { impl_id.is_local() }\n         separate_provide_extern\n@@ -1673,7 +1673,7 @@ rustc_queries! {\n \n     /// Gets the name of the crate.\n     query crate_name(_: CrateNum) -> Symbol {\n-        eval_always\n+        feedable\n         desc { \"fetching what a crate is named\" }\n         separate_provide_extern\n     }\n@@ -1857,7 +1857,7 @@ rustc_queries! {\n     /// This query returns an `&Arc` because codegen backends need the value even after the `TyCtxt`\n     /// has been destroyed.\n     query output_filenames(_: ()) -> &'tcx Arc<OutputFilenames> {\n-        eval_always\n+        feedable\n         desc { \"getting output filenames\" }\n     }\n \n@@ -2041,7 +2041,7 @@ rustc_queries! {\n     }\n \n     query features_query(_: ()) -> &'tcx rustc_feature::Features {\n-        eval_always\n+        feedable\n         desc { \"looking up enabled feature gates\" }\n     }\n "}, {"sha": "65cbac3e8f1cd5f341e7a0054a03be00c6c1bc81", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -239,7 +239,7 @@ impl<'tcx> Const<'tcx> {\n     }\n }\n \n-pub fn const_param_default(tcx: TyCtxt<'_>, def_id: DefId) -> Const<'_> {\n+pub fn const_param_default(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Const<'_>> {\n     let default_def_id = match tcx.hir().get_by_def_id(def_id.expect_local()) {\n         hir::Node::GenericParam(hir::GenericParam {\n             kind: hir::GenericParamKind::Const { default: Some(ac), .. },\n@@ -250,5 +250,5 @@ pub fn const_param_default(tcx: TyCtxt<'_>, def_id: DefId) -> Const<'_> {\n             \"`const_param_default` expected a generic parameter with a constant\"\n         ),\n     };\n-    Const::from_anon_const(tcx, default_def_id)\n+    ty::EarlyBinder(Const::from_anon_const(tcx, default_def_id))\n }"}, {"sha": "0c66443555fa4a38d34a405a545366ed4ea618f5", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -51,7 +51,7 @@ use rustc_macros::HashStable;\n use rustc_query_system::dep_graph::DepNodeIndex;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n-use rustc_session::config::{CrateType, OutputFilenames};\n+use rustc_session::config::CrateType;\n use rustc_session::cstore::{CrateStoreDyn, Untracked};\n use rustc_session::lint::Lint;\n use rustc_session::Limit;\n@@ -74,7 +74,6 @@ use std::hash::{Hash, Hasher};\n use std::iter;\n use std::mem;\n use std::ops::{Bound, Deref};\n-use std::sync::Arc;\n \n pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n@@ -363,6 +362,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn feed_unit_query(self) -> TyCtxtFeed<'tcx, ()> {\n         TyCtxtFeed { tcx: self, key: () }\n     }\n+    pub fn feed_local_crate(self) -> TyCtxtFeed<'tcx, CrateNum> {\n+        TyCtxtFeed { tcx: self, key: LOCAL_CRATE }\n+    }\n }\n \n impl<'tcx, KEY: Copy> TyCtxtFeed<'tcx, KEY> {\n@@ -428,11 +430,6 @@ pub struct GlobalCtxt<'tcx> {\n     pub consts: CommonConsts<'tcx>,\n \n     untracked: Untracked,\n-    /// Output of the resolver.\n-    pub(crate) untracked_resolutions: ty::ResolverGlobalCtxt,\n-    /// The entire crate as AST. This field serves as the input for the hir_crate query,\n-    /// which lowers it from AST to HIR. It must not be read or used by anything else.\n-    pub untracked_crate: Steal<Lrc<ast::Crate>>,\n \n     /// This provides access to the incremental compilation on-disk cache for query results.\n     /// Do not access this directly. It is only meant to be used by\n@@ -457,17 +454,11 @@ pub struct GlobalCtxt<'tcx> {\n     /// Merge this with `selection_cache`?\n     pub evaluation_cache: traits::EvaluationCache<'tcx>,\n \n-    /// The definite name of the current crate after taking into account\n-    /// attributes, commandline parameters, etc.\n-    crate_name: Symbol,\n-\n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n \n     /// Stores memory for globals (statics/consts).\n     pub(crate) alloc_map: Lock<interpret::AllocMap<'tcx>>,\n-\n-    output_filenames: Arc<OutputFilenames>,\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -592,15 +583,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         hir_arena: &'tcx WorkerLocal<hir::Arena<'tcx>>,\n-        untracked_resolutions: ty::ResolverGlobalCtxt,\n         untracked: Untracked,\n-        krate: Lrc<ast::Crate>,\n         dep_graph: DepGraph,\n         on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n         queries: &'tcx dyn query::QueryEngine<'tcx>,\n         query_kinds: &'tcx [DepKindStruct<'tcx>],\n-        crate_name: Symbol,\n-        output_filenames: OutputFilenames,\n     ) -> GlobalCtxt<'tcx> {\n         let data_layout = s.target.parse_data_layout().unwrap_or_else(|err| {\n             s.emit_fatal(err);\n@@ -622,8 +609,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             lifetimes: common_lifetimes,\n             consts: common_consts,\n             untracked,\n-            untracked_resolutions,\n-            untracked_crate: Steal::new(krate),\n             on_disk_cache,\n             queries,\n             query_caches: query::QueryCaches::default(),\n@@ -632,10 +617,8 @@ impl<'tcx> TyCtxt<'tcx> {\n             pred_rcache: Default::default(),\n             selection_cache: Default::default(),\n             evaluation_cache: Default::default(),\n-            crate_name,\n             data_layout,\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n-            output_filenames: Arc::new(output_filenames),\n         }\n     }\n \n@@ -810,7 +793,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // statements within the query system and we'd run into endless\n         // recursion otherwise.\n         let (crate_name, stable_crate_id) = if def_id.is_local() {\n-            (self.crate_name, self.sess.local_stable_crate_id())\n+            (self.crate_name(LOCAL_CRATE), self.sess.local_stable_crate_id())\n         } else {\n             let cstore = &*self.untracked.cstore;\n             (cstore.crate_name(def_id.krate), cstore.stable_crate_id(def_id.krate))\n@@ -2407,13 +2390,8 @@ fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {\n-    providers.resolutions = |tcx, ()| &tcx.untracked_resolutions;\n     providers.module_reexports =\n         |tcx, id| tcx.resolutions(()).reexport_map.get(&id).map(|v| &v[..]);\n-    providers.crate_name = |tcx, id| {\n-        assert_eq!(id, LOCAL_CRATE);\n-        tcx.crate_name\n-    };\n     providers.maybe_unused_trait_imports =\n         |tcx, ()| &tcx.resolutions(()).maybe_unused_trait_imports;\n     providers.maybe_unused_extern_crates =\n@@ -2424,8 +2402,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n \n     providers.extern_mod_stmt_cnum =\n         |tcx, id| tcx.resolutions(()).extern_crate_map.get(&id).cloned();\n-    providers.output_filenames = |tcx, ()| &tcx.output_filenames;\n-    providers.features_query = |tcx, ()| tcx.sess.features_untracked();\n     providers.is_panic_runtime = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::panic_runtime)"}, {"sha": "8a5e765b9a30664adc3a20f7c240d7ea78d7c147", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -88,7 +88,7 @@ impl GenericParamDef {\n                 Some(tcx.bound_type_of(self.def_id).map_bound(|t| t.into()))\n             }\n             GenericParamDefKind::Const { has_default } if has_default => {\n-                Some(tcx.bound_const_param_default(self.def_id).map_bound(|c| c.into()))\n+                Some(tcx.const_param_default(self.def_id).map_bound(|c| c.into()))\n             }\n             _ => None,\n         }"}, {"sha": "0a0a8a5a66a300cdbe107e55e704bcc634a6c334", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2187,8 +2187,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> Option<ImplOverlapKind> {\n         // If either trait impl references an error, they're allowed to overlap,\n         // as one of them essentially doesn't exist.\n-        if self.impl_trait_ref(def_id1).map_or(false, |tr| tr.references_error())\n-            || self.impl_trait_ref(def_id2).map_or(false, |tr| tr.references_error())\n+        if self.impl_trait_ref(def_id1).map_or(false, |tr| tr.subst_identity().references_error())\n+            || self\n+                .impl_trait_ref(def_id2)\n+                .map_or(false, |tr| tr.subst_identity().references_error())\n         {\n             return Some(ImplOverlapKind::Permitted { marker: false });\n         }\n@@ -2218,7 +2220,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let is_marker_overlap = {\n             let is_marker_impl = |def_id: DefId| -> bool {\n                 let trait_ref = self.impl_trait_ref(def_id);\n-                trait_ref.map_or(false, |tr| self.trait_def(tr.def_id).is_marker)\n+                trait_ref.map_or(false, |tr| self.trait_def(tr.skip_binder().def_id).is_marker)\n             };\n             is_marker_impl(def_id1) && is_marker_impl(def_id2)\n         };\n@@ -2364,7 +2366,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Given the `DefId` of an impl, returns the `DefId` of the trait it implements.\n     /// If it implements no trait, returns `None`.\n     pub fn trait_id_of_impl(self, def_id: DefId) -> Option<DefId> {\n-        self.impl_trait_ref(def_id).map(|tr| tr.def_id)\n+        self.impl_trait_ref(def_id).map(|tr| tr.skip_binder().def_id)\n     }\n \n     /// If the given `DefId` describes an item belonging to a trait,"}, {"sha": "e32a7ee1c354569c7df399a82b524d88b1190151", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -32,6 +32,10 @@ impl<T: ParameterizedOverTcx> ParameterizedOverTcx for ty::Binder<'static, T> {\n     type Value<'tcx> = ty::Binder<'tcx, T::Value<'tcx>>;\n }\n \n+impl<T: ParameterizedOverTcx> ParameterizedOverTcx for ty::EarlyBinder<T> {\n+    type Value<'tcx> = ty::EarlyBinder<T::Value<'tcx>>;\n+}\n+\n #[macro_export]\n macro_rules! trivially_parameterized_over_tcx {\n     ($($ty:ty),+ $(,)?) => {"}, {"sha": "c302c461195aaf833b9b00e843efb17c5dd8272f", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -116,7 +116,7 @@ pub trait Printer<'tcx>: Sized {\n             DefPathData::Impl => {\n                 let generics = self.tcx().generics_of(def_id);\n                 let self_ty = self.tcx().bound_type_of(def_id);\n-                let impl_trait_ref = self.tcx().bound_impl_trait_ref(def_id);\n+                let impl_trait_ref = self.tcx().impl_trait_ref(def_id);\n                 let (self_ty, impl_trait_ref) = if substs.len() >= generics.count() {\n                     (\n                         self_ty.subst(self.tcx(), substs),"}, {"sha": "b5bb9238512e4cf87448e6a496d5e607622f3fee", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 89, "deletions": 3, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -7,8 +7,8 @@ use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use crate::ty::visit::ValidateBoundVars;\n use crate::ty::InferTy::*;\n use crate::ty::{\n-    self, AdtDef, DefIdTree, Discr, Term, Ty, TyCtxt, TypeFlags, TypeSuperVisitable, TypeVisitable,\n-    TypeVisitor,\n+    self, AdtDef, DefIdTree, Discr, FallibleTypeFolder, Term, Ty, TyCtxt, TypeFlags, TypeFoldable,\n+    TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n use crate::ty::{List, ParamEnv};\n use hir::def::DefKind;\n@@ -1106,6 +1106,17 @@ impl<'tcx, T> Binder<'tcx, T> {\n         if self.0.has_escaping_bound_vars() { None } else { Some(self.skip_binder()) }\n     }\n \n+    pub fn no_bound_vars_ignoring_escaping(self, tcx: TyCtxt<'tcx>) -> Option<T>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        if !self.0.has_escaping_bound_vars() {\n+            Some(self.skip_binder())\n+        } else {\n+            self.0.try_fold_with(&mut SkipBindersAt { index: ty::INNERMOST, tcx }).ok()\n+        }\n+    }\n+\n     /// Splits the contents into two things that share the same binder\n     /// level as the original, returning two distinct binders.\n     ///\n@@ -1135,6 +1146,81 @@ impl<'tcx, T: IntoIterator> Binder<'tcx, T> {\n     }\n }\n \n+struct SkipBindersAt<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    index: ty::DebruijnIndex,\n+}\n+\n+impl<'tcx> FallibleTypeFolder<'tcx> for SkipBindersAt<'tcx> {\n+    type Error = ();\n+\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn try_fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Result<Binder<'tcx, T>, Self::Error>\n+    where\n+        T: ty::TypeFoldable<'tcx>,\n+    {\n+        self.index.shift_in(1);\n+        let value = t.try_map_bound(|t| t.try_fold_with(self));\n+        self.index.shift_out(1);\n+        value\n+    }\n+\n+    fn try_fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        if !ty.has_escaping_bound_vars() {\n+            Ok(ty)\n+        } else if let ty::Bound(index, bv) = *ty.kind() {\n+            if index == self.index {\n+                Err(())\n+            } else {\n+                Ok(self.tcx().mk_ty(ty::Bound(index.shifted_out(1), bv)))\n+            }\n+        } else {\n+            ty.try_super_fold_with(self)\n+        }\n+    }\n+\n+    fn try_fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+        if !r.has_escaping_bound_vars() {\n+            Ok(r)\n+        } else if let ty::ReLateBound(index, bv) = r.kind() {\n+            if index == self.index {\n+                Err(())\n+            } else {\n+                Ok(self.tcx().mk_region(ty::ReLateBound(index.shifted_out(1), bv)))\n+            }\n+        } else {\n+            r.try_super_fold_with(self)\n+        }\n+    }\n+\n+    fn try_fold_const(&mut self, ct: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, Self::Error> {\n+        if !ct.has_escaping_bound_vars() {\n+            Ok(ct)\n+        } else if let ty::ConstKind::Bound(index, bv) = ct.kind() {\n+            if index == self.index {\n+                Err(())\n+            } else {\n+                Ok(self.tcx().mk_const(\n+                    ty::ConstKind::Bound(index.shifted_out(1), bv),\n+                    ct.ty().try_fold_with(self)?,\n+                ))\n+            }\n+        } else {\n+            ct.try_super_fold_with(self)\n+        }\n+    }\n+\n+    fn try_fold_predicate(\n+        &mut self,\n+        p: ty::Predicate<'tcx>,\n+    ) -> Result<ty::Predicate<'tcx>, Self::Error> {\n+        if !p.has_escaping_bound_vars() { Ok(p) } else { p.try_super_fold_with(self) }\n+    }\n+}\n+\n /// Represents the projection of an associated type.\n ///\n /// For a projection, this would be `<Ty as Trait<...>>::N`.\n@@ -1686,7 +1772,7 @@ impl<'tcx> Ty<'tcx> {\n     }\n \n     #[inline]\n-    pub fn is_ty_infer(self) -> bool {\n+    pub fn is_ty_or_numeric_infer(self) -> bool {\n         matches!(self.kind(), Infer(_))\n     }\n "}, {"sha": "8f764011d0ac32c45d71125eb777f323d3b81d6d", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -202,7 +202,7 @@ impl<'tcx> GenericArg<'tcx> {\n     pub fn is_non_region_infer(self) -> bool {\n         match self.unpack() {\n             GenericArgKind::Lifetime(_) => false,\n-            GenericArgKind::Type(ty) => ty.is_ty_infer(),\n+            GenericArgKind::Type(ty) => ty.is_ty_or_numeric_infer(),\n             GenericArgKind::Const(ct) => ct.is_ct_infer(),\n         }\n     }\n@@ -713,6 +713,10 @@ impl<'tcx, T: TypeFoldable<'tcx>> ty::EarlyBinder<T> {\n         let mut folder = SubstFolder { tcx, substs, binders_passed: 0 };\n         self.0.fold_with(&mut folder)\n     }\n+\n+    pub fn subst_identity(self) -> T {\n+        self.0\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "18281b5175c44461af745914747d9580ee9b1aab", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -193,7 +193,7 @@ pub struct TypeckResults<'tcx> {\n     pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n \n     /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n-    /// as `&[u8]`, depending on the pattern  in which they are used.\n+    /// as `&[u8]`, depending on the pattern in which they are used.\n     /// This hashset records all instances where we behave\n     /// like this to allow `const_to_pat` to reliably handle this situation.\n     pub treat_byte_string_as_slice: ItemLocalSet,"}, {"sha": "1286a5253c068618fcc4da0bee0515990a8eb515", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -652,13 +652,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty::EarlyBinder(self.fn_sig(def_id))\n     }\n \n-    pub fn bound_impl_trait_ref(\n-        self,\n-        def_id: DefId,\n-    ) -> Option<ty::EarlyBinder<ty::TraitRef<'tcx>>> {\n-        self.impl_trait_ref(def_id).map(|i| ty::EarlyBinder(i))\n-    }\n-\n     pub fn bound_explicit_item_bounds(\n         self,\n         def_id: DefId,\n@@ -673,10 +666,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty::EarlyBinder(self.item_bounds(def_id))\n     }\n \n-    pub fn bound_const_param_default(self, def_id: DefId) -> ty::EarlyBinder<ty::Const<'tcx>> {\n-        ty::EarlyBinder(self.const_param_default(def_id))\n-    }\n-\n     pub fn bound_predicates_of(\n         self,\n         def_id: DefId,"}, {"sha": "34e8a559784e6f021d3abd53b12271a0d8b74658", "filename": "compiler/rustc_middle/src/values.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -94,6 +94,18 @@ impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for Representability {\n     }\n }\n \n+impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for ty::EarlyBinder<Ty<'_>> {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, cycle: &[QueryInfo<DepKind>]) -> Self {\n+        ty::EarlyBinder(Ty::from_cycle_error(tcx, cycle))\n+    }\n+}\n+\n+impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for ty::EarlyBinder<ty::Binder<'_, ty::FnSig<'_>>> {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, cycle: &[QueryInfo<DepKind>]) -> Self {\n+        ty::EarlyBinder(ty::Binder::from_cycle_error(tcx, cycle))\n+    }\n+}\n+\n // item_and_field_ids should form a cycle where each field contains the\n // type in the next element in the list\n pub fn recursive_type_error("}, {"sha": "ec1de3056872b027f8d8da8b3bb880ee49c67076", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1352,6 +1352,8 @@ fn create_mono_items_for_default_impls<'tcx>(\n             );\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n+                let trait_ref = trait_ref.subst_identity();\n+\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n                 let overridden_methods = tcx.impl_item_implementor_ids(item.owner_id);"}, {"sha": "8761c23625b210063b1cdfbddf08e7f712cfc395", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -79,7 +79,7 @@ impl<'a> StringReader<'a> {\n     /// preceded by whitespace.\n     fn next_token(&mut self) -> (Token, bool) {\n         let mut preceded_by_whitespace = false;\n-\n+        let mut swallow_next_invalid = 0;\n         // Skip trivial (whitespace & comments) tokens\n         loop {\n             let token = self.cursor.advance_token();\n@@ -232,19 +232,34 @@ impl<'a> StringReader<'a> {\n                 rustc_lexer::TokenKind::Percent => token::BinOp(token::Percent),\n \n                 rustc_lexer::TokenKind::Unknown | rustc_lexer::TokenKind::InvalidIdent => {\n-                    let c = self.str_from(start).chars().next().unwrap();\n+                    // Don't emit diagnostics for sequences of the same invalid token\n+                    if swallow_next_invalid > 0 {\n+                        swallow_next_invalid -= 1;\n+                        continue;\n+                    }\n+                    let mut it = self.str_from_to_end(start).chars();\n+                    let c = it.next().unwrap();\n+                    let repeats = it.take_while(|c1| *c1 == c).count();\n                     let mut err =\n-                        self.struct_err_span_char(start, self.pos, \"unknown start of token\", c);\n+                        self.struct_err_span_char(start, self.pos + Pos::from_usize(repeats * c.len_utf8()), \"unknown start of token\", c);\n                     // FIXME: the lexer could be used to turn the ASCII version of unicode\n                     // homoglyphs, instead of keeping a table in `check_for_substitution`into the\n                     // token. Ideally, this should be inside `rustc_lexer`. However, we should\n                     // first remove compound tokens like `<<` from `rustc_lexer`, and then add\n                     // fancier error recovery to it, as there will be less overall work to do this\n                     // way.\n-                    let token = unicode_chars::check_for_substitution(self, start, c, &mut err);\n+                    let token = unicode_chars::check_for_substitution(self, start, c, &mut err, repeats+1);\n                     if c == '\\x00' {\n                         err.help(\"source files must contain UTF-8 encoded text, unexpected null bytes might occur when a different encoding is used\");\n                     }\n+                    if repeats > 0 {\n+                        if repeats == 1 {\n+                            err.note(format!(\"character appears once more\"));\n+                        } else {\n+                            err.note(format!(\"character appears {repeats} more times\"));\n+                        }\n+                        swallow_next_invalid = repeats;\n+                    }\n                     err.emit();\n                     if let Some(token) = token {\n                         token\n@@ -486,6 +501,11 @@ impl<'a> StringReader<'a> {\n         &self.src[self.src_index(start)..self.src_index(end)]\n     }\n \n+    /// Slice of the source text spanning from `start` until the end\n+    fn str_from_to_end(&self, start: BytePos) -> &str {\n+        &self.src[self.src_index(start)..]\n+    }\n+\n     fn report_raw_str_error(&self, start: BytePos, prefix_len: u32) -> ! {\n         match rustc_lexer::validate_raw_str(self.str_from(start), prefix_len) {\n             Err(RawStrError::InvalidStarter { bad_char }) => {"}, {"sha": "65479b341d7a8f5c2687a97b3e4ecd768962ea34", "filename": "compiler/rustc_parse/src/lexer/unicode_chars.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -337,10 +337,11 @@ pub(super) fn check_for_substitution<'a>(\n     pos: BytePos,\n     ch: char,\n     err: &mut Diagnostic,\n+    count: usize,\n ) -> Option<token::TokenKind> {\n     let &(_u_char, u_name, ascii_char) = UNICODE_ARRAY.iter().find(|&&(c, _, _)| c == ch)?;\n \n-    let span = Span::with_root_ctxt(pos, pos + Pos::from_usize(ch.len_utf8()));\n+    let span = Span::with_root_ctxt(pos, pos + Pos::from_usize(ch.len_utf8() * count));\n \n     let Some((_ascii_char, ascii_name, token)) = ASCII_ARRAY.iter().find(|&&(c, _, _)| c == ascii_char) else {\n         let msg = format!(\"substitution character not found for '{}'\", ch);\n@@ -369,7 +370,12 @@ pub(super) fn check_for_substitution<'a>(\n             \"Unicode character '{}' ({}) looks like '{}' ({}), but it is not\",\n             ch, u_name, ascii_char, ascii_name\n         );\n-        err.span_suggestion(span, &msg, ascii_char, Applicability::MaybeIncorrect);\n+        err.span_suggestion(\n+            span,\n+            &msg,\n+            ascii_char.to_string().repeat(count),\n+            Applicability::MaybeIncorrect,\n+        );\n     }\n     token.clone()\n }"}, {"sha": "d58afcd4c9fc43b906ee2249b980ea0dd66e092c", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -83,7 +83,7 @@ macro_rules! maybe_whole_expr {\n pub(super) enum LhsExpr {\n     NotYetParsed,\n     AttributesParsed(AttrWrapper),\n-    AlreadyParsed(P<Expr>, bool), // (expr, starts_statement)\n+    AlreadyParsed { expr: P<Expr>, starts_statement: bool },\n }\n \n impl From<Option<AttrWrapper>> for LhsExpr {\n@@ -97,11 +97,11 @@ impl From<Option<AttrWrapper>> for LhsExpr {\n }\n \n impl From<P<Expr>> for LhsExpr {\n-    /// Converts the `expr: P<Expr>` into `LhsExpr::AlreadyParsed(expr)`.\n+    /// Converts the `expr: P<Expr>` into `LhsExpr::AlreadyParsed { expr, starts_statement: false }`.\n     ///\n     /// This conversion does not allocate.\n     fn from(expr: P<Expr>) -> Self {\n-        LhsExpr::AlreadyParsed(expr, false)\n+        LhsExpr::AlreadyParsed { expr, starts_statement: false }\n     }\n }\n \n@@ -174,7 +174,7 @@ impl<'a> Parser<'a> {\n         lhs: LhsExpr,\n     ) -> PResult<'a, P<Expr>> {\n         let mut starts_stmt = false;\n-        let mut lhs = if let LhsExpr::AlreadyParsed(expr, starts_statement) = lhs {\n+        let mut lhs = if let LhsExpr::AlreadyParsed { expr, starts_statement } = lhs {\n             starts_stmt = starts_statement;\n             expr\n         } else {\n@@ -562,17 +562,23 @@ impl<'a> Parser<'a> {\n \n         // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n         match this.token.uninterpolate().kind {\n-            token::Not => make_it!(this, attrs, |this, _| this.parse_unary_expr(lo, UnOp::Not)), // `!expr`\n-            token::Tilde => make_it!(this, attrs, |this, _| this.recover_tilde_expr(lo)), // `~expr`\n+            // `!expr`\n+            token::Not => make_it!(this, attrs, |this, _| this.parse_unary_expr(lo, UnOp::Not)),\n+            // `~expr`\n+            token::Tilde => make_it!(this, attrs, |this, _| this.recover_tilde_expr(lo)),\n+            // `-expr`\n             token::BinOp(token::Minus) => {\n                 make_it!(this, attrs, |this, _| this.parse_unary_expr(lo, UnOp::Neg))\n-            } // `-expr`\n+            }\n+            // `*expr`\n             token::BinOp(token::Star) => {\n                 make_it!(this, attrs, |this, _| this.parse_unary_expr(lo, UnOp::Deref))\n-            } // `*expr`\n+            }\n+            // `&expr` and `&&expr`\n             token::BinOp(token::And) | token::AndAnd => {\n                 make_it!(this, attrs, |this, _| this.parse_borrow_expr(lo))\n             }\n+            // `+lit`\n             token::BinOp(token::Plus) if this.look_ahead(1, |tok| tok.is_numeric_lit()) => {\n                 let mut err =\n                     LeadingPlusNotSupported { span: lo, remove_plus: None, add_parentheses: None };\n@@ -587,7 +593,7 @@ impl<'a> Parser<'a> {\n \n                 this.bump();\n                 this.parse_prefix_expr(None)\n-            } // `+expr`\n+            }\n             // Recover from `++x`:\n             token::BinOp(token::Plus)\n                 if this.look_ahead(1, |t| *t == token::BinOp(token::Plus)) =>\n@@ -624,7 +630,7 @@ impl<'a> Parser<'a> {\n         Ok((span, self.mk_unary(op, expr)))\n     }\n \n-    // Recover on `!` suggesting for bitwise negation instead.\n+    /// Recover on `~expr` in favor of `!expr`.\n     fn recover_tilde_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         self.sess.emit_err(TildeAsUnaryOperator(lo));\n \n@@ -651,7 +657,6 @@ impl<'a> Parser<'a> {\n \n     /// Recover on `not expr` in favor of `!expr`.\n     fn recover_not_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n-        // Emit the error...\n         let negated_token = self.look_ahead(1, |t| t.clone());\n \n         let sub_diag = if negated_token.is_numeric_lit() {\n@@ -672,7 +677,6 @@ impl<'a> Parser<'a> {\n             ),\n         });\n \n-        // ...and recover!\n         self.parse_unary_expr(lo, UnOp::Not)\n     }\n \n@@ -1471,9 +1475,8 @@ impl<'a> Parser<'a> {\n             } else if self.eat(&token::Comma) {\n                 // Vector with two or more elements.\n                 let sep = SeqSep::trailing_allowed(token::Comma);\n-                let (remaining_exprs, _) = self.parse_seq_to_end(close, sep, |p| p.parse_expr())?;\n-                let mut exprs = vec![first_expr];\n-                exprs.extend(remaining_exprs);\n+                let (mut exprs, _) = self.parse_seq_to_end(close, sep, |p| p.parse_expr())?;\n+                exprs.insert(0, first_expr);\n                 ExprKind::Array(exprs)\n             } else {\n                 // Vector with one element\n@@ -1593,7 +1596,7 @@ impl<'a> Parser<'a> {\n                     vis.0\n                 };\n \n-                // Suggestion involves adding a (as of time of writing this, unstable) labeled block.\n+                // Suggestion involves adding a labeled block.\n                 //\n                 // If there are no breaks that may use this label, suggest removing the label and\n                 // recover to the unmodified expression."}, {"sha": "e73a17ced7deb2598f52a013189ee3392e379547", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -469,7 +469,7 @@ impl<'a> Parser<'a> {\n     /// Try to recover the more general form `intersect ::= $pat_lhs @ $pat_rhs`.\n     ///\n     /// Allowed binding patterns generated by `binding ::= ref? mut? $ident @ $pat_rhs`\n-    /// should already have been parsed by now  at this point,\n+    /// should already have been parsed by now at this point,\n     /// if the next token is `@` then we can try to parse the more general form.\n     ///\n     /// Consult `parse_pat_ident` for the `binding` grammar."}, {"sha": "4ff9927aab51af8d3acf925aeff8ccfd6f8ba9fc", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -164,7 +164,10 @@ impl<'a> Parser<'a> {\n             // Perform this outside of the `collect_tokens_trailing_token` closure,\n             // since our outer attributes do not apply to this part of the expression\n             let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n-                this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr, true))\n+                this.parse_assoc_expr_with(\n+                    0,\n+                    LhsExpr::AlreadyParsed { expr, starts_statement: true },\n+                )\n             })?;\n             Ok(self.mk_stmt(lo.to(self.prev_token.span), StmtKind::Expr(expr)))\n         } else {\n@@ -198,7 +201,10 @@ impl<'a> Parser<'a> {\n             let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac));\n             let e = self.maybe_recover_from_bad_qpath(e)?;\n             let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n-            let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e, false))?;\n+            let e = self.parse_assoc_expr_with(\n+                0,\n+                LhsExpr::AlreadyParsed { expr: e, starts_statement: false },\n+            )?;\n             StmtKind::Expr(e)\n         };\n         Ok(self.mk_stmt(lo.to(hi), kind))"}, {"sha": "f9f9799d3e4f2058bf9911a23a60c22d9cf2837f", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -82,6 +82,7 @@ impl CheckAttrVisitor<'_> {\n         let attrs = self.tcx.hir().attrs(hir_id);\n         for attr in attrs {\n             let attr_is_valid = match attr.name_or_empty() {\n+                sym::do_not_recommend => self.check_do_not_recommend(attr.span, target),\n                 sym::inline => self.check_inline(hir_id, attr, span, target),\n                 sym::no_coverage => self.check_no_coverage(hir_id, attr, span, target),\n                 sym::non_exhaustive => self.check_non_exhaustive(hir_id, attr, span, target),\n@@ -241,6 +242,16 @@ impl CheckAttrVisitor<'_> {\n         );\n     }\n \n+    /// Checks if `#[do_not_recommend]` is applied on a trait impl.\n+    fn check_do_not_recommend(&self, attr_span: Span, target: Target) -> bool {\n+        if let Target::Impl = target {\n+            true\n+        } else {\n+            self.tcx.sess.emit_err(errors::IncorrectDoNotRecommendLocation { span: attr_span });\n+            false\n+        }\n+    }\n+\n     /// Checks if an `#[inline]` is applied to a function or a closure. Returns `true` if valid.\n     fn check_inline(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) -> bool {\n         match target {"}, {"sha": "94171b4b0c8f1b5ffa6021d2bf3a68c035aceb5c", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -266,7 +266,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n             if let Some(trait_of) = self.tcx.trait_id_of_impl(impl_of)\n                 && self.tcx.has_attr(trait_of, sym::rustc_trivial_field_reads)\n             {\n-                let trait_ref = self.tcx.impl_trait_ref(impl_of).unwrap();\n+                let trait_ref = self.tcx.impl_trait_ref(impl_of).unwrap().subst_identity();\n                 if let ty::Adt(adt_def, _) = trait_ref.self_ty().kind()\n                     && let Some(adt_def_id) = adt_def.did().as_local()\n                 {"}, {"sha": "9c6519ea4bb24be91a133b22d716ca376593ae4d", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -14,6 +14,13 @@ use rustc_span::{Span, Symbol, DUMMY_SP};\n \n use crate::lang_items::Duplicate;\n \n+#[derive(Diagnostic)]\n+#[diag(passes_incorrect_do_not_recommend_location)]\n+pub struct IncorrectDoNotRecommendLocation {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n #[derive(LintDiagnostic)]\n #[diag(passes_outer_crate_level_attr)]\n pub struct OuterCrateLevelAttr;"}, {"sha": "fb55bb4afaac3adadbdc8c993038c794df18b324", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -338,7 +338,7 @@ trait VisibilityLike: Sized {\n         let mut find = FindMin { tcx, effective_visibilities, min: Self::MAX };\n         find.visit(tcx.type_of(def_id));\n         if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n-            find.visit_trait(trait_ref);\n+            find.visit_trait(trait_ref.subst_identity());\n         }\n         find.min\n     }\n@@ -838,7 +838,7 @@ impl ReachEverythingInTheInterfaceVisitor<'_, '_> {\n                 GenericParamDefKind::Const { has_default } => {\n                     self.visit(self.ev.tcx.type_of(param.def_id));\n                     if has_default {\n-                        self.visit(self.ev.tcx.const_param_default(param.def_id));\n+                        self.visit(self.ev.tcx.const_param_default(param.def_id).subst_identity());\n                     }\n                 }\n             }\n@@ -858,7 +858,7 @@ impl ReachEverythingInTheInterfaceVisitor<'_, '_> {\n \n     fn trait_ref(&mut self) -> &mut Self {\n         if let Some(trait_ref) = self.ev.tcx.impl_trait_ref(self.item_def_id) {\n-            self.visit_trait(trait_ref);\n+            self.visit_trait(trait_ref.subst_identity());\n         }\n         self\n     }"}, {"sha": "fb2aebbd18a3d8508e5d06fc0eeba2e58f479f7a", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -167,7 +167,7 @@ impl<'a> Resolver<'a> {\n                 );\n                 err.emit();\n             } else if let Some((span, msg, sugg, appl)) = suggestion {\n-                err.span_suggestion(span, msg, sugg, appl);\n+                err.span_suggestion_verbose(span, msg, sugg, appl);\n                 err.emit();\n             } else if let [segment] = path.as_slice() && is_call {\n                 err.stash(segment.ident.span, rustc_errors::StashKey::CallIntoMethod);"}, {"sha": "d92b046d0b9f226fe3bb0f3111a09658acef8303", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2065,7 +2065,11 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         path: &[Segment],\n     ) -> Option<(Span, &'static str, String, Applicability)> {\n         let (ident, span) = match path {\n-            [segment] if !segment.has_generic_args && segment.ident.name != kw::SelfUpper => {\n+            [segment]\n+                if !segment.has_generic_args\n+                    && segment.ident.name != kw::SelfUpper\n+                    && segment.ident.name != kw::Dyn =>\n+            {\n                 (segment.ident.to_string(), segment.ident.span)\n             }\n             _ => return None,"}, {"sha": "f950e4a9bee65282e8ae37a9358f1d408191e00d", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1137,7 +1137,7 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n     }\n }\n \n-impl Resolver<'_> {\n+impl<'a> Resolver<'a> {\n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n         self.node_id_to_def_id.get(&node).copied()\n     }\n@@ -1194,6 +1194,10 @@ impl Resolver<'_> {\n             self.cstore().item_generics_num_lifetimes(def_id, self.session)\n         }\n     }\n+\n+    pub fn sess(&self) -> &'a Session {\n+        self.session\n+    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "dcc2d9db614e69c5de5cb01af8ef16697cc79d60", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2091,7 +2091,7 @@ fn parse_libs(matches: &getopts::Matches, error_format: ErrorOutputType) -> Vec<\n         .map(|s| {\n             // Parse string of the form \"[KIND[:MODIFIERS]=]lib[:new_name]\",\n             // where KIND is one of \"dylib\", \"framework\", \"static\", \"link-arg\" and\n-            // where MODIFIERS are  a comma separated list of supported modifiers\n+            // where MODIFIERS are a comma separated list of supported modifiers\n             // (bundle, verbatim, whole-archive, as-needed). Each modifier is prefixed\n             // with either + or - to indicate whether it is enabled or disabled.\n             // The last value specified for a given modifier wins."}, {"sha": "7b5fd6cc2a81d9a0c3bc45c660b34f3c7ec7fec3", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1411,6 +1411,8 @@ options! {\n         \"what location details should be tracked when using caller_location, either \\\n         `none`, or a comma separated list of location details, for which \\\n         valid options are `file`, `line`, and `column` (default: `file,line,column`)\"),\n+    log_backtrace: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"add a backtrace along with logging\"),\n     ls: bool = (false, parse_bool, [UNTRACKED],\n         \"list the symbols defined by a library crate (default: no)\"),\n     macro_backtrace: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "ae81d95e27967c999d16ac809b23413209919f91", "filename": "compiler/rustc_span/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_span%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_span%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2FCargo.toml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -15,6 +15,6 @@ scoped-tls = \"1.0\"\n unicode-width = \"0.1.4\"\n cfg-if = \"1.0\"\n tracing = \"0.1\"\n-sha1 = { package = \"sha-1\", version = \"0.10.0\" }\n+sha1 = \"0.10.0\"\n sha2 = \"0.10.1\"\n md5 = { package = \"md-5\", version = \"0.10.0\" }"}, {"sha": "70cd883be09b3d7d57989931b1a58d8a101ab585", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -462,7 +462,7 @@ impl InlineAsmRegClass {\n     }\n \n     /// Returns a suggested template modifier to use for this type and an\n-    /// example of a  register named formatted with it.\n+    /// example of a register named formatted with it.\n     ///\n     /// Such suggestions are useful if a type smaller than the full register\n     /// size is used and a modifier can be used to point to the subregister of"}, {"sha": "ba68da0686feaea3aa7c0c5fb845e27f3034eab8", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2,8 +2,8 @@\n \n use super::infcx_ext::InferCtxtExt;\n use super::{\n-    fixme_instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty,\n-    EvalCtxt, Goal,\n+    instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty, EvalCtxt,\n+    Goal,\n };\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -121,11 +121,8 @@ impl<'a, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'tcx, G> {\n             // canonical wrt the caller.\n             for Candidate { source, result } in normalized_candidates {\n                 self.infcx.probe(|_| {\n-                    let candidate_certainty = fixme_instantiate_canonical_query_response(\n-                        &self.infcx,\n-                        &orig_values,\n-                        result,\n-                    );\n+                    let candidate_certainty =\n+                        instantiate_canonical_query_response(&self.infcx, &orig_values, result);\n \n                     // FIXME: This is a bit scary if the `normalizes_to_goal` overflows.\n                     //"}, {"sha": "f1ee73a5b853f463ad9c77b2104a231bcabd3be2", "filename": "compiler/rustc_trait_selection/src/solve/cache.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -9,11 +9,12 @@\n //! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n //! before then or if I still haven't done that before January 2023.\n use super::overflow::OverflowData;\n-use super::CanonicalGoal;\n+use super::{CanonicalGoal, Certainty, MaybeCause, Response};\n use super::{EvalCtxt, QueryResult};\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_infer::infer::canonical::{Canonical, CanonicalVarKind, CanonicalVarValues};\n+use rustc_middle::ty::{self, TyCtxt};\n use std::{cmp::Ordering, collections::hash_map::Entry};\n \n #[derive(Debug, Clone)]\n@@ -111,11 +112,11 @@ impl<'tcx> EvalCtxt<'tcx> {\n             // No entry, simply push this goal on the stack after dealing with overflow.\n             Entry::Vacant(v) => {\n                 if self.overflow_data.has_overflow(cache.stack.len()) {\n-                    return Err(self.deal_with_overflow());\n+                    return Err(self.deal_with_overflow(goal));\n                 }\n \n                 v.insert(ProvisionalEntry {\n-                    response: fixme_response_yes_no_constraints(),\n+                    response: response_no_constraints(self.tcx, goal, Certainty::Yes),\n                     depth: cache.stack.len(),\n                 });\n                 cache.stack.push(StackElem { goal, has_been_used: false });\n@@ -150,7 +151,11 @@ impl<'tcx> EvalCtxt<'tcx> {\n                 {\n                     Err(entry.response)\n                 } else {\n-                    Err(fixme_response_maybe_no_constraints())\n+                    Err(response_no_constraints(\n+                        self.tcx,\n+                        goal,\n+                        Certainty::Maybe(MaybeCause::Ambiguity),\n+                    ))\n                 }\n             }\n         }\n@@ -248,10 +253,39 @@ impl<'tcx> EvalCtxt<'tcx> {\n     }\n }\n \n-fn fixme_response_yes_no_constraints<'tcx>() -> QueryResult<'tcx> {\n-    unimplemented!()\n-}\n+pub(super) fn response_no_constraints<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    goal: Canonical<'tcx, impl Sized>,\n+    certainty: Certainty,\n+) -> QueryResult<'tcx> {\n+    let var_values = goal\n+        .variables\n+        .iter()\n+        .enumerate()\n+        .map(|(i, info)| match info.kind {\n+            CanonicalVarKind::Ty(_) | CanonicalVarKind::PlaceholderTy(_) => {\n+                tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i).into())).into()\n+            }\n+            CanonicalVarKind::Region(_) | CanonicalVarKind::PlaceholderRegion(_) => {\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(i),\n+                    kind: ty::BrAnon(i as u32, None),\n+                };\n+                tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n+            }\n+            CanonicalVarKind::Const(_, ty) | CanonicalVarKind::PlaceholderConst(_, ty) => tcx\n+                .mk_const(ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i)), ty)\n+                .into(),\n+        })\n+        .collect();\n \n-fn fixme_response_maybe_no_constraints<'tcx>() -> QueryResult<'tcx> {\n-    unimplemented!()\n+    Ok(Canonical {\n+        max_universe: goal.max_universe,\n+        variables: goal.variables,\n+        value: Response {\n+            var_values: CanonicalVarValues { var_values },\n+            external_constraints: Default::default(),\n+            certainty,\n+        },\n+    })\n }"}, {"sha": "dfc2b5ed32947d11a847fd64019b391bf9fc32af", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n         let mut errors = Vec::new();\n         for i in 0.. {\n             if !infcx.tcx.recursion_limit().value_within_limit(i) {\n-                unimplemented!(\"overflow\")\n+                unimplemented!(\"overflowed on pending obligations: {:?}\", self.obligations);\n             }\n \n             let mut has_changed = false;"}, {"sha": "042ba96b379e08ac271a80040fac474e621b233b", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -19,15 +19,19 @@\n \n use std::mem;\n \n-use rustc_infer::infer::canonical::OriginalQueryValues;\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::canonical::{OriginalQueryValues, QueryRegionConstraints, QueryResponse};\n+use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::Obligation;\n+use rustc_middle::infer::canonical::Certainty as OldCertainty;\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{RegionOutlivesPredicate, ToPredicate, TypeOutlivesPredicate};\n use rustc_span::DUMMY_SP;\n \n+use crate::traits::ObligationCause;\n+\n+use self::cache::response_no_constraints;\n use self::infcx_ext::InferCtxtExt;\n \n mod assembly;\n@@ -119,7 +123,7 @@ pub enum MaybeCause {\n }\n \n /// Additional constraints returned on success.\n-#[derive(Debug, PartialEq, Eq, Clone, Hash, TypeFoldable, TypeVisitable)]\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, TypeFoldable, TypeVisitable, Default)]\n pub struct ExternalConstraints<'tcx> {\n     // FIXME: implement this.\n     regions: (),\n@@ -175,7 +179,7 @@ impl<'tcx> EvalCtxt<'tcx> {\n         let canonical_response = self.evaluate_canonical_goal(canonical_goal)?;\n         Ok((\n             true, // FIXME: check whether `var_values` are an identity substitution.\n-            fixme_instantiate_canonical_query_response(infcx, &orig_values, canonical_response),\n+            instantiate_canonical_query_response(infcx, &orig_values, canonical_response),\n         ))\n     }\n \n@@ -208,7 +212,8 @@ impl<'tcx> EvalCtxt<'tcx> {\n         // of `PredicateKind` this is the case and it is and faster than instantiating and\n         // recanonicalizing.\n         let Goal { param_env, predicate } = canonical_goal.value;\n-        if let Some(kind) = predicate.kind().no_bound_vars() {\n+\n+        if let Some(kind) = predicate.kind().no_bound_vars_ignoring_escaping(self.tcx) {\n             match kind {\n                 ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => self.compute_trait_goal(\n                     canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n@@ -234,7 +239,10 @@ impl<'tcx> EvalCtxt<'tcx> {\n                 | ty::PredicateKind::ConstEvaluatable(_)\n                 | ty::PredicateKind::ConstEquate(_, _)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(_)\n-                | ty::PredicateKind::Ambiguous => unimplemented!(),\n+                | ty::PredicateKind::Ambiguous => {\n+                    // FIXME\n+                    response_no_constraints(self.tcx, canonical_goal, Certainty::Yes)\n+                }\n             }\n         } else {\n             let (infcx, goal, var_values) =\n@@ -248,16 +256,18 @@ impl<'tcx> EvalCtxt<'tcx> {\n \n     fn compute_type_outlives_goal(\n         &mut self,\n-        _goal: CanonicalGoal<'tcx, TypeOutlivesPredicate<'tcx>>,\n+        goal: CanonicalGoal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        todo!()\n+        // FIXME\n+        response_no_constraints(self.tcx, goal, Certainty::Yes)\n     }\n \n     fn compute_region_outlives_goal(\n         &mut self,\n-        _goal: CanonicalGoal<'tcx, RegionOutlivesPredicate<'tcx>>,\n+        goal: CanonicalGoal<'tcx, RegionOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        todo!()\n+        // FIXME\n+        response_no_constraints(self.tcx, goal, Certainty::Yes)\n     }\n }\n \n@@ -300,10 +310,27 @@ impl<'tcx> EvalCtxt<'tcx> {\n     }\n }\n \n-fn fixme_instantiate_canonical_query_response<'tcx>(\n-    _: &InferCtxt<'tcx>,\n-    _: &OriginalQueryValues<'tcx>,\n-    _: CanonicalResponse<'tcx>,\n+fn instantiate_canonical_query_response<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    original_values: &OriginalQueryValues<'tcx>,\n+    response: CanonicalResponse<'tcx>,\n ) -> Certainty {\n-    unimplemented!()\n+    let Ok(InferOk { value, obligations }) = infcx\n+        .instantiate_query_response_and_region_obligations(\n+            &ObligationCause::dummy(),\n+            ty::ParamEnv::empty(),\n+            original_values,\n+            &response.unchecked_map(|resp| QueryResponse {\n+                var_values: resp.var_values,\n+                region_constraints: QueryRegionConstraints::default(),\n+                certainty: match resp.certainty {\n+                    Certainty::Yes => OldCertainty::Proven,\n+                    Certainty::Maybe(_) => OldCertainty::Ambiguous,\n+                },\n+                opaque_types: resp.external_constraints.opaque_types,\n+                value: resp.certainty,\n+            }),\n+        ) else { bug!(); };\n+    assert!(obligations.is_empty());\n+    value\n }"}, {"sha": "8bbb9f63e78682702ed9fdba111658e8e9ad3539", "filename": "compiler/rustc_trait_selection/src/solve/overflow.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,7 +1,9 @@\n+use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Limit;\n \n+use super::cache::response_no_constraints;\n use super::{Certainty, EvalCtxt, MaybeCause, QueryResult};\n \n /// When detecting a solver overflow, we return ambiguity. Overflow can be\n@@ -49,9 +51,12 @@ impl OverflowData {\n }\n \n impl<'tcx> EvalCtxt<'tcx> {\n-    pub(super) fn deal_with_overflow(&mut self) -> QueryResult<'tcx> {\n+    pub(super) fn deal_with_overflow(\n+        &mut self,\n+        goal: Canonical<'tcx, impl Sized>,\n+    ) -> QueryResult<'tcx> {\n         self.overflow_data.deal_with_overflow();\n-        fixme_response_overflow_no_constraints()\n+        response_no_constraints(self.tcx, goal, Certainty::Maybe(MaybeCause::Overflow))\n     }\n \n     /// A `while`-loop which tracks overflow.\n@@ -74,7 +79,3 @@ impl<'tcx> EvalCtxt<'tcx> {\n         Ok(Certainty::Maybe(MaybeCause::Overflow))\n     }\n }\n-\n-fn fixme_response_overflow_no_constraints<'tcx>() -> QueryResult<'tcx> {\n-    unimplemented!()\n-}"}, {"sha": "e9140507192e1d296ec0a1671f383a62004ba7e4", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -110,7 +110,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     ) {\n         let tcx = acx.cx.tcx;\n         let goal_trait_ref = goal.predicate.projection_ty.trait_ref(tcx);\n-        let impl_trait_ref = tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n+        let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n         if iter::zip(goal_trait_ref.substs, impl_trait_ref.skip_binder().substs)\n             .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))"}, {"sha": "a43fef5cdb0c875f26e0976766cf9faedc0febf1", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     ) {\n         let tcx = acx.cx.tcx;\n \n-        let impl_trait_ref = tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n+        let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n         if iter::zip(goal.predicate.trait_ref.substs, impl_trait_ref.skip_binder().substs)\n             .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))"}, {"sha": "0edae34190c300f2a42a616db12251dab87a175e", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -80,7 +80,7 @@ pub fn overlapping_impls(\n     let impl1_ref = tcx.impl_trait_ref(impl1_def_id);\n     let impl2_ref = tcx.impl_trait_ref(impl2_def_id);\n     let may_overlap = match (impl1_ref, impl2_ref) {\n-        (Some(a), Some(b)) => iter::zip(a.substs, b.substs)\n+        (Some(a), Some(b)) => iter::zip(a.skip_binder().substs, b.skip_binder().substs)\n             .all(|(arg1, arg2)| drcx.generic_args_may_unify(arg1, arg2)),\n         (None, None) => {\n             let self_ty1 = tcx.type_of(impl1_def_id);\n@@ -126,7 +126,7 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n     let header = ty::ImplHeader {\n         impl_def_id,\n         self_ty: tcx.bound_type_of(impl_def_id).subst(tcx, impl_substs),\n-        trait_ref: tcx.bound_impl_trait_ref(impl_def_id).map(|i| i.subst(tcx, impl_substs)),\n+        trait_ref: tcx.impl_trait_ref(impl_def_id).map(|i| i.subst(tcx, impl_substs)),\n         predicates: tcx.predicates_of(impl_def_id).instantiate(tcx, impl_substs).predicates,\n     };\n \n@@ -461,7 +461,7 @@ pub fn orphan_check(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Result<(), OrphanChe\n \n     // We only except this routine to be invoked on implementations\n     // of a trait, not inherent implementations.\n-    let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+    let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().subst_identity();\n     debug!(\"orphan_check: trait_ref={:?}\", trait_ref);\n \n     // If the *trait* is local to the crate, ok."}, {"sha": "df57c0f60fa6d760675b5ece4064a98d0d41ebe8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/ambiguity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -27,7 +27,7 @@ pub fn recompute_applicable_impls<'tcx>(\n             ocx.normalize(&ObligationCause::dummy(), param_env, placeholder_obligation.trait_ref);\n \n         let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n-        let impl_trait_ref = tcx.bound_impl_trait_ref(impl_def_id).unwrap().subst(tcx, impl_substs);\n+        let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().subst(tcx, impl_substs);\n         let impl_trait_ref = ocx.normalize(&ObligationCause::dummy(), param_env, impl_trait_ref);\n \n         if let Err(_) ="}, {"sha": "32b0f65176c187a88b93d5390bf92801f93ec0fa", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 51, "deletions": 22, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -374,6 +374,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         })\n     }\n }\n+\n impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn report_fulfillment_errors(\n         &self,\n@@ -453,9 +454,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n         }\n \n-        for (error, suppressed) in iter::zip(errors, is_suppressed) {\n-            if !suppressed {\n-                self.report_fulfillment_error(error, body_id);\n+        for from_expansion in [false, true] {\n+            for (error, suppressed) in iter::zip(errors, &is_suppressed) {\n+                if !suppressed && error.obligation.cause.span.from_expansion() == from_expansion {\n+                    self.report_fulfillment_error(error, body_id);\n+                }\n             }\n         }\n \n@@ -852,6 +855,29 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         let mut suggested =\n                             self.suggest_dereferences(&obligation, &mut err, trait_predicate);\n                         suggested |= self.suggest_fn_call(&obligation, &mut err, trait_predicate);\n+                        let impl_candidates = self.find_similar_impl_candidates(trait_predicate);\n+                        suggested = if let &[cand] = &impl_candidates[..] {\n+                            let cand = cand.trait_ref;\n+                            if let (ty::FnPtr(_), ty::FnDef(..)) =\n+                                (cand.self_ty().kind(), trait_ref.self_ty().skip_binder().kind())\n+                            {\n+                                err.span_suggestion(\n+                                    span.shrink_to_hi(),\n+                                    format!(\n+                                        \"the trait `{}` is implemented for fn pointer `{}`, try casting using `as`\",\n+                                        cand.print_only_trait_path(),\n+                                        cand.self_ty(),\n+                                    ),\n+                                    format!(\" as {}\", cand.self_ty()),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                true\n+                            } else {\n+                                false\n+                            }\n+                        } else {\n+                            false\n+                        } || suggested;\n                         suggested |=\n                             self.suggest_remove_reference(&obligation, &mut err, trait_predicate);\n                         suggested |= self.suggest_semicolon_removal(\n@@ -1940,7 +1966,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     return None;\n                 }\n \n-                let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+                let imp = self.tcx.impl_trait_ref(def_id).unwrap().skip_binder();\n \n                 self.fuzzy_match_tys(trait_pred.skip_binder().self_ty(), imp.self_ty(), false)\n                     .map(|similarity| ImplCandidate { trait_ref: imp, similarity })\n@@ -1968,27 +1994,25 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             candidates.sort();\n             candidates.dedup();\n             let len = candidates.len();\n-            if candidates.len() == 0 {\n+            if candidates.is_empty() {\n                 return false;\n             }\n-            if candidates.len() == 1 {\n-                let ty_desc = match candidates[0].self_ty().kind() {\n-                    ty::FnPtr(_) => Some(\"fn pointer\"),\n-                    _ => None,\n-                };\n-                let the_desc = match ty_desc {\n-                    Some(desc) => format!(\" implemented for {} `\", desc),\n-                    None => \" implemented for `\".to_string(),\n-                };\n+            if let &[cand] = &candidates[..] {\n+                let (desc, mention_castable) =\n+                    match (cand.self_ty().kind(), trait_ref.self_ty().skip_binder().kind()) {\n+                        (ty::FnPtr(_), ty::FnDef(..)) => {\n+                            (\" implemented for fn pointer `\", \", cast using `as`\")\n+                        }\n+                        (ty::FnPtr(_), _) => (\" implemented for fn pointer `\", \"\"),\n+                        _ => (\" implemented for `\", \"\"),\n+                    };\n                 err.highlighted_help(vec![\n-                    (\n-                        format!(\"the trait `{}` \", candidates[0].print_only_trait_path()),\n-                        Style::NoStyle,\n-                    ),\n+                    (format!(\"the trait `{}` \", cand.print_only_trait_path()), Style::NoStyle),\n                     (\"is\".to_string(), Style::Highlight),\n-                    (the_desc, Style::NoStyle),\n-                    (candidates[0].self_ty().to_string(), Style::Highlight),\n+                    (desc.to_string(), Style::NoStyle),\n+                    (cand.self_ty().to_string(), Style::Highlight),\n                     (\"`\".to_string(), Style::NoStyle),\n+                    (mention_castable.to_string(), Style::NoStyle),\n                 ]);\n                 return true;\n             }\n@@ -2040,6 +2064,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         || self.tcx.is_builtin_derive(def_id)\n                 })\n                 .filter_map(|def_id| self.tcx.impl_trait_ref(def_id))\n+                .map(ty::EarlyBinder::subst_identity)\n                 .filter(|trait_ref| {\n                     let self_ty = trait_ref.self_ty();\n                     // Avoid mentioning type parameters.\n@@ -2252,8 +2277,11 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     Ok(None) => {\n                         let ambiguities =\n                             ambiguity::recompute_applicable_impls(self.infcx, &obligation);\n-                        let has_non_region_infer =\n-                            trait_ref.skip_binder().substs.types().any(|t| !t.is_ty_infer());\n+                        let has_non_region_infer = trait_ref\n+                            .skip_binder()\n+                            .substs\n+                            .types()\n+                            .any(|t| !t.is_ty_or_numeric_infer());\n                         // It doesn't make sense to talk about applicable impls if there are more\n                         // than a handful of them.\n                         if ambiguities.len() > 1 && ambiguities.len() < 10 && has_non_region_infer {\n@@ -2909,6 +2937,7 @@ impl<'tcx> ty::TypeVisitor<'tcx> for HasNumericInferVisitor {\n     }\n }\n \n+#[derive(Copy, Clone)]\n pub enum DefIdOrName {\n     DefId(DefId),\n     Name(&'static str),"}, {"sha": "18d308f7123aec90bf1d9192e1cc5b24b76dc8a8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -68,7 +68,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         self.tcx.for_each_relevant_impl(trait_ref.def_id, trait_self_ty, |def_id| {\n             let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n-            let impl_trait_ref = tcx.bound_impl_trait_ref(def_id).unwrap().subst(tcx, impl_substs);\n+            let impl_trait_ref = tcx.impl_trait_ref(def_id).unwrap().subst(tcx, impl_substs);\n \n             let impl_self_ty = impl_trait_ref.self_ty();\n "}, {"sha": "8d707b74d92ea911227e0679851a7a624aa053c5", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 137, "deletions": 84, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -212,6 +212,13 @@ pub trait TypeErrCtxtExt<'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool;\n \n+    fn extract_callable_info(\n+        &self,\n+        hir_id: HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)>;\n+\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n@@ -878,99 +885,30 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n+        // It doesn't make sense to make this suggestion outside of typeck...\n+        // (also autoderef will ICE...)\n+        if self.typeck_results.is_none() {\n+            return false;\n+        }\n+\n         if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = obligation.predicate.kind().skip_binder()\n             && Some(trait_pred.def_id()) == self.tcx.lang_items().sized_trait()\n         {\n             // Don't suggest calling to turn an unsized type into a sized type\n             return false;\n         }\n \n-        // This is duplicated from `extract_callable_info` in typeck, which\n-        // relies on autoderef, so we can't use it here.\n-        let found = trait_pred.self_ty().skip_binder().peel_refs();\n-        let Some((def_id_or_name, output, inputs)) = (match *found.kind()\n-        {\n-            ty::FnPtr(fn_sig) => {\n-                Some((DefIdOrName::Name(\"function pointer\"), fn_sig.output(), fn_sig.inputs()))\n-            }\n-            ty::FnDef(def_id, _) => {\n-                let fn_sig = found.fn_sig(self.tcx);\n-                Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs()))\n-            }\n-            ty::Closure(def_id, substs) => {\n-                let fn_sig = substs.as_closure().sig();\n-                Some((\n-                    DefIdOrName::DefId(def_id),\n-                    fn_sig.output(),\n-                    fn_sig.inputs().map_bound(|inputs| &inputs[1..]),\n-                ))\n-            }\n-            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n-                    if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                    && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n-                    // args tuple will always be substs[1]\n-                    && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                    {\n-                        Some((\n-                            DefIdOrName::DefId(def_id),\n-                            pred.kind().rebind(proj.term.ty().unwrap()),\n-                            pred.kind().rebind(args.as_slice()),\n-                        ))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            }\n-            ty::Dynamic(data, _, ty::Dyn) => {\n-                data.iter().find_map(|pred| {\n-                    if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n-                    && Some(proj.def_id) == self.tcx.lang_items().fn_once_output()\n-                    // for existential projection, substs are shifted over by 1\n-                    && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n-                    {\n-                        Some((\n-                            DefIdOrName::Name(\"trait object\"),\n-                            pred.rebind(proj.term.ty().unwrap()),\n-                            pred.rebind(args.as_slice()),\n-                        ))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            }\n-            ty::Param(_) => {\n-                obligation.param_env.caller_bounds().iter().find_map(|pred| {\n-                    if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                    && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n-                    && proj.projection_ty.self_ty() == found\n-                    // args tuple will always be substs[1]\n-                    && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                    {\n-                        Some((\n-                            DefIdOrName::Name(\"type parameter\"),\n-                            pred.kind().rebind(proj.term.ty().unwrap()),\n-                            pred.kind().rebind(args.as_slice()),\n-                        ))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            }\n-            _ => None,\n-        }) else { return false; };\n-        let output = self.replace_bound_vars_with_fresh_vars(\n-            obligation.cause.span,\n+        let self_ty = self.replace_bound_vars_with_fresh_vars(\n+            DUMMY_SP,\n             LateBoundRegionConversionTime::FnCall,\n-            output,\n+            trait_pred.self_ty(),\n         );\n-        let inputs = inputs.skip_binder().iter().map(|ty| {\n-            self.replace_bound_vars_with_fresh_vars(\n-                obligation.cause.span,\n-                LateBoundRegionConversionTime::FnCall,\n-                inputs.rebind(*ty),\n-            )\n-        });\n+\n+        let Some((def_id_or_name, output, inputs)) = self.extract_callable_info(\n+            obligation.cause.body_id,\n+            obligation.param_env,\n+            self_ty,\n+        ) else { return false; };\n \n         // Remapping bound vars here\n         let trait_pred_and_self = trait_pred.map_bound(|trait_pred| (trait_pred, output));\n@@ -998,6 +936,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         };\n \n         let args = inputs\n+            .into_iter()\n             .map(|ty| {\n                 if ty.is_suggestable(self.tcx, false) {\n                     format!(\"/* {ty} */\")\n@@ -1161,6 +1100,120 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         false\n     }\n \n+    /// Extracts information about a callable type for diagnostics. This is a\n+    /// heuristic -- it doesn't necessarily mean that a type is always callable,\n+    /// because the callable type must also be well-formed to be called.\n+    fn extract_callable_info(\n+        &self,\n+        hir_id: HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)> {\n+        // Autoderef is useful here because sometimes we box callables, etc.\n+        let Some((def_id_or_name, output, inputs)) = (self.autoderef_steps)(found).into_iter().find_map(|(found, _)| {\n+            match *found.kind() {\n+                ty::FnPtr(fn_sig) =>\n+                    Some((DefIdOrName::Name(\"function pointer\"), fn_sig.output(), fn_sig.inputs())),\n+                ty::FnDef(def_id, _) => {\n+                    let fn_sig = found.fn_sig(self.tcx);\n+                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs()))\n+                }\n+                ty::Closure(def_id, substs) => {\n+                    let fn_sig = substs.as_closure().sig();\n+                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs().map_bound(|inputs| &inputs[1..])))\n+                }\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n+                    self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n+                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n+                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n+                        // args tuple will always be substs[1]\n+                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n+                        {\n+                            Some((\n+                                DefIdOrName::DefId(def_id),\n+                                pred.kind().rebind(proj.term.ty().unwrap()),\n+                                pred.kind().rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                ty::Dynamic(data, _, ty::Dyn) => {\n+                    data.iter().find_map(|pred| {\n+                        if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n+                        && Some(proj.def_id) == self.tcx.lang_items().fn_once_output()\n+                        // for existential projection, substs are shifted over by 1\n+                        && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n+                        {\n+                            Some((\n+                                DefIdOrName::Name(\"trait object\"),\n+                                pred.rebind(proj.term.ty().unwrap()),\n+                                pred.rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                ty::Param(param) => {\n+                    let generics = self.tcx.generics_of(hir_id.owner.to_def_id());\n+                    let name = if generics.count() > param.index as usize\n+                        && let def = generics.param_at(param.index as usize, self.tcx)\n+                        && matches!(def.kind, ty::GenericParamDefKind::Type { .. })\n+                        && def.name == param.name\n+                    {\n+                        DefIdOrName::DefId(def.def_id)\n+                    } else {\n+                        DefIdOrName::Name(\"type parameter\")\n+                    };\n+                    param_env.caller_bounds().iter().find_map(|pred| {\n+                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n+                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n+                        && proj.projection_ty.self_ty() == found\n+                        // args tuple will always be substs[1]\n+                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n+                        {\n+                            Some((\n+                                name,\n+                                pred.kind().rebind(proj.term.ty().unwrap()),\n+                                pred.kind().rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                _ => None,\n+            }\n+        }) else { return None; };\n+\n+        let output = self.replace_bound_vars_with_fresh_vars(\n+            DUMMY_SP,\n+            LateBoundRegionConversionTime::FnCall,\n+            output,\n+        );\n+        let inputs = inputs\n+            .skip_binder()\n+            .iter()\n+            .map(|ty| {\n+                self.replace_bound_vars_with_fresh_vars(\n+                    DUMMY_SP,\n+                    LateBoundRegionConversionTime::FnCall,\n+                    inputs.rebind(*ty),\n+                )\n+            })\n+            .collect();\n+\n+        // We don't want to register any extra obligations, which should be\n+        // implied by wf, but also because that would possibly result in\n+        // erroneous errors later on.\n+        let InferOk { value: output, obligations: _ } =\n+            self.at(&ObligationCause::dummy(), param_env).normalize(output);\n+\n+        if output.is_ty_var() { None } else { Some((def_id_or_name, output, inputs)) }\n+    }\n+\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,"}, {"sha": "13aa067844a92c4cf75b69add314996bca5e4e1c", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -308,7 +308,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // the `TypeOutlives` predicates first inside the unnormalized parameter environment, and\n     // then we normalize the `TypeOutlives` bounds inside the normalized parameter environment.\n     //\n-    // This works fairly well because trait matching  does not actually care about param-env\n+    // This works fairly well because trait matching does not actually care about param-env\n     // TypeOutlives predicates - these are normally used by regionck.\n     let outlives_predicates: Vec<_> = predicates\n         .drain_filter(|predicate| {\n@@ -521,8 +521,10 @@ fn is_impossible_method(tcx: TyCtxt<'_>, (impl_def_id, trait_item_def_id): (DefI\n \n     let generics = tcx.generics_of(trait_item_def_id);\n     let predicates = tcx.predicates_of(trait_item_def_id);\n-    let impl_trait_ref =\n-        tcx.impl_trait_ref(impl_def_id).expect(\"expected impl to correspond to trait\");\n+    let impl_trait_ref = tcx\n+        .impl_trait_ref(impl_def_id)\n+        .expect(\"expected impl to correspond to trait\")\n+        .subst_identity();\n     let param_env = tcx.param_env(impl_def_id);\n \n     let mut visitor = ReferencesOnlyParentGenerics { tcx, generics, trait_item_def_id };"}, {"sha": "2733d9643fd77ad8c53d120322b6989138d1ecaf", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -357,7 +357,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // Before we create the substitutions and everything, first\n                 // consider a \"quick reject\". This avoids creating more types\n                 // and so forth that we need to.\n-                let impl_trait_ref = self.tcx().bound_impl_trait_ref(impl_def_id).unwrap();\n+                let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n                 if self.fast_reject_trait_refs(obligation, &impl_trait_ref.0) {\n                     return;\n                 }"}, {"sha": "6c8df0a794fdcb5fc1a19306f92d952827f7df33", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2335,7 +2335,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         impl_def_id: DefId,\n         obligation: &TraitObligation<'tcx>,\n     ) -> Normalized<'tcx, SubstsRef<'tcx>> {\n-        let impl_trait_ref = self.tcx().bound_impl_trait_ref(impl_def_id).unwrap();\n+        let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n         match self.match_impl(impl_def_id, impl_trait_ref, obligation) {\n             Ok(substs) => substs,\n             Err(()) => {"}, {"sha": "3b796c623c0ab11a771bf7eb990b1433dc607ef5", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -87,7 +87,7 @@ pub fn translate_substs<'tcx>(\n         param_env, source_impl, source_substs, target_node\n     );\n     let source_trait_ref =\n-        infcx.tcx.bound_impl_trait_ref(source_impl).unwrap().subst(infcx.tcx, &source_substs);\n+        infcx.tcx.impl_trait_ref(source_impl).unwrap().subst(infcx.tcx, &source_substs);\n \n     // translate the Self and Param parts of the substitution, since those\n     // vary across impls\n@@ -148,7 +148,7 @@ pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId,\n \n     // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n     let penv = tcx.param_env(impl1_def_id);\n-    let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n+    let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap().subst_identity();\n \n     // Create an infcx, taking the predicates of impl1 as assumptions:\n     let infcx = tcx.infer_ctxt().build();\n@@ -431,7 +431,7 @@ fn report_conflicting_impls<'tcx>(\n pub(crate) fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<String> {\n     use std::fmt::Write;\n \n-    let trait_ref = tcx.impl_trait_ref(impl_def_id)?;\n+    let trait_ref = tcx.impl_trait_ref(impl_def_id)?.subst_identity();\n     let mut w = \"impl\".to_owned();\n \n     let substs = InternalSubsts::identity_for_item(tcx, impl_def_id);"}, {"sha": "0f9196de4fb197f5974d6b38b437352878ccabf9", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -48,7 +48,7 @@ trait ChildrenExt<'tcx> {\n impl<'tcx> ChildrenExt<'tcx> for Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n-        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().skip_binder();\n         if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer)\n         {\n             debug!(\"insert_blindly: impl_def_id={:?} st={:?}\", impl_def_id, st);\n@@ -63,7 +63,7 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n     /// an impl with a parent. The impl must be present in the list of\n     /// children already.\n     fn remove_existing(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n-        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().skip_binder();\n         let vec: &mut Vec<DefId>;\n         if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer)\n         {\n@@ -181,15 +181,15 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n             if le && !ge {\n                 debug!(\n                     \"descending as child of TraitRef {:?}\",\n-                    tcx.impl_trait_ref(possible_sibling).unwrap()\n+                    tcx.impl_trait_ref(possible_sibling).unwrap().subst_identity()\n                 );\n \n                 // The impl specializes `possible_sibling`.\n                 return Ok(Inserted::ShouldRecurseOn(possible_sibling));\n             } else if ge && !le {\n                 debug!(\n                     \"placing as parent of TraitRef {:?}\",\n-                    tcx.impl_trait_ref(possible_sibling).unwrap()\n+                    tcx.impl_trait_ref(possible_sibling).unwrap().subst_identity()\n                 );\n \n                 replace_children.push(possible_sibling);\n@@ -275,7 +275,8 @@ impl<'tcx> GraphExt<'tcx> for Graph {\n     ) -> Result<Option<FutureCompatOverlapError<'tcx>>, OverlapError<'tcx>> {\n         assert!(impl_def_id.is_local());\n \n-        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        // FIXME: use `EarlyBinder` in `self.children`\n+        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().skip_binder();\n         let trait_def_id = trait_ref.def_id;\n \n         debug!(\n@@ -388,7 +389,7 @@ pub(crate) fn assoc_def(\n     impl_def_id: DefId,\n     assoc_def_id: DefId,\n ) -> Result<LeafDef, ErrorGuaranteed> {\n-    let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n+    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n     let trait_def = tcx.trait_def(trait_def_id);\n \n     // This function may be called while we are still building the"}, {"sha": "7c0cae1e7bdc2e6658a8267d575562368a7fca2e", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -309,7 +309,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(self.interner, bound_vars);\n \n-        let trait_ref = self.interner.tcx.bound_impl_trait_ref(def_id).expect(\"not an impl\");\n+        let trait_ref = self.interner.tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n         let trait_ref = trait_ref.subst(self.interner.tcx, bound_vars);\n \n         let where_clauses = self.where_clauses_for(def_id, bound_vars);\n@@ -351,7 +351,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let all_impls = self.interner.tcx.all_impls(def_id);\n         let matched_impls = all_impls.filter(|impl_def_id| {\n             use chalk_ir::could_match::CouldMatch;\n-            let trait_ref = self.interner.tcx.bound_impl_trait_ref(*impl_def_id).unwrap();\n+            let trait_ref = self.interner.tcx.impl_trait_ref(*impl_def_id).unwrap();\n             let bound_vars = bound_vars_for_item(self.interner.tcx, *impl_def_id);\n \n             let self_ty = trait_ref.map_bound(|t| t.self_ty());\n@@ -380,7 +380,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let trait_def_id = auto_trait_id.0;\n         let all_impls = self.interner.tcx.all_impls(trait_def_id);\n         for impl_def_id in all_impls {\n-            let trait_ref = self.interner.tcx.impl_trait_ref(impl_def_id).unwrap();\n+            let trait_ref = self.interner.tcx.impl_trait_ref(impl_def_id).unwrap().subst_identity();\n             let self_ty = trait_ref.self_ty();\n             let provides = match (self_ty.kind(), chalk_ty) {\n                 (&ty::Adt(impl_adt_def, ..), Adt(id, ..)) => impl_adt_def.did() == id.0.did(),"}, {"sha": "7a24645803c9660441eef85bba5f794d5d51aced", "filename": "compiler/rustc_ty_utils/src/implied_bounds.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -21,14 +21,16 @@ fn assumed_wf_types(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::List<Ty<'_>> {\n             assumed_wf_types.extend(liberated_sig.inputs_and_output);\n             tcx.intern_type_list(&assumed_wf_types)\n         }\n-        DefKind::Impl => match tcx.impl_trait_ref(def_id) {\n-            Some(trait_ref) => {\n-                let types: Vec<_> = trait_ref.substs.types().collect();\n-                tcx.intern_type_list(&types)\n+        DefKind::Impl => {\n+            match tcx.impl_trait_ref(def_id) {\n+                Some(trait_ref) => {\n+                    let types: Vec<_> = trait_ref.skip_binder().substs.types().collect();\n+                    tcx.intern_type_list(&types)\n+                }\n+                // Only the impl self type\n+                None => tcx.intern_type_list(&[tcx.type_of(def_id)]),\n             }\n-            // Only the impl self type\n-            None => tcx.intern_type_list(&[tcx.type_of(def_id)]),\n-        },\n+        }\n         DefKind::AssocConst | DefKind::AssocTy => tcx.assumed_wf_types(tcx.parent(def_id)),\n         DefKind::Mod\n         | DefKind::Struct"}, {"sha": "eb5454bf2634b6b61f948a265efea3b59a0ed8c5", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -289,7 +289,7 @@ fn well_formed_types_in_env(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::List<Predica\n         // In a trait impl, we assume that the header trait ref and all its\n         // constituents are well-formed.\n         NodeKind::TraitImpl => {\n-            let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n+            let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\").subst_identity();\n \n             // FIXME(chalk): this has problems because of late-bound regions\n             //inputs.extend(trait_ref.substs.iter().flat_map(|arg| arg.walk()));\n@@ -360,7 +360,8 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n \n     let trait_ref = tcx\n         .impl_trait_ref(def_id)\n-        .unwrap_or_else(|| bug!(\"issue33140_self_ty called on inherent impl {:?}\", def_id));\n+        .unwrap_or_else(|| bug!(\"issue33140_self_ty called on inherent impl {:?}\", def_id))\n+        .skip_binder();\n \n     debug!(\"issue33140_self_ty({:?}), trait-ref={:?}\", def_id, trait_ref);\n "}, {"sha": "3a797bd5ecaa8ea84e8d90f8a47dab4f5b6c94b9", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -20,7 +20,7 @@ use core::marker::Destruct;\n mod tests;\n \n extern \"Rust\" {\n-    // These are the magic symbols to call the global allocator.  rustc generates\n+    // These are the magic symbols to call the global allocator. rustc generates\n     // them to call `__rg_alloc` etc. if there is a `#[global_allocator]` attribute\n     // (the code expanding that attribute macro generates those functions), or to call\n     // the default implementations in std (`__rdl_alloc` etc. in `library/std/src/alloc.rs`)\n@@ -353,7 +353,7 @@ pub(crate) const unsafe fn box_free<T: ?Sized, A: ~const Allocator + ~const Dest\n \n #[cfg(not(no_global_oom_handling))]\n extern \"Rust\" {\n-    // This is the magic symbol to call the global alloc error handler.  rustc generates\n+    // This is the magic symbol to call the global alloc error handler. rustc generates\n     // it to call `__rg_oom` if there is a `#[alloc_error_handler]`, or to call the\n     // default implementations below (`__rdl_oom`) otherwise.\n     fn __rust_alloc_error_handler(size: usize, align: usize) -> !;"}, {"sha": "f1d0a305d999f1b7e9ab3c85e77dc79d1450fb5b", "filename": "library/alloc/src/collections/binary_heap/mod.rs", "status": "renamed", "additions": 73, "deletions": 16, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -146,6 +146,7 @@\n use core::fmt;\n use core::iter::{FromIterator, FusedIterator, InPlaceIterable, SourceIter, TrustedLen};\n use core::mem::{self, swap, ManuallyDrop};\n+use core::num::NonZeroUsize;\n use core::ops::{Deref, DerefMut};\n use core::ptr;\n \n@@ -165,12 +166,20 @@ mod tests;\n /// It is a logic error for an item to be modified in such a way that the\n /// item's ordering relative to any other item, as determined by the [`Ord`]\n /// trait, changes while it is in the heap. This is normally only possible\n-/// through [`Cell`], [`RefCell`], global state, I/O, or unsafe code. The\n+/// through interior mutability, global state, I/O, or unsafe code. The\n /// behavior resulting from such a logic error is not specified, but will\n /// be encapsulated to the `BinaryHeap` that observed the logic error and not\n /// result in undefined behavior. This could include panics, incorrect results,\n /// aborts, memory leaks, and non-termination.\n ///\n+/// As long as no elements change their relative order while being in the heap\n+/// as described above, the API of `BinaryHeap` guarantees that the heap\n+/// invariant remains intact i.e. its methods all behave as documented. For\n+/// example if a method is documented as iterating in sorted order, that's\n+/// guaranteed to work as long as elements in the heap have not changed order,\n+/// even in the presence of closures getting unwinded out of, iterators getting\n+/// leaked, and similar foolishness.\n+///\n /// # Examples\n ///\n /// ```\n@@ -279,7 +288,9 @@ pub struct BinaryHeap<T> {\n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n pub struct PeekMut<'a, T: 'a + Ord> {\n     heap: &'a mut BinaryHeap<T>,\n-    sift: bool,\n+    // If a set_len + sift_down are required, this is Some. If a &mut T has not\n+    // yet been exposed to peek_mut()'s caller, it's None.\n+    original_len: Option<NonZeroUsize>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -292,7 +303,14 @@ impl<T: Ord + fmt::Debug> fmt::Debug for PeekMut<'_, T> {\n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n impl<T: Ord> Drop for PeekMut<'_, T> {\n     fn drop(&mut self) {\n-        if self.sift {\n+        if let Some(original_len) = self.original_len {\n+            // SAFETY: That's how many elements were in the Vec at the time of\n+            // the PeekMut::deref_mut call, and therefore also at the time of\n+            // the BinaryHeap::peek_mut call. Since the PeekMut did not end up\n+            // getting leaked, we are now undoing the leak amplification that\n+            // the DerefMut prepared for.\n+            unsafe { self.heap.data.set_len(original_len.get()) };\n+\n             // SAFETY: PeekMut is only instantiated for non-empty heaps.\n             unsafe { self.heap.sift_down(0) };\n         }\n@@ -313,7 +331,26 @@ impl<T: Ord> Deref for PeekMut<'_, T> {\n impl<T: Ord> DerefMut for PeekMut<'_, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         debug_assert!(!self.heap.is_empty());\n-        self.sift = true;\n+\n+        let len = self.heap.len();\n+        if len > 1 {\n+            // Here we preemptively leak all the rest of the underlying vector\n+            // after the currently max element. If the caller mutates the &mut T\n+            // we're about to give them, and then leaks the PeekMut, all these\n+            // elements will remain leaked. If they don't leak the PeekMut, then\n+            // either Drop or PeekMut::pop will un-leak the vector elements.\n+            //\n+            // This is technique is described throughout several other places in\n+            // the standard library as \"leak amplification\".\n+            unsafe {\n+                // SAFETY: len > 1 so len != 0.\n+                self.original_len = Some(NonZeroUsize::new_unchecked(len));\n+                // SAFETY: len > 1 so all this does for now is leak elements,\n+                // which is safe.\n+                self.heap.data.set_len(1);\n+            }\n+        }\n+\n         // SAFE: PeekMut is only instantiated for non-empty heaps\n         unsafe { self.heap.data.get_unchecked_mut(0) }\n     }\n@@ -323,9 +360,16 @@ impl<'a, T: Ord> PeekMut<'a, T> {\n     /// Removes the peeked value from the heap and returns it.\n     #[stable(feature = \"binary_heap_peek_mut_pop\", since = \"1.18.0\")]\n     pub fn pop(mut this: PeekMut<'a, T>) -> T {\n-        let value = this.heap.pop().unwrap();\n-        this.sift = false;\n-        value\n+        if let Some(original_len) = this.original_len.take() {\n+            // SAFETY: This is how many elements were in the Vec at the time of\n+            // the BinaryHeap::peek_mut call.\n+            unsafe { this.heap.data.set_len(original_len.get()) };\n+\n+            // Unlike in Drop, here we don't also need to do a sift_down even if\n+            // the caller could've mutated the element. It is removed from the\n+            // heap on the next line and pop() is not sensitive to its value.\n+        }\n+        this.heap.pop().unwrap()\n     }\n }\n \n@@ -398,8 +442,9 @@ impl<T: Ord> BinaryHeap<T> {\n     /// Returns a mutable reference to the greatest item in the binary heap, or\n     /// `None` if it is empty.\n     ///\n-    /// Note: If the `PeekMut` value is leaked, the heap may be in an\n-    /// inconsistent state.\n+    /// Note: If the `PeekMut` value is leaked, some heap elements might get\n+    /// leaked along with it, but the remaining elements will remain a valid\n+    /// heap.\n     ///\n     /// # Examples\n     ///\n@@ -426,7 +471,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// otherwise it's *O*(1).\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n     pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n-        if self.is_empty() { None } else { Some(PeekMut { heap: self, sift: false }) }\n+        if self.is_empty() { None } else { Some(PeekMut { heap: self, original_len: None }) }\n     }\n \n     /// Removes the greatest item from the binary heap and returns it, or `None` if it\n@@ -806,18 +851,30 @@ impl<T: Ord> BinaryHeap<T> {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        let mut first_removed = self.len();\n+        struct RebuildOnDrop<'a, T: Ord> {\n+            heap: &'a mut BinaryHeap<T>,\n+            first_removed: usize,\n+        }\n+\n+        let mut guard = RebuildOnDrop { first_removed: self.len(), heap: self };\n+\n         let mut i = 0;\n-        self.data.retain(|e| {\n+        guard.heap.data.retain(|e| {\n             let keep = f(e);\n-            if !keep && i < first_removed {\n-                first_removed = i;\n+            if !keep && i < guard.first_removed {\n+                guard.first_removed = i;\n             }\n             i += 1;\n             keep\n         });\n-        // data[0..first_removed] is untouched, so we only need to rebuild the tail:\n-        self.rebuild_tail(first_removed);\n+\n+        impl<'a, T: Ord> Drop for RebuildOnDrop<'a, T> {\n+            fn drop(&mut self) {\n+                // data[..first_removed] is untouched, so we only need to\n+                // rebuild the tail:\n+                self.heap.rebuild_tail(self.first_removed);\n+            }\n+        }\n     }\n }\n ", "previous_filename": "library/alloc/src/collections/binary_heap.rs"}, {"sha": "500caa35678ab2abc16f92c51e54fa56837f7122", "filename": "library/alloc/src/collections/binary_heap/tests.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,6 +1,7 @@\n use super::*;\n use crate::boxed::Box;\n use crate::testing::crash_test::{CrashTestDummy, Panic};\n+use core::mem;\n use std::iter::TrustedLen;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n@@ -146,6 +147,24 @@ fn test_peek_mut() {\n     assert_eq!(heap.peek(), Some(&9));\n }\n \n+#[test]\n+fn test_peek_mut_leek() {\n+    let data = vec![4, 2, 7];\n+    let mut heap = BinaryHeap::from(data);\n+    let mut max = heap.peek_mut().unwrap();\n+    *max = -1;\n+\n+    // The PeekMut object's Drop impl would have been responsible for moving the\n+    // -1 out of the max position of the BinaryHeap, but we don't run it.\n+    mem::forget(max);\n+\n+    // Absent some mitigation like leak amplification, the -1 would incorrectly\n+    // end up in the last position of the returned Vec, with the rest of the\n+    // heap's original contents in front of it in sorted order.\n+    let sorted_vec = heap.into_sorted_vec();\n+    assert!(sorted_vec.is_sorted(), \"{:?}\", sorted_vec);\n+}\n+\n #[test]\n fn test_peek_mut_pop() {\n     let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n@@ -455,6 +474,25 @@ fn test_retain() {\n     assert!(a.is_empty());\n }\n \n+#[test]\n+fn test_retain_catch_unwind() {\n+    let mut heap = BinaryHeap::from(vec![3, 1, 2]);\n+\n+    // Removes the 3, then unwinds out of retain.\n+    let _ = catch_unwind(AssertUnwindSafe(|| {\n+        heap.retain(|e| {\n+            if *e == 1 {\n+                panic!();\n+            }\n+            false\n+        });\n+    }));\n+\n+    // Naively this would be [1, 2] (an invalid heap) if BinaryHeap delegates to\n+    // Vec's retain impl and then does not rebuild the heap after that unwinds.\n+    assert_eq!(heap.into_vec(), [2, 1]);\n+}\n+\n // old binaryheap failed this test\n //\n // Integrity means that all elements are present after a comparison panics,"}, {"sha": "afc3a3dc6a8c6bb646b725f281052558f61e7844", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -125,6 +125,7 @@\n #![feature(hasher_prefixfree_extras)]\n #![feature(inline_const)]\n #![feature(inplace_iteration)]\n+#![cfg_attr(test, feature(is_sorted))]\n #![feature(iter_advance_by)]\n #![feature(iter_next_chunk)]\n #![feature(iter_repeat_n)]"}, {"sha": "c9aa23fc4af1f275e98ff6352e4e34480d6044cb", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2179,7 +2179,7 @@ pub struct Weak<T: ?Sized> {\n     // This is a `NonNull` to allow optimizing the size of this type in enums,\n     // but it is not necessarily a valid pointer.\n     // `Weak::new` sets this to `usize::MAX` so that it doesn\u2019t need\n-    // to allocate space on the heap.  That's not a value a real pointer\n+    // to allocate space on the heap. That's not a value a real pointer\n     // will ever have because RcBox has alignment at least 2.\n     // This is only possible when `T: Sized`; unsized `T` never dangle.\n     ptr: NonNull<RcBox<T>>,"}, {"sha": "bab7f5f53657a58cfa55f9614684a6a8b4978700", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -295,7 +295,7 @@ pub struct Weak<T: ?Sized> {\n     // This is a `NonNull` to allow optimizing the size of this type in enums,\n     // but it is not necessarily a valid pointer.\n     // `Weak::new` sets this to `usize::MAX` so that it doesn\u2019t need\n-    // to allocate space on the heap.  That's not a value a real pointer\n+    // to allocate space on the heap. That's not a value a real pointer\n     // will ever have because RcBox has alignment at least 2.\n     // This is only possible when `T: Sized`; unsized `T` never dangle.\n     ptr: NonNull<ArcInner<T>>,\n@@ -1656,7 +1656,7 @@ impl<T: ?Sized> Arc<T> {\n         //\n         // The acquire label here ensures a happens-before relationship with any\n         // writes to `strong` (in particular in `Weak::upgrade`) prior to decrements\n-        // of the `weak` count (via `Weak::drop`, which uses release).  If the upgraded\n+        // of the `weak` count (via `Weak::drop`, which uses release). If the upgraded\n         // weak ref was never dropped, the CAS here will fail so we do not care to synchronize.\n         if self.inner().weak.compare_exchange(1, usize::MAX, Acquire, Relaxed).is_ok() {\n             // This needs to be an `Acquire` to synchronize with the decrement of the `strong`\n@@ -1712,7 +1712,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n         }\n \n         // This fence is needed to prevent reordering of use of the data and\n-        // deletion of the data.  Because it is marked `Release`, the decreasing\n+        // deletion of the data. Because it is marked `Release`, the decreasing\n         // of the reference count synchronizes with this `Acquire` fence. This\n         // means that use of the data happens before decreasing the reference\n         // count, which happens before this fence, which happens before the\n@@ -2172,7 +2172,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n         } else {\n             return Weak { ptr: self.ptr };\n         };\n-        // See comments in Arc::clone() for why this is relaxed.  This can use a\n+        // See comments in Arc::clone() for why this is relaxed. This can use a\n         // fetch_add (ignoring the lock) because the weak count is only locked\n         // where are *no other* weak pointers in existence. (So we can't be\n         // running this code in that case)."}, {"sha": "37966007eb7e43eb1fb661d8925567b303f905ba", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -40,7 +40,7 @@ pub struct IntoIter<\n     // to avoid dropping the allocator twice we need to wrap it into ManuallyDrop\n     pub(super) alloc: ManuallyDrop<A>,\n     pub(super) ptr: *const T,\n-    pub(super) end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    pub(super) end: *const T, // If T is a ZST, this is actually ptr+len. This encoding is picked so that\n                               // ptr == end is a quick test for the Iterator being empty, that works\n                               // for both ZST and non-ZST.\n }\n@@ -146,9 +146,9 @@ impl<T, A: Allocator> IntoIter<T, A> {\n         let mut this = ManuallyDrop::new(self);\n \n         // SAFETY: This allocation originally came from a `Vec`, so it passes\n-        // all those checks.  We have `this.buf` \u2264 `this.ptr` \u2264 `this.end`,\n+        // all those checks. We have `this.buf` \u2264 `this.ptr` \u2264 `this.end`,\n         // so the `sub_ptr`s below cannot wrap, and will produce a well-formed\n-        // range.  `end` \u2264 `buf + cap`, so the range will be in-bounds.\n+        // range. `end` \u2264 `buf + cap`, so the range will be in-bounds.\n         // Taking `alloc` is ok because nothing else is going to look at it,\n         // since our `Drop` impl isn't going to run so there's no more code.\n         unsafe {"}, {"sha": "26120270c0cb0da8402a60b346e0999acf2873f8", "filename": "library/alloc/src/vec/is_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -57,7 +57,7 @@ unsafe impl<T: IsZero, const N: usize> IsZero for [T; N] {\n     #[inline]\n     fn is_zero(&self) -> bool {\n         // Because this is generated as a runtime check, it's not obvious that\n-        // it's worth doing if the array is really long.  The threshold here\n+        // it's worth doing if the array is really long. The threshold here\n         // is largely arbitrary, but was picked because as of 2022-07-01 LLVM\n         // fails to const-fold the check in `vec![[1; 32]; n]`\n         // See https://github.com/rust-lang/rust/pull/97581#issuecomment-1166628022"}, {"sha": "36b0b3c9e7cc072aca6f39d2f165d277d52cbdc3", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2429,7 +2429,7 @@ impl<T: Clone, A: Allocator> Vec<T, A> {\n         self.reserve(range.len());\n \n         // SAFETY:\n-        // - `slice::range` guarantees  that the given range is valid for indexing self\n+        // - `slice::range` guarantees that the given range is valid for indexing self\n         unsafe {\n             self.spec_extend_from_within(range);\n         }\n@@ -2686,7 +2686,7 @@ impl<T: Clone, A: Allocator + Clone> Clone for Vec<T, A> {\n \n     // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n     // required for this method definition, is not available. Instead use the\n-    // `slice::to_vec`  function which is only available with cfg(test)\n+    // `slice::to_vec` function which is only available with cfg(test)\n     // NB see the slice::hack module in slice.rs for more information\n     #[cfg(test)]\n     fn clone(&self) -> Self {"}, {"sha": "2f07c2911a50264aee57ab1a67b966a869045ef3", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1849,7 +1849,7 @@ fn test_stable_pointers() {\n     }\n \n     // Test that, if we reserved enough space, adding and removing elements does not\n-    // invalidate references into the vector (such as `v0`).  This test also\n+    // invalidate references into the vector (such as `v0`). This test also\n     // runs in Miri, which would detect such problems.\n     // Note that this test does *not* constitute a stable guarantee that all these functions do not\n     // reallocate! Only what is explicitly documented at"}, {"sha": "8259c087d22e4ff13cce9566ed8a828a169f0977", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -109,8 +109,8 @@ impl<T, const N: usize> IntoIter<T, N> {\n     /// use std::array::IntoIter;\n     /// use std::mem::MaybeUninit;\n     ///\n-    /// # // Hi!  Thanks for reading the code.  This is restricted to `Copy` because\n-    /// # // otherwise it could leak.  A fully-general version this would need a drop\n+    /// # // Hi!  Thanks for reading the code. This is restricted to `Copy` because\n+    /// # // otherwise it could leak. A fully-general version this would need a drop\n     /// # // guard to handle panics from the iterator, but this works for an example.\n     /// fn next_chunk<T: Copy, const N: usize>(\n     ///     it: &mut impl Iterator<Item = T>,\n@@ -211,7 +211,7 @@ impl<T, const N: usize> IntoIter<T, N> {\n         let initialized = 0..0;\n \n         // SAFETY: We're telling it that none of the elements are initialized,\n-        // which is trivially true.  And \u2200N: usize, 0 <= N.\n+        // which is trivially true. And \u2200N: usize, 0 <= N.\n         unsafe { Self::new_unchecked(buffer, initialized) }\n     }\n "}, {"sha": "fa5073e3304d72e93dff7a042804e043b234caa8", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -174,6 +174,11 @@ pub trait Write {\n     /// This method should generally not be invoked manually, but rather through\n     /// the [`write!`] macro itself.\n     ///\n+    /// # Errors\n+    ///\n+    /// This function will return an instance of [`Error`] on error. Please see\n+    /// [write_str](Write::write_str) for details.\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "b5739f2f3c0b057d286ecff2095d80f861c5ca18", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -756,7 +756,7 @@ impl<A: Step> Iterator for ops::Range<A> {\n     where\n         Self: TrustedRandomAccessNoCoerce,\n     {\n-        // SAFETY: The TrustedRandomAccess contract requires that callers only  pass an index\n+        // SAFETY: The TrustedRandomAccess contract requires that callers only pass an index\n         // that is in bounds.\n         // Additionally Self: TrustedRandomAccess is only implemented for Copy types\n         // which means even repeated reads of the same index would be safe."}, {"sha": "4cbe731b222f920131e999b0bd409747aa387a88", "filename": "library/core/src/iter/sources/from_generator.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_generator.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,3 +1,4 @@\n+use crate::fmt;\n use crate::ops::{Generator, GeneratorState};\n use crate::pin::Pin;\n \n@@ -23,14 +24,21 @@ use crate::pin::Pin;\n /// ```\n #[inline]\n #[unstable(feature = \"iter_from_generator\", issue = \"43122\", reason = \"generators are unstable\")]\n-pub fn from_generator<G: Generator<Return = ()> + Unpin>(\n-    generator: G,\n-) -> impl Iterator<Item = G::Yield> {\n+pub fn from_generator<G: Generator<Return = ()> + Unpin>(generator: G) -> FromGenerator<G> {\n     FromGenerator(generator)\n }\n \n-struct FromGenerator<G>(G);\n+/// An iterator over the values yielded by an underlying generator.\n+///\n+/// This `struct` is created by the [`iter::from_generator()`] function. See its documentation for\n+/// more.\n+///\n+/// [`iter::from_generator()`]: from_generator\n+#[unstable(feature = \"iter_from_generator\", issue = \"43122\", reason = \"generators are unstable\")]\n+#[derive(Clone)]\n+pub struct FromGenerator<G>(G);\n \n+#[unstable(feature = \"iter_from_generator\", issue = \"43122\", reason = \"generators are unstable\")]\n impl<G: Generator<Return = ()> + Unpin> Iterator for FromGenerator<G> {\n     type Item = G::Yield;\n \n@@ -41,3 +49,10 @@ impl<G: Generator<Return = ()> + Unpin> Iterator for FromGenerator<G> {\n         }\n     }\n }\n+\n+#[unstable(feature = \"iter_from_generator\", issue = \"43122\", reason = \"generators are unstable\")]\n+impl<G> fmt::Debug for FromGenerator<G> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"FromGenerator\").finish()\n+    }\n+}"}, {"sha": "3806977f70ee4598d6a78aa88483b10086460b36", "filename": "library/core/src/num/dec2flt/fpu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffpu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffpu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffpu.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -26,7 +26,7 @@ mod fpu_precision {\n     /// Developer's Manual (Volume 1).\n     ///\n     /// The only field which is relevant for the following code is PC, Precision Control. This\n-    /// field determines the precision of the operations performed by the  FPU. It can be set to:\n+    /// field determines the precision of the operations performed by the FPU. It can be set to:\n     ///  - 0b00, single precision i.e., 32-bits\n     ///  - 0b10, double precision i.e., 64-bits\n     ///  - 0b11, double extended precision i.e., 80-bits (default state)"}, {"sha": "2cae98b8e494334e640b3c936181cb1c6db32555", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1538,7 +1538,7 @@ macro_rules! int_impl {\n         ///\n         /// ```\n         /// #![feature(bigint_helper_methods)]\n-        /// // Only the  most significant word is signed.\n+        /// // Only the most significant word is signed.\n         /// //\n         #[doc = concat!(\"//   10  MAX    (a = 10 \u00d7 2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n         #[doc = concat!(\"// + -5    9    (b = -5 \u00d7 2^\", stringify!($BITS), \" + 9)\")]\n@@ -1625,7 +1625,7 @@ macro_rules! int_impl {\n         /// overflow.\n         ///\n         /// Performs \"ternary subtraction\" by subtracting both an integer\n-        /// operandand a borrow-in bit from `self`, and returns a tuple of the\n+        /// operand and a borrow-in bit from `self`, and returns a tuple of the\n         /// difference along with a boolean indicating whether an arithmetic\n         /// overflow would occur. On overflow, the wrapped value is returned.\n         ///\n@@ -1646,7 +1646,7 @@ macro_rules! int_impl {\n         ///\n         /// ```\n         /// #![feature(bigint_helper_methods)]\n-        /// // Only the  most significant word is signed.\n+        /// // Only the most significant word is signed.\n         /// //\n         #[doc = concat!(\"//    6    8    (a = 6 \u00d7 2^\", stringify!($BITS), \" + 8)\")]\n         #[doc = concat!(\"// - -5    9    (b = -5 \u00d7 2^\", stringify!($BITS), \" + 9)\")]"}, {"sha": "7cc00e3f8d1b7205b3e470b8302d52bcc8ddaba4", "filename": "library/core/src/option.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -652,13 +652,14 @@ impl<T> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Converts an <code>Option<[String]></code> into an <code>Option<[usize]></code>, preserving\n-    /// the original. The [`map`] method takes the `self` argument by value, consuming the original,\n-    /// so this technique uses `as_ref` to first take an `Option` to a reference\n-    /// to the value inside the original.\n+    /// Calculates the length of an <code>Option<[String]></code> as an <code>Option<[usize]></code>\n+    /// without moving the [`String`]. The [`map`] method takes the `self` argument by value,\n+    /// consuming the original, so this technique uses `as_ref` to first take an `Option` to a\n+    /// reference to the value inside the original.\n     ///\n     /// [`map`]: Option::map\n     /// [String]: ../../std/string/struct.String.html \"String\"\n+    /// [`String`]: ../../std/string/struct.String.html \"String\"\n     ///\n     /// ```\n     /// let text: Option<String> = Some(\"Hello, world!\".to_string());\n@@ -946,8 +947,8 @@ impl<T> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Converts an <code>Option<[String]></code> into an <code>Option<[usize]></code>, consuming\n-    /// the original:\n+    /// Calculates the length of an <code>Option<[String]></code> as an\n+    /// <code>Option<[usize]></code>, consuming the original:\n     ///\n     /// [String]: ../../std/string/struct.String.html \"String\"\n     /// ```"}, {"sha": "ec0c9984841e68089536f9836cfe70e5bb7dcd81", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -753,7 +753,7 @@ impl<P: DerefMut> Pin<P> {\n impl<'a, T: ?Sized> Pin<&'a T> {\n     /// Constructs a new pin by mapping the interior value.\n     ///\n-    /// For example, if you  wanted to get a `Pin` of a field of something,\n+    /// For example, if you wanted to get a `Pin` of a field of something,\n     /// you could use this to get access to that field in one line of code.\n     /// However, there are several gotchas with these \"pinning projections\";\n     /// see the [`pin` module] documentation for further details on that topic.\n@@ -856,7 +856,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n \n     /// Construct a new pin by mapping the interior value.\n     ///\n-    /// For example, if you  wanted to get a `Pin` of a field of something,\n+    /// For example, if you wanted to get a `Pin` of a field of something,\n     /// you could use this to get access to that field in one line of code.\n     /// However, there are several gotchas with these \"pinning projections\";\n     /// see the [`pin` module] documentation for further details on that topic."}, {"sha": "1ad9af1549a47fcdf12e46b391e12891c2fba0bd", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1701,7 +1701,7 @@ pub(crate) const unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usiz\n         // offset is not a multiple of `stride`, the input pointer was misaligned and no pointer\n         // offset will be able to produce a `p` aligned to the specified `a`.\n         //\n-        // The naive `-p (mod a)` equation  inhibits LLVM's ability to select instructions\n+        // The naive `-p (mod a)` equation inhibits LLVM's ability to select instructions\n         // like `lea`. We compute `(round_up_to_next_alignment(p, a) - p)` instead. This\n         // redistributes operations around the load-bearing, but pessimizing `and` instruction\n         // sufficiently for LLVM to be able to utilize the various optimizations it knows about."}, {"sha": "c3e7f2eb302ca38102f4dad1bd55d35105f10036", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -65,7 +65,7 @@ fn size_from_ptr<T>(_: *const T) -> usize {\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct Iter<'a, T: 'a> {\n     ptr: NonNull<T>,\n-    end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    end: *const T, // If T is a ZST, this is actually ptr+len. This encoding is picked so that\n     // ptr == end is a quick test for the Iterator being empty, that works\n     // for both ZST and non-ZST.\n     _marker: PhantomData<&'a T>,\n@@ -186,7 +186,7 @@ impl<T> AsRef<[T]> for Iter<'_, T> {\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct IterMut<'a, T: 'a> {\n     ptr: NonNull<T>,\n-    end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    end: *mut T, // If T is a ZST, this is actually ptr+len. This encoding is picked so that\n     // ptr == end is a quick test for the Iterator being empty, that works\n     // for both ZST and non-ZST.\n     _marker: PhantomData<&'a mut T>,"}, {"sha": "55af4cb61dcc09383f4a23603f5d843767648896", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -23,7 +23,7 @@ macro_rules! len {\n             $self.end.addr().wrapping_sub(start.as_ptr().addr())\n         } else {\n             // We know that `start <= end`, so can do better than `offset_from`,\n-            // which needs to deal in signed.  By setting appropriate flags here\n+            // which needs to deal in signed. By setting appropriate flags here\n             // we can tell LLVM this, which helps it remove bounds checks.\n             // SAFETY: By the type invariant, `start <= end`\n             let diff = unsafe { unchecked_sub($self.end.addr(), start.as_ptr().addr()) };"}, {"sha": "df7fe2bf76dcda7568976ec874956de7aa6eb3f1", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -703,7 +703,7 @@ impl<T> [T] {\n \n             // Because this function is first compiled in isolation,\n             // this check tells LLVM that the indexing below is\n-            // in-bounds.  Then after inlining -- once the actual\n+            // in-bounds. Then after inlining -- once the actual\n             // lengths of the slices are known -- it's removed.\n             let (a, b) = (&mut a[..n], &mut b[..n]);\n \n@@ -1248,7 +1248,7 @@ impl<T> [T] {\n         ArrayChunksMut::new(self)\n     }\n \n-    /// Returns an iterator over overlapping windows of `N` elements of  a slice,\n+    /// Returns an iterator over overlapping windows of `N` elements of a slice,\n     /// starting at the beginning of the slice.\n     ///\n     /// This is the const generic equivalent of [`windows`].\n@@ -2476,7 +2476,7 @@ impl<T> [T] {\n             let mid = left + size / 2;\n \n             // SAFETY: the while condition means `size` is strictly positive, so\n-            // `size/2 < size`.  Thus `left + size/2 < left + size`, which\n+            // `size/2 < size`. Thus `left + size/2 < left + size`, which\n             // coupled with the `left + size <= self.len()` invariant means\n             // we have `left + size/2 < self.len()`, and this is in-bounds.\n             let cmp = f(unsafe { self.get_unchecked(mid) });"}, {"sha": "4d2fcd917849caf5378a0c04f70a2a0dbf593fd4", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -18,9 +18,9 @@ struct CopyOnDrop<T> {\n \n impl<T> Drop for CopyOnDrop<T> {\n     fn drop(&mut self) {\n-        // SAFETY:  This is a helper class.\n-        //          Please refer to its usage for correctness.\n-        //          Namely, one must be sure that `src` and `dst` does not overlap as required by `ptr::copy_nonoverlapping`.\n+        // SAFETY: This is a helper class.\n+        //         Please refer to its usage for correctness.\n+        //         Namely, one must be sure that `src` and `dst` does not overlap as required by `ptr::copy_nonoverlapping`.\n         unsafe {\n             ptr::copy_nonoverlapping(self.src, self.dest, 1);\n         }"}, {"sha": "14367eb09bc75e0e00c13ec9a4025638df8630f0", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1786,6 +1786,42 @@ impl<T> AtomicPtr<T> {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_xor(self.p.get(), core::ptr::invalid_mut(val), order).cast() }\n     }\n+\n+    /// Returns a mutable pointer to the underlying pointer.\n+    ///\n+    /// Doing non-atomic reads and writes on the resulting integer can be a data race.\n+    /// This method is mostly useful for FFI, where the function signature may use\n+    /// `*mut *mut T` instead of `&AtomicPtr<T>`.\n+    ///\n+    /// Returning an `*mut` pointer from a shared reference to this atomic is safe because the\n+    /// atomic types work with interior mutability. All modifications of an atomic change the value\n+    /// through a shared reference, and can do so safely as long as they use atomic operations. Any\n+    /// use of the returned raw pointer requires an `unsafe` block and still has to uphold the same\n+    /// restriction: operations on it must be atomic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore (extern-declaration)\n+    /// #![feature(atomic_mut_ptr)]\n+    //// use std::sync::atomic::AtomicPtr;\n+    ///\n+    /// extern \"C\" {\n+    ///     fn my_atomic_op(arg: *mut *mut u32);\n+    /// }\n+    ///\n+    /// let mut value = 17;\n+    /// let atomic = AtomicPtr::new(&mut value);\n+    ///\n+    /// // SAFETY: Safe as long as `my_atomic_op` is atomic.\n+    /// unsafe {\n+    ///     my_atomic_op(atomic.as_mut_ptr());\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"atomic_mut_ptr\", reason = \"recently added\", issue = \"66893\")]\n+    pub fn as_mut_ptr(&self) -> *mut *mut T {\n+        self.p.get()\n+    }\n }\n \n #[cfg(target_has_atomic_load_store = \"8\")]\n@@ -2678,9 +2714,9 @@ macro_rules! atomic_int {\n             #[doc = concat!(\"    fn my_atomic_op(arg: *mut \", stringify!($int_type), \");\")]\n             /// }\n             ///\n-            #[doc = concat!(\"let mut atomic = \", stringify!($atomic_type), \"::new(1);\")]\n+            #[doc = concat!(\"let atomic = \", stringify!($atomic_type), \"::new(1);\")]\n             ///\n-            // SAFETY: Safe as long as `my_atomic_op` is atomic.\n+            /// // SAFETY: Safe as long as `my_atomic_op` is atomic.\n             /// unsafe {\n             ///     my_atomic_op(atomic.as_mut_ptr());\n             /// }"}, {"sha": "39559cdbb5ea9c275b9b3db5b1db08291ec90c64", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1488,7 +1488,7 @@ mod slice_index {\n                 // optional:\n                 //\n                 // one or more similar inputs for which data[input] succeeds,\n-                // and the corresponding output as an array.  This helps validate\n+                // and the corresponding output as an array. This helps validate\n                 // \"critical points\" where an input range straddles the boundary\n                 // between valid and invalid.\n                 // (such as the input `len..len`, which is just barely valid)"}, {"sha": "286ad68fd13e8fdf70efab2fb31cb122ec23286d", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1512,7 +1512,7 @@ impl FileType {\n     }\n \n     /// Tests whether this file type represents a regular file.\n-    /// The result is  mutually exclusive to the results of\n+    /// The result is mutually exclusive to the results of\n     /// [`is_dir`] and [`is_symlink`]; only zero or one of these\n     /// tests may pass.\n     ///"}, {"sha": "4c1b7d57684ddcf01b890b8742bc4732588248e8", "filename": "library/std/src/io/buffered/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -288,8 +288,8 @@ fn test_buffered_reader_seek_underflow_discard_buffer_between_seeks() {\n     let mut reader = BufReader::with_capacity(5, ErrAfterFirstSeekReader { first_seek: true });\n     assert_eq!(reader.fill_buf().ok(), Some(&[0, 0, 0, 0, 0][..]));\n \n-    // The following seek will require two underlying seeks.  The first will\n-    // succeed but the second will fail.  This should still invalidate the\n+    // The following seek will require two underlying seeks. The first will\n+    // succeed but the second will fail. This should still invalidate the\n     // buffer.\n     assert!(reader.seek(SeekFrom::Current(i64::MIN)).is_err());\n     assert_eq!(reader.buffer().len(), 0);"}, {"sha": "35de4860fe24925b215e84578bbba65c6a151fe5", "filename": "library/std/src/os/fd/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -3,7 +3,7 @@\n //! This module is supported on Unix platforms and WASI, which both use a\n //! similar file descriptor system for referencing OS resources.\n \n-#![stable(feature = \"io_safety\", since = \"1.63.0\")]\n+#![stable(feature = \"os_fd\", since = \"1.66.0\")]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n // `RawFd`, `AsRawFd`, etc.\n@@ -19,7 +19,7 @@ mod net;\n mod tests;\n \n // Export the types and traits for the public API.\n-#[unstable(feature = \"os_fd\", issue = \"98699\")]\n+#[stable(feature = \"os_fd\", since = \"1.66.0\")]\n pub use owned::*;\n-#[unstable(feature = \"os_fd\", issue = \"98699\")]\n+#[stable(feature = \"os_fd\", since = \"1.66.0\")]\n pub use raw::*;"}, {"sha": "c41e093a7e5c6442f7022cd09d7f587f680af185", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -100,7 +100,7 @@ impl BorrowedFd<'_> {\n \n         // For ESP-IDF, F_DUPFD is used instead, because the CLOEXEC semantics\n         // will never be supported, as this is a bare metal framework with\n-        // no capabilities for multi-process execution.  While F_DUPFD is also\n+        // no capabilities for multi-process execution. While F_DUPFD is also\n         // not supported yet, it might be (currently it returns ENOSYS).\n         #[cfg(target_os = \"espidf\")]\n         let cmd = libc::F_DUPFD;"}, {"sha": "b0db3112e22fd34470d06fa910b73ef4d118f4a7", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -306,11 +306,11 @@ pub mod panic_count {\n     // and after increase and decrease, but not necessarily during their execution.\n     //\n     // Additionally, the top bit of GLOBAL_PANIC_COUNT (GLOBAL_ALWAYS_ABORT_FLAG)\n-    // records whether panic::always_abort() has been called.  This can only be\n+    // records whether panic::always_abort() has been called. This can only be\n     // set, never cleared.\n     // panic::always_abort() is usually called to prevent memory allocations done by\n     // the panic handling in the child created by `libc::fork`.\n-    // Memory allocations performed in  a child created with `libc::fork` are undefined\n+    // Memory allocations performed in a child created with `libc::fork` are undefined\n     // behavior in most operating systems.\n     // Accessing LOCAL_PANIC_COUNT in a child created by `libc::fork` would lead to a memory\n     // allocation. Only GLOBAL_PANIC_COUNT can be accessed in this situation. This is"}, {"sha": "c3593264e520b3243f98c01cbf80f12e9fa0b44c", "filename": "library/std/src/path.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -607,7 +607,7 @@ pub struct Components<'a> {\n \n     // true if path *physically* has a root separator; for most Windows\n     // prefixes, it may have a \"logical\" root separator for the purposes of\n-    // normalization, e.g.,  \\\\server\\share == \\\\server\\share\\.\n+    // normalization, e.g., \\\\server\\share == \\\\server\\share\\.\n     has_physical_root: bool,\n \n     // The iterator is double-ended, and these two states keep track of what has\n@@ -3177,33 +3177,33 @@ impl<'a> IntoIterator for &'a Path {\n }\n \n macro_rules! impl_cmp {\n-    ($lhs:ty, $rhs: ty) => {\n+    (<$($life:lifetime),*> $lhs:ty, $rhs: ty) => {\n         #[stable(feature = \"partialeq_path\", since = \"1.6.0\")]\n-        impl<'a, 'b> PartialEq<$rhs> for $lhs {\n+        impl<$($life),*> PartialEq<$rhs> for $lhs {\n             #[inline]\n             fn eq(&self, other: &$rhs) -> bool {\n                 <Path as PartialEq>::eq(self, other)\n             }\n         }\n \n         #[stable(feature = \"partialeq_path\", since = \"1.6.0\")]\n-        impl<'a, 'b> PartialEq<$lhs> for $rhs {\n+        impl<$($life),*> PartialEq<$lhs> for $rhs {\n             #[inline]\n             fn eq(&self, other: &$lhs) -> bool {\n                 <Path as PartialEq>::eq(self, other)\n             }\n         }\n \n         #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n-        impl<'a, 'b> PartialOrd<$rhs> for $lhs {\n+        impl<$($life),*> PartialOrd<$rhs> for $lhs {\n             #[inline]\n             fn partial_cmp(&self, other: &$rhs) -> Option<cmp::Ordering> {\n                 <Path as PartialOrd>::partial_cmp(self, other)\n             }\n         }\n \n         #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n-        impl<'a, 'b> PartialOrd<$lhs> for $rhs {\n+        impl<$($life),*> PartialOrd<$lhs> for $rhs {\n             #[inline]\n             fn partial_cmp(&self, other: &$lhs) -> Option<cmp::Ordering> {\n                 <Path as PartialOrd>::partial_cmp(self, other)\n@@ -3212,40 +3212,40 @@ macro_rules! impl_cmp {\n     };\n }\n \n-impl_cmp!(PathBuf, Path);\n-impl_cmp!(PathBuf, &'a Path);\n-impl_cmp!(Cow<'a, Path>, Path);\n-impl_cmp!(Cow<'a, Path>, &'b Path);\n-impl_cmp!(Cow<'a, Path>, PathBuf);\n+impl_cmp!(<> PathBuf, Path);\n+impl_cmp!(<'a> PathBuf, &'a Path);\n+impl_cmp!(<'a> Cow<'a, Path>, Path);\n+impl_cmp!(<'a, 'b> Cow<'a, Path>, &'b Path);\n+impl_cmp!(<'a> Cow<'a, Path>, PathBuf);\n \n macro_rules! impl_cmp_os_str {\n-    ($lhs:ty, $rhs: ty) => {\n+    (<$($life:lifetime),*> $lhs:ty, $rhs: ty) => {\n         #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n-        impl<'a, 'b> PartialEq<$rhs> for $lhs {\n+        impl<$($life),*> PartialEq<$rhs> for $lhs {\n             #[inline]\n             fn eq(&self, other: &$rhs) -> bool {\n                 <Path as PartialEq>::eq(self, other.as_ref())\n             }\n         }\n \n         #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n-        impl<'a, 'b> PartialEq<$lhs> for $rhs {\n+        impl<$($life),*> PartialEq<$lhs> for $rhs {\n             #[inline]\n             fn eq(&self, other: &$lhs) -> bool {\n                 <Path as PartialEq>::eq(self.as_ref(), other)\n             }\n         }\n \n         #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n-        impl<'a, 'b> PartialOrd<$rhs> for $lhs {\n+        impl<$($life),*> PartialOrd<$rhs> for $lhs {\n             #[inline]\n             fn partial_cmp(&self, other: &$rhs) -> Option<cmp::Ordering> {\n                 <Path as PartialOrd>::partial_cmp(self, other.as_ref())\n             }\n         }\n \n         #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n-        impl<'a, 'b> PartialOrd<$lhs> for $rhs {\n+        impl<$($life),*> PartialOrd<$lhs> for $rhs {\n             #[inline]\n             fn partial_cmp(&self, other: &$lhs) -> Option<cmp::Ordering> {\n                 <Path as PartialOrd>::partial_cmp(self.as_ref(), other)\n@@ -3254,20 +3254,20 @@ macro_rules! impl_cmp_os_str {\n     };\n }\n \n-impl_cmp_os_str!(PathBuf, OsStr);\n-impl_cmp_os_str!(PathBuf, &'a OsStr);\n-impl_cmp_os_str!(PathBuf, Cow<'a, OsStr>);\n-impl_cmp_os_str!(PathBuf, OsString);\n-impl_cmp_os_str!(Path, OsStr);\n-impl_cmp_os_str!(Path, &'a OsStr);\n-impl_cmp_os_str!(Path, Cow<'a, OsStr>);\n-impl_cmp_os_str!(Path, OsString);\n-impl_cmp_os_str!(&'a Path, OsStr);\n-impl_cmp_os_str!(&'a Path, Cow<'b, OsStr>);\n-impl_cmp_os_str!(&'a Path, OsString);\n-impl_cmp_os_str!(Cow<'a, Path>, OsStr);\n-impl_cmp_os_str!(Cow<'a, Path>, &'b OsStr);\n-impl_cmp_os_str!(Cow<'a, Path>, OsString);\n+impl_cmp_os_str!(<> PathBuf, OsStr);\n+impl_cmp_os_str!(<'a> PathBuf, &'a OsStr);\n+impl_cmp_os_str!(<'a> PathBuf, Cow<'a, OsStr>);\n+impl_cmp_os_str!(<> PathBuf, OsString);\n+impl_cmp_os_str!(<> Path, OsStr);\n+impl_cmp_os_str!(<'a> Path, &'a OsStr);\n+impl_cmp_os_str!(<'a> Path, Cow<'a, OsStr>);\n+impl_cmp_os_str!(<> Path, OsString);\n+impl_cmp_os_str!(<'a> &'a Path, OsStr);\n+impl_cmp_os_str!(<'a, 'b> &'a Path, Cow<'b, OsStr>);\n+impl_cmp_os_str!(<'a> &'a Path, OsString);\n+impl_cmp_os_str!(<'a> Cow<'a, Path>, OsStr);\n+impl_cmp_os_str!(<'a, 'b> Cow<'a, Path>, &'b OsStr);\n+impl_cmp_os_str!(<'a> Cow<'a, Path>, OsString);\n \n #[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\n impl fmt::Display for StripPrefixError {"}, {"sha": "c1e3e48b04468c8c501d45392b3c06b35fa34ac8", "filename": "library/std/src/sync/mpmc/array.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -168,7 +168,7 @@ impl<T> Channel<T> {\n                         return true;\n                     }\n                     Err(_) => {\n-                        backoff.spin();\n+                        backoff.spin_light();\n                         tail = self.tail.load(Ordering::Relaxed);\n                     }\n                 }\n@@ -182,11 +182,11 @@ impl<T> Channel<T> {\n                     return false;\n                 }\n \n-                backoff.spin();\n+                backoff.spin_light();\n                 tail = self.tail.load(Ordering::Relaxed);\n             } else {\n                 // Snooze because we need to wait for the stamp to get updated.\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 tail = self.tail.load(Ordering::Relaxed);\n             }\n         }\n@@ -251,7 +251,7 @@ impl<T> Channel<T> {\n                         return true;\n                     }\n                     Err(_) => {\n-                        backoff.spin();\n+                        backoff.spin_light();\n                         head = self.head.load(Ordering::Relaxed);\n                     }\n                 }\n@@ -273,11 +273,11 @@ impl<T> Channel<T> {\n                     }\n                 }\n \n-                backoff.spin();\n+                backoff.spin_light();\n                 head = self.head.load(Ordering::Relaxed);\n             } else {\n                 // Snooze because we need to wait for the stamp to get updated.\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 head = self.head.load(Ordering::Relaxed);\n             }\n         }\n@@ -330,7 +330,7 @@ impl<T> Channel<T> {\n                 if backoff.is_completed() {\n                     break;\n                 } else {\n-                    backoff.spin();\n+                    backoff.spin_light();\n                 }\n             }\n "}, {"sha": "ec6c0726ac790304403e374be47c6246c50f66dc", "filename": "library/std/src/sync/mpmc/list.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -46,7 +46,7 @@ impl<T> Slot<T> {\n     fn wait_write(&self) {\n         let backoff = Backoff::new();\n         while self.state.load(Ordering::Acquire) & WRITE == 0 {\n-            backoff.snooze();\n+            backoff.spin_heavy();\n         }\n     }\n }\n@@ -82,7 +82,7 @@ impl<T> Block<T> {\n             if !next.is_null() {\n                 return next;\n             }\n-            backoff.snooze();\n+            backoff.spin_heavy();\n         }\n     }\n \n@@ -191,7 +191,7 @@ impl<T> Channel<T> {\n \n             // If we reached the end of the block, wait until the next one is installed.\n             if offset == BLOCK_CAP {\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 tail = self.tail.index.load(Ordering::Acquire);\n                 block = self.tail.block.load(Ordering::Acquire);\n                 continue;\n@@ -247,7 +247,7 @@ impl<T> Channel<T> {\n                     return true;\n                 },\n                 Err(_) => {\n-                    backoff.spin();\n+                    backoff.spin_light();\n                     tail = self.tail.index.load(Ordering::Acquire);\n                     block = self.tail.block.load(Ordering::Acquire);\n                 }\n@@ -286,7 +286,7 @@ impl<T> Channel<T> {\n \n             // If we reached the end of the block, wait until the next one is installed.\n             if offset == BLOCK_CAP {\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 head = self.head.index.load(Ordering::Acquire);\n                 block = self.head.block.load(Ordering::Acquire);\n                 continue;\n@@ -320,7 +320,7 @@ impl<T> Channel<T> {\n             // The block can be null here only if the first message is being sent into the channel.\n             // In that case, just wait until it gets initialized.\n             if block.is_null() {\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 head = self.head.index.load(Ordering::Acquire);\n                 block = self.head.block.load(Ordering::Acquire);\n                 continue;\n@@ -351,7 +351,7 @@ impl<T> Channel<T> {\n                     return true;\n                 },\n                 Err(_) => {\n-                    backoff.spin();\n+                    backoff.spin_light();\n                     head = self.head.index.load(Ordering::Acquire);\n                     block = self.head.block.load(Ordering::Acquire);\n                 }\n@@ -542,7 +542,7 @@ impl<T> Channel<T> {\n             // New updates to tail will be rejected by MARK_BIT and aborted unless it's\n             // at boundary. We need to wait for the updates take affect otherwise there\n             // can be memory leaks.\n-            backoff.snooze();\n+            backoff.spin_heavy();\n             tail = self.tail.index.load(Ordering::Acquire);\n         }\n "}, {"sha": "7a602cecd3b896455a8882b66a9517b3885670ca", "filename": "library/std/src/sync/mpmc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -43,7 +43,7 @@ mod zero;\n use crate::fmt;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n use crate::time::{Duration, Instant};\n-use error::*;\n+pub use error::*;\n \n /// Creates a channel of unbounded capacity.\n ///"}, {"sha": "cfe42750d5239a6a46ab629027581df795c12129", "filename": "library/std/src/sync/mpmc/utils.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -91,9 +91,8 @@ impl<T> DerefMut for CachePadded<T> {\n }\n \n const SPIN_LIMIT: u32 = 6;\n-const YIELD_LIMIT: u32 = 10;\n \n-/// Performs exponential backoff in spin loops.\n+/// Performs quadratic backoff in spin loops.\n pub struct Backoff {\n     step: Cell<u32>,\n }\n@@ -104,25 +103,27 @@ impl Backoff {\n         Backoff { step: Cell::new(0) }\n     }\n \n-    /// Backs off in a lock-free loop.\n+    /// Backs off using lightweight spinning.\n     ///\n-    /// This method should be used when we need to retry an operation because another thread made\n-    /// progress.\n+    /// This method should be used for:\n+    ///     - Retrying an operation because another thread made progress. i.e. on CAS failure.\n+    ///     - Waiting for an operation to complete by spinning optimistically for a few iterations\n+    ///     before falling back to parking the thread (see `Backoff::is_completed`).\n     #[inline]\n-    pub fn spin(&self) {\n+    pub fn spin_light(&self) {\n         let step = self.step.get().min(SPIN_LIMIT);\n         for _ in 0..step.pow(2) {\n             crate::hint::spin_loop();\n         }\n \n-        if self.step.get() <= SPIN_LIMIT {\n-            self.step.set(self.step.get() + 1);\n-        }\n+        self.step.set(self.step.get() + 1);\n     }\n \n-    /// Backs off in a blocking loop.\n+    /// Backs off using heavyweight spinning.\n+    ///\n+    /// This method should be used in blocking loops where parking the thread is not an option.\n     #[inline]\n-    pub fn snooze(&self) {\n+    pub fn spin_heavy(&self) {\n         if self.step.get() <= SPIN_LIMIT {\n             for _ in 0..self.step.get().pow(2) {\n                 crate::hint::spin_loop()\n@@ -131,14 +132,12 @@ impl Backoff {\n             crate::thread::yield_now();\n         }\n \n-        if self.step.get() <= YIELD_LIMIT {\n-            self.step.set(self.step.get() + 1);\n-        }\n+        self.step.set(self.step.get() + 1);\n     }\n \n-    /// Returns `true` if quadratic backoff has completed and blocking the thread is advised.\n+    /// Returns `true` if quadratic backoff has completed and parking the thread is advised.\n     #[inline]\n     pub fn is_completed(&self) -> bool {\n-        self.step.get() > YIELD_LIMIT\n+        self.step.get() > SPIN_LIMIT\n     }\n }"}, {"sha": "33f768dcbe90296d9a98cbc191ad65adc4ce01aa", "filename": "library/std/src/sync/mpmc/zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -57,7 +57,7 @@ impl<T> Packet<T> {\n     fn wait_ready(&self) {\n         let backoff = Backoff::new();\n         while !self.ready.load(Ordering::Acquire) {\n-            backoff.snooze();\n+            backoff.spin_heavy();\n         }\n     }\n }"}, {"sha": "6e3c28f10bb1ba9e31298fa90d34b54029ae32bd", "filename": "library/std/src/sync/mpsc/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -738,6 +738,15 @@ impl<T> SyncSender<T> {\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         self.inner.try_send(t)\n     }\n+\n+    // Attempts to send for a value on this receiver, returning an error if the\n+    // corresponding channel has hung up, or if it waits more than `timeout`.\n+    //\n+    // This method is currently private and only used for tests.\n+    #[allow(unused)]\n+    fn send_timeout(&self, t: T, timeout: Duration) -> Result<(), mpmc::SendTimeoutError<T>> {\n+        self.inner.send_timeout(t, timeout)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "9d2f92ffc9b1415ec6e93a93189f10f64ed35042", "filename": "library/std/src/sync/mpsc/sync_tests.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n use crate::env;\n+use crate::sync::mpmc::SendTimeoutError;\n use crate::thread;\n use crate::time::Duration;\n \n@@ -41,6 +42,13 @@ fn recv_timeout() {\n     assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Ok(1));\n }\n \n+#[test]\n+fn send_timeout() {\n+    let (tx, _rx) = sync_channel::<i32>(1);\n+    assert_eq!(tx.send_timeout(1, Duration::from_millis(1)), Ok(()));\n+    assert_eq!(tx.send_timeout(1, Duration::from_millis(1)), Err(SendTimeoutError::Timeout(1)));\n+}\n+\n #[test]\n fn smoke_threads() {\n     let (tx, rx) = sync_channel::<i32>(0);"}, {"sha": "19350b83fab884d8cf3ebd0efdabb7b9de30d4a3", "filename": "library/std/src/sys/itron/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -294,7 +294,7 @@ impl Drop for Thread {\n                 // Terminate and delete the task\n                 // Safety: `self.task` still represents a task we own (because\n                 //         this method or `join_inner` is called only once for\n-                //         each `Thread`). The task  indicated that it's safe to\n+                //         each `Thread`). The task indicated that it's safe to\n                 //         delete by entering the `FINISHED` state.\n                 unsafe { terminate_and_delete_task(self.task) };\n "}, {"sha": "8e1f35d6cc92011cac5704c196d5384390e3de3c", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -149,12 +149,13 @@ cfg_has_statx! {{\n     ) -> Option<io::Result<FileAttr>> {\n         use crate::sync::atomic::{AtomicU8, Ordering};\n \n-        // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`\n-        // We store the availability in global to avoid unnecessary syscalls.\n-        // 0: Unknown\n-        // 1: Not available\n-        // 2: Available\n-        static STATX_STATE: AtomicU8 = AtomicU8::new(0);\n+        // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`.\n+        // We check for it on first failure and remember availability to avoid having to\n+        // do it again.\n+        #[repr(u8)]\n+        enum STATX_STATE{ Unknown = 0, Present, Unavailable }\n+        static STATX_SAVED_STATE: AtomicU8 = AtomicU8::new(STATX_STATE::Unknown as u8);\n+\n         syscall! {\n             fn statx(\n                 fd: c_int,\n@@ -165,31 +166,44 @@ cfg_has_statx! {{\n             ) -> c_int\n         }\n \n-        match STATX_STATE.load(Ordering::Relaxed) {\n-            0 => {\n-                // It is a trick to call `statx` with null pointers to check if the syscall\n-                // is available. According to the manual, it is expected to fail with EFAULT.\n-                // We do this mainly for performance, since it is nearly hundreds times\n-                // faster than a normal successful call.\n-                let err = cvt(statx(0, ptr::null(), 0, libc::STATX_ALL, ptr::null_mut()))\n-                    .err()\n-                    .and_then(|e| e.raw_os_error());\n-                // We don't check `err == Some(libc::ENOSYS)` because the syscall may be limited\n-                // and returns `EPERM`. Listing all possible errors seems not a good idea.\n-                // See: https://github.com/rust-lang/rust/issues/65662\n-                if err != Some(libc::EFAULT) {\n-                    STATX_STATE.store(1, Ordering::Relaxed);\n-                    return None;\n-                }\n-                STATX_STATE.store(2, Ordering::Relaxed);\n-            }\n-            1 => return None,\n-            _ => {}\n+        if STATX_SAVED_STATE.load(Ordering::Relaxed) == STATX_STATE::Unavailable as u8 {\n+            return None;\n         }\n \n         let mut buf: libc::statx = mem::zeroed();\n         if let Err(err) = cvt(statx(fd, path, flags, mask, &mut buf)) {\n-            return Some(Err(err));\n+            if STATX_SAVED_STATE.load(Ordering::Relaxed) == STATX_STATE::Present as u8 {\n+                return Some(Err(err));\n+            }\n+\n+            // Availability not checked yet.\n+            //\n+            // First try the cheap way.\n+            if err.raw_os_error() == Some(libc::ENOSYS) {\n+                STATX_SAVED_STATE.store(STATX_STATE::Unavailable as u8, Ordering::Relaxed);\n+                return None;\n+            }\n+\n+            // Error other than `ENOSYS` is not a good enough indicator -- it is\n+            // known that `EPERM` can be returned as a result of using seccomp to\n+            // block the syscall.\n+            // Availability is checked by performing a call which expects `EFAULT`\n+            // if the syscall is usable.\n+            // See: https://github.com/rust-lang/rust/issues/65662\n+            // FIXME this can probably just do the call if `EPERM` was received, but\n+            // previous iteration of the code checked it for all errors and for now\n+            // this is retained.\n+            // FIXME what about transient conditions like `ENOMEM`?\n+            let err2 = cvt(statx(0, ptr::null(), 0, libc::STATX_ALL, ptr::null_mut()))\n+                .err()\n+                .and_then(|e| e.raw_os_error());\n+            if err2 == Some(libc::EFAULT) {\n+                STATX_SAVED_STATE.store(STATX_STATE::Present as u8, Ordering::Relaxed);\n+                return Some(Err(err));\n+            } else {\n+                STATX_SAVED_STATE.store(STATX_STATE::Unavailable as u8, Ordering::Relaxed);\n+                return None;\n+            }\n         }\n \n         // We cannot fill `stat64` exhaustively because of private padding fields.\n@@ -600,13 +614,13 @@ impl Iterator for ReadDir {\n             loop {\n                 // As of POSIX.1-2017, readdir() is not required to be thread safe; only\n                 // readdir_r() is. However, readdir_r() cannot correctly handle platforms\n-                // with unlimited or variable NAME_MAX.  Many modern platforms guarantee\n+                // with unlimited or variable NAME_MAX. Many modern platforms guarantee\n                 // thread safety for readdir() as long an individual DIR* is not accessed\n                 // concurrently, which is sufficient for Rust.\n                 super::os::set_errno(0);\n                 let entry_ptr = readdir64(self.inner.dirp.0);\n                 if entry_ptr.is_null() {\n-                    // We either encountered an error, or reached the end.  Either way,\n+                    // We either encountered an error, or reached the end. Either way,\n                     // the next call to next() should return None.\n                     self.end_of_stream = true;\n "}, {"sha": "73b9bef7e2ac9b68b3b8480d27a2e288a7c4cd24", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -587,7 +587,7 @@ pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) ->\n                         // - copy_file_range file is immutable or syscall is blocked by seccomp\u00b9 (EPERM)\n                         // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n                         // - the writer fd was opened with O_APPEND (EBADF\u00b2)\n-                        // and no bytes were written successfully yet.  (All these errnos should\n+                        // and no bytes were written successfully yet. (All these errnos should\n                         // not be returned if something was already written, but they happen in\n                         // the wild, see #91152.)\n                         //"}, {"sha": "d4c7e58b34d2ef85c2d5864962928745d6eebd14", "filename": "library/std/src/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -262,7 +262,7 @@ impl ExitStatus {\n     // available on Fuchsia.\n     //\n     // It does not appear that Fuchsia is Unix-like enough to implement ExitStatus (or indeed many\n-    // other things from std::os::unix) properly.  This veneer is always going to be a bodge.  So\n+    // other things from std::os::unix) properly. This veneer is always going to be a bodge. So\n     // while I don't know if these implementations are actually correct, I think they will do for\n     // now at least.\n     pub fn core_dumped(&self) -> bool {\n@@ -277,24 +277,24 @@ impl ExitStatus {\n \n     pub fn into_raw(&self) -> c_int {\n         // We don't know what someone who calls into_raw() will do with this value, but it should\n-        // have the conventional Unix representation.  Despite the fact that this is not\n+        // have the conventional Unix representation. Despite the fact that this is not\n         // standardised in SuS or POSIX, all Unix systems encode the signal and exit status the\n-        // same way.  (Ie the WIFEXITED, WEXITSTATUS etc. macros have identical behaviour on every\n+        // same way. (Ie the WIFEXITED, WEXITSTATUS etc. macros have identical behaviour on every\n         // Unix.)\n         //\n         // The caller of `std::os::unix::into_raw` is probably wanting a Unix exit status, and may\n         // do their own shifting and masking, or even pass the status to another computer running a\n         // different Unix variant.\n         //\n         // The other view would be to say that the caller on Fuchsia ought to know that `into_raw`\n-        // will give a raw Fuchsia status (whatever that is - I don't know, personally).  That is\n+        // will give a raw Fuchsia status (whatever that is - I don't know, personally). That is\n         // not possible here because we must return a c_int because that's what Unix (including\n         // SuS and POSIX) say a wait status is, but Fuchsia apparently uses a u64, so it won't\n         // necessarily fit.\n         //\n         // It seems to me that the right answer would be to provide std::os::fuchsia with its\n         // own ExitStatusExt, rather that trying to provide a not very convincing imitation of\n-        // Unix.  Ie, std::os::unix::process:ExitStatusExt ought not to exist on Fuchsia.  But\n+        // Unix. Ie, std::os::unix::process:ExitStatusExt ought not to exist on Fuchsia. But\n         // fixing this up that is beyond the scope of my efforts now.\n         let exit_status_as_if_unix: u8 = self.0.try_into().expect(\"Fuchsia process return code bigger than 8 bits, but std::os::unix::ExitStatusExt::into_raw() was called to try to convert the value into a traditional Unix-style wait status, which cannot represent values greater than 255.\");\n         let wait_status_as_if_unix = (exit_status_as_if_unix as c_int) << 8;"}, {"sha": "c2c4aa1c9dfceff80d98f79999e772fd324c28de", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -666,11 +666,11 @@ impl ExitStatus {\n     }\n \n     pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n-        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0.  This is\n+        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0. This is\n         // true on all actual versions of Unix, is widely assumed, and is specified in SuS\n-        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html .  If it is not\n+        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html. If it is not\n         // true for a platform pretending to be Unix, the tests (our doctests, and also\n-        // procsss_unix/tests.rs) will spot it.  `ExitStatusError::code` assumes this too.\n+        // procsss_unix/tests.rs) will spot it. `ExitStatusError::code` assumes this too.\n         match NonZero_c_int::try_from(self.0) {\n             /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n             /* was zero, couldn't convert */ Err(_) => Ok(()),"}, {"sha": "e5e1f956bc351e43c16878ea2d37b6b65d876025", "filename": "library/std/src/sys/unix/process/process_unix/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -19,17 +19,17 @@ fn exitstatus_display_tests() {\n     t(0x00000, \"exit status: 0\");\n     t(0x0ff00, \"exit status: 255\");\n \n-    // On MacOS, 0x0137f is WIFCONTINUED, not WIFSTOPPED.  Probably *BSD is similar.\n+    // On MacOS, 0x0137f is WIFCONTINUED, not WIFSTOPPED. Probably *BSD is similar.\n     //   https://github.com/rust-lang/rust/pull/82749#issuecomment-790525956\n     // The purpose of this test is to test our string formatting, not our understanding of the wait\n-    // status magic numbers.  So restrict these to Linux.\n+    // status magic numbers. So restrict these to Linux.\n     if cfg!(target_os = \"linux\") {\n         t(0x0137f, \"stopped (not terminated) by signal: 19 (SIGSTOP)\");\n         t(0x0ffff, \"continued (WIFCONTINUED)\");\n     }\n \n     // Testing \"unrecognised wait status\" is hard because the wait.h macros typically\n-    // assume that the value came from wait and isn't mad.  With the glibc I have here\n+    // assume that the value came from wait and isn't mad. With the glibc I have here\n     // this works:\n     if cfg!(all(target_os = \"linux\", target_env = \"gnu\")) {\n         t(0x000ff, \"unrecognised wait status: 255 0xff\");"}, {"sha": "569a4b149125d618bd8847691b7b4434d8ab0cb7", "filename": "library/std/src/sys/unix/process/process_vxworks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -195,11 +195,11 @@ impl ExitStatus {\n     }\n \n     pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n-        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0.  This is\n+        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0. This is\n         // true on all actual versions of Unix, is widely assumed, and is specified in SuS\n-        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html .  If it is not\n+        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html. If it is not\n         // true for a platform pretending to be Unix, the tests (our doctests, and also\n-        // procsss_unix/tests.rs) will spot it.  `ExitStatusError::code` assumes this too.\n+        // procsss_unix/tests.rs) will spot it. `ExitStatusError::code` assumes this too.\n         match NonZero_c_int::try_from(self.0) {\n             Ok(failure) => Err(ExitStatusError(failure)),\n             Err(_) => Ok(()),"}, {"sha": "2a1830d060edc5cb934998bd1cac294e3512d281", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -73,7 +73,7 @@ impl Thread {\n                 n => {\n                     assert_eq!(n, libc::EINVAL);\n                     // EINVAL means |stack_size| is either too small or not a\n-                    // multiple of the system page size.  Because it's definitely\n+                    // multiple of the system page size. Because it's definitely\n                     // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n                     // Round up to the nearest page and try again.\n                     let page_size = os::page_size();\n@@ -755,10 +755,10 @@ pub mod guard {\n         if cfg!(all(target_os = \"linux\", not(target_env = \"musl\"))) {\n             // Linux doesn't allocate the whole stack right away, and\n             // the kernel has its own stack-guard mechanism to fault\n-            // when growing too close to an existing mapping.  If we map\n+            // when growing too close to an existing mapping. If we map\n             // our own guard, then the kernel starts enforcing a rather\n             // large gap above that, rendering much of the possible\n-            // stack space useless.  See #43052.\n+            // stack space useless. See #43052.\n             //\n             // Instead, we'll just note where we expect rlimit to start\n             // faulting, so our handler can report \"stack overflow\", and\n@@ -774,14 +774,14 @@ pub mod guard {\n             None\n         } else if cfg!(target_os = \"freebsd\") {\n             // FreeBSD's stack autogrows, and optionally includes a guard page\n-            // at the bottom.  If we try to remap the bottom of the stack\n-            // ourselves, FreeBSD's guard page moves upwards.  So we'll just use\n+            // at the bottom. If we try to remap the bottom of the stack\n+            // ourselves, FreeBSD's guard page moves upwards. So we'll just use\n             // the builtin guard page.\n             let stackptr = get_stack_start_aligned()?;\n             let guardaddr = stackptr.addr();\n             // Technically the number of guard pages is tunable and controlled\n             // by the security.bsd.stack_guard_page sysctl, but there are\n-            // few reasons to change it from the default.  The default value has\n+            // few reasons to change it from the default. The default value has\n             // been 1 ever since FreeBSD 11.1 and 10.4.\n             const GUARD_PAGES: usize = 1;\n             let guard = guardaddr..guardaddr + GUARD_PAGES * page_size;\n@@ -877,9 +877,9 @@ pub mod guard {\n             } else if cfg!(all(target_os = \"linux\", any(target_env = \"gnu\", target_env = \"uclibc\")))\n             {\n                 // glibc used to include the guard area within the stack, as noted in the BUGS\n-                // section of `man pthread_attr_getguardsize`.  This has been corrected starting\n+                // section of `man pthread_attr_getguardsize`. This has been corrected starting\n                 // with glibc 2.27, and in some distro backports, so the guard is now placed at the\n-                // end (below) the stack.  There's no easy way for us to know which we have at\n+                // end (below) the stack. There's no easy way for us to know which we have at\n                 // runtime, so we'll just match any fault in the range right above or below the\n                 // stack base to call that fault a stack overflow.\n                 Some(stackaddr - guardsize..stackaddr + guardsize)"}, {"sha": "d7adeb266ed93f30918a8fab50137fec6852be98", "filename": "library/std/src/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -157,7 +157,7 @@ impl<'a> Iterator for SplitPaths<'a> {\n         // Double quotes are used as a way of introducing literal semicolons\n         // (since c:\\some;dir is a valid Windows path). Double quotes are not\n         // themselves permitted in path names, so there is no way to escape a\n-        // double quote.  Quoted regions can appear in arbitrary locations, so\n+        // double quote. Quoted regions can appear in arbitrary locations, so\n         //\n         //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n         //"}, {"sha": "1cb576c95947a5aeddde2a708fd0665ec9c49a56", "filename": "library/std/src/sys/windows/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -26,7 +26,7 @@ impl Thread {\n \n         // FIXME On UNIX, we guard against stack sizes that are too small but\n         // that's because pthreads enforces that stacks are at least\n-        // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n+        // PTHREAD_STACK_MIN bytes big. Windows has no such lower limit, it's\n         // just that below a certain threshold you can't do anything useful.\n         // That threshold is application and architecture-specific, however.\n         let ret = c::CreateThread("}, {"sha": "69fb529d7f563b56e310bb85cf6b7a1f8282b6f6", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -116,7 +116,7 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Option<Opt\n     } else {\n         if !opts.nocapture {\n             // If we encounter a non-unwinding panic, flush any captured output from the current test,\n-            // and stop  capturing output to ensure that the non-unwinding panic message is visible.\n+            // and stop capturing output to ensure that the non-unwinding panic message is visible.\n             // We also acquire the locks for both output streams to prevent output from other threads\n             // from interleaving with the panic message or appearing after it.\n             let builtin_panic_hook = panic::take_hook();"}, {"sha": "3e8ccc91ab0517fd8ef676174a3e1d56c5ef9d59", "filename": "library/test/src/term/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n         }\n     } else {\n         // Found nothing in TERMINFO_DIRS, use the default paths:\n-        // According to  /etc/terminfo/README, after looking at\n+        // According to /etc/terminfo/README, after looking at\n         // ~/.terminfo, ncurses will search /etc/terminfo, then\n         // /lib/terminfo, and eventually /usr/share/terminfo.\n         // On Haiku the database can be found at /boot/system/data/terminfo"}, {"sha": "7b357da2ffc475c9497b3f13e67fa6fa53449a83", "filename": "src/README.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,8 +1,7 @@\n-This directory contains the source code of the rust project, including:\n+This directory contains some source code for the Rust project, including:\n \n-- The test suite\n - The bootstrapping build system\n-- Various submodules for tools, like cargo, etc.\n+- Various submodules for tools, like cargo, tidy, etc.\n \n For more information on how various parts of the compiler work, see the [rustc dev guide].\n "}, {"sha": "9611c866df5990c038640b5af106f7e0b79838e7", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -154,6 +154,41 @@ fn main() {\n         cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n     }\n \n+    // allow-features is handled from within this rustc wrapper because of\n+    // issues with build scripts. Some packages use build scripts to\n+    // dynamically detect if certain nightly features are available.\n+    // There are different ways this causes problems:\n+    //\n+    // * rustix runs `rustc` on a small test program to see if the feature is\n+    //   available (and sets a `cfg` if it is). It does not honor\n+    //   CARGO_ENCODED_RUSTFLAGS.\n+    // * proc-macro2 detects if `rustc -vV` says \"nighty\" or \"dev\" and enables\n+    //   nightly features. It will scan CARGO_ENCODED_RUSTFLAGS for\n+    //   -Zallow-features. Unfortunately CARGO_ENCODED_RUSTFLAGS is not set\n+    //   for build-dependencies when --target is used.\n+    //\n+    // The issues above means we can't just use RUSTFLAGS, and we can't use\n+    // `cargo -Zallow-features=\u2026`. Passing it through here ensures that it\n+    // always gets set. Unfortunately that also means we need to enable more\n+    // features than we really want (like those for proc-macro2), but there\n+    // isn't much of a way around it.\n+    //\n+    // I think it is unfortunate that build scripts are doing this at all,\n+    // since changes to nightly features can cause crates to break even if the\n+    // user didn't want or care about the use of the nightly features. I think\n+    // nightly features should be opt-in only. Unfortunately the dynamic\n+    // checks are now too wide spread that we just need to deal with it.\n+    //\n+    // If you want to try to remove this, I suggest working with the crate\n+    // authors to remove the dynamic checking. Another option is to pursue\n+    // https://github.com/rust-lang/cargo/issues/11244 and\n+    // https://github.com/rust-lang/cargo/issues/4423, which will likely be\n+    // very difficult, but could help expose -Zallow-features into build\n+    // scripts so they could try to honor them.\n+    if let Ok(allow_features) = env::var(\"RUSTC_ALLOW_FEATURES\") {\n+        cmd.arg(format!(\"-Zallow-features={allow_features}\"));\n+    }\n+\n     if let Ok(flags) = env::var(\"MAGIC_EXTRA_RUSTFLAGS\") {\n         for flag in flags.split(' ') {\n             cmd.arg(flag);"}, {"sha": "b4fc1d4f28da75e7a9513d723cad17118763e3dc", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1381,18 +1381,29 @@ impl<'a> Builder<'a> {\n         // this), as well as #63012 which is the tracking issue for this\n         // feature on the rustc side.\n         cargo.arg(\"-Zbinary-dep-depinfo\");\n-        match mode {\n-            Mode::ToolBootstrap => {\n-                // Restrict the allowed features to those passed by rustbuild, so we don't depend on nightly accidentally.\n-                rustflags.arg(\"-Zallow-features=binary-dep-depinfo\");\n-            }\n-            Mode::ToolStd => {\n-                // Right now this is just compiletest and a few other tools that build on stable.\n-                // Allow them to use `feature(test)`, but nothing else.\n-                rustflags.arg(\"-Zallow-features=binary-dep-depinfo,test,proc_macro_internals,proc_macro_diagnostic,proc_macro_span\");\n+        let allow_features = match mode {\n+            Mode::ToolBootstrap | Mode::ToolStd => {\n+                // Restrict the allowed features so we don't depend on nightly\n+                // accidentally.\n+                //\n+                // binary-dep-depinfo is used by rustbuild itself for all\n+                // compilations.\n+                //\n+                // Lots of tools depend on proc_macro2 and proc-macro-error.\n+                // Those have build scripts which assume nightly features are\n+                // available if the `rustc` version is \"nighty\" or \"dev\". See\n+                // bin/rustc.rs for why that is a problem. Instead of labeling\n+                // those features for each individual tool that needs them,\n+                // just blanket allow them here.\n+                //\n+                // If this is ever removed, be sure to add something else in\n+                // its place to keep the restrictions in place (or make a way\n+                // to unset RUSTC_BOOTSTRAP).\n+                \"binary-dep-depinfo,proc_macro_span,proc_macro_span_shrink,proc_macro_diagnostic\"\n+                    .to_string()\n             }\n-            Mode::Std | Mode::Rustc | Mode::Codegen | Mode::ToolRustc => {}\n-        }\n+            Mode::Std | Mode::Rustc | Mode::Codegen | Mode::ToolRustc => String::new(),\n+        };\n \n         cargo.arg(\"-j\").arg(self.jobs().to_string());\n \n@@ -1915,7 +1926,7 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        Cargo { command: cargo, rustflags, rustdocflags }\n+        Cargo { command: cargo, rustflags, rustdocflags, allow_features }\n     }\n \n     /// Ensure that a given step is built, returning its output. This will\n@@ -2094,6 +2105,7 @@ pub struct Cargo {\n     command: Command,\n     rustflags: Rustflags,\n     rustdocflags: Rustflags,\n+    allow_features: String,\n }\n \n impl Cargo {\n@@ -2138,6 +2150,18 @@ impl Cargo {\n         self.command.current_dir(dir);\n         self\n     }\n+\n+    /// Adds nightly-only features that this invocation is allowed to use.\n+    ///\n+    /// By default, all nightly features are allowed. Once this is called, it\n+    /// will be restricted to the given set.\n+    pub fn allow_features(&mut self, features: &str) -> &mut Cargo {\n+        if !self.allow_features.is_empty() {\n+            self.allow_features.push(',');\n+        }\n+        self.allow_features.push_str(features);\n+        self\n+    }\n }\n \n impl From<Cargo> for Command {\n@@ -2152,6 +2176,10 @@ impl From<Cargo> for Command {\n             cargo.command.env(\"RUSTDOCFLAGS\", rustdocflags);\n         }\n \n+        if !cargo.allow_features.is_empty() {\n+            cargo.command.env(\"RUSTC_ALLOW_FEATURES\", cargo.allow_features);\n+        }\n+\n         cargo.command\n     }\n }"}, {"sha": "4b8a58e87b64eb893a87c090b233b8866ab4ae60", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -346,9 +346,7 @@ impl Step for RustAnalyzer {\n             &[\"rust-analyzer/in-rust-tree\".to_owned()],\n         );\n \n-        cargo.rustflag(\n-            \"-Zallow-features=proc_macro_internals,proc_macro_diagnostic,proc_macro_span\",\n-        );\n+        cargo.allow_features(crate::tool::RustAnalyzer::ALLOW_FEATURES);\n \n         // For ./x.py clippy, don't check those targets because\n         // linting tests and benchmarks can produce very noisy results"}, {"sha": "6078e39ac9d3b8af5a7214921d91edff4c238385", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -378,6 +378,7 @@ impl Step for RustAnalyzer {\n             SourceType::InTree,\n             &[\"sysroot-abi\".to_owned()],\n         );\n+        cargo.allow_features(tool::RustAnalyzer::ALLOW_FEATURES);\n \n         let dir = builder.src.join(workspace_path);\n         // needed by rust-analyzer to find its own text fixtures, cf.\n@@ -690,7 +691,7 @@ impl Step for CompiletestTest {\n         // We need `ToolStd` for the locally-built sysroot because\n         // compiletest uses unstable features of the `test` crate.\n         builder.ensure(compile::Std::new(compiler, host));\n-        let cargo = tool::prepare_tool_cargo(\n+        let mut cargo = tool::prepare_tool_cargo(\n             builder,\n             compiler,\n             Mode::ToolStd,\n@@ -700,6 +701,7 @@ impl Step for CompiletestTest {\n             SourceType::InTree,\n             &[],\n         );\n+        cargo.allow_features(\"test\");\n \n         try_run(builder, &mut cargo.into());\n     }"}, {"sha": "9a2100c2fb785e6b6b264ecdf6cf76778bcaf562", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -29,6 +29,8 @@ struct ToolBuild {\n     is_optional_tool: bool,\n     source_type: SourceType,\n     extra_features: Vec<String>,\n+    /// Nightly-only features that are allowed (comma-separated list).\n+    allow_features: &'static str,\n }\n \n impl Step for ToolBuild {\n@@ -59,7 +61,7 @@ impl Step for ToolBuild {\n             _ => panic!(\"unexpected Mode for tool build\"),\n         }\n \n-        let cargo = prepare_tool_cargo(\n+        let mut cargo = prepare_tool_cargo(\n             builder,\n             compiler,\n             self.mode,\n@@ -69,6 +71,9 @@ impl Step for ToolBuild {\n             self.source_type,\n             &self.extra_features,\n         );\n+        if !self.allow_features.is_empty() {\n+            cargo.allow_features(self.allow_features);\n+        }\n \n         builder.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n         let mut duplicates = Vec::new();\n@@ -292,6 +297,7 @@ macro_rules! bootstrap_tool {\n         $name:ident, $path:expr, $tool_name:expr\n         $(,is_external_tool = $external:expr)*\n         $(,is_unstable_tool = $unstable:expr)*\n+        $(,allow_features = $allow_features:expr)?\n         ;\n     )+) => {\n         #[derive(Copy, PartialEq, Eq, Clone)]\n@@ -355,6 +361,7 @@ macro_rules! bootstrap_tool {\n                         SourceType::InTree\n                     },\n                     extra_features: vec![],\n+                    allow_features: concat!($($allow_features)*),\n                 }).expect(\"expected to build -- essential tool\")\n             }\n         }\n@@ -368,7 +375,7 @@ bootstrap_tool!(\n     Tidy, \"src/tools/tidy\", \"tidy\";\n     Linkchecker, \"src/tools/linkchecker\", \"linkchecker\";\n     CargoTest, \"src/tools/cargotest\", \"cargotest\";\n-    Compiletest, \"src/tools/compiletest\", \"compiletest\", is_unstable_tool = true;\n+    Compiletest, \"src/tools/compiletest\", \"compiletest\", is_unstable_tool = true, allow_features = \"test\";\n     BuildManifest, \"src/tools/build-manifest\", \"build-manifest\";\n     RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\";\n     RustInstaller, \"src/tools/rust-installer\", \"rust-installer\", is_external_tool = true;\n@@ -435,6 +442,7 @@ impl Step for ErrorIndex {\n                 is_optional_tool: false,\n                 source_type: SourceType::InTree,\n                 extra_features: Vec::new(),\n+                allow_features: \"\",\n             })\n             .expect(\"expected to build -- essential tool\")\n     }\n@@ -471,6 +479,7 @@ impl Step for RemoteTestServer {\n                 is_optional_tool: false,\n                 source_type: SourceType::InTree,\n                 extra_features: Vec::new(),\n+                allow_features: \"\",\n             })\n             .expect(\"expected to build -- essential tool\")\n     }\n@@ -622,6 +631,7 @@ impl Step for Cargo {\n                 is_optional_tool: false,\n                 source_type: SourceType::Submodule,\n                 extra_features: Vec::new(),\n+                allow_features: \"\",\n             })\n             .expect(\"expected to build -- essential tool\");\n \n@@ -637,6 +647,7 @@ impl Step for Cargo {\n                 is_optional_tool: true,\n                 source_type: SourceType::Submodule,\n                 extra_features: Vec::new(),\n+                allow_features: \"\",\n             });\n         };\n \n@@ -684,6 +695,7 @@ impl Step for LldWrapper {\n                 is_optional_tool: false,\n                 source_type: SourceType::InTree,\n                 extra_features: Vec::new(),\n+                allow_features: \"\",\n             })\n             .expect(\"expected to build -- essential tool\");\n \n@@ -697,6 +709,11 @@ pub struct RustAnalyzer {\n     pub target: TargetSelection,\n }\n \n+impl RustAnalyzer {\n+    pub const ALLOW_FEATURES: &str =\n+        \"proc_macro_internals,proc_macro_diagnostic,proc_macro_span,proc_macro_span_shrink\";\n+}\n+\n impl Step for RustAnalyzer {\n     type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n@@ -731,6 +748,7 @@ impl Step for RustAnalyzer {\n             extra_features: vec![\"rust-analyzer/in-rust-tree\".to_owned()],\n             is_optional_tool: false,\n             source_type: SourceType::InTree,\n+            allow_features: RustAnalyzer::ALLOW_FEATURES,\n         })\n     }\n }\n@@ -769,6 +787,7 @@ impl Step for RustAnalyzerProcMacroSrv {\n             extra_features: vec![\"proc-macro-srv/sysroot-abi\".to_owned()],\n             is_optional_tool: false,\n             source_type: SourceType::InTree,\n+            allow_features: RustAnalyzer::ALLOW_FEATURES,\n         })?;\n \n         // Copy `rust-analyzer-proc-macro-srv` to `<sysroot>/libexec/`\n@@ -788,6 +807,7 @@ macro_rules! tool_extended {\n        $tool_name:expr,\n        stable = $stable:expr\n        $(,tool_std = $tool_std:literal)?\n+       $(,allow_features = $allow_features:expr)?\n        ;)+) => {\n         $(\n             #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n@@ -839,6 +859,7 @@ macro_rules! tool_extended {\n                     extra_features: $sel.extra_features,\n                     is_optional_tool: true,\n                     source_type: SourceType::InTree,\n+                    allow_features: concat!($($allow_features)*),\n                 })\n             }\n         }"}, {"sha": "5fbce36c39d2844ba3b6be365f97822913f1e2a0", "filename": "src/ci/docker/host-x86_64/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -10,7 +10,7 @@ bin=\"$PWD/clang+llvm-15.0.6-x86_64-linux-gnu-ubuntu-18.04/bin\"\n git clone https://github.com/WebAssembly/wasi-libc\n \n cd wasi-libc\n-git reset --hard 8b7148f69ae241a2749b3defe4606da8143b72e0\n+git reset --hard 4362b1885fd369e042a7c0ecd8df3b6cd47fb4e8\n make -j$(nproc) \\\n     CC=\"$bin/clang\" \\\n     NM=\"$bin/llvm-nm\" \\"}, {"sha": "d5bc76eeb23daee6779672485caf84fcf53ac877", "filename": "src/ci/docker/host-x86_64/mingw-check/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -45,6 +45,7 @@ ENV SCRIPT python3 ../x.py --stage 2 test src/tools/expand-yaml-anchors && \\\n            python3 ../x.py test --stage 0 src/tools/compiletest && \\\n            python3 ../x.py test --stage 0 core alloc std test proc_macro && \\\n            # Build both public and internal documentation.\n+           RUSTDOCFLAGS=\\\"--document-private-items --document-hidden-items\\\" python3 ../x.py doc --stage 0 compiler && \\\n            RUSTDOCFLAGS=\\\"--document-private-items --document-hidden-items\\\" python3 ../x.py doc --stage 0 library/test && \\\n            /scripts/validate-toolstate.sh && \\\n            /scripts/validate-error-codes.sh && \\"}, {"sha": "45db3bb9b007b99e1f8f71e21e120fe0863bf482", "filename": "src/doc/rustdoc/src/lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -261,7 +261,7 @@ typo mistakes for some common attributes.\n \n ## `invalid_html_tags`\n \n-This lint is **allowed by default** and is **nightly-only**. It detects unclosed\n+This lint **warns by default**. It detects unclosed\n or invalid HTML tags. For example:\n \n ```rust"}, {"sha": "e6b2b2349452acff5b992bfbd0d095d7c6c7c509", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     trait_def_id,\n                     impl_def_id\n                 );\n-                let trait_ref = cx.tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n+                let trait_ref = cx.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 if !matches!(trait_ref.0.self_ty().kind(), ty::Param(_)) {\n                     continue;\n                 }"}, {"sha": "c6939326144ea87aae3bd7c1c08df53081a755b8", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -376,7 +376,7 @@ pub(crate) fn build_impl(\n     let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_impl\");\n \n     let tcx = cx.tcx;\n-    let associated_trait = tcx.impl_trait_ref(did);\n+    let associated_trait = tcx.impl_trait_ref(did).map(ty::EarlyBinder::skip_binder);\n \n     // Only inline impl if the implemented trait is\n     // reachable in rustdoc generated documentation"}, {"sha": "415e7d5a360d067eeaee6abe84fef949c8b55d42", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -506,7 +506,9 @@ fn clean_generic_param_def<'tcx>(\n                     Some(def.def_id),\n                 )),\n                 default: match has_default {\n-                    true => Some(Box::new(cx.tcx.const_param_default(def.def_id).to_string())),\n+                    true => Some(Box::new(\n+                        cx.tcx.const_param_default(def.def_id).subst_identity().to_string(),\n+                    )),\n                     false => None,\n                 },\n             },"}, {"sha": "d1b6d470e86ce91da866d11d89abbed6dc1622be", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1221,7 +1221,7 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n     ) {\n         let ast_attrs = self.tcx.hir().attrs(hir_id);\n         if let Some(ref cfg) = ast_attrs.cfg(self.tcx, &FxHashSet::default()) {\n-            if !cfg.matches(&self.sess.parse_sess, Some(self.sess.features_untracked())) {\n+            if !cfg.matches(&self.sess.parse_sess, Some(self.tcx.features())) {\n                 return;\n             }\n         }"}, {"sha": "3149c22b8e55ff6fcdd1293ef3594ce85a74d4a5", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -242,7 +242,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         }\n \n         // Index this method for searching later on.\n-        if let Some(ref s) = item.name.or_else(|| {\n+        if let Some(s) = item.name.or_else(|| {\n             if item.is_stripped() {\n                 None\n             } else if let clean::ImportItem(ref i) = *item.kind &&\n@@ -317,14 +317,15 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                             short_markdown_summary(x.as_str(), &item.link_names(self.cache))\n                         });\n                         let ty = item.type_();\n-                        let name = s.to_string();\n-                        if ty != ItemType::StructField || u16::from_str_radix(&name, 10).is_err() {\n+                        if ty != ItemType::StructField\n+                            || u16::from_str_radix(s.as_str(), 10).is_err()\n+                        {\n                             // In case this is a field from a tuple struct, we don't add it into\n                             // the search index because its name is something like \"0\", which is\n                             // not useful for rustdoc search.\n                             self.cache.search_index.push(IndexItem {\n                                 ty,\n-                                name,\n+                                name: s,\n                                 path: join_with_double_colon(path),\n                                 desc,\n                                 parent,"}, {"sha": "006076baf7257dab55ae538a5361fb17a06be287", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -569,7 +569,7 @@ fn generate_macro_def_id_path(\n     root_path: Option<&str>,\n ) -> Result<(String, ItemType, Vec<Symbol>), HrefError> {\n     let tcx = cx.shared.tcx;\n-    let crate_name = tcx.crate_name(def_id.krate).to_string();\n+    let crate_name = tcx.crate_name(def_id.krate);\n     let cache = cx.cache();\n \n     let fqp: Vec<Symbol> = tcx\n@@ -584,7 +584,7 @@ fn generate_macro_def_id_path(\n             }\n         })\n         .collect();\n-    let mut relative = fqp.iter().map(|elem| elem.to_string());\n+    let mut relative = fqp.iter().copied();\n     let cstore = CStore::from_tcx(tcx);\n     // We need this to prevent a `panic` when this function is used from intra doc links...\n     if !cstore.has_crate_data(def_id.krate) {\n@@ -602,9 +602,9 @@ fn generate_macro_def_id_path(\n     };\n \n     let mut path = if is_macro_2 {\n-        once(crate_name.clone()).chain(relative).collect()\n+        once(crate_name).chain(relative).collect()\n     } else {\n-        vec![crate_name.clone(), relative.next_back().unwrap()]\n+        vec![crate_name, relative.next_back().unwrap()]\n     };\n     if path.len() < 2 {\n         // The minimum we can have is the crate name followed by the macro name. If shorter, then\n@@ -614,17 +614,22 @@ fn generate_macro_def_id_path(\n     }\n \n     if let Some(last) = path.last_mut() {\n-        *last = format!(\"macro.{}.html\", last);\n+        *last = Symbol::intern(&format!(\"macro.{}.html\", last.as_str()));\n     }\n \n     let url = match cache.extern_locations[&def_id.krate] {\n         ExternalLocation::Remote(ref s) => {\n             // `ExternalLocation::Remote` always end with a `/`.\n-            format!(\"{}{}\", s, path.join(\"/\"))\n+            format!(\"{}{}\", s, path.iter().map(|p| p.as_str()).join(\"/\"))\n         }\n         ExternalLocation::Local => {\n             // `root_path` always end with a `/`.\n-            format!(\"{}{}/{}\", root_path.unwrap_or(\"\"), crate_name, path.join(\"/\"))\n+            format!(\n+                \"{}{}/{}\",\n+                root_path.unwrap_or(\"\"),\n+                crate_name,\n+                path.iter().map(|p| p.as_str()).join(\"/\")\n+            )\n         }\n         ExternalLocation::Unknown => {\n             debug!(\"crate {} not in cache when linkifying macros\", crate_name);\n@@ -1050,7 +1055,7 @@ fn fmt_type<'cx>(\n                 _ => String::new(),\n             };\n             let m = mutability.print_with_space();\n-            let amp = if f.alternate() { \"&\".to_string() } else { \"&amp;\".to_string() };\n+            let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n             match **ty {\n                 clean::DynTrait(ref bounds, ref trait_lt)\n                     if bounds.len() > 1 || trait_lt.is_some() =>"}, {"sha": "4ff67fe1551dd019f638bc79ce4ee6460047e6bf", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -30,7 +30,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::edition::Edition;\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n \n use once_cell::sync::Lazy;\n use std::borrow::Cow;\n@@ -198,7 +198,7 @@ fn slugify(c: char) -> Option<char> {\n \n #[derive(Clone, Debug)]\n pub struct Playground {\n-    pub crate_name: Option<String>,\n+    pub crate_name: Option<Symbol>,\n     pub url: String,\n }\n \n@@ -290,7 +290,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n                 .map(|l| map_line(l).for_code())\n                 .intersperse(\"\\n\".into())\n                 .collect::<String>();\n-            let krate = krate.as_ref().map(|s| &**s);\n+            let krate = krate.as_ref().map(|s| s.as_str());\n             let (test, _, _) =\n                 doctest::make_test(&test, krate, false, &Default::default(), edition, None);\n             let channel = if test.contains(\"#![feature(\") { \"&amp;version=nightly\" } else { \"\" };"}, {"sha": "5cefe9475e77576e63458dc5d3a9dfeb1d469285", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -464,8 +464,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         // If user passed in `--playground-url` arg, we fill in crate name here\n         let mut playground = None;\n         if let Some(url) = playground_url {\n-            playground =\n-                Some(markdown::Playground { crate_name: Some(krate.name(tcx).to_string()), url });\n+            playground = Some(markdown::Playground { crate_name: Some(krate.name(tcx)), url });\n         }\n         let mut layout = layout::Layout {\n             logo: String::new(),\n@@ -491,7 +490,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n                 }\n                 (sym::html_playground_url, Some(s)) => {\n                     playground = Some(markdown::Playground {\n-                        crate_name: Some(krate.name(tcx).to_string()),\n+                        crate_name: Some(krate.name(tcx)),\n                         url: s.to_string(),\n                     });\n                 }\n@@ -639,7 +638,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n                 write!(\n                     buf,\n                     \"<div class=\\\"main-heading\\\">\\\n-                     <h1 class=\\\"fqn\\\">Rustdoc settings</h1>\\\n+                     <h1>Rustdoc settings</h1>\\\n                      <span class=\\\"out-of-band\\\">\\\n                          <a id=\\\"back\\\" href=\\\"javascript:void(0)\\\" onclick=\\\"history.back();\\\">\\\n                             Back\\\n@@ -677,7 +676,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n                 write!(\n                     buf,\n                     \"<div class=\\\"main-heading\\\">\\\n-                     <h1 class=\\\"fqn\\\">Rustdoc help</h1>\\\n+                     <h1>Rustdoc help</h1>\\\n                      <span class=\\\"out-of-band\\\">\\\n                          <a id=\\\"back\\\" href=\\\"javascript:void(0)\\\" onclick=\\\"history.back();\\\">\\\n                             Back\\"}, {"sha": "f95d8e4303594900aa892473baed229afcceaacb", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -100,7 +100,7 @@ pub(crate) fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n #[derive(Debug)]\n pub(crate) struct IndexItem {\n     pub(crate) ty: ItemType,\n-    pub(crate) name: String,\n+    pub(crate) name: Symbol,\n     pub(crate) path: String,\n     pub(crate) desc: String,\n     pub(crate) parent: Option<DefId>,\n@@ -364,7 +364,7 @@ impl AllTypes {\n             }\n         }\n \n-        f.write_str(\"<h1 class=\\\"fqn\\\">List of all items</h1>\");\n+        f.write_str(\"<h1>List of all items</h1>\");\n         // Note: print_entries does not escape the title, because we know the current set of titles\n         // doesn't require escaping.\n         print_entries(f, &self.structs, ItemSection::Structs);\n@@ -394,7 +394,7 @@ fn scrape_examples_help(shared: &SharedContext<'_>) -> String {\n     let mut ids = IdMap::default();\n     format!(\n         \"<div class=\\\"main-heading\\\">\\\n-            <h1 class=\\\"fqn\\\">About scraped examples</h1>\\\n+            <h1>About scraped examples</h1>\\\n         </div>\\\n         <div>{}</div>\",\n         Markdown {\n@@ -513,7 +513,7 @@ fn document_full_inner(\n         debug!(\"Doc block: =====\\n{}\\n=====\", s);\n         if is_collapsible {\n             w.write_str(\n-                \"<details class=\\\"rustdoc-toggle top-doc\\\" open>\\\n+                \"<details class=\\\"toggle top-doc\\\" open>\\\n                 <summary class=\\\"hideme\\\">\\\n                      <span>Expand description</span>\\\n                 </summary>\",\n@@ -1343,7 +1343,7 @@ fn notable_traits_decl(ty: &clean::Type, cx: &Context<'_>) -> (String, String) {\n                     write!(\n                         &mut out,\n                         \"<h3>Notable traits for <code>{}</code></h3>\\\n-                     <pre class=\\\"content\\\"><code>\",\n+                     <pre><code>\",\n                         impl_.for_.print(cx)\n                     );\n                 }\n@@ -1514,7 +1514,7 @@ fn render_impl(\n         let toggled = !doc_buffer.is_empty();\n         if toggled {\n             let method_toggle_class = if item_type.is_method() { \" method-toggle\" } else { \"\" };\n-            write!(w, \"<details class=\\\"rustdoc-toggle{}\\\" open><summary>\", method_toggle_class);\n+            write!(w, \"<details class=\\\"toggle{}\\\" open><summary>\", method_toggle_class);\n         }\n         match &*item.kind {\n             clean::MethodItem(..) | clean::TyMethodItem(_) => {\n@@ -1730,7 +1730,7 @@ fn render_impl(\n             close_tags.insert_str(0, \"</details>\");\n             write!(\n                 w,\n-                \"<details class=\\\"rustdoc-toggle implementors-toggle\\\"{}>\",\n+                \"<details class=\\\"toggle implementors-toggle\\\"{}>\",\n                 if rendering_params.toggle_open_by_default { \" open\" } else { \"\" }\n             );\n             write!(w, \"<summary>\")\n@@ -2769,8 +2769,8 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n     let mut work = VecDeque::new();\n \n     let mut process_path = |did: DefId| {\n-        let get_extern = || cache.external_paths.get(&did).map(|s| s.0.clone());\n-        let fqp = cache.exact_paths.get(&did).cloned().or_else(get_extern);\n+        let get_extern = || cache.external_paths.get(&did).map(|s| &s.0);\n+        let fqp = cache.exact_paths.get(&did).or_else(get_extern);\n \n         if let Some(path) = fqp {\n             out.push(join_with_double_colon(&path));\n@@ -2999,7 +2999,7 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n     if it.peek().is_some() {\n         write!(\n             w,\n-            \"<details class=\\\"rustdoc-toggle more-examples-toggle\\\">\\\n+            \"<details class=\\\"toggle more-examples-toggle\\\">\\\n                   <summary class=\\\"hideme\\\">\\\n                      <span>More examples</span>\\\n                   </summary>\\"}, {"sha": "b93db7e28b2d701de6649819290c3d44b2c79457", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -204,7 +204,7 @@ fn should_hide_fields(n_fields: usize) -> bool {\n fn toggle_open(w: &mut Buffer, text: impl fmt::Display) {\n     write!(\n         w,\n-        \"<details class=\\\"rustdoc-toggle type-contents-toggle\\\">\\\n+        \"<details class=\\\"toggle type-contents-toggle\\\">\\\n             <summary class=\\\"hideme\\\">\\\n                 <span>Show {}</span>\\\n             </summary>\",\n@@ -733,7 +733,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         let toggled = !content.is_empty();\n         if toggled {\n             let method_toggle_class = if item_type.is_method() { \" method-toggle\" } else { \"\" };\n-            write!(w, \"<details class=\\\"rustdoc-toggle{method_toggle_class}\\\" open><summary>\");\n+            write!(w, \"<details class=\\\"toggle{method_toggle_class}\\\" open><summary>\");\n         }\n         write!(w, \"<section id=\\\"{}\\\" class=\\\"method has-srclink\\\">\", id);\n         render_rightside(w, cx, m, t, RenderMode::Normal);\n@@ -1027,8 +1027,8 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         .chain(std::iter::once(\"implementors\"))\n         .collect();\n     if let Some(did) = it.item_id.as_def_id() &&\n-        let get_extern = { || cache.external_paths.get(&did).map(|s| s.0.clone()) } &&\n-        let Some(fqp) = cache.exact_paths.get(&did).cloned().or_else(get_extern) {\n+        let get_extern = { || cache.external_paths.get(&did).map(|s| &s.0) } &&\n+        let Some(fqp) = cache.exact_paths.get(&did).or_else(get_extern) {\n         js_src_path.extend(fqp[..fqp.len() - 1].iter().copied());\n         js_src_path.push_fmt(format_args!(\"{}.{}.js\", it.type_(), fqp.last().unwrap()));\n     } else {\n@@ -1840,7 +1840,7 @@ fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n     if item.is_non_exhaustive() {\n         write!(\n             w,\n-            \"<details class=\\\"rustdoc-toggle non-exhaustive\\\">\\\n+            \"<details class=\\\"toggle non-exhaustive\\\">\\\n                  <summary class=\\\"hideme\\\"><span>{}</span></summary>\\\n                  <div class=\\\"docblock\\\">\",\n             {"}, {"sha": "c64349f413cee8e3b19361c05808a0c5130e709d", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -35,7 +35,7 @@ pub(crate) fn build_index<'tcx>(\n                 .map_or_else(String::new, |s| short_markdown_summary(&s, &item.link_names(cache)));\n             cache.search_index.push(IndexItem {\n                 ty: item.type_(),\n-                name: item.name.unwrap().to_string(),\n+                name: item.name.unwrap(),\n                 path: join_with_double_colon(&fqp[..fqp.len() - 1]),\n                 desc,\n                 parent: Some(parent),\n@@ -58,8 +58,8 @@ pub(crate) fn build_index<'tcx>(\n     // Sort search index items. This improves the compressibility of the search index.\n     cache.search_index.sort_unstable_by(|k1, k2| {\n         // `sort_unstable_by_key` produces lifetime errors\n-        let k1 = (&k1.path, &k1.name, &k1.ty, &k1.parent);\n-        let k2 = (&k2.path, &k2.name, &k2.ty, &k2.parent);\n+        let k1 = (&k1.path, k1.name.as_str(), &k1.ty, &k1.parent);\n+        let k2 = (&k2.path, k2.name.as_str(), &k2.ty, &k2.parent);\n         std::cmp::Ord::cmp(&k1, &k2)\n     });\n \n@@ -240,7 +240,7 @@ pub(crate) fn build_index<'tcx>(\n             )?;\n             crate_data.serialize_field(\n                 \"n\",\n-                &self.items.iter().map(|item| &item.name).collect::<Vec<_>>(),\n+                &self.items.iter().map(|item| item.name.as_str()).collect::<Vec<_>>(),\n             )?;\n             crate_data.serialize_field(\n                 \"q\",\n@@ -299,7 +299,7 @@ pub(crate) fn build_index<'tcx>(\n             )?;\n             crate_data.serialize_field(\n                 \"p\",\n-                &self.paths.iter().map(|(it, s)| (it, s.to_string())).collect::<Vec<_>>(),\n+                &self.paths.iter().map(|(it, s)| (it, s.as_str())).collect::<Vec<_>>(),\n             )?;\n             if has_aliases {\n                 crate_data.serialize_field(\"a\", &self.aliases)?;"}, {"sha": "ca3e9916487aad060546b9ac358d9f3a7fb20515", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -345,7 +345,7 @@ if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};\n             };\n \n             let content = format!(\n-                \"<h1 class=\\\"fqn\\\">List of all crates</h1><ul class=\\\"all-items\\\">{}</ul>\",\n+                \"<h1>List of all crates</h1><ul class=\\\"all-items\\\">{}</ul>\",\n                 krates\n                     .iter()\n                     .map(|s| {"}, {"sha": "a08b8d89db67d22454f8d0f59a90db37346c838d", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 43, "deletions": 39, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -139,7 +139,7 @@ h1, h2, h3, h4 {\n .docblock > h6:first-child {\n \tmargin-top: 0;\n }\n-h1.fqn {\n+.main-heading h1 {\n \tmargin: 0;\n \tpadding: 0;\n \tflex-grow: 1;\n@@ -317,7 +317,7 @@ main {\n \tmargin-right: auto;\n }\n \n-details:not(.rustdoc-toggle) summary {\n+details:not(.toggle) summary {\n \tmargin-bottom: .6em;\n }\n \n@@ -1214,18 +1214,22 @@ a.test-arrow:hover {\n \tcontent: \"\\00a0\";\n }\n \n-.notable .docblock {\n+.notable .content {\n \tmargin: 0.25em 0.5em;\n }\n \n-.notable .docblock pre, .notable .docblock code {\n+.notable .content pre, .notable .content code {\n \tbackground: transparent;\n \tmargin: 0;\n \tpadding: 0;\n \tfont-size: 1.25rem;\n \twhite-space: pre-wrap;\n }\n \n+.notable .content > h3:first-child {\n+\tmargin: 0 0 5px 0;\n+}\n+\n .search-failed {\n \ttext-align: center;\n \tmargin-top: 20px;\n@@ -1401,34 +1405,34 @@ details.dir-entry a {\n \tUnfortunately we can't yet specify contain: content or contain: strict\n \tbecause the [-]/[+] toggles extend past the boundaries of the <details>\n \thttps://developer.mozilla.org/en-US/docs/Web/CSS/contain */\n-details.rustdoc-toggle {\n+details.toggle {\n \tcontain: layout;\n \tposition: relative;\n }\n \n /* The hideme class is used on summary tags that contain a span with\n \tplaceholder text shown only when the toggle is closed. For instance,\n \t\"Expand description\" or \"Show methods\". */\n-details.rustdoc-toggle > summary.hideme {\n+details.toggle > summary.hideme {\n \tcursor: pointer;\n \tfont-size: 1rem;\n }\n \n-details.rustdoc-toggle > summary {\n+details.toggle > summary {\n \tlist-style: none;\n \t/* focus outline is shown on `::before` instead of this */\n \toutline: none;\n }\n-details.rustdoc-toggle > summary::-webkit-details-marker,\n-details.rustdoc-toggle > summary::marker {\n+details.toggle > summary::-webkit-details-marker,\n+details.toggle > summary::marker {\n \tdisplay: none;\n }\n \n-details.rustdoc-toggle > summary.hideme > span {\n+details.toggle > summary.hideme > span {\n \tmargin-left: 9px;\n }\n \n-details.rustdoc-toggle > summary::before {\n+details.toggle > summary::before {\n \tbackground: url(\"toggle-plus-1092eb4930d581b0.svg\") no-repeat top left;\n \tcontent: \"\";\n \tcursor: pointer;\n@@ -1440,32 +1444,32 @@ details.rustdoc-toggle > summary::before {\n \tfilter: var(--toggle-filter);\n }\n \n-details.rustdoc-toggle > summary.hideme > span,\n+details.toggle > summary.hideme > span,\n .more-examples-toggle summary, .more-examples-toggle .hide-more {\n \tcolor: var(--toggles-color);\n }\n \n /* Screen readers see the text version at the end the line.\n \tVisual readers see the icon at the start of the line, but small and transparent. */\n-details.rustdoc-toggle > summary::after {\n+details.toggle > summary::after {\n \tcontent: \"Expand\";\n \toverflow: hidden;\n \twidth: 0;\n \theight: 0;\n \tposition: absolute;\n }\n \n-details.rustdoc-toggle > summary.hideme::after {\n+details.toggle > summary.hideme::after {\n \t/* \"hideme\" toggles already have a description when they're contracted */\n \tcontent: \"\";\n }\n \n-details.rustdoc-toggle > summary:focus::before,\n-details.rustdoc-toggle > summary:hover::before {\n+details.toggle > summary:focus::before,\n+details.toggle > summary:hover::before {\n \topacity: 1;\n }\n \n-details.rustdoc-toggle > summary:focus-visible::before {\n+details.toggle > summary:focus-visible::before {\n \t/* The SVG is black, and gets turned white using a filter in the dark themes.\n \t   Do the same with the outline.\n \t   The dotted 1px style is copied from Firefox's focus ring style.\n@@ -1478,17 +1482,17 @@ details.non-exhaustive {\n \tmargin-bottom: 8px;\n }\n \n-details.rustdoc-toggle > summary.hideme::before {\n+details.toggle > summary.hideme::before {\n \tposition: relative;\n }\n \n-details.rustdoc-toggle > summary:not(.hideme)::before {\n+details.toggle > summary:not(.hideme)::before {\n \tposition: absolute;\n \tleft: -24px;\n \ttop: 4px;\n }\n \n-.impl-items > details.rustdoc-toggle > summary:not(.hideme)::before {\n+.impl-items > details.toggle > summary:not(.hideme)::before {\n \tposition: absolute;\n \tleft: -24px;\n }\n@@ -1498,19 +1502,19 @@ details.rustdoc-toggle > summary:not(.hideme)::before {\n \taffect the layout of the items to its right. To do that, we use\n \tabsolute positioning. Note that we also set position: relative\n \ton the parent <details> to make this work properly. */\n-details.rustdoc-toggle[open] > summary.hideme {\n+details.toggle[open] > summary.hideme {\n \tposition: absolute;\n }\n \n-details.rustdoc-toggle[open] > summary.hideme > span {\n+details.toggle[open] > summary.hideme > span {\n \tdisplay: none;\n }\n \n-details.rustdoc-toggle[open] > summary::before {\n+details.toggle[open] > summary::before {\n \tbackground: url(\"toggle-minus-31bbd6e4c77f5c96.svg\") no-repeat top left;\n }\n \n-details.rustdoc-toggle[open] > summary::after {\n+details.toggle[open] > summary::after {\n \tcontent: \"Collapse\";\n }\n \n@@ -1660,8 +1664,8 @@ in storage.js\n \t\tdisplay: block;\n \t}\n \n-\t#main-content > details.rustdoc-toggle > summary::before,\n-\t#main-content > div > details.rustdoc-toggle > summary::before {\n+\t#main-content > details.toggle > summary::before,\n+\t#main-content > div > details.toggle > summary::before {\n \t\tleft: -11px;\n \t}\n \n@@ -1715,12 +1719,12 @@ in storage.js\n \t}\n \n \t/* Position of the \"[-]\" element. */\n-\tdetails.rustdoc-toggle:not(.top-doc) > summary {\n+\tdetails.toggle:not(.top-doc) > summary {\n \t\tmargin-left: 10px;\n \t}\n-\t.impl-items > details.rustdoc-toggle > summary:not(.hideme)::before,\n-\t#main-content > details.rustdoc-toggle:not(.top-doc) > summary::before,\n-\t#main-content > div > details.rustdoc-toggle > summary::before {\n+\t.impl-items > details.toggle > summary:not(.hideme)::before,\n+\t#main-content > details.toggle:not(.top-doc) > summary::before,\n+\t#main-content > div > details.toggle > summary::before {\n \t\tleft: -11px;\n \t}\n \n@@ -1753,8 +1757,8 @@ in storage.js\n \n @media print {\n \tnav.sidebar, nav.sub, .out-of-band, a.srclink, #copy-path,\n-\tdetails.rustdoc-toggle[open] > summary::before, details.rustdoc-toggle > summary::before,\n-\tdetails.rustdoc-toggle.top-doc > summary {\n+\tdetails.toggle[open] > summary::before, details.toggle > summary::before,\n+\tdetails.toggle.top-doc > summary {\n \t\tdisplay: none;\n \t}\n \n@@ -1796,24 +1800,24 @@ in storage.js\n .impl,\n #implementors-list > .docblock,\n .impl-items > section,\n-.impl-items > .rustdoc-toggle > summary,\n+.impl-items > .toggle > summary,\n .methods > section,\n-.methods > .rustdoc-toggle > summary\n+.methods > .toggle > summary\n {\n \tmargin-bottom: 0.75em;\n }\n \n .variants > .docblock,\n .implementors-toggle > .docblock,\n-.impl-items > .rustdoc-toggle[open]:not(:last-child),\n-.methods > .rustdoc-toggle[open]:not(:last-child),\n+.impl-items > .toggle[open]:not(:last-child),\n+.methods > .toggle[open]:not(:last-child),\n .implementors-toggle[open]:not(:last-child) {\n \tmargin-bottom: 2em;\n }\n \n-#trait-implementations-list .impl-items > .rustdoc-toggle:not(:last-child),\n-#synthetic-implementations-list .impl-items > .rustdoc-toggle:not(:last-child),\n-#blanket-implementations-list .impl-items > .rustdoc-toggle:not(:last-child) {\n+#trait-implementations-list .impl-items > .toggle:not(:last-child),\n+#synthetic-implementations-list .impl-items > .toggle:not(:last-child),\n+#blanket-implementations-list .impl-items > .toggle:not(:last-child) {\n \tmargin-bottom: 1em;\n }\n "}, {"sha": "91419093147d728bbdda9478eecda9305db4621e", "filename": "src/librustdoc/html/static/css/settings.css", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -9,7 +9,7 @@\n }\n \n .setting-line .radio-line input,\n-.setting-line .toggle input {\n+.setting-line .settings-toggle input {\n \tmargin-right: 0.3em;\n \theight: 1.2rem;\n \twidth: 1.2rem;\n@@ -22,14 +22,14 @@\n .setting-line .radio-line input {\n \tborder-radius: 50%;\n }\n-.setting-line .toggle input:checked {\n+.setting-line .settings-toggle input:checked {\n \tcontent: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 40 40\">\\\n \t\t<path d=\"M7,25L17,32L33,12\" fill=\"none\" stroke=\"black\" stroke-width=\"5\"/>\\\n \t\t<path d=\"M7,23L17,30L33,10\" fill=\"none\" stroke=\"white\" stroke-width=\"5\"/></svg>');\n }\n \n .setting-line .radio-line input + span,\n-.setting-line .toggle span {\n+.setting-line .settings-toggle span {\n \tpadding-bottom: 1px;\n }\n \n@@ -50,7 +50,7 @@\n \tmargin-left: 0.5em;\n }\n \n-.toggle {\n+.settings-toggle {\n \tposition: relative;\n \twidth: 100%;\n \tmargin-right: 20px;\n@@ -67,11 +67,11 @@\n \tbox-shadow: inset 0 0 0 3px var(--main-background-color);\n \tbackground-color: var(--settings-input-color);\n }\n-.setting-line .toggle input:checked {\n+.setting-line .settings-toggle input:checked {\n \tbackground-color: var(--settings-input-color);\n }\n .setting-line .radio-line input:focus,\n-.setting-line .toggle input:focus {\n+.setting-line .settings-toggle input:focus {\n \tbox-shadow: 0 0 1px 1px var(--settings-input-color);\n }\n /* In here we combine both `:focus` and `:checked` properties. */\n@@ -80,6 +80,6 @@\n \t\t0 0 2px 2px var(--settings-input-color);\n }\n .setting-line .radio-line input:hover,\n-.setting-line .toggle input:hover {\n+.setting-line .settings-toggle input:hover {\n \tborder-color: var(--settings-input-color) !important;\n }"}, {"sha": "f52229d80953630ec0696743d5534b0e9faf3b59", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -526,7 +526,7 @@ function loadCss(cssUrl) {\n         }\n \n         let currentNbImpls = implementors.getElementsByClassName(\"impl\").length;\n-        const traitName = document.querySelector(\"h1.fqn > .trait\").textContent;\n+        const traitName = document.querySelector(\".main-heading h1 > .trait\").textContent;\n         const baseIdName = \"impl-\" + traitName + \"-\";\n         const libs = Object.getOwnPropertyNames(imp);\n         // We don't want to include impls from this JS file, when the HTML already has them.\n@@ -620,7 +620,7 @@ function loadCss(cssUrl) {\n     function expandAllDocs() {\n         const innerToggle = document.getElementById(toggleAllDocsId);\n         removeClass(innerToggle, \"will-expand\");\n-        onEachLazy(document.getElementsByClassName(\"rustdoc-toggle\"), e => {\n+        onEachLazy(document.getElementsByClassName(\"toggle\"), e => {\n             if (!hasClass(e, \"type-contents-toggle\") && !hasClass(e, \"more-examples-toggle\")) {\n                 e.open = true;\n             }\n@@ -632,7 +632,7 @@ function loadCss(cssUrl) {\n     function collapseAllDocs() {\n         const innerToggle = document.getElementById(toggleAllDocsId);\n         addClass(innerToggle, \"will-expand\");\n-        onEachLazy(document.getElementsByClassName(\"rustdoc-toggle\"), e => {\n+        onEachLazy(document.getElementsByClassName(\"toggle\"), e => {\n             if (e.parentNode.id !== \"implementations-list\" ||\n                 (!hasClass(e, \"implementors-toggle\") &&\n                  !hasClass(e, \"type-contents-toggle\"))\n@@ -680,7 +680,7 @@ function loadCss(cssUrl) {\n             setImplementorsTogglesOpen(\"blanket-implementations-list\", false);\n         }\n \n-        onEachLazy(document.getElementsByClassName(\"rustdoc-toggle\"), e => {\n+        onEachLazy(document.getElementsByClassName(\"toggle\"), e => {\n             if (!hideLargeItemContents && hasClass(e, \"type-contents-toggle\")) {\n                 e.open = true;\n             }\n@@ -823,7 +823,7 @@ function loadCss(cssUrl) {\n         });\n     });\n \n-    onEachLazy(document.querySelectorAll(\".rustdoc-toggle > summary:not(.hideme)\"), el => {\n+    onEachLazy(document.querySelectorAll(\".toggle > summary:not(.hideme)\"), el => {\n         el.addEventListener(\"click\", e => {\n             if (e.target.tagName !== \"SUMMARY\" && e.target.tagName !== \"A\") {\n                 e.preventDefault();\n@@ -847,7 +847,7 @@ function loadCss(cssUrl) {\n         window.hideAllModals(false);\n         const ty = e.getAttribute(\"data-ty\");\n         const wrapper = document.createElement(\"div\");\n-        wrapper.innerHTML = \"<div class=\\\"docblock\\\">\" + window.NOTABLE_TRAITS[ty] + \"</div>\";\n+        wrapper.innerHTML = \"<div class=\\\"content\\\">\" + window.NOTABLE_TRAITS[ty] + \"</div>\";\n         wrapper.className = \"notable popover\";\n         const focusCatcher = document.createElement(\"div\");\n         focusCatcher.setAttribute(\"tabindex\", \"0\");"}, {"sha": "9ed8f63610ff6b336d940e934043a6a7f53dd540", "filename": "src/librustdoc/html/static/js/settings.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -150,10 +150,10 @@\n                 });\n                 output += \"</div></div>\";\n             } else {\n-                // This is a toggle.\n+                // This is a checkbox toggle.\n                 const checked = setting[\"default\"] === true ? \" checked\" : \"\";\n                 output += `\\\n-<label class=\"toggle\">\\\n+<label class=\"settings-toggle\">\\\n     <input type=\"checkbox\" id=\"${js_data_name}\"${checked}>\\\n     <span class=\"label\">${setting_name}</span>\\\n </label>`;"}, {"sha": "ee2880bf6d195e23a91bedf640a667c29052cbc3", "filename": "src/librustdoc/html/templates/print_item.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fprint_item.html", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fprint_item.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fprint_item.html?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,5 +1,5 @@\n <div class=\"main-heading\"> {#- -#}\n-    <h1 class=\"fqn\"> {#- -#}\n+    <h1> {#- -#}\n         {{-typ-}}\n         {#- The breadcrumbs of the item path, like std::string -#}\n         {%- for component in path_components -%}"}, {"sha": "86454e1f2eb7316d239d4544c3adeec49e917e89", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -772,7 +772,6 @@ fn main_args(at_args: &[String]) -> MainResult {\n     let crate_version = options.crate_version.clone();\n \n     let output_format = options.output_format;\n-    let externs = options.externs.clone();\n     let scrape_examples_options = options.scrape_examples_options.clone();\n     let bin_crate = options.bin_crate;\n \n@@ -805,9 +804,7 @@ fn main_args(at_args: &[String]) -> MainResult {\n                 let resolver_caches = resolver.borrow_mut().access(|resolver| {\n                     collect_intra_doc_links::early_resolve_intra_doc_links(\n                         resolver,\n-                        sess,\n                         krate,\n-                        externs,\n                         render_options.document_private,\n                     )\n                 });"}, {"sha": "075951312a6393d738fab17772a2778f9b2085b9", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -786,7 +786,7 @@ fn trait_impls_for<'a>(\n         tcx.find_map_relevant_impl(trait_, ty, |impl_| {\n             let trait_ref = tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n             // Check if these are the same type.\n-            let impl_type = trait_ref.self_ty();\n+            let impl_type = trait_ref.skip_binder().self_ty();\n             trace!(\n                 \"comparing type {} with kind {:?} against type {:?}\",\n                 impl_type,"}, {"sha": "42677bd8497483cce642162000a7ffc4848b07e8", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -12,8 +12,6 @@ use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, CRATE_DEF_ID};\n use rustc_hir::TraitCandidate;\n use rustc_middle::ty::{DefIdTree, Visibility};\n use rustc_resolve::{ParentScope, Resolver};\n-use rustc_session::config::Externs;\n-use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::{Symbol, SyntaxContext};\n \n@@ -22,16 +20,13 @@ use std::mem;\n \n pub(crate) fn early_resolve_intra_doc_links(\n     resolver: &mut Resolver<'_>,\n-    sess: &Session,\n     krate: &ast::Crate,\n-    externs: Externs,\n     document_private_items: bool,\n ) -> ResolverCaches {\n     let parent_scope =\n         ParentScope::module(resolver.expect_module(CRATE_DEF_ID.to_def_id()), resolver);\n     let mut link_resolver = EarlyDocLinkResolver {\n         resolver,\n-        sess,\n         parent_scope,\n         visited_mods: Default::default(),\n         markdown_links: Default::default(),\n@@ -52,7 +47,9 @@ pub(crate) fn early_resolve_intra_doc_links(\n     // the known necessary crates. Load them all unconditionally until we find a way to fix this.\n     // DO NOT REMOVE THIS without first testing on the reproducer in\n     // https://github.com/jyn514/objr/commit/edcee7b8124abf0e4c63873e8422ff81beb11ebb\n-    for (extern_name, _) in externs.iter().filter(|(_, entry)| entry.add_prelude) {\n+    for (extern_name, _) in\n+        link_resolver.resolver.sess().opts.externs.iter().filter(|(_, entry)| entry.add_prelude)\n+    {\n         link_resolver.resolver.resolve_rustdoc_path(extern_name, TypeNS, parent_scope);\n     }\n \n@@ -73,7 +70,6 @@ fn doc_attrs<'a>(attrs: impl Iterator<Item = &'a ast::Attribute>) -> Attributes\n \n struct EarlyDocLinkResolver<'r, 'ra> {\n     resolver: &'r mut Resolver<'ra>,\n-    sess: &'r Session,\n     parent_scope: ParentScope<'ra>,\n     visited_mods: DefIdSet,\n     markdown_links: FxHashMap<String, Vec<PreprocessedMarkdownLink>>,\n@@ -166,7 +162,7 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n     fn resolve_doc_links_extern_impl(&mut self, def_id: DefId, is_inherent: bool) {\n         self.resolve_doc_links_extern_outer_fixme(def_id, def_id);\n         let assoc_item_def_ids = Vec::from_iter(\n-            self.resolver.cstore().associated_item_def_ids_untracked(def_id, self.sess),\n+            self.resolver.cstore().associated_item_def_ids_untracked(def_id, self.resolver.sess()),\n         );\n         for assoc_def_id in assoc_item_def_ids {\n             if !is_inherent || self.resolver.cstore().visibility_untracked(assoc_def_id).is_public()\n@@ -191,7 +187,9 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n         if !self.resolver.cstore().may_have_doc_links_untracked(def_id) {\n             return;\n         }\n-        let attrs = Vec::from_iter(self.resolver.cstore().item_attrs_untracked(def_id, self.sess));\n+        let attrs = Vec::from_iter(\n+            self.resolver.cstore().item_attrs_untracked(def_id, self.resolver.sess()),\n+        );\n         let parent_scope = ParentScope::module(\n             self.resolver.get_nearest_non_block_module(\n                 self.resolver.opt_parent(scope_id).unwrap_or(scope_id),\n@@ -205,7 +203,9 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n         if !self.resolver.cstore().may_have_doc_links_untracked(def_id) {\n             return;\n         }\n-        let attrs = Vec::from_iter(self.resolver.cstore().item_attrs_untracked(def_id, self.sess));\n+        let attrs = Vec::from_iter(\n+            self.resolver.cstore().item_attrs_untracked(def_id, self.resolver.sess()),\n+        );\n         let parent_scope = ParentScope::module(self.resolver.expect_module(def_id), self.resolver);\n         self.resolve_doc_links(doc_attrs(attrs.iter()), parent_scope);\n     }\n@@ -321,7 +321,7 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n                         let field_def_ids = Vec::from_iter(\n                             self.resolver\n                                 .cstore()\n-                                .associated_item_def_ids_untracked(def_id, self.sess),\n+                                .associated_item_def_ids_untracked(def_id, self.resolver.sess()),\n                         );\n                         for field_def_id in field_def_ids {\n                             self.resolve_doc_links_extern_outer(field_def_id, scope_id);"}, {"sha": "048ed2646233c45284f6a029b4c37dcf548a9c5c", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -97,17 +97,7 @@ impl<'a, 'tcx> DocFolder for Stripper<'a, 'tcx> {\n             }\n \n             // handled in the `strip-priv-imports` pass\n-            clean::ExternCrateItem { .. } => {}\n-            clean::ImportItem(ref imp) => {\n-                // Because json doesn't inline imports from private modules, we need to mark\n-                // the imported item as retained so it's impls won't be stripped.\n-                //\n-                // FIXME: Is it necessary to check for json output here: See\n-                // https://github.com/rust-lang/rust/pull/100325#discussion_r941495215\n-                if let Some(did) = imp.source.did && self.is_json_output {\n-                    self.retained.insert(did.into());\n-                }\n-            }\n+            clean::ExternCrateItem { .. } | clean::ImportItem(_) => {}\n \n             clean::ImplItem(..) => {}\n "}, {"sha": "1cd6d3803dfb0b342272862a8590f5dfc9f72573", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1 +1 @@\n-Subproject commit d992ab4e9034930e7809749f04077045af8f4d79\n+Subproject commit 1cd6d3803dfb0b342272862a8590f5dfc9f72573"}, {"sha": "751c262673b1ca04bec420a92bddbeea88ffdf10", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -472,7 +472,7 @@ fn check_clippy_lint_names(cx: &LateContext<'_>, name: Symbol, items: &[NestedMe\n \n fn check_lint_reason(cx: &LateContext<'_>, name: Symbol, items: &[NestedMetaItem], attr: &'_ Attribute) {\n     // Check for the feature\n-    if !cx.tcx.sess.features_untracked().lint_reasons {\n+    if !cx.tcx.features().lint_reasons {\n         return;\n     }\n "}, {"sha": "248d7388410673c3da902461a252936750345e67", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -251,7 +251,7 @@ fn check_hash_peq<'tcx>(\n \n                 // Only care about `impl PartialEq<Foo> for Foo`\n                 // For `impl PartialEq<B> for A, input_types is [A, B]\n-                if trait_ref.substs.type_at(1) == ty {\n+                if trait_ref.subst_identity().substs.type_at(1) == ty {\n                     span_lint_and_then(\n                         cx,\n                         DERIVED_HASH_WITH_MANUAL_EQ,\n@@ -299,7 +299,7 @@ fn check_ord_partial_ord<'tcx>(\n \n                 // Only care about `impl PartialOrd<Foo> for Foo`\n                 // For `impl PartialOrd<B> for A, input_types is [A, B]\n-                if trait_ref.substs.type_at(1) == ty {\n+                if trait_ref.subst_identity().substs.type_at(1) == ty {\n                     let mess = if partial_ord_is_automatically_derived {\n                         \"you are implementing `Ord` explicitly but have derived `PartialOrd`\"\n                     } else {"}, {"sha": "2ef547526d4f7961027d20dbb77f7e846435b992", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -56,7 +56,7 @@ impl<'tcx> LateLintPass<'tcx> for FallibleImplFrom {\n         if_chain! {\n             if let hir::ItemKind::Impl(impl_) = &item.kind;\n             if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(item.owner_id);\n-            if cx.tcx.is_diagnostic_item(sym::From, impl_trait_ref.def_id);\n+            if cx.tcx.is_diagnostic_item(sym::From, impl_trait_ref.skip_binder().def_id);\n             then {\n                 lint_impl_body(cx, item.span, impl_.items);\n             }"}, {"sha": "bd66ace4500a8d305f55ec1e430e1785e09d3348", "filename": "src/tools/clippy/clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -76,7 +76,7 @@ impl<'tcx> LateLintPass<'tcx> for FromOverInto {\n             && let Some(into_trait_seg) = hir_trait_ref.path.segments.last()\n             // `impl Into<target_ty> for self_ty`\n             && let Some(GenericArgs { args: [GenericArg::Type(target_ty)], .. }) = into_trait_seg.args\n-            && let Some(middle_trait_ref) = cx.tcx.impl_trait_ref(item.owner_id)\n+            && let Some(middle_trait_ref) = cx.tcx.impl_trait_ref(item.owner_id).map(ty::EarlyBinder::subst_identity)\n             && cx.tcx.is_diagnostic_item(sym::Into, middle_trait_ref.def_id)\n             && !matches!(middle_trait_ref.substs.type_at(1).kind(), ty::Alias(ty::Opaque, _))\n         {"}, {"sha": "5a459548153aab242c7a0d4b6aa800e50d522fc2", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -155,7 +155,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n         let container_id = assoc_item.container_id(cx.tcx);\n         let trait_def_id = match assoc_item.container {\n             TraitContainer => Some(container_id),\n-            ImplContainer => cx.tcx.impl_trait_ref(container_id).map(|t| t.def_id),\n+            ImplContainer => cx.tcx.impl_trait_ref(container_id).map(|t| t.skip_binder().def_id),\n         };\n \n         if let Some(trait_def_id) = trait_def_id {"}, {"sha": "839c3a3815c29ef5a55b0bcf877b680916a41923", "filename": "src/tools/clippy/clippy_lints/src/non_send_fields_in_send_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -90,7 +90,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSendFieldInSendTy {\n             if send_trait == trait_id;\n             if hir_impl.polarity == ImplPolarity::Positive;\n             if let Some(ty_trait_ref) = cx.tcx.impl_trait_ref(item.owner_id);\n-            if let self_ty = ty_trait_ref.self_ty();\n+            if let self_ty = ty_trait_ref.subst_identity().self_ty();\n             if let ty::Adt(adt_def, impl_trait_substs) = self_ty.kind();\n             then {\n                 let mut non_send_fields = Vec::new();"}, {"sha": "7b1d974f2f877e51f0c1d4fe29a89d57d383fb87", "filename": "src/tools/clippy/clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -244,7 +244,7 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n             })) => {\n                 #[allow(trivial_casts)]\n                 if let Some(Node::Item(item)) = get_parent_node(cx.tcx, owner_id.into())\n-                    && let Some(trait_ref) = cx.tcx.impl_trait_ref(item.owner_id)\n+                    && let Some(trait_ref) = cx.tcx.impl_trait_ref(item.owner_id).map(|t| t.subst_identity())\n                     && let Some(trait_item_id) = cx.tcx.associated_item(owner_id).trait_item_def_id\n                 {\n                     ("}, {"sha": "6ae9d9d63538006d7d4e759b17217a07d98424b5", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -137,7 +137,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n             then {\n                 // `self_ty` is the semantic self type of `impl <trait> for <type>`. This cannot be\n                 // `Self`.\n-                let self_ty = impl_trait_ref.self_ty();\n+                let self_ty = impl_trait_ref.subst_identity().self_ty();\n \n                 // `trait_method_sig` is the signature of the function, how it is declared in the\n                 // trait, not in the impl of the trait."}, {"sha": "efdd56dd47d396329b653c03804c8ed1db98d75c", "filename": "src/tools/clippy/tests/ui/crashes/ice-6252.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6252.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6252.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6252.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -17,9 +17,12 @@ error[E0412]: cannot find type `VAL` in this scope\n   --> $DIR/ice-6252.rs:10:63\n    |\n LL | impl<N, M> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n-   |          -                                                    ^^^ not found in this scope\n-   |          |\n-   |          help: you might be missing a type parameter: `, VAL`\n+   |                                                               ^^^ not found in this scope\n+   |\n+help: you might be missing a type parameter\n+   |\n+LL | impl<N, M, VAL> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n+   |          +++++\n \n error[E0046]: not all trait items implemented, missing: `VAL`\n   --> $DIR/ice-6252.rs:10:1"}, {"sha": "1af77d1a25b2d09df7873e047e2dccffd92216d9", "filename": "src/tools/clippy/tests/ui/def_id_nocore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdef_id_nocore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdef_id_nocore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdef_id_nocore.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -15,7 +15,7 @@ pub trait Copy {}\n pub unsafe trait Freeze {}\n \n #[lang = \"start\"]\n-fn start<T>(_main: fn() -> T, _argc: isize, _argv: *const *const u8) -> isize {\n+fn start<T>(_main: fn() -> T, _argc: isize, _argv: *const *const u8, _sigpipe: u8) -> isize {\n     0\n }\n "}, {"sha": "c0dbb2e644c111eccbc4762df64330341701863e", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1 +1 @@\n-279f1c9d8c26a8d227ae8ab806d262bb784b251b\n+9e75dddf609c0201d03f9792e850f95d6a283d11"}, {"sha": "d6d19a3fe8159ccc66ceb1ad7cf44e9ba9da742b", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs-with-isolation.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -22,7 +22,8 @@ fn main() {\n     }\n \n     // test `stat`\n-    assert_eq!(fs::metadata(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+    let err = fs::metadata(\"foo.txt\").unwrap_err();\n+    assert_eq!(err.kind(), ErrorKind::PermissionDenied);\n     // check that it is the right kind of `PermissionDenied`\n-    assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n+    assert_eq!(err.raw_os_error(), Some(libc::EACCES));\n }"}, {"sha": "b296aa2f4e6d619f1493d42df410f8daff7ab733", "filename": "src/tools/rustbook/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2FCargo.toml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -5,10 +5,10 @@ license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n \n [dependencies]\n-clap = \"3.1.1\"\n+clap = \"4.0.32\"\n env_logger = \"0.7.1\"\n \n [dependencies.mdbook]\n-version = \"0.4.21\"\n+version = \"0.4.25\"\n default-features = false\n features = [\"search\"]"}, {"sha": "1368ec653de115fc8a474ea8a04b42f88b922c72", "filename": "src/tools/rustbook/src/main.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -9,18 +9,21 @@ use mdbook::errors::Result as Result3;\n use mdbook::MDBook;\n \n fn main() {\n-    let crate_version = format!(\"v{}\", crate_version!());\n+    let crate_version = concat!(\"v\", crate_version!());\n     env_logger::Builder::from_env(env_logger::Env::default().default_filter_or(\"warn\")).init();\n     let d_arg = arg!(-d --\"dest-dir\" <DEST_DIR>\n \"The output directory for your book\\n(Defaults to ./book when omitted)\")\n-    .required(false);\n-    let dir_arg = arg!([dir]\n-\"A directory for your book\\n(Defaults to Current Directory when omitted)\");\n+    .required(false)\n+    .value_parser(clap::value_parser!(PathBuf));\n+\n+    let dir_arg = arg!([dir] \"Root directory for the book\\n\\\n+                              (Defaults to the current directory when omitted)\")\n+    .value_parser(clap::value_parser!(PathBuf));\n \n     let matches = Command::new(\"rustbook\")\n         .about(\"Build a book with mdBook\")\n         .author(\"Steve Klabnik <steve@steveklabnik.com>\")\n-        .version(&*crate_version)\n+        .version(crate_version)\n         .subcommand_required(true)\n         .arg_required_else_help(true)\n         .subcommand(\n@@ -60,8 +63,8 @@ pub fn build(args: &ArgMatches) -> Result3<()> {\n     // Set this to allow us to catch bugs in advance.\n     book.config.build.create_missing = false;\n \n-    if let Some(dest_dir) = args.value_of(\"dest-dir\") {\n-        book.config.build.build_dir = PathBuf::from(dest_dir);\n+    if let Some(dest_dir) = args.get_one::<PathBuf>(\"dest-dir\") {\n+        book.config.build.build_dir = dest_dir.into();\n     }\n \n     book.build()?;\n@@ -76,10 +79,9 @@ fn test(args: &ArgMatches) -> Result3<()> {\n }\n \n fn get_book_dir(args: &ArgMatches) -> PathBuf {\n-    if let Some(dir) = args.value_of(\"dir\") {\n+    if let Some(p) = args.get_one::<PathBuf>(\"dir\") {\n         // Check if path is relative from current dir, or absolute...\n-        let p = Path::new(dir);\n-        if p.is_relative() { env::current_dir().unwrap().join(dir) } else { p.to_path_buf() }\n+        if p.is_relative() { env::current_dir().unwrap().join(p) } else { p.to_path_buf() }\n     } else {\n         env::current_dir().unwrap()\n     }"}, {"sha": "19812fc6f55b630f9e557d2216e0a45f548a37c6", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -6,6 +6,7 @@ autobins = false\n \n [dependencies]\n cargo_metadata = \"0.14\"\n+cargo-platform = \"0.1.2\"\n regex = \"1\"\n miropt-test-tools = { path = \"../miropt-test-tools\" }\n lazy_static = \"1\""}, {"sha": "bc2edf634de2b617b5f0c46da2c20051f379784c", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 66, "deletions": 104, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,7 +1,7 @@\n //! Checks the licenses of third-party dependencies.\n \n-use cargo_metadata::{Metadata, Package, PackageId, Resolve};\n-use std::collections::{BTreeSet, HashSet};\n+use cargo_metadata::{DepKindInfo, Metadata, Package, PackageId};\n+use std::collections::HashSet;\n use std::path::Path;\n \n /// These are licenses that are allowed for all crates, including the runtime,\n@@ -98,14 +98,12 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"autocfg\",\n     \"bitflags\",\n     \"block-buffer\",\n-    \"bumpalo\", // Included in Cargo's dep graph but only activated on wasm32-*-unknown.\n     \"cc\",\n     \"cfg-if\",\n     \"chalk-derive\",\n     \"chalk-engine\",\n     \"chalk-ir\",\n     \"chalk-solve\",\n-    \"chrono\",\n     \"convert_case\", // dependency of derive_more\n     \"compiler_builtins\",\n     \"cpufeatures\",\n@@ -124,11 +122,9 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"dlmalloc\",\n     \"either\",\n     \"ena\",\n-    \"env_logger\",\n     \"expect-test\",\n     \"fallible-iterator\", // dependency of `thorin`\n     \"fastrand\",\n-    \"filetime\",\n     \"fixedbitset\",\n     \"flate2\",\n     \"fluent-bundle\",\n@@ -142,21 +138,18 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"gsgdt\",\n     \"hashbrown\",\n     \"hermit-abi\",\n-    \"humantime\",\n     \"icu_list\",\n     \"icu_locid\",\n     \"icu_provider\",\n     \"icu_provider_adapters\",\n     \"icu_provider_macros\",\n-    \"if_chain\",\n     \"indexmap\",\n     \"instant\",\n     \"intl-memoizer\",\n     \"intl_pluralrules\",\n     \"itertools\",\n     \"itoa\",\n     \"jobserver\",\n-    \"js-sys\", // Included in Cargo's dep graph but only activated on wasm32-*-unknown.\n     \"lazy_static\",\n     \"libc\",\n     \"libloading\",\n@@ -171,8 +164,6 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"memmap2\",\n     \"memoffset\",\n     \"miniz_oxide\",\n-    \"num-integer\",\n-    \"num-traits\",\n     \"num_cpus\",\n     \"object\",\n     \"odht\",\n@@ -190,7 +181,6 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"proc-macro2\",\n     \"psm\",\n     \"punycode\",\n-    \"quick-error\",\n     \"quote\",\n     \"rand\",\n     \"rand_chacha\",\n@@ -217,7 +207,7 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"serde\",\n     \"serde_derive\",\n     \"serde_json\",\n-    \"sha-1\",\n+    \"sha1\",\n     \"sha2\",\n     \"sharded-slab\",\n     \"smallvec\",\n@@ -235,7 +225,6 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"thiserror-impl\",\n     \"thorin-dwp\",\n     \"thread_local\",\n-    \"time\",\n     \"tinystr\",\n     \"tinyvec\",\n     \"tinyvec_macros\",\n@@ -268,13 +257,6 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"valuable\",\n     \"version_check\",\n     \"wasi\",\n-    // vvv Included in Cargo's dep graph but only activated on wasm32-*-unknown.\n-    \"wasm-bindgen\",\n-    \"wasm-bindgen-backend\",\n-    \"wasm-bindgen-macro\",\n-    \"wasm-bindgen-macro-support\",\n-    \"wasm-bindgen-shared\",\n-    // ^^^ Included in Cargo's dep graph but only activated on wasm32-*-unknown.\n     \"winapi\",\n     \"winapi-i686-pc-windows-gnu\",\n     \"winapi-util\",\n@@ -485,73 +467,55 @@ fn check_permitted_dependencies(\n     restricted_dependency_crates: &[&'static str],\n     bad: &mut bool,\n ) {\n+    let mut deps = HashSet::new();\n+    for to_check in restricted_dependency_crates {\n+        let to_check = pkg_from_name(metadata, to_check);\n+        use cargo_platform::Cfg;\n+        use std::str::FromStr;\n+        // We don't expect the compiler to ever run on wasm32, so strip\n+        // out those dependencies to avoid polluting the permitted list.\n+        deps_of_filtered(metadata, &to_check.id, &mut deps, &|dep_kinds| {\n+            dep_kinds.iter().any(|dep_kind| {\n+                dep_kind\n+                    .target\n+                    .as_ref()\n+                    .map(|target| {\n+                        !target.matches(\n+                            \"wasm32-unknown-unknown\",\n+                            &[\n+                                Cfg::from_str(\"target_arch=\\\"wasm32\\\"\").unwrap(),\n+                                Cfg::from_str(\"target_os=\\\"unknown\\\"\").unwrap(),\n+                            ],\n+                        )\n+                    })\n+                    .unwrap_or(true)\n+            })\n+        });\n+    }\n+\n     // Check that the PERMITTED_DEPENDENCIES does not have unused entries.\n-    for name in permitted_dependencies {\n-        if !metadata.packages.iter().any(|p| p.name == *name) {\n+    for permitted in permitted_dependencies {\n+        if !deps.iter().any(|dep_id| &pkg_from_id(metadata, dep_id).name == permitted) {\n             tidy_error!(\n                 bad,\n-                \"could not find allowed package `{}`\\n\\\n+                \"could not find allowed package `{permitted}`\\n\\\n                 Remove from PERMITTED_DEPENDENCIES list if it is no longer used.\",\n-                name\n             );\n         }\n     }\n-    // Get the list in a convenient form.\n-    let permitted_dependencies: HashSet<_> = permitted_dependencies.iter().cloned().collect();\n-\n-    // Check dependencies.\n-    let mut visited = BTreeSet::new();\n-    let mut unapproved = BTreeSet::new();\n-    for &krate in restricted_dependency_crates.iter() {\n-        let pkg = pkg_from_name(metadata, krate);\n-        let mut bad =\n-            check_crate_dependencies(&permitted_dependencies, metadata, &mut visited, pkg);\n-        unapproved.append(&mut bad);\n-    }\n-\n-    if !unapproved.is_empty() {\n-        tidy_error!(bad, \"Dependencies for {} not explicitly permitted:\", descr);\n-        for dep in unapproved {\n-            println!(\"* {dep}\");\n-        }\n-    }\n-}\n-\n-/// Checks the dependencies of the given crate from the given cargo metadata to see if they are on\n-/// the list of permitted dependencies. Returns a list of disallowed dependencies.\n-fn check_crate_dependencies<'a>(\n-    permitted_dependencies: &'a HashSet<&'static str>,\n-    metadata: &'a Metadata,\n-    visited: &mut BTreeSet<&'a PackageId>,\n-    krate: &'a Package,\n-) -> BTreeSet<&'a PackageId> {\n-    // This will contain bad deps.\n-    let mut unapproved = BTreeSet::new();\n-\n-    // Check if we have already visited this crate.\n-    if visited.contains(&krate.id) {\n-        return unapproved;\n-    }\n \n-    visited.insert(&krate.id);\n+    // Get in a convenient form.\n+    let permitted_dependencies: HashSet<_> = permitted_dependencies.iter().cloned().collect();\n \n-    // If this path is in-tree, we don't require it to be explicitly permitted.\n-    if krate.source.is_some() {\n-        // If this dependency is not on `PERMITTED_DEPENDENCIES`, add to bad set.\n-        if !permitted_dependencies.contains(krate.name.as_str()) {\n-            unapproved.insert(&krate.id);\n+    for dep in deps {\n+        let dep = pkg_from_id(metadata, dep);\n+        // If this path is in-tree, we don't require it to be explicitly permitted.\n+        if dep.source.is_some() {\n+            if !permitted_dependencies.contains(dep.name.as_str()) {\n+                tidy_error!(bad, \"Dependency for {descr} not explicitly permitted: {}\", dep.id);\n+            }\n         }\n     }\n-\n-    // Do a DFS in the crate graph.\n-    let to_check = deps_of(metadata, &krate.id);\n-\n-    for dep in to_check {\n-        let mut bad = check_crate_dependencies(permitted_dependencies, metadata, visited, dep);\n-        unapproved.append(&mut bad);\n-    }\n-\n-    unapproved\n }\n \n /// Prevents multiple versions of some expensive crates.\n@@ -588,24 +552,6 @@ fn check_crate_duplicate(\n     }\n }\n \n-/// Returns a list of dependencies for the given package.\n-fn deps_of<'a>(metadata: &'a Metadata, pkg_id: &'a PackageId) -> Vec<&'a Package> {\n-    let resolve = metadata.resolve.as_ref().unwrap();\n-    let node = resolve\n-        .nodes\n-        .iter()\n-        .find(|n| &n.id == pkg_id)\n-        .unwrap_or_else(|| panic!(\"could not find `{pkg_id}` in resolve\"));\n-    node.deps\n-        .iter()\n-        .map(|dep| {\n-            metadata.packages.iter().find(|pkg| pkg.id == dep.pkg).unwrap_or_else(|| {\n-                panic!(\"could not find dep `{}` for pkg `{}` in resolve\", dep.pkg, pkg_id)\n-            })\n-        })\n-        .collect()\n-}\n-\n /// Finds a package with the given name.\n fn pkg_from_name<'a>(metadata: &'a Metadata, name: &'static str) -> &'a Package {\n     let mut i = metadata.packages.iter().filter(|p| p.name == name);\n@@ -615,41 +561,57 @@ fn pkg_from_name<'a>(metadata: &'a Metadata, name: &'static str) -> &'a Package\n     result\n }\n \n+fn pkg_from_id<'a>(metadata: &'a Metadata, id: &PackageId) -> &'a Package {\n+    metadata.packages.iter().find(|p| &p.id == id).unwrap()\n+}\n+\n /// Finds all the packages that are in the rust runtime.\n fn compute_runtime_crates<'a>(metadata: &'a Metadata) -> HashSet<&'a PackageId> {\n-    let resolve = metadata.resolve.as_ref().unwrap();\n     let mut result = HashSet::new();\n     for name in RUNTIME_CRATES {\n         let id = &pkg_from_name(metadata, name).id;\n-        normal_deps_of_r(resolve, id, &mut result);\n+        deps_of_filtered(metadata, id, &mut result, &|_| true);\n     }\n     result\n }\n \n-/// Recursively find all normal dependencies.\n-fn normal_deps_of_r<'a>(\n-    resolve: &'a Resolve,\n+/// Recursively find all dependencies.\n+fn deps_of_filtered<'a>(\n+    metadata: &'a Metadata,\n     pkg_id: &'a PackageId,\n     result: &mut HashSet<&'a PackageId>,\n+    filter: &dyn Fn(&[DepKindInfo]) -> bool,\n ) {\n     if !result.insert(pkg_id) {\n         return;\n     }\n-    let node = resolve\n+    let node = metadata\n+        .resolve\n+        .as_ref()\n+        .unwrap()\n         .nodes\n         .iter()\n         .find(|n| &n.id == pkg_id)\n         .unwrap_or_else(|| panic!(\"could not find `{pkg_id}` in resolve\"));\n     for dep in &node.deps {\n-        normal_deps_of_r(resolve, &dep.pkg, result);\n+        if !filter(&dep.dep_kinds) {\n+            continue;\n+        }\n+        deps_of_filtered(metadata, &dep.pkg, result, filter);\n     }\n }\n \n+fn direct_deps_of<'a>(metadata: &'a Metadata, pkg_id: &'a PackageId) -> Vec<&'a Package> {\n+    let resolve = metadata.resolve.as_ref().unwrap();\n+    let node = resolve.nodes.iter().find(|n| &n.id == pkg_id).unwrap();\n+    node.deps.iter().map(|dep| pkg_from_id(metadata, &dep.pkg)).collect()\n+}\n+\n fn check_rustfix(metadata: &Metadata, bad: &mut bool) {\n     let cargo = pkg_from_name(metadata, \"cargo\");\n     let compiletest = pkg_from_name(metadata, \"compiletest\");\n-    let cargo_deps = deps_of(metadata, &cargo.id);\n-    let compiletest_deps = deps_of(metadata, &compiletest.id);\n+    let cargo_deps = direct_deps_of(metadata, &cargo.id);\n+    let compiletest_deps = direct_deps_of(metadata, &compiletest.id);\n     let cargo_rustfix = cargo_deps.iter().find(|p| p.name == \"rustfix\").unwrap();\n     let compiletest_rustfix = compiletest_deps.iter().find(|p| p.name == \"rustfix\").unwrap();\n     if cargo_rustfix.version != compiletest_rustfix.version {"}, {"sha": "16d10eb5968c1b897b178a2fa30cd0526e370b8c", "filename": "tests/mir-opt/building/custom/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -18,8 +18,8 @@ fn consts<const C: u32>() {\n     })\n }\n \n-static S: i32 = 5;\n-static mut T: i32 = 10;\n+static S: i32 = 0x05050505;\n+static mut T: i32 = 0x0a0a0a0a;\n // EMIT_MIR consts.statics.built.after.mir\n #[custom_mir(dialect = \"built\")]\n fn statics() {"}, {"sha": "bfef976aa02726b299276088ac0e5e343b97b3b3", "filename": "tests/mir-opt/building/custom/consts.statics.built.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.statics.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.statics.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.statics.built.after.mir?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -19,9 +19,9 @@ fn statics() -> () {\n }\n \n alloc2 (static: T, size: 4, align: 4) {\n-    0a 00 00 00                                     \u2502 ....\n+    0a 0a 0a 0a                                     \u2502 ....\n }\n \n alloc1 (static: S, size: 4, align: 4) {\n-    05 00 00 00                                     \u2502 ....\n+    05 05 05 05                                     \u2502 ....\n }"}, {"sha": "7fa29cccd50d602b0e01bc4ed258c20cadc8564a", "filename": "tests/mir-opt/const_prop/mutable_variable_no_prop.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.main.ConstProp.diff?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -38,6 +38,6 @@\n   }\n   \n   alloc1 (static: STATIC, size: 4, align: 4) {\n-      2a 00 00 00                                     \u2502 *...\n+      42 42 42 42                                     \u2502 BBBB\n   }\n   "}, {"sha": "b69ec931a6311360a097698f26319e9e7b57a899", "filename": "tests/mir-opt/const_prop/mutable_variable_no_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,7 +1,7 @@\n // unit-test\n // compile-flags: -O\n \n-static mut STATIC: u32 = 42;\n+static mut STATIC: u32 = 0x42424242;\n \n // EMIT_MIR mutable_variable_no_prop.main.ConstProp.diff\n fn main() {"}, {"sha": "93804780371cd41d11207b768bdad81a67f63269", "filename": "tests/mir-opt/issues/issue_75439.foo.MatchBranchSimplification.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -26,7 +26,7 @@\n           _3 = _1;                         // scope 2 at $DIR/issue_75439.rs:+2:47: +2:52\n           _2 = transmute::<[u8; 16], [u32; 4]>(move _3) -> bb1; // scope 2 at $DIR/issue_75439.rs:+2:37: +2:53\n                                            // mir::Constant\n-                                           // + span: $DIR/issue_75439.rs:7:37: 7:46\n+                                           // + span: $DIR/issue_75439.rs:8:37: 8:46\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn([u8; 16]) -> [u32; 4] {transmute::<[u8; 16], [u32; 4]>}, val: Value(<ZST>) }\n       }\n   \n@@ -49,7 +49,7 @@\n           _6 = _4;                         // scope 4 at $DIR/issue_75439.rs:+5:33: +5:35\n           _5 = transmute::<u32, [u8; 4]>(move _6) -> bb7; // scope 4 at $DIR/issue_75439.rs:+5:23: +5:36\n                                            // mir::Constant\n-                                           // + span: $DIR/issue_75439.rs:10:23: 10:32\n+                                           // + span: $DIR/issue_75439.rs:11:23: 11:32\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32) -> [u8; 4] {transmute::<u32, [u8; 4]>}, val: Value(<ZST>) }\n       }\n   "}, {"sha": "4c749a150c091f5159defd11c28594e7cd22633c", "filename": "tests/mir-opt/issues/issue_75439.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fmir-opt%2Fissues%2Fissue_75439.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fmir-opt%2Fissues%2Fissue_75439.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissues%2Fissue_75439.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,4 +1,5 @@\n // EMIT_MIR issue_75439.foo.MatchBranchSimplification.diff\n+// ignore-endian-big\n \n use std::mem::transmute;\n "}, {"sha": "22939e87912c1a32f96cb1133cb8ef8e284855e4", "filename": "tests/run-make-fulldeps/target-specs/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frun-make-fulldeps%2Ftarget-specs%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frun-make-fulldeps%2Ftarget-specs%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Ftarget-specs%2Ffoo.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -11,7 +11,7 @@ trait Sized {}\n auto trait Freeze {}\n \n #[lang = \"start\"]\n-fn start<T>(_main: fn() -> T, _argc: isize, _argv: *const *const u8) -> isize {\n+fn start<T>(_main: fn() -> T, _argc: isize, _argv: *const *const u8, _sigpipe: u8) -> isize {\n     0\n }\n "}, {"sha": "85cb72274208c4184b2edaee0642a6faac64718c", "filename": "tests/rustdoc-gui/anchors.goml", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Fanchors.goml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Fanchors.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fanchors.goml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2,7 +2,7 @@\n \n define-function: (\n     \"check-colors\",\n-    (theme, main_color, title_color, fqn_color, fqn_type_color, src_link_color, sidebar_link_color),\n+    (theme, main_color, title_color, main_heading_color, main_heading_type_color, src_link_color, sidebar_link_color),\n     block {\n         goto: \"file://\" + |DOC_PATH| + \"/staged_api/struct.Foo.html\"\n         // This is needed to ensure that the text color is computed.\n@@ -14,8 +14,8 @@ define-function: (\n         reload:\n \n         assert-css: (\"#toggle-all-docs\", {\"color\": |main_color|})\n-        assert-css: (\".fqn a:nth-of-type(1)\", {\"color\": |fqn_color|})\n-        assert-css: (\".fqn a:nth-of-type(2)\", {\"color\": |fqn_type_color|})\n+        assert-css: (\".main-heading h1 a:nth-of-type(1)\", {\"color\": |main_heading_color|})\n+        assert-css: (\".main-heading a:nth-of-type(2)\", {\"color\": |main_heading_type_color|})\n         assert-css: (\n              \".rightside .srclink\",\n              {\"color\": |src_link_color|, \"text-decoration\": \"none solid \" + |src_link_color|},\n@@ -57,7 +57,7 @@ define-function: (\n         assert-css: (\"#top-doc-prose-title\", {\"color\": |title_color|})\n \n         assert-css: (\".sidebar a\", {\"color\": |sidebar_link_color|})\n-        assert-css: (\"h1.fqn a\", {\"color\": |title_color|})\n+        assert-css: (\".main-heading h1 a\", {\"color\": |title_color|})\n \n         // We move the cursor over the \"Implementations\" title so the anchor is displayed.\n         move-cursor-to: \"h2#implementations\"\n@@ -77,8 +77,8 @@ call-function: (\n         \"theme\": \"ayu\",\n         \"main_color\": \"rgb(197, 197, 197)\",\n         \"title_color\": \"rgb(255, 255, 255)\",\n-        \"fqn_color\": \"rgb(255, 255, 255)\",\n-        \"fqn_type_color\": \"rgb(255, 160, 165)\",\n+        \"main_heading_color\": \"rgb(255, 255, 255)\",\n+        \"main_heading_type_color\": \"rgb(255, 160, 165)\",\n         \"src_link_color\": \"rgb(57, 175, 215)\",\n         \"sidebar_link_color\": \"rgb(83, 177, 219)\",\n     },\n@@ -89,8 +89,8 @@ call-function: (\n         \"theme\": \"dark\",\n         \"main_color\": \"rgb(221, 221, 221)\",\n         \"title_color\": \"rgb(221, 221, 221)\",\n-        \"fqn_color\": \"rgb(221, 221, 221)\",\n-        \"fqn_type_color\": \"rgb(45, 191, 184)\",\n+        \"main_heading_color\": \"rgb(221, 221, 221)\",\n+        \"main_heading_type_color\": \"rgb(45, 191, 184)\",\n         \"src_link_color\": \"rgb(210, 153, 29)\",\n         \"sidebar_link_color\": \"rgb(253, 191, 53)\",\n     },\n@@ -101,8 +101,8 @@ call-function: (\n         \"theme\": \"light\",\n         \"main_color\": \"rgb(0, 0, 0)\",\n         \"title_color\": \"rgb(0, 0, 0)\",\n-        \"fqn_color\": \"rgb(0, 0, 0)\",\n-        \"fqn_type_color\": \"rgb(173, 55, 138)\",\n+        \"main_heading_color\": \"rgb(0, 0, 0)\",\n+        \"main_heading_type_color\": \"rgb(173, 55, 138)\",\n         \"src_link_color\": \"rgb(56, 115, 173)\",\n         \"sidebar_link_color\": \"rgb(53, 109, 164)\",\n     },"}, {"sha": "e4ba5f1246d91f7a3ec9854c34bec1ce31a2475c", "filename": "tests/rustdoc-gui/headings.goml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Fheadings.goml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Fheadings.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fheadings.goml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -13,7 +13,7 @@\n // 14px  0.875rem\n goto: \"file://\" + |DOC_PATH| + \"/test_docs/struct.HeavilyDocumentedStruct.html\"\n \n-assert-css: (\"h1.fqn\", {\"font-size\": \"24px\"})\n+assert-css: (\".main-heading h1\", {\"font-size\": \"24px\"})\n \n assert-css: (\"h2#top-doc-prose-title\", {\"font-size\": \"22px\"})\n assert-css: (\"h2#top-doc-prose-title\", {\"border-bottom-width\": \"1px\"})\n@@ -52,7 +52,7 @@ assert-css: (\"h6#sub-sub-heading-for-struct-impl-item-doc\", {\"font-size\": \"14px\"\n \n goto: \"file://\" + |DOC_PATH| + \"/test_docs/enum.HeavilyDocumentedEnum.html\"\n \n-assert-css: (\"h1.fqn\", {\"font-size\": \"24px\"})\n+assert-css: (\".main-heading h1\", {\"font-size\": \"24px\"})\n \n assert-css: (\"h2#top-doc-prose-title\", {\"font-size\": \"22px\"})\n assert-css: (\"h2#top-doc-prose-title\", {\"border-bottom-width\": \"1px\"})\n@@ -111,7 +111,7 @@ assert-css: (\"//ul[@class='block mod']/preceding-sibling::h3\", {\"border-bottom-w\n \n goto: \"file://\" + |DOC_PATH| + \"/test_docs/union.HeavilyDocumentedUnion.html\"\n \n-assert-css: (\"h1.fqn\", {\"font-size\": \"24px\"})\n+assert-css: (\".main-heading h1\", {\"font-size\": \"24px\"})\n \n assert-css: (\"h2#top-doc-prose-title\", {\"font-size\": \"22px\"})\n assert-css: (\"h2#top-doc-prose-title\", {\"border-bottom-width\": \"1px\"})\n@@ -143,7 +143,7 @@ assert-css: (\"h6#sub-heading-for-union-impl-item-doc\", {\"border-bottom-width\": \"\n \n goto: \"file://\" + |DOC_PATH| + \"/test_docs/macro.heavily_documented_macro.html\"\n \n-assert-css: (\"h1.fqn\", {\"font-size\": \"24px\"})\n+assert-css: (\".main-heading h1\", {\"font-size\": \"24px\"})\n \n assert-css: (\"h2#top-doc-prose-title\", {\"font-size\": \"22px\"})\n assert-css: (\"h2#top-doc-prose-title\", {\"border-bottom-width\": \"1px\"})"}, {"sha": "720268a9e7eb1d6cf721aa7d068fc393e227bd80", "filename": "tests/rustdoc-gui/method-margins.goml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Fmethod-margins.goml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Fmethod-margins.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fmethod-margins.goml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,18 +1,18 @@\n // This test ensures that the margins on methods are coherent inside an impl block.\n goto: \"file://\" + |DOC_PATH| + \"/test_docs/trait_members/struct.HasTrait.html#impl-TraitMembers-for-HasTrait\"\n \n-assert-count: (\"#trait-implementations-list > .rustdoc-toggle\", 1)\n+assert-count: (\"#trait-implementations-list > .toggle\", 1)\n \n compare-elements-css: (\n     // compare margin on type with margin on method\n-    \"#trait-implementations-list .impl-items > .rustdoc-toggle:nth-child(1) > summary\",\n-    \"#trait-implementations-list .impl-items > .rustdoc-toggle:nth-child(2) > summary\",\n+    \"#trait-implementations-list .impl-items > .toggle:nth-child(1) > summary\",\n+    \"#trait-implementations-list .impl-items > .toggle:nth-child(2) > summary\",\n     [\"margin\"]\n )\n \n compare-elements-css: (\n     // compare margin on type with margin on method\n-    \"#trait-implementations-list .impl-items > .rustdoc-toggle:nth-child(1)\",\n-    \"#trait-implementations-list .impl-items > .rustdoc-toggle:nth-child(2)\",\n+    \"#trait-implementations-list .impl-items > .toggle:nth-child(1)\",\n+    \"#trait-implementations-list .impl-items > .toggle:nth-child(2)\",\n     [\"margin\"]\n )"}, {"sha": "1b5c3a0d202a0cfd1bd88fb96cb528764ff69822", "filename": "tests/rustdoc-gui/scrape-examples-button-focus.goml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Fscrape-examples-button-focus.goml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Fscrape-examples-button-focus.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fscrape-examples-button-focus.goml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,3 +1,5 @@\n+// This test ensures that the scraped examples buttons are working as expecting\n+// when 'Enter' key is pressed when they're focused.\n goto: \"file://\" + |DOC_PATH| + \"/scrape_examples/fn.test.html\"\n \n // The next/prev buttons vertically scroll the code viewport between examples"}, {"sha": "f444baa6ce10bb3fb56433ff251899bae646ab9b", "filename": "tests/rustdoc-gui/search-result-go-to-first.goml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Fsearch-result-go-to-first.goml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Fsearch-result-go-to-first.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsearch-result-go-to-first.goml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -3,17 +3,17 @@\n // First, we check that the first page doesn't have the string we're looking for to ensure\n // that the feature is changing page as expected.\n goto: \"file://\" + |DOC_PATH| + \"/test_docs/index.html\"\n-assert-text-false: (\".fqn\", \"Struct test_docs::Foo\")\n+assert-text-false: (\".main-heading h1\", \"Struct test_docs::Foo\")\n \n // We now check that we land on the search result page if \"go_to_first\" isn't set.\n goto: \"file://\" + |DOC_PATH| + \"/test_docs/index.html?search=struct%3AFoo\"\n // Waiting for the search results to appear...\n wait-for: \"#search-tabs\"\n-assert-text-false: (\".fqn\", \"Struct test_docs::Foo\")\n+assert-text-false: (\".main-heading h1\", \"Struct test_docs::Foo\")\n // Ensure that the search results are displayed, not the \"normal\" content.\n assert-css: (\"#main-content\", {\"display\": \"none\"})\n \n // Now we can check that the feature is working as expected!\n goto: \"file://\" + |DOC_PATH| + \"/test_docs/index.html?search=struct%3AFoo&go_to_first=true\"\n // Waiting for the page to load...\n-wait-for-text: (\".fqn\", \"Struct test_docs::Foo\")\n+wait-for-text: (\".main-heading h1\", \"Struct test_docs::Foo\")"}, {"sha": "f236dc3e0fe7681344504d8677b693de6c59044b", "filename": "tests/rustdoc-gui/settings.goml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Fsettings.goml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Fsettings.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsettings.goml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -159,7 +159,7 @@ assert-text: (\"#preferred-light-theme .setting-name\", \"Preferred light theme\")\n // We now check that clicking on the toggles' text is like clicking on the checkbox.\n // To test it, we use the \"Disable keyboard shortcuts\".\n local-storage: {\"rustdoc-disable-shortcuts\": \"false\"}\n-click: \".setting-line:last-child .toggle .label\"\n+click: \".setting-line:last-child .settings-toggle .label\"\n assert-local-storage: {\"rustdoc-disable-shortcuts\": \"true\"}\n \n // Make sure that \"Disable keyboard shortcuts\" actually took effect.\n@@ -169,7 +169,7 @@ assert-false: \"#help-button .popover\"\n wait-for-css: (\"#settings-menu .popover\", {\"display\": \"block\"})\n \n // Now turn keyboard shortcuts back on, and see if they work.\n-click: \".setting-line:last-child .toggle .label\"\n+click: \".setting-line:last-child .settings-toggle .label\"\n assert-local-storage: {\"rustdoc-disable-shortcuts\": \"false\"}\n press-key: \"Escape\"\n press-key: \"?\""}, {"sha": "ac346f25b8862c5c40aaa2bb71a7962421bb4971", "filename": "tests/rustdoc-gui/toggle-click-deadspace.goml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Ftoggle-click-deadspace.goml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Ftoggle-click-deadspace.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Ftoggle-click-deadspace.goml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,15 +1,15 @@\n // This test ensures that clicking on a method summary, but not on the \"[-]\",\n // doesn't toggle the <details>.\n goto: \"file://\" + |DOC_PATH| + \"/lib2/struct.Foo.html\"\n-assert-attribute: (\".impl-items .rustdoc-toggle\", {\"open\": \"\"})\n+assert-attribute: (\".impl-items .toggle\", {\"open\": \"\"})\n click: \"h4.code-header\" // This is the position of \"pub\" in \"pub fn a_method\"\n-assert-attribute: (\".impl-items .rustdoc-toggle\", {\"open\": \"\"})\n+assert-attribute: (\".impl-items .toggle\", {\"open\": \"\"})\n click-with-offset: (\n-    \".impl-items .rustdoc-toggle summary\",\n+    \".impl-items .toggle summary\",\n     {\"x\": -24, \"y\": 8}, // This is the position of \"[-]\" next to that pub fn.\n )\n-assert-attribute-false: (\".impl-items .rustdoc-toggle\", {\"open\": \"\"})\n+assert-attribute-false: (\".impl-items .toggle\", {\"open\": \"\"})\n \n // Click the \"Trait\" part of \"impl Trait\" and verify it navigates.\n click: \"#impl-Trait-for-Foo h3 a:first-of-type\"\n-assert-text: (\".fqn\", \"Trait lib2::Trait\")\n+assert-text: (\".main-heading h1\", \"Trait lib2::Trait\")"}, {"sha": "c9d236e9bba8a04ab8d5fee055a4e974ed767e0b", "filename": "tests/rustdoc-gui/toggle-docs.goml", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Ftoggle-docs.goml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Ftoggle-docs.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Ftoggle-docs.goml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -20,10 +20,10 @@ assert-text: (\"#toggle-all-docs\", \"[\u2212]\")\n goto: \"file://\" + |DOC_PATH| + \"/test_docs/struct.Foo.html\"\n // We first check that everything is visible.\n assert-text: (\"#toggle-all-docs\", \"[\u2212]\")\n-assert-attribute: (\"#implementations-list details.rustdoc-toggle\", {\"open\": \"\"}, ALL)\n-assert-attribute: (\"#trait-implementations-list details.rustdoc-toggle\", {\"open\": \"\"}, ALL)\n+assert-attribute: (\"#implementations-list details.toggle\", {\"open\": \"\"}, ALL)\n+assert-attribute: (\"#trait-implementations-list details.toggle\", {\"open\": \"\"}, ALL)\n assert-attribute-false: (\n-    \"#blanket-implementations-list > details.rustdoc-toggle\",\n+    \"#blanket-implementations-list > details.toggle\",\n     {\"open\": \"\"},\n     ALL,\n )\n@@ -32,18 +32,18 @@ assert-attribute-false: (\n click: \"#toggle-all-docs\"\n wait-for-text: (\"#toggle-all-docs\", \"[+]\")\n // We check that all <details> are collapsed (except for the impl block ones).\n-assert-attribute-false: (\"details.rustdoc-toggle:not(.implementors-toggle)\", {\"open\": \"\"}, ALL)\n+assert-attribute-false: (\"details.toggle:not(.implementors-toggle)\", {\"open\": \"\"}, ALL)\n assert-attribute: (\"#implementations-list > details.implementors-toggle\", {\"open\": \"\"})\n // We now check that the other impl blocks are collapsed.\n assert-attribute-false: (\n-    \"#blanket-implementations-list > details.rustdoc-toggle.implementors-toggle\",\n+    \"#blanket-implementations-list > details.toggle.implementors-toggle\",\n     {\"open\": \"\"},\n     ALL,\n )\n // We open them all again.\n click: \"#toggle-all-docs\"\n wait-for-text: (\"#toggle-all-docs\", \"[\u2212]\")\n-assert-attribute: (\"details.rustdoc-toggle\", {\"open\": \"\"}, ALL)\n+assert-attribute: (\"details.toggle\", {\"open\": \"\"}, ALL)\n \n // Checking the toggles style.\n show-text: true\n@@ -56,12 +56,12 @@ define-function: (\n         // We reload the page so the local storage settings are being used.\n         reload:\n \n-        assert-css: (\"details.rustdoc-toggle > summary::before\", {\n+        assert-css: (\"details.toggle > summary::before\", {\n             \"opacity\": \"0.5\",\n             \"filter\": |filter|,\n         }, ALL)\n-        move-cursor-to: \"details.rustdoc-toggle summary\"\n-        assert-css: (\"details.rustdoc-toggle > summary:hover::before\", {\n+        move-cursor-to: \"details.toggle summary\"\n+        assert-css: (\"details.toggle > summary:hover::before\", {\n             \"opacity\": \"1\",\n             \"filter\": |filter|,\n         })"}, {"sha": "000293b555f84ad83774da1e782c26cd3720365a", "filename": "tests/rustdoc-gui/toggled-open-implementations.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Ftoggled-open-implementations.goml", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-gui%2Ftoggled-open-implementations.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Ftoggled-open-implementations.goml?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2,4 +2,4 @@\n // has all the implementations toggled open by default, so users can\n // find method names in those implementations with Ctrl-F.\n goto: \"file://\" + |DOC_PATH| + \"/test_docs/struct.Foo.html\"\n-assert-attribute: (\".rustdoc-toggle.implementors-toggle\", {\"open\": \"\"})\n+assert-attribute: (\".toggle.implementors-toggle\", {\"open\": \"\"})"}, {"sha": "6140a06c555f2c5641c68b9a40a911225b3a6be6", "filename": "tests/rustdoc-ui/invalid-syntax.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-ui%2Finvalid-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-ui%2Finvalid-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Finvalid-syntax.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -77,8 +77,6 @@ LL | ///     ```\n    |         ^^^\n    |\n    = note: error from rustc: unknown start of token: `\n-   = note: error from rustc: unknown start of token: `\n-   = note: error from rustc: unknown start of token: `\n \n warning: could not parse code block as Rust code\n   --> $DIR/invalid-syntax.rs:64:5"}, {"sha": "4bdecdc1b79446302261626e67df86d9c77e6ad0", "filename": "tests/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fz-help.stdout?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -76,6 +76,7 @@\n     -Z                            llvm-plugins=val -- a list LLVM plugins to enable (space separated)\n     -Z                         llvm-time-trace=val -- generate JSON tracing data file from LLVM data (default: no)\n     -Z                         location-detail=val -- what location details should be tracked when using caller_location, either `none`, or a comma separated list of location details, for which valid options are `file`, `line`, and `column` (default: `file,line,column`)\n+    -Z                           log-backtrace=val -- add a backtrace along with logging\n     -Z                                      ls=val -- list the symbols defined by a library crate (default: no)\n     -Z                         macro-backtrace=val -- show macro backtraces (default: no)\n     -Z             maximal-hir-to-mir-coverage=val -- save as much information as possible about the correspondence between MIR and HIR as source scopes (default: no)"}, {"sha": "46be00a080482818f4af2c588dbdf6612953ea4a", "filename": "tests/rustdoc/doc-notable_trait-slice.bare_fn_matches.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fdoc-notable_trait-slice.bare_fn_matches.html", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fdoc-notable_trait-slice.bare_fn_matches.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdoc-notable_trait-slice.bare_fn_matches.html?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1 +1 @@\n-<script type=\"text/json\" id=\"notable-traits-data\">{\"&amp;'static [SomeStruct]\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&amp;amp;[&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait_slice::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;]&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait_slice::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &amp;amp;[&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait_slice::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;]&lt;/span&gt;\"}</script>\n\\ No newline at end of file\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"&amp;'static [SomeStruct]\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&amp;amp;[&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait_slice::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;]&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait_slice::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &amp;amp;[&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait_slice::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;]&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "f592e3b375c026061ec0fb7274a8eef453f201b5", "filename": "tests/rustdoc/doc-notable_trait.bare-fn.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fdoc-notable_trait.bare-fn.html", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fdoc-notable_trait.bare-fn.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdoc-notable_trait.bare-fn.html?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1 +1 @@\n-<script type=\"text/json\" id=\"notable-traits-data\">{\"SomeStruct\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"SomeStruct\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "384be668954000f0a61b53d43cdccd4249881487", "filename": "tests/rustdoc/doc-notable_trait.some-struct-new.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fdoc-notable_trait.some-struct-new.html", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fdoc-notable_trait.some-struct-new.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdoc-notable_trait.some-struct-new.html?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1 +1 @@\n-<script type=\"text/json\" id=\"notable-traits-data\">{\"SomeStruct\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/span&gt;\",\"Wrapper&lt;Self&gt;\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl&amp;lt;T:&amp;nbsp;&lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt;&amp;gt; &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"SomeStruct\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/span&gt;\",\"Wrapper&lt;Self&gt;\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl&amp;lt;T:&amp;nbsp;&lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt;&amp;gt; &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "0cc1ee10fd33571f268e88aacd0fe54a185e8013", "filename": "tests/rustdoc/doc-notable_trait.wrap-me.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fdoc-notable_trait.wrap-me.html", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fdoc-notable_trait.wrap-me.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdoc-notable_trait.wrap-me.html?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1 +1 @@\n-<script type=\"text/json\" id=\"notable-traits-data\">{\"Wrapper&lt;Self&gt;\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl&amp;lt;T:&amp;nbsp;&lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt;&amp;gt; &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"Wrapper&lt;Self&gt;\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl&amp;lt;T:&amp;nbsp;&lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt;&amp;gt; &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "fc755afda4a9cfa2ad24f08502c54101786f291a", "filename": "tests/rustdoc/index-page.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Findex-page.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Findex-page.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Findex-page.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -5,7 +5,7 @@\n #![crate_name = \"foo\"]\n \n // @has foo/../index.html\n-// @has - '//h1[@class=\"fqn\"]' 'List of all crates'\n+// @has - '//h1' 'List of all crates'\n // @has - '//ul[@class=\"all-items\"]//a[@href=\"foo/index.html\"]' 'foo'\n // @has - '//ul[@class=\"all-items\"]//a[@href=\"all_item_types/index.html\"]' 'all_item_types'\n pub struct Foo;"}, {"sha": "7578d49daa508753c34111b664d431faad397c7a", "filename": "tests/rustdoc/issue-41783.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fissue-41783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fissue-41783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-41783.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -5,7 +5,7 @@\n // @!hasraw - '<span class=\"attr\">#[outer]</span>'\n // @hasraw - '#![inner]</span>'\n // @!hasraw - '<span class=\"attr\">#![inner]</span>'\n-// @snapshot 'codeblock' - '//*[@class=\"rustdoc-toggle top-doc\"]/*[@class=\"docblock\"]//pre/code'\n+// @snapshot 'codeblock' - '//*[@class=\"toggle top-doc\"]/*[@class=\"docblock\"]//pre/code'\n \n /// ```no_run\n /// # # space"}, {"sha": "4d047af325515d7c8cfdddf6207be51765fb75c9", "filename": "tests/rustdoc/keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fkeyword.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -7,7 +7,7 @@\n // @has foo/index.html '//div[@class=\"sidebar-elems\"]//li/a' 'Keywords'\n // @has foo/index.html '//div[@class=\"sidebar-elems\"]//li/a/@href' '#keywords'\n // @has foo/keyword.match.html '//a[@class=\"keyword\"]' 'match'\n-// @has foo/keyword.match.html '//h1[@class=\"fqn\"]' 'Keyword match'\n+// @has foo/keyword.match.html '//h1' 'Keyword match'\n // @has foo/keyword.match.html '//section[@id=\"main-content\"]//div[@class=\"docblock\"]//p' 'this is a test!'\n // @has foo/index.html '//a/@href' '../foo/index.html'\n // @!has foo/foo/index.html"}, {"sha": "5dc857773a393ebf1fb883b674a628132269cb2b", "filename": "tests/rustdoc/local-reexport-doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Flocal-reexport-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Flocal-reexport-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Flocal-reexport-doc.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -4,7 +4,7 @@\n #![crate_name = \"foo\"]\n \n // @has 'foo/fn.g.html'\n-// @has - '//*[@class=\"rustdoc-toggle top-doc\"]/*[@class=\"docblock\"]' \\\n+// @has - '//*[@class=\"toggle top-doc\"]/*[@class=\"docblock\"]' \\\n // 'outer module inner module'\n \n mod inner_mod {"}, {"sha": "010058361faafa33e4a63feb9c9dff718dcd0865", "filename": "tests/rustdoc/mixing-doc-comments-and-attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fmixing-doc-comments-and-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fmixing-doc-comments-and-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fmixing-doc-comments-and-attrs.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,15 +1,15 @@\n #![crate_name = \"foo\"]\n \n // @has 'foo/struct.S1.html'\n-// @snapshot S1_top-doc - '//details[@class=\"rustdoc-toggle top-doc\"]/div[@class=\"docblock\"]'\n+// @snapshot S1_top-doc - '//details[@class=\"toggle top-doc\"]/div[@class=\"docblock\"]'\n \n #[doc = \"Hello world!\\n\\n\"]\n /// Goodbye!\n #[doc = \"  Hello again!\\n\"]\n pub struct S1;\n \n // @has 'foo/struct.S2.html'\n-// @snapshot S2_top-doc - '//details[@class=\"rustdoc-toggle top-doc\"]/div[@class=\"docblock\"]'\n+// @snapshot S2_top-doc - '//details[@class=\"toggle top-doc\"]/div[@class=\"docblock\"]'\n \n /// Hello world!\n ///\n@@ -18,7 +18,7 @@ pub struct S1;\n pub struct S2;\n \n // @has 'foo/struct.S3.html'\n-// @snapshot S3_top-doc - '//details[@class=\"rustdoc-toggle top-doc\"]/div[@class=\"docblock\"]'\n+// @snapshot S3_top-doc - '//details[@class=\"toggle top-doc\"]/div[@class=\"docblock\"]'\n /** Par 1\n */ ///\n /// Par 2"}, {"sha": "29b67c6b2b17bad3c7940138763e76609e14f840", "filename": "tests/rustdoc/multiple-import-levels.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fmultiple-import-levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fmultiple-import-levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fmultiple-import-levels.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -21,14 +21,14 @@ mod c {\n }\n \n // @has 'foo/struct.Type.html'\n-// @has - '//*[@class=\"rustdoc-toggle top-doc\"]/*[@class=\"docblock\"]' 'foo 2 1'\n+// @has - '//*[@class=\"toggle top-doc\"]/*[@class=\"docblock\"]' 'foo 2 1'\n /// foo\n pub use b::Type;\n // @has 'foo/struct.Whatever.html'\n-// @has - '//*[@class=\"rustdoc-toggle top-doc\"]/*[@class=\"docblock\"]' 'whatever 3 2 1'\n+// @has - '//*[@class=\"toggle top-doc\"]/*[@class=\"docblock\"]' 'whatever 3 2 1'\n /// whatever\n pub use c::Type as Whatever;\n // @has 'foo/struct.Woof.html'\n-// @has - '//*[@class=\"rustdoc-toggle top-doc\"]/*[@class=\"docblock\"]' 'a dog 4 2 1'\n+// @has - '//*[@class=\"toggle top-doc\"]/*[@class=\"docblock\"]' 'a dog 4 2 1'\n /// a dog\n pub use c::Woof;"}, {"sha": "c3a5eb6d324a475513930b35c91dbff969d7b4d3", "filename": "tests/rustdoc/primitive-reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fprimitive-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fprimitive-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fprimitive-reference.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -9,7 +9,7 @@\n // @has - '//div[@class=\"sidebar-elems\"]//li/a/@href' '#primitives'\n // @has foo/primitive.reference.html\n // @has - '//a[@class=\"primitive\"]' 'reference'\n-// @has - '//h1[@class=\"fqn\"]' 'Primitive Type reference'\n+// @has - '//h1' 'Primitive Type reference'\n // @has - '//section[@id=\"main-content\"]//div[@class=\"docblock\"]//p' 'this is a test!'\n \n // There should be only one implementation listed."}, {"sha": "77922414676101fc548d0758dd62919fb7005737", "filename": "tests/rustdoc/primitive-slice-auto-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fprimitive-slice-auto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fprimitive-slice-auto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fprimitive-slice-auto-trait.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -4,7 +4,7 @@\n #![feature(rustdoc_internals)]\n \n // @has foo/primitive.slice.html '//a[@class=\"primitive\"]' 'slice'\n-// @has - '//h1[@class=\"fqn\"]' 'Primitive Type slice'\n+// @has - '//h1' 'Primitive Type slice'\n // @has - '//section[@id=\"main-content\"]//div[@class=\"docblock\"]//p' 'this is a test!'\n // @has - '//h2[@id=\"synthetic-implementations\"]' 'Auto Trait Implementations'\n // @has - '//div[@id=\"synthetic-implementations-list\"]//h3' 'impl<T> Send for [T]where T: Send'"}, {"sha": "4344d24f98650aa5c6db2eea0cc9c52912e5c3ab", "filename": "tests/rustdoc/primitive-tuple-auto-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fprimitive-tuple-auto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fprimitive-tuple-auto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fprimitive-tuple-auto-trait.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -4,7 +4,7 @@\n #![feature(rustdoc_internals)]\n \n // @has foo/primitive.tuple.html '//a[@class=\"primitive\"]' 'tuple'\n-// @has - '//h1[@class=\"fqn\"]' 'Primitive Type tuple'\n+// @has - '//h1' 'Primitive Type tuple'\n // @has - '//section[@id=\"main-content\"]//div[@class=\"docblock\"]//p' 'this is a test!'\n // @has - '//h2[@id=\"synthetic-implementations\"]' 'Auto Trait Implementations'\n // @has - '//div[@id=\"synthetic-implementations-list\"]//h3' 'Send'"}, {"sha": "61850e2462d887bb545ccc3d65f52dc7ca62faf6", "filename": "tests/rustdoc/primitive-unit-auto-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fprimitive-unit-auto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fprimitive-unit-auto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fprimitive-unit-auto-trait.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -4,7 +4,7 @@\n #![feature(rustdoc_internals)]\n \n // @has foo/primitive.unit.html '//a[@class=\"primitive\"]' 'unit'\n-// @has - '//h1[@class=\"fqn\"]' 'Primitive Type unit'\n+// @has - '//h1' 'Primitive Type unit'\n // @has - '//section[@id=\"main-content\"]//div[@class=\"docblock\"]//p' 'this is a test!'\n // @has - '//h2[@id=\"synthetic-implementations\"]' 'Auto Trait Implementations'\n // @has - '//div[@id=\"synthetic-implementations-list\"]//h3' 'impl Send for ()'"}, {"sha": "516c7c0c6fe9bd40da798b32a95b1b6998ed672c", "filename": "tests/rustdoc/primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fprimitive.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -7,7 +7,7 @@\n // @has foo/index.html '//div[@class=\"sidebar-elems\"]//li/a' 'Primitive Types'\n // @has foo/index.html '//div[@class=\"sidebar-elems\"]//li/a/@href' '#primitives'\n // @has foo/primitive.i32.html '//a[@class=\"primitive\"]' 'i32'\n-// @has foo/primitive.i32.html '//h1[@class=\"fqn\"]' 'Primitive Type i32'\n+// @has foo/primitive.i32.html '//h1' 'Primitive Type i32'\n // @has foo/primitive.i32.html '//section[@id=\"main-content\"]//div[@class=\"docblock\"]//p' 'this is a test!'\n // @has foo/index.html '//a/@href' '../foo/index.html'\n // @!has foo/index.html '//span' '\ud83d\udd12'"}, {"sha": "5f54b7522ae38774e61e4c8cd7c44dc775ad410b", "filename": "tests/rustdoc/spotlight-from-dependency.odd.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fspotlight-from-dependency.odd.html", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fspotlight-from-dependency.odd.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fspotlight-from-dependency.odd.html?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1 +1 @@\n-<script type=\"text/json\" id=\"notable-traits-data\">{\"Odd\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Odd.html\\\" title=\\\"struct foo::Odd\\\"&gt;Odd&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"{{channel}}/core/iter/traits/iterator/trait.Iterator.html\\\" title=\\\"trait core::iter::traits::iterator::Iterator\\\"&gt;Iterator&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Odd.html\\\" title=\\\"struct foo::Odd\\\"&gt;Odd&lt;/a&gt;&lt;/span&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;    type &lt;a href=\\\"{{channel}}/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\"&gt;Item&lt;/a&gt; = &lt;a class=\\\"primitive\\\" href=\\\"{{channel}}/std/primitive.usize.html\\\"&gt;usize&lt;/a&gt;;&lt;/span&gt;\"}</script>\n\\ No newline at end of file\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"Odd\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Odd.html\\\" title=\\\"struct foo::Odd\\\"&gt;Odd&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"{{channel}}/core/iter/traits/iterator/trait.Iterator.html\\\" title=\\\"trait core::iter::traits::iterator::Iterator\\\"&gt;Iterator&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Odd.html\\\" title=\\\"struct foo::Odd\\\"&gt;Odd&lt;/a&gt;&lt;/span&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;    type &lt;a href=\\\"{{channel}}/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\"&gt;Item&lt;/a&gt; = &lt;a class=\\\"primitive\\\" href=\\\"{{channel}}/std/primitive.usize.html\\\"&gt;usize&lt;/a&gt;;&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "ca4c93f92e0a4f4a705ef02323c9629e450aac33", "filename": "tests/rustdoc/strip-block-doc-comments-stars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fstrip-block-doc-comments-stars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Fstrip-block-doc-comments-stars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fstrip-block-doc-comments-stars.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -4,7 +4,7 @@\n // block doc comments can have their lines starting with a star.\n \n // @has foo/fn.foo.html\n-// @snapshot docblock - '//*[@class=\"rustdoc-toggle top-doc\"]//*[@class=\"docblock\"]'\n+// @snapshot docblock - '//*[@class=\"toggle top-doc\"]//*[@class=\"docblock\"]'\n /**\n  *     a\n  */"}, {"sha": "87240f233ff2afef5e28f90d16d49c1b6d0c9133", "filename": "tests/rustdoc/toggle-item-contents.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Ftoggle-item-contents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Ftoggle-item-contents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Ftoggle-item-contents.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,15 +1,15 @@\n #![allow(unused)]\n \n // @has 'toggle_item_contents/struct.PubStruct.html'\n-// @count - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 0\n+// @count - '//details[@class=\"toggle type-contents-toggle\"]' 0\n pub struct PubStruct {\n     pub a: usize,\n     pub b: usize,\n }\n \n // @has 'toggle_item_contents/struct.BigPubStruct.html'\n-// @count - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 1\n-// @has - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 'Show 13 fields'\n+// @count - '//details[@class=\"toggle type-contents-toggle\"]' 1\n+// @has - '//details[@class=\"toggle type-contents-toggle\"]' 'Show 13 fields'\n pub struct BigPubStruct {\n     pub a: usize,\n     pub b: usize,\n@@ -27,8 +27,8 @@ pub struct BigPubStruct {\n }\n \n // @has 'toggle_item_contents/union.BigUnion.html'\n-// @count - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 1\n-// @has - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 'Show 13 fields'\n+// @count - '//details[@class=\"toggle type-contents-toggle\"]' 1\n+// @has - '//details[@class=\"toggle type-contents-toggle\"]' 'Show 13 fields'\n pub union BigUnion {\n     pub a: usize,\n     pub b: usize,\n@@ -46,23 +46,23 @@ pub union BigUnion {\n }\n \n // @has 'toggle_item_contents/union.Union.html'\n-// @count - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 0\n+// @count - '//details[@class=\"toggle type-contents-toggle\"]' 0\n pub union Union {\n     pub a: usize,\n     pub b: usize,\n     pub c: usize,\n }\n \n // @has 'toggle_item_contents/struct.PrivStruct.html'\n-// @count - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 0\n+// @count - '//details[@class=\"toggle type-contents-toggle\"]' 0\n // @has - '//div[@class=\"item-decl\"]' '/* private fields */'\n pub struct PrivStruct {\n     a: usize,\n     b: usize,\n }\n \n // @has 'toggle_item_contents/enum.Enum.html'\n-// @!has - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' ''\n+// @!has - '//details[@class=\"toggle type-contents-toggle\"]' ''\n pub enum Enum {\n     A, B, C,\n     D {\n@@ -72,7 +72,7 @@ pub enum Enum {\n }\n \n // @has 'toggle_item_contents/enum.EnumStructVariant.html'\n-// @!has - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' ''\n+// @!has - '//details[@class=\"toggle type-contents-toggle\"]' ''\n pub enum EnumStructVariant {\n     A, B, C,\n     D {\n@@ -81,14 +81,14 @@ pub enum EnumStructVariant {\n }\n \n // @has 'toggle_item_contents/enum.LargeEnum.html'\n-// @count - '//*[@class=\"rust enum\"]//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 1\n-// @has - '//*[@class=\"rust enum\"]//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 'Show 13 variants'\n+// @count - '//*[@class=\"rust enum\"]//details[@class=\"toggle type-contents-toggle\"]' 1\n+// @has - '//*[@class=\"rust enum\"]//details[@class=\"toggle type-contents-toggle\"]' 'Show 13 variants'\n pub enum LargeEnum {\n     A, B, C, D, E, F(u8), G, H, I, J, K, L, M\n }\n \n // @has 'toggle_item_contents/trait.Trait.html'\n-// @count - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 0\n+// @count - '//details[@class=\"toggle type-contents-toggle\"]' 0\n pub trait Trait {\n     type A;\n     #[must_use]\n@@ -97,8 +97,8 @@ pub trait Trait {\n }\n \n // @has 'toggle_item_contents/trait.GinormousTrait.html'\n-// @count - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 1\n-// @has - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 'Show 16 associated items'\n+// @count - '//details[@class=\"toggle type-contents-toggle\"]' 1\n+// @has - '//details[@class=\"toggle type-contents-toggle\"]' 'Show 16 associated items'\n pub trait GinormousTrait {\n     type A;\n     type B;\n@@ -120,8 +120,8 @@ pub trait GinormousTrait {\n }\n \n // @has 'toggle_item_contents/trait.HugeTrait.html'\n-// @count - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 1\n-// @has - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 'Show 12 associated constants and 2 methods'\n+// @count - '//details[@class=\"toggle type-contents-toggle\"]' 1\n+// @has - '//details[@class=\"toggle type-contents-toggle\"]' 'Show 12 associated constants and 2 methods'\n pub trait HugeTrait {\n     type A;\n     const M: usize = 1;\n@@ -142,8 +142,8 @@ pub trait HugeTrait {\n }\n \n // @has 'toggle_item_contents/trait.GiganticTrait.html'\n-// @count - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 1\n-// @has - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 'Show 1 associated constant and 1 method'\n+// @count - '//details[@class=\"toggle type-contents-toggle\"]' 1\n+// @has - '//details[@class=\"toggle type-contents-toggle\"]' 'Show 1 associated constant and 1 method'\n pub trait GiganticTrait {\n     type A;\n     type B;\n@@ -163,8 +163,8 @@ pub trait GiganticTrait {\n }\n \n // @has 'toggle_item_contents/trait.BigTrait.html'\n-// @count - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 1\n-// @has - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 'Show 14 methods'\n+// @count - '//details[@class=\"toggle type-contents-toggle\"]' 1\n+// @has - '//details[@class=\"toggle type-contents-toggle\"]' 'Show 14 methods'\n pub trait BigTrait {\n     type A;\n     #[must_use]"}, {"sha": "ebc316ca8ad2879ea0e5fcc171a8e70cc9ed294c", "filename": "tests/rustdoc/toggle-method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Ftoggle-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Ftoggle-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Ftoggle-method.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -4,9 +4,9 @@\n // summary. Struct methods with no documentation should not be wrapped.\n //\n // @has foo/struct.Foo.html\n-// @has - '//details[@class=\"rustdoc-toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'is_documented()'\n-// @has - '//details[@class=\"rustdoc-toggle method-toggle\"]//*[@class=\"docblock\"]' 'is_documented is documented'\n-// @!has - '//details[@class=\"rustdoc-toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'not_documented()'\n+// @has - '//details[@class=\"toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'is_documented()'\n+// @has - '//details[@class=\"toggle method-toggle\"]//*[@class=\"docblock\"]' 'is_documented is documented'\n+// @!has - '//details[@class=\"toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'not_documented()'\n pub struct Foo {\n }\n "}, {"sha": "686a174fc8f954b4aa95e29912acf0b7fcb05ea3", "filename": "tests/rustdoc/toggle-trait-fn.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Ftoggle-trait-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Frustdoc%2Ftoggle-trait-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Ftoggle-trait-fn.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -4,14 +4,14 @@\n // summary. Trait methods with no documentation should not be wrapped.\n //\n // @has foo/trait.Foo.html\n-// @has - '//details[@class=\"rustdoc-toggle\"]//summary//h4[@class=\"code-header\"]' 'type Item'\n-// @!has - '//details[@class=\"rustdoc-toggle\"]//summary//h4[@class=\"code-header\"]' 'type Item2'\n-// @has -  '//details[@class=\"rustdoc-toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'is_documented()'\n-// @!has - '//details[@class=\"rustdoc-toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'not_documented()'\n-// @has -  '//details[@class=\"rustdoc-toggle method-toggle\"]//*[@class=\"docblock\"]' 'is_documented is documented'\n-// @has -  '//details[@class=\"rustdoc-toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'is_documented_optional()'\n-// @!has - '//details[@class=\"rustdoc-toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'not_documented_optional()'\n-// @has -  '//details[@class=\"rustdoc-toggle method-toggle\"]//*[@class=\"docblock\"]' 'is_documented_optional is documented'\n+// @has - '//details[@class=\"toggle\"]//summary//h4[@class=\"code-header\"]' 'type Item'\n+// @!has - '//details[@class=\"toggle\"]//summary//h4[@class=\"code-header\"]' 'type Item2'\n+// @has -  '//details[@class=\"toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'is_documented()'\n+// @!has - '//details[@class=\"toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'not_documented()'\n+// @has -  '//details[@class=\"toggle method-toggle\"]//*[@class=\"docblock\"]' 'is_documented is documented'\n+// @has -  '//details[@class=\"toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'is_documented_optional()'\n+// @!has - '//details[@class=\"toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'not_documented_optional()'\n+// @has -  '//details[@class=\"toggle method-toggle\"]//*[@class=\"docblock\"]' 'is_documented_optional is documented'\n pub trait Foo {\n     /// is documented\n     type Item;"}, {"sha": "23f71520040080f22287b09941da4d838d3846a1", "filename": "tests/ui/associated-item/ambiguous-associated-type-with-generics.fixed", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.fixed?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+trait Trait<A> {}\n+\n+trait Assoc {\n+    type Ty;\n+}\n+\n+impl<A> Assoc for dyn Trait<A> {\n+    type Ty = i32;\n+}\n+\n+fn main() {\n+    let _x: <dyn Trait<i32> as Assoc>::Ty; //~ ERROR ambiguous associated type\n+}"}, {"sha": "9c26e339a449b59bf66560b5d7d5ddbe5f11d05a", "filename": "tests/ui/associated-item/ambiguous-associated-type-with-generics.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+trait Trait<A> {}\n+\n+trait Assoc {\n+    type Ty;\n+}\n+\n+impl<A> Assoc for dyn Trait<A> {\n+    type Ty = i32;\n+}\n+\n+fn main() {\n+    let _x: <dyn Trait<i32>>::Ty; //~ ERROR ambiguous associated type\n+}"}, {"sha": "97088b79fd67128a1f2e428d38ee290ce6061c9c", "filename": "tests/ui/associated-item/ambiguous-associated-type-with-generics.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,9 @@\n+error[E0223]: ambiguous associated type\n+  --> $DIR/ambiguous-associated-type-with-generics.rs:13:13\n+   |\n+LL |     let _x: <dyn Trait<i32>>::Ty;\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: use the fully-qualified path: `<dyn Trait<i32> as Assoc>::Ty`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0223`."}, {"sha": "d0c170620766c4d19a983e0f7dc8fa75d8a77e51", "filename": "tests/ui/associated-item/associated-item-duplicate-names-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fassociated-item%2Fassociated-item-duplicate-names-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fassociated-item%2Fassociated-item-duplicate-names-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-item%2Fassociated-item-duplicate-names-3.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -13,7 +13,7 @@ error[E0223]: ambiguous associated type\n   --> $DIR/associated-item-duplicate-names-3.rs:18:12\n    |\n LL |     let x: Baz::Bar = 5;\n-   |            ^^^^^^^^ help: use fully-qualified syntax: `<Baz as Trait>::Bar`\n+   |            ^^^^^^^^ help: use the fully-qualified path: `<Baz as Foo>::Bar`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "00856b55df5ece3ba2e995e921b61b1c3ad93d36", "filename": "tests/ui/associated-types/associated-types-in-ambiguous-context.stderr", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2,31 +2,46 @@ error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:6:36\n    |\n LL | fn get<T:Get,U:Get>(x: T, y: U) -> Get::Value {}\n-   |                                    ^^^^^^^^^^ help: use fully-qualified syntax: `<Type as Get>::Value`\n+   |                                    ^^^^^^^^^^\n+   |\n+help: if there were a type named `Example` that implemented `Get`, you could use the fully-qualified path\n+   |\n+LL | fn get<T:Get,U:Get>(x: T, y: U) -> <Example as Get>::Value {}\n+   |                                    ~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:20:17\n    |\n LL | trait Foo where Foo::Assoc: Bar {\n-   |                 ^^^^^^^^^^ help: use fully-qualified syntax: `<Self as Foo>::Assoc`\n+   |                 ^^^^^^^^^^ help: use the fully-qualified path: `<Self as Foo>::Assoc`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:25:10\n    |\n LL | type X = std::ops::Deref::Target;\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<Type as Deref>::Target`\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a type named `Example` that implemented `Deref`, you could use the fully-qualified path\n+   |\n+LL | type X = <Example as Deref>::Target;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:11:23\n    |\n LL |     fn grab(&self) -> Grab::Value;\n-   |                       ^^^^^^^^^^^ help: use fully-qualified syntax: `<Self as Grab>::Value`\n+   |                       ^^^^^^^^^^^ help: use the fully-qualified path: `<Self as Grab>::Value`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:14:22\n    |\n LL |     fn get(&self) -> Get::Value;\n-   |                      ^^^^^^^^^^ help: use fully-qualified syntax: `<Type as Get>::Value`\n+   |                      ^^^^^^^^^^\n+   |\n+help: if there were a type named `Example` that implemented `Get`, you could use the fully-qualified path\n+   |\n+LL |     fn get(&self) -> <Example as Get>::Value;\n+   |                      ~~~~~~~~~~~~~~~~~~~~~~~\n \n error: aborting due to 5 previous errors\n "}, {"sha": "50fa7d1ac4d43635cdefc031274550538bd3e8c7", "filename": "tests/ui/associated-types/issue-43784-associated-type.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fassociated-types%2Fissue-43784-associated-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fassociated-types%2Fissue-43784-associated-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fissue-43784-associated-type.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -4,6 +4,11 @@ error[E0277]: the trait bound `T: Copy` is not satisfied\n LL |     type Assoc = T;\n    |                  ^ the trait `Copy` is not implemented for `T`\n    |\n+note: required for `<T as Complete>::Assoc` to implement `Partial<T>`\n+  --> $DIR/issue-43784-associated-type.rs:1:11\n+   |\n+LL | pub trait Partial<X: ?Sized>: Copy {\n+   |           ^^^^^^^\n note: required by a bound in `Complete::Assoc`\n   --> $DIR/issue-43784-associated-type.rs:5:17\n    |"}, {"sha": "3979d2001fc5957ae109d6e4bdd9f8b672a6b8b9", "filename": "tests/ui/attributes/log-backtrace.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fattributes%2Flog-backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fattributes%2Flog-backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Flog-backtrace.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,9 @@\n+// run-pass\n+//\n+// This test makes sure that log-backtrace option doesn't give a compilation error.\n+//\n+// dont-check-compiler-stdout\n+// dont-check-compiler-stderr\n+// rustc-env:RUSTC_LOG=info\n+// compile-flags: -Zlog-backtrace=rustc_metadata::creader\n+fn main() {}"}, {"sha": "6ee2320a603ad867f445019e9b36595798a60a0b", "filename": "tests/ui/borrowck/issue-92157.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fborrowck%2Fissue-92157.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fborrowck%2Fissue-92157.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-92157.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,40 @@\n+#![feature(no_core)]\n+#![feature(lang_items)]\n+\n+#![no_core]\n+\n+#[cfg(target_os = \"linux\")]\n+#[link(name = \"c\")]\n+extern {}\n+\n+#[lang = \"start\"]\n+fn start<T>(_main: fn() -> T, _argc: isize, _argv: *const *const u8) -> isize {\n+    //~^ ERROR: incorrect number of parameters for the `start` lang item\n+    40+2\n+}\n+\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+#[lang = \"copy\"]\n+pub trait Copy {}\n+\n+#[lang = \"drop_in_place\"]\n+#[allow(unconditional_recursion)]\n+pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+    drop_in_place(to_drop)\n+}\n+\n+#[lang = \"add\"]\n+trait Add<RHS> {\n+    type Output;\n+    fn add(self, other: RHS) -> Self::Output;\n+}\n+\n+impl Add<isize> for isize {\n+    type Output = isize;\n+    fn add(self, other: isize) -> isize {\n+        self + other\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a4010d73d057a98067a5166ae9232bd1dad8b94f", "filename": "tests/ui/borrowck/issue-92157.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fborrowck%2Fissue-92157.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fborrowck%2Fissue-92157.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-92157.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,11 @@\n+error: incorrect number of parameters for the `start` lang item\n+  --> $DIR/issue-92157.rs:11:1\n+   |\n+LL | fn start<T>(_main: fn() -> T, _argc: isize, _argv: *const *const u8) -> isize {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `start` lang item should have four parameters, but found 3\n+   = note: the `start` lang item should have the signature `fn(fn() -> T, isize, *const *const u8, u8) -> isize`\n+\n+error: aborting due to previous error\n+"}, {"sha": "592aa4369ce0d404606962514f33ea83a08f623e", "filename": "tests/ui/builtin-superkinds/builtin-superkinds-double-superkind.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-double-superkind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-double-superkind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-double-superkind.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: `T` cannot be sent between threads safely\n-  --> $DIR/builtin-superkinds-double-superkind.rs:6:24\n+  --> $DIR/builtin-superkinds-double-superkind.rs:6:32\n    |\n LL | impl <T: Sync+'static> Foo for (T,) { }\n-   |                        ^^^ `T` cannot be sent between threads safely\n+   |                                ^^^^ `T` cannot be sent between threads safely\n    |\n    = note: required because it appears within the type `(T,)`\n note: required by a bound in `Foo`\n@@ -16,10 +16,10 @@ LL | impl <T: Sync+'static + std::marker::Send> Foo for (T,) { }\n    |                       +++++++++++++++++++\n \n error[E0277]: `T` cannot be shared between threads safely\n-  --> $DIR/builtin-superkinds-double-superkind.rs:9:16\n+  --> $DIR/builtin-superkinds-double-superkind.rs:9:24\n    |\n LL | impl <T: Send> Foo for (T,T) { }\n-   |                ^^^ `T` cannot be shared between threads safely\n+   |                        ^^^^^ `T` cannot be shared between threads safely\n    |\n    = note: required because it appears within the type `(T, T)`\n note: required by a bound in `Foo`"}, {"sha": "f9d548bb8fbe938a3e4093337db91eec8996c784", "filename": "tests/ui/builtin-superkinds/builtin-superkinds-in-metadata.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-in-metadata.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-in-metadata.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-in-metadata.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: `T` cannot be sent between threads safely\n-  --> $DIR/builtin-superkinds-in-metadata.rs:13:23\n+  --> $DIR/builtin-superkinds-in-metadata.rs:13:56\n    |\n LL | impl <T:Sync+'static> RequiresRequiresShareAndSend for X<T> { }\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `T` cannot be sent between threads safely\n+   |                                                        ^^^^ `T` cannot be sent between threads safely\n    |\n note: required because it appears within the type `X<T>`\n   --> $DIR/builtin-superkinds-in-metadata.rs:9:8"}, {"sha": "8b19170b0f100e86ea03c8aeed6be1fdf059c46c", "filename": "tests/ui/builtin-superkinds/builtin-superkinds-simple.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-simple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-simple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-simple.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: `Rc<i8>` cannot be sent between threads safely\n-  --> $DIR/builtin-superkinds-simple.rs:6:6\n+  --> $DIR/builtin-superkinds-simple.rs:6:14\n    |\n LL | impl Foo for std::rc::Rc<i8> { }\n-   |      ^^^ `Rc<i8>` cannot be sent between threads safely\n+   |              ^^^^^^^^^^^^^^^ `Rc<i8>` cannot be sent between threads safely\n    |\n    = help: the trait `Send` is not implemented for `Rc<i8>`\n note: required by a bound in `Foo`"}, {"sha": "0cfea72d5f184dddebc0027c2fc9a9def07c7afd", "filename": "tests/ui/builtin-superkinds/builtin-superkinds-typaram-not-send.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-typaram-not-send.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-typaram-not-send.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-typaram-not-send.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: `T` cannot be sent between threads safely\n-  --> $DIR/builtin-superkinds-typaram-not-send.rs:5:24\n+  --> $DIR/builtin-superkinds-typaram-not-send.rs:5:32\n    |\n LL | impl <T: Sync+'static> Foo for T { }\n-   |                        ^^^ `T` cannot be sent between threads safely\n+   |                                ^ `T` cannot be sent between threads safely\n    |\n note: required by a bound in `Foo`\n   --> $DIR/builtin-superkinds-typaram-not-send.rs:3:13"}, {"sha": "1c69b07e3d4af0859656946d6094f3c2bb07e173", "filename": "tests/ui/chalkify/bugs/async.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2,12 +2,21 @@\n // known-bug\n // unset-rustc-env:RUST_BACKTRACE\n // compile-flags:-Z trait-solver=chalk --edition=2021\n-// error-pattern:stack backtrace:\n+// error-pattern:internal compiler error\n // failure-status:101\n-// normalize-stderr-test \"note: .*\" -> \"\"\n-// normalize-stderr-test \"thread 'rustc' .*\" -> \"\"\n-// normalize-stderr-test \"  .*\\n\" -> \"\"\n // normalize-stderr-test \"DefId([^)]*)\" -> \"...\"\n+// normalize-stderr-test \"\\nerror: internal compiler error.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"note:.*unexpectedly panicked.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"note: we would appreciate a bug report.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"note: compiler flags.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"note: rustc.*running on.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"thread.*panicked.*\\n\" -> \"\"\n+// normalize-stderr-test \"stack backtrace:\\n\" -> \"\"\n+// normalize-stderr-test \"\\s\\d{1,}: .*\\n\" -> \"\"\n+// normalize-stderr-test \"\\s at .*\\n\" -> \"\"\n+// normalize-stderr-test \".*note: Some details.*\\n\" -> \"\"\n+// normalize-stderr-test \"\\n\\n[ ]*\\n\" -> \"\"\n+// normalize-stderr-test \"compiler/.*: projection\" -> \"projection\"\n \n fn main() -> () {}\n "}, {"sha": "d1508cb17001b4cf807bc3dcb3a0449f2854dd98", "filename": "tests/ui/chalkify/bugs/async.stderr", "status": "modified", "additions": 42, "deletions": 24, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,29 +1,47 @@\n-error[E0277]: `[async fn body@$DIR/async.rs:14:29: 16:2]` is not a future\n-LL |LL | |LL | | }\n-\n-\n-error[E0277]: the size for values of type `<[async fn body@$DIR/async.rs:14:29: 16:2] as Future>::Output` cannot be known at compilation time\n-LL |LL | |LL | | }\n-\n-\n-error[E0277]: `[async fn body@$DIR/async.rs:14:29: 16:2]` is not a future\n+error[E0277]: `[async fn body@$DIR/async.rs:23:29: 25:2]` is not a future\n+  --> $DIR/async.rs:23:29\n+   |\n+LL |   async fn foo(x: u32) -> u32 {\n+   |  _____________________________-\n+LL | |     x\n+LL | | }\n+   | | ^\n+   | | |\n+   | |_`[async fn body@$DIR/async.rs:23:29: 25:2]` is not a future\n+   |   required by a bound introduced by this call\n+   |\n+   = help: the trait `Future` is not implemented for `[async fn body@$DIR/async.rs:23:29: 25:2]`\n+   = note: [async fn body@$DIR/async.rs:23:29: 25:2] must be a future or must implement `IntoFuture` to be awaited\n+note: required by a bound in `identity_future`\n+  --> $SRC_DIR/core/src/future/mod.rs:LL:COL\n+\n+error[E0277]: the size for values of type `<[async fn body@$DIR/async.rs:23:29: 25:2] as Future>::Output` cannot be known at compilation time\n+  --> $DIR/async.rs:23:29\n+   |\n+LL |   async fn foo(x: u32) -> u32 {\n+   |  _____________________________^\n+LL | |     x\n+LL | | }\n+   | |_^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `<[async fn body@$DIR/async.rs:23:29: 25:2] as Future>::Output`\n+note: required by a bound in `identity_future`\n+  --> $SRC_DIR/core/src/future/mod.rs:LL:COL\n+\n+error[E0277]: `[async fn body@$DIR/async.rs:23:29: 25:2]` is not a future\n+  --> $DIR/async.rs:23:25\n+   |\n LL | async fn foo(x: u32) -> u32 {\n-\n-error: internal compiler error: compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs:1114:25: projection clauses should be implied from elsewhere. obligation: `Obligation(predicate=Binder(ProjectionPredicate(AliasTy { substs: [[async fn body@$DIR/async.rs:14:29: 16:2]], def_id: ...), _use_mk_alias_ty_instead: () }, Term::Ty(u32)), []), depth=0)`\n+   |                         ^^^ `[async fn body@$DIR/async.rs:23:29: 25:2]` is not a future\n+   |\n+   = help: the trait `Future` is not implemented for `[async fn body@$DIR/async.rs:23:29: 25:2]`\n+   = note: [async fn body@$DIR/async.rs:23:29: 25:2] must be a future or must implement `IntoFuture` to be awaited\n+\n+error: internal compiler error: projection clauses should be implied from elsewhere. obligation: `Obligation(predicate=Binder(ProjectionPredicate(AliasTy { substs: [[async fn body@$DIR/async.rs:23:29: 25:2]], def_id: ...), _use_mk_alias_ty_instead: () }, Term::Ty(u32)), []), depth=0)`\n+  --> $DIR/async.rs:23:25\n+   |\n LL | async fn foo(x: u32) -> u32 {\n-\n-\n-stack backtrace:\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-query stack during panic:\n+   |                         ^^^query stack during panic:\n #0 [typeck] type-checking `foo`\n #1 [thir_body] building THIR for `foo`\n #2 [mir_built] building MIR for `foo`"}, {"sha": "84c32fa3771a061a2c365335dcfd993f0df8dce4", "filename": "tests/ui/chalkify/impl_wf.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fchalkify%2Fimpl_wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fchalkify%2Fimpl_wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchalkify%2Fimpl_wf.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the size for values of type `str` cannot be known at compilation time\n-  --> $DIR/impl_wf.rs:11:6\n+  --> $DIR/impl_wf.rs:11:14\n    |\n LL | impl Foo for str { }\n-   |      ^^^ doesn't have a size known at compile-time\n+   |              ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\n note: required by a bound in `Foo`\n@@ -12,10 +12,10 @@ LL | trait Foo: Sized { }\n    |            ^^^^^ required by this bound in `Foo`\n \n error[E0277]: the trait bound `f32: Foo` is not satisfied\n-  --> $DIR/impl_wf.rs:22:6\n+  --> $DIR/impl_wf.rs:22:19\n    |\n LL | impl Baz<f32> for f32 { }\n-   |      ^^^^^^^^ the trait `Foo` is not implemented for `f32`\n+   |                   ^^^ the trait `Foo` is not implemented for `f32`\n    |\n    = help: the trait `Foo` is implemented for `i32`\n note: required by a bound in `Baz`"}, {"sha": "1cd8949b8c4b71eddab96dc8cd9e7fd2cf802230", "filename": "tests/ui/closures/issue-84128.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fclosures%2Fissue-84128.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fclosures%2Fissue-84128.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2Fissue-84128.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -6,6 +6,13 @@ LL |         Foo(())\n    |         |\n    |         arguments to this struct are incorrect\n    |\n+help: the type constructed contains `()` due to the type of the argument passed\n+  --> $DIR/issue-84128.rs:13:9\n+   |\n+LL |         Foo(())\n+   |         ^^^^--^\n+   |             |\n+   |             this argument influences the type of `Foo`\n note: tuple struct defined here\n   --> $DIR/issue-84128.rs:5:8\n    |"}, {"sha": "b492251c01691e85ce617249bb91cf1877509608", "filename": "tests/ui/closures/issue-87461.stderr", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fclosures%2Fissue-87461.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fclosures%2Fissue-87461.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2Fissue-87461.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -6,6 +6,13 @@ LL |     Ok(())\n    |     |\n    |     arguments to this enum variant are incorrect\n    |\n+help: the type constructed contains `()` due to the type of the argument passed\n+  --> $DIR/issue-87461.rs:10:5\n+   |\n+LL |     Ok(())\n+   |     ^^^--^\n+   |        |\n+   |        this argument influences the type of `Ok`\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/result.rs:LL:COL\n \n@@ -17,6 +24,13 @@ LL |     Ok(())\n    |     |\n    |     arguments to this enum variant are incorrect\n    |\n+help: the type constructed contains `()` due to the type of the argument passed\n+  --> $DIR/issue-87461.rs:17:5\n+   |\n+LL |     Ok(())\n+   |     ^^^--^\n+   |        |\n+   |        this argument influences the type of `Ok`\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/result.rs:LL:COL\n \n@@ -28,6 +42,13 @@ LL |         Ok(())\n    |         |\n    |         arguments to this enum variant are incorrect\n    |\n+help: the type constructed contains `()` due to the type of the argument passed\n+  --> $DIR/issue-87461.rs:26:9\n+   |\n+LL |         Ok(())\n+   |         ^^^--^\n+   |            |\n+   |            this argument influences the type of `Ok`\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/result.rs:LL:COL\n "}, {"sha": "668b8319b3875fba17d26ceda66a8b3700ced1bc", "filename": "tests/ui/coherence/coherence-overlap-trait-alias.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,8 +1,8 @@\n error[E0283]: type annotations needed: cannot satisfy `u32: C`\n-  --> $DIR/coherence-overlap-trait-alias.rs:15:6\n+  --> $DIR/coherence-overlap-trait-alias.rs:15:12\n    |\n LL | impl C for u32 {}\n-   |      ^\n+   |            ^^^\n    |\n note: multiple `impl`s satisfying `u32: C` found\n   --> $DIR/coherence-overlap-trait-alias.rs:14:1"}, {"sha": "4c1926387b926a4e843b3e6c5176af7d0b964c95", "filename": "tests/ui/const-generics/unused_braces.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fconst-generics%2Funused_braces.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fconst-generics%2Funused_braces.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Funused_braces.fixed?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2,10 +2,17 @@\n // run-rustfix\n #![warn(unused_braces)]\n \n+macro_rules! make_1 {\n+    () => {\n+        1\n+    }\n+}\n+\n struct A<const N: usize>;\n \n fn main() {\n     let _: A<7>; // ok\n     let _: A<7>; //~ WARN unnecessary braces\n     let _: A<{ 3 + 5 }>; // ok\n+    let _: A<{make_1!()}>; // ok\n }"}, {"sha": "e9f15b401807915c0f85cf7893e8e14d67d60ab0", "filename": "tests/ui/const-generics/unused_braces.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fconst-generics%2Funused_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fconst-generics%2Funused_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Funused_braces.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2,10 +2,17 @@\n // run-rustfix\n #![warn(unused_braces)]\n \n+macro_rules! make_1 {\n+    () => {\n+        1\n+    }\n+}\n+\n struct A<const N: usize>;\n \n fn main() {\n     let _: A<7>; // ok\n     let _: A<{ 7 }>; //~ WARN unnecessary braces\n     let _: A<{ 3 + 5 }>; // ok\n+    let _: A<{make_1!()}>; // ok\n }"}, {"sha": "2c8031c430020b8f86e38ab53137ab02c3783e30", "filename": "tests/ui/const-generics/unused_braces.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fconst-generics%2Funused_braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fconst-generics%2Funused_braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Funused_braces.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,5 +1,5 @@\n warning: unnecessary braces around const expression\n-  --> $DIR/unused_braces.rs:9:14\n+  --> $DIR/unused_braces.rs:15:14\n    |\n LL |     let _: A<{ 7 }>;\n    |              ^^ ^^"}, {"sha": "af03f0e5e5f430ca1bbefa70b91c941ee1038600", "filename": "tests/ui/derives/issue-91550.stderr", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fderives%2Fissue-91550.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fderives%2Fissue-91550.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fissue-91550.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -6,12 +6,15 @@ LL | struct Value(u32);\n    | |\n    | doesn't satisfy `Value: Eq`\n    | doesn't satisfy `Value: Hash`\n+   | doesn't satisfy `Value: PartialEq`\n ...\n LL |     hs.insert(Value(0));\n    |        ^^^^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `Value: Eq`\n+           `Value: PartialEq`\n+           which is required by `Value: Eq`\n            `Value: Hash`\n help: consider annotating `Value` with `#[derive(Eq, Hash, PartialEq)]`\n    |\n@@ -22,7 +25,10 @@ error[E0599]: the method `use_eq` exists for struct `Object<NoDerives>`, but its\n   --> $DIR/issue-91550.rs:26:9\n    |\n LL | pub struct NoDerives;\n-   | -------------------- doesn't satisfy `NoDerives: Eq`\n+   | --------------------\n+   | |\n+   | doesn't satisfy `NoDerives: Eq`\n+   | doesn't satisfy `NoDerives: PartialEq`\n LL |\n LL | struct Object<T>(T);\n    | ---------------- method `use_eq` not found for this struct\n@@ -37,6 +43,9 @@ LL | impl<T: Eq> Object<T> {\n    |         ^^  ---------\n    |         |\n    |         unsatisfied trait bound introduced here\n+   = note: the following trait bounds were not satisfied:\n+           `NoDerives: PartialEq`\n+           which is required by `NoDerives: Eq`\n help: consider annotating `NoDerives` with `#[derive(Eq, PartialEq)]`\n    |\n LL | #[derive(Eq, PartialEq)]\n@@ -46,7 +55,12 @@ error[E0599]: the method `use_ord` exists for struct `Object<NoDerives>`, but it\n   --> $DIR/issue-91550.rs:27:9\n    |\n LL | pub struct NoDerives;\n-   | -------------------- doesn't satisfy `NoDerives: Ord`\n+   | --------------------\n+   | |\n+   | doesn't satisfy `NoDerives: Eq`\n+   | doesn't satisfy `NoDerives: Ord`\n+   | doesn't satisfy `NoDerives: PartialEq`\n+   | doesn't satisfy `NoDerives: PartialOrd`\n LL |\n LL | struct Object<T>(T);\n    | ---------------- method `use_ord` not found for this struct\n@@ -61,6 +75,13 @@ LL | impl<T: Ord> Object<T> {\n    |         ^^^  ---------\n    |         |\n    |         unsatisfied trait bound introduced here\n+   = note: the following trait bounds were not satisfied:\n+           `NoDerives: PartialOrd`\n+           which is required by `NoDerives: Ord`\n+           `NoDerives: PartialEq`\n+           which is required by `NoDerives: Ord`\n+           `NoDerives: Eq`\n+           which is required by `NoDerives: Ord`\n help: consider annotating `NoDerives` with `#[derive(Eq, Ord, PartialEq, PartialOrd)]`\n    |\n LL | #[derive(Eq, Ord, PartialEq, PartialOrd)]\n@@ -72,7 +93,9 @@ error[E0599]: the method `use_ord_and_partial_ord` exists for struct `Object<NoD\n LL | pub struct NoDerives;\n    | --------------------\n    | |\n+   | doesn't satisfy `NoDerives: Eq`\n    | doesn't satisfy `NoDerives: Ord`\n+   | doesn't satisfy `NoDerives: PartialEq`\n    | doesn't satisfy `NoDerives: PartialOrd`\n LL |\n LL | struct Object<T>(T);\n@@ -91,6 +114,13 @@ LL | impl<T: Ord + PartialOrd> Object<T> {\n    |         |     |\n    |         |     unsatisfied trait bound introduced here\n    |         unsatisfied trait bound introduced here\n+   = note: the following trait bounds were not satisfied:\n+           `NoDerives: PartialEq`\n+           which is required by `NoDerives: Ord`\n+           `NoDerives: Eq`\n+           which is required by `NoDerives: Ord`\n+           `NoDerives: PartialEq`\n+           which is required by `NoDerives: PartialOrd`\n help: consider annotating `NoDerives` with `#[derive(Eq, Ord, PartialEq, PartialOrd)]`\n    |\n LL | #[derive(Eq, Ord, PartialEq, PartialOrd)]"}, {"sha": "55096e95df7e06cee280a39f5f477cf81a108c06", "filename": "tests/ui/did_you_mean/bad-assoc-ty.stderr", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -61,25 +61,45 @@ error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:1:10\n    |\n LL | type A = [u8; 4]::AssocTy;\n-   |          ^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<[u8; 4] as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `[u8; 4]`, you could use the fully-qualified path\n+   |\n+LL | type A = <[u8; 4] as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:5:10\n    |\n LL | type B = [u8]::AssocTy;\n-   |          ^^^^^^^^^^^^^ help: use fully-qualified syntax: `<[u8] as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `[u8]`, you could use the fully-qualified path\n+   |\n+LL | type B = <[u8] as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:9:10\n    |\n LL | type C = (u8)::AssocTy;\n-   |          ^^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `u8`, you could use the fully-qualified path\n+   |\n+LL | type C = <u8 as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:13:10\n    |\n LL | type D = (u8, u8)::AssocTy;\n-   |          ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<(u8, u8) as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `(u8, u8)`, you could use the fully-qualified path\n+   |\n+LL | type D = <(u8, u8) as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for type aliases\n   --> $DIR/bad-assoc-ty.rs:17:10\n@@ -91,13 +111,23 @@ error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:21:19\n    |\n LL | type F = &'static (u8)::AssocTy;\n-   |                   ^^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+   |                   ^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `u8`, you could use the fully-qualified path\n+   |\n+LL | type F = &'static <u8 as Example>::AssocTy;\n+   |                   ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:27:10\n    |\n LL | type G = dyn 'static + (Send)::AssocTy;\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<(dyn Send + 'static) as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `(dyn Send + 'static)`, you could use the fully-qualified path\n+   |\n+LL | type G = <(dyn Send + 'static) as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n warning: trait objects without an explicit `dyn` are deprecated\n   --> $DIR/bad-assoc-ty.rs:33:10\n@@ -117,24 +147,33 @@ error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:33:10\n    |\n LL | type H = Fn(u8) -> (u8)::Output;\n-   |          ^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<(dyn Fn(u8) -> u8 + 'static) as Trait>::Output`\n+   |          ^^^^^^^^^^^^^^^^^^^^^^ help: use the fully-qualified path: `<(dyn Fn(u8) -> u8 + 'static) as IntoFuture>::Output`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:39:19\n    |\n LL |     ($ty: ty) => ($ty::AssocTy);\n-   |                   ^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+   |                   ^^^^^^^^^^^^\n ...\n LL | type J = ty!(u8);\n    |          ------- in this macro invocation\n    |\n    = note: this error originates in the macro `ty` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `u8`, you could use the fully-qualified path\n+   |\n+LL |     ($ty: ty) => (<u8 as Example>::AssocTy);\n+   |                   ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:46:10\n    |\n LL | type I = ty!()::AssocTy;\n-   |          ^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `u8`, you could use the fully-qualified path\n+   |\n+LL | type I = <u8 as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/bad-assoc-ty.rs:51:13"}, {"sha": "60e9de90332cc381dff3058e401659ece13e34f4", "filename": "tests/ui/dst/dst-sized-trait-param.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fdst%2Fdst-sized-trait-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fdst%2Fdst-sized-trait-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdst%2Fdst-sized-trait-param.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -16,10 +16,10 @@ LL | trait Foo<T: ?Sized> : Sized { fn take(self, x: &T) { } } // Note: T is siz\n    |            ++++++++\n \n error[E0277]: the size for values of type `[usize]` cannot be known at compilation time\n-  --> $DIR/dst-sized-trait-param.rs:10:6\n+  --> $DIR/dst-sized-trait-param.rs:10:21\n    |\n LL | impl Foo<isize> for [usize] { }\n-   |      ^^^^^^^^^^ doesn't have a size known at compile-time\n+   |                     ^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[usize]`\n note: required by a bound in `Foo`"}, {"sha": "2fe252de256650cf5b67b00bd1e0a28c7557572d", "filename": "tests/ui/error-codes/E0223.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Ferror-codes%2FE0223.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Ferror-codes%2FE0223.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0223.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,4 +1,8 @@\n trait MyTrait { type X; }\n+struct MyStruct;\n+impl MyTrait for MyStruct {\n+    type X = ();\n+}\n \n fn main() {\n     let foo: MyTrait::X;"}, {"sha": "42945e42f6ea1c682884a60c3e92c671964a0dcc", "filename": "tests/ui/error-codes/E0223.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Ferror-codes%2FE0223.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Ferror-codes%2FE0223.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0223.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,8 +1,8 @@\n error[E0223]: ambiguous associated type\n-  --> $DIR/E0223.rs:4:14\n+  --> $DIR/E0223.rs:8:14\n    |\n LL |     let foo: MyTrait::X;\n-   |              ^^^^^^^^^^ help: use fully-qualified syntax: `<Type as MyTrait>::X`\n+   |              ^^^^^^^^^^ help: use the fully-qualified path: `<MyStruct as MyTrait>::X`\n \n error: aborting due to previous error\n "}, {"sha": "3a8a81a73a6cec4a598845accd4d88f6350f0619", "filename": "tests/ui/error-codes/E0308-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Ferror-codes%2FE0308-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Ferror-codes%2FE0308-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0308-2.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,8 +1,8 @@\n error[E0308]: mismatched types\n-  --> $DIR/E0308-2.rs:9:6\n+  --> $DIR/E0308-2.rs:9:13\n    |\n LL | impl Eq for &dyn DynEq {}\n-   |      ^^ lifetime mismatch\n+   |             ^^^^^^^^^^ lifetime mismatch\n    |\n    = note: expected trait `<&dyn DynEq as PartialEq>`\n               found trait `<&(dyn DynEq + 'static) as PartialEq>`"}, {"sha": "9d4ea01152cc9d0374ede99fba3fb24d377a4548", "filename": "tests/ui/functions-closures/fn-help-with-err-generic-is-not-function.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Ffunctions-closures%2Ffn-help-with-err-generic-is-not-function.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Ffunctions-closures%2Ffn-help-with-err-generic-is-not-function.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffunctions-closures%2Ffn-help-with-err-generic-is-not-function.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2,9 +2,12 @@ error[E0412]: cannot find type `T` in this scope\n   --> $DIR/fn-help-with-err-generic-is-not-function.rs:2:13\n    |\n LL | impl Struct<T>\n-   |     -       ^ not found in this scope\n-   |     |\n-   |     help: you might be missing a type parameter: `<T>`\n+   |             ^ not found in this scope\n+   |\n+help: you might be missing a type parameter\n+   |\n+LL | impl<T> Struct<T>\n+   |     +++\n \n error[E0412]: cannot find type `T` in this scope\n   --> $DIR/fn-help-with-err-generic-is-not-function.rs:7:5"}, {"sha": "e5638d90ee8e7a90b7ece6292c4b5627bf1d9a7d", "filename": "tests/ui/generic-associated-types/issue-74824.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fgeneric-associated-types%2Fissue-74824.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fgeneric-associated-types%2Fissue-74824.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fissue-74824.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -17,6 +17,7 @@ LL |     type Copy<T>: Copy = Box<T>;\n    |                          ^^^^^^ the trait `Clone` is not implemented for `T`\n    |\n    = note: required for `Box<T>` to implement `Clone`\n+   = note: required for `<Self as UnsafeCopy>::Copy<T>` to implement `Copy`\n note: required by a bound in `UnsafeCopy::Copy`\n   --> $DIR/issue-74824.rs:6:19\n    |"}, {"sha": "9f669b9a5214b1694bb3c42331ca48480826526f", "filename": "tests/ui/generic-associated-types/missing-bounds.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -23,6 +23,13 @@ LL |         A(self.0 + rhs.0)\n    |\n    = note: expected type parameter `B`\n              found associated type `<B as Add>::Output`\n+help: the type constructed contains `<B as Add>::Output` due to the type of the argument passed\n+  --> $DIR/missing-bounds.rs:11:9\n+   |\n+LL |         A(self.0 + rhs.0)\n+   |         ^^--------------^\n+   |           |\n+   |           this argument influences the type of `A`\n note: tuple struct defined here\n   --> $DIR/missing-bounds.rs:5:8\n    |"}, {"sha": "01515fdc9d2bff7b47479cb52d8db50a0ca79e5d", "filename": "tests/ui/higher-rank-trait-bounds/issue-42114.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-42114.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-42114.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-42114.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+\n+fn lifetime<'a>()\n+where\n+    &'a (): 'a,\n+{\n+    /* do nothing */\n+}\n+\n+fn doesnt_work()\n+where\n+    for<'a> &'a (): 'a,\n+{\n+    /* do nothing */\n+}\n+\n+fn main() {\n+    lifetime();\n+    doesnt_work();\n+}"}, {"sha": "b3ff2ce5a7bfada2b3b20cdadd9dd86f013a2729", "filename": "tests/ui/impl-trait/impl_trait_projections.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.rs?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -11,7 +11,7 @@ fn path_parametrized_type_is_allowed() -> option::Option<impl Debug> {\n \n fn projection_is_disallowed(x: impl Iterator) -> <impl Iterator>::Item {\n //~^ ERROR `impl Trait` is not allowed in path parameters\n-//~^^ ERROR ambiguous associated type\n+//~| ERROR `impl Trait` is not allowed in path parameters\n     x.next().unwrap()\n }\n "}, {"sha": "4deb24731bc030b12c8ca24dc088ee11b3c13297", "filename": "tests/ui/impl-trait/impl_trait_projections.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -22,13 +22,12 @@ error[E0667]: `impl Trait` is not allowed in path parameters\n LL |     -> <dyn Iterator<Item = impl Debug> as Iterator>::Item\n    |                             ^^^^^^^^^^\n \n-error[E0223]: ambiguous associated type\n-  --> $DIR/impl_trait_projections.rs:12:50\n+error[E0667]: `impl Trait` is not allowed in path parameters\n+  --> $DIR/impl_trait_projections.rs:12:51\n    |\n LL | fn projection_is_disallowed(x: impl Iterator) -> <impl Iterator>::Item {\n-   |                                                  ^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<impl Iterator as Trait>::Item`\n+   |                                                   ^^^^^^^^^^^^^\n \n error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0223, E0667.\n-For more information about an error, try `rustc --explain E0223`.\n+For more information about this error, try `rustc --explain E0667`."}, {"sha": "ebe07027d2fa1ba036fd2a950a02b388863f6699", "filename": "tests/ui/implied-bounds/impl-implied-bounds-compatibility-unnormalized.stderr", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,8 +1,8 @@\n error: impl method assumes more implied bounds than the corresponding trait method\n-  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:13:5\n+  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:13:31\n    |\n LL |     fn get<'s>(s: &'s str, _: <&'static &'s () as Project>::Ty) -> &'static str {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `()`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n@@ -14,3 +14,18 @@ LL | #![deny(implied_bounds_entailment)]\n \n error: aborting due to previous error\n \n+Future incompatibility report: Future breakage diagnostic:\n+error: impl method assumes more implied bounds than the corresponding trait method\n+  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:13:31\n+   |\n+LL |     fn get<'s>(s: &'s str, _: <&'static &'s () as Project>::Ty) -> &'static str {\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `()`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n+note: the lint level is defined here\n+  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:1:9\n+   |\n+LL | #![deny(implied_bounds_entailment)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+"}, {"sha": "43d3e058ffeb3f10adc89c2b7a1968f9b781aff1", "filename": "tests/ui/implied-bounds/impl-implied-bounds-compatibility.stderr", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,8 +1,8 @@\n error: impl method assumes more implied bounds than the corresponding trait method\n-  --> $DIR/impl-implied-bounds-compatibility.rs:14:5\n+  --> $DIR/impl-implied-bounds-compatibility.rs:14:35\n    |\n LL |     fn listeners<'b>(&'b self) -> &'a MessageListeners<'b> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `&'b MessageListeners<'b>`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n@@ -14,3 +14,18 @@ LL | #![deny(implied_bounds_entailment)]\n \n error: aborting due to previous error\n \n+Future incompatibility report: Future breakage diagnostic:\n+error: impl method assumes more implied bounds than the corresponding trait method\n+  --> $DIR/impl-implied-bounds-compatibility.rs:14:35\n+   |\n+LL |     fn listeners<'b>(&'b self) -> &'a MessageListeners<'b> {\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `&'b MessageListeners<'b>`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n+note: the lint level is defined here\n+  --> $DIR/impl-implied-bounds-compatibility.rs:1:9\n+   |\n+LL | #![deny(implied_bounds_entailment)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+"}, {"sha": "888c321bc479b8269d1c87b8a22fa8ca7a6be61f", "filename": "tests/ui/inference/cannot-infer-partial-try-return.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,8 +1,6 @@\n error[E0282]: type annotations needed\n   --> $DIR/cannot-infer-partial-try-return.rs:20:9\n    |\n-LL |         infallible()?;\n-   |         ------------- type must be known at this point\n LL |         Ok(())\n    |         ^^ cannot infer type of the type parameter `E` declared on the enum `Result`\n    |"}, {"sha": "a9cb7e5257c83d1db6c8fa8df7e3a1fed7811586", "filename": "tests/ui/inference/question-mark-type-infer.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Finference%2Fquestion-mark-type-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Finference%2Fquestion-mark-type-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Fquestion-mark-type-infer.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,8 +1,13 @@\n error[E0282]: type annotations needed\n-  --> $DIR/question-mark-type-infer.rs:10:30\n+  --> $DIR/question-mark-type-infer.rs:10:21\n    |\n LL |     l.iter().map(f).collect()?\n-   |                              ^ cannot infer type\n+   |                     ^^^^^^^ cannot infer type of the type parameter `B` declared on the associated function `collect`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |     l.iter().map(f).collect::<Vec<_>>()?\n+   |                            ++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "3a9f49ef167d692d6fe7feed84623e5c1b3a8f9e", "filename": "tests/ui/issues/issue-23073.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fissues%2Fissue-23073.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fissues%2Fissue-23073.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-23073.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2,7 +2,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/issue-23073.rs:6:17\n    |\n LL |     type FooT = <<Self as Bar>::Foo>::T;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<<Self as Bar>::Foo as Trait>::T`\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `T` implemented for `<Self as Bar>::Foo`, you could use the fully-qualified path\n+   |\n+LL |     type FooT = <<Self as Bar>::Foo as Example>::T;\n+   |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "f4bd4d1e826a0d16224a5b76fe79c36e957fd590", "filename": "tests/ui/issues/issue-58712.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fissues%2Fissue-58712.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fissues%2Fissue-58712.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-58712.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2,9 +2,12 @@ error[E0412]: cannot find type `DeviceId` in this scope\n   --> $DIR/issue-58712.rs:6:20\n    |\n LL | impl<H> AddrVec<H, DeviceId> {\n-   |       -            ^^^^^^^^ not found in this scope\n-   |       |\n-   |       help: you might be missing a type parameter: `, DeviceId`\n+   |                    ^^^^^^^^ not found in this scope\n+   |\n+help: you might be missing a type parameter\n+   |\n+LL | impl<H, DeviceId> AddrVec<H, DeviceId> {\n+   |       ++++++++++\n \n error[E0412]: cannot find type `DeviceId` in this scope\n   --> $DIR/issue-58712.rs:8:29"}, {"sha": "7ccab88948371bd63ec4885fd722919f8736c518", "filename": "tests/ui/issues/issue-65230.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fissues%2Fissue-65230.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fissues%2Fissue-65230.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-65230.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,8 +1,8 @@\n error[E0308]: mismatched types\n-  --> $DIR/issue-65230.rs:8:6\n+  --> $DIR/issue-65230.rs:8:13\n    |\n LL | impl T1 for &dyn T2 {}\n-   |      ^^ lifetime mismatch\n+   |             ^^^^^^^ lifetime mismatch\n    |\n    = note: expected trait `<&dyn T2 as T0>`\n               found trait `<&(dyn T2 + 'static) as T0>`"}, {"sha": "fc343bb54aace29f40aa5fd3cd5e87a2497de3e3", "filename": "tests/ui/issues/issue-69455.stderr", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fissues%2Fissue-69455.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fissues%2Fissue-69455.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-69455.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -1,14 +1,16 @@\n-error[E0282]: type annotations needed\n-  --> $DIR/issue-69455.rs:29:20\n+error[E0284]: type annotations needed\n+  --> $DIR/issue-69455.rs:29:41\n    |\n LL |     println!(\"{}\", 23u64.test(xs.iter().sum()));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the associated function `new_display`\n+   |                          ----           ^^^ cannot infer type of the type parameter `S` declared on the associated function `sum`\n+   |                          |\n+   |                          type must be known at this point\n    |\n-   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: cannot satisfy `<u64 as Test<_>>::Output == _`\n help: consider specifying the generic argument\n    |\n-LL |     println!(\"{}\", 23u64.test(xs.iter().sum())::<T>);\n-   |                                               +++++\n+LL |     println!(\"{}\", 23u64.test(xs.iter().sum::<S>()));\n+   |                                            +++++\n \n error[E0283]: type annotations needed\n   --> $DIR/issue-69455.rs:29:41\n@@ -33,5 +35,5 @@ LL |     println!(\"{}\", 23u64.test(xs.iter().sum::<S>()));\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0282, E0283.\n-For more information about an error, try `rustc --explain E0282`.\n+Some errors have detailed explanations: E0283, E0284.\n+For more information about an error, try `rustc --explain E0283`."}, {"sha": "d154bfe0cb553daec484377669b5cfec1693e8b5", "filename": "tests/ui/issues/issue-77919.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fissues%2Fissue-77919.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fissues%2Fissue-77919.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-77919.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -13,9 +13,12 @@ error[E0412]: cannot find type `VAL` in this scope\n   --> $DIR/issue-77919.rs:11:63\n    |\n LL | impl<N, M> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n-   |          -                                                    ^^^ not found in this scope\n-   |          |\n-   |          help: you might be missing a type parameter: `, VAL`\n+   |                                                               ^^^ not found in this scope\n+   |\n+help: you might be missing a type parameter\n+   |\n+LL | impl<N, M, VAL> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n+   |          +++++\n \n error[E0046]: not all trait items implemented, missing: `VAL`\n   --> $DIR/issue-77919.rs:11:1"}, {"sha": "70daf8a2f1a6475b2ed53dbaf7fba87283829b8d", "filename": "tests/ui/issues/issue-78622.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fissues%2Fissue-78622.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fissues%2Fissue-78622.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-78622.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -2,7 +2,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/issue-78622.rs:5:5\n    |\n LL |     S::A::<f> {}\n-   |     ^^^^ help: use fully-qualified syntax: `<S as Trait>::A`\n+   |     ^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `A` implemented for `S`, you could use the fully-qualified path\n+   |\n+LL |     <S as Example>::A::<f> {}\n+   |     ~~~~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "bfa7459ab4a39088bb377be499d24dfce7b3b1a0", "filename": "tests/ui/issues/issue-86756.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fissues%2Fissue-86756.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Fissues%2Fissue-86756.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-86756.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -9,8 +9,6 @@ LL | trait Foo<T, T = T> {}\n error[E0412]: cannot find type `dyn` in this scope\n   --> $DIR/issue-86756.rs:5:10\n    |\n-LL | fn eq<A, B>() {\n-   |           - help: you might be missing a type parameter: `, dyn`\n LL |     eq::<dyn, Foo>\n    |          ^^^ not found in this scope\n "}, {"sha": "65c99a93c75112a5fb9a9caeabc09720dc8c4d25", "filename": "tests/ui/lang-items/start_lang_item_args.argc.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.argc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.argc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flang-items%2Fstart_lang_item_args.argc.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,8 @@\n+error: parameter 2 of the `start` lang item is incorrect\n+  --> $DIR/start_lang_item_args.rs:75:38\n+   |\n+LL | fn start<T>(_main: fn() -> T, _argc: i8, _argv: *const *const u8, _sigpipe: u8) -> isize {\n+   |                                      ^^ help: change the type from `i8` to `isize`\n+\n+error: aborting due to previous error\n+"}, {"sha": "f0947a9b3e933afa8682e61c2919a9b09159c0d6", "filename": "tests/ui/lang-items/start_lang_item_args.argv.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.argv.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.argv.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flang-items%2Fstart_lang_item_args.argv.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,8 @@\n+error: parameter 3 of the `start` lang item is incorrect\n+  --> $DIR/start_lang_item_args.rs:89:52\n+   |\n+LL | fn start<T>(_main: fn() -> T, _argc: isize, _argv: u8, _sigpipe: u8) -> isize {\n+   |                                                    ^^ help: change the type from `u8` to `*const *const u8`\n+\n+error: aborting due to previous error\n+"}, {"sha": "08efd5088f99b424228d4c5a84d7912853ebb76b", "filename": "tests/ui/lang-items/start_lang_item_args.argv_inner_ptr.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.argv_inner_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.argv_inner_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flang-items%2Fstart_lang_item_args.argv_inner_ptr.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,13 @@\n+error: parameter 3 of the `start` lang item is incorrect\n+  --> $DIR/start_lang_item_args.rs:82:52\n+   |\n+LL | fn start<T>(_main: fn() -> T, _argc: isize, _argv: *const *const usize, _sigpipe: u8) -> isize {\n+   |                                                    ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: change the type from `*const *const usize` to `*const *const u8`\n+   |\n+LL | fn start<T>(_main: fn() -> T, _argc: isize, _argv: *const *const u8, _sigpipe: u8) -> isize {\n+   |                                                    ~~~~~~~~~~~~~~~~\n+\n+error: aborting due to previous error\n+"}, {"sha": "c20a744661d495146c77dd9cd089814f10b8cd1f", "filename": "tests/ui/lang-items/start_lang_item_args.main_args.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.main_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.main_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flang-items%2Fstart_lang_item_args.main_args.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,13 @@\n+error: parameter 1 of the `start` lang item is incorrect\n+  --> $DIR/start_lang_item_args.rs:61:20\n+   |\n+LL | fn start<T>(_main: fn(i32) -> T, _argc: isize, _argv: *const *const u8, _sigpipe: u8) -> isize {\n+   |                    ^^^^^^^^^^^^\n+   |\n+help: change the type from `fn(i32) -> T` to `fn() -> T`\n+   |\n+LL | fn start<T>(_main: fn() -> T, _argc: isize, _argv: *const *const u8, _sigpipe: u8) -> isize {\n+   |                    ~~~~~~~~~\n+\n+error: aborting due to previous error\n+"}, {"sha": "8f967252f49bec92057907697b12002b30cd5603", "filename": "tests/ui/lang-items/start_lang_item_args.main_ret.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.main_ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.main_ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flang-items%2Fstart_lang_item_args.main_ret.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,13 @@\n+error: parameter 1 of the `start` lang item is incorrect\n+  --> $DIR/start_lang_item_args.rs:68:20\n+   |\n+LL | fn start<T>(_main: fn() -> u16, _argc: isize, _argv: *const *const u8, _sigpipe: u8) -> isize {\n+   |                    ^^^^^^^^^^^\n+   |\n+help: change the type from `fn() -> u16` to `fn() -> T`\n+   |\n+LL | fn start<T>(_main: fn() -> T, _argc: isize, _argv: *const *const u8, _sigpipe: u8) -> isize {\n+   |                    ~~~~~~~~~\n+\n+error: aborting due to previous error\n+"}, {"sha": "deb37b868ea89c59c6b9b36e4dcf8f26b9080148", "filename": "tests/ui/lang-items/start_lang_item_args.main_ty.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.main_ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.main_ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flang-items%2Fstart_lang_item_args.main_ty.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,8 @@\n+error: parameter 1 of the `start` lang item is incorrect\n+  --> $DIR/start_lang_item_args.rs:54:20\n+   |\n+LL | fn start<T>(_main: u64, _argc: isize, _argv: *const *const u8, _sigpipe: u8) -> isize {\n+   |                    ^^^ help: change the type from `u64` to `fn() -> T`\n+\n+error: aborting due to previous error\n+"}, {"sha": "004c2a67f62f19fea0294a477b10c0d7305d1c95", "filename": "tests/ui/lang-items/start_lang_item_args.missing_all_args.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.missing_all_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.missing_all_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flang-items%2Fstart_lang_item_args.missing_all_args.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,11 @@\n+error: incorrect number of parameters for the `start` lang item\n+  --> $DIR/start_lang_item_args.rs:15:1\n+   |\n+LL | fn start<T>() -> isize {\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `start` lang item should have four parameters, but found 0\n+   = note: the `start` lang item should have the signature `fn(fn() -> T, isize, *const *const u8, u8) -> isize`\n+\n+error: aborting due to previous error\n+"}, {"sha": "1d8285b59000aa5f59835af7aedf3f3e38f4034b", "filename": "tests/ui/lang-items/start_lang_item_args.missing_ret.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.missing_ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59d3572bd6514e38ec5d2dfc3b524274074653d3/tests%2Fui%2Flang-items%2Fstart_lang_item_args.missing_ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flang-items%2Fstart_lang_item_args.missing_ret.stderr?ref=59d3572bd6514e38ec5d2dfc3b524274074653d3", "patch": "@@ -0,0 +1,8 @@\n+error: the return type of the `start` lang item is incorrect\n+  --> $DIR/start_lang_item_args.rs:29:84\n+   |\n+LL | fn start<T>(_main: fn() -> T, _argc: isize, _argv: *const *const u8, _sigpipe: u8) {}\n+   |                                                                                    ^ help: change the type from `()` to `isize`\n+\n+error: aborting due to previous error\n+"}]}