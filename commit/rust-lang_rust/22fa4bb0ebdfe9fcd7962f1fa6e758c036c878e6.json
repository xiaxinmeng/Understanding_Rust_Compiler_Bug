{"sha": "22fa4bb0ebdfe9fcd7962f1fa6e758c036c878e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZmE0YmIwZWJkZmU5ZmNkNzk2MmYxZmE2ZTc1OGMwMzZjODc4ZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-19T09:57:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-19T09:57:26Z"}, "message": "Auto merge of #60063 - spastorino:place2_2, r=oli-obk\n\nConvert Place unroll to a proper iterator\n\nr? @oli-obk", "tree": {"sha": "519d99f4c120a338fe25cab86c8d794996e6c8a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/519d99f4c120a338fe25cab86c8d794996e6c8a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22fa4bb0ebdfe9fcd7962f1fa6e758c036c878e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22fa4bb0ebdfe9fcd7962f1fa6e758c036c878e6", "html_url": "https://github.com/rust-lang/rust/commit/22fa4bb0ebdfe9fcd7962f1fa6e758c036c878e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22fa4bb0ebdfe9fcd7962f1fa6e758c036c878e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c22051411208f8f54bd1d85377c327a1e949712", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c22051411208f8f54bd1d85377c327a1e949712", "html_url": "https://github.com/rust-lang/rust/commit/6c22051411208f8f54bd1d85377c327a1e949712"}, {"sha": "0a386baa5f27270012f262881a62b75d1a115a82", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a386baa5f27270012f262881a62b75d1a115a82", "html_url": "https://github.com/rust-lang/rust/commit/0a386baa5f27270012f262881a62b75d1a115a82"}], "stats": {"total": 552, "additions": 298, "deletions": 254}, "files": [{"sha": "b4f63d9a40cdfbe43308435f970cc1a44006fc2e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/22fa4bb0ebdfe9fcd7962f1fa6e758c036c878e6/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22fa4bb0ebdfe9fcd7962f1fa6e758c036c878e6/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=22fa4bb0ebdfe9fcd7962f1fa6e758c036c878e6", "patch": "@@ -20,6 +20,7 @@ use crate::rustc_serialize::{self as serialize};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Formatter, Write};\n+use std::iter::FusedIterator;\n use std::ops::{Index, IndexMut};\n use std::slice;\n use std::vec::IntoIter;\n@@ -2058,8 +2059,101 @@ impl<'tcx> Place<'tcx> {\n             Place::Base(PlaceBase::Static(..)) => None,\n         }\n     }\n+\n+    /// Recursively \"iterates\" over place components, generating a `PlaceBase` and\n+    /// `PlaceProjections` list and invoking `op` with a `PlaceProjectionsIter`.\n+    pub fn iterate<R>(\n+        &self,\n+        op: impl FnOnce(&PlaceBase<'tcx>, PlaceProjectionsIter<'_, 'tcx>) -> R,\n+    ) -> R {\n+        self.iterate2(&PlaceProjections::Empty, op)\n+    }\n+\n+    fn iterate2<R>(\n+        &self,\n+        next: &PlaceProjections<'_, 'tcx>,\n+        op: impl FnOnce(&PlaceBase<'tcx>, PlaceProjectionsIter<'_, 'tcx>) -> R,\n+    ) -> R {\n+        match self {\n+            Place::Projection(interior) => interior.base.iterate2(\n+                &PlaceProjections::List {\n+                    projection: interior,\n+                    next,\n+                },\n+                op,\n+            ),\n+\n+            Place::Base(base) => op(base, next.iter()),\n+        }\n+    }\n+}\n+\n+/// A linked list of projections running up the stack; begins with the\n+/// innermost projection and extends to the outermost (e.g., `a.b.c`\n+/// would have the place `b` with a \"next\" pointer to `b.c`).\n+/// Created by `Place::iterate`.\n+///\n+/// N.B., this particular impl strategy is not the most obvious. It was\n+/// chosen because it makes a measurable difference to NLL\n+/// performance, as this code (`borrow_conflicts_with_place`) is somewhat hot.\n+pub enum PlaceProjections<'p, 'tcx: 'p> {\n+    Empty,\n+\n+    List {\n+        projection: &'p PlaceProjection<'tcx>,\n+        next: &'p PlaceProjections<'p, 'tcx>,\n+    }\n+}\n+\n+impl<'p, 'tcx> PlaceProjections<'p, 'tcx> {\n+    fn iter(&self) -> PlaceProjectionsIter<'_, 'tcx> {\n+        PlaceProjectionsIter { value: self }\n+    }\n }\n \n+impl<'p, 'tcx> IntoIterator for &'p PlaceProjections<'p, 'tcx> {\n+    type Item = &'p PlaceProjection<'tcx>;\n+    type IntoIter = PlaceProjectionsIter<'p, 'tcx>;\n+\n+    /// Converts a list of `PlaceProjection` components into an iterator;\n+    /// this iterator yields up a never-ending stream of `Option<&Place>`.\n+    /// These begin with the \"innermost\" projection and then with each\n+    /// projection therefrom. So given a place like `a.b.c` it would\n+    /// yield up:\n+    ///\n+    /// ```notrust\n+    /// Some(`a`), Some(`a.b`), Some(`a.b.c`), None, None, ...\n+    /// ```\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.iter()\n+    }\n+}\n+\n+/// Iterator over components; see `PlaceProjections::iter` for more\n+/// information.\n+///\n+/// N.B., this is not a *true* Rust iterator -- the code above just\n+/// manually invokes `next`. This is because we (sometimes) want to\n+/// keep executing even after `None` has been returned.\n+pub struct PlaceProjectionsIter<'p, 'tcx: 'p> {\n+    pub value: &'p PlaceProjections<'p, 'tcx>,\n+}\n+\n+impl<'p, 'tcx> Iterator for PlaceProjectionsIter<'p, 'tcx> {\n+    type Item = &'p PlaceProjection<'tcx>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let &PlaceProjections::List { projection, next } = self.value {\n+            self.value = next;\n+            Some(projection)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'p, 'tcx> FusedIterator for PlaceProjectionsIter<'p, 'tcx> {}\n+\n impl<'tcx> Debug for Place<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         use self::Place::*;"}, {"sha": "cebf05ad9b99df2047b590f9e46e2dc7687247c5", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 204, "deletions": 254, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/22fa4bb0ebdfe9fcd7962f1fa6e758c036c878e6/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22fa4bb0ebdfe9fcd7962f1fa6e758c036c878e6/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=22fa4bb0ebdfe9fcd7962f1fa6e758c036c878e6", "patch": "@@ -2,7 +2,10 @@ use crate::borrow_check::ArtificialField;\n use crate::borrow_check::Overlap;\n use crate::borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n-use rustc::mir::{BorrowKind, Mir, Place, PlaceBase, Projection, ProjectionElem, StaticKind};\n+use rustc::mir::{\n+    BorrowKind, Mir, Place, PlaceBase, PlaceProjection, ProjectionElem, PlaceProjectionsIter,\n+    StaticKind\n+};\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n \n@@ -65,14 +68,14 @@ pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n         }\n     }\n \n-    unroll_place(borrow_place, None, |borrow_components| {\n-        unroll_place(access_place, None, |access_components| {\n+    borrow_place.iterate(|borrow_base, borrow_projections| {\n+        access_place.iterate(|access_base, access_projections| {\n             place_components_conflict(\n                 tcx,\n                 mir,\n-                borrow_components,\n+                (borrow_base, borrow_projections),\n                 borrow_kind,\n-                access_components,\n+                (access_base, access_projections),\n                 access,\n                 bias,\n             )\n@@ -83,9 +86,9 @@ pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n fn place_components_conflict<'gcx, 'tcx>(\n     tcx: TyCtxt<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    mut borrow_components: PlaceComponentsIter<'_, 'tcx>,\n+    borrow_projections: (&PlaceBase<'tcx>, PlaceProjectionsIter<'_, 'tcx>),\n     borrow_kind: BorrowKind,\n-    mut access_components: PlaceComponentsIter<'_, 'tcx>,\n+    access_projections: (&PlaceBase<'tcx>, PlaceProjectionsIter<'_, 'tcx>),\n     access: AccessDepth,\n     bias: PlaceConflictBias,\n ) -> bool {\n@@ -130,12 +133,34 @@ fn place_components_conflict<'gcx, 'tcx>(\n     //  - If we didn't run out of access to match, our borrow and access are comparable\n     //    and either equal or disjoint.\n     //  - If we did run out of access, the borrow can access a part of it.\n+\n+    let borrow_base = borrow_projections.0;\n+    let access_base = access_projections.0;\n+\n+    match place_base_conflict(tcx, borrow_base, access_base) {\n+        Overlap::Arbitrary => {\n+            bug!(\"Two base can't return Arbitrary\");\n+        }\n+        Overlap::EqualOrDisjoint => {\n+            // This is the recursive case - proceed to the next element.\n+        }\n+        Overlap::Disjoint => {\n+            // We have proven the borrow disjoint - further\n+            // projections will remain disjoint.\n+            debug!(\"borrow_conflicts_with_place: disjoint\");\n+            return false;\n+        }\n+    }\n+\n+    let mut borrow_projections = borrow_projections.1;\n+    let mut access_projections = access_projections.1;\n+\n     loop {\n         // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n-        if let Some(borrow_c) = borrow_components.next() {\n+        if let Some(borrow_c) = borrow_projections.next() {\n             debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n \n-            if let Some(access_c) = access_components.next() {\n+            if let Some(access_c) = access_projections.next() {\n                 debug!(\"borrow_conflicts_with_place: access_c = {:?}\", access_c);\n \n                 // Borrow and access path both have more components.\n@@ -150,7 +175,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                 // check whether the components being borrowed vs\n                 // accessed are disjoint (as in the second example,\n                 // but not the first).\n-                match place_element_conflict(tcx, mir, borrow_c, access_c, bias) {\n+                match place_projection_conflict(tcx, mir, borrow_c, access_c, bias) {\n                     Overlap::Arbitrary => {\n                         // We have encountered different fields of potentially\n                         // the same union - the borrow now partially overlaps.\n@@ -187,10 +212,8 @@ fn place_components_conflict<'gcx, 'tcx>(\n                 // our place. This is a conflict if that is a part our\n                 // access cares about.\n \n-                let (base, elem) = match borrow_c {\n-                    Place::Projection(box Projection { base, elem }) => (base, elem),\n-                    _ => bug!(\"place has no base?\"),\n-                };\n+                let base = &borrow_c.base;\n+                let elem = &borrow_c.elem;\n                 let base_ty = base.ty(mir, tcx).ty;\n \n                 match (elem, &base_ty.sty, access) {\n@@ -261,7 +284,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n             // If the second example, where we did, then we still know\n             // that the borrow can access a *part* of our place that\n             // our access cares about, so we still have a conflict.\n-            if borrow_kind == BorrowKind::Shallow && access_components.next().is_some() {\n+            if borrow_kind == BorrowKind::Shallow && access_projections.next().is_some() {\n                 debug!(\"borrow_conflicts_with_place: shallow borrow\");\n                 return false;\n             } else {\n@@ -272,94 +295,16 @@ fn place_components_conflict<'gcx, 'tcx>(\n     }\n }\n \n-/// A linked list of places running up the stack; begins with the\n-/// innermost place and extends to projections (e.g., `a.b` would have\n-/// the place `a` with a \"next\" pointer to `a.b`). Created by\n-/// `unroll_place`.\n-///\n-/// N.B., this particular impl strategy is not the most obvious. It was\n-/// chosen because it makes a measurable difference to NLL\n-/// performance, as this code (`borrow_conflicts_with_place`) is somewhat hot.\n-struct PlaceComponents<'p, 'tcx: 'p> {\n-    component: &'p Place<'tcx>,\n-    next: Option<&'p PlaceComponents<'p, 'tcx>>,\n-}\n-\n-impl<'p, 'tcx> PlaceComponents<'p, 'tcx> {\n-    /// Converts a list of `Place` components into an iterator; this\n-    /// iterator yields up a never-ending stream of `Option<&Place>`.\n-    /// These begin with the \"innermost\" place and then with each\n-    /// projection therefrom. So given a place like `a.b.c` it would\n-    /// yield up:\n-    ///\n-    /// ```notrust\n-    /// Some(`a`), Some(`a.b`), Some(`a.b.c`), None, None, ...\n-    /// ```\n-    fn iter(&self) -> PlaceComponentsIter<'_, 'tcx> {\n-        PlaceComponentsIter { value: Some(self) }\n-    }\n-}\n-\n-/// Iterator over components; see `PlaceComponents::iter` for more\n-/// information.\n-///\n-/// N.B., this is not a *true* Rust iterator -- the code above just\n-/// manually invokes `next`. This is because we (sometimes) want to\n-/// keep executing even after `None` has been returned.\n-struct PlaceComponentsIter<'p, 'tcx: 'p> {\n-    value: Option<&'p PlaceComponents<'p, 'tcx>>,\n-}\n-\n-impl<'p, 'tcx> PlaceComponentsIter<'p, 'tcx> {\n-    fn next(&mut self) -> Option<&'p Place<'tcx>> {\n-        if let Some(&PlaceComponents { component, next }) = self.value {\n-            self.value = next;\n-            Some(component)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// Recursively \"unroll\" a place into a `PlaceComponents` list,\n-/// invoking `op` with a `PlaceComponentsIter`.\n-fn unroll_place<'tcx, R>(\n-    place: &Place<'tcx>,\n-    next: Option<&PlaceComponents<'_, 'tcx>>,\n-    op: impl FnOnce(PlaceComponentsIter<'_, 'tcx>) -> R,\n-) -> R {\n-    match place {\n-        Place::Projection(interior) => unroll_place(\n-            &interior.base,\n-            Some(&PlaceComponents {\n-                component: place,\n-                next,\n-            }),\n-            op,\n-        ),\n-\n-        Place::Base(PlaceBase::Local(_)) | Place::Base(PlaceBase::Static(_)) => {\n-            let list = PlaceComponents {\n-                component: place,\n-                next,\n-            };\n-            op(list.iter())\n-        }\n-    }\n-}\n-\n // Given that the bases of `elem1` and `elem2` are always either equal\n // or disjoint (and have the same type!), return the overlap situation\n // between `elem1` and `elem2`.\n-fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n+fn place_base_conflict<'a, 'gcx: 'tcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n-    elem1: &Place<'tcx>,\n-    elem2: &Place<'tcx>,\n-    bias: PlaceConflictBias,\n+    elem1: &PlaceBase<'tcx>,\n+    elem2: &PlaceBase<'tcx>,\n ) -> Overlap {\n     match (elem1, elem2) {\n-        (Place::Base(PlaceBase::Local(l1)), Place::Base(PlaceBase::Local(l2))) => {\n+        (PlaceBase::Local(l1), PlaceBase::Local(l2)) => {\n             if l1 == l2 {\n                 // the same local - base case, equal\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n@@ -370,7 +315,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 Overlap::Disjoint\n             }\n         }\n-        (Place::Base(PlaceBase::Static(s1)), Place::Base(PlaceBase::Static(s2))) => {\n+        (PlaceBase::Static(s1), PlaceBase::Static(s2)) => {\n             match (&s1.kind, &s2.kind) {\n                 (StaticKind::Static(def_id_1), StaticKind::Static(def_id_2)) => {\n                     if def_id_1 != def_id_2 {\n@@ -409,174 +354,179 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 }\n             }\n         }\n-        (Place::Base(PlaceBase::Local(_)), Place::Base(PlaceBase::Static(_))) |\n-        (Place::Base(PlaceBase::Static(_)), Place::Base(PlaceBase::Local(_))) => {\n+        (PlaceBase::Local(_), PlaceBase::Static(_)) |\n+        (PlaceBase::Static(_), PlaceBase::Local(_)) => {\n             debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL-PROMOTED\");\n             Overlap::Disjoint\n         }\n-        (Place::Projection(pi1), Place::Projection(pi2)) => {\n-            match (&pi1.elem, &pi2.elem) {\n-                (ProjectionElem::Deref, ProjectionElem::Deref) => {\n-                    // derefs (e.g., `*x` vs. `*x`) - recur.\n-                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n-                    Overlap::EqualOrDisjoint\n-                }\n-                (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n-                    if f1 == f2 {\n-                        // same field (e.g., `a.y` vs. `a.y`) - recur.\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n-                        Overlap::EqualOrDisjoint\n-                    } else {\n-                        let ty = pi1.base.ty(mir, tcx).ty;\n-                        match ty.sty {\n-                            ty::Adt(def, _) if def.is_union() => {\n-                                // Different fields of a union, we are basically stuck.\n-                                debug!(\"place_element_conflict: STUCK-UNION\");\n-                                Overlap::Arbitrary\n-                            }\n-                            _ => {\n-                                // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n-                                debug!(\"place_element_conflict: DISJOINT-FIELD\");\n-                                Overlap::Disjoint\n-                            }\n-                        }\n+    }\n+}\n+\n+// Given that the bases of `elem1` and `elem2` are always either equal\n+// or disjoint (and have the same type!), return the overlap situation\n+// between `elem1` and `elem2`.\n+fn place_projection_conflict<'a, 'gcx: 'tcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    pi1: &PlaceProjection<'tcx>,\n+    pi2: &PlaceProjection<'tcx>,\n+    bias: PlaceConflictBias,\n+) -> Overlap {\n+    match (&pi1.elem, &pi2.elem) {\n+        (ProjectionElem::Deref, ProjectionElem::Deref) => {\n+            // derefs (e.g., `*x` vs. `*x`) - recur.\n+            debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n+            Overlap::EqualOrDisjoint\n+        }\n+        (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n+            if f1 == f2 {\n+                // same field (e.g., `a.y` vs. `a.y`) - recur.\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                let ty = pi1.base.ty(mir, tcx).ty;\n+                match ty.sty {\n+                    ty::Adt(def, _) if def.is_union() => {\n+                        // Different fields of a union, we are basically stuck.\n+                        debug!(\"place_element_conflict: STUCK-UNION\");\n+                        Overlap::Arbitrary\n                     }\n-                }\n-                (ProjectionElem::Downcast(_, v1), ProjectionElem::Downcast(_, v2)) => {\n-                    // different variants are treated as having disjoint fields,\n-                    // even if they occupy the same \"space\", because it's\n-                    // impossible for 2 variants of the same enum to exist\n-                    // (and therefore, to be borrowed) at the same time.\n-                    //\n-                    // Note that this is different from unions - we *do* allow\n-                    // this code to compile:\n-                    //\n-                    // ```\n-                    // fn foo(x: &mut Result<i32, i32>) {\n-                    //     let mut v = None;\n-                    //     if let Ok(ref mut a) = *x {\n-                    //         v = Some(a);\n-                    //     }\n-                    //     // here, you would *think* that the\n-                    //     // *entirety* of `x` would be borrowed,\n-                    //     // but in fact only the `Ok` variant is,\n-                    //     // so the `Err` variant is *entirely free*:\n-                    //     if let Err(ref mut a) = *x {\n-                    //         v = Some(a);\n-                    //     }\n-                    //     drop(v);\n-                    // }\n-                    // ```\n-                    if v1 == v2 {\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n-                        Overlap::EqualOrDisjoint\n-                    } else {\n+                    _ => {\n+                        // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n                         debug!(\"place_element_conflict: DISJOINT-FIELD\");\n                         Overlap::Disjoint\n                     }\n                 }\n-                (ProjectionElem::Index(..), ProjectionElem::Index(..))\n-                | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n-                | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n-                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n-                | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..)) => {\n-                    // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n-                    // (if the indexes differ) or equal (if they are the same).\n-                    match bias {\n-                        PlaceConflictBias::Overlap => {\n-                            // If we are biased towards overlapping, then this is the recursive\n-                            // case that gives \"equal *or* disjoint\" its meaning.\n-                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-INDEX\");\n-                            Overlap::EqualOrDisjoint\n-                        }\n-                        PlaceConflictBias::NoOverlap => {\n-                            // If we are biased towards no overlapping, then this is disjoint.\n-                            debug!(\"place_element_conflict: DISJOINT-ARRAY-INDEX\");\n-                            Overlap::Disjoint\n-                        }\n-                    }\n-                }\n-                (ProjectionElem::ConstantIndex { offset: o1, min_length: _, from_end: false },\n-                    ProjectionElem::ConstantIndex { offset: o2, min_length: _, from_end: false })\n-                | (ProjectionElem::ConstantIndex { offset: o1, min_length: _, from_end: true },\n-                    ProjectionElem::ConstantIndex {\n-                        offset: o2, min_length: _, from_end: true }) => {\n-                    if o1 == o2 {\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX\");\n-                        Overlap::EqualOrDisjoint\n-                    } else {\n-                        debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX\");\n-                        Overlap::Disjoint\n-                    }\n-                }\n-                (ProjectionElem::ConstantIndex {\n-                    offset: offset_from_begin, min_length: min_length1, from_end: false },\n-                    ProjectionElem::ConstantIndex {\n-                        offset: offset_from_end, min_length: min_length2, from_end: true })\n-                | (ProjectionElem::ConstantIndex {\n-                    offset: offset_from_end, min_length: min_length1, from_end: true },\n-                   ProjectionElem::ConstantIndex {\n-                       offset: offset_from_begin, min_length: min_length2, from_end: false }) => {\n-                    // both patterns matched so it must be at least the greater of the two\n-                    let min_length = max(min_length1, min_length2);\n-                    // `offset_from_end` can be in range `[1..min_length]`, 1 indicates the last\n-                    // element (like -1 in Python) and `min_length` the first.\n-                    // Therefore, `min_length - offset_from_end` gives the minimal possible\n-                    // offset from the beginning\n-                    if *offset_from_begin >= min_length - offset_from_end {\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-FE\");\n-                        Overlap::EqualOrDisjoint\n-                    } else {\n-                        debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-FE\");\n-                        Overlap::Disjoint\n-                    }\n-                }\n-                (ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false },\n-                 ProjectionElem::Subslice {from, .. })\n-                | (ProjectionElem::Subslice {from, .. },\n-                    ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false }) => {\n-                    if offset >= from {\n-                        debug!(\n-                            \"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n-                        Overlap::EqualOrDisjoint\n-                    } else {\n-                        debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n-                        Overlap::Disjoint\n-                    }\n-                }\n-                (ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true },\n-                 ProjectionElem::Subslice {from: _, to })\n-                | (ProjectionElem::Subslice {from: _, to },\n-                    ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true }) => {\n-                    if offset > to {\n-                        debug!(\"place_element_conflict: \\\n-                               DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-SUBSLICE-FE\");\n-                        Overlap::EqualOrDisjoint\n-                    } else {\n-                        debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-SUBSLICE-FE\");\n-                        Overlap::Disjoint\n-                    }\n+            }\n+        }\n+        (ProjectionElem::Downcast(_, v1), ProjectionElem::Downcast(_, v2)) => {\n+            // different variants are treated as having disjoint fields,\n+            // even if they occupy the same \"space\", because it's\n+            // impossible for 2 variants of the same enum to exist\n+            // (and therefore, to be borrowed) at the same time.\n+            //\n+            // Note that this is different from unions - we *do* allow\n+            // this code to compile:\n+            //\n+            // ```\n+            // fn foo(x: &mut Result<i32, i32>) {\n+            //     let mut v = None;\n+            //     if let Ok(ref mut a) = *x {\n+            //         v = Some(a);\n+            //     }\n+            //     // here, you would *think* that the\n+            //     // *entirety* of `x` would be borrowed,\n+            //     // but in fact only the `Ok` variant is,\n+            //     // so the `Err` variant is *entirely free*:\n+            //     if let Err(ref mut a) = *x {\n+            //         v = Some(a);\n+            //     }\n+            //     drop(v);\n+            // }\n+            // ```\n+            if v1 == v2 {\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                Overlap::Disjoint\n+            }\n+        }\n+        (ProjectionElem::Index(..), ProjectionElem::Index(..))\n+        | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n+        | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n+        | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n+        | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..)) => {\n+            // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n+            // (if the indexes differ) or equal (if they are the same).\n+            match bias {\n+                PlaceConflictBias::Overlap => {\n+                    // If we are biased towards overlapping, then this is the recursive\n+                    // case that gives \"equal *or* disjoint\" its meaning.\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-INDEX\");\n+                    Overlap::EqualOrDisjoint\n                 }\n-                (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n-                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-SUBSLICES\");\n-                     Overlap::EqualOrDisjoint\n+                PlaceConflictBias::NoOverlap => {\n+                    // If we are biased towards no overlapping, then this is disjoint.\n+                    debug!(\"place_element_conflict: DISJOINT-ARRAY-INDEX\");\n+                    Overlap::Disjoint\n                 }\n-                (ProjectionElem::Deref, _)\n-                | (ProjectionElem::Field(..), _)\n-                | (ProjectionElem::Index(..), _)\n-                | (ProjectionElem::ConstantIndex { .. }, _)\n-                | (ProjectionElem::Subslice { .. }, _)\n-                | (ProjectionElem::Downcast(..), _) => bug!(\n-                    \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n-                    elem1,\n-                    elem2\n-                ),\n             }\n         }\n-        (Place::Projection(_), _) | (_, Place::Projection(_)) => bug!(\n-            \"unexpected elements in place_element_conflict: {:?} and {:?}\",\n-            elem1,\n-            elem2\n+        (ProjectionElem::ConstantIndex { offset: o1, min_length: _, from_end: false },\n+            ProjectionElem::ConstantIndex { offset: o2, min_length: _, from_end: false })\n+        | (ProjectionElem::ConstantIndex { offset: o1, min_length: _, from_end: true },\n+            ProjectionElem::ConstantIndex {\n+                offset: o2, min_length: _, from_end: true }) => {\n+            if o1 == o2 {\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX\");\n+                Overlap::Disjoint\n+            }\n+        }\n+        (ProjectionElem::ConstantIndex {\n+            offset: offset_from_begin, min_length: min_length1, from_end: false },\n+            ProjectionElem::ConstantIndex {\n+                offset: offset_from_end, min_length: min_length2, from_end: true })\n+        | (ProjectionElem::ConstantIndex {\n+            offset: offset_from_end, min_length: min_length1, from_end: true },\n+           ProjectionElem::ConstantIndex {\n+               offset: offset_from_begin, min_length: min_length2, from_end: false }) => {\n+            // both patterns matched so it must be at least the greater of the two\n+            let min_length = max(min_length1, min_length2);\n+            // `offset_from_end` can be in range `[1..min_length]`, 1 indicates the last\n+            // element (like -1 in Python) and `min_length` the first.\n+            // Therefore, `min_length - offset_from_end` gives the minimal possible\n+            // offset from the beginning\n+            if *offset_from_begin >= min_length - offset_from_end {\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-FE\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-FE\");\n+                Overlap::Disjoint\n+            }\n+        }\n+        (ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false },\n+         ProjectionElem::Subslice {from, .. })\n+        | (ProjectionElem::Subslice {from, .. },\n+            ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false }) => {\n+            if offset >= from {\n+                debug!(\n+                    \"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n+                Overlap::Disjoint\n+            }\n+        }\n+        (ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true },\n+         ProjectionElem::Subslice {from: _, to })\n+        | (ProjectionElem::Subslice {from: _, to },\n+            ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true }) => {\n+            if offset > to {\n+                debug!(\"place_element_conflict: \\\n+                       DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-SUBSLICE-FE\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-SUBSLICE-FE\");\n+                Overlap::Disjoint\n+            }\n+        }\n+        (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+            debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-SUBSLICES\");\n+             Overlap::EqualOrDisjoint\n+        }\n+        (ProjectionElem::Deref, _)\n+        | (ProjectionElem::Field(..), _)\n+        | (ProjectionElem::Index(..), _)\n+        | (ProjectionElem::ConstantIndex { .. }, _)\n+        | (ProjectionElem::Subslice { .. }, _)\n+        | (ProjectionElem::Downcast(..), _) => bug!(\n+            \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n+            pi1,\n+            pi2\n         ),\n     }\n }"}]}