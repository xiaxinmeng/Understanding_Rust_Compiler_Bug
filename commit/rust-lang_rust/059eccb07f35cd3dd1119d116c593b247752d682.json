{"sha": "059eccb07f35cd3dd1119d116c593b247752d682", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1OWVjY2IwN2YzNWNkM2RkMTExOWQxMTZjNTkzYjI0Nzc1MmQ2ODI=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2017-11-03T19:17:54Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2017-11-03T19:36:18Z"}, "message": "Implemented RFC 2008 for enums (not including variants) and structs.", "tree": {"sha": "f46189cc9bbb529e87362c85d1ea1979c8a7b97c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f46189cc9bbb529e87362c85d1ea1979c8a7b97c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/059eccb07f35cd3dd1119d116c593b247752d682", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCgAGBQJZ/MUyAAoJEAF2C0+fU/FUto4QAIBRG1KI0ia0GqZl27E4SxER\nmygBGlfVZnyjfCZEMkE4x9EkiLlq80PRwn82JaMy982Vfwxq120Lxr6eQMIGZq9U\nT+FFXZfa+gdvmGKa80RjyAAJD2pvB+A+cd6Wefa1/JOO/1O2PcgMY2T1xjde2igK\nyFwkP4z2914l7Ep7it/T3iqgWRj9wNDRdCqW+Q4FHnIM9RIXlf4fW49ga2R815UH\nWUi+gYCPmJuB1WbHWJp4etEsGRw27NxKffQD7uHEcOOUgP5uHs6vxpWux17wKpuj\nOxD42DJTmpBH4vh3Qt7uylezB74pxBjNpTq7oirlp3R0oC/0DfgU1JEn7BfaT8zE\naQqTQPlEwPxsvKZU9Bo0Vjn/IHfxRM5hYAOpN6M3lpGns22pDkRZq7sPK2W+Kmln\nO+fA1WY+I+LbYaFNwTyCJXyQ9KfrwExg13GoV5La2EpRcCDsIQS+rHkDsyEQQg8V\nsko+hVM1mMIqdq0zUsiCMUtw6bM5m7ZWQz3xpq4GSoa7i+BKJqugNt3JYe/bZUdk\nCfWIj9av9eZ8xBXOIq8cGE3V9C/y8DqKjSQjQEKy2xWZDCxzg/xaWvJbouqZTnkx\nOAsda+/34goUZyt6kYail1AXUMgckJTXmU99hfNFY2ZU7ps8YHh5MjRqakQP5r+b\nF1ziqZ0YhQxZeznz2VF9\n=M9w8\n-----END PGP SIGNATURE-----", "payload": "tree f46189cc9bbb529e87362c85d1ea1979c8a7b97c\nparent 6c19ebe1288c1fc6fa5d9b1c65da256eede7a77c\nauthor David Wood <david@davidtw.co> 1509736674 +0000\ncommitter David Wood <david@davidtw.co> 1509737778 +0000\n\nImplemented RFC 2008 for enums (not including variants) and structs.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/059eccb07f35cd3dd1119d116c593b247752d682", "html_url": "https://github.com/rust-lang/rust/commit/059eccb07f35cd3dd1119d116c593b247752d682", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/059eccb07f35cd3dd1119d116c593b247752d682/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c19ebe1288c1fc6fa5d9b1c65da256eede7a77c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c19ebe1288c1fc6fa5d9b1c65da256eede7a77c", "html_url": "https://github.com/rust-lang/rust/commit/6c19ebe1288c1fc6fa5d9b1c65da256eede7a77c"}], "stats": {"total": 212, "additions": 203, "deletions": 9}, "files": [{"sha": "861238c10ba57715b08d4120299a10e900933fd3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=059eccb07f35cd3dd1119d116c593b247752d682", "patch": "@@ -1326,6 +1326,12 @@ bitflags! {\n         const IS_FUNDAMENTAL      = 1 << 2;\n         const IS_UNION            = 1 << 3;\n         const IS_BOX              = 1 << 4;\n+        /// Indicates whether this abstract data type will be expanded on in future (new\n+        /// fields/variants) and as such, whether downstream crates must match exhaustively on the\n+        /// fields/variants of this data type.\n+        ///\n+        /// See RFC 2008 (https://github.com/rust-lang/rfcs/pull/2008).\n+        const IS_NON_EXHAUSTIVE   = 1 << 5;\n     }\n }\n \n@@ -1526,6 +1532,9 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         if Some(did) == tcx.lang_items().owned_box() {\n             flags = flags | AdtFlags::IS_BOX;\n         }\n+        if tcx.has_attr(did, \"non_exhaustive\") {\n+            flags = flags | AdtFlags::IS_NON_EXHAUSTIVE;\n+        }\n         match kind {\n             AdtKind::Enum => flags = flags | AdtFlags::IS_ENUM,\n             AdtKind::Union => flags = flags | AdtFlags::IS_UNION,\n@@ -1554,6 +1563,11 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.intersects(AdtFlags::IS_ENUM)\n     }\n \n+    #[inline]\n+    pub fn is_non_exhaustive(&self) -> bool {\n+        self.flags.intersects(AdtFlags::IS_NON_EXHAUSTIVE)\n+    }\n+\n     /// Returns the kind of the ADT - Struct or Enum.\n     #[inline]\n     pub fn adt_kind(&self) -> AdtKind {"}, {"sha": "6ebe3c679667f0a7afffa15811ae4cdbe3359af5", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=059eccb07f35cd3dd1119d116c593b247752d682", "patch": "@@ -208,6 +208,20 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn is_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n+        match ty.sty {\n+            ty::TyAdt(adt_def, ..) => adt_def.is_enum() && adt_def.is_non_exhaustive(),\n+            _ => false,\n+        }\n+    }\n+\n+    fn is_local(&self, ty: Ty<'tcx>) -> bool {\n+        match ty.sty {\n+            ty::TyAdt(adt_def, ..) => adt_def.did.is_local(),\n+            _ => false,\n+        }\n+    }\n+\n     fn is_variant_uninhabited(&self,\n                               variant: &'tcx ty::VariantDef,\n                               substs: &'tcx ty::subst::Substs<'tcx>)\n@@ -628,9 +642,16 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n         let is_privately_empty =\n             all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n-        debug!(\"missing_ctors={:?} is_privately_empty={:?}\", missing_ctors,\n-               is_privately_empty);\n-        if missing_ctors.is_empty() && !is_privately_empty {\n+        let is_declared_nonexhaustive =\n+            cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n+        debug!(\"missing_ctors={:?} is_privately_empty={:?} is_declared_nonexhaustive={:?}\",\n+               missing_ctors, is_privately_empty, is_declared_nonexhaustive);\n+\n+        // For privately empty and non-exhaustive enums, we work as if there were an \"extra\"\n+        // `_` constructor for the type, so we can never match over all constructors.\n+        let is_non_exhaustive = is_privately_empty || is_declared_nonexhaustive;\n+\n+        if missing_ctors.is_empty() && !is_non_exhaustive {\n             all_ctors.into_iter().map(|c| {\n                 is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n             }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n@@ -645,7 +666,51 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             match is_useful(cx, &matrix, &v[1..], witness) {\n                 UsefulWithWitness(pats) => {\n                     let cx = &*cx;\n-                    let new_witnesses = if used_ctors.is_empty() {\n+                    // In this case, there's at least one \"free\"\n+                    // constructor that is only matched against by\n+                    // wildcard patterns.\n+                    //\n+                    // There are 2 ways we can report a witness here.\n+                    // Commonly, we can report all the \"free\"\n+                    // constructors as witnesses, e.g. if we have:\n+                    //\n+                    // ```\n+                    //     enum Direction { N, S, E, W }\n+                    //     let Direction::N = ...;\n+                    // ```\n+                    //\n+                    // we can report 3 witnesses: `S`, `E`, and `W`.\n+                    //\n+                    // However, there are 2 cases where we don't want\n+                    // to do this and instead report a single `_` witness:\n+                    //\n+                    // 1) If the user is matching against a non-exhaustive\n+                    // enum, there is no point in enumerating all possible\n+                    // variants, because the user can't actually match\n+                    // against them himself, e.g. in an example like:\n+                    // ```\n+                    //     let err: io::ErrorKind = ...;\n+                    //     match err {\n+                    //         io::ErrorKind::NotFound => {},\n+                    //     }\n+                    // ```\n+                    // we don't want to show every possible IO error,\n+                    // but instead have `_` as the witness (this is\n+                    // actually *required* if the user specified *all*\n+                    // IO errors, but is probably what we want in every\n+                    // case).\n+                    //\n+                    // 2) If the user didn't actually specify a constructor\n+                    // in this arm, e.g. in\n+                    // ```\n+                    //     let x: (Direction, Direction, bool) = ...;\n+                    //     let (_, _, false) = x;\n+                    // ```\n+                    // we don't want to show all 16 possible witnesses\n+                    // `(<direction-1>, <direction-2>, true)` - we are\n+                    // satisfied with `(_, _, true)`. In this case,\n+                    // `used_ctors` is empty.\n+                    let new_witnesses = if is_non_exhaustive || used_ctors.is_empty() {\n                         // All constructors are unused. Add wild patterns\n                         // rather than each individual constructor\n                         pats.into_iter().map(|mut witness| {"}, {"sha": "458eec372445982714c98bd124ed6e4f8dec6717", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=059eccb07f35cd3dd1119d116c593b247752d682", "patch": "@@ -584,7 +584,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId)) -> Entry<'tcx> {\n         debug!(\"IsolatedEncoder::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n-        let variant = tcx.adt_def(adt_def_id).struct_variant();\n+        let adt_def = tcx.adt_def(adt_def_id);\n+        let variant = adt_def.struct_variant();\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n@@ -606,6 +607,12 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             }\n         }\n \n+        // If the structure is marked as non_exhaustive then lower the visibility\n+        // to within the crate.\n+        if adt_def.is_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n+            ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n+        }\n+\n         let repr_options = get_repr_options(&tcx, adt_def_id);\n \n         Entry {"}, {"sha": "71630de6aa834060d15e2ed5cd6beca4832290c1", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=059eccb07f35cd3dd1119d116c593b247752d682", "patch": "@@ -42,6 +42,15 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n+    fn invalid_non_exhaustive_attribute(&self, variant: &Variant) {\n+        let has_non_exhaustive = variant.node.attrs.iter()\n+            .any(|attr| attr.check_name(\"non_exhaustive\"));\n+        if has_non_exhaustive {\n+            self.err_handler().span_err(variant.span,\n+                                        \"#[non_exhaustive] is not yet supported on variants\");\n+        }\n+    }\n+\n     fn invalid_visibility(&self, vis: &Visibility, span: Span, note: Option<&str>) {\n         if vis != &Visibility::Inherited {\n             let mut err = struct_span_err!(self.session,\n@@ -224,6 +233,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n+                    self.invalid_non_exhaustive_attribute(variant);\n                     for field in variant.node.data.fields() {\n                         self.invalid_visibility(&field.vis, field.span, None);\n                     }"}, {"sha": "cc3a923f62c11094c520caaf8e9383816c329b12", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=059eccb07f35cd3dd1119d116c593b247752d682", "patch": "@@ -627,6 +627,16 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n                                 ctor_vis = field_vis;\n                             }\n                         }\n+\n+                        // If the structure is marked as non_exhaustive then lower the\n+                        // visibility to within the crate.\n+                        let struct_def_id = self.tcx.hir.get_parent_did(node_id);\n+                        let adt_def = self.tcx.adt_def(struct_def_id);\n+                        if adt_def.is_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n+                            ctor_vis = ty::Visibility::Restricted(\n+                                DefId::local(CRATE_DEF_INDEX));\n+                        }\n+\n                         return ctor_vis;\n                     }\n                     node => bug!(\"unexpected node kind: {:?}\", node)"}, {"sha": "b2866a42c426a3426f12ec50a241beecfbf0dcb6", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=059eccb07f35cd3dd1119d116c593b247752d682", "patch": "@@ -338,11 +338,22 @@ impl<'a> Resolver<'a> {\n             // These items live in both the type and value namespaces.\n             ItemKind::Struct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n-                let def = Def::Struct(self.definitions.local_def_id(item.id));\n+                let def_id = self.definitions.local_def_id(item.id);\n+                let def = Def::Struct(def_id);\n                 self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n \n-                // Record field names for error reporting.\n                 let mut ctor_vis = vis;\n+\n+                let has_non_exhaustive = item.attrs.iter()\n+                    .any(|item| item.check_name(\"non_exhaustive\"));\n+\n+                // If the structure is marked as non_exhaustive then lower the visibility\n+                // to within the crate.\n+                if has_non_exhaustive && vis == ty::Visibility::Public {\n+                    ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n+                }\n+\n+                // Record field names for error reporting.\n                 let field_names = struct_def.fields().iter().filter_map(|field| {\n                     let field_vis = self.resolve_visibility(&field.vis);\n                     if ctor_vis.is_at_least(field_vis, &*self) {\n@@ -414,6 +425,7 @@ impl<'a> Resolver<'a> {\n         // value namespace, they are reserved for possible future use.\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n         let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n+\n         self.define(parent, ident, ValueNS, (ctor_def, vis, variant.span, expansion));\n     }\n "}, {"sha": "272f13b28030ebbd86e873283224c8138ea7ff27", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=059eccb07f35cd3dd1119d116c593b247752d682", "patch": "@@ -825,10 +825,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                def_bm: ty::BindingMode) {\n         let tcx = self.tcx;\n \n-        let (substs, kind_name) = match adt_ty.sty {\n-            ty::TyAdt(adt, substs) => (substs, adt.variant_descr()),\n+        let (substs, adt) = match adt_ty.sty {\n+            ty::TyAdt(adt, substs) => (substs, adt),\n             _ => span_bug!(span, \"struct pattern is not an ADT\")\n         };\n+        let kind_name = adt.variant_descr();\n \n         // Index the struct fields' types.\n         let field_map = variant.fields\n@@ -882,6 +883,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.check_pat_walk(&field.pat, field_ty, def_bm, true);\n         }\n \n+        // Require `..` if struct has non_exhaustive attribute.\n+        if adt.is_struct() && adt.is_non_exhaustive() && !adt.did.is_local() && !etc {\n+            span_err!(tcx.sess, span, E0638,\n+                      \"`..` required with {} marked as non-exhaustive\",\n+                      kind_name);\n+        }\n+\n         // Report an error if incorrect number of the fields were specified.\n         if kind_name == \"union\" {\n             if fields.len() != 1 {"}, {"sha": "82d59ecfc92cfabb75bee8413c423ce30fc70d56", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=059eccb07f35cd3dd1119d116c593b247752d682", "patch": "@@ -3448,6 +3448,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::QPath::TypeRelative(ref qself, _) => qself.span\n         };\n \n+        // Prohibit struct expressions when non exhaustive flag is set.\n+        if let ty::TyAdt(adt, _) = struct_ty.sty {\n+            if !adt.did.is_local() && adt.is_non_exhaustive() {\n+                span_err!(self.tcx.sess, expr.span, E0639,\n+                          \"cannot create non-exhaustive {} using struct expression\",\n+                          adt.variant_descr());\n+            }\n+        }\n+\n         self.check_expr_struct_fields(struct_ty, expected, expr.id, path_span, variant, fields,\n                                       base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {"}, {"sha": "0f273d1460335d0df2fea6ad8cba9890ebfeaad3", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059eccb07f35cd3dd1119d116c593b247752d682/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=059eccb07f35cd3dd1119d116c593b247752d682", "patch": "@@ -4606,6 +4606,65 @@ foo.method(); // Ok!\n ```\n \"##,\n \n+E0638: r##\"\n+This error indicates that the struct or enum must be matched non-exhaustively\n+as it has been marked as `non_exhaustive`.\n+\n+When applied within a crate, downstream users of the crate will need to use the\n+`_` pattern when matching enums and use the `..` pattern when matching structs.\n+\n+For example, in the below example, since the enum is marked as\n+`non_exhaustive`, it is required that downstream crates match non-exhaustively\n+on it.\n+\n+```rust,ignore (pseudo-Rust)\n+use std::error::Error as StdError;\n+\n+#[non_exhaustive] pub enum Error {\n+   Message(String),\n+   Other,\n+}\n+\n+impl StdError for Error {\n+   fn description(&self) -> &str {\n+        // This will not error, despite being marked as non_exhaustive, as this\n+        // enum is defined within the current crate, it can be matched\n+        // exhaustively.\n+        match *self {\n+           Message(ref s) => s,\n+           Other => \"other or unknown error\",\n+        }\n+   }\n+}\n+```\n+\n+An example of matching non-exhaustively on the above enum is provided below:\n+\n+```rust,ignore (pseudo-Rust)\n+use mycrate::Error;\n+\n+// This will not error as the non_exhaustive Error enum has been matched with a\n+// wildcard.\n+match error {\n+   Message(ref s) => ...,\n+   Other => ...,\n+   _ => ...,\n+}\n+```\n+\n+Similarly, for structs, match with `..` to avoid this error.\n+\"##,\n+\n+E0639: r##\"\n+This error indicates that the struct or enum cannot be instantiated from\n+outside of the defining crate as it has been marked as `non_exhaustive` and as\n+such more fields/variants may be added in future that could cause adverse side\n+effects for this code.\n+\n+It is recommended that you look for a `new` function or equivalent in the\n+crate's documentation.\n+\"##,\n+\n }\n \n register_diagnostics! {"}]}