{"sha": "7f5f1f90a06961b769162c437681194900ef3b7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNWYxZjkwYTA2OTYxYjc2OTE2MmM0Mzc2ODExOTQ5MDBlZjNiN2U=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-24T01:50:53Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-25T19:12:25Z"}, "message": "Compiled a bounded version of pingpong.\n\nThere are some failures in the other pipe tests, but these seem to just be a matter of generalizing the library code.\n\nUpdating pipes library so all tests pass again", "tree": {"sha": "e8ccac02944c70bfe397bfdb8c08370f7a585013", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8ccac02944c70bfe397bfdb8c08370f7a585013"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f5f1f90a06961b769162c437681194900ef3b7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5f1f90a06961b769162c437681194900ef3b7e", "html_url": "https://github.com/rust-lang/rust/commit/7f5f1f90a06961b769162c437681194900ef3b7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f5f1f90a06961b769162c437681194900ef3b7e/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b97fe9835430553c0b566cf1f5687e6c7403821b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b97fe9835430553c0b566cf1f5687e6c7403821b", "html_url": "https://github.com/rust-lang/rust/commit/b97fe9835430553c0b566cf1f5687e6c7403821b"}], "stats": {"total": 324, "additions": 265, "deletions": 59}, "files": [{"sha": "1945081eebd681df7933556f2ba71b54526f68f6", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7f5f1f90a06961b769162c437681194900ef3b7e/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5f1f90a06961b769162c437681194900ef3b7e/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=7f5f1f90a06961b769162c437681194900ef3b7e", "patch": "@@ -8,7 +8,7 @@ import arc::methods;\n // Things used by code generated by the pipe compiler.\n export entangle, get_buffer, drop_buffer;\n export send_packet_buffered, recv_packet_buffered;\n-export mk_packet, entangle_buffer, has_buffer;\n+export packet, mk_packet, entangle_buffer, has_buffer;\n \n // export these so we can find them in the buffer_resource\n // destructor. This is probably another metadata bug.\n@@ -376,7 +376,7 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n }\n \n /// Returns true if messages are available.\n-pure fn peek<T: send>(p: recv_packet<T>) -> bool {\n+pure fn peek<T: send, Tb: send>(p: recv_packet_buffered<T, Tb>) -> bool {\n     alt unsafe {(*p.header()).state} {\n       empty { false }\n       blocked { fail ~\"peeking on blocked packet\" }\n@@ -480,10 +480,11 @@ fn wait_many(pkts: &[*packet_header]) -> uint {\n     ready_packet\n }\n \n-fn select2<A: send, B: send>(\n-    +a: recv_packet<A>,\n-    +b: recv_packet<B>)\n-    -> either<(option<A>, recv_packet<B>), (recv_packet<A>, option<B>)>\n+fn select2<A: send, Ab: send, B: send, Bb: send>(\n+    +a: recv_packet_buffered<A, Ab>,\n+    +b: recv_packet_buffered<B, Bb>)\n+    -> either<(option<A>, recv_packet_buffered<B, Bb>),\n+              (recv_packet_buffered<A, Ab>, option<B>)>\n {\n     let i = wait_many([a.header(), b.header()]/_);\n \n@@ -514,8 +515,8 @@ fn select2i<A: selectable, B: selectable>(a: A, b: B) -> either<(), ()> {\n \n #[doc = \"Waits on a set of endpoints. Returns a message, its index,\n  and a list of the remaining endpoints.\"]\n-fn select<T: send>(+endpoints: ~[recv_packet<T>])\n-    -> (uint, option<T>, ~[recv_packet<T>])\n+fn select<T: send, Tb: send>(+endpoints: ~[recv_packet_buffered<T, Tb>])\n+    -> (uint, option<T>, ~[recv_packet_buffered<T, Tb>])\n {\n     let ready = wait_many(endpoints.map(|p| p.header()));\n     let mut remaining = ~[];\n@@ -657,10 +658,11 @@ fn entangle<T: send>() -> (send_packet<T>, recv_packet<T>) {\n     (send_packet(p), recv_packet(p))\n }\n \n-fn spawn_service<T: send>(\n-    init: extern fn() -> (send_packet<T>, recv_packet<T>),\n-    +service: fn~(+recv_packet<T>))\n-    -> send_packet<T>\n+fn spawn_service<T: send, Tb: send>(\n+    init: extern fn() -> (send_packet_buffered<T, Tb>,\n+                          recv_packet_buffered<T, Tb>),\n+    +service: fn~(+recv_packet_buffered<T, Tb>))\n+    -> send_packet_buffered<T, Tb>\n {\n     let (client, server) = init();\n \n@@ -676,10 +678,11 @@ fn spawn_service<T: send>(\n     client\n }\n \n-fn spawn_service_recv<T: send>(\n-    init: extern fn() -> (recv_packet<T>, send_packet<T>),\n-    +service: fn~(+send_packet<T>))\n-    -> recv_packet<T>\n+fn spawn_service_recv<T: send, Tb: send>(\n+    init: extern fn() -> (recv_packet_buffered<T, Tb>,\n+                          send_packet_buffered<T, Tb>),\n+    +service: fn~(+send_packet_buffered<T, Tb>))\n+    -> recv_packet_buffered<T, Tb>\n {\n     let (client, server) = init();\n "}, {"sha": "b70100de4c54cbb654865f35c9ab02079954fb49", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 71, "deletions": 2, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7f5f1f90a06961b769162c437681194900ef3b7e/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5f1f90a06961b769162c437681194900ef3b7e/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=7f5f1f90a06961b769162c437681194900ef3b7e", "patch": "@@ -7,6 +7,14 @@ import ast::{ident, node_id};\n import codemap::span;\n import ext::base::mk_ctxt;\n \n+// Transitional reexports so qquote can find the paths it is looking for\n+mod syntax {\n+    import ext;\n+    export ext;\n+    import parse;\n+    export parse;\n+}\n+\n fn ident(s: ~str) -> ast::ident {\n     @(copy s)\n }\n@@ -93,9 +101,60 @@ trait ext_ctxt_ast_builder {\n     fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::ty];\n     fn ty_field_imm(name: ident, ty: @ast::ty) -> ast::ty_field;\n     fn ty_rec(+~[ast::ty_field]) -> @ast::ty;\n+    fn field_imm(name: ident, e: @ast::expr) -> ast::field;\n+    fn rec(+~[ast::field]) -> @ast::expr;\n+    fn block(+stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n+    fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt;\n+    fn stmt_expr(e: @ast::expr) -> @ast::stmt;\n+    fn block_expr(b: ast::blk) -> @ast::expr;\n }\n \n impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n+    fn block_expr(b: ast::blk) -> @ast::expr {\n+        @{id: self.next_id(),\n+          callee_id: self.next_id(),\n+          node: ast::expr_block(b),\n+          span: empty_span()}\n+    }\n+\n+    fn stmt_expr(e: @ast::expr) -> @ast::stmt {\n+        @{node: ast::stmt_expr(e, self.next_id()),\n+          span: empty_span()}\n+    }\n+\n+    fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt {\n+        // If the quasiquoter could interpolate idents, this is all\n+        // we'd need.\n+        //\n+        //let ext_cx = self;\n+        //#ast[stmt] { let $(ident) = $(e) }\n+\n+        @{node: ast::stmt_decl(@{node: ast::decl_local(~[\n+            @{node: {is_mutbl: false,\n+                     ty: self.ty_infer(),\n+                     pat: @{id: self.next_id(),\n+                            node: ast::pat_ident(path(ident), none),\n+                            span: empty_span()},\n+                     init: some({op: ast::init_move,\n+                                 expr: e}),\n+                     id: self.next_id()},\n+              span: empty_span()}]),\n+                               span: empty_span()}, self.next_id()),\n+         span: empty_span()}\n+    }\n+\n+    fn field_imm(name: ident, e: @ast::expr) -> ast::field {\n+        {node: {mutbl: ast::m_imm, ident: name, expr: e},\n+         span: empty_span()}\n+    }\n+\n+    fn rec(+fields: ~[ast::field]) -> @ast::expr {\n+        @{id: self.next_id(),\n+          callee_id: self.next_id(),\n+          node: ast::expr_rec(fields, none),\n+          span: empty_span()}\n+    }\n+\n     fn ty_field_imm(name: ident, ty: @ast::ty) -> ast::ty_field {\n         {node: {ident: name, mt: { ty: ty, mutbl: ast::m_imm } },\n           span: empty_span()}\n@@ -107,6 +166,12 @@ impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n           span: empty_span()}\n     }\n \n+    fn ty_infer() -> @ast::ty {\n+        @{id: self.next_id(),\n+          node: ast::ty_infer,\n+          span: empty_span()}\n+    }\n+\n     fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n         -> ast::ty_param\n     {\n@@ -128,9 +193,9 @@ impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n          id: self.next_id()}\n     }\n \n-    fn expr_block(e: @ast::expr) -> ast::blk {\n+    fn block(+stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n         let blk = {view_items: ~[],\n-                   stmts: ~[],\n+                   stmts: stmts,\n                    expr: some(e),\n                    id: self.next_id(),\n                    rules: ast::default_blk};\n@@ -139,6 +204,10 @@ impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n          span: empty_span()}\n     }\n \n+    fn expr_block(e: @ast::expr) -> ast::blk {\n+        self.block(~[], e)\n+    }\n+\n     fn fn_decl(+inputs: ~[ast::arg],\n                output: @ast::ty) -> ast::fn_decl {\n         {inputs: inputs,"}, {"sha": "7dd33e35bc8e8256bf1589c4f14143b913ffeba7", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 143, "deletions": 40, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/7f5f1f90a06961b769162c437681194900ef3b7e/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5f1f90a06961b769162c437681194900ef3b7e/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=7f5f1f90a06961b769162c437681194900ef3b7e", "patch": "@@ -23,6 +23,14 @@ import ast_builder::methods;\n import ast_builder::path;\n import ast_builder::path_concat;\n \n+// Transitional reexports so qquote can find the paths it is looking for\n+mod syntax {\n+    import ext;\n+    export ext;\n+    import parse;\n+    export parse;\n+}\n+\n trait gen_send {\n     fn gen_send(cx: ext_ctxt) -> @ast::item;\n }\n@@ -60,14 +68,34 @@ impl compile of gen_send for message {\n                               ast::by_copy)],\n                 args_ast);\n \n-            let pat = alt (this.dir, next.dir) {\n-              (send, send) { ~\"(c, s)\" }\n-              (send, recv) { ~\"(s, c)\" }\n-              (recv, send) { ~\"(s, c)\" }\n-              (recv, recv) { ~\"(c, s)\" }\n-            };\n+            let mut body = ~\"{\\n\";\n+\n+            if this.proto.is_bounded() {\n+                let (sp, rp) = alt (this.dir, next.dir) {\n+                  (send, send) { (\"c\", \"s\") }\n+                  (send, recv) { (\"s\", \"c\") }\n+                  (recv, send) { (\"s\", \"c\") }\n+                  (recv, recv) { (\"c\", \"s\") }\n+                };\n \n-            let mut body = #fmt(\"{ let %s = pipes::entangle();\\n\", pat);\n+                body += \"let b = pipe.reuse_buffer();\\n\";\n+                body += #fmt(\"let %s = pipes::send_packet_buffered(\\\n+                              ptr::addr_of(b.buffer.data.%s));\\n\",\n+                             sp, *next.name);\n+                body += #fmt(\"let %s = pipes::recv_packet_buffered(\\\n+                              ptr::addr_of(b.buffer.data.%s));\\n\",\n+                             rp, *next.name);\n+            }\n+            else {\n+                let pat = alt (this.dir, next.dir) {\n+                  (send, send) { ~\"(c, s)\" }\n+                  (send, recv) { ~\"(s, c)\" }\n+                  (recv, send) { ~\"(s, c)\" }\n+                  (recv, recv) { ~\"(c, s)\" }\n+                };\n+\n+                body += #fmt(\"let %s = pipes::entangle();\\n\", pat);\n+            }\n             body += #fmt(\"let message = %s::%s(%s);\\n\",\n                          *this.proto.name,\n                          *self.name(),\n@@ -189,42 +217,121 @@ impl compile of to_type_decls for state {\n             }\n         }\n \n-        vec::push(items,\n-                  cx.item_ty_poly(\n-                      self.data_name(),\n-                      cx.ty_path_ast_builder(\n-                          (@~\"pipes\" + @(dir.to_str() + ~\"_packet\"))\n-                          .add_ty(cx.ty_path_ast_builder(\n-                              (self.proto.name + self.data_name())\n-                              .add_tys(cx.ty_vars(self.ty_params))))),\n-                      self.ty_params));\n+        if !self.proto.is_bounded() {\n+            vec::push(items,\n+                      cx.item_ty_poly(\n+                          self.data_name(),\n+                          cx.ty_path_ast_builder(\n+                              (@~\"pipes\" + @(dir.to_str() + ~\"_packet\"))\n+                              .add_ty(cx.ty_path_ast_builder(\n+                                  (self.proto.name + self.data_name())\n+                                  .add_tys(cx.ty_vars(self.ty_params))))),\n+                          self.ty_params));\n+        }\n+        else {\n+            let ext_cx = cx;\n+            vec::push(items,\n+                      cx.item_ty_poly(\n+                          self.data_name(),\n+                          cx.ty_path_ast_builder(\n+                              (@~\"pipes\" + @(dir.to_str()\n+                                             + ~\"_packet_buffered\"))\n+                              .add_tys(~[cx.ty_path_ast_builder(\n+                                  (self.proto.name + self.data_name())\n+                                  .add_tys(cx.ty_vars(self.ty_params))),\n+                                         #ast[ty] { buffer }])),\n+                          self.ty_params));\n+        };\n         items\n     }\n }\n \n impl compile of gen_init for protocol {\n     fn gen_init(cx: ext_ctxt) -> @ast::item {\n+        let ext_cx = cx;\n+\n         #debug(\"gen_init\");\n         let start_state = self.states[0];\n \n-        let body = alt start_state.dir {\n-          send { cx.parse_expr(~\"pipes::entangle()\") }\n-          recv {\n-            cx.parse_expr(~\"{ \\\n-                           let (s, c) = pipes::entangle(); \\\n-                           (c, s) \\\n-                           }\")\n-          }\n+        let body = if !self.is_bounded() {\n+            alt start_state.dir {\n+              send { #ast { pipes::entangle() } }\n+              recv {\n+                #ast {{\n+                    let (s, c) = pipes::entangle();\n+                    (c, s)\n+                }}\n+              }\n+            }\n+        }\n+        else {\n+            let body = self.gen_init_bounded(ext_cx);\n+            alt start_state.dir {\n+              send { body }\n+              recv {\n+                #ast {{\n+                    let (s, c) = $(body);\n+                    (c, s)\n+                }}\n+              }\n+            }\n         };\n \n         cx.parse_item(#fmt(\"fn init%s() -> (client::%s, server::%s)\\\n-                            { %s }\",\n+                            { import pipes::has_buffer; %s }\",\n                            start_state.ty_params.to_source(),\n                            start_state.to_ty(cx).to_source(),\n                            start_state.to_ty(cx).to_source(),\n                            body.to_source()))\n     }\n \n+    fn gen_buffer_init(ext_cx: ext_ctxt) -> @ast::expr {\n+        ext_cx.rec(self.states.map_to_vec(|s| {\n+            let fty = ext_cx.ty_path_ast_builder(path(s.name));\n+            ext_cx.field_imm(s.name, #ast { pipes::mk_packet::<$(fty)>() })\n+        }))\n+    }\n+\n+    fn gen_init_bounded(ext_cx: ext_ctxt) -> @ast::expr {\n+        #debug(\"gen_init_bounded\");\n+        let buffer_fields = self.gen_buffer_init(ext_cx);\n+\n+        let buffer = #ast {\n+            ~{header: pipes::buffer_header(),\n+              data: $(buffer_fields)}\n+        };\n+\n+        let entangle_body = ext_cx.block_expr(\n+            ext_cx.block(\n+                self.states.map_to_vec(\n+                    |s| ext_cx.parse_stmt(\n+                        #fmt(\"data.%s.set_buffer(buffer)\", *s.name))),\n+                ext_cx.parse_expr(\n+                    #fmt(\"ptr::addr_of(data.%s)\", *self.states[0].name))));\n+\n+        #ast {{\n+            let buffer = $(buffer);\n+            do pipes::entangle_buffer(buffer) |buffer, data| {\n+                $(entangle_body)\n+            }\n+        }}\n+    }\n+\n+    fn gen_buffer_type(cx: ext_ctxt) -> @ast::item {\n+        let ext_cx = cx;\n+        cx.item_ty(\n+            @~\"buffer\",\n+            cx.ty_rec(\n+                (copy self.states).map_to_vec(\n+                    |s| {\n+                        let ty = cx.ty_path_ast_builder(path(s.name));\n+                        let fty = #ast[ty] {\n+                            pipes::packet<$(ty)>\n+                        };\n+                        cx.ty_field_imm(s.name, fty)\n+                    })))\n+    }\n+\n     fn compile(cx: ext_ctxt) -> @ast::item {\n         let mut items = ~[self.gen_init(cx)];\n         let mut client_states = ~[];\n@@ -239,20 +346,7 @@ impl compile of gen_init for protocol {\n         }\n \n         if self.is_bounded() {\n-            vec::push(\n-                items,\n-                cx.item_ty(\n-                    @~\"buffer\",\n-                    cx.ty_rec(\n-                        (copy self.states).map_to_vec(\n-                            |s| cx.ty_field_imm(\n-                                s.name,\n-                                cx.ty_path_ast_builder(\n-                                    (path(@~\"pipes\")\n-                                     + @~\"packet\")\n-                                    .add_ty(\n-                                        cx.ty_path_ast_builder(\n-                                            path(s.name)))))))))\n+            vec::push(items, self.gen_buffer_type(cx))\n         }\n \n         vec::push(items,\n@@ -310,6 +404,7 @@ impl of to_source for @ast::expr {\n trait ext_ctxt_parse_utils {\n     fn parse_item(s: ~str) -> @ast::item;\n     fn parse_expr(s: ~str) -> @ast::expr;\n+    fn parse_stmt(s: ~str) -> @ast::stmt;\n }\n \n impl parse_utils of ext_ctxt_parse_utils for ext_ctxt {\n@@ -330,6 +425,15 @@ impl parse_utils of ext_ctxt_parse_utils for ext_ctxt {\n         }\n     }\n \n+    fn parse_stmt(s: ~str) -> @ast::stmt {\n+        parse::parse_stmt_from_source_str(\n+            ~\"***protocol expansion***\",\n+            @(copy s),\n+            self.cfg(),\n+            ~[],\n+            self.parse_sess())\n+    }\n+\n     fn parse_expr(s: ~str) -> @ast::expr {\n         parse::parse_expr_from_source_str(\n             ~\"***protocol expansion***\",\n@@ -338,4 +442,3 @@ impl parse_utils of ext_ctxt_parse_utils for ext_ctxt {\n             self.parse_sess())\n     }\n }\n-"}, {"sha": "a0091806b02151acd77c87378ca72ae8082461b7", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7f5f1f90a06961b769162c437681194900ef3b7e/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5f1f90a06961b769162c437681194900ef3b7e/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=7f5f1f90a06961b769162c437681194900ef3b7e", "patch": "@@ -131,7 +131,24 @@ class protocol_ {\n \n     fn num_states() -> uint { self.states.len() }\n \n-    fn is_bounded() -> bool { self.bounded.get() }\n+    fn has_ty_params() -> bool {\n+        for self.states.each |s| {\n+            if s.ty_params.len() > 0 {\n+                ret true;\n+            }\n+        }\n+        false\n+    }\n+    fn is_bounded() -> bool {\n+        let bounded = self.bounded.get();\n+        if bounded && self.has_ty_params() {\n+            #debug(\"protocol %s has is bounded, but type parameters\\\n+                    are not yet supported.\",\n+                   *self.name);\n+            false\n+        }\n+        else { bounded }\n+    }\n }\n \n impl methods for protocol {"}, {"sha": "39f4654a138c01e9b7631acc56fa142b43feeb9d", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f5f1f90a06961b769162c437681194900ef3b7e/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5f1f90a06961b769162c437681194900ef3b7e/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=7f5f1f90a06961b769162c437681194900ef3b7e", "patch": "@@ -10,6 +10,7 @@ export new_parser_from_tt;\n export parse_crate_from_file, parse_crate_from_crate_file;\n export parse_crate_from_source_str;\n export parse_expr_from_source_str, parse_item_from_source_str;\n+export parse_stmt_from_source_str;\n export parse_from_source_str;\n \n import parser::parser;\n@@ -129,6 +130,17 @@ fn parse_item_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n     ret r;\n }\n \n+fn parse_stmt_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n+                              +attrs: ~[ast::attribute],\n+                              sess: parse_sess) -> @ast::stmt {\n+    let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n+                                                  codemap::fss_none, source);\n+    let r = p.parse_stmt(attrs);\n+    sess.chpos = rdr.chpos;\n+    sess.byte_pos = sess.byte_pos + rdr.pos;\n+    ret r;\n+}\n+\n fn parse_from_source_str<T>(f: fn (p: parser) -> T,\n                             name: ~str, ss: codemap::file_substr,\n                             source: @~str, cfg: ast::crate_cfg,"}, {"sha": "c4dbc3eaefd0905e6d847e97cc7cdc87d7cbb504", "filename": "src/test/run-pass/pipe-pingpong-bounded.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f5f1f90a06961b769162c437681194900ef3b7e/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5f1f90a06961b769162c437681194900ef3b7e/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs?ref=7f5f1f90a06961b769162c437681194900ef3b7e", "patch": "@@ -10,6 +10,8 @@ mod pingpong {\n     import pipes::*;\n \n     type packets = {\n+        // This is probably a resolve bug, I forgot to export packet,\n+        // but since I didn't import pipes::*, it worked anyway.\n         ping: packet<ping>,\n         pong: packet<pong>,\n     };"}]}