{"sha": "168398bb3dc01f8efecf734342af60a959a74b8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ODM5OGJiM2RjMDFmOGVmZWNmNzM0MzQyYWY2MGE5NTlhNzRiOGQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-08T12:30:22Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-15T08:00:21Z"}, "message": "Stop generating generic versions of generic functions\n\nMonomorphic instances are generated on demand.", "tree": {"sha": "5b4aa5cc1d42cd18771507fd5fc5ad7dc0517f2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b4aa5cc1d42cd18771507fd5fc5ad7dc0517f2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/168398bb3dc01f8efecf734342af60a959a74b8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/168398bb3dc01f8efecf734342af60a959a74b8d", "html_url": "https://github.com/rust-lang/rust/commit/168398bb3dc01f8efecf734342af60a959a74b8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/168398bb3dc01f8efecf734342af60a959a74b8d/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47e65403b79a476fe483f8141c0c5937cbaa06a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/47e65403b79a476fe483f8141c0c5937cbaa06a6", "html_url": "https://github.com/rust-lang/rust/commit/47e65403b79a476fe483f8141c0c5937cbaa06a6"}], "stats": {"total": 123, "additions": 61, "deletions": 62}, "files": [{"sha": "56e7ab47f609003d86c275830517efb379f1660a", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/168398bb3dc01f8efecf734342af60a959a74b8d/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168398bb3dc01f8efecf734342af60a959a74b8d/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=168398bb3dc01f8efecf734342af60a959a74b8d", "patch": "@@ -263,7 +263,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_enum_id(ebml_w, local_def(id));\n         encode_type(ecx, ebml_w,\n                     node_id_to_type(ecx.ccx.tcx, variant.node.id));\n-        if vec::len::<variant_arg>(variant.node.args) > 0u {\n+        if vec::len(variant.node.args) > 0u && ty_params.len() == 0u {\n             encode_symbol(ecx, ebml_w, variant.node.id);\n         }\n         encode_discriminant(ecx, ebml_w, variant.node.id);\n@@ -361,10 +361,11 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_family(ebml_w, purity_fn_family(decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_symbol(ecx, ebml_w, item.id);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         if tps.len() > 0u || should_inline(item.attrs) {\n             astencode::encode_inlined_item(ecx, ebml_w, path, ii_item(item));\n+        } else {\n+            encode_symbol(ecx, ebml_w, item.id);\n         }\n         ebml_w.end_tag();\n       }\n@@ -416,7 +417,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, ty::ty_fn_ret(fn_ty));\n         encode_name(ebml_w, item.ident);\n-        encode_symbol(ecx, ebml_w, item.id);\n+        if tps.len() == 0u {\n+            encode_symbol(ecx, ebml_w, item.id);\n+        }\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n \n@@ -466,12 +469,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             encode_type_param_bounds(ebml_w, ecx, tps + m.tps);\n             encode_type(ecx, ebml_w, node_id_to_type(tcx, m.id));\n             encode_name(ebml_w, m.ident);\n-            encode_symbol(ecx, ebml_w, m.id);\n             encode_path(ebml_w, impl_path, ast_map::path_name(m.ident));\n             if tps.len() > 0u || m.tps.len() > 0u || should_inline(m.attrs) {\n                 astencode::encode_inlined_item(\n                     ecx, ebml_w, impl_path,\n                     ii_method(local_def(item.id), m));\n+            } else {\n+                encode_symbol(ecx, ebml_w, m.id);\n             }\n             ebml_w.end_tag();\n         }"}, {"sha": "ab8855ff2470c22a4f1b4de6cfe427f9ec4c0bd4", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 42, "deletions": 50, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/168398bb3dc01f8efecf734342af60a959a74b8d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168398bb3dc01f8efecf734342af60a959a74b8d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=168398bb3dc01f8efecf734342af60a959a74b8d", "patch": "@@ -2153,29 +2153,29 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n     alt check map_node {\n       ast_map::node_item(i@@{node: ast::item_fn(decl, _, body), _}, _) {\n         set_inline_hint_if_appr(i.attrs, lldecl);\n-        trans_fn(ccx, pt, decl, body, lldecl, no_self, [],\n-                 psubsts, fn_id.node, none);\n+        trans_fn(ccx, pt, decl, body, lldecl, no_self, psubsts, fn_id.node,\n+                 none);\n       }\n       ast_map::node_variant(v, enum_item, _) {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n         let this_tv = option::get(vec::find(*tvs, {|tv|\n             tv.id.node == fn_id.node}));\n         set_inline_hint(lldecl);\n         trans_enum_variant(ccx, enum_item.id, v, this_tv.disr_val,\n-                           (*tvs).len() == 1u, [], psubsts, lldecl);\n+                           (*tvs).len() == 1u, psubsts, lldecl);\n       }\n       ast_map::node_method(mth, impl_def_id, _) {\n         set_inline_hint_if_appr(mth.attrs, lldecl);\n         let selfty = ty::node_id_to_type(ccx.tcx, mth.self_id);\n         let selfty = ty::substitute_type_params(ccx.tcx, substs, selfty);\n         trans_fn(ccx, pt, mth.decl, mth.body, lldecl,\n-                 impl_self(selfty), [], psubsts, fn_id.node, none);\n+                 impl_self(selfty), psubsts, fn_id.node, none);\n       }\n       ast_map::node_ctor(i) {\n         alt check ccx.tcx.items.get(i.id) {\n           ast_map::node_item(@{node: ast::item_res(decl, _, _, _, _), _}, _) {\n             set_inline_hint(lldecl);\n-            trans_res_ctor(ccx, pt, decl, fn_id.node, [], psubsts, lldecl);\n+            trans_res_ctor(ccx, pt, decl, fn_id.node, psubsts, lldecl);\n           }\n           ast_map::node_item(@{node: ast::item_class(_, _, ctor), _}, _) {\n             ccx.sess.unimpl(\"monomorphic class constructor\");\n@@ -2216,10 +2216,11 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n                    mth.id];\n             ccx.external.insert(fn_id, some(mth.id));\n             compute_ii_method_info(ccx, impl_did, mth) {|ty, bounds, path|\n-                let llfn = get_item_val(ccx, mth.id);\n-                trans_fn(ccx, path, mth.decl, mth.body,\n-                         llfn, impl_self(ty), bounds,\n-                         none, mth.id, none);\n+                if bounds.len() == 0u {\n+                    let llfn = get_item_val(ccx, mth.id);\n+                    trans_fn(ccx, path, mth.decl, mth.body,\n+                             llfn, impl_self(ty), none, mth.id, none);\n+                }\n             }\n             local_def(mth.id)\n           }\n@@ -4116,7 +4117,6 @@ enum self_arg { impl_self(ty::t), no_self, }\n fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                  body: ast::blk, llfndecl: ValueRef,\n                  ty_self: self_arg,\n-                 tps_bounds: [ty::param_bounds],\n                  param_substs: option<param_substs>,\n                  id: ast::node_id, maybe_self_id: option<@ast::expr>,\n                  maybe_load_env: fn(fn_ctxt)) {\n@@ -4125,7 +4125,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     // Set up arguments to the function.\n             let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, maybe_self_id,\n                   param_substs, some(body.span));\n-    create_llargs_for_fn_args(fcx, ty_self, decl.inputs, tps_bounds);\n+    create_llargs_for_fn_args(fcx, ty_self, decl.inputs, []);\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n@@ -4168,15 +4168,14 @@ fn trans_fn(ccx: @crate_ctxt,\n             body: ast::blk,\n             llfndecl: ValueRef,\n             ty_self: self_arg,\n-            tps_bounds: [ty::param_bounds],\n             param_substs: option<param_substs>,\n             id: ast::node_id,\n             maybe_self_id: option<@ast::expr>) {\n     let do_time = ccx.sess.opts.stats;\n     let start = if do_time { time::get_time() }\n                 else { {sec: 0u32, usec: 0u32} };\n     trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n-                  tps_bounds, param_substs, id, maybe_self_id, {|fcx|\n+                  param_substs, id, maybe_self_id, {|fcx|\n         if ccx.sess.opts.extra_debuginfo {\n             debuginfo::create_function(fcx);\n         }\n@@ -4188,12 +4187,12 @@ fn trans_fn(ccx: @crate_ctxt,\n }\n \n fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n-                  ctor_id: ast::node_id, tps_bounds: [ty::param_bounds],\n+                  ctor_id: ast::node_id,\n                   param_substs: option<param_substs>, llfndecl: ValueRef) {\n     // Create a function for the constructor\n     let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, ctor_id,\n                                none, param_substs, none);\n-    create_llargs_for_fn_args(fcx, no_self, dtor.inputs, tps_bounds);\n+    create_llargs_for_fn_args(fcx, no_self, dtor.inputs, []);\n     let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n     let fty = node_id_type(bcx, ctor_id);\n     let arg_t = ty::ty_fn_args(fty)[0].ty;\n@@ -4223,7 +4222,6 @@ fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n \n fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n                       variant: ast::variant, disr: int, is_degen: bool,\n-                      ty_params: [ast::ty_param],\n                       param_substs: option<param_substs>,\n                       llfndecl: ValueRef) {\n     // Translate variant arguments to function arguments.\n@@ -4236,17 +4234,10 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n     }\n     let fcx = new_fn_ctxt_w_id(ccx, [], llfndecl, variant.node.id, none,\n                                param_substs, none);\n-    create_llargs_for_fn_args(fcx, no_self, fn_args,\n-                              param_bounds(ccx, ty_params));\n+    create_llargs_for_fn_args(fcx, no_self, fn_args, []);\n     let ty_param_substs = alt param_substs {\n       some(substs) { substs.tys }\n-      none {\n-        let i = 0u;\n-        vec::map(ty_params, {|tp|\n-            i += 1u;\n-            ty::mk_param(ccx.tcx, i - 1u, local_def(tp.id))\n-        })\n-      }\n+      none { [] }\n     };\n     let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n@@ -4400,44 +4391,46 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n     };\n     alt item.node {\n       ast::item_fn(decl, tps, body) {\n-        let llfndecl = get_item_val(ccx, item.id);\n-        if decl.purity != ast::crust_fn  {\n-            trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n-                     llfndecl, no_self, param_bounds(ccx, tps),\n-                     none, item.id, none);\n-        } else {\n+        if decl.purity == ast::crust_fn  {\n+            let llfndecl = get_item_val(ccx, item.id);\n             native::trans_crust_fn(ccx, *path + [path_name(item.ident)],\n                                    decl, body, llfndecl, item.id);\n+        } else if tps.len() == 0u {\n+            let llfndecl = get_item_val(ccx, item.id);\n+            trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n+                     llfndecl, no_self, none, item.id, none);\n         }\n       }\n       ast::item_impl(tps, _, _, ms) {\n         impl::trans_impl(ccx, *path, item.ident, ms, tps);\n       }\n       ast::item_res(decl, tps, body, dtor_id, ctor_id) {\n-        let llctor_decl = get_item_val(ccx, ctor_id);\n-        trans_res_ctor(ccx, *path, decl, ctor_id,\n-                       param_bounds(ccx, tps), none, llctor_decl);\n+        if tps.len() == 0u {\n+            let llctor_decl = get_item_val(ccx, ctor_id);\n+            trans_res_ctor(ccx, *path, decl, ctor_id, none, llctor_decl);\n \n-        // Create a function for the destructor\n-        let lldtor_decl = get_item_val(ccx, item.id);\n-        trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n-                 lldtor_decl, no_self, param_bounds(ccx, tps),\n-                 none, dtor_id, none);\n+            let lldtor_decl = get_item_val(ccx, item.id);\n+            trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n+                     lldtor_decl, no_self, none, dtor_id, none);\n+        }\n       }\n       ast::item_mod(m) {\n         trans_mod(ccx, m);\n       }\n       ast::item_enum(variants, tps) {\n-        let degen = variants.len() == 1u;\n-        let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n-        let i = 0;\n-        for variant: ast::variant in variants {\n-            if variant.node.args.len() > 0u {\n-                trans_enum_variant(ccx, item.id, variant,\n-                                   vi[i].disr_val, degen, tps,\n-                                   none, get_item_val(ccx, variant.node.id));\n+        if tps.len() == 0u {\n+            let degen = variants.len() == 1u;\n+            let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n+            let i = 0;\n+            for variant: ast::variant in variants {\n+                let llfn = get_item_val(ccx, variant.node.id);\n+                if variant.node.args.len() > 0u {\n+                    trans_enum_variant(ccx, item.id, variant,\n+                                       vi[i].disr_val, degen,\n+                                       none, llfn);\n+                }\n+                i += 1;\n             }\n-            i += 1;\n         }\n       }\n       ast::item_const(_, expr) { trans_const(ccx, expr, item.id); }\n@@ -4516,8 +4509,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n                                       with ctor.node.body};\n         trans_fn(ccx, *path + [path_name(item.ident)], ctor.node.dec,\n                  ctor_body__, llctor_decl, no_self,\n-                 param_bounds(ccx, tps), none, ctor.node.id,\n-                 some(rslt_expr));\n+                 none, ctor.node.id, some(rslt_expr));\n         // TODO: translate methods!\n       }\n       _ {/* fall through */ }"}, {"sha": "bdc97206ec2d3ee08f77cb0782af93ef9863ed06", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/168398bb3dc01f8efecf734342af60a959a74b8d/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168398bb3dc01f8efecf734342af60a959a74b8d/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=168398bb3dc01f8efecf734342af60a959a74b8d", "patch": "@@ -470,7 +470,7 @@ fn trans_expr_fn(bcx: block,\n         let cap_vars = capture::compute_capture_vars(\n             ccx.tcx, id, proto, cap_clause);\n         let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck, id);\n-        trans_closure(ccx, sub_path, decl, body, llfn, no_self, [],\n+        trans_closure(ccx, sub_path, decl, body, llfn, no_self,\n                       bcx.fcx.param_substs, id, none, {|fcx|\n             load_environment(bcx, fcx, cdata_ty, cap_vars, ck);\n         });\n@@ -482,7 +482,7 @@ fn trans_expr_fn(bcx: block,\n       ast::proto_box { trans_closure_env(ty::ck_box) }\n       ast::proto_uniq { trans_closure_env(ty::ck_uniq) }\n       ast::proto_bare {\n-        trans_closure(ccx, sub_path, decl, body, llfn, no_self, [], none,\n+        trans_closure(ccx, sub_path, decl, body, llfn, no_self, none,\n                       id, none, {|_fcx|});\n         C_null(T_opaque_box_ptr(ccx))\n       }"}, {"sha": "161256d5235a576193484297bfdb41f360a15938", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/168398bb3dc01f8efecf734342af60a959a74b8d/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168398bb3dc01f8efecf734342af60a959a74b8d/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=168398bb3dc01f8efecf734342af60a959a74b8d", "patch": "@@ -46,13 +46,15 @@ import std::map::hashmap;\n \n fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n               methods: [@ast::method], tps: [ast::ty_param]) {\n+    if tps.len() > 0u { ret; }\n     let sub_path = path + [path_name(name)];\n     for m in methods {\n-        let llfn = get_item_val(ccx, m.id);\n-        let m_bounds = param_bounds(ccx, tps + m.tps);\n-        trans_fn(ccx, sub_path + [path_name(m.ident)], m.decl, m.body,\n-                 llfn, impl_self(ty::node_id_to_type(ccx.tcx, m.self_id)),\n-                 m_bounds, none, m.id, none);\n+        if m.tps.len() == 0u {\n+            let llfn = get_item_val(ccx, m.id);\n+            trans_fn(ccx, sub_path + [path_name(m.ident)], m.decl, m.body,\n+                     llfn, impl_self(ty::node_id_to_type(ccx.tcx, m.self_id)),\n+                     none, m.id, none);\n+        }\n     }\n }\n \n@@ -335,6 +337,7 @@ fn trans_impl_wrapper(ccx: @crate_ctxt, pt: path,\n fn trans_impl_vtable(ccx: @crate_ctxt, pt: path,\n                      iface_id: ast::def_id, ms: [@ast::method],\n                      tps: [ast::ty_param], it: @ast::item) {\n+    if tps.len() > 0u { ret; }\n     let new_pt = pt + [path_name(it.ident), path_name(int::str(it.id)),\n                        path_name(\"wrap\")];\n     let extra_tps = param_bounds(ccx, tps);"}, {"sha": "3a681644f51d02cc3aa1e57b073c9ea97627bf04", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/168398bb3dc01f8efecf734342af60a959a74b8d/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168398bb3dc01f8efecf734342af60a959a74b8d/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=168398bb3dc01f8efecf734342af60a959a74b8d", "patch": "@@ -271,7 +271,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n             ccx, path + [ast_map::path_name(\"__rust_abi\")]);\n         let llty = type_of_fn_from_ty(ccx, t, []);\n         let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n-        trans_fn(ccx, path, decl, body, llfndecl, no_self, [], none, id,\n+        trans_fn(ccx, path, decl, body, llfndecl, no_self, none, id,\n                  none);\n         ret llfndecl;\n     }"}]}