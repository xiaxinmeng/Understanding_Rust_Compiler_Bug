{"sha": "901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwMWQyYzdiMGRiOGEwNWQ4ZTJmYmJhMGY4ZmQyNmI1MjBiMzgyZTc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-16T06:01:45Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-17T00:53:41Z"}, "message": "Rollup merge of #22241 - kmcallister:macro-plugin-cleanup, r=sfackler", "tree": {"sha": "de86c898f9ec8dd4ebf66b4221f8782cb9acfd96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de86c898f9ec8dd4ebf66b4221f8782cb9acfd96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "html_url": "https://github.com/rust-lang/rust/commit/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02fb58af055234becde6b874c6f02b5c778cef08", "url": "https://api.github.com/repos/rust-lang/rust/commits/02fb58af055234becde6b874c6f02b5c778cef08", "html_url": "https://github.com/rust-lang/rust/commit/02fb58af055234becde6b874c6f02b5c778cef08"}, {"sha": "b7683fc02b35cafc849b7097556f4f67c3adcfe9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7683fc02b35cafc849b7097556f4f67c3adcfe9", "html_url": "https://github.com/rust-lang/rust/commit/b7683fc02b35cafc849b7097556f4f67c3adcfe9"}], "stats": {"total": 639, "additions": 396, "deletions": 243}, "files": [{"sha": "79502f3cd17f755768cabac2c00c36c2f594f03a", "filename": "src/doc/trpl/plugins.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Fdoc%2Ftrpl%2Fplugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Fdoc%2Ftrpl%2Fplugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fplugins.md?ref=901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "patch": "@@ -39,6 +39,16 @@ If present, arguments passed as `#![plugin(foo(... args ...))]` are not\n interpreted by rustc itself.  They are provided to the plugin through the\n `Registry`'s [`args` method](../rustc/plugin/registry/struct.Registry.html#method.args).\n \n+In the vast majority of cases, a plugin should *only* be used through\n+`#![plugin]` and not through an `extern crate` item.  Linking a plugin would\n+pull in all of libsyntax and librustc as dependencies of your crate.  This is\n+generally unwanted unless you are building another plugin.  The\n+`plugin_as_library` lint checks these guidelines.\n+\n+The usual practice is to put compiler plugins in their own crate, separate from\n+any `macro_rules!` macros or ordinary Rust code meant to be used by consumers\n+of a library.\n+\n # Syntax extensions\n \n Plugins can extend Rust's syntax in various ways. One kind of syntax extension"}, {"sha": "d09e4bd975924f3392c3b417b1fcc542f641f9a4", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "patch": "@@ -26,7 +26,7 @@\n //! a `pub fn new()`.\n use self::MethodContext::*;\n \n-use metadata::csearch;\n+use metadata::{csearch, decoder};\n use middle::def::*;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n@@ -1964,6 +1964,48 @@ impl LintPass for UnconditionalRecursion {\n     }\n }\n \n+declare_lint! {\n+    PLUGIN_AS_LIBRARY,\n+    Warn,\n+    \"compiler plugin used as ordinary library in non-plugin crate\"\n+}\n+\n+#[derive(Copy)]\n+pub struct PluginAsLibrary;\n+\n+impl LintPass for PluginAsLibrary {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![PLUGIN_AS_LIBRARY]\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        if cx.sess().plugin_registrar_fn.get().is_some() {\n+            // We're compiling a plugin; it's fine to link other plugins.\n+            return;\n+        }\n+\n+        match it.node {\n+            ast::ItemExternCrate(..) => (),\n+            _ => return,\n+        };\n+\n+        let md = match cx.sess().cstore.find_extern_mod_stmt_cnum(it.id) {\n+            Some(cnum) => cx.sess().cstore.get_crate_data(cnum),\n+            None => {\n+                // Probably means we aren't linking the crate for some reason.\n+                //\n+                // Not sure if / when this could happen.\n+                return;\n+            }\n+        };\n+\n+        if decoder::get_plugin_registrar_fn(md.data()).is_some() {\n+            cx.span_lint(PLUGIN_AS_LIBRARY, it.span,\n+                \"compiler plugin used as an ordinary library\");\n+        }\n+    }\n+}\n+\n declare_lint! {\n     pub UNUSED_IMPORTS,\n     Warn,"}, {"sha": "42a6861f452a66f95d6f0f0c301979165a92264a", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "patch": "@@ -214,6 +214,7 @@ impl LintStore {\n                      Stability,\n                      UnconditionalRecursion,\n                      InvalidNoMangleItems,\n+                     PluginAsLibrary,\n         );\n \n         add_builtin_with_new!(sess,"}, {"sha": "0871c36d892c6cb30ed6135e9fb763e760db58fb", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 29, "deletions": 47, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "patch": "@@ -121,12 +121,10 @@ fn register_native_lib(sess: &Session,\n     sess.cstore.add_used_library(name, kind);\n }\n \n-pub struct PluginMetadata<'a> {\n-    sess: &'a Session,\n+// Extra info about a crate loaded for plugins or exported macros.\n+struct ExtensionCrate {\n     metadata: PMDSource,\n     dylib: Option<Path>,\n-    info: CrateInfo,\n-    vi_span: Span,\n     target_only: bool,\n }\n \n@@ -451,21 +449,7 @@ impl<'a> CrateReader<'a> {\n         }).collect()\n     }\n \n-    pub fn read_plugin_metadata<'b>(&'b mut self,\n-                                    krate: CrateOrString<'b>) -> PluginMetadata<'b> {\n-        let (info, span) = match krate {\n-            CrateOrString::Krate(c) => {\n-                (self.extract_crate_info(c).unwrap(), c.span)\n-            }\n-            CrateOrString::Str(sp, s) => {\n-                (CrateInfo {\n-                     name: s.to_string(),\n-                     ident: s.to_string(),\n-                     id: ast::DUMMY_NODE_ID,\n-                     should_link: false,\n-                 }, sp)\n-            }\n-        };\n+    fn read_extension_crate(&mut self, span: Span, info: &CrateInfo) -> ExtensionCrate {\n         let target_triple = &self.sess.opts.target_triple[];\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n@@ -517,30 +501,21 @@ impl<'a> CrateReader<'a> {\n             PMDSource::Owned(library.metadata)\n         };\n \n-        PluginMetadata {\n-            sess: self.sess,\n+        ExtensionCrate {\n             metadata: metadata,\n             dylib: dylib.map(|p| p.0),\n-            info: info,\n-            vi_span: span,\n             target_only: target_only,\n         }\n     }\n-}\n \n-#[derive(Copy)]\n-pub enum CrateOrString<'a> {\n-    Krate(&'a ast::Item),\n-    Str(Span, &'a str)\n-}\n+    /// Read exported macros.\n+    pub fn read_exported_macros(&mut self, krate: &ast::Item) -> Vec<ast::MacroDef> {\n+        let ci = self.extract_crate_info(krate).unwrap();\n+        let ekrate = self.read_extension_crate(krate.span, &ci);\n \n-impl<'a> PluginMetadata<'a> {\n-    /// Read exported macros\n-    pub fn exported_macros(&self) -> Vec<ast::MacroDef> {\n-        let imported_from = Some(token::intern(&self.info.ident[]).ident());\n-        let source_name = format!(\"<{} macros>\", &self.info.ident[]);\n+        let source_name = format!(\"<{} macros>\", krate.ident);\n         let mut macros = vec![];\n-        decoder::each_exported_macro(self.metadata.as_slice(),\n+        decoder::each_exported_macro(ekrate.metadata.as_slice(),\n                                      &*self.sess.cstore.intr,\n             |name, attrs, body| {\n                 // NB: Don't use parse::parse_tts_from_source_str because it parses with\n@@ -558,7 +533,7 @@ impl<'a> PluginMetadata<'a> {\n                     attrs: attrs,\n                     id: ast::DUMMY_NODE_ID,\n                     span: span,\n-                    imported_from: imported_from,\n+                    imported_from: Some(krate.ident),\n                     // overridden in plugin/load.rs\n                     export: false,\n                     use_locally: false,\n@@ -572,28 +547,35 @@ impl<'a> PluginMetadata<'a> {\n     }\n \n     /// Look for a plugin registrar. Returns library path and symbol name.\n-    pub fn plugin_registrar(&self) -> Option<(Path, String)> {\n-        if self.target_only {\n+    pub fn find_plugin_registrar(&mut self, span: Span, name: &str) -> Option<(Path, String)> {\n+        let ekrate = self.read_extension_crate(span, &CrateInfo {\n+             name: name.to_string(),\n+             ident: name.to_string(),\n+             id: ast::DUMMY_NODE_ID,\n+             should_link: false,\n+        });\n+\n+        if ekrate.target_only {\n             // Need to abort before syntax expansion.\n-            let message = format!(\"plugin crate `{}` is not available for triple `{}` \\\n+            let message = format!(\"plugin `{}` is not available for triple `{}` \\\n                                    (only found {})\",\n-                                  self.info.ident,\n+                                  name,\n                                   config::host_triple(),\n                                   self.sess.opts.target_triple);\n-            self.sess.span_err(self.vi_span, &message[]);\n+            self.sess.span_err(span, &message[]);\n             self.sess.abort_if_errors();\n         }\n \n-        let registrar = decoder::get_plugin_registrar_fn(self.metadata.as_slice())\n-            .map(|id| decoder::get_symbol(self.metadata.as_slice(), id));\n+        let registrar = decoder::get_plugin_registrar_fn(ekrate.metadata.as_slice())\n+            .map(|id| decoder::get_symbol(ekrate.metadata.as_slice(), id));\n \n-        match (self.dylib.as_ref(), registrar) {\n+        match (ekrate.dylib.as_ref(), registrar) {\n             (Some(dylib), Some(reg)) => Some((dylib.clone(), reg)),\n             (None, Some(_)) => {\n-                let message = format!(\"plugin crate `{}` only found in rlib format, \\\n+                let message = format!(\"plugin `{}` only found in rlib format, \\\n                                        but must be available in dylib format\",\n-                                       self.info.ident);\n-                self.sess.span_err(self.vi_span, &message[]);\n+                                       name);\n+                self.sess.span_err(span, &message[]);\n                 // No need to abort because the loading code will just ignore this\n                 // empty dylib.\n                 None"}, {"sha": "28c98d455f046dc2e04601c1ce421275b52492af", "filename": "src/librustc/metadata/macro_import.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs?ref=901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "patch": "@@ -0,0 +1,186 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Used by `rustc` when loading a crate with exported macros.\n+\n+use session::Session;\n+use metadata::creader::CrateReader;\n+\n+use std::collections::{HashSet, HashMap};\n+use syntax::ast;\n+use syntax::attr;\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+use syntax::attr::AttrMetaMethods;\n+\n+struct MacroLoader<'a> {\n+    sess: &'a Session,\n+    span_whitelist: HashSet<Span>,\n+    reader: CrateReader<'a>,\n+    macros: Vec<ast::MacroDef>,\n+}\n+\n+impl<'a> MacroLoader<'a> {\n+    fn new(sess: &'a Session) -> MacroLoader<'a> {\n+        MacroLoader {\n+            sess: sess,\n+            span_whitelist: HashSet::new(),\n+            reader: CrateReader::new(sess),\n+            macros: vec![],\n+        }\n+    }\n+}\n+\n+/// Read exported macros.\n+pub fn read_macro_defs(sess: &Session, krate: &ast::Crate) -> Vec<ast::MacroDef> {\n+    let mut loader = MacroLoader::new(sess);\n+\n+    // We need to error on `#[macro_use] extern crate` when it isn't at the\n+    // crate root, because `$crate` won't work properly. Identify these by\n+    // spans, because the crate map isn't set up yet.\n+    for item in &krate.module.items {\n+        if let ast::ItemExternCrate(_) = item.node {\n+            loader.span_whitelist.insert(item.span);\n+        }\n+    }\n+\n+    visit::walk_crate(&mut loader, krate);\n+\n+    loader.macros\n+}\n+\n+pub type MacroSelection = HashMap<token::InternedString, Span>;\n+\n+// note that macros aren't expanded yet, and therefore macros can't add macro imports.\n+impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        // We're only interested in `extern crate`.\n+        match item.node {\n+            ast::ItemExternCrate(_) => {}\n+            _ => {\n+                visit::walk_item(self, item);\n+                return;\n+            }\n+        }\n+\n+        // Parse the attributes relating to macros.\n+        let mut import = Some(HashMap::new());  // None => load all\n+        let mut reexport = HashMap::new();\n+\n+        for attr in &item.attrs {\n+            let mut used = true;\n+            match &attr.name()[] {\n+                \"phase\" => {\n+                    self.sess.span_err(attr.span, \"#[phase] is deprecated\");\n+                }\n+                \"plugin\" => {\n+                    self.sess.span_err(attr.span, \"#[plugin] on `extern crate` is deprecated\");\n+                    self.sess.span_help(attr.span, &format!(\"use a crate attribute instead, \\\n+                                                            i.e. #![plugin({})]\",\n+                                                            item.ident.as_str())[]);\n+                }\n+                \"macro_use\" => {\n+                    let names = attr.meta_item_list();\n+                    if names.is_none() {\n+                        // no names => load all\n+                        import = None;\n+                    }\n+                    if let (Some(sel), Some(names)) = (import.as_mut(), names) {\n+                        for attr in names {\n+                            if let ast::MetaWord(ref name) = attr.node {\n+                                sel.insert(name.clone(), attr.span);\n+                            } else {\n+                                self.sess.span_err(attr.span, \"bad macro import\");\n+                            }\n+                        }\n+                    }\n+                }\n+                \"macro_reexport\" => {\n+                    let names = match attr.meta_item_list() {\n+                        Some(names) => names,\n+                        None => {\n+                            self.sess.span_err(attr.span, \"bad macro reexport\");\n+                            continue;\n+                        }\n+                    };\n+\n+                    for attr in names {\n+                        if let ast::MetaWord(ref name) = attr.node {\n+                            reexport.insert(name.clone(), attr.span);\n+                        } else {\n+                            self.sess.span_err(attr.span, \"bad macro reexport\");\n+                        }\n+                    }\n+                }\n+                _ => used = false,\n+            }\n+            if used {\n+                attr::mark_used(attr);\n+            }\n+        }\n+\n+        self.load_macros(item, import, reexport)\n+    }\n+\n+    fn visit_mac(&mut self, _: &ast::Mac) {\n+        // bummer... can't see macro imports inside macros.\n+        // do nothing.\n+    }\n+}\n+\n+impl<'a> MacroLoader<'a> {\n+    fn load_macros<'b>(&mut self,\n+                       vi: &ast::Item,\n+                       import: Option<MacroSelection>,\n+                       reexport: MacroSelection) {\n+        if let Some(sel) = import.as_ref() {\n+            if sel.is_empty() && reexport.is_empty() {\n+                return;\n+            }\n+        }\n+\n+        if !self.span_whitelist.contains(&vi.span) {\n+            self.sess.span_err(vi.span, \"an `extern crate` loading macros must be at \\\n+                                         the crate root\");\n+            return;\n+        }\n+\n+        let macros = self.reader.read_exported_macros(vi);\n+        let mut seen = HashSet::new();\n+\n+        for mut def in macros {\n+            let name = token::get_ident(def.ident);\n+            seen.insert(name.clone());\n+\n+            def.use_locally = match import.as_ref() {\n+                None => true,\n+                Some(sel) => sel.contains_key(&name),\n+            };\n+            def.export = reexport.contains_key(&name);\n+            self.macros.push(def);\n+        }\n+\n+        if let Some(sel) = import.as_ref() {\n+            for (name, span) in sel.iter() {\n+                if !seen.contains(name) {\n+                    self.sess.span_err(*span, \"imported macro not found\");\n+                }\n+            }\n+        }\n+\n+        for (name, span) in reexport.iter() {\n+            if !seen.contains(name) {\n+                self.sess.span_err(*span, \"reexported macro not found\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "0bf1e6d198fa2ad1fab28f8f611c6d4ae06a7c24", "filename": "src/librustc/metadata/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Flibrustc%2Fmetadata%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Flibrustc%2Fmetadata%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmod.rs?ref=901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "patch": "@@ -18,3 +18,4 @@ pub mod cstore;\n pub mod csearch;\n pub mod loader;\n pub mod filesearch;\n+pub mod macro_import;"}, {"sha": "1895cbcb5421e341f051dd3b4c6109b8dc6f811e", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 21, "deletions": 190, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "patch": "@@ -8,24 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Used by `rustc` when loading a plugin, or a crate with exported macros.\n+//! Used by `rustc` when loading a plugin.\n \n use session::Session;\n-use metadata::creader::{CrateOrString, CrateReader};\n+use metadata::creader::CrateReader;\n use plugin::registry::Registry;\n \n use std::mem;\n use std::env;\n use std::dynamic_lib::DynamicLibrary;\n-use std::collections::{HashSet, HashMap};\n use std::borrow::ToOwned;\n use syntax::ast;\n-use syntax::attr;\n use syntax::codemap::{Span, COMMAND_LINE_SP};\n-use syntax::parse::token;\n use syntax::ptr::P;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n use syntax::attr::AttrMetaMethods;\n \n /// Pointer to a registrar function.\n@@ -37,51 +32,17 @@ pub struct PluginRegistrar {\n     pub args: Vec<P<ast::MetaItem>>,\n }\n \n-/// Information about loaded plugins.\n-pub struct Plugins {\n-    /// Imported macros.\n-    pub macros: Vec<ast::MacroDef>,\n-    /// Registrars, as function pointers.\n-    pub registrars: Vec<PluginRegistrar>,\n-}\n-\n-pub struct PluginLoader<'a> {\n+struct PluginLoader<'a> {\n     sess: &'a Session,\n-    span_whitelist: HashSet<Span>,\n     reader: CrateReader<'a>,\n-    pub plugins: Plugins,\n-}\n-\n-impl<'a> PluginLoader<'a> {\n-    fn new(sess: &'a Session) -> PluginLoader<'a> {\n-        PluginLoader {\n-            sess: sess,\n-            reader: CrateReader::new(sess),\n-            span_whitelist: HashSet::new(),\n-            plugins: Plugins {\n-                macros: vec!(),\n-                registrars: vec!(),\n-            },\n-        }\n-    }\n+    plugins: Vec<PluginRegistrar>,\n }\n \n /// Read plugin metadata and dynamically load registrar functions.\n pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n-                    addl_plugins: Option<Vec<String>>) -> Plugins {\n+                    addl_plugins: Option<Vec<String>>) -> Vec<PluginRegistrar> {\n     let mut loader = PluginLoader::new(sess);\n \n-    // We need to error on `#[macro_use] extern crate` when it isn't at the\n-    // crate root, because `$crate` won't work properly. Identify these by\n-    // spans, because the crate map isn't set up yet.\n-    for item in &krate.module.items {\n-        if let ast::ItemExternCrate(_) = item.node {\n-            loader.span_whitelist.insert(item.span);\n-        }\n-    }\n-\n-    visit::walk_crate(&mut loader, krate);\n-\n     for attr in &krate.attrs {\n         if !attr.check_name(\"plugin\") {\n             continue;\n@@ -102,165 +63,43 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n             }\n \n             let args = plugin.meta_item_list().map(ToOwned::to_owned).unwrap_or_default();\n-            loader.load_plugin(CrateOrString::Str(plugin.span, &*plugin.name()),\n-                               args);\n+            loader.load_plugin(plugin.span, &*plugin.name(), args);\n         }\n     }\n \n     if let Some(plugins) = addl_plugins {\n         for plugin in plugins {\n-            loader.load_plugin(CrateOrString::Str(COMMAND_LINE_SP, &plugin), vec![]);\n-        }\n-    }\n-\n-    return loader.plugins;\n-}\n-\n-pub type MacroSelection = HashMap<token::InternedString, Span>;\n-\n-// note that macros aren't expanded yet, and therefore macros can't add plugins.\n-impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        // We're only interested in `extern crate`.\n-        match item.node {\n-            ast::ItemExternCrate(_) => {}\n-            _ => {\n-                visit::walk_item(self, item);\n-                return;\n-            }\n-        }\n-\n-        // Parse the attributes relating to macro loading.\n-        let mut import = Some(HashMap::new());  // None => load all\n-        let mut reexport = HashMap::new();\n-        for attr in &item.attrs {\n-            let mut used = true;\n-            match &attr.name()[] {\n-                \"phase\" => {\n-                    self.sess.span_err(attr.span, \"#[phase] is deprecated\");\n-                }\n-                \"plugin\" => {\n-                    self.sess.span_err(attr.span, \"#[plugin] on `extern crate` is deprecated\");\n-                    self.sess.span_help(attr.span, &format!(\"use a crate attribute instead, \\\n-                                                            i.e. #![plugin({})]\",\n-                                                            item.ident.as_str())[]);\n-                }\n-                \"macro_use\" => {\n-                    let names = attr.meta_item_list();\n-                    if names.is_none() {\n-                        // no names => load all\n-                        import = None;\n-                    }\n-                    if let (Some(sel), Some(names)) = (import.as_mut(), names) {\n-                        for attr in names {\n-                            if let ast::MetaWord(ref name) = attr.node {\n-                                sel.insert(name.clone(), attr.span);\n-                            } else {\n-                                self.sess.span_err(attr.span, \"bad macro import\");\n-                            }\n-                        }\n-                    }\n-                }\n-                \"macro_reexport\" => {\n-                    let names = match attr.meta_item_list() {\n-                        Some(names) => names,\n-                        None => {\n-                            self.sess.span_err(attr.span, \"bad macro reexport\");\n-                            continue;\n-                        }\n-                    };\n-\n-                    for attr in names {\n-                        if let ast::MetaWord(ref name) = attr.node {\n-                            reexport.insert(name.clone(), attr.span);\n-                        } else {\n-                            self.sess.span_err(attr.span, \"bad macro reexport\");\n-                        }\n-                    }\n-                }\n-                _ => used = false,\n-            }\n-            if used {\n-                attr::mark_used(attr);\n-            }\n+            loader.load_plugin(COMMAND_LINE_SP, &plugin, vec![]);\n         }\n-\n-        self.load_macros(item, import, reexport)\n     }\n \n-    fn visit_mac(&mut self, _: &ast::Mac) {\n-        // bummer... can't see plugins inside macros.\n-        // do nothing.\n-    }\n+    loader.plugins\n }\n \n impl<'a> PluginLoader<'a> {\n-    pub fn load_macros<'b>(&mut self,\n-                           vi: &ast::Item,\n-                           import: Option<MacroSelection>,\n-                           reexport: MacroSelection) {\n-        if let Some(sel) = import.as_ref() {\n-            if sel.is_empty() && reexport.is_empty() {\n-                return;\n-            }\n-        }\n-\n-        if !self.span_whitelist.contains(&vi.span) {\n-            self.sess.span_err(vi.span, \"an `extern crate` loading macros must be at \\\n-                                         the crate root\");\n-            return;\n-        }\n-\n-        let pmd = self.reader.read_plugin_metadata(CrateOrString::Krate(vi));\n-\n-        let mut seen = HashSet::new();\n-        for mut def in pmd.exported_macros() {\n-            let name = token::get_ident(def.ident);\n-            seen.insert(name.clone());\n-\n-            def.use_locally = match import.as_ref() {\n-                None => true,\n-                Some(sel) => sel.contains_key(&name),\n-            };\n-            def.export = reexport.contains_key(&name);\n-            self.plugins.macros.push(def);\n-        }\n-\n-        if let Some(sel) = import.as_ref() {\n-            for (name, span) in sel.iter() {\n-                if !seen.contains(name) {\n-                    self.sess.span_err(*span, \"imported macro not found\");\n-                }\n-            }\n-        }\n-\n-        for (name, span) in reexport.iter() {\n-            if !seen.contains(name) {\n-                self.sess.span_err(*span, \"reexported macro not found\");\n-            }\n+    fn new(sess: &'a Session) -> PluginLoader<'a> {\n+        PluginLoader {\n+            sess: sess,\n+            reader: CrateReader::new(sess),\n+            plugins: vec![],\n         }\n     }\n \n-    pub fn load_plugin<'b>(&mut self,\n-                           c: CrateOrString<'b>,\n-                           args: Vec<P<ast::MetaItem>>) {\n-        let registrar = {\n-            let pmd = self.reader.read_plugin_metadata(c);\n-            pmd.plugin_registrar()\n-        };\n+    fn load_plugin(&mut self, span: Span, name: &str, args: Vec<P<ast::MetaItem>>) {\n+        let registrar = self.reader.find_plugin_registrar(span, name);\n \n         if let Some((lib, symbol)) = registrar {\n-            let fun = self.dylink_registrar(c, lib, symbol);\n-            self.plugins.registrars.push(PluginRegistrar {\n+            let fun = self.dylink_registrar(span, lib, symbol);\n+            self.plugins.push(PluginRegistrar {\n                 fun: fun,\n                 args: args,\n             });\n         }\n     }\n \n     // Dynamically link a registrar function into the compiler process.\n-    fn dylink_registrar<'b>(&mut self,\n-                        c: CrateOrString<'b>,\n+    fn dylink_registrar(&mut self,\n+                        span: Span,\n                         path: Path,\n                         symbol: String) -> PluginRegistrarFun {\n         // Make sure the path contains a / or the linker will search for it.\n@@ -272,11 +111,7 @@ impl<'a> PluginLoader<'a> {\n             // inside this crate, so continue would spew \"macro undefined\"\n             // errors\n             Err(err) => {\n-                if let CrateOrString::Krate(cr) = c {\n-                    self.sess.span_fatal(cr.span, &err[])\n-                } else {\n-                    self.sess.fatal(&err[])\n-                }\n+                self.sess.span_fatal(span, &err[])\n             }\n         };\n \n@@ -288,11 +123,7 @@ impl<'a> PluginLoader<'a> {\n                     }\n                     // again fatal if we can't register macros\n                     Err(err) => {\n-                        if let CrateOrString::Krate(cr) = c {\n-                            self.sess.span_fatal(cr.span, &err[])\n-                        } else {\n-                            self.sess.fatal(&err[])\n-                        }\n+                        self.sess.span_fatal(span, &err[])\n                     }\n                 };\n "}, {"sha": "eb1dba7159cf8a537b1633b463703c5c4e9b72b3", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "patch": "@@ -12,11 +12,11 @@ use rustc::session::Session;\n use rustc::session::config::{self, Input, OutputFilenames};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n+use rustc::metadata;\n use rustc::metadata::creader::CrateReader;\n use rustc::middle::{stability, ty, reachable};\n use rustc::middle::dependency_format;\n use rustc::middle;\n-use rustc::plugin::load::Plugins;\n use rustc::plugin::registry::Registry;\n use rustc::plugin;\n use rustc::util::common::time;\n@@ -409,10 +409,12 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                  syntax::std_inject::maybe_inject_crates_ref(krate,\n                                                              sess.opts.alt_std_name.clone()));\n \n+    let macros = time(time_passes, \"macro loading\", (), |_|\n+        metadata::macro_import::read_macro_defs(sess, &krate));\n+\n     let mut addl_plugins = Some(addl_plugins);\n-    let Plugins { macros, registrars }\n-        = time(time_passes, \"plugin loading\", (), |_|\n-               plugin::load::load_plugins(sess, &krate, addl_plugins.take().unwrap()));\n+    let registrars = time(time_passes, \"plugin loading\", (), |_|\n+        plugin::load::load_plugins(sess, &krate, addl_plugins.take().unwrap()));\n \n     let mut registry = Registry::new(sess, &krate);\n "}, {"sha": "cfc8c015324d9384edfcbb88cb5f8b47717b39df", "filename": "src/test/auxiliary/plugin_with_plugin_lib.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Ftest%2Fauxiliary%2Fplugin_with_plugin_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Ftest%2Fauxiliary%2Fplugin_with_plugin_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_with_plugin_lib.rs?ref=901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+\n+#![feature(plugin_registrar)]\n+#![deny(plugin_as_library)] // should have no effect in a plugin crate\n+\n+extern crate macro_crate_test;\n+extern crate rustc;\n+\n+use rustc::plugin::Registry;\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(_: &mut Registry) { }"}, {"sha": "7a362994b8db6fe6948a3cd8bfef77b0e324118b", "filename": "src/test/compile-fail-fulldeps/macro-crate-rlib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-rlib.rs?ref=901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "patch": "@@ -16,6 +16,6 @@\n \n #![feature(plugin)]\n #![plugin(rlib_crate_test)]\n-//~^ ERROR: plugin crate `rlib_crate_test` only found in rlib format, but must be available in dylib format\n+//~^ ERROR: plugin `rlib_crate_test` only found in rlib format, but must be available in dylib format\n \n fn main() {}"}, {"sha": "c5169b61a2bf9df2dbe58a3d3f041aec3734c9d9", "filename": "src/test/compile-fail-fulldeps/plugin-as-extern-crate.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-as-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-as-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-as-extern-crate.rs?ref=901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+// ignore-stage1\n+// ignore-cross-compile\n+//\n+// macro_crate_test will not compile on a cross-compiled target because\n+// libsyntax is not compiled for it.\n+\n+#![deny(plugin_as_library)]\n+\n+extern crate macro_crate_test; //~ ERROR compiler plugin used as an ordinary library\n+\n+fn main() { }"}, {"sha": "3dfd8838ebec40ca172830f79e3106a4a77690ae", "filename": "src/test/compile-fail-fulldeps/plugin-plus-extern-crate.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-plus-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-plus-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-plus-extern-crate.rs?ref=901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+// ignore-stage1\n+// ignore-cross-compile\n+//\n+// macro_crate_test will not compile on a cross-compiled target because\n+// libsyntax is not compiled for it.\n+\n+#![deny(plugin_as_library)]\n+#![feature(plugin)]\n+#![plugin(macro_crate_test)]\n+\n+extern crate macro_crate_test; //~ ERROR compiler plugin used as an ordinary library\n+\n+fn main() {\n+    assert_eq!(1, make_a_1!());\n+    macro_crate_test::foo();\n+}"}, {"sha": "c612ee75651bab413affb5a0cb4cb1a3ee869347", "filename": "src/test/run-pass-fulldeps/plugin-lib-ok-in-plugin.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-lib-ok-in-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-lib-ok-in-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-lib-ok-in-plugin.rs?ref=901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+// aux-build:plugin_with_plugin_lib.rs\n+// ignore-stage1\n+// ignore-cross-compile\n+//\n+// macro_crate_test will not compile on a cross-compiled target because\n+// libsyntax is not compiled for it.\n+\n+#![deny(plugin_as_library)]\n+#![feature(plugin)]\n+#![plugin(macro_crate_test)]\n+#![plugin(plugin_with_plugin_lib)]\n+\n+fn main() {\n+    assert_eq!(1, make_a_1!());\n+}"}, {"sha": "d1ce83f26778847cbb484ea8abc392d9cf9425c4", "filename": "src/test/run-pass-fulldeps/plugin-plus-extern-crate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-plus-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-plus-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-plus-extern-crate.rs?ref=901d2c7b0db8a05d8e2fbba0f8fd26b520b382e7", "patch": "@@ -15,6 +15,7 @@\n // macro_crate_test will not compile on a cross-compiled target because\n // libsyntax is not compiled for it.\n \n+#![allow(plugin_as_library)]\n #![feature(plugin)]\n #![plugin(macro_crate_test)]\n "}]}