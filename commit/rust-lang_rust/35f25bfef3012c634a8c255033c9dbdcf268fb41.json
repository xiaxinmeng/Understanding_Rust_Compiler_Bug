{"sha": "35f25bfef3012c634a8c255033c9dbdcf268fb41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZjI1YmZlZjMwMTJjNjM0YThjMjU1MDMzYzlkYmRjZjI2OGZiNDE=", "commit": {"author": {"name": "Bernardo Meurer", "email": "meurerbernardo@gmail.com", "date": "2018-08-22T19:58:39Z"}, "committer": {"name": "Bernardo Meurer", "email": "meurerbernardo@gmail.com", "date": "2018-08-23T15:54:23Z"}, "message": "Reflow and fixup comments", "tree": {"sha": "c47a043cef37ffa81a49969c1cdd24bd9e986d03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c47a043cef37ffa81a49969c1cdd24bd9e986d03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35f25bfef3012c634a8c255033c9dbdcf268fb41", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQEcBAABAgAGBQJbftixAAoJEOQhx0GR6hhslUUIAJs+JjZktpE91Zh6iZ1gka5b\n6WZV9slC+v9DnvLNZ0s1w3Wwu4HOVzeWNXlqWTW7ggqpszdBilRQHGsfci4mJdTm\nG/37vcVapPhDSO1Bw6PJp6KtAxokVzGCWEYEfWeGmFxDBnmHm9tsEMLQF5DFyGHg\n7zMqX0dzaO+avz/aP8YgkhKGNHD3fpHZw5R76M2xWhZac0tjydYIE1JiNyW0ImqC\n1FpHgwt5l2vIaEyRqGdHTSvi29PRgbYQjRsVNZQ/TF176bkTgZVMs8LX6YS2crub\njaj+R5X0RnRiX3vAFGrguvdhLxOs2puzzt8fgQ5U17YqLB3qf42WiHMDeRYHjwg=\n=HtIt\n-----END PGP SIGNATURE-----", "payload": "tree c47a043cef37ffa81a49969c1cdd24bd9e986d03\nparent 37db3db53dd1cd34b22efb52e2cd79b34aeb7e11\nauthor Bernardo Meurer <meurerbernardo@gmail.com> 1534967919 -0300\ncommitter Bernardo Meurer <meurerbernardo@gmail.com> 1535039663 -0700\n\nReflow and fixup comments\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35f25bfef3012c634a8c255033c9dbdcf268fb41", "html_url": "https://github.com/rust-lang/rust/commit/35f25bfef3012c634a8c255033c9dbdcf268fb41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35f25bfef3012c634a8c255033c9dbdcf268fb41/comments", "author": {"login": "lovesegfault", "id": 7243783, "node_id": "MDQ6VXNlcjcyNDM3ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/7243783?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lovesegfault", "html_url": "https://github.com/lovesegfault", "followers_url": "https://api.github.com/users/lovesegfault/followers", "following_url": "https://api.github.com/users/lovesegfault/following{/other_user}", "gists_url": "https://api.github.com/users/lovesegfault/gists{/gist_id}", "starred_url": "https://api.github.com/users/lovesegfault/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lovesegfault/subscriptions", "organizations_url": "https://api.github.com/users/lovesegfault/orgs", "repos_url": "https://api.github.com/users/lovesegfault/repos", "events_url": "https://api.github.com/users/lovesegfault/events{/privacy}", "received_events_url": "https://api.github.com/users/lovesegfault/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lovesegfault", "id": 7243783, "node_id": "MDQ6VXNlcjcyNDM3ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/7243783?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lovesegfault", "html_url": "https://github.com/lovesegfault", "followers_url": "https://api.github.com/users/lovesegfault/followers", "following_url": "https://api.github.com/users/lovesegfault/following{/other_user}", "gists_url": "https://api.github.com/users/lovesegfault/gists{/gist_id}", "starred_url": "https://api.github.com/users/lovesegfault/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lovesegfault/subscriptions", "organizations_url": "https://api.github.com/users/lovesegfault/orgs", "repos_url": "https://api.github.com/users/lovesegfault/repos", "events_url": "https://api.github.com/users/lovesegfault/events{/privacy}", "received_events_url": "https://api.github.com/users/lovesegfault/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37db3db53dd1cd34b22efb52e2cd79b34aeb7e11", "url": "https://api.github.com/repos/rust-lang/rust/commits/37db3db53dd1cd34b22efb52e2cd79b34aeb7e11", "html_url": "https://github.com/rust-lang/rust/commit/37db3db53dd1cd34b22efb52e2cd79b34aeb7e11"}], "stats": {"total": 80, "additions": 49, "deletions": 31}, "files": [{"sha": "6458c211ab537be78bfe70a4e8d2fa7963cc3072", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=35f25bfef3012c634a8c255033c9dbdcf268fb41", "patch": "@@ -50,7 +50,8 @@ use std::num::NonZeroU32;\n pub enum Lock {\n     NoLock,\n     WriteLock(DynamicLifetime),\n-    /// This should never be empty -- that would be a read lock held and nobody there to release it...\n+    /// This should never be empty -- that would be a read lock held and nobody\n+    /// there to release it...\n     ReadLock(Vec<DynamicLifetime>),\n }\n "}, {"sha": "aa172c7603ff5ec87a47a8dac3afe5dbcb773036", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=35f25bfef3012c634a8c255033c9dbdcf268fb41", "patch": "@@ -226,7 +226,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 Ok(Scalar::Bits { bits: v, size: 4 })\n             },\n \n-            // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n+            // No alignment check needed for raw pointers.\n+            // But we have to truncate to target ptr size.\n             RawPtr(_) => {\n                 Ok(Scalar::Bits {\n                     bits: self.memory.truncate_to_ptr(v).0 as u128,\n@@ -302,7 +303,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn cast_from_ptr(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Scalar> {\n         use rustc::ty::TyKind::*;\n         match ty.sty {\n-            // Casting to a reference or fn pointer is not permitted by rustc, no need to support it here.\n+            // Casting to a reference or fn pointer is not permitted by rustc,\n+            // no need to support it here.\n             RawPtr(_) |\n             Int(IntTy::Isize) |\n             Uint(UintTy::Usize) => Ok(ptr.into()),"}, {"sha": "3ea5fe89163f675d5d19645de37230ae7eccd085", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=35f25bfef3012c634a8c255033c9dbdcf268fb41", "patch": "@@ -92,7 +92,8 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     pub return_place: Place,\n \n     /// The list of locals for this stack frame, stored in order as\n-    /// `[return_ptr, arguments..., variables..., temporaries...]`. The locals are stored as `Option<Value>`s.\n+    /// `[return_ptr, arguments..., variables..., temporaries...]`.\n+    /// The locals are stored as `Option<Value>`s.\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n     pub locals: IndexVec<mir::Local, LocalValue>,\n@@ -624,7 +625,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         match frame.return_to_block {\n             StackPopCleanup::MarkStatic(mutable) => {\n                 if let Place::Ptr(MemPlace { ptr, .. }) = frame.return_place {\n-                    // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n+                    // FIXME: to_ptr()? might be too extreme here,\n+                    // static zsts might reach this under certain conditions\n                     self.memory.mark_static_initialized(\n                         ptr.to_ptr()?.alloc_id,\n                         mutable,"}, {"sha": "3ed5d3cae234540d614ca3e9d165c0d57c757d76", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=35f25bfef3012c634a8c255033c9dbdcf268fb41", "patch": "@@ -243,11 +243,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         let alloc_kind = self.alloc_kind.remove(&ptr.alloc_id).expect(\"alloc_map out of sync with alloc_kind\");\n \n-        // It is okay for us to still holds locks on deallocation -- for example, we could store data we own\n-        // in a local, and the local could be deallocated (from StorageDead) before the function returns.\n-        // However, we should check *something*.  For now, we make sure that there is no conflicting write\n-        // lock by another frame.  We *have* to permit deallocation if we hold a read lock.\n-        // TODO: Figure out the exact rules here.\n+        // It is okay for us to still holds locks on deallocation -- for example, we could store\n+        // data we own in a local, and the local could be deallocated (from StorageDead) before the\n+        // function returns. However, we should check *something*.  For now, we make sure that there\n+        // is no conflicting write lock by another frame.  We *have* to permit deallocation if we\n+        // hold a read lock.\n+        // FIXME: Figure out the exact rules here.\n         M::free_lock(self, ptr.alloc_id, alloc.bytes.len() as u64)?;\n \n         if alloc_kind != kind {\n@@ -521,13 +522,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &[u8]> {\n-        // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n+        // Zero-sized accesses can use dangling pointers,\n+        // but they still have to be aligned and non-NULL\n         self.check_align(ptr.into(), align)?;\n         if size.bytes() == 0 {\n             return Ok(&[]);\n         }\n         M::check_locks(self, ptr, size, AccessKind::Read)?;\n-        self.check_bounds(ptr.offset(size, self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_bounds(ptr.offset(size, self)?, true)?;\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n@@ -542,13 +545,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n-        // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n+        // Zero-sized accesses can use dangling pointers,\n+        // but they still have to be aligned and non-NULL\n         self.check_align(ptr.into(), align)?;\n         if size.bytes() == 0 {\n             return Ok(&mut []);\n         }\n         M::check_locks(self, ptr, size, AccessKind::Write)?;\n-        self.check_bounds(ptr.offset(size, &*self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_bounds(ptr.offset(size, &*self)?, true)?;\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n@@ -774,14 +779,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     /// Read a *non-ZST* scalar\n     pub fn read_scalar(&self, ptr: Pointer, ptr_align: Align, size: Size) -> EvalResult<'tcx, ScalarMaybeUndef> {\n-        self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n+        // Make sure we don't read part of a pointer as a pointer\n+        self.check_relocation_edges(ptr, size)?;\n         let endianness = self.endianness();\n         // get_bytes_unchecked tests alignment\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n-            // this inflates undefined bytes to the entire scalar, even if only a few bytes are undefined\n+            // this inflates undefined bytes to the entire scalar,\n+            // even if only a few bytes are undefined\n             return Ok(ScalarMaybeUndef::Undef);\n         }\n         // Now we do the actual reading"}, {"sha": "cf21e0238324f71147be23b97438a6fafe10a474", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=35f25bfef3012c634a8c255033c9dbdcf268fb41", "patch": "@@ -119,8 +119,9 @@ impl MemPlace {\n     /// Extract the ptr part of the mplace\n     #[inline(always)]\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n-        // At this point, we forget about the alignment information -- the place has been turned into a reference,\n-        // and no matter where it came from, it now must be aligned.\n+        // At this point, we forget about the alignment information --\n+        // the place has been turned into a reference, and no matter where it came from,\n+        // it now must be aligned.\n         self.to_scalar_ptr_align().0.to_ptr()\n     }\n \n@@ -582,9 +583,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         dest: MPlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let (ptr, ptr_align) = dest.to_scalar_ptr_align();\n-        // Note that it is really important that the type here is the right one, and matches the type things are read at.\n-        // In case `src_val` is a `ScalarPair`, we don't do any magic here to handle padding properly, which is only\n-        // correct if we never look at this data with the wrong type.\n+        // Note that it is really important that the type here is the right one, and matches the\n+        // type things are read at. In case `src_val` is a `ScalarPair`, we don't do any magic here\n+        // to handle padding properly, which is only correct if we never look at this data with the\n+        // wrong type.\n \n         // Nothing to do for ZSTs, other than checking alignment\n         if dest.layout.size.bytes() == 0 {"}, {"sha": "1648bd2f9db541266d991c0c3a65935acbe31166", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=35f25bfef3012c634a8c255033c9dbdcf268fb41", "patch": "@@ -108,8 +108,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         use rustc::mir::StatementKind::*;\n \n-        // Some statements (e.g. box) push new stack frames.  We have to record the stack frame number\n-        // *before* executing the statement.\n+        // Some statements (e.g. box) push new stack frames.\n+        // We have to record the stack frame number *before* executing the statement.\n         let frame_idx = self.cur_frame();\n         self.tcx.span = stmt.source_info.span;\n         self.memory.tcx.span = stmt.source_info.span;"}, {"sha": "8e413aa8284fb6c584a5f00e7c83e38359bc8c2b", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=35f25bfef3012c634a8c255033c9dbdcf268fb41", "patch": "@@ -24,9 +24,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         target: BasicBlock,\n     ) -> EvalResult<'tcx> {\n         trace!(\"drop_in_place: {:?},\\n  {:?}, {:?}\", *place, place.layout.ty, instance);\n-        // We take the address of the object.  This may well be unaligned, which is fine for us here.\n-        // However, unaligned accesses will probably make the actual drop implementation fail -- a problem shared\n-        // by rustc.\n+        // We take the address of the object.  This may well be unaligned, which is fine for us\n+        // here. However, unaligned accesses will probably make the actual drop implementation fail\n+        // -- a problem shared by rustc.\n         let place = self.force_allocation(place)?;\n \n         let (instance, place) = match place.layout.ty.sty {"}, {"sha": "10681e28e020d4bdd66d587b2c6090d0a528ced3", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=35f25bfef3012c634a8c255033c9dbdcf268fb41", "patch": "@@ -185,15 +185,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             DropAndReplace { .. } => unimplemented!(),\n             Resume => unimplemented!(),\n             Abort => unimplemented!(),\n-            FalseEdges { .. } => bug!(\"should have been eliminated by `simplify_branches` mir pass\"),\n-            FalseUnwind { .. } => bug!(\"should have been eliminated by `simplify_branches` mir pass\"),\n+            FalseEdges { .. } => bug!(\"should have been eliminated by\\\n+                                      `simplify_branches` mir pass\"),\n+            FalseUnwind { .. } => bug!(\"should have been eliminated by\\\n+                                       `simplify_branches` mir pass\"),\n             Unreachable => return err!(Unreachable),\n         }\n \n         Ok(())\n     }\n \n-    /// Decides whether it is okay to call the method with signature `real_sig` using signature `sig`.\n+    /// Decides whether it is okay to call the method with signature `real_sig`\n+    /// using signature `sig`.\n     /// FIXME: This should take into account the platform-dependent ABI description.\n     fn check_sig_compat(\n         &mut self,\n@@ -207,7 +210,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             return match (&ty.sty, &real_ty.sty) {\n                 // Permit changing the pointer type of raw pointers and references as well as\n                 // mutability of raw pointers.\n-                // TODO: Should not be allowed when fat pointers are involved.\n+                // FIXME: Should not be allowed when fat pointers are involved.\n                 (&ty::RawPtr(_), &ty::RawPtr(_)) => true,\n                 (&ty::Ref(_, _, _), &ty::Ref(_, _, _)) => {\n                     ty.is_mutable_pointer() == real_ty.is_mutable_pointer()"}, {"sha": "00fca7c586a5670356eda52768808240fc5b9eb4", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f25bfef3012c634a8c255033c9dbdcf268fb41/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=35f25bfef3012c634a8c255033c9dbdcf268fb41", "patch": "@@ -265,7 +265,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                 if value.layout.ty.builtin_deref(false).is_some() {\n                                     trace!(\"Recursing below ptr {:#?}\", value);\n                                     let ptr_place = self.ref_to_mplace(value)?;\n-                                    // we have not encountered this pointer+layout combination before\n+                                    // we have not encountered this pointer+layout\n+                                    // combination before\n                                     if seen.insert(ptr_place) {\n                                         todo.push((ptr_place, path_clone_and_deref(path)));\n                                     }"}]}