{"sha": "ae10e478eb61e75ebf3a7bf672b34b582555fd8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMTBlNDc4ZWI2MWU3NWViZjNhN2JmNjcyYjM0YjU4MjU1NWZkOGU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-05-26T14:12:39Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-05-26T14:22:29Z"}, "message": "Implement defaults for associated types", "tree": {"sha": "b4fb3e99356b26a885cc53d73f6924d7bc45c25e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4fb3e99356b26a885cc53d73f6924d7bc45c25e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae10e478eb61e75ebf3a7bf672b34b582555fd8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae10e478eb61e75ebf3a7bf672b34b582555fd8e", "html_url": "https://github.com/rust-lang/rust/commit/ae10e478eb61e75ebf3a7bf672b34b582555fd8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/comments", "author": null, "committer": null, "parents": [{"sha": "c654a07d29c77b5a023cb9d36dfc61811349f64e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c654a07d29c77b5a023cb9d36dfc61811349f64e", "html_url": "https://github.com/rust-lang/rust/commit/c654a07d29c77b5a023cb9d36dfc61811349f64e"}], "stats": {"total": 287, "additions": 167, "deletions": 120}, "files": [{"sha": "5eefb99b058f19690b6600ca55eee344a199ba32", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=ae10e478eb61e75ebf3a7bf672b34b582555fd8e", "patch": "@@ -252,6 +252,13 @@ fn doc_type<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Ty<'tcx>\n                   |_, did| translate_def_id(cdata, did))\n }\n \n+fn maybe_doc_type<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Option<Ty<'tcx>> {\n+    reader::maybe_get_doc(doc, tag_items_data_item_type).map(|tp| {\n+        parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n+                      |_, did| translate_def_id(cdata, did))\n+    })\n+}\n+\n fn doc_method_fty<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>,\n                         cdata: Cmd) -> ty::BareFnTy<'tcx> {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n@@ -875,24 +882,24 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n                                     id: ast::NodeId,\n                                     tcx: &ty::ctxt<'tcx>)\n                                     -> ty::ImplOrTraitItem<'tcx> {\n-    let method_doc = lookup_item(id, cdata.data());\n+    let item_doc = lookup_item(id, cdata.data());\n \n-    let def_id = item_def_id(method_doc, cdata);\n+    let def_id = item_def_id(item_doc, cdata);\n \n-    let container_id = item_require_parent_item(cdata, method_doc);\n+    let container_id = item_require_parent_item(cdata, item_doc);\n     let container_doc = lookup_item(container_id.node, cdata.data());\n     let container = match item_family(container_doc) {\n         Trait => TraitContainer(container_id),\n         _ => ImplContainer(container_id),\n     };\n \n-    let name = item_name(&*intr, method_doc);\n-    let vis = item_visibility(method_doc);\n+    let name = item_name(&*intr, item_doc);\n+    let vis = item_visibility(item_doc);\n \n-    match item_sort(method_doc) {\n+    match item_sort(item_doc) {\n         Some('C') => {\n-            let ty = doc_type(method_doc, tcx, cdata);\n-            let default = get_provided_source(method_doc, cdata);\n+            let ty = doc_type(item_doc, tcx, cdata);\n+            let default = get_provided_source(item_doc, cdata);\n             ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n                 name: name,\n                 ty: ty,\n@@ -903,11 +910,11 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n             }))\n         }\n         Some('r') | Some('p') => {\n-            let generics = doc_generics(method_doc, tcx, cdata, tag_method_ty_generics);\n-            let predicates = doc_predicates(method_doc, tcx, cdata, tag_method_ty_generics);\n-            let fty = doc_method_fty(method_doc, tcx, cdata);\n-            let explicit_self = get_explicit_self(method_doc);\n-            let provided_source = get_provided_source(method_doc, cdata);\n+            let generics = doc_generics(item_doc, tcx, cdata, tag_method_ty_generics);\n+            let predicates = doc_predicates(item_doc, tcx, cdata, tag_method_ty_generics);\n+            let fty = doc_method_fty(item_doc, tcx, cdata);\n+            let explicit_self = get_explicit_self(item_doc);\n+            let provided_source = get_provided_source(item_doc, cdata);\n \n             ty::MethodTraitItem(Rc::new(ty::Method::new(name,\n                                                         generics,\n@@ -920,8 +927,10 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n                                                         provided_source)))\n         }\n         Some('t') => {\n+            let ty = maybe_doc_type(item_doc, tcx, cdata);\n             ty::TypeTraitItem(Rc::new(ty::AssociatedType {\n                 name: name,\n+                ty: ty,\n                 vis: vis,\n                 def_id: def_id,\n                 container: container,"}, {"sha": "8eefb4d5011d2330f3690ed38cf43b215d543090", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ae10e478eb61e75ebf3a7bf672b34b582555fd8e", "patch": "@@ -894,12 +894,12 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.end_tag();\n }\n \n-fn encode_info_for_associated_type(ecx: &EncodeContext,\n-                                   rbml_w: &mut Encoder,\n-                                   associated_type: &ty::AssociatedType,\n-                                   impl_path: PathElems,\n-                                   parent_id: NodeId,\n-                                   impl_item_opt: Option<&ast::ImplItem>) {\n+fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                             rbml_w: &mut Encoder,\n+                                             associated_type: &ty::AssociatedType<'tcx>,\n+                                             impl_path: PathElems,\n+                                             parent_id: NodeId,\n+                                             impl_item_opt: Option<&ast::ImplItem>) {\n     debug!(\"encode_info_for_associated_type({:?},{:?})\",\n            associated_type.def_id,\n            token::get_name(associated_type.name));\n@@ -913,8 +913,6 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     encode_parent_item(rbml_w, local_def(parent_id));\n     encode_item_sort(rbml_w, 't');\n \n-    encode_bounds_and_type_for_item(rbml_w, ecx, associated_type.def_id.local_id());\n-\n     let stab = stability::lookup(ecx.tcx, associated_type.def_id);\n     encode_stability(rbml_w, stab);\n \n@@ -923,7 +921,14 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n \n     if let Some(ii) = impl_item_opt {\n         encode_attributes(rbml_w, &ii.attrs);\n-        encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx, ii.id));\n+    } else {\n+        encode_predicates(rbml_w, ecx,\n+                          &ty::lookup_predicates(ecx.tcx, associated_type.def_id),\n+                          tag_item_generics);\n+    }\n+\n+    if let Some(ty) = associated_type.ty {\n+        encode_type(ecx, rbml_w, ty);\n     }\n \n     rbml_w.end_tag();"}, {"sha": "700aaad8b72d3ecd753d3d77dbf7e33ce7adbbc1", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=ae10e478eb61e75ebf3a7bf672b34b582555fd8e", "patch": "@@ -857,37 +857,39 @@ fn confirm_impl_candidate<'cx,'tcx>(\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n     // there don't seem to be nicer accessors to these:\n-    let impl_items_map = selcx.tcx().impl_items.borrow();\n     let impl_or_trait_items_map = selcx.tcx().impl_or_trait_items.borrow();\n \n-    let impl_items = impl_items_map.get(&impl_vtable.impl_def_id).unwrap();\n-    let mut impl_ty = None;\n-    for impl_item in impl_items {\n-        let assoc_type = match *impl_or_trait_items_map.get(&impl_item.def_id()).unwrap() {\n-            ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n-            ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => { continue; }\n-        };\n-\n-        if assoc_type.name != obligation.predicate.item_name {\n-            continue;\n+    for impl_item in &selcx.tcx().impl_items.borrow()[&impl_vtable.impl_def_id] {\n+        if let ty::TypeTraitItem(ref assoc_ty) = impl_or_trait_items_map[&impl_item.def_id()] {\n+            if assoc_ty.name == obligation.predicate.item_name {\n+                return (assoc_ty.ty.unwrap().subst(selcx.tcx(), &impl_vtable.substs),\n+                        impl_vtable.nested.into_vec());\n+            }\n         }\n-\n-        let impl_poly_ty = ty::lookup_item_type(selcx.tcx(), assoc_type.def_id);\n-        impl_ty = Some(impl_poly_ty.ty.subst(selcx.tcx(), &impl_vtable.substs));\n-        break;\n     }\n \n-    match impl_ty {\n-        Some(ty) => (ty, impl_vtable.nested.into_vec()),\n-        None => {\n-            // This means that the impl is missing a\n-            // definition for the associated type. This error\n-            // ought to be reported by the type checker method\n-            // `check_impl_items_against_trait`, so here we\n-            // just return ty_err.\n-            (selcx.tcx().types.err, vec!())\n+    let trait_ref = obligation.predicate.trait_ref;\n+    for trait_item in ty::trait_items(selcx.tcx(), trait_ref.def_id).iter() {\n+        if let &ty::TypeTraitItem(ref assoc_ty) = trait_item {\n+            if assoc_ty.name == obligation.predicate.item_name {\n+                if let Some(ty) = assoc_ty.ty {\n+                    return (ty.subst(selcx.tcx(), trait_ref.substs),\n+                            impl_vtable.nested.into_vec());\n+                } else {\n+                    // This means that the impl is missing a\n+                    // definition for the associated type. This error\n+                    // ought to be reported by the type checker method\n+                    // `check_impl_items_against_trait`, so here we\n+                    // just return ty_err.\n+                    return (selcx.tcx().types.err, vec!());\n+                }\n+            }\n         }\n     }\n+\n+    selcx.tcx().sess.span_bug(obligation.cause.span,\n+                              &format!(\"No associated type for {}\",\n+                                       trait_ref.repr(selcx.tcx())));\n }\n \n impl<'tcx> Repr<'tcx> for ProjectionTyError<'tcx> {"}, {"sha": "a67a968ea2cf937b8ea5884774afe300ef109ae9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ae10e478eb61e75ebf3a7bf672b34b582555fd8e", "patch": "@@ -136,7 +136,7 @@ impl ImplOrTraitItemContainer {\n pub enum ImplOrTraitItem<'tcx> {\n     ConstTraitItem(Rc<AssociatedConst<'tcx>>),\n     MethodTraitItem(Rc<Method<'tcx>>),\n-    TypeTraitItem(Rc<AssociatedType>),\n+    TypeTraitItem(Rc<AssociatedType<'tcx>>),\n }\n \n impl<'tcx> ImplOrTraitItem<'tcx> {\n@@ -267,8 +267,9 @@ pub struct AssociatedConst<'tcx> {\n }\n \n #[derive(Clone, Copy, Debug)]\n-pub struct AssociatedType {\n+pub struct AssociatedType<'tcx> {\n     pub name: ast::Name,\n+    pub ty: Option<Ty<'tcx>>,\n     pub vis: ast::Visibility,\n     pub def_id: ast::DefId,\n     pub container: ImplOrTraitItemContainer,"}, {"sha": "6f71def11886da32fed990dabdf87b97354164f1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ae10e478eb61e75ebf3a7bf672b34b582555fd8e", "patch": "@@ -1077,7 +1077,7 @@ impl<'tcx> Repr<'tcx> for ty::AssociatedConst<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::AssociatedType {\n+impl<'tcx> Repr<'tcx> for ty::AssociatedType<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"AssociatedType(name: {}, vis: {}, def_id: {})\",\n                 self.name.repr(tcx),"}, {"sha": "05aad1d64f72955dfa7074dee6210cfeeee3b2d2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ae10e478eb61e75ebf3a7bf672b34b582555fd8e", "patch": "@@ -1070,7 +1070,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Check for missing items from trait\n     let provided_methods = ty::provided_trait_methods(tcx, impl_trait_ref.def_id);\n     let associated_consts = ty::associated_consts(tcx, impl_trait_ref.def_id);\n-    let mut missing_methods = Vec::new();\n+    let mut missing_items = Vec::new();\n     for trait_item in &*trait_items {\n         match *trait_item {\n             ty::ConstTraitItem(ref associated_const) => {\n@@ -1086,8 +1086,8 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     associated_consts.iter().any(|ac| ac.default.is_some() &&\n                                                  ac.name == associated_const.name);\n                 if !is_implemented && !is_provided {\n-                    missing_methods.push(format!(\"`{}`\",\n-                                                 token::get_name(associated_const.name)));\n+                    missing_items.push(format!(\"`{}`\",\n+                                               token::get_name(associated_const.name)));\n                 }\n             }\n             ty::MethodTraitItem(ref trait_method) => {\n@@ -1103,7 +1103,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let is_provided =\n                     provided_methods.iter().any(|m| m.name == trait_method.name);\n                 if !is_implemented && !is_provided {\n-                    missing_methods.push(format!(\"`{}`\", token::get_name(trait_method.name)));\n+                    missing_items.push(format!(\"`{}`\", token::get_name(trait_method.name)));\n                 }\n             }\n             ty::TypeTraitItem(ref associated_type) => {\n@@ -1115,17 +1115,18 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         _ => false,\n                     }\n                 });\n-                if !is_implemented {\n-                    missing_methods.push(format!(\"`{}`\", token::get_name(associated_type.name)));\n+                let is_provided = associated_type.ty.is_some();\n+                if !is_implemented && !is_provided {\n+                    missing_items.push(format!(\"`{}`\", token::get_name(associated_type.name)));\n                 }\n             }\n         }\n     }\n \n-    if !missing_methods.is_empty() {\n+    if !missing_items.is_empty() {\n         span_err!(tcx.sess, impl_span, E0046,\n             \"not all trait items implemented, missing: {}\",\n-            missing_methods.connect(\", \"));\n+            missing_items.connect(\", \"));\n     }\n }\n "}, {"sha": "6507f6dc372424476cf285bcc7f2c2ffb6865a43", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ae10e478eb61e75ebf3a7bf672b34b582555fd8e", "patch": "@@ -718,15 +718,17 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n        .insert(local_def(id), ty::ConstTraitItem(associated_const));\n }\n \n-fn as_refsociated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                 container: ImplOrTraitItemContainer,\n-                                 ident: ast::Ident,\n-                                 id: ast::NodeId,\n-                                 vis: ast::Visibility)\n+fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                     container: ImplOrTraitItemContainer,\n+                                     ident: ast::Ident,\n+                                     id: ast::NodeId,\n+                                     vis: ast::Visibility,\n+                                     ty: Option<Ty<'tcx>>)\n {\n     let associated_type = Rc::new(ty::AssociatedType {\n         name: ident.name,\n         vis: vis,\n+        ty: ty,\n         def_id: local_def(id),\n         container: container\n     });\n@@ -876,21 +878,14 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 if let ast::TypeImplItem(ref ty) = impl_item.node {\n                     if opt_trait_ref.is_none() {\n                         span_err!(tcx.sess, impl_item.span, E0202,\n-                                  \"associated items are not allowed in inherent impls\");\n+                                  \"associated types are not allowed in inherent impls\");\n                     }\n \n-                    as_refsociated_type(ccx, ImplContainer(local_def(it.id)),\n-                                        impl_item.ident, impl_item.id, impl_item.vis);\n-\n                     let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n-                    tcx.tcache.borrow_mut().insert(local_def(impl_item.id),\n-                                                   TypeScheme {\n-                                                       generics: ty::Generics::empty(),\n-                                                       ty: typ,\n-                                                   });\n-                    tcx.predicates.borrow_mut().insert(local_def(impl_item.id),\n-                                                       ty::GenericPredicates::empty());\n-                    write_ty_to_tcx(tcx, impl_item.id, typ);\n+\n+                    convert_associated_type(ccx, ImplContainer(local_def(it.id)),\n+                                            impl_item.ident, impl_item.id, impl_item.vis,\n+                                            Some(typ));\n                 }\n             }\n \n@@ -973,9 +968,14 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             // Convert all the associated types.\n             for trait_item in trait_items {\n                 match trait_item.node {\n-                    ast::TypeTraitItem(..) => {\n-                        as_refsociated_type(ccx, TraitContainer(local_def(it.id)),\n-                                                trait_item.ident, trait_item.id, ast::Public);\n+                    ast::TypeTraitItem(_, ref opt_ty) => {\n+                        let typ = opt_ty.as_ref().map({\n+                            |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n+                        });\n+\n+                        convert_associated_type(ccx, TraitContainer(local_def(it.id)),\n+                                                trait_item.ident, trait_item.id, ast::Public,\n+                                                typ);\n                     }\n                     _ => {}\n                 }\n@@ -2292,10 +2292,10 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let lifetimes_in_associated_types: HashSet<_> =\n         impl_items.iter()\n-                  .filter_map(|item| match item.node {\n-                      ast::TypeImplItem(..) => Some(ty::node_id_to_type(tcx, item.id)),\n-                      ast::ConstImplItem(..) | ast::MethodImplItem(..) |\n-                      ast::MacImplItem(..) => None,\n+                  .map(|item| ty::impl_or_trait_item(tcx, local_def(item.id)))\n+                  .filter_map(|item| match item {\n+                      ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,\n+                      ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => None\n                   })\n                   .flat_map(|ty| ctp::parameters_for_type(ty).into_iter())\n                   .filter_map(|p| match p {"}, {"sha": "fcc4e5bb96c88bebd13e367b229d65108341109e", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ae10e478eb61e75ebf3a7bf672b34b582555fd8e", "patch": "@@ -362,11 +362,13 @@ pub fn build_impl(cx: &DocContext,\n             }\n             ty::TypeTraitItem(ref assoc_ty) => {\n                 let did = assoc_ty.def_id;\n-                let type_scheme = ty::lookup_item_type(tcx, did);\n-                let predicates = ty::lookup_predicates(tcx, did);\n+                let type_scheme = ty::TypeScheme {\n+                    ty: assoc_ty.ty.unwrap(),\n+                    generics: ty::Generics::empty()\n+                };\n                 // Not sure the choice of ParamSpace actually matters here,\n                 // because an associated type won't have generics on the LHS\n-                let typedef = (type_scheme, predicates,\n+                let typedef = (type_scheme, ty::GenericPredicates::empty(),\n                                subst::ParamSpace::TypeSpace).clean(cx);\n                 Some(clean::Item {\n                     name: Some(assoc_ty.name.clean(cx)),"}, {"sha": "b5aa27d0b0394de66b23dbb72f718528e68cadbd", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ae10e478eb61e75ebf3a7bf672b34b582555fd8e", "patch": "@@ -2724,43 +2724,40 @@ impl<'tcx> Clean<Item> for ty::AssociatedConst<'tcx> {\n     }\n }\n \n-impl Clean<Item> for ty::AssociatedType {\n+impl<'tcx> Clean<Item> for ty::AssociatedType<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        // When loading a cross-crate associated type, the bounds for this type\n-        // are actually located on the trait/impl itself, so we need to load\n-        // all of the generics from there and then look for bounds that are\n-        // applied to this associated type in question.\n-        let predicates = ty::lookup_predicates(cx.tcx(), self.container.id());\n-        let generics = match self.container {\n-            ty::TraitContainer(did) => {\n-                let def = ty::lookup_trait_def(cx.tcx(), did);\n-                (&def.generics, &predicates, subst::TypeSpace).clean(cx)\n-            }\n-            ty::ImplContainer(did) => {\n-                let ty = ty::lookup_item_type(cx.tcx(), did);\n-                (&ty.generics, &predicates, subst::TypeSpace).clean(cx)\n-            }\n-        };\n         let my_name = self.name.clean(cx);\n-        let mut bounds = generics.where_predicates.iter().filter_map(|pred| {\n-            let (name, self_type, trait_, bounds) = match *pred {\n-                WherePredicate::BoundPredicate {\n-                    ty: QPath { ref name, ref self_type, ref trait_ },\n-                    ref bounds\n-                } => (name, self_type, trait_, bounds),\n-                _ => return None,\n-            };\n-            if *name != my_name { return None }\n-            match **trait_ {\n-                ResolvedPath { did, .. } if did == self.container.id() => {}\n-                _ => return None,\n-            }\n-            match **self_type {\n-                Generic(ref s) if *s == \"Self\" => {}\n-                _ => return None,\n-            }\n-            Some(bounds)\n-        }).flat_map(|i| i.iter().cloned()).collect::<Vec<_>>();\n+\n+        let mut bounds = if let ty::TraitContainer(did) = self.container {\n+            // When loading a cross-crate associated type, the bounds for this type\n+            // are actually located on the trait/impl itself, so we need to load\n+            // all of the generics from there and then look for bounds that are\n+            // applied to this associated type in question.\n+            let def = ty::lookup_trait_def(cx.tcx(), did);\n+            let predicates = ty::lookup_predicates(cx.tcx(), did);\n+            let generics = (&def.generics, &predicates, subst::TypeSpace).clean(cx);\n+            generics.where_predicates.iter().filter_map(|pred| {\n+                let (name, self_type, trait_, bounds) = match *pred {\n+                    WherePredicate::BoundPredicate {\n+                        ty: QPath { ref name, ref self_type, ref trait_ },\n+                        ref bounds\n+                    } => (name, self_type, trait_, bounds),\n+                    _ => return None,\n+                };\n+                if *name != my_name { return None }\n+                match **trait_ {\n+                    ResolvedPath { did, .. } if did == self.container.id() => {}\n+                    _ => return None,\n+                }\n+                match **self_type {\n+                    Generic(ref s) if *s == \"Self\" => {}\n+                    _ => return None,\n+                }\n+                Some(bounds)\n+            }).flat_map(|i| i.iter().cloned()).collect::<Vec<_>>()\n+        } else {\n+            vec![]\n+        };\n \n         // Our Sized/?Sized bound didn't get handled when creating the generics\n         // because we didn't actually get our whole set of bounds until just now\n@@ -2776,7 +2773,7 @@ impl Clean<Item> for ty::AssociatedType {\n             source: DUMMY_SP.clean(cx),\n             name: Some(self.name.clean(cx)),\n             attrs: inline::load_attrs(cx, cx.tcx(), self.def_id),\n-            inner: AssociatedTypeItem(bounds, None),\n+            inner: AssociatedTypeItem(bounds, self.ty.clean(cx)),\n             visibility: self.vis.clean(cx),\n             def_id: self.def_id,\n             stability: stability::lookup(cx.tcx(), self.def_id).clean(cx),"}, {"sha": "b3def429b9b8ce9564205ca06422ab5e63f117d3", "filename": "src/test/run-pass/default-associated-types.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Ftest%2Frun-pass%2Fdefault-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae10e478eb61e75ebf3a7bf672b34b582555fd8e/src%2Ftest%2Frun-pass%2Fdefault-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault-associated-types.rs?ref=ae10e478eb61e75ebf3a7bf672b34b582555fd8e", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo<T> {\n+    type Out = T;\n+    fn foo(&self) -> Self::Out;\n+}\n+\n+impl Foo<u32> for () {\n+    fn foo(&self) -> u32 {\n+        4u32\n+    }\n+}\n+\n+impl Foo<u64> for bool {\n+    type Out = ();\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    assert_eq!(<() as Foo<u32>>::foo(&()), 4u32);\n+    assert_eq!(<bool as Foo<u64>>::foo(&true), ());\n+}"}]}