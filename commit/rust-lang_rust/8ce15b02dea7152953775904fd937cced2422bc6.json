{"sha": "8ce15b02dea7152953775904fd937cced2422bc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZTE1YjAyZGVhNzE1Mjk1Mzc3NTkwNGZkOTM3Y2NlZDI0MjJiYzY=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2021-03-25T19:52:35Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2021-03-25T20:21:15Z"}, "message": "Fix recursive macro statement expansion", "tree": {"sha": "7ae4be1d4da3bd083fe0bec65f9ed4f5db8eb8c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ae4be1d4da3bd083fe0bec65f9ed4f5db8eb8c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ce15b02dea7152953775904fd937cced2422bc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ce15b02dea7152953775904fd937cced2422bc6", "html_url": "https://github.com/rust-lang/rust/commit/8ce15b02dea7152953775904fd937cced2422bc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ce15b02dea7152953775904fd937cced2422bc6/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59fdd7c84c5fdc16573f3cca4081d6735eaa9208", "url": "https://api.github.com/repos/rust-lang/rust/commits/59fdd7c84c5fdc16573f3cca4081d6735eaa9208", "html_url": "https://github.com/rust-lang/rust/commit/59fdd7c84c5fdc16573f3cca4081d6735eaa9208"}], "stats": {"total": 189, "additions": 119, "deletions": 70}, "files": [{"sha": "229e81dd43a6fb9c5f93b1c094ee471b9e7e3d74", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8ce15b02dea7152953775904fd937cced2422bc6/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ce15b02dea7152953775904fd937cced2422bc6/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=8ce15b02dea7152953775904fd937cced2422bc6", "patch": "@@ -74,6 +74,7 @@ pub(super) fn lower(\n             _c: Count::new(),\n         },\n         expander,\n+        statements_in_scope: Vec::new(),\n     }\n     .collect(params, body)\n }\n@@ -83,6 +84,7 @@ struct ExprCollector<'a> {\n     expander: Expander,\n     body: Body,\n     source_map: BodySourceMap,\n+    statements_in_scope: Vec<Statement>,\n }\n \n impl ExprCollector<'_> {\n@@ -533,15 +535,13 @@ impl ExprCollector<'_> {\n                 ids[0]\n             }\n             ast::Expr::MacroStmts(e) => {\n-                // FIXME:  these statements should be held by some hir containter\n-                for stmt in e.statements() {\n-                    self.collect_stmt(stmt);\n-                }\n-                if let Some(expr) = e.expr() {\n-                    self.collect_expr(expr)\n-                } else {\n-                    self.alloc_expr(Expr::Missing, syntax_ptr)\n-                }\n+                e.statements().for_each(|s| self.collect_stmt(s));\n+                let tail = e\n+                    .expr()\n+                    .map(|e| self.collect_expr(e))\n+                    .unwrap_or_else(|| self.alloc_expr(Expr::Missing, syntax_ptr.clone()));\n+\n+                self.alloc_expr(Expr::MacroStmts { tail }, syntax_ptr)\n             }\n         })\n     }\n@@ -618,58 +618,54 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_stmt(&mut self, s: ast::Stmt) -> Option<Vec<Statement>> {\n-        let stmt = match s {\n+    fn collect_stmt(&mut self, s: ast::Stmt) {\n+        match s {\n             ast::Stmt::LetStmt(stmt) => {\n-                self.check_cfg(&stmt)?;\n-\n+                if self.check_cfg(&stmt).is_none() {\n+                    return;\n+                }\n                 let pat = self.collect_pat_opt(stmt.pat());\n                 let type_ref = stmt.ty().map(|it| TypeRef::from_ast(&self.ctx(), it));\n                 let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n-                vec![Statement::Let { pat, type_ref, initializer }]\n+                self.statements_in_scope.push(Statement::Let { pat, type_ref, initializer });\n             }\n             ast::Stmt::ExprStmt(stmt) => {\n-                self.check_cfg(&stmt)?;\n+                if self.check_cfg(&stmt).is_none() {\n+                    return;\n+                }\n \n                 // Note that macro could be expended to multiple statements\n                 if let Some(ast::Expr::MacroCall(m)) = stmt.expr() {\n                     let syntax_ptr = AstPtr::new(&stmt.expr().unwrap());\n-                    let mut stmts = vec![];\n \n                     self.collect_macro_call(m, syntax_ptr.clone(), false, |this, expansion| {\n                         match expansion {\n                             Some(expansion) => {\n                                 let statements: ast::MacroStmts = expansion;\n \n-                                statements.statements().for_each(|stmt| {\n-                                    if let Some(mut r) = this.collect_stmt(stmt) {\n-                                        stmts.append(&mut r);\n-                                    }\n-                                });\n+                                statements.statements().for_each(|stmt| this.collect_stmt(stmt));\n                                 if let Some(expr) = statements.expr() {\n-                                    stmts.push(Statement::Expr(this.collect_expr(expr)));\n+                                    let expr = this.collect_expr(expr);\n+                                    this.statements_in_scope.push(Statement::Expr(expr));\n                                 }\n                             }\n                             None => {\n-                                stmts.push(Statement::Expr(\n-                                    this.alloc_expr(Expr::Missing, syntax_ptr.clone()),\n-                                ));\n+                                let expr = this.alloc_expr(Expr::Missing, syntax_ptr.clone());\n+                                this.statements_in_scope.push(Statement::Expr(expr));\n                             }\n                         }\n                     });\n-                    stmts\n                 } else {\n-                    vec![Statement::Expr(self.collect_expr_opt(stmt.expr()))]\n+                    let expr = self.collect_expr_opt(stmt.expr());\n+                    self.statements_in_scope.push(Statement::Expr(expr));\n                 }\n             }\n             ast::Stmt::Item(item) => {\n-                self.check_cfg(&item)?;\n-\n-                return None;\n+                if self.check_cfg(&item).is_none() {\n+                    return;\n+                }\n             }\n-        };\n-\n-        Some(stmt)\n+        }\n     }\n \n     fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {\n@@ -685,10 +681,12 @@ impl ExprCollector<'_> {\n         let module = if has_def_map { def_map.root() } else { self.expander.module };\n         let prev_def_map = mem::replace(&mut self.expander.def_map, def_map);\n         let prev_local_module = mem::replace(&mut self.expander.module, module);\n+        let prev_statements = std::mem::take(&mut self.statements_in_scope);\n+\n+        block.statements().for_each(|s| self.collect_stmt(s));\n \n-        let statements =\n-            block.statements().filter_map(|s| self.collect_stmt(s)).flatten().collect();\n         let tail = block.tail_expr().map(|e| self.collect_expr(e));\n+        let statements = std::mem::replace(&mut self.statements_in_scope, prev_statements);\n         let syntax_node_ptr = AstPtr::new(&block.into());\n         let expr_id = self.alloc_expr(\n             Expr::Block { id: block_id, statements, tail, label: None },"}, {"sha": "6c7376fad3abafc5c87e8fae81d946f3eba5c1e7", "filename": "crates/hir_def/src/expr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ce15b02dea7152953775904fd937cced2422bc6/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ce15b02dea7152953775904fd937cced2422bc6/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fexpr.rs?ref=8ce15b02dea7152953775904fd937cced2422bc6", "patch": "@@ -171,6 +171,9 @@ pub enum Expr {\n     Unsafe {\n         body: ExprId,\n     },\n+    MacroStmts {\n+        tail: ExprId,\n+    },\n     Array(Array),\n     Literal(Literal),\n }\n@@ -357,6 +360,7 @@ impl Expr {\n                     f(*repeat)\n                 }\n             },\n+            Expr::MacroStmts { tail } => f(*tail),\n             Expr::Literal(_) => {}\n         }\n     }"}, {"sha": "ca0048b1637f30ff4a44b1d75bfb473faa6febd8", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8ce15b02dea7152953775904fd937cced2422bc6/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ce15b02dea7152953775904fd937cced2422bc6/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=8ce15b02dea7152953775904fd937cced2422bc6", "patch": "@@ -110,15 +110,6 @@ impl ItemTree {\n                     // still need to collect inner items.\n                     ctx.lower_inner_items(e.syntax())\n                 },\n-                ast::ExprStmt(stmt) => {\n-                    // Macros can expand to stmt. We return an empty item tree in this case, but\n-                    // still need to collect inner items.\n-                    ctx.lower_inner_items(stmt.syntax())\n-                },\n-                ast::Item(item) => {\n-                    // Macros can expand to stmt and other item, and we add it as top level item\n-                    ctx.lower_single_item(item)\n-                },\n                 _ => {\n                     panic!(\"cannot create item tree from {:?} {}\", syntax, syntax);\n                 },"}, {"sha": "3f558edd81622e33d2feb6e8ada2b99dc5254740", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ce15b02dea7152953775904fd937cced2422bc6/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ce15b02dea7152953775904fd937cced2422bc6/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=8ce15b02dea7152953775904fd937cced2422bc6", "patch": "@@ -87,14 +87,6 @@ impl Ctx {\n         self.tree\n     }\n \n-    pub(super) fn lower_single_item(mut self, item: ast::Item) -> ItemTree {\n-        self.tree.top_level = self\n-            .lower_mod_item(&item, false)\n-            .map(|item| item.0)\n-            .unwrap_or_else(|| Default::default());\n-        self.tree\n-    }\n-\n     pub(super) fn lower_inner_items(mut self, within: &SyntaxNode) -> ItemTree {\n         self.collect_inner_items(within);\n         self.tree"}, {"sha": "d672f67238a2a0bb985988957145721227909cba", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8ce15b02dea7152953775904fd937cced2422bc6/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ce15b02dea7152953775904fd937cced2422bc6/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=8ce15b02dea7152953775904fd937cced2422bc6", "patch": "@@ -5,7 +5,13 @@ use std::sync::Arc;\n use base_db::{salsa, SourceDatabase};\n use mbe::{ExpandError, ExpandResult, MacroRules};\n use parser::FragmentKind;\n-use syntax::{algo::diff, ast::NameOwner, AstNode, GreenNode, Parse, SyntaxKind::*, SyntaxNode};\n+use syntax::{\n+    algo::diff,\n+    ast::{MacroStmts, NameOwner},\n+    AstNode, GreenNode, Parse,\n+    SyntaxKind::*,\n+    SyntaxNode,\n+};\n \n use crate::{\n     ast_id_map::AstIdMap, hygiene::HygieneFrame, BuiltinDeriveExpander, BuiltinFnLikeExpander,\n@@ -340,13 +346,19 @@ fn parse_macro_with_arg(\n         None => return ExpandResult { value: None, err: result.err },\n     };\n \n-    log::debug!(\"expanded = {}\", tt.as_debug_string());\n-\n     let fragment_kind = to_fragment_kind(db, macro_call_id);\n \n+    log::debug!(\"expanded = {}\", tt.as_debug_string());\n+    log::debug!(\"kind = {:?}\", fragment_kind);\n+\n     let (parse, rev_token_map) = match mbe::token_tree_to_syntax_node(&tt, fragment_kind) {\n         Ok(it) => it,\n         Err(err) => {\n+            log::debug!(\n+                \"failed to parse expanstion to {:?} = {}\",\n+                fragment_kind,\n+                tt.as_debug_string()\n+            );\n             return ExpandResult::only_err(err);\n         }\n     };\n@@ -362,15 +374,34 @@ fn parse_macro_with_arg(\n                     return ExpandResult::only_err(err);\n                 }\n             };\n-\n-            if !diff(&node, &call_node.value).is_empty() {\n-                ExpandResult { value: Some((parse, Arc::new(rev_token_map))), err: Some(err) }\n-            } else {\n+            if is_self_replicating(&node, &call_node.value) {\n                 return ExpandResult::only_err(err);\n+            } else {\n+                ExpandResult { value: Some((parse, Arc::new(rev_token_map))), err: Some(err) }\n+            }\n+        }\n+        None => {\n+            log::debug!(\"parse = {:?}\", parse.syntax_node().kind());\n+            ExpandResult { value: Some((parse, Arc::new(rev_token_map))), err: None }\n+        }\n+    }\n+}\n+\n+fn is_self_replicating(from: &SyntaxNode, to: &SyntaxNode) -> bool {\n+    if diff(from, to).is_empty() {\n+        return true;\n+    }\n+    if let Some(stmts) = MacroStmts::cast(from.clone()) {\n+        if stmts.statements().any(|stmt| diff(stmt.syntax(), to).is_empty()) {\n+            return true;\n+        }\n+        if let Some(expr) = stmts.expr() {\n+            if diff(expr.syntax(), to).is_empty() {\n+                return true;\n             }\n         }\n-        None => ExpandResult { value: Some((parse, Arc::new(rev_token_map))), err: None },\n     }\n+    false\n }\n \n fn hygiene_frame(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<HygieneFrame> {\n@@ -390,21 +421,15 @@ fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n \n     let parent = match syn.parent() {\n         Some(it) => it,\n-        None => {\n-            // FIXME:\n-            // If it is root, which means the parent HirFile\n-            // MacroKindFile must be non-items\n-            // return expr now.\n-            return FragmentKind::Expr;\n-        }\n+        None => return FragmentKind::Statements,\n     };\n \n     match parent.kind() {\n         MACRO_ITEMS | SOURCE_FILE => FragmentKind::Items,\n-        MACRO_STMTS => FragmentKind::Statement,\n+        MACRO_STMTS => FragmentKind::Statements,\n         ITEM_LIST => FragmentKind::Items,\n         LET_STMT => {\n-            // FIXME: Handle Pattern\n+            // FIXME: Handle LHS Pattern\n             FragmentKind::Expr\n         }\n         EXPR_STMT => FragmentKind::Statements,"}, {"sha": "e6ede05ca144289878dab272188da978f635a74a", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ce15b02dea7152953775904fd937cced2422bc6/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ce15b02dea7152953775904fd937cced2422bc6/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=8ce15b02dea7152953775904fd937cced2422bc6", "patch": "@@ -767,6 +767,7 @@ impl<'a> InferenceContext<'a> {\n                     None => self.table.new_float_var(),\n                 },\n             },\n+            Expr::MacroStmts { tail } => self.infer_expr(*tail, expected),\n         };\n         // use a new type variable if we got unknown here\n         let ty = self.insert_type_vars_shallow(ty);"}, {"sha": "01935ec99431542826b1edd8f7e308cff53a89d7", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8ce15b02dea7152953775904fd937cced2422bc6/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ce15b02dea7152953775904fd937cced2422bc6/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=8ce15b02dea7152953775904fd937cced2422bc6", "patch": "@@ -226,11 +226,48 @@ fn expr_macro_expanded_in_stmts() {\n         \"#,\n         expect![[r#\"\n             !0..8 'leta=();': ()\n+            !0..8 'leta=();': ()\n+            !3..4 'a': ()\n+            !5..7 '()': ()\n             57..84 '{     ...); } }': ()\n         \"#]],\n     );\n }\n \n+#[test]\n+fn recurisve_macro_expanded_in_stmts() {\n+    check_infer(\n+        r#\"\n+        macro_rules! ng {\n+            ([$($tts:tt)*]) => {\n+                $($tts)*;\n+            };\n+            ([$($tts:tt)*] $head:tt $($rest:tt)*) => {\n+                ng! {\n+                    [$($tts)* $head] $($rest)*\n+                }\n+            };\n+        }\n+        fn foo() {\n+            ng!([] let a = 3);\n+            let b = a;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..7 'leta=3;': {unknown}\n+            !0..7 'leta=3;': {unknown}\n+            !0..13 'ng!{[leta=3]}': {unknown}\n+            !0..13 'ng!{[leta=]3}': {unknown}\n+            !0..13 'ng!{[leta]=3}': {unknown}\n+            !3..4 'a': i32\n+            !5..6 '3': i32\n+            196..237 '{     ...= a; }': ()\n+            229..230 'b': i32\n+            233..234 'a': i32\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn recursive_inner_item_macro_rules() {\n     check_infer(\n@@ -246,7 +283,8 @@ fn recursive_inner_item_macro_rules() {\n         \"#,\n         expect![[r#\"\n             !0..1 '1': i32\n-            !0..7 'mac!($)': {unknown}\n+            !0..26 'macro_...>{1};}': {unknown}\n+            !0..26 'macro_...>{1};}': {unknown}\n             107..143 '{     ...!(); }': ()\n             129..130 'a': i32\n         \"#]],"}]}