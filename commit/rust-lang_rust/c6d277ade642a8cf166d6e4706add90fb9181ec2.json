{"sha": "c6d277ade642a8cf166d6e4706add90fb9181ec2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZDI3N2FkZTY0MmE4Y2YxNjZkNmU0NzA2YWRkOTBmYjkxODFlYzI=", "commit": {"author": {"name": "Andrea Canciani", "email": "ranma42@gmail.com", "date": "2015-09-22T16:51:04Z"}, "committer": {"name": "Andrea Canciani", "email": "ranma42@gmail.com", "date": "2015-09-22T17:00:20Z"}, "message": "Remove unwind::register\n\nThe `register` function is unstable and it is not used anymore, hence\nit can be removed (together with the now-unused `Callback` type and\n`static` variables).", "tree": {"sha": "13e0beed65dd21a21201d5f35f89f5e5d1694623", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13e0beed65dd21a21201d5f35f89f5e5d1694623"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6d277ade642a8cf166d6e4706add90fb9181ec2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6d277ade642a8cf166d6e4706add90fb9181ec2", "html_url": "https://github.com/rust-lang/rust/commit/c6d277ade642a8cf166d6e4706add90fb9181ec2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6d277ade642a8cf166d6e4706add90fb9181ec2/comments", "author": {"login": "ranma42", "id": 1506030, "node_id": "MDQ6VXNlcjE1MDYwMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1506030?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ranma42", "html_url": "https://github.com/ranma42", "followers_url": "https://api.github.com/users/ranma42/followers", "following_url": "https://api.github.com/users/ranma42/following{/other_user}", "gists_url": "https://api.github.com/users/ranma42/gists{/gist_id}", "starred_url": "https://api.github.com/users/ranma42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ranma42/subscriptions", "organizations_url": "https://api.github.com/users/ranma42/orgs", "repos_url": "https://api.github.com/users/ranma42/repos", "events_url": "https://api.github.com/users/ranma42/events{/privacy}", "received_events_url": "https://api.github.com/users/ranma42/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ranma42", "id": 1506030, "node_id": "MDQ6VXNlcjE1MDYwMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1506030?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ranma42", "html_url": "https://github.com/ranma42", "followers_url": "https://api.github.com/users/ranma42/followers", "following_url": "https://api.github.com/users/ranma42/following{/other_user}", "gists_url": "https://api.github.com/users/ranma42/gists{/gist_id}", "starred_url": "https://api.github.com/users/ranma42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ranma42/subscriptions", "organizations_url": "https://api.github.com/users/ranma42/orgs", "repos_url": "https://api.github.com/users/ranma42/repos", "events_url": "https://api.github.com/users/ranma42/events{/privacy}", "received_events_url": "https://api.github.com/users/ranma42/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbfa61282fc34204b9b66554e06189c2d0b4d085", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbfa61282fc34204b9b66554e06189c2d0b4d085", "html_url": "https://github.com/rust-lang/rust/commit/cbfa61282fc34204b9b66554e06189c2d0b4d085"}], "stats": {"total": 71, "additions": 2, "deletions": 69}, "files": [{"sha": "af6c118450482d09e6fc9208912659dcdae58f79", "filename": "src/libstd/sys/common/unwind/mod.rs", "status": "modified", "additions": 2, "deletions": 69, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c6d277ade642a8cf166d6e4706add90fb9181ec2/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d277ade642a8cf166d6e4706add90fb9181ec2/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs?ref=c6d277ade642a8cf166d6e4706add90fb9181ec2", "patch": "@@ -92,23 +92,6 @@ pub mod imp;\n #[path = \"gcc.rs\"] #[doc(hidden)]\n pub mod imp;\n \n-pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: u32);\n-\n-// Variables used for invoking callbacks when a thread starts to unwind.\n-//\n-// For more information, see below.\n-const MAX_CALLBACKS: usize = 16;\n-static CALLBACKS: [atomic::AtomicUsize; MAX_CALLBACKS] =\n-        [atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n-         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n-         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n-         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n-         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n-         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n-         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n-         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0)];\n-static CALLBACK_CNT: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n-\n thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n \n /// Invoke a closure, capturing the cause of panic if one occurs.\n@@ -249,29 +232,6 @@ fn begin_unwind_inner(msg: Box<Any + Send>,\n     // First, invoke the default panic handler.\n     panicking::on_panic(&*msg, file, line);\n \n-    // Then, invoke call the user-defined callbacks triggered on thread panic.\n-    //\n-    // By the time that we see a callback has been registered (by reading\n-    // MAX_CALLBACKS), the actual callback itself may have not been stored yet,\n-    // so we just chalk it up to a race condition and move on to the next\n-    // callback. Additionally, CALLBACK_CNT may briefly be higher than\n-    // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n-    let callbacks = {\n-        let amt = CALLBACK_CNT.load(Ordering::SeqCst);\n-        &CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n-    };\n-    for cb in callbacks {\n-        match cb.load(Ordering::SeqCst) {\n-            0 => {}\n-            n => {\n-                let f: Callback = unsafe { mem::transmute(n) };\n-                f(&*msg, file, line);\n-            }\n-        }\n-    };\n-\n-    // Now that we've run all the necessary unwind callbacks, we actually\n-    // perform the unwinding.\n     if panicking() {\n         // If a thread panics while it's already unwinding then we\n         // have limited options. Currently our preference is to\n@@ -282,34 +242,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>,\n         unsafe { intrinsics::abort() }\n     }\n     PANICKING.with(|s| s.set(true));\n-    rust_panic(msg);\n-}\n \n-/// Register a callback to be invoked when a thread unwinds.\n-///\n-/// This is an unsafe and experimental API which allows for an arbitrary\n-/// callback to be invoked when a thread panics. This callback is invoked on both\n-/// the initial unwinding and a double unwinding if one occurs. Additionally,\n-/// the local `Thread` will be in place for the duration of the callback, and\n-/// the callback must ensure that it remains in place once the callback returns.\n-///\n-/// Only a limited number of callbacks can be registered, and this function\n-/// returns whether the callback was successfully registered or not. It is not\n-/// currently possible to unregister a callback once it has been registered.\n-pub unsafe fn register(f: Callback) -> bool {\n-    match CALLBACK_CNT.fetch_add(1, Ordering::SeqCst) {\n-        // The invocation code has knowledge of this window where the count has\n-        // been incremented, but the callback has not been stored. We're\n-        // guaranteed that the slot we're storing into is 0.\n-        n if n < MAX_CALLBACKS => {\n-            let prev = CALLBACKS[n].swap(mem::transmute(f), Ordering::SeqCst);\n-            rtassert!(prev == 0);\n-            true\n-        }\n-        // If we accidentally bumped the count too high, pull it back.\n-        _ => {\n-            CALLBACK_CNT.store(MAX_CALLBACKS, Ordering::SeqCst);\n-            false\n-        }\n-    }\n+    // Finally, perform the unwinding.\n+    rust_panic(msg);\n }"}]}