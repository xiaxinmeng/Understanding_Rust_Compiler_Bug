{"sha": "1ebc858e5dd01417a05b08bac067bff2c55faca7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYmM4NThlNWRkMDE0MTdhMDViMDhiYWMwNjdiZmYyYzU1ZmFjYTc=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-02-20T01:12:15Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-03-05T22:08:44Z"}, "message": "Add const kind and UnpackedKind::Const\n\nCo-Authored-By: Gabriel Smith <yodaldevoid@users.noreply.github.com>", "tree": {"sha": "8397bf166aa5d721f4c4b680b7c5305de8c066fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8397bf166aa5d721f4c4b680b7c5305de8c066fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ebc858e5dd01417a05b08bac067bff2c55faca7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ebc858e5dd01417a05b08bac067bff2c55faca7", "html_url": "https://github.com/rust-lang/rust/commit/1ebc858e5dd01417a05b08bac067bff2c55faca7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ebc858e5dd01417a05b08bac067bff2c55faca7/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "691d054e05e37ab000a78ddf580ccb8cc96a41e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/691d054e05e37ab000a78ddf580ccb8cc96a41e2", "html_url": "https://github.com/rust-lang/rust/commit/691d054e05e37ab000a78ddf580ccb8cc96a41e2"}], "stats": {"total": 116, "additions": 110, "deletions": 6}, "files": [{"sha": "35c6f980cd9342d77969dbf8f4603f2f8c86821f", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 110, "deletions": 6, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/1ebc858e5dd01417a05b08bac067bff2c55faca7/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ebc858e5dd01417a05b08bac067bff2c55faca7/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=1ebc858e5dd01417a05b08bac067bff2c55faca7", "patch": "@@ -2,8 +2,9 @@\n \n use crate::hir::def_id::DefId;\n use crate::infer::canonical::Canonical;\n-use crate::ty::{self, Lift, List, Ty, TyCtxt};\n+use crate::ty::{self, Lift, List, Ty, TyCtxt, InferConst, ParamConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::mir::interpret::ConstValue;\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -17,24 +18,26 @@ use std::mem;\n use std::num::NonZeroUsize;\n \n /// An entity in the Rust type system, which can be one of\n-/// several kinds (only types and lifetimes for now).\n+/// several kinds (types, lifetimes, and consts).\n /// To reduce memory usage, a `Kind` is a interned pointer,\n /// with the lowest 2 bits being reserved for a tag to\n-/// indicate the type (`Ty` or `Region`) it points to.\n+/// indicate the type (`Ty`, `Region`, or `Const`) it points to.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Kind<'tcx> {\n     ptr: NonZeroUsize,\n-    marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>)>\n+    marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>, &'tcx ty::LazyConst<'tcx>)>\n }\n \n const TAG_MASK: usize = 0b11;\n const TYPE_TAG: usize = 0b00;\n const REGION_TAG: usize = 0b01;\n+const CONST_TAG: usize = 0b10;\n \n #[derive(Debug, RustcEncodable, RustcDecodable, PartialEq, Eq, PartialOrd, Ord)]\n pub enum UnpackedKind<'tcx> {\n     Lifetime(ty::Region<'tcx>),\n     Type(Ty<'tcx>),\n+    Const(&'tcx ty::LazyConst<'tcx>),\n }\n \n impl<'tcx> UnpackedKind<'tcx> {\n@@ -50,6 +53,11 @@ impl<'tcx> UnpackedKind<'tcx> {\n                 assert_eq!(mem::align_of_val(ty) & TAG_MASK, 0);\n                 (TYPE_TAG, ty as *const _ as usize)\n             }\n+            UnpackedKind::Const(ct) => {\n+                // Ensure we can use the tag bits.\n+                assert_eq!(mem::align_of_val(ct) & TAG_MASK, 0);\n+                (CONST_TAG, ct as *const _ as usize)\n+            }\n         };\n \n         Kind {\n@@ -85,6 +93,12 @@ impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n     }\n }\n \n+impl<'tcx> From<&'tcx ty::LazyConst<'tcx>> for Kind<'tcx> {\n+    fn from(c: &'tcx ty::LazyConst<'tcx>) -> Kind<'tcx> {\n+        UnpackedKind::Const(c).pack()\n+    }\n+}\n+\n impl<'tcx> Kind<'tcx> {\n     #[inline]\n     pub fn unpack(self) -> UnpackedKind<'tcx> {\n@@ -93,6 +107,7 @@ impl<'tcx> Kind<'tcx> {\n             match ptr & TAG_MASK {\n                 REGION_TAG => UnpackedKind::Lifetime(&*((ptr & !TAG_MASK) as *const _)),\n                 TYPE_TAG => UnpackedKind::Type(&*((ptr & !TAG_MASK) as *const _)),\n+                CONST_TAG => UnpackedKind::Const(&*((ptr & !TAG_MASK) as *const _)),\n                 _ => intrinsics::unreachable()\n             }\n         }\n@@ -104,6 +119,7 @@ impl<'tcx> fmt::Debug for Kind<'tcx> {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => write!(f, \"{:?}\", lt),\n             UnpackedKind::Type(ty) => write!(f, \"{:?}\", ty),\n+            UnpackedKind::Const(ct) => write!(f, \"{:?}\", ct),\n         }\n     }\n }\n@@ -113,6 +129,7 @@ impl<'tcx> fmt::Display for Kind<'tcx> {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => write!(f, \"{}\", lt),\n             UnpackedKind::Type(ty) => write!(f, \"{}\", ty),\n+            UnpackedKind::Const(ct) => write!(f, \"{}\", ct),\n         }\n     }\n }\n@@ -122,8 +139,9 @@ impl<'a, 'tcx> Lift<'tcx> for Kind<'a> {\n \n     fn lift_to_tcx<'cx, 'gcx>(&self, tcx: TyCtxt<'cx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match self.unpack() {\n-            UnpackedKind::Lifetime(a) => a.lift_to_tcx(tcx).map(|a| a.into()),\n-            UnpackedKind::Type(a) => a.lift_to_tcx(tcx).map(|a| a.into()),\n+            UnpackedKind::Lifetime(lt) => lt.lift_to_tcx(tcx).map(|lt| lt.into()),\n+            UnpackedKind::Type(ty) => ty.lift_to_tcx(tcx).map(|ty| ty.into()),\n+            UnpackedKind::Const(ct) => ct.lift_to_tcx(tcx).map(|ct| ct.into()),\n         }\n     }\n }\n@@ -133,13 +151,15 @@ impl<'tcx> TypeFoldable<'tcx> for Kind<'tcx> {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => lt.fold_with(folder).into(),\n             UnpackedKind::Type(ty) => ty.fold_with(folder).into(),\n+            UnpackedKind::Const(ct) => ct.fold_with(folder).into(),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => lt.visit_with(visitor),\n             UnpackedKind::Type(ty) => ty.visit_with(visitor),\n+            UnpackedKind::Const(ct) => ct.visit_with(visitor),\n         }\n     }\n }\n@@ -195,6 +215,15 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n                         ty::BoundRegion::BrNamed(param.def_id, param.name)\n                     )).into()\n                 }\n+\n+                ty::GenericParamDefKind::Const => {\n+                    tcx.mk_lazy_const(ty::LazyConst::Evaluated(ty::Const {\n+                        val: ConstValue::Infer(\n+                            InferConst::Canonical(ty::INNERMOST, ty::BoundVar::from(param.index))\n+                        ),\n+                        ty: tcx.type_of(def_id),\n+                    })).into()\n+                }\n             }\n         })\n     }\n@@ -283,6 +312,29 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n         })\n     }\n \n+    #[inline]\n+    pub fn consts(&'a self) -> impl DoubleEndedIterator<Item = &'tcx ty::LazyConst<'tcx>> + 'a {\n+        self.iter().filter_map(|k| {\n+            if let UnpackedKind::Const(ct) = k.unpack() {\n+                Some(ct)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn non_erasable_generics(\n+        &'a self\n+    ) -> impl DoubleEndedIterator<Item = UnpackedKind<'tcx>> + 'a {\n+        self.iter().filter_map(|k| {\n+            match k.unpack() {\n+                UnpackedKind::Lifetime(_) => None,\n+                generic => Some(generic),\n+            }\n+        })\n+    }\n+\n     #[inline]\n     pub fn type_at(&self, i: usize) -> Ty<'tcx> {\n         if let UnpackedKind::Type(ty) = self[i].unpack() {\n@@ -301,6 +353,15 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    pub fn const_at(&self, i: usize) -> &'tcx ty::LazyConst<'tcx> {\n+        if let UnpackedKind::Const(ct) = self[i].unpack() {\n+            ct\n+        } else {\n+            bug!(\"expected const for param #{} in {:?}\", i, self);\n+        }\n+    }\n+\n     #[inline]\n     pub fn type_for_def(&self, def: &ty::GenericParamDef) -> Kind<'tcx> {\n         self.type_at(def.index as usize).into()\n@@ -469,6 +530,21 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n \n         return t1;\n     }\n+\n+    fn fold_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+        if !c.needs_subst() {\n+            return c;\n+        }\n+\n+        if let ty::LazyConst::Evaluated(ty::Const {\n+            val: ConstValue::Param(p),\n+            ..\n+        }) = c {\n+            self.const_for_param(*p, c)\n+        } else {\n+            c.super_fold_with(self)\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n@@ -494,6 +570,34 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n         self.shift_vars_through_binders(ty)\n     }\n \n+    fn const_for_param(\n+        &self,\n+        p: ParamConst,\n+        source_cn: &'tcx ty::LazyConst<'tcx>\n+    ) -> &'tcx ty::LazyConst<'tcx> {\n+        // Look up the const in the substitutions. It really should be in there.\n+        let opt_cn = self.substs.get(p.index as usize).map(|k| k.unpack());\n+        let cn = match opt_cn {\n+            Some(UnpackedKind::Const(cn)) => cn,\n+            _ => {\n+                let span = self.span.unwrap_or(DUMMY_SP);\n+                span_bug!(\n+                    span,\n+                    \"Const parameter `{:?}` ({:?}/{}) out of range \\\n+                     when substituting (root type={:?}) substs={:?}\",\n+                    p,\n+                    source_cn,\n+                    p.index,\n+                    self.root_ty,\n+                    self.substs,\n+                );\n+            }\n+        };\n+\n+        // FIXME(const_generics): shift const through binders\n+        cn\n+    }\n+\n     /// It is sometimes necessary to adjust the De Bruijn indices during substitution. This occurs\n     /// when we are substituting a type with escaping bound vars into a context where we have\n     /// passed through binders. That's quite a mouthful. Let's see an example:"}]}