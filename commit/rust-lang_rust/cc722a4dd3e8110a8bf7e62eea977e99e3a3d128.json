{"sha": "cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNzIyYTRkZDNlODExMGE4YmY3ZTYyZWVhOTc3ZTk5ZTNhM2QxMjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-05T01:19:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-05T01:19:15Z"}, "message": "Auto merge of #22873 - alexcrichton:deprecate-fs, r=aturon\n\nThis commit deprecates the majority of std::old_io::fs in favor of std::fs and\r\nits new functionality. Some functions remain non-deprecated but are now behind a\r\nfeature gate called `old_fs`. These functions will be deprecated once\r\nsuitable replacements have been implemented.\r\n\r\nThe compiler has been migrated to new `std::fs` and `std::path` APIs where\r\nappropriate as part of this change.\r\n\r\n[breaking-change]", "tree": {"sha": "b0872e63b8d75543ce5141ceba44c12c459474f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0872e63b8d75543ce5141ceba44c12c459474f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "html_url": "https://github.com/rust-lang/rust/commit/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b3bb0e682c2d252e9f62dd9df5cff9552af91ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b3bb0e682c2d252e9f62dd9df5cff9552af91ad", "html_url": "https://github.com/rust-lang/rust/commit/3b3bb0e682c2d252e9f62dd9df5cff9552af91ad"}, {"sha": "95d904625b4d45af80b4e40d51a3a0fde1abaa8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/95d904625b4d45af80b4e40d51a3a0fde1abaa8a", "html_url": "https://github.com/rust-lang/rust/commit/95d904625b4d45af80b4e40d51a3a0fde1abaa8a"}], "stats": {"total": 2639, "additions": 1430, "deletions": 1209}, "files": [{"sha": "f7ab86d3a29b92d2dde26091d38dc578758ec25a", "filename": "mk/docs.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -273,11 +273,13 @@ compiler-docs: $(COMPILER_DOC_TARGETS)\n trpl: doc/book/index.html\n \n doc/book/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/trpl/*.md) | doc/\n+\t@$(call E, rustbook: $@)\n \t$(Q)rm -rf doc/book\n \t$(Q)$(RUSTBOOK) build $(S)src/doc/trpl doc/book\n \n style: doc/style/index.html\n \n doc/style/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/style/*.md) | doc/\n+\t@$(call E, rustbook: $@)\n \t$(Q)rm -rf doc/style\n \t$(Q)$(RUSTBOOK) build $(S)src/doc/style doc/style"}, {"sha": "fe556cecef6981eef5b856bb40ccc48d3250c272", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -11,6 +11,7 @@ pub use self::Mode::*;\n \n use std::fmt;\n use std::str::FromStr;\n+use std::path::PathBuf;\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n pub enum Mode {\n@@ -68,13 +69,13 @@ pub struct Config {\n     pub run_lib_path: String,\n \n     // The rustc executable\n-    pub rustc_path: Path,\n+    pub rustc_path: PathBuf,\n \n     // The clang executable\n-    pub clang_path: Option<Path>,\n+    pub clang_path: Option<PathBuf>,\n \n     // The llvm binaries path\n-    pub llvm_bin_path: Option<Path>,\n+    pub llvm_bin_path: Option<PathBuf>,\n \n     // The valgrind path\n     pub valgrind_path: Option<String>,\n@@ -84,13 +85,13 @@ pub struct Config {\n     pub force_valgrind: bool,\n \n     // The directory containing the tests to run\n-    pub src_base: Path,\n+    pub src_base: PathBuf,\n \n     // The directory where programs should be built\n-    pub build_base: Path,\n+    pub build_base: PathBuf,\n \n     // Directory for auxiliary libraries\n-    pub aux_base: Path,\n+    pub aux_base: PathBuf,\n \n     // The name of the stage being built (stage1, etc)\n     pub stage_id: String,\n@@ -105,7 +106,7 @@ pub struct Config {\n     pub filter: Option<String>,\n \n     // Write out a parseable log of tests that were run\n-    pub logfile: Option<Path>,\n+    pub logfile: Option<PathBuf>,\n \n     // A command line to prefix program execution with,\n     // for running under valgrind\n@@ -133,7 +134,7 @@ pub struct Config {\n     pub lldb_version: Option<String>,\n \n     // Path to the android tools\n-    pub android_cross_path: Path,\n+    pub android_cross_path: PathBuf,\n \n     // Extra parameter to run adb on arm-linux-androideabi\n     pub adb_path: String,"}, {"sha": "b9e6f1842eeab8f3a58eaaf817a89280457bf330", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -21,6 +21,11 @@\n #![feature(test)]\n #![feature(unicode)]\n #![feature(core)]\n+#![feature(path)]\n+#![feature(os)]\n+#![feature(io)]\n+#![feature(fs)]\n+#![feature(net)]\n \n #![deny(warnings)]\n \n@@ -31,8 +36,9 @@ extern crate getopts;\n extern crate log;\n \n use std::env;\n+use std::fs;\n use std::old_io;\n-use std::old_io::fs;\n+use std::path::{Path, PathBuf};\n use std::thunk::Thunk;\n use getopts::{optopt, optflag, reqopt};\n use common::Config;\n@@ -114,9 +120,9 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         panic!()\n     }\n \n-    fn opt_path(m: &getopts::Matches, nm: &str) -> Path {\n+    fn opt_path(m: &getopts::Matches, nm: &str) -> PathBuf {\n         match m.opt_str(nm) {\n-            Some(s) => Path::new(s),\n+            Some(s) => PathBuf::new(&s),\n             None => panic!(\"no option (=path) found for {}\", nm),\n         }\n     }\n@@ -131,18 +137,18 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         compile_lib_path: matches.opt_str(\"compile-lib-path\").unwrap(),\n         run_lib_path: matches.opt_str(\"run-lib-path\").unwrap(),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n-        clang_path: matches.opt_str(\"clang-path\").map(|s| Path::new(s)),\n+        clang_path: matches.opt_str(\"clang-path\").map(|s| PathBuf::new(&s)),\n         valgrind_path: matches.opt_str(\"valgrind-path\"),\n         force_valgrind: matches.opt_present(\"force-valgrind\"),\n-        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| Path::new(s)),\n+        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| PathBuf::new(&s)),\n         src_base: opt_path(matches, \"src-base\"),\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n         stage_id: matches.opt_str(\"stage-id\").unwrap(),\n         mode: matches.opt_str(\"mode\").unwrap().parse().ok().expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n         filter: filter,\n-        logfile: matches.opt_str(\"logfile\").map(|s| Path::new(s)),\n+        logfile: matches.opt_str(\"logfile\").map(|s| PathBuf::new(&s)),\n         runtool: matches.opt_str(\"runtool\"),\n         host_rustcflags: matches.opt_str(\"host-rustcflags\"),\n         target_rustcflags: matches.opt_str(\"target-rustcflags\"),\n@@ -276,9 +282,9 @@ pub fn make_tests(config: &Config) -> Vec<test::TestDescAndFn> {\n     debug!(\"making tests from {:?}\",\n            config.src_base.display());\n     let mut tests = Vec::new();\n-    let dirs = fs::readdir(&config.src_base).unwrap();\n-    for file in &dirs {\n-        let file = file.clone();\n+    let dirs = fs::read_dir(&config.src_base).unwrap();\n+    for file in dirs {\n+        let file = file.unwrap().path();\n         debug!(\"inspecting file {:?}\", file.display());\n         if is_test(config, &file) {\n             let t = make_test(config, &file, || {\n@@ -301,7 +307,7 @@ pub fn is_test(config: &Config, testfile: &Path) -> bool {\n           _ => vec!(\".rc\".to_string(), \".rs\".to_string())\n         };\n     let invalid_prefixes = vec!(\".\".to_string(), \"#\".to_string(), \"~\".to_string());\n-    let name = testfile.filename_str().unwrap();\n+    let name = testfile.file_name().unwrap().to_str().unwrap();\n \n     let mut valid = false;\n \n@@ -337,9 +343,9 @@ pub fn make_test_name(config: &Config, testfile: &Path) -> test::TestName {\n \n     // Try to elide redundant long paths\n     fn shorten(path: &Path) -> String {\n-        let filename = path.filename_str();\n-        let p = path.dir_path();\n-        let dir = p.filename_str();\n+        let filename = path.file_name().unwrap().to_str();\n+        let p = path.parent().unwrap();\n+        let dir = p.file_name().unwrap().to_str();\n         format!(\"{}/{}\", dir.unwrap_or(\"\"), filename.unwrap_or(\"\"))\n     }\n \n@@ -348,19 +354,17 @@ pub fn make_test_name(config: &Config, testfile: &Path) -> test::TestName {\n \n pub fn make_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let testfile = testfile.as_str().unwrap().to_string();\n+    let testfile = testfile.to_path_buf();\n     test::DynTestFn(Thunk::new(move || {\n-        runtest::run(config, testfile)\n+        runtest::run(config, &testfile)\n     }))\n }\n \n pub fn make_metrics_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let testfile = testfile.as_str().unwrap().to_string();\n+    let testfile = testfile.to_path_buf();\n     test::DynMetricFn(box move |mm: &mut test::MetricMap| {\n-        runtest::run_metrics(config, testfile, mm)\n+        runtest::run_metrics(config, &testfile, mm)\n     })\n }\n "}, {"sha": "25f962c5785a175654e5511d3d827604057ad9dd", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -9,7 +9,10 @@\n // except according to those terms.\n use self::WhichLine::*;\n \n-use std::old_io::{BufferedReader, File};\n+use std::fs::File;\n+use std::io::BufReader;\n+use std::io::prelude::*;\n+use std::path::Path;\n \n pub struct ExpectedError {\n     pub line: uint,\n@@ -29,7 +32,7 @@ enum WhichLine { ThisLine, FollowPrevious(uint), AdjustBackward(uint) }\n ///          //~| ERROR message two for that same line.\n // Load any test directives embedded in the file\n pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n-    let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n+    let rdr = BufReader::new(File::open(testfile).unwrap());\n \n     // `last_nonfollow_error` tracks the most recently seen\n     // line with an error template that did not use the"}, {"sha": "21cebc61b3a9d3d4dcc821e15de197b896bdd769", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -9,6 +9,10 @@\n // except according to those terms.\n \n use std::env;\n+use std::fs::File;\n+use std::io::BufReader;\n+use std::io::prelude::*;\n+use std::path::{Path, PathBuf};\n \n use common::Config;\n use common;\n@@ -23,7 +27,7 @@ pub struct TestProps {\n     pub run_flags: Option<String>,\n     // If present, the name of a file that this test should match when\n     // pretty-printed\n-    pub pp_exact: Option<Path>,\n+    pub pp_exact: Option<PathBuf>,\n     // Modules from aux directory that should be compiled\n     pub aux_builds: Vec<String> ,\n     // Environment settings to use during execution\n@@ -62,7 +66,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n     let mut pretty_mode = None;\n     let mut pretty_compare_only = false;\n     let mut forbid_output = Vec::new();\n-    iter_header(testfile, |ln| {\n+    iter_header(testfile, &mut |ln| {\n         match parse_error_pattern(ln) {\n           Some(ep) => error_patterns.push(ep),\n           None => ()\n@@ -219,7 +223,7 @@ pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n         }\n     }\n \n-    let val = iter_header(testfile, |ln| {\n+    let val = iter_header(testfile, &mut |ln| {\n         !parse_name_directive(ln, \"ignore-test\") &&\n         !parse_name_directive(ln, &ignore_target(config)) &&\n         !parse_name_directive(ln, &ignore_stage(config)) &&\n@@ -232,12 +236,8 @@ pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n     !val\n }\n \n-fn iter_header<F>(testfile: &Path, mut it: F) -> bool where\n-    F: FnMut(&str) -> bool,\n-{\n-    use std::old_io::{BufferedReader, File};\n-\n-    let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n+fn iter_header(testfile: &Path, it: &mut FnMut(&str) -> bool) -> bool {\n+    let rdr = BufReader::new(File::open(testfile).unwrap());\n     for ln in rdr.lines() {\n         // Assume that any directives will be found before the first\n         // module or function. This doesn't seem to be an optimization\n@@ -322,12 +322,12 @@ fn parse_exec_env(line: &str) -> Option<(String, String)> {\n     })\n }\n \n-fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n+fn parse_pp_exact(line: &str, testfile: &Path) -> Option<PathBuf> {\n     match parse_name_value_directive(line, \"pp-exact\") {\n-      Some(s) => Some(Path::new(s)),\n+      Some(s) => Some(PathBuf::new(&s)),\n       None => {\n         if parse_name_directive(line, \"pp-exact\") {\n-            testfile.filename().map(|s| Path::new(s))\n+            testfile.file_name().map(|s| PathBuf::new(s))\n         } else {\n             None\n         }"}, {"sha": "b684dbcfaceb98b4c465295faf6086fede5b33c0", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::old_io::process::{ProcessExit, Command, Process, ProcessOutput};\n+use std::process::{ExitStatus, Command, Child, Output, Stdio};\n+use std::io::prelude::*;\n use std::dynamic_lib::DynamicLibrary;\n \n fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n@@ -25,10 +26,10 @@ fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     let var = DynamicLibrary::envvar();\n     let newpath = DynamicLibrary::create_path(&path);\n     let newpath = String::from_utf8(newpath).unwrap();\n-    cmd.env(var.to_string(), newpath);\n+    cmd.env(var, &newpath);\n }\n \n-pub struct Result {pub status: ProcessExit, pub out: String, pub err: String}\n+pub struct Result {pub status: ExitStatus, pub out: String, pub err: String}\n \n pub fn run(lib_path: &str,\n            prog: &str,\n@@ -38,24 +39,27 @@ pub fn run(lib_path: &str,\n            input: Option<String>) -> Option<Result> {\n \n     let mut cmd = Command::new(prog);\n-    cmd.args(args);\n+    cmd.args(args)\n+       .stdin(Stdio::piped())\n+       .stdout(Stdio::piped())\n+       .stderr(Stdio::piped());\n     add_target_env(&mut cmd, lib_path, aux_path);\n     for (key, val) in env {\n-        cmd.env(key, val);\n+        cmd.env(&key, &val);\n     }\n \n     match cmd.spawn() {\n         Ok(mut process) => {\n             if let Some(input) = input {\n                 process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n             }\n-            let ProcessOutput { status, output, error } =\n+            let Output { status, stdout, stderr } =\n                 process.wait_with_output().unwrap();\n \n             Some(Result {\n                 status: status,\n-                out: String::from_utf8(output).unwrap(),\n-                err: String::from_utf8(error).unwrap()\n+                out: String::from_utf8(stdout).unwrap(),\n+                err: String::from_utf8(stderr).unwrap()\n             })\n         },\n         Err(..) => None\n@@ -67,13 +71,16 @@ pub fn run_background(lib_path: &str,\n            aux_path: Option<&str>,\n            args: &[String],\n            env: Vec<(String, String)> ,\n-           input: Option<String>) -> Option<Process> {\n+           input: Option<String>) -> Option<Child> {\n \n     let mut cmd = Command::new(prog);\n-    cmd.args(args);\n+    cmd.args(args)\n+       .stdin(Stdio::piped())\n+       .stdout(Stdio::piped())\n+       .stderr(Stdio::piped());\n     add_target_env(&mut cmd, lib_path, aux_path);\n     for (key, val) in env {\n-        cmd.env(key, val);\n+        cmd.env(&key, &val);\n     }\n \n     match cmd.spawn() {"}, {"sha": "7fb1a436ba3859e824c5e73db05c5392912f5ab0", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 184, "deletions": 167, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -11,35 +11,30 @@\n use self::TargetLocation::*;\n \n use common::Config;\n-use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind, DebugInfoGdb};\n-use common::{Codegen, DebugInfoLldb};\n+use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind};\n+use common::{Codegen, DebugInfoLldb, DebugInfoGdb};\n use errors;\n use header::TestProps;\n use header;\n use procsrv;\n use util::logv;\n-#[cfg(target_os = \"windows\")]\n-use util;\n-\n-#[cfg(target_os = \"windows\")]\n-use std::ascii::AsciiExt;\n-use std::old_io::File;\n-use std::old_io::fs::PathExtensions;\n-use std::old_io::fs;\n-use std::old_io::net::tcp;\n-use std::old_io::process::ProcessExit;\n-use std::old_io::process;\n-use std::old_io::timer;\n-use std::old_io;\n+\n use std::env;\n+use std::ffi::OsStr;\n+use std::fmt;\n+use std::fs::{self, File};\n+use std::io::BufReader;\n+use std::io::prelude::*;\n use std::iter::repeat;\n+use std::net::TcpStream;\n+use std::old_io::timer;\n+use std::path::{Path, PathBuf};\n+use std::process::{Command, Output, ExitStatus};\n use std::str;\n-use std::string::String;\n-use std::thread;\n use std::time::Duration;\n use test::MetricMap;\n \n-pub fn run(config: Config, testfile: String) {\n+pub fn run(config: Config, testfile: &Path) {\n     match &*config.target {\n \n         \"arm-linux-androideabi\" | \"aarch64-linux-android\" => {\n@@ -55,12 +50,11 @@ pub fn run(config: Config, testfile: String) {\n     run_metrics(config, testfile, &mut _mm);\n }\n \n-pub fn run_metrics(config: Config, testfile: String, mm: &mut MetricMap) {\n+pub fn run_metrics(config: Config, testfile: &Path, mm: &mut MetricMap) {\n     if config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n         print!(\"\\n\\n\");\n     }\n-    let testfile = Path::new(testfile);\n     debug!(\"running {:?}\", testfile.display());\n     let props = header::load_props(&testfile);\n     debug!(\"loaded props\");\n@@ -127,8 +121,8 @@ fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     };\n \n     // The value our Makefile configures valgrind to return on failure\n-    const VALGRIND_ERR: int = 100;\n-    if proc_res.status.matches_exit_status(VALGRIND_ERR) {\n+    const VALGRIND_ERR: i32 = 100;\n+    if proc_res.status.code() == Some(VALGRIND_ERR) {\n         fatal_proc_rec(\"run-fail test isn't valgrind-clean!\", &proc_res);\n     }\n \n@@ -139,10 +133,10 @@ fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n fn check_correct_failure_status(proc_res: &ProcRes) {\n     // The value the rust runtime returns on failure\n-    const RUST_ERR: int = 101;\n-    if !proc_res.status.matches_exit_status(RUST_ERR) {\n+    const RUST_ERR: i32 = 101;\n+    if proc_res.status.code() != Some(RUST_ERR) {\n         fatal_proc_rec(\n-            &format!(\"failure produced the wrong error: {:?}\",\n+            &format!(\"failure produced the wrong error: {}\",\n                      proc_res.status),\n             proc_res);\n     }\n@@ -201,8 +195,8 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n     let rounds =\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n-    let src = File::open(testfile).read_to_end().unwrap();\n-    let src = String::from_utf8(src.clone()).unwrap();\n+    let mut src = String::new();\n+    File::open(testfile).unwrap().read_to_string(&mut src).unwrap();\n     let mut srcs = vec!(src);\n \n     let mut round = 0;\n@@ -226,9 +220,10 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n     let mut expected = match props.pp_exact {\n         Some(ref file) => {\n-            let filepath = testfile.dir_path().join(file);\n-            let s = File::open(&filepath).read_to_end().unwrap();\n-            String::from_utf8(s).unwrap()\n+            let filepath = testfile.parent().unwrap().join(file);\n+            let mut s = String::new();\n+            File::open(&filepath).unwrap().read_to_string(&mut s).unwrap();\n+            s\n         }\n         None => { srcs[srcs.len() - 2].clone() }\n     };\n@@ -283,7 +278,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                      pretty_type.to_string()),\n                         props.exec_env.clone(),\n                         &config.compile_lib_path,\n-                        Some(aux_dir.as_str().unwrap()),\n+                        Some(aux_dir.to_str().unwrap()),\n                         Some(src))\n     }\n \n@@ -299,11 +294,11 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n                             pretty_type,\n                             format!(\"--target={}\", config.target),\n                             \"-L\".to_string(),\n-                            aux_dir.as_str().unwrap().to_string());\n+                            aux_dir.to_str().unwrap().to_string());\n         args.extend(split_maybe_args(&config.target_rustcflags).into_iter());\n         args.extend(split_maybe_args(&props.compile_flags).into_iter());\n         return ProcArgs {\n-            prog: config.rustc_path.as_str().unwrap().to_string(),\n+            prog: config.rustc_path.to_str().unwrap().to_string(),\n             args: args,\n         };\n     }\n@@ -345,14 +340,14 @@ actual:\\n\\\n                             \"--crate-type=lib\".to_string(),\n                             format!(\"--target={}\", target),\n                             \"-L\".to_string(),\n-                            config.build_base.as_str().unwrap().to_string(),\n+                            config.build_base.to_str().unwrap().to_string(),\n                             \"-L\".to_string(),\n-                            aux_dir.as_str().unwrap().to_string());\n+                            aux_dir.to_str().unwrap().to_string());\n         args.extend(split_maybe_args(&config.target_rustcflags).into_iter());\n         args.extend(split_maybe_args(&props.compile_flags).into_iter());\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         return ProcArgs {\n-            prog: config.rustc_path.as_str().unwrap().to_string(),\n+            prog: config.rustc_path.to_str().unwrap().to_string(),\n             args: args,\n         };\n     }\n@@ -390,18 +385,19 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             // write debugger script\n             let mut script_str = String::with_capacity(2048);\n             script_str.push_str(\"set charset UTF-8\\n\");\n-            script_str.push_str(&format!(\"file {}\\n\", exe_file.as_str().unwrap()));\n+            script_str.push_str(&format!(\"file {}\\n\", exe_file.to_str().unwrap()));\n             script_str.push_str(\"target remote :5039\\n\");\n             script_str.push_str(&format!(\"set solib-search-path \\\n                                          ./{}/stage2/lib/rustlib/{}/lib/\\n\",\n                                          config.host, config.target));\n             for line in breakpoint_lines.iter() {\n                 script_str.push_str(&format!(\"break {:?}:{}\\n\",\n-                                             testfile.filename_display(),\n+                                             testfile.file_name().unwrap()\n+                                                     .to_string_lossy(),\n                                              *line)[..]);\n             }\n             script_str.push_str(&cmds);\n-            script_str.push_str(\"quit\\n\");\n+            script_str.push_str(\"\\nquit\\n\");\n \n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config,\n@@ -415,7 +411,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                          None,\n                          &[\n                             \"push\".to_string(),\n-                            exe_file.as_str().unwrap().to_string(),\n+                            exe_file.to_str().unwrap().to_string(),\n                             config.adb_test_dir.clone()\n                          ],\n                          vec!((\"\".to_string(), \"\".to_string())),\n@@ -440,9 +436,8 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                   if config.target.contains(\"aarch64\")\n                                   {\"64\"} else {\"\"},\n                                   config.adb_test_dir.clone(),\n-                                  str::from_utf8(\n-                                      exe_file.filename()\n-                                      .unwrap()).unwrap());\n+                                  exe_file.file_name().unwrap().to_str()\n+                                          .unwrap());\n \n             let mut process = procsrv::run_background(\"\",\n                                                       &config.adb_path\n@@ -459,16 +454,12 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             loop {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(Duration::milliseconds(1000));\n-                let result = thread::spawn(move || {\n-                    tcp::TcpStream::connect(\"127.0.0.1:5039\").unwrap();\n-                }).join();\n-                if result.is_err() {\n-                    continue;\n+                if TcpStream::connect(\"127.0.0.1:5039\").is_ok() {\n+                    break\n                 }\n-                break;\n             }\n \n-            let tool_path = match config.android_cross_path.as_str() {\n+            let tool_path = match config.android_cross_path.to_str() {\n                 Some(x) => x.to_string(),\n                 None => fatal(\"cannot find android cross path\")\n             };\n@@ -479,7 +470,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                 vec!(\"-quiet\".to_string(),\n                      \"-batch\".to_string(),\n                      \"-nx\".to_string(),\n-                     format!(\"-command={}\", debugger_script.as_str().unwrap()));\n+                     format!(\"-command={}\", debugger_script.to_str().unwrap()));\n \n             let mut gdb_path = tool_path;\n             gdb_path.push_str(&format!(\"/bin/{}-gdb\", config.target));\n@@ -503,12 +494,12 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             };\n \n             debugger_run_result = ProcRes {\n-                status: status,\n+                status: Status::Normal(status),\n                 stdout: out,\n                 stderr: err,\n                 cmdline: cmdline\n             };\n-            if process.signal_kill().is_err() {\n+            if process.kill().is_err() {\n                 println!(\"Adb process is already finished.\");\n             }\n         }\n@@ -518,7 +509,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                 .expect(\"Could not find Rust source root\");\n             let rust_pp_module_rel_path = Path::new(\"./src/etc\");\n             let rust_pp_module_abs_path = rust_src_root.join(rust_pp_module_rel_path)\n-                                                       .as_str()\n+                                                       .to_str()\n                                                        .unwrap()\n                                                        .to_string();\n             // write debugger script\n@@ -538,7 +529,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                         // GDB's script auto loading safe path\n                         script_str.push_str(\n                             &format!(\"add-auto-load-safe-path {}\\n\",\n-                                     rust_pp_module_abs_path.replace(\"\\\\\", \"\\\\\\\\\"))\n+                                     rust_pp_module_abs_path.replace(r\"\\\", r\"\\\\\"))\n                                 );\n                     }\n                 }\n@@ -553,21 +544,24 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             script_str.push_str(\"set print pretty off\\n\");\n \n             // Add the pretty printer directory to GDB's source-file search path\n-            script_str.push_str(&format!(\"directory {}\\n\", rust_pp_module_abs_path)[..]);\n+            script_str.push_str(&format!(\"directory {}\\n\",\n+                                         rust_pp_module_abs_path));\n \n             // Load the target executable\n             script_str.push_str(&format!(\"file {}\\n\",\n-                                         exe_file.as_str().unwrap().replace(\"\\\\\", \"\\\\\\\\\"))[..]);\n+                                         exe_file.to_str().unwrap()\n+                                                 .replace(r\"\\\", r\"\\\\\")));\n \n             // Add line breakpoints\n             for line in &breakpoint_lines {\n                 script_str.push_str(&format!(\"break '{}':{}\\n\",\n-                                             testfile.filename_display(),\n-                                             *line)[..]);\n+                                             testfile.file_name().unwrap()\n+                                                     .to_string_lossy(),\n+                                             *line));\n             }\n \n             script_str.push_str(&cmds);\n-            script_str.push_str(\"quit\\n\");\n+            script_str.push_str(\"\\nquit\\n\");\n \n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config,\n@@ -576,13 +570,8 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                              \"debugger.script\");\n \n             // run debugger script with gdb\n-            #[cfg(windows)]\n-            fn debugger() -> String {\n-                \"gdb.exe\".to_string()\n-            }\n-            #[cfg(unix)]\n-            fn debugger() -> String {\n-                \"gdb\".to_string()\n+            fn debugger() -> &'static str {\n+                if cfg!(windows) {\"gdb.exe\"} else {\"gdb\"}\n             }\n \n             let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n@@ -592,10 +581,10 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                 vec!(\"-quiet\".to_string(),\n                      \"-batch\".to_string(),\n                      \"-nx\".to_string(),\n-                     format!(\"-command={}\", debugger_script.as_str().unwrap()));\n+                     format!(\"-command={}\", debugger_script.to_str().unwrap()));\n \n             let proc_args = ProcArgs {\n-                prog: debugger(),\n+                prog: debugger().to_string(),\n                 args: debugger_opts,\n             };\n \n@@ -618,7 +607,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n     check_debugger_output(&debugger_run_result, &check_lines);\n }\n \n-fn find_rust_src_root(config: &Config) -> Option<Path> {\n+fn find_rust_src_root(config: &Config) -> Option<PathBuf> {\n     let mut path = config.src_base.clone();\n     let path_postfix = Path::new(\"src/etc/lldb_batchmode.py\");\n \n@@ -632,8 +621,6 @@ fn find_rust_src_root(config: &Config) -> Option<Path> {\n }\n \n fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path) {\n-    use std::old_io::process::{Command, ProcessOutput};\n-\n     if config.lldb_python_dir.is_none() {\n         fatal(\"Can't run LLDB test because LLDB's python path is not set.\");\n     }\n@@ -685,11 +672,12 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n         .expect(\"Could not find Rust source root\");\n     let rust_pp_module_rel_path = Path::new(\"./src/etc/lldb_rust_formatters.py\");\n     let rust_pp_module_abs_path = rust_src_root.join(rust_pp_module_rel_path)\n-                                               .as_str()\n+                                               .to_str()\n                                                .unwrap()\n                                                .to_string();\n \n-    script_str.push_str(&format!(\"command script import {}\\n\", &rust_pp_module_abs_path[..])[..]);\n+    script_str.push_str(&format!(\"command script import {}\\n\",\n+                                 &rust_pp_module_abs_path[..])[..]);\n     script_str.push_str(\"type summary add --no-value \");\n     script_str.push_str(\"--python-function lldb_rust_formatters.print_val \");\n     script_str.push_str(\"-x \\\".*\\\" --category Rust\\n\");\n@@ -707,7 +695,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     }\n \n     // Finally, quit the debugger\n-    script_str.push_str(\"quit\\n\");\n+    script_str.push_str(\"\\nquit\\n\");\n \n     // Write the script into a file\n     debug!(\"script_str = {}\", script_str);\n@@ -735,22 +723,19 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n                 rust_src_root: &Path)\n                 -> ProcRes {\n         // Prepare the lldb_batchmode which executes the debugger script\n-        let lldb_script_path = rust_src_root.join(Path::new(\"./src/etc/lldb_batchmode.py\"));\n+        let lldb_script_path = rust_src_root.join(\"src/etc/lldb_batchmode.py\");\n \n         let mut cmd = Command::new(\"python\");\n-        cmd.arg(lldb_script_path)\n+        cmd.arg(&lldb_script_path)\n            .arg(test_executable)\n            .arg(debugger_script)\n-           .env_set_all(&[(\"PYTHONPATH\", config.lldb_python_dir.clone().unwrap())]);\n-\n-        let (status, out, err) = match cmd.spawn() {\n-            Ok(process) => {\n-                let ProcessOutput { status, output, error } =\n-                    process.wait_with_output().unwrap();\n+           .env(\"PYTHONPATH\", config.lldb_python_dir.as_ref().unwrap());\n \n+        let (status, out, err) = match cmd.output() {\n+            Ok(Output { status, stdout, stderr }) => {\n                 (status,\n-                 String::from_utf8(output).unwrap(),\n-                 String::from_utf8(error).unwrap())\n+                 String::from_utf8(stdout).unwrap(),\n+                 String::from_utf8(stderr).unwrap())\n             },\n             Err(e) => {\n                 fatal(&format!(\"Failed to setup Python process for \\\n@@ -760,7 +745,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n \n         dump_output(config, test_executable, &out, &err);\n         return ProcRes {\n-            status: status,\n+            status: Status::Normal(status),\n             stdout: out,\n             stderr: err,\n             cmdline: format!(\"{:?}\", cmd)\n@@ -776,16 +761,14 @@ struct DebuggerCommands {\n \n fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n                            -> DebuggerCommands {\n-    use std::old_io::{BufferedReader, File};\n-\n     let command_directive = format!(\"{}-command\", debugger_prefix);\n     let check_directive = format!(\"{}-check\", debugger_prefix);\n \n     let mut breakpoint_lines = vec!();\n     let mut commands = vec!();\n     let mut check_lines = vec!();\n     let mut counter = 1;\n-    let mut reader = BufferedReader::new(File::open(file_path).unwrap());\n+    let reader = BufReader::new(File::open(file_path).unwrap());\n     for line in reader.lines() {\n         match line {\n             Ok(line) => {\n@@ -963,16 +946,17 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n \n     let prefixes = expected_errors.iter().map(|ee| {\n         format!(\"{}:{}:\", testfile.display(), ee.line)\n-    }).collect::<Vec<String> >();\n-\n-    #[cfg(windows)]\n-    fn prefix_matches( line : &str, prefix : &str ) -> bool {\n-        line.to_ascii_lowercase().starts_with(&prefix.to_ascii_lowercase())\n-    }\n-\n-    #[cfg(unix)]\n-    fn prefix_matches( line : &str, prefix : &str ) -> bool {\n-        line.starts_with( prefix )\n+    }).collect::<Vec<String>>();\n+\n+    fn prefix_matches(line: &str, prefix: &str) -> bool {\n+        use std::ascii::AsciiExt;\n+        // On windows just translate all '\\' path separators to '/'\n+        let line = line.replace(r\"\\\", \"/\");\n+        if cfg!(windows) {\n+            line.to_ascii_lowercase().starts_with(&prefix.to_ascii_lowercase())\n+        } else {\n+            line.starts_with(prefix)\n+        }\n     }\n \n     // A multi-line error will have followup lines which will always\n@@ -1113,12 +1097,42 @@ struct ProcArgs {\n }\n \n struct ProcRes {\n-    status: ProcessExit,\n+    status: Status,\n     stdout: String,\n     stderr: String,\n     cmdline: String,\n }\n \n+enum Status {\n+    Parsed(i32),\n+    Normal(ExitStatus),\n+}\n+\n+impl Status {\n+    fn code(&self) -> Option<i32> {\n+        match *self {\n+            Status::Parsed(i) => Some(i),\n+            Status::Normal(ref e) => e.code(),\n+        }\n+    }\n+\n+    fn success(&self) -> bool {\n+        match *self {\n+            Status::Parsed(i) => i == 0,\n+            Status::Normal(ref e) => e.success(),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Status {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Status::Parsed(i) => write!(f, \"exit code: {}\", i),\n+            Status::Normal(ref e) => e.fmt(f),\n+        }\n+    }\n+}\n+\n fn compile_test(config: &Config, props: &TestProps,\n                 testfile: &Path) -> ProcRes {\n     compile_test_(config, props, testfile, &[])\n@@ -1133,7 +1147,7 @@ fn compile_test_(config: &Config, props: &TestProps,\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let mut link_args = vec!(\"-L\".to_string(),\n-                             aux_dir.as_str().unwrap().to_string());\n+                             aux_dir.to_str().unwrap().to_string());\n     link_args.extend(extra_args.iter().cloned());\n     let args = make_compile_args(config,\n                                  props,\n@@ -1160,7 +1174,7 @@ fn exec_compiled_test(config: &Config, props: &TestProps,\n                             make_run_args(config, props, testfile),\n                             env,\n                             &config.run_lib_path,\n-                            Some(aux_dir.as_str().unwrap()),\n+                            Some(aux_dir.to_str().unwrap()),\n                             None)\n         }\n     }\n@@ -1179,7 +1193,7 @@ fn compose_and_run_compiler(\n \n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let extra_link_args = vec!(\"-L\".to_string(), aux_dir.as_str().unwrap().to_string());\n+    let extra_link_args = vec!(\"-L\".to_string(), aux_dir.to_str().unwrap().to_string());\n \n     for rel_ab in &props.aux_builds {\n         let abs_ab = config.aux_base.join(rel_ab);\n@@ -1196,15 +1210,16 @@ fn compose_and_run_compiler(\n                               crate_type,\n                               |a,b| {\n                                   let f = make_lib_name(a, b, testfile);\n-                                  TargetLocation::ThisDirectory(f.dir_path())\n+                                  let parent = f.parent().unwrap();\n+                                  TargetLocation::ThisDirectory(parent.to_path_buf())\n                               },\n                               &abs_ab);\n         let auxres = compose_and_run(config,\n                                      &abs_ab,\n                                      aux_args,\n                                      Vec::new(),\n                                      &config.compile_lib_path,\n-                                     Some(aux_dir.as_str().unwrap()),\n+                                     Some(aux_dir.to_str().unwrap()),\n                                      None);\n         if !auxres.status.success() {\n             fatal_proc_rec(\n@@ -1226,13 +1241,13 @@ fn compose_and_run_compiler(\n                     args,\n                     Vec::new(),\n                     &config.compile_lib_path,\n-                    Some(aux_dir.as_str().unwrap()),\n+                    Some(aux_dir.to_str().unwrap()),\n                     input)\n }\n \n fn ensure_dir(path: &Path) {\n     if path.is_dir() { return; }\n-    fs::mkdir(path, old_io::USER_RWX).unwrap();\n+    fs::create_dir(path).unwrap();\n }\n \n fn compose_and_run(config: &Config, testfile: &Path,\n@@ -1246,8 +1261,8 @@ fn compose_and_run(config: &Config, testfile: &Path,\n }\n \n enum TargetLocation {\n-    ThisFile(Path),\n-    ThisDirectory(Path),\n+    ThisFile(PathBuf),\n+    ThisDirectory(PathBuf),\n }\n \n fn make_compile_args<F>(config: &Config,\n@@ -1265,9 +1280,9 @@ fn make_compile_args<F>(config: &Config,\n         &*config.target\n     };\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let mut args = vec!(testfile.as_str().unwrap().to_string(),\n+    let mut args = vec!(testfile.to_str().unwrap().to_string(),\n                         \"-L\".to_string(),\n-                        config.build_base.as_str().unwrap().to_string(),\n+                        config.build_base.to_str().unwrap().to_string(),\n                         format!(\"--target={}\", target));\n     args.push_all(&extras);\n     if !props.no_prefer_dynamic {\n@@ -1284,32 +1299,32 @@ fn make_compile_args<F>(config: &Config,\n             path\n         }\n     };\n-    args.push(path.as_str().unwrap().to_string());\n+    args.push(path.to_str().unwrap().to_string());\n     if props.force_host {\n         args.extend(split_maybe_args(&config.host_rustcflags).into_iter());\n     } else {\n         args.extend(split_maybe_args(&config.target_rustcflags).into_iter());\n     }\n     args.extend(split_maybe_args(&props.compile_flags).into_iter());\n     return ProcArgs {\n-        prog: config.rustc_path.as_str().unwrap().to_string(),\n+        prog: config.rustc_path.to_str().unwrap().to_string(),\n         args: args,\n     };\n }\n \n-fn make_lib_name(config: &Config, auxfile: &Path, testfile: &Path) -> Path {\n+fn make_lib_name(config: &Config, auxfile: &Path, testfile: &Path) -> PathBuf {\n     // what we return here is not particularly important, as it\n     // happens; rustc ignores everything except for the directory.\n     let auxname = output_testname(auxfile);\n     aux_output_dir_name(config, testfile).join(&auxname)\n }\n \n-fn make_exe_name(config: &Config, testfile: &Path) -> Path {\n+fn make_exe_name(config: &Config, testfile: &Path) -> PathBuf {\n     let mut f = output_base_name(config, testfile);\n     if !env::consts::EXE_SUFFIX.is_empty() {\n-        let mut fname = f.filename().unwrap().to_vec();\n-        fname.extend(env::consts::EXE_SUFFIX.bytes());\n-        f.set_filename(fname);\n+        let mut fname = f.file_name().unwrap().to_os_string();\n+        fname.push_os_str(OsStr::from_str(env::consts::EXE_SUFFIX));\n+        f.set_file_name(&fname);\n     }\n     f\n }\n@@ -1322,7 +1337,7 @@ fn make_run_args(config: &Config, props: &TestProps, testfile: &Path) ->\n     let exe_file = make_exe_name(config, testfile);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    args.push(exe_file.as_str().unwrap().to_string());\n+    args.push(exe_file.to_str().unwrap().to_string());\n \n     // Add the arguments in the run_flags directive\n     args.extend(split_maybe_args(&props.run_flags).into_iter());\n@@ -1375,29 +1390,28 @@ fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: String\n                      input).expect(&format!(\"failed to exec `{}`\", prog));\n     dump_output(config, testfile, &out, &err);\n     return ProcRes {\n-        status: status,\n+        status: Status::Normal(status),\n         stdout: out,\n         stderr: err,\n         cmdline: cmdline,\n     };\n }\n \n-// Linux and mac don't require adjusting the library search path\n-#[cfg(unix)]\n-fn make_cmdline(_libpath: &str, prog: &str, args: &[String]) -> String {\n-    format!(\"{} {}\", prog, args.connect(\" \"))\n-}\n-\n-#[cfg(windows)]\n fn make_cmdline(libpath: &str, prog: &str, args: &[String]) -> String {\n+    use util;\n \n-    // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n-    // for diagnostic purposes\n-    fn lib_path_cmd_prefix(path: &str) -> String {\n-        format!(\"{}=\\\"{}\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n-    }\n+    // Linux and mac don't require adjusting the library search path\n+    if cfg!(unix) {\n+        format!(\"{} {}\", prog, args.connect(\" \"))\n+    } else {\n+        // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n+        // for diagnostic purposes\n+        fn lib_path_cmd_prefix(path: &str) -> String {\n+            format!(\"{}=\\\"{}\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n+        }\n \n-    format!(\"{} {} {}\", lib_path_cmd_prefix(libpath), prog, args.connect(\" \"))\n+        format!(\"{} {} {}\", lib_path_cmd_prefix(libpath), prog, args.connect(\" \"))\n+    }\n }\n \n fn dump_output(config: &Config, testfile: &Path, out: &str, err: &str) {\n@@ -1409,25 +1423,25 @@ fn dump_output(config: &Config, testfile: &Path, out: &str, err: &str) {\n fn dump_output_file(config: &Config, testfile: &Path,\n                     out: &str, extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n-    File::create(&outfile).write_all(out.as_bytes()).unwrap();\n+    File::create(&outfile).unwrap().write_all(out.as_bytes()).unwrap();\n }\n \n-fn make_out_name(config: &Config, testfile: &Path, extension: &str) -> Path {\n+fn make_out_name(config: &Config, testfile: &Path, extension: &str) -> PathBuf {\n     output_base_name(config, testfile).with_extension(extension)\n }\n \n-fn aux_output_dir_name(config: &Config, testfile: &Path) -> Path {\n+fn aux_output_dir_name(config: &Config, testfile: &Path) -> PathBuf {\n     let f = output_base_name(config, testfile);\n-    let mut fname = f.filename().unwrap().to_vec();\n-    fname.extend(\"libaux\".bytes());\n-    f.with_filename(fname)\n+    let mut fname = f.file_name().unwrap().to_os_string();\n+    fname.push_os_str(OsStr::from_str(\"libaux\"));\n+    f.with_file_name(&fname)\n }\n \n-fn output_testname(testfile: &Path) -> Path {\n-    Path::new(testfile.filestem().unwrap())\n+fn output_testname(testfile: &Path) -> PathBuf {\n+    PathBuf::new(testfile.file_stem().unwrap())\n }\n \n-fn output_base_name(config: &Config, testfile: &Path) -> Path {\n+fn output_base_name(config: &Config, testfile: &Path) -> PathBuf {\n     config.build_base\n         .join(&output_testname(testfile))\n         .with_extension(&config.stage_id)\n@@ -1542,11 +1556,11 @@ fn _arm_exec_compiled_test(config: &Config,\n                      Some(\"\".to_string()))\n         .expect(&format!(\"failed to exec `{}`\", config.adb_path));\n \n-    let mut exitcode: int = 0;\n+    let mut exitcode: i32 = 0;\n     for c in exitcode_out.chars() {\n         if !c.is_numeric() { break; }\n         exitcode = exitcode * 10 + match c {\n-            '0' ... '9' => c as int - ('0' as int),\n+            '0' ... '9' => c as i32 - ('0' as i32),\n             _ => 101,\n         }\n     }\n@@ -1587,7 +1601,7 @@ fn _arm_exec_compiled_test(config: &Config,\n                 &stderr_out);\n \n     ProcRes {\n-        status: process::ProcessExit::ExitStatus(exitcode),\n+        status: Status::Parsed(exitcode),\n         stdout: stdout_out,\n         stderr: stderr_out,\n         cmdline: cmdline\n@@ -1597,16 +1611,17 @@ fn _arm_exec_compiled_test(config: &Config,\n fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n     let tdir = aux_output_dir_name(config, testfile);\n \n-    let dirs = fs::readdir(&tdir).unwrap();\n-    for file in &dirs {\n-        if file.extension_str() == Some(\"so\") {\n+    let dirs = fs::read_dir(&tdir).unwrap();\n+    for file in dirs {\n+        let file = file.unwrap().path();\n+        if file.extension().and_then(|s| s.to_str()) == Some(\"so\") {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let copy_result = procsrv::run(\"\",\n                                            &config.adb_path,\n                                            None,\n                                            &[\n                                             \"push\".to_string(),\n-                                            file.as_str()\n+                                            file.to_str()\n                                                 .unwrap()\n                                                 .to_string(),\n                                             config.adb_test_dir.to_string(),\n@@ -1627,14 +1642,14 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n \n // codegen tests (vs. clang)\n \n-fn append_suffix_to_stem(p: &Path, suffix: &str) -> Path {\n+fn append_suffix_to_stem(p: &Path, suffix: &str) -> PathBuf {\n     if suffix.len() == 0 {\n-        (*p).clone()\n+        p.to_path_buf()\n     } else {\n-        let mut stem = p.filestem().unwrap().to_vec();\n-        stem.extend(\"-\".bytes());\n-        stem.extend(suffix.bytes());\n-        p.with_filename(stem)\n+        let mut stem = p.file_stem().unwrap().to_os_string();\n+        stem.push_os_str(OsStr::from_str(\"-\"));\n+        stem.push_os_str(OsStr::from_str(suffix));\n+        p.with_file_name(&stem)\n     }\n }\n \n@@ -1643,15 +1658,16 @@ fn compile_test_and_save_bitcode(config: &Config, props: &TestProps,\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let mut link_args = vec!(\"-L\".to_string(),\n-                             aux_dir.as_str().unwrap().to_string());\n+                             aux_dir.to_str().unwrap().to_string());\n     let llvm_args = vec!(\"--emit=llvm-bc,obj\".to_string(),\n                          \"--crate-type=lib\".to_string());\n     link_args.extend(llvm_args.into_iter());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args,\n                                  |a, b| TargetLocation::ThisDirectory(\n-                                     output_base_name(a, b).dir_path()),\n+                                     output_base_name(a, b).parent()\n+                                        .unwrap().to_path_buf()),\n                                  testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)\n }\n@@ -1663,12 +1679,12 @@ fn compile_cc_with_clang_and_save_bitcode(config: &Config, _props: &TestProps,\n     let testcc = testfile.with_extension(\"cc\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: config.clang_path.as_ref().unwrap().as_str().unwrap().to_string(),\n+        prog: config.clang_path.as_ref().unwrap().to_str().unwrap().to_string(),\n         args: vec!(\"-c\".to_string(),\n                    \"-emit-llvm\".to_string(),\n                    \"-o\".to_string(),\n-                   bitcodefile.as_str().unwrap().to_string(),\n-                   testcc.as_str().unwrap().to_string())\n+                   bitcodefile.to_str().unwrap().to_string(),\n+                   testcc.to_str().unwrap().to_string())\n     };\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None, None)\n }\n@@ -1682,10 +1698,10 @@ fn extract_function_from_bitcode(config: &Config, _props: &TestProps,\n     let prog = config.llvm_bin_path.as_ref().unwrap().join(\"llvm-extract\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: prog.as_str().unwrap().to_string(),\n+        prog: prog.to_str().unwrap().to_string(),\n         args: vec!(format!(\"-func={}\", fname),\n-                   format!(\"-o={}\", extracted_bc.as_str().unwrap()),\n-                   bitcodefile.as_str().unwrap().to_string())\n+                   format!(\"-o={}\", extracted_bc.to_str().unwrap()),\n+                   bitcodefile.to_str().unwrap().to_string())\n     };\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None, None)\n }\n@@ -1699,16 +1715,17 @@ fn disassemble_extract(config: &Config, _props: &TestProps,\n     let prog = config.llvm_bin_path.as_ref().unwrap().join(\"llvm-dis\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: prog.as_str().unwrap().to_string(),\n-        args: vec!(format!(\"-o={}\", extracted_ll.as_str().unwrap()),\n-                   extracted_bc.as_str().unwrap().to_string())\n+        prog: prog.to_str().unwrap().to_string(),\n+        args: vec!(format!(\"-o={}\", extracted_ll.to_str().unwrap()),\n+                   extracted_bc.to_str().unwrap().to_string())\n     };\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None, None)\n }\n \n \n fn count_extracted_lines(p: &Path) -> uint {\n-    let x = File::open(&p.with_extension(\"ll\")).read_to_end().unwrap();\n+    let mut x = Vec::new();\n+    File::open(&p.with_extension(\"ll\")).unwrap().read_to_end(&mut x).unwrap();\n     let x = str::from_utf8(&x).unwrap();\n     x.lines().count()\n }"}, {"sha": "16e2806f72cecd2bdeef69af472fda23e4798311", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use common::Config;\n-\n-#[cfg(target_os = \"windows\")]\n use std::env;\n+use common::Config;\n \n /// Conversion table from triple OS name to Rust SYSNAME\n const OS_TABLE: &'static [(&'static str, &'static str)] = &[\n@@ -36,24 +34,20 @@ pub fn get_os(triple: &str) -> &'static str {\n     panic!(\"Cannot determine OS from triple\");\n }\n \n-#[cfg(target_os = \"windows\")]\n pub fn make_new_path(path: &str) -> String {\n-\n+    assert!(cfg!(windows));\n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n     match env::var(lib_path_env_var()) {\n-      Ok(curr) => {\n-        format!(\"{}{}{}\", path, path_div(), curr)\n-      }\n-      Err(..) => path.to_string()\n+        Ok(curr) => {\n+            format!(\"{}{}{}\", path, path_div(), curr)\n+        }\n+        Err(..) => path.to_string()\n     }\n }\n \n-#[cfg(target_os = \"windows\")]\n pub fn lib_path_env_var() -> &'static str { \"PATH\" }\n-\n-#[cfg(target_os = \"windows\")]\n-pub fn path_div() -> &'static str { \";\" }\n+fn path_div() -> &'static str { \";\" }\n \n pub fn logv(config: &Config, s: String) {\n     debug!(\"{}\", s);"}, {"sha": "b1fdf139b0c51c739ac10325c00f93857eb538f8", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -73,6 +73,7 @@\n #![feature(unboxed_closures)]\n #![feature(unsafe_no_drop_flag)]\n #![feature(core)]\n+#![feature(unique)]\n #![cfg_attr(test, feature(test, alloc, rustc_private))]\n #![cfg_attr(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")),\n             feature(libc))]"}, {"sha": "6b9d6cb0000f2fa5e296af72026caab82c27ddb5", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -93,6 +93,7 @@\n #![feature(int_uint)]\n #![feature(staged_api)]\n #![feature(str_words)]\n+#![feature(core)]\n #![cfg_attr(test, feature(rustc_private))]\n \n #[cfg(test)] #[macro_use] extern crate log;"}, {"sha": "2d542eafbe1ae3a2dc27c7b3ada24e462772ba10", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -39,6 +39,9 @@\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(os)]\n+#![feature(path)]\n+#![feature(fs)]\n+#![feature(io)]\n #![cfg_attr(test, feature(test))]\n \n extern crate arena;"}, {"sha": "a19ccceb0571538ce22375c6d33b219853816e75", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -21,6 +21,7 @@ use metadata::decoder;\n use metadata::loader;\n use metadata::loader::CratePaths;\n \n+use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi;\n@@ -126,7 +127,7 @@ fn register_native_lib(sess: &Session,\n // Extra info about a crate loaded for plugins or exported macros.\n struct ExtensionCrate {\n     metadata: PMDSource,\n-    dylib: Option<Path>,\n+    dylib: Option<PathBuf>,\n     target_only: bool,\n }\n \n@@ -551,7 +552,8 @@ impl<'a> CrateReader<'a> {\n     }\n \n     /// Look for a plugin registrar. Returns library path and symbol name.\n-    pub fn find_plugin_registrar(&mut self, span: Span, name: &str) -> Option<(Path, String)> {\n+    pub fn find_plugin_registrar(&mut self, span: Span, name: &str)\n+                                 -> Option<(PathBuf, String)> {\n         let ekrate = self.read_extension_crate(span, &CrateInfo {\n              name: name.to_string(),\n              ident: name.to_string(),\n@@ -574,7 +576,7 @@ impl<'a> CrateReader<'a> {\n             .map(|id| decoder::get_symbol(ekrate.metadata.as_slice(), id));\n \n         match (ekrate.dylib.as_ref(), registrar) {\n-            (Some(dylib), Some(reg)) => Some((dylib.clone(), reg)),\n+            (Some(dylib), Some(reg)) => Some((dylib.to_path_buf(), reg)),\n             (None, Some(_)) => {\n                 let message = format!(\"plugin `{}` only found in rlib format, \\\n                                        but must be available in dylib format\","}, {"sha": "47ec31c0f1ab7d0c26b7d366282cf54d368121b9", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -25,6 +25,7 @@ use util::nodemap::{FnvHashMap, NodeMap};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n+use std::path::PathBuf;\n use flate::Bytes;\n use syntax::ast;\n use syntax::codemap;\n@@ -78,8 +79,8 @@ pub enum NativeLibraryKind {\n // must be non-None.\n #[derive(PartialEq, Clone)]\n pub struct CrateSource {\n-    pub dylib: Option<(Path, PathKind)>,\n-    pub rlib: Option<(Path, PathKind)>,\n+    pub dylib: Option<(PathBuf, PathKind)>,\n+    pub rlib: Option<(PathBuf, PathKind)>,\n     pub cnum: ast::CrateNum,\n }\n \n@@ -172,7 +173,7 @@ impl CStore {\n     // topological sort of all crates putting the leaves at the right-most\n     // positions.\n     pub fn get_used_crates(&self, prefer: LinkagePreference)\n-                           -> Vec<(ast::CrateNum, Option<Path>)> {\n+                           -> Vec<(ast::CrateNum, Option<PathBuf>)> {\n         let mut ordering = Vec::new();\n         fn visit(cstore: &CStore, cnum: ast::CrateNum,\n                  ordering: &mut Vec<ast::CrateNum>) {"}, {"sha": "90046398c59f4354bc0fb127d1a3b4319d0642a4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -34,9 +34,9 @@ use middle::astencode::vtable_decoder_helpers;\n \n use std::collections::HashMap;\n use std::hash::{self, Hash, SipHasher};\n-use std::num::FromPrimitive;\n-use std::num::Int;\n-use std::old_io;\n+use std::io::prelude::*;\n+use std::io;\n+use std::num::{FromPrimitive, Int};\n use std::rc::Rc;\n use std::slice::bytes;\n use std::str;\n@@ -1191,7 +1191,7 @@ fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n }\n \n fn list_crate_attributes(md: rbml::Doc, hash: &Svh,\n-                         out: &mut old_io::Writer) -> old_io::IoResult<()> {\n+                         out: &mut io::Write) -> io::Result<()> {\n     try!(write!(out, \"=Crate Attributes ({})=\\n\", *hash));\n \n     let r = get_attributes(md);\n@@ -1236,7 +1236,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     return deps;\n }\n \n-fn list_crate_deps(data: &[u8], out: &mut old_io::Writer) -> old_io::IoResult<()> {\n+fn list_crate_deps(data: &[u8], out: &mut io::Write) -> io::Result<()> {\n     try!(write!(out, \"=External Dependencies=\\n\"));\n     for dep in &get_crate_deps(data) {\n         try!(write!(out, \"{} {}-{}\\n\", dep.cnum, dep.name, dep.hash));\n@@ -1275,7 +1275,7 @@ pub fn get_crate_name(data: &[u8]) -> String {\n     maybe_get_crate_name(data).expect(\"no crate name in crate\")\n }\n \n-pub fn list_crate_metadata(bytes: &[u8], out: &mut old_io::Writer) -> old_io::IoResult<()> {\n+pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Write) -> io::Result<()> {\n     let hash = get_crate_hash(bytes);\n     let md = rbml::Doc::new(bytes);\n     try!(list_crate_attributes(md, &hash, out));"}, {"sha": "22a4a6fc978dc055a9a79ae360b03c0d51feca7e", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -14,9 +14,9 @@ pub use self::FileMatch::*;\n \n use std::collections::HashSet;\n use std::env;\n-use std::os;\n-use std::old_io::fs::PathExtensions;\n-use std::old_io::fs;\n+use std::fs;\n+use std::io::prelude::*;\n+use std::path::{Path, PathBuf};\n \n use util::fs as myfs;\n use session::search_paths::{SearchPaths, PathKind};\n@@ -50,31 +50,31 @@ impl<'a> FileSearch<'a> {\n                 FileMatches => found = true,\n                 FileDoesntMatch => ()\n             }\n-            visited_dirs.insert(path.as_vec().to_vec());\n+            visited_dirs.insert(path.to_path_buf());\n         }\n \n         debug!(\"filesearch: searching lib path\");\n         let tlib_path = make_target_lib_path(self.sysroot,\n                                              self.triple);\n-        if !visited_dirs.contains(tlib_path.as_vec()) {\n+        if !visited_dirs.contains(&tlib_path) {\n             match f(&tlib_path, PathKind::All) {\n                 FileMatches => found = true,\n                 FileDoesntMatch => ()\n             }\n         }\n \n-        visited_dirs.insert(tlib_path.as_vec().to_vec());\n+        visited_dirs.insert(tlib_path);\n         // Try RUST_PATH\n         if !found {\n             let rustpath = rust_path();\n             for path in &rustpath {\n                 let tlib_path = make_rustpkg_lib_path(\n                     self.sysroot, path, self.triple);\n                 debug!(\"is {} in visited_dirs? {}\", tlib_path.display(),\n-                        visited_dirs.contains(&tlib_path.as_vec().to_vec()));\n+                        visited_dirs.contains(&tlib_path));\n \n-                if !visited_dirs.contains(tlib_path.as_vec()) {\n-                    visited_dirs.insert(tlib_path.as_vec().to_vec());\n+                if !visited_dirs.contains(&tlib_path) {\n+                    visited_dirs.insert(tlib_path.clone());\n                     // Don't keep searching the RUST_PATH if one match turns up --\n                     // if we did, we'd get a \"multiple matching crates\" error\n                     match f(&tlib_path, PathKind::All) {\n@@ -88,7 +88,7 @@ impl<'a> FileSearch<'a> {\n         }\n     }\n \n-    pub fn get_lib_path(&self) -> Path {\n+    pub fn get_lib_path(&self) -> PathBuf {\n         make_target_lib_path(self.sysroot, self.triple)\n     }\n \n@@ -97,11 +97,13 @@ impl<'a> FileSearch<'a> {\n     {\n         self.for_each_lib_search_path(|lib_search_path, kind| {\n             debug!(\"searching {}\", lib_search_path.display());\n-            match fs::readdir(lib_search_path) {\n+            match fs::read_dir(lib_search_path) {\n                 Ok(files) => {\n+                    let files = files.filter_map(|p| p.ok().map(|s| s.path()))\n+                                     .collect::<Vec<_>>();\n                     let mut rslt = FileDoesntMatch;\n-                    fn is_rlib(p: & &Path) -> bool {\n-                        p.extension_str() == Some(\"rlib\")\n+                    fn is_rlib(p: &Path) -> bool {\n+                        p.extension().and_then(|s| s.to_str()) == Some(\"rlib\")\n                     }\n                     // Reading metadata out of rlibs is faster, and if we find both\n                     // an rlib and a dylib we only read one of the files of\n@@ -143,59 +145,60 @@ impl<'a> FileSearch<'a> {\n     }\n \n     // Returns a list of directories where target-specific dylibs might be located.\n-    pub fn get_dylib_search_paths(&self) -> Vec<Path> {\n+    pub fn get_dylib_search_paths(&self) -> Vec<PathBuf> {\n         let mut paths = Vec::new();\n         self.for_each_lib_search_path(|lib_search_path, _| {\n-            paths.push(lib_search_path.clone());\n+            paths.push(lib_search_path.to_path_buf());\n             FileDoesntMatch\n         });\n         paths\n     }\n \n     // Returns a list of directories where target-specific tool binaries are located.\n-    pub fn get_tools_search_paths(&self) -> Vec<Path> {\n-        let mut p = Path::new(self.sysroot);\n-        p.push(find_libdir(self.sysroot));\n-        p.push(rustlibdir());\n-        p.push(self.triple);\n+    pub fn get_tools_search_paths(&self) -> Vec<PathBuf> {\n+        let mut p = PathBuf::new(self.sysroot);\n+        p.push(&find_libdir(self.sysroot));\n+        p.push(&rustlibdir());\n+        p.push(&self.triple);\n         p.push(\"bin\");\n         vec![p]\n     }\n }\n \n-pub fn relative_target_lib_path(sysroot: &Path, target_triple: &str) -> Path {\n-    let mut p = Path::new(find_libdir(sysroot));\n+pub fn relative_target_lib_path(sysroot: &Path, target_triple: &str) -> PathBuf {\n+    let mut p = PathBuf::new(&find_libdir(sysroot));\n     assert!(p.is_relative());\n-    p.push(rustlibdir());\n+    p.push(&rustlibdir());\n     p.push(target_triple);\n     p.push(\"lib\");\n     p\n }\n \n fn make_target_lib_path(sysroot: &Path,\n-                        target_triple: &str) -> Path {\n+                        target_triple: &str) -> PathBuf {\n     sysroot.join(&relative_target_lib_path(sysroot, target_triple))\n }\n \n fn make_rustpkg_lib_path(sysroot: &Path,\n                          dir: &Path,\n-                         triple: &str) -> Path {\n-    let mut p = dir.join(find_libdir(sysroot));\n+                         triple: &str) -> PathBuf {\n+    let mut p = dir.join(&find_libdir(sysroot));\n     p.push(triple);\n     p\n }\n \n-pub fn get_or_default_sysroot() -> Path {\n+pub fn get_or_default_sysroot() -> PathBuf {\n     // Follow symlinks.  If the resolved path is relative, make it absolute.\n-    fn canonicalize(path: Option<Path>) -> Option<Path> {\n-        path.and_then(|path|\n+    fn canonicalize(path: Option<PathBuf>) -> Option<PathBuf> {\n+        path.and_then(|path| {\n             match myfs::realpath(&path) {\n                 Ok(canon) => Some(canon),\n                 Err(e) => panic!(\"failed to get realpath: {}\", e),\n-            })\n+            }\n+        })\n     }\n \n-    match canonicalize(os::self_exe_name()) {\n+    match canonicalize(env::current_exe().ok()) {\n         Some(mut p) => { p.pop(); p.pop(); p }\n         None => panic!(\"can't determine value for sysroot\")\n     }\n@@ -216,16 +219,16 @@ pub fn get_rust_path() -> Option<String> {\n /// $HOME/.rust\n /// DIR/.rust for any DIR that's the current working directory\n /// or an ancestor of it\n-pub fn rust_path() -> Vec<Path> {\n-    let mut env_rust_path: Vec<Path> = match get_rust_path() {\n+pub fn rust_path() -> Vec<PathBuf> {\n+    let mut env_rust_path: Vec<PathBuf> = match get_rust_path() {\n         Some(env_path) => {\n             let env_path_components =\n                 env_path.split(PATH_ENTRY_SEPARATOR);\n-            env_path_components.map(|s| Path::new(s)).collect()\n+            env_path_components.map(|s| PathBuf::new(s)).collect()\n         }\n         None => Vec::new()\n     };\n-    let mut cwd = os::getcwd().unwrap();\n+    let cwd = env::current_dir().unwrap();\n     // now add in default entries\n     let cwd_dot_rust = cwd.join(\".rust\");\n     if !env_rust_path.contains(&cwd_dot_rust) {\n@@ -234,17 +237,15 @@ pub fn rust_path() -> Vec<Path> {\n     if !env_rust_path.contains(&cwd) {\n         env_rust_path.push(cwd.clone());\n     }\n-    loop {\n-        if { let f = cwd.filename(); f.is_none() || f.unwrap() == b\"..\" } {\n-            break\n-        }\n-        cwd.set_filename(\".rust\");\n-        if !env_rust_path.contains(&cwd) && cwd.exists() {\n-            env_rust_path.push(cwd.clone());\n+    let mut cur = &*cwd;\n+    while let Some(parent) = cur.parent() {\n+        let candidate = parent.join(\".rust\");\n+        if !env_rust_path.contains(&candidate) && candidate.exists() {\n+            env_rust_path.push(candidate.clone());\n         }\n-        cwd.pop();\n+        cur = parent;\n     }\n-    if let Some(h) = os::homedir() {\n+    if let Some(h) = env::home_dir() {\n         let p = h.join(\".rust\");\n         if !env_rust_path.contains(&p) && p.exists() {\n             env_rust_path.push(p);\n@@ -267,7 +268,7 @@ fn find_libdir(sysroot: &Path) -> String {\n \n     match option_env!(\"CFG_LIBDIR_RELATIVE\") {\n         Some(libdir) if libdir != \"lib\" => return libdir.to_string(),\n-        _ => if sysroot.join(primary_libdir_name()).join(rustlibdir()).exists() {\n+        _ => if sysroot.join(&primary_libdir_name()).join(&rustlibdir()).exists() {\n             return primary_libdir_name();\n         } else {\n             return secondary_libdir_name();"}, {"sha": "d83470354acb90c24cf5d00fc78259a3bc5c9a1c", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -226,21 +226,22 @@ use metadata::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n use util::fs;\n+use util::common;\n use rustc_back::target::Target;\n \n-use std::ffi::CString;\n use std::cmp;\n use std::collections::HashMap;\n-use std::old_io::fs::PathExtensions;\n-use std::old_io;\n+use std::io::prelude::*;\n+use std::io;\n+use std::path::{Path, PathBuf};\n use std::ptr;\n use std::slice;\n use std::time::Duration;\n \n use flate;\n \n pub struct CrateMismatch {\n-    path: Path,\n+    path: PathBuf,\n     got: String,\n }\n \n@@ -262,8 +263,8 @@ pub struct Context<'a> {\n }\n \n pub struct Library {\n-    pub dylib: Option<(Path, PathKind)>,\n-    pub rlib: Option<(Path, PathKind)>,\n+    pub dylib: Option<(PathBuf, PathKind)>,\n+    pub rlib: Option<(PathBuf, PathKind)>,\n     pub metadata: MetadataBlob,\n }\n \n@@ -275,12 +276,12 @@ pub struct ArchiveMetadata {\n \n pub struct CratePaths {\n     pub ident: String,\n-    pub dylib: Option<Path>,\n-    pub rlib: Option<Path>\n+    pub dylib: Option<PathBuf>,\n+    pub rlib: Option<PathBuf>\n }\n \n impl CratePaths {\n-    fn paths(&self) -> Vec<Path> {\n+    fn paths(&self) -> Vec<PathBuf> {\n         match (&self.dylib, &self.rlib) {\n             (&None,    &None)              => vec!(),\n             (&Some(ref p), &None) |\n@@ -400,7 +401,7 @@ impl<'a> Context<'a> {\n         //\n         // The goal of this step is to look at as little metadata as possible.\n         self.filesearch.search(|path, kind| {\n-            let file = match path.filename_str() {\n+            let file = match path.file_name().and_then(|s| s.to_str()) {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n@@ -416,7 +417,7 @@ impl<'a> Context<'a> {\n                 if file.starts_with(&staticlib_prefix[..]) &&\n                    file.ends_with(\".a\") {\n                     staticlibs.push(CrateMismatch {\n-                        path: path.clone(),\n+                        path: path.to_path_buf(),\n                         got: \"static\".to_string()\n                     });\n                 }\n@@ -506,9 +507,9 @@ impl<'a> Context<'a> {\n     // read the metadata from it if `*slot` is `None`. If the metadata couldn't\n     // be read, it is assumed that the file isn't a valid rust library (no\n     // errors are emitted).\n-    fn extract_one(&mut self, m: HashMap<Path, PathKind>, flavor: &str,\n-                   slot: &mut Option<MetadataBlob>) -> Option<(Path, PathKind)> {\n-        let mut ret = None::<(Path, PathKind)>;\n+    fn extract_one(&mut self, m: HashMap<PathBuf, PathKind>, flavor: &str,\n+                   slot: &mut Option<MetadataBlob>) -> Option<(PathBuf, PathKind)> {\n+        let mut ret = None::<(PathBuf, PathKind)>;\n         let mut error = 0;\n \n         if slot.is_some() {\n@@ -587,7 +588,7 @@ impl<'a> Context<'a> {\n         if triple != self.triple {\n             info!(\"Rejecting via crate triple: expected {} got {}\", self.triple, triple);\n             self.rejected_via_triple.push(CrateMismatch {\n-                path: libpath.clone(),\n+                path: libpath.to_path_buf(),\n                 got: triple.to_string()\n             });\n             return false;\n@@ -599,7 +600,7 @@ impl<'a> Context<'a> {\n                 if *myhash != hash {\n                     info!(\"Rejecting via hash: expected {} got {}\", *myhash, hash);\n                     self.rejected_via_hash.push(CrateMismatch {\n-                        path: libpath.clone(),\n+                        path: libpath.to_path_buf(),\n                         got: myhash.as_str().to_string()\n                     });\n                     false\n@@ -627,13 +628,13 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashMap::new();\n         let mut dylibs = HashMap::new();\n         {\n-            let locs = locs.iter().map(|l| Path::new(&l[..])).filter(|loc| {\n+            let locs = locs.iter().map(|l| PathBuf::new(&l[..])).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n                                      self.crate_name, loc.display()));\n                     return false;\n                 }\n-                let file = match loc.filename_str() {\n+                let file = match loc.file_name().and_then(|s| s.to_str()) {\n                     Some(file) => file,\n                     None => {\n                         sess.err(&format!(\"extern location for {} is not a file: {}\",\n@@ -658,7 +659,7 @@ impl<'a> Context<'a> {\n             // Now that we have an iterator of good candidates, make sure\n             // there's at most one rlib and at most one dylib.\n             for loc in locs {\n-                if loc.filename_str().unwrap().ends_with(\".rlib\") {\n+                if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n                     rlibs.insert(fs::realpath(&loc).unwrap(),\n                                  PathKind::ExternFlag);\n                 } else {\n@@ -714,7 +715,7 @@ fn get_metadata_section(is_osx: bool, filename: &Path) -> Result<MetadataBlob, S\n     let dur = Duration::span(|| {\n         ret = Some(get_metadata_section_imp(is_osx, filename));\n     });\n-    info!(\"reading {} => {}ms\", filename.filename_display(),\n+    info!(\"reading {:?} => {}ms\", filename.file_name().unwrap(),\n           dur.num_milliseconds());\n     return ret.unwrap();;\n }\n@@ -723,7 +724,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n     if !filename.exists() {\n         return Err(format!(\"no such file: '{}'\", filename.display()));\n     }\n-    if filename.filename_str().unwrap().ends_with(\".rlib\") {\n+    if filename.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n         // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n         // internally to read the file. We also avoid even using a memcpy by\n         // just keeping the archive along while the metadata is in use.\n@@ -742,7 +743,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n         };\n     }\n     unsafe {\n-        let buf = CString::new(filename.as_vec()).unwrap();\n+        let buf = common::path2cstr(filename);\n         let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n         if mb as int == 0 {\n             return Err(format!(\"error reading library: '{}'\",\n@@ -811,7 +812,7 @@ pub fn read_meta_section_name(is_osx: bool) -> &'static str {\n \n // A diagnostic function for dumping crate metadata to an output stream\n pub fn list_file_metadata(is_osx: bool, path: &Path,\n-                          out: &mut old_io::Writer) -> old_io::IoResult<()> {\n+                          out: &mut io::Write) -> io::Result<()> {\n     match get_metadata_section(is_osx, path) {\n         Ok(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n         Err(msg) => {"}, {"sha": "a1ce8d18184e3e47af087755ad6192fff48bc8c9", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -19,7 +19,7 @@ pub use self::EntryOrExit::*;\n use middle::cfg;\n use middle::cfg::CFGIndex;\n use middle::ty;\n-use std::old_io;\n+use std::io;\n use std::usize;\n use std::iter::repeat;\n use syntax::ast;\n@@ -103,7 +103,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O> {\n     fn pre(&self,\n            ps: &mut pprust::State,\n-           node: pprust::AnnNode) -> old_io::IoResult<()> {\n+           node: pprust::AnnNode) -> io::Result<()> {\n         let id = match node {\n             pprust::NodeIdent(_) | pprust::NodeName(_) => 0,\n             pprust::NodeExpr(expr) => expr.id,\n@@ -485,13 +485,15 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n \n         debug!(\"Dataflow result for {}:\", self.analysis_name);\n         debug!(\"{}\", {\n-            self.pretty_print_to(box old_io::stderr(), blk).unwrap();\n+            let mut v = Vec::new();\n+            self.pretty_print_to(box &mut v, blk).unwrap();\n+            println!(\"{}\", String::from_utf8(v).unwrap());\n             \"\"\n         });\n     }\n \n-    fn pretty_print_to(&self, wr: Box<old_io::Writer+'static>,\n-                       blk: &ast::Block) -> old_io::IoResult<()> {\n+    fn pretty_print_to<'b>(&self, wr: Box<io::Write + 'b>,\n+                           blk: &ast::Block) -> io::Result<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self);\n         try!(ps.cbox(pprust::indent_unit));\n         try!(ps.ibox(0));"}, {"sha": "6211fde79198af387731e8c3840abedef50a42b3", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -28,8 +28,10 @@ use util::ppaux::Repr;\n \n use std::borrow::Cow;\n use std::collections::hash_map::Entry::Vacant;\n-use std::old_io::{self, File};\n use std::env;\n+use std::fs::File;\n+use std::io;\n+use std::io::prelude::*;\n use std::sync::atomic::{AtomicBool, Ordering, ATOMIC_BOOL_INIT};\n use syntax::ast;\n \n@@ -256,10 +258,11 @@ pub type ConstraintMap<'tcx> = FnvHashMap<Constraint, SubregionOrigin<'tcx>>;\n \n fn dump_region_constraints_to<'a, 'tcx:'a >(tcx: &'a ty::ctxt<'tcx>,\n                                             map: &ConstraintMap<'tcx>,\n-                                            path: &str) -> old_io::IoResult<()> {\n+                                            path: &str) -> io::Result<()> {\n     debug!(\"dump_region_constraints map (len: {}) path: {}\", map.len(), path);\n     let g = ConstraintGraph::new(tcx, format!(\"region_constraints\"), map);\n-    let mut f = File::create(&Path::new(path));\n     debug!(\"dump_region_constraints calling render\");\n-    dot::render(&g, &mut f)\n+    let mut v = Vec::new();\n+    dot::render(&g, &mut v).unwrap();\n+    File::create(path).and_then(|mut f| f.write_all(&v))\n }"}, {"sha": "8267b79ff9e7aee3432559ea0e18f621a5ecf317", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -14,10 +14,12 @@ use session::Session;\n use metadata::creader::CrateReader;\n use plugin::registry::Registry;\n \n-use std::mem;\n-use std::os;\n-use std::dynamic_lib::DynamicLibrary;\n use std::borrow::ToOwned;\n+use std::dynamic_lib::DynamicLibrary;\n+use std::env;\n+use std::mem;\n+use std::old_path;\n+use std::path::PathBuf;\n use syntax::ast;\n use syntax::codemap::{Span, COMMAND_LINE_SP};\n use syntax::ptr::P;\n@@ -100,10 +102,11 @@ impl<'a> PluginLoader<'a> {\n     // Dynamically link a registrar function into the compiler process.\n     fn dylink_registrar(&mut self,\n                         span: Span,\n-                        path: Path,\n+                        path: PathBuf,\n                         symbol: String) -> PluginRegistrarFun {\n         // Make sure the path contains a / or the linker will search for it.\n-        let path = os::getcwd().unwrap().join(&path);\n+        let path = env::current_dir().unwrap().join(&path);\n+        let path = old_path::Path::new(path.to_str().unwrap());\n \n         let lib = match DynamicLibrary::open(Some(&path)) {\n             Ok(lib) => lib,"}, {"sha": "a4355803f4a4e3bd79fd3f6223be46b1a8a0f664", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -38,6 +38,7 @@ use std::collections::HashMap;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::env;\n use std::fmt;\n+use std::path::PathBuf;\n \n use llvm;\n \n@@ -89,7 +90,7 @@ pub struct Options {\n     // this.\n     pub search_paths: SearchPaths,\n     pub libs: Vec<(String, cstore::NativeLibraryKind)>,\n-    pub maybe_sysroot: Option<Path>,\n+    pub maybe_sysroot: Option<PathBuf>,\n     pub target_triple: String,\n     // User-specified cfg meta items. The compiler itself will add additional\n     // items to the crate config, and during parsing the entire crate config\n@@ -103,7 +104,7 @@ pub struct Options {\n     pub no_analysis: bool,\n     pub debugging_opts: DebuggingOptions,\n     /// Whether to write dependency files. It's (enabled, optional filename).\n-    pub write_dependency_info: (bool, Option<Path>),\n+    pub write_dependency_info: (bool, Option<PathBuf>),\n     pub prints: Vec<PrintRequest>,\n     pub cg: CodegenOptions,\n     pub color: ColorConfig,\n@@ -142,39 +143,40 @@ pub enum PrintRequest {\n \n pub enum Input {\n     /// Load source from file\n-    File(Path),\n+    File(PathBuf),\n     /// The string is the source\n     Str(String)\n }\n \n impl Input {\n     pub fn filestem(&self) -> String {\n         match *self {\n-            Input::File(ref ifile) => ifile.filestem_str().unwrap().to_string(),\n+            Input::File(ref ifile) => ifile.file_stem().unwrap()\n+                                           .to_str().unwrap().to_string(),\n             Input::Str(_) => \"rust_out\".to_string(),\n         }\n     }\n }\n \n #[derive(Clone)]\n pub struct OutputFilenames {\n-    pub out_directory: Path,\n+    pub out_directory: PathBuf,\n     pub out_filestem: String,\n-    pub single_output_file: Option<Path>,\n+    pub single_output_file: Option<PathBuf>,\n     pub extra: String,\n }\n \n impl OutputFilenames {\n-    pub fn path(&self, flavor: OutputType) -> Path {\n+    pub fn path(&self, flavor: OutputType) -> PathBuf {\n         match self.single_output_file {\n             Some(ref path) => return path.clone(),\n             None => {}\n         }\n         self.temp_path(flavor)\n     }\n \n-    pub fn temp_path(&self, flavor: OutputType) -> Path {\n-        let base = self.out_directory.join(self.filestem());\n+    pub fn temp_path(&self, flavor: OutputType) -> PathBuf {\n+        let base = self.out_directory.join(&self.filestem());\n         match flavor {\n             OutputTypeBitcode => base.with_extension(\"bc\"),\n             OutputTypeAssembly => base.with_extension(\"s\"),\n@@ -185,8 +187,8 @@ impl OutputFilenames {\n         }\n     }\n \n-    pub fn with_extension(&self, extension: &str) -> Path {\n-        self.out_directory.join(self.filestem()).with_extension(extension)\n+    pub fn with_extension(&self, extension: &str) -> PathBuf {\n+        self.out_directory.join(&self.filestem()).with_extension(extension)\n     }\n \n     pub fn filestem(&self) -> String {\n@@ -897,7 +899,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let cg = build_codegen_options(matches);\n \n-    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| Path::new(m));\n+    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| PathBuf::new(&m));\n     let target = matches.opt_str(\"target\").unwrap_or(\n         host_triple().to_string());\n     let opt_level = {"}, {"sha": "a478cb79796aa7a015481e3c936926602a36fd03", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -26,8 +26,9 @@ use syntax::{ast, codemap};\n \n use rustc_back::target::Target;\n \n+use std::path::{Path, PathBuf};\n use std::cell::{Cell, RefCell};\n-use std::os;\n+use std::env;\n \n pub mod config;\n pub mod search_paths;\n@@ -44,11 +45,11 @@ pub struct Session {\n     pub entry_fn: RefCell<Option<(NodeId, codemap::Span)>>,\n     pub entry_type: Cell<Option<config::EntryFnType>>,\n     pub plugin_registrar_fn: Cell<Option<ast::NodeId>>,\n-    pub default_sysroot: Option<Path>,\n+    pub default_sysroot: Option<PathBuf>,\n     // The name of the root source file of the crate, in the local file system. The path is always\n     // expected to be absolute. `None` means that there is no source file.\n-    pub local_crate_source_file: Option<Path>,\n-    pub working_dir: Path,\n+    pub local_crate_source_file: Option<PathBuf>,\n+    pub working_dir: PathBuf,\n     pub lint_store: RefCell<lint::LintStore>,\n     pub lints: RefCell<NodeMap<Vec<(lint::LintId, codemap::Span, String)>>>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n@@ -310,7 +311,7 @@ fn split_msg_into_multilines(msg: &str) -> Option<String> {\n }\n \n pub fn build_session(sopts: config::Options,\n-                     local_crate_source_file: Option<Path>,\n+                     local_crate_source_file: Option<PathBuf>,\n                      registry: diagnostics::registry::Registry)\n                      -> Session {\n     // FIXME: This is not general enough to make the warning lint completely override\n@@ -333,7 +334,7 @@ pub fn build_session(sopts: config::Options,\n }\n \n pub fn build_session_(sopts: config::Options,\n-                      local_crate_source_file: Option<Path>,\n+                      local_crate_source_file: Option<PathBuf>,\n                       span_diagnostic: diagnostic::SpanHandler)\n                       -> Session {\n     let host = match Target::search(config::host_triple()) {\n@@ -355,7 +356,7 @@ pub fn build_session_(sopts: config::Options,\n         if path.is_absolute() {\n             path.clone()\n         } else {\n-            os::getcwd().unwrap().join(&path)\n+            env::current_dir().unwrap().join(&path)\n         }\n     );\n \n@@ -378,7 +379,7 @@ pub fn build_session_(sopts: config::Options,\n         plugin_registrar_fn: Cell::new(None),\n         default_sysroot: default_sysroot,\n         local_crate_source_file: local_crate_source_file,\n-        working_dir: os::getcwd().unwrap(),\n+        working_dir: env::current_dir().unwrap(),\n         lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(NodeMap()),\n         crate_types: RefCell::new(Vec::new()),"}, {"sha": "f85fb3039102e9eb300c9160352ab4c6ac7f24c7", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -9,15 +9,16 @@\n // except according to those terms.\n \n use std::slice;\n+use std::path::{Path, PathBuf};\n \n #[derive(Clone, Debug)]\n pub struct SearchPaths {\n-    paths: Vec<(PathKind, Path)>,\n+    paths: Vec<(PathKind, PathBuf)>,\n }\n \n pub struct Iter<'a> {\n     kind: PathKind,\n-    iter: slice::Iter<'a, (PathKind, Path)>,\n+    iter: slice::Iter<'a, (PathKind, PathBuf)>,\n }\n \n #[derive(Eq, PartialEq, Clone, Copy, Debug)]\n@@ -49,7 +50,7 @@ impl SearchPaths {\n         } else {\n             (PathKind::All, path)\n         };\n-        self.paths.push((kind, Path::new(path)));\n+        self.paths.push((kind, PathBuf::new(path)));\n     }\n \n     pub fn iter(&self, kind: PathKind) -> Iter {"}, {"sha": "0b32f7f69eb448234f93f89756c22a8bf13389da", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -12,11 +12,13 @@\n \n use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n+use std::collections::hash_state::HashState;\n+use std::ffi::CString;\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::iter::repeat;\n+use std::path::Path;\n use std::time::Duration;\n-use std::collections::hash_state::HashState;\n \n use syntax::ast;\n use syntax::visit;\n@@ -222,3 +224,14 @@ pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) ->\n         }\n     }\n }\n+\n+#[cfg(unix)]\n+pub fn path2cstr(p: &Path) -> CString {\n+    use std::os::unix::prelude::*;\n+    use std::ffi::AsOsStr;\n+    CString::new(p.as_os_str().as_bytes()).unwrap()\n+}\n+#[cfg(windows)]\n+pub fn path2cstr(p: &Path) -> CString {\n+    CString::new(p.to_str().unwrap()).unwrap()\n+}"}, {"sha": "a6994387f8d6a27234eae257afe7106f182b0a00", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -10,29 +10,30 @@\n \n //! A helper class for dealing with static archives\n \n-use std::old_io::fs::PathExtensions;\n-use std::old_io::process::{Command, ProcessOutput};\n-use std::old_io::{fs, TempDir};\n-use std::old_io;\n-use std::os;\n+use std::env;\n+use std::fs::{self, TempDir};\n+use std::io::prelude::*;\n+use std::io;\n+use std::path::{Path, PathBuf};\n+use std::process::{Command, Output, Stdio};\n use std::str;\n use syntax::diagnostic::Handler as ErrorHandler;\n \n pub const METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n \n pub struct ArchiveConfig<'a> {\n     pub handler: &'a ErrorHandler,\n-    pub dst: Path,\n-    pub lib_search_paths: Vec<Path>,\n+    pub dst: PathBuf,\n+    pub lib_search_paths: Vec<PathBuf>,\n     pub slib_prefix: String,\n     pub slib_suffix: String,\n     pub maybe_ar_prog: Option<String>\n }\n \n pub struct Archive<'a> {\n     handler: &'a ErrorHandler,\n-    dst: Path,\n-    lib_search_paths: Vec<Path>,\n+    dst: PathBuf,\n+    lib_search_paths: Vec<PathBuf>,\n     slib_prefix: String,\n     slib_suffix: String,\n     maybe_ar_prog: Option<String>\n@@ -45,25 +46,25 @@ pub struct ArchiveBuilder<'a> {\n     archive: Archive<'a>,\n     work_dir: TempDir,\n     /// Filename of each member that should be added to the archive.\n-    members: Vec<Path>,\n+    members: Vec<PathBuf>,\n     should_update_symbols: bool,\n }\n \n fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n           args: &str, cwd: Option<&Path>,\n-          paths: &[&Path]) -> ProcessOutput {\n+          paths: &[&Path]) -> Output {\n     let ar = match *maybe_ar_prog {\n         Some(ref ar) => &ar[..],\n         None => \"ar\"\n     };\n     let mut cmd = Command::new(ar);\n \n-    cmd.arg(args).args(paths);\n+    cmd.arg(args).args(paths).stdout(Stdio::piped()).stderr(Stdio::piped());\n     debug!(\"{:?}\", cmd);\n \n     match cwd {\n         Some(p) => {\n-            cmd.cwd(p);\n+            cmd.current_dir(p);\n             debug!(\"inside {:?}\", p.display());\n         }\n         None => {}\n@@ -75,9 +76,9 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n             if !o.status.success() {\n                 handler.err(&format!(\"{:?} failed with: {}\", cmd, o.status));\n                 handler.note(&format!(\"stdout ---\\n{}\",\n-                                  str::from_utf8(&o.output).unwrap()));\n+                                  str::from_utf8(&o.stdout).unwrap()));\n                 handler.note(&format!(\"stderr ---\\n{}\",\n-                                  str::from_utf8(&o.error).unwrap())\n+                                  str::from_utf8(&o.stderr).unwrap())\n                              );\n                 handler.abort_if_errors();\n             }\n@@ -93,14 +94,15 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n }\n \n pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n-                    search_paths: &[Path], handler: &ErrorHandler) -> Path {\n+                    search_paths: &[PathBuf],\n+                    handler: &ErrorHandler) -> PathBuf {\n     // On Windows, static libraries sometimes show up as libfoo.a and other\n     // times show up as foo.lib\n     let oslibname = format!(\"{}{}{}\", osprefix, name, ossuffix);\n     let unixlibname = format!(\"lib{}.a\", name);\n \n     for path in search_paths {\n-        debug!(\"looking for {} inside {:?}\", name, path.display());\n+        debug!(\"looking for {} inside {:?}\", name, path);\n         let test = path.join(&oslibname[..]);\n         if test.exists() { return test }\n         if oslibname != unixlibname {\n@@ -142,7 +144,7 @@ impl<'a> Archive<'a> {\n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<String> {\n         let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, &[&self.dst]);\n-        let output = str::from_utf8(&output.output).unwrap();\n+        let output = str::from_utf8(&output.stdout).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n         output.lines_any().map(|s| s.to_string()).collect()\n@@ -172,7 +174,7 @@ impl<'a> ArchiveBuilder<'a> {\n \n     /// Adds all of the contents of a native library to this archive. This will\n     /// search in the relevant locations for a library named `name`.\n-    pub fn add_native_library(&mut self, name: &str) -> old_io::IoResult<()> {\n+    pub fn add_native_library(&mut self, name: &str) -> io::Result<()> {\n         let location = find_library(name,\n                                     &self.archive.slib_prefix,\n                                     &self.archive.slib_suffix,\n@@ -187,7 +189,7 @@ impl<'a> ArchiveBuilder<'a> {\n     /// This ignores adding the bytecode from the rlib, and if LTO is enabled\n     /// then the object file also isn't added.\n     pub fn add_rlib(&mut self, rlib: &Path, name: &str,\n-                    lto: bool) -> old_io::IoResult<()> {\n+                    lto: bool) -> io::Result<()> {\n         // Ignoring obj file starting with the crate name\n         // as simple comparison is not enough - there\n         // might be also an extra name suffix\n@@ -205,11 +207,11 @@ impl<'a> ArchiveBuilder<'a> {\n     }\n \n     /// Adds an arbitrary file to this archive\n-    pub fn add_file(&mut self, file: &Path) -> old_io::IoResult<()> {\n-        let filename = Path::new(file.filename().unwrap());\n+    pub fn add_file(&mut self, file: &Path) -> io::Result<()> {\n+        let filename = Path::new(file.file_name().unwrap());\n         let new_file = self.work_dir.path().join(&filename);\n         try!(fs::copy(file, &new_file));\n-        self.members.push(filename);\n+        self.members.push(filename.to_path_buf());\n         Ok(())\n     }\n \n@@ -224,10 +226,10 @@ impl<'a> ArchiveBuilder<'a> {\n     pub fn build(self) -> Archive<'a> {\n         // Get an absolute path to the destination, so `ar` will work even\n         // though we run it from `self.work_dir`.\n-        let abs_dst = os::getcwd().unwrap().join(&self.archive.dst);\n+        let abs_dst = env::current_dir().unwrap().join(&self.archive.dst);\n         assert!(!abs_dst.is_relative());\n-        let mut args = vec![&abs_dst];\n-        let mut total_len = abs_dst.as_vec().len();\n+        let mut args = vec![&*abs_dst];\n+        let mut total_len = abs_dst.to_string_lossy().len();\n \n         if self.members.is_empty() {\n             // OSX `ar` does not allow using `r` with no members, but it does\n@@ -245,7 +247,7 @@ impl<'a> ArchiveBuilder<'a> {\n         const ARG_LENGTH_LIMIT: uint = 32_000;\n \n         for member_name in &self.members {\n-            let len = member_name.as_vec().len();\n+            let len = member_name.to_string_lossy().len();\n \n             // `len + 1` to account for the space that's inserted before each\n             // argument.  (Windows passes command-line arguments as a single\n@@ -258,7 +260,7 @@ impl<'a> ArchiveBuilder<'a> {\n \n                 args.clear();\n                 args.push(&abs_dst);\n-                total_len = abs_dst.as_vec().len();\n+                total_len = abs_dst.to_string_lossy().len();\n             }\n \n             args.push(member_name);\n@@ -275,15 +277,15 @@ impl<'a> ArchiveBuilder<'a> {\n     }\n \n     fn add_archive<F>(&mut self, archive: &Path, name: &str,\n-                      mut skip: F) -> old_io::IoResult<()>\n+                      mut skip: F) -> io::Result<()>\n         where F: FnMut(&str) -> bool,\n     {\n         let loc = TempDir::new(\"rsar\").unwrap();\n \n         // First, extract the contents of the archive to a temporary directory.\n         // We don't unpack directly into `self.work_dir` due to the possibility\n         // of filename collisions.\n-        let archive = os::getcwd().unwrap().join(archive);\n+        let archive = env::current_dir().unwrap().join(archive);\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n                \"x\", Some(loc.path()), &[&archive]);\n \n@@ -296,9 +298,10 @@ impl<'a> ArchiveBuilder<'a> {\n         // We skip any files explicitly desired for skipping, and we also skip\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n-        let files = try!(fs::readdir(loc.path()));\n-        for file in &files {\n-            let filename = file.filename_str().unwrap();\n+        let files = try!(fs::read_dir(loc.path()));\n+        for file in files {\n+            let file = try!(file).path();\n+            let filename = file.file_name().unwrap().to_str().unwrap();\n             if skip(filename) { continue }\n             if filename.contains(\".SYMDEF\") { continue }\n \n@@ -313,8 +316,8 @@ impl<'a> ArchiveBuilder<'a> {\n                 filename\n             };\n             let new_filename = self.work_dir.path().join(&filename[..]);\n-            try!(fs::rename(file, &new_filename));\n-            self.members.push(Path::new(filename));\n+            try!(fs::rename(&file, &new_filename));\n+            self.members.push(PathBuf::new(&filename));\n         }\n         Ok(())\n     }"}, {"sha": "c00c33d4c2fed505ce680d72c1321777498a1141", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -8,14 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::old_io;\n+use std::io;\n use std::old_io::fs;\n+use std::old_io;\n+use std::old_path;\n use std::os;\n+use std::path::{Path, PathBuf};\n \n /// Returns an absolute path in the filesystem that `path` points to. The\n /// returned path does not contain any symlinks in its hierarchy.\n-pub fn realpath(original: &Path) -> old_io::IoResult<Path> {\n-    const MAX_LINKS_FOLLOWED: uint = 256;\n+#[allow(deprecated)] // readlink is deprecated\n+pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n+    let old = old_path::Path::new(original.to_str().unwrap());\n+    match old_realpath(&old) {\n+        Ok(p) => Ok(PathBuf::new(p.as_str().unwrap())),\n+        Err(e) => Err(io::Error::new(io::ErrorKind::Other,\n+                                     \"realpath error\",\n+                                     Some(e.to_string())))\n+    }\n+}\n+\n+#[allow(deprecated)]\n+fn old_realpath(original: &old_path::Path) -> old_io::IoResult<old_path::Path> {\n+    const MAX_LINKS_FOLLOWED: usize = 256;\n     let original = try!(os::getcwd()).join(original);\n \n     // Right now lstat on windows doesn't work quite well\n@@ -55,7 +70,7 @@ pub fn realpath(original: &Path) -> old_io::IoResult<Path> {\n mod test {\n     use std::old_io;\n     use std::old_io::fs::{File, symlink, mkdir, mkdir_recursive};\n-    use super::realpath;\n+    use super::old_realpath as realpath;\n     use std::old_io::TempDir;\n \n     #[test]"}, {"sha": "2b028a5c626234f63381d38f1672f01c14a9a72f", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -33,14 +33,18 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(old_fs)]\n+#![feature(fs)]\n #![feature(hash)]\n #![feature(int_uint)]\n+#![feature(io)]\n #![feature(old_io)]\n-#![feature(os)]\n #![feature(old_path)]\n+#![feature(os)]\n+#![feature(path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(path)]\n+#![feature(tempdir)]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "4f9f1447d8a731b918f765666306916435348de4", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 62, "deletions": 82, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -10,26 +10,20 @@\n \n use std::collections::HashSet;\n use std::env;\n-use std::old_io::IoError;\n-use std::os;\n+use std::io;\n+use std::path::{Path, PathBuf};\n use syntax::ast;\n \n-pub struct RPathConfig<F, G> where\n-    F: FnOnce() -> Path,\n-    G: FnMut(&Path) -> Result<Path, IoError>,\n-{\n-    pub used_crates: Vec<(ast::CrateNum, Option<Path>)>,\n-    pub out_filename: Path,\n+pub struct RPathConfig<'a> {\n+    pub used_crates: Vec<(ast::CrateNum, Option<PathBuf>)>,\n+    pub out_filename: PathBuf,\n     pub is_like_osx: bool,\n     pub has_rpath: bool,\n-    pub get_install_prefix_lib_path: F,\n-    pub realpath: G,\n+    pub get_install_prefix_lib_path: &'a mut FnMut() -> PathBuf,\n+    pub realpath: &'a mut FnMut(&Path) -> io::Result<PathBuf>,\n }\n \n-pub fn get_rpath_flags<F, G>(config: RPathConfig<F, G>) -> Vec<String> where\n-    F: FnOnce() -> Path,\n-    G: FnMut(&Path) -> Result<Path, IoError>,\n-{\n+pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n     // No rpath on windows\n     if !config.has_rpath {\n         return Vec::new();\n@@ -54,10 +48,7 @@ fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     return ret;\n }\n \n-fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String> where\n-    F: FnOnce() -> Path,\n-    G: FnMut(&Path) -> Result<Path, IoError>,\n-{\n+fn get_rpaths(config: &mut RPathConfig, libs: &[PathBuf]) -> Vec<String> {\n     debug!(\"output: {:?}\", config.out_filename.display());\n     debug!(\"libs:\");\n     for libpath in libs {\n@@ -67,7 +58,7 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n     // Use relative paths to the libraries. Binaries can be moved\n     // as long as they maintain the relative relationship to the\n     // crates they depend on.\n-    let rel_rpaths = get_rpaths_relative_to_output(&mut config, libs);\n+    let rel_rpaths = get_rpaths_relative_to_output(config, libs);\n \n     // And a final backup rpath to the global library location.\n     let fallback_rpaths = vec!(get_install_prefix_rpath(config));\n@@ -90,42 +81,49 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n     return rpaths;\n }\n \n-fn get_rpaths_relative_to_output<F, G>(config: &mut RPathConfig<F, G>,\n-                                       libs: &[Path]) -> Vec<String> where\n-    F: FnOnce() -> Path,\n-    G: FnMut(&Path) -> Result<Path, IoError>,\n-{\n+fn get_rpaths_relative_to_output(config: &mut RPathConfig,\n+                                 libs: &[PathBuf]) -> Vec<String> {\n     libs.iter().map(|a| get_rpath_relative_to_output(config, a)).collect()\n }\n \n-fn get_rpath_relative_to_output<F, G>(config: &mut RPathConfig<F, G>, lib: &Path) -> String where\n-    F: FnOnce() -> Path,\n-    G: FnMut(&Path) -> Result<Path, IoError>,\n-{\n+fn get_rpath_relative_to_output(config: &mut RPathConfig, lib: &Path) -> String {\n     // Mac doesn't appear to support $ORIGIN\n     let prefix = if config.is_like_osx {\n         \"@loader_path\"\n     } else {\n         \"$ORIGIN\"\n     };\n \n-    let cwd = os::getcwd().unwrap();\n+    let cwd = env::current_dir().unwrap();\n     let mut lib = (config.realpath)(&cwd.join(lib)).unwrap();\n     lib.pop();\n     let mut output = (config.realpath)(&cwd.join(&config.out_filename)).unwrap();\n     output.pop();\n-    let relative = lib.path_relative_from(&output);\n-    let relative = relative.expect(\"could not create rpath relative to output\");\n+    let relative = relativize(&lib, &output);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    format!(\"{}/{}\",\n-            prefix,\n-            relative.as_str().expect(\"non-utf8 component in path\"))\n+    format!(\"{}/{}\", prefix,\n+            relative.to_str().expect(\"non-utf8 component in path\"))\n }\n \n-fn get_install_prefix_rpath<F, G>(config: RPathConfig<F, G>) -> String where\n-    F: FnOnce() -> Path,\n-    G: FnMut(&Path) -> Result<Path, IoError>,\n-{\n+fn relativize(path: &Path, rel: &Path) -> PathBuf {\n+    let mut res = PathBuf::new(\"\");\n+    let mut cur = rel;\n+    while !path.starts_with(cur) {\n+        res.push(\"..\");\n+        match cur.parent() {\n+            Some(p) => cur = p,\n+            None => panic!(\"can't create relative paths across filesystems\"),\n+        }\n+    }\n+    match path.relative_from(cur) {\n+        Some(s) => { res.push(s); res }\n+        None => panic!(\"couldn't create relative path from {:?} to {:?}\",\n+                       rel, path),\n+    }\n+\n+}\n+\n+fn get_install_prefix_rpath(config: &mut RPathConfig) -> String {\n     let path = (config.get_install_prefix_lib_path)();\n     let path = env::current_dir().unwrap().join(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -147,6 +145,7 @@ fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n mod test {\n     use super::{RPathConfig};\n     use super::{minimize_rpaths, rpaths_to_flags, get_rpath_relative_to_output};\n+    use std::path::{Path, PathBuf};\n \n     #[test]\n     fn test_rpaths_to_flags() {\n@@ -195,50 +194,31 @@ mod test {\n     }\n \n     #[test]\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     fn test_rpath_relative() {\n-        let config = &mut RPathConfig {\n-            used_crates: Vec::new(),\n-            out_filename: Path::new(\"bin/rustc\"),\n-            get_install_prefix_lib_path: || panic!(),\n-            has_rpath: true,\n-            is_like_osx: false,\n-            realpath: |p| Ok(p.clone())\n-        };\n-        let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n-        assert_eq!(res, \"$ORIGIN/../lib\");\n-    }\n-\n-    #[test]\n-    #[cfg(any(target_os = \"freebsd\",\n-              target_os = \"dragonfly\",\n-              target_os = \"bitrig\",\n-              target_os = \"openbsd\"))]\n-    fn test_rpath_relative() {\n-        let config = &mut RPathConfig {\n-            used_crates: Vec::new(),\n-            has_rpath: true,\n-            is_like_osx: false,\n-            out_filename: Path::new(\"bin/rustc\"),\n-            get_install_prefix_lib_path: || panic!(),\n-            realpath: |p| Ok(p.clone())\n-        };\n-        let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n-        assert_eq!(res, \"$ORIGIN/../lib\");\n-    }\n-\n-    #[test]\n-    #[cfg(target_os = \"macos\")]\n-    fn test_rpath_relative() {\n-        let config = &mut RPathConfig {\n-            used_crates: Vec::new(),\n-            has_rpath: true,\n-            is_like_osx: true,\n-            out_filename: Path::new(\"bin/rustc\"),\n-            get_install_prefix_lib_path: || panic!(),\n-            realpath: |p| Ok(p.clone())\n-        };\n-        let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n-        assert_eq!(res, \"@loader_path/../lib\");\n+        if cfg!(target_os = \"macos\") {\n+            let config = &mut RPathConfig {\n+                used_crates: Vec::new(),\n+                has_rpath: true,\n+                is_like_osx: true,\n+                out_filename: PathBuf::new(\"bin/rustc\"),\n+                get_install_prefix_lib_path: &mut || panic!(),\n+                realpath: &mut |p| Ok(p.to_path_buf()),\n+            };\n+            let res = get_rpath_relative_to_output(config,\n+                                                   Path::new(\"lib/libstd.so\"));\n+            assert_eq!(res, \"@loader_path/../lib\");\n+        } else {\n+            let config = &mut RPathConfig {\n+                used_crates: Vec::new(),\n+                out_filename: PathBuf::new(\"bin/rustc\"),\n+                get_install_prefix_lib_path: &mut || panic!(),\n+                has_rpath: true,\n+                is_like_osx: false,\n+                realpath: &mut |p| Ok(p.to_path_buf()),\n+            };\n+            let res = get_rpath_relative_to_output(config,\n+                                                   Path::new(\"lib/libstd.so\"));\n+            assert_eq!(res, \"$ORIGIN/../lib\");\n+        }\n     }\n }"}, {"sha": "4663901a7b4c1f84114586dc066bf05feecf5aac", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -48,7 +48,7 @@\n use serialize::json::Json;\n use syntax::{diagnostic, abi};\n use std::default::Default;\n-use std::old_io::fs::PathExtensions;\n+use std::io::prelude::*;\n \n mod windows_base;\n mod linux_base;\n@@ -302,23 +302,26 @@ impl Target {\n         base\n     }\n \n-    /// Search RUST_TARGET_PATH for a JSON file specifying the given target triple. Note that it\n-    /// could also just be a bare filename already, so also check for that. If one of the hardcoded\n-    /// targets we know about, just return it directly.\n+    /// Search RUST_TARGET_PATH for a JSON file specifying the given target\n+    /// triple. Note that it could also just be a bare filename already, so also\n+    /// check for that. If one of the hardcoded targets we know about, just\n+    /// return it directly.\n     ///\n-    /// The error string could come from any of the APIs called, including filesystem access and\n-    /// JSON decoding.\n+    /// The error string could come from any of the APIs called, including\n+    /// filesystem access and JSON decoding.\n     pub fn search(target: &str) -> Result<Target, String> {\n         use std::env;\n-        use std::os;\n         use std::ffi::OsString;\n-        use std::old_io::File;\n-        use std::old_path::Path;\n+        use std::fs::File;\n+        use std::path::{Path, PathBuf};\n         use serialize::json;\n \n         fn load_file(path: &Path) -> Result<Target, String> {\n-            let mut f = try!(File::open(path).map_err(|e| format!(\"{:?}\", e)));\n-            let obj = try!(json::from_reader(&mut f).map_err(|e| format!(\"{:?}\", e)));\n+            let mut f = try!(File::open(path).map_err(|e| e.to_string()));\n+            let mut contents = Vec::new();\n+            try!(f.read_to_end(&mut contents).map_err(|e| e.to_string()));\n+            let obj = try!(json::from_reader(&mut &contents[..])\n+                                .map_err(|e| e.to_string()));\n             Ok(Target::from_json(obj))\n         }\n \n@@ -390,15 +393,16 @@ impl Target {\n         let path = {\n             let mut target = target.to_string();\n             target.push_str(\".json\");\n-            Path::new(target)\n+            PathBuf::new(&target)\n         };\n \n-        let target_path = env::var_os(\"RUST_TARGET_PATH\").unwrap_or(OsString::from_str(\"\"));\n+        let target_path = env::var_os(\"RUST_TARGET_PATH\")\n+                              .unwrap_or(OsString::from_str(\"\"));\n \n         // FIXME 16351: add a sane default search path?\n \n-        for dir in os::split_paths(target_path.to_str().unwrap()).iter() {\n-            let p =  dir.join(path.clone());\n+        for dir in env::split_paths(&target_path) {\n+            let p =  dir.join(&path);\n             if p.is_file() {\n                 return load_file(&p);\n             }"}, {"sha": "73682faf1a77b3ffccac90846ca5da07e52cea20", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -32,10 +32,10 @@ use super::Compilation;\n use serialize::json;\n \n use std::env;\n-use std::os;\n use std::ffi::OsString;\n-use std::old_io::fs;\n-use std::old_io;\n+use std::fs;\n+use std::io::{self, Write};\n+use std::path::{Path, PathBuf};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::attr;\n@@ -48,8 +48,8 @@ use syntax;\n pub fn compile_input(sess: Session,\n                      cfg: ast::CrateConfig,\n                      input: &Input,\n-                     outdir: &Option<Path>,\n-                     output: &Option<Path>,\n+                     outdir: &Option<PathBuf>,\n+                     output: &Option<PathBuf>,\n                      addl_plugins: Option<Vec<String>>,\n                      control: CompileController) {\n     macro_rules! controller_entry_point{($point: ident, $make_state: expr) => ({\n@@ -166,7 +166,7 @@ pub fn anon_src() -> String {\n pub fn source_name(input: &Input) -> String {\n     match *input {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        Input::File(ref ifile) => ifile.as_str().unwrap().to_string(),\n+        Input::File(ref ifile) => ifile.to_str().unwrap().to_string(),\n         Input::Str(_) => anon_src()\n     }\n }\n@@ -243,12 +243,12 @@ pub struct CompileState<'a, 'ast: 'a, 'tcx: 'a> {\n impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n     fn empty(input: &'a Input,\n              session: &'a Session,\n-             out_dir: &'a Option<Path>)\n+             out_dir: &'a Option<PathBuf>)\n              -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n             input: input,\n             session: session,\n-            out_dir: out_dir.as_ref(),\n+            out_dir: out_dir.as_ref().map(|s| &**s),\n             cfg: None,\n             krate: None,\n             crate_name: None,\n@@ -263,7 +263,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n \n     fn state_after_parse(input: &'a Input,\n                          session: &'a Session,\n-                         out_dir: &'a Option<Path>,\n+                         out_dir: &'a Option<PathBuf>,\n                          krate: &'a ast::Crate)\n                          -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n@@ -274,7 +274,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n \n     fn state_after_expand(input: &'a Input,\n                           session: &'a Session,\n-                          out_dir: &'a Option<Path>,\n+                          out_dir: &'a Option<PathBuf>,\n                           expanded_crate: &'a ast::Crate,\n                           crate_name: &'a str)\n                           -> CompileState<'a, 'ast, 'tcx> {\n@@ -287,7 +287,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n \n     fn state_after_write_deps(input: &'a Input,\n                               session: &'a Session,\n-                              out_dir: &'a Option<Path>,\n+                              out_dir: &'a Option<PathBuf>,\n                               ast_map: &'a ast_map::Map<'ast>,\n                               expanded_crate: &'a ast::Crate,\n                               crate_name: &'a str)\n@@ -302,7 +302,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n \n     fn state_after_analysis(input: &'a Input,\n                             session: &'a Session,\n-                            out_dir: &'a Option<Path>,\n+                            out_dir: &'a Option<PathBuf>,\n                             expanded_crate: &'a ast::Crate,\n                             analysis: &'a ty::CrateAnalysis<'tcx>,\n                             tcx: &'a ty::ctxt<'tcx>)\n@@ -318,7 +318,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n \n     fn state_after_llvm(input: &'a Input,\n                         session: &'a Session,\n-                        out_dir: &'a Option<Path>,\n+                        out_dir: &'a Option<PathBuf>,\n                         trans: &'a trans::CrateTranslation)\n                         -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n@@ -472,7 +472,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             if cfg!(windows) {\n                 _old_path = env::var_os(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch(PathKind::All).get_dylib_search_paths();\n-                new_path.extend(os::split_paths(_old_path.to_str().unwrap()).into_iter());\n+                new_path.extend(env::split_paths(&_old_path));\n                 env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n             }\n             let features = sess.features.borrow();\n@@ -717,7 +717,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n \n         // Remove assembly source, unless --save-temps was specified\n         if !sess.opts.cg.save_temps {\n-            fs::unlink(&outputs.temp_path(config::OutputTypeAssembly)).unwrap();\n+            fs::remove_file(&outputs.temp_path(config::OutputTypeAssembly)).unwrap();\n         }\n     } else {\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n@@ -737,7 +737,7 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     let old_path = env::var_os(\"PATH\").unwrap_or(OsString::from_str(\"\"));\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths();\n-    new_path.extend(os::split_paths(old_path.to_str().unwrap()).into_iter());\n+    new_path.extend(env::split_paths(&old_path));\n     env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n \n     time(sess.time_passes(), \"linking\", (), |_|\n@@ -793,17 +793,17 @@ fn write_out_deps(sess: &Session,\n         _ => return,\n     };\n \n-    let result = (|| -> old_io::IoResult<()> {\n+    let result = (|| -> io::Result<()> {\n         // Build a list of files used to compile the output and\n         // write Makefile-compatible dependency rules\n         let files: Vec<String> = sess.codemap().files.borrow()\n                                    .iter().filter(|fmap| fmap.is_real_file())\n                                    .map(|fmap| escape_dep_filename(&fmap.name))\n                                    .collect();\n-        let mut file = try!(old_io::File::create(&deps_filename));\n+        let mut file = try!(fs::File::create(&deps_filename));\n         for path in &out_filenames {\n-            try!(write!(&mut file as &mut Writer,\n-                          \"{}: {}\\n\\n\", path.display(), files.connect(\" \")));\n+            try!(write!(&mut file,\n+                        \"{}: {}\\n\\n\", path.display(), files.connect(\" \")));\n         }\n         Ok(())\n     })();\n@@ -896,8 +896,8 @@ pub fn collect_crate_metadata(session: &Session,\n }\n \n pub fn build_output_filenames(input: &Input,\n-                              odir: &Option<Path>,\n-                              ofile: &Option<Path>,\n+                              odir: &Option<PathBuf>,\n+                              ofile: &Option<PathBuf>,\n                               attrs: &[ast::Attribute],\n                               sess: &Session)\n                            -> OutputFilenames {\n@@ -908,7 +908,7 @@ pub fn build_output_filenames(input: &Input,\n             // We want to toss everything after the final '.'\n             let dirpath = match *odir {\n                 Some(ref d) => d.clone(),\n-                None => Path::new(\".\")\n+                None => PathBuf::new(\".\")\n             };\n \n             // If a crate name is present, we use it as the link name\n@@ -936,8 +936,9 @@ pub fn build_output_filenames(input: &Input,\n                 sess.warn(\"ignoring --out-dir flag due to -o flag.\");\n             }\n             OutputFilenames {\n-                out_directory: out_file.dir_path(),\n-                out_filestem: out_file.filestem_str().unwrap().to_string(),\n+                out_directory: out_file.parent().unwrap().to_path_buf(),\n+                out_filestem: out_file.file_stem().unwrap()\n+                                      .to_str().unwrap().to_string(),\n                 single_output_file: ofile,\n                 extra: sess.opts.cg.extra_filename.clone(),\n             }"}, {"sha": "aa8b7c7785d204b6c61b64a3d22b4396d885229c", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -30,14 +30,16 @@\n #![feature(old_io)]\n #![feature(libc)]\n #![feature(os)]\n-#![feature(old_path)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(unicode)]\n #![feature(exit_status)]\n+#![feature(path)]\n+#![feature(io)]\n+#![feature(fs)]\n \n extern crate arena;\n extern crate flate;\n@@ -73,9 +75,10 @@ use rustc::metadata;\n use rustc::util::common::time;\n \n use std::cmp::Ordering::Equal;\n-use std::old_io::{self, stdio};\n-use std::iter::repeat;\n use std::env;\n+use std::iter::repeat;\n+use std::old_io::{self, stdio};\n+use std::path::PathBuf;\n use std::sync::mpsc::channel;\n use std::thread;\n \n@@ -159,22 +162,22 @@ pub fn run_compiler<'a>(args: &[String],\n }\n \n // Extract output directory and file from matches.\n-fn make_output(matches: &getopts::Matches) -> (Option<Path>, Option<Path>) {\n-    let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n-    let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n+fn make_output(matches: &getopts::Matches) -> (Option<PathBuf>, Option<PathBuf>) {\n+    let odir = matches.opt_str(\"out-dir\").map(|o| PathBuf::new(&o));\n+    let ofile = matches.opt_str(\"o\").map(|o| PathBuf::new(&o));\n     (odir, ofile)\n }\n \n // Extract input (string or file and optional path) from matches.\n-fn make_input(free_matches: &[String]) -> Option<(Input, Option<Path>)> {\n+fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>)> {\n     if free_matches.len() == 1 {\n         let ifile = &free_matches[0][..];\n         if ifile == \"-\" {\n             let contents = old_io::stdin().read_to_end().unwrap();\n             let src = String::from_utf8(contents).unwrap();\n             Some((Input::Str(src), None))\n         } else {\n-            Some((Input::File(Path::new(ifile)), Some(Path::new(ifile))))\n+            Some((Input::File(PathBuf::new(ifile)), Some(PathBuf::new(ifile))))\n         }\n     } else {\n         None\n@@ -215,14 +218,15 @@ pub trait CompilerCalls<'a> {\n                      &getopts::Matches,\n                      &Session,\n                      &Input,\n-                     &Option<Path>,\n-                     &Option<Path>)\n+                     &Option<PathBuf>,\n+                     &Option<PathBuf>)\n                      -> Compilation;\n \n     // Called after we extract the input from the arguments. Gives the implementer\n     // an opportunity to change the inputs or to add some custom input handling.\n     // The default behaviour is to simply pass through the inputs.\n-    fn some_input(&mut self, input: Input, input_path: Option<Path>) -> (Input, Option<Path>) {\n+    fn some_input(&mut self, input: Input, input_path: Option<PathBuf>)\n+                  -> (Input, Option<PathBuf>) {\n         (input, input_path)\n     }\n \n@@ -234,10 +238,10 @@ pub trait CompilerCalls<'a> {\n     fn no_input(&mut self,\n                 &getopts::Matches,\n                 &config::Options,\n-                &Option<Path>,\n-                &Option<Path>,\n+                &Option<PathBuf>,\n+                &Option<PathBuf>,\n                 &diagnostics::registry::Registry)\n-                -> Option<(Input, Option<Path>)>;\n+                -> Option<(Input, Option<PathBuf>)>;\n \n     // Parse pretty printing information from the arguments. The implementer can\n     // choose to ignore this (the default will return None) which will skip pretty\n@@ -293,10 +297,10 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn no_input(&mut self,\n                 matches: &getopts::Matches,\n                 sopts: &config::Options,\n-                odir: &Option<Path>,\n-                ofile: &Option<Path>,\n+                odir: &Option<PathBuf>,\n+                ofile: &Option<PathBuf>,\n                 descriptions: &diagnostics::registry::Registry)\n-                -> Option<(Input, Option<Path>)> {\n+                -> Option<(Input, Option<PathBuf>)> {\n         match matches.free.len() {\n             0 => {\n                 if sopts.describe_lints {\n@@ -346,8 +350,8 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                      matches: &getopts::Matches,\n                      sess: &Session,\n                      input: &Input,\n-                     odir: &Option<Path>,\n-                     ofile: &Option<Path>)\n+                     odir: &Option<PathBuf>,\n+                     ofile: &Option<PathBuf>)\n                      -> Compilation {\n         RustcDefaultCalls::print_crate_info(sess, Some(input), odir, ofile).and_then(\n             || RustcDefaultCalls::list_metadata(sess, matches, input))\n@@ -400,11 +404,12 @@ impl RustcDefaultCalls {\n         if r.contains(&(\"ls\".to_string())) {\n             match input {\n                 &Input::File(ref ifile) => {\n-                    let mut stdout = old_io::stdout();\n                     let path = &(*ifile);\n+                    let mut v = Vec::new();\n                     metadata::loader::list_file_metadata(sess.target.target.options.is_like_osx,\n                                                          path,\n-                                                         &mut stdout).unwrap();\n+                                                         &mut v).unwrap();\n+                    println!(\"{}\", String::from_utf8(v).unwrap());\n                 }\n                 &Input::Str(_) => {\n                     early_error(\"cannot list metadata for stdin\");\n@@ -419,8 +424,8 @@ impl RustcDefaultCalls {\n \n     fn print_crate_info(sess: &Session,\n                         input: Option<&Input>,\n-                        odir: &Option<Path>,\n-                        ofile: &Option<Path>)\n+                        odir: &Option<PathBuf>,\n+                        ofile: &Option<PathBuf>)\n                         -> Compilation {\n         if sess.opts.prints.len() == 0 {\n             return Compilation::Continue;\n@@ -457,7 +462,8 @@ impl RustcDefaultCalls {\n                                                              style,\n                                                              &id,\n                                                              &t_outputs.with_extension(\"\"));\n-                        println!(\"{}\", fname.filename_display());\n+                        println!(\"{}\", fname.file_name().unwrap()\n+                                            .to_string_lossy());\n                     }\n                 }\n             }"}, {"sha": "ffb2a05e4374920caea984151cfd91c1b135aa00", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -38,8 +38,11 @@ use syntax::ptr::P;\n \n use graphviz as dot;\n \n-use std::old_io::{self, MemReader};\n+use std::fs::File;\n+use std::io::{self, Write};\n+use std::old_io;\n use std::option;\n+use std::path::PathBuf;\n use std::str::FromStr;\n \n #[derive(Copy, PartialEq, Debug)]\n@@ -208,15 +211,15 @@ impl<'ast> PrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n     fn pre(&self,\n            s: &mut pprust::State,\n-           node: pprust::AnnNode) -> old_io::IoResult<()> {\n+           node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n             pprust::NodeExpr(_) => s.popen(),\n             _ => Ok(())\n         }\n     }\n     fn post(&self,\n             s: &mut pprust::State,\n-            node: pprust::AnnNode) -> old_io::IoResult<()> {\n+            node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n             pprust::NodeIdent(_) | pprust::NodeName(_) => Ok(()),\n \n@@ -259,7 +262,7 @@ impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n     fn post(&self,\n             s: &mut pprust::State,\n-            node: pprust::AnnNode) -> old_io::IoResult<()> {\n+            node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n             pprust::NodeIdent(&ast::Ident { name: ast::Name(nm), ctxt }) => {\n                 try!(pp::space(&mut s.s));\n@@ -294,15 +297,15 @@ impl<'tcx> PrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n     fn pre(&self,\n            s: &mut pprust::State,\n-           node: pprust::AnnNode) -> old_io::IoResult<()> {\n+           node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n             pprust::NodeExpr(_) => s.popen(),\n             _ => Ok(())\n         }\n     }\n     fn post(&self,\n             s: &mut pprust::State,\n-            node: pprust::AnnNode) -> old_io::IoResult<()> {\n+            node: pprust::AnnNode) -> io::Result<()> {\n         let tcx = &self.analysis.ty_cx;\n         match node {\n             pprust::NodeExpr(expr) => {\n@@ -507,7 +510,7 @@ pub fn pretty_print_input(sess: Session,\n                           input: &Input,\n                           ppm: PpMode,\n                           opt_uii: Option<UserIdentifiedItem>,\n-                          ofile: Option<Path>) {\n+                          ofile: Option<PathBuf>) {\n     let krate = driver::phase_1_parse_input(&sess, cfg, input);\n \n     let krate = if let PpmSource(PpmEveryBodyLoops) = ppm {\n@@ -547,24 +550,15 @@ pub fn pretty_print_input(sess: Session,\n                             .unwrap()\n                             .as_bytes()\n                             .to_vec();\n-    let mut rdr = MemReader::new(src);\n+    let mut rdr = &src[..];\n \n-    let out = match ofile {\n-        None => box old_io::stdout() as Box<Writer+'static>,\n-        Some(p) => {\n-            let r = old_io::File::create(&p);\n-            match r {\n-                Ok(w) => box w as Box<Writer+'static>,\n-                Err(e) => panic!(\"print-print failed to open {} due to {}\",\n-                                p.display(), e),\n-            }\n-        }\n-    };\n+    let mut out = Vec::new();\n \n     match (ppm, opt_uii) {\n-        (PpmSource(s), None) =>\n+        (PpmSource(s), None) => {\n+            let out: &mut Write = &mut out;\n             s.call_with_pp_support(\n-                sess, ast_map, &arenas, id, out, |annotation, out| {\n+                sess, ast_map, &arenas, id, box out, |annotation, out| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust::print_crate(sess.codemap(),\n@@ -575,9 +569,11 @@ pub fn pretty_print_input(sess: Session,\n                                         out,\n                                         annotation.pp_ann(),\n                                         is_expanded)\n-                }),\n+            })\n+        }\n \n-        (PpmSource(s), Some(uii)) =>\n+        (PpmSource(s), Some(uii)) => {\n+            let out: &mut Write = &mut out;\n             s.call_with_pp_support(\n                 sess, ast_map, &arenas, id, (out,uii), |annotation, (out,uii)| {\n                     debug!(\"pretty printing source code {:?}\", s);\n@@ -589,7 +585,7 @@ pub fn pretty_print_input(sess: Session,\n                                                       sess.diagnostic(),\n                                                       src_name.to_string(),\n                                                       &mut rdr,\n-                                                      out,\n+                                                      box out,\n                                                       annotation.pp_ann(),\n                                                       is_expanded);\n                     for node_id in uii.all_matching_node_ids(ast_map) {\n@@ -600,7 +596,8 @@ pub fn pretty_print_input(sess: Session,\n                         try!(pp::hardbreak(&mut pp_state.s));\n                     }\n                     pp::eof(&mut pp_state.s)\n-                }),\n+                })\n+        }\n \n         (PpmFlowGraph(mode), opt_uii) => {\n             debug!(\"pretty printing flow graph for {:?}\", opt_uii);\n@@ -618,6 +615,7 @@ pub fn pretty_print_input(sess: Session,\n             });\n \n             let code = blocks::Code::from_node(node);\n+            let out: &mut Writer = &mut out;\n             match code {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n@@ -642,14 +640,25 @@ pub fn pretty_print_input(sess: Session,\n                 }\n             }\n         }\n-    }.unwrap()\n+    }.unwrap();\n+\n+    match ofile {\n+        None => print!(\"{}\", String::from_utf8(out).unwrap()),\n+        Some(p) => {\n+            match File::create(&p) {\n+                Ok(mut w) => w.write_all(&out).unwrap(),\n+                Err(e) => panic!(\"print-print failed to open {} due to {}\",\n+                                p.display(), e),\n+            }\n+        }\n+    }\n }\n \n fn print_flowgraph<W:old_io::Writer>(variants: Vec<borrowck_dot::Variant>,\n                                  analysis: ty::CrateAnalysis,\n                                  code: blocks::Code,\n                                  mode: PpFlowGraphMode,\n-                                 mut out: W) -> old_io::IoResult<()> {\n+                                 mut out: W) -> io::Result<()> {\n     let ty_cx = &analysis.ty_cx;\n     let cfg = match code {\n         blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),\n@@ -689,17 +698,10 @@ fn print_flowgraph<W:old_io::Writer>(variants: Vec<borrowck_dot::Variant>,\n         }\n     }\n \n-    fn expand_err_details(r: old_io::IoResult<()>) -> old_io::IoResult<()> {\n+    fn expand_err_details(r: old_io::IoResult<()>) -> io::Result<()> {\n         r.map_err(|ioerr| {\n-            let orig_detail = ioerr.detail.clone();\n-            let m = \"graphviz::render failed\";\n-            old_io::IoError {\n-                detail: Some(match orig_detail {\n-                    None => m.to_string(),\n-                    Some(d) => format!(\"{}: {}\", m, d)\n-                }),\n-                ..ioerr\n-            }\n+            io::Error::new(io::ErrorKind::Other, \"graphviz::render failed\",\n+                           Some(ioerr.to_string()))\n         })\n     }\n }"}, {"sha": "f54480e3e523c156554aaee021f3f70622930bb6", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -16,6 +16,7 @@ use ArchiveRef;\n use std::ffi::CString;\n use std::mem;\n use std::raw;\n+use std::path::Path;\n \n pub struct ArchiveRO {\n     ptr: ArchiveRef,\n@@ -29,14 +30,25 @@ impl ArchiveRO {\n     /// If this archive is used with a mutable method, then an error will be\n     /// raised.\n     pub fn open(dst: &Path) -> Option<ArchiveRO> {\n-        unsafe {\n-            let s = CString::new(dst.as_vec()).unwrap();\n+        return unsafe {\n+            let s = path2cstr(dst);\n             let ar = ::LLVMRustOpenArchive(s.as_ptr());\n             if ar.is_null() {\n                 None\n             } else {\n                 Some(ArchiveRO { ptr: ar })\n             }\n+        };\n+\n+        #[cfg(unix)]\n+        fn path2cstr(p: &Path) -> CString {\n+            use std::os::unix::prelude::*;\n+            use std::ffi::AsOsStr;\n+            CString::new(p.as_os_str().as_bytes()).unwrap()\n+        }\n+        #[cfg(windows)]\n+        fn path2cstr(p: &Path) -> CString {\n+            CString::new(p.to_str().unwrap()).unwrap()\n         }\n     }\n "}, {"sha": "0a1416ff5664a02bcaec4445ec246da9cb708637", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -28,9 +28,9 @@\n #![feature(int_uint)]\n #![feature(libc)]\n #![feature(link_args)]\n-#![feature(old_path)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n+#![feature(path)]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;"}, {"sha": "1e84bc4b8e0bb197d8b2ae7cc0989c3829743a78", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 96, "deletions": 78, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -27,12 +27,13 @@ use util::common::time;\n use util::ppaux;\n use util::sha2::{Digest, Sha256};\n \n-use std::old_io::fs::PathExtensions;\n-use std::old_io::{fs, TempDir, Command};\n-use std::old_io;\n+use std::ffi::{AsOsStr, OsString};\n+use std::fs::{self, TempDir, PathExt};\n+use std::io::{self, Read, Write};\n use std::mem;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n use std::str;\n-use std::string::String;\n use flate;\n use serialize::hex::ToHex;\n use syntax::ast;\n@@ -156,7 +157,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n         return validate(s.to_string(), Some(attr.span));\n     }\n     if let Input::File(ref path) = *input {\n-        if let Some(s) = path.filestem_str() {\n+        if let Some(s) = path.file_stem().and_then(|s| s.to_str()) {\n             return validate(s.to_string(), None);\n         }\n     }\n@@ -356,7 +357,7 @@ pub fn get_cc_prog(sess: &Session) -> String {\n }\n \n pub fn remove(sess: &Session, path: &Path) {\n-    match fs::unlink(path) {\n+    match fs::remove_file(path) {\n         Ok(..) => {}\n         Err(e) => {\n             sess.err(&format!(\"failed to remove {}: {}\",\n@@ -371,7 +372,7 @@ pub fn remove(sess: &Session, path: &Path) {\n pub fn link_binary(sess: &Session,\n                    trans: &CrateTranslation,\n                    outputs: &OutputFilenames,\n-                   crate_name: &str) -> Vec<Path> {\n+                   crate_name: &str) -> Vec<PathBuf> {\n     let mut out_filenames = Vec::new();\n     for &crate_type in &*sess.crate_types.borrow() {\n         if invalid_output_for_target(sess, crate_type) {\n@@ -425,35 +426,35 @@ pub fn invalid_output_for_target(sess: &Session,\n }\n \n fn is_writeable(p: &Path) -> bool {\n-    match p.stat() {\n+    match p.metadata() {\n         Err(..) => true,\n-        Ok(m) => m.perm & old_io::USER_WRITE == old_io::USER_WRITE\n+        Ok(m) => !m.permissions().readonly()\n     }\n }\n \n pub fn filename_for_input(sess: &Session,\n                           crate_type: config::CrateType,\n                           name: &str,\n-                          out_filename: &Path) -> Path {\n+                          out_filename: &Path) -> PathBuf {\n     let libname = format!(\"{}{}\", name, sess.opts.cg.extra_filename);\n     match crate_type {\n         config::CrateTypeRlib => {\n-            out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n+            out_filename.with_file_name(&format!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeDylib => {\n             let (prefix, suffix) = (&sess.target.target.options.dll_prefix,\n                                     &sess.target.target.options.dll_suffix);\n-            out_filename.with_filename(format!(\"{}{}{}\",\n-                                               prefix,\n-                                               libname,\n-                                               suffix))\n+            out_filename.with_file_name(&format!(\"{}{}{}\",\n+                                                  prefix,\n+                                                 libname,\n+                                                 suffix))\n         }\n         config::CrateTypeStaticlib => {\n-            out_filename.with_filename(format!(\"lib{}.a\", libname))\n+            out_filename.with_file_name(&format!(\"lib{}.a\", libname))\n         }\n         config::CrateTypeExecutable => {\n             let suffix = &sess.target.target.options.exe_suffix;\n-            out_filename.with_filename(format!(\"{}{}\", libname, suffix))\n+            out_filename.with_file_name(&format!(\"{}{}\", libname, suffix))\n         }\n     }\n }\n@@ -462,7 +463,7 @@ fn link_binary_output(sess: &Session,\n                       trans: &CrateTranslation,\n                       crate_type: config::CrateType,\n                       outputs: &OutputFilenames,\n-                      crate_name: &str) -> Path {\n+                      crate_name: &str) -> PathBuf {\n     let obj_filename = outputs.temp_path(OutputTypeObject);\n     let out_filename = match outputs.single_output_file {\n         Some(ref file) => file.clone(),\n@@ -507,10 +508,10 @@ fn link_binary_output(sess: &Session,\n     out_filename\n }\n \n-fn archive_search_paths(sess: &Session) -> Vec<Path> {\n+fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n     let mut search = Vec::new();\n     sess.target_filesearch(PathKind::Native).for_each_lib_search_path(|path, _| {\n-        search.push(path.clone());\n+        search.push(path.to_path_buf());\n         FileDoesntMatch\n     });\n     return search;\n@@ -529,7 +530,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     let handler = &sess.diagnostic().handler;\n     let config = ArchiveConfig {\n         handler: handler,\n-        dst: out_filename.clone(),\n+        dst: out_filename.to_path_buf(),\n         lib_search_paths: archive_search_paths(sess),\n         slib_prefix: sess.target.target.options.staticlib_prefix.clone(),\n         slib_suffix: sess.target.target.options.staticlib_suffix.clone(),\n@@ -588,7 +589,9 @@ fn link_rlib<'a>(sess: &'a Session,\n             // the same filename for metadata (stomping over one another)\n             let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n-            match fs::File::create(&metadata).write_all(&trans.metadata) {\n+            match fs::File::create(&metadata).and_then(|mut f| {\n+                f.write_all(&trans.metadata)\n+            }) {\n                 Ok(..) => {}\n                 Err(e) => {\n                     sess.err(&format!(\"failed to write {}: {}\",\n@@ -613,28 +616,32 @@ fn link_rlib<'a>(sess: &'a Session,\n                 let bc_deflated_filename = obj_filename.with_extension(\n                     &format!(\"{}.bytecode.deflate\", i));\n \n-                let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n-                    Ok(buffer) => buffer,\n+                let mut bc_data = Vec::new();\n+                match fs::File::open(&bc_filename).and_then(|mut f| {\n+                    f.read_to_end(&mut bc_data)\n+                }) {\n+                    Ok(..) => {}\n                     Err(e) => sess.fatal(&format!(\"failed to read bytecode: {}\",\n                                                  e))\n-                };\n+                }\n \n                 let bc_data_deflated = match flate::deflate_bytes(&bc_data[..]) {\n                     Some(compressed) => compressed,\n-                    None => sess.fatal(&format!(\"failed to compress bytecode from {}\",\n-                                               bc_filename.display()))\n+                    None => sess.fatal(&format!(\"failed to compress bytecode \\\n+                                                 from {}\",\n+                                                 bc_filename.display()))\n                 };\n \n                 let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n                     Ok(file) => file,\n                     Err(e) => {\n-                        sess.fatal(&format!(\"failed to create compressed bytecode \\\n-                                            file: {}\", e))\n+                        sess.fatal(&format!(\"failed to create compressed \\\n+                                             bytecode file: {}\", e))\n                     }\n                 };\n \n                 match write_rlib_bytecode_object_v1(&mut bc_file_deflated,\n-                                                    bc_data_deflated.as_slice()) {\n+                                                    &bc_data_deflated) {\n                     Ok(()) => {}\n                     Err(e) => {\n                         sess.err(&format!(\"failed to write compressed bytecode: \\\n@@ -670,15 +677,23 @@ fn link_rlib<'a>(sess: &'a Session,\n     ab\n }\n \n-fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n-                                            bc_data_deflated: &[u8])\n-                                         -> ::std::old_io::IoResult<()> {\n+fn write_rlib_bytecode_object_v1(writer: &mut Write,\n+                                 bc_data_deflated: &[u8]) -> io::Result<()> {\n     let bc_data_deflated_size: u64 = bc_data_deflated.len() as u64;\n \n-    try! { writer.write_all(RLIB_BYTECODE_OBJECT_MAGIC) };\n-    try! { writer.write_le_u32(1) };\n-    try! { writer.write_le_u64(bc_data_deflated_size) };\n-    try! { writer.write_all(&bc_data_deflated[..]) };\n+    try!(writer.write_all(RLIB_BYTECODE_OBJECT_MAGIC));\n+    try!(writer.write_all(&[1, 0, 0, 0]));\n+    try!(writer.write_all(&[\n+        (bc_data_deflated_size >>  0) as u8,\n+        (bc_data_deflated_size >>  8) as u8,\n+        (bc_data_deflated_size >> 16) as u8,\n+        (bc_data_deflated_size >> 24) as u8,\n+        (bc_data_deflated_size >> 32) as u8,\n+        (bc_data_deflated_size >> 40) as u8,\n+        (bc_data_deflated_size >> 48) as u8,\n+        (bc_data_deflated_size >> 56) as u8,\n+    ]));\n+    try!(writer.write_all(&bc_data_deflated));\n \n     let number_of_bytes_written_so_far =\n         RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n@@ -690,7 +705,7 @@ fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n     // padding byte to make it even. This works around a crash bug in LLDB\n     // (see issue #15950)\n     if number_of_bytes_written_so_far % 2 == 1 {\n-        try! { writer.write_u8(0) };\n+        try!(writer.write_all(&[0]));\n     }\n \n     return Ok(());\n@@ -796,13 +811,13 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n                                  pname,\n                                  prog.status));\n                 sess.note(&format!(\"{:?}\", &cmd));\n-                let mut output = prog.error.clone();\n-                output.push_all(&prog.output);\n+                let mut output = prog.stderr.clone();\n+                output.push_all(&prog.stdout);\n                 sess.note(str::from_utf8(&output[..]).unwrap());\n                 sess.abort_if_errors();\n             }\n-            debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.error).unwrap());\n-            debug!(\"linker stdout:\\n{}\", String::from_utf8(prog.output).unwrap());\n+            debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.stderr).unwrap());\n+            debug!(\"linker stdout:\\n{}\", String::from_utf8(prog.stdout).unwrap());\n         },\n         Err(e) => {\n             sess.err(&format!(\"could not exec the linker `{}`: {}\",\n@@ -866,9 +881,9 @@ fn link_args(cmd: &mut Command,\n         if t.options.is_like_osx {\n             let morestack = lib_path.join(\"libmorestack.a\");\n \n-            let mut v = b\"-Wl,-force_load,\".to_vec();\n-            v.push_all(morestack.as_vec());\n-            cmd.arg(&v[..]);\n+            let mut v = OsString::from_str(\"-Wl,-force_load,\");\n+            v.push_os_str(morestack.as_os_str());\n+            cmd.arg(&v);\n         } else {\n             cmd.args(&[\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n         }\n@@ -878,7 +893,7 @@ fn link_args(cmd: &mut Command,\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here.\n     if dylib {\n-        cmd.arg(obj_filename.with_extension(\"metadata.o\"));\n+        cmd.arg(&obj_filename.with_extension(\"metadata.o\"));\n     }\n \n     if t.options.is_like_osx {\n@@ -991,9 +1006,9 @@ fn link_args(cmd: &mut Command,\n             cmd.args(&[\"-dynamiclib\", \"-Wl,-dylib\"]);\n \n             if sess.opts.cg.rpath {\n-                let mut v = \"-Wl,-install_name,@rpath/\".as_bytes().to_vec();\n-                v.push_all(out_filename.filename().unwrap());\n-                cmd.arg(&v[..]);\n+                let mut v = OsString::from_str(\"-Wl,-install_name,@rpath/\");\n+                v.push_os_str(out_filename.file_name().unwrap());\n+                cmd.arg(&v);\n             }\n         } else {\n             cmd.arg(\"-shared\");\n@@ -1006,23 +1021,23 @@ fn link_args(cmd: &mut Command,\n     if sess.opts.cg.rpath {\n         let sysroot = sess.sysroot();\n         let target_triple = &sess.opts.target_triple;\n-        let get_install_prefix_lib_path = || {\n+        let mut get_install_prefix_lib_path = || {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n             let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n-            let mut path = Path::new(install_prefix);\n+            let mut path = PathBuf::new(install_prefix);\n             path.push(&tlib);\n \n             path\n         };\n-        let rpath_config = RPathConfig {\n+        let mut rpath_config = RPathConfig {\n             used_crates: sess.cstore.get_used_crates(cstore::RequireDynamic),\n-            out_filename: out_filename.clone(),\n+            out_filename: out_filename.to_path_buf(),\n             has_rpath: sess.target.target.options.has_rpath,\n             is_like_osx: sess.target.target.options.is_like_osx,\n-            get_install_prefix_lib_path: get_install_prefix_lib_path,\n-            realpath: ::util::fs::realpath\n+            get_install_prefix_lib_path: &mut get_install_prefix_lib_path,\n+            realpath: &mut ::util::fs::realpath\n         };\n-        cmd.args(&rpath::get_rpath_flags(rpath_config));\n+        cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n     }\n \n     // Finally add all the linker arguments provided on the command line along\n@@ -1082,7 +1097,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n     let search_path = archive_search_paths(sess);\n     for l in staticlibs {\n         if takes_hints {\n-            cmd.arg(format!(\"-l{}\", l));\n+            cmd.arg(&format!(\"-l{}\", l));\n         } else {\n             // -force_load is the OSX equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n@@ -1091,9 +1106,9 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n                                             &sess.target.target.options.staticlib_suffix,\n                                             &search_path[..],\n                                             &sess.diagnostic().handler);\n-            let mut v = b\"-Wl,-force_load,\".to_vec();\n-            v.push_all(lib.as_vec());\n-            cmd.arg(&v[..]);\n+            let mut v = OsString::from_str(\"-Wl,-force_load,\");\n+            v.push_os_str(lib.as_os_str());\n+            cmd.arg(&v);\n         }\n     }\n     if takes_hints {\n@@ -1103,7 +1118,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n     for &(ref l, kind) in others {\n         match kind {\n             cstore::NativeUnknown => {\n-                cmd.arg(format!(\"-l{}\", l));\n+                cmd.arg(&format!(\"-l{}\", l));\n             }\n             cstore::NativeFramework => {\n                 cmd.arg(\"-framework\").arg(&l[..]);\n@@ -1150,18 +1165,18 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n         match kind {\n             cstore::RequireDynamic => {\n-                add_dynamic_crate(cmd, sess, src.dylib.unwrap().0)\n+                add_dynamic_crate(cmd, sess, &src.dylib.unwrap().0)\n             }\n             cstore::RequireStatic => {\n-                add_static_crate(cmd, sess, tmpdir, src.rlib.unwrap().0)\n+                add_static_crate(cmd, sess, tmpdir, &src.rlib.unwrap().0)\n             }\n         }\n \n     }\n \n     // Converts a library file-stem into a cc -l argument\n-    fn unlib<'a>(config: &config::Config, stem: &'a [u8]) -> &'a [u8] {\n-        if stem.starts_with(\"lib\".as_bytes()) && !config.target.options.is_like_windows {\n+    fn unlib<'a>(config: &config::Config, stem: &'a str) -> &'a str {\n+        if stem.starts_with(\"lib\") && !config.target.options.is_like_windows {\n             &stem[3..]\n         } else {\n             stem\n@@ -1170,7 +1185,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n \n     // Adds the static \"rlib\" versions of all crates to the command line.\n     fn add_static_crate(cmd: &mut Command, sess: &Session, tmpdir: &Path,\n-                        cratepath: Path) {\n+                        cratepath: &Path) {\n         // When performing LTO on an executable output, all of the\n         // bytecode from the upstream libraries has already been\n         // included in our object file output. We need to modify all of\n@@ -1186,12 +1201,12 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // If we're not doing LTO, then our job is simply to just link\n         // against the archive.\n         if sess.lto() {\n-            let name = cratepath.filename_str().unwrap();\n+            let name = cratepath.file_name().unwrap().to_str().unwrap();\n             let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n             time(sess.time_passes(),\n                  &format!(\"altering {}.rlib\", name),\n                  (), |()| {\n-                let dst = tmpdir.join(cratepath.filename().unwrap());\n+                let dst = tmpdir.join(cratepath.file_name().unwrap());\n                 match fs::copy(&cratepath, &dst) {\n                     Ok(..) => {}\n                     Err(e) => {\n@@ -1205,7 +1220,11 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                 // Fix up permissions of the copy, as fs::copy() preserves\n                 // permissions, but the original file may have been installed\n                 // by a package manager and may be read-only.\n-                match fs::chmod(&dst, old_io::USER_READ | old_io::USER_WRITE) {\n+                match fs::metadata(&dst).and_then(|m| {\n+                    let mut perms = m.permissions();\n+                    perms.set_readonly(false);\n+                    fs::set_permissions(&dst, perms)\n+                }) {\n                     Ok(..) => {}\n                     Err(e) => {\n                         sess.err(&format!(\"failed to chmod {} when preparing \\\n@@ -1227,7 +1246,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                 archive.remove_file(&format!(\"{}.o\", name));\n                 let files = archive.files();\n                 if files.iter().any(|s| s.ends_with(\".o\")) {\n-                    cmd.arg(dst);\n+                    cmd.arg(&dst);\n                 }\n             });\n         } else {\n@@ -1236,19 +1255,18 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     }\n \n     // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crate(cmd: &mut Command, sess: &Session, cratepath: Path) {\n+    fn add_dynamic_crate(cmd: &mut Command, sess: &Session, cratepath: &Path) {\n         // If we're performing LTO, then it should have been previously required\n         // that all upstream rust dependencies were available in an rlib format.\n         assert!(!sess.lto());\n \n         // Just need to tell the linker about where the library lives and\n         // what its name is\n-        let dir = cratepath.dirname();\n-        if !dir.is_empty() { cmd.arg(\"-L\").arg(dir); }\n-\n-        let mut v = \"-l\".as_bytes().to_vec();\n-        v.push_all(unlib(&sess.target, cratepath.filestem().unwrap()));\n-        cmd.arg(&v[..]);\n+        if let Some(dir) = cratepath.parent() {\n+            cmd.arg(\"-L\").arg(dir);\n+        }\n+        let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n+        cmd.arg(&format!(\"-l{}\", unlib(&sess.target, filestem)));\n     }\n }\n \n@@ -1286,7 +1304,7 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n         for &(kind, ref lib) in &libs {\n             match kind {\n                 cstore::NativeUnknown => {\n-                    cmd.arg(format!(\"-l{}\", *lib));\n+                    cmd.arg(&format!(\"-l{}\", *lib));\n                 }\n                 cstore::NativeFramework => {\n                     cmd.arg(\"-framework\");"}, {"sha": "db9966e05487d4466ab2ab5398fa0e0a9a9211a1", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -59,7 +59,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         };\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n-        let file = path.filename_str().unwrap();\n+        let file = path.file_name().unwrap().to_str().unwrap();\n         let file = &file[3..file.len() - 5]; // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n         for i in iter::count(0, 1) {"}, {"sha": "156cfa6c4b23a852ebd6076da31617770f1b55a0", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -18,17 +18,19 @@ use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef, Conte\n use llvm::SMDiagnosticRef;\n use trans::{CrateTranslation, ModuleTranslation};\n use util::common::time;\n+use util::common::path2cstr;\n use syntax::codemap;\n use syntax::diagnostic;\n use syntax::diagnostic::{Emitter, Handler, Level, mk_handler};\n \n use std::ffi::{CStr, CString};\n-use std::old_io::Command;\n-use std::old_io::fs;\n+use std::fs;\n use std::iter::Unfold;\n+use std::mem;\n+use std::path::Path;\n+use std::process::{Command, Stdio};\n use std::ptr;\n use std::str;\n-use std::mem;\n use std::sync::{Arc, Mutex};\n use std::sync::mpsc::channel;\n use std::thread;\n@@ -67,7 +69,7 @@ pub fn write_output_file(\n         output: &Path,\n         file_type: llvm::FileType) {\n     unsafe {\n-        let output_c = CString::new(output.as_vec()).unwrap();\n+        let output_c = path2cstr(output);\n         let result = llvm::LLVMRustWriteOutputFile(\n                 target, pm, m, output_c.as_ptr(), file_type);\n         if !result {\n@@ -424,7 +426,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     if config.emit_no_opt_bc {\n         let ext = format!(\"{}.no-opt.bc\", name_extra);\n         let out = output_names.with_extension(&ext);\n-        let out = CString::new(out.as_vec()).unwrap();\n+        let out = path2cstr(&out);\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n@@ -477,7 +479,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                     if config.emit_lto_bc {\n                         let name = format!(\"{}.lto.bc\", name_extra);\n                         let out = output_names.with_extension(&name);\n-                        let out = CString::new(out.as_vec()).unwrap();\n+                        let out = path2cstr(&out);\n                         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n                     }\n                 },\n@@ -511,15 +513,15 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     if config.emit_bc {\n         let ext = format!(\"{}.bc\", name_extra);\n         let out = output_names.with_extension(&ext);\n-        let out = CString::new(out.as_vec()).unwrap();\n+        let out = path2cstr(&out);\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n     time(config.time_passes, \"codegen passes\", (), |()| {\n         if config.emit_ir {\n             let ext = format!(\"{}.ll\", name_extra);\n             let out = output_names.with_extension(&ext);\n-            let out = CString::new(out.as_vec()).unwrap();\n+            let out = path2cstr(&out);\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr());\n             })\n@@ -717,22 +719,19 @@ pub fn run_passes(sess: &Session,\n         cmd.arg(\"-nostdlib\");\n \n         for index in 0..trans.modules.len() {\n-            cmd.arg(crate_output.with_extension(&format!(\"{}.o\", index)));\n+            cmd.arg(&crate_output.with_extension(&format!(\"{}.o\", index)));\n         }\n \n-        cmd.arg(\"-r\")\n-           .arg(\"-o\")\n-           .arg(windows_output_path.as_ref().unwrap_or(output_path));\n+        cmd.arg(\"-r\").arg(\"-o\")\n+           .arg(windows_output_path.as_ref().map(|s| &**s).unwrap_or(output_path));\n \n         cmd.args(&sess.target.target.options.post_link_args);\n \n         if sess.opts.debugging_opts.print_link_args {\n             println!(\"{:?}\", &cmd);\n         }\n \n-        cmd.stdin(::std::old_io::process::Ignored)\n-           .stdout(::std::old_io::process::InheritFd(1))\n-           .stderr(::std::old_io::process::InheritFd(2));\n+        cmd.stdin(Stdio::null());\n         match cmd.status() {\n             Ok(status) => {\n                 if !status.success() {\n@@ -964,9 +963,9 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     let pname = get_cc_prog(sess);\n     let mut cmd = Command::new(&pname[..]);\n \n-    cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(config::OutputTypeObject))\n-                           .arg(outputs.temp_path(config::OutputTypeAssembly));\n-    debug!(\"{:?}\", &cmd);\n+    cmd.arg(\"-c\").arg(\"-o\").arg(&outputs.path(config::OutputTypeObject))\n+                           .arg(&outputs.temp_path(config::OutputTypeAssembly));\n+    debug!(\"{:?}\", cmd);\n \n     match cmd.output() {\n         Ok(prog) => {\n@@ -975,8 +974,8 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n                                  pname,\n                                  prog.status));\n                 sess.note(&format!(\"{:?}\", &cmd));\n-                let mut note = prog.error.clone();\n-                note.push_all(&prog.output);\n+                let mut note = prog.stderr.clone();\n+                note.push_all(&prog.stdout);\n                 sess.note(str::from_utf8(&note[..]).unwrap());\n                 sess.abort_if_errors();\n             }"}, {"sha": "dcc79e90cc5722556f44c2bc140e363a1c53a581", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -29,16 +29,19 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(int_uint)]\n-#![feature(old_io)]\n #![feature(libc)]\n-#![feature(old_path)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n+#![feature(io)]\n+#![feature(fs)]\n+#![feature(path)]\n+#![feature(os)]\n+#![feature(tempdir)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "3c6cb5f9de9892f6f040aaf47be27ce8bb8d3baa", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -33,8 +33,9 @@ use middle::def;\n use middle::ty::{self, Ty};\n \n use std::cell::Cell;\n-use std::old_io::{self, File, fs};\n use std::env;\n+use std::fs::{self, File};\n+use std::path::{Path, PathBuf};\n \n use syntax::ast_util::{self, PostExpansionMethod};\n use syntax::ast::{self, NodeId, DefId};\n@@ -1537,6 +1538,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n     }\n }\n \n+#[allow(deprecated)]\n pub fn process_crate(sess: &Session,\n                      krate: &ast::Crate,\n                      analysis: &ty::CrateAnalysis,\n@@ -1557,15 +1559,15 @@ pub fn process_crate(sess: &Session,\n     info!(\"Dumping crate {}\", cratename);\n \n     // find a path to dump our data to\n-    let mut root_path = match env::var(\"DXR_RUST_TEMP_FOLDER\") {\n-        Ok(val) => Path::new(val),\n-        Err(..) => match odir {\n+    let mut root_path = match env::var_os(\"DXR_RUST_TEMP_FOLDER\") {\n+        Some(val) => PathBuf::new(&val),\n+        None => match odir {\n             Some(val) => val.join(\"dxr\"),\n-            None => Path::new(\"dxr-temp\"),\n+            None => PathBuf::new(\"dxr-temp\"),\n         },\n     };\n \n-    match fs::mkdir_recursive(&root_path, old_io::USER_RWX) {\n+    match fs::create_dir_all(&root_path) {\n         Err(e) => sess.err(&format!(\"Could not create directory {}: {}\",\n                            root_path.display(), e)),\n         _ => (),\n@@ -1579,7 +1581,7 @@ pub fn process_crate(sess: &Session,\n     // Create output file.\n     let mut out_name = cratename.clone();\n     out_name.push_str(\".csv\");\n-    root_path.push(out_name);\n+    root_path.push(&out_name);\n     let output_file = match File::create(&root_path) {\n         Ok(f) => box f,\n         Err(e) => {\n@@ -1595,7 +1597,7 @@ pub fn process_crate(sess: &Session,\n         collected_paths: vec!(),\n         collecting: false,\n         fmt: FmtStrs::new(box Recorder {\n-                            out: output_file as Box<Writer+'static>,\n+                            out: output_file,\n                             dump_spans: false,\n                         },\n                         SpanUtils {"}, {"sha": "f7c0d6a983fb77899f9f9aef1e284b02bd13fd28", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -13,7 +13,7 @@ pub use self::Row::*;\n use super::escape;\n use super::span_utils::SpanUtils;\n \n-use std::vec::Vec;\n+use std::io::Write;\n \n use syntax::ast;\n use syntax::ast::{NodeId,DefId};\n@@ -23,7 +23,7 @@ const ZERO_DEF_ID: DefId = DefId { node: 0, krate: 0 };\n \n pub struct Recorder {\n     // output file\n-    pub out: Box<Writer+'static>,\n+    pub out: Box<Write+'static>,\n     pub dump_spans: bool,\n }\n "}, {"sha": "142262a25bd437982e5f299ec93ac7c240e43d36", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -206,10 +206,12 @@ use middle::pat_util;\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n use util::ppaux;\n+use util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n-use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n+use std::ffi::CString;\n+use std::path::Path;\n use std::ptr;\n use std::rc::{Rc, Weak};\n use syntax::util::interner::Interner;\n@@ -1588,20 +1590,13 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n                 cx.sess().warn(\"debuginfo: Invalid path to crate's local root source file!\");\n                 fallback_path(cx)\n             } else {\n-                match abs_path.path_relative_from(work_dir) {\n+                match abs_path.relative_from(work_dir) {\n                     Some(ref p) if p.is_relative() => {\n-                        // prepend \"./\" if necessary\n-                        let dotdot = b\"..\";\n-                        let prefix: &[u8] = &[dotdot[0], ::std::old_path::SEP_BYTE];\n-                        let mut path_bytes = p.as_vec().to_vec();\n-\n-                        if &path_bytes[..2] != prefix &&\n-                           &path_bytes[..2] != dotdot {\n-                            path_bytes.insert(0, prefix[0]);\n-                            path_bytes.insert(1, prefix[1]);\n+                        if p.starts_with(Path::new(\"./\")) {\n+                            path2cstr(p)\n+                        } else {\n+                            path2cstr(&Path::new(\".\").join(p))\n                         }\n-\n-                        CString::new(path_bytes).unwrap()\n                     }\n                     _ => fallback_path(cx)\n                 }\n@@ -1614,7 +1609,7 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n     let compile_unit_name = compile_unit_name.as_ptr();\n-    let work_dir = CString::new(work_dir.as_vec()).unwrap();\n+    let work_dir = path2cstr(&work_dir);\n     let producer = CString::new(producer).unwrap();\n     let flags = \"\\0\";\n     let split_name = \"\\0\";\n@@ -1716,7 +1711,7 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n     debug!(\"file_metadata: {}\", full_path);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let work_dir = cx.sess().working_dir.as_str().unwrap();\n+    let work_dir = cx.sess().working_dir.to_str().unwrap();\n     let file_name =\n         if full_path.starts_with(work_dir) {\n             &full_path[work_dir.len() + 1..full_path.len()]"}, {"sha": "c39451b15ada5c8334e9d93a50604008598caaca", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -49,7 +49,7 @@ use rustc::middle::stability;\n \n use std::rc::Rc;\n use std::u32;\n-use std::old_path::Path as FsPath; // Conflicts with Path struct\n+use std::path::PathBuf;\n \n use core::DocContext;\n use doctree;\n@@ -118,7 +118,7 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::owned_slice::OwnedSlice<T> {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub name: String,\n-    pub src: FsPath,\n+    pub src: PathBuf,\n     pub module: Option<Item>,\n     pub externs: Vec<(ast::CrateNum, ExternalCrate)>,\n     pub primitives: Vec<PrimitiveType>,\n@@ -191,7 +191,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n \n         let src = match cx.input {\n             Input::File(ref path) => path.clone(),\n-            Input::Str(_) => FsPath::new(\"\") // FIXME: this is wrong\n+            Input::Str(_) => PathBuf::new(\"\") // FIXME: this is wrong\n         };\n \n         Crate {"}, {"sha": "6cfe7a33dd4f366b285c4991f29f755dabec38d5", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -8,7 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{old_io, str};\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::io;\n+use std::old_io;\n+use std::path::{PathBuf, Path};\n+use std::str;\n \n #[derive(Clone)]\n pub struct ExternalHtml{\n@@ -33,16 +38,17 @@ impl ExternalHtml {\n     }\n }\n \n-pub fn load_string(input: &Path) -> old_io::IoResult<Option<String>> {\n-    let mut f = try!(old_io::File::open(input));\n-    let d = try!(f.read_to_end());\n+pub fn load_string(input: &Path) -> io::Result<Option<String>> {\n+    let mut f = try!(File::open(input));\n+    let mut d = Vec::new();\n+    try!(f.read_to_end(&mut d));\n     Ok(str::from_utf8(&d).map(|s| s.to_string()).ok())\n }\n \n macro_rules! load_or_return {\n     ($input: expr, $cant_read: expr, $not_utf8: expr) => {\n         {\n-            let input = Path::new($input);\n+            let input = PathBuf::new($input);\n             match ::externalfiles::load_string(&input) {\n                 Err(e) => {\n                     let _ = writeln!(&mut old_io::stderr(),"}, {"sha": "51c58861b4b252b66ea31d3b4d9a78de7a3e45ae", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -20,7 +20,9 @@ pub use self::imp::Lock;\n \n #[cfg(unix)]\n mod imp {\n-    use std::ffi::CString;\n+    use std::ffi::{AsOsStr, CString};\n+    use std::os::unix::prelude::*;\n+    use std::path::Path;\n     use libc;\n     use std::os as stdos;\n \n@@ -114,7 +116,7 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let buf = CString::new(p.as_vec()).unwrap();\n+            let buf = CString::new(p.as_os_str().as_bytes()).unwrap();\n             let fd = unsafe {\n                 libc::open(buf.as_ptr(), libc::O_RDWR | libc::O_CREAT,\n                            libc::S_IRWXU)\n@@ -163,8 +165,11 @@ mod imp {\n #[cfg(windows)]\n mod imp {\n     use libc;\n+    use std::ffi::AsOsStr;\n     use std::mem;\n+    use std::os::windows::prelude::*;\n     use std::os;\n+    use std::path::Path;\n     use std::ptr;\n \n     const LOCKFILE_EXCLUSIVE_LOCK: libc::DWORD = 0x00000002;\n@@ -190,7 +195,7 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let mut p_16: Vec<u16> = p.as_str().unwrap().utf16_units().collect();\n+            let mut p_16: Vec<_> = p.as_os_str().encode_wide().collect();\n             p_16.push(0);\n             let handle = unsafe {\n                 libc::CreateFileW(p_16.as_ptr(),"}, {"sha": "3acd17dedd59d986503814984c474860e70d2f78", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n use std::fmt;\n-use std::old_io;\n+use std::io::prelude::*;\n+use std::io;\n \n use externalfiles::ExternalHtml;\n \n@@ -31,8 +32,8 @@ pub struct Page<'a> {\n }\n \n pub fn render<T: fmt::Display, S: fmt::Display>(\n-    dst: &mut old_io::Writer, layout: &Layout, page: &Page, sidebar: &S, t: &T)\n-    -> old_io::IoResult<()>\n+    dst: &mut io::Write, layout: &Layout, page: &Page, sidebar: &S, t: &T)\n+    -> io::Result<()>\n {\n     write!(dst,\n r##\"<!DOCTYPE html>\n@@ -159,7 +160,7 @@ r##\"<!DOCTYPE html>\n     )\n }\n \n-pub fn redirect(dst: &mut old_io::Writer, url: &str) -> old_io::IoResult<()> {\n+pub fn redirect(dst: &mut io::Write, url: &str) -> io::Result<()> {\n     // <script> triggers a redirect before refresh, so this is fine.\n     write!(dst,\n r##\"<!DOCTYPE html>"}, {"sha": "add44769bab60fff1ca052786349c8670b4a85eb", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 61, "deletions": 56, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -38,11 +38,13 @@ use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n+use std::ffi::OsStr;\n use std::fmt;\n-use std::old_io::fs::PathExtensions;\n-use std::old_io::{fs, File, BufferedWriter, BufferedReader};\n-use std::old_io;\n+use std::fs::{self, File};\n+use std::io::prelude::*;\n+use std::io::{self, BufWriter, BufReader};\n use std::iter::repeat;\n+use std::path::{PathBuf, Path};\n use std::str;\n use std::sync::Arc;\n \n@@ -89,10 +91,10 @@ pub struct Context {\n     pub root_path: String,\n     /// The path to the crate root source minus the file name.\n     /// Used for simplifying paths to the highlighted source code files.\n-    pub src_root: Path,\n+    pub src_root: PathBuf,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n-    pub dst: Path,\n+    pub dst: PathBuf,\n     /// This describes the layout of each page, and is not modified after\n     /// creation of the context (contains info like the favicon and added html).\n     pub layout: layout::Layout,\n@@ -220,7 +222,7 @@ struct SourceCollector<'a> {\n     /// Processed source-file paths\n     seen: HashSet<String>,\n     /// Root destination to place all HTML output into\n-    dst: Path,\n+    dst: PathBuf,\n }\n \n /// Wrapper struct to render the source code of a file. This will do things like\n@@ -257,11 +259,15 @@ thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> =\n /// Generates the documentation for `crate` into the directory `dst`\n pub fn run(mut krate: clean::Crate,\n            external_html: &ExternalHtml,\n-           dst: Path,\n-           passes: HashSet<String>) -> old_io::IoResult<()> {\n+           dst: PathBuf,\n+           passes: HashSet<String>) -> io::Result<()> {\n+    let src_root = match krate.src.parent() {\n+        Some(p) => p.to_path_buf(),\n+        None => PathBuf::new(\"\"),\n+    };\n     let mut cx = Context {\n         dst: dst,\n-        src_root: krate.src.dir_path(),\n+        src_root: src_root,\n         passes: passes,\n         current: Vec::new(),\n         root_path: String::new(),\n@@ -392,7 +398,7 @@ pub fn run(mut krate: clean::Crate,\n     cx.krate(krate, summary)\n }\n \n-fn build_index(krate: &clean::Crate, cache: &mut Cache) -> old_io::IoResult<String> {\n+fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n     // Build the search index from the collected metadata\n     let mut nodeid_to_pathid = HashMap::new();\n     let mut pathid_to_nodeid = Vec::new();\n@@ -437,7 +443,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> old_io::IoResult<Stri\n     }\n \n     // Collect the index into a string\n-    let mut w = Vec::new();\n+    let mut w = io::Cursor::new(Vec::new());\n     try!(write!(&mut w, r#\"searchIndex['{}'] = {{\"items\":[\"#, krate.name));\n \n     let mut lastpath = \"\".to_string();\n@@ -480,13 +486,13 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> old_io::IoResult<Stri\n \n     try!(write!(&mut w, \"]}};\"));\n \n-    Ok(String::from_utf8(w).unwrap())\n+    Ok(String::from_utf8(w.into_inner()).unwrap())\n }\n \n fn write_shared(cx: &Context,\n                 krate: &clean::Crate,\n                 cache: &Cache,\n-                search_index: String) -> old_io::IoResult<()> {\n+                search_index: String) -> io::Result<()> {\n     // Write out the shared files. Note that these are shared among all rustdoc\n     // docs placed in the output directory, so this needs to be a synchronized\n     // operation with respect to all other rustdocs running around.\n@@ -518,10 +524,10 @@ fn write_shared(cx: &Context,\n                include_bytes!(\"static/SourceCodePro-Semibold.woff\")));\n \n     fn collect(path: &Path, krate: &str,\n-               key: &str) -> old_io::IoResult<Vec<String>> {\n+               key: &str) -> io::Result<Vec<String>> {\n         let mut ret = Vec::new();\n         if path.exists() {\n-            for line in BufferedReader::new(File::open(path)).lines() {\n+            for line in BufReader::new(try!(File::open(path))).lines() {\n                 let line = try!(line);\n                 if !line.starts_with(key) {\n                     continue\n@@ -567,14 +573,14 @@ fn write_shared(cx: &Context,\n             mydst.push(part);\n             try!(mkdir(&mydst));\n         }\n-        mydst.push(format!(\"{}.{}.js\",\n-                           remote_item_type.to_static_str(),\n-                           remote_path[remote_path.len() - 1]));\n+        mydst.push(&format!(\"{}.{}.js\",\n+                            remote_item_type.to_static_str(),\n+                            remote_path[remote_path.len() - 1]));\n         let all_implementors = try!(collect(&mydst, &krate.name,\n                                             \"implementors\"));\n \n-        try!(mkdir(&mydst.dir_path()));\n-        let mut f = BufferedWriter::new(try!(File::create(&mydst)));\n+        try!(mkdir(mydst.parent().unwrap()));\n+        let mut f = BufWriter::new(try!(File::create(&mydst)));\n         try!(writeln!(&mut f, \"(function() {{var implementors = {{}};\"));\n \n         for implementor in &all_implementors {\n@@ -606,7 +612,7 @@ fn write_shared(cx: &Context,\n }\n \n fn render_sources(cx: &mut Context,\n-                  krate: clean::Crate) -> old_io::IoResult<clean::Crate> {\n+                  krate: clean::Crate) -> io::Result<clean::Crate> {\n     info!(\"emitting source files\");\n     let dst = cx.dst.join(\"src\");\n     try!(mkdir(&dst));\n@@ -624,15 +630,15 @@ fn render_sources(cx: &mut Context,\n \n /// Writes the entire contents of a string to a destination, not attempting to\n /// catch any errors.\n-fn write(dst: Path, contents: &[u8]) -> old_io::IoResult<()> {\n-    File::create(&dst).write_all(contents)\n+fn write(dst: PathBuf, contents: &[u8]) -> io::Result<()> {\n+    try!(File::create(&dst)).write_all(contents)\n }\n \n /// Makes a directory on the filesystem, failing the task if an error occurs and\n /// skipping if the directory already exists.\n-fn mkdir(path: &Path) -> old_io::IoResult<()> {\n+fn mkdir(path: &Path) -> io::Result<()> {\n     if !path.exists() {\n-        fs::mkdir(path, old_io::USER_RWX)\n+        fs::create_dir(path)\n     } else {\n         Ok(())\n     }\n@@ -648,21 +654,17 @@ fn shortty(item: &clean::Item) -> ItemType {\n /// static HTML tree.\n // FIXME (#9639): The closure should deal with &[u8] instead of &str\n // FIXME (#9639): This is too conservative, rejecting non-UTF-8 paths\n-fn clean_srcpath<F>(src_root: &Path, src: &[u8], mut f: F) where\n+fn clean_srcpath<F>(src_root: &Path, p: &Path, mut f: F) where\n     F: FnMut(&str),\n {\n-    let p = Path::new(src);\n-\n     // make it relative, if possible\n-    let p = p.path_relative_from(src_root).unwrap_or(p);\n+    let p = p.relative_from(src_root).unwrap_or(p);\n \n-    if p.as_vec() != b\".\" {\n-        for c in p.str_components().map(|x|x.unwrap()) {\n-            if \"..\" == c {\n-                f(\"up\");\n-            } else {\n-                f(c)\n-            }\n+    for c in p.iter().map(|x| x.to_str().unwrap()) {\n+        if \"..\" == c {\n+            f(\"up\");\n+        } else {\n+            f(c)\n         }\n     }\n }\n@@ -733,13 +735,14 @@ impl<'a> DocFolder for SourceCollector<'a> {\n \n impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n-    fn emit_source(&mut self, filename: &str) -> old_io::IoResult<()> {\n-        let p = Path::new(filename);\n+    fn emit_source(&mut self, filename: &str) -> io::Result<()> {\n+        let p = PathBuf::new(filename);\n \n         // If we couldn't open this file, then just returns because it\n         // probably means that it's some standard library macro thing and we\n         // can't have the source to it anyway.\n-        let contents = match File::open(&p).read_to_end() {\n+        let mut contents = Vec::new();\n+        match File::open(&p).and_then(|mut f| f.read_to_end(&mut contents)) {\n             Ok(r) => r,\n             // macros from other libraries get special filenames which we can\n             // safely ignore\n@@ -759,18 +762,20 @@ impl<'a> SourceCollector<'a> {\n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n         let mut root_path = String::from_str(\"../../\");\n-        clean_srcpath(&self.cx.src_root, p.dirname(), |component| {\n+        clean_srcpath(&self.cx.src_root, &p, |component| {\n             cur.push(component);\n             mkdir(&cur).unwrap();\n             root_path.push_str(\"../\");\n         });\n \n-        let mut fname = p.filename().expect(\"source has no filename\").to_vec();\n-        fname.extend(\".html\".bytes());\n-        cur.push(fname);\n-        let mut w = BufferedWriter::new(try!(File::create(&cur)));\n+        let mut fname = p.file_name().expect(\"source has no filename\")\n+                         .to_os_string();\n+        fname.push_os_str(OsStr::from_str(\".html\"));\n+        cur.push(&fname);\n+        let mut w = BufWriter::new(try!(File::create(&cur)));\n \n-        let title = format!(\"{} -- source\", cur.filename_display());\n+        let title = format!(\"{} -- source\", cur.file_name().unwrap()\n+                                               .to_string_lossy());\n         let desc = format!(\"Source to the Rust file `{}`.\", filename);\n         let page = layout::Page {\n             title: &title,\n@@ -779,7 +784,7 @@ impl<'a> SourceCollector<'a> {\n             description: &desc,\n             keywords: get_basic_keywords(),\n         };\n-        try!(layout::render(&mut w as &mut Writer, &self.cx.layout,\n+        try!(layout::render(&mut w, &self.cx.layout,\n                             &page, &(\"\"), &Source(contents)));\n         try!(w.flush());\n         return Ok(());\n@@ -1081,7 +1086,7 @@ impl Context {\n     /// This currently isn't parallelized, but it'd be pretty easy to add\n     /// parallelization to this function.\n     fn krate(mut self, mut krate: clean::Crate,\n-             stability: stability_summary::ModuleSummary) -> old_io::IoResult<()> {\n+             stability: stability_summary::ModuleSummary) -> io::Result<()> {\n         let mut item = match krate.module.take() {\n             Some(i) => i,\n             None => return Ok(())\n@@ -1091,7 +1096,7 @@ impl Context {\n         // render stability dashboard\n         try!(self.recurse(stability.name.clone(), |this| {\n             let json_dst = &this.dst.join(\"stability.json\");\n-            let mut json_out = BufferedWriter::new(try!(File::create(json_dst)));\n+            let mut json_out = BufWriter::new(try!(File::create(json_dst)));\n             try!(write!(&mut json_out, \"{}\", json::as_json(&stability)));\n \n             let mut title = stability.name.clone();\n@@ -1106,7 +1111,7 @@ impl Context {\n                 keywords: get_basic_keywords(),\n             };\n             let html_dst = &this.dst.join(\"stability.html\");\n-            let mut html_out = BufferedWriter::new(try!(File::create(html_dst)));\n+            let mut html_out = BufWriter::new(try!(File::create(html_dst)));\n             layout::render(&mut html_out, &this.layout, &page,\n                            &Sidebar{ cx: this, item: &item },\n                            &stability)\n@@ -1131,12 +1136,12 @@ impl Context {\n     /// all sub-items which need to be rendered.\n     ///\n     /// The rendering driver uses this closure to queue up more work.\n-    fn item<F>(&mut self, item: clean::Item, mut f: F) -> old_io::IoResult<()> where\n+    fn item<F>(&mut self, item: clean::Item, mut f: F) -> io::Result<()> where\n         F: FnMut(&mut Context, clean::Item),\n     {\n-        fn render(w: old_io::File, cx: &Context, it: &clean::Item,\n-                  pushname: bool) -> old_io::IoResult<()> {\n-            info!(\"Rendering an item to {}\", w.path().display());\n+        fn render(w: File, cx: &Context, it: &clean::Item,\n+                  pushname: bool) -> io::Result<()> {\n+            info!(\"Rendering an item to {}\", w.path().unwrap().display());\n             // A little unfortunate that this is done like this, but it sure\n             // does make formatting *a lot* nicer.\n             CURRENT_LOCATION_KEY.with(|slot| {\n@@ -1177,7 +1182,7 @@ impl Context {\n             // We have a huge number of calls to write, so try to alleviate some\n             // of the pain by using a buffered writer instead of invoking the\n             // write syscall all the time.\n-            let mut writer = BufferedWriter::new(w);\n+            let mut writer = BufWriter::new(w);\n             if !cx.render_redirect_pages {\n                 try!(layout::render(&mut writer, &cx.layout, &page,\n                                     &Sidebar{ cx: cx, item: it },\n@@ -1238,7 +1243,7 @@ impl Context {\n             // Things which don't have names (like impls) don't get special\n             // pages dedicated to them.\n             _ if item.name.is_some() => {\n-                let dst = self.dst.join(item_path(&item));\n+                let dst = self.dst.join(&item_path(&item));\n                 let dst = try!(File::create(&dst));\n                 render(dst, self, &item, true)\n             }\n@@ -1307,7 +1312,7 @@ impl<'a> Item<'a> {\n         // has anchors for the line numbers that we're linking to.\n         if ast_util::is_local(self.item.def_id) {\n             let mut path = Vec::new();\n-            clean_srcpath(&cx.src_root, self.item.source.filename.as_bytes(),\n+            clean_srcpath(&cx.src_root, Path::new(&self.item.source.filename),\n                           |component| {\n                 path.push(component.to_string());\n             });"}, {"sha": "b4522ad680b77a7e128ec2fded45729c007ad0d3", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -34,6 +34,10 @@\n #![feature(test)]\n #![feature(unicode)]\n #![feature(str_words)]\n+#![feature(io)]\n+#![feature(fs)]\n+#![feature(path)]\n+#![feature(tempdir)]\n \n extern crate arena;\n extern crate getopts;\n@@ -53,10 +57,12 @@ extern crate \"serialize\" as rustc_serialize; // used by deriving\n use std::cell::RefCell;\n use std::collections::HashMap;\n use std::env;\n-use std::old_io::File;\n-use std::old_io;\n+use std::fs::File;\n+use std::io::{self, Read, Write};\n+use std::path::PathBuf;\n use std::rc::Rc;\n use std::sync::mpsc::channel;\n+\n use externalfiles::ExternalHtml;\n use serialize::Decodable;\n use serialize::json::{self, Json};\n@@ -242,7 +248,7 @@ pub fn main_args(args: &[String]) -> int {\n     let should_test = matches.opt_present(\"test\");\n     let markdown_input = input.ends_with(\".md\") || input.ends_with(\".markdown\");\n \n-    let output = matches.opt_str(\"o\").map(|s| Path::new(s));\n+    let output = matches.opt_str(\"o\").map(|s| PathBuf::new(&s));\n     let cfgs = matches.opt_strs(\"cfg\");\n \n     let external_html = match ExternalHtml::load(\n@@ -261,7 +267,8 @@ pub fn main_args(args: &[String]) -> int {\n         (true, false) => {\n             return test::run(input, cfgs, libs, externs, test_args, crate_name)\n         }\n-        (false, true) => return markdown::render(input, output.unwrap_or(Path::new(\"doc\")),\n+        (false, true) => return markdown::render(input,\n+                                                 output.unwrap_or(PathBuf::new(\"doc\")),\n                                                  &matches, &external_html,\n                                                  !matches.opt_present(\"markdown-no-toc\")),\n         (false, false) => {}\n@@ -278,15 +285,16 @@ pub fn main_args(args: &[String]) -> int {\n     info!(\"going to format\");\n     match matches.opt_str(\"w\").as_ref().map(|s| &**s) {\n         Some(\"html\") | None => {\n-            match html::render::run(krate, &external_html, output.unwrap_or(Path::new(\"doc\")),\n+            match html::render::run(krate, &external_html,\n+                                    output.unwrap_or(PathBuf::new(\"doc\")),\n                                     passes.into_iter().collect()) {\n                 Ok(()) => {}\n                 Err(e) => panic!(\"failed to generate documentation: {}\", e),\n             }\n         }\n         Some(\"json\") => {\n             match json_output(krate, json_plugins,\n-                              output.unwrap_or(Path::new(\"doc.json\"))) {\n+                              output.unwrap_or(PathBuf::new(\"doc.json\"))) {\n                 Ok(()) => {}\n                 Err(e) => panic!(\"failed to write json: {}\", e),\n             }\n@@ -364,15 +372,15 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     let cfgs = matches.opt_strs(\"cfg\");\n     let triple = matches.opt_str(\"target\");\n \n-    let cr = Path::new(cratefile);\n+    let cr = PathBuf::new(cratefile);\n     info!(\"starting to run rustc\");\n \n     let (tx, rx) = channel();\n     std::thread::spawn(move || {\n         use rustc::session::config::Input;\n \n-        let cr = cr;\n-        tx.send(core::run_core(paths, cfgs, externs, Input::File(cr), triple)).unwrap();\n+        tx.send(core::run_core(paths, cfgs, externs, Input::File(cr),\n+                               triple)).unwrap();\n     }).join().map_err(|_| \"rustc failed\").unwrap();\n     let (mut krate, analysis) = rx.recv().unwrap();\n     info!(\"finished with rustc\");\n@@ -451,13 +459,12 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, String> {\n-    let mut input = match File::open(&Path::new(input)) {\n-        Ok(f) => f,\n-        Err(e) => {\n-            return Err(format!(\"couldn't open {}: {}\", input, e))\n-        }\n+    let mut bytes = Vec::new();\n+    match File::open(input).and_then(|mut f| f.read_to_end(&mut bytes)) {\n+        Ok(()) => {}\n+        Err(e) => return Err(format!(\"couldn't open {}: {}\", input, e)),\n     };\n-    match json::from_reader(&mut input) {\n+    match json::from_reader(&mut &bytes[..]) {\n         Err(s) => Err(format!(\"{:?}\", s)),\n         Ok(Json::Object(obj)) => {\n             let mut obj = obj;\n@@ -495,7 +502,7 @@ fn json_input(input: &str) -> Result<Output, String> {\n /// Outputs the crate/plugin json as a giant json blob at the specified\n /// destination.\n fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n-               dst: Path) -> old_io::IoResult<()> {\n+               dst: PathBuf) -> io::Result<()> {\n     // {\n     //   \"schema\": version,\n     //   \"crate\": { parsed crate ... },"}, {"sha": "7d635c8b2327481f609130157e366566004403a5", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -8,7 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::fs::File;\n+use std::io::Write;\n use std::old_io;\n+use std::path::{PathBuf, Path};\n \n use core;\n use getopts;\n@@ -40,10 +43,10 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n \n /// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n /// (e.g. output = \"bar\" => \"bar/foo.html\").\n-pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n+pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n               external_html: &ExternalHtml, include_toc: bool) -> int {\n     let input_p = Path::new(input);\n-    output.push(input_p.filestem().unwrap());\n+    output.push(input_p.file_stem().unwrap());\n     output.set_extension(\"html\");\n \n     let mut css = String::new();\n@@ -59,7 +62,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n     }\n     let playground = playground.unwrap_or(\"\".to_string());\n \n-    let mut out = match old_io::File::create(&output) {\n+    let mut out = match File::create(&output) {\n         Err(e) => {\n             let _ = writeln!(&mut old_io::stderr(),\n                              \"error opening `{}` for writing: {}\","}, {"sha": "9fd38ecb13627f07ee721b931b80da2061ff7a07", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -9,16 +9,20 @@\n // except according to those terms.\n \n use std::cell::RefCell;\n-use std::sync::mpsc::channel;\n+use std::collections::{HashSet, HashMap};\n use std::dynamic_lib::DynamicLibrary;\n-use std::old_io::{Command, TempDir};\n+use std::env;\n+use std::ffi::OsString;\n+use std::fs::TempDir;\n use std::old_io;\n-use std::os;\n+use std::io;\n+use std::path::PathBuf;\n+use std::process::Command;\n use std::str;\n+use std::sync::mpsc::channel;\n use std::thread;\n use std::thunk::Thunk;\n \n-use std::collections::{HashSet, HashMap};\n use testing;\n use rustc_lint;\n use rustc::session::{self, config};\n@@ -43,11 +47,12 @@ pub fn run(input: &str,\n            mut test_args: Vec<String>,\n            crate_name: Option<String>)\n            -> int {\n-    let input_path = Path::new(input);\n+    let input_path = PathBuf::new(input);\n     let input = config::Input::File(input_path.clone());\n \n     let sessopts = config::Options {\n-        maybe_sysroot: Some(os::self_exe_name().unwrap().dir_path().dir_path()),\n+        maybe_sysroot: Some(env::current_exe().unwrap().parent().unwrap()\n+                                              .parent().unwrap().to_path_buf()),\n         search_paths: libs.clone(),\n         crate_types: vec!(config::CrateTypeDylib),\n         externs: externs.clone(),\n@@ -115,7 +120,8 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     let input = config::Input::Str(test.to_string());\n \n     let sessopts = config::Options {\n-        maybe_sysroot: Some(os::self_exe_name().unwrap().dir_path().dir_path()),\n+        maybe_sysroot: Some(env::current_exe().unwrap().parent().unwrap()\n+                                              .parent().unwrap().to_path_buf()),\n         search_paths: libs,\n         crate_types: vec!(config::CrateTypeExecutable),\n         output_types: vec!(config::OutputTypeExe),\n@@ -170,7 +176,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let outdir = TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\");\n-    let out = Some(outdir.path().clone());\n+    let out = Some(outdir.path().to_path_buf());\n     let cfg = config::build_configuration(&sess);\n     let libdir = sess.target_filesearch(PathKind::All).get_lib_path();\n     let mut control = driver::CompileController::basic();\n@@ -187,25 +193,27 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     // environment to ensure that the target loads the right libraries at\n     // runtime. It would be a sad day if the *host* libraries were loaded as a\n     // mistake.\n-    let mut cmd = Command::new(outdir.path().join(\"rust-out\"));\n+    let mut cmd = Command::new(&outdir.path().join(\"rust-out\"));\n+    let var = DynamicLibrary::envvar();\n     let newpath = {\n-        let mut path = DynamicLibrary::search_path();\n+        let path = env::var_os(var).unwrap_or(OsString::new());\n+        let mut path = env::split_paths(&path).collect::<Vec<_>>();\n         path.insert(0, libdir.clone());\n-        DynamicLibrary::create_path(&path)\n+        env::join_paths(path.iter()).unwrap()\n     };\n-    cmd.env(DynamicLibrary::envvar(), newpath);\n+    cmd.env(var, &newpath);\n \n     match cmd.output() {\n         Err(e) => panic!(\"couldn't run the test: {}{}\", e,\n-                        if e.kind == old_io::PermissionDenied {\n+                        if e.kind() == io::ErrorKind::PermissionDenied {\n                             \" - maybe your tempdir is mounted with noexec?\"\n                         } else { \"\" }),\n         Ok(out) => {\n             if should_fail && out.status.success() {\n                 panic!(\"test executable succeeded when it should have failed\");\n             } else if !should_fail && !out.status.success() {\n                 panic!(\"test executable failed:\\n{:?}\",\n-                      str::from_utf8(&out.error));\n+                      str::from_utf8(&out.stdout));\n             }\n         }\n     }"}, {"sha": "bfc6b1bf0ef13ba5729ae98c84b0ffcf2afcc092", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -35,6 +35,7 @@ Core encoding and decoding interfaces.\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n+#![feature(path)]\n #![cfg_attr(test, feature(test))]\n \n // test harness access"}, {"sha": "f287229e0830db19fc9a96a2e499fde9e6c3a9d8", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -15,6 +15,7 @@ Core encoding and decoding interfaces.\n */\n \n use std::old_path;\n+use std::path;\n use std::rc::Rc;\n use std::cell::{Cell, RefCell};\n use std::sync::Arc;\n@@ -564,6 +565,19 @@ impl Decodable for old_path::windows::Path {\n     }\n }\n \n+impl Encodable for path::PathBuf {\n+    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n+        self.to_str().unwrap().encode(e)\n+    }\n+}\n+\n+impl Decodable for path::PathBuf {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<path::PathBuf, D::Error> {\n+        let bytes: String = try!(Decodable::decode(d));\n+        Ok(path::PathBuf::new(&bytes))\n+    }\n+}\n+\n impl<T: Encodable + Copy> Encodable for Cell<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         self.get().encode(s)"}, {"sha": "9a34ec4b026398d2674a7d0279091e48cb659f77", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -82,6 +82,8 @@ use sys_common;\n /// attempted against it for which its underlying file descriptor was not\n /// configured at creation time, via the `FileAccess` parameter to\n /// `File::open_mode()`.\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::File\")]\n+#[unstable(feature = \"old_io\")]\n pub struct File {\n     fd: fs_imp::FileDesc,\n     path: Path,\n@@ -94,6 +96,8 @@ impl sys_common::AsInner<fs_imp::FileDesc> for File {\n     }\n }\n \n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n+#[unstable(feature = \"old_io\")]\n impl File {\n     /// Open a file at `path` in the mode specified by the `mode` and `access`\n     /// arguments\n@@ -133,6 +137,8 @@ impl File {\n     /// * Attempting to open a file with a `FileAccess` that the user lacks\n     ///   permissions for\n     /// * Filesystem-level errors (full disk, etc)\n+    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::OpenOptions\")]\n+    #[unstable(feature = \"old_io\")]\n     pub fn open_mode(path: &Path,\n                      mode: FileMode,\n                      access: FileAccess) -> IoResult<File> {\n@@ -174,6 +180,8 @@ impl File {\n     ///\n     /// let contents = File::open(&Path::new(\"foo.txt\")).read_to_end();\n     /// ```\n+    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::File::open\")]\n+    #[unstable(feature = \"old_io\")]\n     pub fn open(path: &Path) -> IoResult<File> {\n         File::open_mode(path, Open, Read)\n     }\n@@ -195,19 +203,25 @@ impl File {\n     /// # drop(f);\n     /// # ::std::old_io::fs::unlink(&Path::new(\"foo.txt\"));\n     /// ```\n+    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::File::create\")]\n+    #[unstable(feature = \"old_io\")]\n     pub fn create(path: &Path) -> IoResult<File> {\n         File::open_mode(path, Truncate, Write)\n              .update_desc(\"couldn't create file\")\n     }\n \n     /// Returns the original path that was used to open this file.\n+    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n+    #[unstable(feature = \"old_io\")]\n     pub fn path<'a>(&'a self) -> &'a Path {\n         &self.path\n     }\n \n     /// Synchronizes all modifications to this file to its permanent storage\n     /// device. This will flush any internal buffers necessary to perform this\n     /// operation.\n+    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n+    #[unstable(feature = \"old_io\")]\n     pub fn fsync(&mut self) -> IoResult<()> {\n         self.fd.fsync()\n             .update_err(\"couldn't fsync file\",\n@@ -218,6 +232,8 @@ impl File {\n     /// file metadata to the filesystem. This is intended for use cases that\n     /// must synchronize content, but don't need the metadata on disk. The goal\n     /// of this method is to reduce disk operations.\n+    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n+    #[unstable(feature = \"old_io\")]\n     pub fn datasync(&mut self) -> IoResult<()> {\n         self.fd.datasync()\n             .update_err(\"couldn't datasync file\",\n@@ -232,6 +248,8 @@ impl File {\n     /// be shrunk. If it is greater than the current file's size, then the file\n     /// will be extended to `size` and have all of the intermediate data filled\n     /// in with 0s.\n+    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n+    #[unstable(feature = \"old_io\")]\n     pub fn truncate(&mut self, size: i64) -> IoResult<()> {\n         self.fd.truncate(size)\n             .update_err(\"couldn't truncate file\", |e|\n@@ -247,11 +265,15 @@ impl File {\n     /// until you have attempted to read past the end of the file, so if\n     /// you've read _exactly_ the number of bytes in the file, this will\n     /// return `false`, not `true`.\n+    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n+    #[unstable(feature = \"old_io\")]\n     pub fn eof(&self) -> bool {\n         self.last_nread == 0\n     }\n \n     /// Queries information about the underlying file.\n+    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n+    #[unstable(feature = \"old_io\")]\n     pub fn stat(&self) -> IoResult<FileStat> {\n         self.fd.fstat()\n             .update_err(\"couldn't fstat file\", |e|\n@@ -280,6 +302,8 @@ impl File {\n /// This function will return an error if `path` points to a directory, if the\n /// user lacks permissions to remove the file, or if some other filesystem-level\n /// error occurs.\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::remove_file\")]\n+#[unstable(feature = \"old_io\")]\n pub fn unlink(path: &Path) -> IoResult<()> {\n     fs_imp::unlink(path)\n            .update_err(\"couldn't unlink path\", |e|\n@@ -307,6 +331,8 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n /// This function will return an error if the user lacks the requisite permissions\n /// to perform a `stat` call on the given `path` or if there is no entry in the\n /// filesystem at the provided path.\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::metadata\")]\n+#[unstable(feature = \"old_io\")]\n pub fn stat(path: &Path) -> IoResult<FileStat> {\n     fs_imp::stat(path)\n            .update_err(\"couldn't stat path\", |e|\n@@ -321,6 +347,7 @@ pub fn stat(path: &Path) -> IoResult<FileStat> {\n /// # Error\n ///\n /// See `stat`\n+#[unstable(feature = \"old_fs\")]\n pub fn lstat(path: &Path) -> IoResult<FileStat> {\n     fs_imp::lstat(path)\n            .update_err(\"couldn't lstat path\", |e|\n@@ -343,6 +370,8 @@ pub fn lstat(path: &Path) -> IoResult<FileStat> {\n /// This function will return an error if the provided `from` doesn't exist, if\n /// the process lacks permissions to view the contents, or if some other\n /// intermittent I/O error occurs.\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::rename\")]\n+#[unstable(feature = \"old_io\")]\n pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n     fs_imp::rename(from, to)\n            .update_err(\"couldn't rename path\", |e|\n@@ -377,6 +406,8 @@ pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n /// Note that this copy is not atomic in that once the destination is\n /// ensured to not exist, there is nothing preventing the destination from\n /// being created and then destroyed by this operation.\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::copy\")]\n+#[unstable(feature = \"old_io\")]\n pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n     fn update_err<T>(result: IoResult<T>, from: &Path, to: &Path) -> IoResult<T> {\n         result.update_err(\"couldn't copy path\", |e| {\n@@ -421,13 +452,16 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n /// This function will return an error if the provided `path` doesn't exist, if\n /// the process lacks permissions to change the attributes of the file, or if\n /// some other I/O error is encountered.\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::set_permissions\")]\n+#[unstable(feature = \"old_io\")]\n pub fn chmod(path: &Path, mode: old_io::FilePermission) -> IoResult<()> {\n     fs_imp::chmod(path, mode.bits() as uint)\n            .update_err(\"couldn't chmod path\", |e|\n                format!(\"{}; path={}; mode={:?}\", e, path.display(), mode))\n }\n \n /// Change the user and group owners of a file at the specified path.\n+#[unstable(feature = \"old_fs\")]\n pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n     fs_imp::chown(path, uid, gid)\n            .update_err(\"couldn't chown path\", |e|\n@@ -437,6 +471,8 @@ pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n /// Creates a new hard link on the filesystem. The `dst` path will be a\n /// link pointing to the `src` path. Note that systems often require these\n /// two paths to both be located on the same filesystem.\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::hard_link\")]\n+#[unstable(feature = \"old_io\")]\n pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n     fs_imp::link(src, dst)\n            .update_err(\"couldn't link path\", |e|\n@@ -445,6 +481,8 @@ pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n /// symlink pointing to the `src` path.\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::soft_link\")]\n+#[unstable(feature = \"old_io\")]\n pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n     fs_imp::symlink(src, dst)\n            .update_err(\"couldn't symlink path\", |e|\n@@ -457,6 +495,8 @@ pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n ///\n /// This function will return an error on failure. Failure conditions include\n /// reading a file that does not exist or reading a file that is not a symlink.\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::read_link\")]\n+#[unstable(feature = \"old_io\")]\n pub fn readlink(path: &Path) -> IoResult<Path> {\n     fs_imp::readlink(path)\n            .update_err(\"couldn't resolve symlink for path\", |e|\n@@ -480,6 +520,7 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n ///\n /// This function will return an error if the user lacks permissions to make a\n /// new directory at the provided `path`, or if the directory already exists.\n+#[unstable(feature = \"old_fs\")]\n pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n     fs_imp::mkdir(path, mode.bits() as uint)\n            .update_err(\"couldn't create directory\", |e|\n@@ -502,6 +543,8 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n ///\n /// This function will return an error if the user lacks permissions to remove\n /// the directory at the provided `path`, or if the directory isn't empty.\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::remove_dir\")]\n+#[unstable(feature = \"old_io\")]\n pub fn rmdir(path: &Path) -> IoResult<()> {\n     fs_imp::rmdir(path)\n            .update_err(\"couldn't remove directory\", |e|\n@@ -542,6 +585,8 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n /// This function will return an error if the provided `path` doesn't exist, if\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::read_dir\")]\n+#[unstable(feature = \"old_io\")]\n pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n     fs_imp::readdir(path)\n            .update_err(\"couldn't read directory\",\n@@ -552,6 +597,8 @@ pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n /// rooted at `path`. The path given will not be iterated over, and this will\n /// perform iteration in some top-down order.  The contents of unreadable\n /// subdirectories are ignored.\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::walk_dir\")]\n+#[unstable(feature = \"old_io\")]\n pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n     Ok(Directories {\n         stack: try!(readdir(path).update_err(\"couldn't walk directory\",\n@@ -561,6 +608,8 @@ pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n \n /// An iterator that walks over a directory\n #[derive(Clone)]\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::ReadDir\")]\n+#[unstable(feature = \"old_io\")]\n pub struct Directories {\n     stack: Vec<Path>,\n }\n@@ -590,6 +639,7 @@ impl Iterator for Directories {\n /// # Error\n ///\n /// See `fs::mkdir`.\n+#[unstable(feature = \"old_fs\")]\n pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n     // tjc: if directory exists but with different permissions,\n     // should we return false?\n@@ -627,6 +677,8 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n /// # Error\n ///\n /// See `file::unlink` and `fs::readdir`\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::remove_dir_all\")]\n+#[unstable(feature = \"old_io\")]\n pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n     let mut rm_stack = Vec::new();\n     rm_stack.push(path.clone());\n@@ -689,6 +741,8 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n /// `atime` and its modification time set to `mtime`. The times specified should\n /// be in milliseconds.\n // FIXME(#10301) these arguments should not be u64\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::set_file_times\")]\n+#[unstable(feature = \"old_io\")]\n pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n     fs_imp::utime(path, atime, mtime)\n            .update_err(\"couldn't change_file_times\", |e|\n@@ -748,6 +802,8 @@ impl Seek for File {\n }\n \n /// Utility methods for paths.\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::PathExt\")]\n+#[unstable(feature = \"old_io\")]\n pub trait PathExtensions {\n     /// Get information on the file, directory, etc at this path.\n     ///"}, {"sha": "45042d6f0325508cce167321e216e64f150d4597", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -54,6 +54,7 @@ pub trait AsRawFd {\n     fn as_raw_fd(&self) -> Fd;\n }\n \n+#[allow(deprecated)]\n impl AsRawFd for old_io::fs::File {\n     fn as_raw_fd(&self) -> Fd {\n         self.as_inner().fd()"}, {"sha": "df18b404f5fe9e06f4facee997626787e13cffab", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -39,6 +39,7 @@ pub trait AsRawHandle {\n     fn as_raw_handle(&self) -> Handle;\n }\n \n+#[allow(deprecated)]\n impl AsRawHandle for old_io::fs::File {\n     fn as_raw_handle(&self) -> Handle {\n         self.as_inner().handle()"}, {"sha": "53a037ef07e613a15f30a4e926567078359d4595", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -17,7 +17,7 @@ use hash::Hash;\n use libc::{pid_t, c_void};\n use libc;\n use mem;\n-use old_io::fs::PathExtensions;\n+#[allow(deprecated)] use old_io::fs::PathExtensions;\n use old_io::process::{ProcessExit, ExitStatus};\n use old_io::{IoResult, IoError};\n use old_io;"}, {"sha": "faa681c0255285ccab0a12e1f49f05d5d7e3cf34", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -25,7 +25,7 @@ use visit::{self, Visitor};\n use arena::TypedArena;\n use std::cell::RefCell;\n use std::fmt;\n-use std::old_io::IoResult;\n+use std::io;\n use std::iter::{self, repeat};\n use std::mem;\n use std::slice;\n@@ -997,11 +997,11 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n }\n \n pub trait NodePrinter {\n-    fn print_node(&mut self, node: &Node) -> IoResult<()>;\n+    fn print_node(&mut self, node: &Node) -> io::Result<()>;\n }\n \n impl<'a> NodePrinter for pprust::State<'a> {\n-    fn print_node(&mut self, node: &Node) -> IoResult<()> {\n+    fn print_node(&mut self, node: &Node) -> io::Result<()> {\n         match *node {\n             NodeItem(a)        => self.print_item(&*a),\n             NodeForeignItem(a) => self.print_foreign_item(&*a),"}, {"sha": "62d98be8b8505e9bca2d0f7f9f64b815f0ef7672", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -20,7 +20,9 @@ use print::pprust;\n use ptr::P;\n use util::small_vector::SmallVector;\n \n-use std::old_io::File;\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::path::{Path, PathBuf};\n use std::rc::Rc;\n \n // These macros all relate to the file system; they either return\n@@ -97,7 +99,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree\n                                         cx.cfg(),\n                                         &res_rel_file(cx,\n                                                       sp,\n-                                                      &Path::new(file)),\n+                                                      Path::new(&file)),\n                                         true,\n                                         None,\n                                         sp);\n@@ -136,16 +138,17 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         Some(f) => f,\n         None => return DummyResult::expr(sp)\n     };\n-    let file = res_rel_file(cx, sp, &Path::new(file));\n-    let bytes = match File::open(&file).read_to_end() {\n+    let file = res_rel_file(cx, sp, Path::new(&file));\n+    let mut bytes = Vec::new();\n+    match File::open(&file).and_then(|mut f| f.read_to_end(&mut bytes)) {\n+        Ok(..) => {}\n         Err(e) => {\n             cx.span_err(sp,\n                         &format!(\"couldn't read {}: {}\",\n                                 file.display(),\n                                 e));\n             return DummyResult::expr(sp);\n         }\n-        Ok(bytes) => bytes,\n     };\n     match String::from_utf8(bytes) {\n         Ok(src) => {\n@@ -172,30 +175,34 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         Some(f) => f,\n         None => return DummyResult::expr(sp)\n     };\n-    let file = res_rel_file(cx, sp, &Path::new(file));\n-    match File::open(&file).read_to_end() {\n+    let file = res_rel_file(cx, sp, Path::new(&file));\n+    let mut bytes = Vec::new();\n+    match File::open(&file).and_then(|mut f| f.read_to_end(&mut bytes)) {\n         Err(e) => {\n             cx.span_err(sp,\n                         &format!(\"couldn't read {}: {}\", file.display(), e));\n             return DummyResult::expr(sp);\n         }\n-        Ok(bytes) => {\n-            let bytes = bytes.iter().cloned().collect();\n+        Ok(..) => {\n             base::MacEager::expr(cx.expr_lit(sp, ast::LitBinary(Rc::new(bytes))))\n         }\n     }\n }\n \n // resolve a file-system path to an absolute file-system path (if it\n // isn't already)\n-fn res_rel_file(cx: &mut ExtCtxt, sp: codemap::Span, arg: &Path) -> Path {\n+fn res_rel_file(cx: &mut ExtCtxt, sp: codemap::Span, arg: &Path) -> PathBuf {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute() {\n-        let mut cu = Path::new(cx.codemap().span_to_filename(sp));\n-        cu.pop();\n+        let mut cu = PathBuf::new(&cx.codemap().span_to_filename(sp));\n+        if cu.parent().is_some() {\n+            cu.pop();\n+        } else {\n+            cu = PathBuf::new(\"\");\n+        }\n         cu.push(arg);\n         cu\n     } else {\n-        arg.clone()\n+        arg.to_path_buf()\n     }\n }"}, {"sha": "959e3bdb31476afab4b4065226d41b40d03cc4ca", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -1432,7 +1432,7 @@ pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n \n #[cfg(test)]\n mod test {\n-    use std::old_io;\n+    use std::io;\n     use ast;\n     use util::parser_testing::{string_to_crate, matches_codepattern};\n     use parse::token;\n@@ -1442,7 +1442,7 @@ mod test {\n \n     // this version doesn't care about getting comments or docstrings in.\n     fn fake_print_crate(s: &mut pprust::State,\n-                        krate: &ast::Crate) -> old_io::IoResult<()> {\n+                        krate: &ast::Crate) -> io::Result<()> {\n         s.print_mod(&krate.module, &krate.attrs)\n     }\n "}, {"sha": "7bd9cc3b85515dfd733a9c70657848adb88f1f01", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -36,6 +36,9 @@\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n+#![feature(path)]\n+#![feature(fs)]\n+#![feature(io)]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "fb9e0480cebc8b8acdbfdf31691b6ac56bc1de3a", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -19,9 +19,8 @@ use parse::lexer::is_block_doc_comment;\n use parse::lexer;\n use print::pprust;\n \n-use std::old_io;\n+use std::io::Read;\n use std::str;\n-use std::string::String;\n use std::usize;\n \n #[derive(Clone, Copy, PartialEq)]\n@@ -337,9 +336,10 @@ pub struct Literal {\n // probably not a good thing.\n pub fn gather_comments_and_literals(span_diagnostic: &diagnostic::SpanHandler,\n                                     path: String,\n-                                    srdr: &mut old_io::Reader)\n+                                    srdr: &mut Read)\n                                  -> (Vec<Comment>, Vec<Literal>) {\n-    let src = srdr.read_to_end().unwrap();\n+    let mut src = Vec::new();\n+    srdr.read_to_end(&mut src).unwrap();\n     let src = String::from_utf8(src).unwrap();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);"}, {"sha": "def5963e6f4e961ac28e281e1c85838fdcd70c6a", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -18,11 +18,13 @@ use parse::parser::Parser;\n use ptr::P;\n \n use std::cell::{Cell, RefCell};\n-use std::old_io::File;\n-use std::rc::Rc;\n+use std::fs::File;\n+use std::io::Read;\n+use std::iter;\n use std::num::Int;\n+use std::path::{Path, PathBuf};\n+use std::rc::Rc;\n use std::str;\n-use std::iter;\n \n #[macro_use]\n pub mod parser;\n@@ -39,7 +41,7 @@ pub mod obsolete;\n pub struct ParseSess {\n     pub span_diagnostic: SpanHandler, // better be the same as the one in the reader!\n     /// Used to determine and report recursive mod inclusions\n-    included_mod_stack: RefCell<Vec<Path>>,\n+    included_mod_stack: RefCell<Vec<PathBuf>>,\n     pub node_id: Cell<ast::NodeId>,\n }\n \n@@ -250,24 +252,24 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n             None => sess.span_diagnostic.handler().fatal(msg),\n         }\n     };\n-    let bytes = match File::open(path).read_to_end() {\n-        Ok(bytes) => bytes,\n+    let mut bytes = Vec::new();\n+    match File::open(path).and_then(|mut f| f.read_to_end(&mut bytes)) {\n+        Ok(..) => {}\n         Err(e) => {\n-            err(&format!(\"couldn't read {:?}: {}\",\n-                        path.display(), e));\n-            unreachable!()\n+            err(&format!(\"couldn't read {:?}: {}\", path.display(), e));\n+            unreachable!();\n         }\n     };\n     match str::from_utf8(&bytes[..]).ok() {\n         Some(s) => {\n-            return string_to_filemap(sess, s.to_string(),\n-                                     path.as_str().unwrap().to_string())\n+            string_to_filemap(sess, s.to_string(),\n+                              path.to_str().unwrap().to_string())\n         }\n         None => {\n-            err(&format!(\"{:?} is not UTF-8 encoded\", path.display()))\n+            err(&format!(\"{:?} is not UTF-8 encoded\", path.display()));\n+            unreachable!();\n         }\n     }\n-    unreachable!()\n }\n \n /// Given a session and a string, add the string to"}, {"sha": "88df6d6d4cd2fb2bfbf675544be1666dc5de08c9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -78,10 +78,11 @@ use ptr::P;\n use owned_slice::OwnedSlice;\n \n use std::collections::HashSet;\n-use std::old_io::fs::PathExtensions;\n+use std::io::prelude::*;\n use std::iter;\n use std::mem;\n use std::num::Float;\n+use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use std::slice;\n \n@@ -5248,14 +5249,23 @@ impl<'a> Parser<'a> {\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n                     -> (ast::Item_, Vec<ast::Attribute> ) {\n-        let mut prefix = Path::new(self.sess.span_diagnostic.cm.span_to_filename(self.span));\n-        prefix.pop();\n-        let mod_path = Path::new(\".\").join_many(&self.mod_path_stack);\n-        let dir_path = prefix.join(&mod_path);\n+        let mut prefix = PathBuf::new(&self.sess.span_diagnostic.cm\n+                                           .span_to_filename(self.span));\n+        // FIXME(acrichto): right now \"a\".pop() == \"a\", but need to confirm with\n+        //                  aturon whether this is expected or not.\n+        if prefix.parent().is_some() {\n+            prefix.pop();\n+        } else {\n+            prefix = PathBuf::new(\"\");\n+        }\n+        let mut dir_path = prefix;\n+        for part in &self.mod_path_stack {\n+            dir_path.push(&**part);\n+        }\n         let mod_string = token::get_ident(id);\n         let (file_path, owns_directory) = match ::attr::first_attr_value_str_by_name(\n                 outer_attrs, \"path\") {\n-            Some(d) => (dir_path.join(d), true),\n+            Some(d) => (dir_path.join(&*d), true),\n             None => {\n                 let mod_name = mod_string.to_string();\n                 let default_path_str = format!(\"{}.rs\", mod_name);\n@@ -5319,7 +5329,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn eval_src_mod_from_path(&mut self,\n-                              path: Path,\n+                              path: PathBuf,\n                               owns_directory: bool,\n                               name: String,\n                               id_sp: Span) -> (ast::Item_, Vec<ast::Attribute> ) {\n@@ -5329,10 +5339,10 @@ impl<'a> Parser<'a> {\n                 let mut err = String::from_str(\"circular modules: \");\n                 let len = included_mod_stack.len();\n                 for p in &included_mod_stack[i.. len] {\n-                    err.push_str(&p.display().as_cow());\n+                    err.push_str(&p.to_string_lossy());\n                     err.push_str(\" -> \");\n                 }\n-                err.push_str(&path.display().as_cow());\n+                err.push_str(&path.to_string_lossy());\n                 self.span_fatal(id_sp, &err[..]);\n             }\n             None => ()"}, {"sha": "640b7d1c91d503db577ccd3b1bed78392452f759", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -59,7 +59,7 @@\n //! line (which it can't) and so naturally place the content on its own line to\n //! avoid combining it with other lines and making matters even worse.\n \n-use std::old_io;\n+use std::io;\n use std::string;\n use std::iter::repeat;\n \n@@ -161,7 +161,7 @@ pub struct PrintStackElem {\n \n const SIZE_INFINITY: isize = 0xffff;\n \n-pub fn mk_printer(out: Box<old_io::Writer+'static>, linewidth: usize) -> Printer {\n+pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: usize = 3 * linewidth;\n@@ -265,8 +265,8 @@ pub fn mk_printer(out: Box<old_io::Writer+'static>, linewidth: usize) -> Printer\n /// In this implementation (following the paper, again) the SCAN process is\n /// the method called 'pretty_print', and the 'PRINT' process is the method\n /// called 'print'.\n-pub struct Printer {\n-    pub out: Box<old_io::Writer+'static>,\n+pub struct Printer<'a> {\n+    pub out: Box<io::Write+'a>,\n     buf_len: usize,\n     /// Width of lines we're constrained to\n     margin: isize,\n@@ -303,15 +303,15 @@ pub struct Printer {\n     pending_indentation: isize,\n }\n \n-impl Printer {\n+impl<'a> Printer<'a> {\n     pub fn last_token(&mut self) -> Token {\n         self.token[self.right].clone()\n     }\n     // be very careful with this!\n     pub fn replace_last_token(&mut self, t: Token) {\n         self.token[self.right] = t;\n     }\n-    pub fn pretty_print(&mut self, token: Token) -> old_io::IoResult<()> {\n+    pub fn pretty_print(&mut self, token: Token) -> io::Result<()> {\n         debug!(\"pp ~[{},{}]\", self.left, self.right);\n         match token {\n           Token::Eof => {\n@@ -385,7 +385,7 @@ impl Printer {\n           }\n         }\n     }\n-    pub fn check_stream(&mut self) -> old_io::IoResult<()> {\n+    pub fn check_stream(&mut self) -> io::Result<()> {\n         debug!(\"check_stream ~[{}, {}] with left_total={}, right_total={}\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n@@ -445,7 +445,7 @@ impl Printer {\n         self.right %= self.buf_len;\n         assert!((self.right != self.left));\n     }\n-    pub fn advance_left(&mut self) -> old_io::IoResult<()> {\n+    pub fn advance_left(&mut self) -> io::Result<()> {\n         debug!(\"advance_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n                self.left, self.size[self.left]);\n \n@@ -506,7 +506,7 @@ impl Printer {\n             }\n         }\n     }\n-    pub fn print_newline(&mut self, amount: isize) -> old_io::IoResult<()> {\n+    pub fn print_newline(&mut self, amount: isize) -> io::Result<()> {\n         debug!(\"NEWLINE {}\", amount);\n         let ret = write!(self.out, \"\\n\");\n         self.pending_indentation = 0;\n@@ -529,14 +529,14 @@ impl Printer {\n             }\n         }\n     }\n-    pub fn print_str(&mut self, s: &str) -> old_io::IoResult<()> {\n+    pub fn print_str(&mut self, s: &str) -> io::Result<()> {\n         while self.pending_indentation > 0 {\n             try!(write!(self.out, \" \"));\n             self.pending_indentation -= 1;\n         }\n         write!(self.out, \"{}\", s)\n     }\n-    pub fn print(&mut self, token: Token, l: isize) -> old_io::IoResult<()> {\n+    pub fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n         debug!(\"print {} {} (remaining line space={})\", tok_str(&token), l,\n                self.space);\n         debug!(\"{}\", buf_str(&self.token,\n@@ -620,61 +620,61 @@ impl Printer {\n // Convenience functions to talk to the printer.\n //\n // \"raw box\"\n-pub fn rbox(p: &mut Printer, indent: usize, b: Breaks) -> old_io::IoResult<()> {\n+pub fn rbox(p: &mut Printer, indent: usize, b: Breaks) -> io::Result<()> {\n     p.pretty_print(Token::Begin(BeginToken {\n         offset: indent as isize,\n         breaks: b\n     }))\n }\n \n-pub fn ibox(p: &mut Printer, indent: usize) -> old_io::IoResult<()> {\n+pub fn ibox(p: &mut Printer, indent: usize) -> io::Result<()> {\n     rbox(p, indent, Breaks::Inconsistent)\n }\n \n-pub fn cbox(p: &mut Printer, indent: usize) -> old_io::IoResult<()> {\n+pub fn cbox(p: &mut Printer, indent: usize) -> io::Result<()> {\n     rbox(p, indent, Breaks::Consistent)\n }\n \n-pub fn break_offset(p: &mut Printer, n: usize, off: isize) -> old_io::IoResult<()> {\n+pub fn break_offset(p: &mut Printer, n: usize, off: isize) -> io::Result<()> {\n     p.pretty_print(Token::Break(BreakToken {\n         offset: off,\n         blank_space: n as isize\n     }))\n }\n \n-pub fn end(p: &mut Printer) -> old_io::IoResult<()> {\n+pub fn end(p: &mut Printer) -> io::Result<()> {\n     p.pretty_print(Token::End)\n }\n \n-pub fn eof(p: &mut Printer) -> old_io::IoResult<()> {\n+pub fn eof(p: &mut Printer) -> io::Result<()> {\n     p.pretty_print(Token::Eof)\n }\n \n-pub fn word(p: &mut Printer, wrd: &str) -> old_io::IoResult<()> {\n+pub fn word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n     p.pretty_print(Token::String(/* bad */ wrd.to_string(), wrd.len() as isize))\n }\n \n-pub fn huge_word(p: &mut Printer, wrd: &str) -> old_io::IoResult<()> {\n+pub fn huge_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n     p.pretty_print(Token::String(/* bad */ wrd.to_string(), SIZE_INFINITY))\n }\n \n-pub fn zero_word(p: &mut Printer, wrd: &str) -> old_io::IoResult<()> {\n+pub fn zero_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n     p.pretty_print(Token::String(/* bad */ wrd.to_string(), 0))\n }\n \n-pub fn spaces(p: &mut Printer, n: usize) -> old_io::IoResult<()> {\n+pub fn spaces(p: &mut Printer, n: usize) -> io::Result<()> {\n     break_offset(p, n, 0)\n }\n \n-pub fn zerobreak(p: &mut Printer) -> old_io::IoResult<()> {\n+pub fn zerobreak(p: &mut Printer) -> io::Result<()> {\n     spaces(p, 0)\n }\n \n-pub fn space(p: &mut Printer) -> old_io::IoResult<()> {\n+pub fn space(p: &mut Printer) -> io::Result<()> {\n     spaces(p, 1)\n }\n \n-pub fn hardbreak(p: &mut Printer) -> old_io::IoResult<()> {\n+pub fn hardbreak(p: &mut Printer) -> io::Result<()> {\n     spaces(p, SIZE_INFINITY as usize)\n }\n "}, {"sha": "883c2295a3655340107d9a644e70cf7bf4b01d0d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 128, "deletions": 128, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -30,7 +30,7 @@ use ptr::P;\n use std_inject;\n \n use std::{ascii, mem};\n-use std::old_io::{self, IoResult};\n+use std::io::{self, Write, Read};\n use std::iter;\n \n pub enum AnnNode<'a> {\n@@ -43,8 +43,8 @@ pub enum AnnNode<'a> {\n }\n \n pub trait PpAnn {\n-    fn pre(&self, _state: &mut State, _node: AnnNode) -> IoResult<()> { Ok(()) }\n-    fn post(&self, _state: &mut State, _node: AnnNode) -> IoResult<()> { Ok(()) }\n+    fn pre(&self, _state: &mut State, _node: AnnNode) -> io::Result<()> { Ok(()) }\n+    fn post(&self, _state: &mut State, _node: AnnNode) -> io::Result<()> { Ok(()) }\n }\n \n #[derive(Copy)]\n@@ -59,7 +59,7 @@ pub struct CurrentCommentAndLiteral {\n }\n \n pub struct State<'a> {\n-    pub s: pp::Printer,\n+    pub s: pp::Printer<'a>,\n     cm: Option<&'a CodeMap>,\n     comments: Option<Vec<comments::Comment> >,\n     literals: Option<Vec<comments::Literal> >,\n@@ -69,12 +69,12 @@ pub struct State<'a> {\n     encode_idents_with_hygiene: bool,\n }\n \n-pub fn rust_printer(writer: Box<old_io::Writer+'static>) -> State<'static> {\n+pub fn rust_printer<'a>(writer: Box<Write+'a>) -> State<'a> {\n     static NO_ANN: NoAnn = NoAnn;\n     rust_printer_annotated(writer, &NO_ANN)\n }\n \n-pub fn rust_printer_annotated<'a>(writer: Box<old_io::Writer+'static>,\n+pub fn rust_printer_annotated<'a>(writer: Box<Write+'a>,\n                                   ann: &'a PpAnn) -> State<'a> {\n     State {\n         s: pp::mk_printer(writer, default_columns),\n@@ -104,10 +104,10 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                        span_diagnostic: &diagnostic::SpanHandler,\n                        krate: &ast::Crate,\n                        filename: String,\n-                       input: &mut old_io::Reader,\n-                       out: Box<old_io::Writer+'static>,\n+                       input: &mut Read,\n+                       out: Box<Write+'a>,\n                        ann: &'a PpAnn,\n-                       is_expanded: bool) -> IoResult<()> {\n+                       is_expanded: bool) -> io::Result<()> {\n     let mut s = State::new_from_input(cm,\n                                       span_diagnostic,\n                                       filename,\n@@ -143,8 +143,8 @@ impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a CodeMap,\n                           span_diagnostic: &diagnostic::SpanHandler,\n                           filename: String,\n-                          input: &mut old_io::Reader,\n-                          out: Box<old_io::Writer+'static>,\n+                          input: &mut Read,\n+                          out: Box<Write+'a>,\n                           ann: &'a PpAnn,\n                           is_expanded: bool) -> State<'a> {\n         let (cmnts, lits) = comments::gather_comments_and_literals(\n@@ -164,7 +164,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn new(cm: &'a CodeMap,\n-               out: Box<old_io::Writer+'static>,\n+               out: Box<Write+'a>,\n                ann: &'a PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n                literals: Option<Vec<comments::Literal>>) -> State<'a> {\n@@ -185,14 +185,14 @@ impl<'a> State<'a> {\n }\n \n pub fn to_string<F>(f: F) -> String where\n-    F: FnOnce(&mut State) -> IoResult<()>,\n+    F: FnOnce(&mut State) -> io::Result<()>,\n {\n     use std::raw::TraitObject;\n     let mut s = rust_printer(box Vec::new());\n     f(&mut s).unwrap();\n     eof(&mut s.s).unwrap();\n     let wr = unsafe {\n-        // FIXME(pcwalton): A nasty function to extract the string from an `old_io::Writer`\n+        // FIXME(pcwalton): A nasty function to extract the string from an `Write`\n         // that we \"know\" to be a `Vec<u8>` that works around the lack of checked\n         // downcasts.\n         let obj: &TraitObject = mem::transmute(&s.s.out);\n@@ -440,13 +440,13 @@ thing_to_string_impls! { to_string }\n pub mod with_hygiene {\n     use abi;\n     use ast;\n-    use std::old_io::IoResult;\n+    use std::io;\n     use super::indent_unit;\n \n     // This function is the trick that all the rest of the routines\n     // hang on.\n     pub fn to_string_hyg<F>(f: F) -> String where\n-        F: FnOnce(&mut super::State) -> IoResult<()>,\n+        F: FnOnce(&mut super::State) -> io::Result<()>,\n     {\n         super::to_string(move |s| {\n             s.encode_idents_with_hygiene = true;\n@@ -474,44 +474,44 @@ fn needs_parentheses(expr: &ast::Expr) -> bool {\n }\n \n impl<'a> State<'a> {\n-    pub fn ibox(&mut self, u: usize) -> IoResult<()> {\n+    pub fn ibox(&mut self, u: usize) -> io::Result<()> {\n         self.boxes.push(pp::Breaks::Inconsistent);\n         pp::ibox(&mut self.s, u)\n     }\n \n-    pub fn end(&mut self) -> IoResult<()> {\n+    pub fn end(&mut self) -> io::Result<()> {\n         self.boxes.pop().unwrap();\n         pp::end(&mut self.s)\n     }\n \n-    pub fn cbox(&mut self, u: usize) -> IoResult<()> {\n+    pub fn cbox(&mut self, u: usize) -> io::Result<()> {\n         self.boxes.push(pp::Breaks::Consistent);\n         pp::cbox(&mut self.s, u)\n     }\n \n     // \"raw box\"\n-    pub fn rbox(&mut self, u: usize, b: pp::Breaks) -> IoResult<()> {\n+    pub fn rbox(&mut self, u: usize, b: pp::Breaks) -> io::Result<()> {\n         self.boxes.push(b);\n         pp::rbox(&mut self.s, u, b)\n     }\n \n-    pub fn nbsp(&mut self) -> IoResult<()> { word(&mut self.s, \" \") }\n+    pub fn nbsp(&mut self) -> io::Result<()> { word(&mut self.s, \" \") }\n \n-    pub fn word_nbsp(&mut self, w: &str) -> IoResult<()> {\n+    pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n         try!(word(&mut self.s, w));\n         self.nbsp()\n     }\n \n-    pub fn word_space(&mut self, w: &str) -> IoResult<()> {\n+    pub fn word_space(&mut self, w: &str) -> io::Result<()> {\n         try!(word(&mut self.s, w));\n         space(&mut self.s)\n     }\n \n-    pub fn popen(&mut self) -> IoResult<()> { word(&mut self.s, \"(\") }\n+    pub fn popen(&mut self) -> io::Result<()> { word(&mut self.s, \"(\") }\n \n-    pub fn pclose(&mut self) -> IoResult<()> { word(&mut self.s, \")\") }\n+    pub fn pclose(&mut self) -> io::Result<()> { word(&mut self.s, \")\") }\n \n-    pub fn head(&mut self, w: &str) -> IoResult<()> {\n+    pub fn head(&mut self, w: &str) -> io::Result<()> {\n         // outer-box is consistent\n         try!(self.cbox(indent_unit));\n         // head-box is inconsistent\n@@ -523,17 +523,17 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn bopen(&mut self) -> IoResult<()> {\n+    pub fn bopen(&mut self) -> io::Result<()> {\n         try!(word(&mut self.s, \"{\"));\n         self.end() // close the head-box\n     }\n \n     pub fn bclose_(&mut self, span: codemap::Span,\n-                   indented: usize) -> IoResult<()> {\n+                   indented: usize) -> io::Result<()> {\n         self.bclose_maybe_open(span, indented, true)\n     }\n     pub fn bclose_maybe_open (&mut self, span: codemap::Span,\n-                              indented: usize, close_box: bool) -> IoResult<()> {\n+                              indented: usize, close_box: bool) -> io::Result<()> {\n         try!(self.maybe_print_comment(span.hi));\n         try!(self.break_offset_if_not_bol(1, -(indented as isize)));\n         try!(word(&mut self.s, \"}\"));\n@@ -542,7 +542,7 @@ impl<'a> State<'a> {\n         }\n         Ok(())\n     }\n-    pub fn bclose(&mut self, span: codemap::Span) -> IoResult<()> {\n+    pub fn bclose(&mut self, span: codemap::Span) -> io::Result<()> {\n         self.bclose_(span, indent_unit)\n     }\n \n@@ -572,18 +572,18 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn hardbreak_if_not_bol(&mut self) -> IoResult<()> {\n+    pub fn hardbreak_if_not_bol(&mut self) -> io::Result<()> {\n         if !self.is_bol() {\n             try!(hardbreak(&mut self.s))\n         }\n         Ok(())\n     }\n-    pub fn space_if_not_bol(&mut self) -> IoResult<()> {\n+    pub fn space_if_not_bol(&mut self) -> io::Result<()> {\n         if !self.is_bol() { try!(space(&mut self.s)); }\n         Ok(())\n     }\n     pub fn break_offset_if_not_bol(&mut self, n: usize,\n-                                   off: isize) -> IoResult<()> {\n+                                   off: isize) -> io::Result<()> {\n         if !self.is_bol() {\n             break_offset(&mut self.s, n, off)\n         } else {\n@@ -599,16 +599,16 @@ impl<'a> State<'a> {\n \n     // Synthesizes a comment that was not textually present in the original source\n     // file.\n-    pub fn synth_comment(&mut self, text: String) -> IoResult<()> {\n+    pub fn synth_comment(&mut self, text: String) -> io::Result<()> {\n         try!(word(&mut self.s, \"/*\"));\n         try!(space(&mut self.s));\n         try!(word(&mut self.s, &text[..]));\n         try!(space(&mut self.s));\n         word(&mut self.s, \"*/\")\n     }\n \n-    pub fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F) -> IoResult<()> where\n-        F: FnMut(&mut State, &T) -> IoResult<()>,\n+    pub fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F) -> io::Result<()> where\n+        F: FnMut(&mut State, &T) -> io::Result<()>,\n     {\n         try!(self.rbox(0, b));\n         let mut first = true;\n@@ -624,8 +624,8 @@ impl<'a> State<'a> {\n                                   b: Breaks,\n                                   elts: &[T],\n                                   mut op: F,\n-                                  mut get_span: G) -> IoResult<()> where\n-        F: FnMut(&mut State, &T) -> IoResult<()>,\n+                                  mut get_span: G) -> io::Result<()> where\n+        F: FnMut(&mut State, &T) -> io::Result<()>,\n         G: FnMut(&T) -> codemap::Span,\n     {\n         try!(self.rbox(0, b));\n@@ -646,12 +646,12 @@ impl<'a> State<'a> {\n     }\n \n     pub fn commasep_exprs(&mut self, b: Breaks,\n-                          exprs: &[P<ast::Expr>]) -> IoResult<()> {\n+                          exprs: &[P<ast::Expr>]) -> io::Result<()> {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&**e), |e| e.span)\n     }\n \n     pub fn print_mod(&mut self, _mod: &ast::Mod,\n-                     attrs: &[ast::Attribute]) -> IoResult<()> {\n+                     attrs: &[ast::Attribute]) -> io::Result<()> {\n         try!(self.print_inner_attributes(attrs));\n         for item in &_mod.items {\n             try!(self.print_item(&**item));\n@@ -660,7 +660,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod,\n-                             attrs: &[ast::Attribute]) -> IoResult<()> {\n+                             attrs: &[ast::Attribute]) -> io::Result<()> {\n         try!(self.print_inner_attributes(attrs));\n         for item in &nmod.items {\n             try!(self.print_foreign_item(&**item));\n@@ -669,15 +669,15 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_opt_lifetime(&mut self,\n-                              lifetime: &Option<ast::Lifetime>) -> IoResult<()> {\n+                              lifetime: &Option<ast::Lifetime>) -> io::Result<()> {\n         if let Some(l) = *lifetime {\n             try!(self.print_lifetime(&l));\n             try!(self.nbsp());\n         }\n         Ok(())\n     }\n \n-    pub fn print_type(&mut self, ty: &ast::Ty) -> IoResult<()> {\n+    pub fn print_type(&mut self, ty: &ast::Ty) -> io::Result<()> {\n         try!(self.maybe_print_comment(ty.span.lo));\n         try!(self.ibox(0));\n         match ty.node {\n@@ -762,7 +762,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_foreign_item(&mut self,\n-                              item: &ast::ForeignItem) -> IoResult<()> {\n+                              item: &ast::ForeignItem) -> io::Result<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n         try!(self.print_outer_attributes(&item.attrs));\n@@ -791,15 +791,15 @@ impl<'a> State<'a> {\n     }\n \n     fn print_associated_type(&mut self, typedef: &ast::AssociatedType)\n-                             -> IoResult<()>\n+                             -> io::Result<()>\n     {\n         try!(self.print_outer_attributes(&typedef.attrs));\n         try!(self.word_space(\"type\"));\n         try!(self.print_ty_param(&typedef.ty_param));\n         word(&mut self.s, \";\")\n     }\n \n-    fn print_typedef(&mut self, typedef: &ast::Typedef) -> IoResult<()> {\n+    fn print_typedef(&mut self, typedef: &ast::Typedef) -> io::Result<()> {\n         try!(self.word_space(\"type\"));\n         try!(self.print_ident(typedef.ident));\n         try!(space(&mut self.s));\n@@ -809,7 +809,7 @@ impl<'a> State<'a> {\n     }\n \n     /// Pretty-print an item\n-    pub fn print_item(&mut self, item: &ast::Item) -> IoResult<()> {\n+    pub fn print_item(&mut self, item: &ast::Item) -> io::Result<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n         try!(self.print_outer_attributes(&item.attrs));\n@@ -1032,11 +1032,11 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeItem(item))\n     }\n \n-    fn print_trait_ref(&mut self, t: &ast::TraitRef) -> IoResult<()> {\n+    fn print_trait_ref(&mut self, t: &ast::TraitRef) -> io::Result<()> {\n         self.print_path(&t.path, false, 0)\n     }\n \n-    fn print_formal_lifetime_list(&mut self, lifetimes: &[ast::LifetimeDef]) -> IoResult<()> {\n+    fn print_formal_lifetime_list(&mut self, lifetimes: &[ast::LifetimeDef]) -> io::Result<()> {\n         if !lifetimes.is_empty() {\n             try!(word(&mut self.s, \"for<\"));\n             let mut comma = false;\n@@ -1052,15 +1052,15 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    fn print_poly_trait_ref(&mut self, t: &ast::PolyTraitRef) -> IoResult<()> {\n+    fn print_poly_trait_ref(&mut self, t: &ast::PolyTraitRef) -> io::Result<()> {\n         try!(self.print_formal_lifetime_list(&t.bound_lifetimes));\n         self.print_trait_ref(&t.trait_ref)\n     }\n \n     pub fn print_enum_def(&mut self, enum_definition: &ast::EnumDef,\n                           generics: &ast::Generics, ident: ast::Ident,\n                           span: codemap::Span,\n-                          visibility: ast::Visibility) -> IoResult<()> {\n+                          visibility: ast::Visibility) -> io::Result<()> {\n         try!(self.head(&visibility_qualified(visibility, \"enum\")));\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n@@ -1071,7 +1071,7 @@ impl<'a> State<'a> {\n \n     pub fn print_variants(&mut self,\n                           variants: &[P<ast::Variant>],\n-                          span: codemap::Span) -> IoResult<()> {\n+                          span: codemap::Span) -> io::Result<()> {\n         try!(self.bopen());\n         for v in variants {\n             try!(self.space_if_not_bol());\n@@ -1086,7 +1086,7 @@ impl<'a> State<'a> {\n         self.bclose(span)\n     }\n \n-    pub fn print_visibility(&mut self, vis: ast::Visibility) -> IoResult<()> {\n+    pub fn print_visibility(&mut self, vis: ast::Visibility) -> io::Result<()> {\n         match vis {\n             ast::Public => self.word_nbsp(\"pub\"),\n             ast::Inherited => Ok(())\n@@ -1097,7 +1097,7 @@ impl<'a> State<'a> {\n                         struct_def: &ast::StructDef,\n                         generics: &ast::Generics,\n                         ident: ast::Ident,\n-                        span: codemap::Span) -> IoResult<()> {\n+                        span: codemap::Span) -> io::Result<()> {\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n         if ast_util::struct_def_is_tuple_like(struct_def) {\n@@ -1155,7 +1155,7 @@ impl<'a> State<'a> {\n     /// appropriate macro, transcribe back into the grammar we just parsed from,\n     /// and then pretty-print the resulting AST nodes (so, e.g., we print\n     /// expression arguments as expressions). It can be done! I think.\n-    pub fn print_tt(&mut self, tt: &ast::TokenTree) -> IoResult<()> {\n+    pub fn print_tt(&mut self, tt: &ast::TokenTree) -> io::Result<()> {\n         match *tt {\n             ast::TtToken(_, ref tk) => {\n                 try!(word(&mut self.s, &token_to_string(tk)));\n@@ -1193,7 +1193,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_tts(&mut self, tts: &[ast::TokenTree]) -> IoResult<()> {\n+    pub fn print_tts(&mut self, tts: &[ast::TokenTree]) -> io::Result<()> {\n         try!(self.ibox(0));\n         let mut suppress_space = false;\n         for (i, tt) in tts.iter().enumerate() {\n@@ -1213,7 +1213,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn print_variant(&mut self, v: &ast::Variant) -> IoResult<()> {\n+    pub fn print_variant(&mut self, v: &ast::Variant) -> io::Result<()> {\n         try!(self.print_visibility(v.node.vis));\n         match v.node.kind {\n             ast::TupleVariantKind(ref args) => {\n@@ -1242,7 +1242,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_ty_method(&mut self, m: &ast::TypeMethod) -> IoResult<()> {\n+    pub fn print_ty_method(&mut self, m: &ast::TypeMethod) -> io::Result<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(m.span.lo));\n         try!(self.print_outer_attributes(&m.attrs));\n@@ -1256,22 +1256,22 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_trait_method(&mut self,\n-                              m: &ast::TraitItem) -> IoResult<()> {\n+                              m: &ast::TraitItem) -> io::Result<()> {\n         match *m {\n             RequiredMethod(ref ty_m) => self.print_ty_method(ty_m),\n             ProvidedMethod(ref m) => self.print_method(&**m),\n             TypeTraitItem(ref t) => self.print_associated_type(&**t),\n         }\n     }\n \n-    pub fn print_impl_item(&mut self, ii: &ast::ImplItem) -> IoResult<()> {\n+    pub fn print_impl_item(&mut self, ii: &ast::ImplItem) -> io::Result<()> {\n         match *ii {\n             MethodImplItem(ref m) => self.print_method(&**m),\n             TypeImplItem(ref td) => self.print_typedef(&**td),\n         }\n     }\n \n-    pub fn print_method(&mut self, meth: &ast::Method) -> IoResult<()> {\n+    pub fn print_method(&mut self, meth: &ast::Method) -> io::Result<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(meth.span.lo));\n         try!(self.print_outer_attributes(&meth.attrs));\n@@ -1310,7 +1310,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_outer_attributes(&mut self,\n-                                  attrs: &[ast::Attribute]) -> IoResult<()> {\n+                                  attrs: &[ast::Attribute]) -> io::Result<()> {\n         let mut count = 0;\n         for attr in attrs {\n             match attr.node.style {\n@@ -1328,7 +1328,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_inner_attributes(&mut self,\n-                                  attrs: &[ast::Attribute]) -> IoResult<()> {\n+                                  attrs: &[ast::Attribute]) -> io::Result<()> {\n         let mut count = 0;\n         for attr in attrs {\n             match attr.node.style {\n@@ -1345,7 +1345,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_attribute(&mut self, attr: &ast::Attribute) -> IoResult<()> {\n+    pub fn print_attribute(&mut self, attr: &ast::Attribute) -> io::Result<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(attr.span.lo));\n         if attr.node.is_sugared_doc {\n@@ -1361,7 +1361,7 @@ impl<'a> State<'a> {\n     }\n \n \n-    pub fn print_stmt(&mut self, st: &ast::Stmt) -> IoResult<()> {\n+    pub fn print_stmt(&mut self, st: &ast::Stmt) -> io::Result<()> {\n         try!(self.maybe_print_comment(st.span.lo));\n         match st.node {\n             ast::StmtDecl(ref decl, _) => {\n@@ -1395,30 +1395,30 @@ impl<'a> State<'a> {\n         self.maybe_print_trailing_comment(st.span, None)\n     }\n \n-    pub fn print_block(&mut self, blk: &ast::Block) -> IoResult<()> {\n+    pub fn print_block(&mut self, blk: &ast::Block) -> io::Result<()> {\n         self.print_block_with_attrs(blk, &[])\n     }\n \n-    pub fn print_block_unclosed(&mut self, blk: &ast::Block) -> IoResult<()> {\n+    pub fn print_block_unclosed(&mut self, blk: &ast::Block) -> io::Result<()> {\n         self.print_block_unclosed_indent(blk, indent_unit)\n     }\n \n     pub fn print_block_unclosed_indent(&mut self, blk: &ast::Block,\n-                                       indented: usize) -> IoResult<()> {\n+                                       indented: usize) -> io::Result<()> {\n         self.print_block_maybe_unclosed(blk, indented, &[], false)\n     }\n \n     pub fn print_block_with_attrs(&mut self,\n                                   blk: &ast::Block,\n-                                  attrs: &[ast::Attribute]) -> IoResult<()> {\n+                                  attrs: &[ast::Attribute]) -> io::Result<()> {\n         self.print_block_maybe_unclosed(blk, indent_unit, attrs, true)\n     }\n \n     pub fn print_block_maybe_unclosed(&mut self,\n                                       blk: &ast::Block,\n                                       indented: usize,\n                                       attrs: &[ast::Attribute],\n-                                      close_box: bool) -> IoResult<()> {\n+                                      close_box: bool) -> io::Result<()> {\n         match blk.rules {\n             ast::UnsafeBlock(..) => try!(self.word_space(\"unsafe\")),\n             ast::DefaultBlock => ()\n@@ -1444,7 +1444,7 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeBlock(blk))\n     }\n \n-    fn print_else(&mut self, els: Option<&ast::Expr>) -> IoResult<()> {\n+    fn print_else(&mut self, els: Option<&ast::Expr>) -> io::Result<()> {\n         match els {\n             Some(_else) => {\n                 match _else.node {\n@@ -1489,7 +1489,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block,\n-                    elseopt: Option<&ast::Expr>) -> IoResult<()> {\n+                    elseopt: Option<&ast::Expr>) -> io::Result<()> {\n         try!(self.head(\"if\"));\n         try!(self.print_expr(test));\n         try!(space(&mut self.s));\n@@ -1498,7 +1498,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_if_let(&mut self, pat: &ast::Pat, expr: &ast::Expr, blk: &ast::Block,\n-                        elseopt: Option<&ast::Expr>) -> IoResult<()> {\n+                        elseopt: Option<&ast::Expr>) -> io::Result<()> {\n         try!(self.head(\"if let\"));\n         try!(self.print_pat(pat));\n         try!(space(&mut self.s));\n@@ -1510,7 +1510,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_mac(&mut self, m: &ast::Mac, delim: token::DelimToken)\n-                     -> IoResult<()> {\n+                     -> io::Result<()> {\n         match m.node {\n             // I think it's reasonable to hide the ctxt here:\n             ast::MacInvocTT(ref pth, ref tts, _) => {\n@@ -1532,13 +1532,13 @@ impl<'a> State<'a> {\n     }\n \n \n-    fn print_call_post(&mut self, args: &[P<ast::Expr>]) -> IoResult<()> {\n+    fn print_call_post(&mut self, args: &[P<ast::Expr>]) -> io::Result<()> {\n         try!(self.popen());\n         try!(self.commasep_exprs(Inconsistent, args));\n         self.pclose()\n     }\n \n-    pub fn print_expr_maybe_paren(&mut self, expr: &ast::Expr) -> IoResult<()> {\n+    pub fn print_expr_maybe_paren(&mut self, expr: &ast::Expr) -> io::Result<()> {\n         let needs_par = needs_parentheses(expr);\n         if needs_par {\n             try!(self.popen());\n@@ -1552,15 +1552,15 @@ impl<'a> State<'a> {\n \n     fn print_expr_box(&mut self,\n                       place: &Option<P<ast::Expr>>,\n-                      expr: &ast::Expr) -> IoResult<()> {\n+                      expr: &ast::Expr) -> io::Result<()> {\n         try!(word(&mut self.s, \"box\"));\n         try!(word(&mut self.s, \"(\"));\n         try!(place.as_ref().map_or(Ok(()), |e|self.print_expr(&**e)));\n         try!(self.word_space(\")\"));\n         self.print_expr(expr)\n     }\n \n-    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) -> IoResult<()> {\n+    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) -> io::Result<()> {\n         try!(self.ibox(indent_unit));\n         try!(word(&mut self.s, \"[\"));\n         try!(self.commasep_exprs(Inconsistent, &exprs[..]));\n@@ -1570,7 +1570,7 @@ impl<'a> State<'a> {\n \n     fn print_expr_repeat(&mut self,\n                          element: &ast::Expr,\n-                         count: &ast::Expr) -> IoResult<()> {\n+                         count: &ast::Expr) -> io::Result<()> {\n         try!(self.ibox(indent_unit));\n         try!(word(&mut self.s, \"[\"));\n         try!(self.print_expr(element));\n@@ -1583,7 +1583,7 @@ impl<'a> State<'a> {\n     fn print_expr_struct(&mut self,\n                          path: &ast::Path,\n                          fields: &[ast::Field],\n-                         wth: &Option<P<ast::Expr>>) -> IoResult<()> {\n+                         wth: &Option<P<ast::Expr>>) -> io::Result<()> {\n         try!(self.print_path(path, true, 0));\n         if !(fields.is_empty() && wth.is_none()) {\n             try!(word(&mut self.s, \"{\"));\n@@ -1616,7 +1616,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) -> IoResult<()> {\n+    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) -> io::Result<()> {\n         try!(self.popen());\n         try!(self.commasep_exprs(Inconsistent, &exprs[..]));\n         if exprs.len() == 1 {\n@@ -1627,15 +1627,15 @@ impl<'a> State<'a> {\n \n     fn print_expr_call(&mut self,\n                        func: &ast::Expr,\n-                       args: &[P<ast::Expr>]) -> IoResult<()> {\n+                       args: &[P<ast::Expr>]) -> io::Result<()> {\n         try!(self.print_expr_maybe_paren(func));\n         self.print_call_post(args)\n     }\n \n     fn print_expr_method_call(&mut self,\n                               ident: ast::SpannedIdent,\n                               tys: &[P<ast::Ty>],\n-                              args: &[P<ast::Expr>]) -> IoResult<()> {\n+                              args: &[P<ast::Expr>]) -> io::Result<()> {\n         let base_args = &args[1..];\n         try!(self.print_expr(&*args[0]));\n         try!(word(&mut self.s, \".\"));\n@@ -1652,7 +1652,7 @@ impl<'a> State<'a> {\n     fn print_expr_binary(&mut self,\n                          op: ast::BinOp,\n                          lhs: &ast::Expr,\n-                         rhs: &ast::Expr) -> IoResult<()> {\n+                         rhs: &ast::Expr) -> io::Result<()> {\n         try!(self.print_expr(lhs));\n         try!(space(&mut self.s));\n         try!(self.word_space(ast_util::binop_to_string(op.node)));\n@@ -1661,20 +1661,20 @@ impl<'a> State<'a> {\n \n     fn print_expr_unary(&mut self,\n                         op: ast::UnOp,\n-                        expr: &ast::Expr) -> IoResult<()> {\n+                        expr: &ast::Expr) -> io::Result<()> {\n         try!(word(&mut self.s, ast_util::unop_to_string(op)));\n         self.print_expr_maybe_paren(expr)\n     }\n \n     fn print_expr_addr_of(&mut self,\n                           mutability: ast::Mutability,\n-                          expr: &ast::Expr) -> IoResult<()> {\n+                          expr: &ast::Expr) -> io::Result<()> {\n         try!(word(&mut self.s, \"&\"));\n         try!(self.print_mutability(mutability));\n         self.print_expr_maybe_paren(expr)\n     }\n \n-    pub fn print_expr(&mut self, expr: &ast::Expr) -> IoResult<()> {\n+    pub fn print_expr(&mut self, expr: &ast::Expr) -> io::Result<()> {\n         try!(self.maybe_print_comment(expr.span.lo));\n         try!(self.ibox(indent_unit));\n         try!(self.ann.pre(self, NodeExpr(expr)));\n@@ -1958,7 +1958,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn print_local_decl(&mut self, loc: &ast::Local) -> IoResult<()> {\n+    pub fn print_local_decl(&mut self, loc: &ast::Local) -> io::Result<()> {\n         try!(self.print_pat(&*loc.pat));\n         if let Some(ref ty) = loc.ty {\n             try!(self.word_space(\":\"));\n@@ -1967,7 +1967,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_decl(&mut self, decl: &ast::Decl) -> IoResult<()> {\n+    pub fn print_decl(&mut self, decl: &ast::Decl) -> io::Result<()> {\n         try!(self.maybe_print_comment(decl.span.lo));\n         match decl.node {\n             ast::DeclLocal(ref loc) => {\n@@ -1989,7 +1989,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_ident(&mut self, ident: ast::Ident) -> IoResult<()> {\n+    pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n         if self.encode_idents_with_hygiene {\n             let encoded = ident.encode_with_hygiene();\n             try!(word(&mut self.s, &encoded[..]))\n@@ -1999,17 +1999,17 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeIdent(&ident))\n     }\n \n-    pub fn print_usize(&mut self, i: usize) -> IoResult<()> {\n+    pub fn print_usize(&mut self, i: usize) -> io::Result<()> {\n         word(&mut self.s, &i.to_string())\n     }\n \n-    pub fn print_name(&mut self, name: ast::Name) -> IoResult<()> {\n+    pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n         try!(word(&mut self.s, &token::get_name(name)));\n         self.ann.post(self, NodeName(&name))\n     }\n \n     pub fn print_for_decl(&mut self, loc: &ast::Local,\n-                          coll: &ast::Expr) -> IoResult<()> {\n+                          coll: &ast::Expr) -> io::Result<()> {\n         try!(self.print_local_decl(loc));\n         try!(space(&mut self.s));\n         try!(self.word_space(\"in\"));\n@@ -2020,7 +2020,7 @@ impl<'a> State<'a> {\n                   path: &ast::Path,\n                   colons_before_params: bool,\n                   depth: usize)\n-                  -> IoResult<()>\n+                  -> io::Result<()>\n     {\n         try!(self.maybe_print_comment(path.span.lo));\n \n@@ -2044,7 +2044,7 @@ impl<'a> State<'a> {\n                    path: &ast::Path,\n                    qself: &ast::QSelf,\n                    colons_before_params: bool)\n-                   -> IoResult<()>\n+                   -> io::Result<()>\n     {\n         try!(word(&mut self.s, \"<\"));\n         try!(self.print_type(&qself.ty));\n@@ -2064,7 +2064,7 @@ impl<'a> State<'a> {\n     fn print_path_parameters(&mut self,\n                              parameters: &ast::PathParameters,\n                              colons_before_params: bool)\n-                             -> IoResult<()>\n+                             -> io::Result<()>\n     {\n         if parameters.is_empty() {\n             return Ok(());\n@@ -2134,7 +2134,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_pat(&mut self, pat: &ast::Pat) -> IoResult<()> {\n+    pub fn print_pat(&mut self, pat: &ast::Pat) -> io::Result<()> {\n         try!(self.maybe_print_comment(pat.span.lo));\n         try!(self.ann.pre(self, NodePat(pat)));\n         /* Pat isn't normalized, but the beauty of it\n@@ -2253,7 +2253,7 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodePat(pat))\n     }\n \n-    fn print_arm(&mut self, arm: &ast::Arm) -> IoResult<()> {\n+    fn print_arm(&mut self, arm: &ast::Arm) -> io::Result<()> {\n         // I have no idea why this check is necessary, but here it\n         // is :(\n         if arm.attrs.is_empty() {\n@@ -2302,7 +2302,7 @@ impl<'a> State<'a> {\n     // Returns whether it printed anything\n     fn print_explicit_self(&mut self,\n                            explicit_self: &ast::ExplicitSelf_,\n-                           mutbl: ast::Mutability) -> IoResult<bool> {\n+                           mutbl: ast::Mutability) -> io::Result<bool> {\n         try!(self.print_mutability(mutbl));\n         match *explicit_self {\n             ast::SelfStatic => { return Ok(false); }\n@@ -2331,7 +2331,7 @@ impl<'a> State<'a> {\n                     name: ast::Ident,\n                     generics: &ast::Generics,\n                     opt_explicit_self: Option<&ast::ExplicitSelf_>,\n-                    vis: ast::Visibility) -> IoResult<()> {\n+                    vis: ast::Visibility) -> io::Result<()> {\n         try!(self.head(\"\"));\n         try!(self.print_fn_header_info(unsafety, abi, vis));\n         try!(self.nbsp());\n@@ -2343,7 +2343,7 @@ impl<'a> State<'a> {\n \n     pub fn print_fn_args(&mut self, decl: &ast::FnDecl,\n                          opt_explicit_self: Option<&ast::ExplicitSelf_>)\n-        -> IoResult<()> {\n+        -> io::Result<()> {\n         // It is unfortunate to duplicate the commasep logic, but we want the\n         // self type and the args all in the same box.\n         try!(self.rbox(0, Inconsistent));\n@@ -2376,7 +2376,7 @@ impl<'a> State<'a> {\n \n     pub fn print_fn_args_and_ret(&mut self, decl: &ast::FnDecl,\n                                  opt_explicit_self: Option<&ast::ExplicitSelf_>)\n-        -> IoResult<()> {\n+        -> io::Result<()> {\n         try!(self.popen());\n         try!(self.print_fn_args(decl, opt_explicit_self));\n         if decl.variadic {\n@@ -2390,7 +2390,7 @@ impl<'a> State<'a> {\n     pub fn print_fn_block_args(\n             &mut self,\n             decl: &ast::FnDecl)\n-            -> IoResult<()> {\n+            -> io::Result<()> {\n         try!(word(&mut self.s, \"|\"));\n         try!(self.print_fn_args(decl, None));\n         try!(word(&mut self.s, \"|\"));\n@@ -2415,7 +2415,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_capture_clause(&mut self, capture_clause: ast::CaptureClause)\n-                                -> IoResult<()> {\n+                                -> io::Result<()> {\n         match capture_clause {\n             ast::CaptureByValue => self.word_space(\"move\"),\n             ast::CaptureByRef => Ok(()),\n@@ -2425,7 +2425,7 @@ impl<'a> State<'a> {\n     pub fn print_bounds(&mut self,\n                         prefix: &str,\n                         bounds: &[ast::TyParamBound])\n-                        -> IoResult<()> {\n+                        -> io::Result<()> {\n         if !bounds.is_empty() {\n             try!(word(&mut self.s, prefix));\n             let mut first = true;\n@@ -2458,14 +2458,14 @@ impl<'a> State<'a> {\n \n     pub fn print_lifetime(&mut self,\n                           lifetime: &ast::Lifetime)\n-                          -> IoResult<()>\n+                          -> io::Result<()>\n     {\n         self.print_name(lifetime.name)\n     }\n \n     pub fn print_lifetime_def(&mut self,\n                               lifetime: &ast::LifetimeDef)\n-                              -> IoResult<()>\n+                              -> io::Result<()>\n     {\n         try!(self.print_lifetime(&lifetime.lifetime));\n         let mut sep = \":\";\n@@ -2479,7 +2479,7 @@ impl<'a> State<'a> {\n \n     pub fn print_generics(&mut self,\n                           generics: &ast::Generics)\n-                          -> IoResult<()>\n+                          -> io::Result<()>\n     {\n         let total = generics.lifetimes.len() + generics.ty_params.len();\n         if total == 0 {\n@@ -2508,7 +2508,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_ty_param(&mut self, param: &ast::TyParam) -> IoResult<()> {\n+    pub fn print_ty_param(&mut self, param: &ast::TyParam) -> io::Result<()> {\n         try!(self.print_ident(param.ident));\n         try!(self.print_bounds(\":\", &param.bounds));\n         match param.default {\n@@ -2522,7 +2522,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_where_clause(&mut self, generics: &ast::Generics)\n-                              -> IoResult<()> {\n+                              -> io::Result<()> {\n         if generics.where_clause.predicates.len() == 0 {\n             return Ok(())\n         }\n@@ -2573,7 +2573,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_meta_item(&mut self, item: &ast::MetaItem) -> IoResult<()> {\n+    pub fn print_meta_item(&mut self, item: &ast::MetaItem) -> io::Result<()> {\n         try!(self.ibox(indent_unit));\n         match item.node {\n             ast::MetaWord(ref name) => {\n@@ -2596,7 +2596,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn print_view_path(&mut self, vp: &ast::ViewPath) -> IoResult<()> {\n+    pub fn print_view_path(&mut self, vp: &ast::ViewPath) -> io::Result<()> {\n         match vp.node {\n             ast::ViewPathSimple(ident, ref path) => {\n                 try!(self.print_path(path, false, 0));\n@@ -2640,19 +2640,19 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_mutability(&mut self,\n-                            mutbl: ast::Mutability) -> IoResult<()> {\n+                            mutbl: ast::Mutability) -> io::Result<()> {\n         match mutbl {\n             ast::MutMutable => self.word_nbsp(\"mut\"),\n             ast::MutImmutable => Ok(()),\n         }\n     }\n \n-    pub fn print_mt(&mut self, mt: &ast::MutTy) -> IoResult<()> {\n+    pub fn print_mt(&mut self, mt: &ast::MutTy) -> io::Result<()> {\n         try!(self.print_mutability(mt.mutbl));\n         self.print_type(&*mt.ty)\n     }\n \n-    pub fn print_arg(&mut self, input: &ast::Arg) -> IoResult<()> {\n+    pub fn print_arg(&mut self, input: &ast::Arg) -> io::Result<()> {\n         try!(self.ibox(indent_unit));\n         match input.ty.node {\n             ast::TyInfer => try!(self.print_pat(&*input.pat)),\n@@ -2675,7 +2675,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn print_fn_output(&mut self, decl: &ast::FnDecl) -> IoResult<()> {\n+    pub fn print_fn_output(&mut self, decl: &ast::FnDecl) -> io::Result<()> {\n         if let ast::DefaultReturn(..) = decl.output {\n             return Ok(());\n         }\n@@ -2705,7 +2705,7 @@ impl<'a> State<'a> {\n                        id: Option<ast::Ident>,\n                        generics: &ast::Generics,\n                        opt_explicit_self: Option<&ast::ExplicitSelf_>)\n-                       -> IoResult<()> {\n+                       -> io::Result<()> {\n         try!(self.ibox(indent_unit));\n         try!(self.print_fn_header_info(Some(unsafety), abi, ast::Inherited));\n \n@@ -2726,7 +2726,7 @@ impl<'a> State<'a> {\n \n     pub fn maybe_print_trailing_comment(&mut self, span: codemap::Span,\n                                         next_pos: Option<BytePos>)\n-        -> IoResult<()> {\n+        -> io::Result<()> {\n         let cm = match self.cm {\n             Some(cm) => cm,\n             _ => return Ok(())\n@@ -2749,7 +2749,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_remaining_comments(&mut self) -> IoResult<()> {\n+    pub fn print_remaining_comments(&mut self) -> io::Result<()> {\n         // If there aren't any remaining comments, then we need to manually\n         // make sure there is a line break at the end.\n         if self.next_comment().is_none() {\n@@ -2767,7 +2767,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_literal(&mut self, lit: &ast::Lit) -> IoResult<()> {\n+    pub fn print_literal(&mut self, lit: &ast::Lit) -> io::Result<()> {\n         try!(self.maybe_print_comment(lit.span.lo));\n         match self.next_lit(lit.span.lo) {\n             Some(ref ltrl) => {\n@@ -2848,7 +2848,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn maybe_print_comment(&mut self, pos: BytePos) -> IoResult<()> {\n+    pub fn maybe_print_comment(&mut self, pos: BytePos) -> io::Result<()> {\n         loop {\n             match self.next_comment() {\n                 Some(ref cmnt) => {\n@@ -2864,7 +2864,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_comment(&mut self,\n-                         cmnt: &comments::Comment) -> IoResult<()> {\n+                         cmnt: &comments::Comment) -> io::Result<()> {\n         match cmnt.style {\n             comments::Mixed => {\n                 assert_eq!(cmnt.lines.len(), 1);\n@@ -2915,7 +2915,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_string(&mut self, st: &str,\n-                        style: ast::StrStyle) -> IoResult<()> {\n+                        style: ast::StrStyle) -> io::Result<()> {\n         let st = match style {\n             ast::CookedStr => {\n                 (format!(\"\\\"{}\\\"\", st.escape_default()))\n@@ -2943,7 +2943,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_opt_unsafety(&mut self,\n-                            opt_unsafety: Option<ast::Unsafety>) -> IoResult<()> {\n+                            opt_unsafety: Option<ast::Unsafety>) -> io::Result<()> {\n         match opt_unsafety {\n             Some(unsafety) => self.print_unsafety(unsafety),\n             None => Ok(())\n@@ -2952,7 +2952,7 @@ impl<'a> State<'a> {\n \n     pub fn print_opt_abi_and_extern_if_nondefault(&mut self,\n                                                   opt_abi: Option<abi::Abi>)\n-        -> IoResult<()> {\n+        -> io::Result<()> {\n         match opt_abi {\n             Some(abi::Rust) => Ok(()),\n             Some(abi) => {\n@@ -2964,7 +2964,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_extern_opt_abi(&mut self,\n-                                opt_abi: Option<abi::Abi>) -> IoResult<()> {\n+                                opt_abi: Option<abi::Abi>) -> io::Result<()> {\n         match opt_abi {\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n@@ -2977,7 +2977,7 @@ impl<'a> State<'a> {\n     pub fn print_fn_header_info(&mut self,\n                                 opt_unsafety: Option<ast::Unsafety>,\n                                 abi: abi::Abi,\n-                                vis: ast::Visibility) -> IoResult<()> {\n+                                vis: ast::Visibility) -> io::Result<()> {\n         try!(word(&mut self.s, &visibility_qualified(vis, \"\")));\n         try!(self.print_opt_unsafety(opt_unsafety));\n \n@@ -2989,7 +2989,7 @@ impl<'a> State<'a> {\n         word(&mut self.s, \"fn\")\n     }\n \n-    pub fn print_unsafety(&mut self, s: ast::Unsafety) -> IoResult<()> {\n+    pub fn print_unsafety(&mut self, s: ast::Unsafety) -> io::Result<()> {\n         match s {\n             ast::Unsafety::Normal => Ok(()),\n             ast::Unsafety::Unsafe => self.word_nbsp(\"unsafe\"),"}, {"sha": "ba9860ee31f604603a7ebba8d607317f68804dc6", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -52,14 +52,15 @@\n \n #![feature(box_syntax)]\n #![feature(collections)]\n+#![feature(fs)]\n #![feature(int_uint)]\n+#![feature(io)]\n #![feature(old_io)]\n-#![feature(old_path)]\n+#![feature(path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(unicode)]\n #![feature(std_misc)]\n-#![feature(os)]\n+#![feature(unicode)]\n #![cfg_attr(windows, feature(libc))]\n \n #[macro_use] extern crate log;"}, {"sha": "cc9a2880b5d07d10b5f8502315b1f9e9951f0798", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -13,7 +13,8 @@\n //! ncurses-compatible compiled terminfo format parsing (term(5))\n \n use std::collections::HashMap;\n-use std::old_io;\n+use std::io::prelude::*;\n+use std::io;\n use super::super::TermInfo;\n \n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n@@ -158,7 +159,7 @@ pub static stringnames: &'static[&'static str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tb\n     \"box1\"];\n \n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n-pub fn parse(file: &mut old_io::Reader, longnames: bool)\n+pub fn parse(file: &mut Read, longnames: bool)\n              -> Result<Box<TermInfo>, String> {\n     macro_rules! try { ($e:expr) => (\n         match $e {\n@@ -182,17 +183,17 @@ pub fn parse(file: &mut old_io::Reader, longnames: bool)\n     }\n \n     // Check magic number\n-    let magic = try!(file.read_le_u16());\n+    let magic = try!(read_le_u16(file));\n     if magic != 0x011A {\n         return Err(format!(\"invalid magic number: expected {:x}, found {:x}\",\n                            0x011A as usize, magic as usize));\n     }\n \n-    let names_bytes          = try!(file.read_le_i16()) as int;\n-    let bools_bytes          = try!(file.read_le_i16()) as int;\n-    let numbers_count        = try!(file.read_le_i16()) as int;\n-    let string_offsets_count = try!(file.read_le_i16()) as int;\n-    let string_table_bytes   = try!(file.read_le_i16()) as int;\n+    let names_bytes          = try!(read_le_u16(file)) as int;\n+    let bools_bytes          = try!(read_le_u16(file)) as int;\n+    let numbers_count        = try!(read_le_u16(file)) as int;\n+    let string_offsets_count = try!(read_le_u16(file)) as int;\n+    let string_table_bytes   = try!(read_le_u16(file)) as int;\n \n     assert!(names_bytes          > 0);\n \n@@ -212,7 +213,7 @@ pub fn parse(file: &mut old_io::Reader, longnames: bool)\n     }\n \n     // don't read NUL\n-    let bytes = try!(file.read_exact(names_bytes as uint - 1));\n+    let bytes = try!(read_exact(file, names_bytes as uint - 1));\n     let names_str = match String::from_utf8(bytes) {\n         Ok(s)  => s,\n         Err(_) => return Err(\"input not utf-8\".to_string()),\n@@ -222,26 +223,26 @@ pub fn parse(file: &mut old_io::Reader, longnames: bool)\n                                            .map(|s| s.to_string())\n                                            .collect();\n \n-    try!(file.read_byte()); // consume NUL\n+    try!(read_byte(file)); // consume NUL\n \n     let mut bools_map = HashMap::new();\n     if bools_bytes != 0 {\n         for i in 0..bools_bytes {\n-            let b = try!(file.read_byte());\n+            let b = try!(read_byte(file));\n             if b == 1 {\n                 bools_map.insert(bnames[i as uint].to_string(), true);\n             }\n         }\n     }\n \n     if (bools_bytes + names_bytes) % 2 == 1 {\n-        try!(file.read_byte()); // compensate for padding\n+        try!(read_byte(file)); // compensate for padding\n     }\n \n     let mut numbers_map = HashMap::new();\n     if numbers_count != 0 {\n         for i in 0..numbers_count {\n-            let n = try!(file.read_le_u16());\n+            let n = try!(read_le_u16(file));\n             if n != 0xFFFF {\n                 numbers_map.insert(nnames[i as uint].to_string(), n);\n             }\n@@ -253,10 +254,10 @@ pub fn parse(file: &mut old_io::Reader, longnames: bool)\n     if string_offsets_count != 0 {\n         let mut string_offsets = Vec::with_capacity(10);\n         for _ in 0..string_offsets_count {\n-            string_offsets.push(try!(file.read_le_u16()));\n+            string_offsets.push(try!(read_le_u16(file)));\n         }\n \n-        let string_table = try!(file.read_exact(string_table_bytes as uint));\n+        let string_table = try!(read_exact(file, string_table_bytes as usize));\n \n         if string_table.len() != string_table_bytes as uint {\n             return Err(\"error: hit EOF before end of string \\\n@@ -309,6 +310,25 @@ pub fn parse(file: &mut old_io::Reader, longnames: bool)\n     })\n }\n \n+fn read_le_u16<R: Read + ?Sized>(r: &mut R) -> io::Result<u16> {\n+    let mut b = [0; 2];\n+    assert_eq!(try!(r.read(&mut b)), 2);\n+    Ok((b[0] as u16) | ((b[1] as u16) << 8))\n+}\n+\n+fn read_byte<R: Read + ?Sized>(r: &mut R) -> io::Result<u8> {\n+    let mut b = [0; 1];\n+    assert_eq!(try!(r.read(&mut b)), 1);\n+    Ok(b[0])\n+}\n+\n+fn read_exact<R: Read + ?Sized>(r: &mut R, sz: usize) -> io::Result<Vec<u8>> {\n+    let mut v = Vec::with_capacity(sz);\n+    try!(r.take(sz as u64).read_to_end(&mut v));\n+    assert_eq!(v.len(), sz);\n+    Ok(v)\n+}\n+\n /// Create a dummy TermInfo struct for msys terminals\n pub fn msys_terminfo() -> Box<TermInfo> {\n     let mut strings = HashMap::new();"}, {"sha": "f47921cbf5e6acc3e921dd04ea36b1b373a33b2e", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -12,46 +12,47 @@\n //!\n //! Does not support hashed database, only filesystem!\n \n-use std::old_io::File;\n-use std::old_io::fs::PathExtensions;\n use std::env;\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::path::PathBuf;\n \n /// Return path to database entry for `term`\n #[allow(deprecated)]\n-pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n+pub fn get_dbpath_for_term(term: &str) -> Option<Box<PathBuf>> {\n     if term.len() == 0 {\n         return None;\n     }\n \n-    let homedir = ::std::os::homedir();\n+    let homedir = env::home_dir();\n \n     let mut dirs_to_search = Vec::new();\n     let first_char = term.char_at(0);\n \n     // Find search directory\n-    match env::var(\"TERMINFO\") {\n-        Ok(dir) => dirs_to_search.push(Path::new(dir)),\n-        Err(..) => {\n+    match env::var_os(\"TERMINFO\") {\n+        Some(dir) => dirs_to_search.push(PathBuf::new(&dir)),\n+        None => {\n             if homedir.is_some() {\n                 // ncurses compatibility;\n                 dirs_to_search.push(homedir.unwrap().join(\".terminfo\"))\n             }\n             match env::var(\"TERMINFO_DIRS\") {\n                 Ok(dirs) => for i in dirs.split(':') {\n                     if i == \"\" {\n-                        dirs_to_search.push(Path::new(\"/usr/share/terminfo\"));\n+                        dirs_to_search.push(PathBuf::new(\"/usr/share/terminfo\"));\n                     } else {\n-                        dirs_to_search.push(Path::new(i));\n+                        dirs_to_search.push(PathBuf::new(i));\n                     }\n                 },\n                 // Found nothing in TERMINFO_DIRS, use the default paths:\n                 // According to  /etc/terminfo/README, after looking at\n                 // ~/.terminfo, ncurses will search /etc/terminfo, then\n                 // /lib/terminfo, and eventually /usr/share/terminfo.\n                 Err(..) => {\n-                    dirs_to_search.push(Path::new(\"/etc/terminfo\"));\n-                    dirs_to_search.push(Path::new(\"/lib/terminfo\"));\n-                    dirs_to_search.push(Path::new(\"/usr/share/terminfo\"));\n+                    dirs_to_search.push(PathBuf::new(\"/etc/terminfo\"));\n+                    dirs_to_search.push(PathBuf::new(\"/lib/terminfo\"));\n+                    dirs_to_search.push(PathBuf::new(\"/usr/share/terminfo\"));\n                 }\n             }\n         }\n@@ -61,13 +62,13 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n     for p in &dirs_to_search {\n         if p.exists() {\n             let f = first_char.to_string();\n-            let newp = p.join_many(&[&f[..], term]);\n+            let newp = p.join(&f).join(term);\n             if newp.exists() {\n                 return Some(box newp);\n             }\n             // on some installations the dir is named after the hex of the char (e.g. OS X)\n             let f = format!(\"{:x}\", first_char as uint);\n-            let newp = p.join_many(&[&f[..], term]);\n+            let newp = p.join(&f).join(term);\n             if newp.exists() {\n                 return Some(box newp);\n             }\n@@ -100,7 +101,7 @@ fn test_get_dbpath_for_term() {\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     fn x(t: &str) -> String {\n         let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n-        p.as_str().unwrap().to_string()\n+        p.to_str().unwrap().to_string()\n     };\n     assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n     assert!(get_dbpath_for_term(\"\") == None);"}, {"sha": "e309e7a6c221d2665994421b15cb2cdd066f65dd", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -38,10 +38,12 @@\n #![feature(core)]\n #![feature(int_uint)]\n #![feature(old_io)]\n-#![feature(old_path)]\n+#![feature(path)]\n+#![feature(fs)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n+#![feature(io)]\n \n extern crate getopts;\n extern crate serialize;\n@@ -65,13 +67,16 @@ use term::color::{Color, RED, YELLOW, GREEN, CYAN};\n use std::any::Any;\n use std::cmp;\n use std::collections::BTreeMap;\n+use std::env;\n use std::fmt;\n-use std::old_io::stdio::StdWriter;\n-use std::old_io::{File, ChanReader, ChanWriter};\n-use std::old_io;\n+use std::fs::File;\n+use std::io::{self, Write};\n use std::iter::repeat;\n use std::num::{Float, Int};\n-use std::env;\n+use std::old_io::stdio::StdWriter;\n+use std::old_io::{ChanReader, ChanWriter};\n+use std::old_io;\n+use std::path::{PathBuf};\n use std::sync::mpsc::{channel, Sender};\n use std::thread;\n use std::thunk::{Thunk, Invoke};\n@@ -287,7 +292,7 @@ pub struct TestOpts {\n     pub run_ignored: bool,\n     pub run_tests: bool,\n     pub run_benchmarks: bool,\n-    pub logfile: Option<Path>,\n+    pub logfile: Option<PathBuf>,\n     pub nocapture: bool,\n     pub color: ColorConfig,\n }\n@@ -376,7 +381,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     let run_ignored = matches.opt_present(\"ignored\");\n \n     let logfile = matches.opt_str(\"logfile\");\n-    let logfile = logfile.map(|s| Path::new(s));\n+    let logfile = logfile.map(|s| PathBuf::new(&s));\n \n     let run_benchmarks = matches.opt_present(\"bench\");\n     let run_tests = ! run_benchmarks ||\n@@ -446,11 +451,19 @@ struct ConsoleTestState<T> {\n     max_name_len: uint, // number of columns to fill when aligning names\n }\n \n+fn new2old(new: io::Error) -> old_io::IoError {\n+    old_io::IoError {\n+        kind: old_io::OtherIoError,\n+        desc: \"other error\",\n+        detail: Some(new.to_string()),\n+    }\n+}\n+\n impl<T: Writer> ConsoleTestState<T> {\n     pub fn new(opts: &TestOpts,\n                _: Option<T>) -> old_io::IoResult<ConsoleTestState<StdWriter>> {\n         let log_out = match opts.logfile {\n-            Some(ref path) => Some(try!(File::create(path))),\n+            Some(ref path) => Some(try!(File::create(path).map_err(new2old))),\n             None => None\n         };\n         let out = match term::stdout() {\n@@ -560,7 +573,7 @@ impl<T: Writer> ConsoleTestState<T> {\n     }\n \n     pub fn write_log(&mut self, test: &TestDesc,\n-                     result: &TestResult) -> old_io::IoResult<()> {\n+                     result: &TestResult) -> io::Result<()> {\n         match self.log_out {\n             None => Ok(()),\n             Some(ref mut o) => {\n@@ -646,7 +659,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> old_io:\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test, padding) => st.write_test_start(test, padding),\n             TeResult(test, result, stdout) => {\n-                try!(st.write_log(&test, &result));\n+                try!(st.write_log(&test, &result).map_err(new2old));\n                 try!(st.write_result(&result));\n                 match result {\n                     TrOk => st.passed += 1,"}, {"sha": "ac7f2f824cbbf9ab9c5d3dcab3fb911ad7ea8df0", "filename": "src/rustbook/book.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Fbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Fbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbook.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -10,14 +10,16 @@\n \n //! Basic data structures for representing a book.\n \n-use std::old_io::BufferedReader;\n+use std::io::prelude::*;\n+use std::io::BufReader;\n use std::iter;\n use std::iter::AdditiveIterator;\n+use std::path::{Path, PathBuf};\n \n pub struct BookItem {\n     pub title: String,\n-    pub path: Path,\n-    pub path_to_root: Path,\n+    pub path: PathBuf,\n+    pub path_to_root: PathBuf,\n     pub children: Vec<BookItem>,\n }\n \n@@ -76,7 +78,7 @@ impl Book {\n }\n \n /// Construct a book by parsing a summary (markdown table of contents).\n-pub fn parse_summary<R: Reader>(input: R, src: &Path) -> Result<Book, Vec<String>> {\n+pub fn parse_summary(input: &mut Read, src: &Path) -> Result<Book, Vec<String>> {\n     fn collapse(stack: &mut Vec<BookItem>,\n                 top_items: &mut Vec<BookItem>,\n                 to_level: usize) {\n@@ -100,16 +102,16 @@ pub fn parse_summary<R: Reader>(input: R, src: &Path) -> Result<Book, Vec<String\n     // always include the introduction\n     top_items.push(BookItem {\n         title: \"Introduction\".to_string(),\n-        path: Path::new(\"README.md\"),\n-        path_to_root: Path::new(\".\"),\n+        path: PathBuf::new(\"README.md\"),\n+        path_to_root: PathBuf::new(\".\"),\n         children: vec!(),\n     });\n \n-    for line_result in BufferedReader::new(input).lines() {\n+    for line_result in BufReader::new(input).lines() {\n         let line = match line_result {\n             Ok(line) => line,\n             Err(err) => {\n-                errors.push(err.desc.to_string()); // FIXME: include detail\n+                errors.push(err.to_string());\n                 return Err(errors);\n             }\n         };\n@@ -125,16 +127,16 @@ pub fn parse_summary<R: Reader>(input: R, src: &Path) -> Result<Book, Vec<String\n         let title = line[start_bracket + 1..end_bracket].to_string();\n         let indent = &line[..star_idx];\n \n-        let path_from_root = match src.join(given_path).path_relative_from(src) {\n-            Some(p) => p,\n+        let path_from_root = match src.join(given_path).relative_from(src) {\n+            Some(p) => p.to_path_buf(),\n             None => {\n                 errors.push(format!(\"paths in SUMMARY.md must be relative, \\\n                                      but path '{}' for section '{}' is not.\",\n                                      given_path, title));\n-                Path::new(\"\")\n+                PathBuf::new(\"\")\n             }\n         };\n-        let path_to_root = Path::new(iter::repeat(\"../\")\n+        let path_to_root = PathBuf::new(&iter::repeat(\"../\")\n                                          .take(path_from_root.components().count() - 1)\n                                          .collect::<String>());\n         let item = BookItem {"}, {"sha": "1fb30e15400efb7c8fa71965cd92cce3cfad98c7", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -11,13 +11,14 @@\n //! Implementation of the `build` subcommand, used to compile a book.\n \n use std::env;\n-use std::os;\n-use std::old_io;\n-use std::old_io::{fs, File, BufferedWriter, TempDir, IoResult};\n+use std::fs::{self, File, TempDir};\n+use std::io::prelude::*;\n+use std::io::{self, BufWriter};\n+use std::path::{Path, PathBuf};\n \n use subcommand::Subcommand;\n use term::Term;\n-use error::{Error, CliResult, CommandResult};\n+use error::{err, CliResult, CommandResult};\n use book;\n use book::{Book, BookItem};\n use css;\n@@ -29,17 +30,17 @@ struct Build;\n \n pub fn parse_cmd(name: &str) -> Option<Box<Subcommand>> {\n     if name == \"build\" {\n-        Some(box Build as Box<Subcommand>)\n+        Some(Box::new(Build))\n     } else {\n         None\n     }\n }\n \n-fn write_toc(book: &Book, path_to_root: &Path, out: &mut Writer) -> IoResult<()> {\n+fn write_toc(book: &Book, path_to_root: &Path, out: &mut Write) -> io::Result<()> {\n     fn walk_items(items: &[BookItem],\n                   section: &str,\n                   path_to_root: &Path,\n-                  out: &mut Writer) -> IoResult<()> {\n+                  out: &mut Write) -> io::Result<()> {\n         for (i, item) in items.iter().enumerate() {\n             try!(walk_item(item, &format!(\"{}{}.\", section, i + 1)[..], path_to_root, out));\n         }\n@@ -48,9 +49,9 @@ fn write_toc(book: &Book, path_to_root: &Path, out: &mut Writer) -> IoResult<()>\n     fn walk_item(item: &BookItem,\n                  section: &str,\n                  path_to_root: &Path,\n-                 out: &mut Writer) -> IoResult<()> {\n+                 out: &mut Write) -> io::Result<()> {\n         try!(writeln!(out, \"<li><a href='{}'><b>{}</b> {}</a>\",\n-                 path_to_root.join(item.path.with_extension(\"html\")).display(),\n+                 path_to_root.join(&item.path.with_extension(\"html\")).display(),\n                  section,\n                  item.title));\n         if !item.children.is_empty() {\n@@ -75,30 +76,35 @@ fn write_toc(book: &Book, path_to_root: &Path, out: &mut Writer) -> IoResult<()>\n fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n     let tmp = try!(TempDir::new(\"rust-book\"));\n \n-    for (section, item) in book.iter() {\n-        println!(\"{} {}\", section, item.title);\n-\n-        let out_path = tgt.join(item.path.dirname());\n+    for (_section, item) in book.iter() {\n+        let out_path = match item.path.parent() {\n+            Some(p) => tgt.join(p),\n+            None => tgt.to_path_buf(),\n+        };\n \n         let src;\n         if env::args().len() < 3 {\n-            src = os::getcwd().unwrap().clone();\n+            src = env::current_dir().unwrap().clone();\n         } else {\n-            src = Path::new(env::args().nth(2).unwrap().clone());\n+            src = PathBuf::new(&env::args().nth(2).unwrap());\n         }\n         // preprocess the markdown, rerouting markdown references to html references\n-        let markdown_data = try!(File::open(&src.join(&item.path)).read_to_string());\n-        let preprocessed_path = tmp.path().join(item.path.filename().unwrap());\n+        let mut markdown_data = String::new();\n+        try!(File::open(&src.join(&item.path)).and_then(|mut f| {\n+            f.read_to_string(&mut markdown_data)\n+        }));\n+        let preprocessed_path = tmp.path().join(item.path.file_name().unwrap());\n         {\n             let urls = markdown_data.replace(\".md)\", \".html)\");\n-            try!(File::create(&preprocessed_path)\n-                      .write_str(&urls[..]));\n+            try!(File::create(&preprocessed_path).and_then(|mut f| {\n+                f.write_all(urls.as_bytes())\n+            }));\n         }\n \n         // write the prelude to a temporary HTML file for rustdoc inclusion\n         let prelude = tmp.path().join(\"prelude.html\");\n         {\n-            let mut toc = BufferedWriter::new(try!(File::create(&prelude)));\n+            let mut toc = BufWriter::new(try!(File::create(&prelude)));\n             try!(writeln!(&mut toc, r#\"<div id=\"nav\">\n                 <button id=\"toggle-nav\">\n                   <span class=\"sr-only\">Toggle navigation</span>\n@@ -115,12 +121,12 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n         // write the postlude to a temporary HTML file for rustdoc inclusion\n         let postlude = tmp.path().join(\"postlude.html\");\n         {\n-            let mut toc = BufferedWriter::new(try!(File::create(&postlude)));\n-            try!(toc.write_str(javascript::JAVASCRIPT));\n+            let mut toc = BufWriter::new(try!(File::create(&postlude)));\n+            try!(toc.write_all(javascript::JAVASCRIPT.as_bytes()));\n             try!(writeln!(&mut toc, \"</div></div>\"));\n         }\n \n-        try!(fs::mkdir_recursive(&out_path, old_io::USER_DIR));\n+        try!(fs::create_dir_all(&out_path));\n \n         let rustdoc_args: &[String] = &[\n             \"\".to_string(),\n@@ -135,7 +141,7 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n         if output_result != 0 {\n             let message = format!(\"Could not execute `rustdoc` with {:?}: {}\",\n                                   rustdoc_args, output_result);\n-            return Err(box message as Box<Error>);\n+            return Err(err(&message));\n         }\n     }\n \n@@ -150,28 +156,30 @@ impl Subcommand for Build {\n     }\n     fn usage(&self) {}\n     fn execute(&mut self, term: &mut Term) -> CommandResult<()> {\n-        let cwd = os::getcwd().unwrap();\n+        let cwd = env::current_dir().unwrap();\n         let src;\n         let tgt;\n \n         if env::args().len() < 3 {\n             src = cwd.clone();\n         } else {\n-            src = Path::new(env::args().nth(2).unwrap().clone());\n+            src = PathBuf::new(&env::args().nth(2).unwrap());\n         }\n \n         if env::args().len() < 4 {\n             tgt = cwd.join(\"_book\");\n         } else {\n-            tgt = Path::new(env::args().nth(3).unwrap().clone());\n+            tgt = PathBuf::new(&env::args().nth(3).unwrap());\n         }\n \n-        try!(fs::mkdir(&tgt, old_io::USER_DIR));\n+        try!(fs::create_dir(&tgt));\n \n-        try!(File::create(&tgt.join(\"rust-book.css\")).write_str(css::STYLE));\n+        try!(File::create(&tgt.join(\"rust-book.css\")).and_then(|mut f| {\n+            f.write_all(css::STYLE.as_bytes())\n+        }));\n \n-        let summary = try!(File::open(&src.join(\"SUMMARY.md\")));\n-        match book::parse_summary(summary, &src) {\n+        let mut summary = try!(File::open(&src.join(\"SUMMARY.md\")));\n+        match book::parse_summary(&mut summary, &src) {\n             Ok(book) => {\n                 // execute rustdoc on the whole book\n                 render(&book, &tgt)\n@@ -182,7 +190,7 @@ impl Subcommand for Build {\n                     term.err(&format!(\"error: {}\", err)[..]);\n                 }\n \n-                Err(box format!(\"{} errors occurred\", n) as Box<Error>)\n+                Err(err(&format!(\"{} errors occurred\", n)))\n             }\n         }\n     }"}, {"sha": "294b4e556694ad2be1c935ab5749226a392877bf", "filename": "src/rustbook/error.rs", "status": "modified", "additions": 10, "deletions": 58, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ferror.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -10,74 +10,26 @@\n \n //! Error handling utilities. WIP.\n \n+use std::error::Error;\n use std::fmt;\n-use std::fmt::{Debug, Formatter};\n-\n-use std::old_io::IoError;\n \n pub type CliError = Box<Error + 'static>;\n pub type CliResult<T> = Result<T, CliError>;\n \n pub type CommandError = Box<Error + 'static>;\n pub type CommandResult<T> = Result<T, CommandError>;\n \n-pub trait Error {\n-    fn description(&self) -> &str;\n-\n-    fn detail(&self) -> Option<&str> { None }\n-    fn cause(&self) -> Option<&Error> { None }\n-}\n-\n-pub trait FromError<E> {\n-    fn from_err(err: E) -> Self;\n-}\n-\n-impl Debug for Box<Error + 'static> {\n-    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.description())\n-    }\n-}\n-\n-impl<E: Error + 'static> FromError<E> for Box<Error + 'static> {\n-    fn from_err(err: E) -> Box<Error + 'static> {\n-        box err as Box<Error>\n-    }\n-}\n+pub fn err(s: &str) -> CliError {\n+    struct E(String);\n \n-impl<'a> Error for &'a str {\n-    fn description<'b>(&'b self) -> &'b str {\n-        *self\n+    impl Error for E {\n+        fn description(&self) -> &str { &self.0 }\n     }\n-}\n-\n-impl Error for String {\n-    fn description<'a>(&'a self) -> &'a str {\n-        &self[..]\n+    impl fmt::Display for E {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            self.0.fmt(f)\n+        }\n     }\n-}\n-\n-impl<'a> Error for Box<Error + 'a> {\n-    fn description(&self) -> &str { (**self).description() }\n-    fn detail(&self) -> Option<&str> { (**self).detail() }\n-    fn cause(&self) -> Option<&Error> { (**self).cause() }\n-}\n-\n-impl FromError<()> for () {\n-    fn from_err(_: ()) -> () { () }\n-}\n \n-impl FromError<IoError> for IoError {\n-    fn from_err(error: IoError) -> IoError { error }\n+    Box::new(E(s.to_string()))\n }\n-\n-impl Error for IoError {\n-    fn description(&self) -> &str {\n-        self.desc\n-    }\n-    fn detail(&self) -> Option<&str> {\n-        self.detail.as_ref().map(|s| &s[..])\n-    }\n-}\n-\n-\n-//fn iter_map_err<T, U, E, I: Iterator<Result<T,E>>>(iter: I,"}, {"sha": "995d2f2494a490b1845344aaa86886152a733bd9", "filename": "src/rustbook/help.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Fhelp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Fhelp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fhelp.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -19,7 +19,7 @@ struct Help;\n \n pub fn parse_cmd(name: &str) -> Option<Box<Subcommand>> {\n     match name {\n-        \"help\" | \"--help\" | \"-h\" | \"-?\" => Some(box Help as Box<Subcommand>),\n+        \"help\" | \"--help\" | \"-h\" | \"-?\" => Some(Box::new(Help)),\n         _ => None\n     }\n }"}, {"sha": "848f960839e6e0c4cd56fb5ec4823e9c1112cc7a", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -8,31 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(box_syntax)]\n-#![feature(collections)]\n+#![deny(warnings)]\n+\n #![feature(core)]\n+#![feature(exit_status)]\n+#![feature(fs)]\n+#![feature(io)]\n #![feature(old_io)]\n-#![feature(env)]\n-#![feature(os)]\n-#![feature(old_path)]\n+#![feature(path)]\n #![feature(rustdoc)]\n+#![feature(tempdir)]\n \n extern crate rustdoc;\n \n use std::env;\n+use std::error::Error;\n use subcommand::Subcommand;\n use term::Term;\n \n-macro_rules! try (\n-    ($expr:expr) => ({\n-        use error;\n-        match $expr {\n-            Ok(val) => val,\n-            Err(err) => return Err(error::FromError::from_err(err))\n-        }\n-    })\n-);\n-\n mod term;\n mod error;\n mod book;\n@@ -56,15 +49,12 @@ fn main() {\n     } else {\n         match subcommand::parse_name(&cmd[1][..]) {\n             Some(mut subcmd) => {\n-                match subcmd.parse_args(cmd.tail()) {\n+                match subcmd.parse_args(&cmd[..cmd.len()-1]) {\n                     Ok(_) => {\n                         match subcmd.execute(&mut term) {\n                             Ok(_) => (),\n                             Err(err) => {\n-                                term.err(&format!(\"error: {}\", err.description())[..]);\n-                                err.detail().map(|detail| {\n-                                    term.err(&format!(\"detail: {}\", detail)[..]);\n-                                });\n+                                term.err(&format!(\"error: {}\", err));\n                             }\n                         }\n                     }"}, {"sha": "2fa7b7eed7b05d77a8bd6f58ea0b29c7a4f7bc48", "filename": "src/rustbook/serve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Fserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Fserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fserve.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -19,7 +19,7 @@ struct Serve;\n \n pub fn parse_cmd(name: &str) -> Option<Box<Subcommand>> {\n     if name == \"serve\" {\n-        Some(box Serve as Box<Subcommand>)\n+        Some(Box::new(Serve))\n     } else {\n         None\n     }"}, {"sha": "06595cb0455a31d1bb4cecc50bbd546688bcb952", "filename": "src/rustbook/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fterm.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -21,7 +21,7 @@ pub struct Term {\n impl Term {\n     pub fn new() -> Term {\n         Term {\n-            err: box stdio::stderr() as Box<Writer>,\n+            err: Box::new(stdio::stderr())\n         }\n     }\n "}, {"sha": "72df0768e7b9b5c70972123ec3c2425db87bbafe", "filename": "src/rustbook/test.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Frustbook%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ftest.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -11,19 +11,19 @@\n //! Implementation of the `test` subcommand. Just a stub for now.\n \n use subcommand::Subcommand;\n-use error::CliResult;\n-use error::CommandResult;\n-use error::Error;\n+use error::{err, CliResult, CommandResult};\n use term::Term;\n use book;\n-use std::old_io::{Command, File};\n-use std::os;\n+\n+use std::fs::File;\n+use std::env;\n+use std::process::Command;\n \n struct Test;\n \n pub fn parse_cmd(name: &str) -> Option<Box<Subcommand>> {\n     if name == \"test\" {\n-        Some(box Test as Box<Subcommand>)\n+        Some(Box::new(Test))\n     } else {\n         None\n     }\n@@ -35,11 +35,11 @@ impl Subcommand for Test {\n     }\n     fn usage(&self) {}\n     fn execute(&mut self, term: &mut Term) -> CommandResult<()> {\n-        let cwd = os::getcwd().unwrap();\n+        let cwd = env::current_dir().unwrap();\n         let src = cwd.clone();\n \n-        let summary = File::open(&src.join(\"SUMMARY.md\"));\n-        match book::parse_summary(summary, &src) {\n+        let mut summary = try!(File::open(&src.join(\"SUMMARY.md\")));\n+        match book::parse_summary(&mut summary, &src) {\n             Ok(book) => {\n                 for (_, item) in book.iter() {\n                     let output_result = Command::new(\"rustdoc\")\n@@ -50,15 +50,15 @@ impl Subcommand for Test {\n                         Ok(output) => {\n                             if !output.status.success() {\n                                 term.err(&format!(\"{}\\n{}\",\n-                                         String::from_utf8_lossy(&output.output[..]),\n-                                         String::from_utf8_lossy(&output.error[..]))[..]);\n-                                return Err(box \"Some tests failed.\" as Box<Error>);\n+                                         String::from_utf8_lossy(&output.stdout),\n+                                         String::from_utf8_lossy(&output.stderr)));\n+                                return Err(err(\"some tests failed\"));\n                             }\n \n                         }\n                         Err(e) => {\n-                            let message = format!(\"Could not execute `rustdoc`: {}\", e);\n-                            return Err(box message as Box<Error>);\n+                            let message = format!(\"could not execute `rustdoc`: {}\", e);\n+                            return Err(err(&message))\n                         }\n                     }\n                 }\n@@ -67,7 +67,7 @@ impl Subcommand for Test {\n                 for err in errors {\n                     term.err(&err[..]);\n                 }\n-                return Err(box \"There was an error.\" as Box<Error>);\n+                return Err(err(\"there was an error\"))\n             }\n         }\n         Ok(()) // lol"}, {"sha": "8791481d9e75e63b42ac90350468f0b3d5dc5244", "filename": "src/test/compile-fail/empty-extern-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n // compile-flags: --extern std=\n-// error-pattern: is not a file\n+// error-pattern: can't find crate for `std`\n \n fn main() {}"}, {"sha": "3e548981f1ed4676f86801259a8573090f35044a", "filename": "src/test/parse-fail/circular_modules_main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Ftest%2Fparse-fail%2Fcircular_modules_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Ftest%2Fparse-fail%2Fcircular_modules_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fcircular_modules_main.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n #[path = \"circular_modules_hello.rs\"]\n-mod circular_modules_hello; //~ERROR: circular modules\n+mod circular_modules_hello; //~ ERROR: circular modules\n \n pub fn hi_str() -> String {\n-  \"Hi!\".to_string()\n+    \"Hi!\".to_string()\n }\n \n fn main() {"}, {"sha": "b2608cc0b925ef41056586b1b1332292b78c4635", "filename": "src/test/parse-fail/issue-5806.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Ftest%2Fparse-fail%2Fissue-5806.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Ftest%2Fparse-fail%2Fissue-5806.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-5806.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -8,15 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+// ignore-windows\n+// ignore-freebsd\n \n #[path = \"../compile-fail\"]\n mod foo; //~ ERROR: a directory"}, {"sha": "1ed816ed7290a87645737874135e5a3169a04de4", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -18,6 +18,8 @@ use rustc::session::config::{basic_options, build_configuration, Input, OutputTy\n use rustc_driver::driver::{compile_input, CompileController};\n use syntax::diagnostics::registry::Registry;\n \n+use std::path::PathBuf;\n+\n fn main() {\n     let src = r#\"\n     fn main() {}\n@@ -29,9 +31,9 @@ fn main() {\n         panic!(\"expected rustc path\");\n     }\n \n-    let tmpdir = Path::new(&args[1]);\n+    let tmpdir = PathBuf::new(&args[1]);\n \n-    let mut sysroot = Path::new(&args[3]);\n+    let mut sysroot = PathBuf::new(&args[3]);\n     sysroot.pop();\n     sysroot.pop();\n \n@@ -40,7 +42,7 @@ fn main() {\n     compile(src.to_string(), tmpdir.join(\"out\"), sysroot.clone());\n }\n \n-fn basic_sess(sysroot: Path) -> Session {\n+fn basic_sess(sysroot: PathBuf) -> Session {\n     let mut opts = basic_options();\n     opts.output_types = vec![OutputTypeExe];\n     opts.maybe_sysroot = Some(sysroot);\n@@ -51,7 +53,7 @@ fn basic_sess(sysroot: Path) -> Session {\n     sess\n }\n \n-fn compile(code: String, output: Path, sysroot: Path) {\n+fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n     let sess = basic_sess(sysroot);\n     let cfg = build_configuration(&sess);\n     let control = CompileController::basic();"}, {"sha": "75a968c3f811330de7eda03ceacbbfbd5e54e7d8", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc722a4dd3e8110a8bf7e62eea977e99e3a3d128/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=cc722a4dd3e8110a8bf7e62eea977e99e3a3d128", "patch": "@@ -25,6 +25,7 @@ use rustc::session::config::{self, Input};\n use rustc_driver::{driver, CompilerCalls, Compilation};\n use syntax::diagnostics;\n \n+use std::path::PathBuf;\n \n struct TestCalls {\n     count: u32\n@@ -43,25 +44,26 @@ impl<'a> CompilerCalls<'a> for TestCalls {\n                      _: &getopts::Matches,\n                      _: &Session,\n                      _: &Input,\n-                     _: &Option<Path>,\n-                     _: &Option<Path>)\n+                     _: &Option<PathBuf>,\n+                     _: &Option<PathBuf>)\n                      -> Compilation {\n         self.count *= 3;\n         Compilation::Stop\n     }\n \n-    fn some_input(&mut self, input: Input, input_path: Option<Path>) -> (Input, Option<Path>) {\n+    fn some_input(&mut self, input: Input, input_path: Option<PathBuf>)\n+                  -> (Input, Option<PathBuf>) {\n         self.count *= 5;\n         (input, input_path)\n     }\n \n     fn no_input(&mut self,\n                 _: &getopts::Matches,\n                 _: &config::Options,\n-                _: &Option<Path>,\n-                _: &Option<Path>,\n+                _: &Option<PathBuf>,\n+                _: &Option<PathBuf>,\n                 _: &diagnostics::registry::Registry)\n-                -> Option<(Input, Option<Path>)> {\n+                -> Option<(Input, Option<PathBuf>)> {\n         panic!(\"This shouldn't happen\");\n     }\n "}]}