{"sha": "a0a987722e8a38494d818443819ad0853771b37e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwYTk4NzcyMmU4YTM4NDk0ZDgxODQ0MzgxOWFkMDg1Mzc3MWIzN2U=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-05-11T16:59:35Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-05-11T20:50:23Z"}, "message": "save-analysis: attempt number 2 at a JSON version", "tree": {"sha": "b44af6890809a3f4d1cd7e930d335d9426c7f391", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b44af6890809a3f4d1cd7e930d335d9426c7f391"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0a987722e8a38494d818443819ad0853771b37e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0a987722e8a38494d818443819ad0853771b37e", "html_url": "https://github.com/rust-lang/rust/commit/a0a987722e8a38494d818443819ad0853771b37e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0a987722e8a38494d818443819ad0853771b37e/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e37f8593e42335829e98fed27b8ececbad61a05d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e37f8593e42335829e98fed27b8ececbad61a05d", "html_url": "https://github.com/rust-lang/rust/commit/e37f8593e42335829e98fed27b8ececbad61a05d"}], "stats": {"total": 484, "additions": 423, "deletions": 61}, "files": [{"sha": "e7cc534c5b55537d45dce95db500d26e160e6625", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0a987722e8a38494d818443819ad0853771b37e/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0a987722e8a38494d818443819ad0853771b37e/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=a0a987722e8a38494d818443819ad0853771b37e", "patch": "@@ -331,7 +331,7 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n         self.record(\"type_ref\", data.span, values);\n     }\n \n-    fn typedef(&mut self, data: TypedefData) {\n+    fn typedef(&mut self, data: TypeDefData) {\n         let id = data.id.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),"}, {"sha": "2275a1c5c65f2720714d9a5861602d7bbdfc4bc3", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0a987722e8a38494d818443819ad0853771b37e/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0a987722e8a38494d818443819ad0853771b37e/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=a0a987722e8a38494d818443819ad0853771b37e", "patch": "@@ -62,7 +62,7 @@ pub enum Data {\n     /// Data for a tuple variant.\n     TupleVariantData(TupleVariantData),\n     /// Data for a typedef.\n-    TypeDefData(TypedefData),\n+    TypeDefData(TypeDefData),\n     /// Data for a reference to a type or trait.\n     TypeRefData(TypeRefData),\n     /// Data for a use statement.\n@@ -97,6 +97,7 @@ pub struct ExternalCrateData {\n #[derive(Clone, Debug, RustcEncodable)]\n pub struct EnumData {\n     pub id: NodeId,\n+    pub name: String,\n     pub value: String,\n     pub qualname: String,\n     pub span: Span,\n@@ -131,6 +132,7 @@ pub struct FunctionData {\n     pub declaration: Option<DefId>,\n     pub span: Span,\n     pub scope: NodeId,\n+    pub value: String,\n }\n \n /// Data about a function call.\n@@ -205,9 +207,11 @@ pub struct MethodCallData {\n #[derive(Clone, Debug, RustcEncodable)]\n pub struct MethodData {\n     pub id: NodeId,\n+    pub name: String,\n     pub qualname: String,\n     pub span: Span,\n     pub scope: NodeId,\n+    pub value: String,\n }\n \n /// Data for modules.\n@@ -233,6 +237,7 @@ pub struct ModRefData {\n #[derive(Debug, RustcEncodable)]\n pub struct StructData {\n     pub span: Span,\n+    pub name: String,\n     pub id: NodeId,\n     pub ctor_id: NodeId,\n     pub qualname: String,\n@@ -243,6 +248,7 @@ pub struct StructData {\n #[derive(Debug, RustcEncodable)]\n pub struct StructVariantData {\n     pub span: Span,\n+    pub name: String,\n     pub id: NodeId,\n     pub qualname: String,\n     pub type_value: String,\n@@ -254,6 +260,7 @@ pub struct StructVariantData {\n pub struct TraitData {\n     pub span: Span,\n     pub id: NodeId,\n+    pub name: String,\n     pub qualname: String,\n     pub scope: NodeId,\n     pub value: String\n@@ -272,8 +279,9 @@ pub struct TupleVariantData {\n \n /// Data for a typedef.\n #[derive(Debug, RustcEncodable)]\n-pub struct TypedefData {\n+pub struct TypeDefData {\n     pub id: NodeId,\n+    pub name: String,\n     pub span: Span,\n     pub qualname: String,\n     pub value: String,"}, {"sha": "18241b394cc17474986d0b9df95d53daa4d7b5dd", "filename": "src/librustc_save_analysis/dump.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0a987722e8a38494d818443819ad0853771b37e/src%2Flibrustc_save_analysis%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0a987722e8a38494d818443819ad0853771b37e/src%2Flibrustc_save_analysis%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump.rs?ref=a0a987722e8a38494d818443819ad0853771b37e", "patch": "@@ -30,7 +30,7 @@ pub trait Dump {\n     fn trait_data(&mut self, TraitData) {}\n     fn tuple_variant(&mut self, TupleVariantData) {}\n     fn type_ref(&mut self, TypeRefData) {}\n-    fn typedef(&mut self, TypedefData) {}\n+    fn typedef(&mut self, TypeDefData) {}\n     fn use_data(&mut self, UseData) {}\n     fn use_glob(&mut self, UseGlobData) {}\n     fn variable(&mut self, VariableData) {}"}, {"sha": "6f84ccc9e36d4ed2e2e9ee3ce7686222674de641", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a0a987722e8a38494d818443819ad0853771b37e/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0a987722e8a38494d818443819ad0853771b37e/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=a0a987722e8a38494d818443819ad0853771b37e", "patch": "@@ -397,9 +397,11 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 if !self.span.filter_generated(Some(method_data.span), span) {\n                     self.dumper.method(MethodData {\n                         id: method_data.id,\n+                        name: method_data.name,\n                         span: method_data.span,\n                         scope: method_data.scope,\n                         qualname: method_data.qualname.clone(),\n+                        value: String::new(), // TODO\n                     }.lower(self.tcx));\n                 }\n             }\n@@ -455,16 +457,18 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let param_sub_spans = self.span.spans_for_ty_params(full_span,\n                                                             (generics.ty_params.len() as isize));\n         for (param, param_ss) in generics.ty_params.iter().zip(param_sub_spans) {\n+            let name = escape(self.span.snippet(param_ss));\n             // Append $id to name to make sure each one is unique\n-            let name = format!(\"{}::{}${}\",\n-                               prefix,\n-                               escape(self.span.snippet(param_ss)),\n-                               id);\n+            let qualname = format!(\"{}::{}${}\",\n+                                   prefix,\n+                                   name,\n+                                   id);\n             if !self.span.filter_generated(Some(param_ss), full_span) {\n-                self.dumper.typedef(TypedefData {\n+                self.dumper.typedef(TypeDefData {\n                     span: param_ss,\n+                    name: name,\n                     id: param.id,\n-                    qualname: name,\n+                    qualname: qualname,\n                     value: String::new()\n                 }.lower(self.tcx));\n             }\n@@ -548,6 +552,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             self.dumper.struct_data(StructData {\n                 span: sub_span.expect(\"No span found for struct\"),\n                 id: item.id,\n+                name: item.ident.to_string(),\n                 ctor_id: def.id(),\n                 qualname: qualname.clone(),\n                 scope: self.cur_scope,\n@@ -580,10 +585,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n \n         for variant in &enum_definition.variants {\n-            let name = &variant.node.name.name.as_str();\n+            let name = variant.node.name.name.to_string();\n             let mut qualname = enum_data.qualname.clone();\n             qualname.push_str(\"::\");\n-            qualname.push_str(name);\n+            qualname.push_str(&name);\n             let val = self.span.snippet(variant.span);\n \n             match variant.node.data {\n@@ -593,6 +598,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         self.dumper.struct_variant(StructVariantData {\n                             span: sub_span.expect(\"No span found for struct variant\"),\n                             id: variant.node.data.id(),\n+                            name: name,\n                             qualname: qualname,\n                             type_value: enum_data.qualname.clone(),\n                             value: val,\n@@ -679,6 +685,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             self.dumper.trait_data(TraitData {\n                 span: sub_span.expect(\"No span found for trait\"),\n                 id: item.id,\n+                name: item.ident.to_string(),\n                 qualname: qualname.clone(),\n                 scope: self.cur_scope,\n                 value: val\n@@ -1107,8 +1114,9 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 let value = ty_to_string(&ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 if !self.span.filter_generated(sub_span, item.span) {\n-                    self.dumper.typedef(TypedefData {\n+                    self.dumper.typedef(TypeDefData {\n                         span: sub_span.expect(\"No span found for typedef\"),\n+                        name: item.ident.to_string(),\n                         id: item.id,\n                         qualname: qualname.clone(),\n                         value: value"}, {"sha": "dc51c41f296f20dd00b6eee37b684199ba072735", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a0a987722e8a38494d818443819ad0853771b37e/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0a987722e8a38494d818443819ad0853771b37e/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=a0a987722e8a38494d818443819ad0853771b37e", "patch": "@@ -86,6 +86,7 @@ impl Lower for data::CratePreludeData {\n pub struct EnumData {\n     pub id: DefId,\n     pub value: String,\n+    pub name: String,\n     pub qualname: String,\n     pub span: SpanData,\n     pub scope: DefId,\n@@ -97,6 +98,7 @@ impl Lower for data::EnumData {\n     fn lower(self, tcx: TyCtxt) -> EnumData {\n         EnumData {\n             id: make_def_id(self.id, &tcx.map),\n+            name: self.name,\n             value: self.value,\n             qualname: self.qualname,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n@@ -160,6 +162,7 @@ pub struct FunctionData {\n     pub declaration: Option<DefId>,\n     pub span: SpanData,\n     pub scope: DefId,\n+    pub value: String,\n }\n \n impl Lower for data::FunctionData {\n@@ -173,6 +176,7 @@ impl Lower for data::FunctionData {\n             declaration: self.declaration,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.map),\n+            value: self.value,\n         }\n     }\n }\n@@ -268,7 +272,6 @@ pub struct MacroUseData {\n     // we use the callee span to reference the associated macro definition.\n     pub callee_span: SpanData,\n     pub scope: DefId,\n-    pub imported: bool,\n }\n \n impl Lower for data::MacroUseData {\n@@ -281,7 +284,6 @@ impl Lower for data::MacroUseData {\n             qualname: self.qualname,\n             callee_span: SpanData::from_span(self.callee_span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.map),\n-            imported: self.imported,\n         }\n     }\n }\n@@ -312,9 +314,11 @@ impl Lower for data::MethodCallData {\n #[derive(Clone, Debug, RustcEncodable)]\n pub struct MethodData {\n     pub id: DefId,\n+    pub name: String,\n     pub qualname: String,\n     pub span: SpanData,\n     pub scope: DefId,\n+    pub value: String,\n }\n \n impl Lower for data::MethodData {\n@@ -323,9 +327,11 @@ impl Lower for data::MethodData {\n     fn lower(self, tcx: TyCtxt) -> MethodData {\n         MethodData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            name: self.name,\n             scope: make_def_id(self.scope, &tcx.map),\n             id: make_def_id(self.id, &tcx.map),\n             qualname: self.qualname,\n+            value: self.value,\n         }\n     }\n }\n@@ -381,6 +387,7 @@ impl Lower for data::ModRefData {\n #[derive(Debug, RustcEncodable)]\n pub struct StructData {\n     pub span: SpanData,\n+    pub name: String,\n     pub id: DefId,\n     pub ctor_id: DefId,\n     pub qualname: String,\n@@ -394,6 +401,7 @@ impl Lower for data::StructData {\n     fn lower(self, tcx: TyCtxt) -> StructData {\n         StructData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            name: self.name,\n             id: make_def_id(self.id, &tcx.map),\n             ctor_id: make_def_id(self.ctor_id, &tcx.map),\n             qualname: self.qualname,\n@@ -406,6 +414,7 @@ impl Lower for data::StructData {\n #[derive(Debug, RustcEncodable)]\n pub struct StructVariantData {\n     pub span: SpanData,\n+    pub name: String,\n     pub id: DefId,\n     pub qualname: String,\n     pub type_value: String,\n@@ -419,6 +428,7 @@ impl Lower for data::StructVariantData {\n     fn lower(self, tcx: TyCtxt) -> StructVariantData {\n         StructVariantData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            name: self.name,\n             id: make_def_id(self.id, &tcx.map),\n             qualname: self.qualname,\n             type_value: self.type_value,\n@@ -431,6 +441,7 @@ impl Lower for data::StructVariantData {\n #[derive(Debug, RustcEncodable)]\n pub struct TraitData {\n     pub span: SpanData,\n+    pub name: String,\n     pub id: DefId,\n     pub qualname: String,\n     pub scope: DefId,\n@@ -443,6 +454,7 @@ impl Lower for data::TraitData {\n     fn lower(self, tcx: TyCtxt) -> TraitData {\n         TraitData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            name: self.name,\n             id: make_def_id(self.id, &tcx.map),\n             qualname: self.qualname,\n             scope: make_def_id(self.scope, &tcx.map),\n@@ -480,19 +492,21 @@ impl Lower for data::TupleVariantData {\n \n /// Data for a typedef.\n #[derive(Debug, RustcEncodable)]\n-pub struct TypedefData {\n+pub struct TypeDefData {\n     pub id: DefId,\n+    pub name: String,\n     pub span: SpanData,\n     pub qualname: String,\n     pub value: String,\n }\n \n-impl Lower for data::TypedefData {\n-    type Target = TypedefData;\n+impl Lower for data::TypeDefData {\n+    type Target = TypeDefData;\n \n-    fn lower(self, tcx: TyCtxt) -> TypedefData {\n-        TypedefData {\n+    fn lower(self, tcx: TyCtxt) -> TypeDefData {\n+        TypeDefData {\n             id: make_def_id(self.id, &tcx.map),\n+            name: self.name,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             qualname: self.qualname,\n             value: self.value,"}, {"sha": "156a6f5cc971d2a33ee9c9761e2612f46fcc47c8", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 370, "deletions": 41, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/a0a987722e8a38494d818443819ad0853771b37e/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0a987722e8a38494d818443819ad0853771b37e/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=a0a987722e8a38494d818443819ad0853771b37e", "patch": "@@ -10,73 +10,402 @@\n \n use std::io::Write;\n \n+use rustc::hir::def_id::DefId;\n use rustc_serialize::json::as_json;\n \n use super::external_data::*;\n use super::dump::Dump;\n \n pub struct JsonDumper<'b, W: Write + 'b> {\n     output: &'b mut W,\n-    first: bool,\n+    result: Analysis,\n }\n \n impl<'b, W: Write> JsonDumper<'b, W> {\n     pub fn new(writer: &'b mut W) -> JsonDumper<'b, W> {\n-        if let Err(_) = write!(writer, \"[\") {\n-            error!(\"Error writing output\");\n-        }\n-        JsonDumper { output: writer, first: true }\n+        JsonDumper { output: writer, result: Analysis::new() }\n     }\n }\n \n impl<'b, W: Write> Drop for JsonDumper<'b, W> {\n     fn drop(&mut self) {\n-        if let Err(_) = write!(self.output, \"]\") {\n+        if let Err(_) = write!(self.output, \"{}\", as_json(&self.result)) {\n             error!(\"Error writing output\");\n         }\n     }\n }\n \n macro_rules! impl_fn {\n-    ($fn_name: ident, $data_type: ident) => {\n+    ($fn_name: ident, $data_type: ident, $bin: ident) => {\n         fn $fn_name(&mut self, data: $data_type) {\n-            if self.first {\n-                self.first = false;\n-            } else {\n-                if let Err(_) = write!(self.output, \",\") {\n-                    error!(\"Error writing output\");\n-                }\n-            }\n-            if let Err(_) = write!(self.output, \"{}\", as_json(&data)) {\n-                error!(\"Error writing output '{}'\", as_json(&data));\n-            }\n+            self.result.$bin.push(From::from(data));\n         }\n     }\n }\n \n impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n-    impl_fn!(crate_prelude, CratePreludeData);\n-    impl_fn!(enum_data, EnumData);\n-    impl_fn!(extern_crate, ExternCrateData);\n-    impl_fn!(impl_data, ImplData);\n-    impl_fn!(inheritance, InheritanceData);\n-    impl_fn!(function, FunctionData);\n-    impl_fn!(function_ref, FunctionRefData);\n-    impl_fn!(function_call, FunctionCallData);\n-    impl_fn!(method, MethodData);\n-    impl_fn!(method_call, MethodCallData);\n-    impl_fn!(macro_data, MacroData);\n-    impl_fn!(macro_use, MacroUseData);\n-    impl_fn!(mod_data, ModData);\n-    impl_fn!(mod_ref, ModRefData);\n-    impl_fn!(struct_data, StructData);\n-    impl_fn!(struct_variant, StructVariantData);\n-    impl_fn!(trait_data, TraitData);\n-    impl_fn!(tuple_variant, TupleVariantData);\n-    impl_fn!(type_ref, TypeRefData);\n-    impl_fn!(typedef, TypedefData);\n-    impl_fn!(use_data, UseData);\n-    impl_fn!(use_glob, UseGlobData);\n-    impl_fn!(variable, VariableData);\n-    impl_fn!(variable_ref, VariableRefData);\n+    fn crate_prelude(&mut self, data: CratePreludeData) {\n+        self.result.prelude = Some(data)\n+    }\n+\n+    impl_fn!(extern_crate, ExternCrateData, imports);\n+    impl_fn!(use_data, UseData, imports);\n+    impl_fn!(use_glob, UseGlobData, imports);\n+\n+    impl_fn!(enum_data, EnumData, defs);\n+    impl_fn!(tuple_variant, TupleVariantData, defs);\n+    impl_fn!(struct_variant, StructVariantData, defs);\n+    impl_fn!(struct_data, StructData, defs);\n+    impl_fn!(trait_data, TraitData, defs);\n+    impl_fn!(function, FunctionData, defs);\n+    impl_fn!(method, MethodData, defs);\n+    impl_fn!(macro_data, MacroData, defs);\n+    impl_fn!(mod_data, ModData, defs);\n+    impl_fn!(typedef, TypeDefData, defs);\n+    impl_fn!(variable, VariableData, defs);\n+\n+    impl_fn!(function_ref, FunctionRefData, refs);\n+    impl_fn!(function_call, FunctionCallData, refs);\n+    impl_fn!(method_call, MethodCallData, refs);\n+    impl_fn!(mod_ref, ModRefData, refs);\n+    impl_fn!(type_ref, TypeRefData, refs);\n+    impl_fn!(variable_ref, VariableRefData, refs);\n+\n+    impl_fn!(macro_use, MacroUseData, macro_refs);\n+\n+    // FIXME store this instead of throwing it away.\n+    fn impl_data(&mut self, _data: ImplData) {}\n+    fn inheritance(&mut self, _data: InheritanceData) {}\n+}\n+\n+// FIXME do we want to change ExternalData to this mode? It will break DXR.\n+// FIXME methods. The defs have information about possible overriding and the\n+// refs have decl information (e.g., a trait method where we know the required\n+// method, but not the supplied method). In both cases, we are currently\n+// ignoring it.\n+\n+#[derive(Debug, RustcEncodable)]\n+struct Analysis {\n+    prelude: Option<CratePreludeData>,\n+    imports: Vec<Import>,\n+    defs: Vec<Def>,\n+    refs: Vec<Ref>,\n+    macro_refs: Vec<MacroRef>,\n+}\n+\n+impl Analysis {\n+    fn new() -> Analysis {\n+        Analysis {\n+            prelude: None,\n+            imports: vec![],\n+            defs: vec![],\n+            refs: vec![],\n+            macro_refs: vec![],\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+struct Import {\n+    kind: ImportKind,\n+    id: DefId,\n+    span: SpanData,\n+    name: String,\n+    value: String,\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+enum ImportKind {\n+    ExternCrate,\n+    Use,\n+    GlobUse,\n+}\n+\n+impl From<ExternCrateData> for Import {\n+    fn from(data: ExternCrateData) -> Import {\n+        Import {\n+            kind: ImportKind::ExternCrate,\n+            id: data.id,\n+            span: data.span,\n+            name: data.name,\n+            value: String::new(),\n+        }\n+    }\n+}\n+impl From<UseData> for Import {\n+    fn from(data: UseData) -> Import {\n+        Import {\n+            kind: ImportKind::Use,\n+            id: data.id,\n+            span: data.span,\n+            name: data.name,\n+            value: String::new(),\n+        }\n+    }\n+}\n+impl From<UseGlobData> for Import {\n+    fn from(data: UseGlobData) -> Import {\n+        Import {\n+            kind: ImportKind::GlobUse,\n+            id: data.id,\n+            span: data.span,\n+            name: \"*\".to_owned(),\n+            value: data.names.join(\", \"),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+struct Def {\n+    kind: DefKind,\n+    id: DefId,\n+    span: SpanData,\n+    name: String,\n+    qualname: String,\n+    value: String,\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+enum DefKind {\n+    // value = type + generics\n+    Enum,\n+    // value = type + generics\n+    Tuple,\n+    // value = type + generics + types\n+    Struct,\n+    // value = type + generics\n+    Trait,\n+    // value = type + generics\n+    Function,\n+    // No id\n+    Macro,\n+    // value = file_name\n+    Mod,\n+    // value = aliased type\n+    Type,\n+    // value = type and init expression\n+    Variable,\n+}\n+// TODO value for function and method\n+// TODO none of the values are right.\n+\n+impl From<EnumData> for Def {\n+    fn from(data: EnumData) -> Def {\n+        Def {\n+            kind: DefKind::Enum,\n+            id: data.id,\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+\n+impl From<TupleVariantData> for Def {\n+    fn from(data: TupleVariantData) -> Def {\n+        Def {\n+            kind: DefKind::Tuple,\n+            id: data.id,\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+impl From<StructVariantData> for Def {\n+    fn from(data: StructVariantData) -> Def {\n+        Def {\n+            kind: DefKind::Struct,\n+            id: data.id,\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+impl From<StructData> for Def {\n+    fn from(data: StructData) -> Def {\n+        Def {\n+            kind: DefKind::Struct,\n+            id: data.id,\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+impl From<TraitData> for Def {\n+    fn from(data: TraitData) -> Def {\n+        Def {\n+            kind: DefKind::Trait,\n+            id: data.id,\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+impl From<FunctionData> for Def {\n+    fn from(data: FunctionData) -> Def {\n+        Def {\n+            kind: DefKind::Function,\n+            id: data.id,\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+impl From<MethodData> for Def {\n+    fn from(data: MethodData) -> Def {\n+        Def {\n+            kind: DefKind::Function,\n+            id: data.id,\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+impl From<MacroData> for Def {\n+    fn from(data: MacroData) -> Def {\n+        Def {\n+            kind: DefKind::Macro,\n+            id: null_def_id(),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: String::new(),\n+        }\n+    }\n+}\n+impl From<ModData> for Def {\n+    fn from(data:ModData) -> Def {\n+        Def {\n+            kind: DefKind::Mod,\n+            id: data.id,\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.filename,\n+        }\n+    }\n+}\n+impl From<TypeDefData> for Def {\n+    fn from(data: TypeDefData) -> Def {\n+        Def {\n+            kind: DefKind::Type,\n+            id: data.id,\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+impl From<VariableData> for Def {\n+    fn from(data: VariableData) -> Def {\n+        Def {\n+            kind: DefKind::Variable,\n+            id: data.id,\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+enum RefKind {\n+    Function,\n+    Mod,\n+    Type,\n+    Variable,\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+struct Ref {\n+    kind: RefKind,\n+    span: SpanData,\n+    ref_id: DefId,\n+}\n+\n+impl From<FunctionRefData> for Ref {\n+    fn from(data: FunctionRefData) -> Ref {\n+        Ref {\n+            kind: RefKind::Function,\n+            span: data.span,\n+            ref_id: data.ref_id,\n+        }\n+    }\n+}\n+impl From<FunctionCallData> for Ref {\n+    fn from(data: FunctionCallData) -> Ref {\n+        Ref {\n+            kind: RefKind::Function,\n+            span: data.span,\n+            ref_id: data.ref_id,\n+        }\n+    }\n+}\n+impl From<MethodCallData> for Ref {\n+    fn from(data: MethodCallData) -> Ref {\n+        Ref {\n+            kind: RefKind::Function,\n+            span: data.span,\n+            ref_id: data.ref_id.or(data.decl_id).unwrap_or(null_def_id()),\n+        }\n+    }\n+}\n+impl From<ModRefData> for Ref {\n+    fn from(data: ModRefData) -> Ref {\n+        Ref {\n+            kind: RefKind::Mod,\n+            span: data.span,\n+            ref_id: data.ref_id.unwrap_or(null_def_id()),\n+        }\n+    }\n+}\n+impl From<TypeRefData> for Ref {\n+    fn from(data: TypeRefData) -> Ref {\n+        Ref {\n+            kind: RefKind::Type,\n+            span: data.span,\n+            ref_id: data.ref_id.unwrap_or(null_def_id()),\n+        }\n+    }\n+}\n+impl From<VariableRefData> for Ref {\n+    fn from(data: VariableRefData) -> Ref {\n+        Ref {\n+            kind: RefKind::Variable,\n+            span: data.span,\n+            ref_id: data.ref_id,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+struct MacroRef {\n+    span: SpanData,\n+    qualname: String,\n+    callee_span: SpanData,\n+}\n+\n+impl From<MacroUseData> for MacroRef {\n+    fn from(data: MacroUseData) -> MacroRef {\n+        MacroRef {\n+            span: data.span,\n+            qualname: data.qualname,\n+            callee_span: data.callee_span,\n+        }\n+    }\n }"}, {"sha": "0a5ac3af7140a1472114ba8ab5499ce192c92195", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0a987722e8a38494d818443819ad0853771b37e/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0a987722e8a38494d818443819ad0853771b37e/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=a0a987722e8a38494d818443819ad0853771b37e", "patch": "@@ -134,6 +134,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     declaration: None,\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(item.id),\n+                    value: String::new(), // TODO\n                 }))\n             }\n             ast::ItemKind::Static(ref typ, mt, ref expr) => {\n@@ -197,6 +198,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 filter!(self.span_utils, sub_span, item.span, None);\n                 Some(Data::EnumData(EnumData {\n                     id: item.id,\n+                    name: item.ident.to_string(),\n                     value: val,\n                     span: sub_span.unwrap(),\n                     qualname: enum_name,\n@@ -353,6 +355,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             declaration: decl_id,\n             span: sub_span.unwrap(),\n             scope: self.enclosing_scope(id),\n+            value: String::new(), // TODO\n         })\n     }\n "}]}