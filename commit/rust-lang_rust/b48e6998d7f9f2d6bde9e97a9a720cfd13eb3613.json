{"sha": "b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0OGU2OTk4ZDdmOWYyZDZiZGU5ZTk3YTlhNzIwY2ZkMTNlYjM2MTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-26T01:01:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-26T01:01:04Z"}, "message": "auto merge of #5509 : thestinger/rust/oldmap, r=brson\n\nThe reasoning for doing it this way is that it's much easier to transition method-by-method to the `Map` API than trying to do the migration all at once.\r\n\r\nI found an issue unrelated to my changes in one of the run-fail tests - if it uses `LinearMap`, it still fails but exits with 0. I xfailed it for now and opened [an issue](https://github.com/mozilla/rust/issues/5512), because it's not caused by these changes.", "tree": {"sha": "79e9675138989ee4d0f5b9f71a23355d20c10d61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79e9675138989ee4d0f5b9f71a23355d20c10d61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613", "html_url": "https://github.com/rust-lang/rust/commit/b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d469212d9df2ba7084c7db3de89ff50624f6fb67", "url": "https://api.github.com/repos/rust-lang/rust/commits/d469212d9df2ba7084c7db3de89ff50624f6fb67", "html_url": "https://github.com/rust-lang/rust/commit/d469212d9df2ba7084c7db3de89ff50624f6fb67"}, {"sha": "a919e5ede5465cfab27cdc7cae59f2c015735753", "url": "https://api.github.com/repos/rust-lang/rust/commits/a919e5ede5465cfab27cdc7cae59f2c015735753", "html_url": "https://github.com/rust-lang/rust/commit/a919e5ede5465cfab27cdc7cae59f2c015735753"}], "stats": {"total": 389, "additions": 42, "deletions": 347}, "files": [{"sha": "581ad5336de0ffd67de1ec25d1008fbd0a7441c3", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613", "patch": "@@ -141,24 +141,28 @@ pub fn find_extern_mod_stmt_cnum(cstore: @mut CStore,\n     extern_mod_crate_map.find(&emod_id)\n }\n \n-// returns hashes of crates directly used by this crate. Hashes are\n-// sorted by crate name.\n+// returns hashes of crates directly used by this crate. Hashes are sorted by\n+// (crate name, crate version, crate hash) in lexicographic order (not semver)\n pub fn get_dep_hashes(cstore: @mut CStore) -> ~[~str] {\n-    struct crate_hash { name: @~str, hash: @~str }\n+    struct crate_hash { name: @~str, vers: @~str, hash: @~str }\n     let mut result = ~[];\n \n     let extern_mod_crate_map = cstore.extern_mod_crate_map;\n     for extern_mod_crate_map.each_value |&cnum| {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n-        debug!(\"Add hash[%s]: %s\", *cdata.name, *hash);\n+        let vers = decoder::get_crate_vers(cdata.data);\n+        debug!(\"Add hash[%s]: %s %s\", *cdata.name, *vers, *hash);\n         result.push(crate_hash {\n             name: cdata.name,\n+            vers: vers,\n             hash: hash\n         });\n     }\n \n-    let sorted = std::sort::merge_sort(result, |a, b| a.name <= b.name);\n+    let sorted = do std::sort::merge_sort(result) |a, b| {\n+        (a.name, a.vers, a.hash) <= (b.name, b.vers, b.hash)\n+    };\n \n     debug!(\"sorted:\");\n     for sorted.each |x| {"}, {"sha": "00883b28b0493d377395374fe6d06cf09e66ab00", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613", "patch": "@@ -4741,8 +4741,8 @@ pub impl Resolver {\n         let mut j = this.value_ribs.len();\n         while j != 0 {\n             j -= 1;\n-            for this.value_ribs[j].bindings.each_entry |e| {\n-                vec::push(&mut maybes, copy *this.session.str_of(e.key));\n+            for this.value_ribs[j].bindings.each_key |&k| {\n+                vec::push(&mut maybes, copy *this.session.str_of(k));\n                 vec::push(&mut values, uint::max_value);\n             }\n         }"}, {"sha": "b40237cf5848f1ba6fec33ce1123c95a73deb633", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 28, "deletions": 335, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613", "patch": "@@ -8,13 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A map type - **deprecated**, use `core::hashmap` instead\n+//! A deprecated compatibility layer on top of `core::hashmap`\n \n-use core::container::{Container, Mutable, Map};\n-use core::cmp::Eq;\n+use core::prelude::*;\n use core::hash::Hash;\n-use core::io::WriterUtil;\n-use core::to_str::ToStr;\n use core::prelude::*;\n use core::to_bytes::IterBytes;\n use core::vec;\n@@ -24,335 +21,68 @@ pub type Set<K> = HashMap<K, ()>;\n \n pub type HashMap<K, V> = chained::T<K, V>;\n \n-pub mod util {\n-    pub struct Rational {\n-        // : int::positive(*.den);\n-        num: int,\n-        den: int,\n-    }\n-\n-    pub fn rational_leq(x: Rational, y: Rational) -> bool {\n-        // NB: Uses the fact that rationals have positive denominators WLOG:\n-\n-        x.num * y.den <= y.num * x.den\n-    }\n-}\n-\n-\n-// FIXME (#2344): package this up and export it as a datatype usable for\n-// external code that doesn't want to pay the cost of a box.\n pub mod chained {\n-    use super::util;\n-\n-    use core::io;\n     use core::ops;\n-    use core::option;\n     use core::prelude::*;\n-    use core::uint;\n-    use core::vec;\n-\n-    static initial_capacity: uint = 32u; // 2^5\n-\n-    struct Entry<K, V> {\n-        hash: uint,\n-        key: K,\n-        value: V,\n-        mut next: Option<@Entry<K, V>>\n-    }\n+    use core::hashmap::linear::LinearMap;\n \n     struct HashMap_<K, V> {\n-        mut count: uint,\n-        mut chains: ~[Option<@Entry<K,V>>]\n-    }\n-\n-    pub type T<K, V> = @HashMap_<K, V>;\n-\n-    enum SearchResult<K, V> {\n-        NotFound,\n-        FoundFirst(uint, @Entry<K,V>),\n-        FoundAfter(@Entry<K,V>, @Entry<K,V>)\n+        priv map: LinearMap<K, V>\n     }\n \n-    priv impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n-        fn search_rem(&self, k: &K, h: uint, idx: uint,\n-                           e_root: @Entry<K,V>) -> SearchResult<K,V> {\n-            let mut e0 = e_root;\n-            let mut comp = 1u;   // for logging\n-            loop {\n-                match copy e0.next {\n-                  None => {\n-                    debug!(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n-                           comp, h, idx);\n-                    return NotFound;\n-                  }\n-                  Some(e1) => {\n-                    comp += 1u;\n-                    if e1.hash == h && e1.key == *k {\n-                        debug!(\n-                            \"search_tbl: present, comp %u, hash %u, idx %u\",\n-                            comp, h, idx);\n-                        return FoundAfter(e0, e1);\n-                    } else {\n-                        e0 = e1;\n-                    }\n-                  }\n-                }\n-            };\n-        }\n-\n-        fn search_tbl(&self, k: &K, h: uint) -> SearchResult<K,V> {\n-            let idx = h % vec::uniq_len(&const self.chains);\n-            match copy self.chains[idx] {\n-              None => {\n-                debug!(\"search_tbl: none, comp %u, hash %u, idx %u\",\n-                       0u, h, idx);\n-                return NotFound;\n-              }\n-              Some(e) => {\n-                if e.hash == h && e.key == *k {\n-                    debug!(\"search_tbl: present, comp %u, hash %u, \\\n-                           idx %u\", 1u, h, idx);\n-                    return FoundFirst(idx, e);\n-                } else {\n-                    return self.search_rem(k, h, idx, e);\n-                }\n-              }\n-            }\n-        }\n-\n-        fn rehash(@self) {\n-            let n_old_chains = vec::uniq_len(&const self.chains);\n-            let n_new_chains: uint = uint::next_power_of_two(n_old_chains+1u);\n-            let mut new_chains = chains(n_new_chains);\n-            for self.each_entry |entry| {\n-                let idx = entry.hash % n_new_chains;\n-                entry.next = new_chains[idx];\n-                new_chains[idx] = Some(entry);\n-            }\n-            self.chains = new_chains;\n-        }\n-    }\n+    pub type T<K, V> = @mut HashMap_<K, V>;\n \n     pub impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n-        fn each_entry(&self, blk: &fn(@Entry<K,V>) -> bool) {\n-            // n.b. we can't use vec::iter() here because self.chains\n-            // is stored in a mutable location.\n-            let mut i = 0u, n = vec::uniq_len(&const self.chains);\n-            while i < n {\n-                let mut chain = self.chains[i];\n-                loop {\n-                    chain = match chain {\n-                      None => break,\n-                      Some(entry) => {\n-                        let next = entry.next;\n-                        if !blk(entry) { return; }\n-                        next\n-                      }\n-                    }\n-                }\n-                i += 1u;\n-            }\n-        }\n-\n-        fn clear(@self) {\n-            self.count = 0u;\n-            self.chains = chains(initial_capacity);\n+        fn clear(&mut self) {\n+            self.map.clear()\n         }\n     }\n \n     impl<K:Eq + IterBytes + Hash,V> Container for HashMap_<K, V> {\n-        fn len(&const self) -> uint { self.count }\n-        fn is_empty(&const self) -> bool { self.count == 0 }\n+        fn len(&const self) -> uint { self.map.len() }\n+        fn is_empty(&const self) -> bool { self.map.is_empty() }\n     }\n \n     pub impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n-        fn contains_key(@self, k: &K) -> bool {\n-            let hash = k.hash_keyed(0,0) as uint;\n-            match self.search_tbl(k, hash) {\n-              NotFound => false,\n-              FoundFirst(*) | FoundAfter(*) => true\n-            }\n+        fn contains_key(&self, k: &K) -> bool {\n+            self.map.contains_key(k)\n         }\n \n-        fn insert(@self, k: K, v: V) -> bool {\n-            let hash = k.hash_keyed(0,0) as uint;\n-            match self.search_tbl(&k, hash) {\n-              NotFound => {\n-                self.count += 1u;\n-                let idx = hash % vec::uniq_len(&const self.chains);\n-                let old_chain = self.chains[idx];\n-                self.chains[idx] = Some(@Entry {\n-                    hash: hash,\n-                    key: k,\n-                    value: v,\n-                    next: old_chain});\n-\n-                // consider rehashing if more 3/4 full\n-                let nchains = vec::uniq_len(&const self.chains);\n-                let load = util::Rational {\n-                    num: (self.count + 1u) as int,\n-                    den: nchains as int,\n-                };\n-                if !util::rational_leq(load, util::Rational {num:3, den:4}) {\n-                    self.rehash();\n-                }\n-\n-                return true;\n-              }\n-              FoundFirst(idx, entry) => {\n-                self.chains[idx] = Some(@Entry {\n-                    hash: hash,\n-                    key: k,\n-                    value: v,\n-                    next: entry.next});\n-                return false;\n-              }\n-              FoundAfter(prev, entry) => {\n-                prev.next = Some(@Entry {\n-                    hash: hash,\n-                    key: k,\n-                    value: v,\n-                    next: entry.next});\n-                return false;\n-              }\n-            }\n+        fn insert(&mut self, k: K, v: V) -> bool {\n+            self.map.insert(k, v)\n         }\n \n-        fn remove(@self, k: &K) -> bool {\n-            match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n-              NotFound => false,\n-              FoundFirst(idx, entry) => {\n-                self.count -= 1u;\n-                self.chains[idx] = entry.next;\n-                true\n-              }\n-              FoundAfter(eprev, entry) => {\n-                self.count -= 1u;\n-                eprev.next = entry.next;\n-                true\n-              }\n-            }\n+        fn remove(&mut self, k: &K) -> bool {\n+            self.map.remove(k)\n         }\n \n-        fn each(@self, blk: &fn(key: &K, value: &V) -> bool) {\n-            for self.each_entry |entry| {\n-                if !blk(&entry.key, &entry.value) { break; }\n-            }\n+        fn each(&self, blk: &fn(key: &K, value: &V) -> bool) {\n+            do self.map.each |&(k, v)| { blk(k, v) }\n         }\n \n-        fn each_key(@self, blk: &fn(key: &K) -> bool) {\n-            self.each(|k, _v| blk(k))\n+        fn each_key(&self, blk: &fn(key: &K) -> bool) {\n+            self.map.each_key(blk)\n         }\n \n-        fn each_value(@self, blk: &fn(value: &V) -> bool) {\n-            self.each(|_k, v| blk(v))\n+        fn each_value(&self, blk: &fn(value: &V) -> bool) {\n+            self.map.each_value(blk)\n         }\n     }\n \n     pub impl<K:Eq + IterBytes + Hash + Copy,V:Copy> HashMap_<K, V> {\n         fn find(&self, k: &K) -> Option<V> {\n-            match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n-              NotFound => None,\n-              FoundFirst(_, entry) => Some(entry.value),\n-              FoundAfter(_, entry) => Some(entry.value)\n-            }\n+            self.map.find(k).map(|&x| copy *x)\n         }\n \n-        fn update_with_key(@self, key: K, newval: V, ff: &fn(K, V, V) -> V)\n-                        -> bool {\n-/*\n-            match self.find(key) {\n-                None            => return self.insert(key, val),\n-                Some(copy orig) => return self.insert(key, ff(key, orig, val))\n-            }\n-*/\n-\n-            let hash = key.hash_keyed(0,0) as uint;\n-            match self.search_tbl(&key, hash) {\n-              NotFound => {\n-                self.count += 1u;\n-                let idx = hash % vec::uniq_len(&const self.chains);\n-                let old_chain = self.chains[idx];\n-                self.chains[idx] = Some(@Entry {\n-                    hash: hash,\n-                    key: key,\n-                    value: newval,\n-                    next: old_chain});\n-\n-                // consider rehashing if more 3/4 full\n-                let nchains = vec::uniq_len(&const self.chains);\n-                let load = util::Rational {\n-                    num: (self.count + 1u) as int,\n-                    den: nchains as int,\n-                };\n-                if !util::rational_leq(load, util::Rational {num:3, den:4}) {\n-                    self.rehash();\n-                }\n-\n-                return true;\n-              }\n-              FoundFirst(idx, entry) => {\n-                self.chains[idx] = Some(@Entry {\n-                    hash: hash,\n-                    key: key,\n-                    value: ff(key, entry.value, newval),\n-                    next: entry.next});\n-                return false;\n-              }\n-              FoundAfter(prev, entry) => {\n-                prev.next = Some(@Entry {\n-                    hash: hash,\n-                    key: key,\n-                    value: ff(key, entry.value, newval),\n-                    next: entry.next});\n-                return false;\n-              }\n+        fn update(&mut self, key: K, newval: V, ff: &fn(V, V) -> V) -> bool {\n+            match self.find(&key) {\n+                None => self.insert(key, newval),\n+                Some(orig) => self.insert(key, ff(orig, newval))\n             }\n         }\n \n-        fn update(@self, key: K, newval: V, ff: &fn(V, V) -> V) -> bool {\n-            return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n-        }\n-\n         fn get(&self, k: &K) -> V {\n-            let opt_v = self.find(k);\n-            if opt_v.is_none() {\n-                fail!(fmt!(\"Key not found in table: %?\", k));\n-            }\n-            option::unwrap(opt_v)\n-        }\n-    }\n-\n-    pub impl<K:Eq + IterBytes + Hash + Copy + ToStr,V:ToStr + Copy>\n-            HashMap_<K, V> {\n-        fn to_writer(&self, wr: @io::Writer) {\n-            if self.count == 0u {\n-                wr.write_str(~\"{}\");\n-                return;\n-            }\n-\n-            wr.write_str(~\"{ \");\n-            let mut first = true;\n-            for self.each_entry |entry| {\n-                if !first {\n-                    wr.write_str(~\", \");\n-                }\n-                first = false;\n-                wr.write_str(entry.key.to_str());\n-                wr.write_str(~\": \");\n-                wr.write_str((copy entry.value).to_str());\n-            };\n-            wr.write_str(~\" }\");\n-        }\n-    }\n-\n-    impl<K:Eq + IterBytes + Hash + Copy + ToStr,V:ToStr + Copy> ToStr\n-            for HashMap_<K, V> {\n-        fn to_str(&self) -> ~str {\n-            unsafe {\n-                // Meh -- this should be safe\n-                do io::with_str_writer |wr| { self.to_writer(wr) }\n-            }\n+            copy *self.map.get(k)\n         }\n     }\n \n@@ -363,14 +93,8 @@ pub mod chained {\n         }\n     }\n \n-    fn chains<K,V>(nchains: uint) -> ~[Option<@Entry<K,V>>] {\n-        vec::from_elem(nchains, None)\n-    }\n-\n     pub fn mk<K:Eq + IterBytes + Hash,V:Copy>() -> T<K,V> {\n-        let slf: T<K, V> = @HashMap_ {count: 0u,\n-                                      chains: chains(initial_capacity)};\n-        slf\n+        @mut HashMap_{map: LinearMap::new()}\n     }\n }\n \n@@ -661,35 +385,4 @@ mod tests {\n         fail_unless!(map.get(&~\"b\") == 2);\n         fail_unless!(map.get(&~\"c\") == 3);\n     }\n-\n-    #[test]\n-    fn test_update_with_key() {\n-        let map = HashMap::<~str, uint>();\n-\n-        // given a new key, initialize it with this new count, given\n-        // given an existing key, add more to its count\n-        fn addMoreToCount(_k: ~str, v0: uint, v1: uint) -> uint {\n-            v0 + v1\n-        }\n-\n-        fn addMoreToCount_simple(v0: uint, v1: uint) -> uint {\n-            v0 + v1\n-        }\n-\n-        // count the number of several types of animal,\n-        // adding in groups as we go\n-        map.update(~\"cat\",      1, addMoreToCount_simple);\n-        map.update_with_key(~\"mongoose\", 1, addMoreToCount);\n-        map.update(~\"cat\",      7, addMoreToCount_simple);\n-        map.update_with_key(~\"ferret\",   3, addMoreToCount);\n-        map.update_with_key(~\"cat\",      2, addMoreToCount);\n-\n-        // check the total counts\n-        fail_unless!(map.find(&~\"cat\").get() == 10);\n-        fail_unless!(map.find(&~\"ferret\").get() == 3);\n-        fail_unless!(map.find(&~\"mongoose\").get() == 1);\n-\n-        // sadly, no mythical animals were counted!\n-        fail_unless!(map.find(&~\"unicorn\").is_none());\n-    }\n }"}, {"sha": "06a3f0113b01cab4c1aab5b3c5fbccb6534addf3", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=b48e6998d7f9f2d6bde9e97a9a720cfd13eb3613", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:fail\n+// xfail-test - issue #5512, fails but exits with 0\n \n-extern mod std;\n-use std::oldmap;\n-use std::oldmap::HashMap;\n+// error-pattern:fail\n \n fn main() {\n     let count = @mut 0u;\n-    let map = oldmap::HashMap();\n+    let mut map = core::hashmap::linear::LinearMap::new();\n     let mut arr = ~[];\n     for uint::range(0u, 10u) |i| {\n         arr += ~[@~\"key stuff\"];"}]}